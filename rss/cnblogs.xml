<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>成长在软通 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10575560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10575560.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：“每个不曾起舞的日子，都是对生命的一种辜负”---今天收拾东西发现了一些上家公司的东西，发现其实软通动力挺好的，外包到华为上班也挺好的，只可惜华为信息安全管的比较严，好多美好的东西走了之后都没能带出来，这里就贴出一篇2018在软通写的成长文摘，不知道多年后再看到会有什么感觉。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;成长在软通&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201903/1580332-20190321231736371-1213846930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                                                                                         &lt;strong&gt;&lt;span&gt;成长在软通&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      在这分享我在软通成长的心德，不是说我这些成长的心德是多么的正确，你应该引用过去，从此成为你生活当中的一个指导，我从来没有那么自大；也不是说，我觉得自己是多么的重要，以至于重要到我要把我的事情让全世界都知道。我此刻其实只是在告诉你，我的生活当中曾经有那么一些话，一些事，感动过我，点亮过我，改变过我，现在还在影响着我。&lt;br/&gt;      大家都体验过刚入职软通的那段美好时光，出于各种原因，反正就是没活干，而我那段日子的表现亦无疑是虚度光阴。而就在那时，尼采深深地撼动了我的心灵，为什么这么说呢？这也是我要向大家分享的，来自尼采的一句哲理：“每个不曾起舞的日子，都是对生命的一种辜负”。不知道大家有什么想法，我当时读到这句话的时候，就有一种后背发凉的感觉，有一种下跪的膜拜。“每个不曾起舞的日子，都是对生命的一种辜负”，我们为什么要在每一个日子起舞呢？怕不是疯了吧，在人潮中起舞吗？其实不是这个样子的，生命之所以起舞，是因为你觉得你的这一场人生实在是值得庆祝。然后，尼采这句话其实是在告诉我们，既然我们不得不来到这个世界上走这一遭，活这一生，那么就请把你的人生过成一个值得庆祝的人生。如果你的这一场人生没有让你觉得他是值得庆祝的，那么其实某种程度上，你虚度了这来之不易的一生。&lt;br/&gt;      然后说到成长，人的一生每时每刻都在成长，对“人生”这一个大词汇的理解也是仁者见仁，那么什么叫做“人生”呢？我不知道大家是否考虑过什么叫做“人生”，什么叫做我的一生？简而言之就是，我的过去，我的现在，我的未来。而仔细一想，“未来”是今天的延续，所谓“过去”就是已完成了的现在。所以我们大多数人在这个时间概念上一直上这一个当，因为其实根本就没有过去，“过去”就是已完成的现在；其实也没有一个未来，“未来”就是现在的延续。所以，无论是过去还是未来，都是你的“现在”决定的，现在，当下，才是人生最重要的，所以当你活在了当下，其实你就活出了你的人生。“每一个不曾起舞的日子，都是对生命的一种辜负”，这句话当时对我印象很深，从那一刻开始，我就决定把我在软通的每一天，把我人生中的每一天，把我的生命，活成一个礼物，一个值得庆祝的东西。&lt;br/&gt;      也正是如此，我在成长的道路上是非常看重当下的，其实我很少考虑未来的那些事情，这是真的，也许像我这样的人并不多。我并不太考虑未来的那些伟大的目标，远大的志向，我也不大为自己去设计这些伟大的目标，未来的事谁知道，天晓得。所以，我很多时候更关注我能够把我住的每一个当下，这是我唯一能够把握住的。有一句话叫做“明天跟死亡，不知道哪个来得更早”，所以我能够把握住的就是现在，此时此刻。所以，请不要等到明天才开始幸福。在平时的工作生活中，有的时候我会找人聊天，当我跟你说话的时候，那个时候我的心里只有你，我的眼里也只有你；有的时候我会去嗮太阳，我那天就充分地去享受那个阳光，那个时候我的心里只有那个阳光，我的眼里只有那片蓝天白云；有的时候我会去百草园打篮球，那个时候我就会尽情的享受篮球带给我的快感；有的时候我会一个人发呆，然后那个时候我就会彻彻底底的在发呆，这种感觉这的很好，这就是我成长中的一种生活的方式和生活态度，让我感觉很好，所以就跟大家分享一下。&lt;br/&gt;       也正是这样的成长，让我变成了一个很讨厌目标导向的人，因此我不会对自己说到了几岁我要怎样怎样，到了几年之后我要达到什么目标，到了几年之后我要买车买房，到了几年之后我要结婚生子，然后到了几年之后我要到达多高的成就；很多时候这些问题并没有真正困扰到我，也许身边一些人在看我的时候都会这么想：“你小子，到现在还没车没房，没有女朋友，你瞎乐个什么呀！”其实很多人都是这么想的。但是他们的这些想法也没有真正困扰到我，因为我不在乎这个东西，不是那么的在乎这个东西，所以对于我的成长，我的人生，从总体上来说是比较随意的，尽力而为的，顺其自然的。因为成长让我明白了“有志者，事未必竟成”，这才是真相，但事未必竟成，还是要认真地去做，我觉得这才是一个勇敢的人生，一个有腔调的人生，一个不辜负生命的成长。&lt;br/&gt;      我自风情万种，与世无争。我，成长在软通。&lt;/p&gt;

</description>
<pubDate>Thu, 21 Mar 2019 15:26:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：“每个不曾起舞的日子，都是对生命的一种辜负” 今天收拾东西发现了一些上家公司的东西，发现其实软通动力挺好的，外包到华为上班也挺好的，只可惜华为信息安全管的比较严，好多美好的东西走了之后都没能带出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10575560.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 文件系统 - 啊，那一个人</title>
<link>http://www.cnblogs.com/anayigeren/p/10282441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anayigeren/p/10282441.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;静态文件&lt;/span&gt; &lt;span class=&quot;tag blue label&quot;&gt;目录浏览&lt;/span&gt; &lt;span class=&quot;tag blue label&quot;&gt;默认页面&lt;/span&gt; &lt;span class=&quot;tag blue label&quot;&gt;MIME类型配置&lt;/span&gt; &lt;span class=&quot;tag blue label&quot;&gt;实战文件服务器&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;紧接上一讲 &lt;a href=&quot;http://www.cnblogs.com/anayigeren/p/10282441.html#&quot;&gt;中间件&lt;/a&gt; 之后，今天来我们来讲一下关于 ASP.NET  Core 中静态文件服务。&lt;/p&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;什么是静态文件？&lt;/h3&gt;
&lt;p&gt;先看一下下面例子（在客户端浏览器中通过 url 路径访问了网站的一张图片）：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152210114-1920086030.png&quot; alt=&quot;&quot; name=&quot;images/1547649385085.png&quot; data-src=&quot;./images/1547649385085.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样的图片就是一个静态文件&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152211271-2738835.png&quot; alt=&quot;&quot; name=&quot;images/1547651710463.png&quot; data-src=&quot;./images/1547651710463.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul readability=&quot;3.3806541405706&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;静态文件（staticfiles)，其实就是指像 &lt;span class=&quot;mark&quot;&gt;HTML&lt;/span&gt;、&lt;span class=&quot;mark&quot;&gt;CSS&lt;/span&gt;、&lt;span class=&quot;mark&quot;&gt;图片&lt;/span&gt; 和 &lt;span class=&quot;mark&quot;&gt;JavaScript&lt;/span&gt; 之类固定的文件，是会被应用程序直接提供给客户端的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;静态文件通常位于web root（内容根目录或Web根目录）文件夹下。有关 &lt;span class=&quot;mark&quot;&gt;内容根目录&lt;/span&gt; 和 &lt;span class=&quot;mark&quot;&gt;Web根目录&lt;/span&gt; 的信息在&lt;a href=&quot;http://www.cnblogs.com/anayigeren/p/10282441.html#&quot;&gt;第一讲&lt;/a&gt;中介绍过。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容根目录（&lt;span class=&quot;mark&quot;&gt;Contentroot&lt;/span&gt;）：是应用程序所用到的所有内容的根路径。WebHost.CreateDefaultBuilder() 中默认下把项目的当前目录设置为内容根目录，也就是指 web 的项目的文件夹，包括 bin 和 webroot 文件夹。&lt;/li&gt;
&lt;li&gt;Web根目录（&lt;span class=&quot;mark&quot;&gt;webroot&lt;/span&gt;）：项目中用于存放类似于 CSS、JS、图片等公开、静态资源的目录。
&lt;ul&gt;&lt;li&gt; Web根目录默认为的是 &lt;span class=&quot;mark&quot;&gt;Contentroot&lt;/span&gt; 路径下的 &lt;span class=&quot;mark&quot;&gt;wwwroot&lt;/span&gt; 文件夹。&lt;/li&gt;
&lt;li&gt; 静态文件中间件将默认只读取 Web根目录和其子目录中的文件。&lt;/li&gt;
&lt;li&gt; 对于 Razor (.cshtml) 文件，波浪号斜杠 &lt;span class=&quot;mark&quot;&gt;~/&lt;/span&gt; 指向 webroot。 以 &lt;span class=&quot;mark&quot;&gt;~/&lt;/span&gt; 开头的路径称为虚拟路径。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152212382-1439668903.png&quot; alt=&quot;&quot; name=&quot;images/1547652808874.png&quot; data-src=&quot;./images/1547652808874.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;3.6467991169978&quot;&gt;
&lt;p&gt;静态文件可以保存在 Web根目录（默认为wwwroot） 下的任意文件夹内，并通过相对根的路径来访问。例如当你通过 VisualStudio 创建一个默认的 Web应用程序（MVC）项目时，在 &lt;span class=&quot;mark&quot;&gt;wwwroot&lt;/span&gt; 目录下会多出几个文件夹：css、images以及js。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152212732-1204852950.png&quot; alt=&quot;&quot; name=&quot;images/1547653006041.png&quot; data-src=&quot;./images/1547653006041.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;通过下面的URL就能够直接访问 images 目录下的图片：&lt;br/&gt;http://&amp;lt;app&amp;gt;/images/&amp;lt;imageFileName&amp;gt;&lt;br/&gt;&lt;a href=&quot;http://localhost:7819/images/banner1.svg&quot; target=&quot;_blank&quot;&gt;http://localhost:7819/images/banner1.svg&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152213121-244601430.png&quot; alt=&quot;&quot; name=&quot;images/1547653330760.png&quot; data-src=&quot;./images/1547653330760.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;静态文件中间件&lt;/h3&gt;
&lt;p&gt;如上例子，为了能够使用静态文件的服务，必须配置中间件，把静态文件中间件加入到请求管道内。（默认创建的 MVC Web应用程序已经配置了）&lt;br/&gt;静态文件中间件可通过下述方法来配置：在项目中增加 &lt;span class=&quot;mark&quot;&gt;MicrosoftAspNetCore.StaticFiles&lt;/span&gt; 包依赖，然后从&lt;span class=&quot;mark&quot;&gt;Startup.Configure&lt;/span&gt; 中调用 &lt;span class=&quot;mark&quot;&gt;app.UseStaticFiles&lt;/span&gt; 扩展方法：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env)&lt;/span&gt;
&lt;/span&gt;{
    app.UseStaticFiles();
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;mark&quot;&gt;&lt;span&gt;上面我们通过一个简单的实例使用 &lt;/span&gt;app.UseStaticFiles()&lt;/span&gt; 来使用文件中间件，使得Web根目录下的所有静态文件直接发布出来。如果我们需要发布的静态文件存储在其他目录下呢？依旧是这个应用，现在我们将静态文件放在&lt;span&gt;自定义文件夹 MyStaticFiles 内，并将以Web的形式发布出来，&lt;/span&gt;&lt;span&gt;展示如何通过使用&lt;/span&gt; &lt;span class=&quot;mark&quot;&gt;UseStaticFiles&lt;/span&gt; &lt;span&gt;将其他非wwwroot目录下的内容也向外提供服务。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;xsj_remote_html story_remote_resource_block&quot; readability=&quot;32.372549019608&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div id=&quot;xsj_drawio_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152213570-1356152050.png&quot; alt=&quot;&quot; name=&quot;b8fcdd3faff34c6fe3627a507189885f.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;mxfile userAgent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36&quot; version=&quot;8.5.3&quot; editor=&quot;www.draw.io&quot; type=&quot;device&quot;&amp;gt;&amp;lt;diagram&amp;gt;7Vtdk5owFP01PnaHEEB9rPbroZ3pdDvT5ygR00ZCQyxuf31vIBHZ6K6tQN1ddpydcMNHcs89h9wbHeH5Zvdekmz9ScSUj3wv3o3wm5HvY8+D/9pwVxkCNK4MiWRxZfJqwy37TSsjstYti2neOFEJwRXLjBFVxqVIU7pUjROJlKJoXrsSPG5cl5GEOobbJeGu9RuL1bqyTvxxbf9AWbI2T0YomlY9C7L8kUixTc3zRj5elX9V94bYe5mR5WsSi+LAhN+O8FwKoarWZjenXLu26bZ3J3r345Y0Vedc4FcX/CJ8S+2Iy3GpO+sLGGKmm3BTxQj/Av4maaJ7Z0pk0OFBi9OVMk1p/KLbC6GU2JgDwlmSQrs6d/aLwv3A5a+NubzZbMU4nwsuJFhSkeqn5BlZsjT5WD0i8mrTF/OoAEwC7rfipS/XLI5pqociFFFkUc5EX5YJlqoyNMIZfMA1c+8mHIUwzTkco/oYPvp0qeYizZUkrHQnJbkqaK5HH0uRfSUyoXaqK5EqE8gIYJy5SBhw9Lzp7sBkkHlPxYYqeQenmN7QBIkl0WRSHRd1SCIbSOuDcPQjwwTDgmR/5zoSoGGC4Xhg4IsCo3SGOROdCpRGcBzB/ax4aQZH0FZsPAa/nrOZ2+PA+yeA3+uXGUZDAxoBcYB4GHUDePA44JxVfFRS/NjrIvon8DYAAz8g99cyQF4hB1HsIoqPoMfJgvLPImeKCX1/I0J/iWoHHEZe1CRxhBwSW98fQjq5HNFw0PYno+0hwv1pezRoe2vaHp4A/qq0fTwowZNRAjzpUQkmgxK0pgTjE8BflRJMByV4MkoQeNP+lMBWXgYpaEEKpieQvyopQMhBvCiKsvTkR1zPeSGhlaj9FA9CAeal7Wu14cYrVVZ4D9EHQF6Ct6h8KDUs1kzRWwBXP7OQJCtB3KYxjQ2ELXAO4Xv5WRg6pAuOcc5rAQE354bwUzCZl4aCrWzZNVDk9QfCGWnyUPhoofBxZF3bUeEDuQnup7tb8BtbvmOc5s+XRyiYNp0+HvdHpDOSiYFIf4+p743vESnojUhuuqBgnjdZmjxfDvk4/G8c8s9YhQ8cuvxlhKd+Xxzy3WX2gqXPlz7Ihuy+ntXfgto+eqBPx2s5u8LqgT7uRrRYfH859Ak8d9O/M/q4qdBnKTLtj+e9aEZNl2N3i7Yzl1+2FzcUZHstyGL3VdZZQfbCTbuhINv4Bk50AvqrqsheuB03iEGvYnCkRtmdGFy2bzeIQUMMJiegvyoxwG7e6EA+5DIt5DLYXWB3lMvgY+mp2eRpABv93Ao7/Vd5Of/XcAIKsl3daXeFbtyNoodMMMhFvaH0craYEGqWxkOLRg+rfHzGt6kHLl/O5dDrrS6B3b1bBgG7uymZcs0sOvLac0B4IFe+twqaut9RaYlFcFj/DqbsO/itEX77Bw==&amp;lt;/diagram&amp;gt;&amp;lt;/mxfile&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;component_attachment&quot;&gt;&lt;a class=&quot;attachment table_attachment&quot; title=&quot;Diagram&quot; name=&quot;attachments/1547685507116.drawio.html&quot; href=&quot;cid:154770972611116&quot; target=&quot;_blank&quot; data-size=&quot;10228&quot;&gt;&lt;span class=&quot;filename&quot;&gt;1547685507116.drawio.html&lt;/span&gt; &lt;span class=&quot;filesize&quot;&gt;9.99KB&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果要访问 MyStaticFiles 文件夹下的 test.png 图片，可以这样配置静态文件中间件：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env)&lt;/span&gt;
&lt;/span&gt;{
    app.UseStaticFiles();
    app.UseStaticFiles(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StaticFileOptions() // 使用 StaticFileOptions 这个对象来初始化静态文件中间件
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)), 
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;), 
    });
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ASP.NET Core 一般情况下都是利用一个FileProvider 对象&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;来读取文件的，它在处理针对静态文件的请求是也不例外。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上边代码在静态文件中间件中，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;在调用静态文件中间件的方法 UseStaticFiles()，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;该方法可接受一个配置项对象 StaticFileOptions，其内部具有一个 FileProvider 和请求路径的映射关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果调用 UseStaticFiles方法没有指定任何的参数，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;那么这个映射关系的请求路径就是应用的基地址（PathBase），&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;而FileProvider自然就是指向WebRoot目录的PhysicalFileProvider。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过访问 http://&amp;lt;app&amp;gt;/StaticFiles/test.png，这样就能访问到 test.png 图片文件了。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152214708-1974595904.png&quot; alt=&quot;&quot; name=&quot;images/1547685477293.png&quot; data-src=&quot;./images/1547685477293.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h4&gt;静态文件授权 ：&lt;/h4&gt;
&lt;p&gt;静态文件中间件默认不提供授权检查。任何通过该模块提供访问的文件，包括位丁 wwwroot 下的文件都是公开的，那么如何给文件提供授权呢？&lt;/p&gt;
&lt;p&gt;将文件保存在 wwwroot 之外，并将目录设置为可被静态文件中间件访问到，同时通过一个 controller action 来访问，通过授权后返回HleResulU将文件保存在wwwroot之外，并将目录设置为可被静态文件中间件访问到，同时通过一个itrolleraction来访问，通过授权后返回 FileResult。&lt;/p&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;目录浏览&lt;/h3&gt;
&lt;p&gt;以上通过注册的 StaticFileMiddleware 只会处理针对某个具体静态文件的请求，如果我们向某个目录的URL发送HTTP请求，得到的将是一个状态为404的响应。那是因为基于安全考虑，默认情况下应用程序是禁用目录访问功能的。目录浏览就是允许网站用户看到指定目录下的目录和文件列表。我们可以通过注册一个名为DirectoryBrowserMiddleware 的中间件来显示请求目录的内容：&lt;/p&gt;
&lt;p&gt;Step1. 在&lt;span class=&quot;mark&quot;&gt;Startup.ConfigureServices&lt;/span&gt; 中调用 &lt;span class=&quot;mark&quot;&gt;AddDirectoryBrowser&lt;/span&gt; 扩展方法添加目录浏览服务：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;
&lt;/span&gt;{
    services.AddDirectoryBrowser();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Step2. 然后在 &lt;span class=&quot;mark&quot;&gt;Startup.Configure&lt;/span&gt; 中调用 &lt;span class=&quot;mark&quot;&gt;UseDirectoryBrowser&lt;/span&gt; 扩展方法使用中间件来开启网络应用目录浏览：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env)&lt;/span&gt;
&lt;/span&gt;{
    app.UseStaticFiles();
    
    app.UseStaticFiles(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StaticFileOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
    });
    
    app.UseDirectoryBrowser(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DirectoryBrowserOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序后，就可以通过访问 http:&amp;lt;app&amp;gt;/StaticFiles 来浏览 ContentRoot/StaticFiles 文件夹中的目录了。这个中间件会返回一个HTML页面，将请求目录下的所有文件将以表格的形式包含在这个页面中（包括该文件夹下的每一个文件夹与文件）&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152215307-1671935959.png&quot; alt=&quot;&quot; name=&quot;images/1547693741496.png&quot; data-src=&quot;./images/1547693741496.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;注意：使用&lt;span class=&quot;mark&quot;&gt;静态文件&lt;/span&gt;和&lt;span class=&quot;mark&quot;&gt;目录浏览&lt;/span&gt;的区别，上述Step2.&lt;span class=&quot;mark&quot;&gt;Startup.Configure&lt;/span&gt;方法中调用了两个 &lt;span class=&quot;mark&quot;&gt;app.UseStaticFiles&lt;/span&gt; ：第一个调用允许请求 wwwroot 文件夹下的静态文件，第二个调用则是允许通过 http:&amp;lt;app&amp;gt;/StaticFiles/&amp;lt;fileName&amp;gt; 请求 StaticFiles 文件夹中的静态文件，调用 &lt;span class=&quot;mark&quot;&gt;app.UseDirectoryBrowser&lt;/span&gt; 则是允许通过 http:&amp;lt;app&amp;gt;/StaticFiles 请求浏览 StaticFiles 文件夹的目录&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;注册指定目录的浏览&lt;/h4&gt;
&lt;h4&gt; 　　&lt;span class=&quot;mark&quot;&gt;app.UseDirectoryBrowser&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;方法可接受一个配置项对象 DirectoryBrowserOptions，该对象与静态文件中间件配置项对象相似，通过该对象可以配置允许用户浏览的目录&lt;/span&gt;&lt;span&gt;和请求的虚拟路径。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;默认文件&lt;/h3&gt;
&lt;p&gt;设置默认首页能给站点的每个访问者提供一个默认起始页。为了使站点能够提供默认页面，避免用户输入完整URL，我们可以在 &lt;span class=&quot;mark&quot;&gt;Startup.Configure&lt;/span&gt; 中调用 &lt;span class=&quot;mark&quot;&gt;app.UseDefaultFiles&lt;/span&gt; 扩展方法：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&lt;/span&gt;
&lt;/span&gt;{
    app.UseDefaultFiles();
    app.UseStaticFiles();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;mark&quot;&gt;app.UseDefaultFiles&lt;/span&gt; 必须是在 &lt;span class=&quot;mark&quot;&gt;UseStaticFiles&lt;/span&gt; 之前调用。UseDefaultFiles只是重写了URL，而不是真的提供了这样一个文件。因此必须开启静态文件中间件（UseStaticFiles)来提供这个文件。&lt;br/&gt;通过 UseDefanltFiles，请求文件夹的时候将检索以下文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;default.htm&lt;/li&gt;
&lt;li&gt;default.html&lt;/li&gt;
&lt;li&gt;index.htm&lt;/li&gt;
&lt;li&gt;index.html&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;列表中第一个被找到的文件将返回给用户，作为该完整URL的请求的应答，而此时浏览器上URL将继续显示用户输入的URI。&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;指定默认文件&lt;/h4&gt;
&lt;p&gt;静态文件中间件可以接受一个 DefaultFilesOptions 的配置对象参数，通过添加默认主页名称，可以指定自定义的默认文件（默认首页），下面的代码展示如何将默认文件名改为 myindex.html&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;(IApplicationBuilder app)
{
        DefaultFilesOptions options = new DefaultFilesOptions();
        options.DefaultFileNames.Clear(); // 清除默认文件
        options.DefaultFileNames.Add(&quot;login.html&quot;); //添加指定文件为默认文件
        app.UseDefaultFiles(options); //使用默认文件中间件
        app.UseStaticFiles();　　　　 //使用静态文件中间件（必须）
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 web根目录中添加好 login.html 页面，运行程序：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201903/1545277-20190319115606354-416233176.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;UseFileServer&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;mark&quot;&gt;UseFileServer&lt;/span&gt; 集合了 &lt;span class=&quot;mark&quot;&gt;UseStaticFiles&lt;/span&gt;、&lt;span class=&quot;mark&quot;&gt;UseDefaultFiles&lt;/span&gt;以及&lt;span class=&quot;mark&quot;&gt;UseDirectoryBrowser&lt;/span&gt;。&lt;br/&gt;下面的代码启用了静态文件和默认文件，但不允许直接访问目录：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;app.UseFileServer();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的代码启用了静态文件、默认文件和目录浏览功能：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;app.UseFileServer(enableDirectoryBrowsing:&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为一个集合了&lt;span class=&quot;mark&quot;&gt;UseStaticFiles&lt;/span&gt;、&lt;span class=&quot;mark&quot;&gt;UseDefaultFiles&lt;/span&gt;和&lt;span class=&quot;mark&quot;&gt;UseDirectoryBrowser&lt;/span&gt;方法于一体的方法，如果希望提供 web根目录之外存在的文件，则需要实例化并配置一个 &lt;span class=&quot;mark&quot;&gt;FileServerOptions&lt;/span&gt; 对象传递给&lt;span class=&quot;mark&quot;&gt;app.UscFileServer&lt;/span&gt; 的参数。例如，在应用中有如下层次的目录：&lt;/p&gt;

&lt;div class=&quot;xsj_remote_html story_remote_resource_block&quot; readability=&quot;32.372549019608&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div id=&quot;xsj_drawio_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152215841-523587266.png&quot; alt=&quot;&quot; name=&quot;b8fcdd3faff34c6fe3627a507189885f.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;mxfile userAgent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36&quot; version=&quot;8.5.3&quot; editor=&quot;www.draw.io&quot; type=&quot;device&quot;&amp;gt;&amp;lt;diagram&amp;gt;7Vtdk5owFP01PnaHEEB9rPbroZ3pdDvT5ygR00ZCQyxuf31vIBHZ6K6tQN1ddpydcMNHcs89h9wbHeH5Zvdekmz9ScSUj3wv3o3wm5HvY8+D/9pwVxkCNK4MiWRxZfJqwy37TSsjstYti2neOFEJwRXLjBFVxqVIU7pUjROJlKJoXrsSPG5cl5GEOobbJeGu9RuL1bqyTvxxbf9AWbI2T0YomlY9C7L8kUixTc3zRj5elX9V94bYe5mR5WsSi+LAhN+O8FwKoarWZjenXLu26bZ3J3r345Y0Vedc4FcX/CJ8S+2Iy3GpO+sLGGKmm3BTxQj/Av4maaJ7Z0pk0OFBi9OVMk1p/KLbC6GU2JgDwlmSQrs6d/aLwv3A5a+NubzZbMU4nwsuJFhSkeqn5BlZsjT5WD0i8mrTF/OoAEwC7rfipS/XLI5pqociFFFkUc5EX5YJlqoyNMIZfMA1c+8mHIUwzTkco/oYPvp0qeYizZUkrHQnJbkqaK5HH0uRfSUyoXaqK5EqE8gIYJy5SBhw9Lzp7sBkkHlPxYYqeQenmN7QBIkl0WRSHRd1SCIbSOuDcPQjwwTDgmR/5zoSoGGC4Xhg4IsCo3SGOROdCpRGcBzB/ax4aQZH0FZsPAa/nrOZ2+PA+yeA3+uXGUZDAxoBcYB4GHUDePA44JxVfFRS/NjrIvon8DYAAz8g99cyQF4hB1HsIoqPoMfJgvLPImeKCX1/I0J/iWoHHEZe1CRxhBwSW98fQjq5HNFw0PYno+0hwv1pezRoe2vaHp4A/qq0fTwowZNRAjzpUQkmgxK0pgTjE8BflRJMByV4MkoQeNP+lMBWXgYpaEEKpieQvyopQMhBvCiKsvTkR1zPeSGhlaj9FA9CAeal7Wu14cYrVVZ4D9EHQF6Ct6h8KDUs1kzRWwBXP7OQJCtB3KYxjQ2ELXAO4Xv5WRg6pAuOcc5rAQE354bwUzCZl4aCrWzZNVDk9QfCGWnyUPhoofBxZF3bUeEDuQnup7tb8BtbvmOc5s+XRyiYNp0+HvdHpDOSiYFIf4+p743vESnojUhuuqBgnjdZmjxfDvk4/G8c8s9YhQ8cuvxlhKd+Xxzy3WX2gqXPlz7Ihuy+ntXfgto+eqBPx2s5u8LqgT7uRrRYfH859Ak8d9O/M/q4qdBnKTLtj+e9aEZNl2N3i7Yzl1+2FzcUZHstyGL3VdZZQfbCTbuhINv4Bk50AvqrqsheuB03iEGvYnCkRtmdGFy2bzeIQUMMJiegvyoxwG7e6EA+5DIt5DLYXWB3lMvgY+mp2eRpABv93Ao7/Vd5Of/XcAIKsl3daXeFbtyNoodMMMhFvaH0craYEGqWxkOLRg+rfHzGt6kHLl/O5dDrrS6B3b1bBgG7uymZcs0sOvLac0B4IFe+twqaut9RaYlFcFj/DqbsO/itEX77Bw==&amp;lt;/diagram&amp;gt;&amp;lt;/mxfile&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;component_attachment&quot;&gt;&lt;a class=&quot;attachment table_attachment&quot; title=&quot;Diagram&quot; name=&quot;attachments/1547685507116.drawio.html&quot; href=&quot;cid:154770972611117&quot; target=&quot;_blank&quot; data-size=&quot;10228&quot;&gt;&lt;span class=&quot;filename&quot;&gt;1547685507116.drawio.html&lt;/span&gt; &lt;span class=&quot;filesize&quot;&gt;9.99KB&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;对于上面这个层次结构的示例，你可能需耍启用静态文件、默认文件以及浏览 MyStaticFiles 目录等功能。下面的代码片段演示了如何通过调用一次 &lt;span class=&quot;mark&quot;&gt;FileServerOptions&lt;/span&gt; 来完整实现这些功能：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&lt;/span&gt;
&lt;/span&gt;{
    app.UseFileServer(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileServerOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
        EnableDirectoryBrowsing = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
        EnableDefaultFiles = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将 &lt;span class=&quot;mark&quot;&gt;enableDirectoryBrowsing&lt;/span&gt;设置为true，则必须要在 &lt;span class=&quot;mark&quot;&gt;Startup.ConfigureServices&lt;/span&gt; 中调用 &lt;span class=&quot;mark&quot;&gt;services.AddDirectoryBrowser&lt;/span&gt; 扩展方法：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;
&lt;/span&gt;{
    services.AddDirectoryBrowser();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在 MyStaticFiles 目录下存在默认页面，则打开默认页面。如果没有默认命名的文件，则http://StaticFiles将返回目录 StaticFiles 的目录列表，如下图所示。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image&quot; readability=&quot;32&quot;&gt;&lt;img title=&quot;StaticFiles中存在默认页面&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152216253-1630696004.png&quot; alt=&quot;StaticFiles中存在默认页面&quot; name=&quot;images/1547699906480.png&quot; data-src=&quot;./images/1547699906480.png&quot;/&gt;&lt;p&gt;StaticFiles中存在默认页面&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image&quot; readability=&quot;32&quot;&gt;&lt;img title=&quot;StaticFiles中不存在默认页面&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152216489-553537822.png&quot; alt=&quot;StaticFiles中不存在默认页面&quot; name=&quot;images/1547699951896.png&quot; data-src=&quot;./images/1547699951896.png&quot;/&gt;&lt;p&gt;StaticFiles中不存在默认页面&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;FileExtensionContentTypeProvider&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;mark&quot;&gt;FileExtensionContentTypeProvider&lt;/span&gt; 类内包含一个将文件扩展名映射到 &lt;span class=&quot;mark&quot;&gt;MIME内容类型&lt;/span&gt;的集合。在下面的例子中，将多个文件扩展名（如：.myapp）注册为已知的MIME类型（application/x-msdownload），“&lt;span class=&quot;mark&quot;&gt;.rtf&lt;/span&gt;”被替换，“&lt;span class=&quot;mark&quot;&gt;.mp4&lt;/span&gt;”被移除：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app)&lt;/span&gt;
&lt;/span&gt;{
    FileExtensionContentTypeProvider provider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileExtensionContentTypeProvider();
    
    provider.Mappings[&lt;span class=&quot;hljs-string&quot;&gt;&quot;.myapp&quot;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/x-msdownload&quot;&lt;/span&gt;;
    provider.Mappings[&lt;span class=&quot;hljs-string&quot;&gt;&quot;.htm3&quot;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;;
    provider.Mappings[&lt;span class=&quot;hljs-string&quot;&gt;&quot;.image&quot;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;image/png&quot;&lt;/span&gt;;

    
    provider.Mappings[&lt;span class=&quot;hljs-string&quot;&gt;&quot;.rtf&quot;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/x-msdownload&quot;&lt;/span&gt;;

    
    provider.Mappings.Remove(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.mp4&quot;&lt;/span&gt;);
    app.UseStaticFiles(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StaticFileOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
        ContentTypeProvider = provider,
    });

    app.UseDirectoryBrowser(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DirectoryBrowserOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;非标准的内容类型&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://ASP.NET&quot; target=&quot;_blank&quot;&gt;ASP.NET&lt;/a&gt; Core 静态文件中间件能够支持超过400多种己知的文件内容类型。如果用户请求一个未知的文件类型，静态文件中间件将返 HTTP404(未找到）响应。如果启用目录浏览，则该文件的URL将会被显示，但访问URL会返回一个 HTTP404 错误。下面则通过代码把不能识别的类型和文件作为下载的文件处理：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app)&lt;/span&gt;
&lt;/span&gt;{
    app.UseStaticFiles(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StaticFileOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
        ServeUnknownFileTypes = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
        DefaultContentType = &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/x-msdownload&quot;&lt;/span&gt;,
    });

    app.UseDirectoryBrowser(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DirectoryBrowserOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;MyStaticFiles&quot;&lt;/span&gt;)),
        RequestPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PathString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/StaticFiles&quot;&lt;/span&gt;),
    });

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UseDirectoryBrowser 和 UseStaticFiles 可能会泄密。建议不要在生产环境开启目录浏览。要小心那些被你开启了 UseStaticFiles 或 UseDirectoryBrowser 的目录，它们的子文件及子目录都可被访问。建议将公开内容放在&amp;lt;content root&amp;gt;/wwwroot 这样的目录中，远离应用程视图、配置文件等。&lt;/li&gt;
&lt;li&gt;使用 UseDirectoryBrowser 和 UseStaticFiles 暴露的文件的 URL是否区分大小写以及字符限制，受制于底层文件系统。比如Windows是不区分大小写的，但MACOS和Linux则区分大小写。&lt;/li&gt;
&lt;/ul&gt;&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;实战简单文件服务器&lt;/h3&gt;
&lt;p&gt;① 首先新建一个ASP.NETCore项目，选择空的模板。&lt;br/&gt;② 使用NuGet命令添加Microsoft.AspNetCore.StaticFiles引用：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot;&gt;Install-PackageMicrosoft.AspNetCore.StaticFiles
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 如果我们的文件服务器需要能访问和浏览E盘的所有文件与文件夹，那么我们就需要用到 &lt;span class=&quot;mark&quot;&gt;UseStaticFiles&lt;/span&gt; 和 &lt;span class=&quot;mark&quot;&gt;UseDirectoryBrowser&lt;/span&gt; 方法了，在 &lt;span class=&quot;mark&quot;&gt;Startup.Configure&lt;/span&gt; 方法下添加如下代码：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C# hljs&quot; data-info=&quot;C#&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app)&lt;/span&gt;
&lt;/span&gt;{
    FileExtensionContentTypeProvider provider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileExtensionContentTypeProvider();
    provider.Mappings[&lt;span class=&quot;hljs-string&quot;&gt;&quot;.log&quot;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;;
    app.UseStaticFiles(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StaticFileOptions()
    {
        FileProvider = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PhysicalFileProvider(@&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\&quot;),  // 指定静态文件目录
        ServeUnknownFileTypes = true,
        ContentTypeProvider = provider,
        DefaultContentType = &quot;&lt;/span&gt;application/x-msdownload&lt;span class=&quot;hljs-string&quot;&gt;&quot;, // 设置未识别的MIME类型一个默认z值
    });

    app.UseDirectoryBrowser(new DirectoryBrowserOptions()
    {
        FileProvider = new PhysicalFileProvider(@&quot;&lt;/span&gt;E:\&lt;span class=&quot;hljs-string&quot;&gt;&quot;), // 制定目录，这里指定 E盘，也可以是其他目录
    });
}
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行程序，这里选择使用 Kestrel，访问：http://&amp;lt;ip&amp;gt;:5000/，如下图所示：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152216902-580800537.png&quot; alt=&quot;&quot; name=&quot;images/1547705300461.png&quot; data-src=&quot;./images/1547705300461.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152217300-858592658.png&quot; alt=&quot;&quot; name=&quot;images/1547706977888.png&quot; data-src=&quot;./images/1547706977888.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就能通过客户端浏览服务器E盘的所有文件及文件夹了。我们还手动设置了未识别的 MIME 类型一个默认值（&quot;application/x-msdownload&quot;），当浏览器打开这些未识别类型的文件，就会下载这些文件。像 &lt;span class=&quot;mark&quot;&gt;.log&lt;/span&gt; 这样的文件就被手动设置为文本方式，浏览器会直接展示出来。这样我们也就实现了一个简单的文件服务器。&lt;/p&gt;
&lt;p&gt;如果想用局域网内其他电脑或手机查看图片或视频文件，则修改Properties文件下 launchSettings.json 配置文件中的应用程序URL就可以实现：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json hljs&quot; data-info=&quot;json&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;WebApplication&quot;&lt;/span&gt;: {
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;commandName&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Project&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;launchBrowser&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;applicationUrl&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://*:5001;http://*:5000&quot;&lt;/span&gt;,  // 这样就可以通过 http:ip:&lt;span class=&quot;hljs-number&quot;&gt;5000&lt;/span&gt;访问
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;environmentVariables&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Development&quot;&lt;/span&gt;
  }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在同一局域网内，在手机上访问 http:ip:5000，就能访问服务器E盘中的文件了。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1545277/201901/1545277-20190117152217680-209603754.png&quot; alt=&quot;&quot; name=&quot;images/1547708940530.png&quot; data-src=&quot;./images/1547708940530.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;参考原文&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;Microsoft 文档 ASP.NET Core 中间件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/7760648.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core 中间件（Middleware）详解&lt;/a&gt;&lt;a href=&quot;http://item.jd.com/12063817.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Mar 2019 15:07:00 +0000</pubDate>
<dc:creator>啊，那一个人</dc:creator>
<og:description>ASP.NET Core 文件系统 静态文件 目录浏览 默认页面 MIME类型配置 实战文件服务器 紧接上一讲 中间件 之后，今天来我们来讲一下关于 ASP.N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anayigeren/p/10282441.html</dc:identifier>
</item>
<item>
<title>【js】字符串反转可实现的几种方式 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/10575433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/10575433.html</guid>
<description>&lt;h4&gt;方式1：&lt;/h4&gt;
&lt;p&gt;这种方式比较简单，&lt;span&gt;推荐使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串转数组，反转数组，数组转字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;split(&quot;&quot;)&lt;/span&gt;：根据空字符串拆分数组&lt;/p&gt;
&lt;p&gt;&lt;span&gt;reverse()&lt;/span&gt;：数组反转元素位置&lt;/p&gt;
&lt;p&gt;&lt;span&gt;join(&quot;&quot;)&lt;/span&gt;：数组转回字符串,且不带分隔符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190321215658645-399004306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190321215914280-1976859995.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;方式2：&lt;/h4&gt;
&lt;p&gt;这种方式相对麻烦，&lt;span&gt;但也可以&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;定义新的空字符串，遍历str，&lt;span&gt;charAt()&lt;/span&gt;是取字符串的一个字符，先去最后一个字符，再取倒数第二个...以此类推。&lt;/p&gt;
&lt;p&gt;都放到新的字符串前面。这样就是倒序的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190321222803180-774181869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;方式3&lt;img src=&quot;http://image3.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvY1pWMmhScHVBUGdyYW1ac2g0ZmljV2Y2dWljMzhuUk5SdHhnZ2liWDl2bHNQbXZudXNYT0pIRlFDYzhDaWNCR3o0d3VIbmdnVzBId2JjZWd0bmNuZ3dLTWZRLzA/d3hfZm10PWdpZg==&quot; alt=&quot;&quot;/&gt;​：&lt;/h4&gt;
&lt;p&gt;这种方式有点类似第一种方式的底层实现版，&lt;span&gt;一般不推荐使用&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;把中间的数组元素替换位置换成了可以理解。但是太繁琐。有了可使用的函数就可以不用这样了。&lt;/p&gt;
&lt;p&gt;关键在于这里的pop()函数和push()函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pop()&lt;/span&gt;：取数组最后一个元素，并删除该元素&lt;/p&gt;
&lt;p&gt;&lt;span&gt;push()&lt;/span&gt;：元素加入新数组中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190321224821996-348291719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;表情逐渐复杂...&lt;img src=&quot;http://image3.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9naWYvY1pWMmhScHVBUGdyYW1ac2g0ZmljV2Y2dWljMzhuUk5SdGRNWUFOb2J4Qk1FV2ljaWJlT3lBYzJubGtKTmljeUMxbkJFcm1Yb0d0UVNRd1JGRWljczl0Z2VMaWFnLzA/d3hfZm10PWdpZg==&quot; alt=&quot;&quot;/&gt;​&lt;/h3&gt;

</description>
<pubDate>Thu, 21 Mar 2019 15:01:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<og:description>方式1： 这种方式比较简单，推荐使用 字符串转数组，反转数组，数组转字符串。 split(&quot;&quot;)：根据空字符串拆分数组 reverse()：数组反转元素位置 join(&quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/10575433.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core&amp;Jenkins持续交付到Windows Server - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10522424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10522424.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　对于Linux平台上的持续集成和持续交付可以使用Docker快捷的完成任务，但是Windows Server下却不好使用，一般来讲，windows Server下最简单的发布方式是直接手动打包发布或是利用webDeploy完成，但是手动发布太麻烦，webDeploy配置也麻烦，因此尝试使用Jenkins+Powershell，将代码拉取到Windows Server上然后通过dotnet命令发布，并通过Powershell更新相应的网站，但是首次网站配置工作，还是得手动进行发布工作，对于在公司内部服务器测试来讲，可以减轻许多工作量，做到代码合并到主干即可更新测试服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本地环境及工具：Windows Server 2008R2+Jenkins+Powershell+.Net Core2.2&lt;/strong&gt; &lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、服务器安装Jenkins&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;    从&lt;a href=&quot;https://jenkins.io/download/&quot; target=&quot;_blank&quot;&gt;Jenkins官网&lt;/a&gt;下载Windows下的Jenkins程序,下载的压缩包解压后为msi版本，作为系统服务在后台运行，移入到服务器中&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313125726767-1289165686.png&quot; alt=&quot;&quot; width=&quot;432&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行安装，按照正常的安装步骤安装即可&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313125701049-765542141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　安装完毕会自动打开网站或手动访问localhost:8080，开始配置Jenkins，找到网站中指定的路径中，拿到生成的密码解锁Jenkins。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313125954766-429845511.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下一步安装推荐的插件即可,如果知道哪些插件要安装则选择另一个选项，此处我选择第一个也是默认选项，然后等待安装即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313130433093-1231928298.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装完毕，配置管理员账号密码完毕即可，完成后自动跳转到Jenkins中，下次登录时需要用刚配置好的账号密码登录。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313130936210-547735873.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、服务器配置IIS、安装.Net Core SDK及AspNetCoreModule&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　&lt;strong&gt;　1、配置IIS及相关需要的服务：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过&lt;strong&gt;图形界面配置IIS&lt;/strong&gt;并安装需要的服务,可参考Windows ServerR2配置教程：&lt;a href=&quot;https://jingyan.baidu.com/article/5d6edee2e034f099eadeec3c.html&quot; target=&quot;_blank&quot;&gt;https://jingyan.baidu.com/article/5d6edee2e034f099eadeec3c.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313215242318-25089693.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或通过&lt;strong&gt;脚本配置IIS&lt;/strong&gt;，打开Windows Powershell Modules工具，先通过命令查看本地的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
get-command -module servermanager
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313213507573-1211606723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如我本地是Add-开头，则需要将&lt;strong&gt;Install-WindowsFeature&lt;/strong&gt;更换成&lt;strong&gt;Add-WindowsFeature，否则稍后的操作会得到如下错误&lt;/strong&gt;，在2008R2上是Add-开头，而在2008R2以后的版本是Install-开头，此部分可以查看&lt;a href=&quot;https://docs.microsoft.com/zh-cn/previous-versions/windows/powershell-scripting/jj205467(v=wps.630)&quot; target=&quot;_blank&quot;&gt;微软官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313213409176-2016957167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次查看IIS服务并得到展示可以选择的服务，该部分服务就是图形化界面中的选项菜单，选择好需要的服务后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
get-windowsfeature web*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313220913061-298654519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行以下命令完成脚本配置IIS，可以比对脚本内的服务和powershell中的服务，直接继续按照命令安装即可，至此IIS配置及安装需要的服务完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$IISFeatures&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-WebServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Common-Http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Default-Doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Dir-Browsing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Errors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Static-Content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Redirect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Custom-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Log-Libraries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ODBC-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Request-Monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Tracing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Performance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Stat-Compression&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Security&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Filtering&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Basic-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Client-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Digest-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Cert-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-IP-Security&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Windows-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-App-Dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Net-Ext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Asp-Net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ISAPI-Ext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ISAPI-Filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Mgmt-Tools&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Mgmt-Console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Install&lt;/span&gt;-WindowsFeature -Name &lt;span&gt;$IISFeatures&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313221120723-1066903845.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;423&quot;/&gt;　　 　　　　　　　　&lt;/p&gt;
&lt;p&gt;　　可能会得到如下错误信息，需要修改Powershell的执行策略。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313133423516-842979306.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　先通过命令查看当前策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
get-executionpolicy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置当前计算机允许执行脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
set-executionpolicy remotesigned
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次执行配置IIS的脚本等待安装直到成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313221202525-1211730481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ·&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2、安装.Net Core环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　先从官网下载.Net Core SDK和用于与IIS打交道的Runtime &amp;amp; Hosting Bundle，.Net Core SDK不是必须的，如果服务器上只做运行环境的话，但是考虑到做持续交付，得用到SDK完成编译、发布，因此还是装上SDK。此处以&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core/2.2&quot; target=&quot;_blank&quot;&gt;.Net Core2.2&lt;/a&gt;版本为例下载，然后执行安装，可能得注意下安装顺序，先安装SDK程序，后安装Runtime&amp;amp;HostingBundle程序，安装完毕后在IIS的模块页中查看刚刚安装的模块。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313222820263-658552330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　3、脚本一键安装并配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过Powershell中执行一整套命令完成IIS、.Net Core SDK和Runtime &amp;amp; Hosting Bundle的安装及配置工作，需要注意的是，该脚本中部分命令需要在Windows Server2008R2后的版本才能运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$existDotnet&lt;/span&gt;=Test-Path &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Program Files\dotnet\dotnet.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;$existDotnet&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Install IIS&lt;/span&gt;
&lt;span&gt;$IISFeatures&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-WebServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Common-Http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Default-Doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Dir-Browsing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Errors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Static-Content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Redirect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Custom-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Log-Libraries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ODBC-Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Request-Monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Http-Tracing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Performance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Stat-Compression&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Security&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Filtering&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Basic-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Client-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Digest-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Cert-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-IP-Security&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Windows-Auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-App-Dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Net-Ext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Asp-Net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ISAPI-Ext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-ISAPI-Filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Mgmt-Tools&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web-Mgmt-Console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Install&lt;/span&gt;-WindowsFeature -Name &lt;span&gt;$IISFeatures&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Install .NET Core SDK 2.2.104&lt;/span&gt;
&lt;span&gt;$downloadNETCoreSDKUrl&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://download.visualstudio.microsoft.com/download/pr/4a195fc9-7696-4c24-add2-e791b399766c/3a67d698a74505b46db9d9779745e47b/dotnet-sdk-2.2.104-win-x64.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

Invoke&lt;/span&gt;-WebRequest &lt;span&gt;$downloadNETCoreSDKUrl&lt;/span&gt; -outfile &lt;span&gt;$env:temp&lt;/span&gt;\dotnet-&lt;span&gt;sdk.exe
Start&lt;/span&gt;-&lt;span&gt;Process&lt;/span&gt; &lt;span&gt;$env:temp&lt;/span&gt;\dotnet-sdk.exe -ArgumentList '/quiet' -&lt;span&gt;Wait

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Install the .NET Core Windows Server Hosting bundle&lt;/span&gt;
&lt;span&gt;$downloadNETCoreHostingIISUrl&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://download.visualstudio.microsoft.com/download/pr/5efd5ee8-4df6-4b99-9feb-87250f1cd09f/552f4b0b0340e447bab2f38331f833c5/dotnet-hosting-2.2.2-win.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

Invoke&lt;/span&gt;-WebRequest &lt;span&gt;$downloadNETCoreHostingIISUrl&lt;/span&gt; -outfile &lt;span&gt;$env:temp&lt;/span&gt;\dotnet-&lt;span&gt;hosting.exe
Start&lt;/span&gt;-&lt;span&gt;Process&lt;/span&gt; &lt;span&gt;$env:temp&lt;/span&gt;\dotnet-hosting.exe -ArgumentList '/quiet' -&lt;span&gt;Wait

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Restart the web server so that system PATH updates take effect&lt;/span&gt;
net stop was /&lt;span&gt;y
net start w3svc

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;4、配置IIS应用程序池：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在IIS中配置应用程序池已满足.Net Core为自宿主类型，IIS只是起到反向代理作用。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190313222425890-1783737551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、使用Powershell脚本完成项目发布、更新网站&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　1、在Jenkins中配置流水线&lt;/p&gt;
&lt;p&gt;　　选择新增一个任务并选择构建自由风格软件项目， 配置Git地址,如果出现如下错误信息则需要在服务器上安装Git，直接下载Git安装到服务器中，并在Jenkins中配置&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;Failed to connect to repository:Error performing command:git.exe ls-remote-h ........ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Jenkins首页左侧系统管理-&amp;gt;全局工具配置中找到Git，然后修改为安装路径下.exe所在位置，保存即可，再次回到项目制定处填写Git地址错误消失。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190319163626636-748455308.png&quot; alt=&quot;&quot; width=&quot;888&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置完Git地址后的一些信息如下简单设置一下即可&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190319164427264-547709837.png&quot; alt=&quot;&quot; width=&quot;904&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、项目发布后打包到服务器下，通过IIS增加网站，选择应用程序池，选择物理路径等等操作，保证第一次手动操作的正常运行，此处暂时先跳过，操作简便。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190321224048353-2092744984.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3、在Jenkins中安装一个Powershell插件，在系统管理-&amp;gt;插件管理-&amp;gt;可用项下搜索Powershell执行安装。&lt;/p&gt;
&lt;p&gt;　　　　在Jenkins项目配置中新增&lt;strong&gt;Build&lt;/strong&gt;环节，选择Powershell，然后完成对网站的更新&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190321224202007-1950617964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在powershell中涉及到还原依赖包、编译代码、停止站点、发布项目，重启站点等等......，对于站点名称，应用程序池，发布路径，站点路径等都由自己决定，保存后，执行构建，或改动代码触发构建，还可接入邮件通知功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 还原项目&lt;/span&gt;
&lt;span&gt;dotnet restore

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编译项目&lt;/span&gt;
&lt;span&gt;dotnet build

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义站点名称&lt;/span&gt;
&lt;span&gt;$websiteName&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;limsSite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 应用程序池&lt;/span&gt;
&lt;span&gt;$applicationPool&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.NetCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 临时发布路径&lt;/span&gt;
&lt;span&gt;$publishTempPath&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\Project\LimsSiteTemp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; IIS站点路径&lt;/span&gt;
&lt;span&gt;$publishPath&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\Project\LimsSite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭站点&lt;/span&gt;
C:\Windows\System32\inetsrv\appcmd.exe stop site &lt;span&gt;$websiteName&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定发布路径&lt;/span&gt;
dotnet publish -o &lt;span&gt;$publishTempPath&lt;/span&gt; -&lt;span&gt;c Release

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单独停止应用程序池： &lt;/span&gt;
C:\Windows\System32\inetsrv\appcmd.exe stop apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$applicationPool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 复制文件到IIS站点下&lt;/span&gt;
Copy-Item &lt;span&gt;$publishTempPath&lt;/span&gt;  &lt;span&gt;$publishPath&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单独启动应用程序池： &lt;/span&gt;
C:\Windows\System32\inetsrv\appcmd.exe start apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$applicationPool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动站点&lt;/span&gt;
C:\Windows\System32\inetsrv\appcmd.exe start site &lt;span&gt;$websiteName&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除站点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; C:\Windows\System32\inetsrv\appcmd.exe delete site $websiteName&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，Jenkins&amp;amp;Asp.Net Core持续交付到Windows Server上，方便快速测试服务器的发布工作也就完成了，可能还留有坑，暂时不影响。&lt;/p&gt;

&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201903/1133736-20190321224941876-1396346594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2019-03-21,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 21 Mar 2019 14:52:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>对于Linux平台上的持续集成和持续交付可以使用Docker快捷的完成任务，但是Windows Server下却不好使用，一般来讲，windows Server下最简单的发布方式是直接手动打包发布或是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10522424.html</dc:identifier>
</item>
<item>
<title>【jvm】来自于线上的fullGC分析 - 云牙子</title>
<link>http://www.cnblogs.com/lllove/p/10574810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lllove/p/10574810.html</guid>
<description>&lt;p&gt;&lt;span&gt;   系统最近老年代的内存上升的比较快，三到四天会发生一波fullGC。于是开始对GC的情况做一波分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   线上老年代2.7G，年轻带1.3G老年代上升较快，3天一波fullGC,并且fullGC会把内存回收，有时回收一般，有时回收全部。所以判断是不会有内存泄漏现象的，内存发生泄漏是回收不了的。第二个判断，不存在大对象，一个是基于对程序的理解，一个是对于老年代上升的速率，基本是稳固上升。不存在峰值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   我是先用jstack  命令打印出线程状态的  jstack -l pid  &amp;gt;&amp;gt; 文件名  发现这么操作是无用的。jstack主要是分析线程状态的，尤其是针对占用CPU，死循环，死锁操作等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一开始确实定位到一个线程，是我们服务每个一分钟拉去配置中心数据的线程，数据量很小，而且基本都是重复的数据。所以那会没有头绪方向不对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后来老大说打下内存快照啊。于是就开始看下内存快照了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1、先使用 jmap命令打印出内存快照文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      jmap  -dump:format=b,file= 文件路径  pid(进程号)    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2、使用MemoryAnalyzer（windows下的分析工具）工具分析大对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    分析出来是jdbc连接对象实例太多，因为mysql的jdbc包在每次创建jdbc连接的时候，会对连接进行虚引用包装，最后放到一个ConcurrentHashMap里。而系统1分钟会进行年轻代的GC，而程序配置的链接生命周期为30分钟。所以30分钟MinGC将到达30多次，而JVM默认的配置是15。所以我们推测这个配置的不对，要么减少生命周期要么增加JVM年龄的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   经过测试在jdk8的环境下，年龄的阈值是不能超过15的，这就尴尬了。于是只好降低生命周期，同时设置数据源的最大连接和最小连接相等，防止数据源一直创建空闲连接，这样能方式连接数量，同时通过反射，检测ConcurrentHashMap的数量。经过上线后，发现并没有明显效果。于是乎干脆把map的数据直接清空，发现清空了上完线也并没有解决老年代上升的问题。不过老年代每次fullGC都会回收到底。于是判断清空有助于进行回收，并且老年代回收的耗时也变短了，减少到一半时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    另一方面观测，检查了JVM年轻代 E区和S区的比例，你会认为默认是1:8，但是不是那么简单地。发现程序刚启动时确实是1比8，但是随着程序启动，MinGC，jvm默认的垃圾回收器会自动调节这个比例。只有设置CMS才不会自动调节。于是决策是由于S区分配内存太小导致，当时我们的S区稳定在30M左右，E区差不多有1.3G。于是改成了CMS垃圾回收器，发现也并没有卵用，而且老年代内存到达50%就发生了fullGC，看来CMS是可以设置回收阈值的。实在没办法了，只好换数据源了，把HikairCP换成了druid。发现换了之后就解决了，fullGC频率从4天能到达15天，ConcurrentMap的数量很少,最多也就2百的量。而之前能达到上万的量。总之不知道是因为HikairCP的原因，还是我们配置的原因。据说这个数据源号称比druid速度更优的数据源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    历史是何其的相似,程序性能问题又来了，我们程序为了提高tps，经过压测，发现瓶颈在于redis，当时redis是哨兵模式，读写访问一个master,于是想切换为集群。发现切换为集群后，fullGC的频率又回到了原先的地步，而且把操作切换为读集群时，压力更大，竟然再短短5小时内，打满老年代内存， 并且CPU占用也较大。没办法观测了一会，发现每5分钟上升2个百分点。代码回滚了。于是乎又开始了一波分析，代码优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    经过分析本次上线只是添加了cluster管道批量操作的代码，代码肯定出现在这里，于是开始进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先分析线上内存快照，发现最大占用的是 int 数组，这个不好分析，应为属于基本对象，没法分析。于是乎私底下在本地进行读集群方法的压测，再加上代码的分析，发现每次操作都会对取cluster集群的信息，这个集群的信息包含了所有节点的ip+port，以及他们对应的分槽信息，而这个分槽信息是以LinkedHashSet类型存储的，里面是满满的Integer类型的槽。一共16384个，于是基本确定了，是每次实时查询cluster集群信息导致的。发现Jedis的方法是对集群信息做了缓存的 ，但是只缓存了100毫秒。再加上我们本身程序也包含了大量的业务逻辑。估计这么一连起来就造成了YGC次数过高，或者年轻代S区空间太小。于是从两个方面去提高程序性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   发现在修改JVM参数配比，提高年轻代S区的内存大小，并且修改垃圾回收器为CMS，发现在本机进行ab压测，最高tps到达了800。并且在并发80，访问量50000的情况下，老年代内存会上升到100M,YGC次数能够到达200。而哨兵的压测结果tps最高到达2000。而且老年代内存50M。YGC次数也在30以内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是对cluster的代码进行优化，把每次获取集群节点信息放到了for循环里。tps提高到1300，老年代内存稳定在90M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们程序另一条思路是：把集群的信息缓存到JVM，不依靠Jedis的缓存100ms。而是由我们自己缓存。但是存在一个问题，每当集群节点扩容，分槽或者主下线，从上线。我们的程序就检测不到变化了，于是在程序里开启了异步线程每个5秒刷新集群信息，而且对于每次操作cluster做了重试处理，一旦检测到节点连接创建失败，发生MOVED错误，就刷新集群信息，进行操作重试。发现使用静态缓存集群信息的方式，tps提高到2000左右，基本和哨兵持平，而且老年代内存也到达60M左右，YGC次数也降下来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在这些过程中，我学到了什么：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 自己尝试搭建了虚拟机的redis-cluster集群（很早就搭建了，这回正好用上），redis集群分槽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; cluster管道批量操作，jdk的一些常用工具命令，还有ab的简单压测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后重要的是分析问题的能力和思路&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Mar 2019 13:34:00 +0000</pubDate>
<dc:creator>云牙子</dc:creator>
<og:description>系统最近老年代的内存上升的比较快，三到四天会发生一波fullGC。于是开始对GC的情况做一波分析。 线上老年代2.7G，年轻带1.3G老年代上升较快，3天一波fullGC,并且fullGC会把内存回收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lllove/p/10574810.html</dc:identifier>
</item>
<item>
<title>Android startActivity原理分析(基于Android 8.1 AOSP) - 柯壮</title>
<link>http://www.cnblogs.com/kezhuang/p/10574747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kezhuang/p/10574747.html</guid>
<description>&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;应用进程内&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何使用intent做activity的跳转&quot;&gt;如何使用Intent做Activity的跳转&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Intnet intent = new Intent(MainActivity.this,TestActivity.class);
startActivity(intent);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;我们通常会这样写就能跳转到testactivity中但是你知道这简简单单的两行代码在我们庞大的安卓系统中经历了怎样的加工处理吗接下来我带大家深入到系统内了解整个的启动过程&quot;&gt;我们通常会这样写，就能跳转到TestActivity中，但是你知道这简简单单的两行代码在我们庞大的安卓系统中经历了怎样的加工处理吗？接下来我带大家深入到系统内了解整个的启动过程&lt;/h3&gt;
&lt;h3 id=&quot;这里调用了startactivity的函数这个函数被声明在了context类中然后我们的activity类有重写版本所以会执行activity类下的版本我们跟进大家准备好了吗我要发车了&quot;&gt;这里调用了startActivity的函数，这个函数被声明在了Context类中，然后我们的Activity类有重写版本，所以会执行Activity类下的版本，我们跟进。大家准备好了吗。我要发车了！&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void startActivity(Intent intent) {
        this.startActivity(intent, null);
    }

    @Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            startActivityForResult(intent, -1);
        }
    }

    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {
        startActivityForResult(intent, requestCode, null);
    }

    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            if (requestCode &amp;gt;= 0) {
                mStartedActivity = true;
            }

            cancelInputsAndStartExitTransition(options);
        } else {
            if (options != null) {
                mParent.startActivityFromChild(this, intent, requestCode, options);
            } else {
                // Note we want to go through this method for compatibility with
                // existing applications that may have overridden it.
                mParent.startActivityFromChild(this, intent, requestCode);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上面有四个函数基本上都是简单的判断和一些代码的封装在最后一个函数中执行了minstrumentation对象下的execstartactivity函数这个函数会做一些脱离应用进程的操作准备通过ibinder机制将请求发送到ams中简单说一下传入参数&quot;&gt;上面有四个函数，基本上都是简单的判断和一些代码的封装，在最后一个函数中，执行了mInstrumentation对象下的execStartActivity函数，这个函数会做一些脱离应用进程的操作，准备通过IBinder机制将请求发送到Ams中。简单说一下传入参数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;this指的就是我们的MainActivity对象，标明谁是发起者&lt;/li&gt;
&lt;li&gt;getApplicationThread 获取的是应用标示，因为Android系统中每一个应用都是一个客户，而Ams更像是柜台服务人员&lt;/li&gt;
&lt;li&gt;mToken是系统的一个内部标示，是ActivityRecord类下的一个静态内部类，里边用弱引用存了一个ActivityRecord对象，会在startActivityForResult函数中应用，标明应该调用谁的onActivityResult函数，后面会有讲到&lt;/li&gt;
&lt;li&gt;同第一个参数，标明了发起者是谁&lt;/li&gt;
&lt;li&gt;intent就略过吧，很常用了&lt;/li&gt;
&lt;li&gt;requestCode这个值也很常用，所以也不做详细介绍了，默认-1&lt;/li&gt;
&lt;li&gt;options是我们跳转页面需要携带的参数，当然没有参数自然也会是null了&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;接下来我们了解完参数后看一下内部实现吧&quot;&gt;接下来我们了解完参数后看一下内部实现吧&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        Uri referrer = target != null ? target.onProvideReferrer() : null;
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i&amp;lt;N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode &amp;gt;= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个实现就是执行intent脱离我们的应用线程然后发送ibinder消息俗称ipc到ams中到此处便结束了应用之旅开始进入系统内部.&quot;&gt;这个实现就是执行intent脱离我们的应用线程，然后发送IBinder消息（俗称IPC）到Ams中，到此处便结束了应用之旅，开始进入系统内部.&lt;/h3&gt;
&lt;h5 id=&quot;另外我在补充一下activitymonitor这个类的知识这个是一个activity的监视器可以在写测试类的时候用到通常是写一个测试类然后继承instrumentationtestcase有兴趣的可以试一下&quot;&gt;另外我在补充一下ActivityMonitor这个类的知识，这个是一个Activity的监视器，可以在写测试类的时候用到，通常是写一个测试类，然后继承InstrumentationTestCase，有兴趣的可以试一下&lt;/h5&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统进程内(system_server)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final int startActivity(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个函数定义在amsactivitymanagerservice因为是对外调用的接口所以为了不做过多的逻辑处理紧接着转发给了startactivityasuser函数校验一下发起者身份我们可以看到其余的参数都是透传过来的但是最后多出来了一个userid&quot;&gt;这个函数定义在Ams（ActivityManagerService），因为是对外调用的接口，所以为了不做过多的逻辑处理，紧接着转发给了startActivityAsUser函数校验一下发起者身份。我们可以看到其余的参数都是透传过来的，但是最后多出来了一个UserId&lt;/h3&gt;
&lt;h5 id=&quot;userid手机上的用户标示类似于电脑多用户通过-应用uid-100000-计算得出0为手机持有者默认值为0&quot;&gt;UserId：手机上的用户标示，类似于电脑多用户，通过 应用uid / 100000 计算得出，0为手机持有者，默认值为0&lt;/h5&gt;
&lt;h5 id=&quot;uid应用id普通用户从-10000&quot;&gt;Uid：应用id，普通用户从 10000&lt;/h5&gt;
&lt;h5 id=&quot;pid进程id&quot;&gt;Pid：进程id&lt;/h5&gt;
&lt;h3 id=&quot;我们继续向下看吧&quot;&gt;我们继续向下看吧&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller(&quot;startActivity&quot;);
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);
        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, &quot;startActivityAsUser&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过了musercontroller这个对象下的handleincominguser函数校验这个函数会自己在通过userhandle.getcallinguserid获取一遍userid与传入参数的userid做校验如果一支便返回所以我们用普通用户的话这个userid便是0了随后转交给了activitystarter这个类来正式执行开启过程首先第一站便是startactivitymaywait函数接下来如果函数过长我会在代码上加注释方便阅读&quot;&gt;通过了mUserController这个对象下的handleIncomingUser函数校验，这个函数会自己在通过UserHandle.getCallingUserId()获取一遍userid，与传入参数的userId做校验，如果一支便返回，所以我们用普通用户的话，这个userId便是0了。随后转交给了ActivityStarter这个类来正式执行开启过程，首先第一站便是startActivityMayWait函数，接下来如果函数过长，我会在代码上加注释，方便阅读。&lt;/h3&gt;
&lt;h3 id=&quot;这个函数的参数也开始变得非常多了因为后续涉及到的功能太广了我会把我所知的都写出来分享给大家&quot;&gt;这个函数的参数也开始变得非常多了。因为后续涉及到的功能太广了，我会把我所知的都写出来分享给大家&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Instant App&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            TaskRecord inTask, String reason) {
        if (intent != null &amp;amp;&amp;amp; intent.hasFileDescriptors()) {
            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
        }
        mSupervisor.mActivityMetricsLogger.notifyActivityLaunching();
        boolean componentSpecified = intent.getComponent() != null;

        // Save a copy in case ephemeral needs it
        final Intent ephemeralIntent = new Intent(intent);
        // Don't modify the client's object!
        intent = new Intent(intent);
        //判断是否为 instant app，instant app可以通过URL打开，不需要component，所以置为null
        //关于 instant app，大家可以去查询一下资料哦
        if (componentSpecified
                &amp;amp;&amp;amp; intent.getData() != null
                &amp;amp;&amp;amp; Intent.ACTION_VIEW.equals(intent.getAction())
                &amp;amp;&amp;amp; mService.getPackageManagerInternalLocked()
                        .isInstantAppInstallerComponent(intent.getComponent())) {
            // intercept intents targeted directly to the ephemeral installer the
            // ephemeral installer should never be started with a raw URL; instead
            // adjust the intent so it looks like a &quot;normal&quot; instant app launch
            intent.setComponent(null /*component*/);
            componentSpecified = false;
        }

        //通过Pms（PackageManagerService），并且通过我们传递过来的intent去查询目标页面的R
        //esolveInfo。这个类里放了ActivityInfo、ServiceInfo、ProviderInfo，大家可以在
        //demo中通过PackageManager.resolveActivity函数来获取该对象
        ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
        if (rInfo == null) {
            UserInfo userInfo = mSupervisor.getUserInfo(userId);
            if (userInfo != null &amp;amp;&amp;amp; userInfo.isManagedProfile()) {
                // Special case for managed profiles, if attempting to launch non-cryto aware
                // app in a locked managed profile from an unlocked parent allow it to resolve
                // as user will be sent via confirm credentials to unlock the profile.
                UserManager userManager = UserManager.get(mService.mContext);
                boolean profileLockedAndParentUnlockingOrUnlocked = false;
                long token = Binder.clearCallingIdentity();
                try {
                    UserInfo parent = userManager.getProfileParent(userId);
                    profileLockedAndParentUnlockingOrUnlocked = (parent != null)
                            &amp;amp;&amp;amp; userManager.isUserUnlockingOrUnlocked(parent.id)
                            &amp;amp;&amp;amp; !userManager.isUserUnlockingOrUnlocked(userId);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
                if (profileLockedAndParentUnlockingOrUnlocked) {
                    rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,
                            PackageManager.MATCH_DIRECT_BOOT_AWARE
                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
                }
            }
        }
        // 这块便是通过解析ResolveInfo，得到ActivityInfo对象，这个ActivityInfo大家应该比较熟悉了。就是我们开发中偶尔也会用到ActivityInfo
        ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);

        // 这个便是通过解析bundle，查看是否有对activity的启动要求，比如动画之类附加属性，
        // 当然了，我们的bundle都是null了，options自然也会是null
        ActivityOptions options = ActivityOptions.fromBundle(bOptions);
        synchronized (mService) {
            //这块通过Binder获取到了真实的pid和uid，便把行参中的uid和pid置为了-1
            //因为callingUid在在调用该方法的时候被传入了-1，大家可以去上边仔细看看
            // caller是不会为空的。它是我们的应用标示，IApplicationThread对象
            final int realCallingPid = Binder.getCallingPid();
            final int realCallingUid = Binder.getCallingUid();
            int callingPid;
            if (callingUid &amp;gt;= 0) {
                callingPid = -1;
            } else if (caller == null) {
                callingPid = realCallingPid;
                callingUid = realCallingUid;
            } else {
                callingPid = callingUid = -1;
            }

            final ActivityStack stack = mSupervisor.mFocusedStack;
            stack.mConfigWillChange = globalConfig != null
                    &amp;amp;&amp;amp; mService.getGlobalConfiguration().diff(globalConfig) != 0;

            final long origId = Binder.clearCallingIdentity();

            //这块是一个系统级别的判断，我们普通的应用是没有权限使用PRIVATE_FLAG_CANT_SAVE_STATE这个标记的，这块是对重量级线程的处理过程，由于是系统级别的处理，我就没仔细研读，抱歉啦～大概意思便是替换了intent，换上了新的配置
            if (aInfo != null &amp;amp;&amp;amp;
                    (aInfo.applicationInfo.privateFlags
                            &amp;amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
                // This may be a heavy-weight process!  Check to see if we already
                // have another, different heavy-weight process running.
                if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
                    final ProcessRecord heavy = mService.mHeavyWeightProcess;
                    if (heavy != null &amp;amp;&amp;amp; (heavy.info.uid != aInfo.applicationInfo.uid
                            || !heavy.processName.equals(aInfo.processName))) {
                        int appCallingUid = callingUid;
                        if (caller != null) {
                            ProcessRecord callerApp = mService.getRecordForAppLocked(caller);
                            if (callerApp != null) {
                                appCallingUid = callerApp.info.uid;
                            } else {
                                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                                        + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                                        + intent.toString());
                                ActivityOptions.abort(options);
                                return ActivityManager.START_PERMISSION_DENIED;
                            }
                        }

                        IIntentSender target = mService.getIntentSenderLocked(
                                ActivityManager.INTENT_SENDER_ACTIVITY, &quot;android&quot;,
                                appCallingUid, userId, null, null, 0, new Intent[] { intent },
                                new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT
                                        | PendingIntent.FLAG_ONE_SHOT, null);

                        Intent newIntent = new Intent();
                        if (requestCode &amp;gt;= 0) {
                            // Caller is requesting a result.
                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);
                        }
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,
                                new IntentSender(target));
                        if (heavy.activities.size() &amp;gt; 0) {
                            ActivityRecord hist = heavy.activities.get(0);
                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,
                                    hist.packageName);
                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,
                                    hist.getTask().taskId);
                        }
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,
                                aInfo.packageName);
                        newIntent.setFlags(intent.getFlags());
                        newIntent.setClassName(&quot;android&quot;,
                                HeavyWeightSwitcherActivity.class.getName());
                        intent = newIntent;
                        resolvedType = null;
                        caller = null;
                        callingUid = Binder.getCallingUid();
                        callingPid = Binder.getCallingPid();
                        componentSpecified = true;
                        rInfo = mSupervisor.resolveIntent(intent, null /*resolvedType*/, userId);
                        aInfo = rInfo != null ? rInfo.activityInfo : null;
                        if (aInfo != null) {
                            aInfo = mService.getActivityInfoForUser(aInfo, userId);
                        }
                    }
                }
            }

            //此处创建一个ActivityRecord数组，然后startActivityLocked会填充上0索引，以便于执行完了startActivityLocked函数后保存对象并作后边的处理工作，这个小技巧大家也可以在日常开发中用到，并不是只有返回值哦～
            //我们可以去下一站了，去startActivityLocked内了
            final ActivityRecord[] outRecord = new ActivityRecord[1];
            int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,
                    reason);

            Binder.restoreCallingIdentity(origId);

            if (stack.mConfigWillChange) {
                // If the caller also wants to switch to a new configuration,
                // do so now.  This allows a clean switch, as we are waiting
                // for the current activity to pause (so we will not destroy
                // it), and have not yet started the next activity.
                mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,
                        &quot;updateConfiguration()&quot;);
                stack.mConfigWillChange = false;
                if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,
                        &quot;Updating to new configuration after starting activity.&quot;);
                mService.updateConfigurationLocked(globalConfig, null, false);
            }

            if (outResult != null) {
                outResult.result = res;
                if (res == ActivityManager.START_SUCCESS) {
                    mSupervisor.mWaitingActivityLaunched.add(outResult);
                    do {
                        try {
                            mService.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (outResult.result != START_TASK_TO_FRONT
                            &amp;amp;&amp;amp; !outResult.timeout &amp;amp;&amp;amp; outResult.who == null);
                    if (outResult.result == START_TASK_TO_FRONT) {
                        res = START_TASK_TO_FRONT;
                    }
                }
                if (res == START_TASK_TO_FRONT) {
                    final ActivityRecord r = outRecord[0];

                    // ActivityRecord may represent a different activity, but it should not be in
                    // the resumed state.
                    if (r.nowVisible &amp;amp;&amp;amp; r.state == RESUMED) {
                        outResult.timeout = false;
                        outResult.who = r.realActivity;
                        outResult.totalTime = 0;
                        outResult.thisTime = 0;
                    } else {
                        outResult.thisTime = SystemClock.uptimeMillis();
                        mSupervisor.waitActivityVisible(r.realActivity, outResult);
                        // Note: the timeout variable is not currently not ever set.
                        do {
                            try {
                                mService.wait();
                            } catch (InterruptedException e) {
                            }
                        } while (!outResult.timeout &amp;amp;&amp;amp; outResult.who == null);
                    }
                }
            }

            mSupervisor.mActivityMetricsLogger.notifyActivityLaunched(res, outRecord[0]);
            return res;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;虽然有很多注释看完这个方法我还是在做一个总结吧&quot;&gt;虽然有很多注释，看完这个方法我还是在做一个总结吧&lt;/h3&gt;
&lt;h3 id=&quot;这个函数做了两件重要的事情一个是获取resolveinfo一个是获取activityinfo就是目标activity的基本信息我们继续研读startactivitylocked函数吧&quot;&gt;这个函数做了两件重要的事情，一个是获取ResolveInfo，一个是获取ActivityInfo，就是目标Activity的基本信息。我们继续研读startActivityLocked函数吧&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, TaskRecord inTask, String reason) {

        if (TextUtils.isEmpty(reason)) {
            throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);
        }
        //记录时间，然后转发请求
        mLastStartReason = reason;
        mLastStartActivityTimeMs = System.currentTimeMillis();
        mLastStartActivityRecord[0] = null;

        //跳入startActivity函数中
        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                inTask);

        if (outActivity != null) {
            // mLastStartActivityRecord[0] is set in the call to startActivity above.
            outActivity[0] = mLastStartActivityRecord[0];
        }

        // Aborted results are treated as successes externally, but we must track them internally.
        return mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这一站仅仅是记录时间然后清空mlaststartactivityrecord数组的位置为即将要启动的activity腾位置我们继续向下看startactivity吧又是一个很长的函数预警预警&quot;&gt;这一站仅仅是记录时间，然后清空mLastStartActivityRecord数组的位置，为即将要启动的Activity腾位置，我们继续向下看startActivity吧，又是一个很长的函数～预警预警&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, TaskRecord inTask) {

        int err = ActivityManager.START_SUCCESS;
        // Pull the optional Ephemeral Installer-only bundle out of the options early.
        final Bundle verificationBundle
                = options != null ? options.popAppVerificationBundle() : null;
        //获取我们应用的进程描述类ProcessRecord对象，获取原理是先获取所有进程
        //然后用我们的caller和ProcessRecord下的thread对象做对比，如果是同一个便可以作为返回结果返回出来了
        ProcessRecord callerApp = null;
        if (caller != null) {
            callerApp = mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
                callingPid = callerApp.pid;
                callingUid = callerApp.info.uid;
            } else {
                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                        + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                        + intent.toString());
                err = ActivityManager.START_PERMISSION_DENIED;
            }
        }

        //又一次获取了userId～～～
        final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;

        if (err == ActivityManager.START_SUCCESS) {
            Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true, true, false)
                    + &quot;} from uid &quot; + callingUid);
        }
        //这个resultTo就是我们的mToken对象，然后isInAnyStackLocked的作用便是获取Token
        //上弱引用的ActivityRecord对象，这样就得到了我们启动者的ActivityRecord对象了，就是//我们例子中的MainActivity的ActivityRecord对象
        //这块是处理startActivityForResult的逻辑，resultRecord是哪个Activity的信息，就会调用哪个Activity的onActivityResult函数，在requestCode大于等于0的情况，它存的是我们的MainActivity
        ActivityRecord sourceRecord = null;
        ActivityRecord resultRecord = null;
        if (resultTo != null) {
            sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                    &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);
            if (sourceRecord != null) {
                if (requestCode &amp;gt;= 0 &amp;amp;&amp;amp; !sourceRecord.finishing) {
                    resultRecord = sourceRecord;
                }
            }
        }

        final int launchFlags = intent.getFlags();

        //FLAG_ACTIVITY_FORWARD_RESULT这个标记允许我们把startActivityForResult的线路
        //拉长，比如A-&amp;gt;B-&amp;gt;C，然后C可以直接把值传递到A
        if ((launchFlags &amp;amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;amp;&amp;amp; sourceRecord != null) {
            // Transfer the result target from the source activity to the new
            // one being started, including any failures.
            if (requestCode &amp;gt;= 0) {
                ActivityOptions.abort(options);
                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
            }
            resultRecord = sourceRecord.resultTo;
            if (resultRecord != null &amp;amp;&amp;amp; !resultRecord.isInStackLocked()) {
                resultRecord = null;
            }
            resultWho = sourceRecord.resultWho;
            requestCode = sourceRecord.requestCode;
            sourceRecord.resultTo = null;
            if (resultRecord != null) {
                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);
            }
            if (sourceRecord.launchedFromUid == callingUid) {
                // The new activity is being launched from the same uid as the previous
                // activity in the flow, and asking to forward its result back to the
                // previous.  In this case the activity is serving as a trampoline between
                // the two, so we also want to update its launchedFromPackage to be the
                // same as the previous activity.  Note that this is safe, since we know
                // these two packages come from the same uid; the caller could just as
                // well have supplied that same package name itself.  This specifially
                // deals with the case of an intent picker/chooser being launched in the app
                // flow to redirect to an activity picked by the user, where we want the final
                // activity to consider it to have been launched by the previous app activity.
                callingPackage = sourceRecord.launchedFromPackage;
            }
        }
        //接下来开始做一些校验判断
        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; intent.getComponent() == null) {
            // We couldn't find a class that can handle the given Intent.
            // That's the end of that!
            err = ActivityManager.START_INTENT_NOT_RESOLVED;
        }

        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; aInfo == null) {
            // We couldn't find the specific class specified in the Intent.
            // Also the end of the line.
            err = ActivityManager.START_CLASS_NOT_FOUND;
        }

        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; sourceRecord != null
                &amp;amp;&amp;amp; sourceRecord.getTask().voiceSession != null) {
            // If this activity is being launched as part of a voice session, we need
            // to ensure that it is safe to do so.  If the upcoming activity will also
            // be part of the voice session, we can only launch it if it has explicitly
            // said it supports the VOICE category, or it is a part of the calling app.
            if ((launchFlags &amp;amp; FLAG_ACTIVITY_NEW_TASK) == 0
                    &amp;amp;&amp;amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) {
                try {
                    intent.addCategory(Intent.CATEGORY_VOICE);
                    if (!AppGlobals.getPackageManager().activitySupportsIntent(
                            intent.getComponent(), intent, resolvedType)) {
                        Slog.w(TAG,
                                &quot;Activity being started in current voice task does not support voice: &quot;
                                        + intent);
                        err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
                    }
                } catch (RemoteException e) {
                    Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
                }
            }
        }

        if (err == ActivityManager.START_SUCCESS &amp;amp;&amp;amp; voiceSession != null) {
            // If the caller is starting a new voice session, just make sure the target
            // is actually allowing it to run this way.
            try {
                if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(),
                        intent, resolvedType)) {
                    Slog.w(TAG,
                            &quot;Activity being started in new voice task does not support: &quot;
                                    + intent);
                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
                }
            } catch (RemoteException e) {
                Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
            }
        }

        final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();

        if (err != START_SUCCESS) {
            if (resultRecord != null) {
                resultStack.sendActivityResultLocked(
                        -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);
            }
            ActivityOptions.abort(options);
            return err;
        }

        //校验当前应用是否有开启权限，我们的普通开启肯定是有权限啦，所以可以忽略啦
        boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,
                requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp,
                resultRecord, resultStack, options);
        abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,
                callingPid, resolvedType, aInfo.applicationInfo);

        if (mService.mController != null) {
            try {
                // The Intent we give to the watcher has the extra data
                // stripped off, since it can contain private information.
                Intent watchIntent = intent.cloneFilter();
                abort |= !mService.mController.activityStarting(watchIntent,
                        aInfo.applicationInfo.packageName);
            } catch (RemoteException e) {
                mService.mController = null;
            }
        }

        mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);
        mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid,
                options);
        intent = mInterceptor.mIntent;
        rInfo = mInterceptor.mRInfo;
        aInfo = mInterceptor.mAInfo;
        resolvedType = mInterceptor.mResolvedType;
        inTask = mInterceptor.mInTask;
        callingPid = mInterceptor.mCallingPid;
        callingUid = mInterceptor.mCallingUid;
        options = mInterceptor.mActivityOptions;

        if (abort) {
            if (resultRecord != null) {
                resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,
                        RESULT_CANCELED, null);
            }
            // We pretend to the caller that it was really started, but
            // they will just get a cancel result.
            ActivityOptions.abort(options);
            return START_ABORTED;
        }

        // If permissions need a review before any of the app components can run, we
        // launch the review activity and pass a pending intent to start the activity
        // we are to launching now after the review is completed.
        if (mService.mPermissionReviewRequired &amp;amp;&amp;amp; aInfo != null) {
            if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(
                    aInfo.packageName, userId)) {
                IIntentSender target = mService.getIntentSenderLocked(
                        ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,
                        callingUid, userId, null, null, 0, new Intent[]{intent},
                        new String[]{resolvedType}, PendingIntent.FLAG_CANCEL_CURRENT
                                | PendingIntent.FLAG_ONE_SHOT, null);

                final int flags = intent.getFlags();
                Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
                newIntent.setFlags(flags
                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
                newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);
                newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target));
                if (resultRecord != null) {
                    newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true);
                }
                intent = newIntent;

                resolvedType = null;
                callingUid = realCallingUid;
                callingPid = realCallingPid;

                rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
                aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,
                        null /*profilerInfo*/);

                if (DEBUG_PERMISSIONS_REVIEW) {
                    Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true,
                            true, false) + &quot;} from uid &quot; + callingUid + &quot; on display &quot;
                            + (mSupervisor.mFocusedStack == null
                            ? DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId));
                }
            }
        }

        // If we have an ephemeral app, abort the process of launching the resolved intent.
        // Instead, launch the ephemeral installer. Once the installer is finished, it
        // starts either the intent we resolved here [on install error] or the ephemeral
        // app [on install success].
        if (rInfo != null &amp;amp;&amp;amp; rInfo.auxiliaryInfo != null) {
            intent = createLaunchIntent(rInfo.auxiliaryInfo, ephemeralIntent,
                    callingPackage, verificationBundle, resolvedType, userId);
            resolvedType = null;
            callingUid = realCallingUid;
            callingPid = realCallingPid;

            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/);
        }

        //创建出我们的目标ActivityRecord对象，存到传入数组0索引上
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,
                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),
                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,
                mSupervisor, options, sourceRecord);
        if (outActivity != null) {
            outActivity[0] = r;
        }

        if (r.appTimeTracker == null &amp;amp;&amp;amp; sourceRecord != null) {
            // If the caller didn't specify an explicit time tracker, we want to continue
            // tracking under any it has.
            r.appTimeTracker = sourceRecord.appTimeTracker;
        }

        final ActivityStack stack = mSupervisor.mFocusedStack;
        if (voiceSession == null &amp;amp;&amp;amp; (stack.mResumedActivity == null
                || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {
            if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,
                    realCallingPid, realCallingUid, &quot;Activity start&quot;)) {
                PendingActivityLaunch pal =  new PendingActivityLaunch(r,
                        sourceRecord, startFlags, stack, callerApp);
                mPendingActivityLaunches.add(pal);
                ActivityOptions.abort(options);
                return ActivityManager.START_SWITCHES_CANCELED;
            }
        }

        if (mService.mDidAppSwitch) {
            // This is the second allowed switch since we stopped switches,
            // so now just generally allow switches.  Use case: user presses
            // home (switches disabled, switch to home, mDidAppSwitch now true);
            // user taps a home icon (coming from home so allowed, we hit here
            // and now allow anyone to switch again).
            mService.mAppSwitchesAllowedTime = 0;
        } else {
            mService.mDidAppSwitch = true;
        }

        //检查是否有需要延迟启动的Activity，如果有，则启动
        doPendingActivityLaunchesLocked(false);

        //跳转到另外一个startActivity函数中继续执行
        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,
                options, inTask, outActivity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个函数就分析完了写的很长但是逻辑并不复杂主要就是处理startactivityforresult的逻辑和校验权限最后还创建了一个目标activity的activityrecord对象就完了我们继续看下一个重载函数&quot;&gt;这个函数就分析完了，写的很长，但是逻辑并不复杂，主要就是处理startActivityForResult的逻辑和校验权限，最后还创建了一个目标activity的ActivityRecord对象就完了。我们继续看下一个重载函数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {

        int result = START_CANCELED;
        try {
            //阻塞一下Surface
            mService.mWindowManager.deferSurfaceLayout();
            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                    startFlags, doResume, options, inTask, outActivity);
        } finally {
            // If we are not able to proceed, disassociate the activity from the task. Leaving an
            // activity in an incomplete state can lead to issues, such as performing operations
            // without a window container.
            if (!ActivityManager.isStartResultSuccessful(result)
                    &amp;amp;&amp;amp; mStartActivity.getTask() != null) {
                mStartActivity.getTask().removeActivity(mStartActivity);
            }
            mService.mWindowManager.continueSurfaceLayout();
        }

        postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,
                mTargetStack);

        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个函数很简单也只是通知wmswindowmanagerservice阻塞一下surface然后就转发到了startactivityunchecked函数中继续处理了我们接着看startactivityunchecked的实现吧&quot;&gt;这个函数很简单，也只是通知Wms（WindowManagerService）阻塞一下Surface，然后就转发到了startActivityUnchecked函数中继续处理了，我们接着看startActivityUnchecked的实现吧。&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {

        //根据启动intent识别启动模式，如果是startActivityForResult并且启动模式是NEW_TASK的话，就会让startActivityForResult的回调失效
        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,
                voiceInteractor);

        //判断启动模式，并且在mLaunchFlags上追加对应的标记
        computeLaunchingTaskFlags();

        //获取到Activity的启动栈
        computeSourceStack();

        //根据上面的计算，应用识别到的flags
        mIntent.setFlags(mLaunchFlags);

        ActivityRecord reusedActivity = getReusableIntentActivity();

        final int preferredLaunchStackId =
                (mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
        final int preferredLaunchDisplayId =
                (mOptions != null) ? mOptions.getLaunchDisplayId() : DEFAULT_DISPLAY;

        if (reusedActivity != null) {
            // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but
            // still needs to be a lock task mode violation since the task gets cleared out and
            // the device would otherwise leave the locked task.
            if (mSupervisor.isLockTaskModeViolation(reusedActivity.getTask(),
                    (mLaunchFlags &amp;amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))
                            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
                mSupervisor.showLockTaskToast();
                Slog.e(TAG, &quot;startActivityUnchecked: Attempt to violate Lock Task Mode&quot;);
                return START_RETURN_LOCK_TASK_MODE_VIOLATION;
            }

            if (mStartActivity.getTask() == null) {
                mStartActivity.setTask(reusedActivity.getTask());
            }
            if (reusedActivity.getTask().intent == null) {
                // This task was started because of movement of the activity based on affinity...
                // Now that we are actually launching it, we can assign the base intent.
                reusedActivity.getTask().setIntent(mStartActivity);
            }

            // This code path leads to delivering a new intent, we want to make sure we schedule it
            // as the first operation, in case the activity will be resumed as a result of later
            // operations.
            if ((mLaunchFlags &amp;amp; FLAG_ACTIVITY_CLEAR_TOP) != 0
                    || isDocumentLaunchesIntoExisting(mLaunchFlags)
                    || mLaunchSingleInstance || mLaunchSingleTask) {
                final TaskRecord task = reusedActivity.getTask();

                // In this situation we want to remove all activities from the task up to the one
                // being started. In most cases this means we are resetting the task to its initial
                // state.
                final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,
                        mLaunchFlags);

                // The above code can remove {@code reusedActivity} from the task, leading to the
                // the {@code ActivityRecord} removing its reference to the {@code TaskRecord}. The
                // task reference is needed in the call below to
                // {@link setTargetStackAndMoveToFrontIfNeeded}.
                if (reusedActivity.getTask() == null) {
                    reusedActivity.setTask(task);
                }

                if (top != null) {
                    if (top.frontOfTask) {
                        // Activity aliases may mean we use different intents for the top activity,
                        // so make sure the task now has the identity of the new intent.
                        top.getTask().setIntent(mStartActivity);
                    }
                    deliverNewIntent(top);
                }
            }

            sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity);

            reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);

            final ActivityRecord outResult =
                    outActivity != null &amp;amp;&amp;amp; outActivity.length &amp;gt; 0 ? outActivity[0] : null;

            // When there is a reused activity and the current result is a trampoline activity,
            // set the reused activity as the result.
            if (outResult != null &amp;amp;&amp;amp; (outResult.finishing || outResult.noDisplay)) {
                outActivity[0] = reusedActivity;
            }

            if ((mStartFlags &amp;amp; START_FLAG_ONLY_IF_NEEDED) != 0) {
                // We don't need to start a new activity, and the client said not to do anything
                // if that is the case, so this is it!  And for paranoia, make sure we have
                // correctly resumed the top activity.
                resumeTargetStackIfNeeded();
                return START_RETURN_INTENT_TO_CALLER;
            }
            setTaskFromIntentActivity(reusedActivity);

            if (!mAddingToTask &amp;amp;&amp;amp; mReuseTask == null) {
                // We didn't do anything...  but it was needed (a.k.a., client don't use that
                // intent!)  And for paranoia, make sure we have correctly resumed the top activity.
                resumeTargetStackIfNeeded();
                if (outActivity != null &amp;amp;&amp;amp; outActivity.length &amp;gt; 0) {
                    outActivity[0] = reusedActivity;
                }

                return START_TASK_TO_FRONT;
            }
        }

        //校验目标页面的包名，很有可能是没有安装该应用
        if (mStartActivity.packageName == null) {
            final ActivityStack sourceStack = mStartActivity.resultTo != null
                    ? mStartActivity.resultTo.getStack() : null;
            if (sourceStack != null) {
                sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo,
                        mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED,
                        null /* data */);
            }
            ActivityOptions.abort(mOptions);
            return START_CLASS_NOT_FOUND;
        }

        // If the activity being launched is the same as the one currently at the top, then
        // we need to check if it should only be launched once.
        final ActivityStack topStack = mSupervisor.mFocusedStack;
        final ActivityRecord topFocused = topStack.topActivity();
        final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);
        final boolean dontStart = top != null &amp;amp;&amp;amp; mStartActivity.resultTo == null
                &amp;amp;&amp;amp; top.realActivity.equals(mStartActivity.realActivity)
                &amp;amp;&amp;amp; top.userId == mStartActivity.userId
                &amp;amp;&amp;amp; top.app != null &amp;amp;&amp;amp; top.app.thread != null
                &amp;amp;&amp;amp; ((mLaunchFlags &amp;amp; FLAG_ACTIVITY_SINGLE_TOP) != 0
                || mLaunchSingleTop || mLaunchSingleTask);
        if (dontStart) {
            // For paranoia, make sure we have correctly resumed the top activity.
            topStack.mLastPausedActivity = null;
            if (mDoResume) {
                mSupervisor.resumeFocusedStackTopActivityLocked();
            }
            ActivityOptions.abort(mOptions);
            if ((mStartFlags &amp;amp; START_FLAG_ONLY_IF_NEEDED) != 0) {
                // We don't need to start a new activity, and the client said not to do
                // anything if that is the case, so this is it!
                return START_RETURN_INTENT_TO_CALLER;
            }

            deliverNewIntent(top);

            // Don't use mStartActivity.task to show the toast. We're not starting a new activity
            // but reusing 'top'. Fields in mStartActivity may not be fully initialized.
            mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredLaunchStackId,
                    preferredLaunchDisplayId, topStack.mStackId);

            return START_DELIVERED_TO_TOP;
        }

        //接下来判断是否需要新创建一个task出来，比如NEW_TASK
        //如果不需要新建就直接把目标Activity放入到对应的task内，在setTaskFromSourceRecord内执行
        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
                ? mSourceRecord.getTask() : null;
        // Should this be considered a new task?
        int result = START_SUCCESS;
        if (mStartActivity.resultTo == null &amp;amp;&amp;amp; mInTask == null &amp;amp;&amp;amp; !mAddingToTask
                &amp;amp;&amp;amp; (mLaunchFlags &amp;amp; FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            result = setTaskFromReuseOrCreateNewTask(
                    taskToAffiliate, preferredLaunchStackId, topStack);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            setTaskToCurrentTopOrCreateNewTask();
        }
        if (result != START_SUCCESS) {
            return result;
        }

        mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName,
                mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);
        mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent,
                mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));
        if (mSourceRecord != null) {
            mStartActivity.getTask().setTaskToReturnTo(mSourceRecord);
        }
        if (newTask) {
            EventLog.writeEvent(
                    EventLogTags.AM_CREATE_TASK, mStartActivity.userId,
                    mStartActivity.getTask().taskId);
        }
        ActivityStack.logStartActivity(
                EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask());
        mTargetStack.mLastPausedActivity = null;

        //判断是否需要发送警告（PowerManager实现），判断依据是resumedActivity被回收或者是进程被杀死或者是目标Activity的进程和resumedActivity的进程不一致的时候
        sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity);

        //处理新增Task和启动动画的问题
        mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,
                mOptions);
        //处理完启动栈任务栈的问题后，准备执行发起者的Resume状态了
        if (mDoResume) {
            final ActivityRecord topTaskActivity =
                    mStartActivity.getTask().topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null &amp;amp;&amp;amp; topTaskActivity.mTaskOverlay
                    &amp;amp;&amp;amp; mStartActivity != topTaskActivity)) {
                // If the activity is not focusable, we can't resume it, but still would like to
                // make sure it becomes visible as it starts (this will also trigger entry
                // animation). An example of this are PIP activities.
                // Also, we don't want to resume activities in a task that currently has an overlay
                // as the starting activity just needs to be in the visible paused state until the
                // over is removed.
                mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
                // Go ahead and tell window manager to execute app transition for this activity
                // since the app transition will not be triggered through the resume channel.
                mWindowManager.executeAppTransition();
            } else {
                // If the target stack was not previously focusable (previous top running activity
                // on that stack was not visible) then any prior calls to move the stack to the
                // will not update the focused stack.  If starting the new activity now allows the
                // task stack to be focusable, then ensure that we now update the focused stack
                // accordingly.
                if (mTargetStack.isFocusable() &amp;amp;&amp;amp; !mSupervisor.isFocusedStack(mTargetStack)) {
                    mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);
                }
                //从这开始resume我们的MainActivity
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }
        } else {
            mTargetStack.addRecentActivityLocked(mStartActivity);
        }
        mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);

        mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredLaunchStackId,
                preferredLaunchDisplayId, mTargetStack.mStackId);

        return START_SUCCESS;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个startactivityunchecked做的核心功能就是识别并且处理启动模式以及关联的启动栈任务栈最后选择完合适的任务栈后就准备调用resumefocusedstacktopactivitylocked继续开启activity我们来继续往下看&quot;&gt;这个startActivityUnchecked做的核心功能就是识别并且处理启动模式，以及关联的启动栈、任务栈，最后选择完合适的任务栈后就准备调用resumeFocusedStackTopActivityLocked继续开启Activity，我们来继续往下看。&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {

        if (!readyToResume()) {
            return false;
        }

        if (targetStack != null &amp;amp;&amp;amp; isFocusedStack(targetStack)) {
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }

        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        } else if (r.state == RESUMED) {
            // Kick off any lingering app transitions form the MoveTaskToFront operation.
            mFocusedStack.executeAppTransition(targetOptions);
        }

        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个resumefocusedstacktopactivitylocked函数定义在activitystacksupervisor类中从类名上可以看得出来这个是个管理者不参与具体实现所以函数也很短只是做简单的校验就立马转发很符合企业里领导的身份我们看紧接着就被转发到了activitystack下的resumetopactivityuncheckedlocked中了下面这个就是activitystack下的resumetopactivityuncheckedlocked函数了&quot;&gt;这个resumeFocusedStackTopActivityLocked函数定义在ActivityStackSupervisor类中，从类名上可以看得出来这个是个管理者，不参与具体实现，所以函数也很短，只是做简单的校验就立马转发，很符合企业里领导的身份。我们看紧接着就被转发到了ActivityStack下的resumeTopActivityUncheckedLocked中了，下面这个就是ActivityStack下的resumeTopActivityUncheckedLocked函数了&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mStackSupervisor.inResumeTopActivity) {
            // Don't even start recursing.
            return false;
        }

        boolean result = false;
        try {
            // Protect against recursion.
            mStackSupervisor.inResumeTopActivity = true;
            result = resumeTopActivityInnerLocked(prev, options);
        } finally {
            mStackSupervisor.inResumeTopActivity = false;
        }

        // When resuming the top activity, it may be necessary to pause the top activity (for
        // example, returning to the lock screen. We suppress the normal pause logic in
        // {@link #resumeTopActivityUncheckedLocked}, since the top activity is resumed at the end.
        // We call the {@link ActivityStackSupervisor#checkReadyForSleepLocked} again here to ensure
        // any necessary pause logic occurs. In the case where the Activity will be shown regardless
        // of the lock screen, the call to {@link ActivityStackSupervisor#checkReadyForSleepLocked}
        // is skipped.
        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);
        if (next == null || !next.canTurnScreenOn()) {
            checkReadyForSleep();
        }

        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可以看一下他也没做什么业务处理而是转交给了另外一个函数去处理我们继续看&quot;&gt;可以看一下，他也没做什么业务处理。而是转交给了另外一个函数去处理，我们继续看&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
        if (!mService.mBooting &amp;amp;&amp;amp; !mService.mBooted) {
            // Not ready yet!
            return false;
        }

        // Find the next top-most activity to resume in this stack that is not finishing and is
        // focusable. If it is not focusable, we will fall into the case below to resume the
        // 我们的TestActivity已经入栈了，所以next就是我们的TestActivity了
        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);

        final boolean hasRunningActivity = next != null;

        // TODO: Maybe this entire condition can get removed?
        if (hasRunningActivity &amp;amp;&amp;amp; getDisplay() == null) {
            return false;
        }

        mStackSupervisor.cancelInitializingActivities();

        // Remember how we'll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        final boolean userLeaving = mStackSupervisor.mUserLeaving;
        mStackSupervisor.mUserLeaving = false;

        if (!hasRunningActivity) {
            // There are no activities left in the stack, let's look somewhere else.
            return resumeTopActivityInNextFocusableStack(prev, options, &quot;noMoreActivities&quot;);
        }

        next.delayedResume = false;

        // 如果我们要跳转的页面已经是resume状态，那么直接通知Wms执行Activity的过渡
        if (mResumedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.RESUMED &amp;amp;&amp;amp;
                    mStackSupervisor.allResumedActivitiesComplete()) {
            // Make sure we have executed any pending transitions, since there
            // should be nothing left to do at this point.
            executeAppTransition(options);
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    &quot;resumeTopActivityLocked: Top activity resumed &quot; + next);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return false;
        }

        final TaskRecord nextTask = next.getTask();
        final TaskRecord prevTask = prev != null ? prev.getTask() : null;
        if (prevTask != null &amp;amp;&amp;amp; prevTask.getStack() == this &amp;amp;&amp;amp;
                prevTask.isOverHomeStack() &amp;amp;&amp;amp; prev.finishing &amp;amp;&amp;amp; prev.frontOfTask) {
            if (DEBUG_STACK)  mStackSupervisor.validateTopActivitiesLocked();
            if (prevTask == nextTask) {
                prevTask.setFrontOfTask();
            } else if (prevTask != topTask()) {
                // This task is going away but it was supposed to return to the home stack.
                // Now the task above it has to return to the home task instead.
                final int taskNdx = mTaskHistory.indexOf(prevTask) + 1;
                mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE);
            } else if (!isOnHomeDisplay()) {
                return false;
            } else if (!isHomeStack()){
                if (DEBUG_STATES) Slog.d(TAG_STATES,
                        &quot;resumeTopActivityLocked: Launching home next&quot;);
                return isOnHomeDisplay() &amp;amp;&amp;amp;
                        mStackSupervisor.resumeHomeStackTask(prev, &quot;prevFinished&quot;);
            }
        }

        // 判断一下是否已经进入睡眠状态，如果进入睡眠状态Activity也会进入Pause状态
        if (shouldSleepOrShutDownActivities()
                &amp;amp;&amp;amp; mLastPausedActivity == next
                &amp;amp;&amp;amp; mStackSupervisor.allPausedActivitiesComplete()) {
            // Make sure we have executed any pending transitions, since there
            // should be nothing left to do at this point.
            executeAppTransition(options);
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    &quot;resumeTopActivityLocked: Going to sleep and all paused&quot;);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return false;
        }

        // Make sure that the user who owns this activity is started.  If not,
        // we will just leave it as is because someone should be bringing
        // another user's activities to the top of the stack.
        if (!mService.mUserController.hasStartedUserState(next.userId)) {
            Slog.w(TAG, &quot;Skipping resume of top activity &quot; + next
                    + &quot;: user &quot; + next.userId + &quot; is stopped&quot;);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return false;
        }

        // The activity may be waiting for stop, but that is no longer
        // appropriate for it.
        mStackSupervisor.mStoppingActivities.remove(next);
        mStackSupervisor.mGoingToSleepActivities.remove(next);
        next.sleeping = false;
        mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(next);

        if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Resuming &quot; + next);

        // If we are currently pausing an activity, then don't do anything until that is done.
        if (!mStackSupervisor.allPausedActivitiesComplete()) {
            if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,
                    &quot;resumeTopActivityLocked: Skip resume: some activity pausing.&quot;);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return false;
        }

        mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);

        boolean lastResumedCanPip = false;
        final ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();
        if (lastFocusedStack != null &amp;amp;&amp;amp; lastFocusedStack != this) {
            // So, why aren't we using prev here??? See the param comment on the method. prev doesn't
            // represent the last resumed activity. However, the last focus stack does if it isn't null.
            final ActivityRecord lastResumed = lastFocusedStack.mResumedActivity;
            lastResumedCanPip = lastResumed != null &amp;amp;&amp;amp; lastResumed.checkEnterPictureInPictureState(
                    &quot;resumeTopActivity&quot;, userLeaving /* beforeStopping */);
        }
        // If the flag RESUME_WHILE_PAUSING is set, then continue to schedule the previous activity
        // to be paused, while at the same time resuming the new resume activity only if the
        // previous activity can't go into Pip since we want to give Pip activities a chance to
        // enter Pip before resuming the next activity.
        final boolean resumeWhilePausing = (next.info.flags &amp;amp; FLAG_RESUME_WHILE_PAUSING) != 0
                &amp;amp;&amp;amp; !lastResumedCanPip;
        //将发起者置入Pause状态，也就是MainActivity改成onPause状态
        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);
        if (mResumedActivity != null) {
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);
            pausing |= startPausingLocked(userLeaving, false, next, false);
        }
        if (pausing &amp;amp;&amp;amp; !resumeWhilePausing) {
            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,
                    &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);
            // At this point we want to put the upcoming activity's process
            // at the top of the LRU list, since we know we will be needing it
            // very soon and it would be a waste to let it get killed if it
            // happens to be sitting towards the end.
            if (next.app != null &amp;amp;&amp;amp; next.app.thread != null) {
                mService.updateLruProcessLocked(next.app, true, null);
            }
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return true;
        } else if (mResumedActivity == next &amp;amp;&amp;amp; next.state == ActivityState.RESUMED &amp;amp;&amp;amp;
                mStackSupervisor.allResumedActivitiesComplete()) {
            // It is possible for the activity to be resumed when we paused back stacks above if the
            // next activity doesn't have to wait for pause to complete.
            // So, nothing else to-do except:
            // Make sure we have executed any pending transitions, since there
            // should be nothing left to do at this point.
            executeAppTransition(options);
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    &quot;resumeTopActivityLocked: Top activity resumed (dontWaitForPause) &quot; + next);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return true;
        }

        // If the most recent activity was noHistory but was only stopped rather
        // than stopped+finished because the device went to sleep, we need to make
        // sure to finish it as we're making a new activity topmost.
        if (shouldSleepActivities() &amp;amp;&amp;amp; mLastNoHistoryActivity != null &amp;amp;&amp;amp;
                !mLastNoHistoryActivity.finishing) {
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    &quot;no-history finish of &quot; + mLastNoHistoryActivity + &quot; on new resume&quot;);
            requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,
                    null, &quot;resume-no-history&quot;, false);
            mLastNoHistoryActivity = null;
        }

        if (prev != null &amp;amp;&amp;amp; prev != next) {
            if (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)
                    &amp;amp;&amp;amp; next != null &amp;amp;&amp;amp; !next.nowVisible) {
                mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);
                if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,
                        &quot;Resuming top, waiting visible to hide: &quot; + prev);
            } else {
                // The next activity is already visible, so hide the previous
                // activity's windows right now so we can show the new one ASAP.
                // We only do this if the previous is finishing, which should mean
                // it is on top of the one being resumed so hiding it quickly
                // is good.  Otherwise, we want to do the normal route of allowing
                // the resumed activity to be shown so we can decide if the
                // previous should actually be hidden depending on whether the
                // new one is found to be full-screen or not.
                if (prev.finishing) {
                    prev.setVisibility(false);
                    if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,
                            &quot;Not waiting for visible to hide: &quot; + prev + &quot;, waitingVisible=&quot;
                            + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)
                            + &quot;, nowVisible=&quot; + next.nowVisible);
                } else {
                    if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,
                            &quot;Previous already visible but still waiting to hide: &quot; + prev
                            + &quot;, waitingVisible=&quot;
                            + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)
                            + &quot;, nowVisible=&quot; + next.nowVisible);
                }
            }
        }

        // Launching this app's activity, make sure the app is no longer
        // considered stopped.
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(
                    next.packageName, false, next.userId); /* TODO: Verify if correct userid */
        } catch (RemoteException e1) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, &quot;Failed trying to unstop package &quot;
                    + next.packageName + &quot;: &quot; + e);
        }

        // We are starting up the next activity, so tell the window manager
        // that the previous one will be hidden soon.  This way it can know
        // to ignore it when computing the desired screen orientation.
        //这里准备开启页面
        boolean anim = true;
        if (prev != null) {
            if (prev.finishing) {
                if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        &quot;Prepare close transition: prev=&quot; + prev);
                if (mNoAnimActivities.contains(prev)) {
                    anim = false;
                    mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()
                            ? TRANSIT_ACTIVITY_CLOSE
                            : TRANSIT_TASK_CLOSE, false);
                }
                prev.setVisibility(false);
            } else {
                if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        &quot;Prepare open transition: prev=&quot; + prev);
                if (mNoAnimActivities.contains(next)) {
                    anim = false;
                    mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    //准备启动
                    mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()
                            ? TRANSIT_ACTIVITY_OPEN
                            : next.mLaunchTaskBehind
                                    ? TRANSIT_TASK_OPEN_BEHIND
                                    : TRANSIT_TASK_OPEN, false);
                }
            }
        } else {
            if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, &quot;Prepare open transition: no previous&quot;);
            if (mNoAnimActivities.contains(next)) {
                anim = false;
                mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
            } else {
                mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, false);
            }
        }

        Bundle resumeAnimOptions = null;
        if (anim) {
            ActivityOptions opts = next.getOptionsForTargetActivityLocked();
            if (opts != null) {
                resumeAnimOptions = opts.toBundle();
            }
            next.applyOptionsLocked();
        } else {
            next.clearOptionsLocked();
        }

        ActivityStack lastStack = mStackSupervisor.getLastStack();
        if (next.app != null &amp;amp;&amp;amp; next.app.thread != null) {
            if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Resume running: &quot; + next
                    + &quot; stopped=&quot; + next.stopped + &quot; visible=&quot; + next.visible);

            // If the previous activity is translucent, force a visibility update of
            // the next activity, so that it's added to WM's opening app list, and
            // transition animation can be set up properly.
            // For example, pressing Home button with a translucent activity in focus.
            // Launcher is already visible in this case. If we don't add it to opening
            // apps, maybeUpdateTransitToWallpaper() will fail to identify this as a
            // TRANSIT_WALLPAPER_OPEN animation, and run some funny animation.
            final boolean lastActivityTranslucent = lastStack != null
                    &amp;amp;&amp;amp; (!lastStack.mFullscreen
                    || (lastStack.mLastPausedActivity != null
                    &amp;amp;&amp;amp; !lastStack.mLastPausedActivity.fullscreen));
            // The contained logic must be synchronized, since we are both changing the visibility
            // and updating the {@link Configuration}. {@link ActivityRecord#setVisibility} will
            // ultimately cause the client code to schedule a layout. Since layouts retrieve the
            // current {@link Configuration}, we must ensure that the below code updates it before
            // the layout can occur.
            synchronized(mWindowManager.getWindowManagerLock()) {
                // This activity is now becoming visible.
                if (!next.visible || next.stopped || lastActivityTranslucent) {
                    next.setVisibility(true);
                }

                // schedule launch ticks to collect information about slow apps.
                next.startLaunchTickingLocked();

                ActivityRecord lastResumedActivity =
                        lastStack == null ? null :lastStack.mResumedActivity;
                ActivityState lastState = next.state;

                mService.updateCpuStats();

                if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to RESUMED: &quot; + next
                        + &quot; (in existing)&quot;);

                setResumedActivityLocked(next, &quot;resumeTopActivityInnerLocked&quot;);
                //更新进程信息
                mService.updateLruProcessLocked(next.app, true, null);
                updateLRUListLocked(next);
                mService.updateOomAdjLocked();

                // Have the window manager re-evaluate the orientation of
                // the screen based on the new activity order.
                boolean notUpdated = true;

                if (mStackSupervisor.isFocusedStack(this)) {

                    // We have special rotation behavior when Keyguard is locked. Make sure all
                    // activity visibilities are set correctly as well as the transition is updated
                    // if needed to get the correct rotation behavior.
                    // TODO: Remove this once visibilities are set correctly immediately when
                    // starting an activity.
                    if (mStackSupervisor.mKeyguardController.isKeyguardLocked()) {
                        mStackSupervisor.ensureActivitiesVisibleLocked(null /* starting */,
                                0 /* configChanges */, false /* preserveWindows */);
                    }
                    final Configuration config = mWindowManager.updateOrientationFromAppTokens(
                            mStackSupervisor.getDisplayOverrideConfiguration(mDisplayId),
                            next.mayFreezeScreenLocked(next.app) ? next.appToken : null,
                                    mDisplayId);
                    if (config != null) {
                        next.frozenBeforeDestroy = true;
                    }
                    notUpdated = !mService.updateDisplayOverrideConfigurationLocked(config, next,
                            false /* deferResume */, mDisplayId);
                }

                if (notUpdated) {
                    // The configuration update wasn't able to keep the existing
                    // instance of the activity, and instead started a new one.
                    // We should be all done, but let's just make sure our activity
                    // is still at the top and schedule another run if something
                    // weird happened.
                    ActivityRecord nextNext = topRunningActivityLocked();
                    if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG_STATES,
                            &quot;Activity config changed during resume: &quot; + next
                                    + &quot;, new next: &quot; + nextNext);
                    if (nextNext != next) {
                        // Do over!
                        mStackSupervisor.scheduleResumeTopActivities();
                    }
                    if (!next.visible || next.stopped) {
                        next.setVisibility(true);
                    }
                    next.completeResumeLocked();
                    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
                    return true;
                }

                try {
                    // 判断是否需要触发onActivityResult函数
                    ArrayList&amp;lt;ResultInfo&amp;gt; a = next.results;
                    if (a != null) {
                        final int N = a.size();
                        if (!next.finishing &amp;amp;&amp;amp; N &amp;gt; 0) {
                            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                                    &quot;Delivering results to &quot; + next + &quot;: &quot; + a);
                            next.app.thread.scheduleSendResult(next.appToken, a);
                        }
                    }

                    //是否需要触发onNewIntent函数
                    if (next.newIntents != null) {
                        next.app.thread.scheduleNewIntent(
                                next.newIntents, next.appToken, false /* andPause */);
                    }

                    // Well the app will no longer be stopped.
                    // Clear app token stopped state in window manager if needed.
                    next.notifyAppResumed(next.stopped);

                    EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,
                            System.identityHashCode(next), next.getTask().taskId,
                            next.shortComponentName);

                    next.sleeping = false;
                    mService.showUnsupportedZoomDialogIfNeededLocked(next);
                    mService.showAskCompatModeDialogLocked(next);
                    next.app.pendingUiClean = true;
                    next.app.forceProcessStateUpTo(mService.mTopProcessState);
                    next.clearOptionsLocked();
                    //最后通过ActivityThread的scheduleResumeActivity函数进行启动
                    next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                            mService.isNextTransitionForward(), resumeAnimOptions);

                    if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Resumed &quot;
                            + next);
                } catch (Exception e) {
                    // Whoops, need to restart this activity!
                    if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Resume failed; resetting state to &quot;
                            + lastState + &quot;: &quot; + next);
                    next.state = lastState;
                    if (lastStack != null) {
                        lastStack.mResumedActivity = lastResumedActivity;
                    }
                    Slog.i(TAG, &quot;Restarting because process died: &quot; + next);
                    if (!next.hasBeenLaunched) {
                        next.hasBeenLaunched = true;
                    } else  if (SHOW_APP_STARTING_PREVIEW &amp;amp;&amp;amp; lastStack != null &amp;amp;&amp;amp;
                            mStackSupervisor.isFrontStackOnDisplay(lastStack)) {
                        next.showStartingWindow(null /* prev */, false /* newTask */,
                                false /* taskSwitch */);
                    }
                    mStackSupervisor.startSpecificActivityLocked(next, true, false);
                    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
                    return true;
                }
            }

            // From this point on, if something goes wrong there is no way
            // to recover the activity.
            try {
                next.completeResumeLocked();
            } catch (Exception e) {
                // If any exception gets thrown, toss away this
                // activity and try the next one.
                Slog.w(TAG, &quot;Exception thrown during resume of &quot; + next, e);
                requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,
                        &quot;resume-exception&quot;, true);
                if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
                return true;
            }
        } else {
            // Whoops, need to restart this activity!
            if (!next.hasBeenLaunched) {
                next.hasBeenLaunched = true;
            } else {
                if (SHOW_APP_STARTING_PREVIEW) {
                    next.showStartingWindow(null /* prev */, false /* newTask */,
                            false /* taskSwich */);
                }
                if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, &quot;Restarting: &quot; + next);
            }
            if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Restarting &quot; + next);
            mStackSupervisor.startSpecificActivityLocked(next, true, true);
        }

        if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个函数就是对目标页的很多状态判断还有pause我们的启动者然后通知atactivitythread准备启动我们继续查看at内的启动逻辑&quot;&gt;这个函数就是对目标页的很多状态判断，还有pause我们的启动者，然后通知AT（ActivityThread）准备启动，我们继续查看AT内的启动逻辑&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;       @Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List&amp;lt;ResultInfo&amp;gt; pendingResults, List&amp;lt;ReferrerIntent&amp;gt; pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();

            r.token = token;
            r.ident = ident;
            r.intent = intent;
            r.referrer = referrer;
            r.voiceInteractor = voiceInteractor;
            r.activityInfo = info;
            r.compatInfo = compatInfo;
            r.state = state;
            r.persistentState = persistentState;

            r.pendingResults = pendingResults;
            r.pendingIntents = pendingNewIntents;

            r.startsNotResumed = notResumed;
            r.isForward = isForward;

            r.profilerInfo = profilerInfo;

            r.overrideConfig = overrideConfig;
            updatePendingConfiguration(curConfig);

            sendMessage(H.LAUNCH_ACTIVITY, r);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个函数内创建了一个activityclientrecord对象然后通过handler发送命令launch_activity我们看一下命令所对应的函数是什么吧&quot;&gt;这个函数内创建了一个ActivityClientRecord对象，然后通过handler发送命令LAUNCH_ACTIVITY，我们看一下命令所对应的函数是什么吧&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;case LAUNCH_ACTIVITY: {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

    r.packageInfo = getPackageInfoNoCheck(
            r.activityInfo.applicationInfo, r.compatInfo);
    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;这个case下调用了handlelaunchactivity函数我们继续跟进分析&quot;&gt;这个case下调用了handleLaunchActivity函数，我们继续跟进分析&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        if (r.profilerInfo != null) {
            mProfiler.setProfiler(r.profilerInfo);
            mProfiler.startProfiling();
        }

        // Make sure we are running with the most recent config.
        handleConfigurationChanged(null, null);

        if (localLOGV) Slog.v(
            TAG, &quot;Handling launch of &quot; + r);

        // Initialize before creating the activity
        if (!ThreadedRenderer.sRendererDisabled) {
            GraphicsEnvironment.earlyInitEGL();
        }
        WindowManagerGlobal.initialize();

        //通过反射创建Activity的对象
        //并且触发attach、onCreate、onStart生命周期方法
        //此时我们也会自己掉用setContentView来组装DecorView
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            //执行onResume生命周期方法，还会通知ViewRootImpl绘制页面
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished &amp;amp;&amp;amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

            if (!r.activity.mFinished &amp;amp;&amp;amp; r.startsNotResumed) {
                // The activity manager actually wants this one to start out paused, because it
                // needs to be visible but isn't in the foreground. We accomplish this by going
                // through the normal startup (because activities expect to go through onResume()
                // the first time they run, before their window is displayed), and then pausing it.
                // However, in this case we do -not- need to do the full pause cycle (of freezing
                // and such) because the activity manager assumes it can just retain the current
                // state it has.
                performPauseActivityIfNeeded(r, reason);

                // We need to keep around the original state, in case we need to be created again.
                // But we only do this for pre-Honeycomb apps, which always save their state when
                // pausing, so we can not have them save their state when restarting from a paused
                // state. For HC and later, we want to (and can) let the state be saved as the
                // normal part of stopping the activity.
                if (r.isPreHoneycomb()) {
                    r.state = oldState;
                }
            }
        } else {
            // If there was an error, for any reason, tell the activity manager to stop us.
            try {
                ActivityManager.getService()
                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;到此startactivity的完整流程都全部呈现给大家了里边的校验是真的多涉及到的技术面也很广偶尔读读源码还是可以收获很多的上面的每一个判断都是一个知识点有些在开发中可以用到有些判断是给系统app留的&quot;&gt;到此startActivity的完整流程都全部呈现给大家了，里边的校验是真的多。涉及到的技术面也很广，偶尔读读源码还是可以收获很多的，上面的每一个判断，都是一个知识点，有些在开发中可以用到，有些判断是给系统app留的。&lt;/h3&gt;
</description>
<pubDate>Thu, 21 Mar 2019 13:23:00 +0000</pubDate>
<dc:creator>柯壮</dc:creator>
<og:description>应用进程内 如何使用Intent做Activity的跳转 我们通常会这样写，就能跳转到TestActivity中，但是你知道这简简单单的两行代码在我们庞大的安卓系统中经历了怎样的加工处理吗？接下来我带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kezhuang/p/10574747.html</dc:identifier>
</item>
<item>
<title>【杂谈】FilterChain相关知识整理 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/10574734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/10574734.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　做后台的，Filter肯定没少配置，但是知晓其原理的可能不多。在这之前我也不懂，但这并不影响业务开发，同时也有其他的知识要学，所以一直就没看。这阵子有点闲，刚好在看《How Tomcat Works》的PipeLine相关内容。索性好好梳理一下FilterChain相关的知识。&lt;/p&gt;
&lt;h2&gt;类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201903/1313132-20190321205211067-1348359050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;FilterChain的作用&lt;/h2&gt;
&lt;p&gt;顾名思义，FilterChain就是一条过滤链。其中每个过滤器（Filter）都可以决定是否执行下一步。&lt;/p&gt;
&lt;p&gt;过滤分两个方向，进和出：&lt;/p&gt;
&lt;p&gt;进：在把ServletRequest和ServletResponse交给Servlet的service方法之前，需要进行过滤&lt;/p&gt;
&lt;p&gt;出：在service方法完成后，往客户端发送之前，需要进行过滤&lt;/p&gt;
&lt;h2&gt;Filter的定义与配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般，我们定义Filter类一般通过实现Filter接口来完成，然后在doFilter方法中编写自己的过滤逻辑。由于方法参数中有Filter对象所在FilterChain的引用，故可以控制过滤链的进行。但控制内容，只能是&lt;/p&gt;
&lt;p&gt;1.向下执行&lt;/p&gt;
&lt;p&gt;2.不向下执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在老项目中，一般直接在web.xml文件中配置。利用&amp;lt;filter&amp;gt;&amp;lt;/filter&amp;gt;配置过滤器名称，类以及过滤器在链中的位置。&lt;/p&gt;
&lt;p&gt;而在Spring Boot项目中，则可以通过FilterRegisterBean来配置过滤器。&lt;/p&gt;
&lt;h2&gt;FilterChain的执行原理&lt;/h2&gt;
&lt;p&gt;FilterChain的实现类是上图中的ApplicationFilterChain。一个ApplicationFilterChain对象包含几个主要参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;n  =&amp;gt; filter个数&lt;/li&gt;
&lt;li&gt;pos =&amp;gt; 下一个要执行的filter的位置&lt;/li&gt;
&lt;li&gt;Servlet  =&amp;gt; 当pos &amp;gt;= n，即过滤完成时，调用Servlet的service方法，把请求交给Servlet&lt;/li&gt;
&lt;li&gt;filters =&amp;gt; Filter的相关配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多人，可能会疑惑，FilterChain是如何实现向下执行的。其实看到上面那些参数，你估计就已经明白了。即FilterChain持有所有Filter对象到一个数组中，然后通过移动pos，来获取后续的Filter并执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发方式：&lt;/strong&gt;由上一个执行的Filter调用FilterChain的doFilter方法。&lt;/p&gt;
&lt;p&gt;以下是ApplicationFilterChain的doFilter和internalDoFilter方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Invoke the next filter in this chain, passing the specified request
     * and response.  If there are no more filters in this chain, invoke
     * the &amp;lt;code&amp;gt;service()&amp;lt;/code&amp;gt; method of the servlet itself.
     *
     * @param request The servlet request we are processing
     * @param response The servlet response we are creating
     *
     * @exception IOException if an input/output error occurs
     * @exception ServletException if a servlet exception occurs
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest request, ServletResponse response)
        throws IOException, ServletException {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;( Globals.IS_SECURITY_ENABLED ) {
            final ServletRequest req &lt;/span&gt;=&lt;span&gt; request;
            final ServletResponse res &lt;/span&gt;=&lt;span&gt; response;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                java.security.AccessController.doPrivileged(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; java.security.PrivilegedExceptionAction&amp;lt;Void&amp;gt;&lt;span&gt;() {
                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run()
                            throws ServletException, IOException {
                            internalDoFilter(req,res);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                );
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;( PrivilegedActionException pe) {
                Exception e &lt;/span&gt;=&lt;span&gt; pe.getException();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e instanceof ServletException)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (ServletException) e;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e instanceof IOException)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (IOException) e;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e instanceof RuntimeException)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) e;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletException(e.getMessage(), e);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            internalDoFilter(request,response);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; internalDoFilter(ServletRequest request,
                                  ServletResponse response)
        throws IOException, ServletException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call the next filter if there is one&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pos &amp;lt;&lt;span&gt; n) {
            ApplicationFilterConfig filterConfig &lt;/span&gt;= filters[pos++&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Filter filter &lt;/span&gt;=&lt;span&gt; filterConfig.getFilter();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.isAsyncSupported() &amp;amp;&amp;amp; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equalsIgnoreCase(
                        filterConfig.getFilterDef().getAsyncSupported())) {
                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;( Globals.IS_SECURITY_ENABLED ) {
                    final ServletRequest req &lt;/span&gt;=&lt;span&gt; request;
                    final ServletResponse res &lt;/span&gt;=&lt;span&gt; response;
                    Principal principal &lt;/span&gt;=&lt;span&gt;
                        ((HttpServletRequest) req).getUserPrincipal();

                    Object[] args &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Object[]{req, res, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;};
                    SecurityUtil.doAsPrivilege (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filter, classType, args, principal);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    filter.doFilter(request, response, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException | ServletException |&lt;span&gt; RuntimeException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                e &lt;/span&gt;=&lt;span&gt; ExceptionUtils.unwrapInvocationTargetException(e);
                ExceptionUtils.handleThrowable(e);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(sm.getString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterChain.filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), e);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We fell off the end of the chain -- call the servlet instance&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ApplicationDispatcher.WRAP_SAME_OBJECT) {
                lastServicedRequest.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(request);
                lastServicedResponse.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(response);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.isAsyncSupported() &amp;amp;&amp;amp; !&lt;span&gt;servletSupportsAsync) {
                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,
                        Boolean.FALSE);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use potentially wrapped request from this point&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((request instanceof HttpServletRequest) &amp;amp;&amp;amp;&lt;span&gt;
                    (response instanceof HttpServletResponse) &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                    Globals.IS_SECURITY_ENABLED ) {
                final ServletRequest req &lt;/span&gt;=&lt;span&gt; request;
                final ServletResponse res &lt;/span&gt;=&lt;span&gt; response;
                Principal principal &lt;/span&gt;=&lt;span&gt;
                    ((HttpServletRequest) req).getUserPrincipal();
                Object[] args &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{req, res};
                SecurityUtil.doAsPrivilege(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           servlet,
                                           classTypeUsedInService,
                                           args,
                                           principal);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                servlet.service(request, response);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException | ServletException |&lt;span&gt; RuntimeException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            e &lt;/span&gt;=&lt;span&gt; ExceptionUtils.unwrapInvocationTargetException(e);
            ExceptionUtils.handleThrowable(e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(sm.getString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterChain.servlet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ApplicationDispatcher.WRAP_SAME_OBJECT) {
                lastServicedRequest.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                lastServicedResponse.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;FilterChain对象与请求的关系&lt;/h2&gt;
&lt;p&gt;看到上面移动pos（本质上就是++操作），估计有人会跟我一样想到线程安全问题，即FilterChain是否会存在多线程访问的情况。如果存在多线程访问，由于每个线程的过滤进度可能都不一样，必然会互相干扰。&lt;/p&gt;
&lt;p&gt;答案是这样，每个请求都会创建一个新的FilterChain对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：Filter配置是针对整个Web项目的，而每个FilterChain对象是针对每个请求的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我是怎么知道的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;猜测加验证。即定位ApplicationFilterChain的创建操作即可。ApplicationFilterChain对象由ApplicationFilterFactory工厂的createFilterChain方法生成。而这个方法在ApplicationDispatcher的invoke方法内被调用。而这个invoke方法是Connector把新请求传递给Container的方式。&lt;/p&gt;
&lt;h2&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;FilterChain就是典型的责任链模式的实现案例。类似的还有，Tomcat的Pipeline Task，Netty的ChannelPipeline.&lt;/p&gt;

</description>
<pubDate>Thu, 21 Mar 2019 13:22:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 做后台的，Filter肯定没少配置，但是知晓其原理的可能不多。在这之前我也不懂，但这并不影响业务开发，同时也有其他的知识要学，所以一直就没看。这阵子有点闲，刚好在看《How Tomcat Wor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/10574734.html</dc:identifier>
</item>
<item>
<title>对扫描的pdf文件生成目录 - TwoIce</title>
<link>http://www.cnblogs.com/twoice/p/10574668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoice/p/10574668.html</guid>
<description>&lt;p&gt;很多pdf文件是直接扫描生成的，于是它的内容都是一张张的图片，当然就更没有目录索引了。&lt;/p&gt;
&lt;p&gt;有的时候想找某些内容，只能一点点的移动滚动条，非常不方便。&lt;/p&gt;
&lt;p&gt;那么有什么方法能生成目录呢？&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;方法一：使用福昕pdf编辑器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;福昕pdf编辑器使用PRC识别pdf文件，能将pdf文件转换为office文件，更是有目录制作的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;，亲测后发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;也是最关键的问题，他需要money，也就是得升级为会员，才能使用图片识别功能。&lt;/li&gt;
&lt;li&gt;目录制作倒是免费的，但它的目录主要是设置标签，对于目录没有分级功能，且需要一页一页翻的去添加，非常麻烦&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总之，最后的制作非常不理想。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;方法二：使用FreePic2Pdf&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先看一下最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321194522939-2090953893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我使用的是《同济大学高等数学第六版上册.pdf》,打开pdf的软件是2345看图王，也可以用chrome打开。&lt;/p&gt;
&lt;p&gt;怎么样，效果是不是非常良好。&lt;/p&gt;
&lt;p&gt;FreePic2Pdf这是一个图片转pdf文件，但主要使用的是它的更改pdf的功能。&lt;/p&gt;
&lt;p&gt;至于下载地址就不提供了（因为没找到它的官网），网上一搜一堆，第三方下载地址很多的。&lt;/p&gt;
&lt;p&gt;软件打开是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321200641540-937926122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些功能都不需要，主要使用的是右下角的更改pdf，点开之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321200756494-1170377910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要使用的就是这一部分的功能。&lt;/p&gt;
&lt;p&gt;现在开始目录制作。&lt;/p&gt;
&lt;p&gt;先解释一下上述标签的意思：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;往PDF挂书签&lt;/strong&gt;：就是为pdf文件添加目录。不过需要目录文件，下面会有介绍制作的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从PDF取书签&lt;/strong&gt;：就是从有目录的pdf文件中提取出目录文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要操作的目录文件&lt;/strong&gt;：就是需要添加目录的PDF文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存放接口的文件夹&lt;/strong&gt;：就是目录文件，需要制作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他的按键一般没什么需要使用的。&lt;/p&gt;
&lt;p&gt;制作目录需要一个目录文件，使用的是txt格式。&lt;/p&gt;
&lt;h3&gt;一、选择一个存放接口的文件夹&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321201944508-408410220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个文件夹可以自己创建。&lt;/p&gt;
&lt;h3&gt;二，创建配置文件&lt;/h3&gt;
&lt;p&gt;选定文件夹之后，再点击创建文件夹右边的那个按钮，输入以下模板内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Images]

[Font]
Language&lt;/span&gt;=&lt;span&gt;GBK
FontSize&lt;/span&gt;=&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
Margin&lt;/span&gt;=&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;

[Bkmk]
File&lt;/span&gt;=&lt;span&gt;FreePic2Pdf_bkmk.txt
AddAsText&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
ShowBkmk&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
ShowAll&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
BasePage&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

[Main]
ContentsPage&lt;/span&gt;=&lt;span&gt;
TextPage&lt;/span&gt;=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存。之后他就会在选定的文件夹下创建一个名为 FreePic2Pdf.itf 的文件。&lt;/p&gt;
&lt;h3&gt;三、创建目录文件&lt;/h3&gt;
&lt;p&gt;在这个文件夹下新建一个 FreePic2Pdf_bkmk.txt 文件。&lt;/p&gt;
&lt;p&gt;这个文件就是目录文件，这里的目录需要自定义，它需要按照一定的格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;一级目录\t页码
\t二级目录\t页码
\t\t三级目录\t页码
。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;\t表示制表符，也就是TAB键。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321204058694-909425276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个文件可以用记事本写，也可以用notepad等等。&lt;/p&gt;
&lt;p&gt;那么这些内容具体怎么去写呢？&lt;/p&gt;
&lt;p&gt;这个就得看自己的电脑技能了。不过总的来说是以下几步：&lt;/p&gt;
&lt;p&gt;1、识别目录文字&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以使用ABBYY软件识别，但是不建议，具体原因请自行入坑。&lt;/li&gt;
&lt;li&gt;推荐的：使用网页百度翻译。没错，就是百度翻译，将目录图片粘贴上去，他就自动识别并将中文和英文翻译显示出来了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　至于目录的图片，你可以截图，也可以使用2345看图王软件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321205127134-2125958386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接就复制目录了，这样复制的目录完整一点。&lt;/p&gt;
&lt;p&gt;2、目录制作&lt;/p&gt;
&lt;p&gt;百度翻译的识别效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321205345110-336316905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 呃，没有换行，内容也有部分缺失，这些都是需要自己去修改。&lt;/p&gt;
&lt;p&gt;那么如何将这些内容制作成需要的格式呢，这个。。。要么靠自己手动编辑，如果会正则表达式，可以节省一点时间。&lt;/p&gt;
&lt;p&gt;注意：目录的页码是pdf文件的真实页码，而不是书上标志的那些页码，为了方便，可以将接口文件中 BasePage 字段修改为书中第一页对应的pdf页数。&lt;/p&gt;
&lt;p&gt;如：BasePage=12&lt;/p&gt;
&lt;p&gt;制作成功后，选择相应的文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321210109295-837664459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再点击开始，没问题的话瞬间制作完成。制作前记得先保存副本。&lt;/p&gt;
&lt;p&gt;接着再点开pdf文件，就会发现目录有了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1139339/201903/1139339-20190321210223663-708989195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 到此，制作完成！！！&lt;/p&gt;

</description>
<pubDate>Thu, 21 Mar 2019 13:12:00 +0000</pubDate>
<dc:creator>TwoIce</dc:creator>
<og:description>很多pdf文件是直接扫描生成的，于是它的内容都是一张张的图片，当然就更没有目录索引了。 有的时候想找某些内容，只能一点点的移动滚动条，非常不方便。 那么有什么方法能生成目录呢？ 方法一：使用福昕pdf</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/twoice/p/10574668.html</dc:identifier>
</item>
<item>
<title>【带着canvas去流浪】 （3）绘制饼图 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10574646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10574646.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201903/1354575-20190321210744268-971223111.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/canvas-echarts/pie-chart&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-任务说明&quot;&gt;一. 任务说明&lt;/h2&gt;
&lt;p&gt;使用原生&lt;code&gt;canvasAPI&lt;/code&gt;绘制饼图（南丁格尔玫瑰）。（截图以及数据来自于百度Echarts官方示例库&lt;a href=&quot;https://echarts.baidu.com/examples/editor.html?c=pie-roseType&amp;amp;theme=light&quot;&gt;【查看示例链接】&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201903/1354575-20190321210802445-694375084.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.-重点提示&quot;&gt;二. 重点提示&lt;/h2&gt;
&lt;p&gt;南丁格尔玫瑰图的画法有很多种，&lt;code&gt;Echarts&lt;/code&gt;中提供的以半径或面积两种不同模式，本文中以面积比例画法为例，绘制算法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确定每个扇区的角度。由于所有扇区的角度加在一起为2π ，我们先按照数据比例来计算角度：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201903/1354575-20190321210813236-1574006015.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个扇区面积与总面积之间的比例即为数值的比，将给定参数数组&lt;code&gt;options.radius&lt;/code&gt;中的最大和最小数值作为数值最大的一块扇形的绘图数据，代入如下公式即可求得总面积&lt;code&gt;S&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201903/1354575-20190321210829309-388444833.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;再利用上述公式分别计算出每个扇形对应的外圆半径，在canvas中绘制路径并填充即可。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三.-示例代码&quot;&gt;三. 示例代码&lt;/h2&gt;
&lt;p&gt;南丁格尔玫瑰图绘制示例代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//绘制饼图
drawPieChart(options);
    
/**
 * 绘制饼图
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
function drawPieChart(options) {
   //记录最大数值以反求面积总和
   options.maxValue = 0;
   //求数据集总和以在后续计算每个扇形的角度比例
   options.totalNum = options.data.reduce((pre,cur)=&amp;gt;{
     if (cur.value &amp;gt; options.maxValue) {
         options.maxValue = cur.value;
     }
     return pre+cur.value;
   },0);
    /*以最大值对应最大半径来计算面积总和，并覆盖原值
    *使得最大的一块扇形外圆半径为options.radius[0]
    *内圆半径为options.radius[1]
    */
    let Rmin = options.radius[0];
    let Rmax = options.radius[1];
    let r = Math.sqrt((Rmax*Rmax - Rmin*Rmin)*options.totalNum / options.maxValue + Rmin*Rmin);
    options.radius[1] = r;
    //移动坐标系原点至绘图中心
   let paintingCenter={
     x:parseInt(options.center[0],10)/100 * (options.chartZone[2] - options.chartZone[0]) + options.chartZone[0],
     y:parseInt(options.center[1],10)/100 * (options.chartZone[3] - options.chartZone[1]) + options.chartZone[1]
   }
   context.translate(paintingCenter.x, paintingCenter.y);
    //绘制每个扇形,过程中累加旋转角度
   let allAngle = options.data.reduce((prev,cur,index)=&amp;gt;{
       context.fillStyle = options.colorPool[index]
       let angle = calcPaintingData(cur,options);
       return prev + angle;
   },0);
   //绘制中空白色圆
   context.beginPath();
   context.fillStyle = 'white';
   context.arc(0,0,options.radius[0],0,2*Math.PI,false);
   context.fill();
}

/**
 * 计算每个扇形所需要的绘图参数
 */
function calcPaintingData(data,options) {
    let scale = data.value / options.totalNum; 
    let angle = scale * 2 * Math.PI;
    let Rmin = options.radius[0];
    let Rmax = options.radius[1];
    let r = Math.sqrt(scale * (Rmax*Rmax - Rmin*Rmin) + Rmin*Rmin);
    data.r = r;
    //绘制扇形
    paintFan({
        r:r,
        angle:angle,
        data:data,
        options:options
    });
    return angle;//将角度值返回给外层函数以供累加
}

//绘制扇形
function paintFan(opt) {
    context.beginPath();
    context.lineTo(opt.r,0);
    context.arc(0,0,opt.r,0,opt.angle,false);
    context.lineTo(0,0);
    context.closePath();
    context.fill();
    context.rotate(opt.angle);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器中可查看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201903/1354575-20190321210842255-756282351.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.-hover高亮的实现思路&quot;&gt;四. hover高亮的实现思路&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;绘图过程中，将每个扇区的绘图数据（半径，相对于圆心的起始转角，扇区角度）均挂载在绘图数据上。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;canvas&lt;/code&gt;标签上监听鼠标移动事件&lt;code&gt;mousemove&lt;/code&gt;,并在回调函数中将鼠标移动事件&lt;code&gt;event.clientX&lt;/code&gt;和&lt;code&gt;event.clientY&lt;/code&gt;转换为相对于canvas坐标的数值&lt;code&gt;(mouseX,mouseY)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从圆心坐标&lt;code&gt;(paintingCenter.x,paintingCenter.y)&lt;/code&gt;到&lt;code&gt;(mouseX,mouseY)&lt;/code&gt;连接为向量，根据该向量的角度和模即可判断鼠标是否处于某个扇区之上。&lt;/li&gt;
&lt;li&gt;如果处于扇区之上，则以过渡动画来绘制关键帧使得hover效果表现出来。先修改&lt;code&gt;context.fillStyle&lt;/code&gt;颜色为对应扇区的高亮色，然后让外圆绘图半径以线性的方式逐帧增加至目标大小（例如10%）,每一帧中使用canvas绘图上下文重新对绘图区域进行封闭画线，然后填充即可。&lt;/li&gt;
&lt;li&gt;hover效果出现时绘制高亮色的绘图区域，hover效果消失时从外圆开始逐帧绘制白色外层扇区即可，最终再将数据扇区绘制为原色。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 21 Mar 2019 13:09:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10574646.html</dc:identifier>
</item>
<item>
<title>工程实践：给函数取一个&quot;好&quot;的名字 - Matrix海子</title>
<link>http://www.cnblogs.com/dolphin0520/p/10567879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphin0520/p/10567879.html</guid>
<description>&lt;h3 data-pm-slice=&quot;0 0 []&quot;&gt;工程实践：给函数取一个&quot;好&quot;的名字&lt;/h3&gt;
&lt;p&gt;　　早在2013年，国外有个程序员做了一个有意思的投票统计（原始链接请见：《&lt;a href=&quot;https://www.itworld.com/article/2833265/don-t-go-into-programming-if-you-don-t-have-a-good-thesaurus.html&quot; target=&quot;_blank&quot;&gt;程序员：你认为最难做的事情是什么？&lt;/a&gt;》），该投票是让程序员从以下几个选项中选出平时在工作中自己认为最难做的事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;做项目方案设计&lt;/li&gt;
&lt;li&gt;编写测试用例&lt;/li&gt;
&lt;li&gt;撰写设计文档&lt;/li&gt;
&lt;li&gt;向别人解释我们在做什么事情&lt;/li&gt;
&lt;li&gt;实现你不认同的feature&lt;/li&gt;
&lt;li&gt;在别人写的代码基础上做改造&lt;/li&gt;
&lt;li&gt;与人沟通&lt;/li&gt;
&lt;li&gt;给函数、变量命名&lt;/li&gt;
&lt;li&gt;进行工作量估时&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　也许在大家的印象中，&lt;strong&gt;撰写设计文档&lt;/strong&gt;和&lt;strong&gt;在别人写的代码基础上做改造&lt;/strong&gt;应该是最难的事情。但是最终的投票结果确让大家意想不到，这次投票一起有4522名程序员参与了投票，排在第一位的是&lt;strong&gt;给函数、变量命名：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/288799/201903/288799-20190321204646384-117448761.jpg&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;460&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　大概一半的人投票给了&lt;strong&gt;给函数、变量命名，&lt;/strong&gt;从这次投票结果我们足可以看出：给函数、变量命名虽然是一件再普通不过的事情，但是要想把这件事做好绝非易事。那么今天，我们就来聊一聊如何给函数取一个好的名字。以下是本文大纲目录：&lt;/p&gt;
&lt;p&gt;　　一.常见的函数命名风格&lt;/p&gt;
&lt;p&gt;　　二.函数命名的最高境界&lt;/p&gt;
&lt;p&gt;　　三.函数命名最佳实践&lt;/p&gt;
&lt;p&gt;　　若有不正之处请多多谅解，并欢迎批评指正。&lt;/p&gt;
&lt;p&gt;　　请尊重作者劳动成果，转载请标明原文链接：&lt;/p&gt;
&lt;p&gt;    　https://www.cnblogs.com/dolphin0520/p/10567879.html&lt;/p&gt;

&lt;h2&gt;一.常见函数命名风格&lt;/h2&gt;
&lt;p&gt;　　目前来说，最常见的函数命名主要有两种风格：驼峰命名和帕斯卡命名。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;驼峰命名：多个单词组成一个名称时，第一个单词全部小写，后面单词首字母大写；如：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void setUserName(String userName);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;帕斯卡命名：多个单词组成一个名称时，每个单词的首字母大写；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void SetUserName(String userName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两种命名风格都是ok的，但要保证一点，对于一个团队或者一个项目，需要根据语言本身的推荐命名方式做好约定。比如java一般都采取驼峰命名，C#采取帕斯卡命名。&lt;/p&gt;
&lt;h2&gt;二. 函数命名最高境界&lt;/h2&gt;
&lt;p&gt;　　我们通常说：天下武功，唯快不破。那么对于函数命名来说最高境界是什么呢？我认为是：&lt;strong&gt;见字如面&lt;/strong&gt;，顾名思义，就是看到函数的名字就知道这个函数具体做了哪些事情。&lt;/p&gt;
&lt;p&gt;　　比如上面的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void setUserName(String userName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是下面这个函数命名就不是一个好的命名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public String addCharacter(String originString, char ch);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个函数，一咋看，还不错，从函数字面意思看是给某个字符串添加一个字符。&lt;strong&gt;但是到底是在原有字符串首部添加，还是在原有字符串末尾追加呢？亦或是在某个固定位置插入呢？&lt;/strong&gt;从函数名字完全看不出来这个函数的真正意图，只能继续往下读这个函数的具体实现才知道。&lt;/p&gt;
&lt;p&gt;　　而下面这几个名字就比上面要好得多：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public String appendCharacter(String originString, char ch);     // 追加到末尾
public String insertCharacter(String originString, char ch, int insertPosition); // 插入指定位置
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三. 函数命名最佳实践&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）要领1：动词选取要精准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通常来说，动词决定了一个函数要采取什么&quot;动作&quot;。动词取的好，一个函数名字已经成功了80%。&lt;/p&gt;
&lt;p&gt;　　常用动词表：&lt;/p&gt;
&lt;table data-bordercolor=&quot;#cccccc&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;th width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;类别&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;单词&lt;/p&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;添加/插入/创建/初始化/加载&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;add、append、insert、create、initialize、load&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;删除/销毁&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;delete、remove、destroy、drop&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;打开/开始/启动&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;open、start&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;关闭/停止&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;close、stop&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取/读取/查找/查询&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;get、fetch、acquire、read、search、find、query&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置/重置/放入/写入/释放/刷新&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;set、reset、put、write、release、refresh&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;发送/推送&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;send、push&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;接收/拉取&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;receive、pull&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;提交/撤销/取消&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;submit、cancel&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;收集/采集/选取/选择&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;collect、pick、select&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;提取/解析&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;sub、extract、parse&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;编码/解码&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;encode、decode&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;填充/打包/压缩&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;fill、pack、compress&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;清空/拆包/解压&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;flush、clear、unpack、decompress&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;增加/减少&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;increase、decrease、reduce&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;分隔/拼接&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;split、join、concat&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;242&quot; data-colwidth=&quot;242&quot;&gt;
&lt;p&gt;过滤/校验/检测&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;406&quot; data-colwidth=&quot;406&quot;&gt;
&lt;p&gt;filter、valid、check&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;2）要领2：名词使用领域词汇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　动词决定了函数的具体动作，而名词决定了函数具体的操作对象，对于名词，尽量使用领域词汇，不要使用生僻或者大家很少使用的词语。&lt;/p&gt;
&lt;p&gt;　　举个例子：集合的容量通常用capacity、集合实际元素个数用size、字符串长度用length，这种就遵循大家的使用习惯，不要用size去形如字符串的长度。&lt;/p&gt;
&lt;p&gt;　　再比如，假如使用到建造者模式，那么通常会用build作为函数名字，这个时候就不要另辟蹊径，用create来作为函数名字，使用大家约定俗成的命名习惯更容易让你的代码被别人读懂。&lt;/p&gt;
&lt;p&gt;　　常用名词表：&lt;/p&gt;
&lt;table data-bordercolor=&quot;#cccccc&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;th width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;类别&lt;/span&gt;&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;单词&lt;/span&gt;&lt;/p&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;容量/大小/长度&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;capacity、size、length&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;实例/上下文&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;instance、context&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;config、settings&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;头部/前面/前一个/第一个&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;header、front、previous、first&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;尾部/后面/后一个/最后一个&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;tail、back、next、last&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;区间/区域/某一部分/范围/规模&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;range、interval、region、area、section、scope、scale&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;缓存/缓冲/会话&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;cache、buffer、session&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;本地/局部/全局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;local、global&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;成员/元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;member、element&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;菜单/列表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot;&gt;
&lt;p&gt;&lt;span&gt;menu、list&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;249&quot; data-colwidth=&quot;249&quot;&gt;
&lt;p&gt;&lt;span&gt;源/目标&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;472&quot; data-colwidth=&quot;472&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;source、destination、target&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;3）要领3：函数取名最忌讳&quot;名不副实&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　函数取名最忌讳的是&quot;名不副实&quot;，举个例子，假如有个Cache类，里面有个函数判断key是否过期：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public boolean isExpired(String key) {
        // 当前时间戳
        long curTimestamp = DateUtils.nowUnixTime();
        // 获取key的存入时间戳
        long storeTimestamp = getStoreTimestamp(key);
       
        if (curTimestamp - storeTimestamp &amp;gt; MAX_EXPIRE_SECONDS) {
            // 注意这个地方的delete是个隐藏逻辑
            delete(key);
            return true;
        }
        return false;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个函数从函数字面意思看是判断key是否过期，但是！！&lt;strong&gt;它居然在函数里面隐藏了一段特殊逻辑：如果过期则删除掉key。&lt;/strong&gt;这个就是典型的&quot;名不副实&quot;，这个是最忌讳的，会给后续的开发人员留下&quot;巨坑&quot;。&lt;/p&gt;
&lt;p&gt;　　有两种方式去优化这段代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方式一：将隐藏逻辑去掉&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public boolean isExpired(String key) {
        // 当前时间戳
        long curTimestamp = DateUtils.nowUnixTime();
        // 获取key的存入时间戳
        long storeTimestamp = getStoreTimestamp(key);
       
        if (curTimestamp - storeTimestamp &amp;gt; MAX_EXPIRE_SECONDS) {
            return true;
        }
        return false;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;方式二：改变函数名字&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public int deleteIfExpired(String key) {
        // 当前时间戳
        long curTimestamp = DateUtils.nowUnixTime();
        // 获取key的存入时间戳
        long storeTimestamp = getStoreTimestamp(key);
       
        if (curTimestamp - storeTimestamp &amp;gt; MAX_EXPIRE_SECONDS) {
            return delete(key);
        }
        return 0;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4）&lt;strong&gt;要领4：多查询条件的函数名字谨慎使用介词by&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们平时在写查询接口时，假如有多个查询参数怎么办？每个通过by一起连接依赖？No！这绝对不是明智的方式。假如一开始产品的需求是通过学生姓名查询学生信息，写出来的可能是这样的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public List&amp;lt;Student&amp;gt; getByName(String name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后突然又有一天产品提出了新的需求，希望同时可以通过姓名和电话号码来查询学生信息，那么函数可能变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public List&amp;lt;Student&amp;gt; getByNameAndMobile(String name, String mobile);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，没过多久，产品又希望根据学生年龄来查询学生信息，那么函数可能变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public List&amp;lt;Student&amp;gt; getByNameAndMobileAndAge(String name, String mobile, int age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果这样来给函数命名，那么你的噩梦大门即将打开。&lt;/p&gt;
&lt;p&gt;　　通常比较好的做法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public Student getByStudentId(long studentId);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public List&amp;lt;Student&amp;gt; getStudents(StudentSearchParam searchParam);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后，建议大家平时在写代码过程中，不要怕在函数命名上耗费时间，一个好的函数命名在后期会大大减少你代码重构的成本，争取对函数命名做到&quot;见字如面&quot;~&lt;/p&gt;

</description>
<pubDate>Thu, 21 Mar 2019 13:05:00 +0000</pubDate>
<dc:creator>Matrix海子</dc:creator>
<og:description>工程实践：给函数取一个&quot;好&quot;的名字 早在2013年，国外有个程序员做了一个有意思的投票统计（原始链接请见：《程序员：你认为最难做的事情是什么？》），该投票是让程序员从以下几个选项中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphin0520/p/10567879.html</dc:identifier>
</item>
</channel>
</rss>