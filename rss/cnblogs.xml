<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解决SpringBoot在后台接收前台传递对象方式 - qq377905687</title>
<link>http://www.cnblogs.com/Coder1988/p/13023290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Coder1988/p/13023290.html</guid>
<description>&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;问题描述&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;前台传递对象，不管是通过ajax请求方式，还是axios请求方式。后台应该怎么接收对象处理呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;比如前台传递&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ajax方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$.ajax({
    url: &quot;后台的方式&quot;,
    async: false,
    type: &quot;POST&quot;,
    dataType : &quot;json&quot;,
    data: JSON.stringify(formParamObj),
    contentType:'application/json;charset=utf-8',
    success: function (data) {
        if (data.isSuccess) {
            //成功处理方式
        } else if (&quot;403&quot; == data) {
           //失败方式处理
        }
    }
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;axios方式:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 let params = {
    key1:value1,
    key2:value2
 }
 axios.post/get(url,params).then(res=&amp;gt;{
    //处理结果
 })
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在方法的参数前面添加注解@RequestBody就可以解决&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 @PostMapper(&quot;/xxx/xxxx&quot;)
 public List getProgramList(@RequestBody Program program){
     System.out.println(program);
     return null;
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;落地测试:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以通过postman工具进行测试&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jun 2020 00:52:00 +0000</pubDate>
<dc:creator>qq377905687</dc:creator>
<og:description>问题描述 前台传递对象，不管是通过ajax请求方式，还是axios请求方式。后台应该怎么接收对象处理呢？ 比如前台传递 ajax方式： $.ajax({ url: &amp;quot;后台的方式&amp;quot;,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Coder1988/p/13023290.html</dc:identifier>
</item>
<item>
<title>CTR学习笔记&amp;代码实现6-深度ctr模型 后浪 xDeepFM/FiBiNET - 风雨中的小七</title>
<link>http://www.cnblogs.com/gogoSandy/p/13023265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoSandy/p/13023265.html</guid>
<description>&lt;p&gt;xDeepFM用改良的DCN替代了DeepFM的FM部分来学习组合特征信息，而FiBiNET则是应用SENET加入了特征权重比NFM，AFM更进了一步。在看两个model前建议对DeepFM, Deep&amp;amp;Cross, AFM，NFM都有简单了解，不熟悉的可以看下文章最后其他model的博客链接。&lt;/p&gt;
&lt;p&gt;以下代码针对Dense输入更容易理解模型结构，针对spare输入的代码和完整代码 👇&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/DSXiangLi/CTR&quot;&gt;https://github.com/DSXiangLi/CTR&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;xdeepfm&quot;&gt;xDeepFM&lt;/h2&gt;
&lt;h3 id=&quot;模型结构&quot;&gt;模型结构&lt;/h3&gt;
&lt;p&gt;看xDeepFM的名字和DeepFM相似都拥有Deep和Linear的部分，只不过把DeepFM中用来学习二阶特征交互的FM部分替换成了CIN（Compressed Interactino Network）。而CIN是在Deep&amp;amp;Cross的DCN上进一步改良的得到。整体模型结构如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/7fgrzqhquqar2nntxgb30qp0/image.png&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们重点看下CIN的部分，和paper的notation保持一致，有m个特征，每个特征Embedding是D维，第K层的CIN有&lt;span class=&quot;math inline&quot;&gt;\(H_k\)&lt;/span&gt;个unit。CIN第K层的计算分为3个部分分别对应图a-c：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/7dpp0w8i7gdpduz6trswrvnx/image.png&quot; width=&quot;700&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;向量两两做element-wise product, 时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(m*H_{k-1}*D)\)&lt;/span&gt;&lt;br/&gt;对输入层和第K-1层输出，做element-wise乘积进行两两特征交互，得到&lt;span class=&quot;math inline&quot;&gt;\(m*H_{k-1}\)&lt;/span&gt;个D维向量矩阵，如果CIN只有一层，则和FM, NFM，AFM的第一步相同。FM 直接聚合成scaler，NFM沿D进行sum_pooling，而AFM加入Attention沿D进行weighted_pooling。忽略batch的矩阵dimension变化如下&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[z^k = x^0 \odot x^{k-1} = (D * m* 1) \odot (D * 1* H_{k-1}) = D * m*H_{k-1} \]&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Feature Map，空间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(H_k *H_{k-1} *m)\)&lt;/span&gt;，时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(H_k *H_{k-1} *m*D)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_k \in R^{H_{k-1}*m *H_k}\)&lt;/span&gt; 是第K层的权重向量，可以理解为沿Embedding做CNN。每个Filter对所有两两乘积的向量进行加权求和得到 &lt;span class=&quot;math inline&quot;&gt;\(1*D\)&lt;/span&gt;的向量 一共有&lt;span class=&quot;math inline&quot;&gt;\(H_k\)&lt;/span&gt;个channel，输出&lt;span class=&quot;math inline&quot;&gt;\(H_k * D\)&lt;/span&gt;的矩阵向量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[w^k \bullet z^k = (H_k *H_{k-1} *m)* (m*H_{k-1}*D) = H_k *D \]&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Sum Pooling&lt;br/&gt;CIN对每层的输出沿Dimension进行sum pooling，得到&lt;span class=&quot;math inline&quot;&gt;\(H_k*1\)&lt;/span&gt;的输出，然后把每层输出concat以后作为CIN部分的输出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;CIN每一层的计算如上，T层CIN每一层都是上一次层的输出和第一层的输入进行交互得到更高一阶的交互信息。假设每层维度一样&lt;span class=&quot;math inline&quot;&gt;\(H_k=H\)&lt;/span&gt;， CIN 部分整体时间复杂度是&lt;span class=&quot;math inline&quot;&gt;\(O(TDmH^2)\)&lt;/span&gt;，空间复杂度来自每层的Filter权重&lt;span class=&quot;math inline&quot;&gt;\(O(TmH^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CIN保留DCN的任意高阶和参数共享，两个主要差别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DCN是bit-wise，CIN是vector-wise。DCN在做向量乘积时不区分Field，直接对所有Field拼接成的输入（m*D）进行外积。而CIN考虑Field，两两vector进行乘积&lt;/li&gt;
&lt;li&gt;DCN使用了ResNet因为多项式的核心只用输出最后一层，而CIN则是每层都进行pooling后输出&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;CIN的设计还是很巧妙滴，不过。。。吐槽小分队上线: CIN不论是时间复杂度还是空间复杂度都比DCN要高，感觉更容易过拟合。至于说vector-wise的向量乘积要比bit-wise的向量乘积要好，这。。。至少bit-wise可以不限制embedding维度一致, 但vector-wise嘛我实在有些理解无能，明白的童鞋可以comment一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def cross_op(xk, x0, layer_size_prev, layer_size_curr, layer, emb_size, field_size):
    # Hamard product: ( batch * D * HK-1 * 1) * (batch * D * 1* H0) -&amp;gt; batch * D * HK-1 * H0
    zk = tf.matmul( tf.expand_dims(tf.transpose(xk, perm = (0, 2, 1)), 3),
                    tf.expand_dims(tf.transpose(x0, perm = (0, 2, 1)), 2))

    zk = tf.reshape(zk, [-1, emb_size, field_size * layer_size_prev]) # batch * D * HK-1 * H0 -&amp;gt; batch * D * (HK-1 * H0)
    add_layer_summary('zk_{}'.format(layer), zk)

    # Convolution with channel = HK: (batch * D * (HK-1*H0)) * ((HK-1*H0) * HK)-&amp;gt; batch * D * HK
    kernel = tf.get_variable(name = 'kernel{}'.format(layer),
                             shape = (field_size * layer_size_prev, layer_size_curr))
    xkk = tf.matmul(zk, kernel)
    xkk = tf.transpose(xkk, perm = [0,2,1]) # batch * HK * D
    add_layer_summary( 'Xk_{}'.format(layer), xkk )
    return xkk


def cin_layer(x0, cin_layer_size, emb_size, field_size):
    cin_output_list = []

    cin_layer_size.insert(0, field_size) # insert field dimension for input
    with tf.variable_scope('Cin_component'):
        xk = x0
        for layer in range(1, len(cin_layer_size)):
            with tf.variable_scope('Cin_layer{}'.format(layer)):
                # Do cross
                xk = cross_op(xk, x0, cin_layer_size[layer-1], cin_layer_size[layer],
                              layer, emb_size, field_size ) # batch * HK * D
                # sum pooling on dimension axis
                cin_output_list.append(tf.reduce_sum(xk, 2)) # batch * HK

    return tf.concat(cin_output_list, axis=1)

@tf_estimator_model
def model_fn_dense(features, labels, mode, params):
    dense_feature, sparse_feature = build_features()
    dense_input = tf.feature_column.input_layer(features, dense_feature)
    sparse_input = tf.feature_column.input_layer(features, sparse_feature)

    # Linear part
    with tf.variable_scope('Linear_component'):
        linear_output = tf.layers.dense( sparse_input, units=1 )
        add_layer_summary( 'linear_output', linear_output )

    # Deep part
    dense_output = stack_dense_layer( dense_input, params['hidden_units'],
                               params['dropout_rate'], params['batch_norm'],
                               mode, add_summary=True )
    # CIN part
    emb_size = dense_feature[0].variable_shape.as_list()[-1]
    field_size = len(dense_feature)
    embedding_matrix = tf.reshape(dense_input, [-1, field_size, emb_size]) # batch * field_size * emb_size
    add_layer_summary('embedding_matrix', embedding_matrix)

    cin_output = cin_layer(embedding_matrix, params['cin_layer_size'], emb_size, field_size)

    with tf.variable_scope('output'):
        y = tf.concat([dense_output, cin_output,linear_output], axis=1)
        y = tf.layers.dense(y, units= 1)
        add_layer_summary( 'output', y )

    return y
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;fibinet&quot;&gt;FiBiNET&lt;/h2&gt;
&lt;h3 id=&quot;模型结构-2&quot;&gt;模型结构&lt;/h3&gt;
&lt;p&gt;看FiBiNET前可以先了解下Squeeze-and-Excitation Network,感兴趣可以看下这篇博客&lt;a href=&quot;https://towardsdatascience.com/squeeze-and-excitation-networks-9ef5e71eacd7&quot;&gt;Squeeze-and-Excitation Networks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;FiBiNET的主要创新是应用SENET学习每个特征的重要性，加权得到新的Embedding矩阵。在FiBiNET之前，AFM，PNN，DCN和上面的xDeepFM都是在特征交互之后才用attention, 加权等方式学习特征交互的权重，而FiBiNET在保留这部分的同时，在Embedding部分就考虑特征自身的权重。模型结构如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/gpuffsmmvjbj6f986bdiyhvu/image.png&quot; width=&quot;400&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;原始Embedding，和经过SENET调整过权重的新Embedding，在Bilinear-interaction层学习二阶交互特征，拼接后，再经过MLP进一步学习高阶特征。和paper notation保持一致（啊啊啊大家能不能统一下notation搞的我自己看自己的注释都蒙圈），f个特征，k维embedding&lt;/p&gt;
&lt;h4 id=&quot;senet层&quot;&gt;SENET层&lt;/h4&gt;
&lt;p&gt;SENET层学习每个特征的权重对Embedding进行加权，分为以下3步&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/jync56xznq0ap1xrw7njniu8/image.png&quot; width=&quot;250&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;Squeeze&lt;br/&gt;把&lt;span class=&quot;math inline&quot;&gt;\(f*k\)&lt;/span&gt;的Embedding矩阵压缩成&lt;span class=&quot;math inline&quot;&gt;\(f*1\)&lt;/span&gt;, 压缩方式不固定，SENET原paper用的max_pooling,作者用的sum_pooling，感觉这里压缩方式应该取决于Embedding的信息表达&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[\begin{align} E &amp;amp;= [e_1,...,e_f] \\ Z &amp;amp;= [z_1,...,z_f] \\ z_i &amp;amp;= F_{squeeze}(e_i) = \frac{1}{k}\sum_{i=1}^K e_i \\ \end{align} \]&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Excitation&lt;br/&gt;Excitation是一个两层的全连接层，通过先降维再升维的方式过滤一些无用特征，降维的幅度通过额外变量&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;来控制，第一层权重&lt;span class=&quot;math inline&quot;&gt;\(W_1 \in R^{f*f/r}\)&lt;/span&gt;,第二层权重&lt;span class=&quot;math inline&quot;&gt;\(W_2 \in R^{f/r*f}\)&lt;/span&gt;。这里r越高，压缩的幅度越高，最终的权重会更集中,反之会更分散。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[A = \sigma_2(W_2·\sigma_1(W_1·Z)) \]&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Re-weight&lt;br/&gt;最后一步就是用Excitation得到的每个特征的权重对Embedding进行加权得到新Embedding&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[E_{new} = F_{Reweight}(A,E) = [a_1·e_1, ...,a_f·e_f ] \]&lt;/p&gt;
&lt;p&gt;在收入数据集上进行尝试，r=2时会有46%的embedding特征权重为0，所以SENET会在特征交互前先过滤部分对target无用的特征来增加有效特征的权重&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/v5kggfeh0thq3bub7tz0jh9u/image.png&quot; width=&quot;250&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;bilinear-interaction层&quot;&gt;Bilinear-Interaction层&lt;/h4&gt;
&lt;p&gt;作者提出内积和element-wise乘积都不足以捕捉特征交互信息，因此进一步引入权重W，以下面的方式进行特征交互&lt;/p&gt;
&lt;p&gt;\[v_i · W \odot v_j \]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/ph2ahcdo2cg5ny5l1f7rd9le/image.png&quot; width=&quot;250&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中W有三种选择，可以所有特征交互共享一个权重矩阵(Field-All),或者每个特征和其他特征的交互共享权重(Field-Each), 再或者每个特征交互一个权重(Field-Interaction) 具体的优劣感觉需要casebycase来试，不过一般还是照着数据越少参数越少的逻辑来整。&lt;/p&gt;
&lt;p&gt;原始Embedding和调整权重后的Embedding在Bilinear-Interaction学习交互特征后，拼接成shallow 层，再经过全连接层来学习更高阶的特征交互。后面的属于常规操作这里就不再细说。&lt;/p&gt;
&lt;p&gt;我们不去吐槽FiBiNET可以加入wide&amp;amp;deep框架来捕捉低阶特征信息和任意高阶信息，更多把FiBiNET提供的SENET特征权重的思路放到自己的工具箱中就好。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def Bilinear_layer(embedding_matrix, field_size, emb_size, type, name):
    # Bilinear_layer: combine inner and element-wise product
    interaction_list = []
    with tf.variable_scope('BI_interaction_{}'.format(name)):
        if type == 'field_all':
            weight = tf.get_variable( shape=(emb_size, emb_size), initializer=tf.truncated_normal_initializer(),
                                      name='Bilinear_weight_{}'.format(name) )
        for i in range(field_size):
            if type == 'field_each':
                weight = tf.get_variable( shape=(emb_size, emb_size), initializer=tf.truncated_normal_initializer(),
                                          name='Bilinear_weight_{}_{}'.format(i, name) )
            for j in range(i+1, field_size):
                if type == 'field_interaction':
                    weight = tf.get_variable( shape=(emb_size, emb_size), initializer=tf.truncated_normal_initializer(),
                                          name='Bilinear_weight_{}_{}_{}'.format(i,j, name) )
                vi = tf.gather(embedding_matrix, indices = i, axis =1, batch_dims =0, name ='v{}'.format(i)) # batch * emb_size
                vj = tf.gather(embedding_matrix, indices = j, axis =1, batch_dims =0, name ='v{}'.format(j)) # batch * emb_size
                pij = tf.matmul(tf.multiply(vi,vj), weight) # bilinear : vi * wij \odot vj
                interaction_list.append(pij)

        combination = tf.stack(interaction_list, axis =1 ) # batch * emb_size * (Field_size * (Field_size-1)/2)
        combination = tf.reshape(combination, shape = [-1, int(emb_size * (field_size * (field_size-1) /2)) ]) # batch * ~
        add_layer_summary( 'bilinear_output', combination )

    return combination


def SENET_layer(embedding_matrix, field_size, emb_size, pool_op, ratio):
    with tf.variable_scope('SENET_layer'):
        # squeeze embedding to scaler for each field
        with tf.variable_scope('pooling'):
            if pool_op == 'max':
                z = tf.reduce_max(embedding_matrix, axis=2) # batch * field_size * emb_size -&amp;gt; batch * field_size
            else:
                z = tf.reduce_mean(embedding_matrix, axis=2)
            add_layer_summary('pooling scaler', z)

        # excitation learn the weight of each field from above scaler
        with tf.variable_scope('excitation'):
            z1 = tf.layers.dense(z, units = field_size//ratio, activation = 'relu')
            a = tf.layers.dense(z1, units= field_size, activation = 'relu') # batch * field_size
            add_layer_summary('exciitation weight', a )

        # re-weight embedding with weight
        with tf.variable_scope('reweight'):
            senet_embedding = tf.multiply(embedding_matrix, tf.expand_dims(a, axis = -1)) # (batch * field * emb) * ( batch * field * 1)
            add_layer_summary('senet_embedding', senet_embedding) # batch * field_size * emb_size

        return senet_embedding

@tf_estimator_model
def model_fn_dense(features, labels, mode, params):
    dense_feature, sparse_feature = build_features()
    dense_input = tf.feature_column.input_layer(features, dense_feature)
    sparse_input = tf.feature_column.input_layer(features, sparse_feature)

    # Linear part
    with tf.variable_scope('Linear_component'):
        linear_output = tf.layers.dense( sparse_input, units=1 )
        add_layer_summary( 'linear_output', linear_output )

    field_size = len(dense_feature)
    emb_size = dense_feature[0].variable_shape.as_list()[-1]
    embedding_matrix = tf.reshape(dense_input, [-1, field_size, emb_size])

    # SENET_layer to get new embedding matrix
    senet_embedding_matrix = SENET_layer(embedding_matrix, field_size, emb_size,
                                         pool_op = params['pool_op'], ratio= params['senet_ratio'])

    # combination layer &amp;amp; BI_interaction
    BI_org = Bilinear_layer(embedding_matrix, field_size, emb_size, type = params['bilinear_type'], name = 'org')
    BI_senet = Bilinear_layer(senet_embedding_matrix, field_size, emb_size, type = params['bilinear_type'], name = 'senet')

    combination_layer = tf.concat([BI_org, BI_senet] , axis =1)

    # Deep part
    dense_output = stack_dense_layer(combination_layer, params['hidden_units'],
                               params['dropout_rate'], params['batch_norm'],
                               mode, add_summary=True )

    with tf.variable_scope('output'):
        y = dense_output + linear_output
        add_layer_summary( 'output', y )

    return y
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ctr学习笔记代码实现系列&quot;&gt;CTR学习笔记&amp;amp;代码实现系列👇&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DSXiangLi/CTR&quot;&gt;https://github.com/DSXiangLi/CTR&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12501846.html&quot;&gt;CTR学习笔记&amp;amp;代码实现1-深度学习的前奏 LR-&amp;gt;FFM&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12658051.html&quot;&gt;CTR学习笔记&amp;amp;代码实现2-深度ctr模型 MLP-&amp;gt;Wide&amp;amp;Deep&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12742417.html&quot;&gt;CTR学习笔记&amp;amp;代码实现3-深度ctr模型 FNN-&amp;gt;PNN-&amp;gt;DeepFM&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12814804.html&quot;&gt;CTR学习笔记&amp;amp;代码实现4-深度ctr模型 NFM/AFM&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12892973.html&quot;&gt;CTR学习笔记&amp;amp;代码实现5-深度ctr模型 DeepCrossing -&amp;gt; Deep&amp;amp;Cross&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Ref&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Jianxun Lian, 2018, xDeepFM: Combining Explicit and Implicit Feature Interactions for Recommender Systems&lt;/li&gt;
&lt;li&gt;Tongwen Huang, 2019, FiBiNET: Combining Feature Importance and Bilinear feature Interaction for Click-Through Rate Prediction&lt;/li&gt;
&lt;li&gt;Jie Hu, 2017, Squeeze-and-Excitation Networks&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72931811&quot;&gt;https://zhuanlan.zhihu.com/p/72931811&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/79659557&quot;&gt;https://zhuanlan.zhihu.com/p/79659557&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/57162373&quot;&gt;https://zhuanlan.zhihu.com/p/57162373&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/qiaoguan/deep-ctr-prediction&quot;&gt;https://github.com/qiaoguan/deep-ctr-prediction&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 01 Jun 2020 00:46:00 +0000</pubDate>
<dc:creator>风雨中的小七</dc:creator>
<og:description>xDeepFM用改良的DCN替代了DeepFM的FM部分来学习组合特征信息，而FiBiNET则是应用SENET加入了特征权重比NFM，AFM更进了一步。在看两个model前建议对DeepFM, Dee</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gogoSandy/p/13023265.html</dc:identifier>
</item>
<item>
<title>七个生产案例告诉你BATJ为何选择ElasticSearch！应用场景和优势！ - 胖滚猪学编程</title>
<link>http://www.cnblogs.com/liuyanling/p/13023251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyanling/p/13023251.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文来源于公众号【胖滚猪学编程】，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从今天开始，想和你一起死磕ElasticSearch，学习分布式搜索引擎，跟着胖滚猪就对了！&lt;/p&gt;
&lt;p&gt;既然是ES的第一课，那么最重要的是让你爱上它！不想说那些单纯的优势、概念了，直接上大厂的生产案例，才是最能吸引你的！跟着大厂走，没问题的！&lt;/p&gt;

&lt;p&gt;一个技术服务组件，首先需要了解全面它的使用场景，才能更针对性的去研究及推广。因此第一要务是搞懂为什么要学习ElasticSearch，开头po先一张排行图，大哥的地位可不是瞎搞来的，没点实力能上位？凭这排名就是你要学习它的理由！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084229423-441034501.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;凭啥排这么前呢？不就是个搜索引擎吗。额，也许提到Elasticseach，你第一反应就是&quot;搜索引擎&quot;。类似百度搜索、淘宝搜索那种。而我写这篇文章就是为了纠正你这个&quot;错误&quot;的观点。&lt;/p&gt;
&lt;p&gt;Elasticseach 确实是做搜索引擎出家的，但是到现在已经进化成了一个全能型的数据产品。因此你的思维决不能限制在搜索引擎上。&lt;/p&gt;
&lt;p&gt;本文通过一线大厂的八个案例，全方位让你了解ElasticSearch的应用场景和优势，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志实时分析&lt;/li&gt;
&lt;li&gt;搜索服务&lt;/li&gt;
&lt;li&gt;数据分析&lt;/li&gt;
&lt;li&gt;数据监控&lt;/li&gt;
&lt;li&gt;查询服务&lt;/li&gt;
&lt;li&gt;后端存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ElasticSearch在腾讯的应用非常广泛，主要有三：日志实时分析场景、搜索服务、时序数据分析。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;搜索服务： 例如像腾讯文档基于 ES 做全文检索，电商客户拼多多、蘑菇街等大量的商品搜索都是基于 ES。&lt;/li&gt;
&lt;li&gt;日志分析： 这个是 ES 应用最广泛的领域，支持全栈的日志分析，包括各种应用日志、数据库日志、用户行为日志、网络数据、安全数据等等。ES 拥有一套完整的日志解决方案，可以秒级实现从采集到展示。&lt;/li&gt;
&lt;li&gt;时序分析： 典型的场景是监控数据分析，比如云监控，整个腾讯云的监控都是基于 ES 的。此外还包括物联网场景，也有大量的时序数据。时序数据的特点是写入吞吐量特别高，ES 支持的同时也提供了丰富的多维统计分析算子。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;日志实时分析&quot;&gt;日志实时分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084229736-606688594.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;典型日志如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运营日志，比如慢日志、异常日志，用来定位业务问题；&lt;/li&gt;
&lt;li&gt;业务日志，比如用户的点击、访问日志，可以用来分析用户行为；&lt;/li&gt;
&lt;li&gt;审计日志，可以用于安全分析。ES 很完美的解决了日志实时分析的需求，它具有如下特点：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Elastic 生态提供了完整的日志解决方案，任何一个开发、运维同学使用成熟组件，通过简单部署，即可搭建起一个完整的日志实时分析服务。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在 Elastic 生态中，日志从产生到可访问一般在 10s 级。相比于传统大数据解决方案的几十分钟、小时级，时效性非常高。ES 拥有一套完整的日志解决方案（ELK），可以秒级实现从采集到展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;由于支持倒排索引、列存储等数据结构，ES 提供非常灵活的搜索分析能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持交互式分析，即使在万亿级日志的情况下，ES 搜索响应时间也是秒级。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;日志是互联网行业最基础、最广泛的数据形式，ES 非常完美的解决了日志实时分析场景，这也是近几年 ES 快速发展的一个重要原因&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;搜索服务&quot;&gt;搜索服务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084230044-2044929864.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;搜索服务，典型场景包含：商品搜索，类似京东、淘宝、拼多多中的商品搜索；APP 搜索，支持应用商店里的应用搜索；站内搜索，支持论坛、在线文档等搜索功能。我们支持了大量搜索服务，它们主要有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能：单个服务最大达到 10w+ QPS，平响 20ms~，P95 延时小于 100ms。&lt;/li&gt;
&lt;li&gt;强相关：搜索体验主要取决于搜索结果是否高度匹配用户意图，需要通过正确率、召回率等指标进行评估。&lt;/li&gt;
&lt;li&gt;高可用：搜索场景通常要求高可用性，支持单机房故障容灾。任何一个电商服务，如淘宝、京东、拼多多，只要故障一个小时就可以上头条。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;时序数据分析&quot;&gt;时序数据分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084230254-1259689227.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;时序数据分析，典型的时序数据包含：Metrics，即传统的服务器监控；整个腾讯云的监控都是基于 ES 的。APM，应用性能监控；物联网数据，智能硬件、工业物联网等产生的传感器数据。时序数据的特点是写入吞吐量特别高，ES 支持的同时也提供了丰富的多维统计分析算子。这类场景具有以下特点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高并发写入：线上单集群最大规模达到 600+节点、1000w/s 的写入吞吐。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高查询性能：要求单条曲线 或者单个时间线的查询延时在 10ms~。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多维分析：要求灵活、多维度的统计分析能力，比如我们在查看监控的时候，可以按照地域、业务模块等灵活的进行统计分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面通过腾讯的案例我们了解了三大应用场景，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;日志实时分析场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序数据分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外从这三大应用场景我们也可以归纳出ES的几大优势：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、具有高可用性、高扩展性；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、查询速度快，性能佳；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、搜索功能强大，高度匹配用户意图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，可以看出，ES在日志实时分析和搜索方面的应用优势简直是无敌的！起码目前，在这两方面，还没有强劲的对手！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过京东的案例，聊一聊ES在查询、检索、数据分析方面的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于较高的性能和较低的使用门槛，京东内部有很多的场景都在使用 Elasticsearch。覆盖了京东多条业务线，同时也覆盖了很多应用场景：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084230637-361062663.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;补充关系型数据库的结构化数据查询&quot;&gt;补充关系型数据库的结构化数据查询&lt;/h3&gt;
&lt;p&gt;主要应用的业务是商品、促销、优惠券、订单、收银台、物流、对账、评论等大数据量查询。此场景的核心诉求是高性能、稳定性和高可用性，部分场景会有检索要求，通常用于加速关系型数据库，业务系统通过 binlog 同步或业务双写完成数据同步。&lt;/p&gt;
&lt;h3 id=&quot;全文检索功能&quot;&gt;全文检索功能&lt;/h3&gt;
&lt;p&gt;主要的应用场景是应用、安全、风控、交易等操作日志，以及京东部分品类商品搜索。此类日志化场景对写要求很高，查询性能及高可用等要求相对较低，大的业务写会达到数千万 / 秒，存储以 PB 为单位来计算。&lt;br/&gt;这些场景对磁盘、内存有比较高的要求，因此，京东也做了相应优化，用于减少内存消耗，提升磁盘整体使用率，使用更廉价的磁盘来降低成本等等。&lt;/p&gt;
&lt;h3 id=&quot;实时数据分析引擎，形成统计报表&quot;&gt;实时数据分析引擎，形成统计报表&lt;/h3&gt;
&lt;p&gt;主要应用的业务是物流单的各种分析、订单数据分析、用户画像等。因为业务数据分析纬度较多，flink、storm 等流式分析对于某些报表场景不太适用，批处理实时性又成为问题，所以近实时分析的 Elasticsearch 就成为了这些业务的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从京东的案例中，我们似乎看到了，可以利用ES在某些场景下代替关系型数据库哦！不仅如此，ES在实时数据分析领域，居然也有一席之地！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过去哪儿的案例，聊一聊ES在查询方面的应用场景，可以简单的理解为&quot;代替&quot;mysql。注意代替加了引号，闭着眼睛想都不可能完全代替。比如事务性。&lt;/p&gt;
&lt;p&gt;15年去哪儿网酒店日均订单量达到30w+，随着多平台订单的聚合日均订单能达到100w左右。&lt;/p&gt;
&lt;p&gt;原来采用的热表分库方式，即将最近6个月的订单的放置在一张表中，将历史订单放在在history表中。history表存储全量的数据，当用户查询的下单时间跨度超过6个月即查询历史订单表，此分表方式热表的数据量为4000w左右，当时能解决的问题。但是显然不能满足携程艺龙订单接入的需求。&lt;/p&gt;
&lt;p&gt;如果继续按照热表方式，数据量将超过1亿条。全量数据表保存2年的可能就超过4亿的数据量。所以寻找有效途径解决此问题迫在眉睫。由于对这预计4亿的数据量还需按照预定日期、入住日期、离店日期、订单号、联系人姓名、电话、酒店名称、订单状态……等多个条件查询。所以简单按照某一个维度进行分表操作没有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显然只通过DB来支撑大量的查询是不可取的，同时对于一些复杂的查询，Mysql支持得不够友好，所以Elasticsearch分布式搜索储存集群的引入，就是为了解决订单数据的存储与搜索的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对订单模型进行抽象和分类，将常用搜索字段和基础属性字段剥离。DB做分库分表，存储订单详情；Elasticsearch存储搜素字段。&lt;/p&gt;
&lt;p&gt;订单复杂查询直接走Elasticsearch，基于OrderNo的简单查询走DB，如下图所示。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10691149-fbb6847350efe143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从去哪儿的案例中，我们似乎看到了，关系型数据库撑不起的复杂查询，ES可以胜任&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么时候应该用ElasticSearch?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、典型搜索场景：闭着眼用它！&lt;/p&gt;
&lt;p&gt;2、典型日志分析场景：闭着眼用它！&lt;/p&gt;
&lt;p&gt;3、关系型数据库查询有瓶颈：考虑下用它！为啥是考虑？ES的优点在于查询，然而实践证明，在被作为数据库来使用，即写完马上查询会有延迟。&lt;/p&gt;
&lt;p&gt;4、数据分析场景：考虑下用它！为啥是考虑？简单通用的场景需求可以大规模使用，但在特定业务场景领域，还是要选择更加专业的数据产品，如复杂聚合，ClickHouse相比 Elasticserach 做亿级别数据深度聚合需求会更加合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ElasticSearch有什么优势呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、很简便的横向扩容，分布式的架构，可以轻松地对资源进行横向纵向扩缩容，可以满足不同数据量级及查询场景对硬件资源的需求。能由数百台到万台机器搭建满足PB级的快速搜索，也能搭建单机版服务小公司。&lt;/p&gt;
&lt;p&gt;2、查询速度快：ES底层采用Lucene作为搜索引擎，并在此之上做了多重优化，保证了用户对数据查询数据的需求。可&quot;代替&quot;传统关系型数据库，也可用于复杂数据分析，海量数据的近实时处理等。&lt;/p&gt;
&lt;p&gt;3、相关性高：ES内部提供了完善的评分机制，会根据分词出现的频次等信息对文档进行相关性排序，保证相关性越高的文档排序越靠前。另外还提供了包括模糊查询，前缀查询，通配符查询等在内的多种查询手段，帮助用户快速高效地进行检索。&lt;/p&gt;
&lt;p&gt;4、功能点多但使用比较简便，开箱即用，性能优化比较简单&lt;/p&gt;
&lt;p&gt;5、生态圈丰富，社区活跃，适配多种工具。如下图，处理日志和输出到Elasticsearch，您可以使用日志记录工具，如Logstash（www.elastic.co/products/logstash），搜索和可视化界面分析这些日志，你可以使用Kibana（www.elastic.co/产品/ kibana），即传说中的ELK技术栈。另外当前主流的大数据框架也几乎都支持ES，比如Flink和ES就是个完美搭档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202006/2027276-20200601084230848-2109014167.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/9W5tI4FYAaJgKjl8DPT5GA&quot;&gt;腾讯万亿级 Elasticsearch 技术解密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.51cto.com/art/201807/579354.htm&quot;&gt;搜索引擎怎么选？携程酒店订单Elasticsearch实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/muPBWDNWAkQaPxMm67S0AA&quot;&gt;Elasticsearch在京东的使用场景&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文来源于公众号：【胖滚猪学编程】。一枚集颜值与才华于一身，不算聪明却足够努力的女程序媛。用漫画形式让编程so easy and interesting！求关注！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 01 Jun 2020 00:43:00 +0000</pubDate>
<dc:creator>胖滚猪学编程</dc:creator>
<og:description>本文来源于公众号【胖滚猪学编程】，转载请注明出处。 从今天开始，想和你一起死磕ElasticSearch，学习分布式搜索引擎，跟着胖滚猪就对了！ 既然是ES的第一课，那么最重要的是让你爱上它！不想说那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuyanling/p/13023251.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.22：如何打造超级技术栈 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13022186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13022186.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224453570-1348832148.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：build-your-own-x，无论是新手还是老手，这都是一个指向标。方向有了，剩下就是时间和实践的事情，收集了大量可用于软件和 Web 开发的 Public APIs 无疑是你实践之路的好搭档，而拼写检查：vscode-spell-checker 也能让你实践更加顺利，提升你的开发效益，节省研发时间。除了 VSCode 的插件帮你更好地实践技术，responsively-app 这种为调试响应式页面的浏览器也是一个好帮手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 macOS 免费体验：macos-virtualbox&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 Web 开发提速：responsively-app&lt;/li&gt;
&lt;li&gt;2.2 SQL 分析：DuckDB&lt;/li&gt;
&lt;li&gt;2.3 UI 组件管理器：Storybook&lt;/li&gt;
&lt;li&gt;2.4 Demo 之母：RealWorld&lt;/li&gt;
&lt;li&gt;2.5 API 集大成者：Public APIs&lt;/li&gt;
&lt;li&gt;2.6 公式推导解析：pumpkin-book&lt;/li&gt;
&lt;li&gt;2.7 超级技术栈：build-your-own-x&lt;/li&gt;
&lt;li&gt;2.8 架构师技术图谱：awesome-architecture&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #VSCode 插件# 主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 页面自动加载：vscode-live-server&lt;/li&gt;
&lt;li&gt;3.2 拼写检查：vscode-spell-checker&lt;/li&gt;
&lt;li&gt;3.3 Vim 仿真器：VSCodeVim&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-macos-免费体验：macos-virtualbox&quot;&gt;1.1 macOS 免费体验：macos-virtualbox&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想免费体验 macOS 系统吗？macos-virtualbox 是一个 macOS 虚拟机，支持 Windows、Linux。默认安装仅要求用户耐心地坐下，并且在脚本提示按不到十次的 Enter 键，无需与虚拟机进行交互。当前支持 macOS Catalina（10.15），Mojave（10.14）和High Sierra（10.13）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/myspaghetti/macos-virtualbox&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224526367-701100418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-web-开发提速：responsively-app&quot;&gt;2.1 Web 开发提速：responsively-app&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;responsively-app 是来自印度的开发者 Manoj Vivek 为调试响应式页面的开发的浏览器，主要有以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨设备镜像用户交互&lt;/li&gt;
&lt;li&gt;可定制的预览布局，以满足开发需求&lt;/li&gt;
&lt;li&gt;一个方便的元素检查支持所有设备预览&lt;/li&gt;
&lt;li&gt;30+ 内置设备配置文件，可选择添加自定义设备。&lt;/li&gt;
&lt;li&gt;一键截图所有设备。&lt;/li&gt;
&lt;li&gt;支持开发者热重载&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/manojVivek/responsively-app&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224551660-31166516.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-sql-分析：duckdb&quot;&gt;2.2 SQL 分析：DuckDB&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DuckDB 是一款嵌入式关系型分析数据库，主要用于嵌入其他程序执行快速的 SQL 分析查询，官方称其为“分析型数据库中的 SQLite”，使用 C 或 C++ 可将数据库服务器直接嵌入到应用程序中。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法解析：使用 PostgreSQL 解析器，该解析器被重新打包为独立库&lt;/li&gt;
&lt;li&gt;shell：对 SQLite shell 进行了调整，以使用 DuckDB&lt;/li&gt;
&lt;li&gt;测试：使用 SQLite 中的 SQL 逻辑测试来测试 DuckDB&lt;/li&gt;
&lt;li&gt;模糊查询：使用 SQLsmith 生成随机查询以进行额外的测试&lt;/li&gt;
&lt;li&gt;Date Math：使用 MonetDB 中的 Date Math 组件&lt;/li&gt;
&lt;li&gt;SQL 窗口函数：DuckDB 的窗口函数实现使用分段树聚合，如 Viktor Leis、KanKundhikanjana、Alfons Kemper 和 Thomas Neumann&lt;/li&gt;
&lt;li&gt;执行引擎：矢量化执行引擎的灵感来源于 PeterBoncz、Marcin Zukowski 和 Niels nes 的论文 “MonetDB/X 100：超级流水线查询执行”&lt;/li&gt;
&lt;li&gt;优化器：DuckDB 的优化器从 Guido Moerkotte 和 Thomas Neumman 的论文 “动态规划回击” 以及 Thomas Neumann 和 Alfons Kemper 的“取消任意查询嵌套”中获得灵感&lt;/li&gt;
&lt;li&gt;并发控制：我们的 MVCC 实现灵感来自于 Thomas Neumann，Tobias Mühlbauer 和 Alfons Kemper 的论文“用于主存数据库系统的快速序列化多版本并发控制”&lt;/li&gt;
&lt;li&gt;存储：DuckDB 使用 DataBlock 作为持久存储，如 Harald lang、Tobias Mühlbauer、Florian Funke、Peter Boncz、Thomas Neumann 和 Alfons Kemper 在“数据块：利用矢量化和编译的压缩存储上的混合 OLTP和OLAP” 中描述的那样&lt;/li&gt;
&lt;li&gt;正则表达式：DuckDB 使用 Google 的 RE2 正则表达式引擎&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/cwida/duckdb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;23-ui-组件管理器：storybook&quot;&gt;2.3 UI 组件管理器：Storybook&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Storybook 是一个 UI 组件的开发环境，允许你浏览组件库、查看每个组件的不同状态以及交互式开发和测试组件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/storybookjs/storybook&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224618708-1057167989.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-demo-之母：realworld&quot;&gt;2.4 Demo 之母：RealWorld&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RealWorld 向大家展示了如何使用 React/Angular 等框架在 Node/Django 等平台上构建类 Medium 博客平台。开发者可以把它们混合起来，因为它们都遵循相同的 API 规范。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/gothinkster/realworld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224640766-498701422.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-api-集大成者：public-apis&quot;&gt;2.5 API 集大成者：Public APIs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1850+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Public APIs 收集了可用于软件和 Web 开发的大量 API，包括金融、防诈骗、文字分析、动漫、健身等等 50 + 个分类 API，如果你要找资源不妨试试这个公共 API 项目 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/public-apis/public-apis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224658744-287073338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-公式推导解析：pumpkin-book&quot;&gt;2.6 公式推导解析：pumpkin-book&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pumpkin-book 是《机器学习》（西瓜书）公式推导解析，包括：模型评估与选择、线性模型、决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、降维与度量学习、特征选择与稀疏学习等等内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/datawhalechina/pumpkin-book&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;27-超级技术栈：build-your-own-x&quot;&gt;2.7 超级技术栈：build-your-own-x&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;build-your-own-x 是一个收录了大量资源的项目，它旨在教你构建一些专属于自己的技能，内容包括：3D 渲染器、增强现实、区块链、游戏、搜索引擎、命令行工具、神经网络、视觉识别、bot 等等 27 个大类。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/danistefanovic/build-your-own-x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224716666-280910283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;28-架构师技术图谱：awesome-architecture&quot;&gt;2.8 架构师技术图谱：awesome-architecture&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;awesome-architecture 架构师技术图谱包括：分布式、前端、大数据、存储、微服务、推荐系统、框架 、消息队列、编程语言、设计模式、重构、集群等内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/toutiaoio/awesome-architecture&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-本周-github-trending-vscode-插件主题的主力军&quot;&gt;3. 本周 GitHub Trending #VSCode 插件#主题的主力军&lt;/h2&gt;
&lt;p&gt;一款好用的插件能提高我们的开发效率，VSCode 作为 Top IDE，它丰富的生态系统也是大多数开发者选择使用它开发软件的原因，在本期的主题项目中，小鱼干选择了 3 个超好用的插件希望能提高你的开发效率。&lt;/p&gt;
&lt;h3 id=&quot;31-页面自动加载：vscode-live-server&quot;&gt;3.1 页面自动加载：vscode-live-server&lt;/h3&gt;
&lt;p&gt;vscode-live-server 是一个允许我们在更改 IDE 代码时自动重新加载 Web 页面的插件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/ritwickdey/vscode-live-server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224744771-1178491783.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-拼写检查：vscode-spell-checker&quot;&gt;3.2 拼写检查：vscode-spell-checker&lt;/h3&gt;
&lt;p&gt;vscode-spell-checker是一款拼写检查小工具，可帮你报告一些常见的拼写错误，尤其适合驼峰式代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/streetsidesoftware/vscode-spell-checker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202005/759200-20200531224805548-897653395.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-vim-仿真器：vscodevim&quot;&gt;3.3 Vim 仿真器：VSCodeVim&lt;/h3&gt;
&lt;p&gt;VSCodeVim 是一个用于 Visual Studio Code 的 Vim 仿真器，为你的文本编辑器带来 Vim 的强大功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/VSCodeVim/Vim&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 22 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200406212426655-796625417.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jun 2020 00:33:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 摘要：build-your-own-x，无论是新手还是老手，这都是一个指向标。方向有了，剩下就是时间和实践的事情，收集了大量可用于软件和 Web 开发的 Publ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13022186.html</dc:identifier>
</item>
<item>
<title>第四篇-用Flutter手撸一个抖音国内版，看看有多炫 - 风清扬 No.1</title>
<link>http://www.cnblogs.com/fengqingyangNo1/p/13022516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengqingyangNo1/p/13022516.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这次对布局进行优化，主要包含了首页tabview pageview 以及添加几个按钮的操作过程.主要使用到stack层叠布局，tabpview和pageview，tabview两个页面，一个关注，一个推荐，左右切换，pageview被包含在tabview里面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/122099/202005/122099-20200531223202960-1577529367.gif&quot; alt=&quot;&quot; width=&quot;1126&quot; height=&quot;590&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;布局优化&lt;/h2&gt;
&lt;p&gt;抖音的顶部appbar 是悬浮层叠展示，而flutter的层叠组件是stack, 因此最外面采用stack, 其次中间是tabview，分别是关注和推荐两个选项卡，关注在没有登录的时候会弹出一个提示需要认证登录的页面，这里加了两个页面，subscriptionScreen.dart，另外一个是loginScreen.dart&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
 @override
  Widget build(BuildContext context) {
    return Scaffold(
      //backgroundColor: Colors.transparent,
      body: Stack(
        //fit: StackFit.expand,
        children: &amp;lt;Widget&amp;gt;[
          TabBarView(
            controller: _tabController,
            children: &amp;lt;Widget&amp;gt;[
              Subscription(),
              PageView(
                allowImplicitScrolling: true,
                controller: _pageController,
                children: &amp;lt;Widget&amp;gt;[
                  Trending(),
                ],
                onPageChanged: (int index) {
                  setState(() {
                    currentIndex = index;
                  });
                },
              ),
            ],
          ),
          Column(
            children: [
              AppBar(
                backgroundColor: Colors.transparent,
                elevation: 0,
                centerTitle: true,
                leading: IconButton(
                    icon: Icon(Icons.tv),
                    onPressed: () {
                      print('点击了直播按钮');
                    }),
                actions: &amp;lt;Widget&amp;gt;[
                  //导航栏右侧菜单
                  IconButton(
                      icon: Icon(Icons.search),
                      onPressed: () {
                        print('点击了搜索按钮');
                      }),
                ],
                title: TabBar(
                  indicator: UnderlineTabIndicator(
                      borderSide: BorderSide(width: 2.0, color: Colors.white),
                      insets: EdgeInsets.symmetric(horizontal: 18.0)),
                  labelStyle: TextStyle(fontSize: 18),
                  isScrollable: true,
                  controller: _tabController,
                  tabs: toptabs,
                  onTap: (index) {
                    print(index);
                  },
                ),
              )
            ],
          ),
        ],
      ),
      bottomNavigationBar: bottomItems(),
    );
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;底部弹出提示认证页面&lt;/h2&gt;
&lt;p&gt;在 onTap 方法里&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
Scaffold.of(context).showBottomSheet&amp;lt;void&amp;gt;((BuildContext context) {
          return Login();
        });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;BottomSheet &lt;/strong&gt;是一个底部滑出的组件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/122099/202005/122099-20200531235448625-2121727757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
new BottomSheet(
    onClosing: () {},
    builder: (BuildContext context) {
        return new Text('aaa');
    },
),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常很少直接使用 BottomSheet 而是使用 showModalBottomSheet。直接时候的时候看到的知识 builder 里的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
Future&amp;lt;T&amp;gt; showModalBottomSheet &amp;lt;T&amp;gt;({
    @required BuildContext context,
    @required WidgetBuilder builder
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一个示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
new MaterialButton(
    color: Colors.blue,
    child: new Text('点我'),
    onPressed: () {
        showModalBottomSheet(
            context: context,
            builder: (BuildContext context) {
                return new Container(
                    height: 300.0,
                    child: new Image.network(this.imgurl),
                );
            },
        ).then((val) {
            print(val);
        });
 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 具体详细介绍参考官网.&lt;/p&gt;


&lt;h2&gt;关注页面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/122099/202005/122099-20200531225155711-1038819581.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;916&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 整个页面布局，左右都有边距，顶部也有边距，所有采用&lt;strong&gt;Container&lt;/strong&gt;包含，边距使用padding: EdgeInsets.only(top: 150.0, left: 65.0, right: 65.0),  背景颜色 color: Color.fromRGBO(14, 15, 26, 1)，依次image，另外使用sizebox占用空间，&lt;/p&gt;
&lt;p&gt;其他的中间层都是居中，所以采用&lt;strong&gt;center&lt;/strong&gt;都是居中，另外登录按钮是占满屏幕的，所以也采用&lt;strong&gt;SizeBox&lt;/strong&gt;，并且把width:设置为double.infinity，这样就占满屏幕，button采用默认的&lt;strong&gt;RaisedButton&lt;/strong&gt;，在button的&lt;strong&gt;onpressed&lt;/strong&gt;事件调用&lt;strong&gt;showBottomSheet&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;74&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
import 'package:flutter/material.dart';
import 'package:flutter_app/Screens/loginScreen.dart';

class Subscription extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _SubscriptionState();
}

class _SubscriptionState extends State&amp;lt;Subscription&amp;gt;
    with TickerProviderStateMixin {
  final GlobalKey&amp;lt;ScaffoldState&amp;gt; scaffoldKey = GlobalKey&amp;lt;ScaffoldState&amp;gt;();
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(top: 150.0, left: 65.0, right: 65.0),
      color: Color.fromRGBO(14, 15, 26, 1),
      child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: &amp;lt;Widget&amp;gt;[
            Image(image: AssetImage(&quot;assets/images/int_1581491273221.png&quot;)),
            SizedBox(height: 20),
            Center(
              child: Text(
                '你还没有登录',
                style: TextStyle(
                    color: Colors.white,
                    fontSize: 20.0,
                    fontWeight: FontWeight.w400),
              ),
            ),
            SizedBox(height: 10),
            Center(
              child: Text(
                '登录账号，查看你关注的精彩内容',
                style: TextStyle(
                    color: Color.fromRGBO(253, 253, 253, 0.6),
                    fontSize: 14.0,
                    fontWeight: FontWeight.w400),
              ),
            ),
            SizedBox(height: 20),
            SizedBox(
              width: double.infinity,
              child: RaisedButton(
                color: Color.fromRGBO(252, 1, 86, 1),
                child: Text(
                  '登录',
                  style: TextStyle(color: Colors.white),
                ),
                onPressed: () {
                  Scaffold.of(context)
                      .showBottomSheet&amp;lt;void&amp;gt;((BuildContext context) {
                    return Login();
                  });
                },
              ),
            ),
          ]),
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;登录页面&lt;/h2&gt;
&lt;p&gt;布局如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/122099/202005/122099-20200531230537330-119379827.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;892&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这个页面整体布局顶部，左右都有边距，因此使用&lt;strong&gt;Container&lt;/strong&gt;比较合适，设置背景颜色为&lt;strong&gt;color&lt;/strong&gt;: Colors.white, 边距设置为&lt;strong&gt;padding&lt;/strong&gt;:EdgeInsets.only(top: 25.0, left: 25.0, right: 25.0, bottom: 50.0)，整体布局采用&lt;strong&gt;Column&lt;/strong&gt;，因为是上下布局，因此&lt;strong&gt;Column &lt;/strong&gt;设置&lt;/p&gt;
&lt;p&gt;crossAxisAlignment: CrossAxisAlignment.start，顶部的布局是左边一个clear图标按钮，右边一个帮助按钮，所以使用&lt;strong&gt;Row&lt;/strong&gt;布局，并且设置Row的mainAxisAlignment: MainAxisAlignment.spaceBetween，这样就左右布局了，其他依次采用SizeBox占位，&lt;/p&gt;
&lt;p&gt;中间则采用Center来展示文字控件,底部的登录部分因为包含标签 超链接，所有采用RichText比较合适，包含TextSpan即可.&lt;/p&gt;
&lt;p&gt;全部代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;148&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

class Login extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _LoginState();
}

class _LoginState extends State&amp;lt;Login&amp;gt; {
  TapGestureRecognizer _myTapGestureRecognizer;
  @override
  void initState() {
    super.initState();
    _myTapGestureRecognizer = TapGestureRecognizer()
      ..onTap = () {
        launch('https://open.douyin.com/platform');
      };
  }

  @override
  void dispose() {
    _myTapGestureRecognizer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.white,
      padding:
          EdgeInsets.only(top: 25.0, left: 25.0, right: 25.0, bottom: 50.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: Icon(Icons.clear),
                onPressed: () {
                  Navigator.pop(context);
                },
                color: Colors.black,
              ),
              Text('帮助', style: TextStyle(color: Colors.black)),
            ],
          ),
          SizedBox(
            height: 150.0,
          ),
          Center(
            child: Text('180****2520',
                style: TextStyle(color: Colors.black, fontSize: 38)),
          ),
          Center(
            child: Text('认证服务由中国电信提供',
                style: TextStyle(
                    color: Color.fromRGBO(53, 53, 53, 1), fontSize: 12)),
          ),
          SizedBox(
            height: 50.0,
          ),
          SizedBox(
            width: double.infinity,
            child: RaisedButton(
              color: Color.fromRGBO(252, 1, 86, 1),
              child: Text(
                '本机号码一键登录',
                style: TextStyle(color: Colors.white),
              ),
              onPressed: () {
                showBottomSheet(
                    context: context, builder: (context) =&amp;gt; Login());
              },
            ),
          ),
          SizedBox(
            height: 2.0,
          ),
          SizedBox(
            width: double.infinity,
            child: OutlineButton(
              color: Color.fromRGBO(252, 1, 86, 1),
              child: Text(
                '其他手机号码登录',
                style: TextStyle(color: Colors.black),
              ),
              onPressed: () {
                showBottomSheet(
                    context: context, builder: (context) =&amp;gt; Login());
              },
            ),
          ),
          SizedBox(
            height: 5.0,
          ),
          Center(
              child: RichText(
            text: TextSpan(
              children: [
                TextSpan(
                  text: '登录即表明同意',
                  style: TextStyle(color: Color.fromRGBO(53, 53, 53, 0.8)),
                ),
                TextSpan(text: '  '),
                TextSpan(
                  text: '用户协议',
                  style: TextStyle(color: Color.fromRGBO(0, 164, 219, 0.8)),
                ),
                TextSpan(text: '  '),
                TextSpan(
                  text: '和',
                  style: TextStyle(color: Color.fromRGBO(53, 53, 53, 0.8)),
                ),
                TextSpan(text: '  '),
                TextSpan(
                  text: '隐私政策',
                  style: TextStyle(color: Color.fromRGBO(0, 164, 219, 0.8)),
                ),
              ],
            ),
          )),
          Center(
              child: RichText(
            text: TextSpan(
              children: [
                TextSpan(
                  text: '以及',
                  style: TextStyle(color: Color.fromRGBO(53, 53, 53, 0.8)),
                ),
                TextSpan(text: '  '),
                TextSpan(
                    text: '《中国电信认证服务条款》',
                    style: TextStyle(color: Color.fromRGBO(0, 164, 219, 0.8)),
                    recognizer: _myTapGestureRecognizer),
              ],
            ),
          )),
          Expanded(
              flex: 1,
              child: Center(
                  heightFactor: 25.0,
                  child: Text('其他方式登录',
                      style:
                          TextStyle(color: Color.fromRGBO(0, 164, 219, 0.8))))),
        ],
      ),
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;变更记录&lt;/h2&gt;
&lt;p&gt;本次变更主要体现在首页的选项卡设计，需要层叠展示，并且透明的采用appbar显示出顶部的关注、推荐按钮，另外新增了关注页，登录页，并且把底部按钮以及右边的按钮都加上了触发时间&lt;/p&gt;

&lt;p&gt;接下来要完成的双击心形按钮点赞，评论页面，分享页面，这些都可以采用showmodalbottomsheet方法打开一个底部抽屉页面&lt;/p&gt;

&lt;p&gt;还有底部的首页刷新，消息页面，拍短视频页面，消息页面，我的个人信息页面&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;请继续关注本博客，其他页面持续更新完成，源码地址：&lt;a title=&quot;https://github.com/WangCharlie/douyin&quot; href=&quot;https://github.com/WangCharlie/douyin&quot; target=&quot;_blank&quot;&gt;https://github.com/WangCharlie/douyin&lt;/a&gt;，欢迎fork和star，谢谢！！！&lt;/p&gt;

</description>
<pubDate>Mon, 01 Jun 2020 00:27:00 +0000</pubDate>
<dc:creator>风清扬 No.1</dc:creator>
<og:description>前言 这次对布局进行优化，主要包含了首页tabview pageview 以及添加几个按钮的操作过程.主要使用到stack层叠布局，tabpview和pageview，tabview两个页面，一个关注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengqingyangNo1/p/13022516.html</dc:identifier>
</item>
<item>
<title>Node.js躬行记（2）——文件系统和网络 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12655650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12655650.html</guid>
<description>&lt;p&gt;　　fs模块可与文件系统进行交互，封装了常规的POSIX函数。POSIX（Portable Operating System Interface，可移植操作系统接口）是UNIX系统的一个设计标准。fs模块提供了多个操作目录和文件的方法，大多会有同步和异步两种版本，同步的方法名称会以Sync为后缀。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）目录处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　fs模块的readdir()方法可异步的读取目录内容，回调函数包含两个参数，第一个是错误对象，第二个是一个包含文件名称的数组，对应的同步方法是readdirSync()。在下面的示例中，当前目录包含两个文件，上一级目录包含一个目录名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);
fs.readdir(&lt;/span&gt;'./', (err, files) =&amp;gt;&lt;span&gt; {
  console.log(files);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ 'demo.txt', 'index.js' ]&lt;/span&gt;
&lt;span&gt;});
fs.readdir(&lt;/span&gt;'../', (err, files) =&amp;gt;&lt;span&gt; {
  console.log(files);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ '1' ]&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其它处理目录的方法还有opendir()、mkdir()等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）读写文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在fs模块中，可使用批量方法readFile()将文件内容一次性的加载到内存中，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);
fs.readFile(&lt;/span&gt;'./origin.txt', (err, buf) =&amp;gt;&lt;span&gt; {
  console.log(buf.toString());        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;hello Node.js&quot;&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对应的写入方法是writeFile()，如下所示，文件路径、写入内容和回调函数是必传的参数。如果文件不存在，那么会自动创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
fs.writeFile('./target.txt', 'hello Node.js', (err) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
  console.log(&lt;/span&gt;'文件已被保存'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当文件很大时，像上面这样直接读取会有问题，可以改用流式方法createReadStream()，分批次的读取文件，如下所示，每次只读7个字节的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const readable = fs.createReadStream('./origin.txt', {highWaterMark: 7&lt;span&gt;});
readable.on(&lt;/span&gt;&quot;data&quot;, (chunk) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &quot;hello N&quot;
  /* &quot;ode.js&quot;
  /***********&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  console.log(chunk.toString());
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过管道方法pipe()将origin.txt中的内容写入到target-stream.txt中，如下所示，对于不存在的文件，也会自动创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const writable = fs.createWriteStream('./target-stream.txt'&lt;span&gt;);
readable.pipe(writable);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）文件描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　fs模块的stat()方法可读取文件的描述信息，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
fs.stat('./demo.txt', (err, stats) =&amp;gt;&lt;span&gt; {
  console.log(stats);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回调函数中的stats参数是一个fs.Stats对象，其属性如下所示。它还包含一些判断方法，例如isDirectory()、isFile()等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Stats {
  dev: &lt;/span&gt;195650&lt;span&gt;,
  mode: &lt;/span&gt;33206&lt;span&gt;,
  nlink: &lt;/span&gt;1&lt;span&gt;,
  uid: &lt;/span&gt;0&lt;span&gt;,
  gid: &lt;/span&gt;0&lt;span&gt;,
  rdev: &lt;/span&gt;0&lt;span&gt;,
  blksize: undefined,
  ino: &lt;/span&gt;36873221949682120&lt;span&gt;,
  size: &lt;/span&gt;13&lt;span&gt;,
  blocks: undefined,
  atimeMs: &lt;/span&gt;1586227933993.0217&lt;span&gt;,
  mtimeMs: &lt;/span&gt;1585882949091.0166&lt;span&gt;,
  ctimeMs: &lt;/span&gt;1586227933995.0222&lt;span&gt;,
  birthtimeMs: &lt;/span&gt;1586227933993.0217&lt;span&gt;,
  atime: &lt;/span&gt;2020-04-07T02:52:13&lt;span&gt;.993Z,
  mtime: &lt;/span&gt;2020-04-03T03:02:29&lt;span&gt;.091Z,
  ctime: &lt;/span&gt;2020-04-07T02:52:13&lt;span&gt;.995Z,
  birthtime: &lt;/span&gt;2020-04-07T02:52:13&lt;span&gt;.993Z
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　fs模块还提供了fstat()方法，在功能上与stat()等价，只是fstat()方法的第一个参数是文件描述符。在POSIX系统中，文件描述符是一个正整数，它实际上是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当打开或创建一个文件时，就会被分配一个文件描述符。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，open()方法的回调函数中包含一个fd参数（即文件描述符），搭配fstat()方法就能读取文件信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
fs.open('./demo.txt', 'r', (err, fd) =&amp;gt;&lt;span&gt; {
  fs.fstat(fd, (err, stats) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(stats);
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）监控文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　fs模块提供了两种方法来监控文件：watch()和watchFile()，前者能监控文件或目录的更改，后者只能监控文件的更改。&lt;/p&gt;
&lt;p&gt;　　watch()方法的监听器回调包含两个参数，第一个是事件类型（包括rename和change），第二个是触发事件的文件名称，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
fs.watch('./demo.txt', (eventType, filename) =&amp;gt;&lt;span&gt; {
  console.log(eventType, filename);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行node命令后，每次更改demo.txt文件，就会在控制台打印出下面这条语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ node index.js
change demo.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然watch()方法的性能优于watchFile()方法，但是watch()不是一个跨平台的方法，其表现在各个平台中并非百分百一致（例如filename参数不能保证提供），而watchFile()是跨平台的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）异步文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　fs.promises是Node提供的一组备用的异步文件系统方法，它们会返回Promise对象而不是通过回调来处理结果。例如以Promise的方式使用stat()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const fsPromises = require('fs'&lt;span&gt;).promises;
fsPromises.stat(&lt;/span&gt;'./demo.txt').then(stats =&amp;gt;&lt;span&gt; {
  console.log(stats);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Node可以处理的网络协议包括HTTP、TCP、HTTPS等，本节将会重点分析HTTP协议。Node中的http模块基于net、stream、events等模块，提供了一系列的网络传输的底层API，可创建HTTP服务器和客户端，包含重定向、代理、上传数据等功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）HTTP服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过http.createServer()方法就能创建HTTP服务器，其内部会调用net.Server()方法，返回一个http.Server实例。当服务被创建后，就能通过server.listen()方法监听一个端口。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，监听的端口是8000，createServer()的回调函数包含两个参数：req和res，分别表示HTTP的请求和响应，前者是IncomingMessage类（一个可读流）的实例，后者是ServerResponse类（一个可写流）的实例。__dirname是一个全局变量，保存着当前文件所处的路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const http = require('http'&lt;span&gt;); 
const fs &lt;/span&gt;= require('fs'&lt;span&gt;); 
const server &lt;/span&gt;= http.createServer(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
  fs.readFile(__dirname &lt;/span&gt;+ &quot;/index.html&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, data) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.statusCode &lt;/span&gt;= 500&lt;span&gt;;
      res.end(String(err));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.end(data);
    }
  });
}).listen(&lt;/span&gt;8000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在回调函数中，可修改或解析响应报文，例如像上面当发生错误时，将状态码改成500。在浏览器中访问http://localhost:8000，就能通过end()方法在页面中输出index.html的文件内容。&lt;/p&gt;
&lt;p&gt;　　注意，必须调用响应对象的end()方法结束此次响应，如果省略，那么页面将会一直处于加载中，阻塞内容渲染。&lt;/p&gt;
&lt;p&gt;　　http.Server包含一组事件，例如connection和request，如下所示。前者会在建立新的TCP流时触发，后者会在每次请求服务器时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
server.on(&quot;connection&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (socket) {
  console.log(connection&lt;/span&gt;&quot;&lt;span&gt;);
});
server.on(&lt;/span&gt;&quot;request&quot;&lt;span&gt;, function (req, res) {
  console.log('request');
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）重定向&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　3XX格式的状态码用于重定向，例如在Node中实现302跳转，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
http.createServer(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(req.url == '/strick'&lt;span&gt;) {
    res.writeHead(&lt;/span&gt;302, {'Location': 'http://www.pwstrick.com'&lt;span&gt;});
  }
  res.end();
}).listen(&lt;/span&gt;8000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当浏览器访问http://localhost:8000/strick时，才会执行重定向。writeHead()方法可一次性设置响应的状态码和所有的首部。如果只想设置单个响应首部，可以使用setHeader()方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）上传数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在实际的业务开发中，免不了上传数据的需求，例如表单提交、图像上传等。下面是一张form表单，包含一个文本框和一个提交按钮。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:8000&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　点击提交按钮，会将整张表单提交到HTTP服务器（代码如下所示），假设文本框中输入的内容为“咖啡机strick”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const http = require('http'&lt;span&gt;);
const querystring &lt;/span&gt;= require('querystring'&lt;span&gt;);

const server &lt;/span&gt;= http.createServer(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明Content-Type响应首部，以免中文乱码&lt;/span&gt;
  res.setHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;&lt;span&gt;);
  const arr &lt;/span&gt;=&lt;span&gt; [];
  req.on(&lt;/span&gt;&quot;data&quot;, chunk =&amp;gt;&lt;span&gt; {
    arr.push(chunk);
  });
  req.on(&lt;/span&gt;&quot;end&quot;, () =&amp;gt;&lt;span&gt; {
    const buf &lt;/span&gt;= Buffer.concat(arr);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接Buffer数据&lt;/span&gt;
    const params =&lt;span&gt; querystring.decode(buf.toString());
    console.log(params.name);             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;咖啡机strick&quot;&lt;/span&gt;
    res.write(JSON.stringify(params));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应数据&lt;/span&gt;
&lt;span&gt;    res.end();
  });
}).listen(&lt;/span&gt;8000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在data事件中接收数据并添加到arr数组中，然后在end事件中由Buffer.concat()方法拼接Buffer数据。querystring模块的decode()方法可将查询字符串解析成一个对象。write()方法会将响应数据发送给客户端。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）客户端服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　http模块提供了request()方法，可让客户端向服务器发起请求。在下面的示例中，postData变量是要发送的数据，options变量是各种配置参数，包括请求首部的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const http = require('http'&lt;span&gt;); 
const querystring &lt;/span&gt;= require('querystring'&lt;span&gt;);

const postData &lt;/span&gt;=&lt;span&gt; querystring.stringify({
  &lt;/span&gt;'name': '咖啡机strick'&lt;span&gt;
});
const options &lt;/span&gt;=&lt;span&gt; {
  hostname: &lt;/span&gt;'localhost'&lt;span&gt;,
  port: &lt;/span&gt;8000&lt;span&gt;,
  path: &lt;/span&gt;'/'&lt;span&gt;,
  method: &lt;/span&gt;'POST'&lt;span&gt;,
  headers: {
    &lt;/span&gt;'Content-Type': 'application/x-www-form-urlencoded'&lt;span&gt;,
    &lt;/span&gt;'Content-Length'&lt;span&gt;: Buffer.byteLength(postData)
  }
};
const req &lt;/span&gt;= http.request(options, (res) =&amp;gt;&lt;span&gt; {
  const code &lt;/span&gt;= res.statusCode;                　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态码&lt;/span&gt;
  const headers = JSON.stringify(res.headers);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应首部&lt;/span&gt;
  res.setEncoding('utf8');         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为可读流设置字符编码&lt;/span&gt;
  res.on('data', (chunk) =&amp;gt;&lt;span&gt; {
    console.log(chunk);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应数据&lt;/span&gt;
&lt;span&gt;  });
  res.on(&lt;/span&gt;'end', () =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'响应中已无数据'&lt;span&gt;);
  });
});
req.write(postData);
req.end();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，在请求最后需要调用end()方法，结束本次请求。Node还提供了一个基于request()的便捷方法：get()，它会自动调用req.end()方法，并且请求方法是GET。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代理是一种特殊的网络服务，允许一个客户端通过这个服务与目标服务器进行间接的连接，也就是在它们之间建立了一层中转，可用来过滤广告、控制内部资源的访问权限、保障终端的隐私或安全等。&lt;/p&gt;
&lt;p&gt;　　http模块可搭建出一个简易的HTTP代理服务器，下面示例引用自《&lt;span&gt;&lt;a href=&quot;https://book.douban.com/subject/26937390/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Node.js硬实战&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》技巧52一节。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const http = require('http'&lt;span&gt;);
const url &lt;/span&gt;= require('url'&lt;span&gt;);
http.createServer(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
  const options &lt;/span&gt;= url.parse(req.url);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个URL对象&lt;/span&gt;
  options.headers =&lt;span&gt; req.headers;
  
  req.on(&lt;/span&gt;'data', chunk =&amp;gt; {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求的原始数据发送给代理&lt;/span&gt;
&lt;span&gt;    proxyRequest.write(chunk);
  });
  req.on(&lt;/span&gt;'end', chunk =&amp;gt; {             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成原始请求&lt;/span&gt;
&lt;span&gt;    proxyRequest.end();
  });
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制原始请求&lt;/span&gt;
  const proxyRequest = http.request(options, proxyResponse =&amp;gt;&lt;span&gt; {
    proxyResponse.on(&lt;/span&gt;'data', chunk =&amp;gt; {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将响应的原始数据发送给客户端&lt;/span&gt;
&lt;span&gt;      res.write(chunk);
    });
    proxyResponse.on(&lt;/span&gt;'end', chunk =&amp;gt; {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成代理请求&lt;/span&gt;
&lt;span&gt;      res.end();
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将响应报文发送给客户端&lt;/span&gt;
&lt;span&gt;    res.writeHead(proxyResponse.statusCode, proxyResponse.headers);
  });
}).listen(&lt;/span&gt;8000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　url模块的parse()方法能将字符串转换成一个URL对象。在绑定请求对象的data事件后，就能将客户端的请求数据发送给代理。通过http.request()方法发起一次代理请求，并将服务器的响应数据发送给客户端。&lt;/p&gt;

</description>
<pubDate>Mon, 01 Jun 2020 00:24:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、文件系统 fs模块可与文件系统进行交互，封装了常规的POSIX函数。POSIX（Portable Operating System Interface，可移植操作系统接口）是UNIX系统的一个设计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12655650.html</dc:identifier>
</item>
<item>
<title>一篇有趣的负载均衡算法实现 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13021938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13021938.html</guid>
<description>&lt;p&gt;负载平衡（Load balancing）是一种在多个计算机（网络、CPU、磁盘）之间均匀分配资源，以提高资源利用的技术。使用负载均衡可以最大化服务吞吐量，可能最小化响应时间，同时由于使用负载均衡时，会使用多个服务器节点代单点服务，也提高了服务的可用性。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;208.41149773071&quot;&gt;
&lt;blockquote readability=&quot;4.8066298342541&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。&lt;br/&gt;欢迎关注我的&lt;a href=&quot;https://github.com/niumoo/JavaNotes#%E5%85%AC%E4%BC%97%E5%8F%B7&quot;&gt;公众号&lt;/a&gt;，文章每周更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;负载平衡&lt;/strong&gt;（Load balancing）是一种在多个计算机（网络、CPU、磁盘）之间均匀分配资源，以提高资源利用的技术。使用负载均衡可以最大化服务吞吐量，可能最小化响应时间，同时由于使用负载均衡时，会使用多个服务器节点代单点服务，也提高了服务的可用性。&lt;/p&gt;
&lt;p&gt;负载均衡的实现可以软件可以硬件，硬件如大名鼎鼎的 F5 负载均衡设备，软件如 NGINX 中的负载均衡实现，又如 Springcloud Ribbon 组件中的负载均衡实现。&lt;/p&gt;
&lt;p&gt;如果看到这里你还不知道负载均衡是干嘛的，那么只能放一张图了，毕竟没图说个啥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200527075734086.png&quot; alt=&quot;正经的负载均衡示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;负载均衡要做到在多次请求下，每台服务器被请求的次数大致相同。但是实际生产中，可能每台机器的性能不同，我们会希望性能好的机器承担的请求更多一些，这也是正常需求。&lt;/p&gt;
&lt;p&gt;如果这样说下来你看不懂，那我就再举个例子好了，一排可爱的小熊（服务器）站好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200527082251915.png&quot; alt=&quot;一排要被访问的服务器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时有人（用户）要过来打脸（请求访问）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200527082442214.png&quot; alt=&quot;用户请求&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么怎么样我们才能让这每一个可爱的小熊被打的次数大致相同呢？&lt;/p&gt;
&lt;p&gt;又或者熊 4 比较胖，抗击打能力是别人的两倍，我们怎么提高熊 4 被打的次数也是别人的两倍呢？&lt;/p&gt;
&lt;p&gt;又或者每次出手的力度不同，有重有轻，恰巧熊 4 总是承受这种大力度啪啪打脸，熊 4 即将不省熊事，还要继续打它吗？&lt;/p&gt;
&lt;p&gt;这些都是值的思考的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说了那么多，口干舌燥，我双手已经饥渴难耐了，迫不及待的想要撸起代码了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-随机访问&quot;&gt;1. 随机访问&lt;/h2&gt;
&lt;p&gt;上面说了，为了负载均衡，我们必须保证多次出手后，熊 1 到熊 4 被打次数均衡。比如使用随机访问法，根据数学上的概率论，随机出手次数越多，每只熊被打的次数就会越相近。代码实现也比较简单，使用一个随机数，随机访问一个就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 服务器列表 */
private static List&amp;lt;String&amp;gt; serverList = new ArrayList&amp;lt;&amp;gt;();
static {
    serverList.add(&quot;192.168.1.2&quot;);
    serverList.add(&quot;192.168.1.3&quot;);
    serverList.add(&quot;192.168.1.4&quot;);
    serverList.add(&quot;192.168.1.5&quot;);
}

/**
 * 随机路由算法
 */
public static String random() {
    // 复制遍历用的集合，防止操作中集合有变更
    List&amp;lt;String&amp;gt; tempList = new ArrayList&amp;lt;&amp;gt;(serverList.size());
    tempList.addAll(serverList);
    // 随机数随机访问
    int randomInt = new Random().nextInt(tempList.size());
    return tempList.get(randomInt);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用了非线程安全的集合，所以在访问操作时操作的是集合的拷贝，下面几种轮训方式中也是这种思想。&lt;/p&gt;
&lt;p&gt;写一个模拟请求方法，请求10w次，记录请求结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    HashMap&amp;lt;String, Integer&amp;gt; serverMap = new HashMap&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; 20000; i++) {
        String server = random();
        Integer count = serverMap.get(server);
        if (count == null) {
            count = 1;
        } else {
            count++;
        }
        // 记录
        serverMap.put(server, count);
    }
    // 路由总体结果
    for (Map.Entry&amp;lt;String, Integer&amp;gt; entry : serverMap.entrySet()) {
        System.out.println(&quot;IP:&quot; + entry.getKey() + &quot;，次数：&quot; + entry.getValue());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行得到请求结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IP:192.168.1.3，次数：24979
IP:192.168.1.2，次数：24896
IP:192.168.1.5，次数：25043
IP:192.168.1.4，次数：25082
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每台服务器被访问的次数都趋近于 2.5w，有点负载均衡的意思。但是随机毕竟是随机，是不能保证访问次数绝对均匀的。&lt;/p&gt;
&lt;h2 id=&quot;2-轮训访问&quot;&gt;2. 轮训访问&lt;/h2&gt;
&lt;p&gt;轮训访问就简单多了，拿上面的熊1到熊4来说，我们一个接一个的啪啪 - 打脸，熊1打完打熊2，熊2打完打熊3，熊4打完打熊1，最终也是实现了被打均衡。但是保证均匀总是要付出代价的，随机访问中需要随机，轮训访问中需要什么来保证轮训呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 服务器列表 */
private static List&amp;lt;String&amp;gt; serverList = new ArrayList&amp;lt;&amp;gt;();
static {
    serverList.add(&quot;192.168.1.2&quot;);
    serverList.add(&quot;192.168.1.3&quot;);
    serverList.add(&quot;192.168.1.4&quot;);
    serverList.add(&quot;192.168.1.5&quot;);
}
private static Integer index = 0;

/**
 * 随机路由算法
 */
public static String randomOneByOne() {
    // 复制遍历用的集合，防止操作中集合有变更
    List&amp;lt;String&amp;gt; tempList = new ArrayList&amp;lt;&amp;gt;(serverList.size());
    tempList.addAll(serverList);
    String server = &quot;&quot;;
    synchronized (index) {
        index++;
        if (index == tempList.size()) {
            index = 0;
        }
        server = tempList.get(index);;
    }
    return server;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由代码里可以看出来，为了保证轮训，必须记录上次访问的位置，为了让在并发情况下不出现问题，还必须在使用位置记录时进行加锁，很明显这种互斥锁增加了性能开销。&lt;/p&gt;
&lt;p&gt;依旧使用上面的测试代码测试10w次请求负载情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;IP:192.168.1.3，次数：25000
IP:192.168.1.2，次数：25000
IP:192.168.1.5，次数：25000
IP:192.168.1.4，次数：25000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-轮训加权&quot;&gt;3. 轮训加权&lt;/h2&gt;
&lt;p&gt;上面演示了轮训方式，还记的一开始提出的熊4比较胖抗击打能力强，可以承受别人2倍的挨打次数嘛？上面两种方式都没有体现出来熊 4 的这个特点，熊 4 窃喜，不痛不痒。但是熊 1 到 熊 3 已经在崩溃的边缘，不行，我们必须要让胖着多打，能者多劳，提高整体性能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 服务器列表 */
private static HashMap&amp;lt;String, Integer&amp;gt; serverMap = new HashMap&amp;lt;&amp;gt;();
static {
    serverMap.put(&quot;192.168.1.2&quot;, 2);
    serverMap.put(&quot;192.168.1.3&quot;, 2);
    serverMap.put(&quot;192.168.1.4&quot;, 2);
    serverMap.put(&quot;192.168.1.5&quot;, 4);
}
private static Integer index = 0;

/**
 * 加权路由算法
 */
public static String oneByOneWithWeight() {
    List&amp;lt;String&amp;gt; tempList = new ArrayList();
    HashMap&amp;lt;String, Integer&amp;gt; tempMap = new HashMap&amp;lt;&amp;gt;();
    tempMap.putAll(serverMap);
    for (String key : serverMap.keySet()) {
        for (int i = 0; i &amp;lt; serverMap.get(key); i++) {
            tempList.add(key);
        }
    }
    synchronized (index) {
        index++;
        if (index == tempList.size()) {
            index = 0;
        }
        return tempList.get(index);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次记录下了每台服务器的整体性能，给出一个数值，数值越大，性能越好。可以承受的请求也就越多，可以看到服务器 &lt;code&gt;192.168.1.5&lt;/code&gt; 的性能为 4，是其他服务器的两倍，依旧 10 w 请求测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;IP:192.168.1.3，次数：20000
IP:192.168.1.2，次数：20000
IP:192.168.1.5，次数：40000
IP:192.168.1.4，次数：20000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;192.168.1.5&lt;/code&gt; 承担了 2 倍的请求。&lt;/p&gt;
&lt;h2 id=&quot;4-随机加权&quot;&gt;4. 随机加权&lt;/h2&gt;
&lt;p&gt;随机加权的方式和轮训加权的方式大致相同，只是把使用互斥锁轮训的方式换成了随机访问，按照概率论来说，访问量增多时，服务访问也会达到负载均衡。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 服务器列表 */
private static HashMap&amp;lt;String, Integer&amp;gt; serverMap = new HashMap&amp;lt;&amp;gt;();
static {
    serverMap.put(&quot;192.168.1.2&quot;, 2);
    serverMap.put(&quot;192.168.1.3&quot;, 2);
    serverMap.put(&quot;192.168.1.4&quot;, 2);
    serverMap.put(&quot;192.168.1.5&quot;, 4);
}
/**
 * 加权路由算法
 */
public static String randomWithWeight() {
    List&amp;lt;String&amp;gt; tempList = new ArrayList();
    HashMap&amp;lt;String, Integer&amp;gt; tempMap = new HashMap&amp;lt;&amp;gt;();
    tempMap.putAll(serverMap);
    for (String key : serverMap.keySet()) {
        for (int i = 0; i &amp;lt; serverMap.get(key); i++) {
            tempList.add(key);
        }
    }
    int randomInt = new Random().nextInt(tempList.size());
    return tempList.get(randomInt);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依旧 10 w 请求测试，&lt;code&gt;192.168.1.5&lt;/code&gt; 的权重是其他服务器的近似两倍，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-log&quot;&gt;IP:192.168.1.3，次数：19934
IP:192.168.1.2，次数：20033
IP:192.168.1.5，次数：39900
IP:192.168.1.4，次数：20133
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5-ip-hash&quot;&gt;5. IP-Hash&lt;/h2&gt;
&lt;p&gt;上面的几种方式要么使用随机数，要么使用轮训，最终都达到了请求的负载均衡。但是也有一个很明显的缺点，就是同一个用户的多次请求很有可能不是同一个服务进行处理的，这时问题来了，如果你的服务依赖于 session ，那么因为服务不同， session 也会丢失，不是我们想要的，所以出现了一种根据请求端的 ip 进行哈希计算来决定请求到哪一台服务器的方式。这种方式可以保证同一个用户的请求落在同一个服务上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static List&amp;lt;String&amp;gt; serverList = new ArrayList&amp;lt;&amp;gt;();
static {
    serverList.add(&quot;192.168.1.2&quot;);
    serverList.add(&quot;192.168.1.3&quot;);
    serverList.add(&quot;192.168.1.4&quot;);
    serverList.add(&quot;192.168.1.5&quot;);
}

/**
 * ip hash 路由算法
 */
public static String ipHash(String ip) {
    // 复制遍历用的集合，防止操作中集合有变更
    List&amp;lt;String&amp;gt; tempList = new ArrayList&amp;lt;&amp;gt;(serverList.size());
    tempList.addAll(serverList);
    // 哈希计算请求的服务器
    int index = ip.hashCode() % serverList.size();
    return tempList.get(Math.abs(index));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6-总结&quot;&gt;6. 总结&lt;/h2&gt;
&lt;p&gt;上面的四种方式看似不错，那么这样操作下来真的体现了一开始说的负载均衡吗？答案是不一定的。就像上面的最后一个提问。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;又或者每次出手的力度不同，有重有轻，恰巧熊 4 总是承受这种大力度啪啪打脸，熊 4 即将不省熊事，还要继续打它吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务器也是这个道理，每次请求进行的操作对资源的消耗可能是不同的。比如说某些操作它对 CPU 的使用就是比较高，也很正常。&lt;strong&gt;所以负载均衡有时不能简单的通过请求的负载来作为负载均衡的唯一依据&lt;/strong&gt;。还可以结合服务的当前连接数量、最近响应时间等维度进行总体均衡，总而言之，就是为了达到资源使用的负载均衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2348178137652&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎Star和指教。更有一线大厂面试点，Java程序员需要掌握的核心知识等文章，也整理了很多我的文字，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets@439f6a5f6bd130e2aec56f3527656d6edb487b91/webinfo/weixin-public.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 01 Jun 2020 00:22:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>负载平衡（Load balancing）是一种在多个计算机（网络、CPU、磁盘）之间均匀分配资源，以提高资源利用的技术。使用负载均衡可以最大化服务吞吐量，可能最小化响应时间，同时由于使用负载均衡时，会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13021938.html</dc:identifier>
</item>
<item>
<title>这些Java8官方挖过的坑，你踩过几个？ - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/13023193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/13023193.html</guid>
<description>&lt;p&gt;系统启动异常日志竟然被JDK吞噬无法定位？同样的加密方法，竟然出现部分数据解密失败？往List里面添加数据竟然提示不支持？日期明明间隔1年却输出1天，难不成这是天上人间？1582年神秘消失的10天JDK能否识别？Stream很高大上，List转Map却全失败……这些JDK8官方挖的坑，你踩过几个？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;294.81050611657&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200601081243255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzMxMzA5OA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;导读：系统启动异常日志竟然被JDK吞噬无法定位？同样的加密方法，竟然出现部分数据解密失败？往List里面添加数据竟然提示不支持？日期明明间隔1年却输出1天，难不成这是天上人间？1582年神秘消失的10天JDK能否识别？Stream很高大上，List转Map却全失败……这些JDK8官方挖的坑，你踩过几个？ 关注公众号【码大叔】，实战踩坑硬核分享，一起交流！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@&lt;/p&gt;


&lt;p&gt;出于用户隐私信息保护的目的，系统上需将姓名、身份证、手机号等敏感信息进行加密存储，很自然选择了AES算法，外面又套了一层Base64，之前用的是sun.misc.BASE64Decoder/BASE64Encoder，网上的资料基本也都是这种写法，运行得很完美。但这种写法在idea或者maven编译时就会有一些黄色告警提示。到了Java 8后，Base64编码已经成为Java类库的标准，内置了 Base64 编码的编码器和解码器。于是乎，我手贱地修改了代码，改用了jdk8自带的Base64方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.Base64;

public class Base64Utils {

    public static final Base64.Decoder DECODER = Base64.getDecoder();
    public static final Base64.Encoder ENCODER = Base64.getDecoder();

    public static String encodeToString(byte[] textByte) {
        return ENCODER.encodeToString(textByte);
    }

    public static byte[] decode(String str) {
        return DECODER.decode(str);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序员的职业操守咱还是有的，构造新老数据、自测、通过，提交测试版本。信心满满，我要继续延续我 0 Bug的神话！然后……然后版本就被打回了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Caused by: java.lang.IllegalArgumentException: Illegal base64 character 3f
    at java.util.Base64$Decoder.decode0(Base64.java:714)
    at java.util.Base64$Decoder.decode(Base64.java:526)
    at java.util.Base64$Decoder.decode(Base64.java:549)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键是&lt;strong&gt;这个错还很诡异，部分数据是可以解密的，部分解不开&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Base64依赖于简单的编码和解码算法，使用65个字符的US-ASCII子集，其中前64个字符中的每一个都映射到等效的6位二进制序列，第65个字符（=）用于将Base64编码的文本填充到整数大小。后来产生了3个变种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RFC 4648：Basic&lt;br/&gt;此变体使用RFC 4648和RFC 2045的Base64字母表进行编码和解码。编码器将编码的输出流视为一行; 没有输出行分隔符。解码器拒绝包含Base64字母表之外的字符的编码。​&lt;/li&gt;
&lt;li&gt;RFC 2045：MIME&lt;br/&gt;此变体使用RFC 2045提供的Base64字母表进行编码和解码。编码的输出流被组织成不超过76个字符的行; 每行（最后一行除外）通过行分隔符与下一行分隔。解码期间将忽略Base64字母表中未找到的所有行分隔符或其他字符。&lt;/li&gt;
&lt;li&gt;RFC 4648：Url&lt;br/&gt;此变体使用RFC 4648中提供的Base64字母表进行编码和解码。字母表与前面显示的字母相同，只是-替换+和_替换/。不输出行分隔符。解码器拒绝包含Base64字母表之外的字符的编码。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;S.N.&lt;/th&gt;
&lt;th&gt;方法名称 &amp;amp; 描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Decoder getDecoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Decoder解码使用基本型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Encoder getEncoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Encoder编码使用的基本型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Decoder getMimeDecoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Decoder解码使用MIME类型的base64解码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Encoder getMimeEncoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Encoder编码使用MIME类型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)&lt;/strong&gt;&lt;br/&gt;返回Base64.Encoder编码使用指定的行长度和线分隔的MIME类型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Decoder getUrlDecoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Decoder解码使用URL和文件名安全型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;static Base64.Encoder getUrlEncoder()&lt;/strong&gt;&lt;br/&gt;返回Base64.Decoder解码使用URL和文件名安全型base64编码方案。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;关于base64用法的详细说明，可参考：&lt;a href=&quot;https://juejin.im/post/5c99b2976fb9a070e76376cc&quot;&gt;https://juejin.im/post/5c99b2976fb9a070e76376cc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于上面的错误，网上有的说法是，建议使用&lt;code&gt;Base64.getMimeDecoder()&lt;/code&gt;和&lt;code&gt;Base64.getMimeEncoder()&lt;/code&gt;，对此我只能建议：老的系统如果已经有数据了，就不要使用jdk自带的Base64了。JDK官方的Base64和sun的base64是不兼容的！不要替换！不要替换！不要替换！&lt;/p&gt;

&lt;p&gt;这个问题理解起来还是蛮费脑子的，所以我把这个系统异常发生的过程提炼成了一个美好的故事，放松一下，吟诗一首！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最怕相思浓&lt;br/&gt;一切皆是你&lt;br/&gt;唯独&lt;br/&gt;不敢说出你的名字&lt;br/&gt;-- 码大叔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题是在使用springboot的注解时遇到的问题，发现JDK在解析注解时，若注解依赖的类定义在JVM加载时不存在，也就是&lt;code&gt;NoClassDefFoundError&lt;/code&gt;时，实际拿到的异常将会是&lt;code&gt;ArrayStoreException&lt;/code&gt;，而不是&lt;code&gt;NoClassDefFoundError&lt;/code&gt;，涉及到的JDK里的类是&lt;code&gt;AnnotationParser.java&lt;/code&gt;, 具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static Object parseClassArray(int paramInt, ByteBuffer paramByteBuffer, ConstantPool paramConstantPool, Class&amp;lt;?&amp;gt; paramClass) {
    Class[] arrayOfClass = new Class[paramInt];
    int i = 0;
    int j = 0;
    for (int k = 0; k &amp;lt; paramInt; k++){
        j = paramByteBuffer.get();
        if (j == 99) {
            // 注意这个方法
                arrayOfClass[k] = parseClassValue(paramByteBuffer, paramConstantPool, paramClass);
        } else {
                skipMemberValue(j, paramByteBuffer);
                i = 1;
        }
    }
    return i != 0 ? exceptionProxy(j) : arrayOfClass;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static Object parseClassValue(ByteBuffer paramByteBuffer, ConstantPool paramConstantPool, Class&amp;lt;?&amp;gt; paramClass) {
    int i = paramByteBuffer.getShort() &amp;amp; 0xFFFF;
    try
    {
        String str = paramConstantPool.getUTF8At(i);
        return parseSig(str, paramClass);
    } catch (IllegalArgumentException localIllegalArgumentException) {
        return paramConstantPool.getClassAt(i);
    } catch (NoClassDefFoundError localNoClassDefFoundError) {
         // 注意这里，异常发生了转化
        return new TypeNotPresentExceptionProxy(&quot;[unknown]&quot;, localNoClassDefFoundError);
    } catch (TypeNotPresentException localTypeNotPresentException) {
        return new TypeNotPresentExceptionProxy(localTypeNotPresentException.typeName(), localTypeNotPresentException.getCause());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;parseClassArray&lt;/code&gt;这个方法中，预期&lt;code&gt;parseClassValue&lt;/code&gt;返回&lt;code&gt;Class&lt;/code&gt;对象，但看实际&lt;code&gt;parseClassValue&lt;/code&gt;的逻辑，在遇到&lt;code&gt;NoClassDefFoundError&lt;/code&gt;时，返回的是&lt;code&gt;TypeNotPresentExceptionProxy&lt;/code&gt;，由于类型强转失败，最终抛出的是&lt;code&gt;java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy&lt;/code&gt;，此时只能通过debug到这行代码，找到具体是缺少哪个类定义，才能解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;笔者重现一下发现这个坑的场景&lt;/strong&gt;，有三个module，module3依赖module2但未声明依赖module1，module2依赖module1，但声明的是optional类型，依赖关系图如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200531165100528.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面每个module中有一个Class，我们命名为ClassInModuleX。ClassInModule3启动时在注解中使用了ClassInModule2的类，而ClassInModule2这个类的继承了ClassInModule1，这几个类的依赖关系图如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020053116512919.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此，其实很容易知道在module运行ClassInModule3时，会出现ClassInModule1的&lt;code&gt;NoClassDefFoundError&lt;/code&gt;的，但实际运行时，你能看到的异常将不是&lt;code&gt;NoClassDefFoundError&lt;/code&gt;，而是&lt;code&gt;java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy&lt;/code&gt;，此时，若想要知道具体是何许异常，需通过debug在&lt;code&gt;AnnotationParser&lt;/code&gt;中定位具体问题，以下展示两个截图，分别对应系统控制台实际抛出的异常和通过debug发现的异常信息。&lt;/p&gt;
&lt;p&gt;控制台异常信息：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200531165224419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzMxMzA5OA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;注意异常实际在红色圈圈这里，自动收缩了，需要展开才可以看到通过debug发现的异常信息：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200531165333565.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如果你想体验这个示例，可关注公众号码大叔和笔者交流。如果你下次遇到莫名的&lt;code&gt;java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy&lt;/code&gt;,请记得用这个方法定位具体问题。&lt;/p&gt;

&lt;p&gt;Java8之前日期时间操作相当地麻烦，无论是Calendar还是SimpleDateFormat都让你觉得这个设计怎么如此地反人类，甚至还会出现多线程安全的问题，阿里巴巴开发手册中就曾禁用static修饰SimpleDateFormat。好在千呼万唤之后，使出来了，Java8带来了全新的日期和时间API，还带来了Period和Duration用于&lt;strong&gt;时间日期计算&lt;/strong&gt;的两个API。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Duraction和Period，都表示一段时间的间隔，Duraction正常用来表示时、分、秒甚至纳秒之间的时间间隔，Period正常用于年、月、日之间的时间间隔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;网上的大部分文章也是这么描述的&lt;/strong&gt;，于是计算两个日期间隔可以写成下面这样的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// parseToDate方法作用是将String转为LocalDate，略。
LocalDate date1 = parseToDate(&quot;2020-05-12&quot;);
LocalDate date2 = parseToDate(&quot;2021-05-13&quot;);
// 计算日期间隔
int period = Period.between(date1,date2).getDays();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个是202&lt;strong&gt;0&lt;/strong&gt;年，一个是202&lt;strong&gt;1&lt;/strong&gt;年，你认为间隔是多少？1年?&lt;br/&gt;恭喜你，和我一起跳进坑里了（画外音：里面的都挤一挤，动一动，又来新人了）。&lt;br/&gt;正确答案应该是：1天。&lt;/p&gt;
&lt;p&gt;这个单词的含义以及这个方法看起来确实是蛮误导人的，一不注意就会掉进坑里。&lt;strong&gt;Period其实只能计算同月的天数、同年的月数，不能计算跨月的天数以及跨年的月数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确写法1&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; long period = date2.toEpochDay()-date1.toEpochDay();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;toEpochDay()：将日期转换成Epoch 天，也就是相对于1970-01-01（ISO）开始的天数，和时间戳是一个道理，时间戳是秒数。显然，&lt;strong&gt;该方法是有一定的局限性的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确写法2&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;long period = date1.until(date2,ChronoUnit.DAYS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这个写法，一定要注意一下date1和date2前后顺序：date1 until date2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确做法3（推荐）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; long period = ChronoUnit.DAYS.between(date1, date2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ChronoUnit：一组标准的日期时间单位。这组单元提供基于单元的访问来操纵日期，时间或日期时间。 这些单元适用于多个日历系统。这是一个最终的、不可变的和线程安全的枚举。&lt;/p&gt;
&lt;p&gt;看到”适用于多个日历系统“这句话，我一下子想起来&lt;strong&gt;历史上1582年神秘消失的10天&lt;/strong&gt;，在JDK8上是什么效果呢？1582-10-15和1582-10-04你觉得会相隔几天呢？11天还是1天？有兴趣的小伙伴自己去写个代码试试吧。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200531140216942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzMxMzA5OA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;打开你的手机，跳转到1582年10月，你就能看到这消失的10天了。&lt;/p&gt;

&lt;p&gt;这个问题其实在JDK里存在很多年了，JDK8中依然存在，也是很多人最容易跳的一个坑！直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;String&amp;gt; allUser() {
    // 省略
    List&amp;lt;String&amp;gt; currentUserList = getUser();
    currentUserList.add(&quot;码大叔&quot;);
    // 省略
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是上面这样一段代码，往一个list里添加一条数据，你觉得结果是什么呢？“码大叔”成功地添加到了List里？天真，不报个错你怎么能意识到JDK存在呢。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.AbstractList.add(AbstractList.java:148)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：&lt;br/&gt;因为在getUser方法里，返回的List使用的是Arrays.asList生成的，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private List&amp;lt;String&amp;gt; getUser(){
        return Arrays.asList(&quot;剑圣&quot;,&quot;小九九&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看Arrays.asList的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a) {
        return new ArrayList&amp;lt;&amp;gt;(a);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; private static class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
        implements RandomAccess, java.io.Serializable
    {
                private final E[] a;
        // 部分代码略
        ArrayList(E[] array) {
            // 返回的是一个定长的数组
            a = Objects.requireNonNull(array);
        }
        // 部分代码略
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，返回的实际是一个定长的数组，所以只能“一如你我初见”，初始化什么样子就什么样子，不能新增，不能减少。如果你理解了，那我们就&lt;strong&gt;再来一个栗子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   int[] intArr  = {1,2,3,4,5};
   Integer[] integerArr  = {1,2,3,4,5};
   String[] strArr = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;};
   List list1 = Arrays.asList(intArr);
   List list2 = Arrays.asList(integerArr);
   List list3 = Arrays.asList(strArr);
   System.out.println(&quot;list1中的数量是：&quot; + list1.size());
   System.out.println(&quot;list2中的数量是：&quot; + list2.size());
   System.out.println(&quot;list3中的数量是：&quot; + list3.size());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你觉得答案是什么？预想3秒钟，揭晓答案，看跟你预想的是否一致呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;list1中的数量是：1
list2中的数量是：5
list3中的数量是：5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是和你预想又不一样了？还是回到Arrays.asList方法，该方法的输入只能是一个泛型变长参数。基本类型是不能泛型化的，也就是说8个基本类型不能作为泛型参数，要想作为泛型参数就必须使用其所对应的包装类型，那前面的例子传递了一个int类型的数组，为何程序没有报编译错误呢？在Java中，数组是一个对象，它是可以泛型化的，也就是说我们的例子是把一个int类型的数组作为了T的类型，所以在转换后在List中就只有1个类型为int数组的元素了。除了int，其它7个基本类型的数组也存在相似的问题。&lt;/p&gt;
&lt;p&gt;JDK里还为我们提供了一个便捷的集合操作工具类&lt;code&gt;Collections&lt;/code&gt;，比如多个List合并时，可以使用&lt;code&gt;Collections.addAll(list1,list2)&lt;/code&gt;, 在使用时也同样要时刻提醒自己：“请勿踩坑”！&lt;/p&gt;

&lt;p&gt;Java8中新增了Stream流 ，通过流我们能够对集合中的每个元素进行一系列并行或串行的流水线操作。当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以 像链条一样排列，变成一个管道。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200531174119825.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;项目上千万不要使用Stream，因为一旦用起来你会觉得真屏蔽词爽，根本停不下来&lt;/strong&gt;。当然不可避免的，还是有一些小坑的。&lt;/p&gt;
&lt;p&gt;假设我们分析用户的访问日志，放到list里。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;list.add(new User(&quot;码大叔&quot;, &quot;登录公众号&quot;));
list.add(new User(&quot;码大叔&quot;, &quot;编写文章&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为一些原因，我们要讲list转为map，Steam走起来，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static void convert2MapByStream(List&amp;lt;User&amp;gt; list) {
    Map&amp;lt;String, String&amp;gt; map = list.stream().collect(Collectors.toMap(User::getName, User::getValue));
    System.out.println(map);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;咣当，掉坑里了，程序将抛出异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Exception in thread &quot;main&quot; java.lang.IllegalStateException: Duplicate key 码大叔
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Collectors.toMap() 方法中时，默认key值是不允许重复的。当然，该方法还提供了第三个参数：也就是出现 duplicate key的时候的处理方案&lt;/p&gt;
&lt;p&gt;如果在开发的时候就考虑到了key可能重复，你需要在这样定义&lt;code&gt;convert2MapByStream&lt;/code&gt;方法，声明在遇到重复key时是使用新值还是原有值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void convert2MapByStream(List&amp;lt;User&amp;gt; list) {
        Map&amp;lt;String, String&amp;gt; map = list.stream().collect(Collectors.toMap(User::getName, User::getValue, (oldVal, newVal) -&amp;gt; newVal));
        System.out.println(map);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Stream的坑其实还是蛮多的，比如寻找list中的某个对象，可以使用&lt;code&gt;findAny().get()&lt;/code&gt;,你以为是找到就返回找不到就就返回null？依然天真，找不到会抛出异常的，需要使用额外的orElse方法。&lt;/p&gt;

&lt;p&gt;所谓JDK官方的坑，基本上都是因为我们对技术点了解的不够深入，望文生义，以为是怎样怎样的，而实际上我们的自以为是让我们掉进了一个又一个坑里。面对着这些坑，我流下了学艺不精的眼泪！但也有些坑，确实发生的莫名其妙，比如吞噬异常，没有理解JDK为什么这么设计。还有些坑，误导性确实太强了，比如日期计算、list操作等。最后只能说一句：&lt;/p&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行！&lt;br/&gt;编码不易，且行且珍惜！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=6b9b5a081e177c9edbee6d1fb013cb10&amp;amp;chksm=e98bf80cdefc711a988138f56561564eae3786582894fd78cb71e6280840e640424afd1d3d0d&amp;amp;token=1236259493&amp;amp;lang=zh_CN#rd&quot;&gt;Try-Catch包裹的代码异常后，竟然导致了产线事务回滚！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483846&amp;amp;idx=1&amp;amp;sn=4a3b2e22a5d825c6f75de50956202cb4&amp;amp;chksm=e98bfb8ddefc729b70608a64240e033fa23c670bfe45b326f3445b819fb034b1769b34882915&amp;amp;token=745351870&amp;amp;lang=zh_CN#rd&quot;&gt;Redis 6.0 新特性-多线程连环13问！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483813&amp;amp;idx=1&amp;amp;sn=2f46f3ccaf0898d4b5817e070526857c&amp;amp;chksm=e98bfbeedefc72f85ed1cea589fc8550ae5fa3d898c17ae1005ea090df62b2092f4370e9da2e&amp;amp;token=745351870&amp;amp;lang=zh_CN#rd&quot;&gt;报告老板，微服务高可用神器已祭出，您花巨资营销的高流量来了没？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483762&amp;amp;idx=1&amp;amp;sn=b25909118d494d60612329ad8ea56e57&amp;amp;chksm=e98bfb39defc722f197d8ed7b41a1e83a272db611ea1bf8ca013f25214441d91870637d89af3&amp;amp;token=745351870&amp;amp;lang=zh_CN#rd&quot;&gt;我成功攻击了Tomcat服务器，大佬们的反应亮了&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号：码大叔&lt;br/&gt;资深程序员、架构师技术社区&lt;br/&gt;微服务 | 大数据 | 架构设计 | 技术管理&lt;br/&gt;个人微信：itmadashu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 01 Jun 2020 00:19:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>系统启动异常日志竟然被JDK吞噬无法定位？同样的加密方法，竟然出现部分数据解密失败？往List里面添加数据竟然提示不支持？日期明明间隔1年却输出1天，难不成这是天上人间？1582年神秘消失的10天JD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/13023193.html</dc:identifier>
</item>
<item>
<title>被缠上了，小王问我怎么在 Spring Boot 中使用 JDBC 连接 MySQL - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/13023171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/13023171.html</guid>
<description>&lt;p&gt;上次帮小王&lt;a href=&quot;https://mp.weixin.qq.com/s/Ra9zotaUTsm3z-UMimB5pg&quot;&gt;入了 Spring Boot 的门&lt;/a&gt;后，他觉得我这个人和蔼可亲、平易近人，于是隔天小王又微信我说：“二哥，快教教我，怎么在 Spring Boot 项目中使用 JDBC 连接 MySQL 啊？”&lt;/p&gt;
&lt;p&gt;收到问题的时候，我有点头大，难道以后就要被小王缠上了？&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;没等我发牢骚，小王就紧接着说：“二哥，你先别生气，上次你帮了我的忙后，我在心里感激了你一晚上，想着第一次遇到这么亲切的大佬，一定要抱紧大腿。。。。。”&lt;/p&gt;
&lt;p&gt;马屁拍到这份上，我的气自然也就消了。随后，我花了五分钟的时间帮他解决了苦恼，没成想，他又发给我了一个小红包，表示对我的感谢。并建议我再写一篇文章出来，因为他觉得像他这样的小白还有很多。没办法，我关上门，开了灯，开始了今天这篇文章的创作。&lt;/p&gt;
&lt;h3 id=&quot;h01mysql&quot;&gt;&lt;span&gt;01、初始化 MySQL 数据库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;既然要连接 MySQL，那么就需要先在电脑上安装 MySQL 服务（本文暂且跳过），并且创建数据库和表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`springbootdemo`&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`mysql_datasource`&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`mysql_datasource`&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;`id`&lt;/span&gt;)&lt;br/&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h02springinitlallzrspringboot&quot;&gt;&lt;span&gt;02、使用 Spring Initlallzr 创建 Spring Boot 项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;创建一个 Spring Boot 项目非常简单，通过 Spring Initlallzr（&lt;a href=&quot;https://start.spring.io/&quot;&gt;https://start.spring.io/&lt;/a&gt;）就可以了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;勾选 Lombok、Web、MySQL Driver、Actuator、JDBC 等五个依赖。&lt;/p&gt;
&lt;p&gt;1）Lombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的一些冗余代码，比如说可以通过注解生成 getter/setter。使用之前需要先在 IDE 中安装插件。&lt;/p&gt;
&lt;p&gt;2）Web 表明该项目是一个 Web 项目，便于我们直接通过 URL 来实操。&lt;/p&gt;
&lt;p&gt;3）MySQL Driver：连接 MySQL 服务器的驱动器。&lt;/p&gt;
&lt;p&gt;4）Actuator 是 Spring Boot 提供的对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等。&lt;/p&gt;
&lt;p&gt;5）JDBC：本篇文章我们通过 JDBC 来连接和操作数据库。&lt;/p&gt;
&lt;p&gt;选项选择完后，就可以点击【Generate】按钮生成一个初始化的 Spring Boot 项目了。生成的是一个压缩包，导入到 IDE 的时候需要先解压。&lt;/p&gt;
&lt;h3 id=&quot;h03applicationproperties&quot;&gt;&lt;span&gt;03、编辑 application.properties 文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;项目导入成功后，等待 Maven 下载依赖，完成后编辑 application.properties 文件，配置 MySQL 数据源信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;spring.datasource.url=jdbc:mysql:&lt;br/&gt;spring.datasource.username=root&lt;br/&gt;spring.datasource.password=&lt;span class=&quot;hljs-number&quot;&gt;123456&lt;/span&gt;&lt;br/&gt;spring.datasource.driver-&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;-&lt;span class=&quot;hljs-title&quot;&gt;name&lt;/span&gt;&lt;/span&gt;=com.mysql.jdbc.Driver&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）&lt;code&gt;spring.datasource.&lt;/code&gt; 为固定格式。&lt;/p&gt;
&lt;p&gt;2）URL 为 MySQL 的连接地址。&lt;/p&gt;
&lt;p&gt;3）username 为数据库的访问用户名。&lt;/p&gt;
&lt;p&gt;4）password 为数据库的访问密码。&lt;/p&gt;
&lt;p&gt;5）driver-class-name 用来指定数据库的驱动器。也可以不指定，Spring Boot 会根据 URL（有 mysql 关键字） 自动匹配驱动器。&lt;/p&gt;
&lt;h3 id=&quot;h04springboot&quot;&gt;&lt;span&gt;04、编辑 Spring Boot 项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了便于我们操作，我们对 SpringBootMysqlApplication 类进行编辑，增加以下内容。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SpringBootMysqlApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; JdbcTemplate jdbcTemplate;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;insert&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String id = UUID.randomUUID().toString();&lt;br/&gt;String sql = &lt;span class=&quot;hljs-string&quot;&gt;&quot;insert into mysql_datasource (id,name) values ('&quot;&lt;/span&gt;+id+&lt;span class=&quot;hljs-string&quot;&gt;&quot;','沉默王二')&quot;&lt;/span&gt;;&lt;br/&gt;jdbcTemplate.execute(sql);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;插入完毕&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）@SpringBootApplication、@RestController、@RequestMapping 注解在[之前的文章]()中已经介绍过了，这里不再赘述。&lt;/p&gt;
&lt;p&gt;2）@Autowired：顾名思义，用于自动装配 Java Bean。&lt;/p&gt;
&lt;p&gt;3）JdbcTemplate：Spring 对数据库的操作在 jdbc 上做了深层次的封装，利用 Spring 的注入功能可以把 DataSource 注册到 JdbcTemplate 之中。JdbcTemplate 提供了四个常用的方法。&lt;/p&gt;
&lt;p&gt;①、execute() 方法：用于执行任何 SQL 语句。&lt;/p&gt;
&lt;p&gt;②、update() 方法：用于执行新增、修改、删除等 SQL 语句。&lt;/p&gt;
&lt;p&gt;③、query() 方法：用于执行查询相关 SQL 语句。&lt;/p&gt;
&lt;p&gt;④、call() 方法：用于执行存储过程、函数相关 SQL 语句。&lt;/p&gt;
&lt;p&gt;本例中我们使用 execute() 方法向 mysql_datasource 表中插入一行数据 &lt;code&gt;{id:uuid, name:'沉默王二'}&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h05springboot&quot;&gt;&lt;span&gt;05、运行 Spring Boot 项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;接下来，我们直接运行 &lt;code&gt;SpringBootMysqlApplication&lt;/code&gt; 类，这样一个 Spring Boot 项目就启动成功了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这时候，我们可以直接浏览器的 URL 中键入 &lt;code&gt;http://localhost:8080/insert&lt;/code&gt; 测试 MySQL 的插入语句是否执行成功。很遗憾，竟然出错了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;该怎么办呢？这需要我们在连接字符串中显式指定时区，修改 spring.datasource.url 为以下内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;spring.datasource.url=jdbc:mysql:&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新运行该项目后再次访问，发现数据插入成功了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;为了确保数据是否真的插入成功了，我们通过 Navicat（一款强大的数据库管理和设计工具）来查看一下。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;情况不妙，中文乱码了。该怎么办呢？需要我们在连接字符串中显式指定字符集，修改 spring.datasource.url 为以下内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;spring.datasource.url=&lt;span class=&quot;hljs-symbol&quot;&gt;jdbc:&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;mysql:&lt;/span&gt;/&lt;span class=&quot;hljs-regexp&quot;&gt;/127.0.0.1:3306/springbootdemo&lt;/span&gt;?useUnicode=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;amp;characterEncoding=utf-&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;&amp;amp;serverTimezone=UTC&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新运行该项目后再次访问，发现中文不再乱码了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;快给自己点个赞。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/06/java-springboot-jdbc-mysql-08.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我是沉默王二，一枚有趣的程序员。如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;666&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类）。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5890410958904&quot;&gt;
&lt;p&gt;本文 &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;GitHub&lt;/a&gt; 已经收录，有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原创不易，莫要白票，请你为本文点个赞吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jun 2020 00:04:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>上次帮小王入了 Spring Boot 的门后，他觉得我这个人和蔼可亲、平易近人，于是隔天小王又微信我说：“二哥，快教教我，怎么在 Spring Boot 项目中使用 JDBC 连接 MySQL 啊？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/13023171.html</dc:identifier>
</item>
<item>
<title>Blazor WebAssembly 修仙之途 - 组件与数据绑定 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/12990443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/12990443.html</guid>
<description>&lt;h2 id=&quot;一前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;在第一篇文章中，有提到过组件（Component）这个概念。组件在 Blazor 中是必不可少的，UI 全靠它组装起来，和前端的 JS 组件是一个意思，比如：vue component、react component 等等。借用官方文档的描述：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Blazor 应用是使用组件构建的。 组件是自包含的用户界面 (UI) 块，例如页、对话框或窗体。 组件包含插入数据或响应 UI 事件所需的 HTML Tag和处理逻辑。 组件非常灵活且轻量。 可在项目之间嵌套、重复使用和共享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二组件&quot;&gt;二.组件&lt;/h2&gt;
&lt;p&gt;组件一般以 .razor 为文件名后缀，且组件名必须以大写字母开头（猜测可能是和VUE里的命名限制一样，表面和Html标签名重复）。&lt;/p&gt;
&lt;p&gt;我们新建的项目，Shared 文件夹中就有三个组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005611659-2052178344.png&quot; alt=&quot;image-20200529233527594&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧导航菜单组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005611315-879908835.png&quot; alt=&quot;image-20200529233556081&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主布局组件中应用了导航菜单组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005610884-1673828097.png&quot; alt=&quot;image-20200529233635146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多关于组件的资料请查阅官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/blazor/components?view=aspnetcore-3.1&quot;&gt;创建和使用 ASP.NET Core Razor 组件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三数据绑定&quot;&gt;三.数据绑定&lt;/h2&gt;
&lt;h3 id=&quot;1介绍&quot;&gt;1.介绍&lt;/h3&gt;
&lt;p&gt;Razor 组件通过名为 &lt;code&gt;@bind&lt;/code&gt; 的HTML元素属性提供数据绑定功能，这个绑定是&lt;strong&gt;双向&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@bind&lt;/code&gt; 是区分大小写的，例如：&lt;code&gt;@BIND&lt;/code&gt;、&lt;code&gt;@Bind&lt;/code&gt; 都是错误的，下面写了一个例子，将 &lt;code&gt;CurrentValue&lt;/code&gt; 绑定到两个文本框中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;div class=&quot;col-6&quot;&amp;gt;
        &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @bind=&quot;CurrentValue&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;col-6&quot;&amp;gt;
        &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @bind=&quot;CurrentValue&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;ChangeValue&quot;&amp;gt;变 更&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

@code
{
    public int CurrentValue { get; set; } = 0;

    private void ChangeValue()
    {
        CurrentValue ++;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是在文本框的绑定中，仅当呈现组件时，UI才会更新文本框，而不响应于更改属性的值。由于组件是在事件处理程序代码执行后呈现的，因此属性更新&lt;em&gt;通常&lt;/em&gt;在触发事件处理程序后立即反映在UI中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@bind=&quot;CurrentValue&quot;&lt;/code&gt; 等同于以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input value=&quot;@CurrentValue&quot;
    @onchange=&quot;@((ChangeEventArgs __e) =&amp;gt; CurrentValue = 
        __e.Value.ToString())&quot; /&amp;gt;
        
@code {
    public int CurrentValue { get; set; } = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005610392-1900678474.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮，变更了值，也会应用到文本框中:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005609719-979803994.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2变更绑定事件&quot;&gt;2.变更绑定事件&lt;/h3&gt;
&lt;p&gt;上面小节中，默认绑定了 &lt;code&gt;onchange&lt;/code&gt; 事件，只有文本框失去焦点才会触发，体验不是很好，那么可不可以在输入的时候就同步更新值呢，当然是可以的，解决方案就是变更绑定事件为 &lt;code&gt;oninput&lt;/code&gt;，通过设置&lt;code&gt;@bind:event&lt;/code&gt;属性来变更绑定事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;col-6&quot;&amp;gt;
    &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @bind=&quot;CurrentValue&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;col-6&quot;&amp;gt;
    &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @bind=&quot;CurrentValue&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005608642-1415545187.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3输入错误的值&quot;&gt;3.输入错误的值&lt;/h3&gt;
&lt;p&gt;我们设置的 CurrentValue 的类型是 int ，如果我们输入字母，那么字母将不会被接受，同时值会恢复到输入前的正确值。&lt;/p&gt;
&lt;h3 id=&quot;4子父组件数据传递&quot;&gt;4.子父组件数据传递&lt;/h3&gt;
&lt;p&gt;在 vue、react 等 js 中，都有子父组件传值概念，Blazor 也不例外。&lt;/p&gt;
&lt;h4 id=&quot;（1）父传子&quot;&gt;（1）父传子&lt;/h4&gt;
&lt;p&gt;新建一个子组件命名为 &lt;code&gt;ChildComponent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;h2&amp;gt;子组件&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span&amp;gt;Year: &amp;lt;/span&amp;gt; &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; value=&quot;@Year&quot; /&amp;gt;
&amp;lt;/div&amp;gt;

@code {
    [Parameter]
    public int Year { get; set; }

    [Parameter]
    public EventCallback&amp;lt;int&amp;gt; YearChanged { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个 &lt;code&gt;Year&lt;/code&gt; 属性和 &lt;code&gt;EventCallback&amp;lt;int&amp;gt;&lt;/code&gt; 类型的属性 &lt;code&gt;YearChanged&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;新建一个父组件命名为&lt;code&gt;ParentComponent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;h2&amp;gt;父组件&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span&amp;gt;ParentYear: &amp;lt;/span&amp;gt; &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @bind=&quot;ParentYear&quot; @bind:event=&quot;oninput&quot;/&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;ChildComponent @bind-Year=&quot;ParentYear&quot; /&amp;gt;

@code {
    [Parameter]
    public int ParentYear { get; set; } = 1978;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在页面中引用父组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005608016-2006442857.png&quot; alt=&quot;image-20200530002006405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YearChanged&lt;/code&gt; 是一个约定命名，不能更改，更改将会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005607642-1456630023.png&quot; alt=&quot;image-20200530002227725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EventCallback 用于子父组件嵌套时公开事件，比如 YearChanged 就公开了子组件 Year 属性的 changed 事件。父组件里，通过 &lt;code&gt;@bind-Year&lt;/code&gt; 来绑定 &lt;code&gt;Year&lt;/code&gt; 的 changed 事件，然后将父组件 &lt;code&gt;ParentYear&lt;/code&gt; 的值传递过去，达成父级组件向子级组件传递值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;ChildComponent @bind-Year=&quot;ParentYear&quot; /&amp;gt;&lt;/code&gt; 等同于 &lt;code&gt;&amp;lt;ChildComponent @bind-Year=&quot;ParentYear&quot; @bind-Year:event=&quot;YearChanged&quot; /&amp;gt;&lt;/code&gt; ，如果使用后者，那么事件命名将不会受约定命名限制。&lt;/p&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005607133-1396038243.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;（2）子传父（链式绑定）&quot;&gt;（2）子传父（链式绑定）&lt;/h4&gt;
&lt;p&gt;子传父，无法直接通过 &lt;code&gt;@bind&lt;/code&gt; 来实现，需要单独指定事件处理程序和值，我们更改上面的子组件，定义一个 &lt;code&gt;OnYearChanged&lt;/code&gt; 事件，并将其绑定到文本框的 &lt;code&gt;oninput&lt;/code&gt; 事件，在事件里手动更新了 Year的值，并调用 YearChanged 来进行传递。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;h2&amp;gt;子组件&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span&amp;gt;Year: &amp;lt;/span&amp;gt; &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; @oninput=&quot;OnYearChanged&quot; value=&quot;@Year&quot; /&amp;gt;
&amp;lt;/div&amp;gt;

@code {
    [Parameter]
    public int Year { get; set; }

    [Parameter]
    public EventCallback&amp;lt;int&amp;gt; YearChanged { get; set; }

    private Task OnYearChanged(ChangeEventArgs e)
    {
        Year = int.Parse(e.Value.ToString());

        return YearChanged.InvokeAsync(Year);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200530005605838-616010896.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四资料&quot;&gt;四.资料&lt;/h2&gt;
</description>
<pubDate>Sun, 31 May 2020 23:38:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.前言 在第一篇文章中，有提到过组件（Component）这个概念。组件在 Blazor 中是必不可少的，UI 全靠它组装起来，和前端的 JS 组件是一个意思，比如：vue component、re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/12990443.html</dc:identifier>
</item>
</channel>
</rss>