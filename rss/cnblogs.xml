<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>云计算OpenStack：云计算介绍及组件安装（一） - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10564748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10564748.html</guid>
<description>&lt;p&gt;Openstack项目的版本按照ABCDEFG……的顺序发布，每6个月更新一次。&lt;/p&gt;&lt;p&gt;Openstack最初是由NASA和Rackspace共同发起的云端计算服务项目，该项目以Apache许可证授权的方式成为了一款开源产品，目的是将多个组件整合后从而实现一个开源的云计算平台，目前Openstack项目正在被红帽、IBM、AMD、Intel、戴尔、思科、微软等超过一百家厂商共同研发，并已经支持了几乎所有的常见云计算环境，拥有了良好的可扩展性，而且部署搭建Openstack服务也变得十分简单，目前国内对于云计算的需求也逐渐增加，华胜天成、高德地图、京东、阿里巴巴、百度、中兴、华为等中国企业也加入到了Openstack项目研发当中，Openstack项目也正在随着全球内得到了众多厂商的参与支持而快速成熟。&lt;/p&gt;&lt;p&gt;Open是开放，Stack则是堆砌之意，合起来就是将众多的功能服务堆积起来的集合，让人们通过Openstack云计算项目，能够将诸如计算能力、存储、网络和软件等资源抽象成服务，以便让用户可以通过互联网远程来享用，付费的形式也变得因需而定，调整方便，拥有极强的虚拟可扩展性，是公共和私有云的建设与管理软件中的优秀开源项目。&lt;/p&gt;&lt;p&gt;Openstack作为一个云平台的管理项目，其功能组件覆盖了网络、虚拟化、操作系统、服务器等多个方面，每个功能组件交由不同的项目委员会来研发和管理，目前核心的项目包括有：&lt;/p&gt;&lt;div readability=&quot;94.975212002609&quot;&gt;
&lt;table id=&quot;tablepress-151&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;项目名称&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt;计算服务                     &lt;/td&gt;
&lt;td&gt;Nova                                   &lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;负责虚拟机的创建、开关机、挂起、迁移、调整CPU、内存等规则。   (核心服务)                                     &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;对象存储&lt;/td&gt;
&lt;td&gt;Swift&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;用于在大规模可扩展系统中通过内置的冗余及高容差机制实现对象存储的系统。（可选服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;镜像服务&lt;/td&gt;
&lt;td&gt;Glance&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;用于创建、上传、删除、编辑镜像信息的虚拟机镜像查找及索引系统。  （核心服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;身份服务&lt;/td&gt;
&lt;td&gt;Keystone&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;为其他的功能服务提供身份验证、服务规则及服务令牌的功能。   （核心服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;网络管理&lt;/td&gt;
&lt;td&gt;Neutron&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;用于为其他服务提供云计算的网络虚拟化技术，可自定义各种网络规则，支持主流的网络厂商技术。（核心服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;块存储&lt;/td&gt;
&lt;td&gt;Cinder&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;为虚拟机实例提供稳定的数据块存储的创建、删除、挂载、卸载、管理等服务。（核心服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;图形界面&lt;/td&gt;
&lt;td&gt;Horizon&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;为用户提供简单易用的Web管理界面，降低用户对功能服务的操作难度。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;测量服务&lt;/td&gt;
&lt;td&gt;Ceilometer&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;收集项目内所有的事件，用于监控、计费或为其他服务提供数据支撑。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;部署编排&lt;/td&gt;
&lt;td&gt;Heat&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;实现通过模板方式进行自动化的资源环境部署服务。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;数据库服务&lt;/td&gt;
&lt;td&gt;Trove&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;为用户提供可扩展的关系或非关系性数据库服务。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;Openstack服务组件协同工作拓扑图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190320133456638-233247167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间菱形VM是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块&lt;/p&gt;

&lt;h2&gt;OpenStack部署环境规划&lt;/h2&gt;

&lt;p&gt;准备两台虚拟机，一台作为控制节点，一台作为计算节点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;控制节点（Controller Node）&lt;/strong&gt;： 管理 OpenStack，其上运行的服务有 Keystone、Glance、Horizon 、Neutron、Cinder以及 Nova 和 Neutron 中管理相关的组件。 控制节点也运行支持 OpenStack 的服务，例如 SQL 数据库（通常是 MySQL）、消息队列（通常是 RabbitMQ）和网络时间服务 NTP。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算节点（Compute Node）&lt;/strong&gt;：其上运行 Hypervisor（默认使用 KVM）。 同时运行 Neutron 服务的 agent，为虚拟机提供网络支持。&lt;/p&gt;

&lt;p&gt;控制节点IP: 192.168.64.7&lt;/p&gt;
&lt;p&gt;计算节点IP: 192.168.64.8&lt;/p&gt;

&lt;h2&gt;OpenStack部署环境准备&lt;/h2&gt;

&lt;p&gt;第一步：关闭防火墙&lt;/p&gt;
&lt;p&gt;两台虚拟机都要操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# setenforce &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[root@ken&lt;/span&gt;-node1 ~]# systemctl stop firewalld
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：域名解析&lt;/p&gt;
&lt;p&gt;两台节点都需要操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# vim /etc/&lt;span&gt;hosts
[root@ken&lt;/span&gt;-node1 ~]# scp /etc/hosts &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.8&lt;/span&gt;:/etc/&lt;span&gt;
The authenticity of host &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.64.8 (192.168.64.8)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t be established.&lt;/span&gt;
ECDSA key fingerprint &lt;span&gt;is&lt;/span&gt; SHA256:EO1X8PdzqfD689Y2WYB6eLvaO/&lt;span&gt;gvrWwhDd0cGDGmsgo.
ECDSA key fingerprint &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; MD5:6d:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:df:&lt;span&gt;78&lt;/span&gt;:ef:&lt;span&gt;63&lt;/span&gt;:1f:2a:2e:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;73&lt;/span&gt;&lt;span&gt;:bb:fc:9b.
Are you sure you want to &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; connecting (yes/no)?&lt;span&gt; yes
Warning: Permanently added &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.64.8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; (ECDSA) to the list of known hosts.
root@&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s password: &lt;/span&gt;
hosts                                                                                                                      &lt;span&gt;100&lt;/span&gt;%  &lt;span&gt;205&lt;/span&gt;   &lt;span&gt;113&lt;/span&gt;.9KB/s   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;    
[root@ken&lt;/span&gt;-node1 ~]# cat /etc/&lt;span&gt;hosts
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;   localhost localhost.localdomain localhost4 localhost4.localdomain4
::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;         localhost localhost.localdomain localhost6 localhost6.localdomain6
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.7&lt;/span&gt; ken-&lt;span&gt;node1
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.8&lt;/span&gt; ken-node2
&lt;/pre&gt;
&lt;p&gt;192.168.254.6 download.yunwei.edu  #解析公司内部源（外部用户无法使用）&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;第三步：测试外网连通性&lt;/p&gt;
&lt;p&gt;两台都操作&lt;/p&gt;
&lt;p&gt;我的两台节点都是使用的nat模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# ping -c &lt;span&gt;2&lt;/span&gt;&lt;span&gt; baidu.com
PING baidu.com (&lt;/span&gt;&lt;span&gt;123.125&lt;/span&gt;.&lt;span&gt;115.110&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;123.125&lt;/span&gt;.&lt;span&gt;115.110&lt;/span&gt; (&lt;span&gt;123.125&lt;/span&gt;.&lt;span&gt;115.110&lt;/span&gt;): icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;128&lt;/span&gt; time=&lt;span&gt;11.2&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;123.125&lt;/span&gt;.&lt;span&gt;115.110&lt;/span&gt; (&lt;span&gt;123.125&lt;/span&gt;.&lt;span&gt;115.110&lt;/span&gt;): icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;128&lt;/span&gt; time=&lt;span&gt;12.5&lt;/span&gt;&lt;span&gt; ms

&lt;/span&gt;--- baidu.com ping statistics ---
&lt;span&gt;2&lt;/span&gt; packets transmitted, &lt;span&gt;2&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;%&lt;span&gt; packet loss, time 1002ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;11.241&lt;/span&gt;/&lt;span&gt;11.889&lt;/span&gt;/&lt;span&gt;12.537&lt;/span&gt;/&lt;span&gt;0.648&lt;/span&gt; ms
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：使用公司源&lt;/p&gt;
&lt;p&gt;两台主机都安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# cat yum-&lt;span&gt;repo.sh 
mkdir &lt;/span&gt;/etc/yum.repos.d/&lt;span&gt;old
mv &lt;/span&gt;/etc/yum.repos.d/C* /etc/yum.repos.d/old/&lt;span&gt;
wget &lt;/span&gt;-O /etc/yum.repos.d/Centos7-Base-yunwei.repo    &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;254.6&lt;/span&gt;/shell/Centos7-Base-&lt;span&gt;yunwei.repo  
wget &lt;/span&gt;-O /etc/yum.repos.d/epel-yunwei.repo  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;254.6&lt;/span&gt;/shell/epel-&lt;span&gt;yunwei.repo
wget &lt;/span&gt;-O /etc/yum.repos.d/rdo-release-yunwei.repo  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;254.6&lt;/span&gt;/shell/rdo-release-&lt;span&gt;yunwei.repo
wget &lt;/span&gt;-O /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-Cloud  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;254.6&lt;/span&gt;/shell/RPM-GPG-KEY-CentOS-SIG-&lt;span&gt;Cloud
wget &lt;/span&gt;-O /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-&lt;span&gt;7&lt;/span&gt;  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;254.6&lt;/span&gt;/shell/RPM-GPG-KEY-EPEL-&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
yum repolist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第五步：开启虚拟机的虚拟化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190320141128220-2103968044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第六步：两台虚拟机时间统一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken-node2 ~&lt;span&gt;]# ntpdate time1.aliyun.com
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; Mar &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; ntpdate[&lt;span&gt;1160&lt;/span&gt;]: step time server &lt;span&gt;203.107&lt;/span&gt;.&lt;span&gt;6.88&lt;/span&gt; offset -&lt;span&gt;28800.262060&lt;/span&gt;&lt;span&gt; sec
[root@ken&lt;/span&gt;-node2 ~&lt;span&gt;]# date
Wed Mar &lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;52&lt;/span&gt; CST &lt;span&gt;2019&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;OpenStack组件安装&lt;/h2&gt;

&lt;h3&gt;OpenStack包&lt;/h3&gt;

&lt;p&gt;第一步：安装启用OpenStack仓库的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install centos-release-openstack-ocata -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：安装OpenStack客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install python-openstackclient -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步： 安装 &lt;tt&gt;openstack-selinux&lt;/tt&gt; 软件包以便自动管理 OpenStack 服务的安全策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install openstack-selinux -y
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;SQL数据库&lt;/h3&gt;

&lt;p&gt;第一步：安装软件包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install mariadb mariadb-server python2-PyMySQL -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：创建并编辑 &lt;tt&gt;/etc/my.cnf.d/openstack.cnf&lt;/tt&gt;，然后完成如下动作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# cat /etc/my.cnf.d/&lt;span&gt;openstack.cnf
[mysqld]
bind&lt;/span&gt;-address = &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.7  #绑定控制节点IP&lt;/span&gt;

&lt;span&gt;default&lt;/span&gt;-storage-engine =&lt;span&gt; innodb
innodb_file_per_table &lt;/span&gt;=&lt;span&gt; on
max_connections &lt;/span&gt;= &lt;span&gt;4096&lt;/span&gt;&lt;span&gt;
collation&lt;/span&gt;-server =&lt;span&gt; utf8_general_ci
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-server = utf8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：启动数据库服务，并将其配置为开机自启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~&lt;span&gt;]# systemctl enable mariadb.service
Created symlink &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/&lt;span&gt;mariadb.service.
[root@ken&lt;/span&gt;-node1 ~]# systemctl start mariadb.service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：为了保证数据库服务的安全性，运行``mysql_secure_installation``脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# mysql_secure_installation
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 消息队列&lt;/h3&gt;

&lt;p&gt;第一步：安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install rabbitmq-server -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：启动消息队列服务并将其配置为随系统启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# systemctl enable rabbitmq-&lt;span&gt;server.service
Created symlink &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; /etc/systemd/system/multi-user.target.wants/rabbitmq-server.service to /usr/lib/systemd/system/rabbitmq-&lt;span&gt;server.service.
[root@ken&lt;/span&gt;-node1 ~]# systemctl start rabbitmq-server.service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：添加 &lt;tt&gt;openstack&lt;/tt&gt; 用户&lt;/p&gt;
&lt;p&gt;密码为openstack&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~&lt;span&gt;]# rabbitmqctl add_user openstack openstack
Creating user &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openstack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：给``openstack``用户配置写和读权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# rabbitmqctl set_permissions openstack &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Setting permissions &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; user &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openstack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; vhost &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Memcached&lt;/h3&gt;

&lt;p&gt;第一步：安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# yum install memcached python-memcached -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：编辑配置文件/etc/sysconfig/memcached&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~]# vim /etc/sysconfig/&lt;span&gt;memcached
[root@ken&lt;/span&gt;-node1 ~]# cat /etc/sysconfig/&lt;span&gt;memcached
PORT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11211&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
USER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
MAXCONN&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CACHESIZE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OPTIONS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-l 127.0.0.1,::1,192.168.64.7&lt;/span&gt;&lt;span&gt;&quot; #后面添加Ip即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken-node1 ~&lt;span&gt;]# systemctl enable memcached.service
Created symlink &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; /etc/systemd/system/multi-user.target.wants/memcached.service to /usr/lib/systemd/system/&lt;span&gt;memcached.service.
[root@ken&lt;/span&gt;-node1 ~]# systemctl start memcached.service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此，所有的组件已经安装完毕，下节开始安装配置认证服务！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 20 Mar 2019 07:15:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>云计算介绍 当用户能够通过互联网方便的获取到计算、存储等服务时，我们比喻自己使用到了“云计算”，云计算并不能被称为是一种计算技术，而更像是一种服务模式。每个运维人员心里都有一个对云计算的理解，而最普遍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10564748.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2.X 如何优雅的解决跨域问题？ - java_lover</title>
<link>http://www.cnblogs.com/haha12/p/10564972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haha12/p/10564972.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;一、什么是源和跨域&lt;/h3&gt;
&lt;p&gt;源（origin）就是协议、域名和端口号。&lt;br/&gt;URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口全部相同，则表示他们同源。否则，只要协议、域名、端口有任何一个不同，就是跨域。&lt;/p&gt;
&lt;h5 id=&quot;hhttpswwwbaiducomindexhtml&quot;&gt;对https://www.baidu.com/index.html进行跨域比较：&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;URL&lt;/th&gt;
&lt;th&gt;是否跨域&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;https://www.baidu.com/more/index.html&lt;/td&gt;
&lt;td&gt;不跨域&lt;/td&gt;
&lt;td&gt;三要素相同&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;https://map.baidu.com/&lt;/td&gt;
&lt;td&gt;跨域&lt;/td&gt;
&lt;td&gt;域名不同&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;http://www.baidu.com/index.html&lt;/td&gt;
&lt;td&gt;跨域&lt;/td&gt;
&lt;td&gt;协议不同&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;https://www.baidu.com:81/index.html&lt;/td&gt;
&lt;td&gt;跨域&lt;/td&gt;
&lt;td&gt;端口号不同&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;h-1&quot;&gt;二、什么是同源策略？&lt;/h3&gt;
&lt;p&gt;同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;
&lt;p&gt;同源策略又分为以下两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DOM同源策略：禁止对不同源页面DOM 进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。&lt;/li&gt;
&lt;li&gt;XMLHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hspringboot&quot;&gt;三、Spring Boot跨域解决方案&lt;/h3&gt;
&lt;p&gt;本例使用Spring Boot 2.1.2.RELEASE演示，分别用8080和8081端口启动，部分代码如下：&lt;/p&gt;
&lt;p&gt;跨域页面：testOtherDomain.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;不同域名-Java碎碎念&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;b1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点我测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#b1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $.ajax({
            url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8081/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
                console.log(res);
            }
        })
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口类：HelloController&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.helloSpringBoot.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String HelloSpring (){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello Java碎碎念！&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 未解决跨域前运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/463242/201903/463242-20190320150244148-806268953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Spring Boot 2.X应用程序中可以使用注解@CrossOrigin，也可以通过使用WebMvcConfigurer对象来定义全局CORS配置。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;@CrossOrigin注解示例代码&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.helloSpringBoot.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.CrossOrigin;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @CrossOrigin
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String HelloSpring (){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello Java碎碎念！&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt; 2. &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;WebMvcConfigurer对象示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.helloSpringBoot.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.CorsRegistry;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyConfiguration {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebMvcConfigurer corsConfigurer() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebMvcConfigurer() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&lt;/span&gt;&quot;/*&quot;&lt;span&gt;)
                          .allowedOrigins(&lt;/span&gt;&quot;*&quot;&lt;span&gt;)
                          .allowCredentials(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                          .allowedMethods(&lt;/span&gt;&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;,&quot;PATCH&quot;&lt;span&gt;)
                          .maxAge(&lt;/span&gt;3600&lt;span&gt;);
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照上面两种方式的一种配置完成后，即可实现对跨域的支持，运行成功截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/463242/201903/463242-20190320150300391-968520347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完整源码地址：https://github.com/suisui2019/helloSpringBoot&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;推荐阅读&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mcxPf7o-vSazOewiFuyANQ&quot;&gt;1.Redis Cluster搭建高可用Redis服务器集群&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MIgbZV_ZoQ9zAzm6IgWEDA&quot;&gt;2.为什么单线程的Redis这么快？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XeXZZDyIuCPwM_o88P5-AA&quot;&gt;3.Spring Boot集成spring session实现session共享&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YW9nWbtHAMHWQ--PgUmZRg&quot;&gt;4.Spring Boot入门-快速搭建web项目&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XB0V_r538nQxXL_lQtRK0Q&quot;&gt;5.Spring Boot2.0整合Redis&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iYTlkd0vdLUS6fNcNAHXmw&quot;&gt;6.一篇文章搞定SpringMVC参数绑定&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;限时领取免费Java相关资料，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo/Kafka、Hadoop、Hbase、Flink等高并发分布式、大数据、机器学习等技术。&lt;br/&gt;关注下方公众号即可免费领取：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/463242/201903/463242-20190308150124591-2139175944.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Mar 2019 07:15:00 +0000</pubDate>
<dc:creator>java_lover</dc:creator>
<og:description>一、什么是源和跨域 源（origin）就是协议、域名和端口号。URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口全部相同，则表示他们同源。否则，只要协议、域名、端口有任何一个不同，就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haha12/p/10564972.html</dc:identifier>
</item>
<item>
<title>Ubuntu18.04下安装配置MongoDB4.0.6 - 殇灬央</title>
<link>http://www.cnblogs.com/shangyang/p/10563004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangyang/p/10563004.html</guid>
<description>&lt;h2&gt;安装MongoDB&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;1.下载安装包&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;MongoDB 提供了 linux 各发行版本 64 位的安装包，你可以在官网下载安装包。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center#community&quot; target=&quot;_blank&quot;&gt;https://www.mongodb.com/download-center#community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190319153117290-92491705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　注意：package选择TGZ&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.移动目录并解压&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;因为我的应用程序都放在/opt目录下，所以先将压缩包移动到/opt目录下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; mongodb-linux-x86_64-ubuntu1804-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;.tgz /opt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 进入/opt，将安装包解压缩&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;tar&lt;/span&gt; -zxvf mongodb-linux-x86_64-ubuntu1804-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190319154813677-565018206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为解压缩后名字较长，可将文件夹改名为mongodb。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; mongodb-linux-x86_64-ubuntu1804-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt; mongodb
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; &lt;span&gt;3.创建数据库目录。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;进入解压缩后的mongdb文件，创建data/db目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p data/db
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; /data/db 是 MongoDB 默认的启动的数据库路径,但可通过--dbpath指定这个目录。&lt;/p&gt;

&lt;p&gt;更改data和db目录的权限，增加写权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;cd data
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; db
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;4.添加环境配置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开~/.bashrc，将mongodb添加到环境变量中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190319172730941-2105708131.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 更新环境变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; source ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：一定要更新，不然变量不生效&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;5.启动MongoDB&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在mongodb中的bin目录下有这样的两个文件：mongod和mongo，mongod是服务器端，mongo是客户端。要启动mongodb服务，需要先开启mongod。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mongod --dbpath /opt/mongod/data/db
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190320091358692-1966737242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这样mongod就启动成功了。&lt;/p&gt;

&lt;p&gt;接下来可以通过mongo命令来启动MongoDB Shell&lt;/p&gt;
&lt;p&gt;另打开一个终端窗口，输入mongo，最后出现一个箭头表示启动成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190320091845579-28285741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;6.关闭MongoDB&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在mongo窗口输入以下命令即可关闭mongod服务端，然后exit即可推出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;use admin
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; db.shutdownServer()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;7.配置MongoDB&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 在/opt/mongodb/bin目录下新建一个配置文件mongod_config.txt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; vim mongod_config.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190320150309325-642289417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改文件的所有者并赋予权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; -&lt;span&gt;R shangyang:shangyang mongod_config.txt 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; mongod_config.txt 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样每次启动时就可通过配置文件来启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mongod --config /opt/mongodb/bin/mongod_config.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;访问MongoDB HTTP接口&lt;/h2&gt;
&lt;p&gt;MongoDB内置了一个HTTP接口，可以提供有关MongoDB服务器的信息。&lt;/p&gt;
&lt;p&gt;HTTP接口提供了有关MongoDB服务器的状态信息，还提供了一个REST接口，可以通过REST调用来访问数据库。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但该功能只适用于 MongoDB 3.2 及之前的早期版本。&lt;/em&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;如果在启动mongod或mongo时提示not found时，请检查~/.bashrc里的环境变量是否配置正确或应用。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要用ubuntu提供的apt install进行安装mongod-server-core和mongo-client。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过apt install得到的版本是3.xx版，不是4.0.6。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Mar 2019 07:10:00 +0000</pubDate>
<dc:creator>殇灬央</dc:creator>
<og:description>搭建MongoDB环境 安装MongoDB 1.下载安装包 MongoDB 提供了 linux 各发行版本 64 位的安装包，你可以在官网下载安装包。 下载地址：https://www.mongodb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangyang/p/10563004.html</dc:identifier>
</item>
<item>
<title>多媒体开发（7）：编译Android与iOS平台的FFmpeg - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10565025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10565025.html</guid>
<description>&lt;p&gt;编译FFmpeg，一个古老的话题，但小程还是介绍一遍，就当记录。之前介绍怎么给视频添加水印时，就已经提到FFmpeg的编译，并且在编译时指定了滤镜的功能。&lt;/p&gt;
&lt;p&gt;但是，在手机盛行的时代，读者可能更需要的是能在iOS或Android平台上运行的FFmpeg，而对于命令行的ffmpeg，读者可以在个人电脑上面使用（因为它简洁易操作），也可以在服务程序中使用（安装FFmpeg后直接调用ffmpeg命令），比如小程经常在自己的mac机上使用ffmpeg命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文介绍如何编译出iOS或Android平台使用的FFmpeg链接库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如编译macos平台使用的FFmpeg一样，编译iOS或Android平台使用的FFmpeg，主线也是先configure再make，只不过，有更多的细节需要考虑。&lt;/p&gt;
&lt;p&gt;小程使用的是macos系统。&lt;/p&gt;
&lt;h3 id=&quot;编译环境准备&quot;&gt;（1）编译环境准备&lt;/h3&gt;
&lt;h4 id=&quot;pkg-config&quot;&gt;pkg-config&lt;/h4&gt;
&lt;p&gt;FFmpeg在编译时经常使用到第三方库（比如x264、rtmp等），编译器在查找这些第三方库的头文件与库文件时，需要使用到程序pkg-config。&lt;/p&gt;
&lt;p&gt;pkg-conifig给编译器提供路径与链接选项。第三方库在make install时会生成pc后缀的文件并拷贝到系统目录，而pkg-config就是从这个pc文件读取出路径信息。&lt;/p&gt;
&lt;p&gt;这样安装pkg-config：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;brew install pkg-config&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装pkg-config后，可以这样得到第三方库的路径信息：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;pkg-config --cflags --libs librtmp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是对于pkg-config命令的一个载图：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/ffmpeg%E5%B0%B1%E7%94%A8-%E7%BC%96%E8%AF%91ffmpeg/pkg-config.png&quot; alt=&quot;pkg-config&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以设置PKG_CONFIG_PATH这个环境变量，让pkg-config到这个目录下面去找pc文件，如果不设置，则默认在/usr/local/lib/pkgconfig目录下面查找。&lt;/p&gt;
&lt;p&gt;需要注意，虽然pkg-config查找到的pc文件里面有记录到第三方静态库的路径，但实际在编译FFmpeg静态库时，并不会链接上这个第三方库，而且在FFmpeg的编译脚本中可以指定第三方库的路径。&lt;/p&gt;
&lt;h4 id=&quot;freetype&quot;&gt;freetype&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;此项只在使用滤镜功能时需要安装。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果编译时遇到这样的提示：freetype2 not found using pkg-config，那说明还没有安装freetype，这样安装即可：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;brew install freetype&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;clang编译器&quot;&gt;clang编译器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;此项只在编译iOS平台的FFmpeg时才需要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程的mac机已经安装过xcode，所以clang已经存在。如果读者还没有安装clang的话，那建议把xcode安装好。&lt;/p&gt;
&lt;h4 id=&quot;asm编译器&quot;&gt;asm编译器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;此项只在编译iOS平台的FFmpeg时才需要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;x264或FFmpeg等，都有汇编代码，编译这些汇编代码，需要使用更先进的编译脚本来处理，而mac系统没有这样的脚本。&lt;/p&gt;
&lt;p&gt;这个脚本是&lt;strong&gt;gas-preprocessor.pl&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以这样安装gas-preprocessor.pl：&lt;/p&gt;
&lt;blockquote readability=&quot;4.3975155279503&quot;&gt;
&lt;p&gt;git clone &lt;a href=&quot;git://github.com/mansr/gas-preprocessor.git&quot; class=&quot;uri&quot;&gt;git://github.com/mansr/gas-preprocessor.git&lt;/a&gt;&lt;br/&gt;sudo cp -f gas-preprocessor/gas-preprocessor.pl /usr/local/bin/&lt;br/&gt;chmod +x /usr/local/bin/gas-preprocessor.pl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;yasm&quot;&gt;yasm&lt;/h4&gt;
&lt;p&gt;另一个需要的工具是&lt;strong&gt;yasm&lt;/strong&gt;汇编编译器，可以这样安装：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;brew install yasm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;ndk工具包&quot;&gt;NDK工具包&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;此项只在编译Android平台的FFmpeg时才需要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用ndk-r9d版本，或者最新的版本，来编译FFmpeg。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://developer.android.google.cn/ndk/downloads/index.html&quot; class=&quot;uri&quot;&gt;https://developer.android.google.cn/ndk/downloads/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ffmpeg源码下载&quot;&gt;（2）FFmpeg源码下载&lt;/h3&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;git clone &lt;a href=&quot;git://source.ffmpeg.org/ffmpeg.git&quot; class=&quot;uri&quot;&gt;git://source.ffmpeg.org/ffmpeg.git&lt;/a&gt; ffmpeg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;编译脚本&quot;&gt;（3）编译脚本&lt;/h3&gt;
&lt;p&gt;不必自己重写了，找开源的项目过来修改一下（注意开源协议）就可以了，比如参考这个开源项目：&lt;br/&gt;&lt;a href=&quot;https://github.com/yixia/FFmpeg-Vitamio.git&quot; class=&quot;uri&quot;&gt;https://github.com/yixia/FFmpeg-Vitamio.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个项目里面，有编译Android跟iOS平台的相应脚本，而且有相应的优化处理。&lt;/p&gt;
&lt;p&gt;在移动平台使用的库都很注重两个东西，一个是性能，另一个是体积大小。一个好的脚本，既要根据不同的硬件类型作编译上的优化，也要根据软件需求裁剪FFmpeg的功能使得出来的库尽可能小（毕竟FFmpeg的功能并非全部都用上）。&lt;/p&gt;
&lt;h3 id=&quot;脚本修改&quot;&gt;（4）脚本修改&lt;/h3&gt;
&lt;p&gt;小程先介绍一下脚本里面的一些关键参数，这些参数并非平台通用。&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;指定指令集：&lt;br/&gt;--extra-cflags='-arch armv7s' --extra-ldflags='-arch armv7s'&lt;/p&gt;
&lt;p&gt;指定cpu类型：&lt;br/&gt;--arch=arm --cpu=cortex-a9&lt;br/&gt;（应该根据不同的指令集使用不同的cpu优化；--arch=arm64，像这样指定具体指令架构也是可以的。）&lt;/p&gt;
&lt;p&gt;指定系统：&lt;br/&gt;--target-os=darwin&lt;/p&gt;
&lt;p&gt;指定sdk：&lt;br/&gt;--sysroot=/Applications/Xcode.app/.../xxx.sdk&lt;/p&gt;
&lt;p&gt;指定编译器：&lt;br/&gt;--cc=xxx/clang&lt;/p&gt;
&lt;p&gt;指定库生成目录：&lt;br/&gt;--prefix=build&lt;/p&gt;
&lt;p&gt;指定使用的muxer/demuxer/encoder/decoder等：&lt;br/&gt;--enable-muxer=mp4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上使用上面介绍的脚本就可以编译了，但有时候也可以作一些修改，比如要加入第三方库时，或者要对某个指令集作优化时，等等。&lt;/p&gt;
&lt;p&gt;小程再提一些注意点，有可能帮到读者解决编译过程中遇到的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;--sysroot需要指定。iOS平台为....sdk/，不包括usr/inclue；Android平台是编译链的目录。&lt;br/&gt;extra-cflags跟extra-ldflags要指定-arch（iOS）或-march（Android）。&lt;br/&gt;在xcode8.3.2(sdk为10.3)上，armv7/armv7s/arm64不能使用&quot;-mfloat-abi=hard&quot;选项，并且arm64要指定-mcpu=cortex-a53。&lt;br/&gt;在xcode9.2（sdk为11.2）上，需要--disable-asm。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于实际项目来说，FFmpeg的编译是关键的一步，应该多花时间去研究一些关键的细节--功能、性能跟体积大小都很重要。&lt;/p&gt;
&lt;h3 id=&quot;开始编译&quot;&gt;（5）开始编译&lt;/h3&gt;
&lt;p&gt;运行脚本即可。最终会生成二进制库，比如iOS一般为静态库（.a文件），而Android一般为动态库（.so文件）。&lt;/p&gt;
&lt;p&gt;至此，已经介绍完在iOS或Android平台编译FFmpeg的过程。&lt;/p&gt;
&lt;p&gt;在编译得到FFmpeg的链接库后，就可以调用它，让它运行起来。这时，需要写自己的调用程序。在这里给出一个简单的调用示例，并且不做代码解释，只是让有需要的读者有一个感知。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;extern &quot;C&quot; {
#include &quot;libavcodec/avcodec.h&quot;
#include &quot;libavformat/avformat.h&quot;
}

void dump_file_format(const char* filepath) {
    av_register_all();
    av_log_set_level(AV_LOG_DEBUG);
    AVFormatContext* formatContext = avformat_alloc_context();
    AVCodecContext* codecContext = NULL;
    int status = 0;
    bool success = false;
    int audioindex = -1;
    status = avformat_open_input(&amp;amp;formatContext, filepath, NULL, NULL);
    if (status == 0) {
        status = avformat_find_stream_info(formatContext, NULL);
        if (status &amp;gt;= 0) {
            for (int i = 0; i &amp;lt; formatContext-&amp;gt;nb_streams; i ++) {
                if (formatContext-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_AUDIO) {
                    audioindex = i;
                    break;
                }   
            }
            if (audioindex &amp;gt; -1) {
                codecContext = formatContext-&amp;gt;streams[audioindex]-&amp;gt;codec;
                AVCodec* codec = avcodec_find_decoder(codecContext-&amp;gt;codec_id);
                if (codec) {
                    status = avcodec_open2(codecContext, codec, NULL);
                    if (status == 0) {
                        success = true; 
                    }
                }
            }
        }
    }
    if (success) {
        av_dump_format(formatContext, 0, filepath, false);
        av_log(NULL, AV_LOG_DEBUG, &quot;format and decoder sucessful, and now in decoding each frame\n&quot;);
        printf(&quot;sample_rate=%d, channels=%d\n&quot;, codecContext-&amp;gt;sample_rate, codecContext-&amp;gt;channels);
    }
    avformat_free_context(formatContext);
}

int main(int argc, const char *argv[])
{
    const char filepath[] = &quot;test2.mp3&quot;;    
    dump_file_format(filepath);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;总结一下，本文介绍了在macos上，编译出iOS平台或Android平台的FFmpeg的链接库的过程，涉及到编译环境的准备、编译脚本的理解与定制等内容。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Mar 2019 07:07:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>编译FFmpeg，一个古老的话题，但小程还是介绍一遍，就当记录。之前介绍怎么给视频添加水印时，就已经提到FFmpeg的编译，并且在编译时指定了滤镜的功能。 但是，在手机盛行的时代，读者可能更需要的是能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10565025.html</dc:identifier>
</item>
<item>
<title>uni-app—从安装到实战 - 俗的太不一样</title>
<link>http://www.cnblogs.com/qisi007/p/10489176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qisi007/p/10489176.html</guid>
<description>

&lt;p&gt;uni-app实现了一套代码，同时运行到多个平台。支持iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307132327001-213756040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;工具安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发uni-app需要安装HBuilder X.&lt;a href=&quot;http://www.dcloud.io/hbuilderx.html&quot; target=&quot;_blank&quot;&gt;下载地址&lt;/a&gt;。&lt;a href=&quot;http://www.dcloud.io/hbuilderx.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307132435888-1392093562.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载成功后直接解压即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307132810032-1469178924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单的配置一下开发偏好：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307132929460-1941258458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 创建第一个uni-app&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击左上角【文件】&amp;gt;&amp;gt;【新建】&amp;gt;&amp;gt;【项目】，选择uni-app模板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307133417268-2066409206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;uni-app目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190307134013876-188390032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目录结构基本和小程序的目录结构相似，只是多了个基础组件的文件夹；&lt;/p&gt;
&lt;p&gt;uni-app有自己的插件库，直接点击安装即可，而且，它也支持npm包管理，点击【工具】&amp;gt;&amp;gt; 【插件安装】即可配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320115522036-1601620891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;好了，基本的安装工作就是这么多，下面我们看一下如何调试&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;调试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;浏览器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;uni-app支持多个端同时调试，这也是它最便捷的地方，首先看一下浏览器端的调试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调试之前我们首先要配置一下你的浏览器的安装路径，默认HBuilder是检测不到的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击【运行】&amp;gt;&amp;gt;【运行到浏览器】&amp;gt;&amp;gt; 【配置web服务器】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190317164503103-1918420145.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;把浏览器的安装路径粘贴在里边即可&lt;/p&gt;
&lt;p&gt;然后就能够调试了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190317164158067-1880221665.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 然后我们看一下真机&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;手机调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以安卓手机为例，需要开启开发者模式才能进行调试，方法如下：&lt;/p&gt;
&lt;p&gt;打开【设置】&amp;gt;&amp;gt; 【关于本机】，找到【软件版本】，连续点击五次，即可开启开发者选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320113740338-1173208596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;开发者选项的开启和关闭在【设置】 &amp;gt;&amp;gt; 【高级设置】&amp;gt;&amp;gt; 【开发者选项】，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320113920252-1963454477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入打开 【USB调试】，插上数据线连接手机，然后就能真机调试了。中途可能要进行一次授权，点击确认即可，授权成功后你的手机上会安装一个HBuilder app，你之后再开发环境中做的所有效果都会渲染到这个app中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320114112562-763622699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击，选择自己的手机即可调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320114508758-1210116307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;iphone手机更加简单，连接手机后直接运行，他会报错，然后在手机设置一下就行了，步骤如下：&lt;/p&gt;
&lt;p&gt;【设置】&amp;gt;&amp;gt; 【通用】&amp;gt;&amp;gt; 【设备管理】,信任一下HBuilder即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小程序调试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击 【运行】 &amp;gt;&amp;gt; 【运行到小程序模拟器】&amp;gt;&amp;gt; 【运行设置】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320114551699-762922019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开后把微信开发者工具的安装路径粘贴多对应的地址栏即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320114734206-1111016709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要注意两点： 1）微信开发者工具必须是官方最新版。 2）微信开发者工具需要授权，方法如下：&lt;/p&gt;
&lt;p&gt;打开微信开发者工具，点击设置图标&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320114947161-59184337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择【安全】，服务端口选择开启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320115006280-1082150682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后即可进行微信小程序调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320115119825-46251091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;*百度，支付宝，字节跳动小程序步骤和微信类似&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;uni-app项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我做了一个简单的demo，项目结构如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320142329969-286489152.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我把每个不同的功能分了不同的文件夹，相当于不同的层（每个文件夹里可以根据业务在进行细分）,请求工具我用的uni-app官方的api（uni.request），在此基础上我进行了简单的二次封装，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; uni-app请求封装&lt;/span&gt;
&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Request {
    http (router,data&lt;/span&gt;=&lt;span&gt;{},method) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基础地址&lt;/span&gt;
        let path = 'http://mock.allhome.com.cn/mock/5c91b03a2add03001024c420/uni'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回promise&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve,reject) =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求&lt;/span&gt;
&lt;span&gt;            uni.request({
                url: `${path}${router}`,
                data: data,
                method:method,
                success: (res) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将结果抛出&lt;/span&gt;
&lt;span&gt;                    resolve(res.data)
                }
            })
        })    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类接受三个参数，第一个是后端的路由地址，第二个是需要给后端传的实体，第三个是请求方法，该类返回一个Promise，请求成功后将结果抛出，最后在api.js文件中引用并实例化，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import Request from '../static/js/request.js'&lt;span&gt;;
let request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request().http



export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    getJobList: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request('/jobList',{},'GET'&lt;span&gt;)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以在组件里取结果了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import api from '../../api/api.js'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
        data() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                listArr: []
            }
        },
        onLoad() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求职位列表&lt;/span&gt;
            api.getJobList().then(res =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listArr =&lt;span&gt; res.data
            })
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 好了，基本的情况就是 这么多，最后是调试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201903/1412010-20190320143147192-1035641006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;该项目代码我已经上传到了gitlab上：&lt;a href=&quot;https://git.allhome.com.cn/color-z/uni-app&quot; target=&quot;_blank&quot;&gt;gitlab项目地址&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Mar 2019 06:43:00 +0000</pubDate>
<dc:creator>俗的太不一样</dc:creator>
<og:description>uni-app实现了一套代码，同时运行到多个平台。支持iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具 工具安装 开发uni-ap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qisi007/p/10489176.html</dc:identifier>
</item>
<item>
<title>Akka-CQRS（3）- 再想多点，全面点 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/10564790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/10564790.html</guid>
<description>&lt;p&gt;&lt;span&gt;   上篇我介绍了CQRS模式存写部分的具体实现和akka-persistence一些函数和消息的用法。在这篇本来是准备直接用一个具体的例子来示范CQRS模式编程，主要是写端，或者是数据采集端。想着模拟收银机的后端操作，可以使用集群分片（cluster-sharding），每个分片shard代表一部POS机控制系统。在写这段程序之前首先把示例功能实现、cluster-sharding, persistence-actor,actor-passivation, backoff-supervisor, ClusterSharding.start和ClusterSharding.startProxy等技术细节搞清楚：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、构建几个测试销售的产品信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、设计一套简单但功能完整的操作指令command&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、设计运算状态，即一单未结算销售单据的状态。相关的指令-事件command-event转换和状态更新机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、单据状态初始化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、业务逻辑部分，从接到各项指令、指令-事件转换、处理副作用、存写事件、更新单据状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、结束单据处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以一单支付金额大于等于应付金额作为整单结束状态。此时应进行下面的处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     1）增加单号  2）清除所有交易项目  3）saveSnapshot  (重启就不用恢复前面的事件persistent-events)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、资源释放策略及处理 passivation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个shard-entity暂不使用时最好先停掉stop以释放它占用的资源。但用常规的方式停止entity会造成mailbox里未处理的消息丢失，所以cluster-sharding有一套特别的机制ClusterSharding.Passivate(actorRef)来实现shard-entity的安全停用，即：目标entity向ShardRegion发送Passivate(stopMessage)消息、ShardRegion向目标entity发送包嵌在消息里的stopMessage。目标entity在收到消息后可以自行停止。ShardRegion会保留收到Passivate消息到目标entity停止之间收到的消息，还给再启动的entity。在本例子里passivation的应用场景如下：每单支付后如果一段时间没有收到新的开单指令，这个shard-entity可以通过向ShardRegion发送Passivate消息或按空转时间段设定自动passivate自己，这时ShardRegion在entity空转超出时间后自动发送ClusterSharding.start(...)里定义的handOffStopMessage(PoisonPill)，如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def passivate(entity: ActorRef, stopMessage: Any): Unit =&lt;span&gt; {
    idByRef.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(entity) match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(id) ⇒ &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;messageBuffers.contains(id)) {
        passivating &lt;/span&gt;= passivating +&lt;span&gt; entity
        messageBuffers.add(id)
        entity &lt;/span&gt;!&lt;span&gt; stopMessage
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        log.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Passivation already in progress for {}. Not sending stopMessage back to entity.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, entity)
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None ⇒ log.debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown entity {}. Not sending stopMessage back to entity.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, entity)
    }
  }

  def passivateIdleEntities(): Unit &lt;/span&gt;=&lt;span&gt; {
    val deadline &lt;/span&gt;= System.nanoTime() -&lt;span&gt; settings.passivateIdleEntityAfter.toNanos
    val refsToPassivate &lt;/span&gt;=&lt;span&gt; lastMessageTimestamp.collect {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (entityId, lastMessageTimestamp) &lt;span&gt;if&lt;/span&gt; lastMessageTimestamp &amp;lt;&lt;span&gt; deadline ⇒ refById(entityId)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (refsToPassivate.nonEmpty) {
      log.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Passivating [{}] idle entities&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, refsToPassivate.size)
      refsToPassivate.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;&lt;span&gt;(passivate(_, handOffStopMessage))
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;启动passivation的时间长度可以通过配置文件或者直接在代码里设置：在配置文件中设置 akka.cluster.sharding.passivate-idle-entity-after = 2m，代表两分钟内没有接收从ShardRegion发来的POS指令即启动passivation（经entity自身actor或actorRef收发的消息不算）。可以设置off关闭自动passivation。其它设置值参考如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ns, nano, nanos, nanosecond, nanoseconds
us, micro, micros, microsecond, microseconds
ms, milli, millis, millisecond, milliseconds
s, second, seconds
m, minute, minutes
h, hour, hours
d, day, days&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;也可以直接在代码里设定&lt;code&gt;ClusterShardingSettings.passivateIdleEntityAfter=2 minutes。不过我们还是选择配置文件方式，比较灵活。下面是一个包括了passivation, backoffSupervisor的示范代码：&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import akka.cluster.sharding.ShardRegion.Passivate
import scala.concurrent.duration._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SupervisionSpec {
  val config &lt;/span&gt;=&lt;span&gt;
    ConfigFactory.parseString(
      &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;    akka.actor.provider = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    akka.loglevel &lt;/span&gt;=&lt;span&gt; INFO
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Msg(id: Long, msg: Any)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Response(self: ActorRef)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; StopMessage

  val idExtractor: ShardRegion.ExtractEntityId &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Msg(id, msg) ⇒ (id.toString, msg)
  }

  val shardResolver: ShardRegion.ExtractShardId &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Msg(id, msg) ⇒ (id % &lt;span&gt;2&lt;/span&gt;&lt;span&gt;).toString
  }

  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PassivatingActor extends Actor with ActorLogging {

    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def preStart(): Unit =&lt;span&gt; {
      log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def postStop(): Unit =&lt;span&gt; {
      log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def receive: Receive =&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passivate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ⇒
        log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Passivating&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        context.parent &lt;/span&gt;!&lt;span&gt; Passivate(StopMessage)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; simulate another message causing a stop before the region sends the stop message
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. a persistent actor having a persist failure while processing the next message&lt;/span&gt;
&lt;span&gt;        context.stop(self)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ⇒
        sender() &lt;/span&gt;!&lt;span&gt; Response(self)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StopMessage ⇒
        log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Received stop from region&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        context.parent &lt;/span&gt;!&lt;span&gt; PoisonPill
    }
  }

}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SupervisionSpec extends AkkaSpec(SupervisionSpec.config) with ImplicitSender {

  import SupervisionSpec._

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Supervision for a sharded actor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; must {

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allow passivation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; {

      val supervisedProps &lt;/span&gt;=&lt;span&gt; BackoffSupervisor.props(Backoff.onStop(
        Props(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PassivatingActor()),
        childName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        minBackoff &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.seconds,
        maxBackoff &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;.seconds,
        randomFactor &lt;/span&gt;= &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;,
        maxNrOfRetries &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      ).withFinalStopMessage(_ &lt;/span&gt;==&lt;span&gt; StopMessage))

      Cluster(system).join(Cluster(system).selfAddress)
      val region &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).start(
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        supervisedProps,
        ClusterShardingSettings(system),
        idExtractor,
        shardResolver
      )

      region &lt;/span&gt;! Msg(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      val response &lt;/span&gt;= expectMsgType[Response](&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.seconds)
      watch(response.self)

      region &lt;/span&gt;! Msg(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passivate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      expectTerminated(response.self)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This would fail before as sharded actor would be stuck passivating&lt;/span&gt;
      region ! Msg(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      expectMsgType[Response](&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;.seconds)
    }
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8、异常处理、重试策略 backoffsupervisor 实现，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      val supervisedProps =&lt;span&gt; BackoffSupervisor.props(Backoff.onStop(
        Props(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventWriter()),
        childName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        minBackoff &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.seconds,
        maxBackoff &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;.seconds,
        randomFactor &lt;/span&gt;= &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;,
        maxNrOfRetries &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      ))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动passivate时设定  .withFinalStopMessage(_ == StopMessage))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;9、分片sharding部署&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说可以通过ClusterSharding(system).start(...)在每个节点上部署分片，如：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;      ClusterSharding(system).start(
        typeName &lt;/span&gt;=&lt;span&gt; shardName,
        entityProps &lt;/span&gt;=&lt;span&gt; POSProps,
        settings &lt;/span&gt;=&lt;span&gt; mySettings,
        extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
        extractShardId &lt;/span&gt;=&lt;span&gt; getShopId,
        allocationStrategy &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).defaultShardAllocationStrategy(mySettings),
        handOffStopMessage &lt;/span&gt;=&lt;span&gt; PassivatePOS
      )&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;但如果分片的调用客户端所在节点因某种原因不能部署分片时可以用ClusterSharding(system).startProxy(...)部署一个分片代理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;      ClusterSharding(system).startProxy(
        typeName &lt;/span&gt;=&lt;span&gt; shardName,
        role &lt;/span&gt;=&lt;span&gt; Some(role),
        extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
        extractShardId &lt;/span&gt;=&lt;span&gt; getShopId
      )&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际上当所在节点的role不等于startProxy参数role时才能启动这个分片代理。下面是一个成功部署分片代理的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def create(port: Int): ActorSystem =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config: Config =&lt;span&gt; ConfigFactory.load()
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (port != &lt;span&gt;2554&lt;/span&gt;&lt;span&gt;)
       config &lt;/span&gt;= ConfigFactory.parseString(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.port=$port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         .withFallback(ConfigFactory.parseString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.cluster.roles = [shard]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
         .withFallback(ConfigFactory.load())
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
       config &lt;/span&gt;= ConfigFactory.parseString(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.port=$port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         .withFallback(ConfigFactory.load())

    val system &lt;/span&gt;= ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;posSystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,config)
    val role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    val mySettings &lt;/span&gt;= ClusterShardingSettings(system)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.withPassivateIdleAfter(10 seconds)&lt;/span&gt;
&lt;span&gt;      .withRole(role)
 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

     val allocationStrategy = new ShardCoordinator.LeastShardAllocationStrategy(rebalanceThreshold = 2, maxSimultaneousRebalance = 1)
 val region = ClusterSharding(system).start(
      &quot;myType&quot;,
      InactiveEntityPassivationSpec.Entity.props(probe.ref),
      settings,
      extractEntityId,
      extractShardId,
      ClusterSharding(system).defaultShardAllocationStrategy(settings),
      Passivate
    )   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (port != &lt;span&gt;2554&lt;/span&gt;&lt;span&gt;) {
      ClusterSharding(system).start(
        typeName &lt;/span&gt;=&lt;span&gt; shardName,
        entityProps &lt;/span&gt;=&lt;span&gt; POSProps,
        settings &lt;/span&gt;=&lt;span&gt; mySettings,
        extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
        extractShardId &lt;/span&gt;=&lt;span&gt; getShopId,
        allocationStrategy &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).defaultShardAllocationStrategy(mySettings),
        handOffStopMessage &lt;/span&gt;=&lt;span&gt; PassivatePOS
      )
      println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;************** cluster-shard created at port $port **************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      ClusterSharding(system).startProxy(
        typeName &lt;/span&gt;=&lt;span&gt; shardName,
        role &lt;/span&gt;=&lt;span&gt; Some(role),
        extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
        extractShardId &lt;/span&gt;=&lt;span&gt; getShopId
      )
      println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;************** cluster-shard-proxy created at port $port **************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    }

    val eventListener &lt;/span&gt;= system.actorOf(Props[EventLisener],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eventListener&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    system
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;配置文件指定分片部署role例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  cluster {
    seed&lt;/span&gt;-nodes =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.tcp://posSystem@127.0.0.1:2551&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

    log&lt;/span&gt;-info =&lt;span&gt; off
    sharding {
      role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      passivate&lt;/span&gt;-idle-entity-after = &lt;span&gt;10&lt;/span&gt;&lt;span&gt; s
    }
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;10、设计后端执行命令后返回的结果类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11、设计一套POS前端的命名规则：因为有关POS过程的事件持久化是以persistenceId辨别的，所以一个POS编号应该有一个对应的persistenceId，所有这个POS编号的事件都以对应的persistenceId来存储。我们先跳到ClusterSharding是如何动态地构建和部署ShardRegion和entity的：ClusterSharding是通过两个函数extractShardId,extractEntityId来对应ShardRegion和Entity实例的。用一个shardId去调用ShardRegion，如果不存在就用这个Id构建一个。ShardRegion是个actor，那么这个Id应该就是它的ActorPath.name。同样ShardRegion也会用一个entityId去构建Entity。这个entityId也就是Entity的ActorPath.name了。而从ActorPath结构来看：ShardRegion是Entity的父辈。最终，我们可以用父子关系的ActorPath.name来代表persistenceId，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; self.path.parent.name is the type name (utf-8 URL-encoded)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; self.path.name is the entry identifier (utf-8 URL-encoded)  but entity has a supervisor&lt;/span&gt;
  &lt;span&gt;override&lt;/span&gt; def persistenceId: String = self.path.parent.parent.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + self.path.parent.name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果考虑的全面些，我们可以把区域zone,门店shop,部门dpt,POS机合并成一个唯一的Id：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1位zoneId+3位shopId+2位dptId+4位POSId =&amp;gt; 10位POSUID 如1001019365&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12、用actor来模拟POS前端。店号与shardId, 机号与entityId对应。暂时用以显示后端执行指令结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上这12个关注点算是我编程前的一些思路和备注。然后就开始写示范代码了。经历了好几遍周折，这段CQRS的C部分是越写越细、越复杂。主要是想把这个例子做成一个将来可以落地的项目（刚好有朋友公司他们提供零售IT解决方案，需要一个平台化android前端POS解决方案），自不然又不断考虑前端移动客户和后端CQRS的Q部分如何实现的问题，这时在一个局部功能的实现里需要照顾到全局的功能需求，往往把应该在其它部分实现的功能都放到这个C部分代码中来了。所以还是应该先从整体系统考虑的更具体、全面些才行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一开始，我的主要注意力是放在persistenceActor的状态变化，也就是收款机开单操作过程的维护方面。我犯的第一个错误就是老是担心在后面Q端（读端）能不能实现客单项目内容管理，所以复杂化了event数据结构，总是希望为Q端提供完整的信息来支持对客单项目内容的管理。实际上C端和Q端各自的功能应该是：C端主要负责把所有的操作动作都记录下来，Q端把这些动作恢复成交易项目，形成客单内容，然后管理整个客单状态。C端只维护客单的开始、结束状态。至于这张单项目内容的修改、调整则应该是放在Q端的。这样一来，正如本篇标题所述：还是需要多想想，有全局思路。下面是我重新整理的一些想法：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、整体考虑前端POS机客户端、C端、Q端：前端接收收款员操作动作及应对动作所产生的结果如显示、打印等。C端负责动作的数据采集。Q端负责客单交易内容的构建和管理&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、从C端角度考虑：需要向前端返回每个动作产生的结果，使前端有足够的信息进行显示、打印小票等。如实向Q端反应具体操作动作，提供客单状态如新单、结束、单号等Q端管理客单状态必要的信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、C端POSHandler是个cluster-sharding-entity persistenceActor with backoffSupervisor。对应的前端POSRouter是客户端请求入口，是个cluster-singleton，能实现热插拔、热转换。POSRouter可以通过cluster-load-balancing在routees上运行Q端。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、C端有以下几种状态：登陆前、开单中、单结束。C端程序主要是处理这几种状态里的操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、整体POS系统是一个云平台应用。客户端通过POSRouter向POS系统请求POS服务。POSRouter是部署在集群所有节点上的cluster-singleton, 系统通过一个公网IP连接任何一个在线节点的POSRouter，任何一个节点出现异常不会影响系统运行，这是一种高可用的设计。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、POSHandler是集群分片，每个分片代表一部物理POS机。POS机号编码规则为：客户号+店号+序号，客户代表云POS用户&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、每客单结束时POSHandler向POSRouter发送消息请求启动执行一次Q端读取动作，这样可以避免持久数据流占用资源&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、系统应该作为一种云服务提供给各种的客户端设备。客户端用gRPC连接云服务端。调用那项服务，用户有否使用权限由客户端决定。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Mar 2019 06:36:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>上篇我介绍了CQRS模式存写部分的具体实现和akka-persistence一些函数和消息的用法。在这篇本来是准备直接用一个具体的例子来示范CQRS模式编程，主要是写端，或者是数据采集端。想着模拟收银</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/10564790.html</dc:identifier>
</item>
<item>
<title>阿里 EasyExcel 使用及避坑 - 谁将新樽辞旧月，今月曾经照古人</title>
<link>http://www.cnblogs.com/jiangwz/p/10564749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangwz/p/10564749.html</guid>
<description>&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/alibaba/easyexcel&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/easyexcel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本在项目中使用EasyPoi读取excel，后来为了统一技术方案，改用阿里的EasyExcel。EasyExcel和EasyPoi有一定的相似之处。&lt;/p&gt;
&lt;p&gt;EasyExcel和EasyPoi效率对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176316/201903/1176316-20190320141249925-678493912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176316/201903/1176316-20190320141256016-249819580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为数据量少，从效率上看几乎没有差别，EasyExcel略胜一筹。&lt;/p&gt;

&lt;p&gt;使用maven的方式引用EasyExcel&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mvnrepository.com/artifact/com.alibaba/easyexcel&quot; target=&quot;_blank&quot;&gt;https://mvnrepository.com/artifact/com.alibaba/easyexcel&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;easyexcel&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;easyexcel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.2-beat1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Java模型的方式使用easyexcel&lt;/p&gt;
&lt;p&gt;Java模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TotalAmount &lt;span&gt;extends&lt;/span&gt; BaseRowModel &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;

    @ExcelProperty(value &lt;/span&gt;=&quot;类型&quot;,index = 0&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String type;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开支类型 信用卡等&lt;/span&gt;
&lt;span&gt;
    @ExcelProperty(value &lt;/span&gt;= &quot;金额&quot;,index =1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sum;

    @ExcelProperty(value &lt;/span&gt;= &quot;来源&quot;,index =2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开支来源  如：**银行信用卡&lt;/span&gt;
&lt;span&gt;
    @ExcelProperty(value &lt;/span&gt;= &quot;日期&quot;,index =3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String date;

    @ExcelProperty(value &lt;/span&gt;= &quot;状态&quot;,index =4&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer status;

    @ExcelProperty(value &lt;/span&gt;= &quot;备注&quot;,index =5&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String descr;


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Java模型的方式需要继承 BaseRowModel ，字段上使用 @ExcelProperty 注解，注解中 value 属性指定字段名，index属性指定字段排序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：这里和EasyExcel不同的是，目前可以使用只指定index和同时指定index和value的方式来匹配excel文件，但是如果只指定value，则无法读取。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/importExce&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonResponse importExcel(@RequestParam(&quot;excelFile&quot;) MultipartFile excelFile, String type) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        JsonResponse jsonResponse &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResponse();
        String sm&lt;/span&gt;=&quot;2019-02&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Object&amp;gt; dataList = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        dataList &lt;/span&gt;= EasyExcelFactory.read(excelFile.getInputStream(), &lt;span&gt;new&lt;/span&gt; Sheet(3, 1, TotalAmount.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; scuess = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; error = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : dataList) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TotalAmount) {
                TotalAmount importEntity &lt;/span&gt;=&lt;span&gt; (TotalAmount) o;

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    error&lt;/span&gt;++&lt;span&gt;;
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    }

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;    @RequestMapping(&quot;/importExce&quot;)
    @ResponseBody
    public JsonResponse importExce(){
        JsonResponse jsonResponse = new JsonResponse();
        File excelFile = new File
                (&quot;E:\\工作文档\\部门架构201902(bug).xlsx&quot;);
        String sm=&quot;2019-02&quot;;
        InputStream inputStream = new FileInputStream(excelFile);
        List&amp;lt;Object&amp;gt; dataList = null;
        dataList = EasyExcelFactory.read(inputStream, new Sheet(3, 1, TotalAmount.class));
        int scuess = 0;
        int error = 0;
        for (Object o : dataList) {
            if (o instanceof TotalAmount) {
                TotalAmount importEntity = (TotalAmount) o;

                try {

                } catch (Exception e) {
                    error++;
                    e.printStackTrace();
                    continue;
                }
            }
        }
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：在使用EasyExcel时容易出的几个错误：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;For input &quot;&quot; 类型错误，应该是double等类型的字段有非double类型的数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;java.lang.NumberFormatException: multiple points 多线程使用非线程安全类报错，实际是在日期格式里有并非指定日期格式的数据，比如空格，比如指定 yyyy/mm/dd 但数据是 yyyy-mm-dd&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用easyexcel写出excel：&lt;/p&gt;
&lt;p&gt;使用Java模型方式，返回模型列表，带入方法即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 导出Excel
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;export.do&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; export(HttpServletRequest request, String type, HttpServletResponse response,
                       @RequestParam Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ServletOutputStream out &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            out &lt;/span&gt;=&lt;span&gt; response.getOutputStream();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        ExcelWriter writer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ExcelWriter(out, ExcelTypeEnum.XLSX, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        String filename;
        String fileName &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            filename &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toLocaleString();
            fileName &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String((filename).getBytes(), &quot;UTF-8&quot;&lt;span&gt;);
            Sheet sheet2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Sheet(2, 3, ImportEntityEasyExcel.&lt;span&gt;class&lt;/span&gt;, &quot;sheet&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            List&lt;/span&gt;&amp;lt;ImportEntityEasyExcel&amp;gt; list =&lt;span&gt; service.getData(map);
            response.setCharacterEncoding(&lt;/span&gt;&quot;utf-8&quot;&lt;span&gt;);
            response.setContentType(&lt;/span&gt;&quot;application/vnd.ms-excel&quot;&lt;span&gt;);
            response.setHeader(&lt;/span&gt;&quot;content-Disposition&quot;&lt;span&gt;,
                    &lt;/span&gt;&quot;attachment;filename=&quot; + URLEncoder.encode(fileName + &quot;.xlsx&quot;, &quot;utf-8&quot;&lt;span&gt;));
            out.flush();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            writer.finish();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                out.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;easyexcel还有一些并不完善，但是大数据量操作效率高于easypoi&lt;/p&gt;
</description>
<pubDate>Wed, 20 Mar 2019 06:31:00 +0000</pubDate>
<dc:creator>谁将新樽辞旧月，今月曾经照古人</dc:creator>
<og:description>github地址：https://github.com/alibaba/easyexcel 原本在项目中使用EasyPoi读取excel，后来为了统一技术方案，改用阿里的EasyExcel。EasyE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangwz/p/10564749.html</dc:identifier>
</item>
<item>
<title>Go语言为何说它优雅？-- Golang中的几个常用初始化设计 - Tokumi</title>
<link>http://www.cnblogs.com/CattaC/p/10564744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CattaC/p/10564744.html</guid>
<description>&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/482524/201903/482524-20190320143504941-1445358437.png&quot; alt=&quot;Go1&quot; width=&quot;700&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对象池化设计：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;将池对象通过Channel方式进行借出与还入，利用Go本身的特性还能实现更多限定需求。比如利用select的分支可以进行优雅的限流、超时熔断等操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路：将需要池化的对象通过Channel进行包装，使用与归还都通过Channel的方式进行&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;31.92759295499&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package pool

type Pool chan &lt;/span&gt;*&lt;span&gt;Object

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化池，可指定容量&lt;/span&gt;
func New(total &lt;span&gt;int&lt;/span&gt;) *&lt;span&gt;Pool {
    p :&lt;/span&gt;=&lt;span&gt; make(Pool, total)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; total; i++&lt;span&gt; {
        p &lt;/span&gt;&amp;lt;- &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(Object)
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;p
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;p := pool.New(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; obj := &amp;lt;-&lt;span&gt;p:
    obj.Do( &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;希望池中对象进行的操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; )

    p &lt;/span&gt;&amp;lt;- obj &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用完毕归还到池中&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 池资源无剩余，延迟重试或者直接告知失败等操作&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象单例设计：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;这里的实现是具有Go特色的调用方式，与double check的方式相比，更加优雅却达到相同效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路：利用sync包提供的once锁，从而限制创建过程仅执行一次&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package singleton

type singleton map[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
    once sync.Once

    instance singleton
)

func New() singleton {
    once.Do(func() {
        instance &lt;/span&gt;=&lt;span&gt; make(singleton)
    })

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;s :=&lt;span&gt; singleton.New()

s[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;that&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

s2 :&lt;/span&gt;=&lt;span&gt; singleton.New()

fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s2[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:  This is that&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;工厂模式设计：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;与面向对象的语言思路相同，只是这里的接口继承不是强类型的显式继承，而是更加灵活的Duck-Type方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路：只要是隐式实现接口Store的，都可通过Store接口接收对象，并调用接口定义的方法（里氏替换原则）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package data

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口限定了能力（调用的方法）&lt;/span&gt;
type Store &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Open(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;) (io.ReadWriteCloser, error)
}

type StorageType &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt;&lt;span&gt; (
    DiskStorage StorageType &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; iota
    TempStorage
    MemoryStorage
)

func NewStore(t StorageType) Store {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过枚举来创建实际创建的对象类型&lt;/span&gt;
    &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; t {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MemoryStorage:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; newMemoryStorage( &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DiskStorage:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; newDiskStorage( &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; newTempStorage( &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; )
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;s, _ :=&lt;span&gt; data.NewStore(data.MemoryStorage)
f, _ :&lt;/span&gt;= s.Open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

n, _ :&lt;/span&gt;= f.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
defer f.Close()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;代码来源是Github上一个开源项目，项目内容是Go相关的常用设计模式的实现，很实用易懂： &lt;a href=&quot;https://github.com/tmrts/go-patterns&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/tmrts/go-patterns&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/482524/201903/482524-20190320143550955-85131827.png&quot; alt=&quot;Go2&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 20 Mar 2019 06:30:00 +0000</pubDate>
<dc:creator>Tokumi</dc:creator>
<og:description>对象池化设计： 将池对象通过Channel方式进行借出与还入，利用Go本身的特性还能实现更多限定需求。比如利用select的分支可以进行优雅的限流、超时熔断等操作。 思路：将需要池化的对象通过Chan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CattaC/p/10564744.html</dc:identifier>
</item>
<item>
<title>Windows下安装tesserocr - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/10564170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/10564170.html</guid>
<description>&lt;p&gt;&lt;span&gt;很难受，由于这两天重装了系统，又得重新配置环境了，而我在安装tesserocr的时候踩了一些坑，于是想写出来分享一下。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;要安装tesserocr，首先要下载tesseract，它是给tesserocr提供支持的。下载地址为：&lt;a href=&quot;https://digi.bib.uni-mannheim.de/tesseract/&quot;&gt;https://digi.bib.uni-mannheim.de/tesseract/&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开之后可以看到有很多文件，带dev的为开发版本，不带dev的为稳定版本，我们选择下载不带dev的版本，比如最新的这个：&lt;a href=&quot;https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-w64-setup-v4.1.0.20190314.exe&quot; target=&quot;_blank&quot;&gt;tesseract-ocr-w64-setup-v4.1.0.20190314.exe&lt;/a&gt;。下载完成之后运行安装，一直点击next，直到出现如下页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320123812881-1256129387.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Additional language data中包含了OCR支持识别的各国语言包，可以根据情况选择，我这里就选择了中文的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320124147188-138741950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后的过程就不用赘述了，这里因为我只选择了中文语言包，所以下载起来还是很快的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使用pip install tesserocr进行安装。我在安装的时候碰到了下面这个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320124924981-1199485974.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;下载对应版本的whl包进行安装，下载地址：&lt;a href=&quot;https://github.com/simonflueckiger/tesserocr-windows_build/releases&quot;&gt;https://github.com/simonflueckiger/tesserocr-windows_build/releases&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我的Python版本是3.7，电脑是Windows64位，所以我下载的是：&lt;a href=&quot;https://github.com/simonflueckiger/tesserocr-windows_build/releases/download/tesserocr-v2.4.0-tesseract-4.0.0/tesserocr-2.4.0-cp37-cp37m-win_amd64.whl&quot; target=&quot;_blank&quot;&gt;tesserocr-2.4.0-cp37-cp37m-win_amd64.whl&lt;/a&gt;。下载完之后使用pip进行安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320130402159-1088165547.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2）安装Visual Studio，比如VS2017。这个怎么说呢，虽然它里面包含了很多包，安装起来也很简单，但是如果你想卸载就很蛋疼了，而且这个软件会占用C盘几个G的空间，所以我个人是不推荐使用这个办法的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;首先找到你tesseract安装的目录位置，比如E:\Tesseract-OCR，然后将该路径添加到环境变量path中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320132110870-1262665175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之后新建一个系统变量TESSDATA_PREFIX，对应的值为：E:\Tesseract-OCR\tessdata：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320132216917-1681605960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;下面是一个简单的示例，使用的图片为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190320132732283-432049258.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码很简单，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tesserocr
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; img = Image.open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(tesserocr.image_to_text(img))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在第一次运行的时候可能会出现下面这个错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RuntimeError: Failed to init API, possibly an invalid tessdata path: E:\Python\/tessdata/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：将tesseract安装目录下的tessdata文件夹复制到你的Python安装目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最终运行结果为&lt;/strong&gt;：@ python’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到tesserocr在不处理图片直接使用的情况下，识别的效果其实是比较差的，如果我们想要提高OCR识别的准确度，可以进行相应的识别训练。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Mar 2019 06:01:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>很难受，由于这两天重装了系统，又得重新配置环境了，而我在安装tesserocr的时候踩了一些坑，于是想写出来分享一下。 一.安装tesseract 要安装tesserocr，首先要下载tesserac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TM0831/p/10564170.html</dc:identifier>
</item>
<item>
<title>Vue针对性笔记 - 狐狸家的鱼</title>
<link>http://www.cnblogs.com/suRimn/p/10564409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suRimn/p/10564409.html</guid>
<description>&lt;div readability=&quot;24.976780185759&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FsueRimn%2FBlog%2Fblob%2Fmaster%2F%25E5%2589%258D%25E7%25AB%25AF%25E7%259F%25A5%25E8%25AF%2586%25E4%25BD%2593%25E7%25B3%25BB%2F%25E5%2589%258D%25E7%25AB%25AF%25E6%25A1%2586%25E6%259E%25B6%2FVue%2FREADME.md&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;原文阅读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;MVVM(Model-View-ViewModel)模型&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fcamo.githubusercontent.com%2F2b52d778c740389d92f284f08c37c5e6fe5e45e7%2F68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f382f38372f4d56564d5061747465726e2e706e67&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc28132474?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc28132474?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;771&quot; data-height=&quot;232&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MVVM&lt;/code&gt;&lt;/strong&gt;分为&lt;strong&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;View&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;ViewModel&lt;/code&gt;&lt;/strong&gt;三部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/strong&gt;代表数据模型，定义数据和业务逻辑，访问数据层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;View&lt;/code&gt;&lt;/strong&gt;代表视图，展示页面结构、布局和外观（UI）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ViewModel&lt;/code&gt;&lt;/strong&gt;代表视图模型，负责监听&lt;code&gt;Model&lt;/code&gt;数据变化并更新视图，处理用户交互 &lt;code&gt;Model&lt;/code&gt;和&lt;code&gt;View&lt;/code&gt;是通过&lt;code&gt;ViewModel&lt;/code&gt;，&lt;code&gt;Model&lt;/code&gt;的数据变化会触发&lt;code&gt;View&lt;/code&gt;的更新，&lt;code&gt;View&lt;/code&gt;的交互操作也会使&lt;code&gt;Model&lt;/code&gt;的数据发生改变。只需要针对数据进行维护操作，数据的自动同步不需要通过操作&lt;code&gt;dom&lt;/code&gt;实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;Vue指令&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;期望数值类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr&gt;&lt;td&gt;v-text&lt;/td&gt;
&lt;td&gt;更新元素文本内容&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v-html&lt;/td&gt;
&lt;td&gt;更新元素的&lt;code&gt;innerHTML&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-show&lt;/td&gt;
&lt;td&gt;条件渲染。根据表达式的真假值，控制元素的显示或隐藏&lt;/td&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-if&lt;/td&gt;
&lt;td&gt;条件渲染。根据表达式的值的真假条件选择是否渲染元素这个节点&lt;/td&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-else&lt;/td&gt;
&lt;td&gt;条件渲染。根据&lt;code&gt;v-if&lt;/code&gt;的相反条件进行元素渲染&lt;/td&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-else-if&lt;/td&gt;
&lt;td&gt;条件渲染。做&lt;code&gt;v-if&lt;/code&gt;的链式调用&lt;/td&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;v-for&lt;/td&gt;
&lt;td&gt;列表渲染。对数据进行遍历渲染，最好提供&lt;code&gt;key&lt;/code&gt;值&lt;/td&gt;
&lt;td&gt;Array / Object / number / string&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;v-on&lt;/td&gt;
&lt;td&gt;事件处理。绑定事件监听器，事件类型由参数指定，表达式可以是方法名或内联语句。&lt;/td&gt;
&lt;td&gt;Function / Inline Statement / Object&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;v-bind&lt;/td&gt;
&lt;td&gt;动态绑定。动态绑定一个或多个特性，或一个组件&lt;code&gt;prop&lt;/code&gt;到表达式&lt;/td&gt;
&lt;td&gt;any (with argument) / Object (without argument)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;v-model&lt;/td&gt;
&lt;td&gt;表单绑定。在表单或组件是上创建双向绑定&lt;/td&gt;
&lt;td&gt;随表单控件类型变化&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-pre&lt;/td&gt;
&lt;td&gt;跳过该元素和它的子元素的编译过程&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;v-cloak&lt;/td&gt;
&lt;td&gt;设置 &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt;可以在渲染时延后加载&lt;code&gt;Vue&lt;/code&gt;实例，避免闪现&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;v-once&lt;/td&gt;
&lt;td&gt;元素和组件只渲染一次，重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;Vue响应式原理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fcamo.githubusercontent.com%2F1371225cf96292385b7d5327d04e52f59ffab3c3%2F68747470733a2f2f7675652e646f63736368696e612e6f72672f696d616765732f646174612e706e67&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998c1b1087999?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998c1b1087999?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1200&quot; data-height=&quot;750&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;实例化时，遍历访问&lt;code&gt;data&lt;/code&gt;的所有属性，使用&lt;strong&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/strong&gt;将其属性全部转换为&lt;strong&gt;&lt;code&gt;getter/setter&lt;/code&gt;&lt;/strong&gt;进行依赖追踪以便修改属性时进行变更通知，每个组件实例都有相应的 &lt;strong&gt;watcher&lt;/strong&gt; 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 &lt;strong&gt;&lt;code&gt;setter&lt;/code&gt;&lt;/strong&gt; 被调用时，会通知 &lt;strong&gt;watcher&lt;/strong&gt; 重新计算，从而致使它关联的组件得以更新。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-3&quot;&gt;Vue双向数据绑定&lt;/h2&gt;
&lt;p&gt;简单实现，有一个子组件输入框，一个按钮，父组件通过&lt;strong&gt;&lt;code&gt;props&lt;/code&gt;&lt;/strong&gt;传值给子组件，当按钮增加时，子组件通过&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt;通知父组件修改相应的&lt;strong&gt;&lt;code&gt;props&lt;/code&gt;&lt;/strong&gt;值。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FsueRimn%2FBlog%2Fblob%2Fmaster%2F%25E5%2589%258D%25E7%25AB%25AF%25E7%259F%25A5%25E8%25AF%2586%25E4%25BD%2593%25E7%25B3%25BB%2F%25E5%2589%258D%25E7%25AB%25AF%25E6%25A1%2586%25E6%259E%25B6%2FVue%2Fsrc%2FGIF.gif&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bce673d1ac?imageslim&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bce673d1ac?imageslim&quot; data-width=&quot;312&quot; data-height=&quot;129&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;parent&amp;gt;&amp;lt;/parent&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;var&lt;/span&gt; childNode =&lt;span&gt; {
            template:`
                &lt;/span&gt;&amp;lt;div class = &quot;child&quot;&amp;gt;
                    &amp;lt;div&amp;gt;
                        &amp;lt;span&amp;gt;子组件数据&amp;lt;/span&amp;gt;
                        &amp;lt;input v-model=&quot;childMsg&quot;&amp;gt;
                        &amp;lt;button @click=add&amp;gt;+1&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
&lt;span&gt;            `,
            data(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
                    childMsg:&lt;/span&gt;0&lt;span&gt;
                }
            },
            methods: {
                add(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.childMsg++&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('update:foo',&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.childMsg)
                }
            }
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parentNode =&lt;span&gt; {
            template:`
                &lt;/span&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
                    &amp;lt;div&amp;gt;
                        &amp;lt;span&amp;gt;父组件数据:{{msg}}&amp;lt;/span&amp;gt;
                        &amp;lt;child :foo.sync=&quot;msg&quot;&amp;gt;&amp;lt;/child&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
&lt;span&gt;            `,
            components:{
                &lt;/span&gt;'child'&lt;span&gt;:childNode
            },
            data(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;'msg':0&lt;span&gt;
                }
            }
        };
        let vm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;'#app'&lt;span&gt;,
            components:{
                &lt;/span&gt;'parent'&lt;span&gt;:parentNode
            }
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 data-id=&quot;heading-4&quot;&gt;Vue的生命周期钩子&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fcamo.githubusercontent.com%2F37e5ccc9435b25078ef1d1924e9deddb529e7d7d%2F68747470733a2f2f7675652e646f63736368696e612e6f72672f696d616765732f6c6966656379636c652e706e67&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc2fd10f21?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc2fd10f21?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;505&quot; data-height=&quot;1280&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;钩子&lt;/th&gt;
&lt;th&gt;调用&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;是否在服务端渲染期间调用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;beforeCreate&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Vue&lt;/code&gt;实例初始化之后，数据观察和事件配置之前&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;create&lt;/td&gt;
&lt;td&gt;实例创建完成（数据观察/属性和方法运算/事件回调）之后，挂载之前&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;beforeMount&lt;/td&gt;
&lt;td&gt;挂载开始之前，&lt;code&gt;render&lt;/code&gt;函数首次调用&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mounted&lt;/td&gt;
&lt;td&gt;实例挂载完成之后&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;beforeUpdate&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DOM&lt;/code&gt;被&lt;code&gt;patch&lt;/code&gt;之前调用进行数据修改&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;updated&lt;/td&gt;
&lt;td&gt;组件 DOM 更新完成，避免在此期间更改状态&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;actived&lt;/td&gt;
&lt;td&gt;keep-alive 组件激活时&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;deactived&lt;/td&gt;
&lt;td&gt;keep-alive 组件停用时&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;beforeDestroy&lt;/td&gt;
&lt;td&gt;实例销毁之前&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;destroyed&lt;/td&gt;
&lt;td&gt;实例销毁&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;errorCaptured&lt;/td&gt;
&lt;td&gt;当任何一个来自后代组件的错误时被捕获时&lt;br/&gt;收到三个参数：错误对象、发生错误的组件实例，和一个包含错误在何处被捕获信息的字符串&lt;br/&gt;返回 false，以阻止该错误继续向上冒泡&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 data-id=&quot;heading-5&quot;&gt;Vue组件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fcamo.githubusercontent.com%2Fd3fc5839fe592490d9bf52816aa88dfc7f9be1b1%2F68747470733a2f2f7675652e646f63736368696e612e6f72672f696d616765732f636f6d706f6e656e74732e706e67&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc48f60afb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc48f60afb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;495&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组件可以是页面中每一个区域板块，也可以是某一个复用业务逻辑，也可以是每一个单页面。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-6&quot;&gt;组件的构成&lt;/h3&gt;
&lt;p&gt;就以上面的双向数据绑定实现为例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性&lt;strong&gt;&lt;code&gt;props&lt;/code&gt;&lt;/strong&gt;：父组件使用&lt;code&gt;props&lt;/code&gt;定义数据属性，向子组件传递数据&lt;/li&gt;
&lt;li&gt;自定义事件&lt;strong&gt;&lt;code&gt;event&lt;/code&gt;&lt;/strong&gt;：通过&lt;code&gt;$emit&lt;/code&gt;触发自定义事件&lt;code&gt;event&lt;/code&gt;向父组件发送消息&lt;/li&gt;
&lt;li&gt;插槽&lt;strong&gt;&lt;code&gt;slot&lt;/code&gt;&lt;/strong&gt;：&lt;code&gt;slot&lt;/code&gt;进行组件内容分发，插入子组件内容&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-id=&quot;heading-7&quot;&gt;组件通信&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;父子组件通信：父组件使用&lt;strong&gt;&lt;code&gt;props&lt;/code&gt;&lt;/strong&gt;向子组件通信，子组件使用&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt;向父组件传递消息&lt;/li&gt;
&lt;li&gt;非父子组件通信：父组件可以使用&lt;strong&gt;&lt;code&gt;v-on&lt;/code&gt;&lt;/strong&gt;监听子组件的任何事件，子组件使用&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt;传入事件，这样父组件就会收到事件并更新&lt;/li&gt;
&lt;li&gt;跨级组件通信：使用&lt;strong&gt;&lt;code&gt;Vuex&lt;/code&gt;&lt;/strong&gt;比较好管理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-id=&quot;heading-8&quot;&gt;Vue-router路由&lt;/h2&gt;
&lt;p&gt;Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌套的路由/视图表&lt;/li&gt;
&lt;li&gt;模块化的、基于组件的路由配置&lt;/li&gt;
&lt;li&gt;路由参数、查询、通配符&lt;/li&gt;
&lt;li&gt;基于 Vue.js 过渡系统的视图过渡效果&lt;/li&gt;
&lt;li&gt;导航控制&lt;/li&gt;
&lt;li&gt;带有自动激活的 CSS class 的链接&lt;/li&gt;
&lt;li&gt;HTML5 历史模式或 hash 模式，在 IE9 中自动降级&lt;/li&gt;
&lt;li&gt;自定义的滚动条行为&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一个简单路由的实现：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FsueRimn%2FBlog%2Fblob%2Fmaster%2F%25E5%2589%258D%25E7%25AB%25AF%25E7%259F%25A5%25E8%25AF%2586%25E4%25BD%2593%25E7%25B3%25BB%2F%25E5%2589%258D%25E7%25AB%25AF%25E6%25A1%2586%25E6%259E%25B6%2FVue%2Fsrc%2Fvue-router.gif&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc67c172a8?imageslim&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/3/20/169998bc67c172a8?imageslim&quot; data-width=&quot;240&quot; data-height=&quot;176&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot; class=&quot;demo&quot;&amp;gt;
      &amp;lt;h1&amp;gt;Hello App!&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;
          &amp;lt;!-- 通过router-link导航 --&amp;gt;
          &amp;lt;!-- 通过传入'to '属性指定链接--&amp;gt;
          &amp;lt;!--  &amp;lt;router-link&amp;gt; 默认会被渲染成一个 `&amp;lt;a&amp;gt;` 标签--&amp;gt;
              &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;go to Foo&amp;lt;/router-link&amp;gt;
              &amp;lt;router-link to=&quot;/bar&quot;&amp;gt;go to Bar&amp;lt;/router-link&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;!-- 路由出口 --&amp;gt;
      &amp;lt;!-- 路由匹配到的组件将渲染在这里 --&amp;gt;
      &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;!-- 
       0&lt;span&gt;. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)
       &lt;/span&gt;1&lt;span&gt;. 定义 (路由) 组件。
       &lt;/span&gt;2&lt;span&gt;.定义路由
    &lt;/span&gt;--&amp;gt;
   &amp;lt;script&amp;gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 定义 (路由) 组件。&lt;/span&gt;
       const Foo = {template:'&amp;lt;div&amp;gt;foo&amp;lt;/div&amp;gt;'&lt;span&gt;};
       const Bar &lt;/span&gt;= {template:'&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt;};
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.定义路由&lt;/span&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个路由应该映射一个组件。其中component可以是通过Vue.extend()创建的组件构造器&lt;/span&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者只是一个组件配置对象&lt;/span&gt;
       const routes =&lt;span&gt; [
           {path:&lt;/span&gt;'/foo'&lt;span&gt;,component:Foo},
           {path:&lt;/span&gt;'/bar'&lt;span&gt;,component:Bar}
       ]

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.创建router实例，然后传‘routes’配置&lt;/span&gt;
       const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
           routes&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（缩写）相当于routes:routes&lt;/span&gt;
&lt;span&gt;       })

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.创建和挂载根实例&lt;/span&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要记得通过router配置参数注入路由，从而让整个应用都有路由功能&lt;/span&gt;
&lt;span&gt;       
       const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
           router
       }).$mount(&lt;/span&gt;'#app'&lt;span&gt;);
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 20 Mar 2019 05:40:00 +0000</pubDate>
<dc:creator>狐狸家的鱼</dc:creator>
<og:description>Github原文阅读 MVVM(Model-View-ViewModel)模型 MVVM分为Model、View、ViewModel三部分。 Model代表数据模型，定义数据和业务逻辑，访问数据层 V</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suRimn/p/10564409.html</dc:identifier>
</item>
</channel>
</rss>