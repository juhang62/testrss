<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解决margin塌陷和margin合并 - 啃骨头的猫</title>
<link>http://www.cnblogs.com/xingyue525/p/10924625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingyue525/p/10924625.html</guid>
<description>
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;title&amp;gt;嘿嘿嘿&amp;lt;/title&amp;gt;
        &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui, viewport-fit=cover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        
    &amp;lt;/head&amp;gt;
    &amp;lt;style type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        body{
            background: #f5f5f5;
        }
        .father&lt;/span&gt;-&lt;span&gt;box{
            width: 150px;
            height: 150px;
            background&lt;/span&gt;-&lt;span&gt;color: black;
            margin: 20px;
        }
        .father&lt;/span&gt;-box .son-&lt;span&gt;box{
            width: 50px;
            height: 50px;
            background&lt;/span&gt;-&lt;span&gt;color: greenyellow;
            margin: 20px;
        }
        .brother&lt;/span&gt;-&lt;span&gt;two{
            width: 150px;
            height: 20px;
            background&lt;/span&gt;-&lt;span&gt;color: gold;
            margin: 20px;
        }
    &lt;/span&gt;&amp;lt;/style&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;father-box brother&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;son-box&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;brother brother-two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            黄色的是20px的高度
        &lt;/span&gt;&amp;lt;/div&amp;gt;
        
    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1187728/201905/1187728-20190525221121394-1817367163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面执行的代码可以看到两个经典的cssbug:&lt;/p&gt;
&lt;p&gt;     father-box ：黑色盒子；son-box：绿色盒子；brother-two：黄色盒子&lt;/p&gt;
&lt;p&gt;1、margin合并&lt;/p&gt;
&lt;p&gt;      黑色 和 黄色的盒子 都设置了 margin:20px， 按理说黑色和黄色的垂直间距是40px,  但是事实是20px, 这就是margin合并造成的。&lt;/p&gt;
&lt;p&gt;      margin合并：普通文档流中块级元素的垂直外边距会互相合并，也就是会以他们之间外边距大的为准，比如：&lt;/p&gt;
&lt;p&gt;      我如果现在将黄色的盒子的margin-top设为10px;黄色和黑色之间的间距不会改变，依旧是20px;但是如果设为30px,那么黄色和黑色之间的间距就会以较大的30px为准，变为30px;&lt;/p&gt;
&lt;p&gt;      解决方法：&lt;/p&gt;
&lt;p&gt;      推荐也是常用的：如果要上下间距为40px,只需要黄色的盒子上边距设为40px,黑色的盒子不用设下边距，这样就可以了，意思是不需要强行解决这个bug,只需要将一边的边距设为两个盒子边距的和就可以了&lt;/p&gt;
&lt;p&gt;      不推荐也是不常用的（这样会改变html结构）：在黄色和黑色的盒子外面在加一个盒子，让这个加的外层盒子的渲染规则改为BFC（）&lt;/p&gt;
&lt;p&gt;2、margin 塌陷&lt;/p&gt;
&lt;p&gt;     黑色 和 绿色 的margin-top都设为了20px，但是绿色并没有距离黑色上边20px。&lt;/p&gt;
&lt;p&gt;     margin 塌陷：普通文档流中父子块级元素，如果父元素没有设置上内边距或上边框，子元素的上边距就会和父元素的上边距重合，以他们两个中间最大上边距为准，与距离他们最近的盒子隔开。如: &lt;/p&gt;
&lt;p&gt;     如果我现在给绿色的盒 子设置margin-top:40px, 那么黑色和绿色的盒子会一起向下移动20px。&lt;/p&gt;
&lt;p&gt;     解决方法：&lt;/p&gt;
&lt;p&gt;     将父元素的渲染规则改为BFC（）&lt;/p&gt;

&lt;p&gt;这里简单的列举一些触发BFC的方法：&lt;/p&gt;
&lt;p&gt;      1、float:left/right;&lt;/p&gt;
&lt;p&gt;      2、position:absolute;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      3、overflow:hidden;&lt;/p&gt;
&lt;p&gt;      4、display:inline-block;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;brother-two&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 25 May 2019 15:48:00 +0000</pubDate>
<dc:creator>啃骨头的猫</dc:creator>
<og:description>重学前端中遇到的值得记录的知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xingyue525/p/10924625.html</dc:identifier>
</item>
<item>
<title>管理是什么?——读《管理的实践》有感 - zer0black</title>
<link>http://www.cnblogs.com/zer0Black/p/10924497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zer0Black/p/10924497.html</guid>
<description>&lt;p&gt;花了4个月的时间，总算完完整整的读完了《管理的实践》一书。书中诸多观点在现在看来，依旧很新颖，不亏是管理类书籍的开山之作。&lt;/p&gt;
&lt;p&gt;这本书二战刚结束就开始创作，而今很多企业都做不到。与其说是实践，倒不如说是管理的思想。这本书传道受业解惑，但又不可避免的造成“知易行难”的困境。&lt;/p&gt;
&lt;p&gt;书中阐明了企业是什么、企业目标是什么、管理 的本质是什么、企业需要哪一种管理的结构、如何做决策等几个看似简单又难以回答的问题。&lt;/p&gt;
&lt;p&gt;本书以管理企业、管理管理者、管理员工和工作的顺序开展，完整的阐述了作者对管理的思考和定义。&lt;/p&gt;
&lt;p&gt;书中给出了两个我难以忘记的观点：（1）管理者的首要职能是创造企业绩效（2）企业只有一个正确而有效的定义：创造顾客。&lt;/p&gt;
&lt;p&gt;两个观点都和4Y中提到的客户价值藕断丝连。没有客户，企业就没有存在的必要。我们所做的一切，都是为了更好的服务客户。&lt;/p&gt;
&lt;p&gt;如下，给出我对本书的观点提炼，仅供参考&lt;/p&gt;
&lt;p&gt;管理层的职责：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首要职能：经济绩效&lt;/li&gt;
&lt;li&gt;检验管理的是企业的绩效&lt;/li&gt;
&lt;li&gt;企业管理也就是目标管理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;企业是什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;企业是由人创造和管理的&lt;/li&gt;
&lt;li&gt;我们不能单单从利润的角度来定义或解释企业&lt;/li&gt;
&lt;li&gt;企业的目的：&lt;br/&gt;a. 创造顾客&lt;br/&gt;b. 创造需求&lt;/li&gt;
&lt;li&gt;企业的主要功能：&lt;br/&gt;a. 营销&lt;br/&gt;b. 创新&lt;/li&gt;
&lt;li&gt;生产力:&lt;br/&gt;a. 生产力意味着所有生产要素之间的平衡&lt;br/&gt;b. 能力最少的努力，获得最大的产出&lt;br/&gt;c. 体察管理者的局限何在，也是重要的生产力要素&lt;br/&gt;d. 生产力深受组织结构的影响&lt;/li&gt;
&lt;li&gt;利润:&lt;br/&gt;a. 利润是结果&lt;br/&gt;b. 企业经济学的指导原则不是追求最大利润，而是避免亏损&lt;br/&gt;c. 设定目标时必须把目光紧盯预期达到的成就&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们的事业是什么？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们的事业是什么由消费者决定&lt;/li&gt;
&lt;li&gt;要决定在企业在顾客已表示满意的需求中哪些需求最为重要，最有发展前途&lt;/li&gt;
&lt;li&gt;决定谁是顾客&lt;/li&gt;
&lt;li&gt;顾客购买的是什么？&lt;/li&gt;
&lt;li&gt;在顾客心中，价值是什么？应该直接询问客户&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们的事业将是什么？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;市场潜力和趋势。问自己，5到10年后。我们预期市场会变得多大？哪些因素会影响市场的发展&lt;/li&gt;
&lt;li&gt;经济发展，流行趋势和品味的变化，会导致市场结构发生什么样的改变？&lt;/li&gt;
&lt;li&gt;哪些创新将改变客户需求，创造新需求？&lt;/li&gt;
&lt;li&gt;今天还有哪些顾客需求无法从现有产品和服务中获得充分满足？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;企业的目标&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任何一个其绩效和结果对企业的生存和兴旺有着直接和举足轻重影响的领域，都需要有目标&lt;/li&gt;
&lt;li&gt;企业应设定绩效和成果目标的领悟共8个：市场地位、创新、生产力、实物和财力资源、获利能力、管理者绩效和培养管理者、员工绩效和工作态度、社会责任&lt;/li&gt;
&lt;li&gt;设定目标：先确定每个领域中要衡量的是什么，衡量标准是什么&lt;/li&gt;
&lt;li&gt;市场地位&lt;br/&gt;a. 衡量市场地位时，必须同时对照市场潜力及竞争对手的表现&lt;br/&gt;b. 无论如何，变成被边缘化的小供应商都是很危险的，应设法维持最低限度的市场地位&lt;br/&gt;c. 要设定市场地位的目标，企业必须确定它的市场是什么&lt;/li&gt;
&lt;li&gt;创新&lt;br/&gt;a. 产品与服务的创新&lt;br/&gt;b. 提供产品与服务所需的各种技能和活动的创新&lt;br/&gt;c. 企业必须先根据产品线、既有市场、新市场，通常也根据服务上的要求，预测达到营销目标需要的创新&lt;/li&gt;
&lt;li&gt;生产力&lt;br/&gt;a. 管理者最重要的工作就是不断的改善生产力&lt;br/&gt;b. 生产力衡量标准：&quot;贡献值&quot;&lt;br/&gt;c. 贡献值是指营业毛收入和支出之间的差距&lt;br/&gt;d. 企业的首要任务必须是让采购的原料或服务，发挥最大的效用&lt;br/&gt;e. 企业必须提高自有资源的生产力&lt;/li&gt;
&lt;li&gt;实物与财力资源&lt;br/&gt;a. 设法供应企业所需物料，以达到预定的市场地位和创新目标&lt;br/&gt;b. 物料、财力都需要提前规划&lt;/li&gt;
&lt;li&gt;利润率&lt;br/&gt;a. 利润衡量企业付出的努力有多少净效益以及是否健全&lt;br/&gt;b. 利润是弥补继续维持事业的成本的风险溢价&lt;br/&gt;c. 利润或者直接地以自我集资的手段，从留存的积累中提取资金，或者间接的通过提供诱因，以最适合公司目标的形式吸引新的外部资金，保障未来用于创新和发展的资金的供应&lt;br/&gt;d. 获利能力必须将时间因素考虑在内&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生产的原则&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生产并非是把工具应用在材料上，而是将逻辑应用在工作上&lt;/li&gt;
&lt;li&gt;三种生产系统&lt;br/&gt;a. 单件产品生产&lt;br/&gt;b. 大规模生产系统&lt;br/&gt;c. 流程生产系统&lt;/li&gt;
&lt;li&gt;对管理能的要求通则&lt;br/&gt;a. 各种系统要求不但难度有别，而且所要求的管理能力和绩效顺序也不同&lt;br/&gt;b. 越能成功的贯彻每个系统的原则，就越容易达到系统对管理的要求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;管理者的重要性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;员工的工作效益大半取决于员工管理方式&lt;/li&gt;
&lt;li&gt;企业需要的目标决定了管理层的功能和责任&lt;/li&gt;
&lt;li&gt;管理层的功能和责任永远因其任务来决定&lt;/li&gt;
&lt;li&gt;管理管理者的要求&lt;br/&gt;a. 将个别管理者的愿景导向企业的目标，即目标管理与自我控制&lt;br/&gt;b. 为管理者的职务建立适当的结构&lt;br/&gt;c. 为管理组织建立健全的结构性原则&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目标管理与自我控制&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;企业的每一分子都有不同的贡献，但所有的贡献都必须为了共同的目标&lt;/li&gt;
&lt;li&gt;期望管理者达到的绩效目标必须源自于企业的绩效目标，同时也通过管理者对于企业的成功所做的贡献，来衡量他们的工作成果&lt;/li&gt;
&lt;li&gt;上司误导：&lt;br/&gt;a. 下属眼中，上司的言行举止，甚至漫不经心的谈话和个人怪癖。都经过精心策划和考虑，具有特殊意义&lt;br/&gt;b. 管理结构上，必须兼顾管理者及其上司对管理工作的要求，而不是只重视上司的看法&lt;/li&gt;
&lt;li&gt;各个管理层次的差异：&lt;br/&gt;a. 要有良好的沟通，前提是先建立良好的共识和共同的语言&lt;br/&gt;b. 高效能的企业管理层必须激励每位管理者在正确的方向上投入最大的心力，一方面鼓励他们发挥最高的专业水准；另一方面。要把高超的专业技能当做企业绩效目标的手段，而不是把达到高标准本身当成努力目标&lt;/li&gt;
&lt;li&gt;管理者的目标应该是什么&lt;br/&gt;a. 每位管理者都需要有明确的目标，而且必须在目标中可出所管辖单位应该达到的绩效&lt;br/&gt;b. 目标一开始就应该强调团队合作和团队成果&lt;br/&gt;c. 所有的目标应该包含有形的经营目标和管理者的组织和培养，以及员工绩效、态度和社会责任等无形的目标&lt;/li&gt;
&lt;li&gt;靠压力进行管理&lt;br/&gt;a. 靠压力和危机进行管理是有害的&lt;br/&gt;b. 压力不是完成目标的方法&lt;br/&gt;c. 人们会将工作置之一旁去对付当前的压力，或是悄悄对压力采取一种集体怠工的态度&lt;/li&gt;
&lt;li&gt;管理者的目标如何确定，由谁确定&lt;br/&gt;a. 管理者应该负责让自己所管辖的单位对所属部门有所贡献，并且最后对整个企业有所贡献&lt;br/&gt;b. 每位管理者的工作目标必须根据他对上级单位的成功所做的贡献来决定&lt;br/&gt;c. 共同的理解从来不可能通过向下沟通而取得，只能产生于向上沟通&lt;/li&gt;
&lt;li&gt;通过测评进行自我控制&lt;br/&gt;a. 目标管理的主要贡献在于，我们能够以自我控制的管理方式来取代强制式管理&lt;br/&gt;b. 所有公司都应该针对每个关键领域向管理者提供清楚统一的绩效评估方式&lt;/li&gt;
&lt;li&gt;正确使用报告和程序&lt;br/&gt;a. 企业应该把报告和程序保持在最低限度，只有当报告和程序能节省时间和人力时，才运用这项工具，并且应该尽可能简化&lt;br/&gt;b. 意图控制每件事情，就等于控制不了任何事情&lt;br/&gt;c. 试图控制不相干的事情，总是会误导方向&lt;/li&gt;
&lt;li&gt;企业的管理原则&lt;br/&gt;a. 能让个人充分发挥特长&lt;br/&gt;b. 凝聚共同的愿景和一致的努力方向&lt;br/&gt;c. 建立团队合作&lt;br/&gt;d. 调和个人目标和共同福祉的原则&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;管理者必须管理&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管理者的工作是什么&lt;br/&gt;a. 管理者的工作应该以能够达成公司目标的任务为基础，是实质工作，能对企业的成功产生明显而且可以清楚衡量的贡献&lt;br/&gt;b. 管理者应该受绩效目标的指引和控制，而不是由上司指导和控制&lt;/li&gt;
&lt;li&gt;管理职责的幅度&lt;br/&gt;a. 管理职责的基本因素是，帮助和教导，只有通过个人才能得到最好的发挥&lt;/li&gt;
&lt;li&gt;管理者的职权&lt;br/&gt;a. 让决策权尽可能掌握在实际行动者手中&lt;br/&gt;b. 高层管理工作是基本管理工作衍生出来的产物，目的是协助第一线管理者做好他们的工作&lt;br/&gt;c. 任何未以书面形式明确表明为高层管理者所拥有的职权都为下层管理者所拥有&lt;/li&gt;
&lt;li&gt;上下级关系&lt;br/&gt;a. 下层管理人员与上层管理人员的关系&lt;br/&gt;b. 各个管理人员与企业的关系&lt;br/&gt;c. 上层管理人员与下层管理人员的关系&lt;br/&gt;d. 每位管理者都要对上级单位的需求有所贡献，以达成上级的目标&lt;br/&gt;e. 上级主管的责任是尽一切力量，帮助下属达成目标&lt;br/&gt;f. 管理者应该明白他和下属的关系是一种责任，而不是上对下的监督&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;组织的精神&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;能否取长补短，是组织的一大考验&lt;/li&gt;
&lt;li&gt;强调他能做什么，而不是他不能做什么，必须不断改进团体的能力和绩效&lt;/li&gt;
&lt;li&gt;实践而非说教&lt;br/&gt;a. 为了塑造良好的精神，必须依赖道德力量&lt;br/&gt;b. 道德必须是有形的行为，是每个人都看得到，可以实践和衡量的行为&lt;br/&gt;c. 实际做法：&lt;br/&gt;i. 必须建立高绩效标准，不能宽容差的或平庸的表现，而且必须根据绩效，给予奖励&lt;br/&gt;ii. 每个管理职位本身必须有其价值，而不只是升迁的踏板&lt;br/&gt;iii. 必须建立合理而公平的升迁制度&lt;br/&gt;iv. 管理章程中必须清楚说明谁有权制订事关管理者命运的重要决定，管理者必须有向高层申述的途径&lt;br/&gt;v. 在任命管理者时，必须很清楚诚实正直的品格是对管理者的绝对要求，是管理者原本就需具备的特质&lt;/li&gt;
&lt;li&gt;安于平庸的危险&lt;br/&gt;a. 不要容忍持续绩效不佳或表现平平&lt;br/&gt;b. 管理出现失误导致下属失败时，不应该开除员工，但也要把绩效不佳者调离目前工作岗位&lt;/li&gt;
&lt;li&gt;评估的需要&lt;br/&gt;a. 系统化评估下属设定目标和达成目标的能力&lt;br/&gt;b. 评估必须基于绩效&lt;br/&gt;c. 不要试图根据缺点做评估&lt;/li&gt;
&lt;li&gt;奖励和激励的酬劳&lt;br/&gt;a. 特殊奉献精神的奖励&lt;br/&gt;b. 注重长期才可达成目标任务的奖励&lt;br/&gt;c. 需要声望和荣耀的奖励&lt;/li&gt;
&lt;li&gt;升迁&lt;br/&gt;a. 不要过度强调升迁&lt;br/&gt;b. 头衔问题，不影响内部实质关系，但对外产生优越和荣誉感&lt;br/&gt;c. 企业应根据绩效来决定升迁&lt;br/&gt;d. 升迁制度必须确保所有具备升迁资格的员工都列在考虑名单上，而不是只有最受瞩目的人出线&lt;br/&gt;e. 必须由更高层的主管审慎评估所有的升迁确定&lt;/li&gt;
&lt;li&gt;管理章程&lt;br/&gt;a. 管理者应该了解谁是有权做决定的人&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首席执行官与董事会&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;企业高管需要建立中央治理机制和绩效评估机制&lt;/li&gt;
&lt;li&gt;首席执行官的工作必须有所规划，而且也必须根据计划来执行工作&lt;/li&gt;
&lt;li&gt;企业首席执行官的三个基本特质&lt;br/&gt;a. 思考者&lt;br/&gt;b. 行动者&lt;br/&gt;c. 抛头露面者&lt;/li&gt;
&lt;li&gt;最高领导层应该以团队形式组建&lt;/li&gt;
&lt;li&gt;如何组织最高层管理团队&lt;br/&gt;a. 必须是团队。团队没有集体责任，每个团队成员在他所负责的领域中享有最终决策权，有事情大家集思广益，但各自做决定&lt;br/&gt;b. 管理团队成员之间不能互相责难&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;培养管理者&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不能只培养可以获得升迁的员工&lt;/li&gt;
&lt;li&gt;原则：&lt;br/&gt;a. 必须培养所有的管理者&lt;br/&gt;b. 培养管理者必须是动态的活动&lt;br/&gt;i. 我们需要什么的组织来达到明天的目标？&lt;br/&gt;ii. 我们需要什么样的管理职务？&lt;br/&gt;iii. 为了满足明天的需求，管理者必须满足什么样的条件？&lt;br/&gt;iv. 他们需要获得哪些新技能、拥有哪些知识？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;企业需要哪一种结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过活动分析、决策分析、关系分析找出达到经营目标所需的结构&lt;/li&gt;
&lt;li&gt;活动分析&lt;br/&gt;a. 企业应该弄清楚需要哪些活动，才能达到经营目标？&lt;br/&gt;b. 传统制造业典型职能包含生产、营销、工程、会计、采购和人事&lt;/li&gt;
&lt;li&gt;决策分析&lt;br/&gt;a. 企业需要哪些决策以达成绩效、实现目标？&lt;br/&gt;b. 企业需要的决策属于哪一类？&lt;br/&gt;c. 应该由组织中哪个层级来制定决策？&lt;br/&gt;d. 企业决策的其中基本特性&lt;br/&gt;i. 决策的未来性&lt;br/&gt;ii. 决策对其他职能、其他领域或企业整体影响有多大？&lt;br/&gt;iii. 决策的性质是由其中包含多少质的因素来决定&lt;br/&gt;iv. 经常性决策或特殊决策&lt;br/&gt;e. 经常性决策应该建立通则&lt;/li&gt;
&lt;li&gt;关系分析&lt;br/&gt;a. 只有好好分析工作中的各种关系，才能做明智而成功的各种人事安排&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;建立管理结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;三个问题：&lt;br/&gt;a. 管理结构必须满足哪些条件&lt;br/&gt;b. 主要的重点和要求是什么&lt;br/&gt;c. 必须达到什么样的绩效&lt;/li&gt;
&lt;li&gt;三个答案：&lt;br/&gt;a. 管理结构在组织上必须以绩效为目标&lt;br/&gt;i. 应该通过企业绩效和成果来检验管理者&lt;br/&gt;ii. 管理结构必须让企业有意愿和能力为未来打拼&lt;br/&gt;b. 组织结构必须尽可能包含最少的管理层级，设计最便捷（短）的指挥链&lt;br/&gt;c. 组织机构必须能培育和检验未来的高层管理员&lt;/li&gt;
&lt;li&gt;联邦分权制&lt;br/&gt;a. 联邦分权制：尽可能整合所有活动，将企业活动组织成自主管理的产品事业，拥有自己的市场和产品，同时自负盈亏&lt;br/&gt;b. 优点：&lt;br/&gt;i. 将管理者的愿景和努力直接聚焦在经营绩效和成果上。大大降低经营者的自我欺骗&lt;br/&gt;ii. 企业可以充分发挥目标管理的功效&lt;/li&gt;
&lt;li&gt;职能分权制&lt;br/&gt;a. 职能性组织越接近联邦分权制，则效益越高，问题越少&lt;br/&gt;b. 组织职能性工作时，应赋予管理者最大的权责，来产出已完成或接近完成的产品或服务&lt;br/&gt;c. 联邦单位之间的关系是“平行”联结，职能性单位则是“序列”联结&lt;/li&gt;
&lt;li&gt;组织不健全的症状&lt;br/&gt;a. 管理层级不断增加&lt;br/&gt;b. 不能撤换表现不佳的员工&lt;br/&gt;c. 缺乏目标或目标混乱&lt;br/&gt;d. 员工没有明确的工作责任，只负责协助上司完成工作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;IBM的故事&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提升经济绩效的最大契机完全在于企业能否提升员工的工作效能&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;雇佣整个人&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把员工当成资源&lt;br/&gt;a. 人对于要不要工作，握有绝对的自主权&lt;br/&gt;b. 员工的工作动机决定了员工的产出&lt;br/&gt;c. 必须主动创造正面的诱因来激励员工的工作&lt;br/&gt;d. 工作的组织方式必须设法让个人所有的长处、进取心、责任感和能力，都能对群体的绩效和优势有所贡献&lt;/li&gt;
&lt;li&gt;企业对员工的要求&lt;br/&gt;a. 员工能发挥多大的生产力，有很大部分取决于企业对他们的要求有多高&lt;br/&gt;b. 员工必须愿意接受改变&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;员工对企业的要求&lt;br/&gt;a. 从事有意义的严肃工作&lt;br/&gt;b. 建立高绩效标准&lt;br/&gt;c. 具备组织和管理工作的高度能力&lt;br/&gt;d. 明确表达对于良好工作表现的关注&lt;/li&gt;
&lt;li&gt;管理层的任务是激发员工的工作动机和参与感&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创造巅峰绩效的组织&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;针对机械化工作，以机械化为原则;针对人的工作，则以整合为原则&lt;/li&gt;
&lt;li&gt;整合的规则&lt;br/&gt;a. 应用科学管理的方法来分析和组织工作&lt;br/&gt;b. 提高工作绩效最快的方法是改善个别动作或局部工作的绩效&lt;br/&gt;c. 动作的顺序必须经过系统化的设计，根据合乎逻辑的工作流程来安排&lt;/li&gt;
&lt;li&gt;组织人力来完成工作&lt;br/&gt;a. 应设法运用群体的力量和社会凝聚力，提升工作绩效，或至少应该避免两者彼此冲突&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;激励员工创造最佳绩效&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;唯一有效的方法是加强员工的责任感，而非满意度&lt;/li&gt;
&lt;li&gt;负责任的员工&lt;br/&gt;a. 四种方式研究：慎重安排员工职务、设定高绩效标准、提供员工自我控制所需的信息、提供员工参与的机会以培养管理者的愿景&lt;br/&gt;b. 管理层必须对自己的工作绩效提出高标准&lt;br/&gt;c. 最能激励员工绩效的就是把内部管理事务处理得无懈可击，通过这些活动向员工展示管理者的才干和他对工作的认真态度也直接反映出管理者的能力和标准&lt;br/&gt;d. 管理者能力的第一考研，就是是否有能力让员工在干扰最小的情况下，发挥工作最大的效益&lt;/li&gt;
&lt;li&gt;让员工了解情况&lt;br/&gt;a. 员工必须有能力控制、衡量和引导自己的表现&lt;/li&gt;
&lt;li&gt;拥有管理者的愿景&lt;br/&gt;a. 自豪感和成就感都必须源自于工作本身&lt;br/&gt;b. 负责执行工作的人能预先参与工作的规划，那么计划将会更加完善&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;管理者及其工作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管理者必须承担的两项任务&lt;br/&gt;a. 创造出大于各个部分总和的真正整体&lt;br/&gt;b. 协调每个决策和行动的长远的需求和眼前的需求&lt;/li&gt;
&lt;li&gt;管理者工作的五项基本活动&lt;br/&gt;a. 管理者设定目标，决定目标应该是什么，也决定应该采取哪些行动，以达到目标&lt;br/&gt;b. 管理者从事组织的工作&lt;br/&gt;c. 管理者必须激励员工&lt;br/&gt;d. 管理工作的基本要素是衡量标准&lt;br/&gt;e. 管理者必须培养人才&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做决策&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;做管理就是决策的过程&lt;/li&gt;
&lt;li&gt;管理决策中最常发生的错误是只强调找到正确答案，而重视提出正确的问题&lt;/li&gt;
&lt;li&gt;决策的五个阶段&lt;br/&gt;a. 界定问题&lt;br/&gt;i. 先找到“关键因素”&lt;br/&gt;ii. 假定一切条件都不变，问：未来将会发生什么状况？&lt;br/&gt;iii. 回顾过去，问：当初发生这个问题的时候，如果采取了什么行动，或不曾采取什么行动，将会影响到目前的状况？&lt;br/&gt;iv. 决定解决问题需要什么条件，同时彻底想清楚解决方案的目标为何&lt;br/&gt;b. 分析问题&lt;br/&gt;i. 将问题分类，并寻找事实&lt;br/&gt;ii. 决策需要承担风险&lt;br/&gt;c. 制定可行的替代方案&lt;br/&gt;i. 替代方案可保证我们在深思熟虑情况下做决策&lt;br/&gt;ii. 永远考虑一个方案:什么都不做&lt;br/&gt;d. 寻找最佳的解决方案&lt;br/&gt;i. 风险，根据预期收货，权衡每个行动的风险&lt;br/&gt;ii. 投入的精力所达到的经济效益&lt;br/&gt;iii. 考虑时机&lt;br/&gt;iv. 资源的限制，考虑执行决策的人是谁&lt;br/&gt;e. 把决策转化为有效的行动&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 25 May 2019 15:25:00 +0000</pubDate>
<dc:creator>zer0black</dc:creator>
<og:description>花了4个月的时间，总算完完整整的读完了《管理的实践》一书。书中诸多观点在现在看来，依旧很新颖，不亏是管理类书籍的开山之作。 这本书二战刚结束就开始创作，而今很多企业都做不到。与其说是实践，倒不如说是管</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zer0Black/p/10924497.html</dc:identifier>
</item>
<item>
<title>TensorFlow——tensorflow指定CPU与GPU运算 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10924444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10924444.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.指定GPU运算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果安装的是GPU版本，在运行的过程中TensorFlow能够自动检测。如果检测到GPU，TensorFlow会尽可能的利用找到的第一个GPU来执行操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果机器上有超过一个可用的GPU，除了第一个之外的其他的GPU默认是不参与计算的。为了让TensorFlow使用这些GPU，必须将OP明确指派给他们执行。with......device语句能够用来指派特定的CPU或者GPU执行操作：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

with tf.Session() as sess:
    with tf.device(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/cpu:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        a &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
        b &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
        add &lt;/span&gt;=&lt;span&gt; tf.add(a, b)
        sum &lt;/span&gt;= sess.run(add, feed_dict={a: 3, b: 4&lt;span&gt;})
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;设备的字符串标识，当前支持的设备包括以下的几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cpu:0  机器的第一个cpu。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gpu:0  机器的第一个gpu，如果有的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gpu:1  机器的第二个gpu，依次类推&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似的还有tf.ConfigProto来构建一个config，在config中指定相关的GPU，并且在session中传入参数config=“自己创建的config”来指定gpu操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，tf.ConfigProto函数的参数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;log_device_placement=True: 是否打印设备分配日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allow_soft_placement=True: 如果指定的设备不存在，允许TF自动分配设备&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

config &lt;/span&gt;= tf.ConfigProto(log_device_placement=True, allow_soft_placement=&lt;span&gt;True)

with tf.Session(config&lt;/span&gt;=&lt;span&gt;config) as sess:
    a &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    b &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    add &lt;/span&gt;=&lt;span&gt; tf.add(a, b)
    sum &lt;/span&gt;= sess.run(add, feed_dict={a: 3, b: 4&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.设置GPU使用资源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上文的tf.ConfigProto函数生成的config之后，还可以设置其属性来分配GPU的运算资源，如下代码就是按需分配&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

config &lt;/span&gt;= tf.ConfigProto(log_device_placement=True, allow_soft_placement=&lt;span&gt;True)
config.gpu_options.allow_growth &lt;/span&gt;=&lt;span&gt; True

with tf.Session(config&lt;/span&gt;=&lt;span&gt;config) as sess:
    a &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    b &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    add &lt;/span&gt;=&lt;span&gt; tf.add(a, b)
    sum &lt;/span&gt;= sess.run(add, feed_dict={a: 3, b: 4&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用 allow_growth option，刚开始会分配少量的GPU容量，然后按需要慢慢的增加，有与不会释放内存，随意会导致内存碎片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样，上述的代码也可以在config创建时指定，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

gpu_options &lt;/span&gt;= tf.GPUOptions(allow_growth=&lt;span&gt;True)
config &lt;/span&gt;= tf.ConfigProto(gpu_options=&lt;span&gt;gpu_options)


with tf.Session(config&lt;/span&gt;=&lt;span&gt;config) as sess:
    a &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    b &lt;/span&gt;=&lt;span&gt; tf.placeholder(tf.int32)
    add &lt;/span&gt;=&lt;span&gt; tf.add(a, b)
    sum &lt;/span&gt;= sess.run(add, feed_dict={a: 3, b: 4&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们还可以给gpu分配固定大小的计算资源。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
gpu_options = tf.GPUOptions(allow_growth=True, per_process_gpu_memory_fraction=0.5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码的含义是分配给tensorflow的GPU显存大小为：GPU的实际显存*0.5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190525230226022-730645487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190525230314017-592457960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 15:05:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>1.指定GPU运算 如果安装的是GPU版本，在运行的过程中TensorFlow能够自动检测。如果检测到GPU，TensorFlow会尽可能的利用找到的第一个GPU来执行操作。 如果机器上有超过一个可用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baby-lily/p/10924444.html</dc:identifier>
</item>
<item>
<title>Thread线程的基础知识及常见疑惑点 - 张曾经</title>
<link>http://www.cnblogs.com/zzq6032010/p/10921870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/10921870.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    相信各位道友在平时工作中已经很少直接用到Thread线程类了，现在大多是通过线程池或者一些多线程框架来操作线程任务，但我觉得还是有必要了解清楚Thread线程类中各种方法的含义，了解了底层才能更好的理解框架、应用框架。下面我就将Thread线程的相关基础点总结一二，以供观瞻。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、Thread线程的状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    根据《深入理解Java虚拟机》一书的讲述，Java语言定义了五种线程状态，分别为：创建（new）、运行（Runnable）、等待（waiting）、阻塞（blocked）、结束（terminated）。而且规定，在某一个时间点，每个线程能且只能处于其中的一种状态。&lt;/p&gt;
&lt;p&gt;其中，运行状态又包括就绪（Ready）跟正在运行（Running），区别就是是否获得了CPU的执行时间。&lt;/p&gt;
&lt;p&gt;对于等待跟阻塞状态，需要着重说明一下，因为此处极易搞错，而且也是面试常被问到的点。等待状态，一般由Object.wait()、Thread.sleep()、Thread.join()、LockSupport.park()等方法以及这些方法带时间控制的同类方法实现线程的等待。而阻塞状态，一般是由于当前线程还未获取到独占锁且正在等待获取，此时称为阻塞。可以将等待看做主动的线程暂停执行，以为需要调用特定的方法线程才会等待；而阻塞可以看做是被动的线程暂定执行，因为线程在等着获取独占锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、Thread线程的相关方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    start()方法/run()方法：有时在面试的时候，面试官会问到调用线程的start方法跟直接调用run方法有什么区别？虽然有的道友看到这里会觉得问这种问题的面试官有点很没必要，但我还是说一下。调用start方法后，最终会调用Thread类中的一个本地方法start0，这个方法可以新建一个线程来运行你的run方法，而调用run方法后只是在当前线程上运行你的run方法，并没有新线程参与。&lt;/p&gt;
&lt;p&gt;    wait()方法/sleep()方法：请注意，这里很多人都会记错，wait方法以及跟它配套的notify/notifyAll方法，是位于顶级父类Object下的，而其他操作线程的方法都在Thread线程类下。为什么要将wait方法放在Object下呢？其实这是由wait/notify方法的实现原理决定的。wait方法调用了之后，会释放锁，并让当前线程等待，而对于java的原生锁synchronized，是隶属于一个特定对象的监视器monitor的，那这个释放的是锁谁的锁？不能是别人的，只能是调用wait方法的那个对象的。而这个锁是哪里来的？要释放锁，肯定之前加过锁，在哪里加的呢？只能是在synchronized块中给这个对象加的，所以这也解释了为什么wait/notify方法一直要跟synchronized一起用，因为它俩就是通过操作对象的锁实现的等待和唤醒。相比而言sleep方法单纯很多，它只是让当前线程睡眠一段时间，并不会涉及到对锁的操作，所以直接放在Thread类中就行。对于wait跟notify的演示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         System.out.println(&quot;thread获取到锁，触发wait&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                        obj.wait();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         System.out.println(&quot;wait over&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         System.out.println(&quot;thread1获取到锁&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         System.out.println(&quot;1秒后唤醒&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                        obj.notify();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     System.out.println(&quot;notify over&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        thread1.start();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;thread获取到锁，触发wait
thread1获取到锁
1秒后唤醒
notify over
wait over&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  LockSupport.park()：另外还有JUC包中的park方法让当前线程等待。此方法是使用CAS实现的线程等待，不会释放锁。而park/unpark方法比wait/notify这一对好的地方在于，前者可以先unpark在park，这是线程仍然会继续执行；而对于wait/notify，则需要通过程序控制执行顺序，一定要先wait在notify/notifyAll，否则顺序反了线程就会一直等待下去，由此悲剧诞生...  比如讲上述wait/notify的代码34行35行调换一下顺序，执行结果如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;thread1获取到锁
1秒后唤醒
notify over
thread获取到锁，触发wait&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仿佛云天明对程心那一千八百万年的等待&lt;/p&gt;
&lt;p&gt;    join()/yield()：对于Thread下的这两个方法，之所以放在一起讲解，就是因为这两个方法平时比较少用到，属于闲云野鹤的存在。&lt;/p&gt;
&lt;p&gt;yield()方法是让当前线程让步，让步的意思就是放弃执行权，即当前线程会从上述说的运行状态runnable中的running状态进入ready就绪状态，但是虚拟机不保证当前线程执行了yield方法后不会紧接着再次进去running状态，因为可能CPU分配执行时间时又分给了当前线程。所以这个方法其实一般也没啥用，因为效果不稳定。&lt;/p&gt;
&lt;p&gt;join()方法是将调用join的线程插入当前线程的执行过程中，即让当前线程等待，先执行完调用join的线程，再继续执行当前线程。注意join方法不会释放锁。join的演示代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunnableThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         System.out.println(&quot;runnable run&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             System.out.println(&quot;开始睡眠&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Thread.sleep(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(&quot;睡了5秒&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             System.out.println(&quot;runnable exception:&quot; +&lt;span&gt; e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunnableThread());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        thread.join();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;runnable run
开始睡眠
睡了5秒
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    这次先到这里，上述说的东西，虽然很小，而且实际中不会直接用到，但是对于我们理解线程的运行机制、理解多线程框架都有好处，所以还是有必要在自己的学习地图上理解清楚。其实线程还有一个很重要的点就是线程的中断，多线程框架或者JUC包的源码中都会涉及到对线程中断的处理以及响应，这一块我会在后面梳理清楚了之后专门整理出来。最近觉得学习进入了停滞期，有点不知道从何下手，觉得需要学的东西太多。在这里，想跟各位道友讨教一下，一个资质普通的开发者，如何才能将自己的实力提升到一个比较高的层次（比如阿里的P6P7及以上？）欢迎留言赐教，在此不胜感激！&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 14:59:00 +0000</pubDate>
<dc:creator>张曾经</dc:creator>
<og:description>引言 相信各位道友在平时工作中已经很少直接用到Thread线程类了，现在大多是通过线程池或者一些多线程框架来操作线程任务，但我觉得还是有必要了解清楚Thread线程类中各种方法的含义，了解了底层才能更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/10921870.html</dc:identifier>
</item>
<item>
<title>Flak 解析json数据不完整？ - 钟摆人</title>
<link>http://www.cnblogs.com/zhongbr/p/python_flask.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongbr/p/python_flask.html</guid>
<description>&lt;p&gt;当使用Python的flask框架来开发网站后台，解析前端Post来的数据，通常都会使用request.form来获取前端传过来的数据，但是如果传过来的数据比较复杂，其中右array，而且array的元素不是单个的数字或者字符串的时候，就会出现解析不到数据的情况，比如使用下面的js代码向python flask传递数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;$.ajax({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&quot;url&quot;:&quot;/test&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&quot;method&quot;:&quot;post&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　&quot;data&quot;&lt;span&gt;:{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 　　　　　　&quot;test&quot;&lt;span&gt;:[
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;1&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;2&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;3&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;　　　　　　　　]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;　　　　　　}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;　　}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们使用flask的request.form获取前端的数据时，发现获取到的数据是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ImmutableMultiDict([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;？？？我的Post数据呢？给我post到哪里去了？？？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我就去网上查解决办法，但是网上哪些删么使用reqeust.form.getlist()方法好像都对我无效，但是又找不到其他的解决方案？怎么办？&lt;/p&gt;
&lt;p&gt;规范一下自己的请求，在前端请求的时候设置一个Json的请求头，在flask框架钟直接使用json.loads()方法解析reqeust.get_data(as_text=True)，就可以解析到完整的post参数了！&lt;/p&gt;
&lt;p&gt;前端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;$.ajax({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&quot;url&quot;:&quot;/test&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&quot;method&quot;:&quot;post&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　&quot;headers&quot;:{&quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一句很重要！！！&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 　　&quot;data&quot;&lt;span&gt;:{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　　　&quot;test&quot;&lt;span&gt;:[
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;1&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;2&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 　　　　　　　　{&quot;test_dict&quot;:&quot;3&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 　　　　　　&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 　　　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 　　}&lt;br/&gt;　　)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;python代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,methods=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.loads(request.get_data(as_text=&lt;span&gt;True)))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后看看后台打印的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
* Serving Flask app &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_flask.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
*&lt;span&gt; Environment: development
&lt;/span&gt;*&lt;span&gt; Debug mode: off
&lt;/span&gt;* Running on http://127.0.0.1:5000/ (Press CTRL+&lt;span&gt;C to quit)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}]}
&lt;/span&gt;127.0.0.1 - - [25/May/2019 22:43:08] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST /test HTTP/1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 200 -
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;问题解决，可以解析到完整的json数据啦！&lt;/h2&gt;
</description>
<pubDate>Sat, 25 May 2019 14:55:00 +0000</pubDate>
<dc:creator>钟摆人</dc:creator>
<og:description>python flask框架解析post数据的坑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhongbr/p/python_flask.html</dc:identifier>
</item>
<item>
<title>初级Springboot（一） - StanleyBlogs</title>
<link>http://www.cnblogs.com/StanleyBlogs/p/10924359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StanleyBlogs/p/10924359.html</guid>
<description>&lt;p&gt;作者 ： Stanley 罗昊&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;转载请注明出处和署名，谢谢！&lt;/strong&gt;】&lt;/p&gt;
&lt;h2&gt;一.了解Springboot&lt;/h2&gt;
&lt;p&gt;做Java开发的小伙伴都知道，我们在做项目的时候，需要去写大量的配置文件，另外呢，集成第三方组件的时候，也非常复杂，然而，现在流行的语言呢使用起来都非常的简单，这样就降低了Java的京竞争力，所以说呢，在这种情况下，Springboot就产生了；&lt;/p&gt;
&lt;p&gt;总之，它的目前呢，就是来减少我们Java程序员的工作量，下面我们来介绍一下Springboot的核心特点：&lt;/p&gt;
&lt;p&gt;首先呢，我们使用Springboot我们可以直接创建Java工程，不需要去创建web工程了，那么，最后打包的时候呢，打成一个jar包，虽然打成一个jar包它可以，以web程序的形式来运行；&lt;/p&gt;
&lt;p&gt;另外呢，Sprinhboot它内嵌了Servlet容器，比如说我们常用的Tomcat、Jetty，那么这个Springboot呢内置了这样呢，我们就不需要自己去配置，所以呢，也减少了在咱们的这个开发者的工作量；&lt;/p&gt;
&lt;p&gt;还有一点就是Maven/Gradle进行jar包依赖的时候这个Springboot也进行了简化；&lt;/p&gt;
&lt;p&gt;另外呢，Springboot还可以自动的去配置这个Bean，我们在之前使用Spring的时候需要自己手动去配置，而Springboot呢可以自动的去配置；&lt;/p&gt;
&lt;p&gt;然后呢，Springboot还提供了基于HTTP、ssh、telnt对运行时的项目进行一个监控；&lt;/p&gt;
&lt;p&gt;Springboot最大的特点呢，就是减少了任何的XML的配置，这里面呢，我们基本上就使用注解就可以了；&lt;/p&gt;
&lt;h2&gt;二.入门程序&lt;/h2&gt;
&lt;p&gt;入门程序的话就比较简单，我这边使用的是IDEA；&lt;/p&gt;
&lt;p&gt;下面呢，我们就简单的来创建一个Springboot项目；&lt;/p&gt;
&lt;p&gt;我呢，选择使用Gradle来创建一个springboot工程，创建步骤很简单，在这里我就不讲述了；&lt;/p&gt;
&lt;p&gt;创建完成后呢，我们现在以单体项目为例，创建完成之后，一个完整的Springboot项目就建好了，因为我们现在建的是一个单体项目，所以无需建立多个服务；&lt;/p&gt;
&lt;p&gt;在项目中的，build.gardle中配置项目的依赖，然后引入依赖就行了；&lt;/p&gt;
&lt;p&gt;一个单体的Springboot项目就建好了；&lt;/p&gt;
&lt;h2&gt;三.实战开发 - 启动自动配置注解&lt;/h2&gt;
&lt;p&gt;在我们编写Controller层的时候，我们仅需在接口上添加@RequestMing，在括号中填写我们的访问的url；&lt;/p&gt;
&lt;p&gt;但是，既然用到了Controller，我们马上就能想起来到，我们需要配置SpringMvc一些相关组件，比如说，处理器映射器，处理器适配器，视图解析器，以及核心控制器，但是呢，咱们任何配置都没有写，照样可以访问这个Controller，当然，这也是有原因呢，这里面起作用的呢是一个注解：&lt;/p&gt;
&lt;p&gt;@EnableAutoConfiguration，很显然，这个注解的作用就是，启动自动配置，所以呢，所有关于SpringMvc的配置呢，Springboot注解已经帮你做好了；&lt;/p&gt;
&lt;p&gt;另外，我们访问这个Controller接口的时候，我们在可以直接访问，这也就表明，Springboot内置了Tomcat，并且默认端口是8080；&lt;/p&gt;
&lt;p&gt;这个时候，我们就好奇，@EnableAutoConfiguration这个注解，到底是什么原理呢？它怎么就知道我们想要的配置呢？&lt;/p&gt;
&lt;p&gt;@EnableAutoConfiguration：&lt;/p&gt;
&lt;p&gt;启动自动配置该注解会使Springboot根据项目依赖的jar包进行自动配置项目的配置项，例如：、&lt;/p&gt;
&lt;p&gt;我们添加了spring-boot-srarter-web的依赖，项目中也就会引入SpringMvc的依赖，Springboot就会自动配置Tomcat和SpringMvc&lt;/p&gt;
&lt;h2&gt;四.实战开发 - 自定义bannr&lt;/h2&gt;
&lt;p&gt;在启动Springboot项目的时候，我们在控制台可以看到一个打印的图标：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190525224354975-240814261.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个呢，我们称之为banner，如果想改变，其实很容易，我们只需要访问以下网址：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后选择你喜欢的图标：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190525224407167-383271884.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后复制生成好的图标，然后再将我们桌面上创建一个记事本，把文本粘贴进去：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190525224418258-1893029020.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后将这个记事本取名为：banner.txt，名称不能乱起！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，将这个记事本，复制，粘贴到项目中的resources：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190525224427614-489537674.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再启动，我们就发现，图标变啦：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190525224437382-1279356457.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 25 May 2019 14:50:00 +0000</pubDate>
<dc:creator>StanleyBlogs</dc:creator>
<og:description>初级Springboot（一） 作者 ： Stanley 罗昊 【转载请注明出处和署名，谢谢！】 一.了解Springboot 做Java开发的小伙伴都知道，我们在做项目的时候，需要去写大量的配置文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/StanleyBlogs/p/10924359.html</dc:identifier>
</item>
<item>
<title>一些傍晚的感想 - zhuiyicc</title>
<link>http://www.cnblogs.com/zhuiyicc/p/10924322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuiyicc/p/10924322.html</guid>
<description>&lt;p&gt;打ACM这么久了，从来没有今天晚上感想这么多。&lt;/p&gt;
&lt;p&gt;该从何说起呢。马上大四了，才醒悟过来时间已经不多了，以前一直觉得时间还多，很多东西可以以后补回来，&lt;/p&gt;
&lt;p&gt;但是现在已经来不及了，或者说顿时觉得时间不够了，一边是要顾着考研， 一边又想打比赛，这段时间总在二者之间徘徊。&lt;/p&gt;
&lt;p&gt;但我觉得我并没有后悔把这么多时间花费在ACM上，虽然说在比赛上没出什么成果(这可能是比较悲惨的一件事情)&lt;/p&gt;
&lt;p&gt;总该有些总结吧。&lt;/p&gt;
&lt;p&gt;首先反省自己为什么在ACM这条路上没有走的更远，第一点莫过于还是不够聪明，嗯，借网图一张表达我此刻的想法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463737/201905/1463737-20190525215553772-218943245.png&quot; alt=&quot;&quot; width=&quot;183&quot; height=&quot;183&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，搞笑完了，正所谓逆天而行，但大家看过小说，如果自己基础够好，逆天而行，也未尝不能渡劫，自然是因为自己不够聪明(努力)，&lt;/p&gt;
&lt;p&gt;想想英雄联盟，魔兽之类的游戏，还有这个小说，再回首，似乎啥也没捞着，大学三年，还是个白金，小说也没写成，魔兽也只会防守图，&lt;/p&gt;
&lt;p&gt;说不上后悔吧，只是觉得从前自己的想法太过幼稚，浪费的时间，实际上是浪费了价值。(如果你做了一段时间acm，还是没找到乐趣，建议&lt;/p&gt;
&lt;p&gt;退坑，因为这玩意是吸血的，额，是吸时间，当然咯，做什么不花时间呢，不如早早搞搞项目？或者学点网络安全？哈哈，我的意思并不是说&lt;/p&gt;
&lt;p&gt;acm一定是最好的，自己想要的才是最好的总之，特别希望大家能够在大一就能找到自己想要走的路，在下也是各种尝试，可惜浪费了时间)&lt;/p&gt;
&lt;p&gt;第二点，从来没有去搞过自己薄弱的部分，好了，再借网游里面的情节，如果你的攻高，血薄，自然你被怪一打就死，但如果说你去加强&lt;/p&gt;
&lt;p&gt;你的血量，自然可以扛过去，并且能够反杀。这个薄弱部分指的是什么？自然是说的在一场比赛后，做的很艰难的题，没做出的题可以说&lt;/p&gt;
&lt;p&gt;是你的知识量不够而已，做的很艰难的往往都是同一类型的题，但我在这三年来从未总结过，直到最近才明白，为什么做了这么多的题目，&lt;/p&gt;
&lt;p&gt;但是水平卡在了中间的瓶颈上，实际上会做的你永远可以很快做出，不会的你永远不会，这也像英雄联盟里，如果你不玩一个英雄，那么你&lt;/p&gt;
&lt;p&gt;根本不了解它，即使去强行打排位，也只会坑队友罢了，而对于你熟悉的英雄自然是十拿九稳的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463737/201905/1463737-20190525220341752-1445139518.png&quot; alt=&quot;&quot; width=&quot;127&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如上图的O(N^N),你不会的永远只是个O(N^N)，没有人一开始就会O(N)。&lt;/p&gt;
&lt;p&gt;当然可能还有一些点，自己没提，但我想最致命的无非这二者。&lt;/p&gt;
&lt;p&gt;作为一个即将过时的acmer一些小小的建议:&lt;/p&gt;
&lt;p&gt;当然就是忙着去学，学基础，在我看来，acm只分为三大类，数学，数据结构，算法。数学可以不先去搞，因为比较难搞，首先要去搞定的是数据结构，&lt;/p&gt;
&lt;p&gt;极度不推荐在比赛外用STL容器，因为这并不是一个好习惯，极度推荐赛外自己想数据结构去解决问题，这样在比赛的时候，你能快速想到用什么数据&lt;/p&gt;
&lt;p&gt;结构去解决，而STL的限制是非常多的，举个例子，STL没办法同时支持以下区间求和，区间删除，区间修改，如果你对STL依赖太多，就如我，一上来&lt;/p&gt;
&lt;p&gt;就问自己能不能STL解决，这是非常费时间的，搞好基础的数据结构之后，可以去学一些基础的算法，这里不再赘述，因为搜搜网上就有各类算法，不要着急，&lt;/p&gt;
&lt;p&gt;因为你的时间比我多太多了，但也不要告诉自己时间还多(嗯，在下正是明日复明日的那个lowB)，首先你可以把这些基础算法对应的一些直接的题目做了，&lt;/p&gt;
&lt;p&gt;直接也就是说，裸用这个算法就可以解决的问题。在对这些算法有了大致的了解之后，再去cf，严重推荐cf，因为cf上出了标签，难度的筛选了，这时候你想做&lt;/p&gt;
&lt;p&gt;对于某个算法的变形题，可以去这上面自己找题目做，对一个算法大概做10个，我敢保证，你在比赛里再遇到就算写不出来，也知道要用这玩意写。&lt;/p&gt;
&lt;p&gt;以上是筑基篇(基础篇)。&lt;/p&gt;
&lt;p&gt;当然在做完上述事情后，相信你有了一定能力在规定时间内能够解决cf上div2的前3-4题了，但这不够，因为你的数学不行。数学，仔细想了想，我这个LB只能&lt;/p&gt;
&lt;p&gt;推荐一下，建议不要从数论开始，可以先从组合数学或者概率论下手(反正我是只会找规律了，概率我也只会dp)，其次再搞数论，当然如果想逆天而行，可以试试&lt;/p&gt;
&lt;p&gt;先数论，建议看点数学专业的书(这里建议需要深入学的同学试试这玩意，我试了，然后gg了)，高数的话，说实话我打比赛还没见过(其实有的，比方说有个公式可以&lt;/p&gt;
&lt;p&gt;代替微积分求二维平面上面那个啥玩意面积来着，但是要精度高一点)，最后才是计算几何(经常性差精度，无数坑点)。&lt;/p&gt;
&lt;p&gt;以上是金丹篇(提高篇)。&lt;/p&gt;
&lt;p&gt;最后的最后，好了我知道我不该水这一部分的，但是我还是想说下，不如试试bzoj，或者把cf上的2500以上题筛出来试试？&lt;/p&gt;
&lt;p&gt;以上是提高篇。&lt;/p&gt;
&lt;p&gt;以上纯属个人建议，如有雷同，概不负责！如果误导你了，也请不要来打我！&lt;/p&gt;
&lt;p&gt;另外在比赛上的建议，可能也是大家有时候容易犯的错误。&lt;/p&gt;
&lt;p&gt;1.复制粘贴一定要注意检查。&lt;/p&gt;
&lt;p&gt;2.无向图，注意你建的数组大小要为2倍。&lt;/p&gt;
&lt;p&gt;3.有时候你试试快读说不定过了，但是不建议用，比赛时候会卡输入？？？但是如果T了，就试试吧，说不定有奇迹。&lt;/p&gt;
&lt;p&gt;4.注意数组的清0。&lt;/p&gt;
&lt;p&gt;5.注意检查边界数据，极限数据。&lt;/p&gt;
&lt;p&gt;6.自己写的调试输出代码一定要删掉，交代码之前要检查。&lt;/p&gt;
&lt;p&gt;7.无论这一次你改过的代码你有多确定能过，都要再测一次样例。&lt;/p&gt;
&lt;p&gt;说了这么多了，也终于要结束了，再鸡血一下。&lt;/p&gt;
&lt;p&gt;但凡热爱，但凡追逐，终有所得。&lt;/p&gt;
&lt;p&gt;而我所得的，仅仅只是热爱acm罢了。&lt;/p&gt;
&lt;p&gt;好了，祝各位ACMer前程似锦，在下退下了。&lt;/p&gt;
&lt;p&gt;综上了，用一首著名的诗结尾:&lt;/p&gt;
&lt;p&gt;我好菜呀，&lt;/p&gt;
&lt;p&gt;模拟只会猜题意 。&lt;br/&gt;贪心只能过样例 。&lt;br/&gt;数学上来先打表 。&lt;br/&gt;D P 一般看规律 。&lt;br/&gt;组合数学靠运气 。&lt;br/&gt;计算几何瞎暴力 。&lt;br/&gt;图论一顿套模板 。&lt;br/&gt;数论只会 GCD。&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 14:42:00 +0000</pubDate>
<dc:creator>zhuiyicc</dc:creator>
<og:description>打ACM这么久了，从来没有今天晚上感想这么多。 该从何说起呢。马上大四了，才醒悟过来时间已经不多了，以前一直觉得时间还多，很多东西可以以后补回来， 但是现在已经来不及了，或者说顿时觉得时间不够了，一边</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuiyicc/p/10924322.html</dc:identifier>
</item>
<item>
<title>最简单的window下使用Jenkins来做自动化部署的教程 - 隨風.NET</title>
<link>http://www.cnblogs.com/xinzhyu/p/10924311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinzhyu/p/10924311.html</guid>
<description>&lt;p&gt;今天我们来说一下,如何使用Jenkins+powershell脚本,将我们的.NET CORE的脚本部署到对应的服务器上.&lt;/p&gt;
&lt;p&gt;这里我们使用的源码管理工具是TFS.虽然源码管理器比较老旧,但是原理都差不多.&lt;/p&gt;
&lt;p&gt;1.安装Jre,因为我们的Jenkins是基于java开发的,所以需要先在服务器上安装java的运行时环境&lt;/p&gt;
&lt;p&gt;这个安装过程比较简单,百度下载JRE,然后安装,暂且不表.&lt;/p&gt;
&lt;p&gt;下载地址:https://www.java.com/en/download/manual.jsp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/15670/201905/15670-20190525220931189-1534847962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.下载并安装Jenkins,这里服务器是Windows的,所以最好下载Windows版本的,安装好以后直接就以Windows服务的形式运行了.&lt;/p&gt;
&lt;p&gt;这个安装过程也是非常的简单,网上教程很多.&lt;/p&gt;
&lt;p&gt;https://jenkins.io/download/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/15670/201905/15670-20190525221154871-1090802041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.安装好Jenkins以后,根据需要我们安装权限插件,给不用的账号配置不通过的权限,(此步骤可选)&lt;/p&gt;
&lt;p&gt;具体可参看此文章,说的很详细:&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_16320025/article/details/82897577&lt;/p&gt;

&lt;p&gt;4.最关键的一步来了,就是如何使用Jenkins来自动部署我们的代码.&lt;/p&gt;
&lt;p&gt;这里主要分以下几个小点,下面我会贴出详细的代码.&lt;/p&gt;
&lt;p&gt;1)获取TFS中的最新源码,这里我并没有通过Jenkins去获取代码,而是通过tf命令去拉取代码的.&lt;/p&gt;
&lt;p&gt;这样的好处就是,所有的Jenkins任务的源代码,我都可以使用同一份,而不用每个任务单独去拉取一份代码.&lt;/p&gt;
&lt;p&gt;2)拉取到代码以后,自然就是通过命令来编译我们的代码,熟悉.net的朋友们应该都知道,无非就那几个命令了&lt;/p&gt;
&lt;p&gt;3)代码发布出来以后,自然就是要将代码copy到我们的站点或者Windows服务下面去.&lt;/p&gt;
&lt;p&gt;这一步也很简单,无非就是通过命令停止iis站点和应用程序池;copy代码;重启启动对应的站点即可&lt;/p&gt;
&lt;p&gt;一套下来,打完收工.&lt;/p&gt;

&lt;p&gt;下面贴出几个关键步骤的截图:&lt;/p&gt;
&lt;p&gt;1.Jenkins创建自由风格的任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/15670/201905/15670-20190525222758288-448164618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.其他什么都可以不选,只要我们使用powershell脚本,需要Jenkins支持powershell也需要安装插件&lt;/p&gt;
&lt;p&gt;可参看如下链接:https://blog.csdn.net/ff55fff/article/details/76804966&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/15670/201905/15670-20190525222930048-1057615714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3.点击保存,一套搞定.点击build now即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/15670/201905/15670-20190525223104800-245281209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;ps:下面给出详细的powershell脚本,非常简单这里就不详述了,大家一看代码就明白了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aa66381a-39b4-4c41-9c47-b3024ea3d33d')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_aa66381a-39b4-4c41-9c47-b3024ea3d33d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa66381a-39b4-4c41-9c47-b3024ea3d33d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aa66381a-39b4-4c41-9c47-b3024ea3d33d',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa66381a-39b4-4c41-9c47-b3024ea3d33d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;net stop Test1Job
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;C:\Windows\System32\inetsrv\appcmd.exe stop site Test1.test.com
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;C:\Windows\System32\inetsrv\appcmd.exe stop site Test1.api.test.com
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; C:\Windows\System32\inetsrv\appcmd.exe stop apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1.test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; C:\Windows\System32\inetsrv\appcmd.exe stop apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1.api.test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; dir &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PSScriptRoot\lib&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&lt;span&gt;Filter&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.ps1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | &lt;span&gt;foreach&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  . &lt;span&gt;$_&lt;/span&gt;&lt;span&gt;.fullName
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  Write-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Import $($_.fullName)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.获取源码&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;D:\test\tools\get_tfs.bat
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.编译源码&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; dotnet build D:\test\Source\MTools\Source-Promotion\Test.API.csproj -nowarn:msb3202,nu1503,cs1591 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;--no-restore&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;echo API OK
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; dotnet build D:\test\Source\MTools\Source-Promotion\Test.Web.csproj -nowarn:msb3202,nu1503,cs1591 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;--no-restore&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;echo WEB OK
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; dotnet build D:\test\Source\MTools\Source-Promotion\Test.Job.WindowsService.csproj -nowarn:msb3202,nu1503,cs1591 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;--no-restore  -v q&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;echo job OK
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; Sleep 20
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3.发布&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; CCopy D:\test\Source\MTools\Test.\Source-Promotion\Test.API\bin\Debug\netcoreapp2.1&lt;span&gt; D:\Test\Test1\api
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; CCopy D:\test\Source\MTools\Test.\Source-Promotion\Test.Web\bin\Debug\netcoreapp2.1&lt;span&gt; D:\Test\Test1\web
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; CCopy D:\test\Source\MTools\Test.\Source-&lt;span&gt;Promotion\Test.Web\wwwroot D:\Test\Test1\web\wwwroot
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; CCopy D:\test\Source\MTools\Test.\Source-Promotion\Test.Job.WindowsService\bin\Debug\netcoreapp2.1\win-&lt;span&gt;x64 D:\Test\Test1\job
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;net start Test1Job
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;C:\Windows\System32\inetsrv\appcmd.exe start site Test1.test.com
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;C:\Windows\System32\inetsrv\appcmd.exe start site Test1.api.test.com
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; C:\Windows\System32\inetsrv\appcmd.exe start apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1.test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; C:\Windows\System32\inetsrv\appcmd.exe start apppool /apppool.name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test1.api.test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; Write-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; Get-Date
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('83a277ec-1a91-4b5c-899b-5481491125a9')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_83a277ec-1a91-4b5c-899b-5481491125a9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_83a277ec-1a91-4b5c-899b-5481491125a9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('83a277ec-1a91-4b5c-899b-5481491125a9',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_83a277ec-1a91-4b5c-899b-5481491125a9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;  CCopy(&lt;span&gt;$folder_a_path&lt;/span&gt;,&lt;span&gt;$folder_b_path&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!(test-path &lt;span&gt;$folder_b_path&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         md &lt;span&gt;$folder_b_path&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历源文件夹下所有文件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;$folders_a&lt;/span&gt; = gci &lt;span&gt;$folder_a_path&lt;/span&gt; -&lt;span&gt;Recurse
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$folder_a&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;$folders_a&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$folder_a&lt;/span&gt;.fullname &lt;span&gt;-like&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*appsettings.json*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过替换的方式，取目标文件的全路径名称&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;$b&lt;/span&gt; = &lt;span&gt;$folder_a&lt;/span&gt;.fullname.replace(&lt;span&gt;$folder_a_path&lt;/span&gt;,&lt;span&gt;$folder_b_path&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断目标文件是否存在，如果存在则先判断新旧&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;If&lt;/span&gt; (test-path &lt;span&gt;$b&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断目标是否为目录，如果是目录则跳过，如果不跳过，则会创建一级空目录&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;          &lt;span&gt;If&lt;/span&gt; (!((gi &lt;span&gt;$b&lt;/span&gt;&lt;span&gt;).PSIsContainer))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断目标文件、源文件的新旧情况，如果目标已存在文件的修改时间早于源文件，则重新拷贝覆盖&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;            &lt;span&gt;If&lt;/span&gt; ((gci &lt;span&gt;$b&lt;/span&gt;).lastwritetime &lt;span&gt;-lt&lt;/span&gt; &lt;span&gt;$folder_a&lt;/span&gt;&lt;span&gt;.lastwritetime)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;              copy-item &lt;span&gt;$folder_a&lt;/span&gt;.fullname &lt;span&gt;$b&lt;/span&gt; -&lt;span&gt;force
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果目标文件不存在，则直接拷贝&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;       &lt;span&gt;Else&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;          copy-item &lt;span&gt;$folder_a&lt;/span&gt;.fullname &lt;span&gt;$b&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;复制文件&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;一套打完手工,大家有什么意见和建议,请提出~&lt;/p&gt;
&lt;p&gt;后续将进一步写通过powershell将程序发布到其他服务器上,以及发布完成以后,邮件告知结果&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 14:40:00 +0000</pubDate>
<dc:creator>隨風.NET</dc:creator>
<og:description>今天我们来说一下,如何使用Jenkins+powershell脚本,将我们的.NET CORE的脚本部署到对应的服务器上. 这里我们使用的源码管理工具是TFS.虽然源码管理器比较老旧,但是原理都差不多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xinzhyu/p/10924311.html</dc:identifier>
</item>
<item>
<title>Redis实用监控工具一览 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_monitor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_monitor.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;31.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Redis已经成为web应用开发不可或缺的一个组成部分，在项目中的应用越来越广泛，这篇文章就来讲讲那些关于Redis监控的那点事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;redis-benchmark&lt;/h2&gt;
&lt;p&gt;1.1 简介&lt;/p&gt;
&lt;p&gt;第一个就介绍一下，Redis自带的性能检测工具redis-benchmark, 该工具可以模拟 N 个客户端同时发出 Y 个请求。 可以使用 redis-benchmark -h 来查看基准参数。&lt;/p&gt;
&lt;p&gt;1.2 命令格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-benchmark [-h ] [-p ] [-c ] [-n &amp;lt;requests]&amp;gt; [-k ]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.3 参数介绍：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-h&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定服务器主机名&lt;/td&gt;
&lt;td&gt;127.0.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-p&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定服务器端口&lt;/td&gt;
&lt;td&gt;6379&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定服务器 socket&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-c&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定并发连接数&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-n&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定请求数&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-d&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;以字节的形式指定 SET/GET 值的数据大小&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-k&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1=keep alive 0=reconnect&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-r&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;SET/GET/INCR 使用随机 key, SADD 使用随机值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-P&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;通过管道传输 &amp;lt;numreq&amp;gt; 请求&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-q&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;强制退出 redis。仅显示 query/sec 值&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;--csv&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;以 CSV 格式输出&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-l&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;生成循环，永久执行测试&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-t&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;仅运行以逗号分隔的测试命令列表。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;-I&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Idle 模式。仅打开 N 个 idle 连接并等待。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;1.4 实例：&lt;/p&gt;
&lt;p&gt;1.4.1 同时执行1000个请求来检测性能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-benchmark -n 1000 -q&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201905/506684-20190523180025095-268398448.png&quot; alt=&quot;Redis监控工具&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.4.2 50个并发请求，10000个请求，检测Redis性能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-benchmark -h localhost -p 6379 -c 50 -n 10000&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost toutou]# redis-benchmark -h localhost -p 6379 -c 50 -n 10000
====== PING_INLINE ======
  10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

96.25% &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
98.38% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
99.01% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
88495.58 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;PING_BULK &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.10 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

97.74% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
95238.10 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;SET &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.44% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
93457.95 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;GET &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.33% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
99.13% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
93457.95 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;INCR &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.10 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.28% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
95238.10 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LPUSH &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.10 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.70% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
97087.38 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;RPUSH &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.10 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.66% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
95238.10 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LPOP &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.15 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

93.78% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
96.51% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
97.35% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
98.41% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
99.02% &amp;lt;&lt;/span&gt;&lt;span&gt;= 5 &lt;/span&gt;&lt;span&gt;milliseconds
99.23% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
99.46% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
99.96% &amp;lt;&lt;/span&gt;&lt;span&gt;= 8 &lt;/span&gt;&lt;span&gt;milliseconds
99.97% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
67567.57 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;RPOP &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.31 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

65.78% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
84.10% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
90.96% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
94.19% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
95.72% &amp;lt;&lt;/span&gt;&lt;span&gt;= 5 &lt;/span&gt;&lt;span&gt;milliseconds
97.05% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
98.33% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
98.80% &amp;lt;&lt;/span&gt;&lt;span&gt;= 8 &lt;/span&gt;&lt;span&gt;milliseconds
99.40% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
99.72% &amp;lt;&lt;/span&gt;&lt;span&gt;= 10 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 14 &lt;/span&gt;&lt;span&gt;milliseconds
31746.03 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;SADD &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.19 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

93.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
96.88% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
98.33% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
98.92% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
98.94% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
98.95% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
99.04% &amp;lt;&lt;/span&gt;&lt;span&gt;= 10 &lt;/span&gt;&lt;span&gt;milliseconds
99.48% &amp;lt;&lt;/span&gt;&lt;span&gt;= 12 &lt;/span&gt;&lt;span&gt;milliseconds
99.61% &amp;lt;&lt;/span&gt;&lt;span&gt;= 14 &lt;/span&gt;&lt;span&gt;milliseconds
99.62% &amp;lt;&lt;/span&gt;&lt;span&gt;= 15 &lt;/span&gt;&lt;span&gt;milliseconds
99.99% &amp;lt;&lt;/span&gt;&lt;span&gt;= 16 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 16 &lt;/span&gt;&lt;span&gt;milliseconds
52083.33 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;HSET &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

95.90% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
99.95% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
90909.09 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;SPOP &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

97.04% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
99.75% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
99.78% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
90909.09 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LPUSH (needed to benchmark LRANGE) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

96.48% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
99.46% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
99.95% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
87719.30 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LRANGE_100 (first 100 elements) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.33 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

32.63% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
93.24% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
99.83% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
30303.03 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LRANGE_300 (first 300 elements) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.85 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

2.65% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
23.01% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
53.33% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
77.25% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
91.47% &amp;lt;&lt;/span&gt;&lt;span&gt;= 5 &lt;/span&gt;&lt;span&gt;milliseconds
98.58% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
99.99% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
11764.71 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LRANGE_500 (first 450 elements) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 1.22 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

1.01% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
9.09% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
28.25% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
50.31% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
68.06% &amp;lt;&lt;/span&gt;&lt;span&gt;= 5 &lt;/span&gt;&lt;span&gt;milliseconds
81.18% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
90.78% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
96.96% &amp;lt;&lt;/span&gt;&lt;span&gt;= 8 &lt;/span&gt;&lt;span&gt;milliseconds
99.43% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
8196.72 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;LRANGE_600 (first 600 elements) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 1.57 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

0.61% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
4.90% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
14.77% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
28.67% &amp;lt;&lt;/span&gt;&lt;span&gt;= 4 &lt;/span&gt;&lt;span&gt;milliseconds
44.56% &amp;lt;&lt;/span&gt;&lt;span&gt;= 5 &lt;/span&gt;&lt;span&gt;milliseconds
59.45% &amp;lt;&lt;/span&gt;&lt;span&gt;= 6 &lt;/span&gt;&lt;span&gt;milliseconds
72.38% &amp;lt;&lt;/span&gt;&lt;span&gt;= 7 &lt;/span&gt;&lt;span&gt;milliseconds
82.29% &amp;lt;&lt;/span&gt;&lt;span&gt;= 8 &lt;/span&gt;&lt;span&gt;milliseconds
90.01% &amp;lt;&lt;/span&gt;&lt;span&gt;= 9 &lt;/span&gt;&lt;span&gt;milliseconds
95.42% &amp;lt;&lt;/span&gt;&lt;span&gt;= 10 &lt;/span&gt;&lt;span&gt;milliseconds
98.34% &amp;lt;&lt;/span&gt;&lt;span&gt;= 11 &lt;/span&gt;&lt;span&gt;milliseconds
99.78% &amp;lt;&lt;/span&gt;&lt;span&gt;= 12 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 12 &lt;/span&gt;&lt;span&gt;milliseconds
6357.28 requests per second

&lt;/span&gt;&lt;span&gt;====== &lt;/span&gt;&lt;span&gt;MSET (10 keys) &lt;/span&gt;&lt;span&gt;======
  &lt;/span&gt;&lt;span&gt;10000 requests completed in 0.19 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

68.40% &amp;lt;&lt;/span&gt;&lt;span&gt;= 1 &lt;/span&gt;&lt;span&gt;milliseconds
98.61% &amp;lt;&lt;/span&gt;&lt;span&gt;= 2 &lt;/span&gt;&lt;span&gt;milliseconds
100.00% &amp;lt;&lt;/span&gt;&lt;span&gt;= 3 &lt;/span&gt;&lt;span&gt;milliseconds
53763.44 requests per second


[root@localhost toutou]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;redis-cli&lt;/h2&gt;
&lt;p&gt;2.1 简介&lt;/p&gt;
&lt;p&gt;查看redis的连接及读写操作&lt;/p&gt;
&lt;p&gt;2.2 命令格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli -h xx -p yy monitor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.3 实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201905/506684-20190523180114480-2050819609.png&quot; alt=&quot;Redis监控工具&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.4 redis-cli info：&lt;/p&gt;
&lt;p&gt;Redis 监控最直接的方法就是使用系统提供的 &lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://redis.io/commands/info&quot; target=&quot;_blank&quot;&gt;info&lt;/a&gt; 命令，只需要执行下面一条命令，就能获得 Redis 系统的状态报告。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Server
redis_version:5.0.2                    # Redis 的版本
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:bf5d1747be5380f
redis_mode:standalone
os:Linux 2.6.32-220.7.1.el6.x86_64 x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.4.7                       #gcc版本
process_id:49324                        # 当前 Redis 服务器进程id
run_id:bbd7b17efcf108fdde285d8987e50392f6a38f48
tcp_port:6379
uptime_in_seconds:1739082               # 运行时间(秒)
uptime_in_days:20                       # 运行时间(天)
hz:10
lru_clock:1734729
config_file:/home/s/apps/RedisMulti_video_so/conf/zzz.conf
 
# Clients
connected_clients:1                     #连接的客户端数量
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0
 
# Memory
used_memory:821848                       #Redis分配的内存总量             
used_memory_human:802.59K
used_memory_rss:85532672                 #Redis分配的内存总量(包括内存碎片)
used_memory_peak:178987632
used_memory_peak_human:170.70M           #Redis所用内存的高峰值
used_memory_lua:33792
mem_fragmentation_ratio:104.07           #内存碎片比率
mem_allocator:tcmalloc-2.0
 
# Persistence
loading:0
rdb_changes_since_last_save:0            #上次保存数据库之后，执行命令的次数
rdb_bgsave_in_progress:0                 #后台进行中的 save 操作的数量
rdb_last_save_time:1410848505            #最后一次成功保存的时间点，以 UNIX 时间戳格式显示
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
aof_enabled:0                            #redis是否开启了aof
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok
 
# Stats
total_connections_received:5705          #运行以来连接过的客户端的总数量
total_commands_processed:204013          # 运行以来执行过的命令的总数量
instantaneous_ops_per_sec:0
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:34401                       #运行以来过期的 key 的数量
evicted_keys:0                           #运行以来删除过的key的数量
keyspace_hits:2129                       #命中key 的次数
keyspace_misses:3148                     #没命中key 的次数
pubsub_channels:0                        #当前使用中的频道数量
pubsub_patterns:0                        #当前使用中的模式数量
latest_fork_usec:4391
 
# Replication
role:master                              #当前实例的角色master还是slave
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
 
# CPU
used_cpu_sys:1551.61
used_cpu_user:1083.37
used_cpu_sys_children:2.52
used_cpu_user_children:16.79
 
# Keyspace
db0:keys=3,expires=0,avg_ttl=0             #各个数据库的 key 的数量，以及带有生存期的 key 的数量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;redis-cli info&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结果会返回 Server、Clients、Memory、Persistence、Stats、Replication、CPU、Keyspace 8个部分。从info大返回结果中提取相关信息，就可以达到有效监控的目的。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;showlog&lt;/h2&gt;
&lt;p&gt;3.1 简介&lt;/p&gt;
&lt;p&gt;redis的&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://redis.io/commands/slowlog&quot; target=&quot;_blank&quot;&gt;slowlog&lt;/a&gt;是redis用于记录记录慢查询执行时间的日志系统。由于slowlog只保存在内存中，因此slowlog的效率很高，完全不用担心会影响到redis的性能。Slowlog是Redis从2.2.12版本引入的一条命令。&lt;/p&gt;
&lt;p&gt;3.2 命令格式&lt;/p&gt;
&lt;p&gt;在redis-cli中有关于slowlog的设置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONFIG SET slowlog-log-slower-than 6000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CONFIG SET slowlog-max-len 25&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.3 实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201905/506684-20190523180142707-1784925926.png&quot; alt=&quot;Redis监控工具&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上面介绍的都是关于Redis自带的命令化性能查询工具。下面介绍介绍一些第三方的Redis可视化性能监控工具。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;RedisLive&lt;/h2&gt;
&lt;p&gt;4.1 简介&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/nkrode/RedisLive&quot; target=&quot;_blank&quot;&gt;RedisLive&lt;/a&gt;是由Python编写的开源的图形化监控工具。核心服务部分只包括一个web服务和基于Redis自带的Info命令以及monitor命令的监控服务。支持多实例监控，监控信息可以使用redis存储和sqlite持久化存储。&lt;/p&gt;
&lt;p&gt;4.2 安装&lt;/p&gt;
&lt;p&gt;4.2.1 安装依赖环境&lt;/p&gt;
&lt;p&gt;RedisLive是由Python2.X编写的，所以最好使用Python2.7来运行RedisLive，在CentOS 7中预安装了Python2.7，但没有安装Python的包管理器pip。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum install epel-release
sudo yum install python-pip
pip install --upgrade pip
pip install tornado
pip install redis
pip install python-dateutil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.2.2 安装RedisLive&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/nkrode/RedisLive.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.2.3 修改配置文件redis-live.conf&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd RedisLive/src&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//按照以下方式修改配置文件
{
    &quot;RedisServers&quot;:        
    [ 
        #在此处添加需要监控的redis实例
        {
              &quot;server&quot;: &quot;127.0.0.1&quot;,                #redis监听地址，此处为本机
              &quot;port&quot; : 6379,                        #redis端口号，可以通过lsof -i | grep redis-ser查看 redis-server端口号
              &quot;password&quot; : &quot;some-password&quot;          #redis认证密码，如果没有可以删除该行，注意json格式
        }        
    ],

    &quot;DataStoreType&quot; : &quot;redis&quot;,        #监控数据存储方案的配置，可选择redis或sqllite
    #用来存储监控数据的 Redis 实例
    &quot;RedisStatsServer&quot;:    
    {
        &quot;server&quot; : &quot;127.0.0.1&quot;,
        &quot;port&quot; : 6379,
        &quot;password&quot; : &quot;some-password&quot;
    },
    #监控数据持久化数据存储配置
    &quot;SqliteStatsStore&quot; :
    {
        &quot;path&quot;:  &quot;db/redislive.sqlite&quot;    #redis数据文件
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redis-live.conf的配置可以参考redis-live.conf.example&lt;/p&gt;
&lt;p&gt;4.3 启动&lt;/p&gt;
&lt;p&gt;启动监控服务，每60秒监控一次&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-monitor.py --duration=60&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再次开启一个终端，进入/root/RedisLive/src目录，启动web服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-live.py&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.4 效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201905/506684-20190523180443821-799936920.png&quot; alt=&quot;Redis监控工具&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;redis-faina&lt;/h2&gt;
&lt;p&gt;5.1 简介&lt;/p&gt;
&lt;p&gt;5.1.1 背景&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/facebookarchive/redis-faina&quot; target=&quot;_blank&quot;&gt;redis-faina&lt;/a&gt;是由Instagram开发并开源的一个 Redis 查询分析小工具。Instagram团队曾经使用 PGFouine 来作为其PostgreSQL的查询分析工具，他们觉得Redis也需要一个类似的工具来进行query分析工作，于是开发了 redis-faina。&lt;/p&gt;
&lt;p&gt;5.1.1 概念&lt;/p&gt;
&lt;p&gt;redis-faina 是通过Redis的 MONITOR命令来实现的，通过对在Redis上执行的query进行监控，统计出一段时间的query特性。&lt;/p&gt;
&lt;p&gt;5.2 安装&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/facebookarchive/redis-faina.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.3 命令介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost toutou]# cd redis-faina/
[root@localhost redis-faina]# ls
heroku-redistogo-faina.sh  LICENSE  README.md  redis-faina.py
[root@localhost redis-faina]# ./redis-faina.py -h
usage: redis-faina.py [-h] [--prefix-delimiter PREFIX_DELIMITER]
                      [--redis-version REDIS_VERSION]
                      [input]

positional arguments:
  input                 File to parse; will read from stdin otherwise

optional arguments:
  -h, --help            show this help message and exit
  --prefix-delimiter PREFIX_DELIMITER
                        String to split on for delimiting prefix and rest of
                        key
  --redis-version REDIS_VERSION
                        Version of the redis server being monitored
[root@localhost redis-faina]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;--prefix-delimiter&lt;/code&gt; 主要用于统计前缀的key的数据。&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;redis MONITOR&lt;/code&gt; 命令以及管道进行分析，例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli -p 6379 MONITOR | head -n | ./redis-faina.py [options]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-cli -p 6379 MONITOR &amp;gt; outfile.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-faina.py ./outfile.txt&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Overall Stats
========================================
Lines Processed     117773
Commands/Sec        11483.44

Top Prefixes
========================================
friendlist          69945
followedbycounter   25419
followingcounter    10139
recentcomments      3276
queued              7

Top Keys
========================================
friendlist:zzz:1:2     534
followingcount:zzz     227
friendlist:zxz:1:2     167
friendlist:xzz:1:2     165
friendlist:yzz:1:2     160
friendlist:gzz:1:2     160
friendlist:zdz:1:2     160
friendlist:zpz:1:2     156

Top Commands
========================================
SISMEMBER   59545
HGET        27681
HINCRBY     9413
SMEMBERS    9254
MULTI       3520
EXEC        3520
LPUSH       1620
EXPIRE      1598

Command Time (microsecs)
========================================
Median      78.25
75%         105.0
90%         187.25
99%         411.0

Heaviest Commands (microsecs)
========================================
SISMEMBER   5331651.0
HGET        2618868.0
HINCRBY     961192.5
SMEMBERS    856817.5
MULTI       311339.5
SADD        54900.75
SREM        40771.25
EXEC        28678.5

Slowest Calls
========================================
3490.75     &quot;SMEMBERS&quot; &quot;friendlist:zzz:1:2&quot;
2362.0      &quot;SMEMBERS&quot; &quot;friendlist:xzz:1:3&quot;
2061.0      &quot;SMEMBERS&quot; &quot;friendlist:zpz:1:2&quot;
1961.0      &quot;SMEMBERS&quot; &quot;friendlist:yzz:1:2&quot;
1947.5      &quot;SMEMBERS&quot; &quot;friendlist:zpz:1:2&quot;
1459.0      &quot;SISMEMBER&quot; &quot;friendlist:hzz:1:2&quot; &quot;zzz&quot;
1416.25     &quot;SMEMBERS&quot; &quot;friendlist:zhz:1:2&quot;
1389.75     &quot;SISMEMBER&quot; &quot;friendlist:zzx:1:2&quot; &quot;zzz&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_5&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于Redis的监控工具还有很多，这里就不一一列举了，下面给出其它几款优秀的Redis监控工具链接，感兴趣的可以看看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他监控工具：&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 25 May 2019 14:30:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>Redis已经成为web应用开发不可或缺的一个组成部分，在项目中的应用越来越广泛，这篇文章就来讲讲那些关于Redis监控的那点事。 Redis已经成为web应用开发不可或缺的一个组成部分，在项目中的应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toutou/p/redis_monitor.html</dc:identifier>
</item>
<item>
<title>我的十年程序员之路 - ChaosYang1987</title>
<link>http://www.cnblogs.com/chaosyang/p/10924248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaosyang/p/10924248.html</guid>
<description>&lt;p&gt;一晃做程序员也有十年了，总觉得时间过的很快，仿佛第一次写程序还是去年的事情。虽然到现在也已经换了三四家公司了，但总有种自己没有做过什么的感觉。于是便想把个人的经历写下来，留给以后的自己作为个回忆。&lt;/p&gt;

&lt;p&gt;我原本并没有想过学计算机。在高中时我搞过化学竞赛，2005年考大学时填的志愿也和计算机无关，然而机缘巧合，我的分数只能服从专业调剂分配，误打误撞进入了计算机专业，属于没有任何编程基础的”普通学生“。在大学的时候一直仰望着各种信息学竞赛大神，在被碾压中渡过了四年本科时光。大一大二的时候对于编程是觉得既新奇又畏惧，常常在语法上被困扰半天，又或是为了一个边界条件而调试半个小时，算法也一直是我的短板，只到现在还是会对算法面试有一种天生的紧张。如果说在本科的大学时光中有什么事情是我对于写程序这件事情产生热爱，那便是大三时选修的一门《基于Visual C++的MFC编程》。MFC技术已经作古多年，知道这个名词的程序员估计也都年纪不小。虽然这门课程上学到的知识在后来的工作中并没有用到，但是第一次写出在Windows上可以运行的非常简单的界面程序，那种成就感，比大一大二抄书本调试出来的递归程序要高的多，这门小技术也让我在大三大四的许多大作业上沾了些光：毕竟助教比起在命令行运行的指令，更喜欢鼠标点点就可以出来的界面。自此我便在单机图形界面程序上兴趣大增，大四的时候用C#写WinForm的程序作为软件工程课的大作业，和大部分其他用Java写出的界面”划清界限。&lt;/p&gt;
&lt;h2&gt;移动应用工程师&lt;/h2&gt;
&lt;p&gt;学生时代写程序并不能作为”程序员“的经历，我真正的成为一名程序员要从大四开始说起。大四的时候保研结束，有些空闲的时间，想着找一些事情做做。机缘巧合认识了一个大很多届的师兄，自己开了一个公司做智能手机应用。那是2009年，现在二分天下的苹果和安卓的代表手机还是iPhone 2G和HTC G1，系统的版本是iPhone OS 2和Android 1.5. 我进公司实习的第一个应用是把一个在iPhone上的工具类程序移植到Android上。当年的Google还可以访问，但是Android的代码示例也几乎只有官方的Demo，公司里也并没有没有别的会写Android程序的程序员。正是在这样一抹黑的情况下，我迈出了移动开发的第一步。当时每天去公司就是把一台G1连上笔记本电脑，改两行代码后花上半分钟运行一下，看看效果，不行再改两行再试。效率非常的低下。功夫不负有心人，做了三个月之后程序终于上线了。虽然反响也并不好，没有达到iPhone上的营收效果，没多久就从Market上撤下来了；但不管怎么说，也是我第一次写的产品代码，我在程序员的道路上迈出了第一步。&lt;/p&gt;
&lt;p&gt;09年毕业后上了研究生，研究的项目也正好是基于Android的，期间做过Android系统程序的修改，包括修改Java代码和底层的C代码，现在看来都很简单粗糙，完全不值一提。但是最宝贵的可能就是读了大部分Android的框架代码，虽然现在已经面目全非，但是在以后的工作中看再大的代码库也不会觉得无力。&lt;/p&gt;
&lt;p&gt;研究生期间”不务正业“又辗转做了几个公司的intern，当时为了能兼顾实验室和intern，特意都选择了可以remote的实习。其中包括两家在美国的公司。在这两家公司最大的收获便是锻炼了英语读写说的能力，从一开始面试的时候连名词都听不明白，到后来可以和老外侃侃而谈，在这里迈出的第一步很关键。另一个收获就是除了Android之外，又接触了iOS的编程（当时还叫iPhone OS），学习了一门叫Objective C的语言，以至于很长一段时间在Java和Objective C之前切换的时候会不自觉的打出括号和点的组合。&lt;/p&gt;
&lt;p&gt;整个研究生期间我的技能点几乎都点在了移动开发上，关注各种安卓苹果操作系统的新功能，也会借着职务的便利去玩一些新的机型硬件。加之那几年移动应用的发展迅速，市场是对于移动应用开发者还有很大的需求，于是自己对自己的定位为一名移动应用开发者，并将至作为自己毕业后找工作的方向。&lt;/p&gt;
&lt;p&gt;2012年7月研究生毕业，在年初的时候我开始了找工作，由于实验室的背景关系好多师兄毕业后都选择去了国外大公司工作，于是我也在期待着可以步师兄们的后尘。无奈自己的硬实力不够，没有能够通过国外大厂的面试。在国内的找工作也并没有非常好的进行，大公司并没有很多移动开发者的职位，待遇比较不错的职位投递了简历却并没有得到回应。在机缘巧合之下，有几家日本的IT公司来到中国招聘毕业生，我参加了其中一家公司的招聘会并顺利的通过了面试，来到了日本东京开始了自己的程序员生涯。&lt;/p&gt;
&lt;p&gt;我的正式职业生涯的第一家公司（暂且称之为D社），在当时是一家移动手机游戏为主体运营业务的公司，在当年凭借着功能机上的游戏地位站在日本手游界的Top2位置。D社虽然其收购了美国的一家公司在旧金山也有分部，并且也连续几年在海外招聘了一些外国的毕业生程序员，但是本质上还是一个比较偏传统的日式IT公司。&lt;/p&gt;
&lt;p&gt;D社对于新加入公司的毕业生程序员的培训不得不说还是做的比较到位，首先对于海外招聘的毕业生，提供了日语的全日制培训以及之后正式入岗后的日语追加培训。其次，在正式分配部门之前，有为期两个月的技能培训。技能培训的内容是将公司内的Perl框架简化后让大家进行一个类似于填补作业的项目，并全程有老师指导，每阶段需要提交代码并且答辩。答辩不通过的话需要再等两天后才可以预约下一次答辩。现在看来过于严苛和形式主义，但是在以后的工作中，越来越体会到新人培训的重要性，因为在之后的公司从没有过这样细致到“手把手”式的培训。&lt;/p&gt;
&lt;p&gt; 我自己觉得受益比较深的几点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于每一句写下的代码，老师会问为什么这么写，有没有别的写法，各种写法有什么不同？会细扣到代码的顺序，变量名的命名，注释的语法等等。实际上这是非常细致的代码审查（Code Review）流程，大部分新人程序员着眼于如何快速的实现功能，有时会不假思索的借鉴来代码，而我之后供职的公司并没有这样的培训，大多数的代码审查也只是停留在错误检查和性能上。个人觉得在一开始写程序时养成良好的习惯非常重要，尤其是对于刚脱离校园环境的程序员。&lt;/li&gt;
&lt;li&gt;老师也教会了很多工具的使用，比如vim，git，bash等基本操作，比如用bash完成对Apache log的简单统计分析等等。这个其实是程序员的提高生产效率的方法，在之后的公司中遇到太多的新人进入公司好几个月还在git提交上遇到各种困难。或者不得不耗费体力做一些简单脚本可以解决的问题。比起教会的知识，更重要的收获是万事都可以脚本化的信念，不会因为自己的本职工作不包括写脚本而对于脚本就打退堂鼓。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在D社的培训结束后加入了一个临时的岗位，做了三个月的Perl的网站开发，之后又调去了别的部门操刀旧业，维护公司的门户App，说实话门户App的技术含量真心不高，就是WebView封装出来的。期间做了唯一一件有些技术含量的事情是把App内的聊天功能加上了推送功能。在客户端启动时，在服务器端注册客户端的推送口令，在客户端的网页里通过api来通知服务器把消息放进队列，服务器端有定时任务去消化队列中的消息。 这其实是一个非常普通的小系统，也比较成熟，对于个人来说主要的作用就是独立设计并且完成了一个完整的系统，并且在生产环境中实际的运行起来。&lt;/p&gt;
&lt;p&gt;在D社的日子没有持续很长时间，最后在公司的半年被调任到游戏部门，做了一款基于Unity2D的手游，虽只有短短的四个月经历，但是也可成为是个人职业生涯中出品的第一款游戏，它是一款抄袭了FlappyBird的山寨游戏，在制作的过程中重温了一回用C#，顺便熟悉了一下Unity2D开发环境。&lt;/p&gt;
&lt;p&gt;反思一下自己在D社的1年半，在职场的第一份工作并没有能够很好的积累。而只是停留在完成布置的任务阶段，并没有去主动的学习。&lt;/p&gt;

&lt;p&gt;在D社待了一年半之后跳槽到了I社，I社是一家在美国以工作搜索引擎为主体业务的公司，被日本R社收购后在日本开张了办公室。加入I社的时候办公室只有二十名不到的程序员，等到离职的时候已经超过两百人，可以说见证了I社在东京办公室的快速发展时期。&lt;/p&gt;
&lt;p&gt;在I社的前三年我一直在SEM组工作，SEM（Search Engine Marketing）组的主要任务是自动的将公司投放在搜索引擎上的广告优化。这是一个纯后端的组，以前的工作经验在这里并没可以发挥的地方。我的工作内容，从一开始去开发维护一个基于Python的内部工具网站（后来知道老板看我的简历是做App的，误以为我是前段能手），三个月之后Python工具网站的开发告一段落，开始接触竞价算法（Java后台程序）。当时正适逢移动流量开始渐渐追赶并超过个人电脑的流量，针对移动端广告进行竞价调整（Bidding Adjustment）是一个重要的功能。正是在进行这一工作的时候，我有机会去主导从MySQL切换到RabbitMQ的解决方案，解耦合算法端和API端的紧密联系。并且通过和系统工程师的配合，解决了首次部署RabbitMQ中遇到的问题，并设置了警报规则去监视系统的运行健康状况。在切换的过程中，为了保证无故障的切换，先后采用了试运行（Dry Run）的方式模拟从MySQL切换到RabbitMQ的场景，接着运用了A/B test的工具分出少量流量测试RabbitMQ流程的稳定性，最后达到100%切换后进行代码的清理。在这个项目中我学到了很多宝贵的经验，对于以后进行的一些重构式工程有很重要的方法论上的参照意义。&lt;/p&gt;
&lt;p&gt;在SEM组的工作使我从一个入门的初级程序员，成长到可以去带新人的mentor，除了做每个季度组里的季度目标意外，我也参与到全公司的推进的项目中。比如JDK从1.6升级到1.7，从旧的部署系统迁移到新的部署系统，启用CI/CD模型等等，在做这些项目的同时，自己接触到了在平常的开发过程中不会遇到的问题，比如如何解决库中的class冲突，CI/CD模型适用/不适用的情况等等。&lt;/p&gt;
&lt;p&gt;于此同时，自己也不满足于只是去做分配下来的任务，开始观察并思索作为工程师的痛点。比如，每次上游的一些库会莫名其妙的改变一些公有接口，导致下游的项目构建收到影响，结果给下游项目的开发人员带来了额外的负担。另一方面，上游库的开发者要想改变删除过期的接口让下游项目迁移到新的接口，又苦于在公司内部喊嗓子得不到有效的回应，下游项目的工程师没有动力去及时的跟进改变，导致过期接口的删除迟迟不能进行。在这种情况下，如何可以减少不必要的公有接口修改，同时又能提高必要公共接口修改的曝光性？在研究了公司的构建系统之后，我决定在构建系统上，利用一些开源工具和Java编译插件的技术，实现了两个小功能：1. 在发布库的新版本是总是和最后一个旧版本比较API的修改，如果有任何公有接口的修改或缺失则给出警报。2. 提供编译期的注解（Annotation），让程序员可以对公有接口（类）设置过期时间，在过期时间到来之时下游的项目如果有引用则会出发构建失败。这两个功能我是一前一后做出来并在公司内部发布，但是风评却是前一个平平偏向负面，后一个得到不少的点赞和使用，但也引起了不少麻烦。然而由于当时急功近利的心里，并没有很好的去follow。&lt;/p&gt;
&lt;p&gt;I社是我从一名初级程序员向着高级程序员成长，随着在公司的时间增长，手头的工作也很快不能够满足自己的兴趣，在SEM组待了将近三年之后我的经理建议我换组，在经历了一番挣扎后我选择了去一个有前段以及顺带一些移动应用的组，在这里我又重操了一段做移动端应用的经历，并且又学习了一些前段方面的知识。&lt;/p&gt;
&lt;p&gt;在I社待了3年半的时间，当公司越来越大之后，时常会感到个人的贡献越来越有限，感觉个人的成长也在逐步的缓慢。在对比了其他同事的晋升道路后，仿佛看到了自己在N年后的场景。但是之前觉得在日本没有比I社更适合自己的公司了，于是也一直没有去寻求新的机会。去年随着几位前同事的离职，自己也开始认真的考虑换工作的事情。&lt;/p&gt;
&lt;p&gt;恰逢也同样是美国总部的H社在东京开始招全栈程序员，虽然同样是美国公司，但是H社还尚未上市，团队也较小，所以抱着去施展一番拳脚的想法去面试了H社全栈工程师的职位，并于去年7月加入了H社公司。&lt;/p&gt;

&lt;p&gt;加入H社后首先感到的很大的Gap，便是在公司的技术上。在I社，我所碰到的领域都已经有了成熟的解决方案。但是在H社，跟I社所对应的一系列基础设施建设却远远称不上完善。这让我进入公司之后很是怀疑了自己的选择。在进入公司的前两个月，我经常会发信给全公司的程序员，去探讨为什么我们要这么做而不是那么做。并且也提交了很多改进方案，希望可以改成我在I社所接触到的方案。当然这些都并不是很顺利，在H社的老人们给了非常强力的反击。在拿不出充分证据论证的情况下，我只好选择了暂时蛰居，先处理好眼下自己手头的工作。&lt;/p&gt;
&lt;p&gt;加入H社后的首个项目是将一个年头已久的PHP前段+后端网页改成PHP + Apache Thrift + GraphQL + NodeJS +React的新框架，作为全栈（Full Stack）工程师，我需要从PHP到React头到尾都做一遍。首先便是读原来的PHP代码，并抽象成Thrift服务。其次便是在NodeJS服务器端将Thrift服务映射成GraphQL的Schema，并实现GraphQL的Resolver逻辑，然后便是用一个Node应用代替PHP的前段，用React的框架来渲染出一模一样的网页。在短短的几个月内，从一窍不通的React小白，到完成了整个页面的迁移，自己对于React框架的应用和一些实践有了自己的理解。GraphQL也是一个对我新鲜的概念，在GraphQL的实践中，我感到这个框架其实也很适用于我在I社工作的第二个组，甚至可以在脑海中把原来的API用GraphQL一一对应起来。这种相互印证的感觉让我再次意识到做出换工作的决定并没有错误，否则我的思路会很长时间局限在I社的框架中。&lt;/p&gt;
&lt;p&gt;在加入H社的三个月之后我相通了这样的道理：一个什么都做的很完美的公司，或许更不是一个什么都不完美的公司，因为前者让人失去了去改进的机会，而后者却给予了很多这样的机会。于是，我便在工作中，挤出一部分精力去做一些力所能及的改变。首先便从使用的GraphQL入手，通过调试发现存在着过度查询（Over fetching）的情况，某些查询代价较大的字段，明明没有出现在查询语句中，但是后台却仍然将其返回。于是我通过标注（Annotation），在Resolver层面讲字段和Thrift服务的参数进行映射，使得GraphQL被翻译程序Thrift请求时可以自动的附上请求字段的列表，在服务器端根据字段的列表可以选择性的返回字段，达到“减负”的目的。&lt;/p&gt;
&lt;p&gt;春节期间利用闲暇时间，把公司的A/B测试系统进行了优化，这个优化也是我刚进入H社时最想改变的一点，然而遭到很多质疑的点，于是我在进公司提出的propse基础上做了退让，专注于解决最基本的痛点，加入了基于不同域名实行不同的分配（Bucketing）。在于现行系统并存的情况下一步一步的将功能发布了出来，在公司内获得了好评。&lt;/p&gt;

&lt;p&gt;从2009年第一次实习经历算起，一眨眼我已经做了十年的程序员。我也过了而立之年，眼看着行业里自己已经算年龄偏大的从业人员。&lt;/p&gt;
&lt;p&gt;纵观我的程序员经历，从移动应用开发，到后端、前段，以及零星的DevOps和Release Engineering的经验，我觉的我自己是朝着“全才”的方向发展。然而全才意味着什么都懂一些，但是又说不上是哪个领域的专家。&lt;/p&gt;
&lt;p&gt;近两年来在各种媒体上看到大龄程序员的囧境，时常会思考自己的以后的方向。我时常仍会关注国内程序员招岗的要求，发现大多数岗位还是需要领域专家的人才，而不是全才。我也时常会质疑自己，是否太过贪多嚼不烂。然而我最近似乎想通了一点，领域专家vs全才，两种人在这个行业都是被需要的，只是一般的岗位确实会需要你只会干某一样便可以。这并不意味着会的越多就没有施展的地方，在初期的创业公司，以及新成立的部门，这样的人才还是很有必要的。既然自己的兴趣在于了解和挑战不同的领域，不如索性就将其发展到极致。&lt;/p&gt;
&lt;p&gt;下一个十年，我想我任会热爱程序员这个工作，我在现在的岗位上，便朝着填补我技能树上的空白努力，争取在下一份工作，可以将自己全部的所学都能够用上。&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 14:27:00 +0000</pubDate>
<dc:creator>ChaosYang1987</dc:creator>
<og:description>一晃做程序员也有十年了，总觉得时间过的很快，仿佛第一次写程序还是去年的事情。虽然到现在也已经换了三四家公司了，但总有种自己没有做过什么的感觉。于是便想把个人的经历写下来，留给以后的自己作为个回忆。 大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaosyang/p/10924248.html</dc:identifier>
</item>
</channel>
</rss>