<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>存储过程一个简单编写样式与为什么创建存储过程时不执行操作的原因 - 王科慧</title>
<link>http://www.cnblogs.com/Jack-S-Wang/p/10774636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-S-Wang/p/10774636.html</guid>
<description>&lt;p&gt;今天我接收到一个任务就是创建一个数据脚本再原来8万条数据的基础上插入剩下的数据，总共数据为2千万条。之前是创建一个文本文件，进行上传导入数据的，但这个导入数据的时是要有6个月的时间跨度，那么上传一天一个文本，那就要创建180个文本文件，那是得不偿失的。因此想到了数据脚本写存储过程。&lt;/p&gt;
&lt;p&gt;这是我简单插入数据，并根据一定的数量进行时间累加的存储过程脚本：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;USE [eRAS]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;/****** Object:  StoredProcedure [dbo].[AddSrcCCAUTH]    Script Date: 2019/04/26 14:41:17 ******/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SET ANSI_NULLS ON&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SET QUOTED_IDENTIFIER ON&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-- =============================================&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- Author:        &amp;lt;Author,,Name&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- Create date: &amp;lt;Create Date,,&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- Description:    &amp;lt;Description,,&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-- =============================================&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ALTER PROCEDURE [dbo].[AddSrcCCAUTH]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    -- Add the parameters for the stored procedure here&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;AS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    -- SET NOCOUNT ON added to prevent extra result sets from&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    -- interfering with SELECT statements.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    SET NOCOUNT ON;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    declare @i int,@Card varchar(20),@count int,@datenow DateTime,@oldCount int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    --还需添加的数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @i=80001;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    --获取当前的时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @datenow=GETDATE();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @oldCount=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    while(@i&amp;lt;=20000000)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    begin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    --设置卡号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @Card='42019'+RIGHT('00000000000'+CAST(@i as varchar),11);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    --计算需要添加时间的天数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @count=(@i-80000)/110667;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    if(@count!=@oldCount)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    begin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @oldCount=@count;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    select @datenow=DATEADD(DAY,1,@datenow);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    -- Insert statements for procedure here&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    INSERT INTO dbo.SrcCCAUTH ([ID]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_CARD_NBR]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_ORIG_CURR_CODE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_ORIG_AMT]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_LOCAL_MT]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_MCC]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_CHANNEL_IND]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_TXN_AUTH_DATE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_TXN_AUTH_TIME]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_TXN_COUNTRY]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_REFERENCE_NBR]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_UNIQUE_DATE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_UNIQUE_TIME]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_UNIQUE_AUDT_TRACE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_UNIQUE_ACQ_ID]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_UNIQUE_FWD_ID]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_AVAILBLE_AMOUNT]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_ACCOUNT_NBR]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_PROCESS_CODE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_EAS_TC]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_INPUT_SOURCE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_POS_ENTRY_MODE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_MERCH_NAME_LOC]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_POS_COND_CODE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_MC_CARD_PRESENT]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_AUTH_CODE]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[MEROUT_LONG_DESC]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[FILLER]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      ,[REPORT_DATE])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      VALUES (&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      NEWID(),@Card,'840',10.00,61.68,'05999','5','2019-01-09 00:00:00.000',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      '084352','840','000000000009','20190109','084352','0000009','00000009685',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      '00000000000',54928.32,'0005591390000622638','000000','053','M','8120',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      'Ecom01                 St. Louis     MO','','5','794416','','',@datenow&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      );&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      select @i=@i+1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      end&lt;/span&gt;&lt;br/&gt;&lt;span&gt;END&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这里面我要提醒一下这个几个地方，参数设置可以在&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548419/201904/1548419-20190426151309682-1266803219.png&quot; alt=&quot;&quot;/&gt;这个截图的位置上添加。设置值与declare（申明）是一样的，@id int这样就申明了一个为int类型的@id值。然后设置则用select关键字，在sql语句中用set关键字，但存储过程中我使用set是没有用的。 SET NOCOUNT ON;这句话则是为了取消执行多条执行语句返回的结果集，否则每次都返回一句“执行一条数据成功”是很浪费时间的。while或是if语句都是没有大括号来包含内容，因此这些语句都一样用begin和end来包含。&lt;/p&gt;
&lt;p&gt;一个字符串想用一些字符来代替长度不够的部分，则可以使用RIGHT('00000000000'+CAST(@i as varchar),11);语句，这里我是以总长度为11个字符进行设置的，cast则将int值转化为varchar值。&lt;/p&gt;
&lt;p&gt;如果相对一个时间进行添加一天则可用这句话DATEADD(DAY,1,@datenow);第一个参数其实是指要添加的位置，day表示是要在时间的天数上加数值。最后一个参数则是目标值。&lt;/p&gt;
&lt;p&gt;好了，其他的模式就没有什么可以多说的，这个存储过程写得不复杂，大家一看就明了了。现在就来讲讲要执行这个存储过程需要执行哪句话，为什么创建或是更新执行的时候是不执行存储过程的？&lt;/p&gt;
&lt;p&gt;要想执行该存储过程我们可以执行exec AddSrcCCAUTH（存储数据表），执行这句话存储过程文件中的语句才被执行。如果停止不了，然后你不知道怎么停止则可以使用kill 56（这个是spid值）&lt;/p&gt;
&lt;p&gt;如果你找不到该值则可以查询&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SELECT t.[text],er.*&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;  FROM sys.dm_exec_requests AS er CROSS APPLY sys.dm_exec_sql_text(er.sql_handle) AS t&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;WHERE er.session_id!=@@SPID&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;执行该语句则可以查询到spid值。&lt;/p&gt;
&lt;p&gt;其实&lt;img src=&quot;https://img2018.cnblogs.com/blog/1548419/201904/1548419-20190426152945006-285982697.png&quot; alt=&quot;&quot;/&gt;就是截图中那个53的值，你执行的语句在哪里执行就关闭哪个查询sql。&lt;/p&gt;
&lt;p&gt;好了最后说一下为什么创建了是不执行的，&lt;span&gt;因为存储过程一般针对于一些比较复杂的，重复性较多的sql语句编写完成特定功能的SQL 语句集，如果该数据有些是比较重要的，需要客户有权限的人才能去执行，如果你一创建就执行了，那么这些数据又该由谁来负责呢？客户可能会认为有人操作而报警，而你则进入了监狱。所以在本地我们创建了会去执行查看是否正确，可将它创建到正式库里去的时候则不能执行的，也就在创建之时是不执行的，与创建视图执行是不一样的概念&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;今天的日记随笔就写到这吧……&lt;/p&gt;

</description>
<pubDate>Fri, 26 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>王科慧</dc:creator>
<og:description>今天我接收到一个任务就是创建一个数据脚本再原来8万条数据的基础上插入剩下的数据，总共数据为2千万条。之前是创建一个文本文件，进行上传导入数据的，但这个导入数据的时是要有6个月的时间跨度，那么上传一天一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack-S-Wang/p/10774636.html</dc:identifier>
</item>
<item>
<title>Supervisor守护DotNet Core控制台程序 - Cfan1236</title>
<link>http://www.cnblogs.com/rui1236/p/10774551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rui1236/p/10774551.html</guid>
<description>&lt;p&gt;Supervisor 相信对Linux系统很熟的都知道这个软件，基于Python写的一个守护进程软件。具体的介绍和使用我就不再赘述了。&lt;/p&gt;
&lt;p&gt;使用asp.net core 部署在Linux常用的方法 我们可以用Docker、Jexus 、Supervisor等。具体应该使用哪个，因不同的软件都有各自的优缺点，根据自身应用的场景选择一个即可。&lt;/p&gt;
&lt;p&gt;在使用Supervisor  部署asp.net core的时候通常我们只要在&lt;strong&gt;supervisord.d &lt;/strong&gt;目录中添加对应的配置文件如xxx.ini或xxx.conf。（具体目录位置和配置文件扩展名请根据&lt;strong&gt;supervisord.conf&lt;/strong&gt;来进行配置约束。）&lt;/p&gt;
&lt;p&gt;然后在配置文件command 后面写上&lt;strong&gt;dotnet /data/web/webapi.dll &lt;/strong&gt;,然后通过 &lt;strong&gt;supervisorctl start webapi &lt;/strong&gt;即可启动我们的web程序在后台运行。&lt;/p&gt;
&lt;p&gt;当我们在DotNet Core中写一个后台程序，比如定时任务程序、MQ的消费者程序等。这样就没必要写成Web程序；在windows里我们可以写一个windows服务程序，直接在后台运行。但是DotNet Core我们只能写控制台程序了。&lt;/p&gt;
&lt;p&gt;普通的控制台程序我们写好后放到Linux上直接运行没问题，但是如果使用supervisor 进行部署（部署方式同asp.net core一样），会发现 怎么也启动不了。&lt;/p&gt;
&lt;p&gt;比如这样一个程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426110312749-1264931692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux上可以运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426110612092-1862886917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Supervisord部署添加一个配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426110907835-225026285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用supervisor运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426111129506-1109418527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现错误不能成功运行，如果网上搜索 &quot;supervisor Exited too quickly (process log may have details)”或按照supervisor日志里的错误信息搜索，多数会告诉你目录是否配置错误、目录是否有对应权限、dotnet 命令是否能正常运行等。&lt;/p&gt;
&lt;p&gt;我们看看运行日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426111634120-1729762872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样看是有运行，出现【控制台程序已经启动】多次说明我们的程序被Supervisor 多次重启了，在配置文件中startretries就是启动失败后重启次数。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;strong&gt;tail -f /data/logs/apptest.log &lt;/strong&gt;查看日志有没有文件有没有继续持续输出我们打印的时间&lt;strong&gt;，&lt;/strong&gt;或者通过&lt;strong&gt;ps -efl |grep dotnet &lt;/strong&gt;查看当前程序运行的进程是否存在，后者是最准确的。&lt;/p&gt;
&lt;p&gt;不难发现我们本次是有运行 因为有启动日志，但是很快进程就会自动退出了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为控制台程序添加宿主&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在asp.net core中我们都知道有个&lt;strong&gt;WebHost&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;asp.net core 中的WebHost&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426134842974-555500992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制台中我们需要添加&lt;strong&gt;HostBuilder&lt;/strong&gt;来作为宿主。&lt;/p&gt;
&lt;p&gt;通过Nuget 添加&lt;strong&gt;Microsoft.Extensions.Hosting&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改控制台的Main函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;控制台程序已经启动:{DateTime.Now.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;yyyy-MM-dd HH:mm:ss&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hostBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HostBuilder()
   .ConfigureServices(serviceCollection &lt;/span&gt;=&amp;gt;&lt;span&gt;
   {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册我们的服务接口&lt;/span&gt;
       serviceCollection.AddSingleton&amp;lt;IHostedService, MyService&amp;gt;&lt;span&gt;();
   });
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; hostBuilder.RunConsoleAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 一般情况Main函数改为异步后变异会报错，会提示找不到合适的静态入口；可以设置语言版本为C#7.1及以上来解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426152102475-1151586709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们需要添加一个服务文类用来继承我们的宿主&lt;strong&gt;IHostedService&lt;/strong&gt;接口，并重写服务启动和结束方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyService : IHostedService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务启动
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task StartAsync(CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;控制台程序已经开启&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟定时需要后台处理的任务&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前时间是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    }
                }).Start();

            });
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务停止
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task StopAsync(CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;控制台程序已经停止&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });

       }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 发布然后使用supervisorctl start apptest 开启看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201904/554879-20190426152512342-1634927083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Apr 2019 07:32:00 +0000</pubDate>
<dc:creator>Cfan1236</dc:creator>
<og:description>Supervisor 相信对Linux系统很熟的都知道这个软件，基于Python写的一个守护进程软件。具体的介绍和使用我就不再赘述了。 使用asp.net core 部署在Linu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rui1236/p/10774551.html</dc:identifier>
</item>
<item>
<title>一文带你超详细了解Cookie - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10774541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10774541.html</guid>
<description>&lt;h2&gt;cookie 简介&lt;/h2&gt;
&lt;h3 class=&quot;15&quot;&gt;&lt;span&gt;什么是&lt;/span&gt; &lt;strong&gt;cookie&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;cookie，有时我们也用其复数形式 cookies，是服务端保存在浏览器端的数据片段。以 key/value&lt;span&gt;的形式进行保存。每次请求的时候，请求头会自动包含本网站此目录下的&lt;/span&gt; cookie 数据。网站经常使用这个技术来识别用户是否登陆等功能。&lt;/p&gt;
&lt;p&gt;简单的说，cookie 就是服务端留给计算机用户浏览器端的小文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP   是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分中&lt;span&gt;两次请求是否由一个客户端发出。这样的设计严重阻碍的&lt;/span&gt; Web 程序的设计。如：在我&lt;span&gt;们进行网购时，买了一条裤子，又买了一个手机。由于&lt;/span&gt; http 协议是无状态的，如果不&lt;span&gt;通过其他手段，服务器是不能知道用户到底买了什么。而&lt;/span&gt; Cookie 就是解决方案之一。&lt;/li&gt;
&lt;li&gt;Cookie &lt;span&gt;实际上就是服务器保存在浏览器上的一段信息。浏览器有了&lt;/span&gt; Cookie 之后，每次&lt;span&gt;向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据&lt;/span&gt;   该信息处理请求。&lt;/li&gt;
&lt;li&gt;例如：我们上文说的网上商城，当用户向购物车中添加一个商品时，服务器会将这个条&lt;span&gt;信息封装成一个&lt;/span&gt; Cookie &lt;span&gt;发送给浏览器，浏览器收到&lt;/span&gt; Cookie，会将它保存在内存中(注意这里的内存是本机内存，而不是服务器内存)，那之后每次向服务器发送请求，浏览器&lt;span&gt;都会携带该&lt;/span&gt; Cookie&lt;span&gt;，而服务器就可以通过读取&lt;/span&gt; Cookie 来判断用户到底买了哪些商品。&lt;span&gt;当用户进行结账操作时，服务器就可以根据&lt;/span&gt; Cookie 的信息来做结算。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Cookie &lt;span&gt;的用途：&lt;/span&gt; &lt;span&gt;网上商城的购物车&lt;/span&gt; &lt;span&gt;保持用户登录状态&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Cookie 的缺点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　Cookie 做为请求或响应报文发送，无形中增加了网络流量。&lt;/p&gt;
&lt;p&gt;　　　　　Cookie 是明文传送的安全性差。&lt;/p&gt;
&lt;p&gt;　　　　　Cookie &lt;span&gt;中保存数据是不稳定的，用户可以随时清理&lt;/span&gt; cookie,&lt;span&gt;各个浏览器对&lt;/span&gt; Cookie 有限制，使用上有局限&lt;/p&gt;
&lt;h3&gt;庐山真面目&lt;/h3&gt;
&lt;p&gt;chrome &lt;span&gt;的&lt;/span&gt; cookie 位置：&lt;/p&gt;
&lt;p&gt;C:\Users\lfy\AppData\Local\Google\Chrome\User Data\Default\Cookies&lt;/p&gt;
&lt;p&gt;ie &lt;span&gt;中&lt;/span&gt; cookie &lt;span&gt;位&lt;/span&gt; &lt;span&gt;置&lt;/span&gt; &lt;span&gt;：&lt;/span&gt; C:\Users\lfy\AppData\Local\Microsoft\Windows\InetCache 点击设置-&amp;gt;查看对象即可&lt;/p&gt;
&lt;p&gt;chrome &lt;span&gt;中查看&lt;/span&gt; cookie&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190426151300997-1501762655.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cookie 如上图所示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以看出&lt;/span&gt; cookie 是键值对的形式，有过期时间（Max-Age，session 表示在这个会话期内有效）。&lt;/p&gt;
&lt;h3 class=&quot;15&quot;&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;原理&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;1）总的来看 Cookie 像是服务器发给浏览器的一张“会员卡”，浏览器每次向服务器发送请求时都会带着这张“会员卡”，当服务器看到这张“会员卡”时就可以识别浏览器的身份。实际上这个所谓的“会员卡”就是服务器发送的一个响应头：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190426151455827-928438614.png&quot; alt=&quot;&quot; width=&quot;851&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）如图 Set-Cookie 这个响应头就是服务器在向服务器发“会员卡”，这个响应头的名字是 Set-Cookie ， 后 边 JSESSIONID=95A92EC1D7CCB4ADFC24584CB316382E 和 Path=/Test_cookie，是两组键值对的结构就是服务器为这个“会员卡”设置的信息。浏览器收到该信息后就会将它保存到内存或硬盘中。&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）当浏览器再次向服务器发送请求时就会携带这个&lt;/span&gt; Cookie 信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190426151537849-1237729577.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190426151556496-1144075767.png&quot; alt=&quot;&quot; width=&quot;903&quot; height=&quot;536&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Cookie&lt;/strong&gt; 的使用&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;创建对象&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;cookie &lt;span&gt;是由服务端创建的，由浏览器端保存的。所以创建对象我们应该在服务端创建&lt;/span&gt; cookie,cookie 的创建方法：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）创建一个&lt;/span&gt; CookieServlet&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt; Servlet &lt;span&gt;的&lt;/span&gt; doPost()方法中编写如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Cookie对象&lt;/span&gt;
Cookie cookie = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;username&quot;, &quot;zhangsan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Cookie对象放入response对象中response.addCookie(cookie);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;）在浏览器中访问该&lt;/span&gt; Servlet&lt;span&gt;，会发现响应头中出现如下内容：&lt;/span&gt; Set-Cookie: username=zhangsan&lt;/p&gt;
&lt;p&gt;如此就成功的向浏览器设置了一个 Cookie，当我们在刷新页面时会发现浏览器的请求头中出现如下代码：&lt;/p&gt;
&lt;p&gt;Cookie: username=zhangsan&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）同样我们还可以同时设置多个&lt;/span&gt; Cookie：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Cookie对象&lt;/span&gt;
Cookie cookie1 = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;username&quot;, &quot;zhangsan&quot;&lt;span&gt;); 
Cookie cookie2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;password&quot;, &quot;123456&quot;&lt;span&gt;); 
Cookie cookie3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;age&quot;, &quot;20&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Cookie对象放入response对象中&lt;/span&gt;
&lt;span&gt;response.addCookie(cookie1);
response.addCookie(cookie2);
response.addCookie(cookie3);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;浏览器会按以下形式发送&lt;/span&gt; Cookie：&lt;/p&gt;
&lt;p&gt;Cookie: username=zhangsan; password=123456; age=20&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）设置&lt;/span&gt; Cookie &lt;span&gt;就是两个步骤：&lt;/span&gt; &lt;span&gt;创建&lt;/span&gt; Cookie 对象&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将&lt;/span&gt; Cookie &lt;span&gt;对象加入到&lt;/span&gt; response 中&lt;/p&gt;
&lt;h3 class=&quot;15&quot;&gt;&lt;span&gt;设置&lt;/span&gt; &lt;strong&gt;cookie&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 class=&quot;15&quot;&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;的有效时间&lt;/h4&gt;
&lt;p align=&quot;justify&quot;&gt;1&lt;span&gt;）经过上边的介绍我们已经知道&lt;/span&gt; Cookie  &lt;span&gt;是存储在浏览器中的，但是可想而知一般情况下浏览器不可能永远保存一个&lt;/span&gt; Cookie&lt;span&gt;，一来是占用硬盘空间，再来一个&lt;/span&gt; Cookie 可能只在某一时刻有用没必要长久保存。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2） &lt;span&gt;所以我们还需要为&lt;/span&gt; Cookie 设置一个有效时间。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3&lt;span&gt;）通过&lt;/span&gt; Cookie &lt;span&gt;对象的&lt;/span&gt; setMaxAge()&lt;span&gt;可以设置&lt;/span&gt; Cookie 的有效时间。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;其中&lt;/span&gt; setMaxAge()&lt;span&gt;接收一个&lt;/span&gt; int 型的参数，来设置有效时间。参数主要有一下四种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置为&lt;/span&gt; 0，setMaxAge(0)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　Cookie &lt;span&gt;立即失效，下次浏览器发送请求将不会在携带该&lt;/span&gt; Cookie&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置大于&lt;/span&gt; 0，setMaxAge(60)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　表示有效的秒数&lt;/span&gt; 60 &lt;span&gt;就代表&lt;/span&gt; 60 &lt;span&gt;秒即&lt;/span&gt; 1 &lt;span&gt;分钟，也就是&lt;/span&gt; Cookie &lt;span&gt;在&lt;/span&gt; 1 分钟后失效。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置小于&lt;/span&gt; 0，setMaxAge(-1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　设置为负数表示当前会话有效。也就是关闭浏览器后&lt;/span&gt; Cookie 失效&lt;/p&gt;
&lt;p&gt;　　　　如果不设置失效时间，则默认当前会话有效。&lt;/p&gt;
&lt;h4 class=&quot;15&quot; align=&quot;justify&quot;&gt;&lt;strong&gt;cookie&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;的路径&lt;/h4&gt;
&lt;div class=&quot;Section0&quot; readability=&quot;17&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;justify&quot;&gt;1） Cookie &lt;span&gt;的路径指告诉浏览器访问那些地址时该携带该&lt;/span&gt; Cookie，我们知道浏览器会保&lt;span&gt;存很多不同网站的&lt;/span&gt; Cookie&lt;span&gt;，比如百度的&lt;/span&gt; Cookie&lt;span&gt;，新浪的&lt;/span&gt; Cookie&lt;span&gt;，腾讯的&lt;/span&gt; Cookie 等等。那我们不可能访问百度的时候携带新浪的 Cookie，也不可能访问每个网站时都带上所有&lt;span&gt;的&lt;/span&gt; Cookie &lt;span&gt;这是不现实的，所以往往我们还需要为&lt;/span&gt; Cookie &lt;span&gt;设置一个&lt;/span&gt; Path 属性，来告诉浏&lt;span&gt;览器何时携带该&lt;/span&gt; Cookie。&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）我们同过&lt;/span&gt; Cookie &lt;span&gt;的&lt;/span&gt; setPath()来设置路径，这个路径是由浏览器来解析的所以/代表服务器的根目录。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如：&lt;span&gt;设置为&lt;/span&gt; /项目名/&lt;span&gt;路径&lt;/span&gt;  cookie.setPath(“/项目名/路径”),这样设置只有访问“/项目名/路径”&lt;span&gt;下的的资源才会携带&lt;/span&gt; Cookie&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如：/项目名/路径/1.jsp 、/项目名/路径/hello/2.jsp 等&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;如果不设置，默认会在访问&lt;/span&gt;“/&lt;span&gt;项目名&lt;/span&gt;”下的资源时携带如：“/项目名/index.jsp” 、 “/项目名/hello/index.jsp”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Cookie cookie = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;username&quot;, &quot;abc&quot;); cookie.setMaxAge(60*60*24);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒为单位,一天后过期&lt;/span&gt;
cookie.setPath(getServletContext().getContextPath()+&quot;/&quot;); &lt;br/&gt;resp.addCookie(cookie); &lt;br/&gt;resp.sendRedirect(getServletContext().getContextPath()+&quot;/index.jsp&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;推荐博客&lt;/h4&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chen-haozi/p/10227797.html&quot; target=&quot;_blank&quot;&gt;程序员写代码之外，如何再赚一份工资？&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&quot;15&quot;&gt;&lt;span&gt;读取&lt;/span&gt; &lt;strong&gt;cookie&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通过以上步骤，我们将&lt;/span&gt; cookie &lt;span&gt;保存到了浏览器端。那么我们如何读取&lt;/span&gt; cookie 中的值呢。分析：&lt;/p&gt;
&lt;p&gt;cookie &lt;span&gt;被设置进入浏览器后，每次请求都会携带&lt;/span&gt; cookie &lt;span&gt;的值，所以我们需要从&lt;/span&gt; request 中取&lt;span&gt;出&lt;/span&gt; cookie 进行解析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从request中获取所有cookie&lt;/span&gt;
Cookie[] cookies =&lt;span&gt; request.getCookies();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历cookie&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Cookie c:cookies){
　　String cName &lt;/span&gt;= c.getName();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取cookie名String cValue = c.getValue();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取cookie值&lt;/span&gt;
　　System.out.println(&quot;cookie：&quot; + cName + &quot;=&quot; +&lt;span&gt;cValue);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 26 Apr 2019 07:32:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>cookie 简介 什么是 cookie cookie，有时我们也用其复数形式 cookies，是服务端保存在浏览器端的数据片段。以 key/value的形式进行保存。每次请求的时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10774541.html</dc:identifier>
</item>
<item>
<title>马蜂窝火车票系统服务化改造初探 - 马蜂窝技术</title>
<link>http://www.cnblogs.com/mfwtech/p/10774494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfwtech/p/10774494.html</guid>
<description>&lt;p&gt;交通方式是用户旅行前要考虑的核心要素之一。为了帮助用户更好地完成消费决策闭环，马蜂窝上线了大交通业务。现在，用户在马蜂窝也可以完成购买机票、火车票等操作。&lt;/p&gt;
&lt;p&gt;与大多数业务系统相同，我们一样经历着从无到有，再到快速发展的过程。本文将以火车票业务系统为例，主要从技术的角度，和大家分享在一个新兴业务发展的不同阶段背后，系统建设与架构演变方面的一些经验。&lt;/p&gt;

&lt;h2&gt;第一阶段：从无到有&lt;/h2&gt;
&lt;p&gt;在这个阶段，快速支撑起业务，填补业务空白是第一目标。基于这样的考虑，当时的火车票业务从模式上选择的是供应商代购；从技术的角度需要优先实现用户在马蜂窝 App 查询车次余票信息、购票、支付，以及取消、退票退款等核心功能的开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/b21488ca0c4ee33964b4546277a398e0fd0.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;676&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/b21488ca0c4ee33964b4546277a398e0fd0.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1-核心功能与流程&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;技术架构&lt;/h3&gt;
&lt;p&gt;综合考虑项目目标、时间、成本、人力等因素，当时网站服务架构我们选择的是 LNMP（Linux 系统下 Nginx+MySQL+PHP）。整个系统从物理层划分为访问层 ( App，H5，PC 运营后台)，接入层 (Nginx)，应用层 (PHP 程序)，中间件层 (MQ，ElasticSearch)，存储层 (MySQL，Redis)。&lt;/p&gt;
&lt;p&gt;对外部系统依赖主要包括公司内部支付、对账、订单中心等二方系统，和外部供应商系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7c980f661990cd447f8104a8ea0d7ea6285.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;721&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/7c980f661990cd447f8104a8ea0d7ea6285.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 2-火车票系统 V1.0 技术架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如图所示，对外展现功能主要分为两大块，一块是 C 端 App 和 H5，另外是运营后台。二者分别经过外网 Nginx 和内网 Nginx 统一打到 php train 应用上。程序内部主要有四个入口，分别是：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;供其他二方系统调用的 facade 模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运营后台调用的 admin 模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;处理 App 和 H5 请求的 train 核心模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;处理外部供应商回调模块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;四个入口会依赖于下层 modules 模块实现各自功能。对外调用上分两种情况，一种是调用二方系统的 facade 模块满足其公司内部依赖；一种是调用外部供应商。基础设施上依赖于搜索、消息中间件、数据库、缓存等。&lt;/p&gt;
&lt;p&gt;这是典型的单体架构模式，部署简单，分层结构清晰，容易快速实现，可以满足初期产品快速迭代的要求，而且建立在公司已经比较成熟的 PHP 技术基础之上，不必过多担心稳定性和可靠性的问题。&lt;/p&gt;
&lt;p&gt;该架构支撑火车票业务发展了将近一年的时间，简单、易维护的架构为火车票业务的快速发展做出了很大的贡献。然而随着业务的推进，单体架构的缺陷逐渐暴露出来：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有功能聚合在一起，代码修改和重构成本增大&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;研发团队规模逐渐扩大，一个系统多人开发协作难度增加&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;交付效率低，变动范围难以评估。在自动化测试机制不完善的情况下，易导致「修复越多，缺陷越多」的恶性循环&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;伸缩性差，只能横向扩展，无法按模块垂直扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可靠性差，一个 Bug 可能引起系统崩溃&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;阻碍技术创新，升级困难，牵一发而动全身&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决单体架构所带来的一系列问题，我们开始尝试向微服务架构演进，并将其作为后续系统建设的方向。&lt;/p&gt;

&lt;h2&gt;第二阶段：架构转变及服务化初探&lt;/h2&gt;
&lt;p&gt;从 2018 年开始，整个大交通业务开始从 LNMP 架构向服务化演变。&lt;/p&gt;
&lt;h3&gt;架构转变——从单体应用到服务化&lt;/h3&gt;
&lt;p&gt;「工欲善其事，必先利其器」，首先简单介绍一下大交通在实施服务化过程中积累的一些核心设施和组件。&lt;/p&gt;
&lt;p&gt;我们最主要的转变是将开发语言从 PHP 转为 Java，因此技术选型主要围绕 Java 生态圈来展开。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;开发框架与组件&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/768fd84568ceb292d9734b624ca658bd928.jpg&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;643&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/768fd84568ceb292d9734b624ca658bd928.jpg&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3-大交通基础组件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，整体开发框架与组件从下到上分为四层。这里主要介绍最上层大交通业务场景下的封装框架和组件层：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mlang：大交通内部工具包&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mes-client-starter：大交通 MES 技术埋点采集上报&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;dubbo-filter：对 Dubbo 调用的 tracing 追踪&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mratelimit：API 限流保护组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;deploy-starter：部署流量摘除工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tul：统一登录组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;cat-client：对 CAT 调用增强封装的统一组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;基础设施体系&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;服务化的实施离不开基础设施体系的支持。在公司已有基础之上，我们陆续建设了：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;敏捷基础设施：基于 Kubernetes 和 Docker&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基础设施监控告警：Zabbix，Prometheus，Grafana&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;业务告警：基于 ES 日志，MES 埋点 + TAlarm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志系统 ：ELK&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CI/CD 系统：基于 Gitlab+Jekins+Docker+Kubernetes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置中心：Apollo&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务化支撑 ：Springboot2.x+Dubbo&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务治理：Dubbo-admin，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灰度控制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;TOMPS ：大交通应用管理平台&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MPC 消息中心：基于 RocketMQ&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定时任务：基于 Elastic-Job&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;APM 系统 ：PinPoint，CAT&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PHP 和 Java 双向互通支持&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上所述，初步构筑了较为完整的 DevOps + 微服务开发体系。整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/cec7338fa1a80338ffd95503b3fd523591d.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;772&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/cec7338fa1a80338ffd95503b3fd523591d.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4-大交通基础设施体系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上至下依次分为：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问层——目前有 App，H5 和微信小程序；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接入层——走公司公共的 Nginx，OpenResty；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;业务层的应用——包括无线 API，Dubbo 服务，消&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;消息中心和定时任务——部署在 Kubernetes+Docker 中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;中间件层——包括 ElasticSearch，RocketMQ 等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;存储层——MySQL，Redis，FastDFS，HBase 等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，外围支撑系统包括 CI/CD、服务治理与配置、APM 系统、日志系统、监控告警系统。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;CI/CD 系统&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;我们目前还没有放开 Prod 的 OPS 权限给开发，计划在新版 CD 系统中会逐步开放。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/1ab21541fadc3c096bd63c743de1631d27a.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;610&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/1ab21541fadc3c096bd63c743de1631d27a.jpg&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;图5-CI/CD 体系&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h4_9&quot;&gt;服务化框架 Dubbo&lt;/h4&gt;
&lt;p&gt;我们选择 Dubbo 作为分布式微服务框架，主要有以下因素考虑：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;成熟的高性能分布式框架。目前很多公司都在使用，已经经受住各方面性能考验，比较稳定；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以和 Spring 框架无缝集成。我们的架构正是基于 Spring 搭建，并且接入 Dubbo 时可以做到代码无侵入，接入也非常方便；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;具备服务注册、发现、路由、负载均衡、服务降级、权重调节等能力；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码开源。可以根据需求进行个性化定制，扩展功能，进行自研发 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/907e0fce657fb7a97407068a0f1ceb4bef3.jpg&quot; alt=&quot;&quot; width=&quot;1060&quot; height=&quot;769&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/907e0fce657fb7a97407068a0f1ceb4bef3.jpg&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;图 6-Dubbo 架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了保持和 Dubbo 官方以及社区的密切联系外，我们也在不断对 Dubbo 进行增强与改进，比如基于 dubbo-fitler 的日志追踪，基于大交通统一应用管理中心的 Dubbo 统一配置管理、服务治理体系建设等。&lt;/p&gt;
&lt;h3&gt;服务化初探——抢票系统&lt;/h3&gt;
&lt;p&gt;向服务化的演进决不能是一个大跃进运动，那样只会把应用拆分得七零八落，最终不但大大增加运维成本，而且看不到收益。&lt;/p&gt;
&lt;p&gt;为了保证整个系统的服务化演进过程更加平滑，我们首先选择了抢票系统进行实践探索。抢票是火车票业务中的一个重要版块，而且抢票业务相对独立，与已有的 PHP 电子票业务冲突较少，是我们实施服务化的较佳场景。&lt;/p&gt;
&lt;p&gt;在对抢票系统进行服务拆分和设计时，我们积累了一些心得和经验，主要和大家分享以下几点。&lt;/p&gt;
&lt;h4 id=&quot;h4_11&quot;&gt;功能与边界&lt;/h4&gt;
&lt;p&gt;简单来说，抢票就是实现用户提前下抢票单，系统在正式开售之后不断尝试为用户购票的过程。从本质上来说，抢票是一种手段，通过不断检测所选日期和车次的余票信息，以在有余票时为用户发起占座为目的。至于占座成功以后的处理，和正常电子票是没有什么区别的。理解了这个过程之后，在尽量不改动原有 PHP 系统的前提下，我们这样划分它们之间的功能边界：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/9da34f67327f37c2d4a99700edbbb77bb42.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;1340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7-抢票功能划分&lt;/p&gt;

&lt;p&gt;也就是说，用户下抢票单支付成功，待抢票占座成功后，后续出票的事情我们会交给 PHP 电子票系统去完成。同理，在抢票的逆向方面，只需实现「未抢到票全额退」以及「抢到票的差额退」功能，已出票的线上退和线下退票都由 PHP 系统完成，这就在很大程度上减少了抢票的开发任务。&lt;/p&gt;
&lt;h4 id=&quot;h4_12&quot;&gt;服务设计&lt;/h4&gt;
&lt;p&gt;服务的设计原则包括隔离、自治性、单一职责、有界上下文、异步通信、独立部署等。其他部分都比较容易把控，而有界上下文通俗来说反应的就是服务的粒度问题，这也是做服务拆分绕不过去的话题。粒度太大会导致和单体架构类似的问题，粒度太细又会受制于业务和团队规模。结合实际情况，我们对抢票系统从两个维度进行拆分：&lt;/p&gt;
&lt;p&gt;1. 从业务角度系统划分为供应商服务 (同步和推送)、正向交易服务、逆向交易服务、活动服务。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/5fbef1995b70c2ac2f18cb391ec697bae00.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8-抢票服务设计&lt;/p&gt;

&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;正向交易服务：包括用户下抢票单、支付、取消、出票、查询、通知等功能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;逆向交易服务：包括逆向订单、退票、退款、查询、通知等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;供应侧：去请求资源方完成对应业务操作、下抢票单、取消、占座、出票等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;活动服务：包括日常活动、分享、活动排名统计等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2. 从系统层级分为前端 H5 层前后分离、API 接入层、RPC 服务层，和 PHP 之间的桥接层、异步消息处理、定时任务、供应商对外调用和推送网关。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/af1615fd56a053a203c0faa4b4c65768721.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9-抢票系统分层&lt;/p&gt;

&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;展示层：H5 和小程序，前后端分离&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;API 层：对 H5 和小程序提供的统一 API 入口网关，负责对后台服务的聚合，以 HTTP REST 风格对外暴露&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务层：包括上节所提到的业务服务，对外提供 RPC 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;桥接层：包括调用 PHP 的代理服务，对 Java 侧提供 Dubbo RPC 服务，以 HTTP 形式调用统一的 PHP 内部网关；对 PHP 提供的统一 GW，PHP 以 HTTP 形式通过 GW 来调用 Java 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;消息层：异步的消息处理程序，包括订单状态变更通知，优惠券等处理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定时任务层：提供各种补偿任务，或者业务轮询处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h4_13&quot;&gt;数据要素&lt;/h4&gt;
&lt;p&gt;对于交易系统而言，不管是用何种语言，何种架构，要考虑的最核心部分终归是数据。数据结构基本反应了业务模型，也左右着程序的设计、开发、扩展与升级维护。我们简单梳理一下抢票系统所涉及的核心数据表：&lt;/p&gt;
&lt;p&gt;1. 创单环节：用户选择车次进入填单页以后，要选择乘车人、添加联系人，所以首先会涉及到乘车人表，这块复用的 PHP 电子票功能&lt;/p&gt;
&lt;p&gt;2. 用户提交创单申请后，将会涉及到以下数据表：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;订单快照表——首先将用户的创单请求要素存储起来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;抢票订单表 (order)：为用户创建抢票单&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;区段表（segment）：用于一个订单中可能存在的连续乘车而产生的多个车次情况 (类似机票航段)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;乘车人表 (passenger)：抢票单中包含乘车人信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;活动表 (activity)：反映订单中可能包含的活动信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;物品表 (item)：反映包含的车票，保险等信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;履约表：用户购买车票、保险后，最终会做票号回填，我们也叫票号信息表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3. 产生占座结果后：用户占座失败涉及全额退款，占座成功可能涉及差额退款，因此我们会有退票订单表 (refund_order)；虽然只涉及到退款，但同样会有 refund_item 表来记录退款明细。&lt;/p&gt;
&lt;h4 id=&quot;h4_14&quot;&gt;订单状态&lt;/h4&gt;
&lt;p&gt;订单系统的核心要点是订单状态的定义和流转，这两个要素贯穿着整个订单的生命周期。&lt;/p&gt;
&lt;p&gt;我们从之前的系统经验中总结出两大痛点，一是订单状态定义复杂，我们试图用一个状态字段来打通前台展示和后端逻辑处理，结果导致单一订单状态多达 18 种；二是状态流转逻辑复杂，流转的前置因素判断和后置方向上太多的 if else 判断，代码维护成本高。&lt;/p&gt;
&lt;p&gt;因此，我们采用有限状态机来梳理抢票正向订单的状态和状态流转，关于状态机的应用，可以参照之前发过的一篇文章&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MTA4Mzg5NA==&amp;amp;mid=2247483775&amp;amp;idx=1&amp;amp;sn=78f4f6414ee57c627c4c31a93ee7d895&amp;amp;chksm=cfd38c66f8a40570ca670e09ff4dc5142023e79913f6c07081d6b8f79bdef220de9d0b1759bf&amp;amp;scene=21#wechat_redirect&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《状态机在马蜂窝机票交易系统中的应用与优化》&lt;/a&gt;，下图是抢票订单的状态流转图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7eafd7cd0526c7d2b694c7f8ca9e1eedd9b.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;779&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/7eafd7cd0526c7d2b694c7f8ca9e1eedd9b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图10-抢票订单状态流转&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将状态分为订单状态和支付状态，通过事件机制来推进状态的流转。到达目标态有两个前提：一是原状态，二是触发事件。状态按照预设的条件和路线进行流转，将业务逻辑的执行和事件触发与状态流转拆分开，达到解耦和便于扩展维护的目的。&lt;/p&gt;
&lt;p&gt;如上图所示，将订单状态定义为：初始化→下单成功→交易成功→关闭。给支付状态定义为：初始化→待支付→已支付→关闭。以正常 case 来说，用户下单成功后，会进入下单成功和待支付；用户通过收银台支付后，订单状态不变，支付状态为已支付；之后系统会开始帮用户占座，占座成功以后，订单会进入交易成功，支付状态不变。&lt;/p&gt;
&lt;p&gt;如果仅仅是上面的双状态，那么业务程序执行倒是简单了，但无法满足前台给用户丰富的单一状态展示，因此我们还会记录关单原因。关单原因目前有 7 种：未关闭、创单失败、用户取消、支付超时、运营关单、订单过期、抢票失败。我们会根据订单状态、支付状态、关单原因，计算出一个订单对外展示状态。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;服务化的实施具备一定的成本，需要人员和基础设施都有一定的基础。初始阶段，从相对独立的新业务着手，做好和旧系统的融合复用，能较快的获取成果。抢票系统在不到一个月的时间内完成产品设计，开发联调，测试上线，也很好地印证了这一点。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;h2_17&quot;&gt;第三阶段：服务化推进和系统能力提升&lt;/h2&gt;
&lt;p&gt;抢票系统建设的完成，代表我们迈出了一小步，也只是迈出了一小步，毕竟抢票是周期性的业务。更多的时间里，电子票是我们业务量的主要支撑。在新老系统的并行期，主要有以下痛点：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;原有电子票系统由于当时因素影响，与特定供应商绑定紧密，受供应商制约较大；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于和抢票系统及大交通其他系统之间的兼容成本较高，导致我们统一链路追踪、环境隔离、监控告警等工作实施难度很大；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PHP 和 Java 桥接层承接太多业务，性能无法保证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，卸下历史包袱，尽快完成旧系统的服务化迁移，统一技术栈，使主要业务得到更加有力的系统支撑，是我们接下来的目标。&lt;/p&gt;
&lt;h3 id=&quot;h3_18&quot;&gt;与业务同行：电子票流程改造&lt;/h3&gt;
&lt;p&gt;我们希望通过对电子票流程的改造，重塑之前应急模式下建立的火车票项目，最终实现以下几个目标：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;建立马蜂窝火车票的业务规则，改变之前业务功能和流程上受制于供应侧规则的局面；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;完善用户体验和功能，增加在线选座功能，优化搜索下单流程，优化退款速度，提升用户体验；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提升数据指标和稳定性，引入新的供应侧服务，提高可靠性；供应商分单体系，提升占座成功率和出票率；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;技术上完成到 Java 服务化的迁移，为后续业务打下基础&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们要完成的不仅是技术上的重构，而是结合新的业务诉求，去不断丰富新的系统，力求达到业务和技术的目标一致性，因此我们将服务化迁移和业务系统建设结合在一起推进。下图是电子票流程改造后火车票整体架构：&lt;/p&gt;
&lt;h2 id=&quot;h2_19&quot;&gt; &lt;/h2&gt;
&lt;h2 id=&quot;h2_20&quot;&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/4cbd78e5b1e15d9cd40e7f11cb6343efabb.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;666&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;图11-电子票改造后的火车票架构&lt;/p&gt;

&lt;p&gt;图中浅蓝色部分为抢票期间已经建好的功能，深蓝色模块为电子票流程改造新加入的部分。除了和抢票系统类似的供应商接入、正向交易、逆向交易以外，还包括搜索与基础数据系统，在供应侧也增加了电子票的业务功能。同时我们新的运营后台也已经建立，保证了运营支撑的延续性。&lt;/p&gt;
&lt;p&gt;项目实施过程中，除了抢票所说的一些问题之外，也着重解决以下几个问题。&lt;/p&gt;
&lt;h4 id=&quot;h4_21&quot;&gt;搜索优化&lt;/h4&gt;
&lt;p&gt;先来看用户一次站站搜索可能穿过的系统：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/bda8da7e1c895efec09501b9034b8fbdba2.jpg&quot; alt=&quot;&quot; width=&quot;1061&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图12-站站查询调用流程&lt;/p&gt;

&lt;p&gt;请求先到 twl api 层，再到 tsearch 查询服务，tsearch 到 tjs 接入服务再到供应侧，整个调用链路还是比较长的，如果每次调用都是全链路调用，那么结果是不太乐观的。因此 tsearch 对于查询结果有 redis 缓存，缓存也是缩短链路、提高性能的关键。站站查询要缓存有几个难点：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于数据实时性要求很高。核心是余票数量，如果数据不实时，那么用户再下单占座成功率会很低&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据比较分散。比如出发站，到达站，出发日期，缓存命中率不高&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;供应侧接口不稳定。平均在 1000ms 以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综合以上因素考虑，我们设计 tsearch 站站搜索流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/106fcbc48223c52e390bd40ae23b48a6df3.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;1113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图13-搜索设计流程&lt;/p&gt;

&lt;p&gt;如图所示，首先对于一个查询条件，我们会缓存多个渠道的结果，一方面是因为要去对比哪个渠道结果更加准确，另一方面可以增加系统可靠性和缓存命中率。&lt;/p&gt;
&lt;p&gt;我们将 Redis 的过期时间设为 10min，对缓存结果定义的有效期为 10s，首先取有效；如果有效为空，则取失效；如果失效也为空，则同步限时 3s 去调用渠道获取，同时将失效和不存在的缓存渠道交给异步任务去更新。需要注意通过分布式锁来防止并发更新一个渠道结果。最终的缓存结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/522cbcf9d591ffbd7e31317fab19161bb52.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;764&quot;/&gt;&lt;/p&gt;

&lt;p&gt;缓存的命中率会在 96% 以上，RT 平均在 500ms 左右，能够在保证用户体验良好的同时，做到及时的数据更新。&lt;/p&gt;
&lt;h4 id=&quot;h4_22&quot;&gt;消息的消费&lt;/h4&gt;
&lt;p&gt;我们有大量业务是通过异步消息方式来处理的，比如订单状态变更消息、占座通知消息、支付消息等。除了正常的消息消费以外，还有一些特殊的场景，如顺序消费、事务消费、重复消费等，主要基于 RocketMQ 来实现。&lt;/p&gt;
&lt;p&gt;顺序消费&lt;/p&gt;
&lt;p&gt;主要应用于对消息有先后依赖的场景，比如创单消息必须先于占座消息被处理。RocketMQ 本身支持消息顺序消费，我们基于它来实现这种业务场景。从原理上来说也很简单，RocketMQ 限定生产者只能将消息发往一个队列，同时限定消费端只能有一个线程来读取，这样全局单队列，单消费者就保证了消息的顺序消费。&lt;/p&gt;
&lt;p&gt;重复消费&lt;/p&gt;
&lt;p&gt;RocketMQ 保障的是 At Least Once，并不能保证 Exactly Only Once，前面抢票我们也提过，一是通过要求业务侧保持幂等性，另外通过数据库表 message_produce_record 和 message_consume_record 来保证精准一次投递和消费结果确认。&lt;/p&gt;
&lt;p&gt;事务消费&lt;/p&gt;
&lt;p&gt;基于 RocketMQ 的事务消息功能。它支持二阶段提交，会先发送一条预处理消息，然后回调执行本地事务，最终提交或者回滚，帮助保证修改数据库的信息和发送异步消息的一致。&lt;/p&gt;
&lt;h4 id=&quot;h4_23&quot;&gt;灰度运行&lt;/h4&gt;
&lt;p&gt;歼十战机的总设计师曾说过一句话：「造一架飞机不是最难的，难的是让它上天」，对我们来说同样如此。3 月是春游季的高峰，业务量与日俱增，在此期间完成系统重大切换，我们需要完备的方案来保障业务的顺利切换。&lt;/p&gt;
&lt;p&gt;方案设计&lt;/p&gt;
&lt;p&gt;灰度分为白名单部分和百分比灰度部分，我们首先在内部进行白名单灰度，稳定后进入 20% 流量灰度期。&lt;/p&gt;
&lt;p&gt;灰度的核心是入口问题，由于本次前端也进行了完整改版，因此我们从站站搜索入口将用户引入到不同的页面，用户分别会在新旧系统中完成业务。&lt;/p&gt;
&lt;h2 id=&quot;h2_24&quot;&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/e50c8a294954370fe79c4cfa0651871469f.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;975&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;图14-灰度运行方案&lt;/p&gt;

&lt;h4 id=&quot;h4_25&quot;&gt;搜索下单流程&lt;/h4&gt;
&lt;p&gt;App 在站站搜索入口调用灰度接口获取跳转地址，实现入口分流。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/2cf6591018b004e7be5185ebde4ece7cd15.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;762&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图15-搜索下单分流&lt;/p&gt;

&lt;h4 id=&quot;h4_26&quot;&gt;效果对比&lt;/h4&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/3c0b9ed8fb442244dfc7a44794785fa689c.jpg&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;960&quot;/&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/2ee631f14f7bd19f6ffdcd3d0345dee2b06.jpg&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;960&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2_27&quot;&gt;近期规划&lt;/h2&gt;
&lt;p&gt;我们只是初步实现了服务化在火车票业务线的落地实施，与此同时，还有一些事情是未来我们要去持续推进和改进的：&lt;/p&gt;
&lt;p&gt;1. 服务粒度细化：目前的服务粒度仍然比较粗糙。随着功能的不断增多，粒度的细化是我们要去改进的重点，比如将交易服务拆分为订单查询服务，创单服务，处理占座的服务和处理出票的服务。这也是 DevOps 的必然趋势。细粒度的服务，才能最大限度满足我们快速开发、快速部署，以及风险可控的要求。&lt;/p&gt;
&lt;p&gt;2. 服务资源隔离：只在服务粒度实现隔离是不够的。DB 隔离、缓存隔离、MQ 隔离也非常必要。随着系统的不断扩展与数据量的增长，对资源进行细粒度的隔离是另一大重点。&lt;/p&gt;
&lt;p&gt;3. 灰度多版本发布：目前我们的灰度策略只能支持新老版本的并行，未来除了会进行多版本并行验证，还要结合业务定制化需求，使灰度策略更加灵活。&lt;/p&gt;

&lt;h2 id=&quot;h2_28&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;业务的发展离不开技术的发展，同样，技术的发展也要充分考虑当时场景下的业务现状和条件，二者相辅相成。比起设计不足而言，我们更要规避过度设计。&lt;/p&gt;
&lt;p&gt;技术架构是演变出来的，不是一开始设计出来的。我们需要根据业务发展规律，将长期技术方案进行阶段性分解，逐步达成目标。同时，也要考虑服务化会带来很多新问题，如复杂度骤增、业务拆分、一致性、服务粒度、链路过长、幂等性、性能等等。&lt;/p&gt;
&lt;p&gt;比服务支撑更难的是服务治理，这也是我们大家要深入思考和去做的事情。&lt;/p&gt;
&lt;p&gt;本文作者：李战平，马蜂窝大交通业务研发技术专家。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（题图来源：网络）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;关注马蜂窝技术，找到更多你想要的内容&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://oscimg.oschina.net/oscnet/6dbaf8bd5439cb00964a63a7e4bd493e6fe.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;481&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
</description>
<pubDate>Fri, 26 Apr 2019 07:24:00 +0000</pubDate>
<dc:creator>马蜂窝技术</dc:creator>
<og:description>比服务支撑更难的是服务治理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfwtech/p/10774494.html</dc:identifier>
</item>
<item>
<title>使用Entity Framework Core访问数据库（Oracle篇） - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/10756548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/10756548.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哇。。看看时间 真的很久很久没写博客了 将近一年了。&lt;/p&gt;
&lt;p&gt;最近一直在忙各种家中事务和公司的新框架  终于抽出时间来更新一波了。&lt;/p&gt;
&lt;p&gt;本篇主要讲一下关于Entity Framework Core访问oracle数据库的采坑。。&lt;/p&gt;
&lt;p&gt;强调一下，&lt;span&gt;本篇文章发布之前 关于Entity Framework Core访问oracle数据库的甲骨文官方dll还未正式发布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不过我已经在项目中用起来了。。介意的兄弟可以先等等。。甲骨文说的是本年第三季度。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;环境&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.官方文档中支持的环境&lt;/h2&gt;
&lt;p&gt;首先我们来看看所谓的官方支持吧。&lt;/p&gt;
&lt;p&gt;操作系统：&lt;/p&gt;
&lt;p&gt;1. Windows x64&lt;br/&gt;　　1.1Windows 8.1 (Pro and Enterprise Editions)&lt;br/&gt;　　1.2Windows 10 x64 (Pro, Enterprise, and Education Editions)&lt;br/&gt;　　1.3Windows Server 2012 R2 x64 (Standard, Datacenter, Essentials, and FoundationEditions)&lt;br/&gt;　　1.4Windows Server 2016 x64 (Standard and Datacenter Editions)&lt;br/&gt;2.Linux x64&lt;br/&gt;　　2.1Oracle Linux 7&lt;br/&gt;　　2.2Red Hat Enterprise Linux 7&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;.NET版本:&lt;br/&gt;　　1.NET Core 2.1 或者更高&lt;br/&gt;　　2.NET Framework 4.6.1 或者更高&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;· Entity Framework Core版本：&lt;br/&gt;　　1.   2.1版本或者更高&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;依赖库：&lt;br/&gt;　　1. ODP.NET Core 18.3或者更高&lt;br/&gt;　　2.Microsoft.EntityFrameworkCore.Relational 2.1或者更高&lt;br/&gt;　　3.Access to Oracle Database 11g Release 2 (11.2) 或者更高&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本篇将采取CodeFirst的形式来创建数据库。。&lt;/p&gt;
&lt;h2&gt;1.创建数据库&lt;/h2&gt;
&lt;p&gt;我们创建上下文与实体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BloggingContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseOracle(&lt;/span&gt;&lt;span&gt;@&quot;SQL Contion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b =&amp;gt; b.UseOracleSQLCompatibility(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {

        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public int Rating { get; set; }&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里我们先介绍第一个要注意的地方，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;UseOracle参数里面跟的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;UseOracleSQLCompatibility方法，里面参数传递的11，指的是oracle11g版本。如果你是12g版本 请传递12.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为11g和12g的SQL语法有较多不同的地方，所以用这个来区分。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们add一个版本 执行nuget命令如下：(PS:不懂如何使用codeFirst的请移步：&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/GuZhenYin/p/8579420.html&quot;&gt;Entity Framework Core 之数据库迁移&lt;/a&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Add-Migration BanBen1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将版本更新到数据库如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Update-Database
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库生成成功。&lt;/p&gt;

&lt;h2&gt;2.关于oracle序列的坑&lt;/h2&gt;
&lt;p&gt;我们这时候编写插入语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (BloggingContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BloggingContext())
            {
                db.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaaaa1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                db.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看似没问题的语句，会得到一个错误消息如下：&lt;/p&gt;
&lt;p&gt;Index was out of range. Must be non-negative and less than the size of the collection.&lt;br/&gt;Parameter name: index&lt;/p&gt;
&lt;p&gt;这是因为我们没有给主键赋值导致的错误信息。&lt;strong&gt;&lt;span&gt;（因为oracle没有自增主键，只能通过序列自增）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么自增序列如何使用呢？&lt;/p&gt;
&lt;p&gt;我们查看数据库会发现，如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/653851/201904/653851-20190426150704378-1710609575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;codefirst已经帮我们生成了序列，但是并不会自动使用。我们需要配置一下：&lt;/p&gt;
&lt;p&gt;在上下文中的OnModelCreating方法添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Post&amp;gt;(entity =&amp;gt;&lt;span&gt;
            {
                entity.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Posts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                entity.Property(o &lt;/span&gt;=&amp;gt; o.PostId).ForOracleUseSequenceHiLo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Posts_PostId_sq3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            });
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Blog&amp;gt;(entity =&amp;gt;&lt;span&gt;
            {
                entity.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                entity.Property(o &lt;/span&gt;=&amp;gt; o.BlogId).ForOracleUseSequenceHiLo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blogs_BlogId_sq1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定对应表的序列。&lt;/p&gt;
&lt;p&gt;然后在运行。即可添加成功了。&lt;/p&gt;

&lt;h2&gt;3.关于在Docker中部署的坑&lt;/h2&gt;
&lt;p&gt;在我的生产项目中。应该是打包到docker直接运行部署的。&lt;/p&gt;
&lt;p&gt;不过在打包到docker的过程中又出现了诡异的问题。&lt;/p&gt;
&lt;p&gt;就不重现了。。反正就是开发环境没有问题。。直接放到linux中也没问题。但是一旦打包到docker运行 就会查询不到数据。&lt;/p&gt;
&lt;p&gt;经过多方查证 最终发现是微软提供的rumtime镜像，因为是精简版系统 所以里面的市区有问题。&lt;/p&gt;
&lt;p&gt;在dockerfile中添加如下语句 在生成的时候 设置好时区：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
FROM microsoft/dotnet:&lt;span&gt;2.1&lt;/span&gt;-aspnetcore-&lt;span&gt;runtime
&lt;span&gt;ENV TZ&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=Asia/Shanghai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就能成功的操作到数据库了。。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;近期移植了好些个项目到.NET CORE 或多或少遇到了不少坑。。应该算是采坑无数了。。&lt;/p&gt;
&lt;p&gt;其实大部分都集中在数据库连接这一块。。比如oracle  DB2 。。（PS：感觉也就mysql与sql server支持是最好的。。）&lt;/p&gt;
&lt;p&gt;DB2虽然官方发布了。但是他的坑其实比oracle还大。。我们下篇在写。。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 07:24:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<og:description>前言 哇。。看看时间 真的很久很久没写博客了 将近一年了。 最近一直在忙各种家中事务和公司的新框架 终于抽出时间来更新一波了。 本篇主要讲一下关于Entity Framework Core访问orac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/10756548.html</dc:identifier>
</item>
<item>
<title>Docker 容器 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/10767865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/10767865.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.  容器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在过去，如果要开始编写Python应用程序，首先要做的就是在机器上安装Python运行时环境。但是，这就造成了这样一种情况：你的机器上的环境需要完美，以便你的应用程序能够按预期运行，而且还需要与你的生产环境相匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用Docker，你只需要获取一个可移植的Python运行时作为镜像，不需要安装。然后，当你构建应用程序时就会在代码旁边包含基本的Python镜像，确保应用程序、它的依赖项和运行时一起运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些可移植的镜像被一些称之为“Dockerfile”来定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  用Dockerfile定义一个容器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在你的本地机器上创建一个空目录，进入该目录，然后在此目录下创建一个名字叫Dockerfile的文件，将下列内容复制粘贴到文件中，保存。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Use an official Python runtime as a parent image
&lt;span class=&quot;k&quot;&gt;FROM&lt;span class=&quot;s&quot;&gt; python:2.7-slim

&lt;span class=&quot;c&quot;&gt;# Set the working directory to /app
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;span class=&quot;s&quot;&gt; /app

&lt;span class=&quot;c&quot;&gt;# Copy the current directory contents into the container at /app
&lt;span class=&quot;k&quot;&gt;COPY&lt;span class=&quot;s&quot;&gt; . /app

&lt;span class=&quot;c&quot;&gt;# Install any needed packages specified in requirements.txt
&lt;span class=&quot;k&quot;&gt;RUN pip install &lt;span class=&quot;nt&quot;&gt;--trusted-host pypi.python.org &lt;span class=&quot;nt&quot;&gt;-r requirements.txt

&lt;span class=&quot;c&quot;&gt;# Make port 80 available to the world outside this container
&lt;span class=&quot;k&quot;&gt;EXPOSE&lt;span class=&quot;s&quot;&gt; 80

&lt;span class=&quot;c&quot;&gt;# Define environment variable
&lt;span class=&quot;k&quot;&gt;ENV&lt;span class=&quot;s&quot;&gt; NAME World

&lt;span class=&quot;c&quot;&gt;# Run app.py when the container launches
&lt;span class=&quot;k&quot;&gt;CMD&lt;span class=&quot;s&quot;&gt; [&quot;python&quot;, &quot;app.py&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;可以看到，Dockerfile文件需要引用app.py和requirements.txt文件，于是，在与Dockerfile同级的目录下创建这两个文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;requirements.txt&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;Flask
Redis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app.py&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from &lt;span class=&quot;nn&quot;&gt;flask &lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;n&quot;&gt;Flask
&lt;span class=&quot;kn&quot;&gt;from &lt;span class=&quot;nn&quot;&gt;redis &lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;n&quot;&gt;Redis&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;RedisError
&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;os
&lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;nn&quot;&gt;socket

&lt;span class=&quot;c&quot;&gt;# Connect to Redis
&lt;span class=&quot;n&quot;&gt;redis &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;Redis&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;host&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;s&quot;&gt;&quot;redis&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;db&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;socket_connect_timeout&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;socket_timeout&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;n&quot;&gt;app &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;Flask&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;__name__&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;k&quot;&gt;def &lt;span class=&quot;nf&quot;&gt;hello&lt;span class=&quot;p&quot;&gt;():
    &lt;span class=&quot;k&quot;&gt;try&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;n&quot;&gt;visits &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;redis&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;incr&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;counter&quot;&lt;span class=&quot;p&quot;&gt;)
    &lt;span class=&quot;k&quot;&gt;except &lt;span class=&quot;n&quot;&gt;RedisError&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;n&quot;&gt;visits &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;i&amp;gt;cannot connect to Redis, counter disabled&amp;lt;/i&amp;gt;&quot;

    &lt;span class=&quot;n&quot;&gt;html &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;h3&amp;gt;Hello {name}!&amp;lt;/h3&amp;gt;&quot; \
           &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; {hostname}&amp;lt;br/&amp;gt;&quot; \
           &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;b&amp;gt;Visits:&amp;lt;/b&amp;gt; {visits}&quot;
    &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;html&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;format&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;name&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;n&quot;&gt;os&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;getenv&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;&quot;NAME&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;span class=&quot;p&quot;&gt;), &lt;span class=&quot;n&quot;&gt;hostname&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;n&quot;&gt;socket&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;gethostname&lt;span class=&quot;p&quot;&gt;(), &lt;span class=&quot;n&quot;&gt;visits&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;n&quot;&gt;visits&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;n&quot;&gt;__name__ &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;span class=&quot;p&quot;&gt;:
    &lt;span class=&quot;n&quot;&gt;app&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;run&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;host&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;s&quot;&gt;'0.0.0.0'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;port&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;80&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;构建App&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;span class=&quot;nb&quot;&gt;ls
Dockerfile              app.py                  requirements.txt&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;--tag&lt;span class=&quot;o&quot;&gt;=friendlyhello &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ docker image &lt;span class=&quot;nb&quot;&gt;ls

REPOSITORY            TAG                 IMAGE ID
friendlyhello         latest              326387cea398&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意：tag默认是latest，当然你可以手动指定，比如：--tag=friendlyhello:v0.0.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.  运行App&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行app，将本地4000端口映射到容器对外公布的80端口&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-p 4000:80 friendlyhello&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;4.  共享你的镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了能够在任何地方都运行，我们需要将我们的镜像上传到注册中心。注册中心是仓库的集合，而仓库是镜像的集合。这很像GitHub仓库或者Maven仓库。一个账号可以在注册中心中创建许多个仓库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用Docker ID登录&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ docker login&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;5.  给镜像打标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将本地镜像关联到注册中心的某个仓库，格式是这样的： username/repository:tag&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，tag是可选的，但是推荐加上tag。当你关联到仓库后，注册中心会给这个镜像分配一个版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给镜像打Tag的格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker tag image username/repository:tag&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;例如，我们给我们刚才的friendlyhello打一个tag&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker tag friendlyhello gordon/get-started:part2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;6.  发布镜像&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker push username/repository:tag&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;（PS：这个过程很像git在本地打标签并推送到远程仓库）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;git&lt;/span&gt; &lt;span&gt;tag&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;git&lt;/span&gt; &lt;span&gt;push&lt;/span&gt; &lt;span&gt;origin&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;推送成功以后，我们就可以在注册中心看到了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190426144745900-2052043986.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201904/874963-20190425231306301-141683147.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.  备忘单&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t friendlyhello &lt;span class=&quot;nb&quot;&gt;.  &lt;span class=&quot;c&quot;&gt;# Create image using this directory's Dockerfile
docker run &lt;span class=&quot;nt&quot;&gt;-p 4000:80 friendlyhello  &lt;span class=&quot;c&quot;&gt;# Run &quot;friendlyhello&quot; mapping port 4000 to 80
docker run &lt;span class=&quot;nt&quot;&gt;-d &lt;span class=&quot;nt&quot;&gt;-p 4000:80 friendlyhello         &lt;span class=&quot;c&quot;&gt;# Same thing, but in detached mode
docker container &lt;span class=&quot;nb&quot;&gt;ls                                &lt;span class=&quot;c&quot;&gt;# List all running containers
docker container &lt;span class=&quot;nb&quot;&gt;ls &lt;span class=&quot;nt&quot;&gt;-a             &lt;span class=&quot;c&quot;&gt;# List all containers, even those not running
docker container stop &amp;lt;&lt;span class=&quot;nb&quot;&gt;hash&lt;span class=&quot;o&quot;&gt;&amp;gt;           &lt;span class=&quot;c&quot;&gt;# Gracefully stop the specified container
docker container &lt;span class=&quot;nb&quot;&gt;kill &amp;lt;&lt;span class=&quot;nb&quot;&gt;hash&lt;span class=&quot;o&quot;&gt;&amp;gt;         &lt;span class=&quot;c&quot;&gt;# Force shutdown of the specified container
docker container rm &amp;lt;&lt;span class=&quot;nb&quot;&gt;hash&lt;span class=&quot;o&quot;&gt;&amp;gt;        &lt;span class=&quot;c&quot;&gt;# Remove specified container from this machine
docker container rm &lt;span class=&quot;k&quot;&gt;$(docker container &lt;span class=&quot;nb&quot;&gt;ls &lt;span class=&quot;nt&quot;&gt;-a &lt;span class=&quot;nt&quot;&gt;-q&lt;span class=&quot;k&quot;&gt;)         &lt;span class=&quot;c&quot;&gt;# Remove all containers
docker image &lt;span class=&quot;nb&quot;&gt;ls &lt;span class=&quot;nt&quot;&gt;-a                             &lt;span class=&quot;c&quot;&gt;# List all images on this machine
docker image rm &amp;lt;image id&amp;gt;            &lt;span class=&quot;c&quot;&gt;# Remove specified image from this machine
docker image rm &lt;span class=&quot;k&quot;&gt;$(docker image &lt;span class=&quot;nb&quot;&gt;ls &lt;span class=&quot;nt&quot;&gt;-a &lt;span class=&quot;nt&quot;&gt;-q&lt;span class=&quot;k&quot;&gt;)   &lt;span class=&quot;c&quot;&gt;# Remove all images from this machine
docker login             &lt;span class=&quot;c&quot;&gt;# Log in this CLI session using your Docker credentials
docker tag &amp;lt;image&amp;gt; username/repository:tag  &lt;span class=&quot;c&quot;&gt;# Tag &amp;lt;image&amp;gt; for upload to registry
docker push username/repository:tag            &lt;span class=&quot;c&quot;&gt;# Upload tagged image to registry
docker run username/repository:tag                   &lt;span class=&quot;c&quot;&gt;# Run image from a registry&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 26 Apr 2019 06:58:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>1. 容器 在过去，如果要开始编写Python应用程序，首先要做的就是在机器上安装Python运行时环境。但是，这就造成了这样一种情况：你的机器上的环境需要完美，以便你的应用程序能够按预期运行，而且还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/10767865.html</dc:identifier>
</item>
<item>
<title>转发和重定向区别 - 一缕青烟m</title>
<link>http://www.cnblogs.com/mqflive81/p/10774249.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mqflive81/p/10774249.html</guid>
<description>&lt;p&gt;&lt;span&gt;在进行web开发时，跳转是最常见的，今天在这里来学习下2种跳转：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是request.getRequestDispatcher().forward(request,response)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、属于转发，也是服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页共用一个request，可以通过此来传递一些数据或者session信息，request.setAttribute()和request.getAttribute()。&lt;/p&gt;
&lt;p&gt;2、在前后两次执行后，地址栏不变，仍是当前文件的地址。&lt;/p&gt;
&lt;p&gt;3、不能转向到本web应用之外的页面和网站，所以转向的速度要快。&lt;/p&gt;
&lt;p&gt;4、URL中所包含的“/”表示应用程序(项目)的路径。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二种是response.sendRedirect()：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、属于重定向，也是客户端跳转，相当于客户端向服务端发送请求之后，服务器返回一个响应，客户端接收到响应之后又向服务端发送一次请求，一共是2次请求，前后页不共用一个request，不能读取转向前通过request.setAttribute()设置的属性值。&lt;/p&gt;
&lt;p&gt;2、在前后两次执行后，地址栏发生改变，是目标文件的地址。&lt;/p&gt;
&lt;p&gt;3、可以转向到本web应用之外的页面和网站，所以转向的速度相对要慢。&lt;/p&gt;
&lt;p&gt;4、URL种所包含的&quot;/&quot;表示根目录的路径。&lt;/p&gt;

&lt;p&gt;特殊的应用：对数据进行修改、删除、添加操作的时候，应该用response.sendRedirect()。如果是采用了request.getRequestDispatcher().forward(request,response)，那么操作前后的地址栏都不会发生改变，仍然是修改的控制器，如果此时再对当前页面刷新的话，就会重新发送一次请求对数据进行修改，这也就是有的人在刷新一次页面就增加一条数据的原因。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如何采用第二种方式传递数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、可以选择session，但要在第二个文件中删除；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、可以在请求的url中带上参数，如&quot;add.htm?id=122&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 怎么选择是重定向还是转发呢？通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 06:51:00 +0000</pubDate>
<dc:creator>一缕青烟m</dc:creator>
<og:description>在进行web开发时，跳转是最常见的，今天在这里来学习下2种跳转： 第一种是request.getRequestDispatcher().forward(request,response)： 1、属于转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mqflive81/p/10774249.html</dc:identifier>
</item>
<item>
<title>小试小程序云开发 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10774240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10774240.html</guid>
<description>&lt;p&gt;微信小程序刚出没多久时，曾经上手写过demo，但开发体验比较差，所以一直没怎么关注。不过自从诸多适配方案出炉，以及云端的开通，觉得还是有必要上手体验一番的，于是为我的技术博客也写了个小程序版。&lt;/p&gt;
&lt;p&gt;原生开发我是不想再试了，那就选一种适配方案，目前比较知名的有基于vue的 &lt;strong&gt;mpvue&lt;/strong&gt;，&lt;strong&gt;umi-app&lt;/strong&gt;，基于react 的 &lt;strong&gt;taro&lt;/strong&gt;，以及TX团体出的全新框架 &lt;strong&gt;wepy&lt;/strong&gt;。个人对 react 的好感 以及 &lt;strong&gt;taro&lt;/strong&gt; 框架的走向成熟，促使我选择了 taro。&lt;/p&gt;
&lt;p&gt;云端开发就是将普通小程序的传统后端切换为微信提供的 轻量级云端。而这个云端服务部分的开发其实是针对前端开发的，前端工程师很容易就能全栈开发出一整个小程序。但是这种轻量级解决方案也只是针对业务简单的项目，因为公共平台肯定有各种限制，它的出现只是让我们多了一个选择方案而已。&lt;/p&gt;
&lt;p&gt;接着进入主题，项目大体目录结构如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;client #前端目录
├── config #配置
├── dist #输出
├── src #源目录
└── index.html #入口文件
cloud #云目录
├── dao #数据库操作函数集合
├── login #登录云函数
└── ... #其他&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;前端&quot;&gt;前端&lt;/h2&gt;
&lt;p&gt;小程序的前端部分，想必不用过多讲解，因为这都是前端的基本功。就以首页为样例，使用了&lt;strong&gt;typeScript&lt;/strong&gt;，主要功能是分页加载数据，调用微信提供的触发到达底部的api，&lt;strong&gt;onReachBottom&lt;/strong&gt;即可。 taro 相关部分的使用请看 &lt;strong&gt;&lt;a href=&quot;https://nervjs.github.io/taro/docs/README.html&quot;&gt;taro&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;import Taro, { Component, Config } from &quot;@tarojs/taro&quot;;
import { View, Text, Navigator } from &quot;@tarojs/components&quot;;
import &quot;./index.scss&quot;;

interface IState {
  loading: boolean;
  size: number;
  page: number;
  total: number;
  list: Array&amp;lt;{ _id: string; summary: object }&amp;gt;;
  context:object;
}
export default class Index extends Component&amp;lt;{}, IState&amp;gt; {
  state = {
    loading: false,
    size: 10,
    page: 0,
    total: -1,
    list: [],
    context:{}
  };
  config: Config = {
    navigationBarTitleText: &quot;Jeff's Blog&quot;,
    onReachBottomDistance: 50
  };

  componentWillMount() {
    this.getList();
    this.getLogin();
  }

  getDbFn(fn, param) {
    return Taro.cloud.callFunction({
      name: &quot;dao&quot;,
      data: { fn, param }
    });
  }

  onReachBottom() {
    this.getList();
  }
  
  getList() {
    const { size, page, total, loading } = this.state;
    if (loading) return;
    Taro.showLoading({ title: 'loading', });
    if (total &amp;gt;= 0 &amp;amp;&amp;amp; size * page &amp;gt;= total) return;
    this.setState({ loading: true });
    this.getDbFn(&quot;getList&quot;, { size, page: page + 1 }).then(res =&amp;gt; {
      Taro.hideLoading();
      const total = res.result.total;
      const list = this.state.list.concat(res.result.list);
      this.setState({ loading: false, page: page + 1, total, list });
    }).catch(err =&amp;gt; {
      Taro.hideLoading();
      this.setState({ loading: false });
    });
  }

  onShareAppMessage (res) {
    return {
      title: &quot;Jeff's Blog&quot;,
      path: '/pages/index/index'
    }
  }
  
  render() {
    return (
      &amp;lt;View className='container'&amp;gt;
        {this.state.list.map(l =&amp;gt; (
          &amp;lt;View className='item' key={l._id}&amp;gt;
            &amp;lt;Navigator url={'/pages/post/post?id=' + l._id}&amp;gt;
              &amp;lt;Image className='banner' mode='widthFix' src={l.summary.banner} /&amp;gt;
              &amp;lt;View className='title'&amp;gt;{l.summary.title}&amp;lt;/View&amp;gt;
            &amp;lt;/Navigator&amp;gt;
            &amp;lt;View className='sub-title'&amp;gt;
              {l.summary.tags.map(t =&amp;gt; (
                &amp;lt;Navigator className='tag' url={'/pages/list/list?tag=' + t}&amp;gt; {t} &amp;lt;/Navigator&amp;gt;
              ))}
              &amp;lt;Text className='time'&amp;gt;{l.summary.date}&amp;lt;/Text&amp;gt;
            &amp;lt;/View&amp;gt;
          &amp;lt;/View&amp;gt;
        ))}
      &amp;lt;/View&amp;gt;
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与普通小程序不同的地方就是调用云端，云函数调用如官方样例所示&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;getLogin(){
   Taro.cloud.callFunction({
      name: &quot;login&quot;,
      data: {}
   }).then(res =&amp;gt; {
      this.setState({ context: res.result });
   }).catch(err=&amp;gt;{
   });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;云端&quot;&gt;云端&lt;/h2&gt;
&lt;p&gt;云端数据库是个文档型，操作风格与&lt;strong&gt;mongodb&lt;/strong&gt;如出一辙，格式自然是json。最有用的还是操作数据库的部分，操作方法都已经 &lt;strong&gt;Promise&lt;/strong&gt; 化，调用还是比较方便的。具体内容请查看文档: &lt;strong&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html&quot;&gt;小程序云开发&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//数据库引用
const db = wx.cloud.database()
//获取数据集合
const todos = db.collection('todos')

//获取记录数
todos.count();
//条件查找
todos.where({done: false,progress: 50}).get()

//插入
todos.add({data: {content:'11',time:new Date()}},success:(res){});

//更新
todos.doc('todo').update({ data: { done: true}},success:(res){});

//删除
todos.where({done:true}).remove();

//分页查找
todos.orderBy('time','desc')
    .skip(start)
    .limit(size)
    .get();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;云函数&quot;&gt;云函数&lt;/h3&gt;
&lt;p&gt;调用云端的方式就要使用云函数，就以下面数据库操作库为例&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 云函数入口文件
const cloud = require(&quot;wx-server-sdk&quot;);
cloud.init();

// 云函数入口函数
exports.main = async (event, context) =&amp;gt; {
    const { fn, param } = event;
    return dao[fn](param);
};
// 调用数据库
const db = cloud.database();
// 表
const posts = db.collection(&quot;posts&quot;);
const tags = db.collection(&quot;tags&quot;);
const dao = {
    async getList({ page = 1, size = 10 }) {
        const start = (page - 1) * size;
        try {
            const { total } = await posts.count();
            const { data } = await posts
                .field({ summary: true })
                .orderBy('num','desc')
                .skip(start)
                .limit(size)
                .get();
            return {
                code: 0,
                list: data,
                total,
                message: &quot;sucess&quot;
            };
        } catch (err) {
            return {
                code: -1,
                list: [],
                total: -1,
                err: err,
                message: &quot;error&quot;
            };
        }
    },
    getPost({ id }) {
        return posts.doc(id).get();
    },
    async getTagList({ tag }) {
        try{
            const { data } = await tags.where({ name: tag }).get();
            if(!data.length){ 
                return {
                    code:0,
                    list:[],
                    message: &quot;success&quot;
                };
            } 
            const list = data[0].list.sort((a,b) =&amp;gt; b.num - a.num);
            return {
                code:0,
                list:list,
                message: &quot;success&quot;
            };
        } catch(err){
            return {
                code: -1,
                list:[],
                err: err,
                message: &quot;error&quot;
            };
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将操作数据库的所有云函数合并成一个文件，将云函数入口封装一下，即把函数名字和参数都做完参数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;exports.main = async (event, context) =&amp;gt; {
    const { fn, param } = event;
    return dao[fn](param);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应前端部分也封装出一个调用数据库的方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  getDbFn(fn, param) {
    return Taro.cloud.callFunction({
      name: &quot;dao&quot;,
      data: { fn, param }
    });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;云端部分开发完之后，在微信开发者工具里面上传云端代码即可，而其余部分的流程和普通小程序一样，这里也不再介绍。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;小程序部分的开发还是比较简单的，我开发的大部分时间其实是用在写 &lt;strong&gt;markdown&lt;/strong&gt; 转 &lt;strong&gt;wxml&lt;/strong&gt; 解析器上。下一篇讲解如何将 markdown 转换为 wxml 。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 06:51:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>微信小程序刚出没多久时，曾经上手写过demo，但开发体验比较差，所以一直没怎么关注。不过自从诸多适配方案出炉，以及云端的开通，觉得还是有必要上手体验一番的，于是为我的技术博客也写了个小程序版。 原生开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10774240.html</dc:identifier>
</item>
<item>
<title>刨根问底：对象也可以当方法用？ - 丹枫无迹</title>
<link>http://www.cnblogs.com/gl1573/p/10774182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gl1573/p/10774182.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;41&quot;&gt;
&lt;h2 id=&quot;h1&quot;&gt;&lt;span&gt;1、问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我刚开始接触爬虫的时候，只是看完了 python 的基础，对 python 的语法还没有一个很深入的了解，在使用 bs4 这个库的时候，对其中某些语法感到非常的惊奇，不明白是怎么实现的。&lt;/p&gt;
&lt;p&gt;bs4 的官方文档中说到：&lt;code&gt;find_all()&lt;/code&gt; 几乎是 Beautiful Soup 中最常用的搜索方法，所以我们定义了它的简写方法。&lt;code&gt;BeautifulSoup&lt;/code&gt; 对象和 &lt;code&gt;tag&lt;/code&gt; 对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的 &lt;code&gt;find_all()&lt;/code&gt; 方法相同，下面两行代码是等价的:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs apache&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;soup&lt;/span&gt;.find_all(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;soup&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;soup&lt;/code&gt; 是一个 &lt;code&gt;BeautifulSoup&lt;/code&gt; 对象，&lt;code&gt;soup(&quot;a&quot;)&lt;/code&gt; 这很明显是把对象当方法使用了，这是怎么做到的呢？&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;&lt;span&gt;2、实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在 Python 中，除了用户定义的函数，调用运算符（即 ()）还可以应用到其他对象上。内置的 &lt;code&gt;callable()&lt;/code&gt; 函数用来判断一个对象能否调用。就是说，任何 Python 对象都可以表现得像函数一样，为此，只需实现实例方法 &lt;code&gt;__call__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看一个简单的示例：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sum&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, x, y)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;self._x = x&lt;br/&gt;self._y = y&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self._x + self._y&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__call__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.add()&lt;/p&gt;&lt;p&gt;sum = Sum(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;print(sum.add())&lt;br/&gt;print(sum())&lt;br/&gt;print(callable(sum))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就明白了，bs4 中亦是如此，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Tag&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;PageElement&lt;/span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__call__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, *args, **kwargs)&lt;/span&gt;&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.find_all(*args, **kwargs)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这背后涉及到的概念叫做&lt;strong&gt;可调用对象&lt;/strong&gt;，Python 数据模型文档列出了 7 种可调用对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用户定义的函数&lt;/strong&gt;：使用 def 语句或 lambda 表达式创建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内置函数&lt;/strong&gt;：使用 C 语言（CPython）实现的函数，如 len 或 time.strftime。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内置方法&lt;/strong&gt;：使用 C 语言实现的方法，如 dict.get。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：在类的定义体中定义的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类&lt;/strong&gt;：调用类时会运行类的 &lt;code&gt;__new__&lt;/code&gt; 方法创建一个实例，然后运行 &lt;code&gt;__init__&lt;/code&gt; 方法，初始化实例，最后把实例返回给调用方。因为 Python 没有 &lt;code&gt;new&lt;/code&gt; 运算符，所以调用类相当于调用函数。（通常，调用类会创建那个类的实例，不过覆盖 &lt;code&gt;__new__&lt;/code&gt; 方法的话，也可能出现其他行为。）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的实例&lt;/strong&gt;：如果类定义了 &lt;code&gt;__call__&lt;/code&gt; 方法，那么它的实例可以作为函数调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成器函数&lt;/strong&gt;：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 26 Apr 2019 06:41:00 +0000</pubDate>
<dc:creator>丹枫无迹</dc:creator>
<og:description>你知道怎么把对象当方法用吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gl1573/p/10774182.html</dc:identifier>
</item>
<item>
<title>【原】js数组对象去重最简单的方法 - 白树</title>
<link>http://www.cnblogs.com/PeunZhang/p/10773351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PeunZhang/p/10773351.html</guid>
<description>&lt;p&gt;简单的数组去重是比较简单的，方法也特别多，如给下面的数组去重：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let arr = [1,2,2,4,9,6,7,5,2,3,5,6,5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最常用的可以用for循环套for循环，再用splice删除重复的数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let arrUnique = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (arr){            
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=0; i&amp;lt;arr.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let j=i+1; j&amp;lt;arr.length; j++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i]==arr[j]){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个等同于第二个，splice方法删除第二个&lt;/span&gt;
                    arr.splice(j,1&lt;span&gt;);
                    j&lt;/span&gt;--&lt;span&gt;;
                }
            }
        }
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而数组的子集为对象时，一般不使用多个for循环来去重，如下面的数组对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let arr = [
    {
        &lt;/span&gt;mch_id:'ghx1'&lt;span&gt;,
        &lt;/span&gt;status: 1&lt;span&gt;,
        &lt;/span&gt;type: 2&lt;span&gt;
    },
    {
        &lt;/span&gt;mch_id:'awx2'&lt;span&gt;,
        &lt;/span&gt;status: 2&lt;span&gt;,
        &lt;/span&gt;type: 3&lt;span&gt;
    },
    {
        &lt;/span&gt;mch_id:'ghx1'&lt;span&gt;,
        &lt;/span&gt;status: 1&lt;span&gt;,
        &lt;/span&gt;type: 2&lt;span&gt;
    },
    {
        &lt;/span&gt;status: 1&lt;span&gt;,
        &lt;/span&gt;type: 2&lt;span&gt;,
        &lt;/span&gt;mch_id:'ghx1'&lt;span&gt;
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过观察，我们可以发现该数组中的第1、3、4项其实是一样的，最初在谷歌找了几个方法最终都不太满意，比如会改变数组中对象原来的排序、数组去重失败等，后来经过多次尝试和实践，得出以下最简单的方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;利用对象的键名无法重复的特点&lt;/strong&gt;&lt;span&gt;，我们可以新建一个临时对象来存储原数组中的对象子集的值，比如我的项目中mch_id是唯一的ID，然后设置的它为临时对象的键名，值为true即可，保证它的唯一性&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过判断对象的键名是唯一时，把对应的数组值添加到一个空数组中，最终得到一个去重后的数组对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;此方法不会改变数组对象原有的排序&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let arrUnique = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr){
    let result &lt;/span&gt;=&lt;span&gt; {};
    let finalResult&lt;/span&gt;=&lt;span&gt;[];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用对象的键名无法重复的特点，cpmch_id是唯一区别的属性值&lt;/span&gt;
        result[arr[i].mch_id] ? '' : result[arr[i].mch_id] = &lt;span&gt;true&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; finalResult.push(arr[i]);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; finalResult;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者利用ES5数组方法reduce&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let arrUnique = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arr){
    let ojb &lt;/span&gt;=&lt;span&gt; {};
    arr &lt;/span&gt;= arr.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(prevArr, currentItem) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用对象的键名无法重复的特点，mch_id是唯一区别的属性值&lt;/span&gt;
        ojb[currentItem.mch_id] ? '' : ojb[currentItem.mch_id] = &lt;span&gt;true&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; prevArr.push(currentItem);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prevArr
    }, [])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 提前祝大家劳动节快乐&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 06:39:00 +0000</pubDate>
<dc:creator>白树</dc:creator>
<og:description>简单的数组去重是比较简单的，方法也特别多，如给下面的数组去重： 最常用的可以用for循环套for循环，再用splice删除重复的数组： 然而数组的子集为对象时，一般不使用多个for循环来去重，如下面的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PeunZhang/p/10773351.html</dc:identifier>
</item>
</channel>
</rss>