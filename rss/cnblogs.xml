<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开发阶段，将SpringBoot应用快速部署到K8S - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14142009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14142009.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对于生产环境，我们一般会用CI&amp;amp;&amp;amp;CD工具完成整个构建和部署，因此本文不适合生产环境；&lt;/li&gt;
&lt;li&gt;对于学习和开发环境，我们频繁修改代码，又想快速见到效果，本文就是针对这种场景的；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;内容简介&quot;&gt;内容简介&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您正在开发SpringBoot应用，并且应用部署在K8S环境，可以参考本文将应用快速部署到K8S环境；&lt;/li&gt;
&lt;li&gt;文中SpringBoot的版本是2.3.0.RELEASE，从该版本起，SpringBoot官方推荐了一种新的docker镜像构建方案，如果您是之前的版本，请自行修改文中构建镜像的部分；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;p&gt;本次实战有两个环境：开发和运行环境，其中开发环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：Ubuntu 20.04 LTS 桌面版（同样验证过的还有：MacBook pro 13寸，macOS Catalina 10.15.4）&lt;/li&gt;
&lt;li&gt;CPU ：2.30GHz × 4，内存：32G，硬盘：1T NVMe&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_231&lt;/li&gt;
&lt;li&gt;MAVEN：3.6.3&lt;/li&gt;
&lt;li&gt;SpringBoot：2.3.0.RELEASE&lt;/li&gt;
&lt;li&gt;Docker：19.03.10&lt;/li&gt;
&lt;li&gt;开发工具：IDEA 2020.1.1 (Ultimate Edition)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运行环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.8.2003&lt;/li&gt;
&lt;li&gt;Kubernetes：1.15&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外，请在开发环境安装sshpass；&lt;/p&gt;
&lt;h3 id=&quot;springboot工程源码&quot;&gt;SpringBoot工程源码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本次实战用到了一个普通的SpringBoot工程，源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;probedemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201216083010491-1416173148.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;必要的内容&quot;&gt;必要的内容&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;整个工程是普通SpringBoot工程，除了常见的pom.xml和源码，还多了以下三个文件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201216083011269-351386318.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Dockerfile文件用来构建docker镜像，如果您的SpringBoot版本为2.3.0.RELEASE或者更高，建议使用SpringBoot官方推荐的镜像构建方式，此Dockerfile可以用来参考；&lt;/li&gt;
&lt;li&gt;和probedemo.yaml文件和您的具体项目有关，请自行修改，确保可以用来部署deployment和service；&lt;/li&gt;
&lt;li&gt;auto_deploy.sh是可以快速部署的关键，接下来详细说明；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;auto_deploysh详述&quot;&gt;auto_deploy.sh详述&lt;/h3&gt;
&lt;p&gt;auto_deploy.sh的作用如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用maven命令编辑构建工程；&lt;/li&gt;
&lt;li&gt;将构建好的jar文件制作成docker镜像；&lt;/li&gt;
&lt;li&gt;将docker镜像导出为tar文件；&lt;/li&gt;
&lt;li&gt;将tar文件上传到K8S服务器；&lt;/li&gt;
&lt;li&gt;将probedemo.yaml文件发送到K8S服务器；&lt;/li&gt;
&lt;li&gt;通过sshpass远程执行命令，将docker镜像导入K8S服务器的本地docker仓库；&lt;/li&gt;
&lt;li&gt;通过sshpass远程执行命令，部署deployment和service；&lt;/li&gt;
&lt;li&gt;auto_deploy.sh的完整内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#!/bin/bash

# 判断是否安装了sshpass
if ! [ -x &quot;$(command -v sshpass)&quot; ]; then
  echo '请安装sshpass后再使用此脚本！'
  exit 1
fi

# 镜像名
IMAGE_NAME='bolingcavalry/probedemo'

# TAG名
TAG_NAME='0.0.1'

# 配置了deployment和service的yaml文件名
DEPLOY_SERVICE_YAML='probedemo.yaml'

# K8S环境的IP地址
K8S_IP_ADDRESS='192.168.50.135'

# K8S环境的SSH账号
K8S_SSH_ACCOUNT='root'

# 8S环境的SSH密码
K8S_SSH_PSWD='888888'

# K8S上存放tar和yaml文件的位置
K8S_FILE_PATH='~/deploy_temp'

# 当前名目录
CURRENT_DIR=`pwd`

echo '开始自动构建和部署，当前目录是：'${CURRENT_DIR}

# 执行maven命令构建项目
mvn clean package -U -DskipTests

echo &quot;构建镜像文件：&quot;${IMAGE_NAME}/${TAG_NAME}
docker build -t ${IMAGE_NAME}/${TAG_NAME} .

echo &quot;将镜像导出为tar文件：&quot;${IMAGE_NAME}/${TAG_NAME}
docker save ${IMAGE_NAME}/${TAG_NAME} &amp;gt; ${CURRENT_DIR}/image.tar

echo &quot;在K8S服务器创建存放文件的目录：&quot;${K8S_FILE_PATH}
sshpass -p ${K8S_SSH_PSWD} ssh ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS} &quot;mkdir -p ${K8S_FILE_PATH}&quot;

echo &quot;将yaml文件发送到K8S服务器：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} scp ${CURRENT_DIR}/${DEPLOY_SERVICE_YAML} ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS}:${K8S_FILE_PATH}/

echo &quot;将镜像tar文件发送到K8S服务器：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} scp ${CURRENT_DIR}/image.tar ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS}:${K8S_FILE_PATH}/

echo &quot;如果K8S环境之前已经部署过，就先清理：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} ssh ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS} &quot;kubectl delete -f ${K8S_FILE_PATH}/${DEPLOY_SERVICE_YAML}&quot;

echo &quot;等待10秒&quot;
sleep 10

echo &quot;清理之前加载到本地仓库的镜像：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} ssh ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS} &quot;docker rmi ${IMAGE_NAME}/${TAG_NAME}&quot;

echo &quot;从tar文件加载镜像：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} ssh ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS} &quot;docker load &amp;lt; ${K8S_FILE_PATH}/image.tar&quot;

echo &quot;部署：&quot;${IMAGE_NAME}/${TAG_NAME}
sshpass -p ${K8S_SSH_PSWD} ssh ${K8S_SSH_ACCOUNT}@${K8S_IP_ADDRESS} &quot;kubectl apply -f ${K8S_FILE_PATH}/${DEPLOY_SERVICE_YAML}&quot;

echo &quot;删除tar文件：&quot;${CURRENT_DIR}/image.tar
rm -rf ${CURRENT_DIR}/image.tar

echo &quot;删镜像：&quot;${IMAGE_NAME}/${TAG_NAME}
docker rmi ${IMAGE_NAME}/${TAG_NAME}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实验&quot;&gt;实验&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请按照自己的实际情况，修改auto_deploy.sh中变量的值，例如K8S环境地址、账号密码等；&lt;/li&gt;
&lt;li&gt;开发阶段，修改java代码完成；&lt;/li&gt;
&lt;li&gt;执行脚本auto_deploy.sh；&lt;/li&gt;
&lt;li&gt;控制台提示如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201216083012997-474009821.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;部署已经完成，可以验证功能了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;本次实战更新镜像的方法是本地导出为tar，再传到K8S环境去导入，当K8S环境有多台机器时就不适合这样作了，建议使用私有镜像仓库，将镜像push到仓库，然后K8S中镜像仓库pull镜像；&lt;/p&gt;
&lt;p&gt;至此，SpringBoot应用快速部署到K8S的实战就完成了，这是我开发过程中常用的远程部署手段，希望能给您提供一些参考；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Dec 2020 00:30:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14142009.html</dc:identifier>
</item>
<item>
<title>为什么项目开发永远缺乏合理的时间？ - 羽商宫</title>
<link>http://www.cnblogs.com/wlzcool/p/14142005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlzcool/p/14142005.html</guid>
<description>&lt;p&gt;在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大。导致这种普遍性灾难的原因是什么呢？&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.期望一切运转良好&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，如何进行合理的估算，建立在一种悄无声息，但并不真实的假设之上——一切都将运作良好。但是从来不可能有这种一切运作良好的项目存在，&lt;/p&gt;
&lt;p&gt;因为执行者是人，而人就会犯错，理解偏差，对原有代码的不了解，无效沟通等等诸多问题都会在执行者身上出现。&lt;/p&gt;
&lt;p&gt;毕竟对于各种千奇百怪的需求，除非是之前做过，否则，你永远不知道会遇到什么问题，一句隐藏在需求文档中某个旮旯角的话语，有可能就要耗掉一个技术2天甚至3天的时间。&lt;/p&gt;

&lt;p&gt;而这，往往会在需求评审时被有意无意的忽略掉，毕竟最重要的需求评审在当前的需求开发中&lt;/p&gt;
&lt;p&gt;往往会被要求尽量缩短时间，“产品已经设计完了，你们技术尽快开始，月底上线，没问题吧！”&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.混淆进度与工作量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二，我们采用的估算技术隐含地假设人和月可以互换，错误地将进度与工作量相互&lt;/p&gt;
&lt;p&gt;混淆。一个锅蒸一个包子需要3分钟，那么三个锅蒸一个包子呢，难道只需要一分钟么？&lt;/p&gt;
&lt;p&gt;当业务耦合度非常高的时候，某块任务往往只能交给一人来写，不然随之带来的沟通成本&lt;/p&gt;
&lt;p&gt;以及联合调试成本经常使得增加的人力做的更多的是无用功。但是往往上级领导为了表示对项目的重视，通常会向项目中增加人员，而增加的人员往往也是一头雾水，面对大量的代码无从下手，毕竟编程不是垒砖，需要在了解原有项目的基础上进行工作。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.估算无法贯穿始终&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为需求工期一般是是估算，不是精确地计算，项目经理通常不会有耐心持续地进行估算这项工作。当项目中某个模块遇到棘手问题时，往往无法估算具体解决时间，即使估算后也无法增加时间，毕竟月底上线的要求犹在耳边回荡，这时候去要时间很可能换来的只有一句话“要时间没有，你们周六日加班吧！”。&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;4.进度缺少跟踪和监督&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他工程领域中，经过验证的跟踪技术和常规监督程序，在软件工程中常常被认为是无谓的举动。但是在软件工程方面，跟踪往往也是无效果，毕竟大多数企业加需求就像喝水一样轻松。领导知道不能让玻璃幕墙换成瓷砖，但是提的这个软件功能点需要多少时间，那可就没领导知道了。临到上线，领导打开网站一看，提几个新需求，往往就是几个不眠不休的日子。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;5.错误的解决方案带来的反效果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当项目经理意识到进度的偏移时，下意识（以及传统）的反应是增加人力以及加班。&lt;/p&gt;
&lt;p&gt;方向错了，努力再多也是白费。新加入的人员往往需要一段时间才能形成战斗力，而长时间的加班往往带来的是员工的精神和身体上的疲倦，这两者往往都是饮鸩止渴。&lt;/p&gt;

&lt;p&gt;为什么项目开发永远缺乏合理的时间？上面五点之中有没有你们延期的理由？&lt;/p&gt;
</description>
<pubDate>Wed, 16 Dec 2020 00:28:00 +0000</pubDate>
<dc:creator>羽商宫</dc:creator>
<og:description>在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大。导致这种普遍性灾难的原因是什么呢？ 1.期望一切运转良好 首先，如何进行合理的估算，建立在一种悄无声息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wlzcool/p/14142005.html</dc:identifier>
</item>
<item>
<title>数据类型第2篇「字典和集合的原理和应用」 - 清菡</title>
<link>http://www.cnblogs.com/qinghan123/p/14141949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinghan123/p/14141949.html</guid>
<description>&lt;h2 id=&quot;坚持原创输出，点击蓝字关注我吧&quot;&gt;坚持原创输出，点击蓝字关注我吧&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215163131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：清菡&lt;br/&gt;博客：oschina、云+社区、知乎等各大平台都有。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于微信公众号推送改为了信息流的形式，防止走丢，请给加个星标 ⭐，你就可以第一时间接收到本公众号的推送！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;一、集合
&lt;ul&gt;&lt;li&gt;1.定义个有元素的集合&lt;/li&gt;
&lt;li&gt;2.自动去重&lt;/li&gt;
&lt;li&gt;3.集合常用的五个方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二、集合和字典都是无序的&lt;/li&gt;
&lt;li&gt;三 、字典和集合都是无序的，在内存中是怎么存储？
&lt;ul&gt;&lt;li&gt;1.为什么说字典和集合是无序的？&lt;/li&gt;
&lt;li&gt;2.字典查找值的过程&lt;/li&gt;
&lt;li&gt;3.Python 里基础数据类型分为三大类&lt;/li&gt;
&lt;li&gt;4.为什么会出现散列冲突？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;四、可变和不可变元素：可哈希和不可哈希
&lt;ul&gt;&lt;li&gt;1.可变类型的数据不可进行哈希运算，不可变的数据类型可进行哈希运算&lt;/li&gt;
&lt;li&gt;2.集合为什么无序？&lt;/li&gt;
&lt;li&gt;3.散列类型为什么是无序的？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;五、性能分析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;本篇文章：重点掌握集合的用法即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字典，大家都用得特别多，花括号包起来的，一个键一个值构成一个元素。&lt;strong&gt;集合和字典的表达形式是一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典和集合在 Python 中都是使用花括号进行表示的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、集合&quot;&gt;一、集合&lt;/h2&gt;
&lt;h3 id=&quot;1定义个有元素的集合&quot;&gt;1.定义个有元素的集合&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;set1 = {1,2,3}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;集合和字典相比，集合里面只有值，没有键。&lt;/p&gt;
&lt;h3 id=&quot;2自动去重&quot;&gt;2.自动去重&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集合有个比较强大的功能：自动去重。&lt;/strong&gt; 里面不会存在重复的元素，&lt;strong&gt;集合最常见的应用就是对列表去重。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;21-把字典转换成集合，再转换回字典，它会真去重&quot;&gt;2.1 把字典转换成集合，再转换回字典，它会真去重&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;set1 = {1,2,3,3,3,4,4,4,4,4}
print(set1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215111057.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打印出来是集合，重复的元素自动过滤掉了。定义的时候，不管定义多少个重复元素，都自动过滤掉了。&lt;/p&gt;
&lt;h4 id=&quot;22-用集合对列表去重&quot;&gt;2.2 用集合对列表去重&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;li = [1,1,1,2,2,2,3,3,3] # 利用集合对列表去重
li2 = list(set(li))
print(li2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先把列表转换成一个集合，自动把里面的重复元素给去除掉了，再转换回列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215112111.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集合在 Python 中是用得比较少的数据类型。&lt;/p&gt;
&lt;h3 id=&quot;3集合常用的五个方法&quot;&gt;3.集合常用的五个方法&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;add()&lt;/th&gt;
&lt;th&gt;添加元素&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;update()&lt;/td&gt;
&lt;td&gt;更新元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;删除元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;clear()&lt;/td&gt;
&lt;td&gt;清空里面所有的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;copy()&lt;/td&gt;
&lt;td&gt;复制元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;集合，它里面的元素是无序的。可以修改，集合是可变类型的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;31-空集合中怎么添加元素？&quot;&gt;3.1 空集合中怎么添加元素？&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;add()&lt;/code&gt;方法，每次可以往里面添加一个数据进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;se = set()  # 空集合
# 集合添加数据
se.add('qinghan') # 一次只能添加一个，所以只添加了一个qinghan
print(se)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215113137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;32-删除用-remove&quot;&gt;3.2 删除用 remove()&lt;/h4&gt;
&lt;p&gt;集合可以添加也可以删除。删除用&lt;code&gt;remove()&lt;/code&gt;，传入对应的元素就可以进行删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215113645.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集合还可以做交集、并集这样的操作，这个对我们用处不大。&lt;/p&gt;
&lt;h4 id=&quot;33update-更新元素&quot;&gt;3.3update() 更新元素&lt;/h4&gt;
&lt;p&gt;跟字典的&lt;code&gt;update()&lt;/code&gt;一样的。 它是将一个集合更新到这个集合里面，可以往里面一次加入多个元素。&lt;/p&gt;
&lt;p&gt;通过这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;se = set()  # 空集合
se.update({111,22,33,44})
print(se)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以一次更新进去多个元素。&lt;/p&gt;
&lt;p&gt;看&lt;code&gt;update&lt;/code&gt;的源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215115657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接收的是不定量参数，可以传一个也可以传多个。&lt;/p&gt;
&lt;p&gt;可以往里面加元组、列表、字符串，但是一般用的时候选择用集合，将一个集合更新到原来的集合里面。&lt;/p&gt;
&lt;h3 id=&quot;34clear清空元素&quot;&gt;3.4clear()清空元素&lt;/h3&gt;
&lt;p&gt;还有个常用的方法：&lt;code&gt;clear()&lt;/code&gt;清空里面所有的元素。&lt;/p&gt;
&lt;h3 id=&quot;35-copy复制元素&quot;&gt;3.5 copy()复制元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;copy() # 做一个复制的&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、集合和字典都是无序的&quot;&gt;二、集合和字典都是无序的&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215121810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python 里面把它称作散列类型。&lt;/p&gt;
&lt;p&gt;Python 更新到 3.7 之后，字典出现一个新的特性：&lt;strong&gt;3.7 之前的字典是无序的。3.7 之后字典中元素的顺序，它会按你依次添加的顺序进行保存。现在字典，里面的元素实际上是有序的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方文档已声明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215122415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-、字典和集合都是无序的，在内存中是怎么存储？&quot;&gt;三 、字典和集合都是无序的，在内存中是怎么存储？&lt;/h2&gt;
&lt;p&gt;dict 与 set 实现原理是一样的，都是将实际的值放到 list 中。&lt;/p&gt;
&lt;p&gt;唯一不同的在于 hash 函数操作的对象，对于 dict，hash 函数操作的是其 key，而对于 set 是直接操作的它的元素。&lt;/p&gt;
&lt;p&gt;假设操作内容为 x，其作为因变量，放入 hash 函数，通过运算后取 list 的余数，转化为一个 list 的下标，此下标位置对于 set 而言用来放其本身。&lt;/p&gt;
&lt;p&gt;而对于 dict 则是创建了两个 list，一个 list 该下表放此 key，另一个 list 中该下标对应的 value。&lt;/p&gt;
&lt;p&gt;其中，我们把实现 set 的方式叫做 Hash Set，实现 dict 的方式叫做 Hash Map/Table（注：map 指的是通过 Key 来寻找 value 的过程）。&lt;/p&gt;
&lt;h3 id=&quot;1为什么说字典和集合是无序的？&quot;&gt;1.为什么说字典和集合是无序的？&lt;/h3&gt;
&lt;h4 id=&quot;11-字典和集合底层都是存储在列表里面&quot;&gt;1.1 字典和集合底层都是存储在列表里面&lt;/h4&gt;
&lt;p&gt;一个字典，在存储的时候，会拆分成 2 部分，会存在 2 个列表里面，一个列表存键，一个列表存值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215125858.png&quot; alt=&quot;字典存储时的拆分&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;12-怎么通过-key-找到对应的-value-值呢？&quot;&gt;1.2 怎么通过 Key 找到对应的 Value 值呢？&lt;/h4&gt;
&lt;p&gt;字典在存储之前，做了个 Hash 操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215124924.png&quot; alt=&quot;Hash操作如图，图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿到字典的键，进行哈希操作。通过对应的哈希算法，然后得出一串数字。&lt;/p&gt;
&lt;p&gt;拿哈希出来的值除以内存分出来的列表的长度，得到余数。这个余数当成对应元素的下标。把键和值通过下标存在列表中对应的位置。&lt;/p&gt;
&lt;h4 id=&quot;13-散列类型的存储过程&quot;&gt;1.3 散列类型的存储过程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215125422.png&quot; alt=&quot;散列类型的存储过程，图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列类型的意思就是无序的。&lt;/strong&gt; 散列就是哈希。散列内部元素是无序的。&lt;/p&gt;
&lt;p&gt;刚开始内存分了 12 个格子存数据，哈希后，第一个元素得出的余数是 6，有 2 个列表，会把键存在对应的列表里面，把值存在对应的 6 的位置。&lt;/p&gt;
&lt;p&gt;散列表存储数据很松散，不像列表完整得排过来的。散列表里面是分散存储的，会把对应的键存到一个散列表里面。&lt;/p&gt;
&lt;p&gt;查找字典中元素的时候，首先它会拿到你这个键，同样进行哈希运算。运算完毕后得出一个值，然后去散列表里面找对应的键。找到对应的键，然后比较下是不是这个键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典哈希的是它的键，不是它的值。集合是哈希的它的值，所以集合里面的值是不可变类型的，不能有可变类型的值。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2字典查找值的过程&quot;&gt;2.字典查找值的过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215140153.png&quot; alt=&quot;字典查找值的过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;散列值就是哈希值。拿到键名，进行哈希，哈希过后得到散列值。&lt;/p&gt;
&lt;p&gt;拿到散列值进行相应的运算，然后拿到表元。表元是在散列表中的一个序号。&lt;/p&gt;
&lt;h4 id=&quot;21-第一种情况&quot;&gt;2.1 第一种情况&lt;/h4&gt;
&lt;p&gt;比如序号是 6，看 6 里面存的这个键，跟你刚才输进来查找的那个键是不是一样的。&lt;/p&gt;
&lt;p&gt;如果是一样的，键相等，会返回表元里面对应的值，会给你找到你所存储的字典的值。&lt;/p&gt;
&lt;p&gt;如果它在这里没找到值的话，这个时候会抛出异常。（也就是字典通过键去找值，没找到的时候就会抛出错误。）&lt;/p&gt;
&lt;h4 id=&quot;22-第二种情况&quot;&gt;2.2 第二种情况&lt;/h4&gt;
&lt;h5 id=&quot;散列冲突：&quot;&gt;散列冲突：&lt;/h5&gt;
&lt;p&gt;每个元素哈希出来的结果是不一样的。如图，第一个元素计算出来是 6，会找到散列表中第 6 个格子。第二个值，运算之后，如果得出来的也是个 6，那么这个时候就会起散列冲突。&lt;/p&gt;
&lt;h6 id=&quot;解决散列冲突有二种方案：&quot;&gt;解决散列冲突有二种方案：&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有散列冲突的时候，会对散列表进行扩容，扩容后进行重新排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在后面再加个列表。这样的话，第一个元素计算出来是 6，会找到散列表中第 6 个格子。&lt;/p&gt;
&lt;p&gt;第二个值，运算之后，如果得出来的也是个 6，因为加了一个列表（这个列表可存储多个值），就不会起散列冲突了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上是字典，散列类型底层存储。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3python-里基础数据类型分为三大类&quot;&gt;3.Python 里基础数据类型分为三大类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一类，数值类型：&lt;/strong&gt; 1 一个数只有单个元素，像这个 1 就是 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二类，序列类型：&lt;/strong&gt; 字符串、列表、元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三类，散列类型：&lt;/strong&gt; 字典、集合。 特征：内部元素是无序的。&lt;/p&gt;
&lt;h3 id=&quot;4为什么会出现散列冲突？&quot;&gt;4.为什么会出现散列冲突？&lt;/h3&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215144551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个数据通过哈希，计算散列值，取余后拿到的余数，如果是一样的话，在储存值的时候，就会造成散列冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215145051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过字典的键去哈希，把哈希值存在散列表里面。通过对应的键，然后找到列表中存储的对应元素的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集合相对于列表比较简单一些。集合没有键和值，直接拿到集合里面的值进行哈希操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、可变和不可变元素：可哈希和不可哈希&quot;&gt;四、可变和不可变元素：可哈希和不可哈希&lt;/h2&gt;
&lt;h3 id=&quot;1可变类型的数据不可进行哈希运算，不可变的数据类型可进行哈希运算。&quot;&gt;1.可变类型的数据不可进行哈希运算，不可变的数据类型可进行哈希运算。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集合里面只能存储可哈希的对象。意思是集合里面只能存储不可变的数据类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;set2 = {1,2,3,[1,2]}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个集合就报错了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201215152138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为列表是可变类型。可变类型是不能进行哈希运算的。&lt;/p&gt;
&lt;p&gt;数值类型、字符串、元组可以，列表、字典、集合不能作为元素储存在这个集合里面。&lt;/p&gt;
&lt;p&gt;集合里面的元素通过哈希操作算出对应值，放到散列表里面。&lt;/p&gt;
&lt;h3 id=&quot;2集合为什么无序？&quot;&gt;2.集合为什么无序？&lt;/h3&gt;
&lt;p&gt;因为散列表里面存储元素的时候是没有顺序的，散列表也是会不断变化的（会变化长度、调整元素位置的），所以说散列类型是无序的。&lt;/p&gt;
&lt;h3 id=&quot;3散列类型为什么是无序的？&quot;&gt;3.散列类型为什么是无序的？&lt;/h3&gt;
&lt;p&gt;通过哈希算法算了之后，然后存到对应的散列表里面，散列表里面数据存储是没有固定顺序的。&lt;/p&gt;
&lt;h2 id=&quot;五、性能分析&quot;&gt;五、性能分析&lt;/h2&gt;
&lt;p&gt;字典最占用内存，其次是集合。然后是列表、元组。元组是占用内存最少的。但是查找元素的时候，集合是速度最快的，然后是字典。&lt;/p&gt;
&lt;p&gt;集合用起来不方便，如果知道哪个元素就好查找，但是不知道那个元素在哪里，就不方便从集合里去取那个元素。字典通过键取值，元组、列表通过下标。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;公众号 &lt;strong&gt;「清菡软件测试」&lt;/strong&gt; 首发，更多原创文章：&lt;strong&gt;清菡软件测试 107+原创文章&lt;/strong&gt;，欢迎关注、交流，禁止第三方擅自转载。&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 22:41:00 +0000</pubDate>
<dc:creator>清菡</dc:creator>
<og:description>坚持原创输出，点击蓝字关注我吧 作者：清菡 博客：oschina、云+社区、知乎等各大平台都有。 由于微信公众号推送改为了信息流的形式，防止走丢，请给加个星标 ⭐，你就可以第一时间接收到本公众号的推送</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinghan123/p/14141949.html</dc:identifier>
</item>
<item>
<title>Springboot之登录模块探索（含Token，验证码，网络安全等知识） - 半天想不出昵称的斌</title>
<link>http://www.cnblogs.com/top-housekeeper/p/14141871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/top-housekeeper/p/14141871.html</guid>
<description>&lt;p&gt;登录模块很简单，前端发送账号密码的表单，后端接收验证后即可~&lt;/p&gt;
&lt;p&gt;淦！可是我想多了，于是有了以下几个问题（里面还包含网络安全问题）：&lt;/p&gt;
&lt;p&gt;1.登录时的验证码&lt;/p&gt;
&lt;p&gt;2.自动登录的实现&lt;/p&gt;
&lt;p&gt;3.怎么维护前后端登录状态&lt;/p&gt;
&lt;p&gt;在这和大家分享下我实现此功能的过程，包括一些技术和心得&lt;/p&gt;

&lt;p&gt;为什么要验证码，原因很简单，防止脚本无限次重复登录，来暴力破解用户密码或者攻击服务器&lt;/p&gt;
&lt;p&gt;验证码的出现，使得&lt;span&gt;每次登录都有个动态变量需要输入&lt;/span&gt;，无法用脚本写死代码&lt;/p&gt;
&lt;p&gt;具体可以参考：&lt;a href=&quot;https://www.cnblogs.com/top-housekeeper/p/11392439.html&quot; target=&quot;_blank&quot;&gt;滑动验证码的设计和理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;所谓自动登录，指的是当用户登录网站时勾选了自动登录，那么下次再访问网站就不需要输入账号密码直接登录了&lt;/p&gt;
&lt;p&gt;这说明，账号密码信息是必须保存在用户这边的，因此&lt;span&gt;自动登录都是不安全的&lt;/span&gt;！（方便的代价呀）&lt;/p&gt;
&lt;p&gt;尽管不安全，但是我们也必须要尽力让它安全一点，有以下常用方法：&lt;/p&gt;
&lt;p&gt;1.账号密码加密保存&lt;/p&gt;
&lt;p&gt;2.降低自动登录后用户的权限（如果用户自动登录想改密码，想给我转钱等操作的话，就必须输入账号密码再登录一次！）&lt;/p&gt;
&lt;p&gt;3.进行ip检测（之前登录的ip小本本记着），如果发现和上次不一致，则不允许自动登录&lt;/p&gt;
&lt;h2&gt;数据存储在前端哪里呢&lt;/h2&gt;
&lt;p&gt;浏览器有3个经常保存数据的地方&lt;/p&gt;
&lt;p&gt;1.Cookie （我用这个）&lt;/p&gt;
&lt;p&gt;2.LocalStorage&lt;/p&gt;
&lt;p&gt;3.SessionStorage&lt;/p&gt;
&lt;p&gt;各位可以按F12直接观看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1764312/202012/1764312-20201215220003079-546946561.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;451&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果你在多个大型网站下都按按F12，会发现SessionStorage基本没数据&lt;/p&gt;
&lt;p&gt;为啥，因为真的不好用，它并不是后台的session那样，生命周期是一个会话，这个SessionStorage存储的数据只限于该标签的页面&lt;/p&gt;
&lt;p&gt;意思是标签1和标签2即使是同个URL的网址，里面的数据都是不互通的（这有个毛用）&lt;/p&gt;

&lt;p&gt;那么LocalStorage存储的数据如何呢，答案是无限期本地存储&lt;/p&gt;
&lt;p&gt;不过后台无法操作这里的数据，只能由js代码操作（至于操作结果，完全看js，后端无法感知，不太可靠），我认为这里不适合保存敏感点的信息，因为前端的功能是展示，状态性的数据应该由后端直接掌控（后端能直接操作Cookie，保证完成任务）&lt;/p&gt;
&lt;p&gt;你看英雄所见略同，CSDN网站的用户密码也是存在Cookie的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1764312/202012/1764312-20201215221539910-290383504.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; Token就是登录后的令牌（下一点会讲）&lt;/p&gt;

&lt;p&gt;所以用Cookie就对啦，具体实现都很简单，前端多个自动登录的选择，选择后多个参数传给后端，后端根据参数往Cookie里设置加密后的账号密码&lt;/p&gt;
&lt;p&gt;等下次访问时，用拦截器Interceptor进行拦截，检测是否要自动登录即可~&lt;/p&gt;

&lt;p&gt;大家最先想到是用Session来维护，登录后在Session中存放用户信息，不过对分布式很不友好（什么，你说你用不到分布式，我也没用到，可是梦想还是要有的嘛），需要维护个分布式数据库来进行数据同步才行&lt;/p&gt;
&lt;p&gt;于是我用Token实现的，Token就是一串字符串，最适合API鉴权（例如SSO单点登录这种），俗称令牌&lt;/p&gt;
&lt;p&gt;好处就是账号密码用户输入一次就够了，特别是多个系统之间（一张身份的凭证都通用）&lt;/p&gt;
&lt;p&gt;当用户登录后，服务器就会生成一个Token放在Cookie中，之后用户的所有操作都带这个Token访问（将Token放入http头部）&lt;/p&gt;
&lt;h2&gt;为什么要将Token放入头部&lt;/h2&gt;
&lt;p&gt;1.能抵挡下简单的CSRF攻击&lt;/p&gt;
&lt;p&gt;2.浏览器跨域问题&lt;/p&gt;
&lt;h3&gt;什么是CSRF攻击&lt;/h3&gt;
&lt;p&gt;举个例子：我登录了A网站，A网站给我返回了一些Cookie信息，然后我再同一浏览器的另外标签访问了B网站，谁知这个B网站返回了一些攻击代码（向A网站发起一些请求，比如转钱给你，这时候由于是访问A网站，会附带A网站的Cookie，让一切都好像是我在访问一样），这个就是CSRF攻击&lt;/p&gt;
&lt;p&gt;但B网站并不知道A网站这么鸡贼，会在头部放了Token，所以这次攻击请求是的头部是没Token的，因此检测后发现非法，所以没得逞&lt;/p&gt;
&lt;p&gt;当然，这并不可靠，哪天B网站知道你头部放了Token，它研究A网站的js代码，清楚逻辑之后也加上，那就防不住了（所以说前端的东西一切都不可靠）&lt;/p&gt;
&lt;p&gt;正确做法应该是后端检测头部的Referer字段，每个网页里发起请求，请求的头部都会带有此字段，如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1764312/202012/1764312-20201216010234737-12454275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1764312/202012/1764312-20201215224807400-93283299.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;这说明这个请求是从 http://localhost:8099/swr 中发出的&lt;/p&gt;
&lt;p&gt;B网站如果返回攻击代码，这里显示的事B网站的网址，判断出不是自家网站发出，就可以禁止访问&lt;/p&gt;
&lt;h3&gt;浏览器跨域访问会发生什么&lt;/h3&gt;
&lt;p&gt;说到跨域（自家网站去请求别人家的网站），得先了解什么是同源策略：&lt;/p&gt;
&lt;p&gt;同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;
&lt;p&gt;它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。&lt;/p&gt;
&lt;p&gt;所谓同源是指：域名、协议、端口相同。&lt;/p&gt;
&lt;p&gt;下表是相对于 &lt;code&gt;http://www.laixiangran.cn/home/index.html&lt;/code&gt; 的同源检测结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/9932BCD648DE4CACB29A563116CE962B?method=download&amp;amp;shareKey=7fad5abd13151856c933a2bc9064a83a&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，同源策略又分为以下两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。&lt;/li&gt;
&lt;li&gt;XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。（就是ajax）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;咳咳，这里要说下第二种，其实设置一些参数之后，ajax访问时允许跨域请求的，甚至允许跨域时带上自身cookie&lt;/p&gt;
&lt;p&gt;但是，带上自己的Cookie多不安全，明明里面只有1,2个信息要传给对方，现在被人全看见了（不好不好），所以要将Token放入头部&lt;/p&gt;
&lt;p&gt;你说为啥不放到参数里，因为这会跟业务用的参数混淆，造成逻辑混乱（就好像你上学时要扔家里的垃圾，你不会放到书包里吧，都是手里提着的）&lt;/p&gt;
&lt;p&gt;每个请求都放token，所以要封装起来，例如我是将ajax封装起一个新的对象，然后在这个对象使用时添加Token&lt;/p&gt;
&lt;p&gt;当然啦，封装了ajax后还有其他好处（例如统一的成功，失败回调函数，统一的数据解析，统一的等待框等等），有兴趣的同学可以看下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_06d288d7-e599-45be-aab2-8b6e5d1aeeef&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_06d288d7-e599-45be-aab2-8b6e5d1aeeef&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06d288d7-e599-45be-aab2-8b6e5d1aeeef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;124&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt; * 访问后台的对象，为ajax封装
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt; * @param url 后台资源路径
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt; * @param param Map参数
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt; * @param contentType 传输类型
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt; * @param success   成功回调函数
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt; * @param error 失败回调函数
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt; * @param requestType 请求类型（get.post,put,delete）
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt; * @constructor
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; Query = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, param, contentType, successFunc, errorFunc, requestType) {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.url =&lt;span&gt; url;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先确认参数存在&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (param) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是get请求类型，则将参数拼接到url后面&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestType ==&lt;span&gt; Query.GET_TYPE) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.param = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._concatParamToURL(param, url);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他请求类型，要根据不同的传输格式来确定传输的值的类型&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (contentType ==&lt;span&gt; Query.NOMAL_TYPE) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.param = JSON.parse(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._convertParamToJson(param));
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.param = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._convertParamToJson(param);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.param = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.contentType =&lt;span&gt; contentType;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.successFunc =&lt;span&gt; successFunc;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.errorFunc =&lt;span&gt; errorFunc;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求超时，默认10秒&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.timeout = 10000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否异步请求，默认异步&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.async = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.requestType =&lt;span&gt; requestType;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; Query.JSON_TYPE = 'application/json'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; Query.NOMAL_TYPE = 'application/x-www-form-urlencoded'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt; * ajax请求的访问
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt; * 默认是post
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt; * @param url 要访问的地址
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt; * @param paramMap 传给后台的Map参数，key为字符串类型
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt; * @param callback 回调函数
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt; * @param contentType 传输数据的格式  默认传输application/x-www-form-urlencoded格式
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; Query.create = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, paramMap, successFunc, errorFunc) {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(url, paramMap, Query.NOMAL_TYPE, successFunc, errorFunc, Query.GET_TYPE);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------------------以下为RESTFul方法---------------------------&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ajax请求类型&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; Query.GET_TYPE = &quot;get&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; Query.POST_TYPE = &quot;post&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; Query.PUT_TYPE = &quot;put&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; Query.DELETE_TYPE = &quot;delete&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get方法默认是Query.NOMAL_TYPE&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; Query.createGetType = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, paramMap, successFunc, errorFunc) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(url, paramMap, Query.NOMAL_TYPE, successFunc, errorFunc, Query.GET_TYPE);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; Query.createPostType = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, paramMap, successFunc, errorFunc) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(url, paramMap, Query.JSON_TYPE, successFunc, errorFunc, Query.POST_TYPE);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; Query.createPutType = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, paramMap, successFunc, errorFunc) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(url, paramMap, Query.JSON_TYPE, successFunc, errorFunc, Query.PUT_TYPE);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; Query.createDeleteType = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, paramMap, successFunc, errorFunc) {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Query(url, paramMap, Query.JSON_TYPE, successFunc, errorFunc, Query.DELETE_TYPE);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt; * 将paramMap参数转为json格式
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt; * @param paramMap
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; Query.prototype._convertParamToJson = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (paramMap) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; window.tool.strMap2Json(paramMap);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt; * 将参数拼接至URL尾部
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt; * @param paramMap
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt; * @param url
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; Query.prototype._concatParamToURL = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (paramMap, url) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     let size =&lt;span&gt; paramMap.size;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (size &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         let count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         url = url + &quot;?&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         let urlParam = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [k, v] of paramMap) {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             urlParam = urlParam + encodeURIComponent(k) + &quot;=&quot; +&lt;span&gt; encodeURIComponent(v);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (count &amp;lt; size-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 urlParam = urlParam + &quot; &amp;amp;&amp;amp; &quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         url = url +&lt;span&gt; urlParam;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; url;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ajax需要跳转的界面&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; Query.REDIRECT_URL = &quot;REDIRECT_URL&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt; * ajax成功返回时调用的方法
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt; * 会根据ajax的ContentType类型，转换Response对象的data给回调的成功函数
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt; * 如application/json格式类型，data会转成json类型传递
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt; * @param queryResult 返回的值，通常为后台的Response对象
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt; Query.prototype._successFunc = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (queryResult) {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.__afterSuccessComplete(queryResult);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.successFunc) {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.successFunc(data);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有需要跳转的页面，则自动跳转&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (data &amp;amp;&amp;amp; data.REDIRECT_URL != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         window.location =&lt;span&gt; data.REDIRECT_URL;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt; * 会根据ajax的ContentType类型，转换Response对象的data给回调的失败函数
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt; * 如application/json格式类型，data会转成json类型传递
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt; * 如果对获得的参数不满意，可以用this.getMsg或this.getJsonMsg来进行获取（this指Query对象）
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt; * 这里错误分3种
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt; * 1.是Web容器出错
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt; * 2.是Filter过滤器主动报错（如一些校验失败后主动抛出，会有错误提示）
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt; * 3.是Spring抛出，Spring异常会全局捕捉进行封装
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt; * @param queryResult 返回的值，通常为后台的Response对象
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt; Query.prototype._errorFunc = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (queryResult) {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的信息&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.__afterErrorComplete(queryResult);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果data里面没东西&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;data) {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         data =&lt;span&gt; queryResult.statusText;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; 
&lt;span&gt;158&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否调用者自身已解决了错误&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; handleError = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; 
&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用回调函数，如果返回结果为true，则不会默认错误处理&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.errorFunc &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Function) {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         handleError = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.errorFunc(data);
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误编号&lt;/span&gt;
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; code;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有取消对错误的后续处理，那么进行跳转&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;handleError) {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果data成功转为Json对象&lt;/span&gt;
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Filter过滤器主动报错（如一些校验失败后主动抛出，会有错误提示）&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.status) {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                 code =&lt;span&gt; data.status;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.message) {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;                 msg =&lt;span&gt; data.message;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; 
&lt;span&gt;185&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终跳转至错误页面&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; path = &quot;/system/error&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (code &amp;amp;&amp;amp;&lt;span&gt; msg) {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             path = path + &quot;/&quot; + error.code + &quot;/&quot; +&lt;span&gt; error.msg;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         window.location.href =&lt;span&gt; path;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt; Query.SUCCESS_TYPE = &quot;SUCCESS_TYPE&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; Query.ERROR_TYPE = &quot;ERROR_TYPE&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt; * 当一个请求完成时，无论成功或失败，都要调用此函数做一些处理
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt; * @param queryResult 服务端返回的数据
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt; * @returns {*}
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; Query.prototype._afterComplete = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (queryResult) {
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._cancleLoadDom();
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt; * 成功的返回处理，会将data部分转为对象
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt; * 默认application/json会进行单引号转双引号
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt; * @param queryResult 服务端返回的数据
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt; * @param queryResult
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt; * @returns {*}
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt; Query.prototype.__afterSuccessComplete = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (queryResult) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._afterComplete();
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.response =&lt;span&gt; queryResult;
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; queryResult.data;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;data必须要有内容，且不是对象才有转换的意义&lt;/span&gt;
&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (data &amp;amp;&amp;amp; !(data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Object)) {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;             data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJsonMsg();
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; 
&lt;span&gt;226&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt; * 失败的返回处理
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt; * 最终会根据ajax的contentType来进行data相应类型转换
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt; * 默认application/json会进行单引号转双引号
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt; * @param queryResult 服务端返回的数据
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; Query.prototype.__afterErrorComplete = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (queryResult) {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._afterComplete();
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.response =&lt;span&gt; queryResult;
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; queryResult.responseJSON;
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;data) {
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         data =&lt;span&gt; queryResult.responseText;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; 
&lt;span&gt;244&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; &lt;span&gt; * 取消请求时的等待框
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt; Query.prototype._cancleLoadDom = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消加载框&lt;/span&gt;
&lt;span&gt;250&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.loadDom) {
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;         $(&lt;span&gt;this&lt;/span&gt;.loadDom).remove(&quot;#loadingDiv&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; 
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt; * 正式发送ajax
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; &lt;span&gt; * @private
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;259&lt;/span&gt; Query.prototype.sendMessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; xhr =&lt;span&gt; $.ajax(
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;             url: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.url,
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;             type: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestType,
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;             contentType: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contentType,
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;             data: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.param,
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ajax发送前调用的方法，初始化等待动画&lt;/span&gt;
&lt;span&gt;268&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @param XHR  XMLHttpRequest对象&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt;             beforeSend: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (XHR) {
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;试图从Cookie中获得token放入http头部&lt;/span&gt;
&lt;span&gt;271&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; token =&lt;span&gt; window.tool.getCookieMap().get(window.commonStaticValue.TOKEN);
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(token){
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt; &lt;span&gt;                    XHR.setRequestHeader(window.commonStaticValue.TOKEN,token);
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; 
&lt;span&gt;276&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定本次请求的queryObj&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt;                 XHR.queryObj =&lt;span&gt; self;
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (self.beforeSendFunc &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Function) {
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;                    self.beforeSendFunc(XHR);
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; 
&lt;span&gt;282&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (self.loadDom &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HTMLElement) {
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;                     self.loadDom.innerText = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                     $(self.loadDom).append(&quot;&amp;lt;div id='loadingDiv' class='loading'&amp;gt;&amp;lt;img src='/image/loading.gif'/&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (self.loadDom &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; jQuery) {
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt;                    self.loadDom.empty();
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;                     self.loadDom.append(&quot;&amp;lt;div id='loadingDiv' class='loading'&amp;gt;&amp;lt;img src='/image/loading.gif'/&amp;gt;&amp;lt;/div&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将QueryObj设置为上下文&lt;/span&gt;
&lt;span&gt;291&lt;/span&gt; &lt;span&gt;            context: self,
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;             success: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._successFunc,
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;             error: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._errorFunc,
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt;             complete:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;               console.log(&quot;ajax完成&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;             timeout: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.timeout,
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;             async: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.async
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt; 
&lt;span&gt;303&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------------------------------下面提供了获取后台返回信息方法（帮忙封装了）&lt;/span&gt;
&lt;span&gt;304&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; &lt;span&gt; * 获取返回信息Response的Meta头
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;307&lt;/span&gt; Query.prototype.getMeta = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.response.meta;
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt; 
&lt;span&gt;311&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt; * 获得返回值里的data部分
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt; * @returns {*}
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;315&lt;/span&gt; Query.prototype.getMsg = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.response.data;
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; 
&lt;span&gt;319&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; &lt;span&gt; * 获得返回值里的data部分，尝试将其转为Json对象
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;322&lt;/span&gt; Query.prototype.getJsonMsg = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.response.data;
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先将字符串里的&amp;amp;quot;转为双引号&lt;/span&gt;
&lt;span&gt;326&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data = window.tool.replaceAll(data, &quot;&amp;amp;quot;&quot;, &quot;\&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; jsonData =&lt;span&gt; JSON.parse(data);
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsonData;
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; 
&lt;span&gt;336&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------以下为对Query的参数设置---------------------------&lt;/span&gt;
&lt;span&gt;337&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; &lt;span&gt; * 在ajax发送前设置参数，可以有加载的动画，并且请求完成后会自动取消
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt; * @param loadDom 需要显示动画的dom节点
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; &lt;span&gt; * @param beforeSendFunc ajax发送前的自定义函数
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;342&lt;/span&gt; Query.prototype.setBeforeSend = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (loadDom, beforeSendFunc) {
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.loadDom =&lt;span&gt; loadDom;
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.beforeSendFunc =&lt;span&gt; beforeSendFunc;
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; 
&lt;span&gt;347&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt; * 设置超时时间
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; &lt;span&gt; * @param timeout
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;351&lt;/span&gt; Query.prototype.setTimeOut = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (timeout) {
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.timeout =&lt;span&gt; timeout;
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; 
&lt;span&gt;355&lt;/span&gt; Query.prototype.setAsync = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (async) {
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.async =&lt;span&gt; async;
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;预防XSS攻击，Filter知识讲解&lt;/h2&gt;
&lt;p&gt;网上有些文章说，后端设置HttpOnly，让Cookie无法让js读写，可以防止XSS攻击。&lt;/p&gt;
&lt;p&gt;(⊙o⊙)…简直就是乱写，首先要了解下什么是XSS攻击&lt;/p&gt;
&lt;h3&gt;Xss攻击是什么&lt;/h3&gt;
&lt;p&gt;举个简单的例子，假设你前端有个地方可以输入，然后保存的数据库的地方&lt;/p&gt;
&lt;p&gt;用户A输入了以下东西&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这东西就到了后台，当作一串字符串保存了起来&lt;/p&gt;
&lt;p&gt;刚好你网站的html代码里，有个地方是显示用户输入过的东西的（例如评论区），然后上面的东西就被加载到html里面，如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来每个人打开你的网站，都会弹出123的对话框，这就是XSS攻击&lt;/p&gt;
&lt;p&gt;怎么预防呢，在后端设置过滤器，对输入进行过滤，先上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * @auther: NiceBin
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * @description: 系统的拦截器，注册在FilterConfig类中进行
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *               不能使用@WebFilter，因为Filter要排序
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *               1.对ServletRequest进行封装
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *               2.防止CSRF，检查http头的Referer字段
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @date: 2020/12/15 15:32
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SystemFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(SystemFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Environment environment;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(FilterConfig filterConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         logger.info(&quot;系统拦截器SystemFilter开始加载&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         SystemHttpServletRequestWrapper requestWrapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SystemHttpServletRequestWrapper((HttpServletRequest) request);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测http的Referer字段，不允许跨域访问&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         String hostPath = environment.getProperty(&quot;server.host-path&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         String referer = requestWrapper.getHeader(&quot;Referer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;Tool.isNull(referer)){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(referer.lastIndexOf(hostPath)!=0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                ((HttpServletResponse)response).setStatus(HttpStatus.FORBIDDEN.value()); //设置错误状态码
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        chain.doFilter(requestWrapper,response);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乍一看，是不是没发现哪里预防了XSS，其实正在的关键点在22行和33行代码，里面的SystemHttpServletRequestWrapper类才是关键，这个类是包装类，&lt;span&gt;是替换参数里的ServletRequest类的&lt;/span&gt;，为的就是重写里面的方法，来达到预防XSS的目的，因为Spring也是根据ServletRequest类来进行前端参数读取的，所以它就是后端获得数据的源头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * @auther: NiceBin
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * @description: 包装的httpServlet，进行以下增强
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *               1.将流数据取出保存，方便多次读出
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *               2.防止XSS攻击，修改读取数据的方法，过滤敏感字符
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @date: 2020/4/23 19:50
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SystemHttpServletRequestWrapper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServletRequestWrapper {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] body;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpServletRequest request;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; SystemHttpServletRequestWrapper(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(request);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印属性
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printRequestAll(request);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         body = HttpHelper.getBodyString(request).getBytes(Charset.forName(&quot;UTF-8&quot;&lt;span&gt;));  //HttpHelper是我自己写的工具类
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.request =&lt;span&gt; request;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; BufferedReader getReader() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(getInputStream()));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServletInputStream getInputStream() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ByteArrayInputStream bais = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(body);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletInputStream() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isFinished() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isReady() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setReadListener(ReadListener readListener) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; read() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bais.read();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;     * 可以打印出HttpServletRequest里属性的值
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printRequestAll(HttpServletRequest request){
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         Enumeration e =&lt;span&gt; request.getHeaderNames();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (e.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             String name =&lt;span&gt; (String) e.nextElement();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             String value =&lt;span&gt; request.getHeader(name);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             System.out.println(name + &quot; = &quot; +&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为XSS预防&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getParameter(String name) {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         String value =&lt;span&gt; request.getParameter(name);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(value)) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             value =&lt;span&gt; StringEscapeUtils.escapeHtml4(value);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] getParameterValues(String name) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         String[] parameterValues = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getParameterValues(name);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (parameterValues == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; parameterValues.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             String value =&lt;span&gt; parameterValues[i];
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             parameterValues[i] =&lt;span&gt; StringEscapeUtils.escapeHtml4(value);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterValues;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HttpHelper工具类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_763a323f-0d82-4d99-91e8-8f2f32966acf&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_763a323f-0d82-4d99-91e8-8f2f32966acf&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_763a323f-0d82-4d99-91e8-8f2f32966acf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpHelper {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 获取请求中的Body内容
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getBodyString(ServletRequest request) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         InputStream inputStream = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         BufferedReader reader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             inputStream =&lt;span&gt; request.getInputStream();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             reader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             String line = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((line = reader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                sb.append(line);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (inputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    inputStream.close();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (reader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    reader.close();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;可以看到SystemHttpServletRequestWrapper的64行开始，重写了两个获取参数的方法，在获取参数的时候进行过滤即可~&lt;/p&gt;
&lt;p&gt;那64行往上是干啥的咧，这个是将ServletRequest里的数据读出来保存一份，因为&lt;span&gt;ServletRequest里的数据流只能读取一次&lt;/span&gt;，很不方便&lt;/p&gt;
&lt;p&gt;啥意思呢，就是你在这个Filter里&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
inputStream =&lt;span&gt; request.getInputStream();
reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inputStream, Charset.forName(&quot;UTF-8&quot;)));
&lt;/pre&gt;
&lt;pre&gt;
String line = &quot;&quot;;&lt;br/&gt;while ((line = reader.readLine()) != null) {&lt;br/&gt;sb.append(line);&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把数据读完，下个Filter再执行这些代码，就没数据了（从而导致Spring也接收不到数据）&lt;/p&gt;
&lt;p&gt;所以要保存起来，让后面的过滤器Filter和拦截器Interceptor快乐的读数据，没有后顾之忧（例如上面提到的验证码设计，如果你想用拦截器拦截，然后进行验证，则势必会读数据），既然封装ServletRequest这么重要，那必须得保证这个Filter第一个加载啊&lt;/p&gt;
&lt;p&gt;在Springboot中，Filter的排序用@Order是没用的，必须要用FilterRegistrationBean进行注册才能排序，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * @auther: NiceBin
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * @description: 为了排序Filter，如果Filter有顺序要求
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *               那么需要在此注册，设置order（值越低优先级越高）
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *               其他没顺序需要的，可以@WebFilter注册
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *               如@WebFilter(filterName = &quot;SecurityFilter&quot;, urlPatterns = &quot;/*&quot;, asyncSupported = true)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @date: 2020/12/15 15:48
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FilterConfig {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    SystemFilter systemFilter;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 注册SystemFilter，顺序为1，任何其他filter不能比他优先
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean filterRegist(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         FilterRegistrationBean filterRegistrationBean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterRegistrationBean();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        filterRegistrationBean.setFilter(systemFilter);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         filterRegistrationBean.setName(&quot;SystemFilter&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         filterRegistrationBean.addUrlPatterns(&quot;/*&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         filterRegistrationBean.setAsyncSupported(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         filterRegistrationBean.setOrder(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterRegistrationBean;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，如果你没用Springboot，那web.xml中定义的顺序就是Filter加载的顺序&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;知识点提问：在我们之后的Filter或者Interceptor中，需要&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; SystemHttpServletRequestWrapper requestWrapper = (SystemHttpServletRequestWrapper) request
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这样强制转换才能用吗？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是不用的，你可以想想Spring也用了这个东西的，它怎么知道你定义的类叫什么名字，怎么强制转换，那么这设计到Java什么知识呢&lt;/p&gt;
&lt;p&gt;没错，就是Java的多态性，我们看以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayName(){
        System.out.println(&lt;/span&gt;&quot;我是爸爸&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Father{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayName(){
        System.out.println(&lt;/span&gt;&quot;我是儿子&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    @org.junit.Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Father father &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Son();
        otherMethod(father);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; otherMethod(Father father){
        father.sayName();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：我是儿子&lt;/p&gt;
&lt;p&gt;答错了的留言，看看有多少小伙子~~ 接下来言归正传&lt;/p&gt;
&lt;h2&gt;选择JWT生成Token&lt;/h2&gt;
&lt;p&gt;JWT全称JSON Web Tokens 是一种规范化的 token（别人想的挺多挺全面的了，比你自己想的token要好一点）&lt;/p&gt;
&lt;p&gt;一个 JWT token 是一个字符串，它由三部分组成，头部、载荷与签名，中间用 . 分隔，例如：xxxxx.yyyyy.zzzzz&lt;/p&gt;
&lt;h3&gt;头部（header）&lt;/h3&gt;
&lt;p&gt;头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;alg&quot;: &quot;HS256&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;typ&quot;: &quot;JWT&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后用 Base64Url 编码得到头部，即 xxxxx。&lt;span&gt;Base64Url编码后，才能在URL中正常传输（因为有人会把Token放在URL里.....）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;载荷（Payload）&lt;/h3&gt;
&lt;p&gt;载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换，如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;sub&quot;: &quot;1&quot;&lt;span&gt;,

  &lt;/span&gt;&quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;&lt;span&gt;,

  &lt;/span&gt;&quot;iat&quot;: 1451888119&lt;span&gt;,

  &lt;/span&gt;&quot;exp&quot;: 1454516119&lt;span&gt;,

  &lt;/span&gt;&quot;nbf&quot;: 1451888119&lt;span&gt;,

  &lt;/span&gt;&quot;jti&quot;: &quot;37c107e4609ddbcc9c096ea5ee76c667&quot;&lt;span&gt;,

  &lt;/span&gt;&quot;aud&quot;: &quot;dev&quot;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以将载荷用别的方式加密一遍，这样别人得到了token也看不懂&lt;/p&gt;
&lt;h3&gt;签名（Signature）&lt;/h3&gt;
&lt;p&gt;签名时需要用到前面编码过的两个字符串，如果以 HMACSHA256 加密，就如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HMACSHA256(

    base64UrlEncode(header) &lt;/span&gt;+ &quot;.&quot; +&lt;span&gt;

    base64UrlEncode(payload),

    secret

)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加密后再进行 base64url 编码最后得到的字符串就是 token 的第三部分 zzzzz。&lt;/p&gt;
&lt;p&gt;组合便可以得到 token：xxxxx.yyyyy.zzzzz。&lt;/p&gt;
&lt;p&gt;签名的作用：保证 JWT 没有被篡改过，原理如下：&lt;/p&gt;
&lt;p&gt;HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。&lt;/p&gt;
&lt;p&gt;具体Java使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.auth0&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;java-jwt&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.10.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--jwt一些工具类--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.9.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; **
&lt;span&gt;  2&lt;/span&gt;  *&lt;span&gt; @auther: NiceBin
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;  *&lt;span&gt; @description: Jwt构造器，创建Token来进行身份记录
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;  *&lt;span&gt; jwt由3个部分构成：jwt头，有效载荷（主体,payLoad），签名
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;  * @date: 2020/5/7 22:40
&lt;span&gt;  6&lt;/span&gt;  */
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JwtTool {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为JwtTool生成时的主题
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录是否还有效&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUBJECT_ONLINE_STATE = &quot;online_state&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为载荷固定的Key值
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主题&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUBJECT = &quot;subject&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布时间&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TIME_ISSUED = &quot;timeIssued&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过期时间&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String EXPIRATION = &quot;expiration&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;     * 生成token，参数都是载荷（自定义内容）
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;     * 其中Map里为非必要数据，而其他参数为必要参数
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; subject  主题，token生成干啥用的，用上面的常量作为参数
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; liveTime 存活时间(秒单位)，建议使用TimeUnit方便转换
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;     *                 如TimeUnit.HOURS.toSeconds(1);将1小时转为秒 = 3600
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; claimMap 自定义荷载，可以为空
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String createToken(String subject, &lt;span&gt;long&lt;/span&gt; liveTime, HashMap&amp;lt;String, String&amp;gt; claimMap) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         SignatureAlgorithm signatureAlgorithm =&lt;span&gt; SignatureAlgorithm.HS256;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;毫秒要转为秒&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; now = System.currentTimeMillis() / 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(EncrypRSA.keyString);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Key signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;         JwtBuilder jwtBuilder =&lt;span&gt; Jwts.builder()
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密算法&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;                 .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt签名&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                .signWith(signatureAlgorithm, EncrypRSA.convertSecretKey);  //这个Key是我自个的密码，你们自己设个字符串也成，这个得保密
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         HashMap&amp;lt;String,String&amp;gt; payLoadMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        payLoadMap.put(SUBJECT,subject);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        payLoadMap.put(TIME_ISSUED,String.valueOf(now));
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Token的过期时间&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (liveTime &amp;gt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; expiration = now +&lt;span&gt; liveTime;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;            payLoadMap.put(EXPIRATION,String.valueOf(expiration));
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SystemException(SystemStaticValue.TOOL_PARAMETER_EXCEPTION_CODE, &quot;liveTime参数异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         StringBuilder payLoad = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Collections.isEmpty(claimMap)) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            payLoadMap.putAll(claimMap);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接主题payLoad，采用 key1,value1,key2,value2的格式&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; entry : payLoadMap.entrySet()) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             payLoad.append(entry.getKey()).append(',').append(entry.getValue()).append(','&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对payLoad进行加密，这样别人Base64URL解密后也不是明文&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;         String encrypPayLoad =&lt;span&gt; EncrypRSA.encrypt(payLoad.toString());
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        jwtBuilder.setPayload(encrypPayLoad);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会自己生成签名，组装&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jwtBuilder.compact();
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;     * 私钥解密token信息
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; token
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 存有之前定义的Key, value的Map，解析失败则返回null
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HashMap getMap(String token) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Tool.isNull(token)) {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 String encrypPayLoad =&lt;span&gt; Jwts.parser()
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                        .setSigningKey(EncrypRSA.convertSecretKey)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                        .parsePlaintextJws(token).getBody();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;                 String payLoad =&lt;span&gt; EncrypRSA.decrypt(encrypPayLoad);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;                 String[] payLoads = payLoad.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 HashMap&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; payLoads.length - 1; i=i+2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     map.put(payLoads[i], payLoads[i + 1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 System.out.println(&quot;Token解析失败&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;     * 判断token是否有效
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map 已经解析过token的map
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 为有效
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAlive(HashMap&amp;lt;String, String&amp;gt;&lt;span&gt; map) {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Collections.isEmpty(map)) {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             String tokenString =&lt;span&gt; map.get(EXPIRATION);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Tool.isNull(tokenString)) {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 &lt;span&gt;long&lt;/span&gt; expiration = Long.valueOf(tokenString) / 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 &lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (expiration &amp;gt;&lt;span&gt; now) {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt; &lt;span&gt;     * 判断token是否有效
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; token 还未被解析的token
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAlive(String token) {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JwtTool.isAlive(JwtTool.getMap(token));
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，Token的生成和使用就介绍完了，大家有没兴趣了解下重放攻击（淦，我也是在某个博文看到的，又得花时间研究）&lt;/p&gt;
&lt;h2&gt;Https防止半路被截和重放攻击&lt;/h2&gt;
&lt;p&gt;前面提到了Token就是身份令牌，可以相当于已登录一样进入系统，那么半路被人截了那就不好了&lt;/p&gt;
&lt;p&gt;所以要用Https协议，具体怎么设置大家自行百度吧（直接在tomcat操作的，不需要更改代码，证书也有免费的~）&lt;/p&gt;
&lt;p&gt;这里说下Https建立连接的过程，来看看为什么就不会被人截获了&lt;/p&gt;
&lt;p&gt;1.服务器先向CA（证书颁布机构）申请一个证书（证书里有自己的ip等等消息），然后在自己服务器设置好&lt;/p&gt;
&lt;p&gt;2.浏览器向服务器发送HTTPS请求，服务器将自己的证书发给浏览器&lt;/p&gt;
&lt;p&gt;3.浏览器拿到证书后，查看证书是否过期啊，ip是不是跟服务器的一样啊，跟检查身份证跟你长得像不像一样，检查没问题后，跟自己系统里的CA列表比对，看看是谁发的（找不到就报错，说证书不可信），比对成功后从列表里拿出对应的CA公钥解密证书（具体方法跟JWT的很像，浏览器用相同的算法和公钥对证书部分进行加密，看得到的值和证书的签名是否一致），得到服务器的公钥&lt;/p&gt;
&lt;p&gt;4.然后生成一个传输私钥，用服务器的公钥加密，发给服务器&lt;/p&gt;
&lt;p&gt;5.服务器用服务器的私钥解密，得到了传输秘钥，然后用传输秘钥进行加密要传送的信息发给浏览器&lt;/p&gt;
&lt;p&gt;6.浏览器用秘钥解密，然后用传输秘钥进行加密要传送的信息发给服务器（对称加密）&lt;/p&gt;
&lt;p&gt;7.重复5,6步骤直到结束&lt;/p&gt;
&lt;p&gt;以上哪个步骤黑客得到数据都看不懂&lt;/p&gt;
&lt;p&gt;至于为什么能防重放攻击，是因为Https通信自带序列号，如果黑客截取了浏览器的请求，重复发送一遍，那么序列号会一样，会被直接丢弃&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;至此分享完啦，喜欢的小伙伴给个赞呀~~&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：https://learnku.com/articles/17883&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　   https://www.cnblogs.com/laixiangran/p/9064769.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ServletRequest&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 17:07:00 +0000</pubDate>
<dc:creator>半天想不出昵称的斌</dc:creator>
<og:description>简介 登录模块很简单，前端发送账号密码的表单，后端接收验证后即可~ 淦！可是我想多了，于是有了以下几个问题（里面还包含网络安全问题）： 1.登录时的验证码 2.自动登录的实现 3.怎么维护前后端登录状</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/top-housekeeper/p/14141871.html</dc:identifier>
</item>
<item>
<title>【Harbor学习笔记】-教你快速搭建Docker私有仓库 - IT胖</title>
<link>http://www.cnblogs.com/FLY_DREAM/p/14141776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FLY_DREAM/p/14141776.html</guid>
<description>&lt;p&gt;Docker容器应用的开发和运行离不开可靠的镜像管理，虽然Docker官方也提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署我们私有环境内的Registry也是非常必要的。&lt;a href=&quot;https://goharbor.io/&quot; target=&quot;_blank&quot;&gt;Harbor&lt;/a&gt; 是由VMware公司开源的企业级的Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、自我注册、镜像复制和中文支持等功能。&lt;/p&gt;
&lt;p&gt;Harbor 的所有组件都在 Dcoker 中部署，所以 Harbor 可使用 Docker Compose 快速部署。&lt;/p&gt;
&lt;p&gt;注： 由于 Harbor 是基于 Docker Registry V2 版本，所以 docker 版本必须 &amp;gt; = 1.10.0 docker-compose &amp;gt;= 1.6.0&lt;/p&gt;
&lt;p&gt;Harbor的目标是帮助用户迅速搭建一个企业级的Docker registry服务。它&lt;code&gt;以Docker公司开源的registry为基础&lt;/code&gt;，额外提供了如下功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于角色的访问控制(Role Based Access Control)&lt;/li&gt;
&lt;li&gt;基于策略的镜像复制(Policy based image replication)&lt;/li&gt;
&lt;li&gt;镜像的漏洞扫描(Vulnerability Scanning)&lt;/li&gt;
&lt;li&gt;AD/LDAP集成(LDAP/AD support)&lt;/li&gt;
&lt;li&gt;镜像的删除和空间清理(Image deletion &amp;amp; garbage collection)&lt;/li&gt;
&lt;li&gt;友好的管理UI(Graphical user portal)&lt;/li&gt;
&lt;li&gt;审计日志(Audit logging)&lt;/li&gt;
&lt;li&gt;RESTful API&lt;/li&gt;
&lt;li&gt;部署简单(Easy deployment)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;架构图&quot;&gt;架构图&lt;/h2&gt;
&lt;p&gt;Harbor的每个组件都是以Docker容器的形式构建的，可以使用Docker Compose来进行部署。如果环境中使用了kubernetes，Harbor也提供了kubernetes的配置文件。&lt;/p&gt;
&lt;p&gt;Harbor大概需要以下几个容器组成：ui(Harbor的核心服务)、log(运行着rsyslog的容器，进行日志收集)、mysql(由官方mysql镜像构成的数据库容器)、Nginx(使用Nginx做反向代理)、registry(官方的Docker registry)、adminserver(Harbor的配置数据管理器)、jobservice(Harbor的任务管理服务)、redis(用于存储session)。&lt;/p&gt;
&lt;p&gt;Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，整体架构还是很清晰的。下面借用了网上的架构图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201215235908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;harbor依赖的外部组件&quot;&gt;Harbor依赖的外部组件&lt;/h3&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;-&amp;gt; Nginx(即Proxy代理层): Nginx前端代理，主要用于分发前端页面ui访问和镜像上传和下载流量; Harbor的registry,UI,token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将请求转发给后端不同的服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;-&amp;gt; Registry v2: 镜像仓库，负责存储镜像文件; Docker官方镜像仓库, 负责储存Docker镜像，并处理docker push/pull命令。由于我们要对用户进行访问控制，即不同用户对Docker image有不同的读写权限，Registry会指向一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token, Registry会通过公钥对token进行解密验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;-&amp;gt; Database(MySQL或Postgresql)：为core services提供数据库服务，负责储存用户权限、审计日志、Docker image分组信息等数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;harbor自有组件&quot;&gt;Harbor自有组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;-&amp;gt; Core services(Admin Server): 这是Harbor的核心功能，主要提供以下服务：
&lt;ul&gt;&lt;li&gt;-&amp;gt; UI：提供图形化界面，帮助用户管理registry上的镜像（image）, 并对用户进行授权。&lt;/li&gt;
&lt;li&gt;-&amp;gt; webhook：为了及时获取registry 上image状态变化的情况， 在Registry上配置webhook，把状态变化传递给UI模块。&lt;/li&gt;
&lt;li&gt;-&amp;gt; Auth服务：负责根据用户权限给每个docker push/pull命令签发token. Docker 客户端向Regiøstry服务发起的请求,如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。&lt;/li&gt;
&lt;li&gt;-&amp;gt; API: 提供Harbor RESTful API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;-&amp;gt; Replication Job Service：提供多个 Harbor 实例之间的镜像同步功能。&lt;/li&gt;
&lt;li&gt;-&amp;gt; Log collector：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;核心组件&quot;&gt;核心组件&lt;/h2&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Proxy：一个nginx的前端代理，代理Harbor的registry,UI, token等服务。-通过深蓝色先标识&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;db：负责储存用户权限、审计日志、Dockerimage分组信息等数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;UI：提供图形化界面，帮助用户管理registry上的镜像, 并对用户进行授权。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;jobsevice：jobsevice是负责镜像复制工作的，他和registry通信，从一个registry pull镜像然后push到另一个registry，并记录job_log。通过紫色线标识&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Adminserver：是系统的配置管理中心附带检查存储用量，ui和jobserver启动时候回需要加载adminserver的配置。通过灰色线标识；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Registry：镜像仓库，负责存储镜像文件。当镜像上传完毕后通过hook通知ui创建repository，上图通过红色线标识，当然registry的token认证也是通过ui组件完成。通过红色线标识&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Log：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。过docker的log-driver把日志汇总到一起，通过浅蓝色线条标识&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201215235702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;h3 id=&quot;1-下载离线安装包&quot;&gt;1. 下载离线安装包&lt;/h3&gt;
&lt;ul readability=&quot;2.861985472155&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Harbor以容器的形式进行部署, 因此可以被部署到任何支持Docker的Linux发行版, 要使用Harbor，需要安装docker和docker-compose编排工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.67241379310345&quot;&gt;
&lt;p&gt;访问&lt;a href=&quot;https://github.com/goharbor/harbor/releases&quot; target=&quot;_blank&quot;&gt;harbor release page&lt;/a&gt;，下载Harbor软件tgz压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;或执行如下命令 &lt;code&gt;wget https://storage.googleapis.com/harbor-releases/release-2.0.0/harbor-offline-installer-latest.tgz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;解压tgz压缩包&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar xvf harbor-offline-installer-&amp;lt;version&amp;gt;.tgz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-配置-harborcfg-（harboryml）&quot;&gt;2. 配置 harbor.cfg （harbor.yml）&lt;/h3&gt;
&lt;p&gt;注： 新版本是.yaml文件，之前版本是.conf 或者 .cfg文件&lt;/p&gt;
&lt;h3 id=&quot;3-启动-harbor&quot;&gt;3. 启动 Harbor&lt;/h3&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;配置完后，执行安装脚本 &lt;code&gt;./install.sh&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#会拉取好几个镜像下来，及检查环境
Note: docker version: 1.12.5
Note: docker-compose version: 1.9.0

[Step 0]: checking installation environment ...
....
[Step 1]: loading Harbor images ...
....
[Step 2]: preparing environment ...
....
[Step 3]: checking existing instance of Harbor ...
....
[Step 4]: starting Harbor ...
✔ ----Harbor has been installed and started successfully.----
...
For more details, please visit https://github.com/vmware/harbor .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，会发现解压目录harbor下面多了一个docker-compose.yml文件，里面包含了harbor依赖的镜像和对应容器创建的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行 docker-compose ps (执行docker-compose需在包含docker-compose.yml的目录) , 确保 container 的状态都是up (healthy).&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果安装一切顺利，通过之前在harbor.cfg配置的hostname即可以访问到前端了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装配置问题&quot;&gt;安装配置问题&lt;/h2&gt;
&lt;p&gt;Harbor安装 之后，需要用&lt;code&gt;docker-compose ps&lt;/code&gt; 命令去查看状态，保证所有docker 容器都是 healthy, 否则 很可能login harbor 失败&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201215230145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果那个service 启动不正常，就去查看/var/log/harbor/ 下对应的log&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;owen@swarm-node-107:/disk/harbor_v2.0.0$ ls /var/log/harbor/ -lht
总用量 22M
-rw-r--r-- 1 10000 10000 3.5M 12月 15 23:03 registryctl.log
-rw-r--r-- 1 10000 10000 5.4M 12月 15 23:02 core.log
-rw-r--r-- 1 10000 10000 4.4M 12月 15 23:02 portal.log
-rw-r--r-- 1 10000 10000 4.9M 12月 15 23:02 registry.log
-rw-r--r-- 1 10000 10000 1.2M 12月 15 23:02 proxy.log
-rw-r--r-- 1 10000 10000 392K 12月 15 23:00 redis.log
-rw-r--r-- 1 10000 10000 1.6M 12月 15 23:00 jobservice.log
-rw-r--r-- 1 10000 10000  53K 12月 14 21:42 postgresql.log
-rw-r--r-- 1 10000 10000  65K 7月   7 23:35 clair.log
-rw-r--r-- 1 10000 10000 1.2K 7月   5 11:43 clair-adapter.log
-rw-r--r-- 1 10000 10000 1.4K 7月   5 11:38 chartmuseum.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改harbor的运行配置，需要如下步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 停止 harbor
 docker-compose down -v
# 修改配置
 vim harbor.cfg
# 执行./prepare已更新配置到docker-compose.yml文件
 ./prepare
# 启动 harbor
 docker-compose up -d
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题-1-服务启动异常&quot;&gt;问题-1 服务启动异常&lt;/h3&gt;
&lt;p&gt;ubuntu@172-20-16-51:/opt/harbor$ docker login 192.20.16.51&lt;br/&gt;Username: admin&lt;br/&gt;Password:&lt;br/&gt;Error response from daemon: login attempt to &lt;a href=&quot;http://192.20.16.51/v2/&quot; target=&quot;_blank&quot;&gt;http://192.20.16.51/v2/&lt;/a&gt; failed with status: 502 Bad Gateway&lt;/p&gt;
&lt;p&gt;Harbor-db service 不能正常启动，最后查看postgresql.log 发现下面 message.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt; | initdb: directory &quot;/var/lib/postgresql/data&quot; exists but is not empty
 | If you want to create a new database system, either remove or empty
 | the directory &quot;/var/lib/postgresql/data&quot; or run initdb
 | with an argument other than &quot;/var/lib/postgresql/data&quot;.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为当时/data/datebase 目录下，确实不是empty, 手动改了docker-compose.yml ，然后 &lt;code&gt;docker-compose up -d&lt;/code&gt; 重新启动容器，服务正常&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;  postgresql:
    image: goharbor/harbor-db:v2.0.0
    container_name: harbor-db
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    volumes:
      - /data/database:/var/lib/postgresql/data:z
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题-2--dial-tcp-xxxxxxxxxxxx443-connect-connection-refused&quot;&gt;问题-2- dial tcp xxx.xxx.xxx.xxx:443: connect: connection refused&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# docker login 192.20.16.51:80
Username: admin
Password:
Error response from daemon: Get https://192.20.16.51:80/v2/: http: server gave HTTP response to HTTPS client
或者
Error response from daemon: Get https://192.168.31.107/v2/: dial tcp 192.168.31.107:443: connect: connection refused
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker1.3.2版本开始默认docker registry使用的是https，·Harbor默认安装使用的是HTTP协议·，所以当执行用docker login、pull、push等命令操作&lt;code&gt;非https的docker regsitry&lt;/code&gt;的时就会报错。&lt;/p&gt;
&lt;p&gt;临时解决办法：需要在每一台harbor客户端机器都要设置&quot;insecure-registries&quot; (&lt;strong&gt;彻底解决需要启动Harbor HTTPS证书&lt;/strong&gt;)&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果系统是MacOS，则可以点击“Preference”里面的“Advanced”在“Insecure Registry”里加上hostname (e.g. docker.bksx.com)，重启Docker客户端就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果系统是&lt;code&gt;Ubuntu&lt;/code&gt;，则修改配置文件&lt;code&gt;/lib/systemd/system/docker.service&lt;/code&gt;，修改[Service]下ExecStart参数，增加&lt;code&gt;–insecure-registry hostname&lt;/code&gt; (e.g. docker.bksx.com)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果系统是&lt;code&gt;Centos&lt;/code&gt;，可以修改配置&lt;code&gt;/etc/sysconfig/docker&lt;/code&gt;，将OPTIONS增加 &lt;code&gt;–insecure-registry hostname&lt;/code&gt; (e.g. docker.bksx.com)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是新版本的docker在/etc/sysconfig/ 没有docker这个配置文件的情况下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#在daemon.json中添加以下参数
[root@localhost harbor]# cat /etc/docker/daemon.json
{
  &quot;insecure-registries&quot;: [
    &quot;hostname&quot;
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：该文件必须符合 json 规范，否则 Docker 将不能启动。另外hostname 必须与harbor.cfg 里的hostname 一致。&lt;/p&gt;
&lt;p&gt;添加完了后重新启动 docker：&lt;code&gt;systemctl daemon-reload &amp;amp;&amp;amp; systemctl enable docker &amp;amp;&amp;amp; systemctl restart docker&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;登录后，账号信息都保存到本机的&lt;code&gt;~/.docker/config.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;owen@swarm-manager-105:~/gitee/vnote_notebooks$ docker login 192.168.31.107
Username: admin
Password: 
WARNING! Your password will be stored unencrypted in /home/owen/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
owen@swarm-manager-105:~/gitee/vnote_notebooks$ cat ~/.docker/config.json 
{
        &quot;auths&quot;: {
                &quot;192.168.31.107&quot;: {
                        &quot;auth&quot;: &quot;YWRtaW46SGFyYm9yMTIzNDU=&quot;
                }
        },
        &quot;HttpHeaders&quot;: {
                &quot;User-Agent&quot;: &quot;Docker-Client/19.03.14 (linux)&quot;
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题-3-防止容器进程没有权限读取生成的配置&quot;&gt;问题-3 防止容器进程没有权限读取生成的配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20201215232916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 16:06:00 +0000</pubDate>
<dc:creator>IT胖</dc:creator>
<og:description>Docker容器应用的开发和运行离不开可靠的镜像管理，虽然Docker官方也提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署我们私有环境内的Registry也是非常必要的。Harbor 是由VM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FLY_DREAM/p/14141776.html</dc:identifier>
</item>
<item>
<title>业务场景下数据采集机制和策略 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14141645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14141645.html</guid>
<description>&lt;p&gt;现在产品常见的客户端有PC端、H5端、APP端、小程序等各个场景的入口，更有一些物联网设备或者专门做的数据采集机制，不同的场景下的数据类型都是要区分的。通过不同端口下各类数据埋点，获取各个场景下的不同事件的数据来分析产品的优缺点，获取具有建设性的分析结果。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;109.80403902105&quot;&gt;

&lt;p&gt;做面向C端用户的产品，十分依赖用户数据的收集，下面都见过这样一张数据分析图，通过链路上各个环节的数据采集，分析对比出曝光产品的交易量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202012/1691717-20201215231305282-192595467.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对商品的浏览-点击-交易页面-支付购买等，分析产品的交易场景，这里是从大的业务方面观察数据的链路，实际上在分析的时候要考虑很多细节问题。&lt;/p&gt;

&lt;p&gt;用户数据来衡量用户或者产品的各方面纬度是最具有说服力的，所以在互联网的产品后期开发和优化过程中，对数据的采集和管理一直都是非常重要操作。&lt;/p&gt;
&lt;p&gt;现在产品常见的客户端有PC端、H5端、APP端、小程序等各个场景的入口，更有一些物联网设备或者专门做的数据采集机制，不同的场景下的数据类型都是要区分的。通过不同端口下各类数据埋点，获取各个场景下的不同事件的数据来分析产品的优缺点，获取具有建设性的分析结果。&lt;/p&gt;
&lt;p&gt;例如模块一中的案例：通过对端口的分析如果在APP端商品A的推荐和交易率最高，在小程序端推荐效果不好，那就可以考虑针对APP和小程序端采用不同的推荐机制。&lt;/p&gt;

&lt;p&gt;数据需要采集，并且要区分不同端口的数据只是基本的意识层面，思考采集数据的事件类型是最基础的操作。这里要从产品的特点去考虑，不同一概而论。下面提供一些基础采集数据和一些常见案例，关于核心业务数据相对都是精细和完整的，基本具备读库直接分析的条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础信息&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作终端&lt;/td&gt;
&lt;td&gt;app_client&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Android/IOS/小程序/H5等&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;终端版本&lt;/td&gt;
&lt;td&gt;app_version&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;版本号标识&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;用户标识&lt;/td&gt;
&lt;td&gt;user_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;用户ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;网络地址&lt;/td&gt;
&lt;td&gt;ip_address&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;用户IP信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些信息是存在任何采点数据中的，通过这些基础信息采集，用来分析不同端口下用户的特点，以此可以进行差异化的管理和运营。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;登录信息&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;登录时间&lt;/td&gt;
&lt;td&gt;login_time&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;用户登录时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;在线时长&lt;/td&gt;
&lt;td&gt;online_time&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;在线使用系统的时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过对登录和在线时间，以及一些使用信息，判断该类用户活跃度，是否需要重点运营或者营销激活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务基础&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;服务类型&lt;/td&gt;
&lt;td&gt;service_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;不同的业务服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;模块划分&lt;/td&gt;
&lt;td&gt;model_type&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;例如订单/支付/物流等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以此作为业务数据采集的基础信息，用来对业务数据做整体的划分和分析，具体的细节数据需要根据具体场景设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商品案例&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;商品信息&lt;/td&gt;
&lt;td&gt;product_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;商品信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;展现位置&lt;/td&gt;
&lt;td&gt;position_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;例如：列表/推荐位/广告位&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;店铺信息&lt;/td&gt;
&lt;td&gt;shop_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;所属店铺信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;搜索信息&lt;/td&gt;
&lt;td&gt;key_word&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;搜索关键字&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;当前单价&lt;/td&gt;
&lt;td&gt;unit_price&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;商品当前单价&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;当前销量&lt;/td&gt;
&lt;td&gt;sales_num&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;商品当前销量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里是按照用户浏览行为做的一个简单的数据采集信息，这种机制在实际的电商APP中很常见，产生点击或者搜索的商品会被重点推荐，如果没有这类动作，则根据日常浏览信息做推荐机制。在实际的开发中，采集的数据远比这里复杂，需要根据实际业务需要去考量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;营销案例&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;活动位置&lt;/td&gt;
&lt;td&gt;location_id&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;入口位/引导页/推荐位/分享链接等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;营销产品&lt;/td&gt;
&lt;td&gt;product_id&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;营销活动主打产品类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;产品详情流量&lt;/td&gt;
&lt;td&gt;detail_num&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;活动产品浏览量统计&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;订单确认页&lt;/td&gt;
&lt;td&gt;detail_num&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;活动产品浏览量统计&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;活动交易统计&lt;/td&gt;
&lt;td&gt;trade_num&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;活动最终转化统计&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过运营活动进行产品营销，活动结束后对数据进行复盘统计，然后根据活动轨迹数据的分析，平衡营销产生的价值和成本，不断调整活动策略，优化运营思路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、业务层面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从业务角度来看，除了一些用户无感知的采集操作之外，还可以基于问卷调查方式，例如很多APP在使用一段时间后都会弹出用户评价类似的评分系统，或者意见留言的入口，更加直接的搜集用户反馈信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、技术层面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的就是SDK埋点技术，针对特定用户行为或事件进行捕获、处理和发送给服务器的相关技术及其实施过程。这种方式用来处理一些非核心业务十分常见。如果是一些核心业务，可能需要自定义的方式采集数据，避免造成数据泄露的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、数据积累&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当业务不断发展，需要分析的场景会越来越复杂，而且采集的数据量达到一定规模之后，数据管理的和分析的难度就会变大，就会需要专业化的流程和智能工具，例如BI工具，可视化组件，数据大屏，多场景联合分析等。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile
GitEE·地址
https://gitee.com/cicadasmile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 15 Dec 2020 15:27:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>现在产品常见的客户端有PC端、H5端、APP端、小程序等各个场景的入口，更有一些物联网设备或者专门做的数据采集机制，不同的场景下的数据类型都是要区分的。通过不同端口下各类数据埋点，获取各个场景下的不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14141645.html</dc:identifier>
</item>
<item>
<title>数据结构第十一节(散列表) - W&amp;B</title>
<link>http://www.cnblogs.com/cs-Miscellaneous/p/14141627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-Miscellaneous/p/14141627.html</guid>
<description>&lt;h2 id=&quot;什么是散列表&quot;&gt;什么是散列表&lt;/h2&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;
&lt;p&gt;举一个简单的例子，假设我们有5个数字，他们的个位都不相同，如何把这5个数字保存起来，而且在查找这个数字时超级快呢。在这个简单的例子中由于它们的个位数都不相同，故我们对这些数字对10求余取个位数，放在对应下标的的数组里。（{54，76，31，92，109}这个集合，我们将54保存到array[4]，将76保存到array[6]，将31保存到array[1]，将92保存到array[2]，将54保存到array[9]）&lt;/p&gt;
&lt;p&gt;上面是一个极其简单和特殊的例子，在正常情况下我们很难遇到上面的简单情况，多数的情况，会出现冲突。对两个不同的数，如果计算到了同样的键值，该如何处理？&lt;/p&gt;
&lt;p&gt;所以现在构造一个好用的散列表，最重要的是做好以下两件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设计一个&quot;好&quot;的散列函数来计算Key值。(好的哈希函数应尽可能避免冲突的出现，而且计算时应尽可能简洁快速)&lt;/li&gt;
&lt;li&gt;出现了冲突时又该如何调整插入元素。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;散列表的实现&quot;&gt;散列表的实现&lt;/h2&gt;
&lt;h3 id=&quot;散列函数的实现&quot;&gt;散列函数的实现&lt;/h3&gt;
&lt;p&gt;散列函数的实现主要有以下几种方法:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接定址法：取关键字或关键字的某个线性函数值为散列地址。即&lt;span class=&quot;math inline&quot;&gt;\(hash(k)=k\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(hash(k)=a*k+b\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;为常数（这种散列函数叫做自身函数）&lt;/li&gt;
&lt;li&gt;数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。&lt;/li&gt;
&lt;li&gt;平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。&lt;/li&gt;
&lt;li&gt;折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同）， 然后取这几部分的叠加和（舍去进位）作为哈希地址。&lt;/li&gt;
&lt;li&gt;随机数法&lt;/li&gt;
&lt;li&gt;除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即&lt;span class=&quot;math inline&quot;&gt;\(hash(k)=k\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(mod\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上方法精是对数字类型的操作，对字符串类型的数据，可以选择通过相加或者进位转化成数字后，再执行上面的计算方法。&lt;/p&gt;
&lt;h3 id=&quot;散列表解决冲突的方法&quot;&gt;散列表解决冲突的方法&lt;/h3&gt;
&lt;p&gt;解决冲突主要有两种方式，一种是链地址法，另一种为开放地址法。&lt;/p&gt;
&lt;p&gt;对于第1种方法，是将有共同键值的元素串成一条链表的思路。而第2种方法，如果该位置已经有元素了，则换一个地方，当然为了查找时还能找得到他，肯定是不可以随便放的，需要按照指定的增长序列{&lt;span class=&quot;math inline&quot;&gt;\(k_1,k_2,k_3,k_4...k_n\)&lt;/span&gt;}，依次探查离自己距离自己&lt;span class=&quot;math inline&quot;&gt;\(k_1,k_2,k_3,k_4...k_n\)&lt;/span&gt;的地方是否有空。&lt;/p&gt;
&lt;p&gt;增量序列的不同，提供了不同的解决冲突方法。常用的方法有三种，分别为线性探测和平方探测和双散列。&lt;/p&gt;
&lt;p&gt;使用线性探测时，如果出现冲突那就向后错一位，看是否有空，直到找到空的（有点像上厕所找坑）；使用平方探测时，每次向前向后&lt;span class=&quot;math inline&quot;&gt;\(d_i^2\)&lt;/span&gt;位。使用这2种方法容易会造成聚集。聚集（Cluster，也翻译做“堆积”）的意思是，在函数地址的表中，散列函数的结果不均匀地占据表的单元，形成区块，造成线性探测产生一次聚集（primary clustering）和平方探测的二次聚集（secondary clustering），散列到区块中的任何关键字需要查找多次试选单元才能插入表中，解决冲突，造成时间浪费。对于开放定址法，聚集会造成性能的灾难性损失，是必须避免的。总体来说使用平方探测要比使用线性探测出现聚集的概率小。&lt;/p&gt;
&lt;p&gt;使用双散列时，如果出现冲突，就用当前的键值作为参数用另一个散列函数计算键值，直到找到空位。&lt;/p&gt;
&lt;h3 id=&quot;哈希表代码实现&quot;&gt;哈希表代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define null -99999
#define notFound -1
using namespace std;


typedef struct CellNode* Cell;
struct CellNode
{
        int Data;
};

//哈希表结构体
typedef struct HashTlNode* HashTable;
struct HashTlNode
{
        int TableSize;
        Cell Table;
};

//判断一个数是否为素数
bool isPrime(int n) {
        if (n &amp;lt; 2) {
                return false;
        }
        else if (n == 2 || n == 3) {
                return true;
        }
        else if(n%6==1||n%6==5){
                double p = sqrt(n);
                for (int i = 2; i &amp;lt;= p; i++)
                {
                        if (n % i == 0) {
                                return false;
                        }
                }
                return true;
        }
        else {
                return false;
        }
}

//求一个距离最小的素数
int NextPrime(int n) {
        //如果N已经是素数,那么他填满了，在查找不存在的数时一定会死环
        //所以我们去找下一个素数
        if (isPrime(n)) {
                n++;
        }
        //必须是素数,而且可以写成4k+3的形式，这样保证平方探测时不会出现死环。
        while (!(isPrime(n)&amp;amp;&amp;amp;n%4==3))
        {
                n++;
        }
        return n;
}

//创建空的哈希表
HashTable CreatHashTable(int TableSize) {
        HashTable H = (HashTable)malloc(sizeof(struct HashTlNode));
        H-&amp;gt;TableSize = NextPrime(TableSize);
        H-&amp;gt;Table = (Cell)malloc(sizeof(struct CellNode) * H-&amp;gt;TableSize);
        for (int i = 0; i &amp;lt; H-&amp;gt;TableSize; i++)
        {
                H-&amp;gt;Table[i].Data = null;
        }
        return H;
}

//散列函数
int HashFunction(int key, HashTable H) {
        return key % H-&amp;gt;TableSize;
}

//查找
int find(HashTable H,int Key) {
        int currentPos, NewPos;
        int Cnum = 0;
        currentPos = NewPos = HashFunction(Key, H);
        while (H-&amp;gt;Table[NewPos].Data!=null&amp;amp;&amp;amp; H-&amp;gt;Table[NewPos].Data != Key)
        {
                if (++Cnum % 2 != 0) {
                        NewPos = currentPos + (Cnum + 1) * (Cnum + 1) / 4;
                        while (NewPos&amp;gt;=H-&amp;gt;TableSize)
                        {
                                NewPos -= H-&amp;gt;TableSize;
                        }
                }
                else {
                        NewPos = currentPos - Cnum * Cnum / 4;
                        while (NewPos &amp;lt;0)
                        {
                                NewPos += H-&amp;gt;TableSize;
                        }
                }
        }
        if (H-&amp;gt;Table[NewPos].Data == null) {
                NewPos = notFound;
        }
        return NewPos;
}

//插入
void Insert(int key,HashTable H) {
        int currentPos, NewPos;
        int Cnum = 0;
        currentPos = NewPos = HashFunction(key, H);
        while (H-&amp;gt;Table[NewPos].Data != null)
        {
                if (++Cnum % 2 != 0) {
                        NewPos = currentPos + (Cnum + 1) * (Cnum + 1) / 4;
                        while (NewPos &amp;gt;= H-&amp;gt;TableSize)
                        {
                                NewPos -= H-&amp;gt;TableSize;
                        }
                }
                else {
                        NewPos = currentPos - Cnum * Cnum / 4;
                        while (NewPos &amp;lt; 0)
                        {
                                NewPos += H-&amp;gt;TableSize;
                        }
                }
        }
        H-&amp;gt;Table[NewPos].Data = key;
}

int main() {
        int n,t,array[100];
        scanf_s(&quot;%d&quot;, &amp;amp;n);
        HashTable H = CreatHashTable(n);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf_s(&quot;%d&quot;, &amp;amp;t);
                array[i] = t;
                Insert(t, H);
        }
        printf(&quot;The hashtable size is %d\n&quot;,H-&amp;gt;TableSize);
        for (int i = 0; i &amp;lt; n; i++)
        {
                int p = find(H, array[i]);
                if (p != notFound) {
                        printf(&quot;%d in the %d\n&quot;, array[i], p);
                }
                else {
                        printf(&quot;%d not found\n&quot;, array[i]);
                }
        }
        while(scanf_s(&quot;%d&quot;, &amp;amp;t)!=EOF)
        {
                int p = find(H, t);
                if (p != notFound) {
                        printf(&quot;%d in the %d\n&quot;, t, p);
                }
                else {
                        printf(&quot;%d not found\n&quot;, t);
                }
        }
        return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;散列表的性能分析&quot;&gt;散列表的性能分析&lt;/h2&gt;
&lt;p&gt;平均查找长度（ASL）用来度量散列表查找效率：成功、不成功&lt;br/&gt;影响产生冲突多少有以下三个因素：&lt;br/&gt;（1）散列函数是否均匀；&lt;br/&gt;（2）处理冲突的方法；&lt;br/&gt;（3）散列表的装填因子α。&lt;br/&gt;根据上面的性质我们知道，装填因子α越大，寻找一个元素越困难，如果彻底排满的话，又不去判断是否回到头，就一定会陷入死循环。&lt;/p&gt;
&lt;h2 id=&quot;课后练习4个小题&quot;&gt;课后练习(4个小题)&lt;/h2&gt;
&lt;h3 id=&quot;11-散列1-电话聊天狂人-25points&quot;&gt;11-散列1 电话聊天狂人 (25point(s))&lt;/h3&gt;
&lt;p&gt;给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。&lt;/p&gt;
&lt;p&gt;输入格式:&lt;br/&gt;输入首先给出正整数N（≤10^5​），为通话记录条数。随后N行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式:&lt;/strong&gt;&lt;br/&gt;在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4&lt;br/&gt;13005711862 13588625832&lt;br/&gt;13505711862 13088625832&lt;br/&gt;13588625832 18087925832&lt;br/&gt;15005713862 13588625832&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输出样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;13588625832 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;提取号码后六位做哈希函数，哈希表开到10^6,虽然空间浪费有点狠，但是时间可以到100ms左右，稳定过。只取4位，emm。。。小概率压线过。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;math.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;stdbool.h&amp;gt;
#define notFound -1

typedef struct CellNode* Cell;
struct CellNode
{
        char Data[12];
        int isEmpty;
        int time;
};

//哈希表结构体
typedef struct HashTlNode* HashTable;
struct HashTlNode
{
        int TableSize;
        Cell Table;
};

//判断一个数是否为素数
bool isPrime(int n) {
        if (n &amp;lt; 2) {
                return false;
        }
        else if (n == 2 || n == 3) {
                return true;
        }
        else if (n % 6 == 1 || n % 6 == 5) {
                double p = sqrt(n);
                for (int i = 2; i &amp;lt;= p; i++)
                {
                        if (n % i == 0) {
                                return false;
                        }
                }
                return true;
        }
        else {
                return false;
        }
}

//求一个距离最小的素数
int NextPrime(int n) {
        //如果N已经是素数,那么他填满了，在查找不存在的数时一定会死环
        //所以我们去找下一个素数
        if (isPrime(n)) {
                n++;
        }
        //必须是素数,而且可以写成4k+3的形式，这样保证平方探测时不会出现死环。
        while (!(isPrime(n) &amp;amp;&amp;amp; n % 4 == 3))
        {
                n++;
        }
        return n;
}

//创建空的哈希表
HashTable CreatHashTable(int TableSize) {
        HashTable H = (HashTable)malloc(sizeof(struct HashTlNode));
        H-&amp;gt;TableSize = NextPrime(TableSize);
        H-&amp;gt;Table = (Cell)malloc(sizeof(struct CellNode) * H-&amp;gt;TableSize);
        for (int i = 0; i &amp;lt; H-&amp;gt;TableSize; i++)
        {
                H-&amp;gt;Table[i].isEmpty = 1;
        }
        return H;
}

//散列函数
int HashFunction(char key[], HashTable H) {
        char result[7];
        strncpy(result, key + 5, 7);
        return atoi(result);
}

//插入
void Insert(char key[], HashTable H) {
        int currentPos, NewPos;
        int Cnum = 0;
        currentPos = NewPos = HashFunction(key, H);
        //循环结束条件，找到元素或者找不到（找到了未被使用的空间）。
        while (H-&amp;gt;Table[NewPos].isEmpty != 1)
        {
                //判断是否相同，相同直接跳出
                if (strcmp(key,H-&amp;gt;Table[NewPos].Data)==0) {
                        break;
                }
                else if (++Cnum % 2 != 0) {
                        NewPos = currentPos + (Cnum + 1) * (Cnum + 1) / 4;
                        while (NewPos &amp;gt;= H-&amp;gt;TableSize)
                        {
                                NewPos -= H-&amp;gt;TableSize;
                        }
                }
                else {
                        NewPos = currentPos - Cnum * Cnum / 4;
                        while (NewPos &amp;lt; 0)
                        {
                                NewPos += H-&amp;gt;TableSize;
                        }
                }
        }
        //没有找到，创建新的
        if (H-&amp;gt;Table[NewPos].isEmpty==1) {
                H-&amp;gt;Table[NewPos].isEmpty = 0;
                strcpy(H-&amp;gt;Table[NewPos].Data, key);
                H-&amp;gt;Table[NewPos].time = 1;
        }
        else {
                H-&amp;gt;Table[NewPos].time++;
        }
}

//find 电话聊天狂人
void find(HashTable H) {
        int count = 1;
        int max = 0;
        for (int i = 1; i &amp;lt; H-&amp;gt;TableSize; i++)
        {
                if (H-&amp;gt;Table[i].isEmpty != 1) {
                        if (H-&amp;gt;Table[i].time &amp;gt; (H-&amp;gt;Table[max].time)) {
                                max = i;
                                count = 1;
                        }
                        else if(H-&amp;gt;Table[i].time == (H-&amp;gt;Table[max].time)){
                                if (strcmp(H-&amp;gt;Table[i].Data, H-&amp;gt;Table[max].Data)&amp;lt;0) {
                                        max = i;
                                }
                                count++;
                        }
                }
        }
        printf(&quot;%s %d&quot;, H-&amp;gt;Table[max].Data, H-&amp;gt;Table[max].time);
        if (count == 1) {
                printf(&quot;\n&quot;);
        }
        else {
                printf(&quot; %d\n&quot;,count);
        }
}
int main() {
        int n;
        char phone[12];
        scanf(&quot;%d&quot;, &amp;amp;n);
        HashTable H = CreatHashTable(1000000);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%s&quot;, phone);
                Insert(phone, H);
                scanf(&quot;%s&quot;, phone);
                Insert(phone, H);
        }
        find(H);
        return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;11-散列2-hashing-25points&quot;&gt;11-散列2 Hashing (25point(s))&lt;/h3&gt;
&lt;p&gt;The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.&lt;/p&gt;
&lt;p&gt;Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;br/&gt;Each input file contains one test case. For each case, the first line contains two positive numbers: MSize (≤10^4) and N (≤MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output Specification:&lt;/strong&gt;&lt;br/&gt;For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print &quot;-&quot; instead.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sample Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4 4&lt;br/&gt;10 6 4 15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 1 4 -&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;题目的意思是让做散列插入，用仅正向平方探测解决冲突，如果解决不了，就是出现了环，就要输出-，否则输出他的位置。题目的难点在于如何判断环的出现。根据数学可以证明，平方探测的次数达到整个表的一半时，就说明无法插入了，如何得来呢：假设现在进行到了第n次(n&amp;lt;size)，它的平方探测增长值对应到&lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(mod\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(size\)&lt;/span&gt;，我们令一个数m(m&amp;lt;size)且m + n = size。那么n 可以被表示成(size - m)，它的平方探测增长值可写成&lt;span class=&quot;math inline&quot;&gt;\((size-m)^2\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(mod\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(size\)&lt;/span&gt; =&amp;gt; &lt;span class=&quot;math inline&quot;&gt;\((size^2+2*m*size+m^2)\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(mod\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(size\)&lt;/span&gt; =&amp;gt; &lt;span class=&quot;math inline&quot;&gt;\(m^2\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(mod\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(size\)&lt;/span&gt;。因为前两项中包含size，故对他们求于一定为0。到现在我们证明了，对于数m，n(m + n = size 且 m，n &amp;lt; size)，它们对应的平方探测值相同。也就是，平方探测值关于size/2对称。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define null -99999
#define notFound -1
using namespace std;


typedef struct CellNode* Cell;
struct CellNode
{
        int Data;
};

//哈希表结构体
typedef struct HashTlNode* HashTable;
struct HashTlNode
{
        int TableSize;
        Cell Table;
};

//判断一个数是否为素数
bool isPrime(int n) {
        if (n &amp;lt; 2) {
                return false;
        }
        else if (n == 2 || n == 3) {
                return true;
        }
        else if (n % 6 == 1 || n % 6 == 5) {
                double p = sqrt(n);
                for (int i = 2; i &amp;lt;= p; i++)
                {
                        if (n % i == 0) {
                                return false;
                        }
                }
                return true;
        }
        else {
                return false;
        }
}

//求一个距离最小的素数
int NextPrime(int n) {
        while (!isPrime(n))
        {
                n++;
        }
        return n;
}

//创建空的哈希表
HashTable CreatHashTable(int TableSize) {
        HashTable H = (HashTable)malloc(sizeof(struct HashTlNode));
        H-&amp;gt;TableSize = NextPrime(TableSize);
        H-&amp;gt;Table = (Cell)malloc(sizeof(struct CellNode) * H-&amp;gt;TableSize);
        for (int i = 0; i &amp;lt; H-&amp;gt;TableSize; i++)
        {
                H-&amp;gt;Table[i].Data = null;
        }
        return H;
}

//散列函数
int HashFunction(int key, HashTable H) {
        return key % H-&amp;gt;TableSize;
}

//插入
void Insert(int key, HashTable H) {
        int currentPos, NewPos;
        int Cnum = 0,end =H-&amp;gt;TableSize;
        currentPos = NewPos = HashFunction(key, H);
        while (H-&amp;gt;Table[NewPos].Data != null)
        {
                Cnum++;
                NewPos = (currentPos + (Cnum) * (Cnum))% H-&amp;gt;TableSize;
                if (Cnum == end) {
                        printf(&quot;-&quot;);
                        return;
                }
        }
        H-&amp;gt;Table[NewPos].Data = key;
        printf(&quot;%d&quot;, NewPos);
}

int main() {
        int n, t;
        scanf(&quot;%d %d&quot;, &amp;amp;t,&amp;amp;n);
        HashTable H = CreatHashTable(t);
        scanf(&quot;%d&quot;, &amp;amp;t);
        Insert(t, H);
        for (int i = 1; i &amp;lt; n; i++)
        {
                printf(&quot; &quot;);
                scanf(&quot;%d&quot;, &amp;amp;t);
                Insert(t, H);
        }
        printf(&quot;\n&quot;);
        return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;11-散列3-qq帐户的申请与登陆-25points&quot;&gt;11-散列3 QQ帐户的申请与登陆 (25point(s))&lt;/h3&gt;
&lt;p&gt;实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。&lt;/p&gt;
&lt;p&gt;输入格式:&lt;br/&gt;输入首先给出一个正整数N（≤10^​5），随后给出N行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式:&lt;/strong&gt;&lt;br/&gt;针对每条指令，给出相应的信息：&lt;/p&gt;
&lt;p&gt;1）若新申请帐户成功，则输出“New: OK”；&lt;br/&gt;2）若新申请的号码已经存在，则输出“ERROR: Exist”；&lt;br/&gt;3）若老帐户登陆成功，则输出“Login: OK”；&lt;br/&gt;4）若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；&lt;br/&gt;5）若老帐户密码错误，则输出“ERROR: Wrong PW”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;5&lt;br/&gt;L 1234567890 myQQ@qq.com&lt;br/&gt;N 1234567890 myQQ@qq.com&lt;br/&gt;N 1234567890 myQQ@qq.com&lt;br/&gt;L 1234567890 myQQ@qq&lt;br/&gt;L 1234567890 myQQ@qq.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输出样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ERROR: Not Exist&lt;br/&gt;New: OK&lt;br/&gt;ERROR: Exist&lt;br/&gt;ERROR: Wrong PW&lt;br/&gt;Login: OK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;一道简单的模拟题，我这里的散列函数是取QQ号的前6位，开了一个10的6次方大小的散列表，虽然有些浪费，但是速度凑合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;string.h&amp;gt;
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

typedef struct CellNode* Cell;
struct CellNode
{
        char Data[11];
        int isEmpty;
        char passw[17];
};

//哈希表结构体
typedef struct HashTlNode* HashTable;
struct HashTlNode
{
        int TableSize;
        Cell Table;
};

//判断一个数是否为素数
bool isPrime(int n) {
        if (n &amp;lt; 2) {
                return false;
        }
        else if (n == 2 || n == 3) {
                return true;
        }
        else if (n % 6 == 1 || n % 6 == 5) {
                double p = sqrt(n);
                for (int i = 2; i &amp;lt;= p; i++)
                {
                        if (n % i == 0) {
                                return false;
                        }
                }
                return true;
        }
        else {
                return false;
        }
}

//求一个距离最小的素数
int NextPrime(int n) {
        //如果N已经是素数,那么他填满了，在查找不存在的数时一定会死环
        //所以我们去找下一个素数
        if (isPrime(n)) {
                n++;
        }
        //必须是素数,而且可以写成4k+3的形式，这样保证平方探测时不会出现死环。
        while (!(isPrime(n) &amp;amp;&amp;amp; n % 4 == 3))
        {
                n++;
        }
        return n;
}

//创建空的哈希表
HashTable CreatHashTable(int TableSize) {
        HashTable H = (HashTable)malloc(sizeof(struct HashTlNode));
        H-&amp;gt;TableSize = NextPrime(TableSize);
        H-&amp;gt;Table = (Cell)malloc(sizeof(struct CellNode) * H-&amp;gt;TableSize);
        for (int i = 0; i &amp;lt; H-&amp;gt;TableSize; i++)
        {
                H-&amp;gt;Table[i].isEmpty = 1;
        }
        return H;
}

//散列函数
int HashFunction(char key[], HashTable H) {
        char result[7];
        strncpy(result, key, 6);
        return atoi(result);
}

//插入
void Insert(char key[], char pass[], HashTable H) {
        int currentPos, NewPos;
        int Cnum = 0;
        currentPos = NewPos = HashFunction(key, H);
        //循环结束条件，找到元素或者找不到（找到了未被使用的空间）。
        while (H-&amp;gt;Table[NewPos].isEmpty != 1)
        {
                //判断是否相同，相同直接跳出
                if (strcmp(key, H-&amp;gt;Table[NewPos].Data) == 0) {
                        break;
                }
                else if (++Cnum % 2 != 0) {
                        NewPos = currentPos + (Cnum + 1) * (Cnum + 1) / 4;
                        while (NewPos &amp;gt;= H-&amp;gt;TableSize)
                        {
                                NewPos -= H-&amp;gt;TableSize;
                        }
                }
                else {
                        NewPos = currentPos - Cnum * Cnum / 4;
                        while (NewPos &amp;lt; 0)
                        {
                                NewPos += H-&amp;gt;TableSize;
                        }
                }
        }
        //没有找到，创建新的
        if (H-&amp;gt;Table[NewPos].isEmpty == 1) {
                H-&amp;gt;Table[NewPos].isEmpty = 0;
                strcpy(H-&amp;gt;Table[NewPos].Data, key);
                strcpy(H-&amp;gt;Table[NewPos].passw, pass);
                printf(&quot;New: OK\n&quot;);
        }
        else {
                printf(&quot;ERROR: Exist\n&quot;);
        }
}

int stringcmp(const char pass1[], const char pass2[]) {
        for (int i = 0; i &amp;lt; max(strlen(pass1),strlen(pass2)); i++)
        {
                if (pass1[i] != pass2[i]) {
                        return 0;
                }
        }
        return 1;
}

//登陆
void Login(char key[], char pass[], HashTable H) {
        int currentPos, NewPos;
        int Cnum = 0;
        currentPos = NewPos = HashFunction(key, H);
        //循环结束条件，找到元素或者找不到（找到了未被使用的空间）。
        while (H-&amp;gt;Table[NewPos].isEmpty != 1)
        {
                //判断是否相同，相同直接跳出
                if (strcmp(key, H-&amp;gt;Table[NewPos].Data) == 0) {
                        break;
                }
                else if (++Cnum % 2 != 0) {
                        NewPos = currentPos + (Cnum + 1) * (Cnum + 1) / 4;
                        while (NewPos &amp;gt;= H-&amp;gt;TableSize)
                        {
                                NewPos -= H-&amp;gt;TableSize;
                        }
                }
                else {
                        NewPos = currentPos - Cnum * Cnum / 4;
                        while (NewPos &amp;lt; 0)
                        {
                                NewPos += H-&amp;gt;TableSize;
                        }
                }
        }
        //没有找到
        if (H-&amp;gt;Table[NewPos].isEmpty == 1) {
                printf(&quot;ERROR: Not Exist\n&quot;);
        }
        else {
                if (stringcmp(H-&amp;gt;Table[NewPos].passw,pass)) {
                        printf(&quot;Login: OK\n&quot;);
                }
                else {
                        printf(&quot;ERROR: Wrong PW\n&quot;);
                }
        }
}
int main() {
        int n;
        char id[11];
        char pas[17];
        char op = ' ';
        scanf(&quot;%d&quot;, &amp;amp;n);
        HashTable H = CreatHashTable(1000000);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;\n%c&quot;, &amp;amp;op);
                scanf(&quot;%s&quot;, id);
                scanf(&quot;%s&quot;, pas);
                if (op == 'L') {
                        Login(id, pas, H);
                        int p = 0;
                }
                else if (op == 'N') {
                        Insert(id, pas, H);
                        int p = 0;
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;11-散列4-hashing---hard-version-30points&quot;&gt;11-散列4 Hashing - Hard Version (30point(s))&lt;/h3&gt;
&lt;p&gt;Given a hash table of size N, we can define a hash function H(x)=x%N. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers.&lt;/p&gt;
&lt;p&gt;However, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input Specification:&lt;/strong&gt;&lt;br/&gt;Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), which is the size of the hash table. The next line contains N integers, separated by a space. A negative integer represents an empty cell in the hash table. It is guaranteed that all the non-negative integers are distinct in the table.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output Specification:&lt;/strong&gt;&lt;br/&gt;For each test case, print a line that contains the input sequence, with the numbers separated by a space. Notice that there must be no extra space at the end of each line.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sample Input:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;11&lt;br/&gt;33 1 13 12 34 38 27 22 32 -1 21&lt;br/&gt;&lt;strong&gt;Sample Output:&lt;/strong&gt;&lt;br/&gt;1 13 12 21 33 34 38 27 22 32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;题目的大概意思是，先读入一个 n，然后传给你一个大小为N的散列表，如果散列表中的元素为负值，说明该位置是空的，而且该散列表在创建时，用的是散列表大小求余的散列函数，解决冲突的方式为线性探索。&lt;br/&gt;要求输出散列表的插入顺序，数字小的优先靠前。&lt;br/&gt;整个题目可以用一个拓扑排序，再加上一个优先队列(最小堆)来解决，不过优先队列比较麻烦而且该题数据量不大，就直接线性扫描了。对于一个位置是否对另一个位置会造成影响(也就是说这个位置的存在，导致了元素冲突)，可以通过下面的方式来判别，在初始时我们有计算过它的初始偏移量p = i - t % n， p大于哈希表尺寸时，p-=n。在我们输出一个元素后，循环遍历计算该元素到其他所有元素的距离，如果这个距离小于等于初始偏移量，就将该位置的元素偏移量减1。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;vector&amp;gt;
#define INFINITY 999999
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

typedef struct CellNode Cell;
struct CellNode
{
        int Data;
        int pos;
        int firstpos;
};

int main() {
        int n, t, invalid = 0;
        scanf(&quot;%d&quot;, &amp;amp;n);
        vector&amp;lt;Cell&amp;gt; v(n);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;t);
                v[i].Data = t;
                if (t &amp;lt; 0) {
                        v[i].firstpos = -1;
                        v[i].pos = -1;
                        invalid++;
                }
                else {
                        int p = i - t % n;
                        if (p &amp;lt; 0) {
                                p += n;
                        }
                        v[i].firstpos = p;
                        v[i].pos = p;
                }
        }
        //判断是否为第一个输出，是前面不输出空格
        bool isf = true;
        for (int i = 0; i &amp;lt; n-invalid; i++)
        {
                int p=0, minnum = INFINITY;
                //扫描全序列，找偏移为0且最小的点。
                for (int j = 0; j &amp;lt; n; j++)
                {
                        if (v[j].pos == 0 &amp;amp;&amp;amp; v[j].Data &amp;lt; minnum) {
                                minnum = v[j].Data;
                                p = j;
                        }
                }
                //输出且删除该点
                if (isf) {
                        printf(&quot;%d&quot;, minnum);
                        isf = false;
                }
                else {
                        printf(&quot; %d&quot;, minnum);
                }
                //因为p点而偏移的数，偏移量减去1
                for (int j = 0; j &amp;lt; n; j++)
                {
                        int dis = j - p;
                        if (dis &amp;lt; 0) {
                                dis += n;
                        }
                        //因为p点而偏移
                        if (v[j].firstpos &amp;gt;= dis) {
                                v[j].pos--;
                        }
                }
                v[p].pos = -1;
        }
        printf(&quot;\n&quot;);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 15 Dec 2020 15:18:00 +0000</pubDate>
<dc:creator>W&amp;B</dc:creator>
<og:description>#散列表 ##什么是散列表 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-Miscellaneous/p/14141627.html</dc:identifier>
</item>
<item>
<title>容器编排系统之K8s资源标签、标签选择器、资源注解 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14141080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14141080.html</guid>
<description>&lt;p&gt;　　前文我们聊到了使用k8s资源配置清单定义资源的相关话题，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14132890.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14132890.html&lt;/a&gt;；今天我们来聊下资源标签，标签选择器以及资源注解相关话题；&lt;/p&gt;
&lt;p&gt;　　1、标签和标签选择器&lt;/p&gt;
&lt;p&gt;　　对于pod来讲，我们知道使用pod控制器创建的pod在pod故障以后，重建后的pod它的ip地址和名称是变化的，为了解决pod访问问题，我们特此创建了service，我们访问service的ip地址就可以正常访问到pod；那么问题来了，service是怎样去关联pod的呢？我们知道在k8s上如果pod使用pod控制创建的pod，在pod发生故障以后，对应pod会被对应的控制器重启或重建，一个pod重建以后，对应的ip地址和名称都是会发生变化的，所以靠ip地址和名称关联pod是不行的；那靠什么关联pod呢？在k8s上是使用的标签和标签选择器的机制实现资源和资源见相互关联的；&lt;/p&gt;
&lt;p&gt;　　什么是标签？它的作用是干嘛用的？&lt;/p&gt;
&lt;p&gt;　　所谓标签就是指一个键值数据，在k8s上任何资源都可以拥有标签；我们可以在创建资源时在配置清单中指定，也可以创建好资源以后再使用命令添加标签；有了标签以后，我们后续就可以根据标签来管理对应的资源；一个资源可以拥有多个标签，同时一个标签也可以附加给多个资源；我们可以理解为标签就是用来逻辑的对资源进行分组，拥有相同标签的资源为一组；标签的作用是方便用户管理资源；比如在k8s上运行了几百个pod，我们想要管理功能相同的pod，就可以把具有相似功能的pod附加同一个标签，然后要管理这些pod的时，直接指定拥有指定标签的pod即可；标签中的健名称通常由键前缀和键名组成，键前缀和键名用“/”分割，键前缀可以省略，键名最多只能使用63个字符，可使用字母，数字，连接号（-），下划线，点号等字符，并且只能以数字或字母开头和结尾；键前缀必须为dns子域名格式且不能超过253个字符，省略前缀时，健将视为用户的私有数据；有前缀可以视为k8s第三方组件可以应用的资源；不过kubernetes.io这个前缀是预留给k8s核心组件使用，所以我们在定义键前缀时，不能使用“kubernetes.io”；&lt;/p&gt;
&lt;p&gt;　　标签选择器&lt;/p&gt;
&lt;p&gt;　　所谓标签选择器是指一组表达式，主要用来表达标签查询条件或选择标准；在k8s上支持两种类型的标签选择器，一种是基于等值关系的选择器，一种是基于集合关系的选择器；基于等值关系的选择器，通常可以用=、==或！=这些操作符来表示关系；前两个表示同一个意思相等，后面的！=表示不等；基于集合关系的选择器可以用in,notin和exists这三个操作符；in表示指定键名的值在给定的列表中就表示满足条件；notin和in相反；exists表示是否存在对应的键名，比如key表示所有存在此键名标签的资源；！key表示所有不存在此键名标签的资源；此外在使用标签选择器时遵循以下逻辑，第一如果同时指定多个选择器时，选择器之间是逻辑与的关系，表示指定的选择器都要同时满足；第二使用空值的标签选择器意味着每个资源都被选中；第三空的标签选择器将无法选出任何资源；空值和空的选择器是两会事，一个是有键名但其值为空，另一个是连键名都没有；&lt;/p&gt;
&lt;p&gt;　　示例：在资源清单中定义标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo5.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo5
  namespace: testing
  labels:
    app: nginx
    env: testing
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
      - containerPort: 80
        hostPort: 8080
        name: web
        protocol: TCP
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在资源清单中使用labels字段来定义标签，该字段的值是一个字符型字典；键名和值是用户自定义的；&lt;/p&gt;
&lt;p&gt;　　应用资源配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f pod-demo5.yaml
pod/nginx-pod-demo5 created
[root@master01 ~]# kubectl get pod -n testing
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo    1/1     Running   1          6d23h
nginx-pod-demo5   1/1     Running   0          12s
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看pod是类出显示标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n testing --show-labels
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   &amp;lt;none&amp;gt;
nginx-pod-demo5   1/1     Running   0          78s     app=nginx,env=testing
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：查看pod时可以使用--show-labels选项来显示对应pod的标签；标签较多时，也可以使用-L来指定显示那些标签；&lt;/p&gt;
&lt;p&gt;　　显示指定标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n testing -L app
NAME              READY   STATUS    RESTARTS   AGE     APP
nginx-pod-demo    1/1     Running   1          6d23h   
nginx-pod-demo5   1/1     Running   0          3m2s    nginx
[root@master01 ~]# kubectl get pod -n testing -L app,env
NAME              READY   STATUS    RESTARTS   AGE     APP     ENV
nginx-pod-demo    1/1     Running   1          6d23h           
nginx-pod-demo5   1/1     Running   0          3m10s   nginx   testing
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用命令管理标签&lt;/p&gt;
&lt;p&gt;　　修改标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n testing --show-labels
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   &amp;lt;none&amp;gt;
nginx-pod-demo5   1/1     Running   0          8m42s   app=nginx,env=testing
[root@master01 ~]# kubectl label -n testing  pod/nginx-pod-demo5 app=ngx  
error: 'app' already has a value (nginx), and --overwrite is false
[root@master01 ~]# kubectl label -n testing  pod/nginx-pod-demo5 app=ngx  --overwrite
pod/nginx-pod-demo5 labeled
[root@master01 ~]# kubectl get pod -n testing --show-labels               
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   &amp;lt;none&amp;gt;
nginx-pod-demo5   1/1     Running   0          9m1s    app=ngx,env=testing
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用kubectl label命令修改标签时必须添加--overwrite选项来指定强制覆盖原有标签的值；&lt;/p&gt;
&lt;p&gt;　　添加新标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n testing --show-labels
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   &amp;lt;none&amp;gt;
nginx-pod-demo5   1/1     Running   0          11m     app=ngx,env=testing
[root@master01 ~]# kubectl label -n testing pod/nginx-pod-demo app=ngx env=testing
pod/nginx-pod-demo labeled
[root@master01 ~]# kubectl get pod -n testing --show-labels                       
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   app=ngx,env=testing
nginx-pod-demo5   1/1     Running   0          12m     app=ngx,env=testing
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　删除标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n testing --show-labels
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   app=ngx,env=testing
nginx-pod-demo5   1/1     Running   0          12m     app=ngx,env=testing
[root@master01 ~]# kubectl label -n testing pod/nginx-pod-demo app-
pod/nginx-pod-demo labeled
[root@master01 ~]# kubectl get pod -n testing --show-labels        
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   env=testing
nginx-pod-demo5   1/1     Running   0          14m     app=ngx,env=testing
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：删除标签只需要在要删除的标签键名后面加上“-”号即可；&lt;/p&gt;
&lt;p&gt;　　示例：使用标签选择器过滤出标签为app=ngx-dep的资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod --show-labels
NAME                         READY   STATUS    RESTARTS   AGE    LABELS
myapp-dep-5bc4d8cc74-cvkbc   1/1     Running   1          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
myapp-dep-5bc4d8cc74-gmt7w   1/1     Running   2          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
myapp-dep-5bc4d8cc74-gqhh5   1/1     Running   1          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
ngx-dep-5c8d96d457-w6nss     1/1     Running   1          7d3h   app=ngx-dep,pod-template-hash=5c8d96d457
[root@master01 ~]# kubectl get pod -l &quot;app=ngx-dep&quot; -L app
NAME                       READY   STATUS    RESTARTS   AGE    APP
ngx-dep-5c8d96d457-w6nss   1/1     Running   1          7d3h   ngx-dep
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用标签选择器来过滤资源，需要用-l选项来指定标签选择器；&lt;/p&gt;
&lt;p&gt;　　查看app!=ngx-dep的pod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod --show-labels          
NAME                         READY   STATUS    RESTARTS   AGE    LABELS
myapp-dep-5bc4d8cc74-cvkbc   1/1     Running   1          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
myapp-dep-5bc4d8cc74-gmt7w   1/1     Running   2          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
myapp-dep-5bc4d8cc74-gqhh5   1/1     Running   1          7d2h   app=myapp-dep,pod-template-hash=5bc4d8cc74
ngx-dep-5c8d96d457-w6nss     1/1     Running   1          7d3h   app=ngx-dep,pod-template-hash=5c8d96d457
[root@master01 ~]# kubectl get pod -l &quot;app!=ngx-dep&quot; -L app
NAME                         READY   STATUS    RESTARTS   AGE    APP
myapp-dep-5bc4d8cc74-cvkbc   1/1     Running   1          7d2h   myapp-dep
myapp-dep-5bc4d8cc74-gmt7w   1/1     Running   2          7d2h   myapp-dep
myapp-dep-5bc4d8cc74-gqhh5   1/1     Running   1          7d2h   myapp-dep
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　指定多个标签选择器过滤资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod  -n testing --show-labels                                    
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          6d23h   env=testing
nginx-pod-demo3   1/1     Running   0          3m24s   app=nginx,env=test,rel=stable
nginx-pod-demo4   1/1     Running   0          3m48s   app=nginx,env=testing,rel=stable
nginx-pod-demo5   1/1     Running   0          31m     app=ngx,env=testing
[root@master01 ~]# kubectl get pod -n testing -l &quot;app=nginx,env=testing&quot;
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo4   1/1     Running   0          4m21s
[root@master01 ~]# kubectl get pod -n testing -l &quot;app=nginx,env!=testing&quot;
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo3   1/1     Running   0          4m30s
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用基于集合关系的标签选择器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod  -n testing --show-labels             
NAME              READY   STATUS    RESTARTS   AGE     LABELS
nginx-pod-demo    1/1     Running   1          7d      env=testing
nginx-pod-demo3   1/1     Running   0          5m33s   app=nginx,env=test,rel=stable
nginx-pod-demo4   1/1     Running   0          5m57s   app=nginx,env=testing,rel=stable
nginx-pod-demo5   1/1     Running   0          33m     app=ngx,env=testing
[root@master01 ~]# kubectl get pod -n testing -l &quot;app in (ngx,nginx)&quot;
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo3   1/1     Running   0          6m20s
nginx-pod-demo4   1/1     Running   0          6m44s
nginx-pod-demo5   1/1     Running   0          34m
[root@master01 ~]# kubectl get pod -n testing -l &quot;app notin (ngx,nginx)&quot; 
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   1          7d
[root@master01 ~]# kubectl get pod -n testing -l &quot;app&quot;
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo3   1/1     Running   0          6m56s
nginx-pod-demo4   1/1     Running   0          7m20s
nginx-pod-demo5   1/1     Running   0          34m
[root@master01 ~]# kubectl get pod -n testing -l '!app'
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   1          7d
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：！在shell环境中有特殊的意义，所以在指定！key时需要用单引号强应用；&lt;/p&gt;
&lt;p&gt;　　2、资源注解&lt;/p&gt;
&lt;p&gt;　　在k8s上除了可以使用标签来给资源附加自定义元数据外，也可以使用注解给资源附加自定义元数据；标签和注解两者不同的是，标签可以用于标签选择器，而注解不能，它只是为方便用户在给对应资源添加自定义元数据提供一个接口，其次在标签中，标签的的键名和值都不能超过63个字符，而在资源注解中不受字符大小的限定，它可大可小，值可以为结构化数据或非结构化数据；对于在标签中禁止使用的字符，在资源注解中都不受限制；&lt;/p&gt;
&lt;p&gt;　　查看注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201215214607059-380672421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：查看注解可以使用describe子命令来查看，对应Annotations字段就是用来标注对应资源的注解信息；也可以使用kubectl get 使用-o选项输出为yaml格式的信息；找到对应的Annotations字段信息即可；&lt;/p&gt;
&lt;p&gt;　　使用命令添加注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl annotate pod/ngx-dep-5c8d96d457-w6nss description=&quot;this is nginx pod &quot;
pod/ngx-dep-5c8d96d457-w6nss annotated
[root@master01 ~]# kubectl describe pod ngx-dep-5c8d96d457-w6nss|grep &quot;Annotations&quot;
Annotations:  description: this is nginx pod 
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用资源配置清单添加注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo5.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo5
  namespace: testing
  labels:
    app: nginx
    env: testing
  annotations:
    descriptions: &quot;this is test pod &quot;
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    ports:
      - containerPort: 80
        hostPort: 8080
        name: web
        protocol: TCP
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用资源配置清单定义注解信息需要用到annotations字段，该字段的值为一个字符型字典；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f pod-demo5.yaml
pod/nginx-pod-demo5 configured
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看对应资源的注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n testing
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo    1/1     Running   1          7d
nginx-pod-demo3   1/1     Running   0          45m
nginx-pod-demo4   1/1     Running   0          45m
nginx-pod-demo5   1/1     Running   0          73m
[root@master01 ~]# kubectl describe -n testing pod/nginx-pod-demo5|grep &quot;Annotations&quot;
Annotations:  descriptions: this is test pod 
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是在k8s上使用标签，标签选择器以及资源注解相关话题的说明；&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 14:48:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了使用k8s资源配置清单定义资源的相关话题，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/14132890.html；今天我们来聊下资源标签，标签选</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14141080.html</dc:identifier>
</item>
<item>
<title>【Tomcat 源码系列】Tomcat 整体结构 - 楷哥</title>
<link>http://www.cnblogs.com/zzk0/p/14130575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzk0/p/14130575.html</guid>
<description>&lt;p&gt;在开始看源码细节之前，首先要想好要看的问题。想好问题之后，我们该如何寻找要看的代码呢？&lt;/p&gt;
&lt;p&gt;其实，这就好像去爬山的时候，突然想去上厕所，如果有一副地图，那么我们可以很快就找到厕所的位置。带着问题看源码也是同样的道理，如果我们知道源码每个部分的结构是做什么的，那么我们就可以很快定位代码。&lt;/p&gt;
&lt;p&gt;这篇博客主要介绍 Tomcat 的整体设计、源码结构。&lt;/p&gt;
&lt;h2 id=&quot;tomcat-本质&quot;&gt;Tomcat 本质&lt;/h2&gt;
&lt;p&gt;Tomcat 本质上是什么呢？我们上 Tomcat 的官网看看。下面这段来自官网，Tomcat 本质上就是实现了部分 Jakarta EE (Java EE 新的名字) 规范。我们日常使用中，一般都会说 Tomcat 是一个 Web 服务器，它可以处理 Http 相关的请求。因此，Tomcat 是一个实现了部分 Jakarta EE 规范的 Web 服务器。它有两个主要的部分组成，一个是 Connector，一个是 Container。Connector 负责接收 Http 请求，并将请求转发给 Container 去处理，Container 负责处理请求的内容，加载对应的 Servlet，将请求的结果返回给 Connector。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket technologies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先从源码结构开始。Tomcat 服务器相关的代码在 java 文件夹下面，后面我们在进入这个文件夹去分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201213214551841-1493160230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;modules 文件夹下面，有四个部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201213220114178-1488164293.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Tomcat 源码位于 java 文件夹下面。这个 java 文件夹下面的每个东西是干什么事情的呢？下面简要说说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215130506937-1323251881.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-jakarta&quot;&gt;1. Jakarta&lt;/h2&gt;
&lt;p&gt;位于 &lt;code&gt;java/jakarta&lt;/code&gt;，这个文件夹下面保存的是新的 Java EE 规范，现在的 Java EE 也不这么叫了，要改名叫 Jakarta EE。详见&lt;a href=&quot;https://blogs.oracle.com/javamagazine/transition-from-java-ee-to-jakarta-ee&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果去看 tomcat 9，会发现这个文件夹是 javax，不是 jakarta。tomcat 10 的一个重大转变就是从 javax 命名空间转向 jakarta。&lt;/p&gt;
&lt;p&gt;每个规范是做什么的呢？这里参考官网[2]的&lt;a href=&quot;https://jakarta.ee/specifications/&quot; target=&quot;_blank&quot;&gt;规范&lt;/a&gt;简要说说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215131016476-1386903664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;annotation&quot;&gt;annotation&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132429914-531714520.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注解&lt;/strong&gt;。&lt;a href=&quot;https://jakarta.ee/specifications/annotations/2.0/annotations-spec-2.0.html#goals&quot; target=&quot;_blank&quot;&gt;https://jakarta.ee/specifications/annotations/2.0/annotations-spec-2.0.html#goals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面引用了网页中的说法，annotation 这个模块的作用是定义了一些公用的注解，避免在不同的规范中定义相同的注解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;It is hoped that this will help to avoid unnecessary redundancy or duplication between annotations defined in different Jakarta EE specifications&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ejb&quot;&gt;ejb&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132408094-535499327.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enterprise Beans&lt;/strong&gt;。&lt;a href=&quot;https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.htm&quot; target=&quot;_blank&quot;&gt;https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;EJB 是开发和部署基于组件的企业级应用的架构。EJB 是一个架构。我是第一次听说 EJB，所以只能是引用它的说法，看个定义了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The Enterprise Beans architecture is an architecture for the development and deployment of component-based business applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;el&quot;&gt;el&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132346590-143176187.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Expression Language&lt;/strong&gt;。&lt;a href=&quot;https://jakarta.ee/specifications/expression-language/4.0/jakarta-expression-language-spec-4.0.html&quot; target=&quot;_blank&quot;&gt;https://jakarta.ee/specifications/expression-language/4.0/jakarta-expression-language-spec-4.0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个用在 jsp 中，用于求解表达式的值。&lt;/p&gt;
&lt;h3 id=&quot;mail&quot;&gt;mail&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132332846-1369734672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无需看规范，知道它是邮件相关的就行。&lt;/p&gt;
&lt;h3 id=&quot;persistence&quot;&gt;persistence&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132312021-114630912.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;持久化相关。&lt;/p&gt;
&lt;h3 id=&quot;security&quot;&gt;security&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132249929-196320003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安全相关。&lt;/p&gt;
&lt;h3 id=&quot;servlet&quot;&gt;servlet&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132230809-2047008055.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是重头戏。从本质上说，tomcat 就是一个实现了 servlet 规范的一个容器。servlet 定义了服务端处理 Http 请求和响应的规范。&lt;/p&gt;
&lt;h3 id=&quot;transaction&quot;&gt;transaction&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132746106-780139494.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事务相关的接口。&lt;/p&gt;
&lt;h3 id=&quot;websocket&quot;&gt;websocket&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215132909483-957905264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义了使用 websocket 协议的服务端和客户端 API&lt;/p&gt;
&lt;h3 id=&quot;xmlws&quot;&gt;xml.ws&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215133101061-1078466662.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义了基于 SOAP 协议的 xml 方式的 web 服务。&lt;/p&gt;
&lt;h2 id=&quot;2-orgapache&quot;&gt;2. org.apache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;org/apache&lt;/code&gt; 文件夹下面是关于上面规范的部分实现。Tomcat 本质上就是 Jakarta EE 某些规范实现的合集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215134033552-936875748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;catalina&quot;&gt;Catalina&lt;/h3&gt;
&lt;p&gt;tomcat 的核心代码，可以理解为一个 servlet 容器。&lt;/p&gt;
&lt;h3 id=&quot;coyote&quot;&gt;coyote&lt;/h3&gt;
&lt;p&gt;tomcat 的核心代码，负责将网络请求转化后和 Catalina 进行通信。&lt;/p&gt;
&lt;h3 id=&quot;el-1&quot;&gt;el&lt;/h3&gt;
&lt;p&gt;上面的 Jakarta EE 中 el 的实现。&lt;/p&gt;
&lt;h3 id=&quot;jasper&quot;&gt;jasper&lt;/h3&gt;
&lt;p&gt;负责将 jsp 转为 java 代码。&lt;/p&gt;
&lt;h3 id=&quot;juli&quot;&gt;juli&lt;/h3&gt;
&lt;p&gt;日志相关的工具。&lt;/p&gt;
&lt;h3 id=&quot;naming&quot;&gt;naming&lt;/h3&gt;
&lt;p&gt;命名空间相关。&lt;/p&gt;
&lt;h3 id=&quot;tomcat&quot;&gt;tomcat&lt;/h3&gt;
&lt;p&gt;各种辅助工具，包括 websocket 的实现。&lt;/p&gt;

&lt;p&gt;图片来自于 &lt;a href=&quot;https://medium.com/@nikhilmanikonda/tomcat-who-i-am-and-what-i-do-e91ff72fb2ea&quot; target=&quot;_blank&quot;&gt;Medium&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215134302467-1010126314.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;简化&quot;&gt;简化&lt;/h3&gt;
&lt;p&gt;How Tomcat Works 一书中，把 Tomcat 简化为 Connector 和 Container。&lt;/p&gt;
&lt;p&gt;Connector 负责接收 Http 请求，并将请求转发给 Container 去处理，Container 负责处理请求的内容，加载对应的 Servlet，将请求的结果返回给 Connector。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201215224634431-1771367262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这篇文章从源码层面，从设计层面介绍了 Tomcat 的整体结构。后面我们带着问题逐个分析源码，敬请期待。&lt;/p&gt;
&lt;p&gt;有不懂的地方，也欢迎在评论区中交流讨论。如有表述不准确的地方，希望能帮忙指出，谢谢~&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://blogs.oracle.com/javamagazine/transition-from-java-ee-to-jakarta-ee&quot; target=&quot;_blank&quot;&gt;https://blogs.oracle.com/javamagazine/transition-from-java-ee-to-jakarta-ee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://jakarta.ee/specifications/&quot; target=&quot;_blank&quot;&gt;https://jakarta.ee/specifications/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://medium.com/@nikhilmanikonda/tomcat-who-i-am-and-what-i-do-e91ff72fb2ea&quot; target=&quot;_blank&quot;&gt;https://medium.com/@nikhilmanikonda/tomcat-who-i-am-and-what-i-do-e91ff72fb2ea&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 14:47:00 +0000</pubDate>
<dc:creator>楷哥</dc:creator>
<og:description>一，前言 在开始看源码细节之前，首先要想好要看的问题。想好问题之后，我们该如何寻找要看的代码呢？ 其实，这就好像去爬山的时候，突然想去上厕所，如果有一副地图，那么我们可以很快就找到厕所的位置。带着问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzk0/p/14130575.html</dc:identifier>
</item>
<item>
<title>轮廓检测论文解读 | Richer Convolutional Features for Edge Detection | CVPR | 2017 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/14141441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/14141441.html</guid>
<description>&lt;p&gt;有什么问题可以加作者微信讨论，cyx645016617 上千人的粉丝群已经成立，氛围超好。为大家提供一个遇到问题有可能得到答案的平台。&lt;/p&gt;
&lt;h2 id=&quot;0-概述&quot;&gt;0 概述&lt;/h2&gt;
&lt;p&gt;这一篇文论在我看来，&lt;strong&gt;是CVPR 2015年 HED网络（holistically-nested edge detection）的一个改进，RCF的论文中也基本上和HED网络处处对比&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我们依稀记得HED模型有这样一个图：&lt;br/&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f05c5eac14466f8aeb1adb0cc62e87~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中有HED的五个side output的特征图，下图是RCF论文中的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a69917950fa47fd88435f86a16ceffc~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从这两个图的区别中来认识RCF相比HED的改进，大家可以看一看图。&lt;/p&gt;
&lt;p&gt;揭晓答案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HED是豹子的图片，但是RCF是两只小鸟的图片（手动狗头）&lt;/li&gt;
&lt;li&gt;HED中的是side output的输出的特征图，而RCF中是conv3_1,conv3_2，这意味着&lt;strong&gt;RCF似乎把每一个卷积之后的输出的特征图都作为了一个side output&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;没错，HED选取了5个side output，每一个side output都是池化层之前的卷积层输出的特征图；而RCF则对每一次卷积的输出特征图都作为side output，换句话说 &lt;strong&gt;最终的side output中，同一尺寸的输出可能不止一个&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果还没有理解，请看下面章节，模型结构。&lt;/p&gt;
&lt;h2 id=&quot;1-模型结构&quot;&gt;1 模型结构&lt;/h2&gt;
&lt;p&gt;RCF的backbone是VGG模型：&lt;br/&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d703c3726a184e33bfd271d2375aee61~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主干网络上分成state1到5，stage1有两个卷积层，stage2有两个卷积层，总共有13个卷积层，每一次卷积输出的图像，再额外接入一个1x1的卷积，来降低通道数，所以可以看到，图中有大量的21通道的卷积层。&lt;/li&gt;
&lt;li&gt;同一个stage的21通道的特征图经过通道拼接，变成42通道或者是63通道的特征图，然后再经过一个1x1的卷积层，来把通道数降低成1，再进过sigmoid层，输出的结果就是一个RCF模型中的side output了&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-损失函数&quot;&gt;2 损失函数&lt;/h2&gt;
&lt;p&gt;这里的损失函数其实和HED来说类似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b4106f3ec54590b1b5496b5d631d41~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先整体来看，损失函数依然使用二值交叉熵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/290a600a9f8d4c1d90003b1137d75d70~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(|Y^-|\)&lt;/span&gt; 表示 negative的像素值，&lt;span class=&quot;math inline&quot;&gt;\(|Y^+|\)&lt;/span&gt;表示positive的像素值。&lt;strong&gt;一般来说轮廓检测任务中，positive的样本应该是较少的，因此&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;的值较小，因此损失函数中第一行，y=0也就是计算非轮廓部分的损失的时候，就会增加一个较小的权重，来避免类别不均衡的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;损失函数中有两个常数，一个是&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;,这个就是权重常数，默认为1.1；另外一个是&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;。论文中的描述为：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;Edge datasets in this community are usually labeled by several annotators using their knowledge about the presences of objects and object parts. Though humans vary in cognition, these human-labeled edges for the same image share high consistency. For each image, we average all the ground truth to generate an edge probability map, which ranges from 0 to 1. Here, 0 means no annotator labeled at this pixel, and 1 means all annotators have labeled at this pixel. We consider the pixels with edge probability higher than η as positive samples and the pixels with edge probability equal to 0 as negative samples. Otherwise, if a pixel is marked by fewer than η of the annotators, this pixel may be semantically controversial to be an edge point. Thus, whether regarding it as positive or negative samples may confuse networks. So we ignore pixels in this category.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意就是：一般对数据集进行标注，是有多个人来完成的。不同的人虽然有不同的意识，但是他们对于同一个图片的轮廓标注往往是具有一致性。RCF网络最后的输出，是由5个side output融合产生的，因此你这个RCF的输出也应该把大于&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;的考虑为positive，然后小于&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;的考虑为negative。 &lt;strong&gt;其实这一点我自己在复现的时候并没有考虑，我看网上的github和官方的代码中，都没有考虑这个，都是直接交叉熵。。。我这就也就多此一举的讲解一下论文中的这个&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;的含义&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-pytorch部分代码&quot;&gt;3 pytorch部分代码&lt;/h2&gt;
&lt;p&gt;对于这个RCF论文来说，关键就是一个模型的构建，另外一个就是损失函数的构建，这里放出这两部分的代码，来帮助大家更好的理解上面的内容。&lt;/p&gt;
&lt;h3 id=&quot;31-模型部分&quot;&gt;3.1 模型部分&lt;/h3&gt;
&lt;p&gt;下面的代码在上采样部分的写法比较老旧，因为这个网上找来的pytorch版本估计比较老，当时还没有Conv2DTrans这样的函数封装，但是不妨碍大家通过代码来学习RCF。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class RCF(nn.Module):
    def __init__(self):
        super(RCF, self).__init__()
        #lr 1 2 decay 1 0
        self.conv1_1 = nn.Conv2d(3, 64, 3, padding=1)
        self.conv1_2 = nn.Conv2d(64, 64, 3, padding=1)

        self.conv2_1 = nn.Conv2d(64, 128, 3, padding=1)
        self.conv2_2 = nn.Conv2d(128, 128, 3, padding=1)

        self.conv3_1 = nn.Conv2d(128, 256, 3, padding=1)
        self.conv3_2 = nn.Conv2d(256, 256, 3, padding=1)
        self.conv3_3 = nn.Conv2d(256, 256, 3, padding=1)

        self.conv4_1 = nn.Conv2d(256, 512, 3, padding=1)
        self.conv4_2 = nn.Conv2d(512, 512, 3, padding=1)
        self.conv4_3 = nn.Conv2d(512, 512, 3, padding=1)

        self.conv5_1 = nn.Conv2d(512, 512, kernel_size=3,
                        stride=1, padding=2, dilation=2)
        self.conv5_2 = nn.Conv2d(512, 512, kernel_size=3,
                        stride=1, padding=2, dilation=2)
        self.conv5_3 = nn.Conv2d(512, 512, kernel_size=3,
                        stride=1, padding=2, dilation=2)
        self.relu = nn.ReLU()
        self.maxpool = nn.MaxPool2d(2, stride=2, ceil_mode=True)
        self.maxpool4 = nn.MaxPool2d(2, stride=1, ceil_mode=True)


        #lr 0.1 0.2 decay 1 0
        self.conv1_1_down = nn.Conv2d(64, 21, 1, padding=0)
        self.conv1_2_down = nn.Conv2d(64, 21, 1, padding=0)

        self.conv2_1_down = nn.Conv2d(128, 21, 1, padding=0)
        self.conv2_2_down = nn.Conv2d(128, 21, 1, padding=0)

        self.conv3_1_down = nn.Conv2d(256, 21, 1, padding=0)
        self.conv3_2_down = nn.Conv2d(256, 21, 1, padding=0)
        self.conv3_3_down = nn.Conv2d(256, 21, 1, padding=0)

        self.conv4_1_down = nn.Conv2d(512, 21, 1, padding=0)
        self.conv4_2_down = nn.Conv2d(512, 21, 1, padding=0)
        self.conv4_3_down = nn.Conv2d(512, 21, 1, padding=0)
        
        self.conv5_1_down = nn.Conv2d(512, 21, 1, padding=0)
        self.conv5_2_down = nn.Conv2d(512, 21, 1, padding=0)
        self.conv5_3_down = nn.Conv2d(512, 21, 1, padding=0)

        #lr 0.01 0.02 decay 1 0
        self.score_dsn1 = nn.Conv2d(21, 1, 1)
        self.score_dsn2 = nn.Conv2d(21, 1, 1)
        self.score_dsn3 = nn.Conv2d(21, 1, 1)
        self.score_dsn4 = nn.Conv2d(21, 1, 1)
        self.score_dsn5 = nn.Conv2d(21, 1, 1)
        #lr 0.001 0.002 decay 1 0
        self.score_final = nn.Conv2d(5, 1, 1)

    def forward(self, x):
        # VGG
        img_H, img_W = x.shape[2], x.shape[3]
        conv1_1 = self.relu(self.conv1_1(x))
        conv1_2 = self.relu(self.conv1_2(conv1_1))
        pool1   = self.maxpool(conv1_2)

        conv2_1 = self.relu(self.conv2_1(pool1))
        conv2_2 = self.relu(self.conv2_2(conv2_1))
        pool2   = self.maxpool(conv2_2)

        conv3_1 = self.relu(self.conv3_1(pool2))
        conv3_2 = self.relu(self.conv3_2(conv3_1))
        conv3_3 = self.relu(self.conv3_3(conv3_2))
        pool3   = self.maxpool(conv3_3)

        conv4_1 = self.relu(self.conv4_1(pool3))
        conv4_2 = self.relu(self.conv4_2(conv4_1))
        conv4_3 = self.relu(self.conv4_3(conv4_2))
        pool4   = self.maxpool4(conv4_3)

        conv5_1 = self.relu(self.conv5_1(pool4))
        conv5_2 = self.relu(self.conv5_2(conv5_1))
        conv5_3 = self.relu(self.conv5_3(conv5_2))

        conv1_1_down = self.conv1_1_down(conv1_1)
        conv1_2_down = self.conv1_2_down(conv1_2)
        conv2_1_down = self.conv2_1_down(conv2_1)
        conv2_2_down = self.conv2_2_down(conv2_2)
        conv3_1_down = self.conv3_1_down(conv3_1)
        conv3_2_down = self.conv3_2_down(conv3_2)
        conv3_3_down = self.conv3_3_down(conv3_3)
        conv4_1_down = self.conv4_1_down(conv4_1)
        conv4_2_down = self.conv4_2_down(conv4_2)
        conv4_3_down = self.conv4_3_down(conv4_3)
        conv5_1_down = self.conv5_1_down(conv5_1)
        conv5_2_down = self.conv5_2_down(conv5_2)
        conv5_3_down = self.conv5_3_down(conv5_3)

        so1_out = self.score_dsn1(conv1_1_down + conv1_2_down)
        so2_out = self.score_dsn2(conv2_1_down + conv2_2_down)
        so3_out = self.score_dsn3(conv3_1_down + conv3_2_down + conv3_3_down)
        so4_out = self.score_dsn4(conv4_1_down + conv4_2_down + conv4_3_down)
        so5_out = self.score_dsn5(conv5_1_down + conv5_2_down + conv5_3_down)
        ## transpose and crop way 
        weight_deconv2 =  make_bilinear_weights(4, 1).cuda()
        weight_deconv3 =  make_bilinear_weights(8, 1).cuda()
        weight_deconv4 =  make_bilinear_weights(16, 1).cuda()
        weight_deconv5 =  make_bilinear_weights(32, 1).cuda()

        upsample2 = torch.nn.functional.conv_transpose2d(so2_out, weight_deconv2, stride=2)
        upsample3 = torch.nn.functional.conv_transpose2d(so3_out, weight_deconv3, stride=4)
        upsample4 = torch.nn.functional.conv_transpose2d(so4_out, weight_deconv4, stride=8)
        upsample5 = torch.nn.functional.conv_transpose2d(so5_out, weight_deconv5, stride=8)
        ### center crop
        so1 = crop(so1_out, img_H, img_W)
        so2 = crop(upsample2, img_H, img_W)
        so3 = crop(upsample3, img_H, img_W)
        so4 = crop(upsample4, img_H, img_W)
        so5 = crop(upsample5, img_H, img_W)

        fusecat = torch.cat((so1, so2, so3, so4, so5), dim=1)
        fuse = self.score_final(fusecat)
        results = [so1, so2, so3, so4, so5, fuse]
        results = [torch.sigmoid(r) for r in results]
        return results
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-损失函数部分&quot;&gt;3.2 损失函数部分&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def cross_entropy_loss_RCF(prediction, label):
    label = label.long()
    mask = label.float()
    num_positive = torch.sum((mask==1).float()).float()
    num_negative = torch.sum((mask==0).float()).float()

    mask[mask == 1] = 1.0 * num_negative / (num_positive + num_negative)
    mask[mask == 0] = 1.1 * num_positive / (num_positive + num_negative)
    mask[mask == 2] = 0
    cost = torch.nn.functional.binary_cross_entropy(
            prediction.float(),label.float(), weight=mask, reduce=False)
    return torch.sum(cost)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/a8039974/article/details/85696282&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/a8039974/article/details/85696282&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitee.com/HEART1/RCF-pytorch/blob/master/functions.py&quot; target=&quot;_blank&quot;&gt;https://gitee.com/HEART1/RCF-pytorch/blob/master/functions.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openaccess.thecvf.com/content_cvpr_2017/papers/Liu_Richer_Convolutional_Features_CVPR_2017_paper.pdf&quot; target=&quot;_blank&quot;&gt;https://openaccess.thecvf.com/content_cvpr_2017/papers/Liu_Richer_Convolutional_Features_CVPR_2017_paper.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 15 Dec 2020 14:34:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>有什么问题可以加作者微信讨论，cyx645016617 上千人的粉丝群已经成立，氛围超好。为大家提供一个遇到问题有可能得到答案的平台。 0 概述 论文名称：“Richer Convolutional</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/14141441.html</dc:identifier>
</item>
</channel>
</rss>