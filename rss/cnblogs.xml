<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>FF.PyAdmin 接口服务/后台管理微框架 (Flask+LayUI) - fufuok</title>
<link>http://www.cnblogs.com/fufuok/p/PyAdmin.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fufuok/p/PyAdmin.html</guid>
<description>&lt;h2 id=&quot;源码有兴趣的朋友请star一下&quot;&gt;源码(有兴趣的朋友请Star一下)&lt;/h2&gt;
&lt;h2 id=&quot;初衷&quot;&gt;初衷&lt;/h2&gt;
&lt;p&gt;运维开发中, 各类接口服务和后台管理系统必不可少, 索性写个通用的/简单易用的/支持快速开发的微框架.&lt;/p&gt;
&lt;p&gt;一是开发时尽可能只关注业务逻辑, 快速实现, 不用再过多考虑架构/前端/布局什么的.&lt;/p&gt;
&lt;p&gt;二是将常用业务逻辑二次封装, 使用时, 用简洁的语句即可完成复杂的事务, 并自动处理异常.&lt;/p&gt;
&lt;p&gt;三是方便运维小伙伴们快速理解 Web 项目开发, 无须深入理解 Flask 和前端即可完成此类项目开发.&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;后端 Flask, 对异常处理, 数据库, 表单验证, 权限验证都做了二次封装, 调用更简单, 通用性强.&lt;/li&gt;
&lt;li&gt;前端 LayUI, 对数据表格作了二次封装, 支持自动按数据表生成表头, 可选使用. 丰富配色, 丰富图标.&lt;/li&gt;
&lt;li&gt;前后端完全使用 API 接口通信, JSON 数据交互. 方便与各类前端框架/小程序对接.&lt;/li&gt;
&lt;li&gt;适合做纯 API 接口服务, 也适合同时做接口服务和后台管理, 应用广泛/灵活.&lt;/li&gt;
&lt;li&gt;对 HTTP 异常二次封装, APIException/MsgException, 标准化 JSON 字段和错误消息页面.&lt;/li&gt;
&lt;li&gt;实现全局异常处理, 支持配置中自定义 404 等状态码消息. 500 状态码时自动记录日志.&lt;/li&gt;
&lt;li&gt;异常返回自适应, POST 和 AJAX 请求自动返回JSON数据, 其他状态展示自定义错误页, DEBUG 显示原始异常.&lt;/li&gt;
&lt;li&gt;自定义常用权限校验装饰器, 登录验证, 菜单权限验证, 接口权限验证, 来访 IP 白名单等.&lt;/li&gt;
&lt;li&gt;依托 Flask 蓝图和视图函数, 适应大部分情况下的权限管理需求. 扩展性强.&lt;/li&gt;
&lt;li&gt;WTForms 二次封装, 极简调用, 适应性强. 中文内置错误消息, 自动数据获取的验证.&lt;/li&gt;
&lt;li&gt;验证失败自动按需返回 JSON 或错误页. 自定义了通用的字符串和正整数验证方法, 适用性广.&lt;/li&gt;
&lt;li&gt;修正 Flask-wtf 0.14.2, @csrf.exempt 无效的问题.&lt;/li&gt;
&lt;li&gt;SQLAlchemy 数据库交互二次封装, 实现自动提交机制和完善的异常处理, CRUD 全封装, 极简调用.&lt;/li&gt;
&lt;li&gt;自带文件日志, 按日志文件大小自动滚动, 无须配置.&lt;/li&gt;
&lt;li&gt;安全, 方便, 完善的配置文件方案.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;图示&quot;&gt;图示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/67992/201912/67992-20191211083128552-2071578148.png&quot; alt=&quot;完整请求处理流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/67992/201912/67992-20191211083218870-666261329.png&quot; alt=&quot;后台界面&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Flask==1.1.1&lt;/li&gt;
&lt;li&gt;Flask_Login==0.4.1&lt;/li&gt;
&lt;li&gt;Flask_WTF==0.14.2&lt;/li&gt;
&lt;li&gt;Flask_Script==2.0.6&lt;/li&gt;
&lt;li&gt;Flask_Migrate==2.5.2&lt;/li&gt;
&lt;li&gt;Flask_SQLAlchemy==2.4.0&lt;/li&gt;
&lt;li&gt;SQLAlchemy==1.3.11&lt;/li&gt;
&lt;li&gt;cymysql==0.9.14&lt;/li&gt;
&lt;li&gt;WTForms==2.2.1&lt;/li&gt;
&lt;li&gt;Authlib==0.13&lt;/li&gt;
&lt;li&gt;requests==2.22.0&lt;/li&gt;
&lt;li&gt;concurrent_log_handler==0.9.16&lt;/li&gt;
&lt;li&gt;xxtea==1.3.0&lt;/li&gt;
&lt;li&gt;behave==1.2.6&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该框架基于公司内部 OA 系统 OAuth2 登录, 在登录画面点击即可进入演示后台. 需要自行准备 OAuth2 参数配置到配置文件, 如 QQ, 微信, GitHub, 钉钉等. 也可自行实现账号密码登录.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# app/views/web.py
@bp_web.route('/authorize')
def web_authorize():
    &quot;&quot;&quot;OAuth 登录跳转&quot;&quot;&quot;
    # TODO: (演示使用, 自动登录), 请删除并配置自己的认证方式, OAuth2或账密系统
    set_user_login({
        'job_number': 7777,
        'realname': 'Fufu'
    })
    return redirect(url_for('web.web_index'))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结构&quot;&gt;结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;.
├── app  应用根目录, app.root_path
│   ├── conf  配置文件目录
│   ├── forms  表单验证
│   ├── libs  公共类库
│   ├── models  表模型
│   ├── services  中间件, 逻辑处理
│   ├── static  静态文件
│   ├── templates  模板文件
│   └── views  视图函数
├── data  数据文件
├── docs  开发文档
├── features  BDD
│   └── steps
├── logs  日志目录
│   └── behave.reports
├── scripts  脚本
├── tests  单元测试
├── tmp  临时文件
└── venv  虚拟环境&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;secret_settings.py&lt;/code&gt; 必须, 一般设置 SECRET_KEY 及数据库配置, 不要加入 Git.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings.py&lt;/code&gt; 必须, 常规配置, APP_NAME, 日志参数, 错误消息等.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;production_settings.py&lt;/code&gt; 可选, 默认加载项, 生产环境额外配置.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;development_settings.py&lt;/code&gt; 可选, 开发环境额外配置.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;testing_settings.py&lt;/code&gt; 可选, 测试环境额外配置, BDD 或单元测试时使用.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第 3/4/5 项需要设置环境变量, 默认为 &lt;code&gt;production&lt;/code&gt;, 可选: &lt;code&gt;development&lt;/code&gt; &lt;code&gt;testing&lt;/code&gt;. 如:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 1. Windows:
    set FF_PyAdmin=development
    echo %FF_PyAdmin%
# 2. Linux:
    export FF_PyAdmin=development
    echo $FF_PyAdmin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产环境建议使用加密环境变量, 生成加密数据的方式如下:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Fufu~~Text 加密后 792e01268cc350077f772a5f
python3 manage.py encrypt -d Fufu~~Text&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法见 &lt;code&gt;secret_settings.py&lt;/code&gt; 中 &lt;code&gt;OA_CLIENT_SECRET&lt;/code&gt; 和 &lt;code&gt;PYADMIN_DBPASS&lt;/code&gt;, 配置示例:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Linux (Windows 使用上面的 set 方法)
cp scripts/etc-profile.d-ffpyadmin.sh /etc/profile.d/ffpyadmin.sh
chmod +x /etc/profile.d/ffpyadmin.sh
source /etc/profile.d/ffpyadmin.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用不加密的环境变量, 配置文件中的获取环境变量时不加 key 参数即可:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# OA_CLIENT_SECRET = get_environ('PYADMIN_OAUTH_SECRET', key=SECRET_KEY)
OA_CLIENT_SECRET = get_environ('PYADMIN_OAUTH_SECRET')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Python3.5+, pip, MySQL 环境&lt;/li&gt;
&lt;li&gt;建好 MySQL 数据库, 导入 data/db_ff_pyadmin.sql 示例数据, 修改配置文件&lt;/li&gt;
&lt;li&gt;pip3 install -r requirements.txt&lt;/li&gt;
&lt;li&gt;python3 start.py&lt;/li&gt;
&lt;li&gt;访问: http://127.0.0.1:5000 http://ff.pyadmin:777&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Flask https://github.com/pallets/flask&lt;/li&gt;
&lt;li&gt;OAuth2 https://github.com/lepture/authlib&lt;/li&gt;
&lt;li&gt;LayUI https://github.com/sentsin/layui&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 11 Dec 2019 00:35:00 +0000</pubDate>
<dc:creator>fufuok</dc:creator>
<og:description>源码(有兴趣的朋友请Star一下) github: 'https://github.com/fufuok/FF.PyAdmin' gitee: 'https://gitee.com/fufuok/FF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fufuok/p/PyAdmin.html</dc:identifier>
</item>
<item>
<title>你真的了解JMM吗？ - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/12019994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/12019994.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在现代计算机中，&lt;strong&gt;cpu的指令速度远超内存的存取速度&lt;/strong&gt;,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不&lt;strong&gt;加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）&lt;/strong&gt;来作为内存与处理器之间的缓冲：&lt;strong&gt;将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它&lt;strong&gt;引入了一个新的问题：缓存一致性（Cache Coherence）&lt;/strong&gt;。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个CPU之间的共享。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/12/10/16ef0853bc469986?w=966&amp;amp;h=477&amp;amp;f=png&amp;amp;s=50842&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;hjmmjavamemorymodel&quot;&gt;&lt;span&gt;一、JMM(Java Memory Model)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;java虚拟机规范定义&lt;strong&gt;java内存模型屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java内存模型规定了一个线程&lt;strong&gt;如何和何时&lt;/strong&gt;可以看到由&lt;strong&gt;其他线程修改&lt;/strong&gt;过后的&lt;strong&gt;共享变量的值&lt;/strong&gt;，以及在必须时&lt;strong&gt;如何同步的访问共享变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：我们这里强调的是共享变量，不是私有变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java内存模型规定了所有的变量都存储在主内存中（JVM内存的一部分）。每条线程都有自己的工作内存，工作内存中保存了该线程使用的主内存中共享变量的副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量；工作内存在线程间是隔离的，不能直接访问对方工作内存中的变量。所以在多线程操作共享变量时，就通过JMM来进行控制。&lt;/p&gt;
&lt;p&gt;我们来看一看线程，工作内存、主内存三者的交互关系图。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/12/10/16ef085c97d532eb?w=966&amp;amp;h=477&amp;amp;f=png&amp;amp;s=51872&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;hjmm8&quot;&gt;&lt;span&gt;二、JMM的8种内存交互操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;9龙就疑问，JMM是如何保证并发下数据的一致性呢？&lt;/p&gt;
&lt;p&gt;内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;load （载入）：作用于工作内存的变量，它把read操作从主存中得到变量放入工作内存的变量副本中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;store （存储）：作用于工作内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/12/10/16ef0865ef202c4e?w=929&amp;amp;h=512&amp;amp;f=png&amp;amp;s=54458&quot; alt=&quot;&quot;/&gt;&lt;p&gt;如果是将变量从主内存复制到工作内存，必须先执行read，后执行load操作；如果是将变量从工作内存同步到主内存，必须先执行store，后执行write。&lt;strong&gt;JMM要求read和load, store和write必须按顺序执行，但不是必须连续执行，中间可以插入其他的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;h21jmm&quot;&gt;&lt;span&gt;2.1、JMM指令使用规则&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不允许一个线程将没有assign的数据从工作内存同步回主内存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对一个变量进行unlock操作之前，必须把此变量同步回主内存&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hvolatile&quot;&gt;&lt;span&gt;三、volatile&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;很多并发编程中都使用了volatile，你知道为什么一个变量要使用volatile修饰吗？&lt;/p&gt;
&lt;p&gt;volatile有两个语义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;volatile可以保证线程间变量的可见性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile禁止CPU进行指令重排序。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;volatile修饰的变量，如果某个线程更改了变量值，其他线程可以立即观察到这个值。而普通变量不能做到这一点，变量值在线程间传递均需要主内存来完成。如果线程修改了普通变量值，则需要刷新回主内存，另一个线程需要从主内存重新读取才能知道最新值。&lt;/p&gt;
&lt;h4 id=&quot;h31volatile&quot;&gt;&lt;span&gt;3.1、volatile只能保证可见性，不能保证原子性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;虽然volatile只能保证可见性，但不能认为volatile修饰的变量可以在并发下是线程安全的。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; threadNums = &lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt;;&lt;br/&gt;ExecutorService service = Executors.newCachedThreadPool();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; threadNums; i++) {&lt;br/&gt;service.execute(VolatileTest::addCount);&lt;br/&gt;}&lt;br/&gt;System.out.println(count);&lt;br/&gt;service.shutdown();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;count++;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以从例子中看出，共享变量使用了volatile修饰，启动2000个线程对其进行自增操作，如果是线程安全的，结果应该是2000；但结果却小于2000。证明volatile修饰的变量并不能保证原子性，如果想保证原子性，还需要额外加锁。&lt;/p&gt;
&lt;h4 id=&quot;h32volatile&quot;&gt;&lt;span&gt;3.2、volatile禁止指令重排序&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;虽然程序从表象上看到是按照我们书写的顺序进行执行，但由于CPU可能会由于性能原因，对执行指令进行重排序，以此提高性能。&lt;/p&gt;
&lt;p&gt;比如我们有一个方法是关于“&lt;strong&gt;谈恋爱&lt;/strong&gt;”的方法。伪代码如下&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs php&quot; readability=&quot;2&quot;&gt;{&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!追求成功){&lt;br/&gt;sleep();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到线程A需要执行3步，由于cpu执行重排序优化，可能执行顺序变为1、3、2，乱套了，刚认识别人就成功了，接着就牵手，接吻，然后可能再执行追求的过程。。。。。。。。不敢想象，我还只是个孩子啊。这就是指令重排序可能在多线程环境下出现的问题。&lt;/p&gt;
&lt;p&gt;如果我们使用volatile修饰“追求成功”的变量，则可以禁止CPU进行指令重排序，让谈恋爱是一件轻松而快乐的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile使用内存屏障来禁止指令重排序。&lt;/strong&gt;&lt;br/&gt;在每个volatile写操作的前面插入一个StoreStore屏障，在每个volatile写操作的后面插入一个StoreLoad屏障。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/12/10/16ef086d003bc56a?w=468&amp;amp;h=536&amp;amp;f=png&amp;amp;s=26693&quot; alt=&quot;&quot;/&gt;&lt;p&gt;在每个volatile读操作的后面插入一个LoadLoad屏障，在每个volatile读操作的后面插入一个LoadStore屏障。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/12/10/16ef0874b1cc2a93?w=470&amp;amp;h=536&amp;amp;f=png&amp;amp;s=27647&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;四、原子性、可见性、顺序性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们看到JMM围绕这三个特征来建立的。&lt;/p&gt;
&lt;h4 id=&quot;h41&quot;&gt;&lt;span&gt;4.1、原子性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;JMM提供了read、load、use、assign、store、write六个指令直接提供原子操作，我们可以认为&lt;strong&gt;java的基本变量的读写操作是原子的（long，double除外，&lt;/strong&gt;因为有些虚拟机可以将64位分为高32位，低32位分开运算）。对于lock、unlock，虚拟机没有将操作直接开放给用户使用，但提供了更高层次的字节码指令，&lt;strong&gt;monitorenterm&lt;/strong&gt;和&lt;strong&gt;monitorexit&lt;/strong&gt;来隐式使用这两个操作，对应于java的&lt;strong&gt;synchronized&lt;/strong&gt;关键字，因此&lt;strong&gt;synchronized块之间的操作也具有原子性&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h42&quot;&gt;&lt;span&gt;4.2、可见性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们上面说了线程之间的变量是隔离的，&lt;strong&gt;线程拿到的是主存变量的副本，更改变量，需要刷新回主存，其他线程需要从主存重新获取才能拿到变更的值。&lt;/strong&gt;所有变量都要经过这个过程，包括被volatile修饰的变量；但&lt;strong&gt;volatile修饰的变量，可以在修改后强制刷新到主存，并在使用时从主存获取刷新，&lt;/strong&gt;普通变量则不行。&lt;/p&gt;
&lt;p&gt;除了volatile修饰的变量，synchronized和final。&lt;strong&gt;synchronized在执行完毕后，进行unlock之前，必须将共享变量同步回主内存中（执行store和write操作）&lt;/strong&gt;。前面规则其中一条。&lt;/p&gt;
&lt;p&gt;而final修饰的字段，只要在构造函数中一旦初始化完成，并且没有对象逃逸（指对象为初始化完成就可以被别的线程使用），那么在其他线程中就可以看到final字段的值。&lt;/p&gt;
&lt;h4 id=&quot;h43&quot;&gt;&lt;span&gt;4.3、有序性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;有序性在volatile已经详细说明了。可以总结为，&lt;strong&gt;在本线程观察到的结果，所有操作都是有序的；如果多线程环境下，一个线程观察到另一个线程的操作，就说杂乱无序的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java提供了volatile和synchronized两个关键字保证线程之间的有序性，volatile使用内存屏障，而synchronized基于lock之后，必须unlock后，其他线程才能重新lock的规则，让同步块在在多线程间串行执行。&lt;/p&gt;
&lt;h3 id=&quot;hhappendsbefore&quot;&gt;&lt;span&gt;五、Happends-Before原则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;先行发生&lt;/strong&gt;是java内存模型中定义的两个操作的顺序，&lt;strong&gt;如果说操作A先行发生于线程B，就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息，调用了方法等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们举个例子说一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;//线程A执行&lt;br/&gt;i = 1&lt;br/&gt;//线程B执行&lt;br/&gt;j = i&lt;br/&gt;//线程C执行&lt;br/&gt;i = 2&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还是定义A线程执行 i = 1 先行发生于 线程B执行的 j = i；那么我们可以确定，在线程B执行之后，j的值是1。因为根据先行发生原则，线程A执行之后，i的值为1，可以被B观察到；并且线程A执行之后，线程B执行之前，没有线程对i的值进行变更。&lt;/p&gt;
&lt;p&gt;这时候我们考虑线程C，如果我们还是保证线程A先行发生于B，但线程C出现在A与B之间，那么，你可以确定j的值是多少吗？答案是&lt;strong&gt;否定的&lt;/strong&gt;。因为线程C的结果也可能被B观察到，这时候可能是1，也可能是2。这就存在线程安全问题。&lt;/p&gt;
&lt;p&gt;在JMM下具有一些天然的先行发生关系，这些原则在无须任何同步协助下就已经存在，可以直接使用。&lt;strong&gt;如果两个操作之间的关系不在此列，并且无法从以下先行发生原则推导出来，它们就没有顺序性保证，虚拟机就会进行随意的重排序。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;程序次序规则&lt;/strong&gt;（Program Order Rule）：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;锁定规则&lt;/strong&gt;（Monitor Lock Rule）：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;（volatile Variable Rule）：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程启动规则&lt;/strong&gt;（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程终止规则&lt;/strong&gt;（Thread Termination Rule）：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必晚于线程中所有操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程中断规则&lt;/strong&gt;（Thread Interruption Rule）：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;对象终止规则&lt;/strong&gt;（Finalizer Rule）：一个对象的初始化方法先于执行它的finalize()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;传递性&lt;/strong&gt;（Transitivity）：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;本篇详细总结了Java内存模型。再来品一品这句话。&lt;/p&gt;
&lt;p&gt;java内存模型规定了一个线程&lt;strong&gt;如何和何时&lt;/strong&gt;可以看到由&lt;strong&gt;其他线程修改&lt;/strong&gt;过后的&lt;strong&gt;共享变量的值&lt;/strong&gt;，以及在必须时&lt;strong&gt;如何同步的访问共享变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;各位看官，如果觉得9龙的文章对你有帮助，求点赞，求关注。如果转载请注明出处。&lt;/p&gt;
&lt;p&gt;本篇主要总结于：&lt;/p&gt;
&lt;p&gt;深入理解Java虚拟机++JVM高级特性与最佳实践&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 00:31:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>引言 在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/9dragon/p/12019994.html</dc:identifier>
</item>
<item>
<title>15.Django基础十一之认证系统 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/12020204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/12020204.html</guid>
<description>
&lt;p&gt;　　我们在开发一个网站的时候，无可避免的需要设计实现网站的用户系统。此时我们需要实现包括用户注册、用户登录、用户认证、注销、修改密码等功能，这还真是个麻烦的事情呢。&lt;/p&gt;
&lt;p&gt;　　Django作为一个完美主义者的终极框架，当然也会想到用户的这些痛点。它内置了强大的用户认证系统--auth，它默认使用 auth_user 表来存储用户数据，使用auth模块来进行用户认证，那么需要使用人家django自带的auth_user表来存储用户的信息数据。&lt;/p&gt;
&lt;p&gt;　　模块导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib import auth&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　那么有人就有疑问 了，这个auth_user表并不是我们自己在models.py文件中创建的啊，这通过代码怎么操作啊？&lt;/p&gt;
&lt;p&gt;　　其中一个往auth_user表里面添加数据的命令，可以先多添加几个用户，方便后面操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py createsuperuser  #要通过这个指令来创建用户，因为这个指令会将你的密码加密。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201903/988061-20190316134627563-2130007983.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　然后表中就有数据了：这个表里面的数据现在先关注username和password字段就可以了，其他的字段可为空。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201903/988061-20190316134706428-344246076.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　User表具有以下字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;内置的User模型拥有以下的字段：
username： 用户名。150个字符以内。可以包含数字和英文字符，以及_、@、+、.和-字符。不能为空，且必须唯一！
first_name：歪果仁的first_name，在30个字符以内。可以为空。
last_name：歪果仁的last_name，在150个字符以内。可以为空。
email：邮箱。可以为空。
password：密码。经过哈希过后的密码。
#groups：分组。一个用户可以属于多个分组，一个分组可以拥有多个用户。groups这个字段是跟Group的一个多对多的关系。
#user_permissions：权限。一个用户可以拥有多个权限，一个权限可以被多个用户所有用。和Permission属于一种多对多的关系。
is_staff：是否可以进入到admin的站点。代表是否是员工。这个字段如果不使用admin的话，可以自行忽略，不影响使用
is_active：是否是可用的。对于一些想要删除账号的数据，我们设置这个值为False就可以了，而不是真正的从数据库中删除。
is_superuser：是否是超级管理员。如果是超级管理员，那么拥有整个网站的所有权限。
last_login：上次登录的时间。
date_joined：账号创建的时间。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　auth中提供了许多实用方法：&lt;/p&gt;
&lt;h2 id=&quot;authenticate&quot;&gt;&lt;strong&gt;authenticate()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　　　提供了用户认证功能，即验证用户名以及密码是否正确，一般需要username 、password两个关键字参数，因为你仔细看看auth_user表的话，你会发现用户名和密码的字段名称就是username和password。&lt;/p&gt;
&lt;p&gt;　　　　如果认证成功（用户名和密码正确有效，就是去auth_user表中查询一下是否存在这条记录），便会返回一个 User 对象，查询认证失败返回None。&lt;/p&gt;
&lt;p&gt;　　　　authenticate()会在该 User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user = auth.authenticate(username='theuser',password='thepassword')&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;loginhttprequest-user&quot;&gt;&lt;strong&gt;login(HttpRequest, user)&lt;/strong&gt;　　&lt;/h2&gt;
&lt;p&gt;　　　　该函数接受一个HttpRequest对象，以及一个经过认证的User对象。&lt;/p&gt;
&lt;p&gt;　　　　该函数实现一个用户登录的功能。&lt;strong&gt;它本质上会在后端为该用户生成相关session数据&lt;/strong&gt;，保持会话用。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth import authenticate, login
   
def my_view(request):
  username = request.POST['username']
  password = request.POST['password']
  user_obj = authenticate(username=username, password=password)
  if user_obj:
    login(request, user_obj) #可以简单理解为request.session['user_id']=user_id，并且将user_obj封装到了request里面，通过request.user=user_obj
    # Redirect to a success page.
    ...
  else:
    # Return an 'invalid login' error message.
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　只要使用login(request, user_obj)之后，request.user就能拿到当前登录的用户对象。否则request.user得到的是一个匿名用户对象（AnonymousUser Object，是request.user的默认值），这个匿名用户的状态在我的视图函数博客的那个request那一节有介绍，都是空。&lt;/p&gt;
&lt;p&gt;　　　　　　详细原理请查看 AuthenticationMiddleware 中间件源码。&lt;/p&gt;
&lt;p&gt;　　　　　　　　使用login方法之前，打印user的状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def index(request):
    print(request.user) #没有经过login方法来封装用户的信息，那么这个显示的是一个匿名用户
    print(request.user.id) #None
    print(request.user.username) #空的
    print(request.user.is_active) #False
    return render(request,'index.html')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　　　使用login方法之后，打印user的状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def index(request):
    print(request.user) #chao,request.user对象本身是全局的，是当前登陆的user对象，并且可以在模板语言里面直接使用{{ request.user.username }}，万能的句点号
    print(request.user.id) #1  #通过id、username等可以判断用户是否登陆了，但是一般我们都用后面要学的is_authenticated()方法来进行判断。
    print(request.user.username) #chao
    print(request.user.is_active) #True
    return render(request,'index.html')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;logoutrequest&quot;&gt;&lt;strong&gt;logout(request)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　　　该函数接受一个HttpRequest对象，无返回值。&lt;/p&gt;
&lt;p&gt;　　　　当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth import logout
   
def logout_view(request):
  logout(request) #其实内部就是执行了request.session.flush()
  # Redirect to a success page.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　关于User表的扩展阅读内容(目前作为了解)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Django内置的User模型虽然已经足够强大了。但是有时候还是不能满足我们的需求。比如在验证用户登录的时候，他用的是用户名作为验证，而我们有时候需要通过手机号码或者邮箱来进行验证。还有比如我们想要增加一些新的字段。那么这时候我们就需要扩展用户模型了。扩展用户模型有多种方式。这里我们来一一讨论下。

1. 设置Proxy模型：
作用: 给模型增加操作方法

局限: 不能增加或减少User模型的字段

好处: 不破坏原来的User模型的表结构

如果你对Django提供的字段，以及验证的方法都比较满意，没有什么需要改的。但是只是需要在他原有的基础之上增加一些操作的方法。那么建议使用这种方式。示例代码如下：

# models.py
class Person(User):
    # 如果模型是一个代理模型
    # 那么就不能在这个模型中添加新的Field
    # telephone = models.CharField(max_length=11)  # 错误写法
    class Meta:
        proxy = True
 
    # proxy正确用法是给模型添加自定义方法
    # 如添加列出黑名单的方法
    def get_blacklist(self):
        return self.objects.filter(is_active=False)
在以上，我们定义了一个Person类，让他继承自User，并且在Meta中设置proxy=True，说明这个只是User的一个代理模型。他并不会影响原来User模型在数据库中表的结构。以后如果你想方便的获取所有黑名单的人，那么你就可以通过Person.get_blacklist()就可以获取到。并且User.objects.all()和Person.objects.all()其实是等价的。因为他们都是从User这个模型中获取所有的数据。

2. 一对一外键：
作用: 给模型增加新的字段, 新方法

局限: 只能增加, 不能减少字段, 不能修改户验证方法: authenticate

好处: 不破坏原来的User模型的表结构

如果你对用户验证方法authenticate没有其他要求，就是使用username和password即可完成。但是想要在原来模型的基础之上添加新的字段，那么可以使用一对一外键的方式。示例代码如下：

# models.py
from django.contrib.auth.models import User
from django.db import models
from django.dispatch import receiver
from django.db.models.signals import post_save
 
class UserExtension(models.Model):
    user = models.OneToOneField(User,on_delete=models.CASCADE,related_name='extension')
    birthday = models.DateField(null=True,blank=True)
    school = models.CharField(max_length=100)
 
 
@receiver(post_save,sender=User)
def create_user_extension(sender,instance,created,**kwargs):
    if created:
        UserExtension.objects.create(user=instance)
    else:
        instance.extension.save()
以上定义一个UserExtension的模型，并且让她和User模型进行一对一的绑定，以后我们新增的字段，就添加到UserExtension上。并且还写了一个接受保存模型的信号处理方法，只要是User调用了save方法，那么就会创建一个UserExtension和User进行绑定。

# views.py
from django.contrib.auth.models import User
from django.http import HttpResponse
 
 
def one_to_one_view(request):
    user = User.objects.create_user(username='Tom',email='tom@qq.com',password='111111')
    # 给扩展的字段设置值
    user.extension.school = 'Harvard'
    user.save()
    return HttpResponse('一对一扩展User模型')
3. 继承自AbstractUser：
作用: 给模型增加新的字段, 修改户验证方法: authenticate

局限: 只能增加, 不能减少字段

坏处: 破坏了原来的User模型的表结构

对于authenticate不满意，并且不想要修改原来User对象上的一些字段，但是想要增加一些字段，那么这时候可以直接继承自django.contrib.auth.models.AbstractUser，其实这个类也是django.contrib.auth.models.User的父类。比如我们想要在原来User模型的基础之上添加一个telephone和school字段。示例代码如下：

# models.py
from django.contrib.auth.models import AbstractUser
class User(AbstractUser):
    telephone = models.CharField(max_length=11,unique=True)
    school = models.CharField(max_length=100)
    # 指定telephone作为USERNAME_FIELD, 而不是原来的username字段, 所以username要重写
    username = models.CharField(max_length=150)
 
    # 指定telephone作为USERNAME_FIELD，以后使用authenticate
    # 函数验证的时候，就可以根据telephone来验证
    # 而不是原来的username
    USERNAME_FIELD = 'telephone'
    # USERNAME_FIELD对应的'telephone'字段和密码字段默认是必须的字段
    # 下[]可以添加其它必须的字段, 比如['username', 'email']
    REQUIRED_FIELDS = []
 
    # 重新定义Manager对象，在创建user的时候使用telephone和
    # password，而不是使用username和password
    objects = UserManager()
 
 
# 重写UserManager
class UserManager(BaseUserManager):
    use_in_migrations = True
 
    def _create_user(self, telephone, password, **extra_fields):
        if not telephone:
            raise ValueError(&quot;请填入手机号码！&quot;)
        if not password:
            raise ValueError(&quot;请填入密码!&quot;)
        user = self.model(telephone=telephone, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user
 
    def create_user(self, telephone, password, **extra_fields):
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(telephone, password, **extra_fields)
 
    def create_superuser(self, telephone, password, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
 
        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
 
        return self._create_user(telephone, password, **extra_fields)
然后再在settings中配置好

# settings.py
AUTH_USER_MODEL = 'youappname.User'
这种方式因为破坏了原来User模型的表结构，所以必须要在第一次migrate前就先定义好。

4. 继承自AbstractBaseUser模型：
作用: 给模型增加或减少字段, 修改户验证方法: authenticate

坏处: 破坏了原来的User模型的表结构

注意: 继承自AbstractBaseUser同时还要继承PermissionsMixin

如果你想修改默认的验证方式，并且对于原来User模型上的一些字段不想要，那么可以自定义一个模型，然后继承自AbstractBaseUser，再添加你想要的字段。这种方式会比较麻烦，最好是确定自己对Django比较了解才推荐使用。步骤如下：

创建模型。示例代码如下：

# models.py
from django.contrib.auth.base_user import AbstractBaseUser
from django.contrib.auth.models import PermissionsMixin
from django.db import models
 
 
class User(AbstractBaseUser,PermissionsMixin):
     email = models.EmailField(unique=True)
     username = models.CharField(max_length=150)
     telephone = models.CharField(max_length=11,unique=True)
     is_staff = models.BooleanField(default=False)
     is_active = models.BooleanField(default=True)
 
     USERNAME_FIELD = 'telephone'
     REQUIRED_FIELDS = []
 
    # 这里的UserManager同方法3, 需要重写
     objects = UserManager()
 
     def get_full_name(self):
         return self.username
 
     def get_short_name(self):
         return self.username
其中password和last_login是在AbstractBaseUser中已经添加好了的，我们直接继承就可以了。然后我们再添加我们想要的字段。比如email、username、telephone等。这样就可以实现自己想要的字段了。但是因为我们重写了User，所以应该尽可能的模拟User模型：

USERNAME_FIELD：用来描述User模型名字字段的字符串，作为唯一的标识。如果没有修改，那么会使用USERNAME来作为唯一字段。
REQUIRED_FIELDS：一个字段名列表，用于当通过createsuperuser管理命令创建一个用户时的提示。
is_active：一个布尔值，用于标识用户当前是否可用。
get_full_name()：获取完整的名字。
get_short_name()：一个比较简短的用户名。
重新定义UserManager：我们还需要定义自己的UserManager，因为默认的UserManager在创建用户的时候使用的是username和password，那么我们要替换成telephone。示例代码如下：

# models.py
from django.contrib.auth.base_user import BaseUserManager
 
 
# 重写UserManager
class UserManager(BaseUserManager):
    use_in_migrations = True
 
    def _create_user(self, telephone, password, **extra_fields):
        if not telephone:
            raise ValueError(&quot;请填入手机号码！&quot;)
        if not password:
            raise ValueError(&quot;请填入密码!&quot;)
        user = self.model(telephone=telephone, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user
 
    def create_user(self, telephone, password, **extra_fields):
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(telephone, password, **extra_fields)
 
    def create_superuser(self, telephone, password, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
 
        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
 
        return self._create_user(telephone, password, **extra_fields)
 

在创建了新的User模型后，还需要在settings中配置好。配置AUTH_USER_MODEL='appname.User'。

# settings.py
AUTH_USER_MODEL = 'youappname.User'
 

如何使用这个自定义的模型：比如以后我们有一个Article模型，需要通过外键引用这个User模型，那么可以通过以下两种方式引用。
第一种就是直接将User导入到当前文件中。示例代码如下：

# models.py
from django.db import models
 from myauth.models import User
 class Article(models.Model):
     title = models.CharField(max_length=100)
     content = models.TextField()
     author = models.ForeignKey(User, on_delete=models.CASCADE)
这种方式是可以行得通的。但是为了更好的使用性，建议还是将User抽象出来，使用settings.AUTH_USER_MODEL来表示。示例代码如下：

# models.py
from django.db import models
 from django.conf import settings
 class Article(models.Model):
     title = models.CharField(max_length=100)
     content = models.TextField()
     author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
这种方式因为破坏了原来User模型的表结构，所以必须要在第一次migrate前就先定义好。&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　User 对象属性：username， password（必填项）password用哈希算法保存到数据库&lt;/p&gt;
&lt;h2 id=&quot;user对象的-is_authenticated&quot;&gt;user对象的 is_authenticated()&lt;/h2&gt;
&lt;p&gt;　　　　如果是真正的 User 对象，返回值恒为 True 。 用于检查用户是否已经通过了认证。&lt;br/&gt;　　　　通过认证并不意味着用户拥有任何权限，甚至也不检查该用户是否处于激活状态，这只是表明用户成功的通过了认证。 这个方法很重要, 在后台用request.user.is_authenticated()判断用户是否已经登录，如果true则可以向前台展示request.user.name&lt;/p&gt;
&lt;p&gt;　　　　要求：&lt;/p&gt;
&lt;p&gt;　　　　　　1 用户登陆后才能访问某些页面，&lt;/p&gt;
&lt;p&gt;　　　　　　2 如果用户没有登录就访问该页面的话直接跳到登录页面&lt;/p&gt;
&lt;p&gt;　　　　　　3 用户在跳转的登陆界面中完成登陆后，自动访问跳转到之前访问的地址&lt;/p&gt;
&lt;p&gt;　　　　方法1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def my_view(request):
  if not request.user.is_authenticated():
    return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　方法2:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;django已经为我们设计好了一个用于此种情况的装饰器：login_requierd()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.decorators import login_required
      
@login_required
def my_view(request):
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　若用户没有登录，则会跳转到django默认的 登录URL '/accounts/login/ ' (这个值可以在settings文件中通过LOGIN_URL进行修改)。并传递 当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。&lt;/p&gt;
&lt;h2 id=&quot;login_requierd&quot;&gt;&lt;strong&gt;login_requierd()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　　　auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.decorators import login_required
      
@login_required
def my_view(request):
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　若用户没有登录，则会跳转到django默认的 登录URL '/accounts/login/ ' 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。&lt;/p&gt;
&lt;p&gt;　　　　如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOGIN_URL = '/login/'  # 这里配置成你项目登录页面的路由&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;create_user&quot;&gt;create_user()&lt;/h2&gt;
&lt;p&gt;　　　　auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.models import User
user = User.objects.create_user（username='用户名',password='密码',email='邮箱',...）&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;create_superuser&quot;&gt;create_superuser()&lt;/h2&gt;
&lt;p&gt;　　　　auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.models import User
user_obj = User.objects.create_superuser（username='用户名',password='密码',email='邮箱',...）&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;check_passwordraw_password了解&quot;&gt;check_password(raw_password)（了解）&lt;/h2&gt;
&lt;p&gt;　　　　auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。&lt;/p&gt;
&lt;p&gt;　　　　密码正确返回True，否则返回False。&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ok = user_obj.check_password('密码')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　或者直接针对当前请求的user对象校验原密码是否正确：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ok = request.user.check_password(raw_password='原密码')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;set_passwordraw_password&quot;&gt;set_password(raw_password)&lt;/h2&gt;
&lt;p&gt;　　　　auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。&lt;/p&gt;
&lt;p&gt;　　　　注意：设置完一定要调用用户对象的save方法！！！&lt;/p&gt;
&lt;p&gt;　　　　用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user_obj.set_password('新密码')  #user_obj其实就是request.user
user_obj.save()                 #request.user.save()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　&lt;strong&gt;用户对象的属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　user_obj能够拿到认证所用用户表的数据属性，比如username， password等。&lt;/p&gt;
&lt;p&gt;　　　　其他常用属性含义如下：&lt;/p&gt;
&lt;p&gt;　　　　　　is_staff ： 用户是否拥有网站的管理权限.&lt;/p&gt;
&lt;p&gt;　　　　　　is_active ： 是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。&lt;/p&gt;
&lt;p&gt;　　简单示例：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;注册：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def sign_up(request):
 
    state = None
    if request.method == 'POST':
 
        password = request.POST.get('password', '')
        repeat_password = request.POST.get('repeat_password', '')
        email=request.POST.get('email', '')
        username = request.POST.get('username', '')
        if User.objects.filter(username=username):
                state = 'user_exist'
        else:
                new_user = User.objects.create_user(username=username, password=password,email=email)
                new_user.save()
 
                return redirect('/book/')
    content = {
        'state': state,
        'user': None,
    }
    return render(request, 'sign_up.html', content)　　&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;修改密码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@login_required
def set_password(request):
    user = request.user
    state = None
    if request.method == 'POST':
        old_password = request.POST.get('old_password', '')
        new_password = request.POST.get('new_password', '')
        repeat_password = request.POST.get('repeat_password', '') 
        if user.check_password(old_password): #校验老密码是否正确
            if not new_password:
                state = 'empty'
            elif new_password != repeat_password:
                state = 'repeat_error'
            else:
                user.set_password(new_password)
                user.save()
                return redirect(&quot;/log_in/&quot;)
        else:
            state = 'password_error'
    content = {
        'user': user,
        'state': state,
    }
    return render(request, 'set_password.html', content)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　留个作业吧：给图书馆里系统添加一个登陆注册功能。&lt;/p&gt;

&lt;p&gt;　　这内置的认证系统这么好用，但是auth_user表字段都是固定的那几个，我在项目中没法拿来直接使用啊！&lt;/p&gt;
&lt;p&gt;　　比如，我想要加一个存储用户手机号的字段，怎么办？&lt;/p&gt;
&lt;p&gt;　　聪明的你可能会想到新建另外一张表然后通过一对一和内置的auth_user表关联，这样虽然能满足要求但是有没有更好的实现方式呢？&lt;/p&gt;
&lt;p&gt;　　答案是当然有了。&lt;/p&gt;
&lt;p&gt;　　我们可以通过继承内置的 AbstractUser 类，来定义一个自己的Model类。django给我们自动创建的一张user表，而如果要用auth模块，就必须要使用（或继承）这张表。&lt;/p&gt;
&lt;p&gt;　　这样既能根据项目需求灵活的设计用户表，又能使用Django强大的认证系统了。继承表的好处是我们可以增加一些自己需要的字段，并且同时可以使用auth模块提供的接口、方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.models import AbstractUser
class UserInfo(AbstractUser):
    &quot;&quot;&quot;
    用户信息表
    &quot;&quot;&quot;
    nid = models.AutoField(primary_key=True)
    phone = models.CharField(max_length=11, null=True, unique=True)
    
    def __str__(self):
        return self.username&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　需要注意的是，UserInfo表里就不需要有auth_user里重复的字段了，比如说username以及password等，但是还是可以直接使用这些字段的，并且django会自动将password进行加密&lt;/p&gt;
&lt;p&gt;　　按上面的方式扩展了内置的auth_user表之后，一定要在settings.py中告诉Django，我现在使用我新定义的UserInfo表来做用户认证。写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 引用Django自带的User表，继承使用时需要设置,这样django就知道从我们的app名的应用下的models文件中去查找UserInfo这张表了
AUTH_USER_MODEL = &quot;app名.UserInfo&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　自定义认证系统默认使用的数据表之后，我们就可以像使用默认的auth_user表那样使用我们的UserInfo表了。比如：&lt;/p&gt;
&lt;p&gt;　　创建普通用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UserInfo.objects.create_user(username='用户名', password='密码')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建超级用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UserInfo.objects.create_superuser(username='用户名', password='密码')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　再次注意：&lt;/p&gt;
&lt;p&gt;　　　　一旦我们指定了新的认证系统所使用的表，我们就需要重新在数据库中创建该表，而不能继续直接使用原来默认的auth_user表了。&lt;/p&gt;

&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;views.py内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render,HttpResponse,redirect
from django.urls import reverse
from crm import models
# Create your views here.

#1.引入auth认证组件来操作django的auth_user表
from django.contrib import auth

def login(request):
    if request.method == 'GET':
        return render(request, 'login.html')
    else:
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        print(user, pwd)
        #2.authenticate方法回去auth_user表中查询记录，查询成功返回用户对象，查询失败返回None
        user_obj = auth.authenticate(username=user,password=pwd)
        if user_obj:
            #3.保存用户的状态信息，之前我们保存到了session表中，现在也是保存到里面，但是通过一个auth模块的login方法就搞定了，然后重定向到首页index
            auth.login(request,user_obj) #做的事情request.session[&quot;user_id&quot;] = user_obj.pk，还加了一些其他的内容，先不用管他其他的内容，还做了一个事情就是request.user = user_obj当前登陆对象

            # return redirect('index') #不写reverse也行
            return redirect(reverse('index'))


        else:
            return redirect(reverse('login'))


from django.contrib.auth.decorators import login_required
@login_required
def index(request):
    #关于这个默认的匿名用户，看一下我的django的视图系统的那个博客，有相关介绍
    print(request.user) #没有经过login方法来封装用户的信息，那么这个显示的是一个匿名用户
    print(request.user.id) #None
    print(request.user.is_superuser) #False
    print(request.user.username) #空的
    print(request.user.is_active) #False

    # if not request.user.id: #还有一个验证是否登陆的方法，request.user.is_authenticated(),常用的是这个方法
    # if not request.user.is_authenticated(): #还有一个验证是否登陆的方法，request.user.is_authenticated(),常用的是这个方法
    #     return redirect('login')

    return render(request,'index.html')

def logout(request):
    auth.logout(request) #其实就是和咱们django提供的session做的事情差不多

    return redirect('login')


#注册
#注册就是要往django的auth_user表中添加一条记录，所以要想操作User表必须先引入user表，这个auth_user表是auth这个内置应用的表，所以django生成表的时候，表名字是应用名_表名，所以其实表名为User表
#引入Uset表
from django.contrib.auth.models import User
def register(request):

    if request.method == 'GET':

        return render(request,'register.html')

    else:
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')

        # User.objects.create()  #create方法也能插入数据，但是密码是明文的
        User.objects.create_user(username=user,password=pwd)  #创建普通用户
        # User.objects.create_superuser(username=user,password=pwd)  #创建超级用户
        #create_user()和create_superuser()他们两个区别在admin应用里面能够体现出来，但是其实在生成的表记录里面唯一的区别就是那个is_superuser的字段值不同，如果是create_user()方法创建的用户，那么is_superuser的值为False，如果是create_superuser()方法创建的用户，那么is_superuser的值为True，所以我们可以通过这个字不同的值来判断用户是否为管理员啊等操作,这两个方法的username=user,password=pwd，两个参数是必须要给的
        return redirect('login')


def set_password(request):
    request.user.set_password(666)
    request.user.save()

    return redirect('login')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;urls.py内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.contrib import admin
from crm import views
urlpatterns = [
    url(r'^admin/', admin.site.urls),
    #登陆
    url(r'^login/', views.login,name='login'),
    url(r'^index/', views.index,name='index'),
    #注销、退出
    url(r'^logout/', views.logout,name='logout'),
    #注册
    url(r'^register/', views.register,name='register'),
    #修改密码
    url(r'^set_password/', views.set_password,name='set_password'),


]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.html内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;
    这是index页面
    {{ request.user.username }}
&amp;lt;/h1&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;a href=&quot;{% url 'logout' %}&quot;&amp;gt;退出&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;a href=&quot;{% url 'set_password' %}&quot;&amp;gt;修改密码&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;login.html内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;
    {% csrf_token %}
    &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
    &amp;lt;input type=&quot;password&quot; name=&quot;pwd&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　register.html内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;form action=&quot;{% url 'register' %}&quot; method=&quot;post&quot;&amp;gt;
    {% csrf_token %}
    &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
    &amp;lt;input type=&quot;password&quot; name=&quot;pwd&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　settings.py文件中有一个认证装饰器@login_required需要用的一个配置项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOGIN_URL = '/login/' #配置装饰器跳转的登陆的url&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 11 Dec 2019 00:16:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>一 auth模块 我们在开发一个网站的时候，无可避免的需要设计实现网站的用户系统。此时我们需要实现包括用户注册、用户登录、用户认证、注销、修改密码等功能，这还真是个麻烦的事情呢。 Django作为一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/12020204.html</dc:identifier>
</item>
<item>
<title>MyBatis开发Dao的原始Dao开发和Mapper动态代理开发 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11990961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11990961.html</guid>
<description>&lt;p&gt;@&lt;br/&gt;使用MyBatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper动态代理开发方法。原始Dao开发中存在以下问题：&lt;br/&gt;Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法&lt;/p&gt;
&lt;p&gt;调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不得于开发维护。&lt;/p&gt;
&lt;p&gt;而动态代理开发中Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由&lt;/p&gt;
&lt;p&gt;Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用mapper代理的方法来开发dao时，程序员&lt;strong&gt;只需要干两件事&lt;/strong&gt;即可：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;编写mapper.xml映射文件&lt;/span&gt;&lt;br/&gt;2、&lt;span&gt;编写mapper接口（相当于dao接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Mapper接口开发需要遵循以下&lt;span&gt;&lt;strong&gt;四个规范&lt;/strong&gt;(建议初学者结合下图理解)&lt;/span&gt;：&lt;br/&gt;1、Mapper.xml文件中的namespace与mapper接口的类路径相同。&lt;br/&gt;2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同&lt;br/&gt;3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;br/&gt;4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
&lt;h3 id=&quot;咳咳...初学者看文字mapper接口开发四个规范属实有点费劲博主我就废了点劲做了如下图方便理解&quot;&gt;咳咳...初学者看文字（Mapper接口开发四个规范）属实有点费劲，博主我就废了点劲做了如下图，方便理解：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019072510140672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原始dao开发方式&quot;&gt;原始Dao开发方式&lt;/h2&gt;
&lt;p&gt;原始Dao开发方法需要程序员编写Dao接口和Dao实现类。&lt;/p&gt;
&lt;h3 id=&quot;编写映射文件&quot;&gt;1. 编写映射文件&lt;/h3&gt;
&lt;p&gt;编写映射文件如下：（也可以使用入门程序完成的映射文件）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 --&amp;gt;
&amp;lt;mapper namespace=&quot;test&quot;&amp;gt;

    &amp;lt;!-- 根据id查询用户 --&amp;gt;
    &amp;lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot;
        resultType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 根据username模糊查询用户 --&amp;gt;
    &amp;lt;select id=&quot;queryUserByUsername&quot; parameterType=&quot;string&quot;
        resultType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        select * from user where username like '%${value}%'
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 保存用户 --&amp;gt;
    &amp;lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; order=&quot;AFTER&quot;
            resultType=&quot;int&quot;&amp;gt;
            SELECT LAST_INSERT_ID()
        &amp;lt;/selectKey&amp;gt;
        insert into user(username,birthday,sex,address)
        values(#{username},#{birthday},#{sex},#{address})
    &amp;lt;/insert&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;### 2. 编写Dao接口&lt;/p&gt;
&lt;p&gt;先进行DAO的接口开发，编码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public interface UserDao {
    /**
     * 根据id查询用户
     * 
     * @param id
     * @return
     */
    User queryUserById(int id);

    /**
     * 根据用户名模糊查询用户
     * 
     * @param username
     * @return
     */
    List&amp;lt;User&amp;gt; queryUserByUsername(String username);

    /**
     * 保存用户
     * 
     * @param user
     */
    void saveUser(User user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写dao实现类&quot;&gt;3.编写Dao实现类&lt;/h3&gt;
&lt;p&gt;编写的Dao实现类如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class UserDaoImpl implements UserDao {
    private SqlSessionFactory sqlSessionFactory;

    public UserDaoImpl(SqlSessionFactory sqlSessionFactory) {
        super();
        this.sqlSessionFactory = sqlSessionFactory;
    }

    @Override
    public User queryUserById(int id) {
        // 创建SqlSession
        SqlSession sqlSession = this.sqlSessionFactory.openSession();
        // 执行查询逻辑
        User user = sqlSession.selectOne(&quot;queryUserById&quot;, id);
        // 释放资源
        sqlSession.close();

        return user;
    }

    @Override
    public List&amp;lt;User&amp;gt; queryUserByUsername(String username) {
        // 创建SqlSession
        SqlSession sqlSession = this.sqlSessionFactory.openSession();

        // 执行查询逻辑
        List&amp;lt;User&amp;gt; list = sqlSession.selectList(&quot;queryUserByUsername&quot;, username);
        // 释放资源
        sqlSession.close();
        return list;
    }

    @Override
    public void saveUser(User user) {
        // 创建SqlSession
        SqlSession sqlSession = this.sqlSessionFactory.openSession();

        // 执行保存逻辑
        sqlSession.insert(&quot;saveUser&quot;, user);
        // 提交事务
        sqlSession.commit();
        // 释放资源
        sqlSession.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写dao测试&quot;&gt;4.编写Dao测试&lt;/h3&gt;
&lt;p&gt;创建一个JUnit的测试类，对UserDao进行测试（充当main方法），测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class UserDaoTest {
    private SqlSessionFactory sqlSessionFactory;

    @Before
    public void init() throws Exception {
        // 创建SqlSessionFactoryBuilder
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        // 加载SqlMapConfig.xml配置文件
        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 创建SqlsessionFactory
        this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);
    }

    @Test
    public void testQueryUserById() {
        // 创建DAO
        UserDao userDao = new UserDaoImpl(this.sqlSessionFactory);
        // 执行查询
        User user = userDao.queryUserById(1);
        System.out.println(user);
    }

    @Test
    public void testQueryUserByUsername() {
        // 创建DAO

        UserDao userDao = new UserDaoImpl(this.sqlSessionFactory);
        // 执行查询
        List&amp;lt;User&amp;gt; list = userDao.queryUserByUsername(&quot;五&quot;);
        for (User user : list) {
            System.out.println(user);
        }
    }

    @Test
    public void testSaveUser() {
        // 创建DAO
        UserDao userDao = new UserDaoImpl(this.sqlSessionFactory);

        // 创建保存对象
        User user = new User();
        user.setUsername(&quot;孙尚香肠&quot;);
        user.setBirthday(new Date());
        user.setSex(&quot;1&quot;);
        user.setAddress(&quot;蜀国&quot;);
        // 执行保存
        userDao.saveUser(user);

        System.out.println(user);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mapper动态代理方式&quot;&gt;Mapper动态代理方式&lt;/h2&gt;
&lt;h3 id=&quot;定义mapper.xml映射文件&quot;&gt;1.定义Mapper.xml(映射文件)&lt;/h3&gt;
&lt;p&gt;定义mapper映射文件UserMapper.xml&lt;br/&gt;将UserMapper.xml放在config下mapper目录下，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190725102427322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写usermapper.xml配置文件内容&quot;&gt;2、编写UserMapper.xml配置文件内容：&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- namespace：命名空间，用于隔离sql --&amp;gt;
&amp;lt;!-- 还有一个很重要的作用，使用动态代理开发DAO，1. namespace必须和Mapper接口类路径一致 --&amp;gt;
&amp;lt;mapper namespace=&quot;com.gx.mybatis.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;!-- 根据用户id查询用户 --&amp;gt;
    &amp;lt;!-- 2. id必须和Mapper接口方法名一致 --&amp;gt;
    &amp;lt;!-- 3. parameterType必须和接口方法参数类型一致 --&amp;gt;
    &amp;lt;!-- 4. resultType必须和接口方法返回值类型一致 --&amp;gt;
    &amp;lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot;
        resultType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 根据用户名查询用户 --&amp;gt;
    &amp;lt;select id=&quot;queryUserByUsername&quot; parameterType=&quot;string&quot;
        resultType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        select * from user where username like '%${value}%'
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 保存用户 --&amp;gt;
    &amp;lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.gx.mybatis.pojo.User&quot;&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; order=&quot;AFTER&quot;
            resultType=&quot;int&quot;&amp;gt;
            select last_insert_id()
        &amp;lt;/selectKey&amp;gt;
        insert into user(username,birthday,sex,address) values
        (#{username},#{birthday},#{sex},#{address});
    &amp;lt;/insert&amp;gt;

&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写usermapper接口文件&quot;&gt;3.编写UserMapper(接口文件)&lt;/h3&gt;
&lt;p&gt;创建UserMapper接口代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public interface UserMapper {
    /**
     * 根据id查询
     * 
     * @param id
     * @return
     */
    User queryUserById(int id);

    /**
     * 根据用户名查询用户
     * 
     * @param username
     * @return
     */
    List&amp;lt;User&amp;gt; queryUserByUsername(String username);

    /**
     * 保存用户
     * 
     * @param user
     */
    void saveUser(User user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加载usermapper.xml文件&quot;&gt;4.加载UserMapper.xml文件&lt;/h3&gt;
&lt;p&gt;修改SqlMapConfig.xml文件，添加以下所示的内容：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    &amp;lt;!-- 加载映射文件 --&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;sqlmap/User.xml&quot; /&amp;gt;
        &amp;lt;mapper resource=&quot;mapper/UserMapper.xml&quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写测试&quot;&gt;5.编写测试&lt;/h3&gt;
&lt;p&gt;编写的测试方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class UserMapperTest {
    private SqlSessionFactory sqlSessionFactory;

    @Before
    public void init() throws Exception {
        // 创建SqlSessionFactoryBuilder
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        // 加载SqlMapConfig.xml配置文件
        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        // 创建SqlsessionFactory
        this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);
    }

    @Test
    public void testQueryUserById() {
        // 获取sqlSession，和spring整合后由spring管理
        SqlSession sqlSession = this.sqlSessionFactory.openSession();

        // 从sqlSession中获取Mapper接口的代理对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 执行查询方法
        User user = userMapper.queryUserById(1);
        System.out.println(user);

        // 和spring整合后由spring管理
        sqlSession.close();
    }

    @Test
    public void testQueryUserByUsername() {
        // 获取sqlSession，和spring整合后由spring管理
        SqlSession sqlSession = this.sqlSessionFactory.openSession();

        // 从sqlSession中获取Mapper接口的代理对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 执行查询方法
        List&amp;lt;User&amp;gt; list = userMapper.queryUserByUsername(&quot;五&quot;);
        for (User user : list) {
            System.out.println(user);
        }

        // 和spring整合后由spring管理
        sqlSession.close();
    }

    @Test
    public void testSaveUser() {
        // 获取sqlSession，和spring整合后由spring管理
        SqlSession sqlSession = this.sqlSessionFactory.openSession();

        // 从sqlSession中获取Mapper接口的代理对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 创建保存对象
        User user = new User();
        user.setUsername(&quot;刘备胎&quot;);
        user.setBirthday(new Date());
        user.setSex(&quot;2&quot;);
        user.setAddress(&quot;鼠国&quot;);
        // 执行查询方法
        userMapper.saveUser(user);
        System.out.println(user);


        // 和spring整合后由spring管理
        sqlSession.commit();
        sqlSession.close();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 00:04:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[TOC] 使用MyBatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper动态代理开发方法。原始Dao开发中存在以下问题： Dao方法体存在重复代码：通过SqlSessionFa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11990961.html</dc:identifier>
</item>
<item>
<title>JavaEE基础(02)：Servlet核心API用法详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12020195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12020195.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/java-base-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/java-base-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;servlet执行流程&quot;&gt;1、Servlet执行流程&lt;/h2&gt;
&lt;p&gt;Servlet是JavaWeb的三大组件之一（Servlet、Filter、Listener），它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要：接收请求数据；处理请求；完成响应。&lt;/p&gt;
&lt;h2 id=&quot;核心api简介&quot;&gt;2、核心API简介&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ServletConfig&lt;/td&gt;
&lt;td&gt;获取servlet初始化参数和servletContext对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ServletContext&lt;/td&gt;
&lt;td&gt;在整个Web应用的动态资源之间共享数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ServletRequest&lt;/td&gt;
&lt;td&gt;封装Http请求信息，在请求时创建。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ServletResponse&lt;/td&gt;
&lt;td&gt;封装Http响应信息，在请求时创建。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;接口简介&quot;&gt;1、接口简介&lt;/h2&gt;
&lt;p&gt;容器在初始化servlet时，为该servlet创建一个servletConfig对象，并将这个对象通过init()方法来传递并保存在此Servlet对象中。核心作用：1.获取初始化信息;2.获取ServletContext对象。&lt;/p&gt;
&lt;h2 id=&quot;代码案例&quot;&gt;2、代码案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;my-name&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;cicada&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletOneImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.node02.servlet.impl.ServletOneImpl&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletOneImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/servletOneImpl&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServletOneImpl implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        String servletName = servletConfig.getServletName() ;
        System.out.println(&quot;servletName=&quot;+servletName);
        String myName = servletConfig.getInitParameter(&quot;my-name&quot;) ;
        System.out.println(&quot;myName=&quot;+myName);
        Enumeration paramNames = servletConfig.getInitParameterNames() ;
        while (paramNames.hasMoreElements()){
            String paramKey = String.valueOf(paramNames.nextElement()) ;
            String paramValue = servletConfig.getInitParameter(paramKey) ;
            System.out.println(&quot;paramKey=&quot;+paramKey+&quot;;paramValue=&quot;+paramValue);
        }
        ServletContext servletContext = servletConfig.getServletContext() ;
        servletContext.setAttribute(&quot;cicada&quot;,&quot;smile&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;接口简介-1&quot;&gt;1、接口简介&lt;/h2&gt;
&lt;p&gt;一个项目只有一个ServletContext对象，可以在多个Servlet中来获取这个对象，使用它可以给多个Servlet传递数据，该对象在Tomcat启动时就创建，在Tomcat关闭时才会销毁！作用是在整个Web应用的动态资源之间共享数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1、ServletConfig#getServletContext()；
2、GenericServlet#getServletContext();
3、HttpSession#getServletContext()
4、ServletContextEvent#getServletContext()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四大域对象&quot;&gt;2、四大域对象&lt;/h2&gt;
&lt;p&gt;ServletContext是JavaWeb四大域对象之一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、PageContext；
2、ServletRequest；
3、HttpSession；
4、ServletContext；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据。&lt;/p&gt;
&lt;h2 id=&quot;代码案例-1&quot;&gt;3、代码案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;my-blog&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;2019-11-19&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletTwoImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.node02.servlet.impl.ServletTwoImpl&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletTwoImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/servletTwoImpl&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServletTwoImpl extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // 1、参数传递
        ServletContext servletContext = this.getServletContext() ;
        String value = String.valueOf(servletContext.getAttribute(&quot;cicada&quot;)) ;
        System.out.println(&quot;value=&quot;+value);
        // 2、获取初始化参数
        String myBlog = servletContext.getInitParameter(&quot;my-blog&quot;) ;
        System.out.println(&quot;myBlog=&quot;+myBlog);
        // 3、获取应用信息
        String servletContextName = servletContext.getServletContextName() ;
        System.out.println(&quot;servletContextName=&quot;+servletContextName);
        // 4、获取路径
        String pathOne = servletContext.getRealPath(&quot;/&quot;) ;
        String pathTwo = servletContext.getRealPath(&quot;/WEB-INF/&quot;) ;
        System.out.println(&quot;pathOne=&quot;+pathOne+&quot;;pathTwo=&quot;+pathTwo);
        response.getWriter().print(&quot;执行：doGet; value：&quot;+value);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;接口简介-2&quot;&gt;1、接口简介&lt;/h2&gt;
&lt;p&gt;HttpServletRequest接口继承ServletRequest接口，用于封装请求信息，该对象在用户每次请求servlet时创建并传入servlet的service()方法，在该方法中，传入的servletRequest将会被强制转化为HttpservletRequest对象来进行HTTP请求信息的处理。核心作用：1.获取请求报文信息;2.获取网络连接信息;3.获取请求域属性信息。&lt;/p&gt;
&lt;h2 id=&quot;代码案例-2&quot;&gt;2、代码案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletThreeImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.node02.servlet.impl.ServletThreeImpl&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletThreeImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/servletThreeImpl&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServletThreeImpl extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // http://localhost:6003/servletThreeImpl?myName=cicada
        String method = request.getMethod();
        System.out.println(&quot;method=&quot;+method); // GET
        String requestURL = request.getRequestURL().toString();
        // http://localhost:6003/servletThreeImpl
        System.out.println(&quot;requestURL=&quot;+requestURL);
        String requestURI = request.getRequestURI();
        System.out.println(&quot;requestURI=&quot;+requestURI); // /servletThreeImpl
        String queryString = request.getQueryString() ;
        System.out.println(&quot;queryString=&quot;+queryString); // myName=cicada
        String myName = request.getParameter(&quot;myName&quot;);
        System.out.println(&quot;myName=&quot;+myName); // cicada
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;接口简介-3&quot;&gt;1、接口简介&lt;/h2&gt;
&lt;p&gt;HttpServletResponse继承自ServletResponse，封装了Http响应信息。客户端每个请求，服务器都会创建一个response对象，并传入给Servlet.service()方法。核心作用：1.设置响应头信息;2.发送状态码;3.设置响应正文;4.重定向；&lt;/p&gt;
&lt;h2 id=&quot;代码案例-3&quot;&gt;2、代码案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletFourImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.node02.servlet.impl.ServletFourImpl&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;servletFourImpl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/servletFourImpl&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class ServletFourImpl extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(&quot;text/html;charset=utf-8&quot;) ;
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        response.setStatus(200) ;
        response.getWriter().print(&quot;Hello,知了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转发和重定向&quot;&gt;3、转发和重定向&lt;/h2&gt;
&lt;p&gt;服务器端进行的页面跳转的控制 ;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;request.getRequestDispatcher(&quot;/转发地址&quot;).forward(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端响应跳转信息，浏览器端进行的页面跳转 ;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;response.sendRedirect(&quot;重定向地址&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;转发和重定向对比&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;地址栏&lt;/td&gt;
&lt;td&gt;不变&lt;/td&gt;
&lt;td&gt;变化&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;跳转&lt;/td&gt;
&lt;td&gt;服务端跳转&lt;/td&gt;
&lt;td&gt;浏览器端跳转&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;请求次数&lt;/td&gt;
&lt;td&gt;一次&lt;/td&gt;
&lt;td&gt;两次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;域中数据&lt;/td&gt;
&lt;td&gt;不会丢失&lt;/td&gt;
&lt;td&gt;丢失&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/java-base-parent
GitEE·地址
https://gitee.com/cicadasmile/java-base-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 00:01:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' 一、核心API简介 1、Servlet执行流程 Servlet是JavaWeb的三大组件之一（Servlet、Filter、List</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12020195.html</dc:identifier>
</item>
<item>
<title>接口幂等性的解决方案 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11727533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11727533.html</guid>
<description>&lt;p&gt;在编程中，幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数指的是那些使用相同参数重复执行也能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。比如说getIdCard()函数和setTrue()函数就是幂等函数。&lt;/p&gt;
&lt;p&gt;幂等在我的理解里就是，一个操作不论被执行多少次，产生的效果和返回的结果都是一样的。&lt;/p&gt;
&lt;p&gt;一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。&lt;/p&gt;
&lt;p&gt;一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;幂等的方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查询操作：Select是天然的幂等操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查询一次和查询多次，在数据不变的情况下，查询的结果都是一样的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.删除操作：删除操作也是幂等的，删除一次和删除多次都是把数据删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为删除操作通常是定向的，比如通过id去删除数据，如果该id在数据库中存在对应记录，则删除该记录；如果该id在数据库中不存在对应记录，也是执行的删除记录操作，只是没有实质性地删除到记录而已，却也不会有其他的副作用。&lt;/p&gt;
&lt;p&gt;但是如果删除操作具有返回值的话，可能返回的结果会不一样，比如删除一条记录之后返回这条记录中的某个值，如果删除的数据不存在（已经在第一次的删除请求中被删除了），返回的就是空值了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.唯一索引：通过在数据库表的一个字段上建立唯一索引可以有效防止新增脏数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如有一个特殊订单表，这个特殊订单表关联了一个用户表，业务设置是每一个用户只能创建一个特殊订单，也就意味着在这个特殊订单表中只能有一条用户关联的记录。那么这时候就可以在这个特殊订单表上针对这个用户关联的字段做一个唯一索引，通过数据库的唯一约束来限制往特殊订单表中插入多条一个用户关联的记录。这样，当第二次请求往特殊订单表中插入一个用户关联的特殊订单记录的时候，数据库就会报错并回滚插入操作，也就保证了幂等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Token校验机制：操作前先校验Token，以防止页面重复提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原理上是通过Session Token来实现的，当然也可以通过Redis来实现。当客户端请求页面时，服务器会先生成一个全局唯一的Token，然后将该Token放置到Session或Redis当中，然后将Token发送给客户端（一般通过构造Hidden表单或放在浏览器缓存中）。等下次客户端提交请求时，Token就会随着表单一起提交到服务器端。当服务器端第一次验证通过之后，就会将Session中的Token值更新或删除，若用户重复提交，第二次的验证判断就是失败，请求的操作也不会被重复执行。这是因为用户提交的表单中的Token没变，但服务器端的Session中的Token已经改变了或不存在了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.悲观锁：获取数据的时候加锁获取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; yanggb &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;huangq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。&lt;/p&gt;
&lt;p&gt;另外要注意的是，id字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.乐观锁：通过版本号或其他状态字段做更新限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与悲观锁长时间锁表不一样，乐观锁只是在更新数据那一刻锁表，其他时间不锁表。所以乐观锁相对于悲观锁，在大部分场景中效率会更高一些。乐观锁的实现方式多种多样，可以通过version或者其他状态条件。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;age&lt;/td&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;yanggb&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;比如给业务表内添加一个版本号的字段，如果要调用一个接口去更新年龄之前，就需要先查一下他的版本号是多少，然后调用接口的时候带上版本号。&lt;/p&gt;
&lt;p&gt;在接口里保证分布式接口的幂等性（在更新的SQL中添加version的条件判断）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; age &lt;span&gt;=&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;, version &lt;span&gt;=&lt;/span&gt; version &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; version &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，多次提交的请求，因为版本号（version）都一样，因为第一次请求执行成功之后version已经+1了，则后面的请求因为version对应不上，都不会被执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.分布式锁：另一个角度的Token校验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果是分布式系统的话，构建全局唯一索引会比较困难，比如唯一性的字段就没有办法确定。这时候可以引入分布式锁，通过第三方的系统（Redis或Zookeeper），在业务系统插入数据或者更新数据前，需要先获取分布式锁，然后才能做操作，操作完成之后就释放锁。这样其实是把单机系统里面多线程并发锁的思路引入了多个系统的场景，也就是分布式系统中的解决思路。&lt;/p&gt;
&lt;p&gt;要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志（用户ID+后缀等）获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁（分布式锁要第三方系统提供）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.select + insert：一种简单却比较笨的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于一些并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，可以采取的一种简单处理方法是，先根据一些关键数据到表中查询记录，以此来判断是否已经执行过，判断后再进行业务处理就可以了。&lt;/p&gt;
&lt;p&gt;要注意的是，核心高并发流程不要用这种方法，因为要查询一遍数据（你想想为什么要会把数据放到Redis中），性能太低了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.状态机幂等：另一个角度的乐观锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机（状态变更图）。简单理解，就是业务单据上面有个状态的字段，状态在不同的情况下会发生变更，一般情况下存在有限状态机。这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;幂等的概念与分布式、高并发或JavaEE的概念都没有关系，其只关心操作被多次执行产生的影响是否与一次执行是一致的。&lt;/p&gt;
&lt;p&gt;事实上，要做到幂等性，只要从接口的设计上出发，不设计出任何非幂等的操作即可。譬如说有一个需求是，当用户点击赞同时，将答案的赞同数量+1。直接修改用户点赞表（答案id，点赞数）的点赞数（+1）显然不是幂等的。这种场景就可以改为：当用户点击赞同时，往用户点赞表（答案id，用户id）中添加一条记录，然后通过在用户id字段上建立唯一索引来确保在答案赞同表中只存在一条一个用户点赞的记录，最后的赞同数量由答案赞同表通过count去统计出来。当然了，实际的系统也不会这么设计，这里只是我没有想到更好的例子。说起来简单，做起来真的太难了，哈哈哈。&lt;/p&gt;
&lt;p&gt;总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行或互联网金融公司等涉及的都是金钱钱的系统，既要高效，也要保证数据准确，不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好。&lt;/p&gt;

&lt;p&gt;&quot;他们就像星星一样那么亮，我永远都够不着。&quot;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 23:32:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>在编程中，幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数指的是那些使用相同参数重复执行也能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11727533.html</dc:identifier>
</item>
<item>
<title>信息抽取——关系抽取(一) - 西多士NLP</title>
<link>http://www.cnblogs.com/sandwichnlp/p/12020066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sandwichnlp/p/12020066.html</guid>
<description>&lt;p&gt;信息抽取（information extraction），即从自然语言文本中，抽取出特定的事件或事实信息，帮助我们将海量内容自动分类、提取和重构。这些信息通常包括实体（entity）、关系（relation）、事件（event）。例如从新闻中抽取时间、地点、关键人物，或者从技术文档中抽取产品名称、开发时间、性能指标等。&lt;/p&gt;
&lt;p&gt;显然，信息抽取任务与命名实体识别任务类似，但相对来说更为复杂。有时，信息抽取也被称为事件抽取（event extraction）。&lt;/p&gt;
&lt;p&gt;与自动摘要相比，信息抽取更有目的性，并能将找到的信息以一定的框架展示。自动摘要输出的则是完整的自然语言句子，需要考虑语言的连贯和语法，甚至是逻辑。有时信息抽取也被用来完成自动摘要。&lt;/p&gt;
&lt;p&gt;由于能从自然语言中抽取出信息框架和用户感兴趣的事实信息，无论是在知识图谱、信息检索、问答系统还是在情感分析、文本挖掘中，信息抽取都有广泛应用。&lt;/p&gt;
&lt;p&gt;信息抽取主要包括三个子任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实体抽取与链指：也就是命名实体识别&lt;/li&gt;
&lt;li&gt;关系抽取：通常我们说的三元组(triple)抽取，主要用于抽取实体间的关系&lt;/li&gt;
&lt;li&gt;事件抽取：相当于一种多元关系的抽取&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于工作上的原因，先对关系抽取进行总结，实体链指部分之后有时间再补上吧。&lt;/p&gt;

&lt;p&gt;关系抽取通常再实体抽取与实体链指之后。在识别出句子中的关键实体后，还需要抽取两个实体或多个实体之间的语义关系。语义关系通常用于连接两个实体，并与实体一起表达文本的主要含义。常见的关系抽取结果可以用SPO结构的三元组来表示，即 (Subject, Predication, Object)，如&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;中国的首都是北京 ==&amp;gt; (中国, 首都, 北京)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关系抽取的分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否有确定的关系集合：
&lt;ul&gt;&lt;li&gt;限定关系抽取：事先确定好所有需要抽取的关系集合，则可讲关系抽取看作是一中关系判断问题，或者说是分类问题&lt;/li&gt;
&lt;li&gt;开放式关系抽取：需要抽取的关系集合是不确定的，另一方面抽取预料的所属领域也可能是不确定的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关系抽取可以用有监督、半监督甚至是无监督的方法来做。
&lt;ul&gt;&lt;li&gt;有监督学习：监督学习的关系集合通常是确定的，我们仅需要将其当作一个简单的分类问题来处理即可。高质量监督数据下的监督学习模型的准确率会很高，但缺点就是需要大量的人力成本和时间成本来对文本数据进行标注，且其难以扩展新的关系类别，模型较为脆弱，泛化能力有限&lt;/li&gt;
&lt;li&gt;半监督学习利用少量的标注信息作为种子模版，从非结构化数据中抽取大量的新的实例来构成新的训练数据。主要方法包括 Bootstraping 以及远程监督学习的方法&lt;/li&gt;
&lt;li&gt;无监督学习一般利用语料中存在的大量冗余信息做聚类，在聚类结果的基础上给定关系，但由于聚类方法本身就存在难以描述关系和低频实例召回率低的问题，因此无监督学习一般难以得很好的抽取效果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于有监督的关系抽取任务，通常也将其分为两大类
&lt;ul&gt;&lt;li&gt;Pipline：将实体抽取与关系抽取分为两个独立的过程，关系抽取依赖实体抽取的结果，容易造成误差累积&lt;/li&gt;
&lt;li&gt;Joint Model：实体抽取与关系抽取同时进行，通常用模型参数共享的方法来实现&lt;br/&gt;随着深度学习以及词向量的发展，近年来大多的关系抽取模型都采用词向量作为关系抽取的主要特征，且均取得了非常好的效果。限于篇幅，本文仅对有监督学习下的 Pipline 经典模型进行介绍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;model-1-relation-classification-via-convolutional-deep-neural-network&quot;&gt;Model 1: Relation Classification via Convolutional Deep Neural Network&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/C14-1220/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/C14-1220/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在深度学习兴起之前，关系抽取的传统方法依赖于特征工程，而这些特征通常由预先准备的NLP系统得到，这容易在构造特征的过程中造成误差累积，阻碍系统性能。&lt;/p&gt;
&lt;p&gt;该论文属于早期使用深度卷积网络模型解决关系抽取任务的经典论文。该论文将关系抽取问题定义为：给定一个句子 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和名词对 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; ​和 $e_2 $​，判断 &lt;span class=&quot;math inline&quot;&gt;\(e_1​\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; ​在句子中的关系，即将关系抽取问题等效为一个关系分类问题。与传统的方法相比，该模型只需要将整个输入句子以及简单的词信息作为输入，而不需要认为构造特征，就能得到非常好的效果。模型的主要架构如下所示：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/06/YWIB2QDk38caJn7.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型的输入主要包括两个部分，即词汇级别特征以及句子级别特征：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;lexical level features：词汇级别特征包括实体对&lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 的词嵌入向量，&lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 的左右两边词的词嵌入向量，以及一个 WordNet 上位词向量。WordNet 上位词特征指的是 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 同属于哪一个上位名次，如“狗”和“猫”的上位词可以是“动物”或者“宠物”，具体需要参考的 WordNet 词典是怎样构建的。直接将上述的5个向量直接拼接构成词汇级别的特征向量 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;sentence level feature：句子级别特征采用最大池化的卷积神经网络作为主要特征抽取模型，输入特征包括词向量信息以及位置向量信息。
&lt;ul&gt;&lt;li&gt;Word Features：为了能够抽取到每个词完整的上下文信息，在句子首位额外添加了Padding字符，Word Embedding 层是预训练得到的，并且参与后续的训练任务&lt;/li&gt;
&lt;li&gt;Position Features：额外增加了时序特征来弥补卷积网络对时序特征抽取能力不足的缺陷。论文中的做法是为每个词拼接两个固定维度的位置向量，分别表示词距离两个关键实体的相对位置信息。如“中国 的 首都 是 北京”，“的”与“中国”的距离大小为 1，与“北京”的距离大小为 -3，再将 1 和 -3 在 Position Embedding 层中查表得到，Position Embedding 层是随机初始化的，并且参与到模型训练当中&lt;/li&gt;
&lt;li&gt;将上述的 Word Features 与 Position Features 拼接，输入到卷积网络中，再用Max Pooling 层把每个卷积核的输出进行池化操作。再将池化结果通过一个全连接层，激活函数为 &lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt;，将其看作一个更高层次的特征映射，得到最终的句子级别的特征向量 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将词汇级别特征与句子级别特征直接拼接，即&lt;span class=&quot;math inline&quot;&gt;\(f = [l, g]\)&lt;/span&gt;，最终将其送入分类器进行分类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该模型将关系抽取任务利用神经网络进行建模，利用无监督的词向量以及位置向量作为模型的主要输入特征，一定程度上避免了传统方法中的误差累积。但仍然有 lexical level feature 这个人工构造的特征，且 CNN 中的卷积核大小是固定的，抽取到的特征十分单一&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/W15-1506/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/W15-1506/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该论文首先提出关系分类和关系抽取两个主要任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系分类：两个实体之间存在多个关系类型，并且这多个可能关系中有一个 non-relation 类别，这多个类别的样本数量基本是平衡的&lt;/li&gt;
&lt;li&gt;关系抽取：关系抽取与关系分类的区别在于，关系抽取中的 non-relation 类别的样本数目可能远远超过其他类别的样本数目，这样的任务更有挑战性，但在实际中有更为广泛的应用&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/07/Wr3jSxFH8RbtVzu.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;论文主要关注的是关系抽取任务。与 &lt;strong&gt;Model 1&lt;/strong&gt; 类似，同样是利用卷积神经网络作为主要的特征抽取模型，模型细节如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Look-up tables：包括 word embedding 层和 position embedding 层两个部分。word embedding 为预训练得到，而 position embedding 则随机初始化，两者均参与训练。对于输入句子长度，将其限定在两个实体可能的最大长度的范围内，假设句子长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，用 &lt;span class=&quot;math inline&quot;&gt;\(i-i_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(i-i_2\)&lt;/span&gt; 表示地i个词距离第一个实体和第二个实体的距离，则 position embedding 层的维度为&lt;span class=&quot;math inline&quot;&gt;\((2n-1) \times m_d\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(m_d\)&lt;/span&gt; 为位置向量的维度。假设句子中第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个词的词向量为 &lt;span class=&quot;math inline&quot;&gt;\(e_i\)&lt;/span&gt; ，位置向量为 &lt;span class=&quot;math inline&quot;&gt;\(d_{i1}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(d_{i2}\)&lt;/span&gt;，则该词的词表征为 &lt;span class=&quot;math inline&quot;&gt;\(x_i = [e_i, d_{i1}, d_{i2}]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Convolutional layer：该模型的卷积层借鉴了 TextCNN 的模型结构，通过设计多个不同宽度的卷积核来抽取不同粒度大小的特征来提升模型性能。&lt;/li&gt;
&lt;li&gt;Pooling layer：最大池化操作，用于抽取最重要的特征&lt;/li&gt;
&lt;li&gt;Classifier：全连接层，激活函数为softmax，还使用了 dropout 和 l2 正则化策略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该论文的模型输入完全没有人工特征，且使用多宽度大小的卷积核进行特征抽取，相对于 Zeng 的效果来说仅提升了 &lt;span class=&quot;math inline&quot;&gt;\(0.1\%\)&lt;/span&gt;，个人认为提升的主要关键点在于多粒度大小的卷积核上，而 lexical feature 在这种简单的深度学习模型上还是能够起到一定的效果的，这在之后的工作中也得到了证实&lt;/p&gt;
&lt;h2 id=&quot;model-3-classifying-relations-by-ranking-with-convolutional-neural-networks&quot;&gt;Model 3: Classifying Relations by Ranking with Convolutional Neural Networks&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/P15-1061/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/P15-1061/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/07/YBnc9g8qObuCoLh.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇论文同样是在 &lt;strong&gt;Model 1&lt;/strong&gt; 基础上的改进，模型的基本架构与之前基本一致，最大的改变损失函数。模型结构如上图所示，主要有以下几个部分：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;模型仅将整个句子作为输入，不考虑 lexical level feature。输入词表征包括 Word Embedding 和 Position Embedding 两个部分，获取方式与之前一样&lt;/li&gt;
&lt;li&gt;卷积层为窗口为 3 的固定大小的卷积核，且也对输出进行了最大池化操作&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于得到的编码表征，输入一个全连接层，得到每个类别的非归一化分数，但不再对输出做 softmax 操作，而是直接对正类别和负类别进行采样，从而计算损失函数，损失函数(pairwise ranking loss function)如下所示：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L = log(1 + exp(\gamma(m^+-s_{\theta}(x)_{y^+}))) + log(1 + exp(\gamma(m^-+s_{\theta}(x)_{c^-})))\]&lt;/span&gt;&lt;/p&gt;
这个损失函数主要有以下几个特点：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(m^+\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(m^-\)&lt;/span&gt; 为 margin 参数，&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 为缩放因子&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(s_{\theta}(x)\)&lt;/span&gt; 为模型输出的非归一化分数，&lt;span class=&quot;math inline&quot;&gt;\(y^+\)&lt;/span&gt; 为正确标签，&lt;span class=&quot;math inline&quot;&gt;\(c^-\)&lt;/span&gt; 为错误标签中分数大于 &lt;span class=&quot;math inline&quot;&gt;\(m^-\)&lt;/span&gt; 的那些标签，作者认为这些标签具有更大的信息量。&lt;/li&gt;
&lt;li&gt;显然，损失函数 L 将随着 &lt;span class=&quot;math inline&quot;&gt;\(s_{\theta}(x)_{y^+}\)&lt;/span&gt; 的增大而减小，随着 &lt;span class=&quot;math inline&quot;&gt;\(s_{\theta}(x)_{c^-}\)&lt;/span&gt; 的减小而减小&lt;/li&gt;
&lt;li&gt;此外，模型还考虑了两个实体不属于任何类别，将其看作类别 &quot;Other&quot;，在训练的过程中，不考虑这个类别的分类，或者说在全连接层为该类别分配了一个不可训练的零初始化的神经元，对于该类别为正确标签的训练样本，损失函数的第一项为0，只保留第二项。在预测的时候，只当某个样本所有类别分数为负数时，才将其分类为 &quot;Other&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;模型在训练过程中还额外添加了 L2 正则化项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该模型的主要创新点在于其 Ranking loss 上，相比于 Softmax 函数，其能够使得模型不仅仅考虑到正类别分数要尽量高，还要关注易分类错误的类别分数尽量低。其缺点仍然是模型结构上的缺陷。&lt;/p&gt;
&lt;h2 id=&quot;model-4-bidirectional-long-short-term-memory-networks-for-relation-classification&quot;&gt;Model 4: Bidirectional Long Short-Term Memory Networks for Relation Classification&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/Y15-1009/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/Y15-1009/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇论文之前有过利用简单的 RNN 和 BiRNN 作为模型编码模块的处理关系抽取任务的，但是效果较 CNN 来说差的就不是一点两点了，这里就不提了。该论文用经典的 BiLSTM 作为模型主要模块，此外，重新考虑了 lexical feature，实验证明 lexical feature 对模型性能确实有十分明显的提升效果。&lt;/p&gt;
&lt;p&gt;模型的主要架构是 BiLSTM，这个结构大家再熟悉不过了，论文也没有贴模型整体图，这里我也偷下懒...接下来分段阐述一下模型的主要工作。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;特征初始化：模型使用到的特征除了词和位置特征以外，还利用NLP工具获得了词性(POS)、实体(NER)、依存句法(dependency parse)以及上位(hypernyms)特征
&lt;ul&gt;&lt;li&gt;词、词性(POS)、实体(NER)以及上位(hypernyms)特征均为 lexical feature&lt;/li&gt;
&lt;li&gt;位置向量和依存句法特征的构造方式如下所示
&lt;ul&gt;&lt;li&gt;位置向量：位置向量(图中为PF)的构造方法与 Zeng CNN 中一致&lt;/li&gt;
&lt;li&gt;相对依存特征(Relative dependency features)依赖 Stanford dependency parser 依存句法树生成，做如下定义
&lt;ul&gt;&lt;li&gt;Relative root feature：根节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(r_r\)&lt;/span&gt;，根节点的子节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(r_c\)&lt;/span&gt;，其他节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(r_o\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Relative &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; feature：实体 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 定义为 &lt;span class=&quot;math inline&quot;&gt;\(e_{1e}\)&lt;/span&gt;，实体 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 的父节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(e_{1p}\)&lt;/span&gt;，实体 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 的子节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(e_{1c}\)&lt;/span&gt;，其他节点定义为 &lt;span class=&quot;math inline&quot;&gt;\(e_{1o}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Relative &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; feature：相对实体 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 做如 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 类似的定义&lt;/li&gt;
&lt;li&gt;Dep feature：为每个词与其父节点的依存关系&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/08/gSpHWQDIJk92YsN.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;特征嵌入：第个词的词向量 &lt;span class=&quot;math inline&quot;&gt;\(r_i^w\)&lt;/span&gt; 利用预训练的词向量查表得到，第j个特征向量 &lt;span class=&quot;math inline&quot;&gt;\(r_i^{kj}\)&lt;/span&gt; 直接随机初始化得到，最终的词表征为词向量与特征向量拼接而成：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x_i = [r_i^w, r_i^{k1}, ..., r_i^{km}]\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;句子级别表征：直接将词表征输入 BiLSTM 进行编码，用 &lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 表示两个方向，&lt;span class=&quot;math inline&quot;&gt;\(h_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(c_i\)&lt;/span&gt;表示隐藏信息与全局信息，则第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 时刻的输出为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[F_i = [F_{h_i}, F_{c_i}, B_{h_i}, B_{c_i}]\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;特征向量整合：作者受到 Zeng CNN 的启发，也构造了 lexical level feature 和 sentence level feature
&lt;ul&gt;&lt;li&gt;lexical level feature：该特征只关注实体的特征，即只将两个实体的词表征和 BiLSTM 编码表征进行拼接 &lt;span class=&quot;math inline&quot;&gt;\([x_{e1}, F_{e1}, x_{e2}, F_{e2}]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;sentence level feature：句子级别的表征需要关注整个句子的信息，如下图所示，两个实体将整个句子分为三个部分，&lt;span class=&quot;math inline&quot;&gt;\(m1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(m2\)&lt;/span&gt; 分别为 &lt;span class=&quot;math inline&quot;&gt;\([A, B]\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\([B, C]\)&lt;/span&gt; Max Pooling 操作的结果，最后的句子级别特征为 &lt;span class=&quot;math inline&quot;&gt;\([m1, m2]\)&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/08/fnJml5DEWT1wuj9.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;/li&gt;
&lt;li&gt;将两个向量拼接，然后通过多层的全连接网络将其进行整合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后利用前连接层 + softmax 进行分类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;论文最后测试了不加人工特征，只用 word embedding，结果下降了&lt;span class=&quot;math inline&quot;&gt;\(1.5\)&lt;/span&gt;个点，说明人工特征还是有一定效果的。此外，论文还测试了移除某个特征对模型的影响，发现位置特征和 NER 特征的移除对模型的影响非常小，这也是十分好理解的，这里就不多说了。&lt;/p&gt;
&lt;h2 id=&quot;model-5-attention-based-bidirectional-long-short-term-memory-networks-for-relation-classification&quot;&gt;Model 5: Attention-Based Bidirectional Long Short-Term Memory Networks for Relation Classification&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;该模型利用了典型的注意力机制对 BiLSTM 的输出进行了注意力加权求和，在仅利用了词向量的情况下效果接近加入人工特征的模型，可见注意力机制的作用也是十分强大的。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/09/tXa2KHM1ySJDqWZ.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型的主要架构如上图所示。其实模型的主要架构还是比较常规的，下面简单介绍一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Input Layer: 即输入的句子，每个词用 one-hot 向量表示&lt;/li&gt;
&lt;li&gt;Embedding Layer: 预训练的词向量层，为 one-hot 向量提供查询词表&lt;/li&gt;
&lt;li&gt;LSTM Layer: 利用 BiLSTM 对输入句子进行编码，得到每个时刻的输出，即对应每个词的编码结果&lt;/li&gt;
&lt;li&gt;Attention Layer: 典型的 Soft-Attention 层。直接随机初始化一个参数向量作为 Query，用于与句子的编码结果进行一维匹配计算注意力分数，再对句子的各个词的编码结果进行加权求和，具体表达式如下所示：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[M = tanh(H) \\ \alpha =softmax(w^TM) \\ r = H\alpha^T\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; 为 BiLSTM 的所有时刻的输出，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 为随机初始化的参数向量，同时也参与到模型训练，&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 为注意力分数的计算结果，&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 为对 &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; 注意力分数加权的结果，最后还对注意力加权结果通过一个 &lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt; 激活函数，即 &lt;span class=&quot;math inline&quot;&gt;\(h^* = tanh(r)\)&lt;/span&gt; 得到注意力层的输出&lt;/li&gt;
&lt;li&gt;Output Layer: 即一层全连接层分类器，损失函数为交叉熵，同时加入了 L2 正则化项&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从论文的结果来看，不进行特征工程，仅仅将整个句子作为模型输入，并加入注意力机制，模型效果得到了非常大的提高，一方面说明必要的特征工程还是有效的，另一方面表明注意力机制也起到了十分明显的作用&lt;/p&gt;
&lt;h2 id=&quot;model-6-relation-classification-via-multi-level-attention-cnns&quot;&gt;Model 6: Relation Classification via Multi-Level Attention CNNs&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/P16-1123/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/P16-1123/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章公布其在 SemEval-2010 Task 8 上的分数达到了 88.0，但是没有开源，且复现结果也不太好，这个模型的效果存在争议，或许是论文中个别细节描述有误，但是其思路还是非常不错的，先给概括一下整个论文的工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模型主要依赖一种多层注意力机制
&lt;ul&gt;&lt;li&gt;第一层的注意力机制在输入层，用于计算所有词对目标实体的注意力大小&lt;/li&gt;
&lt;li&gt;第二层的注意力机制在CNN的输出部分，用于计算对于目标关系的注意力大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提出了一种新的损失函数，证明其效果要优于传统的损失函数&lt;/li&gt;
&lt;li&gt;其优秀的模型表现依赖于非常丰富的先验知识&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/09/F2UWKnQeGL8jqsZ.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;模型的主要结构如上图所示，下面分别阐述下模型的各个模块：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;Input Representation: 输入表征与 Zeng CNN 一致，为 Word Embedding 和 Position Embeddding 的拼接，即 &lt;span class=&quot;math inline&quot;&gt;\(w^M_i = [w^d_i, w^p_{i,1}, w^p_{i,2}]\)&lt;/span&gt;，由于 CNN 的 n-gram 特性，同样需要对句子的首尾进行 padding 操作。为了与之后的注意力机制进行匹配，通过将以中心词为中心的 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个词的词向量进行拼接，得到 n-gram 表征，即 &lt;span class=&quot;math inline&quot;&gt;\(z_i = [w^M_{i-(k-1)/2}, ..., w^M_{i+(k-1)/2}]\)&lt;/span&gt;，之后的卷积核窗口设置为 1，即可实现与传统的卷积窗口为 k 相类似的效果&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Input Attention Mechanism: 直接使用向量内积的方式来计算实体与其他词之间的相关性，并且将其构造成一个对角阵（其实可以直接用向量来表示的），再将其进行softmax归一化得到注意力分数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[A^j_{i, i} = e_i \cdot w_i \\ \alpha^j_i = \frac{exp(A^j_{i, i})}{\sum_{i'=1}^nexp(A^j_{i', i'})} \]&lt;/span&gt;&lt;/p&gt;
在求得每个词针对两个实体的注意力分数之后，对之前的词表征进行处理，文中给出的处理方法有三种：
&lt;ul&gt;&lt;li&gt;sum: &lt;span class=&quot;math inline&quot;&gt;\(r_i = z_i \frac{\alpha_1 + \alpha_2}{2}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;concat: &lt;span class=&quot;math inline&quot;&gt;\(r_i = [\alpha_1z_i, \alpha_2z_i]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;substract: &lt;span class=&quot;math inline&quot;&gt;\(r_i = z_i \frac{\alpha_1 - \alpha_2}{2}\)&lt;/span&gt;&lt;br/&gt;最后得到 &lt;span class=&quot;math inline&quot;&gt;\(r_i\)&lt;/span&gt; 为词的注意力加权表征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Convolution Layer: 由于事先在数据上做了 n-gram 操作，所以卷积核窗口设置为 1，其余的常规的卷积层没有区别，激活函数为 tanh，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[R^* = tanh(W_fR + B_f)\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Attention-Based Pooling: 将常规的 Max Pooling 直接用 Attention 操作替代，具体操作如下：
&lt;ul&gt;&lt;li&gt;随机初始化一个 relation embedding 矩阵 W_L，在训练过程中更新，再额外初始化一个注意力权重矩阵，计算一个二维匹配模型：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[G = R^*UW_L\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对行进行归一化，即得到每个词表征对每个 relation label 的注意力大小，或说是相关性分数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[A_{i, j}^P = \frac{exp(G_{i, j})}{\sum_{i'=1}^nexp(G_{i',j})}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对词表征进行注意力加权，得到注意力加权的 relation label 表征，再对这个结果进行 Max Pooling：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[w^O = max_j(R^*A^P)\]&lt;/span&gt;&lt;br/&gt;最后的 &lt;span class=&quot;math inline&quot;&gt;\(w^O\)&lt;/span&gt; 即为整个模型的输出向量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;margin-based pairwise loss function: 作者定义了新的损失函数代替之前的分类器 + softmax + 交叉熵的做法
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;假设我们得到的 &lt;span class=&quot;math inline&quot;&gt;\(w^O\)&lt;/span&gt; 为我们得到的实体间的 inferred relation embedding，此外，我们还在 Attention-Based Pooling 中训练了 relation embedding，则计算两个向量间的距离：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\delta_{\theta}(S, y) = ||\frac{w^O}{|w^O|} - W_y^L||\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;我们希望 inferred relation embedding 与 正确标签的 embedding 距离尽量小，且与其他样本的 embedding 距离尽量大，作者借鉴了 pairwise ranking loss function (见 Model 3) 中的做法，损失函数函数定义如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L = [\delta_{\theta}(S, y) + (1-\delta_{\theta}(S, \hat{y}^-))] + \beta||\theta||^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}^-\)&lt;/span&gt; 为所有标签中与 &lt;span class=&quot;math inline&quot;&gt;\(w^O\)&lt;/span&gt; 距离最大的负标签(个人在这里存在疑惑，认为这个应该是与 &lt;span class=&quot;math inline&quot;&gt;\(w^O\)&lt;/span&gt;距离最小的负标签才更为合适，因为我们期望将最易分错的类别与 &lt;span class=&quot;math inline&quot;&gt;\(w^O\)&lt;/span&gt; 应该尽量远)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到这篇论文的两次 Attention 以及 损失函数的设计都是十分巧妙的，且论文中提到效果非常好，许多技巧还是可以借鉴的。&lt;/p&gt;
&lt;h2 id=&quot;model-7-bidirectional-recurrent-convolutional-neural-network-for-relation-classification&quot;&gt;Model 7: Bidirectional Recurrent Convolutional Neural Network for Relation Classification&lt;/h2&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.aclweb.org/anthology/P16-1072/&quot; class=&quot;uri&quot;&gt;https://www.aclweb.org/anthology/P16-1072/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;论文的主要思想是对两个实体间的词法句法的最短依赖路径 SDP (shortest dependency path)进行建模，这也是常见的一种关系抽取任务的建模方法，并与之前的建模方式存在一些区别，下面相对详细地阐述一下。&lt;/p&gt;
&lt;p&gt;由于受到卷积神经网络和循环神经网络特性的限制，之前的工作将句法依赖关系看作是词或者某些句法特征，如词性标签 (POS)。该论文的第一个贡献就是提出了一种 RCNN 的网络结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用两通道的 LSTM 对 SDP 进行全局信息编码&lt;/li&gt;
&lt;li&gt;利用 CNN 捕获每个依赖关系连接的两个单词的局部特征&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/10/Pv8mICs2BhRdcrJ.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，作者还指出，两个实体之间的依赖关系是有向的，如上图展示的因果关系示例图，若存在 &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; 个关系，则需要将其看作 &lt;span class=&quot;math inline&quot;&gt;\((2K + 1)\)&lt;/span&gt; 种分类问题，其中 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(Other\)&lt;/span&gt; 类。因此，作者提出其第二个贡献就在于使用双向的循环卷积神经网络 (BRCNN) 来同时学习双向的表征，可以将双向依赖问题建模为对称的依赖问题，从而将其简化为 &lt;span class=&quot;math inline&quot;&gt;\((K + 1)\)&lt;/span&gt; 的分类问题&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/10/ANLstIVbrMoGcWq.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型细节如上图所示，下面简单讲解一下整个模型结构：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;Input：模型的输入为两个实体间的 SDP。论文中提到，对于句子中的两个实体，存在某种关系R，则其词法句法的最短依赖路径 SDP 将阐明这个关系 R 的大多数信息，其主要有如下两个原因：
&lt;ul&gt;&lt;li&gt;如果实体 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 是同一谓词的论元(与谓词搭配的名词)，则它们之间的最短路径将通过该谓词；&lt;/li&gt;
&lt;li&gt;如果实体 &lt;span class=&quot;math inline&quot;&gt;\(e_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(e_2\)&lt;/span&gt; 属于不同的谓词-论元结构，但共享了同一个论元，则最短路径通过这个共享论元&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Lookup Table：包括词向量和依存关系向量，词向量是预先训练得到的，依存关系向量直接随机初始化即可，此外，还可以在词向量中加入 NER、POS 以及 WordNet 等特征&lt;/li&gt;
&lt;li&gt;BRCNN：BRCNN 为模型的主要架构，包括三个部分 Two-channel BiLSTM、CNN、Classifier
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Two-channel BiLSTM：所谓的两通道指的是对 词 和 依存关系 分别用两个 BiLSTM 结构进行建模。使用 BiLSTM 有两个好处，一方面避免了 LSTM 在时序建模上的偏向性问题(后期的输入比早期的输入更为重要)，另一方面也可以将有向的依赖关系建模为一个对称关系，这样就不需要额外考虑依赖关系的双向性问题。与我们常见的 BiLSTM 不同的是，两个方向的编码结果在后面需要分别处理，而不是像我们之前的那样，直接拼接再做之后的处理。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;对于存在关系的词与依赖关系 &lt;span class=&quot;math inline&quot;&gt;\(w_a -r_{ab}-&amp;gt; w_b\)&lt;/span&gt;，分别用 &lt;span class=&quot;math inline&quot;&gt;\(h_a, h_{ab}', h_b\)&lt;/span&gt; 来表示 LSTM 的对应隐藏表征，则可以利用 CNN 将词及依赖关系的局部特征 &lt;span class=&quot;math inline&quot;&gt;\(L_{ab}\)&lt;/span&gt; 进行抽取，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L_{ab} = tanh(W_{con} \cdot [h_a , h_{ab}', h_b] + b_{con})\]&lt;/span&gt;&lt;/p&gt;
其中， &lt;span class=&quot;math inline&quot;&gt;\(W_{con}\)&lt;/span&gt; 和 b_{con}) 为卷积神经网络参数。在这之后，使用一个 Max Pooling 层局部特征进行池化操作。由于模型是双向分别处理的，两个方向的模型分别得到一个池化结果 &lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{G}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\overleftarrow{G}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;Classifier：输出层由 3 个分类器组成
&lt;ul&gt;&lt;li&gt;coarse-grained softmax classifier：将双向的池化信息拼接作为分类器输入，为一个 &lt;span class=&quot;math inline&quot;&gt;\((K + 1)\)&lt;/span&gt; 类的分类器，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[y = softmax(W_c[\overrightarrow{G}, \overleftarrow{G}] + b_c)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;fine-grained softmax classifiers：两个分类器共享参数，分别对两个方向的池化信息单独进行分类，为一个 &lt;span class=&quot;math inline&quot;&gt;\((2K+1)\)&lt;/span&gt; 类的分类器，作者认为同时对两个方向的信息进行分类有助于加强模型判断关系方向性的能力&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\overrightarrow{y} = softmax(W_f\cdot \overrightarrow{G} + b_f)\\ \overleftarrow{y} = softmax(W_f\cdot \overleftarrow{G} + b_f)\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;目标函数：由于存在三个分类器，损失函数为三个分类器的交叉熵的累加和，同时加上了 l2 正则化&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[J = \sum_{i=1}^{2K+1}\overrightarrow{t}_ilog\ \overrightarrow{y}_i + \sum_{i=1}^{2K+1}\overleftarrow{t}_ilog\ \overleftarrow{y}_i + \sum_{i=1}^{K+1}{t}_ilog\ {y}_i + \lambda||\theta||^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而对于解码过程，两个实体之间只存在一个单向的关系，因此仅需要两个 fine-grained softmax classifiers 的输出结果即可&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[y_{test} = \alpha\cdot \overrightarrow{y} + (1-\alpha)\cdot z(\overleftarrow{y})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 为一个超参数，论文中将其设置为 0.65。另外由于两个预测结果的方向是相反的，因此需要用一个函数 &lt;span class=&quot;math inline&quot;&gt;\(z(·)\)&lt;/span&gt; 来将 &lt;span class=&quot;math inline&quot;&gt;\(\overleftarrow{y}\)&lt;/span&gt; 转化为与 &lt;span class=&quot;math inline&quot;&gt;\(\overrightarrow{y}\)&lt;/span&gt; 对应的格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将词法句法的 SDP 作为输入特征来实现关系抽取也是常见的一种建模方法，且效果也非常不错。这篇论文通过对文本以及依赖关系分别建模，利用 LSTM 和 CNN 进行不同层次的特征编码，并分两个方向进行信息融合，确实是一大亮点。如果词向量只用 Word Embeddings，分数可以达到 85.4，如果加上 NER、POS 以及 WordNet 等特征可以达到 86.3。&lt;/p&gt;
&lt;p&gt;将关系抽取看作单独任务的模型总结就做到这里了，或许之后看见更优秀的论文还会进行一些更新，这里将每个模型在 SemEval-2010 Task-8 上的分数都记载一下：&lt;br/&gt;|模型| 论文名称 | 输入特征 |F1|&lt;br/&gt;| :----- | :----- | :----- | :----- |&lt;br/&gt;| Model 1 | Relation Classification via Convolutional Deep Neural Network | Word Embeddings, Position Embeddings, WordNet | 82.7 |&lt;br/&gt;| Model 2 | Relation Extraction: Perspective from Convolutional Neural Networks | Word Embeddings, Position Embeddings | 82.8 |&lt;br/&gt;| Model 3 | Classifying Relations by Ranking with Convolutional Neural Networks | Word Embeddings, Position Embeddings | 84.1 |&lt;br/&gt;| Model 4 | Attention-Based Bidirectional Long Short-Term Memory Networks for Relation Classification | Word Embeddings, Position Embeddings, POS, NER, WordNet, Dependency Feature | 84.3 |&lt;br/&gt;| Model 5 | Bidirectional Long Short-Term Memory Networks for Relation Classification | Word Embeddings, Position Embeddings | 84.0 |&lt;br/&gt;| Model 6 | Relation Classification via Multi-Level Attention CNNs | Word Embeddings, Position Embeddings | 88.0 |&lt;br/&gt;| Model 7 | Bidirectional Recurrent Convolutional Neural Network for Relation Classification |Word Embeddings, WordNet, NER, WordNet | 86.3 |&lt;/p&gt;
&lt;p&gt;总的来说，人工特征、句法特征、注意力机制、特殊的损失函数都是关系抽取模型性能提升的关键点，其余的就需要在模型架构上进行合理的设计了，下一篇准备介绍实体与关系联合抽取模型，争取早点写出来...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45422620&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/45422620&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.shuang0420.com/2018/09/15/%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96-%E5%AE%9E%E4%BD%93%E5%8F%8A%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/&quot; class=&quot;uri&quot;&gt;http://www.shuang0420.com/2018/09/15/知识抽取-实体及关系抽取/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91762831&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/91762831&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://shomy.top/2018/02/28/relation-extraction/&quot; class=&quot;uri&quot;&gt;http://shomy.top/2018/02/28/relation-extraction/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 16:25:00 +0000</pubDate>
<dc:creator>西多士NLP</dc:creator>
<og:description>[TOC] 简介 信息抽取（information extraction），即从自然语言文本中，抽取出特定的事件或事实信息，帮助我们将海量内容自动分类、提取和重构。这些信息通常包括实体（entity）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sandwichnlp/p/12020066.html</dc:identifier>
</item>
<item>
<title>Java语法进阶13-文件、IO流 - 远离颠倒梦想</title>
<link>http://www.cnblogs.com/Open-ing/p/12003457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Open-ing/p/12003457.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;File&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;File是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;File类的对象用来表示文件和文件夹的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果这个路径名对应的文件或目录不存在，那么在堆中的File对象的成员变量就是默认值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;如果这个路径名对应的文件或目录存在，那么在堆中的File对象就根据这个路径找到对应的文件或目录，然后将一些信息获取到为File对象的成员变量赋值&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;常用方法&lt;/span&gt;&lt;/h3&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;方法签名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;方法功能&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;File(String pathName)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;根据文件、目录的路径名构建File对象&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;File(String parent, String child)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;构建File对象，路径名通过指定父目录与子目录方式来指定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;public File(File parent,String child)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;从父抽象路径名和子路径名字符串创建新的 File实例&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;String getName()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取文件名&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;long length()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取文件大小，无法直接获取目录大小,空目录返回0&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;String getPath()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取构造路径&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;String getAbsolutePath()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取绝对路径&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;String getCanonicalPath()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取规范路径&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;long lastModified()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取文件最后修改时间&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean isFile()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否是文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean isDirectory()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否是目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean exists()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断文件或目录是否实际存在&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean isHidden()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否隐藏&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean isAbsolute()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否是绝对路径&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean canRead()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否可读&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boolean canWrite()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;判断是否可写&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;createNewFile()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;当且仅当具有该名称的文件尚不存在时,创建文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;mkdir()或mkdirs()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;创建目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;delete()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;删除文件或空目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;renameTo(File dest)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;重命名文件或目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;String[] list()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取目录里面的文件或子目录,返回String数组&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;File[] listFiles()&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;获取目录里面的文件或子目录,返回File数组&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;File[] listFiles(FileFilter filter)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;根据过滤条件获取目录里面的文件或子目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;无论该路径下是否存在文件或者目录，都不影响File对象的创建。&lt;/p&gt;
&lt;p&gt;如果文件或目录不存在，那么exists()、isFile()和isDirectory()都是返回false&lt;/p&gt;
&lt;p&gt;调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;绝对路径&lt;/strong&gt;：从盘符开始的路径，这是一个完整的路径。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;相对路径&lt;/strong&gt;&lt;span&gt;：相对于&lt;span&gt;&lt;strong&gt;项目目录&lt;/strong&gt;&lt;span&gt;的路径，这是一个便捷的路径，开发中经常使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;规范路径&lt;/strong&gt;&lt;span&gt;：所谓规范路径名，即对路径中的“..”等进行解析后的路径名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;创建和删除临时文件&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;public void deleteOnExit()&lt;/code&gt;&lt;span&gt;：当退出JVM时，删除文件，一般用于删除临时文件，一旦请求，无法取消。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;public static File createTempFile(String prefix,String suffix) throws IOException在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。调用此方法等同于调用 createTempFile(prefix, suffix, null)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;public static File createTempFile(String prefix,String suffix,File directory)throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;prefix - 用于生成文件名的前缀字符串；必须至少三个字符。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;suffix - 用于生成文件名的后缀字符串；如果为 null，默认为 &quot;.tmp&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;directory - 将创建的文件所在的目录；如果使用默认临时文件目录，则该参数为 null&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;IO&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;颠倒梦想&quot; href=&quot;https://www.cnblogs.com/Open-ing/p/11951499.html&quot; target=&quot;_blank&quot;&gt;Stream&lt;/a&gt;即流向内存的是输入流(Reader,Input)，流出内存的输出流(Writer,Output)。&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;节点流&lt;/strong&gt;&lt;span&gt;：可以从或向一个特定的地方（节点）读写数据。如FileReader.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;处理流&lt;/strong&gt;&lt;span&gt;：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。并且可进行多次包装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;InputStream基类：字节输入流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;抽象类字节流可以传输任意文件类型数据&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;int read()：读一个字节，如果流中没有数据了，返回-1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(byte[] data)：一次读取多个字节，最多读取data.length个，把读取的数据放到data中，从data[0]开始存储，如果流中没有data.length个，那么有几个读取几个，返回实际读取的字节的个数。如果流中没有数据了，返回-1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(byte[] data, int offset, int count)：一次读取多个字节，最多读取count个，把读取的数据放到data中，从data[offset]开始存储，如果流中没有count个，那么有几个读取几个，返回实际读取的字节的个数。如果流中没有数据了，返回-1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;void close()：关闭流资源&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;OutputStream基类：字节输出流&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;public void close()&lt;/code&gt; &lt;span&gt;：关闭此输出流并释放与此流相关联的任何系统资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public void flush()&lt;/code&gt; &lt;span&gt;：刷新此输出流并强制任何缓冲的输出字节被写出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public void write(byte[] b)&lt;/code&gt;&lt;span&gt;：将 b.length字节从指定的字节数组写入此输出流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public void write(byte[] b, int off, int len)&lt;/code&gt; &lt;span&gt;：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;public abstract void write(int b)&lt;/code&gt; &lt;span&gt;：将指定的字节输出流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;FileInputStream类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;继承InoutStream方法同上，文件输入流，从文件中读取字节。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;构造方法&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;FileInputStream(File file)&lt;/code&gt;&lt;span&gt;： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;FileInputStream(String name)&lt;/code&gt;&lt;span&gt;： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出&lt;span&gt;&lt;code&gt;FileNotFoundException&lt;/code&gt; &lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;long &lt;strong&gt;skip&lt;/strong&gt;(long n) ：从输入流中跳过并丢弃 n 个字节的数据。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-expand&quot;&gt;读取字节&lt;span&gt;：&lt;span&gt;&lt;strong&gt;&lt;code&gt;read&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回&lt;span&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;FileOutputStream类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;继承OutputStream方法同上，文件输出流，用于将数据写出到文件。&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;构造方法&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public FileOutputStream(File file)&lt;/code&gt;&lt;span class=&quot;md-expand&quot;&gt;：创建文件输出流以写入由指定的 File对象表示的文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public FileOutputStream(String name)&lt;/code&gt;&lt;span&gt;： 创建文件输出流以指定的名称写入文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;&lt;span&gt;&lt;span&gt;public FileOutputStream(String name, boolean append)：指定 String文件名name的文件输出流&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;　　　public FileOutputStream(File file, boolean append)：指定 File 对象的文件输出流，append为true&lt;span class=&quot;md-expand&quot;&gt;表示追加数据，&lt;span&gt;&lt;code&gt;false&lt;/code&gt; &lt;span&gt;表示清空原有数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据，或指定追加。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;系统中的换行：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Windows系统里，每行结尾是 &lt;span&gt;&lt;code&gt;回车+换行&lt;/code&gt; &lt;span&gt;，即&lt;span&gt;&lt;code&gt;\r\n&lt;/code&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Unix系统里，每行结尾只有 &lt;span&gt;&lt;code&gt;换行&lt;/code&gt; &lt;span&gt;，即&lt;span&gt;&lt;code&gt;\n&lt;/code&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;Mac系统里，每行结尾是 &lt;span&gt;&lt;code&gt;回车&lt;/code&gt; &lt;span&gt;，即&lt;span&gt;&lt;code&gt;\r&lt;/code&gt;&lt;span&gt;。从 Mac OS X开始与Linux统一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;流的关闭原则：先开后关，后开先关。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Reader基类：&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;字符输入流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;抽象类以字符为单位读写数据，专门用于处理文本文件&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public int read()&lt;/code&gt;&lt;span&gt;： 读取一个字符，如果已经到达流末尾，没有数据可读了，返回-1.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;public int read(char[] cbuf)&lt;/code&gt;&lt;span&gt;： 读取多个字符到data数组中，从data[0]开始存储，最多读取data.length个字符。返回的是实际读取的字符数。如果已经到达流末尾，没有数据可读了，返回-1.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;abstract&lt;/strong&gt; int read(char[] data, int offset, int len)：读取多个字符到data数组中，从data[offset]开始存储，最多读取len个字符。返回的是实际读取的字符数。如果已经到达流末尾，没有数据可读了，返回-1.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void close()&lt;/code&gt; ：关闭此流并释放与此流相关联的任何系统资源&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt; long skip(long n) ： 跳过n字符。 &lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;FileReader类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;继承Reader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;构造方法&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;FileReader(File file)&lt;/code&gt;&lt;span&gt;： 创建一个新的 FileReader ，给定要读取的File对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;FileReader(String fileName)&lt;/code&gt;&lt;span&gt;： 创建一个新的 FileReader ，给定要读取的文件的名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当你创建一个流对象时，必须传入一个文件路径。其&lt;strong&gt;方法同上&lt;/strong&gt;继承父类方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然读取了一个字符，但是会自动提升为int类型。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Writer基类：&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;字符输出流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;抽象类表示用于写出字符流，将指定的字符信息写出到目的地&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;9&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;void write(int c)&lt;/code&gt; &lt;span&gt;写入单个字符。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;void write(char[] cbuf)&lt;/code&gt;&lt;span&gt;写入字符数组。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;abstract&lt;/strong&gt; void write(char[] cbuf, int off, int len)&lt;/code&gt;&lt;span&gt;写入字符数组的某一部分,off数组的开始索引,len写的字符个数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;void write(String str)&lt;/code&gt;&lt;span&gt;写入字符串。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;void write(String str, int off, int len)&lt;/code&gt; &lt;span&gt;写入字符串的某一部分,off字符串的开始索引,len写的字符个数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;void flush()&lt;/code&gt;&lt;span&gt;刷新该流的缓冲。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;void close()&lt;/code&gt; &lt;span&gt;关闭此流，但要先刷新它。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;FileWriter类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;继承Writer类是写出字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象以及指示是否附加写入数据。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;当你创建一个流对象时，必须传入一个文件路径，其&lt;strong&gt;方法同上&lt;/strong&gt;继承父类方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;未调用close方法，数据只是保存到了缓冲区，并未写出到文件中，即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;操作IO流的步骤&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;（1）创建合适的IO流的对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;（2）读、写&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;（3）关闭IO流&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;要么只关闭最外层的IO流，要是都关的话，注意顺序，先关外面的再关里面的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;缓冲流&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;字节缓冲流&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;code&gt;BufferedInputStream&lt;/code&gt;&lt;span&gt;，&lt;span&gt;&lt;code&gt;BufferedOutputStream&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;public BufferedInputStream(InputStream in)&lt;/code&gt; &lt;span&gt;：创建一个 新的缓冲输入流。亦可指定缓冲区大小(InputStream in, int size) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;public BufferedOutputStream(OutputStream out)&lt;/code&gt;&lt;span&gt;： 创建一个新的缓冲输出流。亦可指定缓冲区大小(OutputStream out, int size) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字符缓冲流&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;span&gt;，&lt;span&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;public BufferedReader(Reader in)&lt;/code&gt; &lt;span&gt;：创建一个 新的缓冲输入流。亦可指定缓冲区大小(Reader in, int sz) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;public BufferedWriter(Writer out)&lt;/code&gt;&lt;span&gt;： 创建一个新的缓冲输出流。亦可指定缓冲区大小(Writer out, int sz) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;字符缓冲流的特有方法。&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;BufferedReader：&lt;span&gt;&lt;code&gt;public String readLine()&lt;/code&gt;&lt;span&gt;: 读一行文字。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分从off开始读len个。 实现了基类的抽象方法&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;BufferedWriter：&lt;span&gt;&lt;code&gt;public void newLine()&lt;/code&gt;&lt;span&gt;: 写一行行分隔符,由系统属性定义符号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;void write(char[] cbuf, int off, int len) ：写入字符数组的某一部分从off开始写len个。实现了基类的抽象方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;转换流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;解码:字节(看不懂的)--&amp;gt;字符(能看懂的)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;编码:字符(能看懂的)--&amp;gt;字节(看不懂的) &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;InputStreamReader类&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;InputStreamReader(InputStream in)&lt;/code&gt;&lt;span&gt;: 创建一个使用系统默认字符集的字符流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;InputStreamReader(InputStream in, String charsetName)&lt;/code&gt;&lt;span&gt;: 创建一个指定字符集的字符流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是Reader的子类，用来解码包装字节流，把字节输入流包装为字符输入流。&lt;/p&gt;
&lt;p&gt;应用场景：读取源为字符类型的字节流可指定字符集解码成字符流，以便阅读&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;OutputStreamWriter类&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;OutputStreamWriter(OutputStream in)&lt;/code&gt;&lt;span&gt;: 创建一个使用系统默认字符集的字符流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;code&gt;OutputStreamWriter(OutputStream in, String charsetName)&lt;/code&gt;&lt;span&gt;: 创建一个指定字符集的字符流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是Writer的子类，用来编码包装字节流，把字节输出流包装为字符输出流。&lt;/p&gt;
&lt;p&gt;应用场景：可将要写入的字符源为字节流的数据转为字符类型写入并可按指定字符集再编码成字节存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;转换流是字节与字符间的桥梁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1863179/201912/1863179-20191207212552642-53276885.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;数据流&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 继承字节流可直接处理Java的基本数据类型，要求读写顺序一一对应&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DataOutputStream：数据输出流&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;writeUTF(String)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;writeInt(int)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;writeDouble(double)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;writeChar(char)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;writeBoolean(boolean)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DataInputStream：数据输入流&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;String readUTF()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;int readInt()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;double readDouble()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;char readChar()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;boolean readBoolean()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;对象&lt;span&gt;&lt;strong&gt;&lt;span&gt;序列化，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;用一个字节序列可以表示一个对象，该字节序列包含该&lt;span&gt;&lt;code&gt;对象的类型&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;对象中存储的属性&lt;/code&gt;&lt;span&gt;等信息，可将字节序列写出到文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;反之，该字节序列还可以从文件中读取回来，重构对象，对它进行&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;反序列化&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1863179/201912/1863179-20191208135456170-1228490088.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;ObjectOutputStream类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public final void writeObject (Object obj)&lt;/code&gt; : 将指定的对象写出到OutputStream流。&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;该类必须实现&lt;span&gt;&lt;code&gt;java.io.&lt;strong&gt;Serializable&lt;/strong&gt;&lt;/code&gt; &lt;span&gt;标记接口，&lt;span&gt;&lt;span&gt;不实现此接口的类将不会使任何状态序列化或反序列化，会抛&lt;span&gt;&lt;code&gt;NotSerializableException&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用&lt;span&gt;&lt;strong&gt;&lt;code&gt;transient&lt;/code&gt;&lt;/strong&gt; &lt;span&gt;关键字修饰。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;静态&lt;/strong&gt;变量的值不会序列化&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;ObjectInputStream类&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;如果能找到一个对象的&lt;strong&gt;class文件&lt;/strong&gt;，我们可以进行反序列化操作，调用&lt;span&gt;&lt;code&gt;ObjectInputStream&lt;/code&gt;&lt;span&gt;读取对象的方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个&lt;code&gt;InvalidClassException&lt;/code&gt;异常&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;发生这个异常的原因如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;Serializable&lt;/code&gt; &lt;span&gt;接口给需要序列化的类，提供了一个序列&lt;strong&gt;版本号&lt;/strong&gt;。&lt;span&gt;&lt;code&gt;serialVersionUID&lt;/code&gt; &lt;span&gt;该版本号的目的在于验证序列化的对象和对应类是否版本匹配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;java.io.Externalizable接口&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;实现这个接口，可以自定义需要被系列化的属性使得对象能够被序列化，但是要求程序员重写两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;void writeExternal(ObjectOutput out) ：编写哪些属性需要序列化&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;void readExternal(ObjectInput in) ：编写哪些属性需要反序列化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：读取的顺序要与写的顺序一致，虽然可以自己决定任意属性的输出和读取，但是还是建议不要输出静态的和transient属性。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;PrintStream类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;字节流该类&lt;span class=&quot;md-expand&quot;&gt;调用&lt;span&gt;&lt;code&gt;print&lt;/code&gt;&lt;span&gt;方法和&lt;span&gt;&lt;code&gt;println&lt;/code&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;能够方便地打印各种数据类型的值，是一种便捷的输出方式。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;System.in：InputStream类型对象&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;System.out：PrintStream类型对象&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;System.err：PrintStream类型对象&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Scanner类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有多个构造方法可由多种方式生成从指定流的扫描对象，并实现了迭代器接口&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;新try..catch&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;语法格式：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;try(&lt;span class=&quot;cm-variable&quot;&gt;需要关闭的资源对象的声明){&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable&quot;&gt;业务逻辑代码&lt;br/&gt;&lt;span&gt;}&lt;span class=&quot;cm-keyword&quot;&gt;catch(&lt;span class=&quot;cm-variable&quot;&gt;异常类型 &lt;span class=&quot;cm-variable&quot;&gt;e){&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable&quot;&gt;处理异常代码&lt;br/&gt;&lt;span&gt;}&lt;span class=&quot;cm-keyword&quot;&gt;catch(&lt;span class=&quot;cm-variable&quot;&gt;异常类型 &lt;span class=&quot;cm-variable&quot;&gt;e){&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable&quot;&gt;处理异常代码&lt;br/&gt;&lt;span&gt;}&lt;br/&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 10 Dec 2019 14:34:00 +0000</pubDate>
<dc:creator>远离颠倒梦想</dc:creator>
<og:description>File File是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。 File</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Open-ing/p/12003457.html</dc:identifier>
</item>
<item>
<title>数学基础系列(一)----函数、极限、连续性、导数 - |旧市拾荒|</title>
<link>http://www.cnblogs.com/xiaoyh/p/11968162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyh/p/11968162.html</guid>
<description>&lt;p&gt;为了加深在人工智能、深度学习领域的学习，接下来会推出数学基础系列博客，加深自己在这领域的基础知识。&lt;/p&gt;
&lt;h2&gt;一、函数&lt;/h2&gt;
&lt;h3&gt;1、函数的定义&lt;/h3&gt;
&lt;p&gt;函数表示量与量之间的关系如：$A=\pi r^{2}$。更普遍的是用$y=f(x)$表示，其中x表示自变量，y表示因变量。函数在x&lt;sub&gt;0&lt;/sub&gt;处取得的函数值$y_{0}=y\mid _{x=x_{0}}=f(x_{0})$。值得一提的是，符号只是一种表示，也可以用其他符号来表示，比如：$y=g(x)$、$y=\varphi (x)$、$y=\psi (x)$等。&lt;/p&gt;
&lt;h3&gt;2、常用函数形式&lt;/h3&gt;
&lt;p&gt;分段函数：$f(x)=\left\{\begin{matrix}\sqrt{x}, &amp;amp;x\geqslant 0 \\ -x, &amp;amp; x&amp;lt; 0\end{matrix}\right.$&lt;/p&gt;
&lt;p&gt;反函数：$h=\frac{1}{2}gt^{2}\rightarrow h=h(t) \rightarrow t=\sqrt{\frac{2h}{g}}\rightarrow t=t(h)$&lt;/p&gt;
&lt;p&gt;显函数：$y=x^{2}+1$&lt;/p&gt;
&lt;p&gt;隐函数：$F(x,y)=0$，$3x+y-4=0$&lt;/p&gt;
&lt;h3&gt;3、函数特点&lt;/h3&gt;
&lt;p&gt;奇函数：相对于原点对称的函数$f(-x)=-f(x)$，如$f(x)=x^{3}$，代入计算可得$f(-x)=(-x)^{3}=-x^{3}=-f(x)$。&lt;/p&gt;
&lt;p&gt;偶函数：相当于Y轴对称的函数$f(-x)=f(x)$，如$f(x)=x^{2}$，代入计算可得$f(-x)=(-x)^{2}=x^{2}=f(x)$。&lt;/p&gt;
&lt;p&gt;周期函数：经过一个周期T的变化函数值仍相等$f(x+T)=f(x)$，如常见的三角函数等。&lt;/p&gt;
&lt;p&gt;单调性：分为单调递增函数和单调递减函数。&lt;/p&gt;
&lt;h2&gt;二、极限&lt;/h2&gt;
&lt;h3&gt;1、数列&lt;/h3&gt;
&lt;p&gt;通俗的讲就是一列有序的数：$u_{1},u_{2},...,u_{n},...$，其中$u_{n}$叫做&lt;span&gt;通项&lt;/span&gt;。对于数列$\left \{ u_{n} \right \}$，如果当n无限增大时，其通项无限接近于一个常数A，则称该数列以A为极限或称数列收敛于A，否则称数列为发散。$\lim\limits_{n \rightarrow \infty }u_{n}  = A$，或$u_{n}\rightarrow A(n\rightarrow \infty )$，$\lim\limits_{n \rightarrow \infty }\frac{1}{3^{n}}  = 0$，$\lim\limits_{n \rightarrow \infty }\frac{n}{n+1}  = 1$，$\lim\limits_{n \rightarrow \infty }2^{n}$不存在。&lt;/p&gt;
&lt;h3&gt;2、极限&lt;/h3&gt;
&lt;p&gt;符号表示：&lt;/p&gt;
&lt;p&gt;$x\rightarrow \infty $表示“当|x|无限增大时” ，&lt;/p&gt;
&lt;p&gt;$x\rightarrow +\infty $表示“当x无限增大时” ，&lt;/p&gt;
&lt;p&gt;$x\rightarrow -\infty $表示“当x无限减少时” ，&lt;/p&gt;
&lt;p&gt;$x\rightarrow x_{0}$表示“当x从x&lt;sub&gt;0&lt;/sub&gt;的左右两侧无限接近于x&lt;sub&gt;0&lt;/sub&gt;时” ，&lt;/p&gt;
&lt;p&gt;$x\rightarrow x_{0}^{+}$表示“当x从x&lt;sub&gt;0&lt;/sub&gt;的右侧无限接近于x&lt;sub&gt;0&lt;/sub&gt;时” ，&lt;/p&gt;
&lt;p&gt;$x\rightarrow x_{0}^{-}$表示“当x从x&lt;sub&gt;0&lt;/sub&gt;的左侧无限接近于x&lt;sub&gt;0&lt;/sub&gt;时” ，&lt;/p&gt;
&lt;p&gt;下面用几个示例图形象地表示极限&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191204225129790-1963490955.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、定义&lt;/h3&gt;
&lt;p&gt;函数在x&lt;sub&gt;0&lt;/sub&gt;的邻域内有定义，有$\lim\limits_{x \rightarrow x_{0} }f(x)=A$，或$f(x)\rightarrow A(x-x_{0})$。例如$\lim\limits_{x \rightarrow 1 }\frac{x^{2}-1}{x-1}  = \lim\limits_{x \rightarrow 1 }\frac{(x-1)(x+1)}{x-1}=2$&lt;/p&gt;
&lt;h3&gt;4、左右极限&lt;/h3&gt;
&lt;p&gt;函数在左半邻域/右半邻域内有定义$(x_{0},x_{0}+\delta ),(x_{0}-\delta,x_{0} )$，有&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191205230058102-1190410669.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;$\lim\limits_{x \rightarrow x_{0} }f(x)  = A$的&lt;span&gt;充要条件&lt;/span&gt;是$\lim\limits_{x \rightarrow x_{0}^{-} }f(x)  = \lim\limits_{x \rightarrow x_{0}^{+} }f(x)=A$&lt;/p&gt;
&lt;p&gt;有以下例题，求$f(x)$的极限&lt;/p&gt;
&lt;p&gt;$f(x)=\left\{\begin{matrix}&lt;br/&gt;x-1 &amp;amp; x&amp;lt;0\\&lt;br/&gt;0 &amp;amp;x=0 \\&lt;br/&gt;x+1 &amp;amp; x&amp;gt;0&lt;br/&gt;\end{matrix}\right.$&lt;/p&gt;
&lt;p&gt;求解可得，当x-&amp;gt;0时，f(x)的极限$\lim\limits_{x \rightarrow x_{0}^{+} }f(x)  = \lim\limits_{x \rightarrow x_{0}^{+} }(x+1)=1$，$\lim\limits_{x \rightarrow x_{0}^{-} }f(x)  = \lim\limits_{x \rightarrow x_{0}^{-} }(x-1)=-1$。左右极限存在但不相等，所以f(x)在x-&amp;gt;0时极限不存在。&lt;/p&gt;
&lt;h3&gt;5、极限性质&lt;/h3&gt;
&lt;p&gt;无穷小：以零为极限，如函数$\lim\limits_{x \rightarrow \infty  }\frac{1}{x}  = 0$，$\frac{1}{x} $是$x \rightarrow \infty $时的无穷小。$\lim\limits_{x \rightarrow 2  }(3x-6)  = 0$，$3x-6 $是$x \rightarrow 2 $时的无穷小。&lt;/p&gt;
&lt;p&gt;基本性质：&lt;/p&gt;
&lt;p&gt;1.有限个无穷小的代数和仍是无穷小。&lt;/p&gt;
&lt;p&gt;2.有限个无穷小的积仍是无穷小。&lt;/p&gt;
&lt;p&gt;3.有界变量与无穷小的积仍是无穷小。&lt;/p&gt;
&lt;p&gt;4.无限个无穷小之和&lt;span&gt;不一定&lt;/span&gt;是无穷小。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191205232138942-1025787.png&quot; alt=&quot;&quot; width=&quot;149&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.无穷小的商&lt;span&gt;不一定&lt;/span&gt;是无穷小。$\lim\limits_{x \rightarrow 0 }\frac{x}{2x} =\frac{1}{2},\lim\limits_{x \rightarrow 0 }\frac{x^{2}}{2x} =0,\lim\limits_{x \rightarrow 0 }\frac{2x}{x^{2}} =\infty $&lt;/p&gt;
&lt;p&gt;6.极限有无限小的关系：$\lim\limits_{x \rightarrow x_{0} }f(x) =A$的充要条件是$f(x)=A+\alpha (x)$，其中$\alpha (x)$是$x \rightarrow x_{0} $时的无穷小。&lt;/p&gt;
&lt;p&gt;7.无穷大：并不是一个很大的数，是相对于变换过程来说。$\lim\limits_{x \rightarrow x_{0} }f(x) =\infty $或$f(x)\rightarrow \infty (x\rightarrow x_{0})$。&lt;/p&gt;
&lt;p&gt;8.无穷小和无穷大的关系：在自变量的变换的同一过程中，如果f(x)为无穷大，那么$\frac{1}{f(x)}$为无穷小。&lt;/p&gt;
&lt;p&gt;9.无穷小的比较：$\alpha =\alpha (x),\beta =\beta (x)$都是无穷小，$\lim\limits_{x \rightarrow x_{0} }\alpha (x) =0,\lim\limits_{x \rightarrow x_{0} }\beta (x) =0$。有如下比较。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209210244128-64873908.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、连续性&lt;/h2&gt;
&lt;h3&gt;1、函数的连续性&lt;/h3&gt;
&lt;p&gt;设函数y=f(x)在点x&lt;sub&gt;0&lt;/sub&gt;的某邻域内有定义，如果当自变量的改变量$\Delta x$趋近于0时，相应函数的改变量$\Delta y$也趋近于0，则称y=f(x)在点x&lt;sub&gt;0&lt;/sub&gt;处连续。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209210708457-1710122703.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数的连续性，函数f(x)在点x&lt;sub&gt;0&lt;/sub&gt;处连续，需要满足的条件：1、函数在该点有定义。2、函数在该点极限$\lim\limits_{x \rightarrow x_{0} }f(x)$存在。3、极限值等于函数值f(x&lt;sub&gt;0&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;例题，函数$f(x)=\left\{\begin{matrix}x+1 &amp;amp; x\leqslant 0\\ \frac{\sin x}{x} &amp;amp; x&amp;gt; 0\end{matrix}\right.$在x=0处的连续性？&lt;/p&gt;
&lt;p&gt;解：判断左右界限是否存在且先等。如下图所示&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209211647895-1557282245.png&quot; alt=&quot;&quot; width=&quot;342&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、函数的间断点&lt;/h3&gt;
&lt;p&gt;函数f(x)在点x=x&lt;sub&gt;0&lt;/sub&gt;处不连续，则称其为函数的间断点。一共三种情况为间断点：1、函数f(x)在点x&lt;sub&gt;0&lt;/sub&gt;处没有定义。2、函数在该点极限$\lim\limits_{x \rightarrow x_{0} }f(x)$不存在。3、满足前两点，但是$\lim\limits_{x \rightarrow x_{0} }f(x)\neq f(x)$。&lt;/p&gt;
&lt;p&gt;当x-&amp;gt;x&lt;sub&gt;0&lt;/sub&gt;时，f(x)的左右极限存在，则称x&lt;sub&gt;0&lt;/sub&gt;为f(x)的&lt;span&gt;第一类间断点&lt;/span&gt;，第一类间断点分为跳跃间断点和可去间断点，否则为&lt;span&gt;第二类间断点&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;跳跃间断点：$\lim\limits_{x \rightarrow 0^{-} }f(x)$与$\lim\limits_{x \rightarrow 0^{-} }f(x)$均存在，但不相等。&lt;/p&gt;
&lt;p&gt;可去间断点：$\lim\limits_{x \rightarrow x_{0} }f(x)$存在但不等于$f(x_{0})$。&lt;/p&gt;
&lt;h3&gt;3、例题&lt;/h3&gt;
&lt;p&gt;函数$f(x)=\frac{x^{2}-1}{x^{2}-3x+2}$的连续性？ &lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209212927559-1027988452.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、导数&lt;/h2&gt;
&lt;p&gt;平均速度很好表示，如v=s/t，但是如何表示瞬时速度呢？&lt;/p&gt;
&lt;p&gt;瞬时经过路程：$\Delta s=s(t_{0}+\Delta t)-s(t_{0})$&lt;/p&gt;
&lt;p&gt;这一小段的平均路程：$\bar{v} = \frac{\Delta s}{\Delta t}=\frac{s(t_{0}+\Delta t)-s(t_{0})}{\Delta t}$&lt;/p&gt;
&lt;p&gt;当$\Delta t\rightarrow 0$时也就是瞬时速度了，$v(t_{0})=\lim\limits_{\Delta t \rightarrow 0 }\bar{v}=\lim\limits_{\Delta t \rightarrow 0 }\frac{\Delta s}{\Delta t}=\lim\limits_{\Delta t \rightarrow 0 }\frac{s(t_{0}+\Delta t)-s(t_{0})}{\Delta t}$。&lt;/p&gt;
&lt;p&gt;导数：如果平均变化率的极限存在， $\lim\limits_{\Delta x \rightarrow 0 }\frac{\Delta y}{\Delta x}=\lim\limits_{\Delta x \rightarrow 0 }\frac{f(x_{0}+\Delta x)-f(x_{0})}{\Delta x}$，则称此极限为函数y=f(x)在点x&lt;sub&gt;0&lt;/sub&gt;处的导数f'(x&lt;sub&gt;0&lt;/sub&gt;)。$y'\mid _{x=x_{0}},\frac{dy}{dx}\mid _{x=x_{0}}$或$\frac{df(x)}{dx}\mid _{x=x_{0}}$。&lt;/p&gt;
&lt;p&gt;下面列出常见函数的导数。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209215732533-271001505.png&quot; alt=&quot;&quot; width=&quot;307&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面列出导数的运算法则（最后一条不经常用）：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/201912/1126989-20191209215235523-119536897.png&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 10 Dec 2019 14:28:00 +0000</pubDate>
<dc:creator>|旧市拾荒|</dc:creator>
<og:description>为了加深在人工智能、深度学习领域的学习，接下来会推出数学基础系列博客，加深自己在这领域的基础知识。 一、函数 1、函数的定义 函数表示量与量之间的关系如：$A=\pi r^{2}$。更普遍的是用$y=</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyh/p/11968162.html</dc:identifier>
</item>
<item>
<title>Leader 让我做 CMS 帮助中心的技术选型，我撸了 VuePress 和 GitBook，然后选择... - 天明夜尽</title>
<link>http://www.cnblogs.com/biaochenxuying/p/12019342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/biaochenxuying/p/12019342.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-e40d0f9196c9d49d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;因为自己平时经常写博客，也有博客网站，所以 Leader 叫我做一个 &lt;code&gt;CMS&lt;/code&gt; 的帮助中心的技术选型，&lt;code&gt;CMS&lt;/code&gt; 的帮助中心的功能：是通过文章来教用户如何使用我们的项目。&lt;/p&gt;
&lt;p&gt;所以笔者要做一个静态网站的技术选型，笔者把网上流行的 &lt;code&gt;VuePress&lt;/code&gt; 和 &lt;code&gt;GitBook&lt;/code&gt; 两种方式都尝试了一下，并做了对比，这里写篇文章总结一下，顺便把自己的博客网站重作一便，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-01244eb427774fa9.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;vuepress&quot;&gt;1. VuePress&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;1.1 简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;VuePress&lt;/strong&gt; 是 &lt;code&gt;Vue&lt;/code&gt; 驱动的静态网站生成器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简洁至上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;Markdown&lt;/code&gt; 为中心的项目结构，以最少的配置帮助你专注于写作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vue 驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;享受 &lt;code&gt;Vue + webpack&lt;/code&gt; 的开发体验，可以在 &lt;code&gt;Markdown&lt;/code&gt; 中使用 &lt;code&gt;Vue&lt;/code&gt; 组件，又可以使用 &lt;code&gt;Vue&lt;/code&gt; 来开发自定义主题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;VuePress&lt;/code&gt; 会为每个页面预渲染生成静态的 &lt;code&gt;HTML&lt;/code&gt;，同时，每个页面被加载的时候，将作为 &lt;code&gt;SPA&lt;/code&gt; 运行。&lt;/p&gt;
&lt;h3 id=&quot;效果&quot;&gt;1.2 效果&lt;/h3&gt;
&lt;p&gt;首页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-7c616cb995aa5ec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;评论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-b93b34bd853edbdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果详情请看：&lt;a href=&quot;https://biaochenxuying.github.io/blog/&quot; class=&quot;uri&quot;&gt;https://biaochenxuying.github.io/blog/&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;1.3 简单使用&lt;/h3&gt;
&lt;p&gt;像数 1, 2, 3 一样容易&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装
yarn global add vuepress # 或者：npm install -g vuepress

# 创建项目目录
mkdir vuepress-starter &amp;amp;&amp;amp; cd vuepress-starter

# 新建一个 markdown 文件
echo '# Hello VuePress!' &amp;gt; README.md

# 开始写作
vuepress dev .

# 构建静态文件
vuepress build .&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;1.4 目录结构&lt;/h3&gt;
&lt;p&gt;VuePress 遵循 “约定优于配置” 的原则，推荐的目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;├── docs
│   ├── .vuepress (可选的)
│   │   ├── components (可选的)
│   │   ├── theme (可选的)
│   │   │   └── Layout.vue
│   │   ├── public (可选的)
│   │   ├── styles (可选的)
│   │   │   ├── index.styl
│   │   │   └── palette.styl
│   │   ├── templates (可选的, 谨慎配置)
│   │   │   ├── dev.html
│   │   │   └── ssr.html
│   │   ├── config.js (可选的)
│   │   └── enhanceApp.js (可选的)
│   │ 
│   ├── README.md
│   ├── guide
│   │   └── README.md
│   └── config.md
│ 
└── package.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：请留意目录名的大写。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;docs/.vuepress&lt;/code&gt;: 用于存放全局的配置、组件、静态资源等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/components&lt;/code&gt;: 该目录中的 &lt;code&gt;Vue&lt;/code&gt; 组件将会被自动注册为全局组件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/theme&lt;/code&gt;: 用于存放本地主题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/styles&lt;/code&gt;: 用于存放样式相关的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/styles/index.styl&lt;/code&gt;: 将会被自动应用的全局样式文件，会生成在最终的 &lt;code&gt;CSS&lt;/code&gt; 文件结尾，具有比默认样式更高的优先级。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/styles/palette.styl&lt;/code&gt;: 用于重写默认颜色常量，或者设置新的 &lt;code&gt;stylus&lt;/code&gt; 颜色常量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/public&lt;/code&gt;: 静态资源目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/templates&lt;/code&gt;: 存储 &lt;code&gt;HTML&lt;/code&gt; 模板文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/templates/dev.html&lt;/code&gt;: 用于开发环境的 &lt;code&gt;HTML&lt;/code&gt; 模板文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/templates/ssr.html&lt;/code&gt;: 构建时基于 &lt;code&gt;Vue SSR&lt;/code&gt; 的 &lt;code&gt;HTML&lt;/code&gt; 模板文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/config.js&lt;/code&gt;: 配置文件的入口文件，也可以是 &lt;code&gt;YML&lt;/code&gt; 或 &lt;code&gt;toml&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs/.vuepress/enhanceApp.js&lt;/code&gt;: 客户端应用的增强。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当你想要去自定义 &lt;code&gt;templates/ssr.html&lt;/code&gt; 或 &lt;code&gt;templates/dev.html&lt;/code&gt; 时，最好基于 &lt;a href=&quot;https://github.com/vuejs/vuepress/blob/master/packages/%40vuepress/core/lib/client/index.dev.html&quot;&gt;默认的模板文件&lt;/a&gt; 来修改，否则可能会导致构建出错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;还有就是笔者的  &lt;code&gt;templates/ssr.html&lt;/code&gt; 和 &lt;code&gt;templates/dev.html&lt;/code&gt; 是有添加如下这一行代码的：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;meta id=&quot;referrer&quot; name=&quot;referrer&quot; content=&quot;never&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为笔者的图片都是存在简书上的，所以为了可以访问第三方图床的图片，才添加了这句代码，如果你的图片是存在本地的，去掉这句代码即可，至于具体原因请看笔者写的文章：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/31&quot;&gt;前端解决第三方图片防盗链的办法 - html referrer 访问图片资源403问题&lt;/a&gt; 。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;笔者的目录也是按官方推荐的来的，如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-f1e0ab5e9a3b5eb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;评论&quot;&gt;1.5 评论&lt;/h3&gt;
&lt;p&gt;评论功能用了 GitTalk。&lt;/p&gt;
&lt;h4 id=&quot;申请一个-oauth-app&quot;&gt;1.5.1 申请一个 OAuth App&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;具体实践如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先登录你的 GitHub 账号，然后点击进入Settings。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-780fe06c4053c80d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点击 OAuth Apps , Register a new application 或者 New OAuth App 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-f1a48fc621c54c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-31f643b581b15def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用信息说明：&lt;code&gt;Client ID&lt;/code&gt; &amp;amp;&amp;amp; &lt;code&gt;Client Secret&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-5947dfc53a989634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功有 &lt;code&gt;Client ID&lt;/code&gt; 和 &lt;code&gt;Client Secret&lt;/code&gt; ，保存下来，后面我们会用到。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建评论组件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;Vuepress&lt;/code&gt; 默认 &lt;code&gt;.vuepress / components&lt;/code&gt; 文件夹下的组件会全局注册，因此我们创建一个 &lt;strong&gt;comment&lt;/strong&gt; 组件。&lt;/p&gt;
&lt;p&gt;gittalk.css 请点击 &lt;a href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;gitalk-container&quot;&amp;gt;
    &amp;lt;div id=&quot;gitalk-container&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: 'comment',
  data() {
    return {};
  },
  mounted() {
    let body = document.querySelector('.gitalk-container');
    let script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js';
    body.appendChild(script);
    script.onload = () =&amp;gt; {
      const commentConfig = {
        clientID: '你的clientID',
        clientSecret: '你的clientSecret',
        repo: '你的仓库名称',
        owner: '你的用户名',
        // 这里接受一个数组，可以添加多个管理员，可以是你自己
        admin: ['管理用户名'],
        // id 用于当前页面的唯一标识，一般来讲 pathname 足够了，
        // 但是如果你的 pathname 超过 50 个字符，GitHub 将不会成功创建 issue，此情况可以考虑给每个页面生成 hash 值的方法.
        id: location.pathname,
        distractionFreeMode: false,
      };
      const gitalk = new Gitalk(commentConfig);
      gitalk.render('gitalk-container');
    };
  },
};
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
@import '../css/gittalk.css';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用评论组件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;理论上，我们在每个 &lt;code&gt;markdown&lt;/code&gt; 文件里直接加入这个组件即可，但是每次都添加有点麻烦，还是让 &lt;code&gt;node&lt;/code&gt; 来帮我们吧&lt;/p&gt;
&lt;p&gt;根目录创建 &lt;code&gt;build&lt;/code&gt; 文件夹, 创建三个文件 &lt;code&gt;addComponents.js&lt;/code&gt;, &lt;code&gt;delComponents.js&lt;/code&gt;, &lt;code&gt;findMarkdown.js&lt;/code&gt;, 分别代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// addComponents.js
const fs = require(&quot;fs&quot;);
const findMarkdown = require(&quot;./findMarkdown&quot;);
const rootDir = &quot;./docs&quot;;

findMarkdown(rootDir, writeComponents);

function writeComponents(dir) {
    if (!/README/.test(dir)) {
        fs.appendFile(dir, `\n \n &amp;lt;comment/&amp;gt; \n `, err =&amp;gt; {
            if (err) throw err;
            console.log(`add components to ${dir}`);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// delComponents.js
const fs = require(&quot;fs&quot;);
const findMarkdown = require(&quot;./findMarkdown&quot;);
const rootDir = &quot;./docs&quot;;

findMarkdown(rootDir, delComponents);

function delComponents(dir) {
    fs.readFile(dir, &quot;utf-8&quot;, (err, content) =&amp;gt; {
        if (err) throw err;

        fs.writeFile(
            dir,
            content.replace(/\n \n &amp;lt;comment\/&amp;gt; \n /g, &quot;&quot;),
            err =&amp;gt; {
                if (err) throw err;
                console.log(`del components from ${dir}`);
            }
        );
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// findMarkdown.js
const fs = require(&quot;fs&quot;);

function findMarkdown(dir, callback) {
    fs.readdir(dir, function(err, files) {
        if (err) throw err;
        files.forEach(fileName =&amp;gt; {
            let innerDir = `${dir}/${fileName}`;
            if (fileName.indexOf(&quot;.&quot;) !== 0) {
                fs.stat(innerDir, function(err, stat) {
                    if (stat.isDirectory()) {
                        findMarkdown(innerDir, callback);
                    } else {
                        // 跳过readme 文件，当然你也可以自行修改
                        if (/\.md$/.test(fileName) &amp;amp;&amp;amp; !/README/.test(fileName))
                            callback(innerDir);
                    }
                });
            }
        });
    });
}
module.exports = findMarkdown;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;scripts&lt;/code&gt;, 先为每个 &lt;code&gt;md&lt;/code&gt; 文件添加组件，然后打包，最后再一一删除 &lt;code&gt;markdown&lt;/code&gt; 中的 &lt;code&gt;comment&lt;/code&gt; 组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;build&quot;: &quot;node ./builds/addComponents.js &amp;amp;&amp;amp; vuepress build docs &amp;amp;&amp;amp; node ./builds/delComponents.js&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者的项目里面是把添加了二条命令的，比如 &lt;code&gt;npm run dev:md&lt;/code&gt; 和 &lt;code&gt;npm run build:md&lt;/code&gt; 才是有评论组件的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;dev:md&quot;: &quot;node ./builds/addComponents.js &amp;amp;&amp;amp; vuepress dev docs &amp;amp;&amp;amp; node ./builds/delComponents.js&quot;,
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;build&quot;: &quot;vuepress build docs&quot;,
    &quot;build:md&quot;: &quot;node ./builds/addComponents.js &amp;amp;&amp;amp; vuepress build docs &amp;amp;&amp;amp; node ./builds/delComponents.js&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;,
    &quot;delay&quot;: &quot;bash delay.sh&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想要怎样的打包命令，自己修改就行。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你的文章的评论要和 &lt;code&gt;github&lt;/code&gt; 的 &lt;code&gt;issues&lt;/code&gt; 的同步的话，还要在 &lt;code&gt;issues&lt;/code&gt; 的 &lt;code&gt;label&lt;/code&gt; 里添加相应的 &lt;code&gt;pathname&lt;/code&gt; 和 &lt;code&gt;gitalk&lt;/code&gt;，其中 &lt;code&gt;pathname&lt;/code&gt; 就是评论组件里面的 &lt;code&gt;location.pathname&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如我的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-6145f4293b296e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署到-github-pages&quot;&gt;1.6 部署到 Github pages&lt;/h3&gt;
&lt;p&gt;当我们将文档写好后就到了我们最关心的地方了，怎么将打包后的代码推送到远程仓库的 &lt;code&gt;gh-pages&lt;/code&gt; 分支上。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个deploy.sh&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;touch deploy.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;编写脚本&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env sh

# 确保脚本抛出遇到的错误
set -e

# 生成静态文件
npm run docs:build

# 进入生成的文件夹
cd docs/.vuepress/dist

# 如果是发布到自定义域名
# echo 'www.example.com' &amp;gt; CNAME

git init
git add -A
git commit -m 'deploy'

# 如果发布到 https://&amp;lt;USERNAME&amp;gt;.github.io
# git push -f git@github.com:&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git master

# 如果发布到 https://&amp;lt;USERNAME&amp;gt;.github.io/&amp;lt;REPO&amp;gt;
# git push -f git@github.com:&amp;lt;USERNAME&amp;gt;/&amp;lt;REPO&amp;gt;.git master:gh-pages

cd -
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;设置 &lt;code&gt;package.json&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;{
    &quot;scripts&quot;: {
        &quot;deploy&quot;: &quot;bash deploy.sh&quot;
      },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;发布&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;npm run deploy   // 即可自动构建部署到 github 上。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;访问自己的域名，比如笔者的：&lt;a href=&quot;https://biaochenxuying.github.io/blog/&quot; class=&quot;uri&quot;&gt;https://biaochenxuying.github.io/blog/&lt;/a&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;详情移步 vuepress 官网&lt;/strong&gt; &lt;a href=&quot;https://vuepress.vuejs.org/zh/guide/deploy.html&quot;&gt;vuepress.vuejs.org&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;gitbook&quot;&gt;2. GitBook&lt;/h2&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-f2cf1b9cdc7a46a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果详情请看：&lt;a href=&quot;http://biaochenxuying.cn:2021&quot; class=&quot;uri&quot;&gt;http://biaochenxuying.cn:2021&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;gitbook-常用指令&quot;&gt;2.1 GitBook 常用指令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安装 GitBook&lt;/strong&gt;：&lt;code&gt;npm i gitbook-cli -g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化 GitBook 项目&lt;/strong&gt;：&lt;code&gt;gitbook init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安装 GitBook 依赖&lt;/strong&gt;：&lt;code&gt;gitbook install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启 GitBook 服务&lt;/strong&gt;：&lt;code&gt;gitbook serve&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打包 GitBook 项目&lt;/strong&gt;：&lt;code&gt;gitbook build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitBook 命令行查看&lt;/strong&gt;：&lt;code&gt;gitbook -help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitBook 版本查看&lt;/strong&gt;：&lt;code&gt;gitbook -V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;简单上手&quot;&gt;2.2 简单上手&lt;/h3&gt;
&lt;p&gt;然后，我们找个空文件夹，初始化一个 GitBook 项目。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;gitbook init&lt;/code&gt; 初始化 README.md 和 SUMMARY.md 两个文件.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook build&lt;/code&gt; 本地构建但不运行服务，默认输出到 _book/ 目录.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook serve&lt;/code&gt; 本地构建并运行服务，默认访问 http://localhost:4000 实时预览.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;- GitBook
 - README.md
 - SUMMARY.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-90ed6f4108cc543b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;README.md&lt;/code&gt; 是默认首页文件，相当于网站的首页 &lt;code&gt;index.html&lt;/code&gt; ,一般是介绍文字或相关导航链接.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUMMARY.md&lt;/code&gt; 是默认概括文件，主要是根据该文件内容生成相应的目录结构，同 &lt;code&gt;README.md&lt;/code&gt; 一样都是被 &lt;code&gt;gitbook init&lt;/code&gt; 初始化默认创建的重要文件.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_book&lt;/code&gt; 是默认的输出目录，存放着原始 &lt;code&gt;markdown&lt;/code&gt; 渲染完毕后的 &lt;code&gt;html&lt;/code&gt; 文件，可以直接打包到服务器充当静态网站使用。一般是执行 &lt;code&gt;gitbook build&lt;/code&gt; 或 &lt;code&gt;gitbook serve&lt;/code&gt; 自动生成的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;book.json&lt;/code&gt; 是配置文件，用于个性化调整 &lt;code&gt;gitbook&lt;/code&gt; 的相关配置，如定义电子书的标题、封面、作者等信息。虽然是手动创建但一般是必选的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GLOSSARY.md&lt;/code&gt; 是默认的词汇表，主要说明专业词汇的详细解释，这样阅读到专业词汇时就会有相应提示信息，也是手动创建但是可选的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LANGS.md&lt;/code&gt; 是默认的语言文件，用于国际化版本翻译和 &lt;code&gt;GLOSSARY.md&lt;/code&gt; 一样是手动创建但是可选的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;book.json 的意思：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;title&lt;/code&gt;：网站标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;author&lt;/code&gt;：网站作者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt;：网站功能描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;language&lt;/code&gt;：网站使用语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;styles&lt;/code&gt;：网站额外配置的样式表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plugins&lt;/code&gt;：网站使用的插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pluginsConfig&lt;/code&gt;：网站使用的插件的额外配&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;笔者的 &lt;code&gt;book.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
  &quot;title&quot;: &quot;夜尽天明的博客&quot;,
  &quot;author&quot;: &quot;biaochenxuying&quot;,
  &quot;description&quot;: &quot;大前端技术为主，读书笔记、随笔、理财为辅，做个终身学习者。&quot;,
  &quot;language&quot;: &quot;zh-hans&quot;,
  &quot;plugins&quot;: [
    &quot;-highlight&quot;,
    &quot;copy-code-button&quot;,
    &quot;search-pro&quot;,
    &quot;-search&quot;,
    &quot;-lunr&quot;,
    &quot;expandable-chapters&quot;,
    &quot;splitter&quot;,
    &quot;-sharing&quot;,
    &quot;github-buttons&quot;,
    &quot;donate&quot;,
    &quot;tbfed-pagefooter&quot;,
    &quot;baidu-tongji&quot;,
    &quot;anchor-navigation-ex&quot;
  ],
  &quot;pluginsConfig&quot;: {
    &quot;github-buttons&quot;: {
      &quot;buttons&quot;: [
        {
          &quot;user&quot;: &quot;biaochenxuying&quot;,
          &quot;repo&quot;: &quot;blog&quot;, 
          &quot;type&quot;: &quot;star&quot;,
          &quot;count&quot;: true,
          &quot;size&quot;: &quot;small&quot;
        }, 
        {
          &quot;user&quot;: &quot;biaochenxuying&quot;,
          &quot;width&quot;: &quot;160&quot;, 
          &quot;type&quot;: &quot;follow&quot;, 
          &quot;count&quot;: true,
          &quot;size&quot;: &quot;small&quot;
        }
      ]
    },
    &quot;donate&quot;: {
      &quot;button&quot;: &quot;打赏&quot;,
      &quot;wechatText&quot;: &quot;微信打赏&quot;,
      &quot;wechat&quot;: &quot;https://camo.githubusercontent.com/ee094d402f957e5d656a399b9dc50ff8c010114e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d666661623762643234643038633030642e6a7065673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430&quot;
    },
    &quot;tbfed-pagefooter&quot;: {
      &quot;copyright&quot;:&quot;Copyright &amp;amp;copy biaochenxuying.cn 2019&quot;,
      &quot;modify_label&quot;: &quot;该文件修订时间：&quot;,
      &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;
    },
    &quot;baidu-tongji&quot;: {
      &quot;token&quot;: &quot;XXXXX&quot;
    },
    &quot;anchor-navigation-ex&quot;: {
      &quot;showLevel&quot;: false
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插件&quot;&gt;2.3 插件&lt;/h3&gt;
&lt;p&gt;插件的配置可以说是 GitBook 的核心。&lt;/p&gt;
&lt;p&gt;详情可以看 &lt;a href=&quot;https://juejin.im/post/5ce51e126fb9a07ed440d7d0#heading-3&quot;&gt;GitBook - 快速打造可留言的博客&lt;/a&gt;，这里就不展开讲了。&lt;/p&gt;
&lt;h2 id=&quot;vuepress-vs-gitbook&quot;&gt;3. VuePress VS GitBook&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;相同点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;目前只支持 &lt;code&gt;markdown&lt;/code&gt; 格式，图片、视频 等静态资源可以保存在本地，或者保存到允许访问的第三方服务商（如七牛云）；&lt;/li&gt;
&lt;li&gt;如果是 &lt;code&gt;world&lt;/code&gt; 文档或者 &lt;code&gt;html&lt;/code&gt; 格式，要转换成 &lt;code&gt;md&lt;/code&gt; 格式才行。&lt;/li&gt;
&lt;li&gt;找了几个 &lt;code&gt;world&lt;/code&gt; 文档转换成 md 格式的工具，都不好用，特别是有原文档有图片的时候。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;不同点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;GitBook&lt;/code&gt; 的配置成本很小，可以本地编辑，然后直接部署；&lt;code&gt;GitBook&lt;/code&gt; 官方还有个在线编辑器，不过内容要存在 &lt;code&gt;GitBook&lt;/code&gt; 的服务器上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VuePress&lt;/code&gt; 的配置成本稍稍大一点，不过可以使用 &lt;code&gt;Vue&lt;/code&gt; 的语法与组件，定制化更自由一点，而且 &lt;code&gt;VuePress&lt;/code&gt; 中编写 &lt;code&gt;Vue&lt;/code&gt; 和平时一样，学习成本几乎为零，可以本地用 VsCode 编辑，然后直接命令行部署。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;都要用 &lt;code&gt;markdown&lt;/code&gt; 语法来写文章，&lt;code&gt;markdown&lt;/code&gt; 也就几个常用语法而已，非常简单上手。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非技术人员推荐用 &lt;code&gt;GitBook&lt;/code&gt;，技术人员推荐用 &lt;code&gt;VuePress&lt;/code&gt;，特别是前端技术人员&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;个人更喜欢 &lt;code&gt;VuePress&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;项目源码&quot;&gt;4. 项目源码&lt;/h2&gt;
&lt;p&gt;本文中使用 &lt;code&gt;VuePress&lt;/code&gt; 和 &lt;code&gt;GitBook&lt;/code&gt; 的搭建的完整示例代码都已经上传到 &lt;code&gt;GitHub&lt;/code&gt; 上了，可以自行下载来用。&lt;/p&gt;
&lt;p&gt;只要把其中的一些配置信息换成自己的就行，比如 &lt;code&gt;仓库&lt;/code&gt;、&lt;code&gt;Client ID&lt;/code&gt; &amp;amp;&amp;amp; &lt;code&gt;Client Secret&lt;/code&gt;、作者等。&lt;/p&gt;
&lt;p&gt;源码地址： &lt;a href=&quot;https://github.com/biaochenxuying/blog&quot; class=&quot;uri&quot;&gt;https://github.com/biaochenxuying/blog&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;VuePress&lt;/code&gt; 和 &lt;code&gt;GitBook&lt;/code&gt; 的示例代码都在 &lt;code&gt;blog-gitbook&lt;/code&gt; 和 &lt;code&gt;blog-vuepress&lt;/code&gt; 里面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-9f517f38ba66e68b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这次需求的结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令笔者吐血的是：花了 3 天搞的调研，最后 leader 没有采用 😭，还是用回了 功能很重的 &lt;code&gt;wordpress&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为非技术人员要用起来的话，学习成本是比较大的 😂，比如要学 &lt;code&gt;markdown 语法&lt;/code&gt;、&lt;code&gt;ide 编辑器&lt;/code&gt;、基本的打包命令、可能还要学 &lt;code&gt;git&lt;/code&gt; ，而非技术人员编辑文档时，一般是用 &lt;code&gt;wps&lt;/code&gt; 的 😂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-2c27371376ee83aa.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较欣慰的是：笔者做完调研后，自己的博客网站也能用上了，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-047a49dd1d6a5f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/45&quot;&gt;GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目&lt;/a&gt;，估计很多人都不知道的技巧，甚至很多高级工程师都不知道。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://juejin.im/post/5db7f92ff265da4d120675ae&quot;&gt;为你的 VuePress 博客添加 GitTalk 评论&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 13:33:00 +0000</pubDate>
<dc:creator>天明夜尽</dc:creator>
<og:description>前言 因为自己平时经常写博客，也有博客网站，所以 Leader 叫我做一个 的帮助中心的技术选型， 的帮助中心的功能：是通过文章来教用户如何使用我们的项目。 所以笔者要做一个静态网站的技术选型，笔者把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/biaochenxuying/p/12019342.html</dc:identifier>
</item>
</channel>
</rss>