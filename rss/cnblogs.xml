<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>springboot+mybatis+dubbo+aop日志第二篇 - Eric.Chen</title>
<link>http://www.cnblogs.com/lc-chenlong/p/10655233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lc-chenlong/p/10655233.html</guid>
<description>&lt;p&gt;本篇主要介绍dubbo-demo-api接口层和dubbo-demo-service层，介绍代码前，咱们先来回顾一下整个demo工程的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190404153642074-1920496147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里面主要是定义所有的接口，demo工程里就定义了一个测试接口，看一下该层的代码结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190404153701583-1588162787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DemoApi.java代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.example.dubbo.demo.api;

import java.util.List;

import dubbo.demo.model.entity.Student;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Demo 接口定义
 * @author 
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DemoApi {
    String sayHello(String name);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(Student student);
    List&lt;/span&gt;&amp;lt;Student&amp;gt;&lt;span&gt; getAll();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该层主要实现api的接口，因此该层依赖api层，pom文件的依赖如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.example.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-demo-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：需要在api层执行install的maven命令，把api的jar包生打包到本地.m2仓库。&lt;/p&gt;
&lt;p&gt;该层代码结构如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190404153826116-1277220193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;aop包主要是记录每一个service方法调用时的入参，返回值，执行时间、接口的全名称等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;impl包实现api的接口逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mapper包是mybatis与数据库交互的方法，与mapper.xml对应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mapping文件夹下保存所有mapper.xml文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;dubbo-config.xml 是dubbo暴露服务的配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;impl/DemoApiImpl.java代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.api.DemoApi;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.service.mapper.StudentMapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; dubbo.demo.model.entity.Student;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.dubbo.config.annotation.Service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; chenlong12
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoApiImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DemoApi {
  
  @Autowired
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StudentMapper studentMapper;
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 实现 sayHello 接口
   *
   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(String name) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello, &quot; + name + &quot; (from Spring Boot with dubbo-2.7.1)&quot;&lt;span&gt;;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(Student student) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;    studentMapper.add(student);
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; getAll() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; studentMapper.getAll();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;mapper/StudentMapper.java代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.service.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; dubbo.demo.model.entity.Student;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; StudentMapper {

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(Student student);
  List&lt;/span&gt;&amp;lt;Student&amp;gt;&lt;span&gt; getAll();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;mapping/StudentMapper.xml代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.example.dubbo.demo.service.mapper.StudentMapper&quot;&amp;gt;
  &amp;lt;resultMap id=&quot;StudentResultMap&quot; type=&quot;dubbo.demo.model.entity.Student&quot;&amp;gt;
    &amp;lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&amp;gt;
    &amp;lt;result column=&quot;num&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;num&quot; /&amp;gt;
    &amp;lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot; /&amp;gt;
    &amp;lt;result column=&quot;age&quot; jdbcType=&quot;INTEGER&quot; property=&quot;age&quot; /&amp;gt;
    &amp;lt;result column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;sex&quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  &amp;lt;insert id=&quot;add&quot; parameterType=&quot;dubbo.demo.model.entity.Student&quot;&amp;gt;&lt;span&gt;
    insert into student (num, name, age,sex)
    values (#{num},#{name},#{age},#{sex})
  &lt;/span&gt;&amp;lt;/insert&amp;gt;
  
  &amp;lt;!--我自己加的方法--&amp;gt;
  &amp;lt;select id=&quot;getAll&quot; resultType=&quot;dubbo.demo.model.entity.Student&quot;&amp;gt;&lt;span&gt;
    select &lt;/span&gt;*&lt;span&gt; from student
  &lt;/span&gt;&amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dubbo-config.xml会引用该配置文件里的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
spring.config.name=&lt;span&gt;application

# spring 的环境配置
spring.profiles.active&lt;/span&gt;=&lt;span&gt;dev
# 服务启动端口，即内置 tomcat 启动时占用的端口
server.port&lt;/span&gt;=8087&lt;span&gt;

spring.aop.auto&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

spring.datasource.driver&lt;/span&gt;-&lt;span&gt;class&lt;/span&gt;-name=&lt;span&gt;com.mysql.jdbc.Driver
spring.datasource.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/school?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/span&gt;
spring.datasource.username=&lt;span&gt;
spring.datasource.password&lt;/span&gt;=&lt;span&gt;

mybatis.mapper&lt;/span&gt;-locations=classpath:mapping&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.xml
mybatis.type-aliases-package=dubbo.demo.model.entity
# dubbo config
# 应用定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识
my.dubbo.application.name=dubbo-demo-service
# 应用所属者
my.dubbo.application.owner=ll
# 应用所属组织
my.dubbo.application.organization=ll

# 使用 zookeeper 注册中心暴露服务，注意要先开启 zookeeper
# 注册中心id
my.dubbo.registry.id=zookeeper-registry
# 注册中心协议
my.dubbo.registry.protocol=zookeeper
# 注册中心地址
my.dubbo.registry.address=127.0.0.1:2181

# dubbo协议在20880端口暴露服务
# 协议名称
my.dubbo.protocol.name=dubbo
# 协议端口
my.dubbo.protocol.port=20880
# 协议访问log
my.dubbo.protocol.accesslog=dubbo-access.log
# 重试次数
my.dubbo.provider.retries=0
# 超时时间
my.dubbo.provider.timeout=3000
# 注册监控中心
my.dubbo.monitor.protocol=registry&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;dubbo-config.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这dubbo的配置文件，所有的服务都是通过这个配置文件发布出去&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:dubbo&lt;/span&gt;&lt;span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:application &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;${my.dubbo.application.name}&quot;&lt;/span&gt;&lt;span&gt; owner&lt;/span&gt;&lt;span&gt;=&quot;ll&quot;&lt;/span&gt;&lt;span&gt; organization&lt;/span&gt;&lt;span&gt;=&quot;ll&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用 zookeeper 注册中心暴露服务，注意要先开启 zookeeper&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;zookeeper-registry&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;${my.dubbo.registry.protocol}&quot;&lt;/span&gt;&lt;span&gt; address&lt;/span&gt;&lt;span&gt;=&quot;${my.dubbo.registry.address}&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; dubbo协议在20880端口暴露服务 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;${my.dubbo.protocol.name}&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;${my.dubbo.protocol.port}&quot;&lt;/span&gt;&lt;span&gt; accesslog&lt;/span&gt;&lt;span&gt;=&quot;dubbo-access.log&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:provider &lt;/span&gt;&lt;span&gt;retries&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;&lt;span&gt;=&quot;30000&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:monitor &lt;/span&gt;&lt;span&gt;protocol&lt;/span&gt;&lt;span&gt;=&quot;registry&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;demoApiImpl&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.example.dubbo.demo.service.impl.DemoApiImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用 dubbo 协议实现定义好的 Service Api 接口&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.example.dubbo.demo.api.DemoApi&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;demoApiImpl&quot;&lt;/span&gt;&lt;span&gt; retries&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;add&quot;&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;&lt;span&gt;=&quot;10000&quot;&lt;/span&gt;&lt;span&gt; retries&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; loadbalance&lt;/span&gt;&lt;span&gt;=&quot;leastactive&quot;&lt;/span&gt;&lt;span&gt; actives&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:service&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细的配置说明请参见dubbo官方文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html&quot; target=&quot;_blank&quot;&gt;http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DubboDemoServiceApplication.java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目启动main方法，项目启动前需要先把zookeeper启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.dubbo.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.dubbo.config.spring.context.annotation.DubboComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.dubbo.config.spring.context.annotation.EnableDubboConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.annotation.MapperScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ImportResource;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@EnableDubboConfig
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@DubboComponentScan(&quot;com.example.dubbo.demo.service.impl&quot;)&lt;/span&gt;
@MapperScan(&quot;com.example.dubbo.demo.service.mapper&quot;&lt;span&gt;)
@SpringBootApplication
@ImportResource(locations&lt;/span&gt;=&quot;classpath:dubbo-config.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DubboDemoServiceApplication {

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    SpringApplication.run(DubboDemoServiceApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;下一篇咱们介绍怎么用aop获取每一个service服务的入参、出参、执行时间等信息&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 04 Apr 2019 07:47:00 +0000</pubDate>
<dc:creator>Eric.Chen</dc:creator>
<og:description>本篇主要介绍dubbo-demo-api接口层和dubbo-demo-service层，介绍代码前，咱们先来回顾一下整个demo工程的结构 1.dubbo-demo-api 这里面主要是定义所有的接口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lc-chenlong/p/10655233.html</dc:identifier>
</item>
<item>
<title>程序员学习笔记之消费心理学1 - honkerzh</title>
<link>http://www.cnblogs.com/honkerzh/p/10655237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/honkerzh/p/10655237.html</guid>
<description>&lt;h4 id=&quot;心理账户---让用户从最有钱的那个心理账户上花钱&quot;&gt;1.心理账户 - 让用户从最有钱的那个心理账户上花钱&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一个人会把自己所能支出的钱存入不同的心理账户上，比如日常生活必须开支、娱乐开支、维系感情的开支、保障身体健康开支、维系社交开支、保障面子开支等等&lt;/strong&gt;。如果一个人觉得你卖的东西挺好的就是太贵了，你可以让他从其它的心理账户上掏钱，比如这个商品能对维系感情的作用或者增加面子方面作用等等。&lt;br/&gt;比如一个人准备花200元买了一张音乐会门票，他去坐公交路上突然发现自己出门揣口袋里面的刚充值200元公交卡掉了，他会不会因为这个而放弃去看演唱会呢？几乎是不会的。相反，如果他是把准备买演唱会的那200元掉了，他很有可能就不会去看演唱会了。为什么同样是损失200元钱，结果完全不一样呢。原因之一就是这个人心里账户的存储金额不同，如果是公交卡那200掉了，重新充值公交卡是属于日常生活开销的心理账户，而演唱会那200元是属于 娱乐账户开支，如果这笔娱乐开支掉了，就好比他觉得自己已经为这次演唱会付费过了，他很难再重新拿200元买一张票。&lt;/p&gt;
&lt;h4 id=&quot;沉没成本&quot;&gt;2.沉没成本&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;沉没成本是指已发生或承诺、无法回收的成本支出，如因失误造成的不可收回的投资。沉没成本是一种历史成本，对现有决策而言是不可控成本，不会影响当前行为或未来决策。从这个意义上说，在投资决策时理性的决策者应排除沉没成本的干扰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如你去店里买东西，特别喜欢一种东西，但是觉得太贵了，店家就是不肯降价，此时相比于假装说太贵了自己不买了而借势离开更好做法是在店里试各种衣服让店员帮各种忙，最后选中这件商品时候，再讨价还价或顺势离开。因为店家为你付出的沉没成本越大，他就越不愿意放走你这个客户，即使少赚一点钱。这是一种利用大众对沉没成本的潜意识的执念。比如婚姻的复杂性，让所有亲朋好友来做见证，其实也是一种沉没成本的表现，包括钻戒等高价值婚姻物品，都能增加婚姻的稳定性。因为谁都不想因为一点小事而让自己再结一次婚，再去经历一次那么恐怖的流程，让亲朋好友再见证一次”你是否会终生只爱这个人“的”场面“。&lt;br/&gt;经济学告诉我们，一件事情是继续做还是放弃与为此付出的代价（沉没成本）无关，而应该与未来是否因为这个决定更美好有关。但大部分人是不容易做到的，我虽然知道这个道理但也依然在面临诸多选择时候被沉没成本所牵绊。既然不能摆脱它，不如就去学习它、使用它吧。&lt;br/&gt;比如：为什么感情里单方面无条件的付出是不提倡的，想让感情稳步前进应该让双方都对这段感情有比较高的投入。你能用沉没成本的道理进行解释吗？&lt;/p&gt;
&lt;h4 id=&quot;比例偏见&quot;&gt;3.比例偏见&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;很多场合本来应该考虑数值本身的变化，但人们更倾向于考虑比率或者倍率的变化。也就是说人们对比例的感知比对数字的感知更加敏感。&lt;/strong&gt;&lt;br/&gt;比如：你需要买的一个原本价值50块的东西，你现在买东西的商场10分钟的距离另外一个商场搞促销便宜15块钱，你很有可能因为这15块而去那个搞促销的商场。而假如你想买一个5000的冰箱，同样有人告诉你，旁边商场走路过去10分钟的商场打促销只卖4985，你很有可能不会去另一个商场买。同样的15元，为什么会造成两种差异呢。这儿很大一部分就是比例偏见效果在起作用。&lt;br/&gt;所以，懂经济学的销售员会在 商品标价比较低情况下，打比例牌，比如便宜了20%，30%，甚至50%。而售卖贵重的商品时采用换购策略，也就是购买了这个商品之后，加一元或者加10元就能获得一个附赠品。&lt;br/&gt;比如当你要买一台电冰箱需要花费5000元（双开门的哈，不过还是建议大家买单开门的，家里人不多，单开门够用，而且冷冻食品吃多了对身体不太好，还是建议吃新鲜的） 此时如果店家搞活动吸引顾客最好的手段不是赠送一个100元的锅，因为比例偏见的存在，人们会拿这50元的和5000元进行对比，差距太大了，毫无吸引力。相反采用换购，告诉客户我们店现在搞活动 买了这台价值5000元的冰箱之后，加一元就能多买一个价值100元的锅，此时 比例偏见生效了，100元不再和5000元进行对比，而是和那1元对比，此时顾客的幸福感会大大增加，感觉赚到了便宜。ps： 最具有吸引力的是让客户觉得自己占到了很大的便宜。而这种利用比例偏见的促销手段让商家和客户都得到比较大的满足，岂不是很美吗，哈哈哈。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 07:47:00 +0000</pubDate>
<dc:creator>honkerzh</dc:creator>
<og:description>1.心理账户 让用户从最有钱的那个心理账户上花钱 一个人会把自己所能支出的钱存入不同的心理账户上，比如日常生活必须开支、娱乐开支、维系感情的开支、保障身体健康开支、维系社交开支、保障面子开支等等 。如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/honkerzh/p/10655237.html</dc:identifier>
</item>
<item>
<title>《前端之路》之  2019年 三月 前端跳槽小记 （杂谈 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/10655217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/10655217.html</guid>
<description>&lt;h2 id=&quot;年-三月-前端跳槽小记&quot;&gt;2019年 三月 前端跳槽小记&lt;/h2&gt;
&lt;p&gt;本来按照 一月一篇的更新速度来着，因为三月份换工作的原因，鸽了一篇，真的是难受。&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190401160712858-1059352394.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇文章中，不会涉及到 太多前端知识点，只是对于这个阶段的一个总结以及一些可能对目前的你有帮助的 &lt;code&gt;前端&lt;/code&gt;面试经验。&lt;/p&gt;
&lt;h3 id=&quot;一互联网寒冬&quot;&gt;一、互联网寒冬&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;1. 人员优化：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;早在 2018年的&lt;code&gt;第四季度&lt;/code&gt;，很多互联网公司都陆续出现 所谓的&lt;code&gt;人员优化&lt;/code&gt;的现象。&lt;br/&gt;那么作为一只有着5年互联网经验的从业人员来说，这，确实是第一次遇到，毕竟整体经济增速下行，创业公司频频倒闭，大到BAT，小到创业公司、P2P公司等等，都出现了不太友好的&lt;code&gt;环境变化&lt;/code&gt;。当然了，环境也是&lt;code&gt;因人而异&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;出现这种情况的原因大概就是因为 &lt;code&gt;资本&lt;/code&gt;对于互联网行业的热情褪去，&lt;code&gt;创业公司减少&lt;/code&gt;，&lt;code&gt;大厂HC 缩减&lt;/code&gt;从而保证在 寒冬中能够顺利渡过。这些举措在现在看来都是没有任何问题的。 那么这些年想通过 读 CS系 相关专业的毕业生们就比较艰难的找到工作，大厂中的 开发者们 耶不敢轻易的跳槽。那么基于这些情况， 跳槽找工作本身就是对于自身能力的一种自信和挑战。&lt;/p&gt;
&lt;p&gt;下面会讲到我在这 面试的一个月中遇到的种种情况。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2. 996.ICU 对抗：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在我这休息的 大半个月中，（其实也不能算是彻底的度假式 的休息，因为还要操心面试找工作的事情。） 陆陆续续的也能收到 大厂、小厂、创业公司 等等 的一些 面试邀请，然后现在已经拿到了一些 offer 了。 在这些面试过程中，面试官活着 HR 会有意无意的提示你，我们公司可能会出现 短期 或者 长期的 996 的情况，你能适应么？ 那么当你作为一名 应聘者 被问到这些问题的时候，你内心的第一个想法是什么？ （钱给到位了，我都可以睡公司 - - ） 但是更多的一个回答就是： 当然可以适应这种情况了，因为只有这样才能对于自身能力提升做到一个很不错的保障。 当然这不是 必然的答案，看自身需求以及场景了。&lt;/p&gt;
&lt;p&gt;那么 996 的 github 的对抗，对于国内目前这种国情能起到什么作用么？&lt;br/&gt;答案是： &lt;code&gt;##不能##&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;毕竟 资本家尝到了这样做的甜头了，再让他们回去一般来说不太可能。&lt;/p&gt;
&lt;p&gt;再加上当前 资本寒冬，996 已经是他们救命的稻草了吧。&lt;/p&gt;
&lt;p&gt;那么 作为程序员如何 应对 996 ？&lt;/p&gt;
&lt;p&gt;答案： 晚饭后 抽出必要时间 &lt;code&gt;坚持运动，坚持锻炼&lt;/code&gt;，真不要长期 996 不锻炼，然后 ICU，对于自己来讲不划算。（在医院检查的时候遇到一大哥，30多岁在深圳靠自己买了几套房，但是由于太卖命了，现在在医院做&lt;code&gt;心脏搭桥手术&lt;/code&gt;）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190401231048708-778930175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者在去年 因为长期的 加班，导致有段时间缺乏锻炼，身体极度不适应，而且情绪也变得有些暴躁，静不下心来，后来体检，医生说心脏有些问题，心有不安，从而去 心血管专科医院检查，前前后后 检查了 一周左右，当自己躺在病床上，检查的仪器挂在自己的身上的时候，真不敢相信，我自己还会有这样的一天。&lt;/p&gt;
&lt;p&gt;所以： 面对 996，越是长期高压的开发压力，越是需要 足够的锻炼，让自己的身体得到保障，不然真的会死人的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3. 休息的这半个月：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3.1 能安静下来了&lt;/code&gt;&lt;br/&gt;这个是休息的这半个月的时间里面，感触最大的地方就是感觉自己可以安静下来做一些事情了，执行力也变的强了一些。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3.2 回顾 上一家公司的最后的状态&lt;/code&gt;&lt;br/&gt;非常难平静下来，内心也特别急躁，不知道急躁一些什么。但是内心还是比较压抑，而且工作带来的成就感也不那么强烈了。但是压死骆驼的最后一根稻草是 所在部门业务优化，当前业务线不做了，直接合并给了别的部门，要么&lt;code&gt;内部转岗&lt;/code&gt;，要么协商 &lt;code&gt;n+1&lt;/code&gt; 离开。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3.3 内部转岗 和 n+1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果有同学想了解 内部转岗和n+1 分别应该如何抉择的话，我相信我最近的 经历完全可以给你一个完美的建议。对这方面感兴趣的同学可以加笔者微 &lt;code&gt;Zigzag1118&lt;/code&gt; 我想我能给你一个 参考意见。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3.4 知道自己想要什么了：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这段时间不管是和面试官沟通还是自己静下心来思考着自己这最近近五年的开发工作中，我们是否认真思考过一些问题？&lt;br/&gt;我们是否认真思考过自己真正想要的是什么？&lt;br/&gt;我们是否对于自己的职业规划有一个非常明确的规划？&lt;br/&gt;我们是否知道我们自己擅长什么？自己的短板又在哪里？&lt;br/&gt;我们对于自己的薪资有一个什么样的预期？&lt;br/&gt;我们的能力能匹配这样的薪资么？&lt;br/&gt;需要每天都这么来反省自己，并且要告诉自己通过今天这一天的上班过程中，我学到了哪些知识点，哪些地方是还需要改进的，那么基于这么一个 自我反省的机制，自我驱动学习成长，应该是没有问题的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190402154249821-374992180.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二公司变动以及未来个人职业规划总结&quot;&gt;二、公司变动以及未来个人职业规划总结&lt;/h3&gt;
&lt;h4 id=&quot;公司变动&quot;&gt;&lt;code&gt;1. 公司变动&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这种情况在非创业公司中应该会比较少的遇到，一般大一点的公司往往遇到的是 部门变动，或者 业务调整， 这个时候其实你是需要非常&lt;code&gt;警惕&lt;/code&gt;这种情况的。&lt;/p&gt;
&lt;p&gt;情况之严峻的排序： 业务调整 &amp;lt; 部门调整 &amp;lt; 公司变动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;业务调整：&lt;/code&gt; 这个业务在公司规划中 未能产生预期的效益。&lt;/p&gt;
&lt;h4 id=&quot;职业规划&quot;&gt;&lt;code&gt;2. 职业规划：&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;在上面的各种调整中，看似对个人的影响不大，但是往往各种调整对于一线的开发者来说都是有着非常大的关联。我们需要弄清楚这个 调整的缘由，在必要的条件下，我们还是有必要对于自己利益做一些前置思考。&lt;/p&gt;
&lt;p&gt;前段时间 看到 easy 大佬 有发过一篇文章关于 996.icu 的&lt;/p&gt;
&lt;p&gt;里面我记得一句非常清楚的话就是： 公司和工作 其实就是： 一群人在一起想办法挣钱，然后再一起分钱的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190402160449342-1914195303.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么 这和个人职业规划又有什么关系呢？&lt;/p&gt;
&lt;p&gt;因为还有一句话： &lt;code&gt;技术从来都不是企业发展的第一生产力，产品才是。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自己的职业规划就是找到适合自己的地方（职位晋升渠道 或者 行业背景渠道） 找准方向，一路向北。&lt;/p&gt;
&lt;h3 id=&quot;三面试&quot;&gt;三、面试&lt;/h3&gt;
&lt;h4 id=&quot;面试需要准备么&quot;&gt;&lt;code&gt;1. 面试需要准备么？&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;无论什么面试都是需要准备的，就算是相亲也是需要准备的，对吧。&lt;/p&gt;
&lt;p&gt;那么针对国内现在的前端技术氛围，前端需要准备一些什么内容呢？&lt;/p&gt;
&lt;h5 id=&quot;前端基础能力-hmtl5css3js浏览器通信协议安全策略&quot;&gt;&lt;code&gt;前端基础能力:&lt;/code&gt; hmtl5、css3、JS、浏览器、通信协议、安全策略&lt;/h5&gt;
&lt;p&gt;其中 html5 和 css3 往往是考验 移动端适配、布局、盒模型、动画效果&lt;br/&gt;也有一些公司会去考虑 新的一些特性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JS 能力：&lt;/code&gt; 那么作为面试官一般会如何去评判你的 JS 基础能力呢？&lt;br/&gt;基本的数据类型？&lt;br/&gt;JS 原型？ 事件模型？ ES5、6、7、8、9 的新特性，以及这些新特性的原理？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浏览器 能力：&lt;/code&gt; 这里往往就是 Bom 和 浏览器渲染 html 机制、最经典的一个问题就是 从浏览器的输入框中输入了 url 到整个页面 呈现出来的过程讲解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;通信协议：&lt;/code&gt; 这里的话 往往就是 http、https 、TCP三次握手、TSL加密原理、XHR 、跨域、如何解决跨域。websocket、网络七层协议 等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;安全策略&lt;/code&gt; xss、crsf 等等 web安全与防御策略&lt;/p&gt;
&lt;p&gt;以上几个问题，不同厂的 面试风格完全不一样，可能会问到的问题的深度也完全不一样，还是要稳固的掌握好基础哇，这样才能以不变应万变。&lt;/p&gt;
&lt;h4 id=&quot;技术面试需要注意哪些地方&quot;&gt;&lt;code&gt;2. 技术面试需要注意哪些地方？&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;表达：&lt;/code&gt; 对，其实就是表达，善于表达 == 善于沟通。 在我的个人经验来看，一个 team 一定要 善于沟通，甚至是 沟通无障碍就非常满足了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;技术细节&lt;/code&gt; 上面提到的一些基础的技术细节一定要非常清楚，往往细节决定成败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;框架理解能力&lt;/code&gt; 前端的面试中，会被问到前端三大框架的应用理解能力，那么 掌握自己擅长框架的 原理和 底层源码，将是必要的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;更多的就是描述之前的工作经验，以及让你觉得有意思的地方&lt;/code&gt;&lt;br/&gt;这个就是看之前的项目经验，和自身成长过程中遇到的问题和解决方案了&lt;/p&gt;
&lt;h4 id=&quot;技术经理面试一般都会问些什么问题&quot;&gt;&lt;code&gt;3. 技术经理面试，一般都会问些什么问题？&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过了前面 用人小组的面试，那基本上前端基础的问题你已经符合他们的庸人要求了，剩下的一个就是 技术经理的面试了。&lt;/p&gt;
&lt;p&gt;这一层面的话，往往就是 对于你对整个技术大方向的理解，一般会问到你一些 算法的问题， 那么 日常的开发 之余 还是建议说 能够有意识的对锻炼自己的算法能力，提升逻辑处理能力。这样在 技术经理面试你一系列算法问题的时候 从容不迫。&lt;/p&gt;
&lt;h4 id=&quot;hr-面试的时候需要在主意些什么问题&quot;&gt;&lt;code&gt;4. Hr 面试的时候需要在主意些什么问题？&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;如果你能面到 Hr 这一轮的话，那么恭喜你了，你基本上已经大概率满足他们的庸人需求了，剩下的就是 双方 谈薪资 的这个关键点、当然 薪资的 包含了 很多的内容，一般是 年终奖+项目奖金+周边福利&lt;/p&gt;
&lt;p&gt;这一关：其实是非常重要的，因为能否在合适的点儿上 谈到合适的价格，这是一种谈判能力。&lt;/p&gt;
&lt;p&gt;建议找一些程序员与 hr 谈薪资的 Demo 来看一看，聊到自己满意的薪资才是最终的胜利。&lt;/p&gt;
&lt;p&gt;各位加油～&lt;/p&gt;
&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;其实也没啥特别好总结的， 作为技术开发，强化自己的技术能力，争取在公司能做出一番成绩，在哪里上班不重要，坚持不断的学习才是自己的第一竞争力。那么除了这以外的能力，就是一个为人处事的能力了，不断的锻炼自己的情商，让同事与你相处起来否非常的开心。然后带着一群人一起做一些赚钱的事情，一起慢慢成长。 愿诸位在2019年都能拿到自己心仪的offer，共勉～&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190404153916746-974371011.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.25&quot;&gt;
&lt;p&gt;GitHub 地址：（欢迎 star 、欢迎推荐 : )&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E6%9D%82%E8%B0%88/2019%E5%B9%B4%E5%89%8D%E7%AB%AF%E4%B8%89%E6%9C%88%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93.md&quot;&gt;2019年 三月 前端跳槽小记&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 04 Apr 2019 07:45:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>2019年 三月 前端跳槽小记 本来按照 一月一篇的更新速度来着，因为三月份换工作的原因，鸽了一篇，真的是难受。 这篇文章中，不会涉及到 太多前端知识点，只是对于这个阶段的一个总结以及一些可能对目前的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/10655217.html</dc:identifier>
</item>
<item>
<title>MySQL 是如何解决幻读的 - 吴丹阳LastSun</title>
<link>http://www.cnblogs.com/wdy1184/p/10655180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdy1184/p/10655180.html</guid>
<description>&lt;h2 id=&quot;一什么是幻读&quot;&gt;一、什么是幻读&lt;/h2&gt;
&lt;p&gt;在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。&lt;/p&gt;
&lt;p&gt;而多出来或者少的哪一行被叫做 &lt;code&gt;幻行&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二为什么要解决幻读&quot;&gt;二、为什么要解决幻读&lt;/h2&gt;
&lt;p&gt;在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。&lt;/p&gt;
&lt;h2 id=&quot;三mysql-是如何解决幻读的&quot;&gt;三、MySQL 是如何解决幻读的&lt;/h2&gt;
&lt;p&gt;如果你看到了这篇文章，那么我会默认你了解了 &lt;code&gt;脏读&lt;/code&gt; 、&lt;code&gt;不可重复读&lt;/code&gt;与&lt;code&gt;可重复读&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;多版本并发控制mvcc快照读&quot;&gt;1. 多版本并发控制（MVCC）（快照读）&lt;/h3&gt;
&lt;p&gt;多数数据库都实现了多版本并发控制，并且都是靠保存数据快照来实现的。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;InnoDB&lt;/code&gt; 为例，每一行中都冗余了两个字断。一个是行的创建版本，一个是行的删除（过期）版本。版本号随着每次事务的开启自增。事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。&lt;/p&gt;
&lt;p&gt;普通的 select 就是快照读。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from T where number = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。&lt;/p&gt;
&lt;h3 id=&quot;next-key-锁-当前读&quot;&gt;2. next-key 锁 （当前读）&lt;/h3&gt;
&lt;p&gt;next-key 锁包含两部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录锁（行锁）&lt;/li&gt;
&lt;li&gt;间隙锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;记录锁是加在索引上的锁，间隙锁是加在索引之间的。（思考：如果列上没有索引会发生什么？）&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from T where number = 1 for update;
select * from T where number = 1 lock in share mode;
insert
update
delete&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。&lt;/p&gt;
&lt;h2 id=&quot;其他mysql-innodb-引擎-rr-隔离级别是否解决了幻读&quot;&gt;其他：MySQL InnoDB 引擎 RR 隔离级别是否解决了幻读&lt;/h2&gt;
&lt;p&gt;引用一个 github 上面的评论 &lt;a href=&quot;https://github.com/Yhzhtk/note/issues/42#issuecomment-424079787&quot;&gt;地址&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读。&lt;br/&gt;a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意dml操作），a事务再select出来的结果在MVCC下还和第一次select一样，接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了，实测在RR级别下确实如此。&lt;/p&gt;
&lt;p&gt;如果这样理解的话，Mysql的RR级别确实防不住幻读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有道友回复 &lt;a href=&quot;https://github.com/Yhzhtk/note/issues/42#issuecomment-449682887&quot;&gt;地址&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在快照读读情况下，mysql通过mvcc来避免幻读。&lt;br/&gt;在当前读读情况下，mysql通过next-key来避免幻读。&lt;br/&gt;select * from t where a=1;属于快照读&lt;br/&gt;select * from t where a=1 lock in share mode;属于当前读&lt;/p&gt;
&lt;p&gt;不能把快照读和当前读得到的结果不一样这种情况认为是幻读，这是两种不同的使用。所以我认为mysql的rr级别是解决了幻读的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说结论，MySQL 存储引擎 InnoDB 隔离级别 RR 解决了幻读问题。&lt;/p&gt;
&lt;p&gt;如引用一问题所说，T1 select 之后 update，会将 T2 中 insert 的数据一起更新，那么认为多出来一行，所以防不住幻读。看着说法无懈可击，但是其实是错误的，InnoDB 中设置了 快照读 和 当前读 两种模式，如果只有快照读，那么自然没有幻读问题，但是如果将语句提升到当前读，那么 T1 在 select 的时候需要用如下语法： &lt;code&gt;select * from t for update (lock in share mode)&lt;/code&gt; 进入当前读，那么自然没有 T2 可以插入数据这一回事儿了。&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;next-key 固然很好的解决了幻读问题，但是还是遵循一般的定律，隔离级别越高，并发越低。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 04 Apr 2019 07:40:00 +0000</pubDate>
<dc:creator>吴丹阳LastSun</dc:creator>
<og:description>MySQL 是如何解决幻读的 一、什么是幻读 在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。 而多出来或者少的哪一行被叫做 二、为什么要解决幻读 在高并发数据库系统中，需要保证事务与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdy1184/p/10655180.html</dc:identifier>
</item>
<item>
<title>LZ从Java Web转大数据，并且成功拿到上市公司Offer，工资直接涨了9K+ - Hongten</title>
<link>http://www.cnblogs.com/hongten/p/hongten_big_data_offer.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongten/p/hongten_big_data_offer.html</guid>
<description>&lt;h2&gt;Before&lt;/h2&gt;
&lt;p&gt;本文的目的是为你（有一定编程基础的同学仔）提供一些想打算转大数据的参考；&lt;/p&gt;
&lt;p&gt;如果你是大数据工程师，不太适合你进行进阶学习；&lt;/p&gt;
&lt;p&gt;如果你是零编程基础同学仔，你可以参考我之前写的blog，建议先把基础打牢，再去学习大数据；&lt;/p&gt;
&lt;p&gt;如果你不是攻城狮，那么你可以当做一个故事即可。&lt;/p&gt;

&lt;p&gt;大家好，我是Hongten&lt;/p&gt;
&lt;p&gt;今天我要给大家分享一下我的个人经历，我从Java Web转大数据，并且成功拿到上市公司Offer，工资直接涨了9K+&lt;/p&gt;
&lt;p&gt;我大二的时候，就开始接触Java，之前也接触了一些Android的知识，但是最终还是觉得自己更擅长Java Web。所以就这样一直朝着Web方向发展。&lt;/p&gt;
&lt;p&gt;工作一段时间后，从刚开始接触的Servlet/JSP，JPA，Web Service到后来的Struts，Hibernate，Spring（SSH），再到后来的Spring boot，Spring Data，CXF，Quartz等，用着用着，你会有一种感觉，就是他们有太多的相似之处，总逃不过MVC，我更喜欢把它理解为三个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们看到的UI&lt;/li&gt;
&lt;li&gt;我们编写的处理逻辑&lt;/li&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于我自己来说 ，我更擅长编写处理逻辑，即我们所说的后端程序。也经常与数据库打交道。在数据库方面，多数情况下使用mysql或者是oracle。&lt;/p&gt;
&lt;p&gt;数据的更改：数据从UI流入我们的逻辑处理（通常情况下，我们使用框架来实现，如Spring），经过处理的数据保存到数据库。&lt;/p&gt;
&lt;p&gt;数据的查询：通过查询条件从数据库中过滤后，得到我们想要的数据，经过我们的逻辑处理，最后在UI上面呈现，有些是以report的方式呈现，但是不管用什么方式，最终，我们要看到我们想要的数据即可手工。&lt;/p&gt;
&lt;p&gt;所以，做着做着，我感觉遇到了瓶颈！&lt;/p&gt;
&lt;p&gt;我从一下几个方面进行对我自我剖析：&lt;/p&gt;
&lt;p&gt;第一：Java基础掌握程度&lt;/p&gt;
&lt;p&gt;第二：框架掌握程度&lt;/p&gt;
&lt;p&gt;第三：数据库掌握程度&lt;/p&gt;
&lt;p&gt;第四：数据结构与算法&lt;/p&gt;

&lt;p&gt;若有不正之处，还请多多谅解，并希望批评指正。&lt;/p&gt;
&lt;p&gt;请尊重作者劳动成果，转发请标明blog地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/hongten/p/10635627.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/hongten/p/10635627.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;第一：Java基础掌握程度&lt;/h2&gt;
&lt;p&gt;在Java基础方面，集合LZ的面试经验，LZ大致分为一下几个方面&lt;/p&gt;
&lt;h3&gt;1.集合&lt;/h3&gt;
&lt;p&gt;比较List和Set？我想多数人都觉得easy&lt;/p&gt;
&lt;p&gt;比较ArrayList,LinkedList, Vector？&lt;/p&gt;
&lt;p&gt;比较HashSet,TreeSet,LinkedSet？&lt;/p&gt;
&lt;p&gt;比较HashMap,HashTable,TreeTable,LinkedHashMap？&lt;/p&gt;
&lt;p&gt;当你都能够回答以上问题以后，那么接下来，面试官会想，这小子还不错哦，至少对集合还是有一定认识的!!! 那么给你来一点难度：&lt;/p&gt;
&lt;p&gt;HashMap的工作原理是什么？&lt;/p&gt;
&lt;p&gt;HashMap冲突很厉害，性能差，你会怎样解决？（很多人估计回想HashMap有冲突？？？我咋第一次听到呢？还性能差，还要解决？？？）&lt;/p&gt;
&lt;p&gt;当你解决了HashMap的冲突，那么接下来，面试官就会想，这小子还有两把刷子啊，我再给你来两个进阶Questions!!!&lt;/p&gt;
&lt;p&gt;比较HashMap,HashTable,ConcurrentHashMap？（看到这里，我想也有一堆人一脸懵逼，好像看过，但是有说不出来.....）&lt;/p&gt;

&lt;h3&gt;2.IO/NIO&lt;/h3&gt;
&lt;p&gt;比较IO和NIO？&lt;/p&gt;
&lt;p&gt;当你刷刷刷，说完，哈哈哈，不要以为你NB，这时候面试官会给你来一些更猛的：&lt;/p&gt;
&lt;p&gt;在NIO里面，说说Buffer的原理？&lt;/p&gt;
&lt;p&gt;说说Selector的原理？&lt;/p&gt;
&lt;p&gt;我们作为面试者，不要慌，不要认怂。把你能想到的，一条一条的讲出来。面试官会肯定你的。&lt;/p&gt;

&lt;h3&gt;3.线程&lt;/h3&gt;
&lt;p&gt;我觉得java里面的线程和接下来的JVM是比较难的。&lt;/p&gt;
&lt;p&gt;线程是啥？进程是啥？&lt;/p&gt;
&lt;p&gt;线程的创建过程？线程的状态？&lt;/p&gt;
&lt;p&gt;线程的常用方法：Thread.sleep(), Thread.yield(), t.join(), t.wait(), t.notify(), t.notifyAll() 他们的特点是啥？怎么用？在哪里用？&lt;/p&gt;
&lt;p&gt;面试官常用三连炮：what, where, how.&lt;/p&gt;
&lt;p&gt;如果你准备，那么上面的问题还是easy&lt;/p&gt;
&lt;p&gt;这是就会迁出下面的问题：&lt;/p&gt;
&lt;p&gt;你们的项目里面有用过线程池啥的吗？&lt;/p&gt;
&lt;p&gt;如果你做了一段时间的java开发，线程池都没有用过，面试官估计当场就要在他内心里面打人！！！&lt;/p&gt;
&lt;p&gt;线程池任务缓存排队策略是啥？&lt;/p&gt;
&lt;p&gt;线程池任务拒绝策略是啥？&lt;/p&gt;
&lt;p&gt;线程池创建都用哪些方法？&lt;/p&gt;
&lt;p&gt;一连串的炮轰下来，面试官想要的结果就是，我是面试官，我是最NB的！！！没把你面倒，是他的责任啊！！！&lt;/p&gt;

&lt;h3&gt;4.JVM&lt;/h3&gt;
&lt;p&gt;JVM在面试的时候一定会有的，所以，建议大家看看比较好&lt;/p&gt;
&lt;p&gt;类加载过程是啥？&lt;/p&gt;
&lt;p&gt;类加载层级结构是啥？双亲委派机制你知道吗？优势在哪里？&lt;/p&gt;
&lt;p&gt;Java内存模型原理？特征？&lt;/p&gt;
&lt;p&gt;Synchronized和Volatile的区别？&lt;/p&gt;
&lt;p&gt;内存屏障/栅栏原理？&lt;/p&gt;
&lt;p&gt;哪些内存需要GC？怎样判断？&lt;/p&gt;
&lt;p&gt;内存回收算法？&lt;/p&gt;
&lt;p&gt;经常Full GC,该怎样处理？&lt;/p&gt;
&lt;p&gt;垃圾回收器比较？&lt;/p&gt;
&lt;p&gt;在这里，我建议大家多看书，多总结。毕竟作为一个Java开发人员，知道JVM也是一种工作态度吧！！！&lt;/p&gt;

&lt;h2&gt;第二：框架掌握程度&lt;/h2&gt;
&lt;p&gt;对于框架，我想Hibernate和Spring是非常不错的，特别是他们里面的一些代码设计思想，确实值得我们借鉴。&lt;/p&gt;
&lt;p&gt;框架是给我们使用的，你说你会使用，不要觉得你听NB的，一个零基础的Java开发人员可以在一个月里面，把Hibernate和Spring用的很6&lt;/p&gt;
&lt;p&gt;真正NB的人，绝不会停留在只会使用它们，他们更注重源框架里面的或者底层的东西。&lt;/p&gt;
&lt;h3&gt;1.Hibernate&lt;/h3&gt;
&lt;p&gt;多看源码&lt;/p&gt;
&lt;p&gt;Hibernate的原理？&lt;/p&gt;
&lt;p&gt;一级缓存，二级缓存？&lt;/p&gt;
&lt;p&gt;Hibernate里面的几种状态？&lt;/p&gt;
&lt;p&gt;Hibernate支持的缓存策略？&lt;/p&gt;

&lt;h3&gt;2.Spring&lt;/h3&gt;
&lt;p&gt;多看源码&lt;/p&gt;
&lt;p&gt;Spring工作原理？&lt;/p&gt;
&lt;p&gt;IOC原理？&lt;/p&gt;

&lt;p&gt;总之，框架是给我们使用的，是用的，是用的，是用的。&lt;/p&gt;
&lt;p&gt;多练习，你可以使用的很6；&lt;/p&gt;
&lt;p&gt;多看源码，人们会觉得你技术很6&lt;/p&gt;

&lt;h2&gt;第三：数据库掌握程度&lt;/h2&gt;
&lt;p&gt;在面试的过程中，数据库这块也会被提到的，如果没有数据库，那么你数据存哪里呀？是吧&lt;/p&gt;
&lt;p&gt;MySQL引擎有哪些，特点？&lt;/p&gt;
&lt;p&gt;事务是啥？&lt;/p&gt;
&lt;p&gt;存储过程有听说过吗？优缺点？&lt;/p&gt;
&lt;p&gt;锁的原理？&lt;/p&gt;
&lt;p&gt;索引是啥？优缺点？原理？&lt;/p&gt;
&lt;p&gt;视图原理？&lt;/p&gt;
&lt;p&gt;SQl优化？&lt;/p&gt;
&lt;p&gt;面试官在面试这些的时候，多数会联系你的项目经验来提问。&lt;/p&gt;
&lt;p&gt;始终要清楚：what, where, how&lt;/p&gt;

&lt;h2&gt;第四：数据结构与算法&lt;/h2&gt;
&lt;p&gt;数据结构与算法我想作为程序猿或攻城狮的你，应该说必须要掌握的呀。&lt;/p&gt;

&lt;h3&gt;1.排序算法&lt;/h3&gt;
&lt;p&gt;插入排序&lt;/p&gt;
&lt;p&gt;快速排序&lt;/p&gt;
&lt;p&gt;归并排序&lt;/p&gt;
&lt;p&gt;冒泡排序&lt;/p&gt;
&lt;p&gt;堆排序&lt;/p&gt;
&lt;p&gt;我们需要知道他们的原理，并且能够随意转换为代码实现&lt;/p&gt;

&lt;h3&gt;2.BFS与DFS&lt;/h3&gt;
&lt;p&gt;广度优先搜索与深度优先搜索（对于有些同学仔，看见这个可能会懵逼，这是啥？）&lt;/p&gt;

&lt;h3&gt;3.Tree&lt;/h3&gt;
&lt;p&gt;遍历树&lt;/p&gt;
&lt;p&gt;先序遍历&lt;/p&gt;
&lt;p&gt;中序遍历&lt;/p&gt;
&lt;p&gt;后序遍历&lt;/p&gt;
&lt;p&gt;动态创建树&lt;/p&gt;
&lt;p&gt;树的高度&lt;/p&gt;
&lt;p&gt;树的最大值&lt;/p&gt;
&lt;p&gt;树的最小值&lt;/p&gt;

&lt;h3&gt;4.动态规划&lt;/h3&gt;
&lt;p&gt;动态规划需要大家理解并掌握，思想很重要&lt;/p&gt;

&lt;h3&gt;5.LZ给你出的算法题&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('79fbe233-06c3-48a5-9c43-d8ee21e0c0f5')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_79fbe233-06c3-48a5-9c43-d8ee21e0c0f5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_79fbe233-06c3-48a5-9c43-d8ee21e0c0f5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('79fbe233-06c3-48a5-9c43-d8ee21e0c0f5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_79fbe233-06c3-48a5-9c43-d8ee21e0c0f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 算法题：
 * 给出一个有序的非空数组a，数字target和k，里面涉及到的数都是int类型。
 * 需求：把target插入到数组a里面去，然后求出与target相邻的k个数。如果离target的距离相等，那么取小值（如下面6和10，取值6）。
 * 
 * 举例：
 * 输入：
 * int[] a = {-3, -2, 1, 2, 4, 5, 6, 7, 9, 10, 13, 15, 18, 20, 34};
 * int target = 8;
 * int k = 3;
 * 
 * 输出：
 * 6, 7, 9
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;大家可以到&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/&quot; target=&quot;_blank&quot;&gt;https://leetcode.com/&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;上面去刷题，提高自己的算法能力。&lt;/p&gt;

&lt;p&gt;当你觉得上面的问题都easy，并且在面试的时候有条理的说出来，我想你在web开发面试中薪水要求高一些没毛病。&lt;/p&gt;

&lt;p&gt;若有不正之处，还请多多谅解，并希望批评指正。&lt;/p&gt;
&lt;p&gt;请尊重作者劳动成果，转发请标明blog地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/hongten/p/10635627.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hongten/p/10635627.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;转战大数据&lt;/h2&gt;
&lt;p&gt;可能会有同学仔会问，LZ粉丝超过2000，博客园排名在100左右，技术啥的，应该不错，干嘛还要转大数据方向呢？&lt;/p&gt;
&lt;p&gt;其实主要有一下几个因素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LZ感觉在web方面遇到了瓶颈&lt;/li&gt;
&lt;li&gt;LZ觉得大数据是一种趋势&lt;/li&gt;
&lt;li&gt;LZ喜欢学习新的事物&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1.LZ感觉在web方面遇到了瓶颈&lt;/h2&gt;
&lt;p&gt;LZ在工作了一段时间后，感觉在web方面遇到了瓶颈，正如前文所讲。这种瓶颈导致LZ有一些迷茫，感觉看不到前方的路。&lt;/p&gt;
&lt;p&gt;站在技术层面上来讲，技术是可以通过我们后天努力达到的。我们只要不断的练习，总结，我们的技术就会在短时间内得到飞速提高。&lt;/p&gt;
&lt;p&gt;LZ在过去的一段时间里面做了很多政府网站的开发和维护工作。在此期间也积累了很多实战经验。所以，遇到web方面的问题，基本都能拿下。&lt;/p&gt;
&lt;p&gt;但是，当我们做很多事情的时候，都是用同一的方法，每日重复着相同的动作，做着做着，你会开始怀疑你自己，开始怀疑人生。&lt;/p&gt;
&lt;p&gt;干嘛要这样做？有什么意义？我的目的何在？&lt;/p&gt;

&lt;h2&gt;2.LZ觉得大数据是一种趋势&lt;/h2&gt;
&lt;p&gt;大数据在几年前就开始火起来，并且迅速升温。&lt;/p&gt;
&lt;p&gt;现在是大数据时代了，大数据是一种趋势。&lt;/p&gt;
&lt;p&gt;我们应该赶上大数据这班车才行，否则，是否被淘汰？&lt;/p&gt;

&lt;h2&gt;3.LZ喜欢学习新的事物&lt;/h2&gt;
&lt;p&gt;或许也有一些人想转入大数据，但是不知道从哪方面入手。如果有人给你指出一条路，那么你成功转入大数据，就变的相对容易了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：你需要有编程基础（LZ具备了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：你需要有Linux的基础（知道啥是Linux，基本的命令会敲吧，LZ具备了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：你需要具备学习新的编程语言的能力（比如Python，Scala，LZ很久之前就学习了Python，所以很容易上手-主要针对机器学习，Scala也差不多-主要针对Spark。Scala很好学的，LZ也是在学Spark之前，学习Scala的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：接下来，才是学习大数据。学习Hadoop以及Hadoop的生态圈（Hive，Hbase（Redis），Yarn，Zookeeper，Flume，Kafka）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步&lt;/strong&gt;：学习Spark，Spark-SQL，Spark-Streaming，Storm&lt;/p&gt;
&lt;p&gt;这是LZ自己的学习路线。LZ是从第三步开始的，如果你没有第一步和第二步作为基础，你最终还是会返回来从第一步开始。所以不要走捷径。&lt;/p&gt;
&lt;p&gt;那么，学那么多的东西，到低有啥用呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;技术上，这是你比web开发人员懂得多的地方，即你的知识门槛就高一些&lt;/li&gt;
&lt;li&gt;薪资上，你的知识门槛高了，那么自然你的薪资就会高，LZ花了4个多月的时间完成了第三步到第五步，成功拿到offer的时候，薪资涨了9k+，LZ认为这样的时间投入和汇报还是不错的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你也想成为像LZ这样，在技术上面门槛高一点，薪水多一些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/hongten/1329546/o_hongten_big_data.png&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以通过扫描上面的二维码拿资料，或者加LZ的wx：hongtenzone （备注：big data）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/hongten/1329546/o_hongten_wechat.png&quot; alt=&quot;&quot; width=&quot;244&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你也想在大数据方面发展的话，那么是你行动的时候了&lt;/p&gt;
&lt;p&gt;如果你也想在工资上面有所改善，那么是时候改变你自己了&lt;/p&gt;
&lt;p&gt;12块软妹币，或许就改变不了你今天的生活，但是这些资料，或许会改变你的一生。&lt;/p&gt;

&lt;h2&gt;资料&lt;/h2&gt;
&lt;p&gt;12块软妹币，LZ可以提供的资料有哪些呢？&lt;/p&gt;
&lt;p&gt;1.大数据的学习资料（包括Linux，Hadoop，Spark）一套，LZ就是使用这些资料的，你也可以在网上搜索到其他资料，但是很散。&lt;/p&gt;
&lt;p&gt;2.LZ的技术总结（包括前面提到的Java基础技术总结和大数据知识总结，LZ通过这个技术总结，成功拿到上市公司offer，工资直接涨了9K+）&lt;/p&gt;
&lt;p&gt;3.LZ提供学习过程中的技术指导（如果你在学习大数据的过程中，遇到什么问题，可以随时给LZ讲，LZ尽量第一时间回复你）&lt;/p&gt;
&lt;p&gt;4.LZ也会分享一些面试经验给你，增加你面试的成功率，毕竟LZ是过来人&lt;/p&gt;

&lt;h2&gt;结束语&lt;/h2&gt;
&lt;p&gt;追求卓越，成功就会在不经意间追上你!&lt;/p&gt;
&lt;p&gt;行动起来吧!!!少年!!!&lt;/p&gt;

</description>
<pubDate>Thu, 04 Apr 2019 07:31:00 +0000</pubDate>
<dc:creator>Hongten</dc:creator>
<og:description>大家好，我是Hongten 今天我要给大家分享一下我的个人经历，我从Java Web转大数据，并且成功拿到上市公司Offer，工资直接涨了9K+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongten/p/hongten_big_data_offer.html</dc:identifier>
</item>
<item>
<title>Unity 新手入门 如何理解协程 IEnumerator yield - zhxmdefj</title>
<link>http://www.cnblogs.com/zhxmdefj/p/10655033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxmdefj/p/10655033.html</guid>
<description>&lt;h2 id=&quot;协程是什么能干什么&quot;&gt;协程是什么，能干什么？&lt;/h2&gt;
&lt;p&gt;为了能通俗的解释，我们先用一个简单的例子来看看协程可以干什么&lt;/p&gt;
&lt;p&gt;首先，我突发奇想，要实现一个&lt;strong&gt;倒计时器&lt;/strong&gt;，我可能是这样写的：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    public float sumtime = 3;
    void Update()//Update是每帧调用的
    {
        {
            sumtime -= Time.deltaTime;
            if (sumtime &amp;lt;= 0)
                Debug.Log(&quot;Done!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道，写进 Update() 里的代码会被&lt;strong&gt;每帧调用一次&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;所以，让&lt;strong&gt;总时间&lt;/strong&gt;sumtime在Update()中每一帧减去一个&lt;strong&gt;增量时间&lt;/strong&gt;Time.deltaTime（可以理解成帧与帧的间隔时间）就能实现一个简单的倒计时器&lt;/p&gt;
&lt;p&gt;但是，当我们需要&lt;strong&gt;多个独立的计时器&lt;/strong&gt;时，用同样的思路，我们的代码可能就会写成这样：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    public float sumtime1 = 3;
    public float sumtime2 = 2;
    public float sumtime3 = 1;

    void Update()
    {
        sumtime1 -= Time.deltaTime;
        if (sumtime1 &amp;lt;= 0)
            Debug.Log(&quot;timer1 Done!&quot;);

        sumtime2 -= Time.deltaTime;
        if (sumtime2 &amp;lt;= 0)
            Debug.Log(&quot;timer2 Done!&quot;);

        sumtime3 -= Time.deltaTime;
        if (sumtime3 &amp;lt;= 0)
            Debug.Log(&quot;timer3 Done!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重复度很高，计时器越多看的越麻烦&lt;/p&gt;
&lt;p&gt;然后有朋友可能会提到，我们是不是可以用一个循环来解决这个问题&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;for (float sumtime = 3; sumtime &amp;gt;= 0; sumtime -= Time.deltaTime)
{
    //nothing
}
Debug.Log(&quot;This happens after 5 seconds&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在每一个计时器变量都成为for循环的一部分了，这看上去好多了，而且我不需要去单独设置每一个跌倒变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道&lt;strong&gt;Update()&lt;/strong&gt; 是&lt;strong&gt;每帧调用一次&lt;/strong&gt;的，我们不能把这个循环直接写进Update() 里，更不能写一个方法在Update() 里调用，因为这相当于&lt;strong&gt;每帧开启一个独立的循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，你可能知道我想说什么了，我们正好可以用&lt;strong&gt;协程&lt;/strong&gt;来干这个&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    void Start()
    {
        StartCoroutine(Count3sec());
    }

    IEnumerator Count3sec()
    {
        for (float sumtime = 3; sumtime &amp;gt;= 0; sumtime -= Time.deltaTime)
            yield return 0;
        Debug.Log(&quot;This happens after 3 seconds&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你很可能看不懂上面的几个关键字，但不急，我们一个个解释上面的代码干了什么&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;StartCoroutine(Count3sec());&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;这一句用来开始我们的Count3sec方法&lt;/p&gt;
&lt;p&gt;然后你可能想问的是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IEnumerator 是什么？返回值是什么？&lt;/li&gt;
&lt;li&gt;For循环中的yield return是什么？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;理解以下的话稍有难度，但暂时理解不了问题也不大&lt;/p&gt;
&lt;h3 id=&quot;详细的讲&quot;&gt;详细的讲：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IEnumerator&lt;/strong&gt; 是C#的一个迭代器，你可以把它当成&lt;strong&gt;指向一个序列的某个节点的指针&lt;/strong&gt;，C#提供了两个重要的接口，分别是Current（返回当前指向的元素）和 MoveNext()（将指针向前移动一个单位，如果移动成功，则返回true）IEnumerator是一个interface接口，你不用担心的具体实现&lt;/p&gt;
&lt;p&gt;通常，如果你想实现一个接口，你可以写一个类，实现成员，等等。迭代器块（iterator block） 是一个方便的方式实现IEnumerator，你只需要遵循一些规则，并实现IEnumerator由编译器自动生成。&lt;/p&gt;
&lt;p&gt;一个迭代器块具备如下特征：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回IEnumerator&lt;/li&gt;
&lt;li&gt;使用yield关键字&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么&lt;strong&gt;yield关键字&lt;/strong&gt;是干嘛的？它用来声明序列中的下一个值，或者一个无意义的值。如果使用yield x（x是指一个具体的对象或数值）的话，那么movenext返回为true并且current被赋值为x，如果使用yield break使得movenext()返回false（停止整个协程）&lt;/p&gt;
&lt;p&gt;看不太懂？问题不大&lt;/p&gt;
&lt;h3 id=&quot;简单来说&quot;&gt;简单来说：&lt;/h3&gt;
&lt;p&gt;你现在只需要理解，上面代码中，IEnumerator类型的方法Count3sec就是一个协程，并且可以通过&lt;strong&gt;yield关键字&lt;/strong&gt;控制协程的运行&lt;/p&gt;
&lt;p&gt;一个协程的执行，可以&lt;strong&gt;在任何地方用yield语句来暂停&lt;/strong&gt;，yield return的值决定了&lt;strong&gt;什么时候协程恢复执行&lt;/strong&gt;。通俗点讲，当你&lt;strong&gt;“yield”&lt;/strong&gt;一个方法时，你相当于对这个程序说：“现在停止这个方法，然后在下一帧中，从这里重新开始！”&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;yield return 0;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;然后你可能会问，yield return后面的数字表示什么？比如yield return 10，是不是表示延缓10帧再处理？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并不！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并不！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并不！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yield return 0表示&lt;strong&gt;暂缓一帧&lt;/strong&gt;，也就是让你的程序等待一帧，再继续运行。（不一定是一帧，下面会讲到如何控制等待时间）就算你把这个0换成任意的int类型的值，都是都是表示&lt;strong&gt;暂停一帧，从下一帧开始执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的效果类似于&lt;strong&gt;主线程单独出了一个子线程&lt;/strong&gt;来处理一些问题，而且性能开销较小&lt;/p&gt;
&lt;p&gt;现在你大致学会了怎么开启协程，怎么写协程了，来看看我们还能干点什么：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    IEnumerator count5times()
    {
        yield return 0;
        Debug.Log(&quot;1&quot;);
        yield return 0;
        Debug.Log(&quot;2&quot;);
        yield return 0;
        Debug.Log(&quot;3&quot;);
        yield return 0;
        Debug.Log(&quot;4&quot;);
        yield return 0;
        Debug.Log(&quot;5&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个协程中，我们每隔一帧输出了一次Hello，当然你也可以改成一个循环&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    IEnumerator count5times()
    {
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.Log(&quot;i+1&quot;);
            yield return 0;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点来了，有意思的是，你可以在这里加一个&lt;strong&gt;记录始末状态&lt;/strong&gt;的变量：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    bool isDone = false;
    IEnumerator count5times()
    {
        Debug.Log(isDone);
        for (int i = 0; i &amp;lt; 5; i++)
        {
            Debug.Log(&quot;i+1&quot;);
            yield return 0;
        }
        isDone = true;
        Debug.Log(isDone);
    }

    void Start()
    {
        StartCoroutine(count5times());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易看得出上面的代码实现了什么，也就就是我们一开始的需求，&lt;strong&gt;计时器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个协程方法突出了协程一个“非常有用的，和Update()不同的地方：&lt;strong&gt;方法的状态能被存储&lt;/strong&gt;，这使得方法中定义的这些变量（比如isUpdate）都会保存它们的值，即使是在不同的帧中&lt;/p&gt;
&lt;p&gt;再修改一下，就是一个简单的协程计时器了&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    IEnumerator countdown(int count, float frequency)
    {
        Debug.Log(&quot;countdown START!&quot;);
        for (int i = 0; i &amp;lt; count; i++)
        {
            for (float timer = 0; timer &amp;lt; frequency; timer += Time.deltaTime)
                yield return 0;
        }
        Debug.Log(&quot;countdown DONE!&quot;);
    }
    void Start()
    {
        StartCoroutine(countdown(5, 1.0f));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子我们也能看出，和普通方法一样，协程方法也可以带参数&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;1554346320184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你甚至可以通过yield一个&lt;strong&gt;WaitForSeconds()&lt;/strong&gt;更方便简洁地实现倒计时&lt;/p&gt;
&lt;h3 id=&quot;协程计时器&quot;&gt;协程计时器&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    IEnumerator countdown(float sec)//参数为倒计时时间
    {
        Debug.Log(&quot;countdown START!&quot;);
        yield return new WaitForSeconds(sec);
        Debug.Log(&quot;countdown DONE!&quot;);
    }
    void Start()
    {
        StartCoroutine(countdown(5.0f));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，可能你已经注意到了，yield的用法还是很多的&lt;/p&gt;
&lt;p&gt;在此之前，我们之前的代码yield的时候总是用0（或者可以用null），这仅仅告诉程序在继续执行前等待下一帧。现在你又学会了用yield return new WaitForSeconds(sec)来控制等待时间，你已经可以做更多的骚操作了！&lt;/p&gt;
&lt;p&gt;协程另外强大的一个功能就是，你甚至可以yeild&lt;strong&gt;另一个协程&lt;/strong&gt;，也就是说，你可以&lt;strong&gt;通过使用yield语句来相互嵌套协程&lt;/strong&gt;，&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    IEnumerator SaySomeThings()
    {
        Debug.Log(&quot;The routine has started&quot;);
        yield return StartCoroutine(Wait(1.0f));
        Debug.Log(&quot;1 second has passed since the last message&quot;);
        yield return StartCoroutine(Wait(2.5f));
        Debug.Log(&quot;2.5 seconds have passed since the last message&quot;);
    }
    IEnumerator Wait(float waitsec)
    {
        for (float timer = 0; timer &amp;lt; waitsec; timer += Time.deltaTime)
            yield return 0;
    }
    void Start()
    {
        StartCoroutine(SaySomeThings());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;yield return StartCoroutine(Wait(1.0f));&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;这里的&lt;strong&gt;Wait&lt;/strong&gt;指的是&lt;strong&gt;另一个协程&lt;/strong&gt;，这相当于是说，“暂停执行本程序，等到直到&lt;strong&gt;Wait&lt;/strong&gt;协程结束”&lt;/p&gt;
&lt;h3 id=&quot;协程控制对象行为&quot;&gt;协程控制对象行为&lt;/h3&gt;
&lt;p&gt;根据我们上面讲的特性，协程还能像创建计时器一样方便的控制对象行为，比如&lt;strong&gt;物体运动到某一个位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IEnumerator MoveToPosition(Vector3 target)
    {
        while (transform.position != target)
        {
            transform.position = Vector3.MoveTowards(transform.position, target, moveSpeed * Time.deltaTime);
            yield return 0;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以让上面的程序做更多，不仅仅是一个指定位置，还可以通过数组来给它指定更多的位置，然后通过MoveToPosition() ，可以让它在这些点之间持续运动。&lt;/p&gt;
&lt;p&gt;我们还可以再加入一个bool变量，控制在对象运动到最后一个点时是否要进行循环&lt;/p&gt;
&lt;p&gt;再把上文的Wait()方法加进来，这样就能让我们的对象在某个点就可以选择是否暂停下来，停多久，就像一个正在巡逻的守卫一样 （这里没有实现，各位读者可以尝试自己写一个）&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CoroutineTest : MonoBehaviour
{
    public Vector3[] path;  
    public float moveSpeed;

    void Start()
    {
        StartCoroutine(MoveOnPath(true));
    }

    IEnumerator MoveOnPath(bool loop)
    {
        do
        {
            foreach (var point in path)
                yield return StartCoroutine(MoveToPosition(point));
        }
        while (loop);
    }

    IEnumerator MoveToPosition(Vector3 target)
    {
        while (transform.position != target)
        {
            transform.position = Vector3.MoveTowards(transform.position, target, moveSpeed * Time.deltaTime);
            yield return 0;
        }
    }

    IEnumerator Wait(float waitsec)
    {
        for (float timer = 0; timer &amp;lt; waitsec; timer += Time.deltaTime)
            yield return 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yield其他&quot;&gt;yield其他&lt;/h3&gt;
&lt;p&gt;这里列举了yield后面可以有的表达式&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;null,0,1,...... 暂缓一帧，下一帧继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;WaitForEndOfFrame - the coroutine executes on the frame, after all of the rendering and GUI is complete 等待帧结束&lt;/li&gt;
&lt;li&gt;WaitForFixedUpdate - causes this coroutine to execute at the next physics step, after all physics is calculated 等待一个固定帧&lt;/li&gt;
&lt;li&gt;WaitForSeconds - causes the coroutine not to execute for a given game time period&lt;/li&gt;
&lt;li&gt;WWW - waits for a web request to complete (resumes as if WaitForSeconds or null)&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StartCoroutine(Another coroutine) - in which case the new coroutine will run to completion before the yielder is resumed 等待另一个协程暂停&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;值得注意的是 WaitForSeconds()受Time.timeScale影响，当Time.timeScale = 0f 时，yield return new WaitForSecond(x) 将不会满足&lt;/p&gt;
&lt;h3 id=&quot;停止协程&quot;&gt;停止协程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;StopCoroutine(string methodName);&lt;/li&gt;
&lt;li&gt;StopAllCoroutine();&lt;/li&gt;
&lt;li&gt;设置gameobject的active为false时可以终止协同程序，但是再次设置为true后协程不会再启动。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结一下&quot;&gt;总结一下&lt;/h3&gt;
&lt;p&gt;协程就是：你可以写一段顺序代码，然后标明哪里需要暂停，然后在指定在下一帧或者任意间后，系统会继续执行这段代码&lt;/p&gt;
&lt;p&gt;通过协程我们可以方便的做出一个计时器，甚至利用协程控制游戏物体平滑运动&lt;/p&gt;
&lt;p&gt;如果你刚接触协程，我希望这篇博客能帮助你了解它们是如何工作的，以及如何来使用它们&lt;/p&gt;
&lt;h2 id=&quot;深入讲一下&quot;&gt;深入讲一下&lt;/h2&gt;
&lt;p&gt;待更新&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 07:18:00 +0000</pubDate>
<dc:creator>zhxmdefj</dc:creator>
<og:description>Unity 新手入门 如何理解协程 IEnumerator yield 协程是什么，能干什么？ 为了能通俗的解释，我们先用一个简单的例子来看看协程可以干什么 首先，我突发奇想，要实现一个 倒计时器 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhxmdefj/p/10655033.html</dc:identifier>
</item>
<item>
<title>为什么要抛弃Pact？如何快速实现契约测试（CDC） - 隔壁王书</title>
<link>http://www.cnblogs.com/dc20181010/p/10654965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dc20181010/p/10654965.html</guid>
<description>&lt;p&gt;在前几天的博客中，我转载了一篇文章，其中介绍了契约测试和pact是怎么实施的，的确很有帮助。但我经过研究，其实是pact本身也是有缺陷的，结合我近期在使用的服务型工具和我的实际情况，觉得实现契约测试其实有更有效率的解决方案，本文就通过我的视角看看我是如何快速实现契约测试的。&lt;/p&gt;

&lt;p&gt;因为前后端对接的过程中会出现信息不对称，以及工作进度不一致的情况，因此希望通过事先约定好API返回数据的文档，根据文档来开发后端代码，以及生产可以被前端调用的虚拟的API，帮助前后端能够同时开展工作并且保持前后端代码的正确性，加快后期的系统集成测试甚至是取消系统集成测试。&lt;/p&gt;
&lt;p&gt;我们将以上的做法称之为契约测试。契约测试最开始的概念由 Martin Fowler 提出，它又被称之为：消费者驱动的契约测试（Consumer Driven Contracts），简称CDC。这里的契约是指软件系统中各个服务间交互的数据标准格式，更多的指消费端（client）和提供端（server）之间交互的API的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;契约测试带来的变化主要是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.将前后端测试解耦，前后端可以分别在对方还没有完成工作的时候就开展测试；&lt;/p&gt;
&lt;p&gt;2.将测试过程前移，加速或者取代集成测试；&lt;/p&gt;
&lt;p&gt;3.保证数据的一致性，让后端服务返回的数据就是前端想要得到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我做了一张图方便大家理解CDC的概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142608490-13174213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上图经历了三个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.消费者（广义的前端）根据业务需要编写好契约文件，契约文件里面编写了需要返回的数据；&lt;/p&gt;
&lt;p&gt;2.消费者（广义的前端）向契约文件（实际上是一个API服务）发起请求，得到预期的结果，验证前端业务逻辑是否正确；&lt;/p&gt;
&lt;p&gt;3.契约文件（实际上是一个API服务）向提供者（广义的后端）发起请求，得到后端真实的返回结果并且与契约文件中的数据规则进行校验，判断后端返回的数据是否满足契约的要求。如果无法通过校验，说明提供者的服务发生了改变，或者是没有按照契约所规定的来进行开发。&lt;/p&gt;

&lt;p&gt;如果通过了上面的三步，我们可以认为前后端对于契约的理解和实现是一致的，等到真正集成之后也不会出现问题。&lt;/p&gt;

&lt;p&gt;之前业内较为常见的做法是通过Pact（一个契约测试框架）进行契约测试：通过前端开发人员编写代码进行测试并生成Pact契约文件，后端通过Pact Brocker等服务管理契约以及调用等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是Pact也存在一些缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.需要引入Pact的相关文件以及正确搭建服务，用起来需要一定的时间成本&lt;/p&gt;
&lt;p&gt;2.生成的返回数据不够灵活，无法编写代码生成复杂的随机数据；&lt;/p&gt;
&lt;p&gt;3.无法判断请求参数来返回不同的结果；&lt;/p&gt;
&lt;p&gt;4.需要开发人员额外编写代码，增加了工作量；&lt;/p&gt;
&lt;p&gt;5.存在代码入侵的情况，并且目前支持的语言较少；&lt;/p&gt;
&lt;p&gt;6.模糊了开发与测试人员之间的界限，管理不当容易导致重复劳动；&lt;/p&gt;

&lt;p&gt;由于有以上的不足之处，Pact 在实际应用的效果往往并不理解。因此我们提出了通过 Mock API 以及测试用例实现更快速、更有效地契约测试。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://s.growingio.com/ddx3bP&quot; target=&quot;_blank&quot;&gt;EOLINKER API Studio（https://www.eolinker.com）&lt;/a&gt; 提供了UI实现的 Mock API，配合API Studio 的测试用例与自动化测试，可以帮助研发团队更快速、更有效地实现契约测试。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;什么是Mock API？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过 Mock API，您可以事先编写好 API 的数据生成规则，由 API Studio 动态生成 API 的返回数据。开发人员通过访问 Mock API 的 URL 来获得所需要的数据，完成对接工作。&lt;/p&gt;
&lt;p&gt;在 API Studio中，同一个项目中的 Mock API 的地址前缀是相同的（如mock.eolinker.com/uasyd1/…），因此可以在代码中将 Mock API 的地址前缀作为全局变量，项目上线时仅需替换变量的值即可改变整个项目的 API 请求地址前缀。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142711771-310907535.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;创建Mock API，实现前端的契约测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在EOLINKER API Studio中，创建 Mock API 之前需要先创建API文档（或者导入Postman、Swagger等数据），API文档可以作为前后端对接的依据。这里我创建了一个简单的用户登录API文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142751075-924182036.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建好API文档之后，点击 Mock API 标签进入Mock API的管理页面，在这里可以快速创建多个Mock API，并且根据不同的请求参数返回相应的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142815888-433978966.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个 Mock API 期望，我们希望当传递user_name=******和user_psw=112233时，Mock Server返回登录成功的数据，这里返回的数据类型选择Json，填写好Json的格式以及内容即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142847375-322329927.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击预览按钮可以看到是我们希望得到的返回数据，然后确定保存即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142915028-919242677.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这种方式可以创建多个Mock API，并且通过请求红框处的 Mock API URL 得到返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404142939876-36075236.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;API Studio 中也提供了强大的 API 测试的功能，我们直接在平台上对刚才的登录成功的 Mock API 发起请求，可以看到当我们传递正确的参数时，可以得到预期的返回结果，至此契约测试的前端契约就已经完成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404143006850-1162069688.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;创建测试用例，实现后端的契约测试：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;传统的契约测试其实并不能够保证测试的覆盖率，因为前端开发人员提供的契约文件很可能无法覆盖所有的请求情况，导致出现漏测的情况。&lt;/p&gt;
&lt;p&gt;因此 API Studio 建议将后端的契约测试交给测试人员负责，这样可以提供更完善的测试用例，并且可以结合各类CI工具实现自动化测试。&lt;/p&gt;
&lt;p&gt;由于 API Studio 基于 API 文档来实现契约测试、API用例测试、API自动化测试等功能，因此可以将前端、后端、测试人员解耦，工作的流程可以进一步改进为下图所示，前后端、测试人员可以同时开展工作，并且测试用例可以导入到自动化测试中成为长期的定时测试任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506969/201904/1506969-20190404143052176-956146465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于测试用例与自动化测试所包含的内容较多，如有需要可以前往 EOLINKER API Studio 官方网站（&lt;a href=&quot;http://www.eolinker.com?ref=cnblogs&quot; target=&quot;_blank&quot;&gt;https://www.eolinker.com&lt;/a&gt;）或者是查阅 API Studio 帮助文档，在此不再赘述。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 07:07:00 +0000</pubDate>
<dc:creator>隔壁王书</dc:creator>
<og:description>前言 在前几天的博客中，我转载了一篇文章，其中介绍了契约测试和pact是怎么实施的，的确很有帮助。但我经过研究，其实是pact本身也是有缺陷的，结合我近期在使用的服务型工具和我的实际情况，觉得实现契约</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dc20181010/p/10654965.html</dc:identifier>
</item>
<item>
<title>【故障公告】阿里云抢占式实例服务器被自动释放引发的故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/10654134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/10654134.html</guid>
<description>&lt;p&gt;非常抱歉，由于一台使用阿里云抢占式实例的缓存服务器被自动释放，造成今天 10:20-11:30 左右网站无法正常访问，由此给您带来很大的麻烦，恳请您的谅解。&lt;/p&gt;
&lt;p&gt;这台阿里云抢占式实例服务器的出价方式是“使用自动出价”，之前我们使用这种出价方式的阿里云抢占式实例从来没有被自动释放过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35695/201904/35695-20190404121549248-921270161.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而购买页面的提示“使用自动出价-以按量付费实例规格价格为上限”，让我们误以为自动出价的抢占式实例不会被释放，最多只会以按量付费实例的价格收费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35695/201904/35695-20190404133827186-1821468485.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;昨天下午 14:50 左右，收到了阿里云的通知短信与邮件：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;【阿里云】尊敬的用户，您好！您的抢占式实例: i-bp1938t1plpkzggc5jd1(couchbase)  因库存变化,  即将进入释放状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;您好！您的抢占式实例: i-bp1938t1plpkzggc5jd1已标记进入即将进入释放状态，5分钟后会自动释放。&lt;/p&gt;&lt;p&gt;建议您使用关机脚本来保存您的应用数据。谢谢!&lt;/p&gt;&lt;p&gt;阿里云计算有限公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;收到通知时觉得很奇怪，自动出价的服务器怎么会被释放？难道是阿里云的误通知？&lt;/p&gt;
&lt;p&gt;为了以防万一，当时准备换服务器，但过了5分钟后发现那台服务器还在，没被释放，于是就真以为是阿里云的误通知。&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;p&gt;今天出故障时发现数据库服务器压力非常大，在排查过程中突然想到昨天阿里云释放服务器的通知，赶紧查看，汗，那台服务器没了。&lt;/p&gt;
&lt;p&gt;原来阿里云在后来的某个时间将那台服务器“偷偷”释放了（释放时没有发任何通知），而且这样的释放不会触发阿里云云监控的报警，再加上我们缺少对缓存服务器的专门监控，结果在服务器被释放后我们没有及时发现，造成今天在访问高峰时数据库服务器压力过大，从而引发故障。&lt;/p&gt;
&lt;p&gt;我们会吸取这次教训，改进服务器的部署。&lt;/p&gt;
&lt;p&gt;后来，向阿里云提交工单后才知道&quot;当市场价格高于您的出价或者资源供需关系变化时，实例会被自动释放&quot;也适用于“使用自动出价”的方式，自动出价不会出现“市场价格高于您的出价”的情况，但会出现“资源供需关系变化”的情况（比如阿里云库存服务器不够用），这时阿里云就会在已购买的竞价服务器中“抢占”一些据为己有。&lt;/p&gt;
&lt;p&gt;通过这次教训也终于明白了为什么阿里云把当初的“竞价实例”改名为“抢占式实例”。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 06:30:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>非常抱歉，由于一台使用阿里云抢占式实例的缓存服务器被自动释放，造成今天 10:20-11:30 左右网站无法正常访问，由此给您带来很大的麻烦，恳请您的谅解。 这台阿里云抢占式实例服务器的出价方式是“使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/10654134.html</dc:identifier>
</item>
<item>
<title>KVM虚拟化使用详解--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10550350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10550350.html</guid>
<description>
&lt;h2&gt;KVM介绍&lt;/h2&gt;

&lt;p&gt;Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。&lt;/p&gt;
&lt;p&gt;KVM的虚拟化需要硬件支持(如Intel VT技术或者AMD V技术)。是基于硬件的完全虚拟化。&lt;/p&gt;

&lt;p&gt;虚拟化是云计算的基础。虚拟化可以满足在一台物理的服务器上运行多个虚拟机。虚拟机共享物理机的 CPU、内存、IO 硬件资源，但逻辑上虚拟机之间是相互隔离的。&lt;/p&gt;
&lt;p&gt;物理机我们一般称为宿主机（Host），宿主机上面的虚拟机称为客户机（Guest）。&lt;/p&gt;

&lt;h2&gt;虚拟化分类&lt;/h2&gt;

&lt;p&gt;虚拟化分为两种：1型虚拟化和2型虚拟化。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1型虚拟化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。Hypervisor 实现方式一般是一个特殊定制的 Linux 系统。Xen 和 VMWare 的 ESXi 都属于这个类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201904/1499615-20190404155452530-1876543523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;2型虚拟化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;物理机上首先安装常规的操作系统，比如 Redhat、Ubuntu 和 Windows。Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。KVM、VirtualBox 和 VMWare Workstation 都属于这个类型。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201904/1499615-20190404155511564-801457176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;理论上讲：&lt;/p&gt;
&lt;p&gt;1型虚拟化一般对硬件虚拟化功能进行了特别优化，性能上比2型要高；&lt;/p&gt;
&lt;p&gt;2型虚拟化因为基于普通的操作系统，会比较灵活，比如支持虚拟机嵌套。嵌套意味着可以在KVM虚拟机中再运行KVM。&lt;/p&gt;



&lt;h2&gt;部署KVM&lt;/h2&gt;

&lt;p&gt;环境准备&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318113709266-2089552704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;确认开启虚拟化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# grep -E &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(vmx)|(svm)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /proc/&lt;span&gt;cpuinfo 
flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc art rep_good nopl tsc_reliable nonstop_tsc extd_apicid aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw retpoline_amd vmmcall fsgsbase bmi1 avx2 smep bmi2 rdseed adx smap xsaveopt clzero irperf xsaveerptr ibpb arat nptsvm_lock nrip_save vmcb_clean flushbyasid decodeassists&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一步：下载相关软件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install libvirt virt-install qemu-kvm -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;libvirt :  KVM 的管理工具。Libvirt 包含 3 个东西：后台 daemon 程序 libvirtd、API 库和命令行工具 virsh&lt;/p&gt;
&lt;p&gt;qemu-kvm：KVM 和 QEMU 的核心包，提供 CPU、内存和 IO 虚拟化功能&lt;/p&gt;
&lt;p&gt;virt-install是一个命令行工具，它能够为KVM、Xen或其它支持libvrit API的hypervisor创建虚拟机并完成GuestOS安装&lt;/p&gt;

&lt;p&gt;第二步：启动libvirt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart libvirtd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：创建磁盘&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# qemu-img create -f raw /ken/centos7-&lt;span&gt;x86_64.raw 10G
Formatting &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ken/centos7-x86_64.raw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fmt=raw size=&lt;span&gt;10737418240&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：创建虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virt-install --virt-type kvm --name Centos7-x86_64 --ram &lt;span&gt;1024&lt;/span&gt; --cdrom=/tmp/CentOS-&lt;span&gt;7.3&lt;/span&gt;-x86_64-Minimal-&lt;span&gt;1511&lt;/span&gt;.iso --disk path=/ken/centos7-x86_64.raw --network network=&lt;span&gt;default&lt;/span&gt; --graphics vnc,listen=&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt; --noautoconsole
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：需要上传一个镜像到/tmp目录下，其他目录也可以，上面指定即可&lt;/p&gt;

&lt;p&gt;第五步：快速使用VNC进行连接&lt;/p&gt;
&lt;p&gt;ip地址输入虚拟机ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318114420881-739383742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;开始安装系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318114626067-717413964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;定制化系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318114754403-1985228052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;开始安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318114843531-355882964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第六步：查看已经创建的虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;[root@ken ~]# virsh list --all&lt;br/&gt;Id Name State&lt;br/&gt;----------------------------------------------------&lt;br/&gt;- Centos7-x86_64 shut off&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;第七步：启动虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh start Centos7-&lt;span&gt;x86_64
Domain Centos7&lt;/span&gt;-&lt;span&gt;x86_64 started

[root@ken &lt;/span&gt;~]# virsh list --&lt;span&gt;all
 Id    Name                           State
&lt;/span&gt;----------------------------------------------------
 &lt;span&gt;2&lt;/span&gt;     Centos7-x86_64                 running
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第八步：使用VNC再次连接&lt;/p&gt;
&lt;p&gt;现在就可以登录进去我们创建的虚拟机里面去了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318131514067-1720128368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第九步：ssh连接&lt;/p&gt;
&lt;p&gt;宿主机上连接&lt;/p&gt;
&lt;p&gt;首先查看新建虚拟机IP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318131658974-1938547574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 宿主机进行连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ssh &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.198&lt;/span&gt;&lt;span&gt;
The authenticity of host &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.122.198 (192.168.122.198)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; can&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t be established.&lt;/span&gt;
ECDSA key fingerprint &lt;span&gt;is&lt;/span&gt; SHA256:t+jpHwwHJk8mo2XZB93H9afhSVy7BCMvLsvqsUF+&lt;span&gt;Obg.
ECDSA key fingerprint &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; MD5:&lt;span&gt;48&lt;/span&gt;:d5:9e:db:f8:bb:5e:&lt;span&gt;56&lt;/span&gt;:c1:c8:1d:a2:4b:&lt;span&gt;45&lt;/span&gt;&lt;span&gt;:d6:fc.
Are you sure you want to &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; connecting (yes/no)?&lt;span&gt; yes
Warning: Permanently added &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.122.198&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; (ECDSA) to the list of known hosts.
root@&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.198&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s password: &lt;/span&gt;
Last login: Mon Mar &lt;span&gt;18&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;&lt;span&gt;
[root@localhost &lt;/span&gt;~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt;&lt;span&gt; qdisc noqueue state UNKNOWN 
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UP qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;52&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;89&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;span&gt;:d7 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.198&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.255&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt; &lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt; eth0
       valid_lft 3510sec preferred_lft 3510sec
    inet6 fe80::&lt;/span&gt;&lt;span&gt;5054&lt;/span&gt;:ff:fe89:17d7/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;登录退出虚拟机&lt;/h2&gt;

&lt;p&gt;第一步：在创建的KVM虚拟机里面执行如下的命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# grubby --update-kernel=ALL --args=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;console=ttyS0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：重启KVM虚拟机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318142754076-937132168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：使用virsh console登录登录虚拟机&lt;/p&gt;
&lt;p&gt;执行virsh console 虚拟机名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh console Centos7-&lt;span&gt;x86_64
Connected to domain Centos7&lt;/span&gt;-&lt;span&gt;x86_64
Escape character &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; ^&lt;span&gt;]    #到这步再次按回车

CentOS Linux &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; (Core)
Kernel &lt;/span&gt;&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;327&lt;/span&gt;&lt;span&gt;.el7.x86_64 on an x86_64

localhost login: root     #输入用户
Password:                 #密码
Last login: Mon Mar &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt;&lt;span&gt; on ttyS0
[root@localhost &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：退出KVM虚拟机&lt;/p&gt;
&lt;p&gt;按这两个组合键，按ctrl加上中括号的右边： ctrl+]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh console Centos7-&lt;span&gt;x86_64
Connected to domain Centos7&lt;/span&gt;-&lt;span&gt;x86_64
Escape character &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; ^&lt;span&gt;]

CentOS Linux &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; (Core)
Kernel &lt;/span&gt;&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;327&lt;/span&gt;&lt;span&gt;.el7.x86_64 on an x86_64

localhost login: root
Password: 
Last login: Mon Mar &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;&lt;span&gt; on ttyS0
[root@localhost &lt;/span&gt;~&lt;span&gt;]# 
[root@ken &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;克隆虚拟机&lt;/h2&gt;

&lt;p&gt;第一步：关闭虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh shutdown Centos7-&lt;span&gt;x86_64
Domain Centos7&lt;/span&gt;-x86_64 &lt;span&gt;is&lt;/span&gt;&lt;span&gt; being shutdown

[root@ken &lt;/span&gt;~]# virsh list --&lt;span&gt;all
 Id    Name                           State
&lt;/span&gt;----------------------------------------------------
 -     Centos7-x86_64                 shut off
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步: 创建磁盘位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# mkdir /ken/img
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：使用virt-clone克隆新的虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virt-clone -o Centos7-x86_64 -n centos7_test -f /ken/img/&lt;span&gt;centos7_test.img
Allocating &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;centos7_test.img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                                                                                  |  &lt;span&gt;10&lt;/span&gt; GB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;&lt;span&gt;     

Clone &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;centos7_test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; created successfully.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：查看虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh list --&lt;span&gt;all
 Id    Name                           State
&lt;/span&gt;----------------------------------------------------
 -     Centos7-&lt;span&gt;x86_64                 shut off
 &lt;/span&gt;-     centos7_test                   shut off
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第五步：启动虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# virsh start centos7_test 
Domain centos7_test started

[root@ken &lt;/span&gt;~]# virsh list --&lt;span&gt;all
 Id    Name                           State
&lt;/span&gt;----------------------------------------------------
 &lt;span&gt;3&lt;/span&gt;     centos7_test                   running
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第六步：进入虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# virsh console centos7_test
Connected to domain centos7_test
Escape character &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; ^&lt;span&gt;]

CentOS Linux &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; (Core)
Kernel &lt;/span&gt;&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;327&lt;/span&gt;&lt;span&gt;.el7.x86_64 on an x86_64


localhost login: root
Password: 
Last login: Mon Mar &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;&lt;span&gt; on ttyS0
[root@localhost &lt;/span&gt;~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt;&lt;span&gt; qdisc noqueue state UNKNOWN 
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UP qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;52&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:cc:&lt;span&gt;69&lt;/span&gt;&lt;span&gt;:f8 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.161&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.255&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt; &lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt; eth0
       valid_lft 3597sec preferred_lft 3597sec
    inet6 fe80::&lt;/span&gt;&lt;span&gt;5054&lt;/span&gt;:ff:fecc:69f8/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;xshell连接虚拟机&lt;/h2&gt;

&lt;p&gt;现在物理主机是ping不通KVM虚拟机的，只有宿主机可以和KVM通信&lt;/p&gt;

&lt;p&gt;第一步：创建脚本并执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# cat bridg.sh 
#&lt;/span&gt;!/bin/&lt;span&gt;bash
brctl addbr br0  #创建桥接网卡
brctl addif br0 eth0 #把eth0加入到br0中
ip a d &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.190&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt; dev eth0 #删除eth0的IP地址
ifconfig br0 &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.190&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt; up  #启动br0网络
route add &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; gw &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.1  #添加网关&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：查看网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318153345601-1104104553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：测试外网连通性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ping www.baidu.com
PING www.a.shifen.com (&lt;/span&gt;&lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt; (&lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt;): icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;54&lt;/span&gt; time=&lt;span&gt;6.08&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt; (&lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt;): icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;54&lt;/span&gt; time=&lt;span&gt;9.20&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes &lt;span&gt;from&lt;/span&gt; &lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt; (&lt;span&gt;119.75&lt;/span&gt;.&lt;span&gt;217.26&lt;/span&gt;): icmp_seq=&lt;span&gt;3&lt;/span&gt; ttl=&lt;span&gt;54&lt;/span&gt; time=&lt;span&gt;8.58&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;^&lt;span&gt;C
&lt;/span&gt;--- www.a.shifen.com ping statistics ---
&lt;span&gt;3&lt;/span&gt; packets transmitted, &lt;span&gt;3&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;%&lt;span&gt; packet loss, time 6020ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;6.087&lt;/span&gt;/&lt;span&gt;7.957&lt;/span&gt;/&lt;span&gt;9.201&lt;/span&gt;/&lt;span&gt;1.346&lt;/span&gt; ms
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：编辑虚拟机&lt;/p&gt;
&lt;p&gt; 修改如下的三处位置即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# virsh edit Centos7-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201903/1499615-20190318153723568-1437337068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第五步: 启动KVM虚拟机并进入KVM虚拟机编辑网卡&lt;/p&gt;
&lt;p&gt;配置一个与物理主机同网段的网络&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-&lt;span&gt;eth0 
TYPE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ethernet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
BOOTPROTO&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
DEVICE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ONBOOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
IPADDR&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.165&lt;/span&gt;&lt;span&gt;
NETMASK&lt;/span&gt;=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
GATEWAY&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.1&lt;/span&gt;&lt;span&gt;
DNS1&lt;/span&gt;=&lt;span&gt;8.8&lt;/span&gt;.&lt;span&gt;8.8&lt;/span&gt;&lt;span&gt;
[root@localhost &lt;/span&gt;~]# systemctl restart network
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第六步：xshell连接KVM虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Connecting to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.165&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;...
Connection established.
To escape to local shell, press &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ctrl+Alt+]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.

WARNING&lt;/span&gt;!&lt;span&gt; The remote SSH server rejected X11 forwarding request.
Last login: Mon Mar &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;33&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;&lt;span&gt;
[root@localhost &lt;/span&gt;~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt;&lt;span&gt; qdisc noqueue state UNKNOWN 
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UP qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;52&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;89&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;span&gt;:d7 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.165&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.255&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::&lt;/span&gt;&lt;span&gt;5054&lt;/span&gt;:ff:fe89:17d7/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 04 Apr 2019 06:06:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>KVM介绍 Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。 KVM的虚拟化需要硬件支持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10550350.html</dc:identifier>
</item>
<item>
<title>Restful架构思想 - 帅娃</title>
<link>http://www.cnblogs.com/yshang/p/10654491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yshang/p/10654491.html</guid>
<description>&lt;p&gt;　　java作为一门后端语言，其厉害之处在于web，大家比较熟知的各种网络应用，java都能做，那么在这个移动优先的时代，如何继续发挥java的强大呢。通常是让java作为一个app的服务端，为app客户端提供数据，做业务逻辑，所以我们用java来写接口，app客户端访问接口返回json文件进行解析，最后实现业务逻辑。这种方式就是我们通常所说的restful架构风格的api。&lt;/p&gt;
&lt;p&gt;　　restful是一种架构思想，最初由Roy T. Fielding（HTTP/1.1协议专家组负责人）在其2000年的博士学位论文中提出。HTTP就是该架构风格的一个典型应用，其核心思想就是前后端分离，前端通过http请求，如www.xxxx.com/demo/username/password  来访问后端的接口，然后后端将处理好的数据封装为json返回，这样，后端只需关注具体逻辑 提供接口，而前端只关心界面，提高了程序解耦性。 在移动优先的时代，restful极为重要。通常一套后台可以让多种终端访问,包括移动端，pc端。通过restful改进的mvc    在java中比较容易实现restful的是SpringMVC框架，他提供了一套处理json的注解。通过@ResponseBody返回json数据，通过@ResquestBody解析json。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/910770/201904/910770-20190404122848009-406490929.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个ios访问我的java后台demo，java后台采用了springMVC和Hibernate。&lt;/p&gt;
&lt;p&gt;//java端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cotroller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; jdk.nashorn.api.scripting.JSObject;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model.Student;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model.Teacher;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestBody;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.ResponseBody;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dao.Get;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dao.StudentDAO;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;登陆servlet&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginCotroller {    
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * 1. value=&quot;/doLogin/{username}/{password}&quot; 拦截 xxx/doLogin/xx/xx
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * 2. @ResponseBody 使用此注解将返回数据类型封装json
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * 3. @PathVariable(&quot;username&quot;) 截取请求1.value中{username}的值
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     * 4. Map&amp;lt;String, Object&amp;gt; 服务端将值放入map中再封装为json,客户端方便通过key取出value
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     StudentDAO studentDAO = &lt;span&gt;new&lt;/span&gt; StudentDAO();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用登陆判断方法&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     
&lt;span&gt;38&lt;/span&gt;     @RequestMapping(value=&quot;/doLogin/{username}/{password}&quot;,method=&lt;span&gt;RequestMethod.GET)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getTeacher(@PathVariable(&quot;username&quot;) Integer username, @PathVariable(&quot;password&quot;&lt;span&gt;) String password){    
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         System.out.println(&quot;拦截了客户端json请求&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         Map&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(studentDAO.loginByStudent(username, password)){
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             System.out.println(&quot;密码正确&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             map.put(&quot;result&quot;, &quot;1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; map; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装为json返回给客户端&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             
&lt;span&gt;50&lt;/span&gt;         System.out.println(&quot;密码错误&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         map.put(&quot;result&quot;, &quot;0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; map; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装为json返回给客户端&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;//ios端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #&lt;span&gt;import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;import&lt;/span&gt; &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[]) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @autoreleasepool {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; oldUsername[128&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; oldPassword[128&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         NSLog(@&quot;请输入用户名 ：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         scanf(&quot;%s&quot;&lt;span&gt;, oldUsername);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         NSString *username = [NSString stringWithUTF8String:oldUsername]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为NSString *&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         NSLog(@&quot;请输入密码 ：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         scanf(&quot;%s&quot;&lt;span&gt;, oldPassword);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         NSString *password = [NSString stringWithUTF8String:oldPassword]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为NSString *
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问springMVC后台并解析返回的json数据
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个异常&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         NSError *&lt;span&gt;error;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义请求action 使用stringWithFormat拼接字符串&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         NSString *url = [NSString stringWithFormat:@&quot;http://154212l6t7.imwork.net:27063/partyOS_APP/doLogin/%@/%@&quot;&lt;span&gt;, username, password];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载一个NSURL对象&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         NSURLRequest *request =&lt;span&gt; [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求 将请求的url数据放到NSData对象中&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         NSData *response =&lt;span&gt; [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;NSJSONSerialization从response请求中解析出数据放到字典中&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         NSDictionary *jsonResult = [NSJSONSerialization JSONObjectWithData:response options:NSJSONReadingMutableLeaves error:&amp;amp;&lt;span&gt;error];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt;         NSString *resultValue = [jsonResult objectForKey:@&quot;result&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt;         NSLog(@&quot;你的url是%@&quot;&lt;span&gt;, url);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         NSLog(@&quot;服务端返回值%@&quot;&lt;span&gt;, resultValue);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; oc字符串比较方法 resultValue isEqualToString:@&quot;1&quot;] 和java 的equlse类似&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;([resultValue isEqualToString:@&quot;1&quot;&lt;span&gt;]){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             NSLog(@&quot;登录成功!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             NSLog(@&quot;登录失败,用户名或密码错误!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt;         
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fight！！！！！！！！&lt;/p&gt;
</description>
<pubDate>Thu, 04 Apr 2019 05:59:00 +0000</pubDate>
<dc:creator>帅娃</dc:creator>
<og:description>java作为一门后端语言，其厉害之处在于web，大家比较熟知的各种网络应用，java都能做，那么在这个移动优先的时代，如何继续发挥java的强大呢。通常是让java作为一个app的服务端，为app客户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yshang/p/10654491.html</dc:identifier>
</item>
</channel>
</rss>