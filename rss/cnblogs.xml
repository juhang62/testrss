<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.Net Core微服务入门全纪录（五）——Ocelot-API网关（下） - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13132255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13132255.html</guid>
<description>&lt;p&gt;上一篇【&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13092535.html&quot;&gt;.Net Core微服务入门全纪录（四）——Ocelot-API网关（上）&lt;/a&gt;】已经完成了Ocelot网关的基本搭建，实现了服务入口的统一。当然，这只是API网关的一个最基本功能，它的进阶功能还有很多很多。&lt;/p&gt;

&lt;p&gt;首先需要解决的就是服务发现的问题，服务发现的优点之前讲过，就不说了。&lt;br/&gt;上一篇中我们的服务地址都是写在ocelot.json配置文件里，现在我们需要结合之前的Consul来实现服务发现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;改造代码：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先NuGet安装&lt;code&gt;Ocelot.Provider.Consul&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200615213448863-1043664447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改Startup.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            //添加ocelot服务
            services.AddOcelot()
                .AddConsul();//添加consul支持
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改ocelot.json配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Routes&quot;: [
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;ProductService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      }
    },
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;OrderService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      }
    }
  ],
  &quot;GlobalConfiguration&quot;: {
    &quot;BaseUrl&quot;: &quot;http://localhost:9070&quot;,
    &quot;ServiceDiscoveryProvider&quot;: {
      &quot;Scheme&quot;: &quot;http&quot;,
      &quot;Host&quot;: &quot;localhost&quot;,
      &quot;Port&quot;: 8500,
      &quot;Type&quot;: &quot;Consul&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个配置应该很好理解，就是把我们上次的DownstreamHostAndPorts节点去掉了，然后增加了ServiceDiscoveryProvider服务发现相关配置。&lt;br/&gt;注意，Ocelot除了支持Consul服务发现以外，还有Eureka也可以，Eureka也是一个类似的注册中心。&lt;/p&gt;
&lt;p&gt;好了，代码修改就差不多了，下面运行程序测试一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200615221633113-1526943266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200615221920176-9130658.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;客户端正常运行。&lt;/p&gt;
&lt;p&gt;至此我们就实现了服务注册与发现和api网关的基本功能。接下来就要提到：&lt;strong&gt;服务治理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实服务治理也没有一个非常明确的定义。它的作用简单来说，就是帮助我们更好的管理服务，提升服务的可用性。——缓存，限流，熔断，链路追踪 等等。。。都属于常用的服务治理手段。&lt;br/&gt;之前讲的负载均衡，服务发现也可以算是服务治理。&lt;/p&gt;
&lt;p&gt;在Ocelot中启用缓存，需要NuGet安装一下&lt;code&gt;Ocelot.Cache.CacheManager&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200616201422921-1718170282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改Startup.cs中的ConfigureServices()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//添加ocelot服务
services.AddOcelot()
    //添加consul支持
    .AddConsul()
    //添加缓存
    .AddCacheManager(x =&amp;gt;
    {
        x.WithDictionaryHandle();
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改ocelot.json配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Routes&quot;: [
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;ProductService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      },
      &quot;FileCacheOptions&quot;: {
        &quot;TtlSeconds&quot;: 5,
        &quot;Region&quot;: &quot;regionname&quot;
      }
    },
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;OrderService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      },
      &quot;FileCacheOptions&quot;: {
        &quot;TtlSeconds&quot;: 5,
        &quot;Region&quot;: &quot;regionname&quot;
      }
    }
  ],
  &quot;GlobalConfiguration&quot;: {
    &quot;BaseUrl&quot;: &quot;http://localhost:9070&quot;,
    &quot;ServiceDiscoveryProvider&quot;: {
      &quot;Scheme&quot;: &quot;http&quot;,
      &quot;Host&quot;: &quot;localhost&quot;,
      &quot;Port&quot;: 8500,
      &quot;Type&quot;: &quot;Consul&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Routes路由配置中增加了FileCacheOptions。TtlSeconds代表缓存的过期时间，Region代表缓冲区名称，这个我们目前用不到。&lt;/p&gt;
&lt;p&gt;好了，代码修改完需要编译重启一下网关项目，然后打开客户端网站测试一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200616203849105-1496099469.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到，5秒之内的请求都是同样的缓存数据。Ocelot也支持自定义缓存。&lt;/p&gt;
&lt;p&gt;限流就是限制客户端一定时间内的请求次数。&lt;br/&gt;继续修改配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Routes&quot;: [
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/products&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;ProductService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      },
      &quot;FileCacheOptions&quot;: {
        &quot;TtlSeconds&quot;: 5,
        &quot;Region&quot;: &quot;regionname&quot;
      },
      &quot;RateLimitOptions&quot;: {
        &quot;ClientWhitelist&quot;: [ &quot;SuperClient&quot; ],
        &quot;EnableRateLimiting&quot;: true,
        &quot;Period&quot;: &quot;5s&quot;,
        &quot;PeriodTimespan&quot;: 2,
        &quot;Limit&quot;: 1
      }
    },
    {
      &quot;DownstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;,
      &quot;UpstreamPathTemplate&quot;: &quot;/orders&quot;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot; ],
      &quot;ServiceName&quot;: &quot;OrderService&quot;,
      &quot;LoadBalancerOptions&quot;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;
      },
      &quot;FileCacheOptions&quot;: {
        &quot;TtlSeconds&quot;: 5,
        &quot;Region&quot;: &quot;regionname&quot;
      },
      &quot;RateLimitOptions&quot;: {
        &quot;ClientWhitelist&quot;: [ &quot;SuperClient&quot; ],
        &quot;EnableRateLimiting&quot;: true,
        &quot;Period&quot;: &quot;5s&quot;,
        &quot;PeriodTimespan&quot;: 2,
        &quot;Limit&quot;: 2
      }
    }
  ],
  &quot;GlobalConfiguration&quot;: {
    &quot;BaseUrl&quot;: &quot;http://localhost:9070&quot;,
    &quot;ServiceDiscoveryProvider&quot;: {
      &quot;Scheme&quot;: &quot;http&quot;,
      &quot;Host&quot;: &quot;localhost&quot;,
      &quot;Port&quot;: 8500,
      &quot;Type&quot;: &quot;Consul&quot;
    },
    &quot;RateLimitOptions&quot;: {
      &quot;DisableRateLimitHeaders&quot;: false,
      &quot;QuotaExceededMessage&quot;: &quot;too many requests...&quot;,
      &quot;HttpStatusCode&quot;: 999,
      &quot;ClientIdHeader&quot;: &quot;Test&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Routes路由配置中增加了RateLimitOptions。ClientWhitelist代表客户端白名单，在白名单中的客户端可以不受限流的影响；EnableRateLimiting代表是否限流；Period代表限流的单位时间，例如1s，5m，1h，1d等；PeriodTimespan代表客户端达到请求上限多少秒后可以重试；Limit代表客户端在定义的时间内可以发出的最大请求数。&lt;br/&gt;在GlobalConfiguration配置中也增加了RateLimitOptions。DisableRateLimitHeaders代表是否禁用X-Rate-Limit和Retry-After标头（请求达到上限时response header中的限制数和多少秒后能重试）；QuotaExceededMessage：代表请求达到上限时返回给客户端的消息；HttpStatusCode：代表请求达到上限时返回给客户端的HTTP状态代码。ClientIdHeader可以允许自定义用于标识客户端的标头。默认情况下为“ ClientId”。&lt;br/&gt;最重要的就是Period，PeriodTimespan，Limit这几个配置。&lt;/p&gt;
&lt;p&gt;重新编译启动看一下效果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200616211944189-440946732.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;超时/熔断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;超时很好理解，就是网关请求服务时可容忍的最长响应时间。熔断的意思就是当请求某个服务的异常次数达到一定量时，那么网关在一定时间内就不再对这个服务发起请求了，直接熔断。&lt;br/&gt;Ocelot中启用 超时/熔断 需要NuGet安装一下&lt;code&gt;Ocelot.Provider.Polly&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200616214037176-1072442140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改Startup.cs中的ConfigureServices()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//添加ocelot服务
services.AddOcelot()
    //添加consul支持
    .AddConsul()
    //添加缓存
    .AddCacheManager(x =&amp;gt;
    {
        x.WithDictionaryHandle();
    })
    //添加Polly
    .AddPolly();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的在ocelot.json路由配置中增加QoSOptions：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;QoSOptions&quot;: {
        &quot;ExceptionsAllowedBeforeBreaking&quot;: 3,
        &quot;DurationOfBreak&quot;: 10000,
        &quot;TimeoutValue&quot;: 5000
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExceptionsAllowedBeforeBreaking代表发生错误的次数，DurationOfBreak代表熔断时间，TimeoutValue代表超时时间。&lt;br/&gt;以上的配置意思就是当服务发生3次错误时，那么就熔断10秒，期间客户端的请求直接返回错误，10秒之后恢复。&lt;br/&gt;这个不太好模拟，就不演示了，应该也挺好理解的。&lt;/p&gt;
&lt;p&gt;。。。。。。&lt;/p&gt;
&lt;p&gt;关于服务治理的学问还有很多，不继续了。。。就到此为止吧。&lt;br/&gt;想要更深入了解Ocelot的，请看官网：&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/&quot;&gt;https://ocelot.readthedocs.io/en/latest/&lt;/a&gt;&lt;br/&gt;或者看源码：&lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot;&gt;https://github.com/ThreeMammals/Ocelot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇准备说一下：事件总线。&lt;/p&gt;
&lt;p&gt;代码放在：&lt;a href=&quot;https://github.com/xiajingren/NetCoreMicroserviceDemo&quot;&gt;https://github.com/xiajingren/NetCoreMicroserviceDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jun 2020 00:22:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 上一篇【.Net Core微服务入门全纪录（四）——Ocelot-API网关（上）】已经完成了Ocelot网关的基本搭建，实现了服务入口的统一。当然，这只是API网关的一个最基本功能，它的进阶功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13132255.html</dc:identifier>
</item>
<item>
<title>对 JsonConvert 的认识太肤浅了，终于还是遇到了问题 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13161143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13161143.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;在开始本文之前，真的好想做个问卷调查，到底有多少人和我一样，对 JsonConvert 的认识只局限在 &lt;code&gt;SerializeObject&lt;/code&gt; 和 &lt;code&gt;DeserializeObject&lt;/code&gt; 这两个方法上(┬＿┬), 这样我也好结伴同行，不再孤单落魄😁😁😁，或许是这两个方法基本上能够解决工作中 80% 的场景，对于我来说确实是这样，但随着编码的延续，终究还是会遇到那剩下的 20% ，所以呀。。。&lt;/p&gt;
&lt;p&gt;我的场景是这样的：前段时间写业务代码的时候，我有一个自定义的客户算法类型的Model，这个Model中有这种算法类型下的客户群以及Report统计信息，还用了 HashSet 记录了该类型下的 CustomerID集合，为了方便讲述，我把Model简化如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class CustomerAlgorithmModel
    {
        public string DisplayName { get; set; }

        public int CustomerType { get; set; }

        public ReprotModel Report { get; set; }

        public HashSet&amp;lt;int&amp;gt; CustomerIDHash { get; set; }
    }

    class ReprotModel
    {
        public int TotalCustomerCount { get; set; }

        public int TotalTradeCount { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那有意思的就来了，我个人是有记日志的癖好，就想着以后不会出现死无对证的情况，然后就理所当然的使用 &lt;code&gt;JsonConvert.SerializeObject&lt;/code&gt;, 这一下就出问题了，日志送入到了 &lt;code&gt;ElasticSearch&lt;/code&gt; ，然后通过 &lt;code&gt;Kibana&lt;/code&gt; 查不出来，为啥呢？ 看完上面的 Model 我想你也猜到了原因，json体太大了哈，好歹 &lt;code&gt;CustomerIDHash&lt;/code&gt; 中也有几十万个撒，这一下全导出成json了，这 size 还能小吗？ 要不我写段代码看一看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var algorithModel = new CustomerAlgorithmModel()
            {
                CustomerType = 1,
                DisplayName = &quot;🐮👃&quot;,
                Report = new ReprotModel()
                {
                    TotalCustomerCount = 1000,
                    TotalTradeCount = 50
                },
                CustomerIDHash = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(1, 500000))
            };

            var json = JsonConvert.SerializeObject(algorithModel);

            File.WriteAllText(&quot;1.txt&quot;, json, Encoding.UTF8);

            Console.WriteLine(&quot;写入完成！&quot;);
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200619080907542-626066165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，仅一个json就 &lt;code&gt;3.3M&lt;/code&gt;，这样的记录多来几打后，在 &lt;code&gt;kibana&lt;/code&gt; 上一检索，浏览器就卡的要死，其实 &lt;code&gt;CustomerIDHash&lt;/code&gt; 这个字段对我来说是可有可无的，就算存下来了也没啥大用，所以需求就来了，如何屏蔽掉 &lt;code&gt;CustomerIDHash&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二：寻求解决方案&quot;&gt;二：寻求解决方案&lt;/h2&gt;
&lt;h3 id=&quot;1-使用-jsonignore&quot;&gt;1. 使用 JsonIgnore&lt;/h3&gt;
&lt;p&gt;有问题就网上搜啊，这一搜马上就有人告诉你可以使用 &lt;code&gt;JsonIgnoreAttribute&lt;/code&gt; 忽略特性，加好这个特性后继续跑一下程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    [Newtonsoft.Json.JsonIgnore]
    public HashSet&amp;lt;int&amp;gt; CustomerIDHash { get; set; }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200619080907871-2135321165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;太好了，终于搞定了，但是静下心来想一想，总感觉心里有那么一点不舒服，为什么这么说，一旦你给这个 &lt;code&gt;CustomerIDHash&lt;/code&gt; 套上了 &lt;code&gt;JsonIgnore&lt;/code&gt; ，这就意味着它在 JsonConvet 的世界中从此消失，也不管是谁在使用这个Model， 但这并不是我的初衷，我的初衷仅仅是为了在记录日志的时候踢掉 &lt;code&gt;CustomerIDHash&lt;/code&gt;，可千万不要影响在其他场景下的使用哈，现在这种做法就会给自己，给别人挖坑，埋下了不可预知的bug，我想你应该明白我的意思，还得继续寻找下一个方案。&lt;/p&gt;
&lt;h3 id=&quot;2-使用自定义的-jsonconverter&quot;&gt;2. 使用自定义的 JsonConverter&lt;/h3&gt;
&lt;p&gt;真的，&lt;code&gt;Newtonsoft&lt;/code&gt; 太强大了，我都想写一个专题好好弥补弥补我的知识盲区，其实在这个场景中不就是想把 &lt;code&gt;HashSet&amp;lt;int&amp;gt;&lt;/code&gt; 给屏蔽掉嘛，&lt;code&gt;Newtonsoft&lt;/code&gt; 中专门提供了一个针对特定类型的自定义处理类，接下来我就写一段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
   /// &amp;lt;summary&amp;gt;
   /// 自定义一个 针对 HashSet&amp;lt;int&amp;gt; 的转换类
   /// &amp;lt;/summary&amp;gt;
   public class HashSetConverter : Newtonsoft.Json.JsonConverter&amp;lt;HashSet&amp;lt;int&amp;gt;&amp;gt;
   {
       public override HashSet&amp;lt;int&amp;gt; ReadJson(JsonReader reader, Type objectType, HashSet&amp;lt;int&amp;gt; existingValue, bool hasExistingValue, JsonSerializer serializer)
       {
           return existingValue;
       }

       public override void WriteJson(JsonWriter writer, HashSet&amp;lt;int&amp;gt; value, JsonSerializer serializer)
       {
           writer.WriteNull();
       }
   } 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这么简单，然后就可以在 &lt;code&gt;SerializeObject&lt;/code&gt; 的时候指定下自定义的 &lt;code&gt;HashSetConverter&lt;/code&gt; 即可，然后再将程序跑起来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
 var json = JsonConvert.SerializeObject(algorithModel, Formatting.Indented, new HashSetConverter());

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200619080908118-301859342.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中看，貌似也是解决了，但我突然发现自己要钻牛角尖了，如果我的实体中又来了一个顶级优质客户群的 &lt;code&gt;TopNCustomerIDHash&lt;/code&gt;，但因为这个CustomerID 比较少，我希望在 Json 中能保留下来，然后就是踢掉的那个 CustomerIDHash 我要保留 &lt;code&gt;CustomerIDHash.Length&lt;/code&gt; ，哈哈，搞事情哈，那接下来怎么解决呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;修改 Model 实体&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class CustomerAlgorithmModel
    {
        public HashSet&amp;lt;int&amp;gt; CustomerIDHash { get; set; }

        // topN 优质客户群
        public HashSet&amp;lt;int&amp;gt; TopNCustomerIDHash { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;HashSetConverter 增加逻辑鉴别是否为保留字段&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public override void WriteJson(JsonWriter writer, HashSet&amp;lt;int&amp;gt; value, JsonSerializer serializer)
        {
            if (writer.Path == &quot;TopNCustomerIDHash&quot;)
            {
                writer.WriteStartArray();

                foreach (var item in value)
                {
                    writer.WriteValue(item);
                }

                writer.WriteEndArray();
            }
            else
            {
                writer.WriteValue(value.Count);
            }
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最后给 TopNCustomerIDHash 赋值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
            var algorithModel = new CustomerAlgorithmModel()
            {
                CustomerType = 1,
                DisplayName = &quot;🐮👃&quot;,
                Report = new ReprotModel()
                {
                    TotalCustomerCount = 1000,
                    TotalTradeCount = 50
                },
                CustomerIDHash = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(1, 500000)),
                TopNCustomerIDHash = new HashSet&amp;lt;int&amp;gt;(Enumerable.Range(1, 10)),
            };

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三块都搞定后就可以把程序跑起来了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200619080908484-2080311596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;貌似钻牛角尖的问题是解决了，既然钻牛角尖肯定要各种鄙视，比如这里的 ReportModel 我是不需要的，CustomerType 我也是不需要的，我仅仅需要看一下 &lt;code&gt;DisplayName&lt;/code&gt; 和 &lt;code&gt;TotalCustomerCount&lt;/code&gt; 这两个字段就可以了， 那这个要怎么解决呢？&lt;/p&gt;
&lt;h3 id=&quot;3-使用-匿名类型&quot;&gt;3. 使用 匿名类型&lt;/h3&gt;
&lt;p&gt;确实很多时候记日志，就是为了跟踪 Model 中你特别关心的那几个字段，所以掺杂了多余的字段确实也是没必要的，这里可以用匿名来解决，我就来写一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    var json = JsonConvert.SerializeObject(new
    {
        algorithModel.DisplayName,
        algorithModel.Report.TotalCustomerCount
    }, Formatting.Indented);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200619080908770-1632920626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三：-总结&quot;&gt;三： 总结&lt;/h2&gt;
&lt;p&gt;虽然阻击了几个回合，但同时也发现了 &lt;code&gt;Newtonsoft&lt;/code&gt; 中还有特别多的未挖掘功能，真的需要好好研究研究，源码已下好，接下来准备做个系列来解剖一下，值得一提的是 &lt;code&gt;.Net&lt;/code&gt;中已自带了 &lt;code&gt;System.Text.Json.JsonSerializer&lt;/code&gt; 类，目前来看功能还不算太丰富，简单用用还是可以的，本篇就说到这里，希望对您有帮助。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Fri, 19 Jun 2020 00:09:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 在开始本文之前，真的好想做个问卷调查，到底有多少人和我一样，对 JsonConvert 的认识只局限在 SerializeObject 和 DeserializeObject</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13161143.html</dc:identifier>
</item>
<item>
<title>恕我直言你可能真的不会java第4篇：Stream管道流Map操作 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13161118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13161118.html</guid>
<description>&lt;h2 id=&quot;一、回顾stream管道流map的基础用法&quot;&gt;一、回顾Stream管道流map的基础用法&lt;/h2&gt;
&lt;p&gt;最简单的需求：将集合中的每一个字符串，全部转换成大写！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; alpha = Arrays.asList(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;);

//不使用Stream管道流
List&amp;lt;String&amp;gt; alphaUpper = new ArrayList&amp;lt;&amp;gt;();
for (String s : alpha) {
    alphaUpper.add(s.toUpperCase());
}
System.out.println(alphaUpper); //[MONKEY, LION, GIRAFFE, LEMUR]

// 使用Stream管道流
List&amp;lt;String&amp;gt; collect = alpha.stream().map(String::toUpperCase).collect(Collectors.toList());
//上面使用了方法引用，和下面的lambda表达式语法效果是一样的
//List&amp;lt;String&amp;gt; collect = alpha.stream().map(s -&amp;gt; s.toUpperCase()).collect(Collectors.toList());

System.out.println(collect); //[MONKEY, LION, GIRAFFE, LEMUR]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以&lt;strong&gt;map函数的作用就是针对管道流中的每一个数据元素进行转换操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200619074257914-1438012054.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、处理非字符串类型集合元素&quot;&gt;二、处理非字符串类型集合元素&lt;/h2&gt;
&lt;p&gt;map()函数不仅可以处理数据，还可以转换数据的类型。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; lengths = alpha.stream()
        .map(String::length)
        .collect(Collectors.toList());

System.out.println(lengths); //[6, 4, 7, 5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Stream.of(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;)
        .mapToInt(String::length)
        .forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;6
4
7
5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了mapToInt。还有maoToLong，mapToDouble等等用法&lt;/p&gt;
&lt;h2 id=&quot;三、再复杂一点：处理对象数据格式转换&quot;&gt;三、再复杂一点：处理对象数据格式转换&lt;/h2&gt;
&lt;p&gt;还是使用上一节中的Employee类，创建10个对象。需求如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将每一个Employee的年龄增加一岁&lt;/li&gt;
&lt;li&gt;将性别中的“M”换成“male”，F换成Female。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Employee e1 = new Employee(1,23,&quot;M&quot;,&quot;Rick&quot;,&quot;Beethovan&quot;);
    Employee e2 = new Employee(2,13,&quot;F&quot;,&quot;Martina&quot;,&quot;Hengis&quot;);
    Employee e3 = new Employee(3,43,&quot;M&quot;,&quot;Ricky&quot;,&quot;Martin&quot;);
    Employee e4 = new Employee(4,26,&quot;M&quot;,&quot;Jon&quot;,&quot;Lowman&quot;);
    Employee e5 = new Employee(5,19,&quot;F&quot;,&quot;Cristine&quot;,&quot;Maria&quot;);
    Employee e6 = new Employee(6,15,&quot;M&quot;,&quot;David&quot;,&quot;Feezor&quot;);
    Employee e7 = new Employee(7,68,&quot;F&quot;,&quot;Melissa&quot;,&quot;Roy&quot;);
    Employee e8 = new Employee(8,79,&quot;M&quot;,&quot;Alex&quot;,&quot;Gussin&quot;);
    Employee e9 = new Employee(9,15,&quot;F&quot;,&quot;Neetu&quot;,&quot;Singh&quot;);
    Employee e10 = new Employee(10,45,&quot;M&quot;,&quot;Naveen&quot;,&quot;Jain&quot;);


    List&amp;lt;Employee&amp;gt; employees = Arrays.asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);

    /*List&amp;lt;Employee&amp;gt; maped = employees.stream()
            .map(e -&amp;gt; {
                e.setAge(e.getAge() + 1);
                e.setGender(e.getGender().equals(&quot;M&quot;)?&quot;male&quot;:&quot;female&quot;);
                return e;
            }).collect(Collectors.toList());*/

    List&amp;lt;Employee&amp;gt; maped = employees.stream()
            .peek(e -&amp;gt; {
                e.setAge(e.getAge() + 1);
                e.setGender(e.getGender().equals(&quot;M&quot;)?&quot;male&quot;:&quot;female&quot;);
            }).collect(Collectors.toList());

    System.out.println(maped);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于map的参数e就是返回值，所以可以用peek函数。peek函数是一种特殊的map函数，当函数没有返回值或者参数就是返回值的时候可以使用peek函数。&lt;/p&gt;
&lt;h2 id=&quot;四、flatmap&quot;&gt;四、flatMap&lt;/h2&gt;
&lt;p&gt;map可以对管道流中的数据进行转换操作，但是如果管道中还有管道该如何处理？即：如何处理二维数组及二维集合类。实现一个简单的需求：将“hello”，“world”两个字符串组成的集合，元素的每一个字母打印出来。如果不用Stream我们怎么写？写2层for循环,第一层遍历字符串，并且将字符串拆分成char数组，第二层for循环遍历char数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;hello&quot;, &quot;word&quot;);
words.stream()
        .map(w -&amp;gt; Arrays.stream(w.split(&quot;&quot;)))    //[[h,e,l,l,o],[w,o,r,l,d]]
        .forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.stream.ReferencePipeline$Head@3551a94
java.util.stream.ReferencePipeline$Head@531be3c5
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用map方法是做不到的，这个需求用map方法无法实现。map只能针对一维数组进行操作，数组里面还有数组，管道里面还有管道，它是处理不了每一个元素的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200619074258271-2000046664.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flatMap可以理解为将若干个子管道中的数据全都，平面展开到父管道中进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200619074258769-1528898385.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;words.stream()
        .flatMap(w -&amp;gt; Arrays.stream(w.split(&quot;&quot;))) // [h,e,l,l,o,w,o,r,l,d]
        .forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h
e
l
l
o
w
o
r
d
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jun 2020 23:43:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、回顾Stream管道流map的基础用法 最简单的需求：将集合中的每一个字符串，全部转换成大写！ List&amp;amp;lt;String&amp;amp;gt; alpha = Arrays.asList(&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13161118.html</dc:identifier>
</item>
<item>
<title>小师妹学JVM之:JIT中的LogCompilation - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-jit-logcompilation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-jit-logcompilation.html</guid>
<description>&lt;p&gt;我们知道在JVM中为了加快编译速度，引入了JIT即时编译的功能。那么JIT什么时候开始编译的，又是怎么编译的，作为一个高傲的程序员，有没有办法去探究JIT编译的秘密呢？答案是有的，今天和小师妹一起带大家来看一看这个编译背后的秘密。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，JIT这么神器，但是好像就是一个黑盒子，有没有办法可以探寻到其内部的本质呢？&lt;/p&gt;
&lt;p&gt;追求真理和探索精神是我们作为程序员的最大优点，想想如果没有玻尔关于原子结构的新理论，怎么会有原子体系的突破，如果没有海森堡的矩阵力学，怎么会有量子力学的建立？&lt;/p&gt;
&lt;p&gt;JIT的编译日志输出很简单，使用 -XX:+LogCompilation就够了。&lt;/p&gt;
&lt;p&gt;如果要把日志重定向到一个日志文件中，则可以使用-XX:LogFile= 。&lt;/p&gt;
&lt;p&gt;但是要开启这些分析的功能，又需要使用-XX:+UnlockDiagnosticVMOptions。 所以总结一下，我们需要这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:LogFile=www.flydean.com.log
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;根据上面的介绍，我们现场来生成一个JIT的编译日志，为了体现出专业性，这里我们需要使用到JMH来做性能测试。&lt;/p&gt;
&lt;p&gt;JMH的全称是Java Microbenchmark Harness，是一个open JDK中用来做性能测试的套件。该套件已经被包含在了JDK 12中。&lt;/p&gt;
&lt;p&gt;如果你使用的不是JDK 12，那么需要添加如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.19&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-generator-annprocess&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.19&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多详情可以参考我之前写的： 在java中使用JMH（Java Microbenchmark Harness）做性能测试一文。&lt;/p&gt;
&lt;p&gt;之前有的朋友说，代码也用图片，看起来好看，从本文之后，我们会尽量把代码也转成图片来展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200529101342389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完我的JMH的介绍，上面的例子应该很清楚了，主要就是做一个累加操作，然后warmup 5轮，测试5轮。&lt;/p&gt;
&lt;p&gt;在@Fork注解里面，我们可以配置jvm的参数，为什么我注释掉了呢？因为我发现在jvmArgsPrepend中的-XX:LogFile是不生效的。&lt;/p&gt;
&lt;p&gt;没办法，我只好在运行配置中添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200529101742580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行之后，你就可以得到输出的编译日志文件。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，我看了一下生成的文件好复杂啊，用肉眼能看得明白吗？&lt;/p&gt;
&lt;p&gt;别怕，只是内容的多一点，如果我们细细再细细的分析一下，你会发现其实它真的非常非常......复杂!&lt;/p&gt;
&lt;p&gt;其实写点简单的小白文不好吗？为什么要来分析这么复杂，又没人看，看了也没人懂的JVM底层.....&lt;/p&gt;
&lt;p&gt;大概，这就是专业吧！&lt;/p&gt;
&lt;p&gt;LogCompilation文件其实是xml格式的，我们现在来大概分析一下，它的结构，让大家下次看到这个文件也能够大概了解它的重点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200529222302406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先最基本的信息就是JVM的信息，包括JVM的版本，JVM运行的参数，还有一些properties属性。&lt;/p&gt;
&lt;p&gt;我们收集到的日志其实是分两类的，第一类是应用程序本身的的编译日志，第二类就是编译线程自己内部产生的日志。&lt;/p&gt;
&lt;p&gt;第二类的日志会以hs_c*.log的格式存储，然后在JVM退出的时候，再将这些文件跟最终的日志输出文件合并，生成一个整体的日志文件。&lt;/p&gt;
&lt;p&gt;比如下面的两个就是编译线程内部的日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;thread_logfile thread='22275' filename='/var/folders/n5/217y_bgn49z18zvjch907xb00000gp/T//hs_c22275_pid83940.log'/&amp;gt;
&amp;lt;thread_logfile thread='41731' filename='/var/folders/n5/217y_bgn49z18zvjch907xb00000gp/T//hs_c41731_pid83940.log'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面列出了编译线程的id=22275，如果我们顺着22275找下去，则可以找到具体编译线程的日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;compilation_log thread='22275'&amp;gt;
...
&amp;lt;/compilation_log&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面由compilation_log围起来的部分就是编译日志了。&lt;/p&gt;
&lt;p&gt;接下来的部分表示，编译线程开始执行了，其中stamp表示的是启动时间，下图列出了一个完整的编译线程的日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200529224327438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;start_compile_thread name='C2 CompilerThread0' thread='22275' process='83940' stamp='0.058'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来描述的是要编译的方法信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;task compile_id='10' method='java.lang.Object &amp;lt;init&amp;gt; ()V' bytes='1' count='1409' iicount='1409' stamp='0.153'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面列出了要编译的方法名，compile_id表示的是系统内部分配的编译id，bytes是方法中的字节数，count表示的是该方法的调用次数，注意，这里的次数并不是方法的真实调用次数，只能做一个估计。&lt;/p&gt;
&lt;p&gt;iicount是解释器被调用的次数。&lt;/p&gt;
&lt;p&gt;task执行了，自然就会执行完成，执行完成的内容是以task_done标签来表示的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;task_done success='1' nmsize='120' count='1468' stamp='0.155'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中success表示是否成功执行，nmsize表示编译器编译出来的指令大小，以byte为单位。如果有内联的话，还有个inlined_bytes属性，表示inlined的字节个数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;type id='1025' name='void'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type表示的是方法的返回类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;klass id='1030' name='java.lang.Object' flags='1'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;klass表示的是实例和数组类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;method id='1148' holder='1030' name='&amp;lt;init&amp;gt;' return='1025' flags='1' bytes='1' compile_id='1' compiler='c1' level='3' iicount='1419'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;method表示执行的方法，holder是前面的klass的id，表示的是定义该方法的实例或者数组对象。method有名字，有&lt;br/&gt;return，return对应的是上面的type。&lt;/p&gt;
&lt;p&gt;flags表示的是方法的访问权限。&lt;/p&gt;
&lt;p&gt;接下来是parse，是分析阶段的日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;parse method='1148' uses='1419.000000' stamp='0.153'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面有parse的方法id。uses是使用次数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;bc code='177' bci='0'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bc是byte Count的缩写，code是byte的个数，bci是byte code的索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency type='no_finalizable_subclasses' ctxk='1030'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dependency分析的是类的依赖关系，type表示的是什么类型的依赖，ctkx是依赖的context class。&lt;/p&gt;
&lt;p&gt;我们注意有的parse中，可能会有uncommon_trap：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;uncommon_trap bci='10' reason='unstable_if' action='reinterpret' debug_id='0' comment='taken never'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么理解uncommon_trap呢？字面上意思就是捕获非常用的代码，就是说在解析代码的过程中发现发现这些代码是uncommon的，然后解析产生一个uncommon_trap，不再继续进行了。&lt;/p&gt;
&lt;p&gt;它里面有两个比较重要的字段，reason表示的是被标记为uncommon_trap的原因。action表示的出发uncommon_trap的事件。&lt;/p&gt;
&lt;p&gt;有些地方还会有call：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;call method='1150' count='5154' prof_factor='1.000000' inline='1'/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;call的意思是，在该代码中将会调用其他的方法。count是执行次数。&lt;/p&gt;

&lt;p&gt;复杂的编译日志终于讲完了，可能讲的并不是很全，还有一些其他情况这里并没有列出来，后面如果遇到了，我再添加进去。&lt;/p&gt;
&lt;p&gt;本文的例子&lt;a href=&quot;https://github.com/ddean2009/learn-java-base-9-to-20&quot;&gt;https://github.com/ddean2009/learn-java-base-9-to-20&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.4950495049505&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-jit-logcompilation/&quot;&gt;http://www.flydean.com/jvm-jit-logcompilation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Jun 2020 23:07:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 我们知道在JVM中为了加快编译速度，引入了JIT即时编译的功能。那么JIT什么时候开始编译的，又是怎么编译的，作为一个高傲的程序员，有没有办法去探究JIT编译的秘密呢？答案是有的，今天和小师妹一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-jit-logcompilation.html</dc:identifier>
</item>
<item>
<title>优秀源码带给我们的一些启示  - 肥宅快乐码</title>
<link>http://www.cnblogs.com/fatmanhappycode/p/12744761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fatmanhappycode/p/12744761.html</guid>
<description>&lt;p&gt;首先是个人的一些阅读源码的小技巧，不一定适用每个人，可以直接跳过。&lt;/p&gt;



&lt;h2&gt;博客+总结&lt;/h2&gt;
&lt;p&gt;个人觉得大多数情况下跟着一篇优秀的博客配合着看就足够了，之后再自己写博客总结一遍加深印象，画一下流程图基本都能理顺。（图为学AQS时本人画的获取独占锁流程图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576191/202006/1576191-20200619003827269-748130854.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;类关系&lt;/h2&gt;
&lt;p&gt;配合idea看类之间的关系（ctrl+alt+shift+u）的功能也能更好的理解整个项目的整体架构。因为很多源码其实并不是真的复杂，只是为了扩展性优雅简洁等原因建立了大量的接口和抽象类以及各种设计模式，使得项目看起来很庞大很复杂，借助这个功能有利于你排除掉一些你暂时不想去关心的设计逻辑。知道那个部分才是最核心的逻辑，专注于去看核心代码。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576191/202006/1576191-20200619003644227-1757566925.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;多看注释&lt;/h2&gt;
&lt;p&gt;但是如果你看的博客里面刚好缺少了一部分你想看的内容，而你又找不到资料，需要自己去看，又或者你想看的源码一点点资料都找不到的情况下想去看源码。&lt;/p&gt;
&lt;p&gt;这个时候比较有作用的就是注释，源码中的注释看不懂也没关系，放到百度翻译里基本也能理解大概的意思。仔细看完方法或类的注释之后你就理解了接下来这个类大致是在做什么，之后读它的源码会通顺很多，有一些方法或类甚至在你看完注释之后就已经能知道你想看的内容了，已经没有需要继续往下读了。&lt;/p&gt;
&lt;p&gt;不仅仅是类或方法的注释文档，方法中代码的注释也很重要，基本上稍微复杂一点点的代码，甚至有时候加个锁，作者都会认认真真的写一行注释解释自己这么做的原因。&lt;/p&gt;

&lt;h2&gt;适当囫囵吞枣&lt;/h2&gt;
&lt;p&gt;还有一点是适当忽略一些不重要的细节，这个主要看你想看什么，一般我们看第一遍大多数只是想知道大致的流程是什么样的，所以可以适当忽略并发逻辑和一些方法里的内容（看一眼注释先知道这个方法会做什么的就够了）。第一遍大致知道流程，第二第三遍再去深究细节和并发逻辑等。&lt;/p&gt;

&lt;h2&gt;善用debug&lt;/h2&gt;
&lt;p&gt;多用debug，很多时候源码走的路线会和你想象中的有很大不同，你以为会进入这个if，其实他偷偷进了else。&lt;/p&gt;


&lt;p&gt;经常看到利用短路机制的代码，这里以 &lt;span class=&quot;cnblogs_code&quot;&gt;AbstractQueuedSynchronizer&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;acquire&lt;/span&gt; 方法为例子，只有 &lt;span class=&quot;cnblogs_code&quot;&gt;tryAcquire&lt;/span&gt; 获取锁失败， &lt;span class=&quot;cnblogs_code&quot;&gt;!tryAcquire&lt;/span&gt; 返回 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 时才会执行后面进入阻塞队列并挂起的方法，如果获取锁成功了，根据短路机制自然不会执行入队方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer.acquire(int arg)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
    selfInterrupt();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p id=&quot;reentrantreadwritelock-&quot;&gt;ReentrantReadWriteLock的这段代码里将AQS的state一分为二给共享锁和独占锁使用，个人觉得这种设计非常巧妙：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock&lt;/span&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面这块说的就是将 state 一分为二，高 16 位用于共享模式，低16位用于独占模式&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT   = 16&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_UNIT    = (1 &amp;lt;&amp;lt;&lt;span&gt; SHARED_SHIFT);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_COUNT      = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取 c 的高 16 位值，代表读锁的获取次数(包括重入)&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sharedCount(&lt;span&gt;int&lt;/span&gt; c)    { &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; SHARED_SHIFT; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取 c 的低 16 位值，代表写锁的重入次数，因为写锁是独占模式&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; exclusiveCount(&lt;span&gt;int&lt;/span&gt; c) { &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;忘记在哪里看到的了，翻了一下浏览记录应该是在Java AIO部分的源码里，这种写法感觉很简洁就记下来了，不过可读性似乎不太高，特别是第一种乍一看还以为是lambda表达式&lt;/p&gt;
&lt;p&gt;意思等同于 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++)&lt;/span&gt;  ，但是 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;while&lt;/span&gt;(n-- &amp;gt; 0)&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;while&lt;/span&gt; (--n &amp;gt;= 0)&lt;/span&gt; 这种写法会直接改变n的值&lt;/p&gt;


&lt;p&gt;在很多jdk的源码中我们都可以看到 &lt;span class=&quot;cnblogs_code&quot;&gt;xx = &lt;span&gt;null&lt;/span&gt; &lt;span&gt;//&lt;/span&gt; &lt;span&gt;help GC&lt;/span&gt;&lt;/span&gt; 这样的代码，用来置空引用，帮助jvm完成gc。具体可以了解可达性算法。&lt;/p&gt;
&lt;p&gt;这里我们以LinkList为例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkList 的方法&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; E unlinkFirst(Node&amp;lt;E&amp;gt;&lt;span&gt; f) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; f.item;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; f.next;
    f.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    f.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
    first =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        next.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    size&lt;/span&gt;--&lt;span&gt;;
    modCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在很多地方都会使用位移来进行运算，平时写算法题也一样很多人都这么使用，下面以 &lt;span class=&quot;cnblogs_code&quot;&gt;ArrayList&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;grow&lt;/span&gt; 方法为例子，这里通过右移1位使 &lt;span class=&quot;cnblogs_code&quot;&gt;oldCapacity&lt;/span&gt; 变为原来的0.5倍，之后加上它本身得到  &lt;span class=&quot;cnblogs_code&quot;&gt;newCapacity&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ArrayList.grow(int minCapacity)&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; grow(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; . . . . . .&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newCapacity就是1.5倍的oldCapacity
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; . . . . . . &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是我目前的水平所能总结出来的，后续学到其他的会继续更新，如果大家有什么补充的请告诉我&lt;/p&gt;

&lt;p&gt;最后惯例附一图：（&lt;strong&gt;根本不存在想雇佣我的地方( ´_ゝ`).jpg&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576191/202006/1576191-20200619005102888-264991343.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jun 2020 17:00:00 +0000</pubDate>
<dc:creator>肥宅快乐码</dc:creator>
<og:description>首先是个人的一些阅读源码的小技巧，不一定适用每个人，可以直接跳过。 阅读源码的一些个人技巧 博客+总结 个人觉得大多数情况下跟着一篇优秀的博客配合着看就足够了，之后再自己写博客总结一遍加深印象，画一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fatmanhappycode/p/12744761.html</dc:identifier>
</item>
<item>
<title>【原创】强撸基于 .NET 的 Redis Cluster 集群访问组件 - TANZAME</title>
<link>http://www.cnblogs.com/yiting/p/13149846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiting/p/13149846.html</guid>
<description>&lt;p&gt;　　Hello 大家好，我是TANZAME，我们又见面了。今天我们来聊聊怎么手撸一个 Redis Cluster 集群客户端，纯手工有干货，您细品。&lt;/p&gt;
&lt;p&gt;　　随着业务增长，线上环境的QPS暴增，自然而然将当前的单机 Redis 切换到群集模式。燃鹅，我们悲剧地发现，ServiceStack.Redis这个官方推荐的 .NET 客户端并没有支持集群模式。一通度娘翻墙无果后，决定自己强撸一个基于ServiceStack.Redis的Redis集群访问组件。&lt;/p&gt;
&lt;p&gt;　　话不多说，先上运行效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/89702/202006/89702-20200618143326704-141840287.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Redis-Cluster集群使用 hash slot 算法对每个key计算CRC16值，然后对16383取模，可以获取key对应的 hash slot。Redis-Cluster中每个master都会持有部分 slot，在访问key时根据计算出来的hash slot去找到具体的master节点，再由当前找到的节点去执行具体的 Redis 命令（具体可查阅&lt;a title=&quot;REDIS 集群说明文档&quot; href=&quot;https://redis.io/topics/cluster-tutorial&quot; target=&quot;_blank&quot;&gt;官方说明文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;　　由于 ServiceStack.Redis已经实现了单个实例的Redis命令，因此我们可以将即将要实现的 Redis 集群客户端当做一个代理，它只负责计算 key 落在哪一个具体节点（寻址）然后将Redis命令转发给对应的节点执行即可。&lt;/p&gt;
&lt;p&gt;　　ServiceStack.Redis的RedisClient是非线程安全的，ServiceStack.Redis 使用缓存客户端管理器（PooledRedisClientManager）来提高性能和并发能力，我们的Redis Cluster集群客户端也应集成PooledRedisClientManager来获取 RedisClient 实例。&lt;/p&gt;
&lt;p&gt;　　同时，Redis-Cluster集群支持在线动态扩容和slot迁移，我们的Redis集群客户端也应具备自动智能发现新节点和自动刷新 slot 分布的能力。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;总结起来，要实现一个Redis-Cluster客户端，需要实现以下几个要点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如下面类图所示，接下来我们详细分析具体的代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/89702/202006/89702-20200617232204203-2012898308.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;section_crc16&quot;&gt;&lt;span&gt;　　一、CRC16 &lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CRC即循环冗余校验码，是信息系统中一种常见的检错码。CRC校验码不同的机构有不同的标准，这里Redis遵循的标准是CRC-16-CCITT标准，这也是被XMODEM协议使用的CRC标准，所以也常用XMODEM CRC代指，是比较经典的“基于字节查表法的CRC校验码生成算法”。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据 key 计算对应的哈希槽
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetSlot(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     key =&lt;span&gt; CRC16.ExtractHashTag(key);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; optimization with modulo operator with power of 2 equivalent to getCRC16(key) % 16384&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; GetCRC16(key) &amp;amp; (&lt;span&gt;16384&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计算给定字节组的 crc16 检验码
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetCRC16(&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; e)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; crc = &lt;span&gt;0x0000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = s; i &amp;lt; e; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         crc = ((crc &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) ^ LOOKUP_TABLE[((crc &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) ^ (bytes[i] &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;)) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; crc &amp;amp; &lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p id=&quot;section_read_nodes&quot;&gt;　　&lt;span&gt;二、读取集群节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从集群中的任意节点使用 CLUSTER NODES 命令可以读取到集群中所有的节点信息，包括连接状态，它们的标志，属性和分配的槽等等。CLUSTER NODES 以串行格式提供所有这些信息，输出示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
d99b65a25ef726c64c565901e345f98c496a1a47 127.0.0.1:7007 master - 0 1592288083308 8 connected
2d71879d6529d1edbfeed546443051986245c58e 127.0.0.1:7003 master - 0 1592288084311 11 connected 10923-16383
654cdc25a5fa11bd44b5b716cdf07d4ce176efcd 127.0.0.1:7005 slave 484e73948d8aacd8327bf90b89469b52bff464c5 0 1592288085313 10 connected
ed65d52dad7ef6854e0e261433b56a551e5e11cb 127.0.0.1:7004 slave 754d0ec7a7f5c7765f784a6a2c370ea38ea0c089 0 1592288081304 9 connected
754d0ec7a7f5c7765f784a6a2c370ea38ea0c089 127.0.0.1:7001 master - 0 1592288080300 9 connected 0-5460
484e73948d8aacd8327bf90b89469b52bff464c5 127.0.0.1:7002 master - 0 1592288082306 10 connected 5461-10922
2223bc6d099bd9838e5d2f1fbd9a758f64c554c4 127.0.0.1:7006 myself,slave 2d71879d6529d1edbfeed546443051986245c58e 0 0 6 connected
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每个字段的含义如下：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041789&quot; class=&quot;J-stage-100041789 doc-postil&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　1. &lt;code&gt;id&lt;/code&gt;：节点 ID，一个40个字符的随机字符串，当一个节点被创建时不会再发生变化（除非&lt;code&gt;CLUSTER RESET HARD&lt;/code&gt;被使用）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041790&quot; class=&quot;J-stage-100041790 doc-postil&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　　2. &lt;code&gt;ip:port&lt;/code&gt;：客户端应该联系节点以运行查询的节点地址。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041791&quot; class=&quot;J-stage-100041791 doc-postil&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　3. &lt;code&gt;flags&lt;/code&gt;：逗号列表分隔的标志：&lt;code&gt;myself&lt;/code&gt;，&lt;code&gt;master&lt;/code&gt;，&lt;code&gt;slave&lt;/code&gt;，&lt;code&gt;fail?&lt;/code&gt;，&lt;code&gt;fail&lt;/code&gt;，&lt;code&gt;handshake&lt;/code&gt;，&lt;code&gt;noaddr&lt;/code&gt;，&lt;code&gt;noflags&lt;/code&gt;。标志在下一节详细解释。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041792&quot; class=&quot;J-stage-100041792 doc-postil&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　4. &lt;code&gt;master&lt;/code&gt;：如果节点是从属节点，并且主节点已知，则节点ID为主节点，否则为“ - ”字符。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041793&quot; class=&quot;J-stage-100041793 doc-postil&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　5. &lt;code&gt;ping-sent&lt;/code&gt;：以毫秒为单位的当前激活的ping发送的unix时间，如果没有挂起的ping，则为零。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041794&quot; class=&quot;J-stage-100041794 doc-postil&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　　6. &lt;code&gt;pong-recv&lt;/code&gt;：毫秒 unix 时间收到最后一个乒乓球。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041795&quot; class=&quot;J-stage-100041795 doc-postil&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;　　7. &lt;code&gt;config-epoch&lt;/code&gt;：当前节点（或当前主节点，如果该节点是从节点）的配置时期（或版本）。每次发生故障切换时，都会创建一个新的，唯一的，单调递增的配置时期。如果多个节点声称服务于相同的哈希槽，则具有较高配置时期的节点将获胜。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041796&quot; class=&quot;J-stage-100041796 doc-postil&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　8. &lt;code&gt;link-state&lt;/code&gt;：用于节点到节点集群总线的链路状态。我们使用此链接与节点进行通信。可以是&lt;code&gt;connected&lt;/code&gt;或&lt;code&gt;disconnected&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041797&quot; class=&quot;J-stage-100041797 doc-postil&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;　　9. &lt;code&gt;slot&lt;/code&gt;：散列槽号或范围。从参数9开始，但总共可能有16384个条目（限制从未达到）。这是此节点提供的散列槽列表。如果条目仅仅是一个数字，则被解析为这样。如果它是一个范围，它是在形式&lt;code&gt;start-end&lt;/code&gt;，并且意味着节点负责所有散列时隙从&lt;code&gt;start&lt;/code&gt;到&lt;code&gt;end&lt;/code&gt;包括起始和结束值。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041798&quot; class=&quot;J-stage-100041798 doc-postil&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;标志的含义（字段编号3）：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041799&quot; class=&quot;J-stage-100041799 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;myself&lt;/code&gt;：您正在联系的节点。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041800&quot; class=&quot;J-stage-100041800 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;master&lt;/code&gt;：节点是主人。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041801&quot; class=&quot;J-stage-100041801 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;：节点是从属的。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041802&quot; class=&quot;J-stage-100041802 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;fail?&lt;/code&gt;：节点处于&lt;code&gt;PFAIL&lt;/code&gt;状态。对于正在联系的节点无法访问，但仍然可以在逻辑上访问（不处于&lt;code&gt;FAIL&lt;/code&gt;状态）。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041803&quot; class=&quot;J-stage-100041803 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;fail&lt;/code&gt;：节点处于&lt;code&gt;FAIL&lt;/code&gt;状态。对于将&lt;code&gt;PFAIL&lt;/code&gt;状态提升为&lt;code&gt;FAIL&lt;/code&gt;的多个节点而言，这是无法访问的。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041804&quot; class=&quot;J-stage-100041804 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;handshake&lt;/code&gt;：不受信任的节点，我们握手。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041805&quot; class=&quot;J-stage-100041805 doc-postil&quot;&gt;
&lt;div class=&quot;rno-markdown&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;noaddr&lt;/code&gt;：此节点没有已知的地址。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div id=&quot;stage-100041806&quot; class=&quot;J-stage-100041806 doc-postil&quot; readability=&quot;48.291579936883&quot;&gt;
&lt;div class=&quot;rno-markdown&quot; readability=&quot;52.274390653327&quot;&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;code&gt;noflags&lt;/code&gt;：根本没有标志。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('11e35619-0c07-448e-9940-f074fbdca451')&quot; readability=&quot;38&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_11e35619-0c07-448e-9940-f074fbdca451&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_11e35619-0c07-448e-9940-f074fbdca451&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_11e35619-0c07-448e-9940-f074fbdca451&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取集群上的节点信息&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IList&amp;lt;InternalClusterNode&amp;gt; ReadClusterNodes(IEnumerable&amp;lt;ClusterNode&amp;gt;&lt;span&gt; source)
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     RedisClient c = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     StringReader reader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     IList&amp;lt;InternalClusterNode&amp;gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; rowCount =&lt;span&gt; source.Count();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从当前节点读取REDIS集群节点信息&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;             index += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisClient(node.Host, node.Port, node.Password);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             RedisData data = c.RawCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CLUSTER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.ToUtf8Bytes(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NODES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.ToUtf8Bytes());
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; info =&lt;span&gt; Encoding.UTF8.GetString(data.Data);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将读回的字符文本转成强类型节点实体&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringReader(info);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; line =&lt;span&gt; reader.ReadLine();
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (line != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;) result = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InternalClusterNode&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 InternalClusterNode n =&lt;span&gt; InternalClusterNode.Parse(line);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 n.Password =&lt;span&gt; node.Password;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                result.Add(n);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;                 line =&lt;span&gt; reader.ReadLine();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要任意一个节点拿到集群信息，直接退出&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; result.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出现异常，如果还没到最后一个节点，则继续使用下一下节点读取集群信息
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则抛出异常&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (index &amp;lt;&lt;span&gt; rowCount)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 Thread.Sleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisClusterException(ex.Message, c != &lt;span&gt;null&lt;/span&gt; ? c.GetHostString() : &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty, ex);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (reader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) reader.Dispose();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) c.Dispose();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         result = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InternalClusterNode&amp;gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从 cluster nodes 的每一行命令里读取出集群节点的相关信息
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;line&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;集群命令&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InternalClusterNode Parse(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(line))
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     InternalClusterNode node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalClusterNode();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     node._nodeDescription =&lt;span&gt; line;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;[] segs = line.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     node.NodeId = segs[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     node.Host = segs[&lt;span&gt;1&lt;/span&gt;].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     node.Port = &lt;span&gt;int&lt;/span&gt;.Parse(segs[&lt;span&gt;1&lt;/span&gt;].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     node.MasterNodeId = segs[&lt;span&gt;3&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : segs[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     node.PingSent = &lt;span&gt;long&lt;/span&gt;.Parse(segs[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     node.PongRecv = &lt;span&gt;long&lt;/span&gt;.Parse(segs[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     node.ConfigEpoch = &lt;span&gt;int&lt;/span&gt;.Parse(segs[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     node.LinkState = segs[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;[] flags = segs[&lt;span&gt;2&lt;/span&gt;].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     node.IsMater = flags[&lt;span&gt;0&lt;/span&gt;] == MYSELF ? flags[&lt;span&gt;1&lt;/span&gt;] == MASTER : flags[&lt;span&gt;0&lt;/span&gt;] ==&lt;span&gt; MASTER;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     node.IsSlave = !&lt;span&gt;node.IsMater;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; start = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (flags[start] ==&lt;span&gt; MYSELF)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         start = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (flags[start] == SLAVE || flags[start] ==&lt;span&gt; MASTER)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         start += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     node.NodeFlag = &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, flags.Skip(start));
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (segs.Length &amp;gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt;[] slots = segs[&lt;span&gt;8&lt;/span&gt;].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         node.Slot.Start = &lt;span&gt;int&lt;/span&gt;.Parse(slots[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (slots.Length &amp;gt; &lt;span&gt;1&lt;/span&gt;) node.Slot.End = &lt;span&gt;int&lt;/span&gt;.Parse(slots[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;9&lt;/span&gt;; index &amp;lt; segs.Length; index++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (node.RestSlots == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 node.RestSlots = &lt;span&gt;new&lt;/span&gt; List&amp;lt;HashSlot&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;             slots = segs[index].Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; s1 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; s2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; b1 = &lt;span&gt;int&lt;/span&gt;.TryParse(slots[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; s1);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; b2 = &lt;span&gt;int&lt;/span&gt;.TryParse(slots[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; s2);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!b1 || !&lt;span&gt;b2)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;                 node.RestSlots.Add(&lt;span&gt;new&lt;/span&gt; HashSlot(s1, slots.Length &amp;gt; &lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;new&lt;/span&gt; Nullable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(s2) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p id=&quot;section_alloc_manager&quot;&gt;　　&lt;span&gt;三、为节点分配缓存客户端管理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在单实例的Redis中，我们通过 PooledRedisClientManager 这个管理器来获取RedisClient。借鉴这个思路，在Redis Cluster集群中，我们为每一个主节点实例化一个 PooledRedisClientManager，并且该主节点持有的 slot 都共享一个 PooledRedisClientManager 实例。以 slot 做为 key 将 slot 与 PooledRedisClientManager 一一映射并缓存起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('94e0618d-f686-48f4-927d-2ac82ede7605')&quot; readability=&quot;38&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_94e0618d-f686-48f4-927d-2ac82ede7605&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_94e0618d-f686-48f4-927d-2ac82ede7605&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94e0618d-f686-48f4-927d-2ac82ede7605&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化集群管理&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Initialize(IList&amp;lt;InternalClusterNode&amp;gt; clusterNodes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 redis 读取集群信息&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     IList&amp;lt;InternalClusterNode&amp;gt; nodes = clusterNodes == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; RedisCluster.ReadClusterNodes(_source) : clusterNodes;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成主节点，每个主节点的 slot 对应一个REDIS客户端缓冲池管理器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     IList&amp;lt;InternalClusterNode&amp;gt; masters = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     IDictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, PooledRedisClientManager&amp;gt; managers = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; nodes)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点无效或者&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(n.IsMater &amp;amp;&amp;amp;
&lt;span&gt;14&lt;/span&gt;             !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(n.Host) &amp;amp;&amp;amp;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(n.NodeFlag) &amp;amp;&amp;amp;
&lt;span&gt;16&lt;/span&gt;             (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(n.LinkState) || n.LinkState == InternalClusterNode.CONNECTED))) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         n.SlaveNodes = nodes.Where(x =&amp;gt; x.MasterNodeId ==&lt;span&gt; n.NodeId);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (masters == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             masters = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InternalClusterNode&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        masters.Add(n);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用每一个主节点的哈希槽做键，导入REDIS客户端缓冲池管理器
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后，方法表指针（又名类型对象指针）上场，占据 4 个字节。 4 * 16384 / 1024 = 64KB&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (managers == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             managers = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, PooledRedisClientManager&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt;[] writeHosts = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { n.HostString };
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt;[] readHosts = n.SlaveNodes.Where(n =&amp;gt; &lt;span&gt;false&lt;/span&gt;).Select(n =&amp;gt;&lt;span&gt; n.HostString).ToArray();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; pool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PooledRedisClientManager(writeHosts, readHosts, _config);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        managers.Add(n.Slot.Start, pool);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (n.Slot.End != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个范围内的哈希槽都用同一个缓冲池&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; s = n.Slot.Start + &lt;span&gt;1&lt;/span&gt;; s &amp;lt;= n.Slot.End.Value; s++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                managers.Add(s, pool);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (n.RestSlots != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; slot &lt;span&gt;in&lt;/span&gt;&lt;span&gt; n.RestSlots)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                managers.Add(slot.Start, pool);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (slot.End != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个范围内的哈希槽都用同一个缓冲池&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; s = slot.Start + &lt;span&gt;1&lt;/span&gt;; s &amp;lt;= slot.End.Value; s++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                        managers.Add(s, pool);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     _masters =&lt;span&gt; masters;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     _redisClientManagers =&lt;span&gt; managers;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     _clusterNodes = nodes != &lt;span&gt;null&lt;/span&gt; ? nodes : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (_masters == &lt;span&gt;null&lt;/span&gt;) _masters = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InternalClusterNode&amp;gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (_clusterNodes == &lt;span&gt;null&lt;/span&gt;) _clusterNodes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InternalClusterNode&amp;gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (_redisClientManagers == &lt;span&gt;null&lt;/span&gt;) _redisClientManagers = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, PooledRedisClientManager&amp;gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (_masters.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         _source = _masters.Select(n =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClusterNode(n.Host, n.Port, n.Password)).ToList();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;四、将 hash slot 路由到正确的节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在访问一个 key 时，根据第三步缓存起来的 PooledRedisClientManager ，用 key 计算出来的 hash slot 值可以快速找出这个 key 对应的 PooledRedisClientManager 实例，调用 PooledRedisClientManager.GetClient() 即可将 hash slot 路由到正确的主节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行指定动作并返回值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; T DoExecute&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, Func&amp;lt;RedisClient, T&amp;gt; action) =&amp;gt; &lt;span&gt;this&lt;/span&gt;.DoExecute(() =&amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetRedisClient(key), action);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行指定动作并返回值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; T DoExecute&amp;lt;T&amp;gt;(Func&amp;lt;RedisClient&amp;gt; slot, Func&amp;lt;RedisClient, T&amp;gt; action, &lt;span&gt;int&lt;/span&gt; tryTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     RedisClient c = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         c =&lt;span&gt; slot();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(c);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略 ...&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            c.Dispose();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定key对应的主设备节点&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; RedisClient GetRedisClient(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; slot =&lt;span&gt; CRC16.GetSlot(key);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_redisClientManagers.ContainsKey(slot))
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SlotNotFoundException(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No reachable node in cluster for slot {{{0}}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, slot), slot, key);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pool =&lt;span&gt; _redisClientManagers[slot];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (RedisClient)pool.GetClient();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p id=&quot;section_auto_discovery&quot;&gt;　　&lt;span&gt;五、自动发现新节点和自动刷新slot分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在实际生产环境中，Redis 集群经常会有添加/删除节点、迁移 slot 、主节点宕机从节点转主节点等，针对这些情况，我们的 Redis Cluster 组件必须具备自动发现节点和刷新在 &lt;a href=&quot;https://www.cnblogs.com/yiting/p/13149846.html#section_alloc_manager&quot;&gt;第三步 &lt;/a&gt; 缓存起来的 slot 的能力。在这里我的实现思路是当节点执行 Redis 命令时返回 RedisException 异常时就强制刷新集群节点信息并重新缓存 slot 与 节点之间的映射。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0d27fbae-0766-4b70-a53a-aa171131c8e5')&quot; readability=&quot;38.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_0d27fbae-0766-4b70-a53a-aa171131c8e5&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_0d27fbae-0766-4b70-a53a-aa171131c8e5&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d27fbae-0766-4b70-a53a-aa171131c8e5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行指定动作并返回值&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; T DoExecute&amp;lt;T&amp;gt;(Func&amp;lt;RedisClient&amp;gt; slot, Func&amp;lt;RedisClient, T&amp;gt; action, &lt;span&gt;int&lt;/span&gt; tryTimes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     RedisClient c = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         c =&lt;span&gt; slot();
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(c);
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(ex &lt;span&gt;is&lt;/span&gt; RedisException) || tryTimes == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisClusterException(ex.Message, c != &lt;span&gt;null&lt;/span&gt; ? c.GetHostString() : &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty, ex);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             tryTimes -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试重新刷新集群信息&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; isRefresh =&lt;span&gt; DiscoveryNodes(_source, _config);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRefresh)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 集群节点有更新过，重新执行&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DoExecute(slot, action, tryTimes);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 集群节点未更新过，直接抛出异常&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisClusterException(ex.Message, c != &lt;span&gt;null&lt;/span&gt; ? c.GetHostString() : &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty, ex);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            c.Dispose();
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新刷新集群信息&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DiscoveryNodes(IEnumerable&amp;lt;ClusterNode&amp;gt;&lt;span&gt; source, RedisClientManagerConfig config)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; lockTaken = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; noop&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_isDiscoverying) { }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;         Monitor.Enter(_objLock, &lt;span&gt;ref&lt;/span&gt;&lt;span&gt; lockTaken);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;         _source =&lt;span&gt; source;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         _config =&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         _isDiscoverying = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跟上次同步时间相隔 {MONITORINTERVAL} 秒钟以上才需要同步&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((DateTime.Now - _lastDiscoveryTime).TotalMilliseconds &amp;gt;=&lt;span&gt; MONITORINTERVAL)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; isRefresh = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             IList&amp;lt;InternalClusterNode&amp;gt; newNodes =&lt;span&gt; RedisCluster.ReadClusterNodes(_source);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; newNodes)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; n = _clusterNodes.FirstOrDefault(x =&amp;gt; x.HostString ==&lt;span&gt; node.HostString);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 isRefresh =
&lt;span&gt; 57&lt;/span&gt;                     n == &lt;span&gt;null&lt;/span&gt; ||                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新节点                                                                &lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;                     n.Password != node.Password ||      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密码变了                                                                &lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;                     n.IsMater != node.IsMater ||        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主变从或者从变主                                                                &lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;                     n.IsSlave != node.IsSlave ||        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主变从或者从变主                                                                &lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;                     n.NodeFlag != node.NodeFlag ||      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点标记位变了                                                                &lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;                     n.LinkState != node.LinkState ||    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点状态位变了                                                                &lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;                     n.Slot.Start != node.Slot.Start ||  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希槽变了                                                                &lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;                     n.Slot.End != node.Slot.End ||      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希槽变了&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;                     (n.RestSlots == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.RestSlots != &lt;span&gt;null&lt;/span&gt;) ||
&lt;span&gt; 66&lt;/span&gt;                     (n.RestSlots != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.RestSlots == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!isRefresh &amp;amp;&amp;amp; n.RestSlots != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.RestSlots != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; slots1 = n.RestSlots.OrderBy(x =&amp;gt;&lt;span&gt; x.Start).ToList();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; slots2 = node.RestSlots.OrderBy(x =&amp;gt;&lt;span&gt; x.Start).ToList();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; slots1.Count; index++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                         isRefresh =
&lt;span&gt; 74&lt;/span&gt;                             slots1[index].Start != slots2[index].Start ||   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希槽变了                                                                &lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;                             slots1[index].End != slots2[index].End;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希槽变了&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (isRefresh) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isRefresh) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRefresh)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新初始化集群&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Dispose();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Initialize(newNodes);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;._lastDiscoveryTime =&lt;span&gt; DateTime.Now;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后刷新时间在 {MONITORINTERVAL} 内，表示是最新群集信息 newest&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (DateTime.Now - _lastDiscoveryTime).TotalMilliseconds &amp;lt;&lt;span&gt; MONITORINTERVAL;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lockTaken)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             _isDiscoverying = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            Monitor.Exit(_objLock);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;六、配置访问组件调用入口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后我们需要为组件提供访问入口，我们用 RedisCluster 类实现 字符串、列表、哈希、集合、有序集合和Keys的基本操作，并且用 RedisClusterFactory 工厂类对外提供单例操作，这样就可以像单实例 Redis 那样调用 Redis Cluster 集群。调用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var node = new ClusterNode(&quot;127.0.0.1&quot;, 7001);
var redisCluster = RedisClusterFactory.Configure(node, config);
string key = &quot;B070x14668&quot;;
redisCluster.Set(key, key);
string value = redisCluster.Get&amp;lt;string&amp;gt;(key);
redisCluster.Del(key);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('41b2e97f-44a9-4e6a-980e-ca2565de79da')&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_41b2e97f-44a9-4e6a-980e-ca2565de79da&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_41b2e97f-44a9-4e6a-980e-ca2565de79da&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_41b2e97f-44a9-4e6a-980e-ca2565de79da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; REDIS 集群工厂
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisClusterFactory
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; RedisClusterFactory _factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisClusterFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; RedisCluster _cluster = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Redis 集群
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisCluster Cluster
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;get&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_cluster == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You should call RedisClusterFactory.Configure to config cluster first.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _cluster;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化 &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;RedisClusterFactory&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; 类的新实例
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisClusterFactory()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置 REDIS 集群
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;para&amp;gt;&lt;/span&gt;&lt;span&gt;若群集中有指定 password 的节点，必须使用  IEnumerable&amp;amp;lt;ClusterNode&amp;amp;gt; 重载列举出这些节点&lt;/span&gt;&lt;span&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;node&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;集群节点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisCluster Configure(ClusterNode node)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; RedisClusterFactory.Configure(node, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置 REDIS 集群
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;para&amp;gt;&lt;/span&gt;&lt;span&gt;若群集中有指定 password 的节点，必须使用  IEnumerable&amp;amp;lt;ClusterNode&amp;amp;gt; 重载列举出这些节点&lt;/span&gt;&lt;span&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;node&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;集群节点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;see cref=&quot;RedisClientManagerConfig&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; 客户端缓冲池配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RedisCluster Configure(ClusterNode node, RedisClientManagerConfig config)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; RedisClusterFactory.Configure(&lt;span&gt;new&lt;/span&gt; List&amp;lt;ClusterNode&amp;gt;&lt;span&gt; { node }, config);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置 REDIS 集群
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;nodes&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;集群节点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;see cref=&quot;RedisClientManagerConfig&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; 客户端缓冲池配置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedisCluster Configure(IEnumerable&amp;lt;ClusterNode&amp;gt;&lt;span&gt; nodes, RedisClientManagerConfig config)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (nodes == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (nodes == &lt;span&gt;null&lt;/span&gt; || nodes.Count() == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;There is no nodes to configure cluster.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (_cluster == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_factory)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (_cluster == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                     RedisCluster c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisCluster(nodes, config);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                     _cluster =&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _cluster;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　今天我们详细介绍了如何从0手写一个Redis Cluster集群客户端访问组件，相信对同样在寻找类似解决方案的同学们会有一定的启发，喜欢的同学请点个 star。在没有相同案例可以参考的情况下笔者通过查阅官方说明文档和借鉴 Java 的 JedisCluster 的实现思路，虽说磕磕碰碰但最终也初步完成这个组件并投入使用，必须给自己加一个鸡腿！！在此我有一个小小的疑问，.NET 的同学们在用 Redis 集群时，你们是用什么组件耍的，为何网上的相关介绍和现成组件几乎都没有？欢迎讨论。&lt;/p&gt;
&lt;p&gt;　　GitHub 代码托管：&lt;a href=&quot;https://github.com/TANZAME/ServiceStack.Redis.Cluster&quot;&gt;https://github.com/TANZAME/ServiceStack.Redis.Cluster&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　技术交流 QQ 群：816425449&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 18 Jun 2020 16:56:00 +0000</pubDate>
<dc:creator>TANZAME</dc:creator>
<og:description>Hello 大家好，我是TANZAME，我们又见面了。今天我们来聊聊怎么手撸一个&amp;#160;Redis Cluster 集群客户端，纯手工有干货，您细品。 随着业务增长，线上环境的QPS暴增，自然而然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yiting/p/13149846.html</dc:identifier>
</item>
<item>
<title>Netty中的这些知识点，你需要知道！ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13155554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13155554.html</guid>
<description>&lt;p&gt;Channel、EventLoop、Unsafe、multiplexor、AdaptiveRecvByteBufAllocator、ChannelPipeline...&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;146.10134023043&quot;&gt;
&lt;h2&gt;一、Channel&lt;/h2&gt;
&lt;p&gt;Channel是一个&lt;strong&gt;接口&lt;/strong&gt;，而且是一个很大的接口，我们称之为“大而全”，囊括了server端及client端接口所需要的接口。&lt;/p&gt;
&lt;p&gt;Channel是一个&lt;span&gt;&lt;strong&gt;门面&lt;/strong&gt;&lt;/span&gt;，封装了包括网络I/O及相关的所有操作。&lt;/p&gt;
&lt;p&gt;Channel&lt;span&gt;&lt;strong&gt;聚合&lt;/strong&gt;&lt;/span&gt;了包括网络读写、链路管理、网络连接信息、获取EventLoop、Pipeline等相关功能类；统一分配，调度实现相应场景的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618014545640-42163202.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;246&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个Channel &lt;strong&gt;&lt;span&gt;对应一个物理连接&lt;/span&gt;&lt;/strong&gt;，是基于物理连接上的操作包装。&lt;/p&gt;
&lt;h2&gt;二、EventLoop&lt;/h2&gt;
&lt;p&gt;EventLoop，Event意为事件、Loop意为环，EventLoo即为&lt;span&gt;&lt;strong&gt;事件环&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;EventLoop是一种程序&lt;strong&gt;设计结构&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;等待以及分发&lt;/strong&gt;&lt;/span&gt;事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618020149069-1425194326.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;218&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NioEventLoop，是一个Netty工作线程，又不仅仅是一个Netty工作线程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/13070107.html&quot; target=&quot;_blank&quot;&gt;标准的netty线程模型&lt;/a&gt; 中我们讲过Netty的标准线程池模型，池子里的每个线程对象就是一个NioEventLoop对象。或负责&lt;strong&gt;&lt;span&gt;接受连接&lt;/span&gt;&lt;/strong&gt;，或&lt;strong&gt;&lt;span&gt;负责网络I/O&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;说它不仅仅是一个Netty线程，因为它实现了很多功能，我们可以看下它的继承图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618204514189-414304278.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;591&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的上方有两个枝丫，一个&lt;span&gt;&lt;strong&gt;线程属性&lt;/strong&gt;&lt;/span&gt;，一个&lt;span&gt;&lt;strong&gt;EventLoop&lt;/strong&gt;&lt;/span&gt;，它是Netty的&lt;span&gt;&lt;strong&gt;Reactor线程&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;既然是Reactor线程，那么首先我们需要一个&lt;strong&gt;&lt;span&gt;多路复用器&lt;/span&gt;&lt;/strong&gt;。在Netty NioEventLoop中，包就含一个 Selector，它的操作对象是Channel。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618220620517-1530612963.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;278&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NioEventLoop的主要逻辑在它的run()方法，方法体内是一个&lt;span&gt;&lt;strong&gt;无限循环 for (;;)&lt;/strong&gt;&lt;span&gt;，循环体内实现Loop功能。这也是通用的NIO线程实现方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618222621735-1124071953.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;358&quot; loading=&quot;lazy&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Loop 从任务队列里获取任务，然后检查多路复用器中就绪的Channel进行处理。&lt;/p&gt;
&lt;h2&gt;三、Unsafe&lt;/h2&gt;
&lt;p&gt;Netty中的Unsafe，一个Channel&lt;span&gt;&lt;strong&gt;内部聚合接口&lt;/strong&gt;&lt;/span&gt;，用以处理实际的网络I/O读写。当然，取Unsafe命名，源码中释义：提供的网络相关的操作方法，永远不应该被开发人员操作使用。&lt;/p&gt;
&lt;p&gt;它是Channel的一个&lt;strong&gt;&lt;span&gt;辅助接口&lt;/span&gt;&lt;/strong&gt;，主要方法：&lt;/p&gt;
&lt;p&gt;1、register：注册Channel&lt;/p&gt;
&lt;p&gt;2、deregister：取消注册&lt;/p&gt;
&lt;p&gt;3、bind：绑定地址，服务端绑定监听特定端口；客户端指定本地绑定Socket地址。&lt;/p&gt;
&lt;p&gt;4、connect：建立连接&lt;/p&gt;
&lt;p&gt;5、disconnect：断开连接&lt;/p&gt;
&lt;p&gt;6、close：关闭连接&lt;/p&gt;
&lt;p&gt;7、write：调度写，将数据写入buffer，&lt;span&gt;&lt;strong&gt;并未真正进入Channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8、flush：将缓冲区中的数据写入Channel&lt;/p&gt;
&lt;h2&gt;四、AdaptiveRecvByteBufAllocator&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态缓冲区分配器&lt;/strong&gt;&lt;/span&gt;，源码说明：根据&lt;span&gt;&lt;strong&gt;实时的反馈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;动态&lt;/strong&gt;&lt;/span&gt;的增加或者减少&lt;span&gt;&lt;strong&gt;预需&lt;/strong&gt;&lt;/span&gt;的缓冲区大小。&lt;/p&gt;
&lt;p&gt;如果&lt;span&gt;&lt;strong&gt;上&lt;/strong&gt;&lt;strong&gt;一次&lt;/strong&gt;&lt;/span&gt;分配的缓冲区被填满了，则调高下一次分配的缓冲区大小。&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;&lt;span&gt;连续两次&lt;/span&gt;&lt;/strong&gt;实际使用的容量低于分配的缓冲区大小特定比例，则减小下一次分配的缓冲区大小。&lt;/p&gt;
&lt;p&gt;其它情景，保持分配大小不变。&lt;/p&gt;
&lt;p&gt;Netty的这种&lt;span&gt;&lt;strong&gt;“智能化”&lt;/strong&gt;&lt;/span&gt;处理，可以说是相当有用的：&lt;/p&gt;
&lt;p&gt;1、首先，实际的应用场景千差万别，同一场景下不同时刻的缓冲区需求也是实时变化（一句话可以是一个字，也可能是1000个字），这就需要Netty动态调整缓冲分配大小以适应不同的&lt;span&gt;&lt;strong&gt;业务场景，时刻场景&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200618234604888-749823847.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;375&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、其次，&lt;span&gt;&lt;strong&gt;过大的不必要的&lt;/strong&gt;&lt;/span&gt;内存分配，会导致Buffer处理性能下降；&lt;span&gt;&lt;strong&gt;过小的&lt;/strong&gt;&lt;/span&gt;内存分配，则会导致频繁的分配释放。这都是一个优良的网络框架不应该有的。 &lt;/p&gt;
&lt;p&gt;3、最后，动态的调整最直接的好处就是&lt;span&gt;&lt;strong&gt;内存的的高效使用&lt;/strong&gt;&lt;/span&gt;，一定程度上做到了&lt;span&gt;&lt;strong&gt;按需分配&lt;/strong&gt;&lt;/span&gt;。 &lt;/p&gt;
&lt;h2&gt;五、ChannelPipeline&lt;/h2&gt;
&lt;p&gt;Pipeline 管道，Channel的&lt;span&gt;&lt;strong&gt;数据流通管道&lt;/strong&gt;&lt;/span&gt;，在这个管道中，可以做很多事情。&lt;/p&gt;
&lt;p&gt;ChannelPipeline 是一种&lt;span&gt;&lt;strong&gt;职责链&lt;/strong&gt;&lt;/span&gt;，可以对其中流动的数据进行&lt;span&gt;&lt;strong&gt;过滤、拦截处理&lt;/strong&gt;&lt;/span&gt;，是一种&lt;span&gt;&lt;strong&gt;插拔式的链路装配器&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200619000457982-1182918482.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;437&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1、ChannelPipline是一个容器&lt;/h3&gt;
&lt;p&gt;支持查询、添加、删除、替换等容器操作。&lt;/p&gt;
&lt;h3&gt;2、ChannelPipline支持动态的添加和删除 Handler&lt;/h3&gt;
&lt;p&gt;ChannelPipline的这种特性给了我们相当的想象空间，例如动态的添加系统拥塞保护Handler，敏感数据过滤Handler、日志记录Handler、性能统计Handler等。&lt;/p&gt;
&lt;h3&gt;3、ChannelPipline 是线程安全的&lt;/h3&gt;
&lt;p&gt;ChannelPipline使用 &lt;span&gt;&lt;strong&gt;synchronized &lt;/strong&gt;&lt;/span&gt;实现线程安全，业务线程可以&lt;span&gt;&lt;strong&gt;并发的操作&lt;/strong&gt;&lt;/span&gt;ChannelPipline。但需要注意的是，&lt;span&gt;&lt;strong&gt;Handler是非线程安全的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;六、HandlerAdapter&lt;/h2&gt;
&lt;p&gt;Adapter是一种&lt;span&gt;&lt;strong&gt;适配器&lt;/strong&gt;&lt;/span&gt;，对于用户自定义的Handler，可以通过继承HandlerAdapter，来&lt;span&gt;&lt;strong&gt;规避不必要的接口实现&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200619004006549-1391336846.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;428&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 18 Jun 2020 16:49:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>Channel、EventLoop、Unsafe、multiplexor、AdaptiveRecvByteBufAllocator、ChannelPipeline...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/13155554.html</dc:identifier>
</item>
<item>
<title>【String注解驱动开发】面试官让我说说：如何使用FactoryBean向Spring容器中注册bean？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13160930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13160930.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8.8940092165899&quot;&gt;
&lt;p&gt;在前面的文章中，我们知道可以通过多种方式向Spring容器中注册bean。可以使用@Configuration结合@Bean向Spring容器中注册bean；可以按照条件向Spring容器中注册bean；可以使用@Import向容器中快速导入bean对象；可以在@Import中使用ImportBeanDefinitionRegistrar向容器中注册bean。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;factorybean概述&quot;&gt;FactoryBean概述&lt;/h2&gt;
&lt;p&gt;一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean 。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在标签中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可以得到一个更加简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。&lt;/p&gt;
&lt;p&gt;FactoryBean接口对于Spring框架来说占有重要的地位，Spring 自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring 3.0 开始， FactoryBean开始支持泛型，即接口声明改为FactoryBean 的形式：&lt;/p&gt;
&lt;p&gt;在Spring 5.2.6版本中，FactoryBean接口的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory;
import org.springframework.lang.Nullable;

public interface FactoryBean&amp;lt;T&amp;gt; {

        String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;

        @Nullable
        T getObject() throws Exception;

        @Nullable
        Class&amp;lt;?&amp;gt; getObjectType();

        default boolean isSingleton() {
                return true;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;T getObject()：返回由FactoryBean创建的bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中。&lt;/li&gt;
&lt;li&gt;boolean isSingleton()：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。&lt;/li&gt;
&lt;li&gt;Class getObjectType()：返回FactoryBean创建的bean类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这里，需要注意的是：当配置文件中标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;factorybean实例&quot;&gt;FactoryBean实例&lt;/h2&gt;
&lt;p&gt;首先，创建一个PersonFactoryBean，实现FactoryBean接口，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import org.springframework.beans.factory.FactoryBean;
/**
 * @author binghe
 * @version 1.0.0
 * @description 商品的FactoryBean，测试FactoryBean
 */
public class PersonFactoryBean implements FactoryBean&amp;lt;Person&amp;gt; {

    //返回一个Person对象，这个对象会被注册到Spring容器中
    @Override
    public Person getObject() throws Exception {
        return new Person();
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return Person.class;
    }

    //bean是否为单例;true:是；false:否
    @Override
    public boolean isSingleton() {
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在PersonConfig2类中加入PersonFactoryBean的声明，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public PersonFactoryBean personFactoryBean(){
    return new PersonFactoryBean();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要小伙伴们注意的是：我在这里使用@Bean注解向Spring容器中添加的是PersonFactory对象。那我们就来看看Spring容器中有哪些bean。接下来，运行SpringBeanTest类中的testAnnotationConfig7()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
personConfig2
io.mykit.spring.plugins.register.bean.Department
io.mykit.spring.plugins.register.bean.Employee
io.mykit.spring.plugins.register.bean.User
io.mykit.spring.plugins.register.bean.Role
person
binghe001
personFactoryBean
company
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，结果信息中输出了一个personFactoryBean，我们看下这个personFactoryBean到底是个什么鬼！此时，我们对SpringBeanTest类中的testAnnotationConfig7()方法稍加改动，添加获取personFactoryBean的代码，并输出personFactoryBean实例的类型，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAnnotationConfig7(){
    ApplicationContext context = new AnnotationConfigApplicationContext(PersonConfig2.class);
    String[] names = context.getBeanDefinitionNames();
    Arrays.stream(names).forEach(System.out::println);

    Object personFactoryBean = context.getBean(&quot;personFactoryBean&quot;);
    System.out.println(&quot;personFactoryBean实例的类型为：&quot; + personFactoryBean.getClass());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行SpringBeanTest类中的testAnnotationConfig7()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
personConfig2
io.mykit.spring.plugins.register.bean.Department
io.mykit.spring.plugins.register.bean.Employee
io.mykit.spring.plugins.register.bean.User
io.mykit.spring.plugins.register.bean.Role
person
binghe001
personFactoryBean
company
personFactoryBean实例的类型为：class io.mykit.spring.plugins.register.bean.Person
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，虽然我在代码中使用@Bean注解注入的PersonFactoryBean对象，但是，实际上从Spring容器中获取到的bean对象却是调用PersonFactoryBean类中的getObject()获取到的Person对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看到这里，是不是有种豁然开朗的感觉！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在PersonFactoryBean类中，我们将Person对象设置为单实例bean，接下来，我们在SpringBeanTest类中的testAnnotationConfig7()方法多次获取Person对象，并输出多次获取的对象是否为同一对象，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAnnotationConfig7(){
    ApplicationContext context = new AnnotationConfigApplicationContext(PersonConfig2.class);
    String[] names = context.getBeanDefinitionNames();
    Arrays.stream(names).forEach(System.out::println);

    Object personFactoryBean1 = context.getBean(&quot;personFactoryBean&quot;);
    Object personFactoryBean2 = context.getBean(&quot;personFactoryBean&quot;);
    System.out.println(personFactoryBean1 == personFactoryBean2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行testAnnotationConfig7()方法输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
personConfig2
io.mykit.spring.plugins.register.bean.Department
io.mykit.spring.plugins.register.bean.Employee
io.mykit.spring.plugins.register.bean.User
io.mykit.spring.plugins.register.bean.Role
person
binghe001
personFactoryBean
company
true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在PersonFactoryBean类的isSingleton()方法中返回true时，每次获取到的Person对象都是同一个对象，说明Person对象是单实例bean。&lt;/p&gt;
&lt;p&gt;这里，可能就会有小伙伴要问了，如果将Person对象修改成多实例bean呢？别急，这里我们只需要在PersonFactoryBean类的isSingleton()方法中返回false，即可将Person对象设置为多实例bean，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//bean是否为单例;true:是；false:否
@Override
public boolean isSingleton() {
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行SpringBeanTest类中的testAnnotationConfig7()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
personConfig2
io.mykit.spring.plugins.register.bean.Department
io.mykit.spring.plugins.register.bean.Employee
io.mykit.spring.plugins.register.bean.User
io.mykit.spring.plugins.register.bean.Role
person
binghe001
personFactoryBean
company
false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，最终结果返回了false，说明此时Person对象是多实例bean。&lt;/p&gt;
&lt;h2 id=&quot;如何在spring容器中获取到factorybean对象？&quot;&gt;如何在Spring容器中获取到FactoryBean对象？&lt;/h2&gt;
&lt;p&gt;之前，我们使用@Bean注解向Spring容器中注册的PersonFactoryBean，获取出来的确实Person对象。那么，小伙伴们可能会问：我就想获取PersonFactoryBean实例，该怎么办呢？&lt;/p&gt;
&lt;p&gt;其实，这也很简单， &lt;strong&gt;只需要在获取bean对象时，在id前面加上&amp;amp;符号即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;打开我们的测试类SpringBeanTest，在testAnnotationConfig7()方法中添加获取PersonFactoryBean实例的代码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAnnotationConfig7(){
    ApplicationContext context = new AnnotationConfigApplicationContext(PersonConfig2.class);
    String[] names = context.getBeanDefinitionNames();
    Arrays.stream(names).forEach(System.out::println);

    Object personFactoryBean1 = context.getBean(&quot;personFactoryBean&quot;);
    Object personFactoryBean2 = context.getBean(&quot;personFactoryBean&quot;);
    System.out.println(&quot;personFactoryBean1类型：&quot; + personFactoryBean1.getClass());
    System.out.println(&quot;personFactoryBean2类型：&quot; + personFactoryBean2.getClass());
    System.out.println(personFactoryBean1 == personFactoryBean2);

    Object personFactoryBean3 = context.getBean(&quot;&amp;amp;personFactoryBean&quot;);
    System.out.println(&quot;personFactoryBean3类型：&quot; + personFactoryBean3.getClass());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行SpringBeanTest类中的testAnnotationConfig7()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
personConfig2
io.mykit.spring.plugins.register.bean.Department
io.mykit.spring.plugins.register.bean.Employee
io.mykit.spring.plugins.register.bean.User
io.mykit.spring.plugins.register.bean.Role
person
binghe001
personFactoryBean
company
personFactoryBean1类型：class io.mykit.spring.plugins.register.bean.Person
personFactoryBean2类型：class io.mykit.spring.plugins.register.bean.Person
false
personFactoryBean3类型：class io.mykit.spring.plugins.register.bean.PersonFactoryBean
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在获取bean时，在id前面加上&amp;amp;符号就会获取到PersonFactoryBean实例对象。&lt;/p&gt;
&lt;p&gt;那问题又来了！！&lt;strong&gt;为什么在id前面加上&amp;amp;符号就会获取到PersonFactoryBean实例对象呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就揭开这个神秘的面纱，打开BeanFactory接口，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory;
import org.springframework.beans.BeansException;
import org.springframework.core.ResolvableType;
import org.springframework.lang.Nullable;

public interface BeanFactory {
        String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;;
    /**************以下省略n行代码***************/
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，是不是明白了呢？没错，在BeanFactory接口中定义了一个&amp;amp;前缀，只要我们使用bean的id来从Spring容器中获取bean时，Spring就会知道我们是在获取FactoryBean本身。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Jun 2020 16:25:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在前面的文章中，我们知道可以通过多种方式向Spring容器中注册bean。可以使用@Configuration结合@Bean向Spring容器中注册bean；可以按照条件向Spring容器中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13160930.html</dc:identifier>
</item>
<item>
<title>80386学习（五） 80386分页机制与虚拟内存 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/13068678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/13068678.html</guid>
<description>&lt;p&gt;　　80386能够将内存分为不同属性的段，并通过段描述符、段表以及段选择子等机制，通过段基址和段内偏移量计算出线性地址进行访问，这一内存管理方式被称为&lt;strong&gt;段式内存管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　这里要介绍的是另一种内存管理的方式：80386在开启了分页机制后，便能够将物理内存划分为一个个大小相同且连续的物理内存页，访问时通过物理内存页号和页内偏移计算出最终需要访问的线性地址进行访问，由于内存管理单元由段变成了页，因此这一内存管理方式被称为&lt;strong&gt;页式内存管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;80386的分页机制只能在保护模式下开启。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;为什么需要页式内存管理？&lt;/h2&gt;
&lt;p&gt;　　在介绍80386分页机制前，需要先理解为什么CPU在管理内存时，要在段式内存管理的基础上再引入一种有很大差异的页式内存管理方式？页式内存管理与纯段式内存管理相比到底具有哪些优点？&lt;/p&gt;
&lt;p&gt;　　一个很重要的原因是为了解决多任务环境下，&lt;strong&gt;段式内存管理中多任务的创建与终止时会产生较多内存碎片，使得内存空间使用率不高的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;内存碎片分为外碎片和内碎片两种。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;外碎片&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;对于指令和数据的访问通常都是连续的，所以需要为一个任务分配连续的内存空间&lt;/strong&gt;。在段式内存管理中，通常为任务分配一个完整的内存段，或是按照任务内段功能的不同，分配包括代码段、数据段和堆栈段在内的多个完整连续段空间。&lt;strong&gt;支持多道任务的系统分配的内存空间，会在某些任务退出并释放内存时，产生外部内存碎片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　举个例子，假设当前存在10MB的内存空间，存在A/B/C/D四个任务，并为每个任务分配一整块的内存空间，其所占用的内存空间分别为3MB/2MB/4MB/1MB，如下图所示(一个格子代表1MB内存)。&lt;/p&gt;
&lt;p&gt;　　当任务B和任务D执行完成后，所占用的内存空间被释放，10MB的内存空间中出现了3MB大小的空闲内存。如果此时出现了一个任务E，需要为其分配3MB的内存空间，此时内存虽然存在3MB的内存空间，却由于空闲内存的不连续，碎片化，导致无法直接分配给任务E使用。而这里任务B、任务D结束后释放的空余内存空间就被视为外碎片。&lt;/p&gt;
&lt;p&gt;　　这里的例子任务数量少且内存空间也很小。而在实际的32位甚至64位的系统中，物理内存空间少则4GB，多则几十甚至上百GB，由于任务内存的反复分配和释放，导致出现的外碎片的数量及浪费的内存空间会很多，很大程度上降低了内存空间的利用率。&lt;/p&gt;
&lt;p&gt;　　虽然理论上能够通过操作系统小心翼翼的挪动内存，使得外碎片能够拼接为连续的大块，得以被有效利用(内存紧缩)。但是操作系统挪动、复制内存本身很占用CPU资源，且存在对指令进行地址重定位、暂时暂停对所挪动内存区域的访问等附加问题，造成的效率降低程度几乎是不可忍受的，因此这一解决方案并没有被广泛使用。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202006/1506329-20200610234004524-1910338670.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;553&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;内碎片&lt;/h3&gt;
&lt;p&gt;　　外碎片指的是不同任务内存之间的碎片，而内碎片指的是一个任务内产生的内存碎片。&lt;/p&gt;
&lt;p&gt;　　通常操作系统为了管理多任务环境下的物理内存，会将内存分隔为固定大小的分区，使用系统表记录对应分区内存的使用情况(如是否已分配等)。分区的大小必须适当，如果分区过小，则相同物理内存大小下，系统表项过多使得所占用的空间过大；可如果分区过大，则会产生过大的内碎片，造成不必要的内存空间浪费。&lt;/p&gt;
&lt;p&gt;　　以上述介绍外碎片的数据为例，系统中的内存分区固定大小为1MB，其中为任务C分配了4个内存分区，共4MB大小。可实际上任务C实际只需要3.5MB的空间即可满足需求，但由于分区是内存管理的最小单元，只能为任务分配整数个的内存分区。3个分区3MB并不满足任务C的3.5MB的内存需求，因此只能分配4个分区给任务C。而这里任务C额外多占用的0.5MB内存就是内碎片。　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;内碎片就是已经被分配出去，却不能被有效利用的内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;80386是如何解决内存碎片问题的？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;外碎片的解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　外碎片问题产生的主要原因是程序所需要分配的内存空间是连续的。为此，80386提供了分页机制，使得最终分配给任务的物理内存空间可以不连续。如果任务所使用的内存不必连续，前面外碎片例子中提到的任务E就能够在1MB+2MB的离散物理内存上正常运行，外碎片问题自然就得到了解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内碎片的解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　内碎片从本质上来说是很难完全避免的(内存管理最小单元不能过小)，主要的问题在于前面提到的内存分区管理单元大小的较优值不好确定。开启了分页管理的80386，允许将物理内存分割最小为4KB固定大小的管理单元，这个固定大小的内存管理单元被称为页，并由专门的被称为页表的数据结构来追踪内存页的使用情况。&lt;/p&gt;
&lt;p&gt;　　对于页表项过多的问题，80386的设计者提供了多级页表机制，减少了页表所占用的空间。&lt;/p&gt;
&lt;p&gt;　　对于内碎片过大的问题，由于80386所运行的任务所占用的内存段一般远大于一个内存页的大小，因此页机制下所产生的内部碎片是十分有限的，可以达到一个令人满意的内存使用率。&lt;/p&gt;

&lt;p&gt;　　为了解决应用程序高速增长的内存需求与物理内存增加缓慢的矛盾，计算机科学家们提供了虚拟内存的概念。使用了虚拟内存的系统，可以使得系统内运行的程序所占用的内存空间总量，远大于实际物理内存的容量。&lt;/p&gt;
&lt;p&gt;　　能够实现虚拟内存的关键在于程序在特定时刻所需要访问的内存地址是符合&lt;strong&gt;局部性原理&lt;/strong&gt;的。通过操作系统和硬件的紧密配合，能够将任务暂时不需要访问的内存交换到外部硬盘中，而将物理内存留给真正需要访问的那部分内存(&lt;strong&gt;工作集内存&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　虚拟内存和分页机制是一对好搭档，分页机制提供了管理内存的基本单位：页，80386的页式虚拟内存实现在工作集内存调度时也依赖分页机制提供的页来进行。随着程序的执行，程序的工作集内存在动态变化，当CPU检测到当前所访问的内存页不在物理内存中时，便会通知操作系统(内存缺页异常)，操作系统的缺页异常处理程序会将硬盘交换区中的对应内存页数据写回物理内存。如果物理内存页已经满了的情况下，则还需要根据某种算法将另一个物理内存页替换，来容纳这一换入的内存页。&lt;/p&gt;

&lt;p&gt;　　在介绍分页机制原理之前，需要先理解关于80386保护模式下32位内存寻址时几种地址的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理地址(Physical Address)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　物理地址就是32位的地址总线所对应的真实的硬件存储空间。对于物理内存的访问，无论中间会经过多少次转换，最终必须转换为最终的物理地址进行访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑地址(Logical Address)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在80386保护模式的程序指令中，对内存的访问是由段选择子和段内偏移决定的。&lt;strong&gt;段选择子+段内偏移 --&amp;gt; 逻辑地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性地址(Linear Address)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;CPU在内存寻址时，从指令中获得段选择子和段内偏移，即逻辑地址。由段选择子在段表(GDT或LDT)中找到对应的段描述符，获取段基址。&lt;strong&gt;段基址+段内偏移决定线性地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果没有开启分页，CPU就使用生成的线性地址直接作为最终的物理地址进行访问；如果开启了分页，则还需要通过页表等机制，将线性地址进一步处理才能生成物理地址进行访问。&lt;/p&gt;
&lt;h2&gt;页式虚拟内存实现原理&lt;/h2&gt;
&lt;p&gt;　　程序要求访问一个段时，其线性地址必须是连续的。在纯粹的段式内存管理中，线性地址等于物理地址的情况下，就会出现外碎片的问题。而在段式内存管理的基础上，80386如果还开启了页机制，就能&lt;strong&gt;通过抽象出一层线性地址到物理地址的映射，使得最终分配给程序的物理内存段不必连续。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　80386中的内存页大小为4KB，在32位的内存寻址空间中(4GB)，存在着0x10000 = 1048576个页。每个页对应的起始地址低12位都为0，第一个物理内存页的物理地址为0x00000000，第二个物理内存页的物理地址为0x00001000，依此类推，最后一个物理页的物理地址是0xFFFFF000。&lt;/p&gt;
&lt;h2&gt;页表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在80386的分页机制的实现中，是通过页表来实现线性地址到物理地址映射转换的。&lt;strong&gt;每个任务都有一个自己的页表&lt;/strong&gt;，&lt;strong&gt;记录着任务的线性地址到物理地址的映射关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;开启了页机制后的线性地址也被称为虚拟地址&lt;/strong&gt;，这是因为线性地址已经不再直接对应真实的物理地址，而是一个不承载真实数据的虚拟内存地址。&lt;strong&gt;开启了分页机制后，一个任务的虚拟地址空间依然是连续的，但&lt;/strong&gt;所占用的物理地址空间却可以不连续。&lt;/p&gt;
&lt;p&gt;　　页表保存着被称为&lt;strong&gt;页表项&lt;/strong&gt;的数据结构集合，每一个页表项都记载着一个虚拟内存页到物理内存页的映射关系。开启了页机制之后，CPU在内存寻址时，在通过段表计算出了线性地址(虚拟地址)后，便可以在连续排布的虚拟地址空间中找到对应的页表项，通过页表项获取虚拟内存页所对应的物理内存页地址，进行物理内存的访问。虚拟地址到物理地址映射的细节会在后面进行展开。&lt;/p&gt;
&lt;p&gt;　　由于是将不断变化的虚拟内存页装载进相对不变的物理内存页中，就像画廊中展示的画会不断的更替，但画框基本不变一样。为了更好的区分这两者，&lt;strong&gt;页通常特指虚拟内存页，而物理内存页则被称为页框。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;页表项介绍&lt;/h3&gt;
&lt;p&gt;　　页表项是32位的，其结构如下图所示。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202006/1506329-20200613214426851-1944434721.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　P&lt;/strong&gt;(&lt;strong&gt;Present&lt;/strong&gt;)&lt;strong&gt;位&lt;/strong&gt;，存在位。标识当前虚拟内存页是否存在于物理内存页中。当P位为1时，表示当前虚拟内存页存在于物理内存中，可以直接进行访问。当P位为0时，表示对应的物理内存页不存在，需要新分配物理内存页或是从磁盘中将其调度回物理内存。&lt;/p&gt;
&lt;p&gt;　　分页模式下的内存寻址，如果CPU发现对应的页表项P位为0，会引发缺页异常中断，操作系统在缺页异常处理程序中进行对应的处理，以实现虚拟内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RW位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　RW(Read/Write)位，读写位。&lt;/strong&gt;标识当前页是否能够写入。当RW为1时，代表当前页可读可写；当RW为0时，代表当前页是只读的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;US位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　US(User/Supervisor)位，用户/管理位&lt;/strong&gt;。当US为1时，标识当前页是用户级别的，允许所有当前特权级的任务进行访问。当US为0时，表示当前页是属于管理员级别的，只允许当前特权级为0、1、2的任务进行访问，而当前特权级为3的用户态任务无法进行访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PWT位/PCD位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PWT(Page-level Write Through)位，页级通写位。&lt;/strong&gt;PWT为1时，表示当前物理页的高速缓存采用通写法；PWT为0时，表示当前物理页的高速缓存采用回写法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PCD(Page-level Cache Disable)位，页级高速缓存禁止位。&lt;/strong&gt;PCD为1时，表示访问当前物理页禁用高速缓存；PCD为0时，表示访问当前物理页时允许使用高速缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;PWT与PCD位的使用，涉及到了80386高速缓存的工作原理与内存一致性问题，限于篇幅不在这里展开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　A(Access)位，访问位。&lt;/strong&gt;A位为1时，代表当前页曾经被访问过；A位为0时，代表当前页没有被访问过。&lt;/p&gt;
&lt;p&gt;　　A位的设置由CPU固件在对应内存页访问时自动设置为1，且可以由操作系统在适当的时候通过程序指令重置为0，用以计算内存页的访问频率。通过访问频率，操作系统能够以此作为虚拟内存调度算法中评估的依据，在物理内存紧张的情况下，可以选择将最少使用的内存页换出，以减少不必要的虚拟内存页调度时的磁盘I/O，提高虚拟内存的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　D(Dirty)位，脏位。&lt;/strong&gt;当D位为1时，表示当前页被写入修改过；D位为0时，代表当前页没有被写入修改过。&lt;/p&gt;
&lt;p&gt;　　脏位由CPU在对应内存页被写入时自动设置为1。操作系统在进行内存页调度时，如果发现需要被换出的内存页D位为1时，则需要将对应物理内存页数据写回虚拟页对应的磁盘交换区，保证磁盘/内存数据的一致性；当发现需要被换出的物理内存页的D位为0时，表示当前页自从换入物理内存以来没有被修改过，和磁盘交换区中的数据一致，便直接将其覆盖，而不进行磁盘的写回，减少不必要的I/O以提高效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PAT位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PAT(Page Attribute Table)，页属性表支持位。&lt;/strong&gt;PAT位的存在使得CPU能够支持更复杂的，不同页大小的分页管理。当PAT=0时，每一页的大小为4KB；当PAT=1时，每一页的大小是4MB，或是其它大小(分CPU的情况而定)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G位:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　G(Global)，全局位。&lt;/strong&gt;表示当前页是否是全局的，而不是属于某一特定任务的。G=1时，表示当前页是全局的；G=0时，表示当前页是属于特定任务的。&lt;/p&gt;
&lt;p&gt;　　为了加速页表项的访问，80386提供了TLB快表，作为页表访问的高速缓存。当任务切换时，TLB内所有G=0的非全局页将会被清除，G=1的全局页将会被保留。将操作系统内核中关键的，频繁访问的页设置为全局页，使得其能够一直保存在TLB快表中，加速对其的访问速度，提高效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AVL位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　AVL(Avaliable)，可用位。&lt;/strong&gt;和段描述符中的AVL位功能类似，CPU并不使用它，而是提供给操作系统软件自定义使用。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页物理基地址字段：　　&lt;/strong&gt; 　　&lt;/p&gt;
&lt;p&gt;　　页物理基地址字段用于标识对应的物理页，共20位。&lt;/p&gt;
&lt;p&gt;　　由于32位的80386的页最小是4KB，而4GB的物理内存被分解为了最多0x10000个4KB的物理页。20位的页物理基地址字段作为物理页的索引标号与每一个具体的物理页一一对应。通过页物理基地址字段，便能找到唯一对应的物理内存页。&lt;/p&gt;
&lt;h2&gt;多级页表&lt;/h2&gt;
&lt;p&gt;　　在32位的CPU中，操作系统可以给每个程序分配至多4GB的虚拟内存空间，如果一个内存页占4KB，那么对应的每个程序的页表中最多需要存放着0x10000个页表项来进行映射。即使每个页表项只占小小的32位共4个字节(4Byte)，这依然是一个不小的内存开销(0x10000个页表项的大小为4MB)。&lt;/p&gt;
&lt;p&gt;　　一个应用程序虽然可以被分配4GB的虚拟内存空间，但实际上可能只使用其中的一小部分，例如40MB的大小。通常程序的堆栈段和数据段都分别位于虚拟内存空间的高低两端，并随着程序的执行慢慢的向中间扩展，由于页表项对应与虚拟地址空间的连续性，这就要求任务在执行时必须完整的定义整张页表。&lt;/p&gt;
&lt;p&gt;　　可以看到，&lt;strong&gt;一级的平面页表结构存在着明显的页表空间浪费的问题。&lt;/strong&gt;虽然可以要求应用程序不要一下子就以4GB的内存规格进行编程，而是一开始用较小的内存，并在需要更大内存时梯度的申请更大的内存空间，并重新构造数据段和堆栈段以减少每个任务的无用页表项空间的浪费。但这将页表空间优化的繁重任务强加给了应用程序，并不是一个好的解决办法。&lt;/p&gt;
&lt;p&gt;　　为此，计算机科学家们提出了&lt;strong&gt;多级页表的方案来解决页表项过多的问题&lt;/strong&gt;。多级页表顾名思义，页表的结构不再是一个一级的平面结构(一级页表)，而是像一颗树一样，由&lt;strong&gt;页目录项节点&lt;/strong&gt;和&lt;strong&gt;页表项节点&lt;/strong&gt;组成。目录节点中保存着下一级节点的物理页地址等信息，叶子节点中则包含着真正的页表项信息。查询页表项时，从一级页目录节点(根目录)出发，按照一定的规则可以找到对应的下一级子目录节点，直到查询出对应的叶子节点为止。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202006/1506329-20200615000824118-1327835411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;80386页目录项介绍&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;80386采用的是二级页表的设计，二级页表由页目录表和页表共同组成。&lt;strong&gt;页目录表中存放的是页目录项，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;页目录项的大小和页表项一致，为4字节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过80386指令得到的32位线性地址，其中高20位作为页表项索引，低12位作为页内偏移地址(4KB大小的物理页)。如果采用的是一级页表结构，20位的页表项索引能直接找到4MB页表中的对应页表项。&lt;/p&gt;
&lt;p&gt;　　而对于80386二级页表的设计来说，&lt;strong&gt;由于一个物理页大小为4KB，最多可以容纳1024(2^10)个页表项或者页目录项&lt;/strong&gt;，所以将页表项索引的高10位作为根目录页中页目录项的索引值，通过页目录项中的页表项物理页号可以找到对应的页表物理页；再根据页表项索引的后10位找到页表中对应的页表项。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202006/1506329-20200615003331305-327649121.png&quot; alt=&quot;&quot; width=&quot;1024&quot; height=&quot;508&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;80386页目录项结构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　80386的二级页表的页目录项占32位，其低12位的含义与页表项一致。主要区别在于其高20位存放的是下一级页表的物理页索引，而不是虚拟地址映射的物理内存页地址。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202006/1506329-20200615003450236-715712375.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;页表基址寄存器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;前面提到过，和LDT一样，每个任务都拥有着自己独立的页表。为此80386CPU提供了一个专门的寄存器用于追踪定位任务自己的页表，这个寄存器的名称叫做页表基址寄存器(&lt;strong&gt;Page Directory Base Register，PDBR&lt;/strong&gt;)，也就是控制寄存器CR3。&lt;/p&gt;
&lt;p&gt;　　由于80386分页机制使用的是二级页表，因此PDBR指向的是二级页表结构中的页目录，通过页目录表便能够间接的访问整个二级页表。为了效率其中存放的直接就是页目录表的32位物理地址，一般由操作系统负责在任务切换时将新任务对应的页目录表预先加载进物理内存。&lt;/p&gt;
&lt;p&gt;　　由于PDBR是和当前任务有关的，在任务切换时会被新任务TSS中的PDBR字段值所替换，指向新任务的页目录表，而旧任务的PDBR的值则在保护现场时被存入对应的TSS中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多级页表是如何解决页表项浪费问题的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以80386的二级页表设计为例，最大4GB的虚拟内存空间下，无论如何一级页目录表是必须存在的。当不需要为应用程序分配过多的内存时，页目录表中的页目录项所指向的对应页表可以不存在，即页目录项的P位为0，实际不使用的虚拟内存空间将没有对应的二级页表节点，相比一级页表的设计其浪费的内存会少很多。&lt;/p&gt;
&lt;p&gt;　　假设需要为一个虚拟地址首尾各需要分配20MB，共占用40MB内存的任务构建对应的页表。&lt;/p&gt;
&lt;p&gt;　　1. 如果使用一级页表，4GB的虚拟内存空间下需要提供0x10000个页表项，共4MB，页表的体积达到了任务自身所需40MB内存的10%，但其中绝大多数的页表项都是没用的(P位为0)，不会对应实际的物理内存，空间效率很低。&lt;/p&gt;
&lt;p&gt;　　2. 如果使用二级页表，除了占一个物理页4KB大小的页目录表是必须存在的外，其页目录表中只有首尾两项的P位为1，分别指向一个实际存在的页表(二级节点)，页目录表中间其它的页目录项P位都为0，不需要为这些不会使用到的虚拟地址分配页表。对于这个40MB的程序来说，其页表只占了3个物理页面，共12KB，空间效率相比一级页表高很多。&lt;/p&gt;
&lt;h2&gt;TLB快表&lt;/h2&gt;
&lt;p&gt;　　前面提到了多级页表所带来的好处：通过页表分层，可以减少顺序排列的无效页表项数量，节约内存空间；页表的层级越多，空间效率也越高。&lt;/p&gt;
&lt;p&gt;　　计算机领域中，通常并没有免费的午餐，一个问题的解决，往往会带来新的问题：&lt;strong&gt;多级页表本质上是一个树状结构，每一个节点页都是离散的，因此每一层级访问都需要进行一次内存寻址操作，页表的层级越多，访问的次数也就越多，虚拟页地址映射过程也越慢。&lt;/strong&gt;在32位的80386中，2级页表下问题还不算特别严重；但64位CPU的出现带来了更大的寻址空间，也需要更多的页表项，页表的层级也渐渐的从2级变成了3级、4级甚至更多。&lt;strong&gt;页机制开启之后，所有的内存寻址都需要经过CPU的页部件进行转化才能获得最终的物理地址，因此这一过程必须要快，不能因为页表的离散层次访问就严重影响虚拟地址空间到物理地址空间的转换速度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　要加快原本相对耗时的查询操作，一个常用的办法便是引入缓存。为了加速通用内存的访问，80386利用局部性原理提供了高速缓存；为了加速多级页表的页表项访问，80386提供了TLB。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TLB(Translation Lookaside Buffer)&lt;/strong&gt;直译为&lt;strong&gt;地址转换后援缓冲器&lt;/strong&gt;，根据其作用也被称为&lt;strong&gt;页表缓存&lt;/strong&gt;或是&lt;strong&gt;快表&lt;/strong&gt;(快速页表)。TLB中存放着一张表，其中的每一项用于缓存当前任务虚拟页号和对应页表项中的关键信息，被称为TLB项。&lt;/p&gt;
&lt;p&gt;　　TLB的工作原理和高速缓存类似：当CPU访问某一虚拟页时，通过虚拟页号先在TLB中寻找，如果发现对应的TLB项存在，则直接以TLB项中的数据进行物理地址的转换，这被称为TLB命中；当发现对应的TLB项不存在时(TLB未命中)，则进行内存的访问，在获取内存中页表项数据的同时，也将对应页表项缓存入TLB中。如果TLB已满则需要通过某种置换算法选出一个已存在的TLB项将其替换。&lt;/p&gt;
&lt;p&gt;　　TLB的查询速度比内存快，但容量相对内存小很多，因此只能缓存数量有限的页表项。但由于内存访问的局部性，只要通过合理的设计提高TLB的命中率(通常可以达到90%以上)，就能达到很好的效果。　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面总结一下开启了分页机制的80386是如何进行内存寻址的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. CPU首先从内存访问指令中获取段选择子和段内偏移地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 根据段选择子从段表(GDT或LDT)中查询出对应的段描述符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 根据段描述符中的段基址和指令中的段内偏移地址生成32位的线性地址(页机制下的虚拟地址)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. 32位的线性地址根据80386二级页表的设计，拆分成三个部分：高10位作为页目录项索引，中间次高10位作为页表项索引，低12位作为页内偏移地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5. 通过高10位的页目录项索引从一级页目录表中获取二级页表的物理页地址(通过物理页框号可得)，再根据中间10位的页表项索引找到对应的物理页框。根据物理页框号与页内偏移地址共同生成最终的物理地址，进行物理内存的访问。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;想要通过学习操作系统来更好的理解计算机程序底层的工作原理，基础的硬件知识是必须要了解的。纸上得来终觉浅，绝知此事要躬行，在理解了基础原理后，还需要通过实践来加深对原理知识的理解，而阅读相关操作系统的实现源码就是一个很好的将实践与原理紧密结合的学习方式。&lt;/p&gt;
&lt;p&gt;　　希望通过对硬件和操作系统的学习能帮助我打开计算机程序底层运行的神秘黑盒子一窥究竟，在思考问题时能够换一个角度从底层的视角出发，去更好的理解和掌握上层的应用技术，以避免迷失在快速发展的技术浪潮中。&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jun 2020 15:54:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>一. 页式内存管理介绍 80386能够将内存分为不同属性的段，并通过段描述符、段表以及段选择子等机制，通过段基址和段内偏移量计算出线性地址进行访问，这一内存管理方式被称为段式内存管理。 这里要介绍的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiongcanguan/p/13068678.html</dc:identifier>
</item>
<item>
<title>如何只用5分钟完成数据 列表、创建页面 - 连程</title>
<link>http://www.cnblogs.com/anxin1225/p/13160847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin1225/p/13160847.html</guid>
<description>&lt;p&gt;我们当然希望能够更快的完成我们的工作，这样我们才能有更多的时间做其他的事情，比如说测试、学习、放松。&lt;/p&gt;

&lt;p&gt;软件一般也就这么几个方面的工作要做，增、删、改、查。如果归结到页面上来说，那么无非也就这么几个页面Form页面（增）、列表页面（查、删）、编辑页面（改）。很大程度上，你的项目就是由不同的实体的这么几个页面组装起来的。既然他们都是这么几个页面，那么，我们是不是可以考虑针对这几个页面进行抽象呢？然后使用数据描述这几个页面的行为。&lt;/p&gt;

&lt;p&gt;经典倒叙，先上效果图&lt;/p&gt;
&lt;h2 id=&quot;列表页面&quot;&gt;列表页面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c8095099259ca?w=837&amp;amp;h=1079&amp;amp;f=png&amp;amp;s=51171&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建页面&quot;&gt;创建页面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c809aa268db38?w=837&amp;amp;h=1079&amp;amp;f=png&amp;amp;s=49705&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前就简单实现了列表页面和创建页面。编辑页面，跟创建页面太像了。暂时还没有实现相关内容，不过，这个不是很重要了。&lt;/p&gt;

&lt;h2 id=&quot;需求分析&quot;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;其实，每个页面都是存在固定的路数的。&lt;/p&gt;
&lt;p&gt;比如说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表页面&lt;/strong&gt;里边主要存在这么几个参数：列表名、列表头上的按钮、列表的表头、列表内容、列表每一行中的操作、分页控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表单页面&lt;/strong&gt;列表主要存在这么几个参数：表单名、表单内容项。&lt;/p&gt;
&lt;p&gt;主要的参数出现的位置都是固定的。但是什么地方出现什么内容则是可以变化的，一般情况下，我们都是通过代码，一遍一遍的重写这些页面，然后来达到不同的应用之间的变化的目的。其实我们是可以通过数据来描述他们的。比如说向下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c815e4ab1c036?w=965&amp;amp;h=376&amp;amp;f=png&amp;amp;s=22372&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;列表页面的定义&quot;&gt;列表页面的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c810b3043370b?w=641&amp;amp;h=674&amp;amp;f=png&amp;amp;s=53034&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;form表单页面的定义&quot;&gt;Form表单页面的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c8125777c2370?w=615&amp;amp;h=514&amp;amp;f=png&amp;amp;s=39583&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;原始数据的定义&quot;&gt;原始数据的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c812c8939a8d0?w=611&amp;amp;h=500&amp;amp;f=png&amp;amp;s=31136&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后将这些定义好的属性通过后端渲染到页面上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c8142b2b8731d?w=1549&amp;amp;h=1000&amp;amp;f=png&amp;amp;s=124090&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c81467c7f390b?w=1574&amp;amp;h=779&amp;amp;f=png&amp;amp;s=105091&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就可以达到，前边展示的这种效果了。&lt;/p&gt;
&lt;h3 id=&quot;数据存储&quot;&gt;数据存储&lt;/h3&gt;
&lt;p&gt;因为数据类型是自定义的，所以数据存储的字段也是可以自己随便预设的。然后系统就可以直接支持这一数据类型。在这个Demo里边，我是简单粗暴的使用了文件存储Json文件的方式来进行保存的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c819a46214611?w=988&amp;amp;h=338&amp;amp;f=png&amp;amp;s=15960&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实应该链接数据库的。不过我在Demo项目里边留下了相关的接口，只要再实现一个数据库版本的实例就可以无缝对接了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c81a946b91e01?w=406&amp;amp;h=459&amp;amp;f=png&amp;amp;s=23967&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其实&quot;&gt;其实&lt;/h3&gt;
&lt;p&gt;当然了这只是他的最初级的形态，因为现在写的配置文件都是通过手写来实现，将来可以做一个编辑器。并且可以实时看到调整过的效果。&lt;/p&gt;
&lt;p&gt;其实这个做法，是来源于PaaS项目中的一个很小很小的功能块。真正的PaaS项目这一整套东西都是在线上直接编辑看效果的。&lt;/p&gt;

&lt;h2 id=&quot;系列&quot;&gt;系列&lt;/h2&gt;
&lt;p&gt;这个项目将来会融入到我写的PaaS Demo中作为前端展示部分。 系列的目录在 &lt;a href=&quot;https://juejin.im/post/5eca2a186fb9a047e96b2884&quot;&gt;https://juejin.im/post/5eca2a186fb9a047e96b2884&lt;/a&gt; 这个部分会一点点完善。&lt;/p&gt;
&lt;h2 id=&quot;开源&quot;&gt;开源&lt;/h2&gt;
&lt;p&gt;虽然东西不大，但是还是希望能给你一点点启发。 项目地址 &lt;a href=&quot;https://gitee.com/anxin1225/Dov.GenericWeb&quot;&gt;https://gitee.com/anxin1225/Dov.GenericWeb&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单的体验&quot;&gt;简单的体验&lt;/h2&gt;
&lt;p&gt;部署到云端了，可以简单体验一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gw.ash50p.com/Generic/Meeting.Record/List&quot;&gt;http://gw.ash50p.com/Generic/Meeting.Record/List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载莫忘原文地址：&lt;a href=&quot;https://juejin.im/post/5eeb85b8e51d45740850f755&quot;&gt;https://juejin.im/post/5eeb85b8e51d45740850f755&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jun 2020 15:53:00 +0000</pubDate>
<dc:creator>连程</dc:creator>
<og:description>前言 我们当然希望能够更快的完成我们的工作，这样我们才能有更多的时间做其他的事情，比如说测试、学习、放松。 背景 软件一般也就这么几个方面的工作要做，增、删、改、查。如果归结到页面上来说，那么无非也就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/anxin1225/p/13160847.html</dc:identifier>
</item>
</channel>
</rss>