<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>阿里云移动端播放器高级功能---直播时移 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10477255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10477255.html</guid>
<description>&lt;h2 id=&quot;1&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689912.i0.26f9ede669rCB0&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;通常都知道直播是无法seek拖动的，那么针对在直播中想回看之前直播过的内容的用户来说，直播时移就能派上用场。我们阿里云播放器支持了直播时移功能，用户能较为方面和快速的使用直播时移的功能。&lt;br/&gt;先来看一下直播时移的介绍：时移直播基于常规的HLS视频直播，直播推流被切分成TS分片，通过HLS协议向播放用户分发，用户请求的m3u8播放文件中包含不断刷新的TS分片地址；对于常规的HLS直播而言，TS分片地址及相应的TS文件并不持久化保存，导致当前时间之前的直播视频内容无法回溯；而对于开通了时移功能的HLS直播而言，TS分片地址及相应TS文件会分别在数据库和OSS中持久化保存最长15天，使得回溯从直播开始时间到当前时间之间的视频内容成为可能。&lt;br/&gt;更多的信息可以参考官网介绍：直播时移&lt;/p&gt;
&lt;p&gt;先来看一下时移效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201903/1482139-20190305154453067-1408985412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;2&quot;&gt;时移原理&lt;/h2&gt;
&lt;p&gt;时移是通过时间轴url(TimeLineUrl) 去实时获取到可以时移的时间范围。在这个时间范围内的直播流，可以往回拖拽，回看之前的内容。拖拽时，播放器内部通过更新直播流的地址，加上起播的时间参数，然后从服务器拉取新的流，达到回看的目的。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;接口和示例&lt;/h2&gt;
&lt;h3 id=&quot;4&quot;&gt;Android使用&lt;/h3&gt;
&lt;h4 id=&quot;5&quot;&gt;时移源的设置&lt;/h4&gt;
&lt;p&gt;AliyunVodPlayer 提供了 &lt;code&gt;AliyunLiveTimeShift&lt;/code&gt; 这个类作为直播时移的播放源。其中&lt;code&gt;setUrl&lt;/code&gt;和&lt;code&gt;setTimeLineUrl&lt;/code&gt;是主要涉及的两个地址。&lt;br/&gt;setUrl:这个设置的是直播流的地址。通过这个地址，播放器播放对应的直播源。&lt;br/&gt;setTimeLineUrl：这个设置的是时移区间的获取地址。播放器将会每隔1分钟调用一次此接口去更新时移时间段。&lt;br/&gt;（如何生成TimeLineUrl，请参考：直播时移）&lt;/p&gt;
&lt;h4 id=&quot;6&quot;&gt;时移信息的获取&lt;/h4&gt;
&lt;p&gt;时移的获取，跟普通的点播信息获取基本类似，但是有特有的新增接口（Android）：&lt;br/&gt;getCurrentLiveTime:获取当前直播的时间点。&lt;br/&gt;getCurrentTime：获取当前播放的时间点。&lt;/p&gt;
&lt;p&gt;比如：现在是2019-01-30 14:01:04，播放的时候，往前时移了1分钟。那么：&lt;br/&gt;getCurrentLiveTime = 2019-01-30 14:01:04。&lt;br/&gt;getCurrentTime = 2019-01-30 14:00:04。&lt;/p&gt;
&lt;h4 id=&quot;7&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot; language-undefined&quot;&gt;
&lt;code class=&quot;language- language-undefined&quot;&gt;//1.创建时移对象
mAliyunLiveTimeShift = new AliyunLiveTimeShift();
long currentSeconds = System.currentTimeMillis() / 1000;

//2.设置直播流地址
mAliyunLiveTimeShift.setUrl(&quot;http://pull-videocall.aliyuncs.com/timeline/test.m3u8&quot;);

//3.设置时移区间地址。
mAliyunLiveTimeShift.setTimeLineUrl(&quot;http://pull-videocall.aliyuncs.com/openapi/timeline/query?lhs_start=1&amp;amp;app=timeline&amp;amp;stream=test&amp;amp;format=ts&amp;amp;lhs_start_unix_s_0=&quot;
                + (currentSeconds - 5 * 60) + &quot;&amp;amp;lhs_end_unix_s_0=&quot; + (currentSeconds + 5 * 60));

//4.准备时移源。
mPlayer.prepareAsync(mAliyunLiveTimeShift);

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;8&quot;&gt;iOS接口和示例&lt;/h3&gt;
&lt;p&gt;iOS提供了以下接口来使用直播时移：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot; language-undefined&quot;&gt;
&lt;code class=&quot;language- language-undefined&quot;&gt;//直播时间
@property (nonatomic, assign) NSTimeInterval liveTime;

//播放时间
@property (nonatomic, assign) NSTimeInterval currentPlayTime;

//每60秒更新用户时移时间，设置更新区间url后，可以获取
@property (nonatomic, strong) AliyunPlayerVideoTimeShiftModel *timeShiftModel;

//设置直播数据源
- (void)prepareWithLiveTimeUrl:(NSURL *)liveTimeUrl;

//设置时移区间更新url
- (void)setLiveTimeShiftUrl:(NSString*)liveTimeShiftUrl;

//时移到指定的时间
- (void)seekToLiveTime:(NSTimeInterval)startTime;

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体使用过程：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot; language-undefined&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689912.i1.26f9ede669rCB0&quot;&gt;
&lt;code class=&quot;language- language-undefined&quot;&gt;//1.设置时移区间更新url，地址需要用当前时间来进行拼写
NSTimeInterval currentSeconds = [[NSDate date] timeIntervalSince1970]; //秒
    NSString *currentLive = [NSString stringWithFormat:@&quot;http://push-demo.aliyunlive.com/openapi/timeline/query?app=asr&amp;amp;stream=yunxi&amp;amp;format=ts&amp;amp;lhs_start_unix_s_0=%.0f&amp;amp;lhs_end_unix_s_0=%.0f&quot;,(currentSeconds - 5 * 60), (currentSeconds + 5 * 60)];
[self.vodPlayer setLiveTimeShiftUrl:currentLive];

//2. 准备直播时移播放地址
[self.vodPlayer prepareWithLiveTimeUrl:[NSURL URLWithString:@&quot;http://push-demo.aliyunlive.com/asr/yunxi.m3u8&quot;]];

//3. 播放成功后可以更新界面UI显示
//开始时间
double start = self.vodPlayer.timeShiftModel.startTime;
//记录总的结束时间
self.vodPlayer.timeShiftModel.endTime

//4. 拖动seek时移区间，通过进度条计算出来具体的时移时间
[self.vodPlayer seekToLiveTime:(int)(n*sender.value+s)];&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/689912?utm_content=g_1000044537&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 07:45:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>基本介绍 通常都知道直播是无法seek拖动的，那么针对在直播中想回看之前直播过的内容的用户来说，直播时移就能派上用场。我们阿里云播放器支持了直播时移功能，用户能较为方面和快速的使用直播时移的功能。先来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10477255.html</dc:identifier>
</item>
<item>
<title>Java 并发系列（一） ThreadPoolExecutor源码解析及理解 - nolan4954</title>
<link>http://www.cnblogs.com/nolan4954/p/10477200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nolan4954/p/10477200.html</guid>
<description>&lt;p&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;它是线程池最核心的类, 这里对核心的方法做简要的剖析（会持续更新），以加深对线程池运行原理的理解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 核心成员变量及相关方法&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctl非常重要，用整型表示，共32位，其中**高3位代表线程池状态，低29位代表工作线程数**；
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池状态初始化为RUNNING，工作线程数为0&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 偏移量29&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COUNT_BITS = Integer.SIZE - 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 理论最大线程数（约500万）&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1左偏移29位（下同），运行中状态，既能接收新提交的任务，又能执行阻塞队列中的任务&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭状态，不再接收新提交的任务，但还能继续执行阻塞队列中的任务(调用shutdown()可以进入此状态)&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止状态，不再接收新提交的任务，也不再执行队列中的任务；而且会尝试中断正在执行的工作线程(调用shutdownNow()可以进入此状态)&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清理状态，当workCount(工作线程数)为0，且队列也为空时就是此状态
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SHUTDOWN -&amp;gt; TIDYING 线程数为0，队列也为空时会自动进入改状态
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; STOP -&amp;gt; TIDYING 线程数为0时，就会自动进入该状态&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结状态 可以通过调用awaitTermination方法来来等待线程池彻底终结&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池运行状态；因为CAPACITY为29个1，取反后是29个0，再通过&amp;amp;运算会取出最高的3位&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runStateOf(&lt;span&gt;int&lt;/span&gt; c)     { &lt;span&gt;return&lt;/span&gt; c &amp;amp; ~&lt;span&gt;CAPACITY; }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中线程数；取出最低的29位&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt; c)  { &lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将运行状态与线程数拼接起来，共有恰好有32位（因为rs已经左偏移29位了！）&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ctlOf(&lt;span&gt;int&lt;/span&gt; rs, &lt;span&gt;int&lt;/span&gt; wc) { &lt;span&gt;return&lt;/span&gt; rs | wc; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 核心构造方法&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;*   1. 共有7个参数
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*   2. 具体实现不再细说，只简单说下各个作用（就是使用流程）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*   corePoolSize: 核心线程数，如果总工作线程数小于核心线程数, 有新任务时则会继续创建新的线程
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*   maximumPoolSize: 最大线程数，理论上包含了核心线程数和非核心线程数
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*   keepAliveTime: 一般上（allowCoreThreadTimeOut=false)是指非核心线程没有任务执行的存活时间（可以通过getTask()方法去分析）
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*   TimeUnit: keepAliveTime的时间单位
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*   workQueue: 阻塞队列，其中包含有SynchronousQueue, ArrayBlockingQueue, LinkedBlockingQueue; 存放核心线程执行不过来时被提交的任务
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;*   threadFactory: 线程工厂，创建线程的地方
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*   handler: 拒绝策略，线程池满时会执行该策略rejectedExecution()方法；自带有4种拒绝策略，默认使用抛异常拒绝策略，另有什么都不做策略，用调用者线程执行任务策略，抛弃最旧任务策略
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;*   注意：1. 核心线程和非核心线程只是个逻辑的概念，某个线程被创建后，一开始可能是核心的，到后来会变成非核心的，身份并不固定。（看具体getTask()时会不会得到null)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;*        2. 流程归总：当新任务被提交后，当工作线程数小于核心核心线程数时，会继续创建线程来处理此任务，否则会将其放在阻塞队列中；若阻塞队列已满，则会创建线程来处理此任务；若创建线程失败（不小于了最大线程数），则会执行拒绝策略。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                              ThreadFactory threadFactory,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                              RejectedExecutionHandler handler) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||
&lt;span&gt;23&lt;/span&gt;             maximumPoolSize &amp;lt;= 0 ||
&lt;span&gt;24&lt;/span&gt;             maximumPoolSize &amp;lt; corePoolSize ||
&lt;span&gt;25&lt;/span&gt;             keepAliveTime &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span&gt;null&lt;/span&gt; ?
&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;null&lt;/span&gt;&lt;span&gt; :
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                AccessController.getContext();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;3. 疑问&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;1. 线程池属于terminated后，是怎么样释放资源的？terminated()方法是空实现?&lt;/p&gt;
&lt;p&gt;2. execute()添加到队列后为什么还要recheck?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 05 Mar 2019 07:38:00 +0000</pubDate>
<dc:creator>nolan4954</dc:creator>
<og:description>ThreadPoolExecutor 它是线程池最核心的类, 这里对核心的方法做简要的剖析（会持续更新），以加深对线程池运行原理的理解。 1. 核心成员变量及相关方法 1 // ctl非常重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nolan4954/p/10477200.html</dc:identifier>
</item>
<item>
<title>JavaScript构造函数原理 - 孙红岩</title>
<link>http://www.cnblogs.com/itstone/p/10477020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itstone/p/10477020.html</guid>
<description>&lt;p&gt;1.var obj={} plainObject 对象字面量/对象直接量&lt;br/&gt;2.构造函数创建&lt;br/&gt;1）。系统自带的构造函数 Object() var obj=new Object(); 和 var obj = {} 没区别 &lt;/p&gt;
&lt;p&gt;         原则上来说，使用字面量的形式要比new对象的形式要有效率  如下图 chrome上测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/296068/201903/296068-20190305151644568-865454601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;2）。自定义&lt;br/&gt;function Car(){&lt;br/&gt;this.name= &quot;BWM&quot;;&lt;br/&gt;this.height=&quot;1400&quot;;&lt;br/&gt;this.lang=&quot;4900&quot;;&lt;br/&gt;this.weight=1000;&lt;br/&gt;this.health=100;&lt;br/&gt;this.run=function(){&lt;br/&gt;this.health --;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;var car = new Car();&lt;br/&gt;var car1 = new Car();&lt;/p&gt;
&lt;p&gt;构造函数的原理&lt;br/&gt;1.有了new后 在函数最顶端有一个var this={} ;然后会在this里会加上自定义加的属性等&lt;br/&gt;2.执行this.xxx = xxx;&lt;br/&gt;3.隐式的返回this&lt;/p&gt;
&lt;p&gt;function Person(name,heigth){&lt;br/&gt;//var this = {}&lt;br/&gt;this.name=name;&lt;br/&gt;this.height = height;&lt;br/&gt;//return this; //隐式返回&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;每一个js函数都是有返回值的，其返回值是由隐式this创建的。&lt;/p&gt;

</description>
<pubDate>Tue, 05 Mar 2019 07:18:00 +0000</pubDate>
<dc:creator>孙红岩</dc:creator>
<og:description>1.var obj={} plainObject 对象字面量/对象直接量2.构造函数创建 1）。系统自带的构造函数 Object() var obj=new Object(); 和 var obj =</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itstone/p/10477020.html</dc:identifier>
</item>
<item>
<title>浅析关于java的一些基础问题（上篇） - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10474765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10474765.html</guid>
<description>&lt;p&gt;       要想让一个问题变难，最基本有两种方式，即极度细化和高度抽象。对于任何语言的研究，良好的基础至关重要，本篇文章，将从极度细化的角度&lt;/p&gt;
&lt;p&gt;来解析一些java中的基础问题，这些问题也是大部分编程人员的软肋或易混淆点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一  关于String问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.String是基本类型(值类型)还是引用类型？&lt;/p&gt;
&lt;p&gt; （1）String是引用类型。通过查看jdk，String是一个类，既然是一个类，那么就是引用类型；&lt;/p&gt;
&lt;p&gt; （2）基本类型包括：int,float,boolean,byte，凡是通过new关键字的，都属于引用类型，如&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;一般情况，引用类型是通过new关键字，如ClassA  a=new ClassA() ,a就是引用类型，引用类型存储在内存堆中，而值类型存储在内存栈中。&lt;/p&gt;
&lt;p&gt;堆和栈的区别是，栈存取速度快，固定存储长度；而堆长度根据运行时实际情况分配，速度慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.String str1=“Alan”与String str2=new String(&quot;Alan&quot;)区别？&lt;/p&gt;
&lt;p&gt;回答该问题，就涉及到java虚拟机常量池问题&lt;/p&gt;
&lt;p&gt;（1）在常量池中，不存在两个相同的变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String str1=&quot;Alan_beijing&quot;&lt;span&gt;;
String str2&lt;/span&gt;=&quot;Alan_beijing&quot;&lt;span&gt;;

System.out.println(str1&lt;/span&gt;==str2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
System.out.println(str1.equals(str2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明str1和str2指向同一个对象。&lt;/p&gt;
&lt;p&gt;（2）每new一个对象，就新增加一个对象，不管常量池中是否存在相同的变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String str1=&quot;Alan_beijing&quot;&lt;span&gt;;
String str2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;Alan_beijing&quot;&lt;span&gt;);

System.out.println(str1&lt;/span&gt;==str2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
System.out.println(str1.equals(str2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.equals和==区别？&lt;/p&gt;
&lt;p&gt;(1)核心区别：equals比较对象值是否相等，==比较是否是同一个对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String str1=&quot;Alan_beijing&quot;&lt;span&gt;;
String str2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;Alan_beijing&quot;&lt;span&gt;);

System.out.println(str1&lt;/span&gt;==str2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
System.out.println(str1.equals(str2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.为什么StringBuilder相对于String字符串拼接比较快？&lt;/p&gt;
&lt;p&gt;知道了1-3答案，这个问题就非常容易解决了，因为每拼接一个字符串，就要new一个对象，占用内存堆，而StringBuilder不需要，故比较快。&lt;/p&gt;
&lt;p&gt;String str=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;//要额外增加3个变量，“ab”,&quot;abc&quot;,'abcd'&lt;/p&gt;
&lt;p&gt; 5.考虑如下问题答案&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String str0=&quot;Alan&quot;&lt;span&gt;;
String str1&lt;/span&gt;=&quot;Alan&quot;&lt;span&gt;;
String str2&lt;/span&gt;=&quot;A&quot;+&quot;lan&quot;&lt;span&gt;;
String str3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;Alan1&quot;&lt;span&gt;);
String str4&lt;/span&gt;=&quot;A&quot;+&lt;span&gt;new&lt;/span&gt; String(&quot;lan&quot;&lt;span&gt;);
String str5&lt;/span&gt;=&lt;span&gt;str3.intern();


System.out.println(str0&lt;/span&gt;==&lt;span&gt;str1);
System.out.println(str1&lt;/span&gt;==&lt;span&gt;str2);
System.out.println(str1&lt;/span&gt;==&lt;span&gt;str3);
System.out.println(str3&lt;/span&gt;==&lt;span&gt;str4);
System.out.println(str1&lt;/span&gt;==str5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二  关于集合问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.HashMap,TreeMap,HashSet和HashTable比较&lt;/p&gt;
&lt;p&gt;（1）实现接口不一样。HashMap和HashTable实现Map接口，而HashSet实现Set接口&lt;/p&gt;
&lt;p&gt;（2）线程安全性不一样。HashMap线程不安全(异步锁)，HashTable线程安全(同步锁)，HashSet线程不安全,因为它的底层&lt;/p&gt;
&lt;p&gt;是由HashMap不重复key实现的。&lt;/p&gt;
&lt;p&gt;（3）性能从高到底&lt;/p&gt;
&lt;p&gt;HashMap&amp;gt;HashSet&amp;gt;HashTable&lt;/p&gt;
&lt;p&gt;（4）K,V是否为null&lt;/p&gt;
&lt;p&gt;HashMap的K,V都可以存放null;&lt;/p&gt;
&lt;p&gt;HashTable的K,V不能存放null;&lt;/p&gt;
&lt;p&gt;HashSet只能V存放nll,K不能存放null&lt;/p&gt;
&lt;p&gt;（5）存储内容差异&lt;/p&gt;
&lt;p&gt;HashMap&amp;lt;k,v&amp;gt;和HashTable&amp;lt;k,v&amp;gt;存储k,v,而HashSet&amp;lt;E&amp;gt;存储对象&lt;/p&gt;
&lt;p&gt;（6）HashMap和TreeMap区别&lt;/p&gt;
&lt;p&gt;TreeMap保存对象排列次序，HashMap不须保存对象排列次序&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三 关于IO种类划分问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IO从种类上，一般划分为字符流和字节流两大类，其中，字符流是以Reader或Writer结尾的，如InputStreamReader,&lt;/p&gt;
&lt;p&gt;OutputStreamWriter；而字节流是以Stream结尾的，如InputStream,OutputStream。他们的继承关系如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201903/1066923-20190305142414813-749816079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 四  关于异常问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）所有的异常类继承类Throwable&lt;/p&gt;
&lt;p&gt;（2）异常从种类上来划分，分为非受查异常(派生于所有Error或RuntimeException)和受查异常&lt;/p&gt;
&lt;p&gt;（3）自定义异常类，只需继承Exception类或Exception下的任何子类即可&lt;/p&gt;
&lt;p&gt;（4）何为异常传递？指异常传递给调用的子类，而不在自己内部实现异常，通过throws向调用的类传递异常。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201903/1066923-20190305143101238-1378039370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五  值传递和引用传递&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值传递传递的是值，引用传递传递的是地址(也可叫做指针)&lt;/p&gt;
&lt;p&gt;下面的的代码，最终输出结果为15 0 20，请考虑为什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; demo.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MGenalTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        first();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; first(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=5&lt;span&gt;;
        Value v&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Value();
        v.i&lt;/span&gt;=25&lt;span&gt;;
        second(v,i);
        System.out.println(v.i);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; second(Value v,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
        i&lt;/span&gt;=0&lt;span&gt;;
        v.i&lt;/span&gt;=20&lt;span&gt;;
        Value val&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Value();
        v&lt;/span&gt;=&lt;span&gt;val;
        System.out.println(v.i&lt;/span&gt;+&quot; &quot;+&lt;span&gt;i);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Value{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i=15&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六 反射&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java中的反射是一种强大的工具，它能够创建灵活的代码，这些代码可以在运行时装配，无须再组件之间进行链接，反射允许&lt;/p&gt;
&lt;p&gt;在编写与执行时，使程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七  序列化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于序列化，只需实现接口Serializable即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Serializable {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;八  JVM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于JVM，重点了解JVM垃圾回收机制，一般情况地，对象在垃圾回收前，会先调用方法finalize()，然后再调用gc()方法。&lt;/p&gt;
&lt;p&gt;关于垃圾回收机制问题，有很多回收算法，不同的算法，实现不同的机制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;九 算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于算法，递归算法考察比较多，如斐波拉列数列 1，1，2，3，5，8，。。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;十 版权区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;   转载博客，必须注明博客出处&lt;/li&gt;
&lt;li&gt;   博主网址：http://www.cnblogs.com/wangjiming/&lt;/li&gt;
&lt;li&gt;   如您有新想法，欢迎提出，邮箱：2098469527@qq.com&lt;/li&gt;
&lt;li&gt;  专业.NET之家技术QQ群：490539956&lt;/li&gt;
&lt;li&gt;  专业化Java之家QQ群：924412846&lt;/li&gt;
&lt;li&gt;  有问必答QQ群：2098469527&lt;/li&gt;
&lt;li&gt;  一对一技术辅导QQ：2098469527&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 05 Mar 2019 07:12:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>要想让一个问题变难，最基本有两种方式，即极度细化和高度抽象。对于任何语言的研究，良好的基础至关重要，本篇文章，将从极度细化的角度 来解析一些java中的基础问题，这些问题也是大部分编程人员的软肋或易混</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10474765.html</dc:identifier>
</item>
<item>
<title>安卓开发笔记（九）：广播动态注册实现监听网络变化 - Geeksongs</title>
<link>http://www.cnblogs.com/geeksongs/p/10476961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geeksongs/p/10476961.html</guid>
<description>&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android 中的广播主要分两种类型：标准广播和有序广播。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;标准广播&lt;/strong&gt;（Normal broadcasts）&lt;br/&gt;  是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可 言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。标准广播的工作流程如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;390&quot; data-height=&quot;205&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2509931-4d74e7a20cf39fb9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/390/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/2509931-4d74e7a20cf39fb9.jpg&quot; data-original-width=&quot;390&quot; data-original-height=&quot;205&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;14520&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;标准广播工作示意图&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有序广播&lt;/strong&gt;（Ordered broadcasts）&lt;br/&gt;  是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。有序广播的工作流程如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;558&quot; data-height=&quot;207&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2509931-4fbd17c536317710.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/2509931-4fbd17c536317710.jpg&quot; data-original-width=&quot;558&quot; data-original-height=&quot;207&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;18947&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;有序广播工作示意图&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;p&gt;注册广播的方式有两种，在代码中注册（动态注册）和在 AndroidManifest.xml 中注册（静态注册）。&lt;/p&gt;
&lt;p&gt;创建一个广播接收器：新建一个类，继承 BroadcastReceiver， 并重写父类的 onReceive() 方法。当有广播到来时，onReceive()方法就会得到执行， 具体的逻辑在这个方法中处理。&lt;/p&gt;
&lt;p&gt;接下来先通过动态注册的方式编写一个能够监听网络变化的程序，学习一下广播接收器的基本用法。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 广播，动态监听网络变化
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BroadcastActivity extends AppCompatActivity {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntentFilter intentFilter;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NetworkChangeReceiver networkChangeReceiver;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_broadcast);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 IntentFilter 实例&lt;/span&gt;
        intentFilter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IntentFilter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加广播值&lt;/span&gt;
        intentFilter.addAction(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;android.net.conn.CONNECTIVITY_CHANGE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 NetworkChangeReceiver 实例&lt;/span&gt;
        networkChangeReceiver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetworkChangeReceiver();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册广播&lt;/span&gt;
&lt;span&gt;        registerReceiver(networkChangeReceiver,intentFilter);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
        super.onDestroy();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消注册&lt;/span&gt;
&lt;span&gt;        unregisterReceiver(networkChangeReceiver);
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; NetworkChangeReceiver extends BroadcastReceiver{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onReceive(Context context, Intent intent) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取管理网络连接的系统服务类的实例&lt;/span&gt;
            ConnectivityManager connectivityManager =&lt;span&gt; (ConnectivityManager)
                    getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo &lt;/span&gt;=&lt;span&gt; connectivityManager.getActiveNetworkInfo();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断网络是否可用&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (networkInfo != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; networkInfo.isAvailable()){
                ToastUtils.showShort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络可用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ToastUtils.showShort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络不可用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy()方法中通过调用 unregisterReceiver()方法来实现的。&lt;/li&gt;
&lt;li&gt;在 AndroidManifest.xml 文件中加入访问系统的网络状态权限：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;uses-permission android:name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;android.permission.ACCESS_NETWORK_STATE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序，然后按下 Home 键→按下 Menu 键→System settings→Data usage 进入到数据使用详情界面，关闭 Mobile Data 会弹出网络不可用的提示:&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201903/1363478-20190305150741534-772245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新打开 Mobile Data 又会弹出网络可用的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201903/1363478-20190305150840746-1463222364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：目前利用这种动态注册的方式按道理来说应该在任何一款安卓手机上是有效的，但是却在笔者本人的小米6身上失效了，因此我们还是使用了谷歌的手机以及模拟器来做测试才能够获得最终的成功。&lt;/p&gt;

</description>
<pubDate>Tue, 05 Mar 2019 07:11:00 +0000</pubDate>
<dc:creator>Geeksongs</dc:creator>
<og:description>一. Android 中的广播主要分两种类型：标准广播和有序广播。 标准广播（Normal broadcasts） 是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geeksongs/p/10476961.html</dc:identifier>
</item>
<item>
<title>jmeter（4）——简单测试流程 - 幸运的灵小小</title>
<link>http://www.cnblogs.com/icy88/p/10476945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/icy88/p/10476945.html</guid>
<description>&lt;p&gt;今天通过一个简单的例子梳理一下用jmeter进行测试的流程&lt;/p&gt;
&lt;h2&gt;1.确定被测网站：gogomall.com&lt;/h2&gt;
&lt;h2&gt;2.制定测试指标：响应时间和错误率&lt;/h2&gt;
&lt;h2&gt;3.设计测试场景&lt;/h2&gt;
&lt;h2&gt;4.具体测试步骤&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305102456407-220850151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1&amp;gt;创建一个测试计划，测试计划里创建线程组，线程组中再创建取样器，一般是http请求，创建成功如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305111436202-173370971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305112929320-285873482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来解释一下http请求的设置：&lt;/p&gt;
&lt;p&gt;①名称：用于标识一个取样器，建议使用一个有意义的名称，自己能够区分&lt;/p&gt;
&lt;p&gt;②注释：仅用于记录用户可读的注释信息，对测试无任何作用&lt;/p&gt;
&lt;p&gt;③协议：向目标服务器发送http请求时的协议，可以是http或者是https，默认为http&lt;/p&gt;
&lt;p&gt;④服务器名称或IP：http请求发送的目标服务器名称或IP地址&lt;/p&gt;
&lt;p&gt;⑤端口号：目标服务器的端口号，默认值为80&lt;/p&gt;
&lt;p&gt;⑥方法：发送http请求的方法，可用方法包括GET,POST,HEAD,PUT.......等&lt;/p&gt;
&lt;p&gt;⑦路径：目标url路径，不包括服务器地址和端口&lt;/p&gt;
&lt;p&gt;⑧内容编码：内容的编码方式&lt;/p&gt;
&lt;p&gt;⑨自动重定向：如果选中，当发送http请求后得到的响应是302/301时，jmeter自动重定向到新的页面&lt;/p&gt;
&lt;p&gt;⑩使用KeepAlive（持久常连接）：如果选中，jmeter和目标服务器之间使用Keep-Alive方式进行HTTP通信，默认选中&lt;/p&gt;
&lt;p&gt;⑪对POST使用multipart/form-data：当发送HTTP   POST请求时，使用multipart/from-data方法发送，默认不选中&lt;/p&gt;
&lt;p&gt;⑫同请求一起发送参数：在请求中发送url参数，用户可以将url中所有参数设置在本表，表中的每一行是一个参数值对（对应url中的名称1=值1）&lt;/p&gt;
&lt;p&gt;⑬同请求一起发送文件：在请求中发送文件，通常，HTTP文件上传行为可以通过这种方式模拟&lt;/p&gt;
&lt;p&gt;⑭从HTML文件获取所有内含的资源：当该选项被选中时，jmeter在发出HTTP请求并获得响应的HTML文件内容后，还对该HTML进行解析并获取HTML中包含的所有资源，默认不选中，如果用户只希望获取页面中的特定资源，可以在下方的【网址必须匹配】文本框中填入需要下载的特定资源表达式，这样，只有能匹配指定正则表达式的url指向资源会被下载&lt;/p&gt;
&lt;p&gt;⑮保存响应为MD5哈希：选中该项，在执行时仅记录服务端响应数据的MD5值，而不是记录完整的响应数据，在需要进行数据量非常大的测试时，建议选中该项以减少取样器记录响应数据的开销&lt;/p&gt;
&lt;p&gt;2&amp;gt;测试场景设计—线程组设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305140045857-1673956386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;①线程数：虚拟用户数&lt;/p&gt;
&lt;p&gt;②Ramp-Up时间：设置的虚拟用户数需要多长时间全部启动完&lt;/p&gt;
&lt;p&gt;③循环次数：每个线程发送请求的次数，如果勾选了【永远】，那么所有线程会一直发送请求，一直到选择停止运行脚本&lt;/p&gt;
&lt;p&gt;④调度器：可以更灵活的设置运行时间等&lt;/p&gt;
&lt;p&gt;3&amp;gt;设置监听器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305135332837-385027078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4&amp;gt;运行脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305135909581-1187652351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击启动，开始执行测试&lt;/p&gt;
&lt;p&gt;5&amp;gt;查看报告&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305140204889-1337635440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报告数据详解：&lt;/p&gt;
&lt;p&gt;①Label：定义HTTP请求名称&lt;/p&gt;
&lt;p&gt;②Samples：表示这次测试中一共发出了多少个请求，我设置的20个，循环10次，所以是200个&lt;/p&gt;
&lt;p&gt;③Average：平均响应时长，默认情况下是单个请求的平均响应时长，当使用了事务控制器时，也可以以事务为单位显示平均响应时长&lt;/p&gt;
&lt;p&gt;④Median：中位数，也就是50%的响应时长&lt;/p&gt;
&lt;p&gt;⑤90%Line：90%用户的响应时长&lt;/p&gt;
&lt;p&gt;⑥95%Line：95%用户的响应时长&lt;/p&gt;
&lt;p&gt;⑦99%Line：99%用户的响应时长&lt;/p&gt;
&lt;p&gt;⑧Min：访问页面的最小响应时长&lt;/p&gt;
&lt;p&gt;⑨Max：访问页面的最大响应时长 &lt;/p&gt;
&lt;p&gt;⑩Error%：错误请求的数量/请求的总数&lt;/p&gt;
&lt;p&gt;⑪Throughput（吞吐量）：默认情况下表示每秒完成的请求数，当使用了事务控制器时，也可以表示每秒处理的事务个数&lt;/p&gt;
&lt;p&gt;⑫Received KB/sec：每秒从服务器端接收到的数据量&lt;/p&gt;
&lt;p&gt;⑬Sent KB/sec：每秒向服务器端发送的数据量&lt;/p&gt;
&lt;p&gt;注：jmeter中，时间单位都为毫秒&lt;/p&gt;
&lt;p&gt;6&amp;gt;保存报告，注意，文件后缀为.jtl&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549697/201903/1549697-20190305145026594-498154080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：上面的例子中只有一个HTTP请求，所以监听器放线程组下或者HTTP请求下结果都是一样的，当请求多了之后，可以在每个请求下都添加一个监听器&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 07:09:00 +0000</pubDate>
<dc:creator>幸运的灵小小</dc:creator>
<og:description>今天通过一个简单的例子梳理一下用jmeter进行测试的流程 1.确定被测网站：gogomall.com 2.制定测试指标：响应时间和错误率 3.设计测试场景 4.具体测试步骤 1&gt;创建一个测试计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/icy88/p/10476945.html</dc:identifier>
</item>
<item>
<title>6、javascript中对象和数组的深拷贝 - 吃不胖的瘦子！</title>
<link>http://www.cnblogs.com/hgdzjp/p/10476883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hgdzjp/p/10476883.html</guid>
<description>&lt;p&gt;不管是在面试中还是我们的项目中经常会用到数组或者对象的深拷贝，下面我就自己总结的分享给大家。&lt;/p&gt;
&lt;p&gt;首先要知道什么是深拷贝？什么是浅拷贝？&lt;/p&gt;
&lt;p&gt;       深拷贝：源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。&lt;/p&gt;
&lt;p&gt;       浅拷贝：拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间。&lt;/p&gt;
&lt;p&gt;怎么理解呢？&lt;/p&gt;
&lt;p&gt;         举个栗子：定义了一个对象 A={x:0,y:0}，和一个对象B，我现在要将对象A赋值给对象B，如果对象A的值发生改变后对象B的值也发生改变的话我们称这种拷贝为浅拷贝，如果A的值发生变化后B的值不发生变化则称这种拷贝为深拷贝。当A被赋值时就已经有了自己的内存，深拷贝的同时为对象B开辟了&lt;span&gt; 一个新的内存，A所对应的内存和B所对应的内存相互独自，互不影响。而浅拷贝时不会为B开辟新的内存，B指向了A的内存，A的值的变化会影响B的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、对象(object)的深拷贝和浅拷贝：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt; 1.1对象的浅拷贝：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a={x:0,y:0&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;       a.x=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 2, y: 0}&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 2, y: 0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   以上代码很简单，定义了一个对象a，将对象a赋值给对象b，修改a的x值为2，打印a和b的值，结果显示a的x值为2,而b的x值也为2，这就是简单的浅拷贝。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;    1.2&lt;span&gt;对象的深拷贝的几种方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;方法1：利用JSON.parse();&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj1={x:0,y:0&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj2=&lt;span&gt;JSON.parse(JSON.stringify(obj1));
    obj1.x&lt;/span&gt;=2&lt;span&gt;;
  console.log(obj1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 2, y: 0}&lt;/span&gt;
  console.log(obj2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 0, y: 0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;     方法2：es6中的Object.assign();&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj1={x:1,y:1&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj2=&lt;span&gt;Object.assign({},obj1);
    obj1.x&lt;/span&gt;=2&lt;span&gt;;
console.log(obj1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 2, y: 1}&lt;/span&gt;
console.log(obj2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;Object {x: 1, y: 1}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  以上两种方法显示：obj1的值发生变化不会影响obj2的值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   &lt;strong&gt;2、数组(Array)的深拷贝和浅拷贝：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;span&gt;2.1数组的浅拷贝：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr1=[1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;arr1;
    arr1.push(&lt;/span&gt;5&lt;span&gt;);
  console.log(arr1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 5]&lt;/span&gt;
  console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   以上通过赋值的方法进行浅拷贝，结果显示，数组arr1发生变化时数组arr2的值也发生变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;2.2数组深拷贝的几种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt;   方法一：利用slice()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;var&lt;/span&gt; arr=[1,2,3&lt;span&gt;];
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;arr.slice();
         arr.push(&lt;/span&gt;4&lt;span&gt;);
      console.log(arr); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 4]&lt;/span&gt;
      console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        方法二：利用 Object.assign() 方法：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr=[1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;Object.assign([],arr);
    arr.push(&lt;/span&gt;4&lt;span&gt;);
   console.log(arr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 4]&lt;/span&gt;
   console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        方法三：数组的 concat() 方法：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr=[1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;arr.concat();
    arr.push(&lt;/span&gt;4&lt;span&gt;);
   console.log(arr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 4]&lt;/span&gt;
   console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        方法四：es6中的扩展运算符：  &lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let arr=[1,2,3&lt;span&gt;];
let [...arr2]&lt;/span&gt;=&lt;span&gt;arr;
    arr.push(&lt;/span&gt;4&lt;span&gt;);
   console.log(arr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 4]&lt;/span&gt;
   console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 方法五：通过遍历将值赋值：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 let arr=[1,2,3&lt;span&gt;];
 let arr2&lt;/span&gt;=arr.map((item,index)=&amp;gt;&lt;span&gt;{
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
      })
     arr.push(&lt;/span&gt;4&lt;span&gt;);
    console.log(arr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3, 4]&lt;/span&gt;
    console.log(arr2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过以上5中方法实现了数组的深拷贝，数组arr1和数组arr2相互独自，互不影响。&lt;/p&gt;



</description>
<pubDate>Tue, 05 Mar 2019 07:03:00 +0000</pubDate>
<dc:creator>吃不胖的瘦子！</dc:creator>
<og:description>不管是在面试中还是我们的项目中经常会用到数组或者对象的深拷贝，下面我就自己总结的分享给大家。 首先要知道什么是深拷贝？什么是浅拷贝？ 深拷贝：源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hgdzjp/p/10476883.html</dc:identifier>
</item>
<item>
<title>bing Map 在多语言的vue项目中的使用 - 代码是我蓝朋友</title>
<link>http://www.cnblogs.com/wxy-developer/p/10476804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxy-developer/p/10476804.html</guid>
<description>&lt;h3&gt;bing Map 初始化&lt;/h3&gt;
&lt;p&gt;通常地图引入是&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;，但vue项目中仅某一两个页面需要用到百度地图，所以不想在 &lt;code&gt;index.html&lt;/code&gt; 中全局引用。&lt;/p&gt;
&lt;p&gt;但是我直接在当前页面通过 DOM 操作方式插入script标签到当前document中，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let scriptNode = document.createElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
scriptNode.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
scriptNode.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.bing.com/api/maps/mapcontrol?setLang=zh-CN&amp;amp;ak=您的密钥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
document.body.appendChild(scriptNode);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果会报“Mirosorft is not defined”的错误，这里的原因是由于异步加载，所以在调用&quot;Mirosorft&quot;的时候可能SDK并没有引用成功。&lt;/p&gt;
&lt;p&gt;那么：我采用了单独创建&lt;code&gt;initM&lt;/code&gt;ap.js脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bing map init devTools&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    init: function (){
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; lang =&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZH-ch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; bingKey = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;密匙&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BingMapUrl = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.bing.com/api/maps/mapcontrol?setLang=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ lang +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;key=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; bingKey;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; Microsoft !== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
            resolve(Microsoft);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          }
    
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入script脚本&lt;/span&gt;
          let scriptNode = document.createElement(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          scriptNode.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          scriptNode.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, BingMapUrl);
          document.body.appendChild(scriptNode);
    
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待页面加载完毕回调&lt;/span&gt;
          let timeout = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
          let interval &lt;/span&gt;= setInterval(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时10秒加载失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(timeout &amp;gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;) {
              reject();
              clearInterval(interval);&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; Microsoft !== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
              resolve(Microsoft);
              clearInterval(interval);&lt;/span&gt;&lt;span&gt;
            }
            timeout &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
          }, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
      });
    }
  }  
  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我说了，我做的项目是多语言的，而我的语种是存在session里的，这时需要在上面的方法里获取到语种，如下：（保存、删除、获取我都写出来了）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存数据到sessionStorage&lt;/span&gt;
sessionStorage.setItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从sessionStorage获取数据&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; data = sessionStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从sessionStorage删除保存的数据&lt;/span&gt;
sessionStorage.removeItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从sessionStorage删除所有保存的数据&lt;/span&gt;
sessionStorage.clear();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我需要在vue页面调用这个方法，于是我在mounted里面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;initBingMap.init()
        .then((Microsoft) =&amp;gt;&lt;span&gt; {
            console.log(Microsoft)
            console.log(&quot;加载成功...&quot;&lt;span&gt;);
            this&lt;span&gt;.loadMap();
        })&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 剩下的地图样式就在loadMap方法里面写了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt; Microsoft.Maps.Map(document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myMap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No need to set credentials if already passed in URL &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                center: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Microsoft.Maps.Location(&lt;span&gt;47.624527&lt;/span&gt;, -&lt;span&gt;122.355255&lt;/span&gt;&lt;span&gt;),
                zoom: &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt; });
                Microsoft.Maps.loadModule(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Microsoft.Maps.Search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function () {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; searchManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Microsoft.Maps.Search.SearchManager(map);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestOptions =&lt;span&gt; {
                        bounds: map.getBounds(),
                        &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;: 地址,
                        callback: function (answer, userData) {
                            map.setView({ bounds: answer.results[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].bestView });
                            map.entities.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Microsoft.Maps.Pushpin(answer.results[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].location));
                        }
                    };
                    searchManager.geocode(requestOptions);
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然：最重要的一点是要在页面加入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myMap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width: 100%; height: 300px;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样就成功了！&lt;/p&gt;
</description>
<pubDate>Tue, 05 Mar 2019 06:54:00 +0000</pubDate>
<dc:creator>代码是我蓝朋友</dc:creator>
<og:description>bing Map 初始化 通常地图引入是&lt;script&gt;&lt;/script&gt;，但vue项目中仅某一两个页面需要用到百度地图，所以不想在 index.html </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxy-developer/p/10476804.html</dc:identifier>
</item>
<item>
<title>Kafka 概念、单机搭建与使用 - WangKane</title>
<link>http://www.cnblogs.com/primadonna/p/10476663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/primadonna/p/10476663.html</guid>
<description>&lt;p&gt;官方网址：&lt;a href=&quot;http://kafka.apache.org/intro&quot;&gt;Apache Kafka® is &lt;em&gt;a distributed streaming platform&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念介绍&quot;&gt;基本概念介绍&lt;/h2&gt;
&lt;p&gt;在Kafka中有一些基本的概念，&lt;/p&gt;
&lt;h3 id=&quot;topic&quot;&gt;&lt;strong&gt;Topic&lt;/strong&gt;&lt;/h3&gt;
&lt;ul readability=&quot;8.3766626360339&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;简介：Topic在Kafka中是一个抽象的概念，一个主题是已经发布的记录的种类。主题在Kafka中是可以被多重订阅的，这就意味着一个主题可能有0个、一个、或者许多个消费者去订阅这个主题中的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Partitions：在每一个topic在Kafka中可以有多个分区，增加一个主题的分区可以提高Kafka的吞吐率，但是不是越多越好，因为如果分区数量越多的话生产者插入的效率也会降低。所以真正到生产环境时，需要权衡生产与消费的一个平衡关系，消费稍微大于生产者，不会产生消息的堆积，也能够充分提高Kafka的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Replication Factor：复制因子，是对于当前的Topic是否需要副本。如果设置成1的话，代表当前Topic在整个Kafka中只有一份。这里有个限制Topic的数量不能够多于当前Kafka的Broker数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;存储方式：在Kafka的配置中(Server.properties)有logs.dir的配置，这个是Kafka存储消息的位置。如果Topic复制因子是1分区是1的话，在对应的文件夹下会有一个名称为topicname的文件夹；如果复制因子是2分区是2，假设存在两个Broker，在每个Broker中将会存在两个文件夹分别为topicname_0 topicname_1的文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8709677419355&quot;&gt;
&lt;p&gt;Leader与Follower：由于每个topic如果存在副本的话，是对于partition进行复制。这么多存在在不同的Broker上的副本，其中有一个partition是leader其他的是Followers，当一个broker宕机会在副本中选择一个充当Leader。关于Kafka中的选举机制以及Leader的确认可以查看这两篇文章：&lt;a href=&quot;https://blog.csdn.net/qingqing7/article/details/80842511&quot;&gt;Leader确认&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/yanshu2012/article/details/54894629&quot;&gt;选举机制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;producer&quot;&gt;&lt;strong&gt;Producer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;生产者，顾明思议是生产消息，允许应用发布一个流的消息到一个或者多个主题中，&lt;/p&gt;
&lt;h3 id=&quot;consumer&quot;&gt;&lt;strong&gt;Consumer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Broker 是一个Kafka的Server，一台单物理机或者集群都可以拥有多个broker一个broker可以容纳多个主题，这个与复制因子、主题的分区都有关系。&lt;/p&gt;
&lt;h2 id=&quot;kafka单机配置一个broker&quot;&gt;Kafka单机配置，一个Broker&lt;/h2&gt;
&lt;h3 id=&quot;环境&quot;&gt;环境：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;win10物理机&lt;/li&gt;
&lt;li&gt;Wmare Centos7虚拟机&lt;/li&gt;
&lt;li&gt;XShell 访问虚拟机&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置zookeeper&quot;&gt;配置zookeeper&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# zookeeper
wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解压后进入目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd zookeeper-3.4.13/conf&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;复制zookeeper的配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cp zoo_sample.cfg zoo.cfg   &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回上级进入bin目录下，键入如下命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;./zkServer.sh start &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看是否成功开启zookeeper服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#注：这里提示一下开启后提示的成功不一定是真的成功,所以需要查看一下
netstat -tunlp|egrep 2181
# 如果没有结果查看统计目录下的 zookeeper.out文件 查看log信息
# 使用jps命令查看 QuorumPeerMain是zookeeper的守护进程
11089 QuorumPeerMain
11114 Jps&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置kafka&quot;&gt;配置Kafka&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;下载安装包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# Kafka
wget http://mirror.bit.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解压后进入文件夹下bin目录下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 第一个是start.sh位置第二个是server.rpoperties的位置，所以确认好路径的正确性
./kafka-server-start.sh ./../config/server.properties &amp;amp;
# 我们可以在Kafka的目录下直接执行，而不进入到bin下，命令看着更舒服些
./bin/kafka-server-start.sh ./config/server.properties &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看是否开启成功：默认的Kafka端口是9092，zookeeper是2181&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;netstat -tunlp|egrep &quot;(2181|9092)&quot;
# 结果如下
[root@localhost ~]# netstat -tunlp|egrep &quot;(2181|9092)&quot;
tcp6      0     0 :::9092               :::*                  LISTEN      1877/java  tcp6      0     0 :::2181               :::*                  LISTEN      1820/java
# jps 查看
11089 QuorumPeerMain
11458 Kafka
11847 Jps&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此Kafka配置成功&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用kafka&quot;&gt;使用Kafka&lt;/h3&gt;
&lt;h4 id=&quot;创建topic&quot;&gt;创建topic&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
# 返回结果
Created topic &quot;test&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在虚拟机用sh脚本上作为生产者生产消息&quot;&gt;在虚拟机用&lt;strong&gt;sh脚本&lt;/strong&gt;上作为生产者生产消息&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;我们重新开一个Xshell窗口，CD到&lt;code&gt;Kafka目录/bin&lt;/code&gt;下，我们先介绍这一节会使用到的 &lt;strong&gt;kafka-console-producer.sh&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 键入如下命令
./kafka-console-producer.sh --broker-list localhost:9092 --topic test
&amp;gt;today message
&amp;gt;
# 最近本的指定，broker-list与topic是必须的参数
# 成功命令行会进入一个&amp;gt;的情况，键入消息按回车键就是发送消息到Kafka了
# 发送一个【today message】&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;kafka-console-producer.sh&lt;/strong&gt;参数说明，运行&lt;code&gt;./kafka-console-producer.sh --help&lt;/code&gt;可查看&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;在虚拟机上用sh脚本作为消费者消费消息&quot;&gt;在虚拟机上用&lt;strong&gt;sh脚本&lt;/strong&gt;作为消费者消费消息&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;重新开另个一Xshell窗口CD到&lt;code&gt;Kafka目录/bin&lt;/code&gt;下，我们先介绍这一节会使用到的 &lt;strong&gt;kafka-console-consumer.sh&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 键入如下命令
./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
# 最近本的指定，bootstrap-server与topic/whitelist是必须的参数
# 由于有 from-beginning 参数 会从头load所有消息
# 消费后返回如下
today message
#在生产端键入消息后，消费端会同步消息出现&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;kafka-console-consumer.sh&lt;/strong&gt;参数说明运行&lt;code&gt;./kafka-console-consumer.sh --help&lt;/code&gt;可查看&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用python作为生产者消费者&quot;&gt;使用&lt;strong&gt;Python&lt;/strong&gt;作为生产者、消费者&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在物理机上写一个Python生产者的脚本&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from kafka.producer import KafkaProducer
import time
def send_data(data):
    producer = KafkaProducer(bootstrap_servers='192.168.233.138:9092')
    producer.send(&quot;test&quot;,b''+str(data)+'')
    producer.flush()
    print (&quot;end&quot;)
    
if __name__==&quot;__main__&quot;:
    send_data(&quot;physics python message&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看Xshell上消费的命令行&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@localhost ~]# /home/kafka_2.11-2.1.0/bin/kafka-console-consumer.sh --bootstrap-server 192.168.233.138:9092 --topic test --from-beginning
111
333

1
12
physics python message&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在物理机上写一个消费者的脚本&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from kafka import KafkaConsumer
import time
def get_data(data):
    consumer = KafkaConsumer('test',bootstrap_servers='192.168.233.138:9092', group_id='my_favorite_group')
    print (&quot;end&quot;)
    for msg in consumer:
        print(msg)
    
if __name__==&quot;__main__&quot;:
    get_data();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;物理机消费者的结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 我这边是先运行的消费者的脚本，所以实时接收到了物理机产生的消息
ConsumerRecord(topic=u'test', partition=0, offset=5, timestamp=1551762485911L, timestamp_type=0, key=None, value='physics python message', checksum=1520092583, serialized_key_size=-1, serialized_value_size=22)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试使用虚拟机sh端的生产者发送123 消息，查看物理机消费者结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ConsumerRecord(topic=u'test', partition=0, offset=6, timestamp=1551762784609L, timestamp_type=0, key=None, value='123', checksum=1760815061, serialized_key_size=-1, serialized_value_size=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;几点注意&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 物理机连接时可能出现【kafka.errors.NoBrokersAvailable: NoBrokersAvailable】这个错误按照如下顺序依次更改
1. 查看虚拟机防火墙是否关闭
    systemctl status firewalld
    systemctl stop firewalld
2. 更改kafka服务端的server.properties:
    增加 [ listeners=PLAINTEXT://192.168.233.138:9092 ]这一行
3. 修改物理机的hosts文件 C:\Windows\System32\drivers\etc\hosts
    增加 【虚拟机ip 虚拟机主机名】 Eg:[192.168.233.138 localhost]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用springboot-作为生产者消费者&quot;&gt;使用&lt;strong&gt;Springboot&lt;/strong&gt; 作为生产者、消费者&lt;/h4&gt;
&lt;p&gt;注：我直接在我的一个寄存的Spring Boot Demo项目上更改&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在pom.xml中添加kafka依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;org.springframework.kafka&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;spring-kafka&amp;lt;/artifactId&amp;gt;
 &amp;lt;/dependency&amp;gt;
&amp;lt;!-- 提示一件事情此处别指定version了，直接用最新的就可以，老的版本一些包找不到 --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;写一个kafka 生产者配置类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.kane.config;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;

@Configuration
@EnableKafka
public class kafka_config {
     public Map&amp;lt;String, Object&amp;gt; producerConfigs() {
            Map&amp;lt;String, Object&amp;gt; props = new HashMap&amp;lt;&amp;gt;();
            props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.233.138:9092&quot;);
            props.put(ProducerConfig.RETRIES_CONFIG, 0);
            props.put(ProducerConfig.BATCH_SIZE_CONFIG, 4096);
            props.put(ProducerConfig.LINGER_MS_CONFIG, 1);
            props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 40960);
            props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
            props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
            return props;
        }
     
        public ProducerFactory&amp;lt;String, String&amp;gt; producerFactory() {
            return new DefaultKafkaProducerFactory&amp;lt;&amp;gt;(producerConfigs());
        }
     
        @Bean
        public KafkaTemplate&amp;lt;String, String&amp;gt; kafkaTemplate() {
            return new KafkaTemplate&amp;lt;String, String&amp;gt;(producerFactory());
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建一个生产数据的Controller&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.kane.Controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.web.bind.annotation.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@RestController
@RequestMapping(&quot;/kafka&quot;)
public class CollectController {
     protected final Logger logger = LoggerFactory.getLogger(this.getClass());
        @Autowired
        private KafkaTemplate kafkaTemplate;

        @RequestMapping(value = &quot;/send&quot;, method = RequestMethod.GET)
        public void sendKafka(HttpServletRequest request, HttpServletResponse response) {
            try {
                String message = request.getParameter(&quot;message&quot;);
                logger.info(&quot;kafka的消息={}&quot;, message);
                kafkaTemplate.send(&quot;test&quot;, &quot;key&quot;, message);
                logger.info(&quot;发送kafka成功.&quot;);
            } catch (Exception e) {
                logger.error(&quot;发送kafka失败&quot;, e);
            }
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动项目后，在浏览器访问http://localhost:8080/kafka/send?message=url_producer&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 查看结果
2019-03-05 13:57:16.438  INFO 10208 --- [nio-8080-exec-1] c.e.kane.Controller.CollectController    : 发送kafka成功.
2019-03-05 13:57:45.871  INFO 10208 --- [nio-8080-exec-5] c.e.kane.Controller.CollectController    : kafka的消息=url_producer
2019-03-05 13:57:45.872  INFO 10208 --- [nio-8080-exec-5] c.e.kane.Controller.CollectController    : 发送kafka成功.
# 查看虚拟机 Consumer结果

[root@localhost ~]# /home/kafka_2.11-2.1.0/bin/kafka-console-consumer.sh --bootstrap-server 192.168.233.138:9092 --topic test --from-beginning
physics python message
123
null
url_producer&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;增加消费者的配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.kane.config;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.KafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;

import java.util.HashMap;
import java.util.Map;

import com.example.kane.service.kafka_listener;
@Configuration
@EnableKafka
public class kafka_consumer_config {
    @Bean
    public KafkaListenerContainerFactory&amp;lt;ConcurrentMessageListenerContainer&amp;lt;String, String&amp;gt;&amp;gt; kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory&amp;lt;String, String&amp;gt; factory = new ConcurrentKafkaListenerContainerFactory&amp;lt;&amp;gt;();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }

    public ConsumerFactory&amp;lt;String, String&amp;gt; consumerFactory() {
        return new DefaultKafkaConsumerFactory&amp;lt;&amp;gt;(consumerConfigs());
    }


    public Map&amp;lt;String, Object&amp;gt; consumerConfigs() {
        Map&amp;lt;String, Object&amp;gt; propsMap = new HashMap&amp;lt;&amp;gt;();
        propsMap.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.233.138:9092&quot;);
        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);
        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        propsMap.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;test&quot;);
        return propsMap;
    }
    @Bean
    public kafka_listener listener() {
        return new kafka_listener();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;增加listener类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.kane.service;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.annotation.KafkaListener;
public class kafka_listener {
    protected final Logger logger = LoggerFactory.getLogger(this.getClass());


    @KafkaListener(topics = {&quot;test&quot;})
    public void listen(ConsumerRecord&amp;lt;?, ?&amp;gt; record) {
        logger.info(record.toString());
        logger.info(&quot;kafka的key: &quot; + record.key());
        logger.info(&quot;kafka的value: &quot; + record.value().toString());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;同样我们用访问http://localhost:8080/kafka/send?message=url_producer1重新发一个消息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 结果
2019-03-05 14:31:04.787  INFO 10208 --- [nio-8080-exec-1] c.e.kane.Controller.CollectController    : 发送kafka成功.
2019-03-05 14:31:04.848  INFO 10208 --- [ntainer#0-0-C-1] com.example.kane.service.kafka_listener  : ConsumerRecord(topic = test, partition = 0, offset = 10, CreateTime = 1551767464787, serialized key size = 3, serialized value size = 13, headers = RecordHeaders(headers = [], isReadOnly = false), key = key, value = url_producer1)
2019-03-05 14:31:04.848  INFO 10208 --- [ntainer#0-0-C-1] com.example.kane.service.kafka_listener  : kafka的key: key
2019-03-05 14:31:04.848  INFO 10208 --- [ntainer#0-0-C-1] com.example.kane.service.kafka_listener  : kafka的value: url_producer1
# 查看虚拟机 消费者信息
physics python message
123
null
url_producer
url_producer1
url_producer1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一些需要注意的问题&quot;&gt;一些需要注意的问题&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;现在kafka官方提供自带zookeeper版本，不建议使用自带的，还是建议自己安装zookeeper&lt;/li&gt;
&lt;li&gt;物理机没法访问的时候，看文中的注意事项，依次更改一定能访问&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 05 Mar 2019 06:40:00 +0000</pubDate>
<dc:creator>WangKane</dc:creator>
<og:description>[TOC] Kafka 概念、单机搭建与使用 官方网址： 'Apache Kafka® is a distributed streaming platform ' 基本概念介绍 在Kafka中有一些基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/primadonna/p/10476663.html</dc:identifier>
</item>
<item>
<title>【学习笔记】深入理解async/await - 唐吉sir</title>
<link>http://www.cnblogs.com/youma/p/10475214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youma/p/10475214.html</guid>
<description>&lt;p&gt;参考资料：&lt;span&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007535316#articleHeader1&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;理解javaScript中的async/await&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，感谢原文作者的总结，本文在理解的基础上做了一点小小的修改，主要为了加深自己的知识点掌握&lt;/p&gt;
&lt;p&gt;学完了Promise，我们知道可以用then链来解决多层回调问题，但是这还不是最理想的操作，我们需要调用很多个then链才能达到要求，那么有没有一种更简便代码量更少的方式达到then链相同的结果呢？asynv和await就很好地解决了这个问题，首先用async声明一个异步函数，然后再用await等待异步结果，把以前then链的结果放到直接放在await，非常方便。&lt;/p&gt;
&lt;p&gt;那么，async和await原理是什么呢？为什么可以用这样的语法来优化then链呢？&lt;/p&gt;
&lt;h2&gt;1. async/await是什么？&lt;/h2&gt;
&lt;p&gt;async/await其实是Promise的语法糖，它能实现的效果都能用then链来实现，这也和我们之前提到的一样，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await译为等待，所以我们很好理解async声明function是异步的，await等待某个操作完成。当然语法上强制规定await只能出现在asnyc函数中，我们先来看看async函数返回了什么： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAsy(){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'hello world';&lt;span&gt;
}
let result &lt;/span&gt;=&lt;span&gt; testAsy(); 
console.log(result)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/900566/201903/900566-20190305111634765-1348673175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个async声明的异步函数把return后面直接量通过Promise.resolve()返回Promise对象，所以如果这个最外层没有用await调用的话，是可以用原来then链的方式来调用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAsy(){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'hello world'&lt;span&gt;
}
let result &lt;/span&gt;=&lt;span&gt; testAsy() 
console.log(result)
result.then(v&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(v)   //hello world
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;联想一下Promise特点——异步无等待，所以当没有await语句执行async函数，它就会立即执行，返回一个Promise对象，非阻塞，与普通的Promise对象函数一致。&lt;/p&gt;
&lt;p&gt;重点就在await，它等待什么呢？&lt;/p&gt;
&lt;p&gt;按照&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await&quot; target=&quot;_blank&quot;&gt;语法说明&lt;/a&gt;，await等待的是一个Promise对象，或者是其他值（也就是说可以等待任何值），如果等待的是Promise对象，则返回Promise的处理结果；如果是其他值，则返回该值本身。并且await会暂停当前async function的执行，等待Promise的处理完成。若Promise正常处理（fulfillded），其将回调的resolve函数参数作为await表达式的值，继续执行async function；若Promise处理异常（rejected），await表达式会把Promise异常原因抛出；另外如果await操作符后面的表达式不是一个Promise对象，则返回该值本身。&lt;/p&gt;
&lt;h2&gt;2. 深入理解async/await&lt;/h2&gt;
&lt;p&gt;我们来详细说明一下async/await的作用。await操作符后面可以是任意值，当是Promise对象的时候，会暂停async function执行。也就是说，必须得等待await后面的Promise处理完成才能继续：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAsy(x){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve=&amp;gt;{setTimeout(() =&amp;gt;&lt;span&gt; {
       resolve(x);
     }, &lt;/span&gt;3000&lt;span&gt;)
    }
   )
}
async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAwt(){    
  let result &lt;/span&gt;=  await testAsy('hello world'&lt;span&gt;);
  console.log(result);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3秒钟之后出现hello world&lt;/span&gt;
&lt;span&gt;}
testAwt();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;await 表达式的运算结果取决于它等的东西。&lt;/p&gt;
&lt;p&gt;如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。&lt;/p&gt;
&lt;p&gt;如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。&lt;/p&gt;
&lt;p&gt;我们再把上面的代码修改一下，好好体会“阻塞”这个词&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAsy(x){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve=&amp;gt;{setTimeout(() =&amp;gt;&lt;span&gt; {
       resolve(x);
     }, &lt;/span&gt;3000&lt;span&gt;)
    }
   )
}
async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testAwt(){    
  let result &lt;/span&gt;=  await testAsy('hello world'&lt;span&gt;);
  console.log(result);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3秒钟之后出现hello world&lt;/span&gt;
  console.log('tangj')   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3秒钟之后出现tangj&lt;/span&gt;
&lt;span&gt;}
testAwt();
console.log(&lt;/span&gt;'tangSir')  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;立即输出tangSir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'tangSir''最先输出，hello world'和‘tangj’是3秒钟后同时出现的。&lt;/p&gt;
&lt;h2&gt;3. async和await简单应用&lt;/h2&gt;
&lt;p&gt;上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。&lt;/p&gt;
&lt;p&gt;现在举例，用 setTimeout模拟耗时的异步操作，先来看看不用 async/await 会怎么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; takeLongTime() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
        setTimeout(() &lt;/span&gt;=&amp;gt; resolve(&quot;long_time_value&quot;), 1000&lt;span&gt;);
    });
}

takeLongTime().then(v &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;&quot;got&quot;&lt;span&gt;, v); //一秒钟后输出got long_time_value
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果改用 async/await 呢，会是这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; takeLongTime() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
        setTimeout(() &lt;/span&gt;=&amp;gt; resolve(&quot;long_time_value&quot;), 1000&lt;span&gt;);
    });
}

async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test() {
    const v &lt;/span&gt;=&lt;span&gt; await takeLongTime();
    console.log(v);  // 一秒钟后输出long_time_value
}

test();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tankLongTime()本身就是返回的 Promise 对象，所以加不加 async结果都一样。&lt;/p&gt;
&lt;h2&gt;4. 处理then链&lt;/h2&gt;
&lt;p&gt;前面我们说了，async和await是处理then链的语法糖，现在我们来看看具体是怎么实现的：&lt;/p&gt;
&lt;p&gt;假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用setTimeout来模拟异步操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; takeLongTime(n) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
        setTimeout(() &lt;/span&gt;=&amp;gt; resolve(n + 200&lt;span&gt;), n);
    });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; step1(n) {
    console.log(`step1 &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; ${n}`);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; takeLongTime(n);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; step2(n) {
    console.log(`step2 &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; ${n}`);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; takeLongTime(n);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; step3(n) {
    console.log(`step3 &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; ${n}`);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; takeLongTime(n);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在用 Promise 方式来实现这三个步骤的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doIt(){
    console.time(&lt;/span&gt;'doIt'&lt;span&gt;);
    let time1 &lt;/span&gt;= 300&lt;span&gt;;
    step1(time1)
        .then((time2) &lt;/span&gt;=&amp;gt;&lt;span&gt; step2(time2))
        .then((time3) &lt;/span&gt;=&amp;gt;&lt;span&gt; step3(time3))　　
        .then((result) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(`result is ${result}`);
            console.timeEnd(&lt;/span&gt;&quot;doIt&quot;&lt;span&gt;);
        })
}

doIt();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果为:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step1 with 300&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step2 with 500&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step3 with 700&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;result is 900&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;doIt: 1510.2490234375ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果 &lt;code&gt;result&lt;/code&gt; 是 &lt;code&gt;step3()&lt;/code&gt; 的参数 &lt;code&gt;700 + 200&lt;/code&gt; = &lt;code&gt;900&lt;/code&gt;。&lt;code&gt;doIt()&lt;/code&gt; 顺序执行了三个步骤，一共用了 &lt;code&gt;300 + 500 + 700 = 1500&lt;/code&gt; 毫秒，和 &lt;code&gt;console.time()/console.timeEnd()&lt;/code&gt; 计算的结果一致。&lt;/p&gt;
&lt;p&gt;如果用 async/await 来实现呢，会是这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; doIt() {
    console.time(&lt;/span&gt;'doIt'&lt;span&gt;);
    let time1 &lt;/span&gt;= 300&lt;span&gt;;
    let time2 &lt;/span&gt;= await step1(time1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Promise对象resolve(n+200)的值赋给time2&lt;/span&gt;
    let time3 =&lt;span&gt; await step1(time2);
    let result &lt;/span&gt;=&lt;span&gt; await step1(time3);
    console.log(`result is ${result}`);
    console.timeEnd(&lt;/span&gt;'doIt'&lt;span&gt;);
}

doIt();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行结果为:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step1 with 300&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step2 with 500&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;step3 with 700&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;result is 900&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;doIt: 1512.904296875ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然我们用async/await简单多了。&lt;/p&gt;
&lt;h2&gt;5. Promise处理结果为rejected&lt;/h2&gt;
&lt;p&gt;await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunction() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        await somethingThatReturnAPromise();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err){
        console.log(err);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;另一种写法&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; myFunction() {
    await somethingThatReturnAPromise().&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err) {
        console.log(err);
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 05 Mar 2019 06:25:00 +0000</pubDate>
<dc:creator>唐吉sir</dc:creator>
<og:description>参考资料：理解javaScript中的async/await，感谢原文作者的总结，本文在理解的基础上做了一点小小的修改，主要为了加深自己的知识点掌握 学完了Promise，我们知道可以用then链来解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youma/p/10475214.html</dc:identifier>
</item>
</channel>
</rss>