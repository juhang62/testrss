<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot 集成SpringSecurity JWT - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/12637923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/12637923.html</guid>
<description>&lt;h2 id=&quot;1-简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;今天&lt;a href=&quot;https://www.cnblogs.com/itdragon/&quot;&gt;ITDragon&lt;/a&gt;分享一篇在Spring Security 框架中使用JWT，以及对失效Token的处理方法。&lt;/p&gt;
&lt;h3 id=&quot;11-springsecurity&quot;&gt;1.1 SpringSecurity&lt;/h3&gt;
&lt;p&gt;Spring Security 是Spring提供的安全框架。提供认证、授权和常见的攻击防护的功能。功能丰富和强大。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;12-oauth2&quot;&gt;1.2 OAuth2&lt;/h3&gt;
&lt;p&gt;OAuth（Open Authorization）开放授权是为用户资源的授权定义一个安全、开放的标准。而OAuth2是OAuth协议的第二个版本。OAuth常用于第三方应用授权登录。在第三方无需知道用户账号密码的情况下，获取用户的授权信息。常见的授权模式有：授权码模式、简化模式、密码模式和客户端模式。&lt;/p&gt;
&lt;h3 id=&quot;13-jwt&quot;&gt;1.3 JWT&lt;/h3&gt;
&lt;p&gt;JWT（json web token）是一个开放的标准，它可以在各方之间作为JSON对象安全地传输信息。可以通过数字签名进行验证和信任。JWT可以解决分布式系统登陆授权、单点登录跨域等问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5.7159763313609&quot;&gt;
&lt;p&gt;JSON Web Token (JWT) is an open standard (&lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;RFC 7519&lt;/a&gt;) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-springboot-集成-springsecurity&quot;&gt;2. SpringBoot 集成 SpringSecurity&lt;/h2&gt;
&lt;p&gt;SpringBoot 集成Spring Security 非常方便，也是简单的两个步骤：导包和配置&lt;/p&gt;
&lt;h3 id=&quot;21-导入spring-security-库&quot;&gt;2.1 导入Spring Security 库&lt;/h3&gt;
&lt;p&gt;作为Spring的自家项目，只需要导入spring-boot-starter-security 即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;compile('org.springframework.boot:spring-boot-starter-security')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-配置spring-security&quot;&gt;2.2 配置Spring Security&lt;/h3&gt;
&lt;p&gt;第一步：创建Spring Security Web的配置类，并继承web应用的安全适配器WebSecurityConfigurerAdapter。&lt;/p&gt;
&lt;p&gt;第二步：重写configure方法，可以添加登录验证失败处理器、退出成功处理器、并按照ant风格开启拦截规则等相关配置。&lt;/p&gt;
&lt;p&gt;第三步：配置默认或者自定义的密码加密逻辑、AuthenticationManager、各种过滤器等，比如JWT过滤器。&lt;/p&gt;
&lt;p&gt;配置代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.itdragon.server.config

import com.itdragon.server.security.service.ITDragonJwtAuthenticationEntryPoint
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpMethod
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder

@Configuration
@EnableWebSecurity
class ITDragonWebSecurityConfig: WebSecurityConfigurerAdapter() {

    @Autowired
    lateinit var authenticationEntryPoint: ITDragonJwtAuthenticationEntryPoint

    /**
     * 配置密码编码器
     */
    @Bean
    fun passwordEncoder(): PasswordEncoder{
        return BCryptPasswordEncoder()
    }

    override fun configure(http: HttpSecurity) {
        // 配置异常处理器
        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)
                        // 配置登出逻辑
                .and().logout()
                .logoutSuccessHandler(logoutSuccessHandler)
                // 开启权限拦截
                .and().authorizeRequests()
                // 开放不需要拦截的请求
                .antMatchers(HttpMethod.POST, &quot;/itdragon/api/v1/user&quot;).permitAll()
                // 允许所有OPTIONS请求
                .antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()
                // 允许静态资源访问
                .antMatchers(HttpMethod.GET,
                        &quot;/&quot;,
                        &quot;/*.html&quot;,
                        &quot;/favicon.ico&quot;,
                        &quot;/**/*.html&quot;,
                        &quot;/**/*.css&quot;,
                        &quot;/**/*.js&quot;
                ).permitAll()
                // 对除了以上路径的所有请求进行权限拦截
                .antMatchers(&quot;/itdragon/api/v1/**&quot;).authenticated()
                // 先暂时关闭跨站请求伪造，它限制除了get以外的大多数方法。
                .and().csrf().disable()
                        // 允许跨域请求
                .cors().disable()

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1）、csrf防跨站请求伪造的功能是默认打开，调试过程中可以先暂时关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2）、logout()退出成功后默认跳转到/login路由上，对于前后端分离的项目并不友好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3）、permitAll()方法修饰的配置建议写在authenticated()方法的上面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3-springsecurity-配置jwt&quot;&gt;3. SpringSecurity 配置JWT&lt;/h2&gt;
&lt;p&gt;JWT的优点有很多，使用也很简单。但是我们&lt;a href=&quot;https://www.cnblogs.com/itdragon/&quot;&gt;ITDragon&lt;/a&gt;在使用的过程中也需要注意处理JWT的失效问题。&lt;/p&gt;
&lt;h3 id=&quot;31-导入jwt库&quot;&gt;3.1 导入JWT库&lt;/h3&gt;
&lt;p&gt;Spring Security 整合JWT还需要额外引入io.jsonwebtoken:jjwt 库&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;compile('io.jsonwebtoken:jjwt:0.9.1')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-创建jwt工具类&quot;&gt;3.2 创建JWT工具类&lt;/h3&gt;
&lt;p&gt;JWT工具类主要负责：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1）、token的生成。建议使用用户的登录账号作为生成token的属性，这是考虑到账号的唯一性和可读性都很高。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2）、token的验证。包括token是否已经自然过期、是否因为人为操作导致失效、数据的格式是否合法等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.itdragon.server.security.utils

import com.itdragon.server.security.service.JwtUser
import io.jsonwebtoken.Claims
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.SignatureAlgorithm
import org.springframework.beans.factory.annotation.Value
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.stereotype.Component
import java.util.*

private const val CLAIM_KEY_USERNAME = &quot;itdragon&quot;

@Component
class JwtTokenUtil {

    @Value(&quot;\${itdragon.jwt.secret}&quot;)
    private val secret: String = &quot;ITDragon&quot;

    @Value(&quot;\${itdragon.jwt.expiration}&quot;)
    private val expiration: Long = 24 * 60 * 60

    /**
     * 生成令牌Token
     * 1. 建议使用唯一、可读性高的字段作为生成令牌的参数
     */
    fun generateToken(username: String): String {
        return try {
            val claims = HashMap&amp;lt;String, Any&amp;gt;()
            claims[CLAIM_KEY_USERNAME] = username
            generateJWT(claims)
        } catch (e: Exception) {
            &quot;&quot;
        }
    }

    /**
     * 校验token
     * 1. 判断用户名和token包含的属性一致
     * 2. 判断token是否失效
     */
    fun validateToken(token: String, userDetails: UserDetails): Boolean {
        userDetails as JwtUser
        return getUsernameFromToken(token) == userDetails.username &amp;amp;&amp;amp; !isInvalid(token, userDetails.model.tokenInvalidDate)
    }

    /**
     * token 失效判断，依据如下：
     * 1. 关键字段被修改后token失效，包括密码修改、用户退出登录等
     * 2. token 过期失效
     */
    private fun isInvalid(token: String, tokenInvalidDate: Date?): Boolean {
        return try {
            val claims = parseJWT(token)
            claims!!.issuedAt.before(tokenInvalidDate) &amp;amp;&amp;amp; isExpired(token)
        } catch (e: Exception) {
            false
        }
    }

    /**
     * token 过期判断，常见逻辑有几种：
     * 1. 基于本地内存，问题是重启服务失效
     * 2. 基于数据库，常用的有Redis数据库，但是频繁请求也是不小的开支
     * 3. 用jwt的过期时间和当前时间做比较（推荐）
     */
    private fun isExpired(token: String): Boolean {
        return try {
            val claims = parseJWT(token)
            claims!!.expiration.before(Date())
        } catch (e: Exception) {
            false
        }
    }

    /**
     * 从token 中获取用户名
     */
    fun getUsernameFromToken(token: String): String {
        return try {
            val claims = parseJWT(token)
            claims!![CLAIM_KEY_USERNAME].toString()
        } catch (e: Exception) {
            &quot;&quot;
        }
    }

    /**
     * 生成jwt方法
     */
    fun generateJWT(claims: Map&amp;lt;String, Any&amp;gt;): String {
        return Jwts.builder()
                .setClaims(claims)      // 定义属性
                .设计如下：(Date())    // 设置发行时间
                .setExpiration(Date(System.currentTimeMillis() + expiration * 1000)) // 设置令牌有效期
                .signWith(SignatureAlgorithm.HS512, secret) // 使用指定的算法和密钥对jwt进行签名
                .compact()              // 压缩字符串
    }

    /**
     * 解析jwt方法
     */
    private fun parseJWT(token: String): Claims? {
        return try {
            Jwts.parser()
                    .setSigningKey(secret)  // 设置密钥
                    .parseClaimsJws(token)  // 解析token
                    .body
        } catch (e: Exception) {
            null
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-添加jwt过滤器&quot;&gt;3.3 添加JWT过滤器&lt;/h3&gt;
&lt;p&gt;添加的JWT过滤器需要实现以下几个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）、自定义的JWT过滤器要在Spring Security 提供的用户名密码过滤器之前执行&lt;/li&gt;
&lt;li&gt;2）、要保证需要拦截的请求都必须带上token信息&lt;/li&gt;
&lt;li&gt;3）、判断传入的token是否有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.itdragon.server.security.service

import com.itdragon.server.security.utils.JwtTokenUtil
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Value
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter
import javax.servlet.FilterChain
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

@Component
class ITDragonJwtAuthenticationTokenFilter: OncePerRequestFilter() {

    @Value(&quot;\${itdragon.jwt.header}&quot;)
    lateinit var tokenHeader: String
    @Value(&quot;\${itdragon.jwt.tokenHead}&quot;)
    lateinit var tokenHead: String
    @Autowired
    lateinit var userDetailsService: UserDetailsService
    @Autowired
    lateinit var jwtTokenUtil: JwtTokenUtil

    /**
     * 过滤器验证步骤
     * 第一步：从请求头中获取token
     * 第二步：从token中获取用户信息，判断token数据是否合法
     * 第三步：校验token是否有效，包括token是否过期、token是否已经刷新
     * 第四步：检验成功后将用户信息存放到SecurityContextHolder Context中
     */
    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {

        // 从请求头中获取token
        val authHeader = request.getHeader(this.tokenHeader)
        if (authHeader != null &amp;amp;&amp;amp; authHeader.startsWith(tokenHead)) {
            val authToken = authHeader.substring(tokenHead.length)
            // 从token中获取用户信息
            val username = jwtTokenUtil.getUsernameFromToken(authToken)
            if (username.isBlank()) {
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Unauthorized: Auth token is illegal&quot;)
                return
            }
            if (null != SecurityContextHolder.getContext().authentication) {
                val tempUser = SecurityContextHolder.getContext().authentication.principal
                tempUser as JwtUser
                println(&quot;SecurityContextHolder : ${tempUser.username}&quot;)
            }

            // 验证token是否有效
            val userDetails = this.userDetailsService.loadUserByUsername(username)
            if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                // 将用户信息添加到SecurityContextHolder 的Context
                val authentication = UsernamePasswordAuthenticationToken(userDetails, userDetails.password, userDetails.authorities)
                authentication.details = WebAuthenticationDetailsSource().buildDetails(request)
                SecurityContextHolder.getContext().authentication = authentication
            }
        }

        filterChain.doFilter(request, response)
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将JWT过滤器添加到UsernamePasswordAuthenticationFilter 过滤器之前&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter::class.java)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的ITDragonWebSecurityConfig类的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.itdragon.server.config

import com.itdragon.server.security.service.ITDragonJwtAuthenticationEntryPoint
import com.itdragon.server.security.service.ITDragonJwtAuthenticationTokenFilter
import com.itdragon.server.security.service.ITDragonLogoutSuccessHandler
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpMethod
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter

@Configuration
@EnableWebSecurity
class ITDragonWebSecurityConfig: WebSecurityConfigurerAdapter() {

    @Autowired
    lateinit var jwtAuthenticationTokenFilter: ITDragonJwtAuthenticationTokenFilter
    @Autowired
    lateinit var authenticationEntryPoint: ITDragonJwtAuthenticationEntryPoint
    @Autowired
    lateinit var logoutSuccessHandler: ITDragonLogoutSuccessHandler

    @Bean
    fun passwordEncoder(): PasswordEncoder{
        return BCryptPasswordEncoder()
    }

    @Bean
    fun itdragonAuthenticationManager(): AuthenticationManager {
        return authenticationManager()
    }

    /**
     * 第一步：将JWT过滤器添加到默认的账号密码过滤器之前，表示token验证成功后无需登录
     * 第二步：配置异常处理器和登出处理器
     * 第三步：开启权限拦截，对所有请求进行拦截
     * 第四步：开放不需要拦截的请求，比如用户注册、OPTIONS请求和静态资源等
     * 第五步：允许OPTIONS请求，为跨域配置做准备
     * 第六步：允许访问静态资源，访问swagger时需要
     */
    override fun configure(http: HttpSecurity) {
        // 添加jwt过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter::class.java)
                // 配置异常处理器
                .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)
                // 配置登出逻辑
                .and().logout()
                .logoutSuccessHandler(logoutSuccessHandler)
                // 开启权限拦截
                .and().authorizeRequests()
                // 开放不需要拦截的请求
                .antMatchers(HttpMethod.POST, &quot;/itdragon/api/v1/user&quot;).permitAll()
                // 允许所有OPTIONS请求
                .antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()
                // 允许静态资源访问
                .antMatchers(HttpMethod.GET,
                        &quot;/&quot;,
                        &quot;/*.html&quot;,
                        &quot;/favicon.ico&quot;,
                        &quot;/**/*.html&quot;,
                        &quot;/**/*.css&quot;,
                        &quot;/**/*.js&quot;
                ).permitAll()
                // 对除了以上路径的所有请求进行权限拦截
                .antMatchers(&quot;/itdragon/api/v1/**&quot;).authenticated()
                // 先暂时关闭跨站请求伪造，它限制除了get以外的大多数方法。
                .and().csrf().disable()
                // 允许跨域请求
                .cors().disable()

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34-登录验证&quot;&gt;3.4 登录验证&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.itdragon.server.security.service

import com.itdragon.server.security.utils.JwtTokenUtil
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.stereotype.Service

@Service
class ITDragonAuthService {
    @Autowired
    lateinit var authenticationManager: AuthenticationManager
    @Autowired
    lateinit var userDetailsService: UserDetailsService
    @Autowired
    lateinit var jwtTokenUtil: JwtTokenUtil

    fun login(username: String, password: String): String {
        // 初始化UsernamePasswordAuthenticationToken对象
        val upAuthenticationToken = UsernamePasswordAuthenticationToken(username, password)
        // 身份验证
        val authentication = authenticationManager.authenticate(upAuthenticationToken)
        // 验证成功后回将用户信息存放到 securityContextHolder的Context中
        SecurityContextHolder.getContext().authentication = authentication
        // 生成token并返回
        val userDetails = userDetailsService.loadUserByUsername(username)
        return jwtTokenUtil.generateToken(userDetails.username)
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;35-关于jwt失效处理&quot;&gt;3.5 关于JWT失效处理&lt;/h3&gt;
&lt;p&gt;Token的失效包括常见的过期失效、刷新失效、修改密码失效还有就是用户登出失效（有的场景不需要）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/itdragon/&quot;&gt;ITDragon&lt;/a&gt;是以JWT自带的创建时间和到期时间、与传入的时间做判断。来判断token是否失效，这样可以减少和数据库的交互。&lt;/p&gt;
&lt;p&gt;解决自然过期的token失效设计如下：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1）、生成token时，设置setExpiration属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1）、校验token时，通过获取expiration属性，并和当前时间做比较，若在当前时间之前则说明token已经过期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决人为操作上的token失效设计如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）、生成token时，设置setIssuedAt属性&lt;/li&gt;
&lt;li&gt;2）、用户表添加tokenInvalidDate字段。在刷新token、修改用户密码等操作时，更新这个字段&lt;/li&gt;
&lt;li&gt;3）、校验token时，通过获取issuedAt属性，并和tokenInvalidDate时间做比较，若在tokenInvalidDate时间之前则说明token已经失效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;/**
     * token 失效判断，依据如下：
     * 1. 关键字段被修改后token失效，包括密码修改、用户退出登录等
     * 2. token 过期失效
     */
private fun isInvalid(token: String, tokenInvalidDate: Date?): Boolean {
    return try {
        val claims = parseJWT(token)
        claims!!.issuedAt.before(tokenInvalidDate) &amp;amp;&amp;amp; isExpired(token)
    } catch (e: Exception) {
        false
    }
}

/**
     * token 过期判断，常见逻辑有几种：
     * 1. 基于本地内存，问题是系统重启后失效
     * 2. 基于数据库，常用的有Redis数据库，但是频繁请求也是不小的开支
     * 3. 用jwt的过期时间和当前时间做比较（推荐）
     */
private fun isExpired(token: String): Boolean {
    return try {
        val claims = parseJWT(token)
        claims!!.expiration.before(Date())
    } catch (e: Exception) {
        false
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章到这里就结束了，感谢各位看官！！😘😘😘&lt;/p&gt;
&lt;p&gt;完整代码访问GitHub地址：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/spring-boot-springsecurity-jwt&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/spring-boot-springsecurity-jwt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目所在目录可能会发生变化，但是&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup&quot;&gt;https://github.com/ITDragonBlog/daydayup&lt;/a&gt; 地址不会变&lt;/p&gt;
</description>
<pubDate>Wed, 19 Aug 2020 00:15:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<og:description>1. 简介 今天ITDragon分享一篇在Spring Security 框架中使用JWT，以及对失效Token的处理方法。 1.1 SpringSecurity Spring Security 是S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itdragon/p/12637923.html</dc:identifier>
</item>
<item>
<title>SpringSecurity权限管理系统实战—五、整合SpringSecurity（下） - codermy</title>
<link>http://www.cnblogs.com/codermy/p/13516388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codermy/p/13516388.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上篇文章SpringSecurity整合了一半，这次把另一半整完，所以本篇的序号接着上一篇。&lt;/p&gt;
&lt;h2 id=&quot;七、自定义用户信息&quot;&gt;七、自定义用户信息&lt;/h2&gt;
&lt;p&gt;前面我们登录都是用的指定的用户名和密码或者是springsecurity默认的用户名和打印出来的密码。我们要想连接上自定义数据库只需要实现一个自定义的UserDetailsService。&lt;/p&gt;
&lt;p&gt;我们新建一个JwtUserDto继承UserDetails并实现它的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@AllArgsConstructor
public class JwtUserDto implements UserDetails {
    //用户数据
    private MyUser myUser;
        //用户权限的集合
    @JsonIgnore
    private List&amp;lt;GrantedAuthority&amp;gt; authorities;
                
    public List&amp;lt;String&amp;gt; getRoles() {
        return authorities.stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList());
    }
        //加密后的密码
    @Override
    public String getPassword() {
        return myUser.getPassword();
    }
        //用户名
    @Override
    public String getUsername() {
        return myUser.getUserName();
    }
        //是否过期
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
        //是否锁定
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
        //凭证是否过期
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
        //是否可用
    @Override
    public boolean isEnabled() {
        return myUser.getStatus() == 1 ? true : false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义一个UserDetailsServiceImpl实现UserDetailsService&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
@Slf4j
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private UserService userService;
    @Autowired
    private MenuDao menuDao;
    @Override
    public JwtUserDto loadUserByUsername(String userName) throws UsernameNotFoundException {
        MyUser user = userService.getUser(userName);//根据用户名获取用户
        if (user == null ){
            throw new UsernameNotFoundException(&quot;用户名不存在&quot;);//这个异常一定要抛
        }else if (user.getStatus().equals(MyUser.Status.LOCKED)) {
            throw new LockedException(&quot;用户被锁定,请联系管理员&quot;);
        }
        List&amp;lt;GrantedAuthority&amp;gt; grantedAuthorities = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;MenuIndexDto&amp;gt; list = menuDao.listByUserId(user.getId());
        List&amp;lt;String&amp;gt; collect = list.stream().map(MenuIndexDto::getPermission).collect(Collectors.toList());
        for (String authority : collect){
            if (!(&quot;&quot;).equals(authority) &amp;amp; authority !=null){
                GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(authority);
                grantedAuthorities.add(grantedAuthority);
            }
        }//将用户所拥有的权限加入GrantedAuthority集合中
        JwtUserDto loginUser =new JwtUserDto(user,grantedAuthorities);
        return loginUser;
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里在获取权限的时候遇到了个小小的坑，就是mybatis数据里的空值和null，在你从未对这个数据修改时，它就是null。如果修改了又删除掉了，它就会是空值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124704956.PNG#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;meudao中的listByUserId方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @Select(&quot;SELECT DISTINCT sp.id,sp.parent_id,sp.name,sp.icon,sp.url,sp.type,sp.permission  &quot; +
            &quot;FROM my_role_user sru &quot; +
            &quot;INNER JOIN my_role_menu srp ON srp.role_id = sru.role_id &quot; +
            &quot;LEFT JOIN my_menu sp ON srp.menu_id = sp.id &quot; +
            &quot;WHERE &quot; +
            &quot;sru.user_id = #{userId}&quot;)
    @Result(property = &quot;title&quot;,column = &quot;name&quot;)
    @Result(property = &quot;href&quot;,column = &quot;url&quot;)
    List&amp;lt;MenuIndexDto&amp;gt; listByUserId(@Param(&quot;userId&quot;)Integer userId);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八、加密&quot;&gt;八、加密&lt;/h2&gt;
&lt;p&gt;老话题来聊一聊，加密的重要性。&lt;/p&gt;
&lt;p&gt;2011年国内某开发者社区（可不就是csdn吗）被攻击数据库，600多万明文存储的用户账号被公开，大量用户隐私泄露。&lt;/p&gt;
&lt;p&gt;这是个老梗了，几乎每篇说加密重要性的博文中，csdn的事就要被拿出来遛一遛。&lt;/p&gt;
&lt;p&gt;那么为什么密码加密怎么重要？？因为在你的数据库被攻击泄露了数据时，如果你的密码也被黑客掌握，那么即使你修复好了数据库泄露的问题，黑客手上仍然还有着用户的密码（总不能要求所有用户修改密码吧）&lt;/p&gt;
&lt;p&gt;所以我们需要在系统开发之初就尽量的避免这种问题。&lt;/p&gt;
&lt;p&gt;那么说了这么多，怎么来加密呢？&lt;/p&gt;
&lt;p&gt;其实在SpringSecurity种已经内置了密码的加密机制，只需要实现一个PasswordEncoder接口即可。&lt;/p&gt;
&lt;p&gt;来看一下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface PasswordEncoder {
    String encode(CharSequence var1);

    boolean matches(CharSequence var1, String var2);

    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;encode():把参数按照特定的解析规则进行解析。&lt;/li&gt;
&lt;li&gt;matches()验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。&lt;/li&gt;
&lt;li&gt;upgradeEncoding()：如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个参数表示需要被解析的密码。第二个参数表示存储的密码。&lt;/p&gt;
&lt;p&gt;Spring Security 还内置了几种常用的 PasswordEncoder 接口，官方推荐使用的是BCryptPasswordEncoder&lt;/p&gt;
&lt;p&gt;。我们来配置一下。在SpringConfig种添加如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @Autowired
    private UserDetailsService userDetailsService;
        @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
        @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }//自定义userDetailsService加密
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是十分简单，我们再重启项目，这时候控制台就不再打印密码，现在需要输入数据库中的用户名密码才能登录。&lt;/p&gt;
&lt;h2 id=&quot;九、获取用户信息&quot;&gt;九、获取用户信息&lt;/h2&gt;
&lt;p&gt;之前我们在绘制菜单时，把用户的id给写死了。现在我们要从SpringSecurity中来获取用户信息。&lt;/p&gt;
&lt;p&gt;有两种方法获取已登录用户的信息，一种是从session中拿，另一种就是SpringSecurity提供的方法。这里选择后一种方法。&lt;/p&gt;
&lt;p&gt;我们可以通过以下方法来获取登录后用户的信息(其余还有获取登录ip等方法，不多介绍)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SecurityContextHolder.getContext().getAuthentication().getPrincipal()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们转换下类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JwtUserDto jwtUserDto = (JwtUserDto)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印一下jwtUserDto，看到我们确实拿到了用户的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124739442.PNG#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们改写下通过用户id获取菜单这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @GetMapping(value = &quot;/index&quot;)
    @ResponseBody
    @ApiOperation(value = &quot;通过用户id获取菜单&quot;)
    public List&amp;lt;MenuIndexDto&amp;gt; getMenu() {
        JwtUserDto jwtUserDto = (JwtUserDto)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        Integer userId = jwtUserDto.getMyUser().getId();
        return menuService.getMenu(userId);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在将前端写死的userId删除。现在我们已经能根据登录用户的不同来自动绘制菜单了。&lt;/p&gt;
&lt;p&gt;拥有admin权限的用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124811176.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;普通权限的用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020072212482893.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;十、授权&quot;&gt;十、授权&lt;/h2&gt;
&lt;p&gt;我们目前只是绘制出了不同权限用户能操作的界面，但是还没有真正的进行权限控制。&lt;/p&gt;
&lt;p&gt;之前在七中，我们已经将每个用户所拥有的权限集合放入了GrantedAuthority集合中&lt;/p&gt;
&lt;p&gt;在之前打印的用户信息中可以看到 authorities中就是该用户所拥有的权限&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020072212484622.PNG#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringSecurity会自动帮我们进行权限控制。而我们要做的就是在需要进行权限控制的方法上添加上权限标识即可。&lt;/p&gt;
&lt;p&gt;例如：用户管理的权限标识是user:list&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124906907.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要在相关的接口上加上@PreAuthorize(&quot;hasAnyAuthority('user:list')&quot;)即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @GetMapping(&quot;/index&quot;)
    @PreAuthorize(&quot;hasAnyAuthority('user:list')&quot;)
    public String index(){
        return &quot;system/user/user&quot;;
    }
    @GetMapping
    @ResponseBody
    @ApiOperation(value = &quot;用户列表&quot;)
    @PreAuthorize(&quot;hasAnyAuthority('user:list')&quot;)
    public Result&amp;lt;MyUser&amp;gt; userList(PageTableRequest pageTableRequest, UserQueryDto userQueryDto){
        pageTableRequest.countOffset();
        return userService.getAllUsersByPage(pageTableRequest.getOffset(),pageTableRequest.getLimit(),userQueryDto);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们登录普通用户来操作相关接口，发现报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124922494.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台打印&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124939161.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改所有接口，在需要权限控制的接口上添加注解&lt;/p&gt;
&lt;h2 id=&quot;十一、自定义异常处理&quot;&gt;十一、自定义异常处理&lt;/h2&gt;
&lt;p&gt;虽说现在功能已经实现了，用户虽说不能访问没有权限的功能了，但是异常没有处理。如果点击，如果前端也没有做错误的拦截的话，用户会看到一串的报错信息，这很不友好，并且也会对服务器造成压力。&lt;/p&gt;
&lt;p&gt;我们只需要在之前创建的全局异常处理类中捕获上图的异常即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @ExceptionHandler(AccessDeniedException.class)
    public Result handleAuthorizationException(AccessDeniedException e)
    {
        log.error(e.getMessage());
        return Result.error().code(ResultCode.FORBIDDEN).message(&quot;没有权限，请联系管理员授权&quot;);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启项目，在前端书写相应规则，就会十分友好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722124954590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hZRENT,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;十二、自定义退出登录&quot;&gt;十二、自定义退出登录&lt;/h2&gt;
&lt;p&gt;其实SpringSecurity默认注册了一个/logout路由，通过这个路由可以注销登录状态，包括Session和remember-me等等。&lt;/p&gt;
&lt;p&gt;我们可以直接在SpringSecurityConfig的configure中定义相应规则，类似formlogin。也可以自定义一个LogoutHadnler，具体可以看&lt;a href=&quot;https://www.cnblogs.com/felordcn/p/12142535.html&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此SpringSecurity的一些常用功能已经实现，下一节我们整合jwt实现无状态登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本系列&lt;a href=&quot;https://gitee.com/witmy/my-springsecurity-plus&quot;&gt;gitee&lt;/a&gt;和&lt;a href=&quot;https://github.com/witmy/my-springsecurity-plus&quot;&gt;github&lt;/a&gt;中同步更新&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Aug 2020 00:09:00 +0000</pubDate>
<dc:creator>codermy</dc:creator>
<og:description>系列目录 前言 上篇文章SpringSecurity整合了一半，这次把另一半整完，所以本篇的序号接着上一篇。 七、自定义用户信息 前面我们登录都是用的指定的用户名和密码或者是springsecurit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codermy/p/13516388.html</dc:identifier>
</item>
<item>
<title>查找 - 符号表 - Ruby_Lu</title>
<link>http://www.cnblogs.com/afei-24/p/13514164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/13514164.html</guid>
<description>&lt;p&gt;　　高效检索海量信息（经典查找算法）是现代信息世界的基础设施。我们使用&lt;strong&gt;符号表&lt;/strong&gt;描述一张抽象的表格，将信息（值）存储在其中，然后按照指定的键来搜索并获取这些信息。键和值的具体意义取决于不同的应用。符号表中可能会保存很多键和很多信息，因此实现一张高效的符号表是很重要的任务。&lt;/p&gt;
&lt;p&gt;　　符号表有时被称为字典，有时被称为索引。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.符号表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　符号表是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。符号表最主要的目的就是将一个健和一个值联系起来。&lt;/p&gt;
&lt;p&gt;　　构造符号表的方法有很多，它们不光能够高效地插入和查找，还可以进行其他几种方便的操作。要实现符号表，首先要定义其背后的数据结构，并指明创建并操作这种数据结构以实现插入，查找等操作所需的算法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　API&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ISymbolTables&amp;lt;Key,Value&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;  Key : IComparable
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; CompareCount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将键值对存入表中（若值未空则将键key从表中删除）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Put(Key key, Value value);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取键 key 对应的值（若键不存在则返回 null）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        Value Get(Key key);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从表中删去键 key
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(Key key);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 键 key 是否在表中存在
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Contains(Key key);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表是否未空
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsEmpty();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表中的键值对数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Size();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表中所有键的集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        IEnumerable&amp;lt;Key&amp;gt;&lt;span&gt; Keys();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最小的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        Key Min();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最大的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        Key Max();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 小于等于 key 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        Key Floor(Key key);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大于等于 key 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        Key Ceilling(Key key);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;小于 key 的键的数量（key 的排名）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Rank(Key key);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  排名为 k 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;k&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        Key Select(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除最小的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DeleteMin();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除最大的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DeleteMax();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; [lo ... hi]之间的键的数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Size(Key lo,Key hi);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; [lo ... hi]之间的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        IEnumerable&amp;lt;Key&amp;gt;&lt;span&gt; Keys(Key lo, Key hi);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　基本实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 符号表基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Key&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Value&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseSymbolTables&amp;lt;Key, Value&amp;gt;: ISymbolTables&amp;lt;Key, Value&amp;gt;
        &lt;span&gt;where&lt;/span&gt;&lt;span&gt; Key : IComparable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareCount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将键值对存入表中（若值未空则将键key从表中删除）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Put(Key key, Value value)
        { 
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取键 key 对应的值（若键不存在则返回 null）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Value Get(Key key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Value);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从表中删去键 key
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(Key key)
        {
            
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 键 key 是否在表中存在
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Contains(Key key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表是否未空
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsEmpty()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Size()==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表中的键值对数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Size()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 表中所有键的集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IEnumerable&amp;lt;Key&amp;gt;&lt;span&gt; Keys()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Key&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最小的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Key Min()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最大的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Key Max()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 小于等于 key 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Key Floor(Key key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大于等于 key 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Key Ceilling(Key key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;小于 key 的键的数量（key 的排名）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Rank(Key key)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  排名为 k 的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;k&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Key Select(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Key);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除最小的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DeleteMin()
        {

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除最大的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DeleteMax()
        {

        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; [lo ... hi]之间的键的数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Size(Key lo, Key hi)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; [lo ... hi]之间的键
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;lo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;hi&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IEnumerable&amp;lt;Key&amp;gt;&lt;span&gt; Keys(Key lo, Key hi)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Key&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.有序符号表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　典型的应用程序中，键都是 IComparable 对象，因此可以使用 a.CompareTo( b ) 来比较 a 和 b 两个键。符号表保持键的有序性，可以扩展它的API，根据键的相对位置定义更多实用操作。例如，最大和最小的键。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;排名（Rank 方法）和选择 （Select 方法）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　检查一个新的键是否插入合适位置的基本操作是排名（Rank，找出小于指定键的键的数量）和选择（Select，找出排名为 k 的键）。对于 0 到 Size（）-1 的所有 i 都有 i == Rank( Select(i) )，且所有的键都满足 key == Select( Rank( key ) ) 。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;键的等价性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　IComparable  类型中 CompareTo 和 Equals 方法是一致的，但为了避免任何潜在的二义性，这里只是用 a.CompareTo( b )  == 0 来判断 a 和 b 是否相等。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;成本模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　查找的成本模型：在符号表的实现中，将比较的次数作为成本模型。在内循环不进行比较的情况下，使用数组的访问次数。&lt;/p&gt;
&lt;p&gt;　　符号表实现的重点在于其中使用的数据结构和 Get() , Put() 方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.无序链表中的顺序查找&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。&lt;/p&gt;
&lt;p&gt;　　Get 方法的实现即为遍历链表，用 Equals 方法比较需要查找的键和每个结点中键。如果匹配就返回相应的值，否则返回 null。Put 方法的实现也是遍历，如果匹配就更新相应的值，否则就用给定的键值对创建一个新的结点并将其插入链表的开头。这种方法称为&lt;strong&gt;顺序查找&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 顺序查找
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Key&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Value&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt; SequentialSearchST&amp;lt;Key,Value&amp;gt;:BaseSymbolTables&amp;lt;Key, Value&amp;gt;
        &lt;span&gt;where&lt;/span&gt;&lt;span&gt; Key : IComparable
    {
        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node First;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Key key;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Value value;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node next;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(Key _key,Value _value,Node _next)
            {
                key &lt;/span&gt;=&lt;span&gt; _key;
                value &lt;/span&gt;=&lt;span&gt; _value;
                next &lt;/span&gt;=&lt;span&gt; _next;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Value Get(Key key)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node x = First; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (key.Equals(x.key))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x.value;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Value);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Put(Key key, Value value)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node x = First; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            {
                CompareCount&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (key.Equals(x.key))
                {
                    x.value &lt;/span&gt;=&lt;span&gt; value;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }

            First &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key,value,First);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们使用一个字符串数组来测试上面的算法，键是数组中的值，值是插入的索引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt;[] strs = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是顺序查找的索引用例的轨迹：&lt;/p&gt;
&lt;p&gt;　　分析符号表算法比排序算法更困难，因为不同的用例所进行的操作序列各不相同。常见的情形是虽然查找和插入的使用模式是不可预测的，但它们的使用肯定不是随机的。因此我们主要研究最坏情况下的性能。我们使用命中表示一次成功的查找，未命中表示一次失败的查找。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202008/984232-20200818074345441-2026000740.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;在含有 N 对键值的基于链表的符号表中，未命中的查找和插入操作都需要 N 次比较。命中的查找在最坏情况下需要 N 次比较。特别地，向一个空表中插入 N 个不同的键需要 ~ N^2 /2 次比较。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总时间除以 N 。在查找表中每个键的可能性都相同的情况下，这个结果就是一次查找平均所需的比较次数。称它为随机命中。由上面的算法可以得到平均比较次数为 ~N/2:  查找第一个键需要比较一次，查找第二个键需要比较两次 ...... 平均比较次数为（1+2+3.....+N）/ N = (N+1)/2。&lt;/p&gt;
&lt;p&gt;　　这证明基于链表的实现以及顺序查找是低效的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.有序数组中的二分查找&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有序符号表API的实现使用的数据结构是一对平行的数组，一个存储键一个存储值。下面的代码保证数组中 IComparable 类型的键有序，然后使用数组的索引来高效地实现 Get 和其他操作。&lt;/p&gt;
&lt;p&gt;　　下面算法的核心是 Rank 方法(它使用二分查找的算法)，它返回表中小于给定键的键的数量。对于 Get 方法，只要给定的键存在于表中就返回，否则返回空。&lt;/p&gt;
&lt;p&gt;　　Put 方法，只要给定的键存在于表中，Rank 方法就能够精确告诉我们它的为并去更新，以及当键不存在时我们也能直到将键存储到什么位置。插入键值对时，将更大的键和值向后移一格，并将给定的键值对分别插入到数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BinarySearchST&amp;lt;Key,Value&amp;gt; : BaseSymbolTables&amp;lt;Key, Value&amp;gt;
        &lt;span&gt;where&lt;/span&gt;&lt;span&gt; Key : IComparable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Key[] keys;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Value[] vals;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; N;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BinarySearchST(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity)
        {
            keys &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Key[capacity];
            vals &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Value[capacity];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Size()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; N;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Value Get(Key key)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsEmpty())
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Value);

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Rank(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; N &amp;amp;&amp;amp; keys[i].CompareTo(key) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vals[i];
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(Value);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Rank(Key key)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lo = &lt;span&gt;0&lt;/span&gt;, hi = N - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (lo &amp;lt;=&lt;span&gt; hi)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = lo + (hi-lo) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                CompareCount&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cmp =&lt;span&gt; key.CompareTo(keys[mid]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    hi &lt;/span&gt;= mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    lo &lt;/span&gt;= mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lo;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Put(Key key, Value value)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Rank(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; N &amp;amp;&amp;amp; keys[i].CompareTo(key) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                vals[i] &lt;/span&gt;=&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = N; j &amp;gt; i; j--&lt;span&gt;)
            {
                keys[j] &lt;/span&gt;= keys[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                vals[j] &lt;/span&gt;= vals[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            }

            keys[i] &lt;/span&gt;=&lt;span&gt; key;
            vals[i] &lt;/span&gt;=&lt;span&gt; value;
            N&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Key Min()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; keys[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Key Max()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; keys[N-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Key Select(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[k];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Key Ceilling(Key key)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Rank(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[i];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IEnumerable&amp;lt;Key&amp;gt;&lt;span&gt; Keys()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是该算法的用例移动轨迹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202008/984232-20200818204000295-449197733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;对二分查找的分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Rank 方法的递归实现使用了二分查找，二分查找比顺序查找快很多。在 N 个键的有序数组中进行二分查找最多需要 （lgN + 1）次比较。&lt;/p&gt;
&lt;p&gt;　　尽管该算法能够保证查找所需的时间是对数级别的，但 Put 方法还是太慢，需要移动数组。对于随机数组，构造一个基于有序数组的符号表所需访问数组的次数是数组长度的平方级别。&lt;/p&gt;
&lt;p&gt;　　向大小为 N 的有序数组中插入一个新的键值对在最坏情况下需要访问 ~2N 次数组，因此向一个空符号表中插入 N 个元素在最坏情况下需要访问 ~N^2 次数组。&lt;/p&gt;

&lt;p&gt;　　对于一个静态表（不允许插入）来说，将其在初始化时就排序是值得的。下面是符号表简单实现的总结：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;算法&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;p&gt;最坏情况下的成本&lt;/p&gt;
&lt;p&gt;（N 次插入后）&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;平均情况下的成本&lt;/p&gt;
&lt;p&gt;（N 次随机插入后）&lt;/p&gt;
&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;是否支持有序性相关的操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查找&lt;/td&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;td&gt;查找&lt;/td&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;顺序查找（无序链表）&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N/2&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二分查找（有序数组）&lt;/td&gt;
&lt;td&gt;lgN&lt;/td&gt;
&lt;td&gt;2N&lt;/td&gt;
&lt;td&gt;lgN&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Wed, 19 Aug 2020 00:08:00 +0000</pubDate>
<dc:creator>Ruby_Lu</dc:creator>
<og:description>高效检索海量信息（经典查找算法）是现代信息世界的基础设施。我们使用符号表描述一张抽象的表格，将信息（值）存储在其中，然后按照指定的键来搜索并获取这些信息。键和值的具体意义取决于不同的应用。符号表中可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/afei-24/p/13514164.html</dc:identifier>
</item>
<item>
<title>DDD与Repository - bluesky234</title>
<link>http://www.cnblogs.com/Pray4U/p/13527146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Pray4U/p/13527146.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;Repository已经不是什么新鲜概念了。DDD模型自2004年提出，发展至今已经16年了。但是不少企业却无法实施，其原因也很简单：DDD是基于需求的，而很多并不理解需求；DDD是容易实现的，而很多设计者并不会编程。这种情况就有一些两头不讨好，而如果有办法结合统一的话，则会非常好用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;学习Repository的过程中，最先要进行的是思想的转变。在过往的编程过程中，大家往往将目光聚焦在CRUD中，导致每个程序员首先想的是我如何使用SQL实现我所要的目标。而在DDD过程中，实践者应当将目光聚焦中功能上，首先将需求分解为若干个功能，然后再将功能进行组合。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;举例而言，某系统拥有组织机构和用户功能。组织机构树的每个部门下属若干个职位，每个职位都有用户担任，每个用户可以出任多个部门的多个职位。这时，系统设计师告诉你这里要有以下功能：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门管理（部门的CRUD，部门下职位的CRUD，职位与部门的CRUD）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;用户管理（用户的CRUD）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;讲到这里，很容易看出，这里其实有四张表，也就是部门，职位，用户和用户职位关联表。表关系也容易理出，部门与职位1对多，职位与用户多对多。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果你使用的是DAO思想（或者说分层思想），那么需求分析做到这一步也就结束了。你可以直接通过上述内容整理出你需要实现的接口，即每张表的CRUD。然后在前端实现一个界面，每个界面调用相关的接口程序也就写完了。比如，其中一个接口可能是这样的：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;[Route(“~/api/SetPosition”)]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;public void SetPosition(Guid userId, Guid positionId);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么，现在问题来了。需求发生了一个变更，来了一个全新的需求，客户说我现在需求每个部门的更改必须通过流程进行。即当部门信息发生变更时，必须层层审核，最后才通过后，才能在更新数据。这个审核过程甚至包含了一部分关键职位的人员变化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这时，那个坑人的系统设计师又站出来了，给了你一系列功能变化表：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门修改申请（部门修改申请CRUD，部门申请审核，部门申请同步到部门表，部门申请同步到职位表）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;看上去，这个设计很美好“自顶向下逐步细化”分解的也非常舒服。但是，你仔细研究一下就发现这里有两个巨大的坑：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、新建部门修改申请。在部门修改申请时，试问是否要将以前的部门数据复制到这张申请表中？如果你不复制，那了不得了，全部门所有手动数据全部要用户自行输入此表，那恐怕最终用户会和你闹的不可开交——这什么垃圾软件？！而如果你打算实现他，那我告诉你，这张可怕的部门表里，字段不多，100个（呵呵）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、如果你说功能1其实是必须实现的新功能，和设计关系不大。那么你再观察，将部门申请同步到部门这个功能。他绝对可以细分为“修改部门”和“修改职位”两个子功能，而这两个子功能其实是之前的接口就实现的。那么，你是否为之前的接口留下了复用性？仔细看看之前接口的实现代码，你就会悲剧的发现，70%的可能性那个接口是无法复用的，因为查询代码其实不太一样。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那这只是我随手说的一个需求变更，如果有更多的需求变化呢？那么虽然代码还是能够复用一部分，设计空间释放也不会太麻烦。但是，仔细评判你的代码和设计，就会发现原来优雅而简洁的可复用设计的复用性越来越低，原来整齐而易读的代码的可读性越来越差。这就是人间悲剧。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;而这时，Repository的思想从天而降，他也许能够为你可怜的代码带来一些让你惊喜的变更。如果使用DDD的思想设计上述内容，首先你需要确定领域。显而易见的，这里的领域可以这样划分：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;用户领域：添加用户，删除用户，修改用户，修改用户的职位，移除用户的职位&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门领域：添加部门，删除部门，修改部门，查询部门下的职位，查询部门下的用户&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;职位领域：添加职位，修改职位，删除职位，查询职位下的用户，将用户添加到职位中，将用户从职位中移除&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：这里，如果是我写代码，我很可能会把“部门领域”和“职位领域”合并。这个并无不可，因为两者其实没有那么明显的边界。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在这个设计中，可以看到其实有些功能是重复的，比如说“修改用户的职位”和“将用户添加到职位中”。但是，在领域设计中，我却将其认为是两个不同的功能，因为他们的主体不一样。对前者而言，我先查出用户，函数的参数是“用户ID”和“职位名称”，这里使用出字符串的职位名称，即意味着对于用户领域来说，他不需要认识“职位”这个类。对于后者而言，我先查出职位，函数参数是“职位”和“一个或者多个用户ID”。这意味着，对于职位领域来说，他也不需要认识用户这个类。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里可以看到，领域之间，耦合度很低。其实达到了最小知识原则所要求的内容。但是，实现过程中，可能会有这样的疑问，将职位添加到用户过程中，难道你不需要判断用户是否存在吗？当然，判断还是要判断的，但是我完全可以不认识用户这个类。通过将“用户职位关系表”中的“用户ID”字段与用户表中的“ID”字段做出外键关系，完全可以让数据帮我保证数据有效性。我只需要做一个简单的异常处理即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;另外，耦合度低不等于不能耦合，在这里查询一次用户表，我认为也没有突破什么界限，所以完全没有问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在设计完领域后，需要再设计边界，也就是说由哪些类将这些功能全部暴露给外界。这时可以这么设计：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门类：添加职位，修改职位，删除职位，查询职位下的用户，将用户添加到职位中，将用户从职位中移除&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;用户类：查询我所在的部门和职位&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;用户服务类：用户的CRUD&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门服务类：部门的CRUD&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里，实际是将部门当作了职位的聚合。这只是我随手写的设计，没有实践过也不知道有没有什么问题。但我想大致应当是正确的。这时，我就将所有功能都通过这几个类暴露在外界。在考虑这些内容的情况下，再来上述需求时，问题就明确了，他需要新建一个领域：部门修改申请。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;部门修改申请：通过部门新建修改申请，通过旧的修改申请新建修改申请，审核修改申请，将修改申请同步到部门中，将修改申请同步到职位中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在再来看之前的两个大坑。问题1其实是规避不了。因为这个就是新功能，规避的唯一办法就是加钱，钱到位了功能也就到位了。而问题2确实就简单了，因为你可以直接调用暴露在“修改职位功能”将申请表中的用户给到对应职位，也可以通过调用“修改部门功能”直接将部门信息反向同步，而不需要考虑代码是否优雅，因为这里就是调用一个函数，并不存在优雅与否的问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;再到以后，如果再有新功能，哪怕你还是需要释放设计空间。但你在重构的时候，已经整理过的功能就不需要整理第二遍。你只需要交被释放出的设计空间全部放回领域中，重构的工作量大大减少。而这，就是我所看重的DDD的核心优势。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;针对到实现层面，之前那些乱七八糟的领域功能，其实就是Repository，他的出现自然而又简单。你所需要的只是简单的变化一下自己的思想，多写几十行代码，仅此而已。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最后，稍稍总结一下。完成以上内容的核心和关键其实并不是你对DDD了解多少。而真正有效的是你对需求了解多少，你认为需求有多少内容可能发生变化。对需求把握才是软件设计的核心。任何设计思想，设计模式都基于对需求的理解。我个人对软件思想的重要理解：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不基于需求任何想法都空谈，不理解需求任何代码都是胡说，不把握变化任何设计都是假想。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;与君共勉。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Aug 2020 00:05:00 +0000</pubDate>
<dc:creator>bluesky234</dc:creator>
<og:description>Repository已经不是什么新鲜概念了。DDD模型自2004年提出，发展至今已经16年了。但是不少企业却无法实施，其原因也很简单：DDD是基于需求的，而很多并不理解需求；DDD是容易实现的，而很多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Pray4U/p/13527146.html</dc:identifier>
</item>
<item>
<title>秒杀 2Sum 3Sum 4Sum 算法题 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13527148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13527148.html</guid>
<description>&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghujl0hs7hg30dc0491kx.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2 Sum 这题是 Leetcode 的第一题，相信大部分小伙伴都听过的吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一道标着 Easy 难度的题，它真的这么简单吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在之前的刷题视频里说过，大家刷题一定要吃透一类题，为什么有的人题目做着越来越少，有的人总觉得刷不完的题，就是因为没有分类吃透。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单纯的追求做题数量是没有意义的，Leetcode 的题目只会越来越多，就像高三时的模考试卷一样做不完，但分类总结，学会解决问题的方式方法，才能遇到新题也不手足无措。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtbxc1gzej30l808g0ti.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题题意就是，给一个数组和一个目标值，让你在这个数组里找到两个数，使得它俩之和等于这个目标值的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如题目中给的例子，目标值是 9，然后数组里 &lt;code&gt;2 + 7 = 9&lt;/code&gt;，于是返回 2 和 7 的下标。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;方法一&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我多年前还不知道时空复杂度的时候，我想这还不简单嘛，就每个组合挨个试一遍呗，也就是两层循环。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我才知道，这样时间复杂度是很高的，是 &lt;code&gt;O(n^2)&lt;/code&gt;；但另一方面，这种方法的空间复杂度最低，是 &lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;面试时一定要先问面试官，是希望优化时间还是优化空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说我们追求优化时间，但你不能默认面试官也是这么想的，有时候他就是想考你有没有这个意识呢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个方法能够兼具优化时间和空间那就更好了，比如斐波那契数列这个问题中从递归到 DP 的优化，就是时间和空间的双重优化，不清楚的同学后台回复「递归」快去补课～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下这个代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[i] + nums[j] == target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{i, j};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;时间复杂度：O(n^2)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;空间复杂度：O(1)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喏，这速度不太行诶。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtd5qpe0wj30hz03vwev.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;方法二&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在我学了 &lt;code&gt;HashMap&lt;/code&gt; 这个数据结构之后呢，我又有了新的想法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt; 或者 &lt;code&gt;HashSet&lt;/code&gt; 的最大优势就是能够用 &lt;code&gt;O(1)&lt;/code&gt; 的时间获取到目标值，那么是不是可以优化方法一的第二个循环呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个思路，假设当前在看 &lt;code&gt;x&lt;/code&gt;，那就是需要把 &lt;code&gt;x&lt;/code&gt; 之前或者之后的数放在 &lt;code&gt;HashSet&lt;/code&gt; 里，然后看下 &lt;code&gt;target - x&lt;/code&gt; 在不在这个 &lt;code&gt;hashSet&lt;/code&gt; 里，如果在的话，那就匹配成功～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诶这里有个问题，这题要求返回这俩数的下标，可是 &lt;code&gt;HashSet&lt;/code&gt; 里的数是无序的...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就用升级版——&lt;code&gt;HashMap&lt;/code&gt; 嘛～～还不了解 &lt;code&gt;HashMap&lt;/code&gt; 的原理的同学快去公众号后台回复「HashMap」看文章啦。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt; 里记录下数值和它的 &lt;code&gt;index&lt;/code&gt; 这样匹配成功之后就可以顺便得到 &lt;code&gt;index&lt;/code&gt; 了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们&lt;strong&gt;不需要提前记录所有的值&lt;/strong&gt;，只需要&lt;strong&gt;边过数组边记录&lt;/strong&gt;就好了，为了防止重复，我们只在这个当前的数出现之前的数组部分里找另一个数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;code&gt;HashMap&lt;/code&gt; 里记录的是下标 &lt;code&gt;i&lt;/code&gt; 之前的所有出现过的数；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;对于每个 &lt;code&gt;nums[i]&lt;/code&gt; ，我们先检查 &lt;code&gt;target - nums[i]&lt;/code&gt; 是否在这个 &lt;code&gt;map&lt;/code&gt; 里；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果在就直接返回了，如果不在就把当前 &lt;code&gt;i&lt;/code&gt; 的信息加进 &lt;code&gt;map&lt;/code&gt; 里。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] res = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];&lt;br/&gt;Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (map.containsKey(target - nums[i])) {&lt;br/&gt;res[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = map.get(target - nums[i]);&lt;br/&gt;res[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = i;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;map.put(nums[i], i);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;时间复杂度：O(n)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;空间复杂度：O(n)&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喏，速度提升至 &lt;code&gt;beat 99.96%&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtd5zy0d8j30hv042weu.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;拓展&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最基本的 &lt;code&gt;2 Sum&lt;/code&gt; 问题，这个题可以有太多的变种了：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组里有不止一组结果，要求返回所有组合，该怎么做？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组里有重复元素，又该怎么做？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果这个数组是一个排好序了的数组，那如何利用这个条件呢？- Leetcode 167&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果不是数组而是给一个 &lt;code&gt;BST&lt;/code&gt; ，该怎么在一棵树上找这俩数呢？- Leetcode 653&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里讲一下排序数组这道题，之后会在 &lt;code&gt;BST&lt;/code&gt; 的文章里会讲 653 这题。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;排序数组&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf6itm65j30mi0bo402.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道排序算法中最快的也需要 &lt;code&gt;O(nlogn)&lt;/code&gt;，所以如果是一个 &lt;code&gt;2 Sum&lt;/code&gt; 问题，那没必要专门排序，因为排序会成为运算的瓶颈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果题目给的就是个排好序了的数组，那肯定要好好收着了呀！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当数组是排好序的时候，我们可以进一步优化空间，达到 &lt;code&gt;O(n)&lt;/code&gt; 的时间和 &lt;code&gt;O(1)&lt;/code&gt; 的空间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该怎么利用排好序这个性质呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是说，在 &lt;code&gt;x&lt;/code&gt; 右边的数，都比 &lt;code&gt;x&lt;/code&gt; 要大；在 &lt;code&gt;x&lt;/code&gt; 左边的数，都比 &lt;code&gt;x&lt;/code&gt; 要小。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果 &lt;code&gt;x + y &amp;gt; target&lt;/code&gt;，那么就要 &lt;code&gt;y&lt;/code&gt; 往左走，往小的方向走；&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;如果 &lt;code&gt;x + y &amp;lt; target&lt;/code&gt;，那么就要 &lt;code&gt;x&lt;/code&gt; 往右走，往大的方向走。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtjsqaugfj30im06wgls.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就是典型的 &lt;code&gt;Two pointer&lt;/code&gt; 算法，两个指针相向而行的情况，我之后也会出文章详细来讲哒。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] twoSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] numbers, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; right = numbers.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (left &amp;lt; right) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; sum = numbers[left] + numbers[right];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (sum == target) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{left + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, right + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}; &lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (sum &amp;lt; target) {&lt;br/&gt;left ++;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;right --;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf785x1rj30m00bu756.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;3 Sum&lt;/code&gt; 的问题其实就是一个 &lt;code&gt;2 Sum&lt;/code&gt; 的升级版，因为 1 + 2 = 3 嘛。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是外面一层循环，固定一个值，在剩下的数组里做 &lt;code&gt;2 Sum&lt;/code&gt; 问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正 &lt;code&gt;3 Sum&lt;/code&gt; 怎么着都得 &lt;code&gt;O(n^2)&lt;/code&gt; ，就可以先排序，反正不在乎排序的这点时间了，这样就可以用 &lt;code&gt;Two pointer&lt;/code&gt; 来做了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还需要注意的是，这道题返回的是&lt;strong&gt;数值&lt;/strong&gt;，而非 &lt;code&gt;index&lt;/code&gt;，所以它不需要重复的数值——The solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;Arrays.sort(nums);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;lt; nums.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nums[i] == nums[i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k = nums.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target = -nums[i];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j] + nums[k] == target) {&lt;br/&gt;res.add(Arrays.asList(nums[i], nums[j], nums[k]));&lt;br/&gt;j++;&lt;br/&gt;k--;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k &amp;amp;&amp;amp; nums[j] == nums[j - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;j++;  &lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; k &amp;amp;&amp;amp; nums[k] == nums[k + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) {&lt;br/&gt;k--;  &lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j] + nums[k] &amp;gt; target) {&lt;br/&gt;k--;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;j++;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4 Sum&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是 &lt;code&gt;4 Sum&lt;/code&gt; 问题啦。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtf90id1nj30mk0c975d.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一题如果只是 &lt;code&gt;O(n^3)&lt;/code&gt; 的解法没什么难的，因为就是在 &lt;code&gt;3 Sum&lt;/code&gt; 的基础上再加一层循环嘛。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果在面试中只做出 &lt;code&gt;O(n^3)&lt;/code&gt; 恐怕就过不了了哦😯&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 4 个数，可以想成两两的 &lt;code&gt;2 Sum&lt;/code&gt;，先把第一个 &lt;code&gt;2 Sum&lt;/code&gt; 的结果存下来，然后在后续的数组中做第二个 &lt;code&gt;2 Sum&lt;/code&gt;，这样就可以把时间降低到 &lt;code&gt;O(n^2)&lt;/code&gt; 了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意的是，为了&lt;strong&gt;避免重复&lt;/strong&gt;，也就是下图的 &lt;code&gt;nums[x] + nums[y] + nums[z] + nums[k]&lt;/code&gt; ，其实和 &lt;code&gt;nums[z] + nums[k] + nums[x] + nums[y]&lt;/code&gt; 并没有区别，所以我们要&lt;strong&gt;限制第二组的两个数要在第一组的两个数之后&lt;/strong&gt;哦。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghtjt88465j30lh09ldga.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下代码吧：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target) {&lt;br/&gt;Set&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; set = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;Map&amp;lt;Integer, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;Arrays.sort(nums);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currSum = nums[i] + nums[j];&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pairs = map.getOrDefault(currSum, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;pairs.add(Arrays.asList(i, j));&lt;br/&gt;map.put(currSum, pairs);&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; i &amp;lt; nums.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; j &amp;lt; nums.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currSum = nums[i] + nums[j];&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prevPairs = map.get(target - currSum);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(prevPairs == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(List&amp;lt;Integer&amp;gt; pair : prevPairs) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(pair.get(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;lt; i) {&lt;br/&gt;set.add(Arrays.asList(nums[pair.get(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)], nums[pair.get(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)], nums[i], nums[j]));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(set);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，以上就是 &lt;code&gt;2 Sum&lt;/code&gt; 相关的所有问题啦，如果有收获的话，记得给我点个赞哦～&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghujn778icg30g10b91l0.gif&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Wed, 19 Aug 2020 00:05:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>2 Sum 这题是 Leetcode 的第一题，相信大部分小伙伴都听过的吧。 作为一道标着 Easy 难度的题，它真的这么简单吗？ 我在之前的刷题视频里说过，大家刷题一定要吃透一类题，为什么有的人题目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13527148.html</dc:identifier>
</item>
<item>
<title>实战开发，使用 Spring Session 与 Spring security 完成网站登录改造！！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13527127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13527127.html</guid>
<description>&lt;p&gt;上次小黑在文章中介绍了&lt;a href=&quot;https://mp.weixin.qq.com/s/8HgFYgrJDC3bi5MY0icJfg&quot;&gt;四种分布式一致性 Session 的实现方式&lt;/a&gt;，在这四种中最常用的就是后端集中存储方案，这样即使 web 应用重启或者扩容，Session 都没有丢失的风险。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073732307-816857285.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天我们就使用这种方式对 Session 存储方式进行改造，将其统一存储到 Redis 中。&lt;/p&gt;
&lt;h2 id=&quot;实现方案&quot;&gt;实现方案&lt;/h2&gt;
&lt;p&gt;我们先来想一下，如果我们不依靠任何框架，自己如何实现后端 &lt;strong&gt;Session&lt;/strong&gt; 集中存储。&lt;/p&gt;
&lt;p&gt;这里我们假设我们的网站除了某些页面，比如首页可以直接访问以外，其他任何页面都需要登录之后才能访问。&lt;/p&gt;
&lt;p&gt;如果需要实现这个需求，这就需要我们对每个请求都进行鉴权，鉴权目的是为了判断用户是否登录，判断用户角色。&lt;/p&gt;
&lt;p&gt;如果用户没有登录，我们需要将请求强制跳转到登录页面进行登录。&lt;/p&gt;
&lt;p&gt;用户登录之后，我们需要将登录获取到的用户信息存储到 &lt;strong&gt;Session&lt;/strong&gt; 中，这样后面请求鉴权只需要判断 &lt;strong&gt;Session&lt;/strong&gt; 中是否存在即可。&lt;/p&gt;
&lt;p&gt;知道整个流程之后，其实实现原理就不是很难了。&lt;/p&gt;
&lt;p&gt;我们可以使用类似 &lt;strong&gt;AOP&lt;/strong&gt; 的原理，在每个请求进来之后，都先判断 Session 中是否存在用户信息，如果不存在就跳转到登录页。&lt;/p&gt;
&lt;p&gt;整个流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073732698-806807378.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以利用 &lt;strong&gt;Servelt Filter&lt;/strong&gt; 实现上述流程，不过上述整套流程，Spring 已经帮我们实现了，那我们就不用重复造轮子了。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;strong&gt;Spring-Session&lt;/strong&gt; 与 &lt;strong&gt;Spring-security&lt;/strong&gt; 实现上述网站的流程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring-Session&lt;/strong&gt; 是 Spring 提供一套管理用户 &lt;strong&gt;Session&lt;/strong&gt; 的实现方案，使用 &lt;strong&gt;Spring-Session&lt;/strong&gt; 之后，默认 WEB 容器，比如 Tomcat，产生的 &lt;strong&gt;Session&lt;/strong&gt; 将会被 &lt;strong&gt;Spring-Session&lt;/strong&gt; 接管。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;strong&gt;Spring-Session&lt;/strong&gt; 还提供几种常见后端存储实现方案，比如 Redis，数据库等。&lt;/p&gt;
&lt;p&gt;有了 &lt;strong&gt;Spring-Session&lt;/strong&gt; 之后，它只是帮我们解决了 &lt;strong&gt;Session&lt;/strong&gt; 后端集中存储。但是上述流程中我们还需要登录授权，而这一块我们可以使用 &lt;strong&gt;Spring-security&lt;/strong&gt; 来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring-security&lt;/strong&gt; 可以维护统一的登录授权方式，同时它可以结合 &lt;strong&gt;Spring-Session&lt;/strong&gt; 一起使用。用户登录授权之后，获取的用户信息可以自动存储到 &lt;strong&gt;Spring-Session&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;好了，不说废话了，我们来看下实现代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下述使用 Spring Boot 实现， Spring-Boot 版本为：2.3.2.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spring-session&quot;&gt;Spring Session&lt;/h2&gt;
&lt;p&gt;首先我们引入 Spring Session 依赖，这里我们使用 Redis 集中存储 Session 信息，所以我们需要下述依赖即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不是 Spring Boot 项目，那主要需要引入如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-data-redis&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-session-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入依赖之后，我们首先需要在 &lt;code&gt;application.properties&lt;/code&gt;增加 Session 相关的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;## Session 存储方式
spring.session.store-type=redis

## Session 过期时间，默认单位为 s
server.servlet.session.timeout=600
## Session 存储到 Redis 键的前缀
spring.session.redis.namespace=test:spring:session

## Redis 相关配置
spring.redis.host=127.0.0.1
spring.redis.password=****
spring.redis.port=6379
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成之后，Spring Session 就会开始管理 Session 信息，下面我们来测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ResponseBody
@GetMapping(&quot;/hello&quot;)
public String hello() {
    return &quot;Hello World&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们访问上面地址之后，访问 Redis ，可以看到存储的 Session 信息。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6492890995261&quot;&gt;
&lt;p&gt;推荐大家一个 Redis 客户端「Another Redis DeskTop Manager」，这个客户端 UI 页面非常漂亮，操作也很方便，下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/qishibo/anotherredisdesktopmanager/releases&quot;&gt;https://github.com/qishibo/anotherredisdesktopmanager/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073733056-1836698601.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Session 默认使用HttpSession 序列化方式，这种值看起来不够直观。我们可以将其修改成 json 序列化方式，存储到 redis 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class HttpSessionConfig implements BeanClassLoaderAware {


    private ClassLoader loader;

    @Bean
    public RedisSerializer&amp;lt;Object&amp;gt; springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer(objectMapper());
    }

    /**
     * Customized {@link ObjectMapper} to add mix-in for class that doesn't have default
     * constructors
     *
     * @return the {@link ObjectMapper} to use
     */
    private ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModules(SecurityJackson2Modules.getModules(this.loader));
        return mapper;
    }


    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        this.loader = classLoader;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改之后 Redis 键值如下所示：&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073733751-1772629628.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps:这里 Redis 键值含义，下次分析源码的时候，再做分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Session 还存在一个 &lt;strong&gt;@EnableRedisHttpSession&lt;/strong&gt;，我们可以在这个注解上配置 Spring Session 相关配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableRedisHttpSession(redisNamespace = &quot;test:session&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，如果使用这个注解，将会导致 &lt;code&gt;application.properties&lt;/code&gt; Session 相关配置失效，也就是说 Spring Session 将会直接使用注解上的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073734092-78406027.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里小黑比较推荐大家使用配置文件的方式。&lt;/p&gt;
&lt;p&gt;好了，Spring Session 到这里我们就接入完成了。&lt;/p&gt;
&lt;h2 id=&quot;spring-security&quot;&gt;Spring security&lt;/h2&gt;
&lt;p&gt;上面我们集成了 Spring Session，完成 Session 统一 Redis 存储。接下来主要需要实现请求的登陆鉴权。&lt;/p&gt;
&lt;p&gt;这一步我们使用 Spring security 实现统一的登陆鉴权服务，同样的框架的还有 Shiro，这里我们就使用 Spring 全家桶。&lt;/p&gt;
&lt;p&gt;首先我们需要依赖的相应的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入上面的依赖之后，应用启动之后将会生成一个随机密码，然后所有的请求将会跳转到一个 Spring security 的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073734490-45924016.jpg&quot; alt=&quot;默认密码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200819073734796-843952487.jpg&quot; alt=&quot;登录页面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们需要实现自己业务的登陆页，所以我们需要自定义登录校验逻辑。&lt;/p&gt;
&lt;p&gt;在 Spring security 我们只需要实现 &lt;code&gt;UserDetailsService&lt;/code&gt;接口，重写 &lt;code&gt;loadUserByUsername&lt;/code&gt;方法逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    PasswordEncoder passwordEncoder;


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        // 简单起见，直接内部校验
        String uname = &quot;admin&quot;;
        String passwd = &quot;1234qwer&quot;;

        // 如果是正式项目，我们需要从数据库数据数据，然后再校验，形式如下：
        // User user = userDAO.query(username);

        if (!username.equals(uname)) {
            throw new UsernameNotFoundException(username);
        }
        // 封装成 Spring security 定义的 User 对象
        return User.builder()
                .username(username)
                .passwordEncoder(s -&amp;gt; passwordEncoder.encode(passwd))
                .authorities(new SimpleGrantedAuthority(&quot;user&quot;))
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码实现，这里主要在内存固定用户名与密码，真实环境下，我们需要修改成从数据库查询用户信息。&lt;/p&gt;
&lt;p&gt;接着我们需要把 &lt;code&gt;UserServiceImpl&lt;/code&gt; 配置到 &lt;code&gt;Spring security&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    @Autowired
    UserServiceImpl userService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 使用自定义用户服务校验登录信息
     *
     * @param auth
     * @throws Exception
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 用户登录信息校验使用自定义 userService
        // 还需要注意密码加密与验证需要使用同一种方式
        auth.userDetailsService(userService).passwordEncoder(passwordEncoder());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置中，密码部分我们使用 &lt;code&gt;BCrypt&lt;/code&gt; 算法加密，这里需要注意，加密与解密需要使用同一种方式。&lt;/p&gt;
&lt;p&gt;接着我们需要实现一个自定义的登陆页面，这里就懒得自己写了，直接使用 &lt;a href=&quot;https://github.com/spring-projects/spring-session.git&quot;&gt;spring-session-data-redis&lt;/a&gt; 页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns:th=&quot;https://www.thymeleaf.org&quot; xmlns:layout=&quot;https://github.com/ultraq/thymeleaf-layout-dialect&quot;
      layout:decorate=&quot;~{layout}&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Login&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div layout:fragment=&quot;content&quot;&amp;gt;
    &amp;lt;!-- 自定义登录的请求    --&amp;gt;
    &amp;lt;form name=&quot;f&quot; th:action=&quot;@{/auth/login}&quot; method=&quot;post&quot;&amp;gt;
        &amp;lt;fieldset&amp;gt;
            &amp;lt;legend&amp;gt;Please Login -&amp;lt;/legend&amp;gt;
            &amp;lt;div th:if=&quot;${param.error}&quot; class=&quot;alert alert-error&quot;&amp;gt;Invalid username and password.&amp;lt;/div&amp;gt;
            &amp;lt;div th:if=&quot;${param.logout}&quot; class=&quot;alert alert-success&quot;&amp;gt;You have been logged out.&amp;lt;/div&amp;gt;
            &amp;lt;label for=&quot;username&quot;&amp;gt;Username&amp;lt;/label&amp;gt;
            &amp;lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;/&amp;gt;
            &amp;lt;label for=&quot;password&quot;&amp;gt;Password&amp;lt;/label&amp;gt;
            &amp;lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;/&amp;gt;
            &amp;lt;input type=&quot;hidden&quot; th:name=&quot;${_csrf.parameterName}&quot; th:value=&quot;${_csrf.token}&quot;/&amp;gt;
            &amp;lt;label&amp;gt;remember me: &amp;lt;/label&amp;gt;
            &amp;lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot;/&amp;gt;
            &amp;lt;div class=&quot;form-actions&quot;&amp;gt;
                &amp;lt;button type=&quot;submit&quot; class=&quot;btn&quot;&amp;gt;Log in&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/fieldset&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一点，这里 &lt;strong&gt;form&lt;/strong&gt; 表单的请求地址使用 &lt;code&gt;/auth/login&lt;/code&gt;，我们需要在下面配置中修改，默认情况下登录请求的地址需要为 &lt;code&gt;/login&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着我们在上面的 &lt;code&gt;SecurityConfig&lt;/code&gt; 类增加相应配置方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 自定义处理登录处理
 *
 * @param http
 * @throws Exception
 */
@Override
protected void configure(HttpSecurity http) throws Exception {

    http.authorizeRequests((authorize) -&amp;gt; authorize
            .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() // 静态资源，比如 css,js 无需登录鉴权
            .anyRequest().permitAll() // 其他页面需要登录鉴权
    ).formLogin((formLogin) -&amp;gt; formLogin  // 自定义登录页面
            .loginPage(&quot;/login&quot;) // 登录页
            .loginProcessingUrl(&quot;/auth/login&quot;) // 自定义登录请求地址
            .permitAll()// 登录页当然无需鉴权了，不然不就套娃了吗？
    ).logout(LogoutConfigurer::permitAll // 登出页面
    ).rememberMe(rememberMe -&amp;gt; rememberMe
            .rememberMeCookieName(&quot;test-remember&quot;) // 自定义记住我 cookie 名
            .key(&quot;test&quot;) // 盐值
            .tokenValiditySeconds(3600 * 12)) // 记住我，本地生成 cookie 包含用户信息

    ;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法可能比较长，重点解释一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;authorizeRequests&lt;/code&gt;方法内需要指定那些页面需要鉴权，这里我们指定静态资源无需登录鉴权，其他请求我们都需要登录鉴权&lt;/li&gt;
&lt;li&gt;&lt;code&gt;formLogin&lt;/code&gt; 方法内修改默认的登录页面地址，以及登录的请求地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logout&lt;/code&gt;在这里面可以配置登出的相关配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rememberMe&lt;/code&gt;开启这个功能之后，当内部 Session 过期之后，用户还可以根据用户浏览器中的 Cookie 信息实现免登录的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们需要配置一些页面的跳转地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 首页
        registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;);
        // 登录之后跳转到 home 页
        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到此为止，我们已经集成 &lt;strong&gt;Spring-Session&lt;/strong&gt; 与 &lt;strong&gt;Spring-security&lt;/strong&gt; 完成完整的网站的登录鉴权功能。从这个例子可以看到，引入这个两个框架之后，我们只需要按照 Spring 规范开发即可，其他复杂实现原理我们都不需要自己实现了，这样真的很方便。&lt;/p&gt;
&lt;p&gt;上面只是一个简单的小例子，小黑只是抛转引玉一下，真实开发中可能需要修改配置会更多，这里需要使用小伙伴自己在深入研究了。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://creaink.github.io/post/Backend/SpringBoot/Spring-boot-security.html&quot;&gt;https://creaink.github.io/post/Backend/SpringBoot/Spring-boot-security.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-session&quot;&gt;https://github.com/spring-projects/spring-session&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 18 Aug 2020 23:38:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>上次小黑在文章中介绍了四种分布式一致性 Session 的实现方式，在这四种中最常用的就是后端集中存储方案，这样即使 web 应用重启或者扩容，Session 都没有丢失的风险。 今天我们就使用这种方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13527127.html</dc:identifier>
</item>
<item>
<title>JVM的方法执行引擎-模板表 - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13524329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13524329.html</guid>
<description>&lt;p&gt;Java的模板解析执行需要模板表与转发表的支持，而这2个表中的数据在HotSpot虚拟机启动时就会初始化。这一篇首先介绍模板表。&lt;/p&gt;
&lt;p&gt;在启动虚拟机阶段会调用init_globals()方法初始化全局模块，在这个方法中通过调用interpreter_init()方法初始化模板解释器，调用栈如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TemplateInterpreter::initialize()    templateInterpreter.cpp
interpreter_init()                   interpreter.cpp
init_globals()                       init.cpp
Threads::create_vm()                 thread.cpp
JNI_CreateJavaVM()                   jni.cpp
InitializeJVM()                      java.c
JavaMain()                           java.c
start_thread()                       pthread_create.c   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;interpreter_init()方法主要是通过调用TemplateInterpreter::initialize()方法来完成逻辑，initialize()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：/src/share/vm/interpreter/templateInterpreter.cpp
 
void TemplateInterpreter::initialize() {
  if (_code != NULL) 
       return;
 
  // 抽象解释器AbstractInterpreter的初始化，AbstractInterpreter是基于汇编模型的解释器的共同基类，
  // 定义了解释器和解释器生成器的抽象接口
  AbstractInterpreter::initialize();
 
  // 模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板
  TemplateTable::initialize();
 
  // generate interpreter
  {
     ResourceMark rm;
     int code_size = InterpreterCodeSize;
     // CodeCache的Stub队列StubQueue的初始化
     _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,&quot;Interpreter&quot;);
     //  实例化模板解释器生成器对象TemplateInterpreterGenerator
     InterpreterGenerator g(_code);
  }
 
  // initialize dispatch table
  _active_table = _normal_table;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板解释器的初始化包括如下几个方面：&lt;/p&gt;
&lt;p&gt;（1）抽象解释器AbstractInterpreter的初始化，AbstractInterpreter是基于汇编模型的解释器的共同基类，定义了解释器和解释器生成器的抽象接口。&lt;/p&gt;
&lt;p&gt;（2）模板表TemplateTable的初始化，模板表TemplateTable保存了各个字节码的模板（目标代码生成函数和参数）；&lt;/p&gt;
&lt;p&gt;（3）CodeCache的Stub队列StubQueue的初始化；&lt;/p&gt;
&lt;p&gt;（4）解释器生成器InterpreterGenerator的初始化。&lt;/p&gt;
&lt;p&gt;在之前介绍过，在TemplateInterpreter::initialize() 中通过调用语句来间接调用generate_method_entry()和generate_normal_entry()创建方法执行的栈帧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
InterpreterGenerator g(_code);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过在如上语句调用之前，首先需要调用TemplateInterpreter类中的initialize()方法初始化模板表，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TemplateTable::initialize();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板表TemplateTable保存了各个字节码的模板（目标代码生成函数和参数），initialize()方法的实现如下：&lt;/p&gt;
&lt;p&gt;源代码位置：/src/share/vm/interpreter/templateInterpreter.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;380&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void TemplateTable::initialize() {
  if (_is_initialized) return;


  _bs = Universe::heap()-&amp;gt;barrier_set();

  // For better readability
  const char _    = ' ';
  const int  ____ = 0;
  const int  ubcp = 1 &amp;lt;&amp;lt; Template::uses_bcp_bit;
  const int  disp = 1 &amp;lt;&amp;lt; Template::does_dispatch_bit;
  const int  clvm = 1 &amp;lt;&amp;lt; Template::calls_vm_bit;
  const int  iswd = 1 &amp;lt;&amp;lt; Template::wide_bit;
  //                                    interpr. templates
  // Java spec bytecodes                ubcp|disp|clvm|iswd  in    out   generator             argument
  def(Bytecodes::_nop                 , ____|____|____|____, vtos, vtos, nop                 ,  _           );
  def(Bytecodes::_aconst_null         , ____|____|____|____, vtos, atos, aconst_null         ,  _           );
  def(Bytecodes::_iconst_m1           , ____|____|____|____, vtos, itos, iconst              , -1           );
  def(Bytecodes::_iconst_0            , ____|____|____|____, vtos, itos, iconst              ,  0           );
  // ...
  def(Bytecodes::_tableswitch         , ubcp|disp|____|____, itos, vtos, tableswitch         ,  _           );
  def(Bytecodes::_lookupswitch        , ubcp|disp|____|____, itos, itos, lookupswitch        ,  _           );
  def(Bytecodes::_ireturn             , ____|disp|clvm|____, itos, itos, _return             , itos         );
  def(Bytecodes::_lreturn             , ____|disp|clvm|____, ltos, ltos, _return             , ltos         );
  def(Bytecodes::_freturn             , ____|disp|clvm|____, ftos, ftos, _return             , ftos         );
  def(Bytecodes::_dreturn             , ____|disp|clvm|____, dtos, dtos, _return             , dtos         );
  def(Bytecodes::_areturn             , ____|disp|clvm|____, atos, atos, _return             , atos         );
  def(Bytecodes::_return              , ____|disp|clvm|____, vtos, vtos, _return             , vtos         );
  def(Bytecodes::_getstatic           , ubcp|____|clvm|____, vtos, vtos, getstatic           , f1_byte      );
  def(Bytecodes::_putstatic           , ubcp|____|clvm|____, vtos, vtos, putstatic           , f2_byte      );
  def(Bytecodes::_getfield            , ubcp|____|clvm|____, vtos, vtos, getfield            , f1_byte      );
  def(Bytecodes::_putfield            , ubcp|____|clvm|____, vtos, vtos, putfield            , f2_byte      );
  def(Bytecodes::_invokevirtual       , ubcp|disp|clvm|____, vtos, vtos, invokevirtual       , f2_byte      );
  def(Bytecodes::_invokespecial       , ubcp|disp|clvm|____, vtos, vtos, invokespecial       , f1_byte      );
  def(Bytecodes::_invokestatic        , ubcp|disp|clvm|____, vtos, vtos, invokestatic        , f1_byte      );
  def(Bytecodes::_invokeinterface     , ubcp|disp|clvm|____, vtos, vtos, invokeinterface     , f1_byte      );
  def(Bytecodes::_invokedynamic       , ubcp|disp|clvm|____, vtos, vtos, invokedynamic       , f1_byte      );
  def(Bytecodes::_new                 , ubcp|____|clvm|____, vtos, atos, _new                ,  _           );
  def(Bytecodes::_newarray            , ubcp|____|clvm|____, itos, atos, newarray            ,  _           );
  def(Bytecodes::_anewarray           , ubcp|____|clvm|____, itos, atos, anewarray           ,  _           );
  def(Bytecodes::_arraylength         , ____|____|____|____, atos, itos, arraylength         ,  _           );
  def(Bytecodes::_athrow              , ____|disp|____|____, atos, vtos, athrow              ,  _           );
  def(Bytecodes::_checkcast           , ubcp|____|clvm|____, atos, atos, checkcast           ,  _           );
  def(Bytecodes::_instanceof          , ubcp|____|clvm|____, atos, itos, instanceof          ,  _           );
  def(Bytecodes::_monitorenter        , ____|disp|clvm|____, atos, vtos, monitorenter        ,  _           );
  def(Bytecodes::_monitorexit         , ____|____|clvm|____, atos, vtos, monitorexit         ,  _           );
  def(Bytecodes::_wide                , ubcp|disp|____|____, vtos, vtos, wide                ,  _           );
  def(Bytecodes::_multianewarray      , ubcp|____|clvm|____, vtos, atos, multianewarray      ,  _           );
  def(Bytecodes::_ifnull              , ubcp|____|clvm|____, atos, vtos, if_nullcmp          , equal        );
  def(Bytecodes::_ifnonnull           , ubcp|____|clvm|____, atos, vtos, if_nullcmp          , not_equal    );
  def(Bytecodes::_goto_w              , ubcp|____|clvm|____, vtos, vtos, goto_w              ,  _           );
  def(Bytecodes::_jsr_w               , ubcp|____|____|____, vtos, vtos, jsr_w               ,  _           );

  // wide Java spec bytecodes
  def(Bytecodes::_iload               , ubcp|____|____|iswd, vtos, itos, wide_iload          ,  _           );
  def(Bytecodes::_lload               , ubcp|____|____|iswd, vtos, ltos, wide_lload          ,  _           );
  // ...

  // JVM bytecodes
  def(Bytecodes::_fast_agetfield      , ubcp|____|____|____, atos, atos, fast_accessfield    ,  atos        );
  def(Bytecodes::_fast_bgetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );
  def(Bytecodes::_fast_cgetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );
  def(Bytecodes::_fast_dgetfield      , ubcp|____|____|____, atos, dtos, fast_accessfield    ,  dtos        );
  def(Bytecodes::_fast_fgetfield      , ubcp|____|____|____, atos, ftos, fast_accessfield    ,  ftos        );
  def(Bytecodes::_fast_igetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );
  def(Bytecodes::_fast_lgetfield      , ubcp|____|____|____, atos, ltos, fast_accessfield    ,  ltos        );
  def(Bytecodes::_fast_sgetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );

  def(Bytecodes::_fast_aputfield      , ubcp|____|____|____, atos, vtos, fast_storefield ,   atos        );
  def(Bytecodes::_fast_bputfield      , ubcp|____|____|____, itos, vtos, fast_storefield ,   itos        );
  def(Bytecodes::_fast_cputfield      , ubcp|____|____|____, itos, vtos, fast_storefield  ,  itos        );
  def(Bytecodes::_fast_dputfield      , ubcp|____|____|____, dtos, vtos, fast_storefield  ,  dtos        );
  def(Bytecodes::_fast_fputfield      , ubcp|____|____|____, ftos, vtos, fast_storefield  ,  ftos        );
  def(Bytecodes::_fast_iputfield      , ubcp|____|____|____, itos, vtos, fast_storefield  ,  itos        );
  def(Bytecodes::_fast_lputfield      , ubcp|____|____|____, ltos, vtos, fast_storefield  ,  ltos        );
  def(Bytecodes::_fast_sputfield      , ubcp|____|____|____, itos, vtos, fast_storefield  ,  itos        );

  def(Bytecodes::_fast_aload_0        , ____|____|____|____, vtos, atos, aload               ,  0           );
  def(Bytecodes::_fast_iaccess_0      , ubcp|____|____|____, vtos, itos, fast_xaccess        ,  itos        );
  def(Bytecodes::_fast_aaccess_0      , ubcp|____|____|____, vtos, atos, fast_xaccess        ,  atos        );
  def(Bytecodes::_fast_faccess_0      , ubcp|____|____|____, vtos, ftos, fast_xaccess        ,  ftos        );

  def(Bytecodes::_fast_iload          , ubcp|____|____|____, vtos, itos, fast_iload          ,  _       );
  def(Bytecodes::_fast_iload2         , ubcp|____|____|____, vtos, itos, fast_iload2         ,  _       );
  def(Bytecodes::_fast_icaload        , ubcp|____|____|____, vtos, itos, fast_icaload        ,  _       );

  def(Bytecodes::_fast_invokevfinal   , ubcp|disp|clvm|____, vtos, vtos, fast_invokevfinal   , f2_byte      );

  def(Bytecodes::_fast_linearswitch   , ubcp|disp|____|____, itos, vtos, fast_linearswitch   ,  _           );
  def(Bytecodes::_fast_binaryswitch   , ubcp|disp|____|____, itos, vtos, fast_binaryswitch   ,  _           );

  def(Bytecodes::_fast_aldc           , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  false       );
  def(Bytecodes::_fast_aldc_w         , ubcp|____|clvm|____, vtos, atos, fast_aldc           ,  true        );

  def(Bytecodes::_return_register_finalizer , ____|disp|clvm|____, vtos, vtos, _return       ,  vtos        );

  def(Bytecodes::_invokehandle        , ubcp|disp|clvm|____, vtos, vtos, invokehandle        , f1_byte      );

  def(Bytecodes::_shouldnotreachhere   , ____|____|____|____, vtos, vtos, shouldnotreachhere ,  _           );
  // platform specific bytecodes
  pd_initialize();

  _is_initialized = true;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TemplateTable的初始化调用def()将所有字节码的目标代码生成函数和参数保存在_template_table或_template_table_wide（wide指令）模板数组中。除了虚拟机规范本身定义的字节码指令外，HotSpot虚拟机也定义了一些字节码指令，这些指令为了辅助虚拟机进行更好、理简单的功能实现，例如Bytecodes::_return_register_finalizer等在之前已经介绍过，可以更好的实现finalizer类型对象的注册功能。&lt;/p&gt;
&lt;p&gt;对于调用def()函数时传递的一些参数在后面会解释。def()函数有2个，接收的参数不同，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void TemplateTable::def(
        Bytecodes::Code code, // 字节码指令
        int flags,            // 标志位
        TosState in,          // 模板执行前TosState
        TosState out,         // 模板执行后TosState
        void (*gen)(),        // 模板生成器，是模板的核心组件
        char filler
) {
  assert(filler == ' ', &quot;just checkin'&quot;);
  def(code, flags, in, out, (Template::generator)gen, 0); // 调用下面的def()函数
}

void TemplateTable::def(
  Bytecodes::Code code,    // 字节码指令
  int flags,               // 标志位
  TosState in,             // 模板执行前TosState
  TosState out,            // 模板执行后TosState
  void (*gen)(int arg),    // 模板生成器，是模板的核心组件
  int arg 
) {
  // should factor out these constants
  const int ubcp = 1 &amp;lt;&amp;lt; Template::uses_bcp_bit;      // 表示是否需要bcp指针
  const int disp = 1 &amp;lt;&amp;lt; Template::does_dispatch_bit; // 表示是否在模板范围内进行转发
  const int clvm = 1 &amp;lt;&amp;lt; Template::calls_vm_bit;      // 表示是否需要调用JVM函数
  const int iswd = 1 &amp;lt;&amp;lt; Template::wide_bit;          // 表示是否为wild指令

  // determine which table to use
  bool is_wide = (flags &amp;amp; iswd) != 0;

  // make sure that wide instructions have a vtos entry point
  // (since they are executed extremely rarely, it doesn't pay out to have an
  // extra set of 5 dispatch tables for the wide instructions - for simplicity
  // they all go with one table)
  assert(in == vtos || !is_wide, &quot;wide instructions have vtos entry point only&quot;);
  Template* t = is_wide ? template_for_wide(code) : template_for(code);

  // setup entry
  t-&amp;gt;initialize(flags, in, out, gen, arg); // 调用模板表t的initialize()方法初始化模板表
  assert(t-&amp;gt;bytecode() == code, &quot;just checkin'&quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板表由模板表数组与一组生成器组成：&lt;/p&gt;
&lt;p&gt;（1）模板表数组有_template_table与_template_table_wild，数组的下标为bytecode，值为Template，按照字节码指令的操作码递增顺序排列。&lt;/p&gt;
&lt;p&gt;（2）一组生成器，所有与bytecode配套的生成器，在初始化模板表时作为gen参数传给相应的Template。&lt;/p&gt;
&lt;p&gt;Template类的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：hotspot/src/share/vm/interpreter/templateTable.hpp
// A Template describes the properties of a code template for a given bytecode
// and provides a generator to generate the code template.

class Template VALUE_OBJ_CLASS_SPEC {
 private:
  enum Flags {
    // 字节码指令指的是该字节码的操作数是否存在于字节码里面
    uses_bcp_bit,     // set if template needs the bcp pointing to bytecode
    does_dispatch_bit,// set if template dispatches on its own
    calls_vm_bit,     // set if template calls the vm
    wide_bit          // set if template belongs to a wide instruction
  };

  typedef void (*generator)(int arg);

  int       _flags;   // describes interpreter template properties (bcp unknown)
  TosState  _tos_in;  // tos cache state before template execution
  TosState  _tos_out; // tos cache state after  template execution
  generator _gen;     // template code generator
  int       _arg;     // argument for template code generator
  ...

  // Templates
  static Template* template_for(Bytecodes::Code code)  {
          Bytecodes::check(code);
          return &amp;amp;_template_table[code];
  }
  static Template* template_for_wide(Bytecodes::Code code)  {
          Bytecodes::wide_check(code);
          return &amp;amp;_template_table_wide[code];
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的template_for()与template_for_wild()方法从_template_table或_template_for_wild数组中取值。这2个变量定义在TemplateTable类中，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static Template        _template_table     [Bytecodes::number_of_codes];
static Template        _template_table_wide[Bytecodes::number_of_codes];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续看TemplateTable::def(0函数的各个参数，解释如下：&lt;/p&gt;
&lt;p&gt;（1）_flags：是一个标志，低四位分别表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;uses_bcp_bit，标志需要使用字节码指针（byte code pointer，数值为字节码基址+字节码偏移量）&lt;/li&gt;
&lt;li&gt;does_dispatch_bit，标志是否在模板范围内进行转发，如跳转类指令会设置该位&lt;/li&gt;
&lt;li&gt;calls_vm_bit，标志是否需要调用JVM函数&lt;/li&gt;
&lt;li&gt;wide_bit，标志是否是wide指令（使用附加字节扩展全局变量索引）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）_tos_in：表示模板执行前的TosState（操作数栈栈顶元素的数据类型，TopOfStack，用来检查模板所声明的输出输入类型是否和该函数一致，以确保栈顶元素被正确使用）&lt;/p&gt;
&lt;p&gt;（3）_tos_out：表示模板执行后的TosState &lt;/p&gt;
&lt;p&gt;（4）_gen：表示模板生成器（函数指针）&lt;/p&gt;
&lt;p&gt;（5）_arg：表示模板生成器参数&lt;/p&gt;
&lt;p&gt;再来看一下TemplateTable::initialize()方法中对def()函数的调用，以_iinc（将局部变量增加1）为例，调用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
def(
        Bytecodes::_iinc,     // 字节码指令
        ubcp|____|clvm|____,  // 标志
        vtos,                 // 模板执行前的TosState
        vtos,                 // 模板执行后的TosState
        iinc ,                // 模板生成器，是一个iinc()函数的指针
        _                     // 不需要模板生成器参数
);　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置标志位uses_bcp_bit和calls_vm_bit，表示iinc指令的生成器需要使用bcp指针函数at_bcp()，且需要调用JVM函数，下面给出了生成器的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp

void TemplateTable::iinc() {
  transition(vtos, vtos);
  __ load_signed_byte(rdx, at_bcp(2)); // get constant
  locals_index(rbx);
  __ addl(iaddress(rbx), rdx);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iinc指令的格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
iinc
index
const
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作码iinc占用一个字节，而index与const分别占用一个字节。使用at_bcp()函数获取iinc指令的操作数，2表示偏移2字节，所以会将const取出来存储到rdx中。调用locals_index()函数取出index，locals_index()就是JVM函数。最终生成的汇编如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// %r13存储的是指向字节码的指针，偏移2字节后取出const存储到%edx
0x00007fffe101a210: movsbl 0x2(%r13),%edx
// 取出index存储到%ebx
0x00007fffe101a215: movzbl 0x1(%r13),%ebx
0x00007fffe101a21a: neg    %rbx
// %r14指向本地变量表的首地址，将%edx加到%r14+%rbx*8指向的内存所存储的值上
// 之所以要对%rbx执行neg进行符号反转，是因为在Linux内核的操作系统上，栈是向低地址方向生长的
0x00007fffe101a21d: add    %edx,(%r14,%rbx,8)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过这里并不会调用iinc()函数生成对应的汇编代码，只是将传递给def()函数的各种信息保存到Template对象中，在TemplateTable::def()方法中，通过template_for()或template_for_wild()方法获取到数组中对应的Template对象后，就会调用Template::initialize()方法，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void Template::initialize(int flags, TosState tos_in, TosState tos_out, generator gen, int arg) {
  _flags   = flags;
  _tos_in  = tos_in;
  _tos_out = tos_out;
  _gen     = gen;
  _arg     = arg;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，只是将信息保存到对应的Template对象中，这样就可以根据字节码索引从数组中获取对应的Template对象，进而获取相关信息。下一篇我们将会看到对这些信息的使用。　　&lt;/p&gt;
&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;10、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13291427.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（6）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;11、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13297034.html&quot; target=&quot;_blank&quot;&gt;操作句柄Handle（7）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13303505.html&quot; target=&quot;_blank&quot;&gt;句柄Handle的释放（8）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13320889.html&quot; target=&quot;_blank&quot;&gt;类加载器&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;14、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13338549.html&quot; target=&quot;_blank&quot;&gt;类的双亲委派机制&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;15、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13343296.html&quot; target=&quot;_blank&quot;&gt;核心类的预装载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13353233.html&quot; target=&quot;_blank&quot;&gt;Java主类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;17、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13354961.html&quot; target=&quot;_blank&quot;&gt;触发类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;18、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13356636.html&quot; target=&quot;_blank&quot;&gt;类文件介绍&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;19、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13358460.html&quot; target=&quot;_blank&quot;&gt;文件流&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;20、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407609.html&quot; target=&quot;_blank&quot;&gt;解析Class文件&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;21、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407690.html&quot; target=&quot;_blank&quot;&gt;常量池解析（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;22、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13408261.html&quot; target=&quot;_blank&quot;&gt;常量池解析（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409707.html&quot; target=&quot;_blank&quot;&gt;字段解析（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409953.html&quot; target=&quot;_blank&quot;&gt;字段解析之伪共享（2）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;25、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413170.html&quot; target=&quot;_blank&quot;&gt;字段解析（3） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;26、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413207.html&quot; target=&quot;_blank&quot;&gt;字段解析之OopMapBlock（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;27、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436627.html&quot; target=&quot;_blank&quot;&gt;方法解析之Method与ConstMethod介绍 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;28、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436632.html&quot; target=&quot;_blank&quot;&gt;方法解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13456515.html&quot; target=&quot;_blank&quot;&gt;klassVtable与klassItable类的介绍&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;30、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13461949.html&quot; target=&quot;_blank&quot;&gt;计算vtable的大小&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;31、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13462910.html&quot; target=&quot;_blank&quot;&gt;计算itable的大小 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;32、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13467751.html&quot; target=&quot;_blank&quot;&gt;解析Class文件之创建InstanceKlass对象&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;33、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13469745.html&quot; target=&quot;_blank&quot;&gt;字段解析之字段注入&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;34、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13470515.html&quot; target=&quot;_blank&quot;&gt;类的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;35、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13473410.html&quot; target=&quot;_blank&quot;&gt;类的连接之验证&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;36、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474567.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;37、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474577.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;38、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13488845.html&quot; target=&quot;_blank&quot;&gt;方法的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;39、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13494714.html&quot; target=&quot;_blank&quot;&gt;初始化vtable&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;40、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495636.html&quot; target=&quot;_blank&quot;&gt;初始化itable &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;41、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495639.html&quot; target=&quot;_blank&quot;&gt;类的初始化 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;42、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13500050.html&quot; target=&quot;_blank&quot;&gt;对象的创建 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;43、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13502748.html&quot; target=&quot;_blank&quot;&gt;Java引用类型&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;44、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13503800.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之软引用（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;45、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13503996.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之软引用（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;46、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13504081.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之弱引用与幻像引用&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;47、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13504083.html&quot; target=&quot;_blank&quot;&gt;Java引用类型之最终引用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;48、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13511722.html&quot; target=&quot;_blank&quot;&gt;HotSpot的垃圾回收算法&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;49、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13511728.html&quot; target=&quot;_blank&quot;&gt;HotSpot的垃圾回收器 &lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;50、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13516197.html&quot; target=&quot;_blank&quot;&gt;CallStub栈帧 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;51、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13516634.html&quot; target=&quot;_blank&quot;&gt;entry point栈帧 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;52、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13518846.html&quot; target=&quot;_blank&quot;&gt;generate_fixed_frame()方法生成Java方法栈帧 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;53、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13518830.html&quot; target=&quot;_blank&quot;&gt;dispatch_next()方法的实现 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;54、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13524213.html&quot; target=&quot;_blank&quot;&gt;虚拟机执行模式&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;classloading.com&lt;/strong&gt;&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;   &lt;/p&gt;


</description>
<pubDate>Tue, 18 Aug 2020 22:49:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>Java的模板解析执行需要模板表与转发表的支持，而这2个表中的数据在HotSpot虚拟机启动时就会初始化。这一篇首先介绍模板表。 在启动虚拟机阶段会调用init_globals()方法初始化全局模块，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13524329.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】一文学会20多个动画组件 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13527110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13527110.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064023447-1353525453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老孟导读：此篇文章是 Flutter 动画系列文章第三篇，后续还有动画序列、过度动画、转场动画、自定义动画等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flutter 系统提供了20多个动画组件，只要你把前面【动画核心】(文末有链接)的文章看明白了，这些组件对你来说是非常轻松的，这些组件大部分都是对常用操作的封装。&lt;/p&gt;
&lt;h2 id=&quot;显示动画组件&quot;&gt;显示动画组件&lt;/h2&gt;
&lt;p&gt;回顾上一篇【动画核心】的文章中创建动画三个必须的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 AnimationController。&lt;/li&gt;
&lt;li&gt;监听 AnimationController，调用 &lt;code&gt;setState&lt;/code&gt; 刷新UI。&lt;/li&gt;
&lt;li&gt;释放 AnimationController。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看第二步，每个动画都需要这个步骤，因此对其封装，命名为 MyAnimatedWidget：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyAnimatedWidget extends StatefulWidget {
  final AnimationController controller;
  final Widget child;

  const MyAnimatedWidget(
      {Key key, @required this.controller, @required  this.child})
      : super(key: key);

  @override
  _MyAnimatedWidgetState createState() =&amp;gt; _MyAnimatedWidgetState();
}

class _MyAnimatedWidgetState extends State&amp;lt;MyAnimatedWidget&amp;gt; {
  @override
  void initState() {
    super.initState();
    widget.controller.addListener(() {
      setState(() {});
    });
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
        
  @override
  void dispose() {
    super.dispose();
    widget.controller.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义的动画组件只有两个功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;监听 AnimationController，调用 &lt;code&gt;setState&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;释放 AnimationController。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而 AnimationController 的创建需要开发者自行创建，为什么封装在自定义组件内？这个后面会介绍。&lt;/p&gt;
&lt;p&gt;其实这个组件不用我们自己封装，因为系统已经封装好了，在学习 Flutter 的过程中自定义组件是非常重要的，因此多封装一些组件，即使是系统已经存在的，用自己和系统的进行对比，可以极大的提高我们自定义组件的能力。&lt;/p&gt;
&lt;p&gt;系统封装的类似上面的组件是 &lt;strong&gt;AnimatedWidget&lt;/strong&gt;，此类是抽象类，源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064024003-443987302.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;我们使用 监听 AnimationController，调用 &lt;code&gt;setState&lt;/code&gt; ，而系统使用 &lt;strong&gt;Listenable&lt;/strong&gt;，Listenable 是一个维护侦听器列表的对象，用于通知客户端该对象已被更新。&lt;/p&gt;
&lt;p&gt;Listenable 有两个变体：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;ValueListenable&lt;/strong&gt; ：扩展[Listenable]接口的接口，具有当前值的概念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Animation&lt;/strong&gt;：一个扩展[ValueListenable]接口的接口，添加方向（正向或反向）的概念。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AnimationController 的继承结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064024344-73742644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AnimationController 也是继承自 Listenable，因此使用 Listenable 适用的范围更广，不仅仅可以用于 Animation ，还可以用于 ChangeNotifier。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于使用了 Listenable，因此监听和释放使用&lt;code&gt;listenable.addListener&lt;/code&gt; 和 &lt;code&gt;listenable.removeListener&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AnimatedWidget 是一个抽象类，不能直接使用，其子类包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064024624-84255965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;strong&gt;ScaleTransition&lt;/strong&gt; 为例使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class AnimationDemo extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _AnimationDemo();
}

class _AnimationDemo extends State&amp;lt;AnimationDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _animationController;
  Animation _animation;

  @override
  void initState() {
    _animationController =
        AnimationController(duration: Duration(seconds: 2), vsync: this);

    _animation = Tween(begin: .5, end: .1).animate(_animationController);

    //开始动画
    _animationController.forward();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return ScaleTransition(
      scale: _animation,
      child: Container(
        height: 200,
        width: 200,
        color: Colors.red,
      ),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064024829-623230035.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和【动画核心】中写法唯一的不同是不需要主动调用 &lt;code&gt;setState&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;AnimatedWidget 其他子类的用法类似，不在一一介绍，其他组件的详细用法可到 &lt;a href=&quot;http://laomengit.com/flutter/widgets/widgets_structure.html&quot;&gt;http://laomengit.com/flutter/widgets/widgets_structure.html&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;h2 id=&quot;隐式动画组件&quot;&gt;隐式动画组件&lt;/h2&gt;
&lt;p&gt;AnimatedWidget 只是封装了 &lt;code&gt;setState&lt;/code&gt;，系统是否有封装 AnimationController、Tween、Curve且自动管理AnimationController的组件呢？有的，此组件就是 &lt;strong&gt;ImplicitlyAnimatedWidget&lt;/strong&gt;，ImplicitlyAnimatedWidget 也是一个抽象类，其子类包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064025213-254862451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;strong&gt;AnimatedOpacity&lt;/strong&gt; 为例使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class AnimatedWidgetDemo extends StatefulWidget {
  @override
  _AnimatedWidgetDemoState createState() =&amp;gt; _AnimatedWidgetDemoState();
}

class _AnimatedWidgetDemoState extends State&amp;lt;AnimatedWidgetDemo&amp;gt; {
  double _opacity = 1.0;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AnimatedOpacity(
        opacity: _opacity,
        duration: Duration(seconds: 2),
        child: GestureDetector(
          onTap: () {
            setState(() {
              _opacity = 0;
            });
          },
          child: Container(
            height: 60,
            width: 150,
            color: Colors.blue,
          ),
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064025520-757869135.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 AnimatedOpacity 我们并没有主动创建 AnimationController 和 Tween，是因为 AnimatedOpacity 内部已经创建了。&lt;/p&gt;
&lt;p&gt;所以别看 Flutter 内置了20多种动画组件，90% 都是对上面两种方式的封装，分别称为隐式动画组件 和 显示动画组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;隐式动画组件&lt;/strong&gt;：只需提供给组件动画开始、结束值，组件创建 AnimationController、Curve、Tween，执行动画，释放AnimationController，我们称之为隐式动画组件，隐式动画组件有： &lt;strong&gt;AnimatedAlign&lt;/strong&gt;、&lt;strong&gt;AnimatedContainer&lt;/strong&gt;、&lt;strong&gt;AnimatedDefaultTextStyle&lt;/strong&gt;、&lt;strong&gt;AnimatedOpacity&lt;/strong&gt;、&lt;strong&gt;AnimatedPadding&lt;/strong&gt;、&lt;strong&gt;AnimatedPhysicalModel&lt;/strong&gt;、&lt;strong&gt;AnimatedPositioned&lt;/strong&gt;、&lt;strong&gt;AnimatedPositionedDirectional&lt;/strong&gt;、&lt;strong&gt;AnimatedTheme&lt;/strong&gt;、&lt;strong&gt;SliverAnimatedOpacity&lt;/strong&gt;、&lt;strong&gt;TweenAnimationBuilder&lt;/strong&gt;、&lt;strong&gt;AnimatedContainer&lt;/strong&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显示动画组件&lt;/strong&gt;：需要设置 AnimationController，控制动画的执行，使用显式动画可以完成任何隐式动画的效果，甚至功能更丰富一些，不过你需要管理该动画的 AnimationController 生命周期，AnimationController 并不是一个控件，所以需要将其放在 stateful 控件中。显示动画组件有：&lt;strong&gt;AlignTransition&lt;/strong&gt;、&lt;strong&gt;AnimatedBuilder&lt;/strong&gt;、&lt;strong&gt;AnimatedModalBarrier&lt;/strong&gt;、&lt;strong&gt;DecoratedBoxTransition&lt;/strong&gt;、&lt;strong&gt;DefaultTextStyleTransition&lt;/strong&gt;、&lt;strong&gt;PositionedTransition&lt;/strong&gt;、&lt;strong&gt;RelativePositionedTransition&lt;/strong&gt;、&lt;strong&gt;RotationTransition&lt;/strong&gt;、&lt;strong&gt;ScaleTransition&lt;/strong&gt;、&lt;strong&gt;SizeTransition&lt;/strong&gt;、&lt;strong&gt;SlideTransition&lt;/strong&gt; 、&lt;strong&gt;FadeTransition&lt;/strong&gt; 等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不难看出，使用隐式动画控件，代码更简单，而且无需管理 AnimationController 的生命周期，有人觉得隐式动画组件多方便啊，为什么还要显示动画组件呢？因为：&lt;strong&gt;封装的越复杂，使用越简单，往往伴随着功能越不丰富。&lt;/strong&gt;比如想让动画一直重复执行，隐式动画组件是无法实现的。&lt;/p&gt;
&lt;p&gt;显示动画组件和隐式动画组件中各有一个万能的组件，它们是 &lt;strong&gt;AnimatedBuilder&lt;/strong&gt; 和 &lt;strong&gt;TweenAnimationBuilder&lt;/strong&gt;，当系统中不存在我们想要的动画组件时，可以使用这两个组件，以 AnimatedBuilder 为例，实现 Container 大小和颜色同时动画，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class AnimatedBuilderDemo extends StatefulWidget {
  @override
  _AnimatedBuilderDemoState createState() =&amp;gt; _AnimatedBuilderDemoState();
}

class _AnimatedBuilderDemoState extends State&amp;lt;AnimatedBuilderDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
  Animation&amp;lt;Color&amp;gt; _colorAnimation;
  Animation&amp;lt;Size&amp;gt; _sizeAnimation;

  @override
  void initState() {
    _controller =
        AnimationController(vsync: this, duration: Duration(seconds: 2));

    _colorAnimation =
        ColorTween(begin: Colors.blue, end: Colors.red).animate(_controller);
    _sizeAnimation =
        SizeTween(begin: Size(100.0, 50.0), end: Size(200.0, 100.0))
            .animate(_controller);

    _controller.forward();
    super.initState();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, widget) {
          return Container(
            width: _sizeAnimation.value.width,
            height: _sizeAnimation.value.height,
            color: _colorAnimation.value,
          );
        },
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064025972-1486978650.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AnimatedBuilder&lt;/strong&gt; 和 &lt;strong&gt;TweenAnimationBuilder&lt;/strong&gt; 本质上和其他动画组件没有区别，只是给了我们更高的灵活性。&lt;/p&gt;
&lt;h2 id=&quot;如何选取&quot;&gt;如何选取&lt;/h2&gt;
&lt;p&gt;Flutter 内置的动画组件分为两种：&lt;strong&gt;隐式动画组件&lt;/strong&gt; 和 &lt;strong&gt;显示动画组件&lt;/strong&gt; ，显示动画组件只封装了 &lt;code&gt;setState&lt;/code&gt; 方法，需要开发者创建 AnimationController，并管理 AnimationController。隐式动画组件封装了 AnimationController、Curve、Tween，只需提供给组件动画开始、结束值，其余由系统管理。&lt;/p&gt;
&lt;p&gt;隐式动画组件可以完成效果，显示动画组件都可以完成，那么什么时候使用隐式动画组件？什么时候使用显示动画组件？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断你的动画组件是否一直重复，比如一直转圈的loading动画，如果是选择显式动画。&lt;/li&gt;
&lt;li&gt;判断你的动画组件是否需要多个组件联动，如果是选择显式动画。&lt;/li&gt;
&lt;li&gt;判断你的动画组件是否需要组合动画，如果是选择显式动画。&lt;/li&gt;
&lt;li&gt;如果上面三个条件都是否，就选择隐式动画组件，判断是否已经内置动画组件，如果没有，使用 TweenAnimationBuilder，有就直接使用内置动画组件。&lt;/li&gt;
&lt;li&gt;选择显式动画组件，判断是否已经内置动画组件，如果没有，使用 AnimatedBuilder，有就直接使用内置动画组件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;逻辑图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064026245-462589891.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个简单的区分办法：如果你的动画相对比较简单，动画从一种状态过渡到另一种状态，不需要单独控制 AnimationController，这种情况下，隐式动画组件一般可以就可以实现。&lt;/p&gt;
&lt;p&gt;不过也没有必要特别纠结使用隐式动画组件还是显示动画组件，不管使用哪一种，实现效果即可。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064026493-734376921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200819064026803-1173183616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 18 Aug 2020 22:40:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：此篇文章是 Flutter 动画系列文章第三篇，后续还有动画序列、过度动画、转场动画、自定义动画等。 Flutter 系统提供了20多个动画组件，只要你把前面【动画核心】(文末有链接)的文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13527110.html</dc:identifier>
</item>
<item>
<title>【译】New experimental Razor editor for Visual Studio - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13527029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13527029.html</guid>
<description>&lt;p&gt;随着 Visual Studio 2019 16.7 Preview 4 的发布，现在可以尝试我们新的实验性Razor编辑器，用于本地开发，包括 MVC、Razor Page 和 Blazor。我们很期待你来试一试！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;123.61739054596&quot;&gt;
&lt;p&gt;　　随着 Visual Studio 2019 16.7 Preview 4 的发布，现在可以尝试我们新的实验性 Razor 编辑器，用于本地开发，包括 MVC、Razor Page 和 Blazor。我们很期待你来试一试！&lt;/p&gt;

&lt;p&gt;　　要在 Visual Studio 2019 16.7 Preview 4 或更高版本中启用新的实验性 Razor 编辑器：&lt;/p&gt;
&lt;p&gt;　　1. 安装最新版 Visual Studio&lt;/p&gt;
&lt;p&gt;　　2. 点击 &lt;strong&gt;Tools&lt;/strong&gt; &amp;gt; &lt;strong&gt;Options&lt;/strong&gt; &amp;gt; &lt;strong&gt;Environment&lt;/strong&gt; &amp;gt; &lt;strong&gt;Preview Features&lt;/strong&gt;，勾选Enable experimental Razor editor 选项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202008/270073-20200819011838846-1596732727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 点击 OK 并重启 Visual Studio&lt;/p&gt;
&lt;p&gt;　　如此，现在可以使用新的 Razor 编辑器。&lt;/p&gt;

&lt;p&gt;　　Razor 是一种基于 HTML 和 C# 的模板语言，用于为基于 MVC、Razor Page 和 Blazor 的 .NET Web 应用程序定义动态呈现逻辑。在 MVC 和 Razor 页面应用程序中，你使用 Razor 来定义视图和页面的呈现逻辑 .cshtml 文件。在 Blazor 中，使用 Razor 在 .razor 文件中编写可重用的 UI 组件。Razor 是使用 .NET 构建 Web 应用程序的体验中至关重要的一部分。&lt;/p&gt;
&lt;p&gt;　　你现在可以尝试一下 Razor，用 ASP.NET Core 或 Blazor 构建你的第一个Web 应用程序。&lt;/p&gt;

&lt;p&gt;　　Razor 的部分价值在于 Visual Studio 为编辑 Razor 文件提供了丰富的工具体验。Visual Studio 现在在同一个 Razor 文件中为 HTML、CSS、JavaScript、C# 和 Razor 特定语法提供了智能感知、自动完成和诊断。&lt;/p&gt;
&lt;p&gt;　　Visual Studio 做了一些巧妙的操作，以在 Razor 文件中同时启用对所有这些语言的编辑器支持。对 Razor 文档进行解析以确定其组成部分，然后将每个部分投影到一个称为投影缓冲区的特定于语言的缓冲区中。在 Visual Studio 中编辑 Razor 文档时，您看到的是这些投影缓冲区中的一组小窗口，它们组成了一个完整的文档。然后，每个语言服务分别为每个独立的投影缓冲区处理编辑体验。&lt;/p&gt;
&lt;p&gt;　　例如，考虑下面Razor代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;About&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Visual Studio 处理 Razor 代码的方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202008/270073-20200819011920040-1901948511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个项目缓冲区设置在 Visual Studio 和 Mac 的 Visual Studio 中工作得很好，但是对于远程编辑场景，比如 Visual Studio LiveShare 或 Visual Studio Codespaces，它就有问题了。它也不能用于没有投影缓冲区支持的编辑器，比如 Visual Studio Code。由于 Razor 编辑器缺少中央编配器，如果不仔细协调各种语言服务实现（因为它们在投影场景中控制自己的体验），就很难启用新特性。&lt;/p&gt;

&lt;p&gt;　　为了更广泛地支持 Razor 编辑，我们已经为一个基于 Razor 语言服务器的 ASP.NET Core 项目的新的 Razor 编辑器工作了一段时间。这个新的 Razor 语言服务器通过 LSP（Language Server Protocol）实现了一些编辑器特性，比如自动完成、转到定义等，LSP 为编辑器或 IDE 定义了一种启用这些特性的标准方法。然后一个 IDE 特定的 Razor 扩展用于处理与 Razor 语言服务器以及其他 HTML 和 C# 语言服务器的协调。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202008/270073-20200819012024791-891657695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个新的 Razor 语言服务器已经作为 C# 扩展的一部分在 Visual Studio 代码中启用了对 Razor 的支持。它将是 Visual Studio Codespaces 和 Visual Studio LiveShare 支持 Razor 编辑的基础。现在可以在 Visual Studio 中作为预览特性进行本地开发。&lt;/p&gt;
&lt;p&gt;　　目前，我们的重点是使新的基于 LSP 的 Razor 编辑器在功能上与现有的 Visual Studio Razor 编辑体验相同（如下所述，仍然有一些功能上的差距需要解决）。在未来的版本中，我们希望通过添加重要的新功能来填补这些功能空白，比如为 Razor 带来更多的 C# 编辑特性，以及其他针对 Razor 的生产力改进。&lt;/p&gt;

&lt;p&gt;　　新的 Razor 编辑器目前还处于试验阶段，有一些已知的限制。下面的Razor编辑器功能还没有完全实现，将在未来的版本中增加：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持 JavaScript 和 CSS 的智能感知&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C#、JavaScript、CSS、Blazor 组件、Tag Helper 和 tooltip 的颜色设置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;格式化仅限于 @code 和 @functions 块中的 C# 代码（没有嵌入 HTML 标记或 Razor 语法）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HTML 中支持 URL 选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C# 代码段（“prop”、“ctor”等）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;复杂的 C# 自动完成（例如，生成 override）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从 C# 到 Razor 的定义/实现&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C# 文件中的重命名不会传播到Razor文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HTML 和 { } 中匹配标识符高亮显示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　16.7 Preview 4 中新的 Razor 编辑器也有一些功能问题，这些问题将在未来的版本中解决：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C# 中标识错误的波浪线可能是对不齐&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;由于在 Razor 文件中不必要地使用指令而报告了不必要的信息错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Blazor 组件和 Tag Helper 现在的颜色和 C# 类一样，不受 Tag Helper 颜色选项的控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　对于 Visual Studio 中新的基于 LSP 的 Razor 编辑体验来说，现在还处于早期阶段。我们知道，在它取代 Visual Studio 中现有的 Razor 编辑经验之前，还有很多工作要做。新的 Razor 工具在 16.7 中仍然是可选的和实验性的，我们不希望它成为默认的 Razor 编辑器，直到它的功能超过了现有的编辑器。但是，我们希望尽早与你分享我们的进展，以便开始获得你对新 Razor 编辑器工作情况的反馈。为了确保我们提供最好的 Razor 编辑经验，请尝试新的 Razor 工具并让我们知道你的想法。你可以通过在 GitHub 上分享你的反馈。我们感谢你的反馈！&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/new-experimental-razor-editor-for-visual-studio/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://devblogs.microsoft.com/aspnet/new-experimental-razor-editor-for-visual-studio/&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Tue, 18 Aug 2020 17:47:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>随着 Visual Studio 2019 16.7 Preview 4 的发布，现在可以尝试我们新的实验性Razor编辑器，用于本地开发，包括 MVC、Razor Page 和 Blazor。我们很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13527029.html</dc:identifier>
</item>
<item>
<title>OptaPlanner的新约束表达方式 Constraint Streams - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/13527040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/13527040.html</guid>
<description>&lt;p&gt;　　有好些时间没有写过关于OptaPlanner的东西了，其实近半年来，OptaPlanner还是推出了不少有用、好用的新特性。包括本文讲到的以Stream接口实现评分编程。关于OptraPlanner的约束详细用法，可以参考官方资料.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最近几个版本推出的新功能、特性中，有不少功能还处于初始探索阶段，甚至有些功能还未成体系，包括我在上一篇文件中推出的SolverManger实现批量异步规划。此功能尚未支持ProblemChanged接口，从而无法实现Realtime Planning. 因此，若需要将这些功能应用于项目实践，还请自行作详细调查分析，以免在项目中处于进退两难境地。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;PS. 任何技术都一样，功能、版本越新，带来的收益越高，当然需要面对的风险也越高。&lt;/p&gt;
&lt;p&gt;　　对OptaPlanner有初步认识都清楚，我们使用OptaPlanner规划建模时，需要在模型中表达一系列约束，以描述各个业务实体的约束和规划的优化目标。以往通常有两种方式实现评分逻辑（详细可分为3种）。分别是：&lt;/p&gt;
&lt;p&gt;1. 通过Drools脚本中的Rule来描述约束并进行评分；&lt;/p&gt;
&lt;p&gt;2. 通过Java编写评分逻辑，通过Java编辑评分逻辑又分为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2.1. Java简易评分 - Easy Java score calculation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2.2. Java增量评分 - Incremental Java score calculation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从7.31版本开始提供的constraint streams属于Java增量评分的一种。在普通的Java增量评分中，我们需要针对各个约束逻辑，编辑相应的判断，并在满足一定条件后，通过ScoreHolder对象进行记分。引擎会将各个层次的分数进行累加，成为当前方案的总分。Constraint Streams的原理也一样，只是通过强大的Stream特性，令评分逻辑更为简洁，使用更短的代码即可实现更丰富的逻辑描述。&lt;/p&gt;
&lt;p&gt;　　关于Java的Stream特性(Java1.8及以后的版本才出现）的使用方法，可自行通过其它网络资源学习，本文假设读者熟悉Java Stream的各种用法。&lt;/p&gt;
&lt;p&gt;我们先以一个简单的示例说明Constraint streams接口的使用方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doNotAssignAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getShiftList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmployeeAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上述代码块是一Java简易评分的示例，从方法名doNotAssignAnn就很容易理解到，该约束的作用是“使得任务不要分配给Ann”。我们知道在OptaPlanner里，评分通常都是负数，表示惩罚一个行为，令引擎找出尽可能规避这种行为的方案。示例中使用了Java的Stream功能进行判断和过滤。其逻辑是：从班次列表中找出所有分配给了Ann的班次，对每一个满足这个条件的班次进行扣分，并把分数加总作为方法的返回值。&lt;/p&gt;
&lt;p&gt;　　那么同样的约束要求，使用Constraint Stream应该如何实现呢？见以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doNotAssignAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmployeeAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Don't assign Ann&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_SOFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先要提醒一下，与Java简单评分法类似（评分类需要实现EasyScoreCalculator接口），OptaPlanner的Constraint Stream提供一个名为ConstraintProvider的接口，实现评分的类需要实现这个接口，这个接口只有一个需要实现的方法 - defineConstraints，它传入ConstrantFactory类，返回一个Constraint数组，数组的元素就是已进行了评分和惩罚的各个约束对象。上面的代码中可以看到，doNotAssignAnn方法返回一个Constraint对象，这个对象表示了对Ann被分配到的班次数的惩罚分数。上述代码可以看到，我们只需要对ConstraintFactory的对象factory进行Stream操作，一步即可完成判断、过滤和惩罚三个操作，完成这些操作后会得到一个操作过的Contraint对象，返回该对象即可。上述代码中，对于factory的三步操作也相当明了，大家可以自己理解。&lt;/p&gt;
&lt;p&gt;　　但是对于一些更复杂的判断，其实现步骤与模式也一样，只不过需要编写一些更复杂的Lambda表达式来进行判断、过滤和各种运算。如下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getComputer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRequiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;requiredCpuPowerTotal&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_HARD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该代码是CloudBalance中用于，计算限制一台计划机被分配超出其CPU运算能力的约束。大家可以回想，或从官方示例中看一下CloudBalance的其中一个最基本约束 - 每台计算机所分得的CPU需求，不可超过该计算机的可用CPU能力。&lt;/p&gt;
&lt;p&gt;　　因此，可以看到，factory除了过from操作获得所有Process对象，通过filter对Process进行过滤，通过penalize进行计分外。factory对象还有一个groupBy方法，用于对所有Process中的Computer进行分组并加总每一组（即每个Computer）的所有CPU计算能力需求量。因此，在filter方法中，就找出那些超出CPU能力的Computer（即分组），在penalize方法中，对整所有超出CPU需求中的计算进行扣分，扣分值是超出部分。&lt;/p&gt;
&lt;p&gt;　　由此可能，OptaPlanner提供的Constraint Stream可以进行更复杂的条件判断，至于这种方法是否更好用，就取决于大家对Stream（类似C#中的Linq）的熟悉程度。&lt;/p&gt;
&lt;p&gt;　　至于整个Constraint Stream代码的结果方式，即上面提到的实现ConstraintProvider接口的代码如下(摘自官方示例CloudBalance)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CloudBalancingConstraintProvider&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConstraintProvider&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defineConstraints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredMemoryTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredNetworkBandwidthTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;computerCost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ************************************************************************
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Hard constraints
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ************************************************************************
&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getComputer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRequiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;requiredCpuPowerTotal&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_HARD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重复提示一下，Constraint Stream功能是7.31版才开始提供的功能，从功能接口上应该是未够成功的，如果需要在项目中实现一些更为复杂的约束描述，建议暂时还是不要直接使用。在OptaPlanner的用户手册中，也有相关的提示；大家看情况而用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-612afc3109ffc5a71f9805622429856a_720w.png&quot; width=&quot;1138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;131&quot; data-original=&quot;https://pic4.zhimg.com/v2-612afc3109ffc5a71f9805622429856a_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-612afc3109ffc5a71f9805622429856a_b.png&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最近一段时间OptaPlanner更新算比较频繁，但从网站上的更新内容看到，很多版本尽管隔了很长时间，但接口上的更新内容却不多。我向Geoffrey查询过，他表示这些版本更多的情况是在实现一些引擎内部的优化和一些新的内部运算功能，但这些功能不一定反映到API上，因此对于我们使用者来说，并没有太大的变化。可是如果大家也跟进将OptaPlanner的程序包也更新到最新版本，就会发现，很多一些常用的接口、方法，都已经被标准为将为放弃，从Javadocs上可以看到一些当前版本被标识为&lt;span&gt;@Deprecated&lt;/span&gt;的方法、成员，已明确说明将在8.x中停止使用。&lt;/p&gt;
&lt;p&gt;　　上述功能希望可以帮大家理解并应用OptaPlanner的第四种评分方式。&lt;/p&gt;
&lt;p&gt;有好些时间没有写过关于OptaPlanner的东西了，其实近半年来，OptaPlanner还是推出了不少有用、好用的新特性。包括本文讲到的以Stream接口实现评分编程。关于OptraPlanner的约束详细用法，可以参考官方资料：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.optaplanner.org/7.41.0.Final/optaplanner-docs/html_single/index.html%23constraintStreams&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Constraint streams score calculation&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;/span&gt;docs.optaplanner.org&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近几个版本推出的新功能、特性中，有不少功能还处于初始探索阶段，甚至有些功能还未成体系，包括我在上一篇文件中推出的SolverManger实现批量异步规划。此功能尚未支持ProblemChanged接口，从而无法实现Realtime Planning. 因此，若需要将这些功能应用于项目实践，还请自行作详细调查分析，以免在项目中处于进退两难境地。&lt;/p&gt;
&lt;p&gt;PS. 任何技术都一样，功能、版本越新，带来的收益越高，当然需要面对的风险也越高。&lt;/p&gt;
&lt;p&gt;对OptaPlanner有初步认识都清楚，我们使用OptaPlanner规划建模时，需要在模型中表达一系列约束，以描述各个业务实体的约束和规划的优化目标。以往通常有两种方式实现评分逻辑（详细可分为3种）。分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过Drools脚本中的Rule来描述约束并进行评分；&lt;/li&gt;
&lt;li&gt;通过Java编写评分逻辑，通过Java编辑评分逻辑又分为：
&lt;ol&gt;&lt;li&gt;Java简易评分 - Easy Java score calculation&lt;/li&gt;
&lt;li&gt;Java增量评分 - Incremental Java score calculation&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从7.31版本开始提供的constraint streams属于Java增量评分的一种。在普通的Java增量评分中，我们需要针对各个约束逻辑，编辑相应的判断，并在满足一定条件后，通过ScoreHolder对象进行记分。引擎会将各个层次的分数进行累加，成为当前方案的总分。Constraint Streams的原理也一样，只是通过强大的Stream特性，令评分逻辑更为简洁，使用更短的代码即可实现更丰富的逻辑描述。&lt;/p&gt;
&lt;p&gt;关于Java的Stream特性(Java1.8及以后的版本才出现）的使用方法，可自行通过其它网络资源学习，本文假设读者熟悉Java Stream的各种用法。&lt;/p&gt;
&lt;p&gt;我们先以一个简单的示例说明Constraint streams接口的使用方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doNotAssignAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getShiftList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmployeeAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述代码块是一Java简易评分的示例，从方法名doNotAssignAnn就很容易理解到，该约束的作用是“使得任务不要分配给Ann”。我们知道在OptaPlanner里，评分通常都是负数，表示惩罚一个行为，令引擎找出尽可能规避这种行为的方案。示例中使用了Java的Stream功能进行判断和过滤。其逻辑是：从班次列表中找出所有分配给了Ann的班次，对每一个满足这个条件的班次进行扣分，并把分数加总作为方法的返回值。&lt;/p&gt;
&lt;p&gt;那么同样的约束要求，使用Constraint Stream应该如何实现呢？见以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doNotAssignAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmployeeAnn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Don't assign Ann&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_SOFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先要提醒一下，与Java简单评分法类似（评分类需要实现EasyScoreCalculator接口），OptaPlanner的Constraint Stream提供一个名为ConstraintProvider的接口，实现评分的类需要实现这个接口，这个接口只有一个需要实现的方法 - defineConstraints，它传入ConstrantFactory类，返回一个Constraint数组，数组的元素就是已进行了评分和惩罚的各个约束对象。上面的代码中可以看到，doNotAssignAnn方法返回一个Constraint对象，这个对象表示了对Ann被分配到的班次数的惩罚分数。上述代码可以看到，我们只需要对ConstraintFactory的对象factory进行Stream操作，一步即可完成判断、过滤和惩罚三个操作，完成这些操作后会得到一个操作过的Contraint对象，返回该对象即可。上述代码中，对于factory的三步操作也相当明了，大家可以自己理解。&lt;/p&gt;
&lt;p&gt;但是对于一些更复杂的判断，其实现步骤与模式也一样，只不过需要编写一些更复杂的Lambda表达式来进行判断、过滤和各种运算。如下代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getComputer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRequiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;requiredCpuPowerTotal&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_HARD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该代码是CloudBalance中用于，计算限制一台计划机被分配超出其CPU运算能力的约束。大家可以回想，或从官方示例中看一下CloudBalance的其中一个最基本约束 - 每台计算机所分得的CPU需求，不可超过该计算机的可用CPU能力。&lt;/p&gt;
&lt;p&gt;因此，可以看到，factory除了过from操作获得所有Process对象，通过filter对Process进行过滤，通过penalize进行计分外。factory对象还有一个groupBy方法，用于对所有Process中的Computer进行分组并加总每一组（即每个Computer）的所有CPU计算能力需求量。因此，在filter方法中，就找出那些超出CPU能力的Computer（即分组），在penalize方法中，对整所有超出CPU需求中的计算进行扣分，扣分值是超出部分。&lt;/p&gt;
&lt;p&gt;由此可能，OptaPlanner提供的Constraint Stream可以进行更复杂的条件判断，至于这种方法是否更好用，就取决于大家对Stream（类似C#中的Linq）的熟悉程度。&lt;/p&gt;
&lt;p&gt;至于整个Constraint Stream代码的结果方式，即上面提到的实现ConstraintProvider接口的代码如下(摘自官方示例CloudBalance)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CloudBalancingConstraintProvider&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConstraintProvider&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defineConstraints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredMemoryTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;requiredNetworkBandwidthTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;computerCost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ************************************************************************
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Hard constraints
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ************************************************************************
&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Constraint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requiredCpuPowerTotal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConstraintFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constraintFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getComputer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CloudProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRequiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;penalize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;requiredCpuPowerTotal&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;HardSoftScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ONE_HARD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requiredCpuPower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCpuPower&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重复提示一下，Constraint Stream功能是7.31版才开始提供的功能，从功能接口上应该是未够成功的，如果需要在项目中实现一些更为复杂的约束描述，建议暂时还是不要直接使用。在OptaPlanner的用户手册中，也有相关的提示；大家看情况而用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-612afc3109ffc5a71f9805622429856a_720w.png&quot; width=&quot;1138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;131&quot; data-original=&quot;https://pic4.zhimg.com/v2-612afc3109ffc5a71f9805622429856a_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-612afc3109ffc5a71f9805622429856a_b.png&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近一段时间OptaPlanner更新算比较频繁，但从网站上的更新内容看到，很多版本尽管隔了很长时间，但接口上的更新内容却不多。我向Geoffrey查询过，他表示这些版本更多的情况是在实现一些引擎内部的优化和一些新的内部运算功能，但这些功能不一定反映到API上，因此对于我们使用者来说，并没有太大的变化。可是如果大家也跟进将OptaPlanner的程序包也更新到最新版本，就会发现，很多一些常用的接口、方法，都已经被标准为将为放弃，从Javadocs上可以看到一些当前版本被标识为&lt;span&gt;@Deprecated&lt;/span&gt;的方法、成员，已明确说明将在8.x中停止使用。&lt;/p&gt;

&lt;p&gt;本系列文章在公众号不定时连载，请关注公众号（让APS成为可能）及时接收,二维码：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-ece8f48f45bb8a2a69bf8925efb6791e_hd.jpg&quot; alt=&quot;&quot; width=&quot;400&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;400&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ece8f48f45bb8a2a69bf8925efb6791e_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;如需了解更多关于Optaplanner的应用，请发电邮致：&lt;a href=&quot;mailto:kentbill@gmail.com&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;br/&gt;或到讨论组发表你的意见：&lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;groups.google.com/forum&lt;span class=&quot;invisible&quot;&gt;/#!forum/optaplanner-cn&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)&lt;/p&gt;

&lt;p&gt;上述功能希望可以帮大家理解并应用OptaPlanner的第四种评分方式。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Aug 2020 17:25:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>有好些时间没有写过关于OptaPlanner的东西了，其实近半年来，OptaPlanner还是推出了不少有用、好用的新特性。包括本文讲到的以Stream接口实现评分编程。关于OptraPlanner的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kentzhang/p/13527040.html</dc:identifier>
</item>
</channel>
</rss>