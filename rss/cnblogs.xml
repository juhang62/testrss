<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.net core中Quartz的使用 - ♀影☆响</title>
<link>http://www.cnblogs.com/dangzhensheng/p/10496278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dangzhensheng/p/10496278.html</guid>
<description>&lt;p&gt;原来工作中有用到定时任务Quartz，不过是在MVC项目中，现在net core项目中也要用到，就开始改版。中间发现在网上的教程只有执行定时计划的过程，却很少有人写注册的过程，觉得有点略坑。所以写此文章一是自己做个记录，二是希望能帮助到其他人。后面还把此功能做出了多任务定时执行，网上关于net core的教程更是少了，花费了不少时间实现了出来。&lt;/p&gt;
&lt;p&gt;Quartz版本：3.0.7&lt;/p&gt;
&lt;p&gt;1.NuGet中下载安装Quartz&lt;/p&gt;
&lt;p&gt;2.新建Quartz帮助类&lt;/p&gt;
&lt;p&gt; (1)新建QuartzJob类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuartzJob : IJob
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jobKey = context.JobDetail.Key;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取job信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; triggerKey = context.Trigger.Key;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取trigger信息&lt;/span&gt;
&lt;span&gt;
            LogHelper.Info($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} QuartzJob:==&amp;gt;&amp;gt;自动执行.{jobKey.Name}|{triggerKey.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  ps： 上面代码中的&lt;span&gt;jobKey和&lt;/span&gt;&lt;span&gt;triggerKey可获取到自己定义的job和trigger的信息，这样做多任务时可区分要执行的是哪个任务. 另LogHelper.Info是自己封装好的日子记录类，可替换为自己的日志类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）新建QuartzFactory类，代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuartzFactory : IJobFactory
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider _serviceProvider;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; QuartzFactory(IServiceProvider serviceProvider)
        {
            _serviceProvider &lt;/span&gt;=&lt;span&gt; serviceProvider;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jobDetail =&lt;span&gt; bundle.JobDetail;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; job =&lt;span&gt; (IJob)_serviceProvider.GetService(jobDetail.JobType);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; job;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReturnJob(IJob job)
        {
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （3）新建QuartzService类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt; 单任务
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartJob&amp;lt;TJob&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TJob : IJob
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scheduler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory().GetScheduler().Result;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; job = JobBuilder.Create&amp;lt;TJob&amp;gt;&lt;span&gt;()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trigger1 =&lt;span&gt; TriggerBuilder.Create()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job.trigger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .StartNow()
                .WithSimpleSchedule(x &lt;/span&gt;=&amp;gt; x.WithInterval(TimeSpan.FromSeconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)).RepeatForever())
                .ForJob(job)
                .Build();

            scheduler.AddJob(job, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            scheduler.ScheduleJob(job, trigger1);
            scheduler.Start();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 多任务
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartJobs&amp;lt;TJob&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TJob : IJob
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scheduler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory().GetScheduler().Result;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; job = JobBuilder.Create&amp;lt;TJob&amp;gt;&lt;span&gt;()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jobs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trigger1 =&lt;span&gt; TriggerBuilder.Create()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job.trigger1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .StartNow()
                .WithSimpleSchedule(x &lt;/span&gt;=&amp;gt; x.WithInterval(TimeSpan.FromSeconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)).RepeatForever())
                .ForJob(job)
                .Build();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trigger2 =&lt;span&gt; TriggerBuilder.Create()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job.trigger2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .StartNow()
                .WithSimpleSchedule(x &lt;/span&gt;=&amp;gt; x.WithInterval(TimeSpan.FromSeconds(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)).RepeatForever())
                .ForJob(job)
                .Build();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dictionary = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;IJobDetail, IReadOnlyCollection&amp;lt;ITrigger&amp;gt;&amp;gt;&lt;span&gt;
            {
                {job, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;ITrigger&amp;gt;&lt;span&gt; {trigger1, trigger2}}
            };
            scheduler.ScheduleJobs(dictionary, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            scheduler.Start();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 配置
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddQuartz(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] jobs)
        {
            services.AddSingleton&lt;/span&gt;&amp;lt;IJobFactory, QuartzFactory&amp;gt;&lt;span&gt;();
            services.Add(jobs.Select(jobType &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceDescriptor(jobType, jobType, ServiceLifetime.Singleton)));

            services.AddSingleton(provider &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; schedulerFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scheduler =&lt;span&gt; schedulerFactory.GetScheduler().Result;
                scheduler.JobFactory &lt;/span&gt;= provider.GetService&amp;lt;IJobFactory&amp;gt;&lt;span&gt;();
                scheduler.Start();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; scheduler;
            });
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.在Startup.cs中注册代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
            services.AddQuartz(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(QuartzJob));&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;........&lt;/span&gt;
&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    QuartzService.StartJobs&lt;/span&gt;&amp;lt;QuartzJob&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;........&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ps: 因AddQuartz方法定义的是Type[]类型，所以可传多个执行类，如：services.AddQuartz(typeof(QuartzJob1), typeof(QuartzJob2)); 不过这样做StartJob()方法就得另处理下，这里就略过&lt;/p&gt;

&lt;p&gt;OK，大功告成，这个东西折腾了两天终于尘埃落定了，执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/588260/201903/588260-20190308154840882-128363129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Mar 2019 07:51:00 +0000</pubDate>
<dc:creator>♀影☆响</dc:creator>
<og:description>原来工作中有用到定时任务Quartz，不过是在MVC项目中，现在net core项目中也要用到，就开始改版。中间发现在网上的教程只有执行定时计划的过程，却很少有人写注册的过程，觉得有点略坑。所以写此文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dangzhensheng/p/10496278.html</dc:identifier>
</item>
<item>
<title>大数据技术之_11_HBase学习_02_HBase API 操作 + HBase 与 Hive 集成 + HBase 优化 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10495955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10495955.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h6hbaseapi&quot;&gt;第6章 HBase API 操作&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h61&quot;&gt;6.1 环境准备&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h62hbaseapi&quot;&gt;6.2 HBase API&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h621&quot;&gt;6.2.1 判断表是否存在&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h622configurationconnectionadmin&quot;&gt;6.2.2 抽取获取 Configuration、Connection、Admin 对象的方法以及关闭资源的方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h623admin&quot;&gt;6.2.3 创建表（admin）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h624admin&quot;&gt;6.2.4 删除表（admin）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h625put&quot;&gt;6.2.5 向表中插入数据（put）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h626delete&quot;&gt;6.2.6 删除多行数据（delete）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h627scan&quot;&gt;6.2.7 获取所有数据（scan）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h628get&quot;&gt;6.2.8 获取某一行数据（get）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h629get&quot;&gt;6.2.9 获取某一行指定“列族:列”的数据（get）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h63mapreduce&quot;&gt;6.3 MapReduce&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h631hbasemapreduce&quot;&gt;6.3.1 官方 HBase-MapReduce&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h632hbasemapreduce1&quot;&gt;6.3.2 自定义 HBase-MapReduce1&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h633hbasemapreduce2&quot;&gt;6.3.3 自定义 HBase-MapReduce2&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h64hive&quot;&gt;6.4 与 Hive 的集成&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h641hbasehive&quot;&gt;6.4.1 HBase 与 Hive 的对比&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h642hbasehive&quot;&gt;6.4.2 HBase 与 Hive 集成使用&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h7hbase&quot;&gt;第7章 HBase 优化&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h71&quot;&gt;7.1 高可用&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h72&quot;&gt;7.2 预分区&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h73rowkey&quot;&gt;7.3 RowKey 设计&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h74&quot;&gt;7.4 内存优化&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10495955.html#h75&quot;&gt;7.5 基础优化&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h6hbaseapi&quot;&gt;&lt;span&gt;&lt;strong&gt;第6章 HBase API 操作&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1 环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;新建项目后在pom.xml中添加依赖：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;xml language-xml hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.hbase&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase-server&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3.1&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.hbase&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase-client&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3.1&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;jdk.tools&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jdk.tools&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}/lib/tools.jar&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h62hbaseapi&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2 HBase API&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h621&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.1 判断表是否存在&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;旧API&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isTableExistOldAPI&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; MasterNotRunningException, ZooKeeperConnectionException, IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;deprecation&quot;&lt;/span&gt;)&lt;br/&gt;HBaseConfiguration conf = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HBaseConfiguration();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.25.102&quot;&lt;/span&gt;);&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;2181&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;deprecation&quot;&lt;/span&gt;)&lt;br/&gt;HBaseAdmin hBaseAdmin = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HBaseAdmin(conf);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; tableExists = hBaseAdmin.tableExists(tableName);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;hBaseAdmin.close();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tableExists;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新API&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isTableExistNewAPI&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; MasterNotRunningException, ZooKeeperConnectionException, IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Configuration conf = HBaseConfiguration.create();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.25.102&quot;&lt;/span&gt;);&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;2181&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Connection connection = ConnectionFactory.createConnection(conf);&lt;br/&gt;Admin admin = connection.getAdmin();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; tableExists = admin.tableExists(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;admin.close();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; tableExists;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h622configurationconnectionadmin&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.2 抽取获取 Configuration、Connection、Admin 对象的方法以及关闭资源的方法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;20&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Admin admin = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Connection conn = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Configuration conf = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; {&lt;br/&gt;conf = HBaseConfiguration.create();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.25.102&quot;&lt;/span&gt;);&lt;br/&gt;conf.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;2181&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;conn = ConnectionFactory.createConnection(conf);&lt;br/&gt;admin = conn.getAdmin();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Connection conn, Admin admin)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (conn != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;conn.close();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (admin != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;admin.close();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;注意&lt;/code&gt;：以下演示均使用新API！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h623admin&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.3 创建表（admin）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;createTable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName, String... columnFamily)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isTableExistNewAPI(tableName)) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;表&quot;&lt;/span&gt; + tableName + &lt;span class=&quot;hljs-string&quot;&gt;&quot;已存在！&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;HTableDescriptor hTableDescriptor = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HTableDescriptor(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String cf : columnFamily) {&lt;br/&gt;HColumnDescriptor HColumnDescriptor = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HColumnDescriptor(cf);&lt;br/&gt;hTableDescriptor.addFamily(HColumnDescriptor);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;admin.createTable(hTableDescriptor);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;表&quot;&lt;/span&gt; + tableName + &lt;span class=&quot;hljs-string&quot;&gt;&quot;创建成功！&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h624admin&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.4 删除表（admin）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteTable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isTableExistNewAPI(tableName)) {&lt;br/&gt;admin.disableTable(TableName.valueOf(tableName));&lt;br/&gt;admin.deleteTable(TableName.valueOf(tableName));&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;表&quot;&lt;/span&gt; + tableName + &lt;span class=&quot;hljs-string&quot;&gt;&quot;删除成功！&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;表&quot;&lt;/span&gt; + tableName + &lt;span class=&quot;hljs-string&quot;&gt;&quot;不存在！&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：truncate，清空表数据，实际底层操作是先使表不可用（下线），然后删除表，最后根据表信息重新创建一张新表。&lt;/p&gt;
&lt;h4 id=&quot;h625put&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.5 向表中插入数据（put）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;9&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;putRowData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName, String rowKey, String columnFamily, String column, String value)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Table table = conn.getTable(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;Put put = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Put(Bytes.toBytes(rowKey));&lt;br/&gt;put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(column), Bytes.toBytes(value));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;table.put(put);&lt;/p&gt;&lt;p&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;插入数据成功&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;table.close();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h626delete&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.6 删除多行数据（delete）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName, String rowKey, String columnFamily, String column)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Table table = conn.getTable(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Delete delete = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Delete(Bytes.toBytes(rowKey));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;table.delete(delete);&lt;/p&gt;&lt;p&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;删除多行数据成功&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;table.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h627scan&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.7 获取所有数据（scan）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;9&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;scanTable&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Table table = conn.getTable(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Scan scan = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Scan();&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;ResultScanner resultScanner = table.getScanner(scan);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Result result : resultScanner) {&lt;br/&gt;Cell[] cells = result.rawCells();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Cell cell : cells) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;行键:&quot;&lt;/span&gt; + Bytes.toString(result.getRow())&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列族：&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneFamily(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneQualifier(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 值:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneValue(cell)));&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;table.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表结构图解：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0GxH.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h628get&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.8 获取某一行数据（get）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;9&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getRowData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName, String rowKey)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Table table = conn.getTable(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Get get = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Get(Bytes.toBytes(rowKey));&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Result result = table.get(get);&lt;br/&gt;Cell[] cells = result.rawCells();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Cell cell : cells) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;行键:&quot;&lt;/span&gt; + Bytes.toString(result.getRow())&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列族：&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneFamily(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneQualifier(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 值:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneValue(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 时间戳:&quot;&lt;/span&gt; + cell.getTimestamp());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;table.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h629get&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.9 获取某一行指定“列族:列”的数据（get）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getRowQualifierData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String tableName, String rowKey, String columnFamily, String column)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;Table table = conn.getTable(TableName.valueOf(tableName));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Get get = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Get(Bytes.toBytes(rowKey));&lt;br/&gt;get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(column));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Result result = table.get(get);&lt;br/&gt;Cell[] cells = result.rawCells();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Cell cell : cells) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;行键:&quot;&lt;/span&gt; + Bytes.toString(result.getRow())&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列族：&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneFamily(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 列:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneQualifier(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 值:&quot;&lt;/span&gt; + Bytes.toString(CellUtil.cloneValue(cell))&lt;br/&gt;+ &lt;span class=&quot;hljs-string&quot;&gt;&quot; 时间戳:&quot;&lt;/span&gt; + cell.getTimestamp());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;table.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数代码：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; MasterNotRunningException, ZooKeeperConnectionException, IOException &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;getRowQualifierData(&lt;span class=&quot;hljs-string&quot;&gt;&quot;student&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;1002&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;info&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;close(conn, admin);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h63mapreduce&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3 MapReduce&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  通过 HBase 的相关 JavaAPI，我们可以实现伴随 HBase 操作的 MapReduce 过程，比如使用 MapReduce 将数据从本地文件系统导入到 HBase 的表中，比如我们从 HBase 中读取一些原始数据后使用 MapReduce 做数据分析。&lt;/p&gt;
&lt;h4 id=&quot;h631hbasemapreduce&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.1 官方 HBase-MapReduce&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;0．使用 MapReduce 作为 HBase 的分析框架，首先我们需要 Hadoop 持有 HBase 的jar包。&lt;br/&gt;1．查看 HBase 的 MapReduce 任务的执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;$ bin/hbase mapredcp&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．环境变量的导入&lt;br/&gt;（1）执行环境变量的导入（临时生效，在命令行执行下述操作）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;$ &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HBASE_HOME=&lt;span class=&quot;hljs-regexp&quot;&gt;/opt/m&lt;/span&gt;odule/hbase&lt;br/&gt;$ &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HADOOP_HOME=&lt;span class=&quot;hljs-regexp&quot;&gt;/opt/m&lt;/span&gt;odule/hadoop&lt;span class=&quot;hljs-number&quot;&gt;-2.7&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.2&lt;/span&gt;&lt;br/&gt;$ &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HADOOP_CLASSPATH=&lt;span class=&quot;hljs-string&quot;&gt;`&lt;span class=&quot;hljs-subst&quot;&gt;${HBASE_HOME}&lt;/span&gt;/bin/hbase mapredcp`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）永久生效：在/etc/profile配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HBASE_HOME=/opt/&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;/hbase&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使/etc/profile文件生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs shell&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; /etc/profile&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在 hadoop-env.sh 中配置：（&lt;code&gt;注意&lt;/code&gt;：在for循环之后配，即使用&lt;code&gt;追加&lt;/code&gt;的方式）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;export HADOOP_CLASSPATH=$HADOOP_CLASSPATH&lt;span class=&quot;hljs-symbol&quot;&gt;:/opt/module/hbase/lib/*&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置分发&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ xsync etc/hadoop/hadoop-env.sh &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．运行官方的 MapReduce 任务&lt;br/&gt;案例一：统计 Student 表中有多少行数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; ./&lt;span class=&quot;hljs-title&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hbase&lt;/span&gt;-&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt;-1.3.1.&lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;rowcounter&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;student&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;案例二：使用 MapReduce 将本地数据导入到 HBase&lt;br/&gt;1）在本地(HDFS)创建一个 tsv 格式的文件：fruit.tsv&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs ruby&quot; readability=&quot;2&quot;&gt;[atguigu@hadoop102 datas]$ pwd&lt;br/&gt;/opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;datas&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;[atguigu@hadoop102 datas]$ vim fruit.tsv&lt;p&gt;&lt;span class=&quot;hljs-number&quot;&gt;1001&lt;/span&gt;    Apple   Red&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1002&lt;/span&gt;    Pear    Yellow&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1003&lt;/span&gt;    Pineapple   Yellow&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）在 HBase 上创建 fruit 表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;hbase(main):001:0&amp;gt;&lt;/span&gt; create &lt;span class=&quot;hljs-string&quot;&gt;'fruit'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'info'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）在 HDFS 中创建 input_fruit 文件夹并上传 fruit.tsv 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hdfs&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt; -&lt;span class=&quot;hljs-title&quot;&gt;mkdir&lt;/span&gt; /&lt;span class=&quot;hljs-title&quot;&gt;input_fruit&lt;/span&gt;/&lt;/span&gt;&lt;br/&gt;$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hdfs&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt; -&lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt; /&lt;span class=&quot;hljs-title&quot;&gt;opt&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;datas&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;fruit&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;tsv&lt;/span&gt; /&lt;span class=&quot;hljs-title&quot;&gt;input_fruit&lt;/span&gt;/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）执行 MapReduce 到 HBase 的 fruit 表中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; ./&lt;span class=&quot;hljs-title&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hbase&lt;/span&gt;-&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt;-1.3.1.&lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;importtsv&lt;/span&gt; \&lt;/span&gt;&lt;br/&gt;-Dimporttsv.columns=HBASE_ROW_KEY,&lt;span class=&quot;hljs-symbol&quot;&gt;info:&lt;/span&gt;name,&lt;span class=&quot;hljs-symbol&quot;&gt;info:&lt;/span&gt;color fruit \&lt;br/&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;hdfs:&lt;/span&gt;/&lt;span class=&quot;hljs-regexp&quot;&gt;/hadoop102:9000/input&lt;/span&gt;_fruit&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5）使用 scan 命令查看 HBase 导入后的结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;hbase(main):001:0&amp;gt;&lt;/span&gt; scan &lt;span class=&quot;hljs-string&quot;&gt;'fruit'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h632hbasemapreduce1&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.2 自定义 HBase-MapReduce1&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;目标：将 fruit 表中的一部分数据，通过 MR 迁入到 fruit_mr 表中。&lt;br/&gt;即：从 HBase 读数据，通过 MR，最终写入 HBase。&lt;br/&gt;分步实现：&lt;br/&gt;1．构建 ReadFruitFromHBaseMapper 类，用于读取 fruit 表中的数据&lt;/p&gt;
&lt;pre readability=&quot;16.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;27&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr1;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.Cell;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.CellUtil;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Result;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.io.ImmutableBytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.mapreduce.TableMapper;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.util.Bytes;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ReadFruitFromHBaseMapper&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TableMapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ImmutableBytesWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Put&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ImmutableBytesWritable key, Result value, Context context)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Cell[] cells = value.rawCells();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Put put = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Put(key.get());&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Cell cell : cells) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;info&quot;&lt;/span&gt;.equals(Bytes.toString(CellUtil.cloneFamily(cell)))) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;.equals(Bytes.toString(CellUtil.cloneQualifier(cell)))) {&lt;br/&gt;put.add(cell);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;color&quot;&lt;/span&gt;.equals(Bytes.toString(CellUtil.cloneQualifier(cell)))) {&lt;br/&gt;put.add(cell);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;context.write(key, put);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．构建 WriteFruitMRReducer 类，用于将读取到的 fruit 表中的数据写入到 fruit_mr 表中&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr1;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.io.ImmutableBytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.mapreduce.TableReducer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.NullWritable;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;WriteFruitMRReducer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TableReducer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ImmutableBytesWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Put&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;NullWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ImmutableBytesWritable key, Iterable&amp;lt;Put&amp;gt; values, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Put value : values) {&lt;br/&gt;context.write(NullWritable.get(), value);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．构建 Fruit2FruitMRRunner extends Configuration implements Tool 用于组装运行 Job 任务&lt;/p&gt;
&lt;pre readability=&quot;25.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;45&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr1;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.HBaseConfiguration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Scan;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.io.ImmutableBytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.util.Tool;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.util.ToolRunner;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Fruit2FruitMRRunner&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configuration&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Tool&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Configuration conf = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Configuration &lt;span class=&quot;hljs-title&quot;&gt;getConf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.conf;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setConf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Configuration conf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.conf = conf;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Job job = Job.getInstance(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.getConf());&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(Fruit2FruitMRRunner.class);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Scan scan = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Scan();&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;TableMapReduceUtil.initTableMapperJob(&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;fruit&quot;&lt;/span&gt;,                        &lt;br/&gt;scan ,                          &lt;br/&gt;ReadFruitMapper.class,          &lt;br/&gt;ImmutableBytesWritable.class,   &lt;br/&gt;Put.class,                      &lt;br/&gt;job                             &lt;br/&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;TableMapReduceUtil.initTableReducerJob(&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;fruit_mr&quot;&lt;/span&gt;, &lt;br/&gt;WriteFruitMRReducer.class, &lt;br/&gt;job);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setNumReduceTasks(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isSuccess = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!isSuccess) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Job running with error&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; isSuccess ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;Configuration conf = HBaseConfiguration.create();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; status = ToolRunner.run(conf, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Fruit2FruitMRRunner(), args);&lt;br/&gt;System.exit(status);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：这是针对 HBase 官方建议的组装 Job 任务的方式，为什么官方建议这样做呢？&lt;br/&gt;&lt;strong&gt;　　答&lt;/strong&gt;：是因为我们在运行 MapReduce 任务的时候要添加一些额外的参数，而参数要能被解析，格式就要这么去写。&lt;br/&gt;&lt;code&gt;小结&lt;/code&gt;：以后的 Driver 建议这么去写！！！&lt;/p&gt;
&lt;p&gt;4．主函数中调用运行该 Job 任务&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;p&gt;Configuration conf = HBaseConfiguration.create();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; status = ToolRunner.run(conf, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Fruit2FruitMRRunner(), args);&lt;br/&gt;System.exit(status);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5．打包运行任务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; /&lt;span class=&quot;hljs-title&quot;&gt;opt&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;datas&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;HBase&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;mr1&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Fruit2FruitMRRunner&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;提示&lt;/code&gt;：运行任务前，如果待导入的数据的表不存在，则需要提前创建。所以我们先在 HBase 上创建 fruit_mr 表。&lt;br/&gt;&lt;code&gt;提示&lt;/code&gt;：maven 打包命令：-P local clean package 或 -P dev clean package install（将第三方jar包一同打包，需要插件：maven-shade-plugin）&lt;/p&gt;
&lt;h4 id=&quot;h633hbasemapreduce2&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.3 自定义 HBase-MapReduce2&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;目标：实现将 HDFS 中的数据写入到 HBase 表中。&lt;br/&gt;分步实现：&lt;br/&gt;1．构建 ReadFruitFromHDFSMapper 于读取 HDFS 中的文件数据&lt;/p&gt;
&lt;pre readability=&quot;19.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;33&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr2;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.util.Bytes;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.LongWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.NullWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.Text;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Mapper;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ReadFruitFromHDFSMapper&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mapper&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;LongWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Text&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;NullWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Put&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(LongWritable key, Text value, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;String line = value.toString();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;String[] fields = line.split(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;String rowKey = fields[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];&lt;br/&gt;String name = fields[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;String color = fields[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Put put = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Put(Bytes.toBytes(rowKey));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;put.addColumn(Bytes.toBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;info&quot;&lt;/span&gt;), Bytes.toBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;),  Bytes.toBytes(name)); &lt;br/&gt;put.addColumn(Bytes.toBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;info&quot;&lt;/span&gt;), Bytes.toBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;color&quot;&lt;/span&gt;),  Bytes.toBytes(color)); &lt;/p&gt;&lt;p&gt;&lt;br/&gt;context.write(NullWritable.get(), put);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．构建 WriteFruitMRFromTxtReducer 类&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;18&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr2;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.io.ImmutableBytesWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.mapreduce.TableReducer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.NullWritable;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;WriteFruitMRFromTxtReducer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TableReducer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ImmutableBytesWritable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Put&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;NullWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ImmutableBytesWritable key, Iterable&amp;lt;Put&amp;gt; values, Context context)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Put value : values) {&lt;br/&gt;context.write(NullWritable.get(), value);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．创建 Txt2FruitRunner 组装 Job&lt;/p&gt;
&lt;pre readability=&quot;24&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;42&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.mr2;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.conf.Configuration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.fs.Path;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.HBaseConfiguration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.client.Put;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.io.NullWritable;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.Job;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.util.Tool;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.apache.hadoop.util.ToolRunner;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Txt2FruitRunner&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configuration&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Tool&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Configuration conf = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Configuration &lt;span class=&quot;hljs-title&quot;&gt;getConf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.conf;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setConf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Configuration conf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.conf = conf;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Job job = Job.getInstance(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.getConf());&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setJarByClass(Txt2FruitRunner.class);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setMapperClass(ReadFruitFromHDFSMapper.class);&lt;br/&gt;job.setMapOutputKeyClass(NullWritable.class);&lt;br/&gt;job.setMapOutputValueClass(Put.class);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;TableMapReduceUtil.initTableReducerJob(&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;fruit_hdfs&quot;&lt;/span&gt;, &lt;br/&gt;WriteFruitMRFromTxtReducer.class, &lt;br/&gt;job);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;job.setNumReduceTasks(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Path inPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Path(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hdfs://hadoop102:9000/input_fruit/fruit.tsv&quot;&lt;/span&gt;);&lt;br/&gt;FileInputFormat.addInputPath(job, inPath);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isSuccess = job.waitForCompletion(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!isSuccess) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Job running with error&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; isSuccess ? &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;Configuration conf = HBaseConfiguration.create();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; status = ToolRunner.run(conf, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Txt2FruitRunner(), args);&lt;br/&gt;System.exit(status);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4．调用执行 Job&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;Configuration conf = HBaseConfiguration.create();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; status = ToolRunner.run(conf, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Txt2FruitRunner(), args);&lt;br/&gt;System.exit(status);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5．打包运行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;$ /opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hadoop&lt;/span&gt;-2.7.2/&lt;span class=&quot;hljs-title&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;yarn&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HBase2&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;jar&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;mr2&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Txt2FruitRunner&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;提示&lt;/code&gt;：运行任务前，如果待数据导入的表不存在，则需要提前创建之。所以我们先在 HBase 上创建 fruit_hdfs 表。&lt;br/&gt;&lt;code&gt;提示&lt;/code&gt;：maven打包命令：-P local clean package 或 -P dev clean package install（将第三方jar包一同打包，需要插件：maven-shade-plugin）&lt;/p&gt;
&lt;h3 id=&quot;h64hive&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4 与 Hive 的集成&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h641hbasehive&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.1 HBase 与 Hive 的对比&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1．Hive&lt;/strong&gt;&lt;br/&gt;(1) 数据仓库&lt;br/&gt;  Hive 的本质其实就相当于将 HDFS 中已经存储的文件在 Mysql 中做了一个双射关系，以方便使用 HQL 去管理查询。&lt;br/&gt;(2) 用于数据分析、清洗（ETL工程师：把业务数据准备好）&lt;br/&gt;  Hive 适用于离线的数据分析和清洗，延迟较高。&lt;br/&gt;(3) 基于 HDFS、MapReduce&lt;br/&gt;  Hive 存储的数据依旧在 DataNode 上，编写的 HQL 语句终将是转换为 MapReduce 代码执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2．HBase&lt;/strong&gt;&lt;br/&gt;(1) 数据库&lt;br/&gt;  是一种面向列存储的非关系型数据库。&lt;br/&gt;(2) 用于存储结构化和非结构化的数据&lt;br/&gt;  适用于单表非关系型数据的存储，不适合做关联查询，类似 JOIN 等操作。&lt;br/&gt;(3) 基于 HDFS&lt;br/&gt;  数据持久化存储的体现形式是 Hfile，存放于 DataNode 中，被 ResionServer 以 Region 的形式进行管理。&lt;br/&gt;(4) 延迟较低，接入在线业务使用&lt;br/&gt;  面对大量的企业数据，HBase 可以实现单表大量数据的存储，同时提供了高效的数据访问速度。&lt;/p&gt;
&lt;h4 id=&quot;h642hbasehive&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.2 HBase 与 Hive 集成使用&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;尖叫提示&lt;/code&gt;：HBase 与 Hive 的集成在最新的两个原生版本中无法兼容。错误截图如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0tsA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们只能对 hive-hbase-handler-1.2.1.jar 做适配。&lt;br/&gt;所以，我们只能含着泪勇敢的重新编译：hive-hbase-handler-1.2.1.jar 好气啊！！！&lt;br/&gt;&lt;strong&gt;编译步骤如下：&lt;/strong&gt;&lt;br/&gt;(1) 准备好 hive 的源码&lt;br/&gt;(2) 将 /opt/module/hive/lib目录下 和 /opt/module/hbase/lib目录下 的jar包合并在一起，删除掉里面的pom文件和文件夹(ruby、PHP、python)&lt;br/&gt;(3) 建议使用 eclipse 编译jar包&lt;br/&gt;(4) 新建一个普通的 java 工程&lt;br/&gt;(5) 导入 hive 的源码&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0YMd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择【File System】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz01PO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择要编译的jar包，没有必要选择要编译的全部jar包&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz03GD.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;手动导入依赖，先新建一个lib文件夹&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz08Re.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;复制粘贴准备好的jar包，放在lib文件夹下，然后添加至构建路径，之后删除掉低相同的版本的依赖&lt;br/&gt;然后进行导出操作&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0NqI.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择 JAR file&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0ddP.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;去掉勾选lib，选择文件路径，点击完成即可&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0aZt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;将新编译的 hive-hbase-handler-1.2.1.jar 拷贝至 /opt/module/hive/lib 目录下，覆盖掉以前的jar。
&lt;p&gt;&lt;strong&gt;环境准备&lt;/strong&gt;&lt;br/&gt;因为我们后续可能会在操作 Hive 的同时对 HBase 也会产生影响，所以 Hive 需要持有操作 HBase 的 Jar，那么接下来拷贝 Hive 所依赖的 Jar包（或者使用软连接的形式）。&lt;br/&gt;即：Hive 如何能获取到 HBase 中的数据。&lt;br/&gt;修改/etc/profile文件，增加以下内容：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs coffeescript&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HBASE_HOME=/opt/&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;/hbase&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HIVE_HOME=/opt/&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;/hive&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使/etc/profile文件生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs shell&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; /etc/profile&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用软连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;ln&lt;/span&gt; -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-common-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-common-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-server-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-server-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-client-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-client-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-protocol-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-protocol-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-it-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-it-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/htrace-core-&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;-incubating.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/htrace-core-&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;-incubating.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-hadoop2-compat-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-hadoop2-compat-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;ln -s &lt;span class=&quot;hljs-variable&quot;&gt;$HBASE_HOME&lt;/span&gt;/lib/hbase-hadoop-compat-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar &lt;span class=&quot;hljs-variable&quot;&gt;$HIVE_HOME&lt;/span&gt;/lib/hbase-hadoop-compat-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.jar&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时在 hive-site.xml 中修改 zookeeper 的属性，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 conf]$ pwd&lt;br/&gt;/opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hive&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;conf&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;[atguigu@hadoop102 conf]$ vim hive-site.xml &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hive.zookeeper.quorum&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;hadoop102,hadoop103,hadoop104&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;The list of ZooKeeper servers to talk to. This is only needed for read/write locks.&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hive.zookeeper.client.port&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;2181&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;The port of ZooKeeper servers to talk to. This is only needed for read/write locks.&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1．案例一&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;目标&lt;/strong&gt;：建立 Hive 表，关联 HBase 表，插入数据到 Hive 表的同时能够影响 HBase 表。&lt;br/&gt;分步实现：&lt;br/&gt;(1) 在 Hive 中创建表同时关联 HBase&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; hive_hbase_emp_table(&lt;br/&gt;empno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;ename &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;job &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;mgr &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;hiredate &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;sal &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;comm &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;deptno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;STORED&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'org.apache.hadoop.hive.hbase.HBaseStorageHandler'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;WITH&lt;/span&gt; SERDEPROPERTIES (&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.columns.mapping&quot;&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;:key,info:ename,info:job,info:mgr,info:hiredate,info:sal,info:comm,info:deptno&quot;&lt;/span&gt;)&lt;br/&gt;TBLPROPERTIES (&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.table.name&quot;&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase_emp_table&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;提示&lt;/code&gt;：完成之后，可以分别进入 Hive 和 HBase 查看，都生成了对应的表。&lt;/p&gt;
&lt;p&gt;(2) 在 Hive 中创建临时中间表，用于 load 文件中的数据&lt;br/&gt;&lt;code&gt;提示&lt;/code&gt;：不能将数据直接 load 进 Hive 所关联 HBase 的那张表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; emp(&lt;br/&gt;empno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;ename &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;job &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;mgr &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;hiredate &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;sal &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;comm &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;deptno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'\t'&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 向 Hive 中间表中 load 数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;hive&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;load&lt;/span&gt; data &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; inpath &lt;span class=&quot;hljs-string&quot;&gt;'/opt/module/datas/emp.txt'&lt;/span&gt; into &lt;span class=&quot;hljs-built_in&quot;&gt;table&lt;/span&gt; emp;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) 通过 insert 命令将中间表中的数据导入到 Hive 关联 HBase 的那张表中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;hive&amp;gt; insert &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; table hive_hbase_emp_table &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; emp;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) 查看 Hive 以及关联的 HBase 表中是否已经成功的同步插入了数据&lt;br/&gt;Hive：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;hive&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; hive_hbase_emp_table;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HBase：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs shell&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;hbase&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; scan ‘hbase_emp_table’&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2．案例二&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;目标&lt;/strong&gt;：在 HBase 中已经存储了某一张表 hbase_emp_table，然后在 Hive 中创建一个外部表来关联 HBase 中的 hbase_emp_table 这张表，使之可以借助 Hive 来分析 HBase 这张表中的数据。&lt;br/&gt;&lt;code&gt;注&lt;/code&gt;：该案例2紧跟案例1的脚步，所以完成此案例前，请先完成案例1。&lt;br/&gt;分步实现：&lt;br/&gt;(1) 在Hive中创建外部表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXTERNAL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; relevance_hbase_emp(&lt;br/&gt;empno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;ename &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;job &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;mgr &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;hiredate &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;sal &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;comm &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;deptno &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;STORED&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'org.apache.hadoop.hive.hbase.HBaseStorageHandler'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;WITH&lt;/span&gt; SERDEPROPERTIES (&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.columns.mapping&quot;&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;:key,info:ename,info:job,info:mgr,info:hiredate,info:sal,info:comm,info:deptno&quot;&lt;/span&gt;) &lt;br/&gt;TBLPROPERTIES (&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase.table.name&quot;&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hbase_emp_table&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 关联后就可以使用 Hive 函数进行一些分析操作了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;hive (&lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; relevance_hbase_emp;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h7hbase&quot;&gt;&lt;span&gt;&lt;strong&gt;第7章 HBase 优化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h71&quot;&gt;&lt;span&gt;&lt;strong&gt;7.1 高可用&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  在 HBase 中 Hmaster 负责监控 RegionServer 的生命周期，均衡 RegionServer 的负载，如果 Hmaster 挂掉了，那么整个 HBase 集群将陷入不健康的状态，并且此时的工作状态并不会维持太久。所以 HBase 支持对 Hmaster 的高可用配置。&lt;br/&gt;1．关闭 HBase 集群（如果没有开启则跳过此步）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ bin/stop-hbase.sh\&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．在 conf 目录下创建 backup-masters 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ touch conf/backup-masters&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．在 backup-masters 文件中配置高可用 HMaster 节点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ echo hadoop103 &amp;gt; conf/backup-masters&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4．将整个 conf 目录 scp 到其他节点 或者 配置分发&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs ruby&quot; readability=&quot;2&quot;&gt;[atguigu@hadoop102 hbase]$ scp -r conf/ &lt;span class=&quot;hljs-symbol&quot;&gt;hadoop103:&lt;/span&gt;/opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hbase&lt;/span&gt;/&lt;/span&gt;&lt;br/&gt;[atguigu@hadoop102 hbase]$ scp -r conf/ &lt;span class=&quot;hljs-symbol&quot;&gt;hadoop104:&lt;/span&gt;/opt/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;hbase&lt;/span&gt;/&lt;/span&gt;&lt;p&gt;或者&lt;/p&gt;&lt;p&gt;[atguigu@hadoop102 hbase]$ xsync conf/backup-masters&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5．启动 Hbase&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ bin/start-hbase.sh\&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6．打开页面测试查看&lt;br/&gt;  http://hadooo102:16010&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0szQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  http://hadoop103:16010/master-status&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0Bi8.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;7．我们杀死主节点 hadoop102
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[atguigu@hadoop102 hbase]$ &lt;span class=&quot;hljs-keyword&quot;&gt;kill&lt;/span&gt; -&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7886&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8．再次打开页面测试查看&lt;br/&gt;  http://hadoop103:16010/master-status&lt;br/&gt;hadoop103 节点变为主节点了&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0wIf.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;9．我们再单次启动 hadoop102 作为主节点
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 hbase]$ bin/hbase-daemon.sh start master&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开页面测试查看&lt;br/&gt;  http://hadoop103:16010/master-status&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0DJS.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h72&quot;&gt;&lt;span&gt;&lt;strong&gt;7.2 预分区&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自动分区&lt;/strong&gt;&lt;br/&gt;自动分区会导致数据倾斜。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/08/kz0rRg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  每一个 region 维护着 startRow 与 endRowKey，如果加入的数据符合某个 region 维护的 rowKey 范围，则该数据交给这个 region 维护。那么依照这个原则（&lt;code&gt;即预估数据量&lt;/code&gt;），我们可以&lt;code&gt;将数据所要投放的分区提前大致的规划好，以提高 HBase 性能&lt;/code&gt;。&lt;br/&gt;1．手动设定预分区
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;hbase&amp;gt; create &lt;span class=&quot;hljs-string&quot;&gt;'staff1'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'info'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'partition1'&lt;/span&gt;,SPLITS =&amp;gt; [&lt;span class=&quot;hljs-string&quot;&gt;'1000'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'2000'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'3000'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'4000'&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．生成16进制序列预分区&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;hbase&amp;gt; create &lt;span class=&quot;hljs-string&quot;&gt;'staff2'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'info'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'partition2'&lt;/span&gt;,{NUMREGIONS =&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;, SPLITALGO =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;'HexStringSplit'&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．按照文件中设置的规则预分区（HBase底层会自动排序）&lt;br/&gt;创建splits.txt文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;aaaa&lt;/span&gt;&lt;br/&gt;bbbb&lt;br/&gt;cccc&lt;br/&gt;dddd&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;hbase&amp;gt; create &lt;span class=&quot;hljs-string&quot;&gt;'staff3'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'partition3'&lt;/span&gt;,SPLITS_FILE =&amp;gt; &lt;span class=&quot;hljs-string&quot;&gt;'/opt/module/datas/splits.txt'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4．使用 JavaAPI 创建预分区(旧API)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;[][] splitKeys = 某个散列值函数;&lt;br/&gt;HBaseAdmin hAdmin = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HBaseAdmin(HBaseConfiguration.create());&lt;br/&gt;HTableDescriptor tableDesc = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HTableDescriptor(tableName);&lt;br/&gt;hAdmin.createTable(tableDesc, splitKeys);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;工作经验小结&lt;/strong&gt;：针对于一张表，一台服务器有2到3个Region。&lt;/p&gt;
&lt;h3 id=&quot;h73rowkey&quot;&gt;&lt;span&gt;&lt;strong&gt;7.3 RowKey 设计&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  一条数据的唯一标识就是 rowkey，那么这条数据存储于哪个分区，取决于 rowkey 处于哪个一个预分区的区间内，设计 rowkey 的主要目的 ，就是&lt;code&gt;让数据均匀的分布于所有的 region 中&lt;/code&gt;，在一定程度上&lt;code&gt;防止数据倾斜&lt;/code&gt;。接下来我们就谈一谈 rowkey 常用的设计方案。&lt;br/&gt;  &lt;strong&gt;原则&lt;/strong&gt;：唯一性、长度、散列。&lt;br/&gt;  &lt;strong&gt;心法&lt;/strong&gt;：数据散列不能太散列，数据集中不能太集中。结合业务（站在什么角度），进行取舍。&lt;br/&gt;  &lt;strong&gt;常用预分区键(拦截数据)&lt;/strong&gt;：00_|xxxx_xxxx_xxxx、01_|xxxx_xxxx_xxxx、02_|xxxx_xxxx_xxxx&lt;br/&gt;  计算 RowKey 是跟 RowKey 对应的数据相关的，对应的数据中我们抽取时间戳、最常用的列、最特殊的列等等拿出来进行hash或者MD5，然后与预分区数进行取模，即散列。&lt;/p&gt;
&lt;p&gt;1．生成随机数、hash、散列值&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;比如：&lt;br/&gt;原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7&lt;br/&gt;原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd&lt;br/&gt;原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913&lt;p&gt;在做此操作之前，一般我们会选择从数据集中抽取样本，来决定什么样的 rowKey 来 Hash 后作为每个分区的临界值。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．字符串反转&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;20170524000001转成10000042507102&lt;br/&gt;20170524000002转成20000042507102&lt;p&gt;这样也可以在一定程度上散列逐步put进来的数据。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．字符串拼接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;20170524000001_a12e&lt;br/&gt;20170524000001_93i7&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h74&quot;&gt;&lt;span&gt;&lt;strong&gt;7.4 内存优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  HBase 操作过程中需要大量的内存开销，毕竟 Table 是可以缓存在内存中的，一般会分配整个可用内存的 70% 给 HBase 的 Java 堆。但是不建议分配非常大的堆内存，因为GC过程持续太久会导致 RegionServer 处于长期不可用状态，&lt;code&gt;一般16~48G内存&lt;/code&gt;就可以了，如果因为框架占用内存过高导致系统内存不足，框架一样会被系统服务拖死。&lt;/p&gt;
&lt;h3 id=&quot;h75&quot;&gt;&lt;span&gt;&lt;strong&gt;7.5 基础优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1．允许在 HDFS 的文件中追加内容&lt;br/&gt;hdfs-site.xml、hbase-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.support&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.append&lt;/span&gt;&lt;br/&gt;解释：开启 &lt;span class=&quot;hljs-selector-tag&quot;&gt;HDFS&lt;/span&gt; 追加同步，可以优秀的配合 &lt;span class=&quot;hljs-selector-tag&quot;&gt;HBase&lt;/span&gt; 的数据同步和持久化。默认值为&lt;span class=&quot;hljs-selector-tag&quot;&gt;true&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2．优化 DataNode 允许的最大文件打开数&lt;br/&gt;hdfs-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.datanode&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.max&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.transfer&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.threads&lt;/span&gt;&lt;br/&gt;解释：&lt;span class=&quot;hljs-selector-tag&quot;&gt;HBase&lt;/span&gt; 一般都会同一时间操作大量的文件（刷写、合并），根据集群的数量和规模以及数据动作，设置为4096或者更高。默认值：4096。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3．优化延迟高的数据操作的等待时间&lt;br/&gt;hdfs-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.image&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.transfer&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.timeout&lt;/span&gt;&lt;br/&gt;解释：如果对于某一次数据操作来讲，延迟非常高，&lt;span class=&quot;hljs-selector-tag&quot;&gt;socket&lt;/span&gt; 需要等待更长的时间，建议把该值设置为更大的值（默认60000毫秒），以确保 &lt;span class=&quot;hljs-selector-tag&quot;&gt;socket&lt;/span&gt; 不会被 &lt;span class=&quot;hljs-selector-tag&quot;&gt;timeout&lt;/span&gt; 掉。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4．优化数据的写入效率&lt;br/&gt;mapred-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mapreduce&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.output&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.compress&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;mapreduce&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.map&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.output&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.compress&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.codec&lt;/span&gt;&lt;br/&gt;解释：开启这两个数据可以大大提高文件的写入效率，减少写入时间。第一个属性值修改为&lt;span class=&quot;hljs-selector-tag&quot;&gt;true&lt;/span&gt;，第二个属性值修改为：&lt;span class=&quot;hljs-selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.apache&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.hadoop&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.io&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.compress&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.GzipCodec&lt;/span&gt;或者其他压缩方式。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5．设置 RPC 监听数量&lt;br/&gt;hbase-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.regionserver&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.handler&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.count&lt;/span&gt;&lt;br/&gt;解释：默认值为30，用于指定&lt;span class=&quot;hljs-selector-tag&quot;&gt;RPC&lt;/span&gt;监听的数量，可以根据客户端的请求数进行调整，读写请求较多时，增加此值。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6．优化 HStore 文件大小&lt;br/&gt;hbase-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.hregion&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.max&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.filesize&lt;/span&gt;&lt;br/&gt;解释：默认值10737418240（10&lt;span class=&quot;hljs-selector-tag&quot;&gt;GB&lt;/span&gt;），如果需要运行 &lt;span class=&quot;hljs-selector-tag&quot;&gt;HBase&lt;/span&gt; 的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;MR&lt;/span&gt; 任务，可以减小此值，因为一个 &lt;span class=&quot;hljs-selector-tag&quot;&gt;region&lt;/span&gt; 对应一个 &lt;span class=&quot;hljs-selector-tag&quot;&gt;map&lt;/span&gt; 任务，如果单个 &lt;span class=&quot;hljs-selector-tag&quot;&gt;region&lt;/span&gt; 过大，会导致 &lt;span class=&quot;hljs-selector-tag&quot;&gt;map&lt;/span&gt; 任务执行时间过长。&lt;br/&gt;该值的意思就是，如果 &lt;span class=&quot;hljs-selector-tag&quot;&gt;HFile&lt;/span&gt; 的大小达到这个数值，则这个 &lt;span class=&quot;hljs-selector-tag&quot;&gt;region&lt;/span&gt; 会被切分为两个 &lt;span class=&quot;hljs-selector-tag&quot;&gt;Hfile&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7．优化 hbase 客户端缓存&lt;br/&gt;hbase-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.client&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.write&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.buffer&lt;/span&gt;&lt;br/&gt;解释：用于指定 &lt;span class=&quot;hljs-selector-tag&quot;&gt;HBase&lt;/span&gt; 客户端缓存（即 &lt;span class=&quot;hljs-selector-tag&quot;&gt;BlockCache&lt;/span&gt; 大小），增大该值可以减少 &lt;span class=&quot;hljs-selector-tag&quot;&gt;RPC&lt;/span&gt; 调用次数，但是会消耗更多内存，反之则反之。一般我们需要设定一定的缓存大小，以达到减少 &lt;span class=&quot;hljs-selector-tag&quot;&gt;RPC&lt;/span&gt; 次数的目的。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8．指定 scan.next 扫描 HBase 所获取的行数&lt;br/&gt;hbase-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;属性：&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.client&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.scanner&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.caching&lt;/span&gt;&lt;br/&gt;解释：用于指定 &lt;span class=&quot;hljs-selector-tag&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.next&lt;/span&gt; 方法获取的默认行数，值越大，消耗内存越大。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9．flush、compact、split机制&lt;/p&gt;
&lt;p&gt;  当 MemStore 达到阈值，将 Memstore 中的数据 Flush 进 Storefile；&lt;br/&gt;  compact 机制则是把 flush 出来的小文件合并成大的 Storefile 文件；&lt;br/&gt;  split 则是当 Region 达到阈值，会把过大的 Region 一分为二。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及属性：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.hregion&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.memstore&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flush&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.size&lt;/span&gt;：134217728&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即：128M就是 Memstore 的默认阈值，这个参数的作用是当单个 HRegion 内所有的 Memstore 大小总和超过指定值时，flush 该 HRegion 的所有 memstore。RegionServer 的 flush 是通过将请求添加一个队列，模拟生产消费模型来异步处理的。那这里就有一个问题，当队列来不及消费，产生大量积压请求时，可能会导致内存陡增，最坏的情况是触发OOM。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.regionserver&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.global&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.memstore&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.upperLimit&lt;/span&gt;：0&lt;span class=&quot;hljs-selector-class&quot;&gt;.4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;hbase&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.regionserver&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.global&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.memstore&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.lowerLimit&lt;/span&gt;：0&lt;span class=&quot;hljs-selector-class&quot;&gt;.38&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即：当 MemStore 使用内存总量达到 hbase.regionserver.global.memstore.upperLimit指定值时，将会有多个 MemStores flush 到文件中，MemStore flush 顺序是按照大小降序执行的，直到刷新到 MemStore 使用内存略小于 lowerLimit。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 07:06:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第6章 HBase API 操作6.1 环境准备6.2 HBase API6.2.1 判断表是否存在6.2.2 抽取获取 Configuration、Connection、Admin 对象的方法以及关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10495955.html</dc:identifier>
</item>
<item>
<title>安卓权限申请处理框架Android-UsesPermission - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/10495580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/10495580.html</guid>
<description>&lt;blockquote readability=&quot;10.750436300175&quot;&gt;
&lt;p&gt;安卓权限申请封装处理框架。测试支持4.0+。项目源于正式处理Android权限问题时，没找到简单、能满足被拒绝权限自动会到系统设置处理的框架，按自己的编程习惯造一个熟悉的轮子还是蛮好的。第一次使用Android Studio，还是Eclipse敲代码爽。来自一个（独爱HTML+CSS来构建用户界面的）Android很早入门的新手。&lt;/p&gt;
&lt;p&gt;项目用到了&lt;a href=&quot;https://github.com/getActivity/XXPermissions&quot;&gt;&lt;code&gt;XXPermissions&lt;/code&gt;&lt;/a&gt;中的权限列表、国产手机权限设置页面跳转列表，借鉴了其中的权限结果&lt;code&gt;onRequestPermissionsResult&lt;/code&gt;的接收方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/xiangyuecn/Android-UsesPermission&quot; class=&quot;uri&quot;&gt;https://github.com/xiangyuecn/Android-UsesPermission&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;一个函数调用处理权限申请的所有问题，被拒绝的权限重复询问，被永久拒绝的权限（记住选择、不再询问）打开App授权系统设置。&lt;/li&gt;
&lt;li&gt;函数式调用，代码简洁明晰，阅读源码不用跳来跳去。&lt;/li&gt;
&lt;li&gt;明确的授权结果回调，要么有(True)，要么没有(False)。&lt;/li&gt;
&lt;li&gt;默认0界面，调用者无需知道、提供、导入任何界面包括文件，但可深度定制。&lt;/li&gt;
&lt;li&gt;中性，默认非弓虽J式、有回旋余地的对待拒绝权限的场景。&lt;/li&gt;
&lt;li&gt;理论上支持任何Android版本（但仅在 4.0 - 9.0 模拟器上进行了测试）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;演示&quot;&gt;演示&lt;/h2&gt;
&lt;p&gt;可直接编译&lt;code&gt;test_app&lt;/code&gt;项目进行测试，或者下载&lt;code&gt;.assets/test_app-debug-xxx.apk&lt;/code&gt;测试安装包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-69b8d67bb5ac6886.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速使用&quot;&gt;快速使用&lt;/h2&gt;
&lt;p&gt;直接复制&lt;code&gt;lib_comm/src/main/java/ecomm/lib_comm/permission&lt;/code&gt;里面的文件到你的程序里面即可使用。&lt;/p&gt;
&lt;h3 id=&quot;示例代码&quot;&gt;示例代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//假设需要获取摄像头、录音权限，直接在调用的地方实现抽象类，调用逻辑能简单直观不少

new UsesPermission(MainActivity.this, Permission.CAMERA, Permission.RECORD_AUDIO){
    @Override
    protected void onTrue(@NonNull ArrayList&amp;lt;String&amp;gt; lowerPermissions) {
        //获取了全部权限执后行此函数，
    }

    @Override
    protected void onFalse(@NonNull ArrayList&amp;lt;String&amp;gt; rejectFinalPermissions, @NonNull ArrayList&amp;lt;String&amp;gt; rejectPermissions, @NonNull ArrayList&amp;lt;String&amp;gt; invalidPermissions) {
        //未全部授权时执行此函数
    }

    //要么实现上面两个方法即可，onTrue或onFalse只会有一个会被调用一次
    //要么仅仅实现下面这个方法，不管授权了几个权限都会调用一次

    @Override
    protected void onComplete(@NonNull ArrayList&amp;lt;String&amp;gt; resolvePermissions, @NonNull ArrayList&amp;lt;String&amp;gt; lowerPermissions, @NonNull ArrayList&amp;lt;String&amp;gt; rejectFinalPermissions, @NonNull ArrayList&amp;lt;String&amp;gt; rejectPermissions, @NonNull ArrayList&amp;lt;String&amp;gt; invalidPermissions) {
        //完成回调，可能全部已授权、全部未授权、或者部分已授权
        //通过resolvePermissions.contains(Permission.XXX)来判断权限是否已授权
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;默认行为逻辑&quot;&gt;默认行为逻辑&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先直接发起权限申请
&lt;ul&gt;&lt;li&gt;普通权限（没永久拒绝的权限）如果被拒绝（非永久拒绝），后续会安排再弹框申请一次(防用户误选)。&lt;/li&gt;
&lt;li&gt;如果授权结果有被永久拒绝的，这部分权限会和第二步权限申请一起弹框跳转到App授权系统设置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;弹一次框处理被永久拒绝的权限(弹一次够了)，跳转到App授权系统设置界面。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可参考重写&lt;code&gt;onTips&lt;/code&gt;方法修改此行为，做到不弹提示或者多次弹提示授权。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import ecomm.lib_comm.permission.Permission;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个类对外只有一个构造函数，直接&lt;code&gt;new&lt;/code&gt;直接调起授权请求。使用过程中只需重写这个类的相应函数来控制授权请求行为。无多余、也不提供对外控制的方法。&lt;/p&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;h3 id=&quot;usespermissionactivitypermissionsdefaulttips&quot;&gt;UsesPermission(activity,permissions,defaultTips=&quot;&quot;)&lt;/h3&gt;
&lt;p&gt;调用构造函数立即会调起授权请求，对&lt;code&gt;permissions&lt;/code&gt;列表中的权限进行申请。&lt;/p&gt;
&lt;p&gt;请求过程中会根据&lt;code&gt;onTips&lt;/code&gt;返回的结果来控制提示信息、和授权请求流程，&lt;code&gt;defaultTips&lt;/code&gt;是&lt;code&gt;onTips&lt;/code&gt;默认实现使用到的提示信息默认值，默认为&quot;&quot;字符串；具体逻辑参考&lt;code&gt;onTips&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;回调类可重写函数&quot;&gt;回调类可重写函数&lt;/h2&gt;
&lt;p&gt;这些函数都是可以选择重写，默认提供了空实现，不实现也没关系。&lt;/p&gt;
&lt;h3 id=&quot;void-ontruelowerpermissions&quot;&gt;void onTrue(lowerPermissions)&lt;/h3&gt;
&lt;p&gt;权限已全部授权时的回调，不管什么情况，&lt;code&gt;onTrue&lt;/code&gt;和&lt;code&gt;onFalse&lt;/code&gt;肯定有一个会回调。注意：方法内跟API版本有关的方法调用，应自行判断API版本，因为低版本API中高版本权限请求全部会放行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lowerPermissions&lt;/code&gt;：如果是在低版本API上处理不支持的高版本新权限时，会忽略此项权限的检测的检测，默许放行，此时本参数将带上此权限。&lt;/p&gt;
&lt;h3 id=&quot;void-onfalserejectfinalpermissionsrejectpermissionsinvalidpermissions&quot;&gt;void onFalse(rejectFinalPermissions,rejectPermissions,invalidPermissions)&lt;/h3&gt;
&lt;p&gt;未授权时回调，不管什么情况，True和False肯定有一个会回调&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rejectFinalPermissions&lt;/code&gt;：被永久拒绝的权限列表，为&lt;code&gt;rejectPermissions&lt;/code&gt;的子集，空数组代表没有此项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rejectPermissions&lt;/code&gt;：被拒绝的权限列表，空数组代表没有此项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;invalidPermissions&lt;/code&gt;：未在&lt;code&gt;manifest&lt;/code&gt;里声明的权限列表，不会出现在&lt;code&gt;rejectFinalPermissions&lt;/code&gt;中，空数组代表没有此项。&lt;/p&gt;
&lt;h3 id=&quot;void-oncompleteresolvepermissionslowerpermissionsrejectfinalpermissionsrejectpermissionsinvalidpermissions&quot;&gt;void onComplete(resolvePermissions,lowerPermissions,rejectFinalPermissions,rejectPermissions,invalidPermissions)&lt;/h3&gt;
&lt;p&gt;授权完成时回调，会在&lt;code&gt;onTrue&lt;/code&gt;和&lt;code&gt;onFalse&lt;/code&gt;之一回调后调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolvePermissions&lt;/code&gt;：已授权的权限列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lowerPermissions&lt;/code&gt;：参考&lt;code&gt;onTrue&lt;/code&gt;，为&lt;code&gt;resolvePermissions&lt;/code&gt;的子集。&lt;/p&gt;
&lt;p&gt;剩余参数参考&lt;code&gt;onFalse&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;控制类可重写函数&quot;&gt;控制类可重写函数&lt;/h2&gt;
&lt;p&gt;这些函数都是用来控制授权行为，都提供了默认实现。&lt;/p&gt;
&lt;h3 id=&quot;string-ontipsviewtipscountpermissionsisfinal&quot;&gt;String onTips(viewTipsCount,permissions,isFinal)&lt;/h3&gt;
&lt;p&gt;整个类里面最核心，逻辑最复杂的一个方法（虽然默认实现只有3行代码）。此方法控制着整个权限请求的流程，弹不弹提示，尝不尝试重新申请，都是它说了算。&lt;/p&gt;
&lt;p&gt;授权请求发起前会回调此方法，用来生成设置提示信息，也是来决定是否提示和进行授权。如果返回null，代表不进行下下一步操作；返回字符串会进行提示然后进行请求授权。注意：这个方法，会有不同权限进行多次调用；如果用户选点击了取消默认这些权限不会再调起请求（可重写&lt;code&gt;onCancelTips&lt;/code&gt;修改此行为）。&lt;/p&gt;
&lt;p&gt;默认行为为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先直接发起权限申请 &lt;code&gt;viewTipsCount=0&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;普通权限（非永久拒绝）如果被拒绝（非永久拒绝），后续会安排再弹框申请一次(防误选)。&lt;/li&gt;
&lt;li&gt;如果结果有被永久拒绝，这部分权限会和后面的永久权限申请一起弹框处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;弹一次框处理被永久拒绝的权限(弹一次够了)，跳转到App授权系统设置界面 &lt;code&gt;viewTipsCount=1+&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@param viewTipsCount 0-n 是第几次准备弹提示框。
         0：申请前的引导提示，返回null代表不弹提示，直接调起授权。
             注意：第0次包含所有权限(不含带自定义授权请求的权限)，无法区分是不是永久拒绝的权限。
         1+:被永久拒绝的权限申请，或普通权限上一轮被拒。
             注意：为1的时候，如果权限带自定义的授权请求方式，就算返回了null，也会进行提示并调用授权请求。

@param permissions 被拒绝的权限列表
@param isFinal 这个权限列表是不是永久被拒绝的权限，true是，false为未永久拒绝

@return 返回提示信息；返回值为null不进行申请；为空字符串时自动生成合理的提示。
     字符串内容支持特定占位符：
         {Auto}:用自动生成提示内容替换
         {Names}:自动替换被拒绝的权限名称
                如：'xx&quot;{Names}&quot;xx' =&amp;gt; 'xx&quot;权限名1,权限名2,权限名3&quot;xx'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string-oncanceltipsviewcancelcountpermissionsisfinal&quot;&gt;String onCancelTips(viewCancelCount,permissions,isFinal)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不建议重写，取消了也弹提示真不友好&lt;/strong&gt;，弹出了提示时，用户点击了取消时的额外提示信息。返回null彻底不再调起提示，默认就是返回null。这个回调的用法和&lt;code&gt;onTips&lt;/code&gt;一模一样，只是这个仅仅作用在点击了取消时。注意：重写这个方法应该慎重，最多&lt;code&gt;viewCancelCount&lt;/code&gt;几次后就返回&lt;code&gt;null&lt;/code&gt;，避免出现无法取消永远弹框的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;viewCancelCount&lt;/code&gt; &lt;code&gt;1-n&lt;/code&gt; 当前这次请求是第几次取消。&lt;/p&gt;
&lt;h3 id=&quot;string-ontipsdialogviewtipsiscancelviewtipscountpermissionsisfinalokcallcancelcall&quot;&gt;String onTipsDialogView(tips,isCancel,viewTipsCount,permissions,isFinal,okCall,cancelCall)&lt;/h3&gt;
&lt;p&gt;授权提示弹框，重写此方法自定义弹框行为，默认使用系统&lt;code&gt;AlertDialog&lt;/code&gt;弹框。只要求必须回调&lt;code&gt;okCall&lt;/code&gt;，&lt;code&gt;cancelCall&lt;/code&gt;中的任何一个，怎么显示界面、显示多少个界面 -&amp;gt; 随意。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import ecomm.lib_comm.permission.Permission;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个类封装了8.0版本的危险权限列表，并且提供了对应的权限名称映射。&lt;/p&gt;
&lt;h2 id=&quot;权限列表&quot;&gt;权限列表&lt;/h2&gt;
&lt;p&gt;使用过程中推荐使用这个类里面定义的权限，比如&lt;code&gt;Permission.CAMERA&lt;/code&gt;。如果用&lt;code&gt;Manifest.permission.CAMERA&lt;/code&gt;也可以，他们是等价的。&lt;/p&gt;
&lt;h2 id=&quot;静态方法&quot;&gt;静态方法&lt;/h2&gt;
&lt;h3 id=&quot;string-querynamepermission&quot;&gt;String QueryName(permission)&lt;/h3&gt;
&lt;p&gt;查询权限对应的名称，比如&lt;code&gt;Permission.CAMERA&lt;/code&gt;对应的名称为&lt;code&gt;相机&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;string-querynamespermissions&quot;&gt;String QueryNames(permissions)&lt;/h3&gt;
&lt;p&gt;获取权限名称列表，如&lt;code&gt;权限名1,权限名2,权限名3&lt;/code&gt;，此方法用于方便的生成授权提示信息。&lt;/p&gt;

&lt;h2 id=&quot;使用默认实现&quot;&gt;使用默认实现&lt;/h2&gt;
&lt;p&gt;不重写&lt;code&gt;onTips&lt;/code&gt;即为默认实现。&lt;/p&gt;
&lt;p&gt;请求授权时直接弹出请求，用户如果点了拒绝（非永久），后续还会弹一次提示，防止误点。如果有被永久拒绝的权限，会弹提示，转到系统设置。&lt;/p&gt;
&lt;h2 id=&quot;授权前先提示&quot;&gt;授权前先提示&lt;/h2&gt;
&lt;p&gt;在调起授权前先弹提示，其他行为和默认实现一样。重写&lt;code&gt;onTips&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected String onTips(int viewTipsCount, @NonNull ArrayList&amp;lt;String&amp;gt; permissions, boolean isFinal) {
    if(viewTipsCount&amp;lt;=1) {
        return &quot;&quot;;
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不授权永远弹提示&quot;&gt;不授权永远弹提示&lt;/h2&gt;
&lt;p&gt;如果不授权功能是没法使用的场景，可以一直弹提示，直到用户点击了取消为止（可重写&lt;code&gt;onCancelTips&lt;/code&gt;让无法取消，但不建议）。重写&lt;code&gt;onTips&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected String onTips(int viewTipsCount, @NonNull ArrayList&amp;lt;String&amp;gt; permissions, boolean isFinal) {
    if(viewTipsCount&amp;gt;0) {//如果需要授权调起前先提醒，直接把这个if去掉就行了
        return &quot;&quot;;
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;静默方式授权&quot;&gt;静默方式授权&lt;/h2&gt;
&lt;p&gt;如果权限被拒绝，不弹任何提示，也不跳转权限系统设置界面。仅仅用来调起授权请求。但对于需要引导才能进行权限设置的除外(如安装、悬浮窗权限)。重写&lt;code&gt;onTips&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected String onTips(int viewTipsCount, @NonNull ArrayList&amp;lt;String&amp;gt; permissions, boolean isFinal) {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义提示界面&quot;&gt;自定义提示界面&lt;/h2&gt;
&lt;p&gt;默认实现在弹提示的时候使用的是系统&lt;code&gt;AlertDialog&lt;/code&gt;弹框，可重写&lt;code&gt;onTipsDialogView&lt;/code&gt;方法来使用自己的提示界面。比如&lt;a href=&quot;https://github.com/yewei02538/HiPermission&quot;&gt;&lt;code&gt;HiPermission&lt;/code&gt;&lt;/a&gt;的这种蛮美观友好的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-3ea6ed64129476bb.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个库不提供界面实现，需要自行实现。&lt;/p&gt;
&lt;h2 id=&quot;更多实现&quot;&gt;更多实现&lt;/h2&gt;
&lt;p&gt;参考&lt;code&gt;test_app&lt;/code&gt;目录中的&lt;code&gt;MainActivity&lt;/code&gt;，里面有已实现的代码。&lt;/p&gt;
&lt;p&gt;相关源码请前往&lt;a href=&quot;https://github.com/xiangyuecn/Android-UsesPermission&quot;&gt;Github&lt;/a&gt;查阅，如果这个库有帮助到您，请 Star 一下。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 06:23:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>安卓权限申请封装处理框架。测试支持4.0+。项目源于正式处理Android权限问题时，没找到简单、能满足被拒绝权限自动会到系统设置处理的框架，按自己的编程习惯造一个熟悉的轮子还是蛮好的。第一次使用An</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiangyuecn/p/10495580.html</dc:identifier>
</item>
<item>
<title>《七哥说道》第一章：风雨知秋之进城三人 - jstarseven</title>
<link>http://www.cnblogs.com/jstarseven/p/10495406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jstarseven/p/10495406.html</guid>
<description>&lt;p&gt;&lt;span&gt;&amp;lt;&lt;span&gt; 编码之余，记录一下生活，写成小说分享，哈哈哈&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【 转载请注明】：&lt;/p&gt;
&lt;p&gt;原文出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 《七哥说道》第一章：风雨知秋之进城三人&quot; href=&quot;https://www.cnblogs.com/jstarseven/p/10495406.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jstarseven/p/10495406.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;作者：jstarseven&lt;/p&gt;
&lt;p&gt;码字挺辛苦的.....&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        15年的夏天过去的很快，大三的课程过的更快，即将要面临找工作的七哥，也是颤颤悠悠，恍恍惚惚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIslTYib1rPL9C1r05t57ItKNqO9PqQnAGc04udkicxtV7y2a40uTbJ5uLQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        毕竟三年的大学课程并没有把我打造成编码高手，我还是一个什么都不会的小码仔。不过唯一值得庆幸的是，在我大二下学期的时候，经过我同学（大鲁子：七哥大学四年室友，隔壁床铺，编程高手，喜好玩游戏，二次元，宅男，现任小米公司高级开发工程师）的推荐，我进入了计算机学院开办的数据库开发实验室，学习了将近一年的java开发，初识了java这门编程语言，总算是开启了新世界，爱上了写代码的快感。可是毕竟学校里学的还是远远不够，对于即将要找工作的我，还是有点慌张的，当时班里说要来北京找工作的不多，我就和我的同学，也是我现在的好朋友（大志远：大三时期的数据库开发实验室的负责人，由于喜欢前端开发，自学了前端开发，现任花椒直播，高级前端开发）一起约好，来北京找工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIstS9xAtFezocSkKDy3BibnOmyic9vYZpFoFfSseP27maAsqRd29fLpGOw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7923076923076923&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;260&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        当时的我们，还很年轻，正所谓初生牛犊不怕虎，一心只想往前飞。当时的我们也很穷，没钱（现在也没钱，留下了伤心的泪水），没女朋友，哈哈哈，两个屌丝结伴而行，各自向家里要了几千块钱，我要了4000，大志远好像也是拿了4000，毕竟都要去工作了，没好意思向家里多要钱。就这样我和大志远踏上了和很多人一样的北漂征程，扛着硕大的旅行箱，背着还是高中时代买的古董笔记本，坐上了开往北京的直达火车，一路上我们并没有感觉到压力，害怕，和对未知的恐惧，或许这就是年轻的好处吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsNGnVhTDD2h6biaRicajoSUpTW7YwhOmRrzVLMpxvWQcP6slgdeSKsvSw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.1187845303867403&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;362&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        第二天的上午，大约十一点多的时候，火车到了北京，那是我第一次在周五的这个点，挤在了北京站的地铁里，看着多如牛毛的行人，急急忙忙的脚步，感觉到了大都市的气息。办好地铁卡的我和大志远，顺着以前在实验室一起学习的学长（进哥：在实验室学习时期的一个很好的学长，也是java开发，现任美团旅行高级开发工程师）给的路线，坐着地铁一路奔向回龙观东大街地铁站，这个我最最熟悉的地方了，当然我现在也还住在这附近，或许是在一个地方呆久了就有感情了吧。（其实是贫穷使我冷静...）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsickuoImBjx3rpfTKXUNaZH7M7EJyEmohicb9sibxKeHrvR61OA2HpFRXQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9666666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        那天我和大志远，折腾了好久才到回龙观东大街，到了之后，等了一会进哥，进哥非说要来接我俩，怕我俩找不到去他那里的路，我记得进哥是和嫂子一起过来的，我们打的车去的平西王府（这个听起来很高端的地方），进哥说他平时不怎么打车，都是回龙观东大街D口坐996路公交车，可以直达平西王府公交场站。平西王府，来这里之前，进哥就已经和他的房东打好了招呼，给我两预留了一间房间，就是那种自建房，一门一户，只有一张床，进门就是厨房，床头就是卫生间（有门），没空调，450一个月，押一付三，网费100，电费自己交，水费不要钱，很大程度上减轻了我和大志远的经济压力。虽然环境恶劣，但是对于刚来的我们还是很划算很开心的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIs3Swk6lfhyKQkUWtIOXPUqPnk1ZVEttLuv1AqgiaIsxjhEbcXk2vpNxA/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;335&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;18&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;248&quot; data-ratio=&quot;0.8961038961038961&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我记得当时的公寓名称好像是安雅公寓，入口是一个小院子，小院子出门的左边是一家沙县小吃（他家有个红烧肉饭是我的最爱，下班回家必来点一份，外加一份老鸭汤，一共16元），右边是一家西安面馆（他家的油泼面真的很好吃，还便宜，只要10块钱）。整体来说，平西王府这里的消费水平都比较低的，感觉和外面不是一个地方，有种这里不是北京的错觉，但是这里确实生活了很多很多的北漂的人，男的，女的，老的，少的，形形色色的人都有，一片和谐。或许这就是我在那里住了好几年的原因吧。扯了有点远了，赶紧拉回来，那天晚上还下起了小雨，进哥和嫂子对刚来北京的我和大志远，真的是没话说，带着我们置办了被子，凉席，风扇，各种用的东西，还请我们吃了一顿诸葛烤鱼，实在是感觉很不好意思。进哥让我们不用着急，工作好找，实习要求不会很高的，你们的水平完全够了，安心住下来，有什么事情就找我和你嫂子，就在你们楼下。这种感觉，就像是你处在一个陌生的城市里，一片黑，突然间有人给你开了一盏灯，真的很温暖，很温馨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsibhYjb2E6ZeWzSeaKYhoZQMXKxgs8V4jc1Xq0dx2G9I1NhrFTBiaA95w/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;309&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.9386363636363636&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        朝阳透过没有窗帘的窗户，照在了我的脸上，我醒了，很早，才六点钟。望着一个床上的大志远，两个光着膀子的大男青年，这景象，放到现在容易让人开车，哈哈哈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsvlClqrVvVoBQW8rWRnSgRzTzIOKHjQ1Quw7MSUpuicUseDtemEBnNRg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        中午，我和大志远卯足了劲，说要把平西王府周围熟悉一遍，防止之后下班回家找不到住的地方。出了住房小院子的门，我们穿过一条一条的小巷子，发现这里全都是外来人员，都是和我们一样的打工仔，不妨也有我老家安徽的。菜市场距离我住的地方，隔了四五条巷子，菜价很便宜，水果也很不错。熟悉了菜市场，公交站，以及来来回回的小巷子之后，我们出了平西王府大牌楼的门，就是这个门。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJhibVRzSibtFaT8Fn5HRVrw2WicaAaxk8v3fxbtksukk6q9OrxL90h32HPQufLOicklcyPvASia21XYgw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6982507288629738&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;before-image&quot;&gt;&lt;span&gt;放眼望去，感觉到了另一个世界一般，仿佛是从村里进了城，对面都是不一样的人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJhibVRzSibtFaT8Fn5HRVrw2MdfeXLv8aibbIjhX88QRcqSfD1asibHZZEoIjgpbavgpMs4P1JP0lyVg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.462059620596206&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        温都水城，北京邮电，北京电影学院，形形色色的店面，各种长得好看的小姐姐，大志远眼睛都直了，哈哈哈，其实我也差不多。走了一下午，逛了个够，也买了点生活用品，还是回到了住的地方，开始了蜗居，开始准备面试的材料，我面试java开发实习，他面试前端开发实习。一开始我们也不知道实习的薪资要多少合适，就综合了每个月的开销，觉得4500左右吧，这样每个月还能存点钱，想的真的挺好的，可是零零碎碎的面试了几家后。彻底改变了我的想法，HR开口说的都是，像你们这种本科出来的，还敢开口要这么多钱？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsCbs3L4FYh8dMTMGarnbKqyjF6bHSmFvkzhrO5YK8AVbiacKxic8kKX7w/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;216&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        虽然你水平还行，但是公司对实习有规定，2000，自己带电脑，你自己考虑吧。我一想，2000，只能勉强维持自己在北京不饿死，不可能的。回家之后，我立马抓着我的电脑，前前后后的复习着java开发的相关知识，看着自己以前做过的各种小项目，看面试宝典，学习着怎么和面试官交谈，我不信，我就是2000的水平，而此时的大志远，已经以每个月4000的薪资进了一家初创小公司（不记得名字）开始上班了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIswVZDSxfeLswpZqlyqkOrwvSX2pzoPgibICPtQ72M0pJdRCBVib9ndSgg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        说实话，当时的我，内心真的是很焦急，此时距离我来北京已经快一个月了，身上的钱交了房租，购买各种生活用品后，已经所剩不多了，再找不到工作，我可能就要活不下去了。可能就要继续伸手向家里要钱了，可是来北京的时候，大话我已经放出去了，“爸，我去北京找工作，你就再打一次钱给我，以后我自己管自己，不用给我钱了”。男人的承诺，男人的尊严，事事不如意的屈辱感，一下子涌上了心头，这种感觉或许只有男人才会懂吧。晚上九点左右的时候，爸爸妈妈打了个电话来，问我工作找的怎么样了，问我住在哪里，吃的怎么样，身上钱还有吗？我不敢说自己还没找到工作，身上的钱也用的快没了，我告诉他们工作已经找到了，4000一个月，身上还有2000多，够用了，下个月八号就发工资了，这边吃住都挺好的，房租也便宜，还有认识的学长带我，不用担心。接完电话，我自己一个人下楼了，穿过满是人的小巷子，来到公交站前面的一条没有人走的路，这里一片漆黑，我喜欢留在这里，因为没有光，只有停在这里的车子，不时的可以看到远处天空的探照灯，仿佛是在告诉我，这里是北京，北京。站了好久好久，一个人想了好久好久，回到出租房的时候，我已经听到了大志远那熟悉的鼾声，睡的很香。我小心翼翼的洗漱完，睡下了，希望明天可以是美好的一天。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OIoO0IAVCHJhibVRzSibtFaT8Fn5HRVrw2Cf61RKZias0S77IXtdEYPw65Uia6lWiciaOlUPqIl0hr3mWvF2akkN5MkQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;680&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;287&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;287&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        清晨天还微微亮，我就醒了，抱着电脑在床上又复习了一遍应对面试准备的材料，八点左右出的门，开始了面试的一天。上午的一家面的和昨天差不多，给了offer说是2700，自己带电脑，叫我考虑一下。下午来到了最能代表这个城市科技的地方，西二旗，准备面试，这是一家做汽车行业相关服务的公司，面试我的是一个技术很厉害的人（这个人之后也成为了我就业路上的第一个恩师）。面试聊的很好，公司用的技术也很新，待遇说是3500加餐补和路费补助，经历了多次碰壁之后的我，对于这个待遇，立马就答应了，恨不得今天就上班，哈哈哈。这家公司就成了我就业历程中的第一家公司了，算是我的启蒙地吧，感恩！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        风雨知秋之进城三人，至此才说到了我和大志远两个人，还有个人是个妹子（老萍），是大志远的小师妹（也是个前端，广西桂林的）。她的经历也比较扎心（后面我也会陆续说到），她是在我和大志远来北京了快一个月的时候来的，来的第一天，我们帮助她找到了一个住的地方。房租500每个月，距离我和大志远住的地方很近，毕竟一个女生很不容易，那天我们三个人一起去帮她买了被褥、电扇等生活用品。我记得买东西的那家店老板也是安徽人，很客气，开了他的三轮车帮我们把东西送回去，路上还下起了大暴雨，三个人站在三轮车的后车厢里，也没个雨衣，从头到脚淋的透湿。（大概就是如下图的场景，原谅七哥这个灵魂画手，哈哈哈）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJhibVRzSibtFaT8Fn5HRVrw2nbzPIYmAGhENEYfHnUsfjqxt5icbVcN0hUr1nlrCSaMPZdibID4Ragew/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;358&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5576707726763718&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可是诺大的城市里，三个人一起总感觉有个依靠，我，大志远，老萍，虽然淋了雨，但是还是傻笑了一路，晚上老萍给我们做了晚饭，自己煮了大米饭，做了两个菜，忘了是什么菜了，但是我记得我们吃的特别香，我吃了两大碗，大志远还要拿盘子吃，哈哈哈哈。简单的不能再简单了，清贫的不能再清贫了，坐地上，盘着腿，吧唧着嘴，真香。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        陌生的城市，熟悉的人，爱笑的面孔以及对未来的憧憬，让我们三个人建立起了深深的羁绊，自此算是北漂青年（三人组）的正式开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        最后附上一张北漂青年，那年在平西王府大斜坡上的合照，猜猜那个是七哥我，哈哈哈哈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OIoO0IAVCHJgCGVGaLg6VHVHySKuZeIsMNZP9SJ8JGnibUoh3JwYfXCROfo9W4sTXBnXyajXXdMpicxR3p1cL8SA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7833333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【备注】下章：《初出茅庐之拜师学艺》，敬请期待更多有趣的故事，感谢您的关注！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加七哥微信：&lt;span&gt;kinyseven&lt;/span&gt;，来扯犊子啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675297/201903/675297-20190308135254315-282942460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;after-image&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 05:54:00 +0000</pubDate>
<dc:creator>jstarseven</dc:creator>
<og:description>&lt; 编码之余，记录一下生活，写成小说分享，哈哈哈&gt; 【 转载请注明】： 原文出处：https://www.cnblogs.com/jstarseven/p/104954</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jstarseven/p/10495406.html</dc:identifier>
</item>
<item>
<title>《k8s-1.13版本源码分析》-调度预选 - CloudGeek</title>
<link>http://www.cnblogs.com/cloudgeek/p/10495179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudgeek/p/10495179.html</guid>
<description>&lt;p&gt;本系列文章已经开源到github：&lt;a href=&quot;https://github.com/farmer-hutao/k8s-source-code-analysis&quot; target=&quot;_blank&quot;&gt;https://github.com/farmer-hutao/k8s-source-code-analysis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;预选流程&quot;&gt;1. 预选流程&lt;/h2&gt;
&lt;p&gt;predicate过程从&lt;code&gt;pkg/scheduler/core/generic_scheduler.go:389 findNodesThatFit()&lt;/code&gt;方法就算正式开始了，这个方法根据给定的&lt;strong&gt;predicate functions&lt;/strong&gt;过滤所有的nodes来寻找一堆可以跑pod的node集。老规矩，我们来看主干代码：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:389&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;g &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;genericScheduler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;findNodesThatFit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodes &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; FailedPredicateMap&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    checkNode &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token builtin&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        fits&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; failedPredicates&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;podFitsOnNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
            
        &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; fits &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            length &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; atomic&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;AddInt32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;filteredLen&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            filtered&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;length&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cachedNodeInfoMap&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;nodeName&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    workqueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ParallelizeUntil&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;allNodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; checkNode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filtered&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extenders&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; extender &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extenders &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; filtered&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; failedPredicateMap&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，删的有点多，大家也可以看一下原函数然后对比一下，看看我为什么只保留这一点。从上面代码中我们可以发现，最重要的是一个子函数调用过程&lt;code&gt;fits, failedPredicates, err := podFitsOnNode()&lt;/code&gt;，这个函数的参数我没有贴出来，下面会详细讲；下半部分是一个extender过程，extender不影响对predicate过程的理解，我们后面专门当作一个主题讲。所以这里的关注点是&lt;code&gt;podFitsOnNode()&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;predicate的并发&quot;&gt;2. predicate的并发&lt;/h2&gt;
&lt;p&gt;进入&lt;code&gt;podFitsOnNode()&lt;/code&gt;函数逻辑之前，我们先看一下调用到&lt;code&gt;podFitsOnNode()&lt;/code&gt;函数的匿名函数变量&lt;strong&gt;checkNode&lt;/strong&gt;是怎么被调用的：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:458&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;workqueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ParallelizeUntil&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;allNodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; checkNode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ParallelizeUntil()&lt;/code&gt;函数是用于并行执行N个独立的工作过程的，这个逻辑写的挺有意思，我们看一下完整的代码(这段的分析思路写到注释里哦)：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;vendor/k8s.io/client-go/util/workqueue/parallelizer.go:38&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ParallelizeUntil&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ctx context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; workers&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pieces &lt;span class=&quot;token builtin&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; doWorkPiece DoWorkPieceFunc&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    
    
    
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; stop &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; ctx &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        stop &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ctx&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    toProcess &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pieces&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; pieces&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        toProcess &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt; i
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;toProcess&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; pieces &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; workers &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        workers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pieces
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    wg &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; sync&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;WaitGroup&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; workers&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;defer&lt;/span&gt; utilruntime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;HandleCrash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;defer&lt;/span&gt; wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; piece &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; toProcess &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                
                
                
                
                &lt;span class=&quot;token keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt;stop&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                    
                    
                    &lt;span class=&quot;token function&quot;&gt;doWorkPiece&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;piece&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回想一下前面的&lt;code&gt;checkNode := func(i int){……}&lt;/code&gt;，上面的&lt;code&gt;doWorkPiece(piece)&lt;/code&gt;也就是调用到了这里的这个匿名函数&lt;code&gt;func(i int){……}&lt;/code&gt;；到这里就清楚如何实现并发执行多个node的predicate过程了。&lt;/p&gt;
&lt;h2 id=&quot;一个node的predicate&quot;&gt;3. 一个node的predicate&lt;/h2&gt;
&lt;p&gt;checkNode的主要逻辑就是上面介绍的并发加上下面这个&lt;code&gt;podFitsOnNode()&lt;/code&gt;函数逻辑：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:425&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;fits&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; failedPredicates&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;podFitsOnNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                meta&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;cachedNodeInfoMap&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;nodeName&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;predicates&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                nodeCache&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;schedulingQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                g&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alwaysCheckAllPredicates&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                equivClass&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从&lt;code&gt;podFitsOnNode()&lt;/code&gt;的函数定义入手：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:537&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;podFitsOnNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    pod &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    meta algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateMetadata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    info &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;schedulercache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeInfo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    predicateFuncs &lt;span class=&quot;token keyword&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;FitPredicate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nodeCache &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;equivalence&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeCache&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue internalqueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;SchedulingQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    alwaysCheckAllPredicates &lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    equivClass &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;equivalence&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Class&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于这个函数的逻辑，注释里的描述翻译过来大概是这个意思：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;podFitsOnNode()函数检查一个通过NodeInfo形式给定的node是否满足指定的predicate functions. 对于给定的一个Pod，podFitsOnNode()函数会检查是否有某个“等价的pod”存在，然后重用那个等价pod缓存的predicate结果。 这个函数的调用入口有2处: Schedule and Preempt.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当从Schedule进入时：这个函数想要测试node上所有已经存在的pod外加被指定将要调度到这个node上的其他所有高优先级（优先级不比自己低，也就是&amp;gt;=）的pod后，当前pod是否可以被调度到这个node上。&lt;/li&gt;
&lt;li&gt;当从Preempt进入时：后面讲preempt时再详细分析。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;podFitsOnNode()函数的参数有点多，每个跟进去就是一堆知识点。这里建议大家从字面先过一边，然后跟进去看一下类型定义，类型的注释等，了解一下功能，先不深究。整体看完一边调度器代码后回过头深入细节。&lt;/p&gt;
&lt;p&gt;我们一起看一下其中这个参数：&lt;code&gt;predicateFuncs map[string]algorithm.FitPredicate&lt;/code&gt;；这里的&lt;strong&gt;predicateFuncs&lt;/strong&gt;是一个map，表示所有的predicate函数。这个map的key是个字符串，也就是某种形式的name了；value类型跟进去看一下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/algorithm/types.go:36&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;

&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; FitPredicate &lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; meta PredicateMetadata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfo &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;schedulercache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeInfo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FitPredicate是一个函数类型，3个参数，pod和node都很好理解，meta跟进去简单看一下可以发现定义的是一些和predicate相关的一些元数据，这些数据是根据pod和node信息获取到的，类似pod的端口有哪些，pod亲和的pod列表等。返回值是一个表示是否fit的bool值，predicate失败的原因列表，一个错误类型。&lt;/p&gt;
&lt;p&gt;也就是说，FitPredicate这个函数类型也就是前面一直说的predicate functions的真面目了。下面看podFitsOnNode()函数的具体逻辑吧：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:537&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;podFitsOnNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    pod &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    meta algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateMetadata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    info &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;schedulercache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeInfo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    predicateFuncs &lt;span class=&quot;token keyword&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;FitPredicate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nodeCache &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;equivalence&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeCache&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue internalqueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;SchedulingQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    alwaysCheckAllPredicates &lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    equivClass &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;equivalence&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Class&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    podsAdded &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        metaToUse &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; meta
        nodeInfoToUse &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; info
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            podsAdded&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; metaToUse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfoToUse &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addNominatedPods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; meta&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; info&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;podsAdded &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;failedPredicates&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        eCacheAvailable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; equivClass &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nodeCache &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;podsAdded
        
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;failedPredicates&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; failedPredicates&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的逻辑是从一个for循环开始的，关于这个2次循环的含义代码里有很长的一段注释，我们先看一下注释里怎么说的（这里可以多看几遍体会一下）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;出于某些原因考虑我们需要运行两次predicate. 如果node上有更高或者相同优先级的“指定pods”（这里的“指定pods”指的是通过schedule计算后指定要跑在一个node上但是还未真正运行到那个node上的pods），我们将这些pods加入到meta和nodeInfo后执行一次计算过程。&lt;/li&gt;
&lt;li&gt;如果这个过程所有的predicates都成功了，我们再假设这些“指定pods”不会跑到node上再运行一次。第二次计算是必须的，因为有一些predicates比如pod亲和性，也许在“指定pods”没有成功跑到node的情况下会不满足。&lt;/li&gt;
&lt;li&gt;如果没有“指定pods”或者第一次计算过程失败了，那么第二次计算不会进行。&lt;/li&gt;
&lt;li&gt;我们在第一次调度的时候只考虑相等或者更高优先级的pods，因为这些pod是当前pod必须“臣服”的，也就是说不能够从这些pod中抢到资源，这些pod不会被当前pod“抢占”；这样当前pod也就能够安心从低优先级的pod手里抢资源了。&lt;/li&gt;
&lt;li&gt;新pod在上述2种情况下都可调度基于一个保守的假设：资源和pod反亲和性等的predicate在“指定pods”被处理为Running时更容易失败；pod亲和性在“指定pods”被处理为Not Running时更加容易失败。&lt;/li&gt;
&lt;li&gt;我们不能假设“指定pods”是Running的因为它们当前还没有运行，而且事实上，它们确实有可能最终又被调度到其他node上了。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;看了这个注释后，上面代码里的前几行就很好理解了，在第一次进入循环体和第二次进入时做了不同的处理，具体怎么做的处理我们暂时不关注。下面看省略的这个for循环做了啥：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/core/generic_scheduler.go:583&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; predicateID&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; predicateKey &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; predicates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        fit     &lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;
        reasons &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason
        err     &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; predicate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; exist &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; predicateFuncs&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;predicateKey&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; exist &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; eCacheAvailable &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            fit&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reasons&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nodeCache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;RunPredicate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;predicate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; predicateKey&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; predicateID&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; metaToUse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfoToUse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; equivClass&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            
            fit&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reasons&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; metaToUse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfoToUse&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;fit &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们看一下2个地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;predicates.Ordering()&lt;/li&gt;
&lt;li&gt;fit, reasons, err = predicate(pod, metaToUse, nodeInfoToUse)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分两个小节吧～&lt;/p&gt;
&lt;h3 id=&quot;predicates的顺序&quot;&gt;3.1. predicates的顺序&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/algorithm/predicates/predicates.go:130&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
   predicatesOrdering &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       CheckNodeConditionPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       CheckNodeUnschedulablePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       GeneralPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       HostNamePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       PodFitsHostPortsPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       MatchNodeSelectorPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       PodFitsResourcesPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       NoDiskConflictPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       PodToleratesNodeTaintsPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       PodToleratesNodeNoExecuteTaintsPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       CheckNodeLabelPresencePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       CheckServiceAffinityPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       MaxEBSVolumeCountPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       MaxGCEPDVolumeCountPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       MaxCSIVolumeCountPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       MaxAzureDiskVolumeCountPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       CheckVolumeBindingPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       NoVolumeZoneConflictPred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       CheckNodeMemoryPressurePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       CheckNodePIDPressurePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       CheckNodeDiskPressurePred&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
       MatchInterPodAffinityPred&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，这里定义了一个次序，前面的for循环遍历的是这个[]string，这样也就实现了不管&lt;code&gt;predicateFuncs&lt;/code&gt;里定义了怎样的顺序，影响不了predicate的实际调用顺序。官网对于这个顺序有这样一个&lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/predicates-ordering.md&quot; target=&quot;_blank&quot;&gt;表格&lt;/a&gt;解释：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Position&lt;/th&gt;
&lt;th&gt;Predicate&lt;/th&gt;
&lt;th&gt;comments (note, justification...)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CheckNodeConditionPredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;we really don’t want to check predicates against unschedulable nodes.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodFitsHost&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;we check the pod.spec.nodeName.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodFitsHostPorts&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;we check ports asked on the spec.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodMatchNodeSelector&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;check node label after narrowing search.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodFitsResources&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;this one comes here since it’s not restrictive enough as we do not try to match values but ranges.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;code&gt;NoDiskConflict&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Following the resource predicate, we check disk&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodToleratesNodeTaints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;check toleration here, as node might have toleration&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PodToleratesNodeNoExecuteTaints&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;check toleration here, as node might have toleration&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CheckNodeLabelPresence&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;labels are easy to check, so this one goes before&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;code&gt;checkServiceAffinity&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MaxPDVolumeCountPredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VolumeNodePredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VolumeZonePredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CheckNodeMemoryPressurePredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;doesn’t happen often&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CheckNodeDiskPressurePredicate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;doesn’t happen often&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;code&gt;InterPodAffinityMatches&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Most expensive predicate to compute&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个表格大家对着字面意思体会一下吧，基本还是可以联想到意义的。&lt;/p&gt;
&lt;p&gt;当然这个顺序是可以被配置文件覆盖的，用户可以使用类似这样的配置：&lt;/p&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;kind&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Policy&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;v1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;predicates&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PodFitsHostPorts&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PodFitsResources&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;NoDiskConflict&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PodToleratesNodeTaints&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;MatchNodeSelector&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PodFitsHost&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;order&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;priorities&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;LeastRequestedPriority&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;weight&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;BalancedResourceAllocation&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;weight&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;ServiceSpreadingPriority&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;weight&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;EqualPriority&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;&quot;weight&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token property&quot;&gt;&quot;hardPodAffinitySymmetricWeight&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整体过完源码后我们再实际尝试一下这些特性，这一边先知道有这回事吧，ok，继续～&lt;/p&gt;
&lt;h3 id=&quot;单个predicate执行过程&quot;&gt;3.2. 单个predicate执行过程&lt;/h3&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;fit&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reasons&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;predicate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; metaToUse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfoToUse&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码其实没有啥复杂逻辑，不过我们还是重复讲一下，清晰理解这一行很有必要。这里的&lt;code&gt;predicate()&lt;/code&gt;来自前几行的if语句&lt;code&gt;predicate, exist := predicateFuncs[predicateKey]&lt;/code&gt;，往前跟也就是&lt;strong&gt;FitPredicate&lt;/strong&gt;类型，我们前面提过，类型定义在&lt;code&gt;pkg/scheduler/algorithm/types.go:36&lt;/code&gt;，这个&amp;amp;#x7C7#x7C7B;型表示的是一个具体的predicate函数，这里使用&lt;code&gt;predicate()&lt;/code&gt;也就是一个函数调用的语法，很和谐了。&lt;/p&gt;
&lt;h3 id=&quot;具体的predicate函数&quot;&gt;3.3. 具体的predicate函数&lt;/h3&gt;
&lt;p&gt;一直在讲predicate，那么predicate函数到底长什么样子呢，我们从具体的实现函数找一个看一下。开始讲design的时候提到过predicate的实现在&lt;code&gt;pkg/scheduler/algorithm/predicates/predicates.go&lt;/code&gt;文件中，先看一眼Structure吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998740/201903/998740-20190308132133287-1293921361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个文件中predicate函数有点多，这样看眼花，我们具体点开一个观察一下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/algorithm/predicates/predicates.go:277&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;NoDiskConflict&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pod &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Pod&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; meta algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateMetadata&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nodeInfo &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;schedulercache&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;NodeInfo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; v &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; pod&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Spec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Volumes &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ev &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; nodeInfo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Pods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isVolumeConflict&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;v&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ev&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;algorithm&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;PredicateFailureReason&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;ErrDiskConflict&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道predicate函数的特点，这样就很好在这个一千六百多行go文件中寻找predicate函数了。像上面这个&lt;code&gt;NoDiskConflict()&lt;/code&gt;函数，参数是pod、meta和nodeinfo，很明显是&lt;strong&gt;FitPredicate&lt;/strong&gt;类型的，标准的predicate函数。&lt;/p&gt;
&lt;p&gt;这个函数的实现也特别简单，遍历pod的Volumes，然后对于pod的每一个Volume，遍历node上的每个pod，看是否和当前podVolume冲突。如果不fit就返回false加原因；如果fit就返回true，很清晰。&lt;/p&gt;
&lt;span class=&quot;copyright&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998740/201903/998740-20190308131528871-1671029879.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;</description>
<pubDate>Fri, 08 Mar 2019 05:20:00 +0000</pubDate>
<dc:creator>CloudGeek</dc:creator>
<og:description>本文大纲 &lt;!-- toc --&gt; 预选流程 predicate的并发 一个node的predicate predicates的顺序 单个predicate执行过程 具体的predicat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudgeek/p/10495179.html</dc:identifier>
</item>
<item>
<title>从零开始搭建Prometheus自动监控报警系统（企业级） - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/10494868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/10494868.html</guid>
<description>&lt;h2 id=&quot;什么是prometheus&quot;&gt;什么是Prometheus?&lt;/h2&gt;
&lt;p&gt;Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。&lt;br/&gt;2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。&lt;br/&gt;Prometheus目前在开源社区相当活跃。&lt;br/&gt;Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。&lt;/p&gt;
&lt;h2 id=&quot;prometheus的特点&quot;&gt;Prometheus的特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;多维度数据模型。&lt;/li&gt;
&lt;li&gt;灵活的查询语言。&lt;/li&gt;
&lt;li&gt;不依赖分布式存储，单个服务器节点是自主的。&lt;/li&gt;
&lt;li&gt;通过基于HTTP的pull方式采集时序数据。&lt;/li&gt;
&lt;li&gt;可以通过中间网关进行时序列数据推送。&lt;/li&gt;
&lt;li&gt;通过服务发现或者静态配置来发现目标服务对象。&lt;/li&gt;
&lt;li&gt;支持多种多样的图表和界面展示，比如Grafana等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官网地址：https://prometheus.io/&lt;/p&gt;
&lt;h2 id=&quot;架构图&quot;&gt;架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115806797-1750460125.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115354474-1478270204.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)。&lt;/p&gt;
&lt;h2 id=&quot;服务过程&quot;&gt;服务过程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Prometheus Daemon负责定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。&lt;/li&gt;
&lt;li&gt;Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。&lt;/li&gt;
&lt;li&gt;Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。&lt;/li&gt;
&lt;li&gt;PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。&lt;/li&gt;
&lt;li&gt;Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三大套件&quot;&gt;三大套件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Server 主要负责数据采集和存储，提供PromQL查询语言的支持。&lt;/li&gt;
&lt;li&gt;Alertmanager 警告管理器，用来进行报警。&lt;/li&gt;
&lt;li&gt;Push Gateway 支持临时性Job主动推送指标的中间网关。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;本飞猪教程内容简介&quot;&gt;本飞猪教程内容简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1.演示安装Prometheus Server&lt;/li&gt;
&lt;li&gt;2.演示通过golang和node-exporter提供metrics接口&lt;/li&gt;
&lt;li&gt;3.演示pushgateway的使用&lt;/li&gt;
&lt;li&gt;4.演示grafana的使用&lt;/li&gt;
&lt;li&gt;5.演示alertmanager的使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装准备&quot;&gt;安装准备&lt;/h2&gt;
&lt;p&gt;这里我的IP是10.211.55.25，登入，建立相应文件夹&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /home/chenqionghe/promethues
mkdir -p /home/chenqionghe/promethues/server
mkdir -p /home/chenqionghe/promethues/client
touch /home/chenqionghe/promethues/server/rules.yml
chmod 777 /home/chenqionghe/promethues/server/rules.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面开始三大套件的学习&lt;/p&gt;

&lt;p&gt;通过docker方式&lt;br/&gt;首先创建一个配置文件/home/chenqionghe/test/prometheus/prometheus.yml&lt;br/&gt;挂载之前需要改变文件权限为777，要不会引起修改宿主机上的文件 会引起内容不同步的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。
  external_labels:
    monitor: 'codelab-monitor'
# 这里表示抓取对象的配置
scrape_configs:
    #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&quot;prometheus&quot;}的标签  - job_name: 'prometheus'
    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒
    static_configs:
      - targets: ['localhost:9090']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker rm -f prometheus
docker run --name=prometheus -d \
-p 9090:9090 \
-v /home/chenqionghe/promethues/server/prometheus.yml:/etc/prometheus/prometheus.yml \
-v /home/chenqionghe/promethues/server/rules.yml:/etc/prometheus/rules.yml \
prom/prometheus:v2.7.2 \
--config.file=/etc/prometheus/prometheus.yml \
--web.enable-lifecycle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动时加上--web.enable-lifecycle启用远程热加载配置文件&lt;br/&gt;调用指令是curl -X POST http://localhost:9090/-/reload&lt;/p&gt;
&lt;p&gt;访问http://10.211.55.25:9090&lt;br/&gt;我们会看到如下l界面&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120421903-117006715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问http://10.211.55.25:9090/metrics&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120433999-2023519443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们配置了9090端口，默认prometheus会抓取自己的/metrics接口&lt;br/&gt;在Graph选项已经可以看到监控的数据&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115422639-2083020411.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;通过golang客户端提供metrics&quot;&gt;1.通过golang客户端提供metrics&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /home/chenqionghe/promethues/client/golang/src
cd !$
export GOPATH=/home/chenqionghe/promethues/client/golang/
#克隆项目
git clone https://github.com/prometheus/client_golang.git
#安装需要FQ的第三方包
mkdir -p $GOPATH/src/golang.org/x/
cd !$
git clone https://github.com/golang/net.git
git clone https://github.com/golang/sys.git
git clone https://github.com/golang/tools.git
#安装必要软件包
go get -u -v github.com/prometheus/client_golang/prometheus
#编译
cd $GOPATH/src/client_golang/examples/random
go build -o random main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行3个示例metrics接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./random -listen-address=:8080 &amp;amp;
./random -listen-address=:8081 &amp;amp;
./random -listen-address=:8082 &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过node-exporter提供metrics&quot;&gt;2.通过node exporter提供metrics&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d \
--name=node-exporter \
-p 9100:9100 \
prom/node-exporter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把这两些接口再次配置到prometheus.yml, 重新载入配置curl -X POST http://localhost:9090/-/reload&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。
  external_labels:
    monitor: 'codelab-monitor'
rule_files:
  #- 'prometheus.rules'
# 这里表示抓取对象的配置
scrape_configs:
  #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&quot;prometheus&quot;}的标签  - job_name: 'prometheus'
  - job_name: 'prometheus'
    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒
    static_configs:
      - targets: ['localhost:9090']
      - targets: ['http://10.211.55.25:8080', 'http://10.211.55.25:8081','http://10.211.55.25:8082']
        labels:
          group: 'client-golang'
      - targets: ['http://10.211.55.25:9100']
        labels:
          group: 'client-node-exporter'

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到接口都生效了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115453501-1461914786.png&quot;/&gt;&lt;br/&gt;prometheus还提供了各种exporter工具，感兴趣小伙伴可以去研究一下&lt;/p&gt;

&lt;p&gt;pushgateway是为了允许临时作业和批处理作业向普罗米修斯公开他们的指标。&lt;br/&gt;由于这类作业的存在时间可能不够长, 无法抓取到, 因此它们可以将指标推送到推网关中。&lt;br/&gt;Prometheus采集数据是用的pull也就是拉模型，这从我们刚才设置的5秒参数就能看出来。但是有些数据并不适合采用这样的方式，对这样的数据可以使用Push Gateway服务。&lt;br/&gt;它就相当于一个缓存，当数据采集完成之后，就上传到这里，由Prometheus稍后再pull过来。&lt;br/&gt;我们来试一下，首先启动Push Gateway&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /home/chenqionghe/promethues/pushgateway
cd !$
docker run -d -p 9091:9091 --name pushgateway prom/pushgateway&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问http://10.211.55.25:9091 已经pushgateway运行起来了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120318942-842220712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们就可以往pushgateway推送数据了，prometheus提供了多种语言的sdk，最简单的方式就是通过shell&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推送一个指标&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;echo &quot;cqh_metric 3.14&quot; | curl --data-binary @- http://ubuntu-linux:9091/metrics/job/cqh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;推送多个指标&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cat &amp;lt;&amp;lt;EOF | curl --data-binary @- http://10.211.55.25:9091/metrics/job/cqh/instance/test
# 锻炼场所价格
muscle_metric{label=&quot;gym&quot;} 8800
# 三大项数据 kg
bench_press 100
dead_lift 160
deep_squal 160
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再将pushgateway配置到prometheus.yml里边,重载配置&lt;br/&gt;看到已经可以搜索出刚刚推送的指标了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115513785-779429082.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Grafana是用于可视化大型测量数据的开源程序，它提供了强大和优雅的方式去创建、共享、浏览数据。&lt;br/&gt;Dashboard中显示了你不同metric数据源中的数据。&lt;br/&gt;Grafana最常用于因特网基础设施和应用分析，但在其他领域也有用到，比如：工业传感器、家庭自动化、过程控制等等。&lt;br/&gt;Grafana支持热插拔控制面板和可扩展的数据源，目前已经支持Graphite、InfluxDB、OpenTSDB、Elasticsearch、Prometheus等。&lt;/p&gt;
&lt;p&gt;我们使用docker安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -p 3000:3000 --name grafana grafana/grafana&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认登录账户和密码都是admin，进入后界面如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115539209-1034408605.png&quot;/&gt;&lt;br/&gt;我们添加一个数据源&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115742521-1216773920.png&quot;/&gt;&lt;br/&gt;把Prometheus的地址填上&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115608797-630123242.png&quot;/&gt;&lt;br/&gt;导入prometheus的模板&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115620090-1083923378.png&quot;/&gt;&lt;br/&gt;打开左上角选择已经导入的模板会看到已经有各种图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115633809-1013780572.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来添加一个自己的图表&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115913743-1707140186.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115934622-453640251.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308115946769-2109720034.png&quot;/&gt;&lt;br/&gt;指定自己想看的图标和关键字，右上角保存&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120004908-1940528641.png&quot;/&gt;&lt;br/&gt;看到如下数据&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120018358-351400776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就已经实现了数据的自动收集和展示，下面来说下prometheus如何自动报警&lt;/p&gt;

&lt;p&gt;Pormetheus的警告由独立的两部分组成。&lt;br/&gt;Prometheus服务中的警告规则发送警告到Alertmanager。&lt;br/&gt;然后这个Alertmanager管理这些警告。包括silencing, inhibition, aggregation，以及通过一些方法发送通知，例如：email，PagerDuty和HipChat。&lt;br/&gt;建立警告和通知的主要步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建和配置Alertmanager&lt;/li&gt;
&lt;li&gt;启动Prometheus服务时，通过-alertmanager.url标志配置Alermanager地址，以便Prometheus服务能和Alertmanager建立连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建和配置Alertmanager&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /home/chenqionghe/promethues/alertmanager
cd !$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建配置文件alertmanager.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  resolve_timeout: 5m
route:
  group_by: ['cqh']
  group_wait: 10s #组报警等待时间
  group_interval: 10s #组报警间隔时间
  repeat_interval: 1m #重复报警间隔时间
  receiver: 'web.hook'
receivers:
  - name: 'web.hook'
    webhook_configs:
      - url: 'http://10.211.55.2:8888/open/test'
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'dev', 'instance']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置成了web.hook的方式，当server通知alertmanager会自动调用webhook http://10.211.55.2:8888/open/test&lt;/p&gt;
&lt;p&gt;下面运行altermanager&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker rm -f alertmanager
docker run -d -p 9093:9093 \
--name alertmanager \
-v /home/chenqionghe/promethues/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml \
prom/alertmanager&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问http://10.211.55.25:9093&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120035275-598446493.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来修改Server端配置报警规则和altermanager地址&lt;br/&gt;修改规则/home/chenqionghe/promethues/server/rules.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;groups:
  - name: cqh
    rules:
      - alert: cqh测试
        expr: dead_lift &amp;gt; 150
        for: 1m
        labels:
          status: warning
        annotations:
          summary: &quot;{{$labels.instance}}:硬拉超标！lightweight baby!!!&quot;
          description: &quot;{{$labels.instance}}:硬拉超标！lightweight baby!!!&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条规则的意思是，硬拉超过150公斤，持续一分钟，就报警通知&lt;br/&gt;然后再修改prometheus添加altermanager配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  scrape_interval:     15s # 默认抓取间隔, 15秒向目标抓取一次数据。
  external_labels:
    monitor: 'codelab-monitor'
rule_files:
  - /etc/prometheus/rules.yml
# 这里表示抓取对象的配置
scrape_configs:
  #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个{job_name:&quot;prometheus&quot;}的标签  - job_name: 'prometheus'
  - job_name: 'prometheus'
    scrape_interval: 5s # 重写了全局抓取间隔时间，由15秒重写成5秒
    static_configs:
      - targets: ['localhost:9090']
      - targets: ['10.211.55.25:8080', '10.211.55.25:8081','10.211.55.25:8082']
        labels:
          group: 'client-golang'
      - targets: ['10.211.55.25:9100']
        labels:
          group: 'client-node-exporter'
      - targets: ['10.211.55.25:9091']
        labels:
          group: 'pushgateway'
alerting:
  alertmanagers:
    - static_configs:
        - targets: [&quot;10.211.55.25:9093&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载prometheus配置，规则就已经生效&lt;br/&gt;接下来我们观察grafana中数据的变化&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120236208-1227567585.png&quot;/&gt;&lt;br/&gt;然后我们点击prometheus的Alert模块，会看到已经由绿-&amp;gt;黄-红，触发了报警&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120055391-1844210675.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120104124-603881581.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120113501-838293511.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再来看看提供的webhook接口，这里的接口我是用的golang写的，接到数据后将body内容报警到钉钉&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120125377-632714300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;钉钉收到报警内容如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/201903/662544-20190308120137716-2091922830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，从零开始搭建Prometheus实现自动监控报警就说介绍完了，一条龙服务，自动抓取接口+自动报警+优雅的图表展示，你还在等什么，赶紧high起来！&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 04:07:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>从零搭建Prometheus监控报警系统 什么是Prometheus? Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqionghe/p/10494868.html</dc:identifier>
</item>
<item>
<title>版本控制工具——Git常用操作（上） - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10494832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10494832.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：工程师小熊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开始。完成本系列博客的阅读以后，你将掌握git的基本概念与git的基本命令，可以在本地随心所欲的完成代码的提交撤销保存修改等操作、可以流畅的参与多人协作，本文致力于快速的入门，如果涉及到更高级的功能需要进行更深一步的学习。&lt;/p&gt;
&lt;p&gt;本文核心点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Git的基本概念&lt;/li&gt;
&lt;li&gt;一个人使用Git时的代码版本控制--（提交、拉代码、分支操作）&lt;/li&gt;
&lt;li&gt;多人合作时的代码版本控制--（合并冲突、暂存代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。&lt;/p&gt;
&lt;p&gt;git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到，让我们来由浅入深进行学习。&lt;/p&gt;
&lt;h2 id=&quot;git的历史&quot;&gt;git的历史&lt;/h2&gt;
&lt;p&gt;git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（牛笔的人）&lt;/p&gt;

&lt;h2 id=&quot;安装git&quot;&gt;安装git&lt;/h2&gt;
&lt;p&gt;选择自己的操作系统对应的git版本安装，安装成功后运行&lt;code&gt;git version&lt;/code&gt;后，输出git版本则安装正确。&lt;/p&gt;
&lt;p&gt;git 官方： &lt;a href=&quot;https://git-scm.com/downloads&quot; class=&quot;uri&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置用户信息&quot;&gt;配置用户信息&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;命令来配置用户名和邮箱&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;git config --global user.name &quot;pzqu&quot; 
git config --global user.email pzqu@example.com&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用&lt;code&gt;git config user.name&lt;/code&gt;和&lt;code&gt;git config user.email&lt;/code&gt;来检查是否成功，也可以直接用&lt;code&gt;git config --list&lt;/code&gt;来列出全部git配置信息来查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/eut6rrnvjr.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建git托管的项目&quot;&gt;创建git托管的项目&lt;/h2&gt;
&lt;p&gt;假如我们创建一个项目叫make_money，先创建一个文件夹叫make_money，再使用&lt;code&gt;git init&lt;/code&gt;命令创建git项目。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# pzqu @ pzqu-pc in ~/Documents/code/test [0:05:29]
$ mkdir make_money

# pzqu @ pzqu-pc in ~/Documents/code/test [0:06:24]
$ ls
make_money

# pzqu @ pzqu-pc in ~/Documents/code/test [0:06:29]
$ cd make_money

# pzqu @ pzqu-pc in ~/Documents/code/test/make_money [0:07:10]
$ git init
Initialized empty Git repository in /Users/pzqu/Documents/code/test/make_money/.git/

# pzqu @ pzqu-pc in ~/Documents/code/test/make_money on git:master o [0:07:12]
$ ls -al
total 0
drwxr-xr-x  3 pzqu  staff   96 11  7 00:07 .
drwxr-xr-x  3 pzqu  staff   96 11  7 00:06 ..
drwxr-xr-x  9 pzqu  staff  288 11  7 00:07 .git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功以后，会出现一个叫.git的隐藏文件夹，这个就是你的git仓库，以后所有的git操作历史提交记录信息就全部记录在此了，只要这个文件夹在就可以记住我们的全部git操作&lt;/p&gt;
&lt;h2 id=&quot;工作区和暂存区&quot;&gt;工作区和暂存区&lt;/h2&gt;
&lt;p&gt;在使用git的时候还要清楚暂存区和工作区的含义，参考&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000&quot;&gt;廖雪峰的官方网站-git篇-工作区和暂存区&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;提交代码&quot;&gt;提交代码&lt;/h2&gt;
&lt;h3 id=&quot;新文件与修改&quot;&gt;新文件与修改&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:37:50]
$ ls
README.md

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [11:42:02]
$ touch file1.txt

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:15]
$ git add file1.txt

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:42:23]
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   file1.txt
# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [11:56:38]
$ git commit -m &quot;[+]add new file1.txt&quot;
[master 66cc488] [+]add new file1.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file1.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上图操作包含:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建新文件file1.txt&lt;/li&gt;
&lt;li&gt;add 添加修改的内容到索引&lt;/li&gt;
&lt;li&gt;status 查看修改的内容&lt;/li&gt;
&lt;li&gt;commit 把索引提交到本地分支&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt; ：监控工作区的状态树，此命令会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add -u&lt;/code&gt;：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update的缩写）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add -A&lt;/code&gt; ：是上面两个功能的合集（git add --all的缩写）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/u3p66p5cb7.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;git show 列出最近一次的提交&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于commit：像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;删除文件&quot;&gt;删除文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:24]
$ ls
README.md file1.txt

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [12:55:25]
$ git rm file1.txt
rm 'file1.txt'

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:30]
$ ls
README.md

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:32]
$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    deleted:    file1.txt

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master x [12:55:40] C:128
$ git commit -m &quot;[-]delete file1.txt&quot;
[master e278392] [-]delete file1.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 file1.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上图操作包含:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建新文件file1.txt&lt;/li&gt;
&lt;li&gt;git rm 删除file1.txt文件&lt;/li&gt;
&lt;li&gt;status 查看修改的内容&lt;/li&gt;
&lt;li&gt;commit 把索引提交到本地分支&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tip1: 如果没有用git rm删除文件，在本地删除文件后，git add一下再提交可以达到同样的效果&lt;/p&gt;
&lt;p&gt;tip2: 要是你加班太晚，头晕不小心删除了不想删除的文件怎么办？见&lt;/p&gt;
&lt;p&gt;下一篇：版本控制工具——Git常用操作（下）-后悔药&lt;/p&gt;
&lt;h2 id=&quot;拉代码&quot;&gt;拉代码&lt;/h2&gt;
&lt;h3 id=&quot;方法一-pull&quot;&gt;方法一 pull&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [17:01:13]
$ git pull
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:pzqu/git_test
   5fd4d8f..7b54a8a  master     -&amp;gt; origin/master
Merge made by the 'recursive' strategy.
 share_file.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 share_file.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上图命令：&lt;/p&gt;
&lt;p&gt;查看本地仓库变化&lt;code&gt;git log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/4dxbkpnji8.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;p&gt;上图可以看到向远程仓库pull的时候，出现了两个新的commit，&lt;code&gt;commit 7b54a8ae74...&lt;/code&gt;的提交信息为&lt;code&gt;Create share_file.txt&lt;/code&gt;,另一个&lt;code&gt;commit fdbb19cf4c51770&lt;/code&gt;的提交信息为&lt;code&gt;Merge branch 'master' of github.com:pzqu/git_test&lt;/code&gt;。事实上主线只有一个提交，为什么会出现这种情况? 是因为pull其实会做两个操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拉远程仓库代码到本地&lt;/li&gt;
&lt;li&gt;自动与当前分支合并并生成一个合并成功的提交&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意这里的第二个个步骤如果远程有人和你改了同一个文件就会出现一个冲突，这个时候git会提示你哪些文件有冲突，手动改了再提交一次就可以了。详情见合并冲突&lt;/p&gt;
&lt;h3 id=&quot;方法二-fetch&quot;&gt;方法二 fetch&lt;/h3&gt;
&lt;p&gt;我在远程修改了文件，向&lt;code&gt;share_file.txt&lt;/code&gt;加了一行内容&lt;code&gt;tom modify&lt;/code&gt;，此时拉代码。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:07:21]
$ git fetch

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:master o [21:08:43]
$ git rebase origin/master
First, rewinding head to replay your work on top of it...
Applying: [+]add new file1.txt
Applying: [-]delete file1.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上图所示有以下两个操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fetch 拉取远端代码到本地&lt;/li&gt;
&lt;li&gt;rebase 把本地代码提交基于远端分支重新replay&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/hdghbz2s9c.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;p&gt;上图是&lt;code&gt;git log&lt;/code&gt;所输出的提交内容，刚刚pull的时候忘记把pull自动产生的merge提交到远程，rebase的时候把本地的提交放到了远程提交之后，看起来就是一条直线，比较优雅，也是推荐的方式。&lt;/p&gt;
&lt;p&gt;同样的，如果产生了冲突，详情见合并冲突&lt;/p&gt;
&lt;h2 id=&quot;分支操作&quot;&gt;分支操作&lt;/h2&gt;
&lt;h3 id=&quot;创建分支&quot;&gt;创建分支&lt;/h3&gt;
&lt;p&gt;分支是多人协同最经典的地方所在，我们来创建一个分支&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git checkout -b dev/pzqu origin/master
Branch 'dev/pzqu' set up to track remote branch 'master' from 'origin'.
Switched to a new branch 'dev/pzqu'

$ git branch
* dev/pzqu
  master&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git checkout -b 分支名 其他分支&lt;/code&gt;,&lt;code&gt;-b&lt;/code&gt;代表创建并切换到新建的分支，&lt;code&gt;分支名&lt;/code&gt;代表新创建的分支叫什么名字，这里叫&lt;code&gt;dev/pzqu&lt;/code&gt; ，&lt;code&gt;其他分支&lt;/code&gt;代表基于哪一个分支来创建，这里基于远程的master分支&lt;code&gt;origin/master&lt;/code&gt;，如果省略则代表基于当前分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt;展示本地的分支情况，加&lt;code&gt;-a&lt;/code&gt;参数可以展示全部的分支，包括远程分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;在分支前，指明了现在所在的分支是&lt;code&gt;dev/pzqu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;切换分支&quot;&gt;切换分支&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git checkout -b dev/pzqu2
Switched to a new branch 'dev/pzqu2'

$ git branch
  dev/pzqu
* dev/pzqu2
  master

$ git checkout dev/pzqu
Switched to branch 'dev/pzqu'
Your branch is up to date with 'origin/master'.

$ git branch
* dev/pzqu
  dev/pzqu2
  master&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基于当前分支创建了一个新的分支并自动切换过去&lt;code&gt;dev/pzqu2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout 已存在的分支名&lt;/code&gt;切换分支回到&lt;code&gt;dev/pzqu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;删除分支&quot;&gt;删除分支&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git branch
* dev/pzqu
  dev/pzqu2
  master
  
$ git branch -D dev/pzqu2
Deleted branch dev/pzqu2 (was 7c9be37).

$ git branch
* dev/pzqu
  master
  &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;位于&lt;code&gt;dev/pzqu&lt;/code&gt;，删除了&lt;code&gt;dev/pzqu2&lt;/code&gt;分支&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;合并冲突&quot;&gt;合并冲突&lt;/h2&gt;
&lt;h3 id=&quot;合并同一个分支的冲突常见&quot;&gt;合并同一个分支的冲突（常见）&lt;/h3&gt;
&lt;p&gt;为了产生一个冲突，我在另一个地方向远程仓库提交了代码，更改&lt;code&gt;share_file.txt&lt;/code&gt;文件，加了一行内容&lt;code&gt;tom add for merge&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;本地修改同一个文件加了一行&lt;code&gt;pzqu add for merge&lt;/code&gt;，并提交到本地，这样一来，本地和远程仓库的同一个文件就不一样了，一会拉代码一定会产生一个冲突。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/t7ydr9gb6e.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般rebase或pull冲突的时候，都会出现提示，然后git status会出现上图图示&lt;/li&gt;
&lt;li&gt;这个时候不可以进行任何分支切换和commit操作，按照他提示进行处理&lt;/li&gt;
&lt;li&gt;git status提示哪个文件是都被修改的，both modified，然后使用编辑器修改该文件，解决冲突&lt;/li&gt;
&lt;li&gt;解决完成后，git add 添加该冲突文件&lt;/li&gt;
&lt;li&gt;git rebase --continue，并更新commit message，完成整个rebase流程 我们来看看这个冲突的文件：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/3rwxib9u0s.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;p&gt;Git用&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;，&lt;code&gt;=======&lt;/code&gt;，&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;标记出不同分支的内容，我们修改如下后保存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/uve6hug0dz.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt;再&lt;code&gt;git rebase --continue&lt;/code&gt;后完成rebase，效果如下，再&lt;code&gt;push&lt;/code&gt;的远程仓库即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/2cr81n6tl8.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;h3 id=&quot;合并不同分支的代码产生冲突&quot;&gt;合并不同分支的代码产生冲突&lt;/h3&gt;
&lt;p&gt;关于怎么创建分支与切换分支见创建分支和切换分支,这里只讨论合并时产生的冲突的情况，我们已经基于&lt;code&gt;master&lt;/code&gt;分支创建了一个&lt;code&gt;dev/pzqu&lt;/code&gt;分支&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git branch
* dev/pzqu
  master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换到&lt;code&gt;master&lt;/code&gt;分支，加一行&lt;code&gt;master add for merge&lt;/code&gt;并提交，文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ cat share_file.txt
tom add
tom modify
tom add for merge
pzqu add for merge
master add for merge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换到&lt;code&gt;dev/pzqu&lt;/code&gt;分支，向&lt;code&gt;share_file.txt&lt;/code&gt;加入一行&lt;code&gt;dev/pzqu add for merge&lt;/code&gt;并提交，现在&lt;code&gt;share_file.txt&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ cat share_file.txt
tom add
tom modify
tom add for merge
pzqu add for merge
dev/pzqu add for merge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在两个分支的同一个文件内容不一样了，现在我们在&lt;code&gt;dev/pzqu&lt;/code&gt;分支上进行合并：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git merge master
Auto-merging share_file.txt
CONFLICT (content): Merge conflict in share_file.txt
Automatic merge failed; fix conflicts and then commit the result.

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:17:31] C:1
$ git status
On branch dev/pzqu
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution)

    both modified:   share_file.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)

$ cat share_file.txt
tom add
tom modify
tom add for merge
pzqu add for merge
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
dev/pzqu add for merge
=======
master add for merge
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上图出现了一个冲突，是我们意料之中的，修改&lt;code&gt;share_file.txt&lt;/code&gt;文件，解决此冲突：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ cat share_file.txt
tom add
tom modify
tom add for merge
pzqu add for merge
dev/pzqu add for merge
master add for merge

$ git add share_file.txt

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu x [11:22:40]
$ git commit -m &quot;[*]merge master to dev/pzqu&quot;
[dev/pzqu d9e018e] [*]merge master to dev/pzqu

# pzqu @ pzqu-pc in ~/Documents/code/test/git_test on git:dev/pzqu o [11:23:00]
$ git status
On branch dev/pzqu
Your branch is ahead of 'origin/master' by 3 commits.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;冲突解决也提交了，看看我们现在的分支内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/a8m1ydt8t3.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;p&gt;上图我们可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;master&lt;/code&gt;分支比远程&lt;code&gt;origin/master&lt;/code&gt;分支多一次提交，&lt;code&gt;dev/pzqu&lt;/code&gt;分支由于是基于&lt;code&gt;origin/master&lt;/code&gt;分支，合并了&lt;code&gt;master&lt;/code&gt;分支的提交和当前&lt;code&gt;dev/pzqu&lt;/code&gt;分支的提交，超出本地&lt;code&gt;master&lt;/code&gt;两个提交，致此我们把&lt;code&gt;master&lt;/code&gt;合并到&lt;code&gt;dev/pzqu&lt;/code&gt;的操作就完成了。&lt;/li&gt;
&lt;li&gt;通常我们开一个新的开发分支是为了在自己的分支上写代码，方便提交也不会把主线弄乱，现在我们用同样的方法将&lt;code&gt;dev/pzqu&lt;/code&gt;合并到&lt;code&gt;master&lt;/code&gt;分支，然后把两个分支都提交到远程。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

$ git merge dev/pzqu
Updating 58f047a..d9e018e
Fast-forward
 share_file.txt | 1 +
 1 file changed, 1 insertion(+)

$ git push origin master
Total 0 (delta 0), reused 0 (delta 0)
To github.com:pzqu/git_test.git
   7c9be37..d9e018e  master -&amp;gt; master
   
$ git push origin dev/pzqu
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 887 bytes | 887.00 KiB/s, done.
Total 9 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
remote:
remote: Create a pull request for 'dev/pzqu' on GitHub by visiting:
remote:      https://github.com/pzqu/git_test/pull/new/dev/pzqu
remote:
To github.com:pzqu/git_test.git
 * [new branch]      dev/pzqu -&amp;gt; dev/pzqu&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;切换到&lt;code&gt;master&lt;/code&gt;分支&lt;/li&gt;
&lt;li&gt;合并&lt;code&gt;dev/pzqu&lt;/code&gt;到&lt;code&gt;master&lt;/code&gt;分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;推到远程仓库&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;dev/pzqu&lt;/code&gt;要保留，就可以推送到远程仓库。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/3097464/a0mebixdpe.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;upload successful&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现在我们可以看到全部的分支都在一起了，强迫症都舒服了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;暂存代码保存现场&quot;&gt;暂存代码保存现场&lt;/h2&gt;
&lt;p&gt;这种情况一般是出现在你正在完成一个功能，但是忽然线上发现了一个Bug，必须马上开一个新的分支来修复bug，但是现在的功能没写完不打算提交(commit)，现在怎么办？？不用怕暂存代码来帮助你。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git status
On branch dev/pzqu
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   need_stash.txt
    modified:   share_file.txt

$ git stash
Saved working directory and index state WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu

$ git stash list
stash@{0}: WIP on dev/pzqu: d9e018e [*]merge master to dev/pzqu

$ git status
On branch dev/pzqu
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean


//省略操作：去创建一个Bug分支，修复他并完成与主线的合并，删除Bug分支。
//省略操作：切回来当前分支继续开发
//下面来恢复现场


$ git stash apply stash@{0}
On branch dev/pzqu
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   need_stash.txt

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   share_file.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;status&lt;/code&gt;查看到有2个文件修改没有提交&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stash&lt;/code&gt;把修改放到暂存区，并生成一个id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stash list&lt;/code&gt;列出暂存区所有内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stash apply&lt;/code&gt;重新把暂存区内容放到本地&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的&lt;code&gt;stash apply&lt;/code&gt;成功的把暂存区的一次暂存恢复到了本地，但是暂存区还有会保存这次暂存，如果想删除这次暂存要用&lt;code&gt;git stash drop&lt;/code&gt;来删除；也可以用&lt;code&gt;git stash pop&lt;/code&gt;，恢复最后一次暂存的同时把stash内容也删了。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ git stash drop stash@{0}
Dropped stash@{0} (bfdc065df8adc44c8b69fa6826e75c5991e6cad0)

$ git stash list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，暂存区清干净了。&lt;/p&gt;
&lt;p&gt;​ 注意：要放到暂存区的文件一定要先通过git add加到index&lt;/p&gt;

&lt;p&gt;本文阅读结束以后，我们学会了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Git的基本概念，知道git的作用、历史；学会安装配置Git，使用Git创建项目托管以及工作区和暂存区的概念&lt;/li&gt;
&lt;li&gt;学会Git的本地操作，提交、拉代码、创建切换删除分支操作，&lt;/li&gt;
&lt;li&gt;多人合作时的代码版本控制，学会了不同情况下的合并冲突、暂存代码操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git常用操作（下）我计划给大家介绍以下点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后悔药-各种后悔操作（撤消commit,回滚，回退远程仓库等）&lt;/li&gt;
&lt;li&gt;哎呀，提交的时候漏了文件&lt;/li&gt;
&lt;li&gt;tag操作&lt;/li&gt;
&lt;li&gt;git忽略不想提交的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上，git日常用到的命令是 diff show fetch rebase pull push checkout commit status 等，这些命令都不会导致代码丢失，假如害怕代码丢失，可以预先commit一次，再进行修改，但切记&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不可使用自己不熟悉的命令 任何命令，不要加上-f的强制参数，否则可能导致代码丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建议多使用命令行，不要使用图形界面操作&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs&quot;&gt;git官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰的官方网站-git篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ihaoming.top/archives/c9c37af.html#more&quot;&gt;hexo博客部署到vps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 03:43:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：工程师小熊 摘要：用了很久的Git和svn,由于总是眼高手低，没能静下心来写这些程序员日常开发最常用的知识点。现在准备开一个专题，专门来总结一下版本控制工具，让我们从git开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10494832.html</dc:identifier>
</item>
<item>
<title>tomcat 启动速度慢背后的真相 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/10494620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/10494620.html</guid>
<description>&lt;h2 id=&quot;tomcat-启动慢&quot;&gt;1. tomcat 启动慢&lt;/h2&gt;
&lt;p&gt;在线上环境中，我们经常会遇到类似的问题，就是tomcat 启动比较慢，查看内存和cpu,io都是正常的，但是启动很慢，有的时候长达几分钟，这到底是什么原因导致的。&lt;/p&gt;
&lt;h3 id=&quot;tomcat-获取随机值阻塞&quot;&gt;1.1 tomcat 获取随机值阻塞&lt;/h3&gt;
&lt;p&gt;​ tomcat的启动需要产生session id，这个产生需要通过&lt;code&gt;java.security.SecureRandom&lt;/code&gt;生成随机数来实现，随机数算法使用的是”SHA1PRNG”，但这个算法依赖于操作系统的提供的随机数据，在linux系统中，这个值又依赖于/dev/random 和/dev/urandom&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;/dev/random :阻塞型，读取它就会产生随机数据，但该数据取决于熵池噪声，当熵池空了，对/dev/random 的读操作也将会被阻塞。
/dev/urandom: 非阻塞的随机数产生器，它会重复使用熵池中的数据以产生伪随机数据。这表示对/dev/urandom的读取操作不会产生阻塞，但其输出的熵可能小于/dev/random的。它可以作为生成较低强度密码的伪随机数生成器，不建议用于生成高强度长期密码。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过查看java.security 文件，(我的java版本是1.8.0_131) 发现依赖的是/dev/random&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/tomcat%E4%BC%98%E5%8C%96/1552010227451.png&quot; alt=&quot;1552010227451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tomcat 启动产生session id 最终依赖的是/dev/random ，/dev/random 又依赖于熵池，&lt;/p&gt;
&lt;p&gt;对于熵池，百度百科这样写到&lt;/p&gt;
&lt;pre class=&quot;bahs&quot;&gt;
&lt;code&gt;     Linux内核采用熵来描述数据的随机性。熵（entropy）是描述系统混乱无序程度的物理量，一个系统的熵越大则说明该系统的有序性越差，即不确定性越大。在信息学中，熵被用来表征一个符号或系统的不确定性，熵越大，表明系统所含有用信息量越少，不确定度越大。计算机本身是可预测的系统，因此，用计算机算法不可能产生真正的随机数。但是机器的环境中充满了各种各样的噪声，如硬件设备发生中断的时间，用户点击鼠标的时间间隔等是完全随机的，事先无法预测。Linux内核实现的随机数产生器正是利用系统中的这些随机噪声来产生高质量随机数序列。内核维护了一个熵池用来收集来自设备驱动程序和其它来源的环境噪音。理论上，熵池中的数据是完全随机的，可以实现产生真随机数序列。为跟踪熵池中数据的随机性，内核在将数据加入池的时候将估算数据的随机性，这个过程称作熵估算。熵估算值描述池中包含的随机数位数，其值越大表示池中数据的随机性越好。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何查看熵池 的大小,文件 /proc/sys/kernel/random/entropy_avail 保存着 熵池的大小。/proc/sys/kernel/random/poolsize 保存着熵池的最大容量，单位都是bit。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@haha cwd]# cat  /proc/sys/kernel/random/entropy_avail
146&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结 tomcat 启动慢的原因是随机数产生遭到阻塞，遭到阻塞的原因是 熵池大小 。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更换产生随机数的源，(也是tomcat的官方文档的启动比较慢的解决办法)&lt;/li&gt;
&lt;li&gt;增大熵池 的值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;1 . 更换产生随机数的源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://wiki.apache.org/tomcat/HowTo/FasterStartUp&quot;&gt;官方文档链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ 因为/dev/urandom 是非阻塞的随机数产生器，所以我们可以从这边获取，但是生产的随机数的随机性比较低。我们可以在 我们的tomcat启动脚本(catalina.sh)里面添加&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;JAVA_OPTS=&quot;$JAVA_OPTS -Djava.security.egd=file:/dev/./urandom&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者是更改java的java.security 文件，将securerandom.source=file:/dev/random&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;securerandom.source=file:/dev/./urandom&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 注意一下，为什么我们这里使用的路径是&quot;/dev/./urandom&quot;,而不是 &quot;/dev/urandom&quot;,是因为在java 8之前的版本设置了/dev/urandom ，但是实际还是使用/dev/random，设置为&quot;/dev/./urandom&quot;才能正常使用 &quot;/dev/urandom&quot; ， 这个bug在java8版本已经修复了，如果你是java7版本的话，需要按照上面设置，java8的话可以不用加 &quot;./&quot;。&lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6202721&quot;&gt;官方bug链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 .增大熵池 的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要增大熵池 的值首先得你的cpu支持DRNG 特性， 如何查看我们的服务器的是否支持DRNG特性？&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cat /proc/cpuinfo | grep rdrand&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不支持的话，那么就只能通过上面的第一种方法来解决了&lt;/p&gt;
&lt;p&gt;安装rngd服务(&lt;a href=&quot;https://wiki.archlinux.org/index.php/Rng-tools&quot;&gt;关于rngd服务的介绍&lt;/a&gt;)&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yum -y install rng-tools
systemctl enable   rngd
systemctl start  rngd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们进行查看我们的熵池 的值,会发现变大了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; cat  /proc/sys/kernel/random/entropy_avail&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们启动tomcat 会发现启动速度快很多。&lt;/p&gt;
&lt;h3 id=&quot;tomcat-需要部署的web应用程序太多&quot;&gt;1.2 tomcat 需要部署的web应用程序太多&lt;/h3&gt;
&lt;p&gt;​ 有的时候，我们tomcat启动比较慢是因为它需要部署的web应用程序太多，但是其中有些应用程序是我们不需要的，比如在webapps下的 doc 、example、ROOT 等等，我们可以将我们不需要的webapps删除，然后再进行发布，这些不需要的web，不仅会占用我们的资源，还有可能是入侵者的入侵对象。如果我们想并行启动多个web应用程序，我们可以Host 的属性 startStopThreads 值设置大于1 ，但这也取决于我们的服务器是不是多核的。如果是多核的建议调大 startStopThreads 的值，但不超过内核数。&lt;/p&gt;
&lt;h3 id=&quot;tomcat启动内存不足&quot;&gt;1.3 tomcat启动内存不足&lt;/h3&gt;
&lt;p&gt;​ 如果是项目比较大的话，我们使用默认的参数去启动的tomcat是很有可能内存不足的，我们需要设置JVM，将内存调整，JVM 的最大值和最小值建议是不要相差太大(最好一致.)&lt;/p&gt;
&lt;p&gt;在启动脚本catalina.sh加上：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;JAVA_OPTS='-server -Xms1024m -Xmx1024m'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的内存大小，根据业务调整。&lt;/p&gt;
&lt;p&gt;以上就是解决tomcat 启动慢的问题和解决方案，可根据自己的项目情况进行使用。后面也会有一篇tomcat 调优的文章，请大家点波关注哦。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 03:35:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>1. tomcat 启动慢 在线上环境中，我们经常会遇到类似的问题，就是tomcat 启动比较慢，查看内存和cpu,io都是正常的，但是启动很慢，有的时候长达几分钟，这到底是什么原因导致的。 1.1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/operationhome/p/10494620.html</dc:identifier>
</item>
<item>
<title>Redux学习之解读applyMiddleware源码深入middleware工作机制 - 林璡</title>
<link>http://www.cnblogs.com/fe-linjin/p/10494763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fe-linjin/p/10494763.html</guid>
<description>&lt;h2 id=&quot;随笔前言&quot;&gt;随笔前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/fe-linjin/p/10457089.html&quot;&gt;上一周的学习&lt;/a&gt;中，我们熟悉了如何通过redux去管理数据，而在这一节中，我们将一起深入到redux的知识中学习。&lt;/p&gt;
&lt;h2 id=&quot;首先谈一谈为什么要用到middleware&quot;&gt;首先谈一谈为什么要用到middleware&lt;/h2&gt;
&lt;p&gt;我们知道在一个简单的数据流场景中，点击一个button后，在回调中分发一个action，reducer收到action后就会更新state并通知view重新渲染，如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1616136/201903/1616136-20190308105637811-1254705826.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果需要打印每一个action来调试，就得去改dispatch或者reducer实现，使其具备打印功能，那么该如何做？因此，需要中间件的加入。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1616136/201903/1616136-20190308105739321-141962987.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了应用middleware后的Redux处理事件的逻辑，每个middleware都可以处理一个相对独立的事物，通过串联不同的middleware实现变化多样的功能！&lt;/p&gt;
&lt;h4 id=&quot;小结redux中的reducer更加的专注于转化逻辑所以middleware是为了增强dispatch而出现的&quot;&gt;小结：Redux中的reducer更加的专注于转化逻辑，所以middleware是为了增强dispatch而出现的。&lt;/h4&gt;
&lt;h2 id=&quot;middleware是如何工作的&quot;&gt;middleware是如何工作的&lt;/h2&gt;
&lt;p&gt;Redux提供了一个applyMiddleware方法来加载middleware，它的源码是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import compose from './compose';

export default function applyMiddleware(...middlewares) {
    return (next) =&amp;gt; (reducer, initalState) =&amp;gt; {
        let store = next(reducer, initalState);
        let dispatch = store.dispatch;
        let chain = [];

        var middlewareAPI = {
            getState: store.getState,
            dispatch: (action) =&amp;gt; dispatch(action)
        };
        chain = middlewares.map( middleware =&amp;gt; middleware(middlewareAPI));
        dispatch = compose(...chain)(store.dispatch);

        return {
            ...store,
            dispatch
        };

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再上一个logger middleware的源码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default store =&amp;gt; next =&amp;gt; action =&amp;gt; {
    console.log('dispatch:', action);
    next(action);
    console.log('finish:', action);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然看到“源码”的那两个字的时候，内心一万只草什么马奔过，但是一看到代码这么精简，这么优美，那就初读一下源码把。&lt;br/&gt;然后&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1616136/201903/1616136-20190308113019378-1528599879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就开始解读上面源码&lt;/p&gt;
&lt;h2 id=&quot;深入解析middleware运行原理&quot;&gt;深入解析middleware运行原理&lt;/h2&gt;
&lt;h3 id=&quot;函数式编程思想设计&quot;&gt;1. 函数式编程思想设计&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;middleware是一个层层包裹的匿名函数，这其实是函数式编程的currying（Currying就是把一个带有多个参数的函数拆分成一系列带部分参数的函数）。那么applyMiddleware会对logger这个middleware进行层层的调用，动态的将store和next参数赋值。

那么currying的middleware结构有什么好处呢？

1.1  易串联： currying函数具有延迟执行的特性，通过不断currying形成的middleware可以积累参数，再配合组合（compose）的方式，这样很容易就形成pipeline来处理数据流
1.2  共享store：在applyMiddleware执行的过程当中，store还是旧的，但是因为闭包的存在，applyMiddleware完成之后，所有的middleware内部拿到的store是最新的且是相同的。

并且applyMiddleware的结构也是一个多层currying的函数，借助compose，applyMiddleware可以用来和其他插件加强createStore函数&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;给middleware分发store&quot;&gt;2. 给middleware分发store&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;通过如下方式创建一个普通的store
```
let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);
```

上述代码执行完后，applyMiddleware方法陆续获得了3个参数，第一个是middlewares数组[mid1, mid2, mid3，...]，第二个是Redux原生的createStore方法，最后一个是reducer。然后我们可以看到applyMiddleware利用createStore和reducer创建了一个store。而store的getState方法和dispatch方法又分别被直接和间接地赋值给middlewareAPI变量的store

```
const middleAPI = {
    getState: store.getState,
    dispatch: (action) =&amp;gt; dispatch(action)
}
chain = middlewares.map(middle =&amp;gt; middleware(middlewareAPI))
```

然后，每个middleware带着middlewareAPI这个参数分别执行一遍，执行后，得到一个chain数组[f1, f2, ..., fx, ..., fn]，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数多可以访问相同的store，即middlewareAPI.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组合串联middleware&quot;&gt;3.组合串联middleware&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;这一层只有一行代码，确是applyMiddleware精华所在。
```
dispatch = compose(...chain)(store.dispatch);
```

其中，compose是函数式编程中的组合，它将chain中的所有匿名函数[f1, f2, ..., fn]组装成一个新的函数，即新的dispatch。当新的dispatch执行的时候，[f1, f2, ...]会从右到左依次执行。Redux中compose的实现是这样的，当然实现的方式不唯一。
```
function compose(...funs) {
    return arg =&amp;gt; funcs.reduceRight( (compose, f) =&amp;gt; f(composed), arg)
}
```
compose(...funcs)返回的是一个匿名函数，其中funcs就是chain数组。当调用reduceRight时，依次从funcs数组的右端取一个函数f(x)拿来执行，f(x)的参数composed就是前一次f(x+1)执行的结果，而第一次执行的f(n)n代表chain的长度，它的参数arg就是store.dispatch。

因此，当compose执行完后，我们得到的dispatch是这样的：

假设n=3：
dispatch = f1(f2(f3(store.dispatch)));

这时调用dispatch，每一个middleware就会依次执行了。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在middleware中调用dispatch会发生什么呢&quot;&gt;4.在middleware中调用dispatch会发生什么呢？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;经过compose后，所有的middleware就算是已经串联起来了。

***那么问题来了？***
在分发store时，我们有说到每个middleware都可以访问store，也就是我们说的通过middlewareAPI这个变量去拿到dispatch属性进行操作。那么如果在middleware中调用store.dispatch会如何？和调用next()有什么区别？

先上一波代码：
```
//next()
const logger = store =&amp;gt; next =&amp;gt; action =&amp;gt; {
    console.log('dispatch:', action);
    next(action);
    console.log('finish:', action );
}

//store.dispatch(action);
const logger = store =&amp;gt; next =&amp;gt; action {
    console.log('dispatch:', action);
    store.dispatch(action);
    console.log('finishL:', action);
}
```

在分发store的时候，我们有说过：midddleware中的store的dispatch通过匿名函数的方式和最终compose结束后的新dispatch保持一致，所以，在middleware中调用store.dispatch()和在其他任何地方调用其实效果是一样的。

而如果在middleware中调用next()，效果是进入下一个middleware中。

具体如下两个图1和图2所示：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1616136/201903/1616136-20190308113245540-646662315.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如图1所示，正常情况下，当我们去分发一个action时，middleware会通过next(action)一层层处理和传递action直到redux原生的dispatch。如果某个middleware中使用了store.dispatch(action)来分发action，就会发生如图2所示的情况。这就相当于是又从头开始了。

***那么问题又来了***，假如这个middleware一直简单粗暴地调用store.dispatch(action)，就会形成一个无限循环了，那么store.dispatch(action)的用武之地到底在哪里呢？

假如我们需要发送一个异步请求到服务端获取数据，成功后弹出个message，这里我们通常会用到reduce-thunk这个插件。

const thunk = store =&amp;gt; next =&amp;gt; action =&amp;gt; 
    typeof action === 'function' ? 
        action(store.dispatch, store.getState) :
        next(action)
        
代码很清晰，就是会先判断你dispatch过来的action是不是一个function，如果是则执行action，如果不是则传递到下一个middleware。因此，我们可以这样设计action：

```
const getMessage = (dispatch, getState) =&amp;gt; {
    const url = 'http://xxx.json';
    Axios.get(url)
      .then( res =&amp;gt; {
          dispatch({
              type: 'SHOW_MESSAGE',
              message: res.data.data
          })
      })
      .catch( err =&amp;gt; {
          dispatch({
              type: 'ERR_GET',
              message: 'error'
          })
      }) 
}
```

如上所示，只要在应用中去调用store.dispatch(getThenShow), redux-thunk这个middleware接收到后就会去执行getMessage方法。getMessage会先请求数据，根据请求结果去做相对应的分发action。这这里的dispatch就是通过redux-thunk这个middleware传递进来的。

总结：在middleware中使用dispatch的场景一般是接受到一个定向action，而这个action又并不希望到达原生的分发action，往往用在异步请求的需求里面。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;----------------作者的话：其实看了挺多遍，在脑海中构建整个middleware流程，再结合上周学习Redux时的Demo才渐渐的知其形，还需要多在实践中会其神！--------------&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 03:34:00 +0000</pubDate>
<dc:creator>林璡</dc:creator>
<og:description>随笔前言 在 '上一周的学习' 中，我们熟悉了如何通过redux去管理数据，而在这一节中，我们将一起深入到redux的知识中学习。 首先谈一谈为什么要用到middleware 我们知道在一个简单的数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fe-linjin/p/10494763.html</dc:identifier>
</item>
<item>
<title>《深入理解Java虚拟机》-----Java内存区域与内存溢出异常——Java高级开发必须懂的 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10488208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10488208.html</guid>
<description>&lt;h2&gt;2.1 概述&lt;/h2&gt;
&lt;p&gt;对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们即是拥有最高权力的皇帝又是执行最基础工作的劳动人民——拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。&lt;/p&gt;
&lt;p&gt;对于Java程序员来说，不需要在为每一个new操作去写配对的delete/free，不容易出现内容泄漏和内存溢出错误，看起来由JVM管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了JVM，一旦出现泄漏和溢出，如果不了解JVM是怎样使用内存的，那排查错误将会是一件非常困难的事情。&lt;/p&gt;
&lt;h2 id=&quot;22-运行时数据区域&quot;&gt;2.2 运行时数据区域&lt;/h2&gt;
&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域 &lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201903/1168971-20190307110035509-308623185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;221-程序计数器&quot;&gt;2.2.1 程序计数器&lt;/h3&gt;
&lt;p&gt;程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&lt;/p&gt;
&lt;p&gt;由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。&lt;/p&gt;
&lt;p&gt;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。&lt;/p&gt;
&lt;h3 id=&quot;222-java虚拟机栈&quot;&gt;2.2.2 Java虚拟机栈&lt;/h3&gt;
&lt;p&gt;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。&lt;/p&gt;
&lt;p&gt;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。&lt;/p&gt;
&lt;p&gt;其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。&lt;/p&gt;
&lt;p&gt;在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;223-本地方法栈&quot;&gt;2.2.3 本地方法栈&lt;/h3&gt;
&lt;p&gt;本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;224-java堆&quot;&gt;2.2.4 Java堆&lt;/h3&gt;
&lt;p&gt;对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。&lt;/p&gt;
&lt;p&gt;Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将是第3章的主题。&lt;/p&gt;
&lt;p&gt;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;225-方法区&quot;&gt;2.2.5 方法区&lt;/h3&gt;
&lt;p&gt;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、方法、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。&lt;/p&gt;
&lt;p&gt;对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern()）会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。&lt;/p&gt;
&lt;p&gt;Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;226-运行时常量池&quot;&gt;2.2.6 运行时常量池&lt;/h3&gt;
&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。&lt;/p&gt;
&lt;p&gt;Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。&lt;/p&gt;
&lt;p&gt;运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。&lt;/p&gt;
&lt;p&gt;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h3 id=&quot;227-直接内存&quot;&gt;2.2.7 直接内存&lt;/h3&gt;
&lt;p&gt;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。&lt;/p&gt;
&lt;p&gt;在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。&lt;/p&gt;
&lt;p&gt;显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。&lt;/p&gt;
&lt;h2 id=&quot;23-hotspot虚拟机对象探秘&quot;&gt;2.3 HotSpot虚拟机对象探秘&lt;/h2&gt;
&lt;p&gt;介绍完Java虚拟机的运行时数据区之后，我们大致知道了虚拟机内存的概况，读者了解了内存中放了些什么后，也许就会想更进一步了解这些虚拟机内存中的数据的其他细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样涉及细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。基于实用优先的原则，笔者以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。&lt;/p&gt;
&lt;h3 id=&quot;231-对象的创建&quot;&gt;2.3.1 对象的创建&lt;/h3&gt;
&lt;p&gt;Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？&lt;/p&gt;
&lt;p&gt;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，本书第7章将探讨这部分内容的细节。&lt;/p&gt;
&lt;p&gt;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为&lt;span&gt;“指针碰撞”&lt;/span&gt;（Bump the Pointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为&lt;span&gt;“空闲列表”&lt;/span&gt;（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。&lt;/p&gt;
&lt;p&gt;除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。&lt;/p&gt;
&lt;p&gt;内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。&lt;/p&gt;
&lt;p&gt;接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后再做详细介绍。&lt;/p&gt;
&lt;p&gt;在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。&lt;/p&gt;
&lt;p&gt;下面的代码清单是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少有机会实际使用，因为大部分平台上都使用模板解释器；当代码通过JIT编译器执行时差异就更大了。不过，这段代码用于了解HotSpot的运作过程是没有什么问题的）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保常量池中存放的是已解释的类&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(!constants-&amp;gt;&lt;span&gt;tag_at(index).is_unresolved_klass()){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断言确保是klassOop和instanceKlassOop（这部分下一节介绍）&lt;/span&gt;
oop entry=（klassOop）*constants-&lt;span&gt;＞obj_at_addr（index）;
&lt;/span&gt;&lt;span&gt;assert&lt;/span&gt;（entry-＞is_klass（），&quot;Should be resolved klass&quot;&lt;span&gt;）;
klassOop k_entry&lt;/span&gt;=&lt;span&gt;（klassOop）entry;
&lt;/span&gt;&lt;span&gt;assert&lt;/span&gt;（k_entry-＞klass_part（）-＞oop_is_instance（），&quot;Should be instanceKlass&quot;&lt;span&gt;）;
instanceKlass &lt;/span&gt;* ik=（instanceKlass*）k_entry-&lt;span&gt;＞klass_part（）;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保对象所属类型已经经过初始化阶段&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(ik-&amp;gt;is_initialized()&amp;amp;&amp;amp;ik-&amp;gt;&lt;span&gt;can_be_fastpath_allocated())
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取对象长度&lt;/span&gt;
size_t obj_size=ik-&amp;gt;&lt;span&gt;size_helper();
oop result&lt;/span&gt;=&lt;span&gt;NULL；
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录是否需要将对象所有字段置零值&lt;/span&gt;
bool need_zero=!&lt;span&gt;ZeroTLAB；
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否在TLAB中分配对象&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(UseTLAB){
result&lt;/span&gt;=（oop）THREAD-&amp;gt;&lt;span&gt;tlab().allocate(obj_size);
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;（result==&lt;span&gt;NULL）{
need_zero&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接在eden中分配对象&lt;/span&gt;
&lt;span&gt;retry：
HeapWord &lt;/span&gt;* compare_to=*Universe：heap（）-&lt;span&gt;＞top_addr（）；
HeapWord &lt;/span&gt;* new_top=compare_to+&lt;span&gt;obj_size；
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，如果并发失败，
转到retry中重试，直至成功分配为止&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;（new_top＜=*Universe：heap（）-&lt;span&gt;＞end_addr（））{
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;（Atomic：cmpxchg_ptr（new_top,Universe：heap（）-＞top_addr（），compare_to）！=&lt;span&gt;compare_to）{
&lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; retry；
}
result&lt;/span&gt;=&lt;span&gt;（oop）compare_to；
}
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;（result！=&lt;span&gt;NULL）{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要，则为对象初始化零值&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;（need_zero）{
HeapWord &lt;/span&gt;* to_zero=（HeapWord*）result+sizeof（oopDesc）/&lt;span&gt;oopSize；
obj_size&lt;/span&gt;-=sizeof（oopDesc）/&lt;span&gt;oopSize；
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;（obj_size＞0&lt;span&gt;）{
memset（to_zero，&lt;/span&gt;0，obj_size *&lt;span&gt; HeapWordSize）；
}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据是否启用偏向锁来设置对象头信息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;（UseBiasedLocking）{
result&lt;/span&gt;-＞set_mark（ik-&lt;span&gt;＞prototype_header（））；
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
result&lt;/span&gt;-&lt;span&gt;＞set_mark（markOopDesc：prototype（））；
}r
esult&lt;/span&gt;-＞set_klass_gap（0&lt;span&gt;）；
result&lt;/span&gt;-&lt;span&gt;＞set_klass（k_entry）；
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对象引用入栈，继续执行下一条指令&lt;/span&gt;
SET_STACK_OBJECT（result，0&lt;span&gt;）；
UPDATE_PC_AND_TOS_AND_CONTINUE（&lt;/span&gt;3，1&lt;span&gt;）；
}
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;232-对象的内存布局&quot;&gt;2.3.2 对象的内存布局&lt;/h3&gt;
&lt;p&gt;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;
&lt;p&gt;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20161209164720457&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。&lt;/p&gt;
&lt;p&gt;另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 &lt;br/&gt;代码清单为HotSpot虚拟机markOop.cpp中的代码（注释）片段，它描述了32bit下MarkWord的存储状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Bit-format of an object header(most significant first,big endian layout below):
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;32 bits:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash：25------------&amp;gt;|age：4 biased_lock：1 lock：2（normal object）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JavaThread*：23 epoch：2 age：4 biased_lock：1 lock：2（biased object）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size：32------------------------------------------&amp;gt;|（CMS free block）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;PromotedObject*：29----------&amp;gt;|promo_bits：3-----&amp;gt;|（CMS promoted object）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。&lt;/p&gt;
&lt;p&gt;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。&lt;/p&gt;
&lt;h3 id=&quot;233-对象的访问定位&quot;&gt;2.3.3 对象的访问定位&lt;/h3&gt;
&lt;p&gt;建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有&lt;span&gt;使用句柄&lt;/span&gt;和&lt;span&gt;直接指针&lt;/span&gt;两种。&lt;/p&gt;
&lt;p&gt;如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20161209170908358&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图所示。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20161209170949905&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。&lt;/p&gt;
&lt;p&gt;使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。&lt;/p&gt;
&lt;h2 id=&quot;24-实战outofmemoryerror异常&quot;&gt;2.4 实战：OutOfMemoryError异常&lt;/h2&gt;
&lt;p&gt;在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（下文称OOM）异常的可能，本节将通过若干实例来验证异常发生的场景（代码清单2-3～代码清单2-9的几段简单代码），并且会初步介绍几个与内存相关的 &lt;br/&gt;最基本的虚拟机参数。&lt;/p&gt;
&lt;p&gt;本节内容的目的有两个：第一，通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容；第二，希望读者在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。&lt;/p&gt;
&lt;p&gt;下文代码的开头都注释了执行时所需要设置的虚拟机启动参数（注释中“VM Args”后面跟着的参数），这些参数对实验的结果有直接影响，读者调试代码的时候千万不要忽略。如果读者使用控制台命令来执行程序，那直接跟在Java命令之后书写就可以。如果读者使用Eclipse IDE，则可以参考图在Debug/Run页签中的设置。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20161213132850439&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下文的代码都是基于Sun公司的HotSpot虚拟机运行的，对于不同公司的不同版本的虚拟机，参数和程序运行的结果可能会有所差别。&lt;/p&gt;
&lt;h3 id=&quot;241-java堆溢出&quot;&gt;2.4.1 Java堆溢出&lt;/h3&gt;
&lt;p&gt;Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。&lt;/p&gt;
&lt;p&gt;代码清单2-3中代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。&lt;/p&gt;
&lt;p&gt;代码清单2-3　Java堆内存溢出异常测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HeapOOM {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OOMObject {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;OOMObject&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OOMObject&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OOMObject());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;java.lang.OutOfMemoryError :Java heap space
Dumping heap to java_pid3404.hprof.
Heap dump file created[&lt;/span&gt;22045981 bytes in 0.663 secs]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。&lt;/p&gt;
&lt;p&gt;要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。下图显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20161213133159066&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。&lt;/p&gt;
&lt;p&gt;如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。&lt;/p&gt;
&lt;p&gt;以上是处理Java堆内存问题的简单思路，处理这些问题所需要的知识、工具与经验是后面3章的主题。&lt;/p&gt;
&lt;h3 id=&quot;242-虚拟机栈和本地方法栈溢出&quot;&gt;2.4.2 虚拟机栈和本地方法栈溢出&lt;/h3&gt;
&lt;p&gt;由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。&lt;/p&gt;
&lt;p&gt;关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。&lt;/li&gt;
&lt;li&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。&lt;/p&gt;
&lt;p&gt;在笔者的实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，测试代码如代码清单2-4所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。&lt;/li&gt;
&lt;li&gt;定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码清单2-4　虚拟机栈和本地方法栈OOM测试（仅作为第1点测试程序）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args：-Xss128k
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavaVMStackSOF {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; stackLength = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stackLeak() {
        stackLength&lt;/span&gt;++&lt;span&gt;;
        stackLeak();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        JavaVMStackSOF oom &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaVMStackSOF();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            oom.stackLeak();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            System.out.println(&lt;/span&gt;&quot;stack length:&quot; +&lt;span&gt; oom.stackLength);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
stack length :2402&lt;span&gt;
Exception in thread&lt;/span&gt;&quot;main&quot;&lt;span&gt;java.lang.StackOverflowError
at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.java :&lt;/span&gt;20 ) at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.java :21 ) at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.iava :21&lt;span&gt; ) 
.....后续异常堆栈信息省略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。&lt;/p&gt;
&lt;p&gt;如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。&lt;/p&gt;
&lt;p&gt;其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以 &lt;br/&gt;建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。&lt;/p&gt;
&lt;p&gt;这一点读者需要在开发多线程的应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。 &lt;br/&gt;代码清单2-5　创建线程导致内存溢出异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args：-Xss2M （这时候不妨设大些）
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavaVMStackOOM {

       &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dontStop() {
              &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
              }
       }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stackLeakByThread() {
              &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                     Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                            @Override
                            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                                   dontStop();
                            }
                     });
                     thread.start();
              }
       }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
              JavaVMStackOOM oom &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaVMStackOOM();
              oom.stackLeakByThread();
       }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，特别提示一下，如果读者要尝试运行上面这段代码，记得要先保存当前的工作。由于在Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，因此上述代码执行时有较大的风险，可能会导致操作系统假死。 &lt;br/&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Exception in thread&quot;main&quot;java.lang.OutOfMemoryError :unable to create &lt;span&gt;new&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; thread
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;243-方法区和运行时常量池溢出&quot;&gt;2.4.3 方法区和运行时常量池溢出&lt;/h3&gt;
&lt;p&gt;由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。&lt;/p&gt;
&lt;p&gt;String.intern（）是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。&lt;/p&gt;
&lt;p&gt;代码清单2-6　运行时常量池导致的内存溢出异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RuntimeConstantPoolOOM {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用List保持着常量池引用，避免Full GC回收常量池行为&lt;/span&gt;
        List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10MB的PermSize在integer范围内足够产生OOM了&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            list.add(String.valueOf(i&lt;/span&gt;++&lt;span&gt;).intern());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Exception in thread&quot;main&quot;&lt;span&gt;java.lang.OutOfMemoryError :PermGen space
at java.lang.String, intern (Native Method )
at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:&lt;/span&gt;18)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。&lt;/p&gt;
&lt;p&gt;而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响，如代码清单2-7所示。&lt;/p&gt;
&lt;p&gt;代码清单2-7　String.intern（）返回引用的测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RuntimeConstantPoolOOM {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;中国&quot;).append(&quot;钓鱼岛&quot;&lt;span&gt;).toString();
        System.out.println(str1.intern() &lt;/span&gt;==&lt;span&gt; str1);

        String str2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;ja&quot;).append(&quot;va&quot;&lt;span&gt;).toString();
        System.out.println(str2.intern() &lt;/span&gt;==&lt;span&gt; str2);
    }   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。&lt;/p&gt;
&lt;p&gt;方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单2-8中，笔者借助CGLib直接操作字节码运行时生成了大量的动态类。&lt;/p&gt;
&lt;p&gt;值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单2-8相似的溢出场景。&lt;/p&gt;
&lt;p&gt;代码清单2-8　借助CGLib使方法区出现内存溢出异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavaMethodAreaOOM {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
            enhancer.setSuperclass(OOMObject.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            enhancer.setUseCache(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            enhancer.setCallback(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodInterceptor() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OOMObject {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Caused by :java.lang.OutOfMemoryError :PermGen space
at java.lang.ClassLoader.defineClassl (Native Method)
at java.lang.ClassLoader.defineClassCond (ClassLoader. java :&lt;/span&gt;632 ) at java.lang.ClassLoader.defineClass (ClassLoader.java :616&lt;span&gt; )
— &lt;/span&gt;8 more
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。&lt;/p&gt;
&lt;h3 id=&quot;244-本机直接内存溢出&quot;&gt;2.4.4 本机直接内存溢出&lt;/h3&gt;
&lt;p&gt;DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，代码清单2-9越过了DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe（）方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory（）。&lt;/p&gt;
&lt;p&gt;代码清单2-9　使用unsafe分配本机内存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zzm
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectMemoryOOM {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024 * 1024&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Field unsafeField &lt;/span&gt;= Unsafe.&lt;span&gt;class&lt;/span&gt;.getDeclaredFields()[0&lt;span&gt;];
        unsafeField.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        Unsafe unsafe &lt;/span&gt;= (Unsafe) unsafeField.get(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            unsafe.allocateMemory(_1MB);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Exception in thread&quot;main&quot;java.lang.OutOfMemoryError at sun.misc.Unsafe .allocateMemory (Native Method ) at org. fenixsoft. oom.DMOOM.main (DMOOM.java :20 )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。&lt;/p&gt;
&lt;h4&gt;推荐博客&lt;/h4&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chen-haozi/p/10227797.html&quot; target=&quot;_blank&quot;&gt;程序员写代码之外，如何再赚一份工资？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;25-本章小结&quot;&gt;2.5 本章小结&lt;/h2&gt;
&lt;p&gt;通过本章的学习，我们明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并不遥远，本章只是讲解了各个区域出现内存溢出异常的原因，第3章将详细讲解Java垃圾收集机制为了避免内存溢出异常的出现都做了哪些努力。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 03:16:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>2.1 概述 对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们即是拥有最高权力的皇帝又是执行最基础工作的劳动人民——拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10488208.html</dc:identifier>
</item>
</channel>
</rss>