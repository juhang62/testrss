<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lucene的分词器宝典 - HelloWord404</title>
<link>http://www.cnblogs.com/wh1520577322/p/10096933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wh1520577322/p/10096933.html</guid>
<description>&lt;p&gt;&lt;span&gt;Analyzer&lt;span&gt;类&lt;/span&gt;&lt;span&gt;（分词器）&lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;是把一段文本中的词按&lt;/span&gt;&lt;span&gt;某些&lt;/span&gt;&lt;span&gt;规则取出&lt;/span&gt;,&lt;span&gt;提供和以后查询时使用的工具类，注意在创建索引时会用到分词器，在使用字符串搜索时也会用到分词器，这两个地方&lt;/span&gt;&lt;span&gt;要使用同一个分词器&lt;/span&gt;&lt;span&gt;，否则可能会搜索不出结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;分词器工作流程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1， &lt;span&gt;切分关键词&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2， &lt;span&gt;去除停用词&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3， &lt;span&gt;对于英文单词，&lt;/span&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;所有字母转为小写&lt;/span&gt;(&lt;span&gt;搜索时不区分大小写&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;停用词：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;　　有些词在文本中&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;出现的频率非常高&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;但是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;对文本所携带的信息基本不产生影响&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，例如英文的&lt;/span&gt;“a&lt;span&gt;、&lt;/span&gt;&lt;span&gt;an&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;the&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;of&lt;/span&gt;”&lt;span&gt;，或中文的&lt;/span&gt;“&lt;span&gt;的、了、着&lt;/span&gt;&lt;span&gt;、是&lt;/span&gt;”&lt;span&gt;，以及各种标点符号等&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;文本经过分词之后，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;停用词通常被过滤掉，不会被进行索引&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这样的词称为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;停用词&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;stop word&lt;span&gt;）。在检索的时候，用户的查询中如果含有停用词，检索系统也会将其过滤掉（因为用户输入的查询字符串也要进行分词处理）。排除停用词可以加快建立索引的速度&lt;/span&gt;&lt;span&gt;，减小索引库文件的大小&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　中文的分词比较复杂，因为不是一个字就是一个词，而且一个词在另外一个地方就可能不是一个词，如在&lt;/span&gt;“&lt;span&gt;帽子和服装&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;和服&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;就不是一个词。对于中文分词，通常有三种方式：&lt;/span&gt;&lt;span&gt;单字分词、二分法分词、词典分词。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;单字分词：就是按照中文一个字一个字地进行分词。如：&lt;/span&gt;“&lt;span&gt;我们是中国人&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;效果：&lt;/span&gt;“&lt;span&gt;我&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;们&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;国&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;人&lt;/span&gt;”&lt;span&gt;。（&lt;/span&gt;StandardAnalyzer&lt;span&gt;就是这样）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　二分法分词：按两个字进行切分。如：&lt;/span&gt;“&lt;span&gt;我们是中国人&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，效果：&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;我们&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;们是&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;是中&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;国人&lt;/span&gt;”&lt;span&gt;。（&lt;/span&gt;CJKAnalyzer&lt;span&gt;就是这样）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　词库分词：按某种算法构造词，然后去匹配已建好的词库集合，如果匹配到就切分出来成为词语。通常词库分词被认为是最理想的中文分词算法。如：&lt;/span&gt;“&lt;span&gt;我们是中国人&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，效果为：&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;我们&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中国人&lt;/span&gt;”&lt;span&gt;。（使用极易分词的&lt;/span&gt;MMAnalyzer&lt;span&gt;。可以使用&lt;/span&gt;“&lt;span&gt;极易分词&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，或者是&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;庖丁分词&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;分词器、&lt;/span&gt;&lt;span&gt;IKAnalyzer&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;中文分词器使用&lt;/span&gt;IKAnalyzer&lt;span&gt;，主页：&lt;/span&gt;&lt;a href=&quot;http://www.oschina.net/p/ikanalyzer&quot;&gt;&lt;span&gt;http://www.oschina.net/p/ikanalyzer&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实现了以词典为基础的正反向全切分，以及正反向最大匹配切分两种方法。&lt;/span&gt;IKAnalyzer&lt;span&gt;是第三方实现的分词器，继承自&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Analyzer&lt;/span&gt;&lt;span&gt;类，针对中文文本进行处理。具体的使用方式参见其文档。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：扩展的词库与停止词文件要是&lt;/span&gt;UTF-8&lt;span&gt;的编码，并且在要文件头部加一空行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;需要添加&lt;/span&gt; lucene-analyzers-3.0.0.jar&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不同的分词器,中文代码测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testAnalyzer(Analyzer analyzer, String text) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;当前使用的分词器：&quot; +&lt;span&gt; analyzer.getClass().getSimpleName());
        TokenStream tokenStream &lt;/span&gt;= analyzer.tokenStream(&quot;content&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringReader(text));
        tokenStream.addAttribute(TermAttribute.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (tokenStream.incrementToken()) {
            TermAttribute termAttribute &lt;/span&gt;= tokenStream.getAttribute(TermAttribute.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            System.out.println(termAttribute.term());
        }
        System.out.println();
    }

测试代码如下：
@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testAnalyzer()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        helloWorld.testAnalyzer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SimpleAnalyzer(),&quot;钓鱼岛是中国的&quot;&lt;span&gt;);
        helloWorld.testAnalyzer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StandardAnalyzer(Version.LUCENE_30),&quot;钓鱼岛是中国的&quot;&lt;span&gt;);
        helloWorld.testAnalyzer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CJKAnalyzer(Version.LUCENE_30),&quot;钓鱼岛是中国的&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216909/201812/1216909-20181210154520403-1652482508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IK Analyzer &lt;span&gt;是一个开源的，基于&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;诧言开发的轻量级的中文分词工具包。从&lt;/span&gt; &lt;span&gt;2006&lt;/span&gt;&lt;span&gt;年&lt;/span&gt; 12 &lt;span&gt;月推出&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt; &lt;span&gt;版开始，&lt;/span&gt; &lt;span&gt;IKAnalyzer&lt;/span&gt; &lt;span&gt;已经推出了&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;个大版本。最初，它是以开源项目&lt;/span&gt;Luence &lt;span&gt;为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的&lt;/span&gt; &lt;span&gt;IK&lt;/span&gt; Analyzer 3.X &lt;span&gt;则发展为面吐&lt;/span&gt; &lt;span&gt;Java&lt;/span&gt; &lt;span&gt;的公用分词组件，独立于&lt;/span&gt; &lt;span&gt;Lucene&lt;/span&gt; &lt;span&gt;项目，同时提供了对&lt;/span&gt;Lucene&lt;span&gt;的默认优化实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; GoogleCode&lt;span&gt;开源项目  ：&lt;/span&gt;&lt;span&gt;http://code.google.com/p/ik-analyzer/ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;GoogleCode SVN&lt;span&gt;下载：&lt;/span&gt;&lt;a href=&quot;http://ik-analyzer.googlecode.com/svn/trunk/&quot;&gt;&lt;span&gt;http://ik-analyzer.googlecode.com/svn/trunk/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testAnalyzer()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false 细粒度切分&lt;/span&gt;
        helloWorld.testAnalyzer(&lt;span&gt;new&lt;/span&gt; IKAnalyzer(&lt;span&gt;false&lt;/span&gt;),&quot;钓鱼岛是中国的&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 最大词长切分&lt;/span&gt;
        helloWorld.testAnalyzer(&lt;span&gt;new&lt;/span&gt; IKAnalyzer(&lt;span&gt;true&lt;/span&gt;),&quot;钓鱼岛是中国的&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216909/201812/1216909-20181210154639599-1877746357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;基于配置的词典扩充&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. IK &lt;span&gt;分词器还支持通过配置&lt;/span&gt; &lt;span&gt;IKAnalyzer.cfg.xml&lt;/span&gt; &lt;span&gt;文件来扩充您的与有词典以及停止词典&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;过滤词典&lt;/span&gt;&lt;span&gt;) UTF-8&lt;/span&gt;&lt;span&gt;格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;部署&lt;/span&gt;IKAnalyzer.cfg.xml ,IKAnalyzer.cfg.xml &lt;span&gt;部 署 在 代 码 根 目 录 下&lt;/span&gt; &lt;span&gt;(&lt;/span&gt; &lt;span&gt;对 于&lt;/span&gt; &lt;span&gt;web&lt;/span&gt; &lt;span&gt;项 目&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;通 常 是&lt;/span&gt;&lt;span&gt;WEB-INF/classes&lt;/span&gt; &lt;span&gt;目录）同&lt;/span&gt; &lt;span&gt;hibernate&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;log4j&lt;/span&gt; &lt;span&gt;等配置文件相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. IKAnalyzer.cfg.xml&lt;span&gt;配置如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216909/201812/1216909-20181210154703569-936534734.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;/mydict.dic&lt;span&gt;用来配置扩展词典&lt;/span&gt;, &lt;span&gt;而&lt;/span&gt;/ext_stopword.dic &lt;span&gt;用来配置停用词典&lt;/span&gt;,&lt;span&gt;配置后细粒度和最大词拆分如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216909/201812/1216909-20181210154720219-1639167151.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;排序：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;相关度得分是在查询时根据查询条件实进计算出来的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;设置按指定的字段排序&lt;/span&gt;.(&lt;span&gt;注意&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如果设置了指定的字段排序&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;相关度排序则无效&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果需要配置文件或者 代码jar包的可以留言 我发给大家&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 07:50:00 +0000</pubDate>
<dc:creator>HelloWord404</dc:creator>
<og:description>分词器概念介绍： Analyzer类（分词器）就是把一段文本中的词按某些规则取出,提供和以后查询时使用的工具类，注意在创建索引时会用到分词器，在使用字符串搜索时也会用到分词器，这两个地方要使用同一个分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wh1520577322/p/10096933.html</dc:identifier>
</item>
<item>
<title>金猫kinmall：浅谈区块链通证的激励设置 - 金猫kinmall</title>
<link>http://www.cnblogs.com/kinmall/p/10096947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kinmall/p/10096947.html</guid>
<description>&lt;p&gt;当前，大多数的1CO都意图将项目融资和网络参与强行打包塞进一种通证中，这就形成了通证激励。&lt;/p&gt;
&lt;p&gt;您需要在您所希望看到的参与者的短期表现（持有通证以维护其早期价值）和长期表现（大量花费并赚取通证）之间进行权衡。这些校准问题没有明确的最佳实践，因此，这是发生在区块链上的最有趣的实验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181210/ac32d6d9c80f409ebae6eb01629a8dc4.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从事风投五年后，我认为1CO的项目融资方是很重要的，但他们可能缺乏创新。它可能会模仿现有的结构，受到各种IPO、私募和风险投资的启发。区块链呈现的真正机会在于使用某种通证或某种协议的分层激励结构，以促使网络保持长期稳定。&lt;/p&gt;
&lt;p&gt;当您回顾HTTP或其他核心协议的历史时，并未看到与协议开发密切相关的财务激励。这意味着存在很多关于协议激励如何在区块链上发生作用的假设，但并没有多少确切答案。好消息是，随着1CO的普及，我们现在已经有了很多实验结果。&lt;/p&gt;
&lt;p&gt;在与众多律师，会计师，企业家，开发商，投资者进行交谈并阅读大量的白皮书后，我已经有了一些关于激励的假设，但我正在寻找更好的例子和对这些想法的相左意见。以下是我的一些当前想法，希望能够就这些想法收到更多的反馈：&lt;/p&gt;
&lt;p&gt;企业在发行通证后，不得控制该通证的价格。&lt;/p&gt;
&lt;p&gt;假设通证的价格既有上涨的可能，也有下跌的可能。从长远来看，它的价格可能会上涨，但正如事实证明的那样，无论网络中存在何种机制，所有加密货币都可能出现大幅下跌，这会影响正在做功中通证的市场价格。例如，LivePeer的CEO概述了他们利用通货膨胀去影响网络价值的案例，“根据网络的功能和未来的预期用途去计算该网络的价值是有可能实现的”，但却没有考虑到公共市场的影响。&lt;/p&gt;
&lt;p&gt;通过向对冲基金推出私人1CO，您将吸引一批投机者。&lt;/p&gt;
&lt;p&gt;锁仓可以在短期内改变拉高出货的行为，但代价是大量已发行的通证在刚发行的期间无法在网络中使用。当锁仓结束后，它将对市场产生一定的影响。即将结束锁仓时，需要向网络用户发出信号，这一点非常重要，这样用户才能知晓通证的价格即将出现波动。透明化可以提前在通证中建立起信任，同样的道理也适用于目标的项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181210/2b219e9c73104b5fb0ec6bfb6cf9aa12.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通证的价值可能会随着使用量的增加而下降。&lt;/p&gt;
&lt;p&gt;几年后，随着不同的基于区块链的服务之间竞争加剧，通证将创造出一个更具竞争力的市场，这通常会推动通证价格的下跌，而非上涨。例如，随着Google Cloud和Digital Ocean的推出，AWS的价格随着时间的推移而下跌，而非上涨。他们的网络规模更大了，可以从更多的客户那里赚钱，但每单位的销售成本却下降了。应该把关注的重点放在服务的价值上，而不是通证的价格上。（供应量可能会改变这种情况，但却更加难以预测）&lt;/p&gt;
&lt;p&gt;货币政策的制定很难，而且不能作为解决通证贬值的长期方案。&lt;/p&gt;
&lt;p&gt;通过使用回购或创造更多通证的方式来控制供应量，可以改变通证的价格。您可以通过不同的方式将通证构建为智能合约，作为对网络参与行为或网络贡献奖金的响应，但这样也创造了更多针对该系统的博弈方式。大家并不想成为像美联储一样的机构，但美联储所拥有的超级力量却改变了他们的想法。协议智能合约可以被更改，但会影响您现有的客户。&lt;/p&gt;
&lt;p&gt;奖励不应该仅限于金钱。&lt;/p&gt;
&lt;p&gt;我们在丹尼尔·平克的著作《驱动力》中了解到，从长远来看，金钱是一种糟糕的驱动力。相较于金钱奖励，在您的社区中创造长期价值可以更好地激励用户行为。如果您的通证的价格成为您提供的价值的后续想法，那就是真正的胜利。我们看到，类似于Farmville中的游戏机制并未给用户一分钱，但却产生了大量的参与行为。&lt;/p&gt;
&lt;p&gt;去中心化的目标是降低中心化控制。安全监管将持续对买卖双方进行限制（即使通证尚未被称为证券）。某些项目认为你可以通过嵌入一个只能由经过认可的人或非美国公民购买的智能合约来控制这一点。但挑战在于，它需要使用区块链上的身份来验证哪些人是经认可的投资者，哪些人不是。这种验证不只是在一开始时需要，而是每笔交易都需要进行这种验证。如果只有一部分人可以购买这些通证，但其他人可以想办法赚取这些通证，那么当功能性成为真正的目标时，就会创建不同类别的通证。假设您无法控制谁将赚取和购买这些通证，那就需要尽力遵循法规办事。&lt;/p&gt;
&lt;p&gt;为不良行为创建故障保护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20181210/534d041305d745c18b0794daf848946c.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设您的市场可能会出现贪婪和滥权行为。这不是通证市场，而是全球对财富的需求和对漏洞的利用。不需要针对贪婪行为进行优化，但如果偏离了正常轨道，就要在协议中制定计划。我们看到互联网上已经出现了攻击，欺诈，网络赎金，网络罢工和其他类似行为。有一些工具可以帮助防止这些行为出现在互联网上，但却还不能防止它们出现在分布式系统上。&lt;/p&gt;
&lt;p&gt;也许在几年后，真正的最佳实践才会出现，但是会有很多项目等待我们去研究。在我们等待真实的市场数据的同时，我正在寻找有助于更好地对上述假设进行模拟的工具。如果您已经见到过或正在构建类似下面的工具，我很乐意对它进行beta测试：&lt;/p&gt;
&lt;p&gt;实时网络模拟——您能否以编程的方式展现不同的激励方案，并查看这些方案的最终结果？使用虚拟货币演练要比使用真实的证券更划算。&lt;/p&gt;
&lt;p&gt;通证的蒙特·卡罗式模型价格随时间而变化，假设存在着一定的网络风险和市场风险。&lt;/p&gt;
&lt;p&gt;白皮书案例文本——白皮书协作回购可以实现更佳的协作讨论和不同结构的纸对纸比较。&lt;/p&gt;
&lt;p&gt;历史实例中有很多随着时间的推移而演变进化的激励结构。互联网时代是否存在将财务激励整合到开发中的协议？在历史的某个阶段，我们是否拥有一个在不需要任何中心化机构的情况下，将贡献和财务激励紧密联系起来的平行空间？&lt;/p&gt;
&lt;p&gt;我对区块链技术的力量持乐观态度，但我相信我们也需要去研究它的缺点，从而构建更好的反脆弱网络。作为一个长期投资者，我认为最好的1CO将通过灵活的层级激励结构在早期通证持有者（投资者）和现场网络所有者（贡献者）之间建立更多的一致性。区块链还处于初期阶段，我很高兴能够继续从实时的项目中学习知识。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 07:50:00 +0000</pubDate>
<dc:creator>金猫kinmall</dc:creator>
<og:description>当前，大多数的1CO都意图将项目融资和网络参与强行打包塞进一种通证中，这就形成了通证激励。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kinmall/p/10096947.html</dc:identifier>
</item>
<item>
<title>单点登录单例 - 盗帅年</title>
<link>http://www.cnblogs.com/dsqn/p/10096940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dsqn/p/10096940.html</guid>
<description>&lt;p&gt;单点登录是什么呢，简单的来说吧，你去旅游景点参观，里面有一种票叫做全票（也不知道是不是这个，反正就是有这个票里面所有的景区你都可以去参观），还有一种票就是单个景区的票，这个票只是这个景区可以用，到了其它的景点就要再买票了。单点登录就类似于全票，只要和这个绑定了的网站或者其他的网页，只要你在其中一个地方登录了，另一个地方便会自动的登录，这样的话用户的体验便大大的增强了。&lt;br/&gt;今天我们就来做一做简单的单点登录的案例。我们主要用的就是ssm了，由于是简单的案例，我们这里也就不用数据库了。具体的依赖或是jar还有想应的配置文件自己自行的导入即可，就不在这里做过多的强调了。&lt;br/&gt;下面便是我们登录的前台页面了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&quot;false&quot; %&amp;gt;
&amp;lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&quot;&amp;lt;%= basePath%&amp;gt;user/login&quot; method=&quot;post&quot;&amp;gt;
&amp;lt;span&amp;gt;用户名:&amp;lt;/span&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;/&amp;gt;
&amp;lt;span&amp;gt;密  码&amp;lt;/span&amp;gt;&amp;lt;input type=&quot;password&quot; name=&quot;password&quot;/&amp;gt;
&amp;lt;input type=&quot;hidden&quot; name=&quot;gotoUrl&quot; value=&quot;${gotoUrl}&quot;&amp;gt;
&amp;lt;input type=&quot;submit&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中有个gotoUrl的值先在这里卖个关子，后面再告诉大家里面的玄机。其他的相信大家都不陌生了，就是提供一个from表单和对应用户的用户名和密码。&lt;br/&gt;就下来就需要写一个登录的控制器了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@PostMapping(&quot;/login&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String log(String username,String password,String gotoUrl,HttpServletResponse response){
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; ok =&lt;span&gt; SSOCheck.checkLogin(username,password);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ok){
Cookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;ssocookie&quot;,&quot;sso&quot;&lt;span&gt;);
cookie.setPath(&lt;/span&gt;&quot;/&quot;&lt;span&gt;);
response.addCookie(cookie);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; gotoUrl;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;将对应的from表单里面的值传入进去。其中有个工具类，里面有个checkLogin的方法，因为这只是一个小小的案例，所以这个方法只是提供了一个写死的用户名和密码。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String USERNAME = &quot;user&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PASSWORD = &quot;123&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkLogin(String username,String password){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(username.equals(USERNAME) &amp;amp;&amp;amp;&lt;span&gt; password.equals(PASSWORD)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就是当你的用户名是user时和密码是123时你才可以登录成功，相信这个大家很容易理解。&lt;br/&gt;当我们登录成功的时候这个方法会返回一个Boolean值true，这个时候我们就会将会像cookie里面写入一个密令（这个时候就相当于我们在景点买了一个全票）。最后返回你想要登录的页面。&lt;/p&gt;
&lt;p&gt;下面的分别是第一个页面登录后的主页以及第二个页面登录后的主页&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;欢迎访问DEMO1&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;这个是DEMO1的主页&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;欢迎访问DEMO2&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;这个是DEMO2的主页&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;里面的结构很简单，只是里面的标题和正文有些区别而已。当我们直接访问这两个页面的时候便会先判断用户是否登录了，如果没有登录的话就跳转到登录界面。这个时候之前卖关子的地方便出来了，这个时候gotoUrl便派上了用场，这个是用来记录你本来要去哪个页面的地址，就是你本来是要去success1这个页面的，但是你没有登录，当你登录成功的时候自然是跳转回来success1这个页面，而这个时候gotoUrl就会告诉你要跳转到相应的页面，如果没有这个的话，你都不知道页面要往哪个页面跳转。接下来的便是对应的后台控制器的代码了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@GetMapping(&quot;/demo1&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo1(HttpServletRequest request){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(SSOCheck.checkCookie(request)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success1&quot;&lt;span&gt;;
}
request.getSession().setAttribute(&lt;/span&gt;&quot;gotoUrl&quot;,&quot;success1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;这里面也有一个工具类里的方法，它的作用是检测你是否有之前的密令（也就是你是否有全票），具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkCookie(HttpServletRequest request){
Cookie[] cookies &lt;/span&gt;=&lt;span&gt; request.getCookies();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cookies!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie:cookies){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cookie.getName().equals(&quot;ssocookie&quot;) &amp;amp;&amp;amp; cookie.getValue().equals(&quot;sso&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;该方法的返回值也是Boolean值，如果拿到了密令就会返回相应的页面，若是没有拿到密令的话也就是你没有登录或者是登录失效了（要知道cookie你30分钟内你没有进行任何操作它是会失效的），这个时候就会把你要去对应页面的地址放在gotoUrl里面，然后跳到登录页面进行登录。&lt;br/&gt;下面的代码是第二个网页的跳转&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@GetMapping(&quot;/demo2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo2(HttpServletRequest request){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(SSOCheck.checkCookie(request)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success2&quot;&lt;span&gt;;
}
request.getSession().setAttribute(&lt;/span&gt;&quot;gotoUrl&quot;,&quot;success2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;里面的逻辑基本上是和第一个相同，只是修改跳转对应的页面。&lt;br/&gt;基本上我们这个简单的单点登录案例到这里就结束了，下面我把完整的控制层代码以及工具类的代码给出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itds.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.itds.util.SSOCheck;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PostMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.Cookie;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; tb
* @ClassName LogConreoller
* @description 登录控制器
* @DATE 2018/12/10 0010 09:31
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Controller
@RequestMapping(&lt;/span&gt;&quot;/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogConreoller {

@PostMapping(&lt;/span&gt;&quot;/login&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String log(String username,String password,String gotoUrl,HttpServletResponse response){
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; ok =&lt;span&gt; SSOCheck.checkLogin(username,password);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ok){
Cookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;ssocookie&quot;,&quot;sso&quot;&lt;span&gt;);
cookie.setPath(&lt;/span&gt;&quot;/&quot;&lt;span&gt;);
response.addCookie(cookie);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; gotoUrl;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}


@GetMapping(&lt;/span&gt;&quot;/demo1&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo1(HttpServletRequest request){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(SSOCheck.checkCookie(request)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success1&quot;&lt;span&gt;;
}
request.getSession().setAttribute(&lt;/span&gt;&quot;gotoUrl&quot;,&quot;success1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
}

@GetMapping(&lt;/span&gt;&quot;/demo2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String demo2(HttpServletRequest request){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(SSOCheck.checkCookie(request)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success2&quot;&lt;span&gt;;
}
request.getSession().setAttribute(&lt;/span&gt;&quot;gotoUrl&quot;,&quot;success2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itds.util;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.Cookie;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; tb
* @ClassName SSOCheck
* @description 验证工具类
* @DATE 2018/12/7 0007 15:57
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SSOCheck {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String USERNAME = &quot;user&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PASSWORD = &quot;123&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkLogin(String username,String password){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(username.equals(USERNAME) &amp;amp;&amp;amp;&lt;span&gt; password.equals(PASSWORD)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkCookie(HttpServletRequest request){
Cookie[] cookies &lt;/span&gt;=&lt;span&gt; request.getCookies();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cookies!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie:cookies){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cookie.getName().equals(&quot;ssocookie&quot;) &amp;amp;&amp;amp; cookie.getValue().equals(&quot;sso&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面就是最后测试阶段了。对应的效果图如下：&lt;br/&gt;注意看两个页面的地址栏。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553779/201812/1553779-20181210154659924-1151740926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553779/201812/1553779-20181210154719222-8800297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;由于这个时候没有登录所以都是显示的让你登录，那么我们就随便在其中页面上进行登录。登录后效果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553779/201812/1553779-20181210154806512-762274380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;这个时候第一个页面已经是登录了的，而第二个页面还是需要我们进行登录，这个时候我们只需要对第二个页面进行刷新即可看到效果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1553779/201812/1553779-20181210154829333-185016797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;这个时候我们可以对比下第一个网页的地址栏就知道第二个网页是刷新后的结果了。&lt;br/&gt;到这里我们的小案例就完成了，希望这个对大家有所帮助。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 07:49:00 +0000</pubDate>
<dc:creator>盗帅年</dc:creator>
<og:description>单点登录是什么呢，简单的来说吧，你去旅游景点参观，里面有一种票叫做全票（也不知道是不是这个，反正就是有这个票里面所有的景区你都可以去参观），还有一种票就是单个景区的票，这个票只是这个景区可以用，到了其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dsqn/p/10096940.html</dc:identifier>
</item>
<item>
<title>十年工龄的程序员为你揭示最危害程序员职业生涯的三大观念 - 神一样的编程</title>
<link>http://www.cnblogs.com/zhoudatong/p/10096916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoudatong/p/10096916.html</guid>
<description>&lt;p&gt;蓦然回首自己做软件开发这个行业已经十年了，这十年中我获得了很多，技术能力、培训、出国、大公司的经历，还有很多很好的朋友。但再仔细一想，这十年中我至少浪费了五年时间，这五年可以足够让自己成长为一个优秀的程序员，可惜我错过了，我用这五年时间和很多程序员一样在困惑和迷茫中找不到出路！&lt;/p&gt;
&lt;p&gt;路其实一直都在那里，只是我们看不到而已！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://static.oschina.net/uploads/img/201612/28091748_zIER.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前我一直被公司和技术牵着走，并不是自己在选择技术，而是不自觉地被推到了这个位置上。想想有多少人对于自己将来要从事的职业和技术类型进行过深入思考和比较呢？当我跳出编码后，我开始思考和程序及程序员职业生涯相关的问题，最后发现，影响我们走入今天的困局的竟然是一些我们常常挂在嘴边的话（观念）。&lt;/p&gt;
&lt;p&gt;今天，就为大家指出这几个重要的可能是你已经习以为常的观念，希望大家深入的思考一下这些观念对你的危害。如果你还年轻，刚从事软件开发这行没多久，也希望指出这些问题能让你跳过一些误区，不要像我一样多浪费五年时间。&lt;/p&gt;
&lt;h3 id=&quot;h3_2&quot;&gt;观念一： “别管我，我只想一个人安静地写代码！”&lt;/h3&gt;
&lt;p&gt;是不是每天想安安静静地写代码时，IM窗口或者Email总会不合时宜地弹出各种提示，一会要开会啦一会要讨论需求了，再一会测试又来和你理论Bug了。世界这么喧嚣，还让不让人安静地写代码了？“别管我，我只想一个人安静地写代码”，这句话道出了多少程序员的心声啊，我们都想“静静”！不过今天我要告诉你，这种想法是多么的错误，并且严重影响了你职来生涯的发展。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://static.oschina.net/uploads/img/201612/28091748_IpXs.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得自己的工作就是写写代码，那你最好三思。在软件开领域，我们大多数时候是与人而不是与计算机打交道。我们所写的代码首先是供人使用的，其次才是让计算机可以理解的，如果你只想和机器打交道，那写二进制的代码机器才能理解你。仔细想想自己一天的工作中有多少时间用在了与人互动上，收发邮件、会议、讨论（扯皮）等等，作为一个软件开发人员，你的工作就是与人打交道（其实几乎所有的职业都是这样）。&lt;/p&gt;
&lt;p&gt;所以，虽然你是一个码代码的码农，看似你工作的重心是在码代码上，但其实你自己统计一下也会发现：你真正写代码的时间占你工作时间的比例并不高甚至有些人非常低。即使没有人打扰你，你仍然需要花很多的时间去设计（思考）怎么写你的代码，或者花很长的时间去看懂别人的代码然后找到Bug产生的原理，这个过程中看似你面对的是代码是机器，但其实你面对的是人（写代码的人和读你代码的人）。这还没有谈论怎么把业务的需求变成代码，你仍然需要了解一定的业务知识，当然最好的方式是先和业务、需求设计人员进行沟通，而不是闷头写代码。&lt;/p&gt;
&lt;p&gt;所以认为做程序员可以不讲究沟通和谈话技巧，可以恰当地掩饰自己这方面的不足，那么你就太错特错了。如果你是因为自己与人交流的能力不足而觉得程序员是一个很合适的职业的话，那么你很难成为一个优秀的程序员。正如前面所说的一样，程序员写的代码仍然是需要和人交流的，如果只是一味的逃避自己不足的地方，写某方面代码的能力有可能可以大幅提高，但软件设计和开发的能力并不会轻易地提高。最后的软件开发，除了需要你有专业知识并懂得业务外，更重要的是需要你能和相互关系的系统和人进行有效的沟通。&lt;/p&gt;
&lt;p&gt;所以，对程序员来说人际交往能力远比你想象的要重要！学会如何与人打交道，是你通向优秀程序员的第一步。&lt;/p&gt;
&lt;h3 id=&quot;h3_3&quot;&gt;观念二：“这不关我的事！”&lt;/h3&gt;
&lt;p&gt;常常在工作中听到程序员在抱怨“测试又来找我了”、“需求又来找我了”，“客户又来找我了”等等，这些事都和自己的编码没有直接的关系，咋一看从职能分功上确实不关程序员的事。然而，这也是一个很严重的错误观念，它让你损失了很多成长的机会，而且也是你工作几年后走入程序员困境的主要原因。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://static.oschina.net/uploads/img/201612/28091748_Zyzx.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大多数程序员（当然包括笔者）从职业生涯一开始就犯了几个严重的错误。截至目前，最大的错识就是没有把自己的软件开发事业当作一桩生意来看待。当你为了谋生一头扎进写代码的世界时，其实你和在建筑工地上搬砖的民工并没有多大的区别。&lt;/p&gt;
&lt;p&gt;你职业生涯中必须要做的第一要务：转变你的心态，从被一纸“卖身契”束缚住的仆人转变为一各拥有自己生意的商人。你需要学会像企业一样思考，思考一下“作为一个企业我能提供什么”，就会对你如何考量自己的职业生涯有深远的影响。企业需要持续不断地改进和完善自己的产品，你也应该这样做，你的产品就是你的编程技能和服务。换到这个角度后，你就不会再抱怨工作中总被很多莫名其妙的人和事打扰，因为那些事都和你息息相关，或者都和你的生意有关联。积极地承担责任，至少能让你建立起良好的个人品牌，最终你会发现这个品牌的价值比公司给你开的高工资有用得多！&lt;/p&gt;
&lt;p&gt;而且处理一些你看似不相关的事情，也会让你得到某方面的锻炼，这些事情中也可能就有某些行业的痛点问题，如果你解决了，其实一个产品原型就出来了。虽然你的时间被打扰了，但获得的技能和生意却是自己的。&lt;/p&gt;
&lt;p&gt;记住：你工作的公司、客户和同事都有可能是你的生意。&lt;/p&gt;
&lt;h3 id=&quot;h3_4&quot;&gt;观念三：“等我有钱了，我就XXX”&lt;/h3&gt;
&lt;p&gt;“等我有钱了，我就顾几个越南程序员帮我写无聊的代码”，“等我有钱了，我就天天吃食堂的自助餐”等等，这类台词在公司里经常能听到吧，不过一般这样说的人都不会有钱的，或者说很难等到他有钱时。也许看到这里你会产生一些困惑，这个有没有钱和我们做程序员有什么关系呢？&lt;/p&gt;
&lt;p&gt;好，请复习一下观念二！&lt;/p&gt;
&lt;p&gt;财务问题是程序员群体不善处理的一大问题！其实不单是程序员群体，整个大学教育培养出来的学生一般都不具备正确的财务知识和观念。钱不是万能的，但有钱却能解决很多问题，“人穷志短”实在是太精辟了。当你没有钱的时候，你会看重很多你不应该看重的东西，很多东西你可以用钱买来（比如技术和别人的经历）但你不愿意，因为你手上钱不多所以要省省是吧。结果你只能花自己的时间去琢磨，而等你琢磨透时商机已去！&lt;/p&gt;
&lt;p&gt;有句话叫：能用钱买来的就是捡便宜！&lt;/p&gt;
&lt;p&gt;而且因为没有钱你会更看重钱，最终会为了某个公司一个月多给你几千块的涨薪就跳槽，而忽视了去比较真正对你未来有帮助的成长机会！&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://static.oschina.net/uploads/img/201612/28091748_Gedb.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;财务自由是很多程序员非常向往的一个目标，就是我们说的“有钱了”的状态，但如果你真正问一个人什么是财务自由，多少钱才够财务自由？可能很多人都回答不上来，而且对于钱的量级每个人的答案也可能不一样。&lt;/p&gt;
&lt;p&gt;我比较赞成的财务自由的解释是：所谓的财务自由，指的是某人再也不用为了满足生活必需而出售自己的时间了。&lt;/p&gt;
&lt;p&gt;最终我们会发现，财务自由并不是我们努力工作的终极目标，而是我们成长过程的一个重要的里程碑！最终你把财务自由看淡，并看到它身后更远的东西，你才真正有可能实现财务自由。&lt;/p&gt;
&lt;p&gt;所以，不要等，而是要不停的成长，包括技术和为人处事等等各方面。只要你在不停的成长，你就会一直在为自己积累很多东西（技术、人脉资源等），等这些东西达到一定量级你自然会“有钱了”！&lt;/p&gt;
&lt;h2 id=&quot;h2_5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;除了一些高精尖的技术问题，我们一般开发遇到的技术问题其实最终都不是我们成功的关键，而且技术是会更新迭代或是交替的，代码之外的软技能才是我们成长为一个熟练工之后应该着重考虑的。但一些你认为（别人也都这样认为）正确的关念，其实一直影响你并最终把你变成和大多数人一样碌碌无为。每个人的性格和所处环境不同，我们没有必要要求所有人都一样，但如果你想改变或者觉得目前的状态很困惑，不妨思考一下哪些观念是有问题的，是时候来升级一下你的操作系统（你的大脑）了！&lt;/p&gt;
&lt;p&gt;我们再总结一下这三大错误观念：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;认为程序员的主要工作不需要和人交流，不重视人际交往能力；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;认为和写代码不相关的事都不是自己的责任，没有把工作当成自己的生意来对待；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;认为有钱是终极目标，只重薪水不重成长；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你能意识到他们是错误的，并且对自己的职业生涯有极大的危害，那么这篇文章的作用也就达到了，至于如何解决这些观念带来的问题，需要你自己去践行了！&lt;/p&gt;
&lt;p&gt;套用发哥的广告词与大家共勉：“成功？我才刚上路咧！”&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 07:46:00 +0000</pubDate>
<dc:creator>神一样的编程</dc:creator>
<og:description>蓦然回首自己做软件开发这个行业已经十年了，这十年中我获得了很多，技术能力、培训、出国、大公司的经历，还有很多很好的朋友。但再仔细一想，这十年中我至少浪费了五年时间，这五年可以足够让自己成长为一个优秀的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoudatong/p/10096916.html</dc:identifier>
</item>
<item>
<title>RedisCacheManager设置Value序列化器技巧 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/10084452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10084452.html</guid>
<description>&lt;h2&gt;CacheManager基本配置&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　请参考博文：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hujunzheng/p/9660681.html&quot;&gt;springboot2.0 redis EnableCaching的配置和使用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;RedisCacheManager构造函数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Construct a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; RedisCacheManager}.
 * 
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; redisOperations
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SuppressWarnings(&lt;/span&gt;&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisCacheManager(RedisOperations redisOperations) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(redisOperations, Collections.&amp;lt;String&amp;gt;&lt;span&gt; emptyList());
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Construct a static {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; RedisCacheManager}, managing caches for the specified cache names only.
 * 
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; redisOperations
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cacheNames
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.2
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SuppressWarnings(&lt;/span&gt;&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisCacheManager(RedisOperations redisOperations, Collection&amp;lt;String&amp;gt;&lt;span&gt; cacheNames) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisOperations =&lt;span&gt; redisOperations;
    setCacheNames(cacheNames);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RedisCacheManager需要一个 RedisOperations实例，一般是RedisTemplate。还有一个不必须的缓存名称集合参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; RedisCache createCache(String cacheName) {
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; expiration =&lt;span&gt; computeExpiration(cacheName);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisCache(cacheName, (usePrefix ? cachePrefix.prefix(cacheName) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;), redisOperations, expiration);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在创建缓存时，通过RedisCache的构造函数传入 redisOperations（即RedisTemplate实例）。&lt;/p&gt;
&lt;h2&gt;设置全局通用的序列化器&lt;/h2&gt;
&lt;h3&gt;　　GenericJackson2JsonRedisSerializer&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
&lt;/pre&gt;
&lt;pre&gt;
GenericJackson2JsonRedisSerializer serializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer();
User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
user.setName(&lt;/span&gt;&quot;hjzgg&quot;&lt;span&gt;);
user.setAge(&lt;/span&gt;26&lt;span&gt;);

System.out.println(serializer.deserialize(serializer.serialize(user)));


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.toStringHelper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .add(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, name)
                .add(&lt;/span&gt;&quot;age&quot;&lt;span&gt;, age)
                .toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调试发现，序列化内容加入了对象的类型信息，如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210131049780-1215581532.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看GenericJackson2JsonRedisSerializer构造函数，序列化和反序列化的实现是通过Jackson的ObjectMapper完成的。并开启了默认类型的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Creates {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer} and configures {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ObjectMapper} for default typing using the
 * given {&lt;/span&gt;&lt;span&gt;@literal&lt;/span&gt;&lt;span&gt; name}. In case of an {&lt;/span&gt;&lt;span&gt;@literal&lt;/span&gt;&lt;span&gt; empty} or {&lt;/span&gt;&lt;span&gt;@literal&lt;/span&gt;&lt;span&gt; null} String the default
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; JsonTypeInfo.Id#CLASS} will be used.
 * 
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; classPropertyTypeName Name of the JSON property holding type information. Can be {&lt;/span&gt;&lt;span&gt;@literal&lt;/span&gt;&lt;span&gt; null}.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer(String classPropertyTypeName) {

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper());

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(classPropertyTypeName)) {
        mapper.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, classPropertyTypeName);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        mapper.enableDefaultTyping(DefaultTyping.NON_FINAL, As.PROPERTY);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　Protostuff序列化和反序列化&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dyuproject.protostuff.LinkedBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dyuproject.protostuff.ProtostuffIOUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dyuproject.protostuff.Schema;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dyuproject.protostuff.runtime.RuntimeSchema;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.RedisSerializer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProtostuffRedisSerializer &lt;span&gt;implements&lt;/span&gt; RedisSerializer&amp;lt;Object&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Schema&amp;lt;ObjectWrapper&amp;gt; schema = RuntimeSchema.getSchema(ObjectWrapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProtostuffRedisSerializer() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] serialize(Object object) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (object == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[0&lt;span&gt;];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            LinkedBuffer buffer &lt;/span&gt;= LinkedBuffer.allocate(512&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] var3;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                var3 &lt;/span&gt;= ProtostuffIOUtil.toByteArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectWrapper(object), schema, buffer);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                buffer.clear();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var3;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object deserialize(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bytes != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; bytes.length != 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ObjectWrapper objectWrapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectWrapper();
                ProtostuffIOUtil.mergeFrom(bytes, objectWrapper, schema);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objectWrapper.getObject();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception var3) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(var3.getMessage(), var3);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ObjectWrapper {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object object;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ObjectWrapper(Object object) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ObjectWrapper() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getObject() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.object;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setObject(Object object) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面通过Protostuff自定义了一个序列化和反序列化的工具，测试代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    ProtostuffRedisSerializer serializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProtostuffRedisSerializer();
    Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
    person.setName(&lt;/span&gt;&quot;hjzgg&quot;&lt;span&gt;);
    person.setAge(&lt;/span&gt;26&lt;span&gt;);

    System.out.println(serializer.deserialize(serializer.serialize(person)));
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调试发现，序列化内容加入了对象的类型信息，如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210132027645-1226643569.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　JdkSerializationRedisSerializer&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
JdkSerializationRedisSerializer serializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer();
User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
user.setName(&lt;/span&gt;&quot;hjzgg&quot;&lt;span&gt;);
user.setAge(&lt;/span&gt;26&lt;span&gt;);

System.out.println(serializer.deserialize(serializer.serialize(user)));

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.toStringHelper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .add(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, name)
                .add(&lt;/span&gt;&quot;age&quot;&lt;span&gt;, age)
                .toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　JdkSerializationRedisSerializer构造函数如下，序列转换器和反序列转换器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Creates a new {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer} using the default class loader.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; SerializingConverter(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeserializingConverter());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现JdkSerializationRedisSerializer内部使用的是我们最熟悉的ObjectInputStream和ObjectOutputStream。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210135736174-1802077218.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210135833506-1834487425.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　调试发现，序列化内容加入了对象的类型信息，如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210134957260-812572997.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;123&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要缓存的 Java 对象必须实现 Serializable 接口，因为 Spring 会将对象先序列化再存入 Redis，比如本文中的 User 类，如果不实现 Serializable 的话将会遇到类似这种错误：nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.XXX.User]]。&lt;/p&gt;
&lt;h2&gt; 不同cache设置不同序列化器&lt;/h2&gt;
&lt;h3&gt;　　Jackson2JsonRedisSerializer&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
&lt;/pre&gt;
&lt;pre&gt;
Jackson2JsonRedisSerializer&amp;lt;?&amp;gt; serializer1 = &lt;span&gt;new&lt;/span&gt; Jackson2JsonRedisSerializer&amp;lt;&amp;gt;(JacksonHelper.genJavaType(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
System.out.println(serializer1.deserialize(serializer1.serialize(user)));

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.toStringHelper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .add(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, name)
                .add(&lt;/span&gt;&quot;age&quot;&lt;span&gt;, age)
                .toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Jackson2JsonRedisSerializer内部序列化过程也是通过Jackson ObjectMapper来完成的，但是序列化内容不包含对象类型信息，如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201812/640632-20181210132632549-275515793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以，在使用Jackson2JsonRedisSerializer的时候需要指定当前cache存储的对象类型。&lt;/p&gt;
&lt;h3&gt;　　自定义RedisCacheManager &lt;/h3&gt;
&lt;p&gt;　　实现不同RedisCache对应不同的RedisTemplate（即对应不同的序列化器）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomRedisCacheManager &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RedisCacheManager {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, RedisCache&amp;gt; redisCaches =&lt;span&gt; Maps.newConcurrentMap();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CACHE_NAME_DEFAULT = &quot;DEFAULT_CACHE&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomRedisCacheManager(Map&amp;lt;String, CustomRedisConfiguration&amp;gt;&lt;span&gt; configurations) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(configurations.get(CACHE_NAME_DEFAULT).getRedisTemplate(), configurations.keySet());
        configurations.keySet()
                .stream()
                .forEach(
                        cacheName &lt;/span&gt;-&amp;gt; redisCaches.put(cacheName, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisCache(cacheName
                                , &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                                , configurations.get(cacheName).getRedisTemplate()
                                , configurations.get(cacheName).duration.getSeconds()))
                );
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cache getCache(String cacheName) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisCaches.get(cacheName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RedisCacheManager 通过加载自定义配置实现类RedisCacheConfigurationProvider获取不同RedisCache的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@Primary
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisCacheManager redisCacheManager(RedisTemplate redisTemplate, ObjectProvider&amp;lt;RedisCacheConfigurationProvider&amp;gt;&lt;span&gt; provider) {
    Map&lt;/span&gt;&amp;lt;String, CustomRedisConfiguration&amp;gt; configurations =&lt;span&gt; Maps.newHashMap();
    configurations.put(CustomRedisCacheManager.CACHE_NAME_DEFAULT, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CustomRedisConfiguration(redisTemplate, Duration.ofMinutes(20&lt;span&gt;)));
    RedisCacheConfigurationProvider configurationProvider &lt;/span&gt;=&lt;span&gt; provider.getIfAvailable();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Objects.isNull(configurationProvider)) {
        configurations.putAll(configurationProvider.resolve(redisTemplate.getConnectionFactory()));
    }
    RedisCacheManager cacheManager &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomRedisCacheManager(configurations);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cacheManager;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RedisCache自定义配置提供者抽象类，根据不同的缓存类型设置不同的序列化器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCacheConfigurationProvider {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key = 缓存名称， value = 缓存时间 和 缓存类型&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; Map&amp;lt;String, Pair&amp;lt;Duration, JavaType&amp;gt;&amp;gt;&lt;span&gt; configs;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initConfigs();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, CustomRedisConfiguration&amp;gt;&lt;span&gt; resolve(RedisConnectionFactory connectionFactory) {
        initConfigs();
        Assert.notEmpty(configs, &lt;/span&gt;&quot;RedisCacheConfigurationProvider 配置不能为空...&quot;&lt;span&gt;);
        Map&lt;/span&gt;&amp;lt;String, CustomRedisConfiguration&amp;gt; result =&lt;span&gt; Maps.newHashMap();

        configs.forEach((cacheName, pair) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            RedisTemplate&lt;/span&gt;&amp;lt;?, ?&amp;gt; redisTemplate = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
            redisTemplate.setConnectionFactory(connectionFactory);
            redisTemplate.setKeySerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer());
            redisTemplate.setValueSerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Jackson2JsonRedisSerializer&amp;lt;&amp;gt;&lt;span&gt;(pair.getValue()));
            redisTemplate.afterPropertiesSet();
            result.put(cacheName, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomRedisConfiguration(redisTemplate, pair.getKey()));
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用户根据缓存名称设置不同的存储类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CouponRedisCacheConfigurationProvider &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RedisCacheConfig.RedisCacheConfigurationProvider {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initConfigs() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configs =&lt;span&gt; Maps.newHashMap();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configs.put(CouponConstants.COUPON_ALL_CACHE, &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(Duration.ofHours(12), JacksonHelper.genMapType(HashMap.&lt;span&gt;class&lt;/span&gt;, String.&lt;span&gt;class&lt;/span&gt;, Coupon.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configs.put(CouponConstants.COUPON_GOOD_CACHE, &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(Duration.ofHours(12), JacksonHelper.genCollectionType(List.&lt;span&gt;class&lt;/span&gt;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)));

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configs.put(CouponConstants.COUPON_HANDLE_TELEPHONE_STATUS_CACHE, &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(Duration.ofHours(1), JacksonHelper.genCollectionType(List.&lt;span&gt;class&lt;/span&gt;, CouponHandle.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configs.put(CouponConstants.COUPON_HANDLE_TELEPHONE_GOOD_CACHE, &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(Duration.ofHours(1), JacksonHelper.genJavaType(CompositeCouponHandle.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 　　CompositeCacheManager&lt;/h3&gt;
&lt;p&gt;　　复合CacheManager实现了给定的委托CacheManager实例集合。允许NoOpCacheManager自动添加到列表末尾，以便在没有后备存储的情况下处理缓存声明。否则，任何自定义CacheManager也可以扮演最后一个委托的角色，懒惰地为任何请求的名称创建缓存区域。注意：如果复合管理器委托的常规CacheManagers需要从getCache（String）返回null，如果它们不知道指定的缓存名称，则允许迭代到下一个委托。但是，大多数CacheManager实现都会在请求时回退到命名缓存的延迟创建;查看具有固定缓存名称的“静态”模式的特定配置详细信息（如果有）。&lt;/p&gt;
&lt;p&gt;　　通过CompositeCacheManager 可以配置过个CacheManager，每个CacheManager可以配置不同的序列化器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompositeCacheManager &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CacheManager, InitializingBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;CacheManager&amp;gt; cacheManagers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;CacheManager&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; fallbackToNoOpCache = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Construct an empty CompositeCacheManager, with delegate CacheManagers to
     * be added via the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setCacheManagers &quot;cacheManagers&quot;} property.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompositeCacheManager() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Construct a CompositeCacheManager from the given delegate CacheManagers.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cacheManagers the CacheManagers to delegate to
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompositeCacheManager(CacheManager... cacheManagers) {
        setCacheManagers(Arrays.asList(cacheManagers));
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Specify the CacheManagers to delegate to.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCacheManagers(Collection&amp;lt;CacheManager&amp;gt;&lt;span&gt; cacheManagers) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cacheManagers.addAll(cacheManagers);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicate whether a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; NoOpCacheManager} should be added at the end of the delegate list.
     * In this case, any {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; getCache} requests not handled by the configured CacheManagers will
     * be automatically handled by the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; NoOpCacheManager} (and hence never return {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setFallbackToNoOpCache(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fallbackToNoOpCache) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fallbackToNoOpCache =&lt;span&gt; fallbackToNoOpCache;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fallbackToNoOpCache) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cacheManagers.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoOpCacheManager());
        }
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cache getCache(String name) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (CacheManager cacheManager : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cacheManagers) {
            Cache cache &lt;/span&gt;=&lt;span&gt; cacheManager.getCache(name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cache != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Collection&amp;lt;String&amp;gt;&lt;span&gt; getCacheNames() {
        Set&lt;/span&gt;&amp;lt;String&amp;gt; names = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (CacheManager manager : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cacheManagers) {
            names.addAll(manager.getCacheNames());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.unmodifiableSet(names);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 10 Dec 2018 07:42:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>CacheManager基本配置 请参考博文：springboot2.0 redis EnableCaching的配置和使用 RedisCacheManager构造函数 RedisCacheManag</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10084452.html</dc:identifier>
</item>
<item>
<title>BlockingQueue队列 - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10096862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10096862.html</guid>
<description>&lt;div readability=&quot;37&quot;&gt;
&lt;p align=&quot;left&quot;&gt;1)add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则招聘异常&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2)offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3)put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4)poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5)take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;其中：BlockingQueue&lt;/tt&gt; 不接受&lt;tt&gt;null&lt;/tt&gt; 元素。试图&lt;tt&gt;add&lt;/tt&gt;、&lt;tt&gt;put&lt;/tt&gt; 或&lt;tt&gt;offer&lt;/tt&gt; 一个&lt;tt&gt;null&lt;/tt&gt; 元素时，某些实现会抛出&lt;tt&gt;NullPointerException&lt;/tt&gt;。&lt;tt&gt;null&lt;/tt&gt; 被用作指示&lt;tt&gt;poll&lt;/tt&gt; 操作失败的警戒值。 &lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;23.825581395349&quot;&gt;
&lt;p&gt;&lt;tt&gt;【1】BlockingQueue&lt;/tt&gt; &lt;strong&gt;可以是限定容量的&lt;/strong&gt;。它在任意给定时间都可以有一个&lt;tt&gt;remainingCapacity&lt;/tt&gt;，超出此容量，便无法无阻塞地&lt;tt&gt;put&lt;/tt&gt; 附加元素。没有任何内部容量约束的&lt;tt&gt;BlockingQueue&lt;/tt&gt; 总是报告&lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; 的剩余容量。&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;【2】BlockingQueue&lt;/tt&gt; &lt;strong&gt;实现主要用于生产者-使用者队列&lt;/strong&gt;，但它另外还支持&lt;a title=&quot;java.util 中的接口&quot; href=&quot;http://blog.csdn.net/itm_hadf/article/details/7538083&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; 接口。因此，举例来说，使用&lt;tt&gt;remove(x)&lt;/tt&gt; 从队列中移除任意一个元素是有可能的。然而，这种操作通常&lt;em&gt;不&lt;/em&gt; 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;【3】BlockingQueue&lt;/tt&gt; 实现是&lt;strong&gt;线程安全&lt;/strong&gt;的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，&lt;em&gt;大量的&lt;/em&gt; Collection 操作（&lt;tt&gt;addAll&lt;/tt&gt;、&lt;tt&gt;containsAll&lt;/tt&gt;、&lt;tt&gt;retainAll&lt;/tt&gt; 和&lt;tt&gt;removeAll&lt;/tt&gt;）&lt;em&gt;没有&lt;/em&gt; 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了&lt;tt&gt;c&lt;/tt&gt; 中的一些元素后，&lt;tt&gt;addAll(c)&lt;/tt&gt; 有可能失败（抛出一个异常）。&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;【4】BlockingQueue&lt;/tt&gt; 实质上&lt;strong&gt;不支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项&lt;/strong&gt;。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的&lt;em&gt;end-of-stream&lt;/em&gt; 或&lt;em&gt;poison&lt;/em&gt; 对象，并根据使用者获取这些对象的时间来对它们进行解释。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;ArrayBlockingQueue&lt;/h2&gt;
&lt;p&gt;实现细节&lt;/p&gt;
&lt;p&gt;1.基于数组实现循环队列： 也就意味着预分配了空间，不过基于数组在性能上比基于链表的实现性能高些（CPU cache更友好吧）&lt;/p&gt;
&lt;p&gt;2.在读写队列的时候都是用一个ReentrantLock对整个队列上锁（默认非公平锁，公平锁会线程饥饿）。&lt;/p&gt;
&lt;p&gt;3.一旦创建，大小固定，有界队列。比较适合作为有界缓冲。大小固定，也就不必纠结空间回收的问题了，这个是优点也是缺点，看怎么理解了。&lt;/p&gt;
&lt;p&gt;4.实现中使用了Condition来控制notFull和notEmpty条件： 例如take取数据的时候由于队列空了被阻塞；有新的数据put了，就可以signal那些take数据被阻塞的线程了。不利用Condition的话自己利用Object的notify、wait方法也可以做，不过显然麻烦多了。&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;p&gt;比较适合作为有界缓冲。&lt;/p&gt;
&lt;h2&gt;LinkedBlockingQueue&lt;/h2&gt;
&lt;p&gt;实现细节&lt;/p&gt;
&lt;p&gt;1.基于链表实现： 大小可变，更加灵活。默认最大大小为Integer.MAX_VALUE。&lt;/p&gt;
&lt;p&gt;2.在队首（putLock）和队尾使用两把锁： 可以实现读写并发，吞吐性能比ArrayBlockingQueue好很多，&lt;/p&gt;
&lt;p&gt;也利用Condition来做非空非满的条件判断&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;p&gt;常见的不涉及大量互斥资源的生产消费的情况，都可以用该类实现生产消费模型&lt;/p&gt;
&lt;h2&gt;SynchronousQueue&lt;/h2&gt;
&lt;p&gt;总结下有以下特点：&lt;/p&gt;
&lt;p&gt;1.容量永远为0&lt;/p&gt;
&lt;p&gt;2.适合一对一的生产消费场景，由于经过很多优化，性能是很好的。因此容量为1的队列，就别使用其他阻塞queue了&lt;/p&gt;
&lt;p&gt;3.实现上也用了CAS、自旋锁&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;p&gt;性能比前面几种Queue都要高&lt;/p&gt;
&lt;p&gt;适合当做一个生产者和消费者之间的汇合点，传递数据。&lt;/p&gt;
&lt;h2&gt;DelayedQueue&lt;/h2&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;1.延迟队列内部使用优先队列管理任务&lt;/p&gt;
&lt;p&gt;2.使用一个availabe Condition条件来做唤醒&lt;/p&gt;
&lt;p&gt;3.使用的heap数据结构（因为用的优先队列是基于堆得）&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;p&gt;延迟任务、定期任务、周期任务&lt;/p&gt;
&lt;h2&gt;PriorityBlockingQueue&lt;/h2&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;1.存储的对象必须是实现Comparable接口&lt;/p&gt;
&lt;p&gt;2.基于heap的数据机构（array-based binary heap）&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;p&gt;有优先级的任务&lt;/p&gt;
&lt;h2&gt;LinkedTransferQueue&lt;/h2&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;1.非阻塞&lt;/p&gt;
&lt;p&gt;2.基于CAS无锁&lt;/p&gt;
&lt;p&gt;3.Doug Lea说从功能角度来讲，LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。&lt;/p&gt;


</description>
<pubDate>Mon, 10 Dec 2018 07:39:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>1.BlockingQueue定义的常用方法如下 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e,time,unit) 移除 remove() pol</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10096862.html</dc:identifier>
</item>
<item>
<title>深度学习基础系列（十一）| Keras中图像增强技术详解 - 可可心心</title>
<link>http://www.cnblogs.com/hutao722/p/10075150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hutao722/p/10075150.html</guid>
<description>&lt;p&gt;　　在深度学习中，数据短缺是我们经常面临的一个问题，虽然现在有不少公开数据集，但跟大公司掌握的海量数据集相比，数量上仍然偏少，而某些特定领域的数据采集更是非常困难。根据之前的学习可知，数据量少带来的最直接影响就是过拟合。那有没有办法在现有少量数据基础上，降低或解决过拟合问题呢？&lt;/p&gt;
&lt;p&gt;      答案是有的，就是数据增强技术。我们可以对现有的数据，如图片数据进行平移、翻转、旋转、缩放、亮度增强等操作，以生成新的图片来参与训练或测试。这种操作可以将图片数量提升数倍，由此大大降低了过拟合的可能。本文将详解图像增强技术在Keras中的原理和应用。&lt;/p&gt;

&lt;h3&gt;一、Keras中的ImageDataGenerator类&lt;/h3&gt;
&lt;p&gt;　　图像增强的官网地址是：&lt;a href=&quot;https://keras.io/preprocessing/image/&quot; target=&quot;_blank&quot;&gt;https://keras.io/preprocessing/image/&lt;/a&gt; ，API使用相对简单，功能也很强大。&lt;/p&gt;
&lt;p&gt;　　先介绍的是ImageDataGenerator类，这个类定义了图片该如何进行增强操作，其API及参数定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
keras.preprocessing.image.ImageDataGenerator(&lt;br/&gt;　　　　featurewise_center=&lt;span&gt;False, #输入值按照均值为0进行处理
　　　　samplewise_center&lt;/span&gt;=&lt;span&gt;False, #每个样本的均值按0处理
　　　　featurewise_std_normalization&lt;/span&gt;=False, #输入值按照标准正态化处理&lt;br/&gt;　　　　samplewise_std_normalization=&lt;span&gt;False, #每个样本按照标准正态化处理 
　　　　zca_whitening&lt;/span&gt;=&lt;span&gt;False, # 是否开启增白
　　　　zca_epsilon&lt;/span&gt;=1e-06&lt;span&gt;, 
　　　　rotation_range&lt;/span&gt;=&lt;span&gt;0, #图像随机旋转一定角度，最大旋转角度为设定值
　　　　width_shift_range&lt;/span&gt;=0.0&lt;span&gt;, #图像随机水平平移，最大平移值为设定值。若值为小于1的float值，则可认为是按比例平移，若大于1，则平移的是像素；若值为整型，平移的也是像素；假设像素为2.0，则移动范围为[-1,1]之间
　　　　height_shift_range&lt;/span&gt;=0.0&lt;span&gt;, #图像随机垂直平移，同上
　　　　brightness_range&lt;/span&gt;=&lt;span&gt;None, # 图像随机亮度增强，给定一个含两个float值的list，亮度值取自上下限值间
　　　　shear_range&lt;/span&gt;=0.0&lt;span&gt;, # 图像随机修剪
　　　　zoom_range&lt;/span&gt;=0.0&lt;span&gt;, # 图像随机变焦 
　　　　channel_shift_range&lt;/span&gt;=0.0&lt;span&gt;, 
　　　　fill_mode&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nearest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, #填充模式，默认为最近原则，比如一张图片向右平移，那么最左侧部分会被临近的图案覆盖
　　　　cval&lt;/span&gt;=0.0&lt;span&gt;, 
　　　　horizontal_flip&lt;/span&gt;=&lt;span&gt;False, #图像随机水平翻转
　　　　vertical_flip&lt;/span&gt;=&lt;span&gt;False, #图像随机垂直翻转
　　　　rescale&lt;/span&gt;=&lt;span&gt;None, #缩放尺寸
　　　　preprocessing_function&lt;/span&gt;=&lt;span&gt;None, 
　　　　data_format&lt;/span&gt;=&lt;span&gt;None, 
　　　　validation_split&lt;/span&gt;=0.0&lt;span&gt;, 
　　　　dtype&lt;/span&gt;=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　下文将以mnist和花类的数据集进行图片操作，其中花类（17种花，共1360张图片）数据集可见我的百度网盘： &lt;a href=&quot;https://pan.baidu.com/s/1YDA_VOBlJSQEijcCoGC60w&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1YDA_VOBlJSQEijcCoGC60w&lt;/a&gt; 。让我们以直观地方式看看各参数能带来什么样的图片变化。&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;随机旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们可用mnist数据集对图片进行随机旋转，旋转的最大角度由参数定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K

K.set_image_dim_ordering(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

(train_data, train_label), (test_data, test_label) &lt;/span&gt;=&lt;span&gt; mnist.load_data()
train_data &lt;/span&gt;= train_data.reshape(train_data.shape[0], 1, 28, 28&lt;span&gt;)
train_data &lt;/span&gt;= train_data.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容&lt;/span&gt;
datagen = ImageDataGenerator(&lt;strong&gt;rotation_range=90&lt;/strong&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像生成器要训练的数据&lt;/span&gt;
&lt;span&gt;datagen.fit(train_data)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; batch_data, batch_label &lt;span&gt;in&lt;/span&gt; datagen.flow(train_data, train_label, batch_size=9&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个 3*3的九宫格，以显示图片&lt;/span&gt;
        pyplot.subplot(330 + 1 +&lt;span&gt; i)
        pyplot.imshow(batch_data[i].reshape(&lt;/span&gt;28, 28), cmap=pyplot.get_cmap(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210103702408-1643419848.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;随机平移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可用花类数据集对图片进行随机平移，可以在垂直和水平方向上平移，平移最大值由参数定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; array_to_img

IMAGE_SIZE &lt;/span&gt;= 224&lt;span&gt;
NUM_CLASSES &lt;/span&gt;= 17&lt;span&gt;
TRAIN_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/train&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TEST_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
FLOWER_CLASSES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bluebell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButterCup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ColtsFoot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cowslip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Crocus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daffodil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daisy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dandelion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fritillary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LilyValley&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pansy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Snowdrop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sunflower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tigerlily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tulip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WindFlower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，平移的最大比例为50%&lt;/span&gt;
train_datagen = ImageDataGenerator(&lt;strong&gt;width_shift_range=0.5, height_shift_range=0.5&lt;/strong&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; X_batch, y_batch &lt;span&gt;in&lt;/span&gt; train_datagen.flow_from_directory(directory=TRAIN_PATH, target_size=(IMAGE_SIZE, IMAGE_SIZE),batch_size=9, classes=&lt;span&gt;FLOWER_CLASSES):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        pyplot.subplot(&lt;/span&gt;330 + 1 +&lt;span&gt; i)
        pyplot.imshow(array_to_img(X_batch[i]))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210111040657-1236415376.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以观察到，图片除了实现平移外，其原来的位置都被最近的图案给填充，因为默认给的填充方式是nearest。&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;随机亮度调整&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们可用花类数据集对图片进行随机亮度调整，亮度范围由参数定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; array_to_img

IMAGE_SIZE &lt;/span&gt;= 224&lt;span&gt;
NUM_CLASSES &lt;/span&gt;= 17&lt;span&gt;
TRAIN_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/train&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TEST_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
FLOWER_CLASSES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bluebell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButterCup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ColtsFoot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cowslip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Crocus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daffodil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daisy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dandelion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fritillary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LilyValley&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pansy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Snowdrop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sunflower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tigerlily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tulip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WindFlower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，亮度范围在0.1~10之间随机选择&lt;/span&gt;
train_datagen = ImageDataGenerator(&lt;strong&gt;brightness_range=[0.1, 10&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;]&lt;/strong&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; X_batch, y_batch &lt;span&gt;in&lt;/span&gt; train_datagen.flow_from_directory(directory=TRAIN_PATH, target_size=(IMAGE_SIZE, IMAGE_SIZE),batch_size=9, classes=&lt;span&gt;FLOWER_CLASSES):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        pyplot.subplot(&lt;/span&gt;330 + 1 +&lt;span&gt; i)
        pyplot.imshow(array_to_img(X_batch[i]))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210111706087-2073918754.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;随机焦距调整&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可用mnist数据集对图片进行随机焦距调整，焦距调整值由参数定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K

K.set_image_dim_ordering(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

(train_data, train_label), (test_data, test_label) &lt;/span&gt;=&lt;span&gt; mnist.load_data()
train_data &lt;/span&gt;= train_data.reshape(train_data.shape[0], 1, 28, 28&lt;span&gt;)
train_data &lt;/span&gt;= train_data.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，焦距值在0.1~1之间&lt;/span&gt;
datagen = ImageDataGenerator(&lt;strong&gt;zoom_range=[0.1, 1&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;]&lt;/strong&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像生成器要训练的数据&lt;/span&gt;
&lt;span&gt;datagen.fit(train_data)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; batch_data, batch_label &lt;span&gt;in&lt;/span&gt; datagen.flow(train_data, train_label, batch_size=9&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个 3*3的九宫格，以显示图片&lt;/span&gt;
        pyplot.subplot(330 + 1 +&lt;span&gt; i)
        pyplot.imshow(batch_data[i].reshape(&lt;/span&gt;28, 28), cmap=pyplot.get_cmap(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210112223092-334534022.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看出这跟相机调焦一样，可以放大或缩小焦距。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;随机翻转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们可用花类数据集对图片进行随机翻转。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; array_to_img

IMAGE_SIZE &lt;/span&gt;= 224&lt;span&gt;
NUM_CLASSES &lt;/span&gt;= 17&lt;span&gt;
TRAIN_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/hutao/Documents/tensorflow/images/17flowerclasses/train&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TEST_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/hutao/Documents/tensorflow/images/17flowerclasses/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
FLOWER_CLASSES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bluebell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButterCup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ColtsFoot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cowslip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Crocus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daffodil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daisy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dandelion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fritillary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LilyValley&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pansy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Snowdrop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sunflower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tigerlily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tulip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WindFlower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，图片随机翻转&lt;/span&gt;
train_datagen = ImageDataGenerator(&lt;strong&gt;horizontal_flip=True, vertical_flip=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;True&lt;/strong&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; X_batch, y_batch &lt;span&gt;in&lt;/span&gt; train_datagen.flow_from_directory(directory=TRAIN_PATH, target_size=(IMAGE_SIZE, IMAGE_SIZE),batch_size=9, classes=&lt;span&gt;FLOWER_CLASSES):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        pyplot.subplot(&lt;/span&gt;330 + 1 +&lt;span&gt; i)
        pyplot.imshow(array_to_img(X_batch[i]))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210113151707-1627100127.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可看出，有些图片水平翻转了，有些是垂直翻转了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;ZCA图像增白&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;说实在我不太清楚该技术有何用，用花类图片实验结果显示zca不支持，可以用mnist数据集来看看效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K

K.set_image_dim_ordering(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

(train_data, train_label), (test_data, test_label) &lt;/span&gt;=&lt;span&gt; mnist.load_data()
train_data &lt;/span&gt;= train_data.reshape(train_data.shape[0], 1, 28, 28&lt;span&gt;)
train_data &lt;/span&gt;= train_data.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，增白图片&lt;/span&gt;
datagen = ImageDataGenerator(&lt;strong&gt;zca_whitening=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;True&lt;/strong&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像生成器要训练的数据&lt;/span&gt;
&lt;span&gt;datagen.fit(train_data)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; batch_data, batch_label &lt;span&gt;in&lt;/span&gt; datagen.flow(train_data, train_label, batch_size=9&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个 3*3的九宫格，以显示图片&lt;/span&gt;
        pyplot.subplot(330 + 1 +&lt;span&gt; i)
        pyplot.imshow(batch_data[i].reshape(&lt;/span&gt;28, 28), cmap=pyplot.get_cmap(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210114321491-424168075.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;特征标准化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;特征标准化的含义是使图片的像素均值为0，标准差为1，不过我试了多次，直观效果不明显。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K

K.set_image_dim_ordering(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

(train_data, train_label), (test_data, test_label) &lt;/span&gt;=&lt;span&gt; mnist.load_data()
train_data &lt;/span&gt;= train_data.reshape(train_data.shape[0], 1, 28, 28&lt;span&gt;)
train_data &lt;/span&gt;= train_data.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建图像生成器，指定对图像操作的内容，允许图片标准化处理&lt;/span&gt;
datagen = ImageDataGenerator(&lt;strong&gt;featurewise_center=True, featurewise_std_normalization=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;True&lt;/strong&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像生成器要训练的数据&lt;/span&gt;
&lt;span&gt;datagen.fit(train_data)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是个图像生成迭代器，是可以无限生成各种新图片，我们指定每轮迭代只生成9张图片&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; batch_data, batch_label &lt;span&gt;in&lt;/span&gt; datagen.flow(train_data, train_label, batch_size=9&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 9&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个 3*3的九宫格，以显示图片&lt;/span&gt;
        pyplot.subplot(330 + 1 +&lt;span&gt; i)
        pyplot.imshow(batch_data[i].reshape(&lt;/span&gt;28, 28), cmap=pyplot.get_cmap(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    pyplot.show()
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891145/201812/891145-20181210121302848-600451131.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　就个人而言，我倾向于在图像增强中使用旋转、亮度调整、翻转和平移操作。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、Keras如何进行图像增强数据训练&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在之前的文章中我已经展现过数据增强的使用。在Keras中，增强图片有三种来源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图片来源于已知数据集，如mnist、cifar，数据格式为numpy格式；&lt;/li&gt;
&lt;li&gt;图片来源于我们自己搜集的图片，如本文引入的花类数据集，其图片为jpg、png等格式；&lt;/li&gt;
&lt;li&gt;图片来源于panda数据集；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　其中数据来源已知数据集&lt;/strong&gt;，其操作方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
(x_train, y_train), (x_test, y_test) =&lt;span&gt; cifar10.load_data()
y_train &lt;/span&gt;=&lt;span&gt; np_utils.to_categorical(y_train, num_classes)
y_test &lt;/span&gt;=&lt;span&gt; np_utils.to_categorical(y_test, num_classes)

datagen &lt;/span&gt;=&lt;span&gt; ImageDataGenerator(
    featurewise_center&lt;/span&gt;=&lt;span&gt;True,
    featurewise_std_normalization&lt;/span&gt;=&lt;span&gt;True,
    rotation_range&lt;/span&gt;=20&lt;span&gt;,
    width_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
    height_shift_range&lt;/span&gt;=0.2&lt;span&gt;,
    horizontal_flip&lt;/span&gt;=&lt;span&gt;True)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成器绑定训练集&lt;/span&gt;
&lt;span&gt;datagen.fit(x_train)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模型绑定生成器，并不停地迭代产生数据，可指定迭代次数，假设图片总数为1000张，batch默认为32，则每次迭代需要产生1000/32=32个步骤&lt;/span&gt;
history = model.fit_generator(datagen.flow(x_train, y_train, batch_size=32&lt;span&gt;),
                    steps_per_epoch&lt;/span&gt;=len(x_train) / 32, epochs=epochs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;数据来源图片集，&lt;/strong&gt;其操作方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
batch_size = 32
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代50次&lt;/span&gt;
epochs = 50
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依照模型规定，图片大小被设定为224&lt;/span&gt;
IMAGE_SIZE = 224&lt;span&gt;
TRAIN_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/train&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TEST_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/tensorflow/images/17flowerclasses/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
FLOWER_CLASSES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bluebell&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButterCup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ColtsFoot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cowslip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Crocus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daffodil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Daisy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dandelion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fritillary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LilyValley&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pansy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Snowdrop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sunflower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tigerlily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tulip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WindFlower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用数据增强&lt;/span&gt;
train_datagen =&lt;span&gt; ImageDataGenerator(rotation_range=90)&lt;br/&gt;# 可指定输出图片大小，因为深度学习要求训练图片大小保持一致
train_generator &lt;/span&gt;= train_datagen.flow_from_directory(directory=&lt;span&gt;TRAIN_PATH,
                                                        target_size&lt;/span&gt;=&lt;span&gt;(IMAGE_SIZE, IMAGE_SIZE),
                                                        classes&lt;/span&gt;=&lt;span&gt;FLOWER_CLASSES)
test_datagen &lt;/span&gt;=&lt;span&gt; ImageDataGenerator()
test_generator &lt;/span&gt;= test_datagen.flow_from_directory(directory=&lt;span&gt;TEST_PATH, 
                                                      target_size&lt;/span&gt;=&lt;span&gt;(IMAGE_SIZE, IMAGE_SIZE),
                                                      classes&lt;/span&gt;=&lt;span&gt;FLOWER_CLASSES)
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行模型&lt;/span&gt;
history = model.fit_generator(train_generator, epochs=epochs, validation_data=test_generator)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　需要说明的是，这些增强图片都是在内存中实时批量迭代生成的，不是一次性被读入内存，这样可以极大地节约内存空间，加快处理速度。若想保留中间过程生成的增强图片，可以在上述方法中添加保存路径等参数，此处不再赘述。&lt;/p&gt;

&lt;h3&gt;三、结论&lt;/h3&gt;
&lt;p&gt;　　本文介绍了如何在Keras中使用图像增强技术，对图片可以进行各种操作，以生成数倍于原图片的增强图片集。这些数据集可帮助我们有效地对抗过拟合问题，更好地生成理想的模型。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 07:21:00 +0000</pubDate>
<dc:creator>可可心心</dc:creator>
<og:description>在深度学习中，数据短缺是我们经常面临的一个问题，虽然现在有不少公开数据集，但跟大公司掌握的海量数据集相比，数量上仍然偏少，而某些特定领域的数据采集更是非常困难。根据之前的学习可知，数据量少带来的最直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hutao722/p/10075150.html</dc:identifier>
</item>
<item>
<title>架构模式：MVC与MVVM - IvanEye</title>
<link>http://www.cnblogs.com/ivaneye/p/10096598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivaneye/p/10096598.html</guid>
<description>&lt;p&gt;本文探讨如下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是MVC&lt;/li&gt;
&lt;li&gt;什么是MVVM&lt;/li&gt;
&lt;li&gt;MVC与MVVM对架构属性的影响&lt;/li&gt;
&lt;li&gt;MVC实例SpringMVC&lt;/li&gt;
&lt;li&gt;MVVM实例Vue&lt;/li&gt;
&lt;li&gt;MVC、MVVM与Layer中的Model,Controller有什么区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在「&lt;a href=&quot;https://www.cnblogs.com/ivaneye/p/9785096.html&quot;&gt;什么是架构模式和架构风格&lt;/a&gt;」一文中，对架构模式的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Architecture Pattern: { Problem, Context } → architecture approach;&lt;br/&gt;&lt;strong&gt;架构模式描述了一组组件之间的关系，用以解决特定上下文内的某个常见的架构问题&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MVC和MVVM都是架构模式！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC&lt;strong&gt;描述了「Model,View,Controller」三者之间的关系，用以解决「有展示界面的系统」「界面开发与业务逻辑的耦合问题」&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MVVM&lt;strong&gt;描述了[Model,View,ViewModel(和Binder)」三者之间的关系，用以解决「有展示界面的系统」「界面开发与业务逻辑的耦合问题」&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出MVC和MVVM都是为了解耦「界面」和「业务逻辑」，只是解决方案不同！也可以说MVVM是MVC的一种变体(ViewModel+Binder可以说是Controller的一种实现方式)，或者衍生！&lt;/p&gt;
&lt;p&gt;我们先说，为什么要解耦「界面」和「业务逻辑」？&lt;/p&gt;
&lt;p&gt;早期的界面系统开发时，展示逻辑与数据是糅合在一起的！以早期的Java为例，所有的展示逻辑和业务逻辑都写在了Servlet/JSP中，导致了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单个文件的代码量较多，既包含了展示代码又包含了业务逻辑&lt;/li&gt;
&lt;li&gt;违背了职责单一性原则&lt;/li&gt;
&lt;li&gt;修改麻烦&lt;/li&gt;
&lt;li&gt;复用性差&lt;/li&gt;
&lt;li&gt;不易于维护&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MVC将系统拆分为控制器、视图和模型来解决上面的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;控制器（Controller）&lt;/strong&gt;- 负责转发请求，对请求进行处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图（View）&lt;/strong&gt; - 界面设计人员进行图形界面设计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型（Model）&lt;/strong&gt; - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Wiki给出了一个Js模拟的MVC模式代码，能更清晰的理解三者之间的关系：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/** 模拟 Model, View, Controller */
var M = {}, V = {}, C = {};

/** Model 负责存放数据 */
M.data = &quot;hello world&quot;;

/** View 负责将资料展示出来 */
V.render = (M) =&amp;gt; { alert(M.data); }

/** Controller 作为M和V的桥梁 */
C.handleOnload = () =&amp;gt; { V.render(M); }

/** 在页面加载的时候调用Controller*/
window.onload = C.handleOnload;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的拆分，提高了系统的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：View、Model和Controller分别负责视图、数据和控制，可独立进化。能较方便的增加新功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：结构清晰，多个View可以复用一个Model，减少了代码重复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可测试性&lt;/strong&gt;：每个组件的职责单一，可以对Model进行自动化测试&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：Controller 可以用来连接不同的 Model 和 View 去完成用户的需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可配置性&lt;/strong&gt;：给定一些可重用的 Model 、 View 和Controller 可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 来处理结果显示给用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而MVVM模式将系统拆分为&lt;strong&gt;视图、模型和视图模型以及绑定器&lt;/strong&gt;来解决耦合问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;：Model是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。和MVC中的Model指代的内容相似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：就像在MVC中一样，View是用户在屏幕上看到的结构、布局和外观（UI）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ViewModel&lt;/strong&gt;：ViewModel是暴露公共属性和命令的视图的抽象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binder&lt;/strong&gt;：绑定器是MVVM模式里的一个隐含组件，ViewModel中声明了数据与View之间的绑定关系，而绑定器来处理声明的绑定关系。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ViewModel和Binder的关系就像Java里的&lt;strong&gt;注解与注解处理器&lt;/strong&gt;之间的关系：注解只是标示了某个字段、方法或某个类应该具备什么属性；注解处理器根据注解，对被注解的字段、方法或某个类来进行实际的处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的拆分，与MVC模式一样，提高了相同的系统属性，只是方式有一些差异：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：View、Model和ViewModel(和Binder)分别负责视图、数据和数据视图绑定，可独立进化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：结构清晰，多个View可以复用一个Model，减少了代码重复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可测试性&lt;/strong&gt;：每个组件的职责单一，可以对Model进行自动化测试。前台也可以对ViewModel进行自动化测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：ViewModel 可以用来绑定不同的 Model 和 View 去完成用户的需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可配置性&lt;/strong&gt;：给定一些可重用的 Model 、 View可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 来处理结果显示给用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpringMVC是目前使用比较广泛的MVC框架！它是MVC与「前端控制器」的混合体！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。前端控制器包含如下组件：&lt;br/&gt;&lt;strong&gt;前端控制器（Front Controller）&lt;/strong&gt;：处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。&lt;br/&gt;&lt;strong&gt;调度器（Dispatcher）&lt;/strong&gt;：前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。&lt;br/&gt;&lt;strong&gt;视图（View）&lt;/strong&gt;：视图是为请求而创建的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在SpringMVC中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：指的是各种展现模板，比如：velocity,freemark,theamleaf等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;：指的是前端控制器与Controller层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;：指的是Controller后的后续处理组件，比如Service,Model,Domain,DAO层等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SpringMVC的前端控制器做了很多事情，结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371217/201812/371217-20181210150734607-1736455042.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HandlerMappingMap： 维护了请求与处理程序(一组前置拦截器+处理程序+后置拦截器)之间的关系，如何维护映射关系，由具体的实现决定。例如：RequestMappingHandlerMapping基于@RequestMapping注解来维护映射关系；SimpleUrlHandlerMapping根据URI匹配关系来处理映射关系&lt;/li&gt;
&lt;li&gt;HandlerAdapter：用于执行具体的处理程序。由于不同的映射关系，执行处理程序的方式也不一样，HandlerAdapter封装了这些执行差异&lt;/li&gt;
&lt;li&gt;HandlerException：异常处理程序，将异常映射到处理程序、或HTML或其它组件上。即可以通过配置，统一的处理某一种类型的异常&lt;/li&gt;
&lt;li&gt;ViewResolver：通过解析「基于字符串的视图名称」来找到真实的视图，来进行渲染，回写到响应中&lt;/li&gt;
&lt;li&gt;LocaleResolver, LocaleContextResolver：处理国际化&lt;/li&gt;
&lt;li&gt;ThemeResolver：处理主题&lt;/li&gt;
&lt;li&gt;MultipartResolver：处理multi-part请求 (上传文件)&lt;/li&gt;
&lt;li&gt;FlashMapManager：实现Flash作用域。因为标准J2EE中只提供了page，request，session，application四种作用域。Spring通过FlashMapManager实现了Flash作用域，用于在单个请求内传递参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vue实现的是MVVM模式！&lt;/p&gt;
&lt;p&gt;在Vue中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;View：指的是各种template，即基于html语法的展示&lt;/li&gt;
&lt;li&gt;ViewModel：指的是对应的js，声明绑定的元素及绑定的数据&lt;/li&gt;
&lt;li&gt;Binder：处理template与js的绑定逻辑&lt;/li&gt;
&lt;li&gt;Model：指的是获取数据的逻辑。如果使用的是node，则就是node相关逻辑代码；如果调用的是远程服务，则指的是远程服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个简单的Vue代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=en&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;Hello world&amp;lt;/title&amp;gt;
        &amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;app&quot;&amp;gt;{{content}}&amp;lt;/div&amp;gt;
        &amp;lt;script&amp;gt;
            var app = new Vue({
                el:'#app', //vue实例处理哪个dom
                data:{   //定义
                    content:'hello world'
                },
                methods:{
                    fetchData: function() {
                        // 获取数据
                    }
                }
            });
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图是Vue的生命周期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/371217/201812/371217-20181210150758484-184238684.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vue对象就是ViewModel，它声明了：
&lt;ul&gt;&lt;li&gt;要处理哪个dom「el」&lt;/li&gt;
&lt;li&gt;有哪些数据「data」&lt;/li&gt;
&lt;li&gt;有哪些方法「methods」&lt;/li&gt;
&lt;li&gt;生命周期钩子（beforeCreate,created...）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Binder（Vue框架处理代码）根据上面的声明，来进行相应的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面有三处提到了Model和Controller，这三处的Model和Controller并不完全相同！&lt;/p&gt;
&lt;p&gt;三处Model：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC中的Model：这里的Mode指的是提供数据相关服务的组件。或者说是业务处理逻辑。&lt;/li&gt;
&lt;li&gt;MVVM中的Model：和MVC一致&lt;/li&gt;
&lt;li&gt;系统中的Model：指的是分层系统中的Model层（代码分层），主要作为系统与持久层的数据载体，可以是只有get、set方法的POJO也可以是包含领域方法的领域对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三处Controller：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC中的Controller：指的是连接View和Model的组件&lt;/li&gt;
&lt;li&gt;Spring中的前端控制器：Controller的一种实现，统一处理请求&lt;/li&gt;
&lt;li&gt;Spring中的Controller：分层系统里的Controller层（代码分层，可能叫Handler更合适），属于MVC中的Controller&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 10 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>IvanEye</dc:creator>
<og:description>本文探讨如下几个问题： 什么是MVC 什么是MVVM MVC与MVVM对架构属性的影响 MVC实例SpringMVC MVVM实例Vue MVC、MVVM与Layer中的Model,Controlle</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ivaneye/p/10096598.html</dc:identifier>
</item>
<item>
<title>vuex详解 - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10096540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10096540.html</guid>
<description>&lt;h2&gt;vuex详解&lt;/h2&gt;
&lt;p&gt;　　yarn add vuex&lt;/p&gt;
&lt;p&gt;1、vuex流程图&lt;/p&gt;
&lt;p&gt;　　vuex可以帮助我们管理组件间公共的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201812/1459163-20181210115925783-1131924654.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个 store　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)&lt;/span&gt;
&lt;span&gt;
const store &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;0&lt;span&gt;
  },
  mutations: {
    increment (state) {
      state.count&lt;/span&gt;++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　现在，你可以通过 &lt;code&gt;store.state&lt;/code&gt; 来获取状态对象，以及通过 &lt;code&gt;store.commit&lt;/code&gt; 方法触发状态变更：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.commit('increment'&lt;span&gt;)

console.log(store.state.count) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;

&lt;p&gt;2、详解(state)&lt;/p&gt;

&lt;p&gt;　　由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在&lt;a href=&quot;https://cn.vuejs.org/guide/computed.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;计算属性&lt;/a&gt;中返回某个状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Counter 组件&lt;/span&gt;
const Counter =&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;{{ count }}&amp;lt;/div&amp;gt;`,
&lt;span&gt;  computed: {
    count () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; store.state.count
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　每当 &lt;code&gt;store.state.count&lt;/code&gt; 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。&lt;/p&gt;
&lt;p&gt;　　这种模式导致组件依赖全局状态单例&lt;/p&gt;
&lt;p&gt;　　所以，&lt;/p&gt;
&lt;p&gt;　　Vuex 通过 &lt;code&gt;store&lt;/code&gt; 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件&lt;/span&gt;
&lt;span&gt;  store,
  components: { Counter },
  template: `
    &lt;/span&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
      &amp;lt;counter&amp;gt;&amp;lt;/counter&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  `
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　通过在根实例中注册 &lt;code&gt;store&lt;/code&gt; 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 &lt;code&gt;this.$store&lt;/code&gt; 访问到。让我们更新下 &lt;code&gt;Counter&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const Counter =&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;{{ count }}&amp;lt;/div&amp;gt;`,
&lt;span&gt;  computed: {
    count () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.state.count
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;mapState辅助函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，我们可以使用 &lt;code&gt;mapState&lt;/code&gt; 辅助函数帮助我们生成计算属性，让你少按几次键：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在单独构建的版本中辅助函数为 Vuex.mapState&lt;/span&gt;
import { mapState } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  computed: mapState({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 箭头函数可使代码更简练&lt;/span&gt;
    count: state =&amp;gt;&lt;span&gt; state.count,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传字符串参数 'count' 等同于 `state =&amp;gt; state.count`&lt;/span&gt;
    countAlias: 'count'&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了能够使用 `this` 获取局部状态，必须使用常规函数&lt;/span&gt;
&lt;span&gt;    countPlusLocalState (state) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.count + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localCount
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;3、详解(Getter)&lt;/p&gt;
&lt;p&gt;　　个人理解：&lt;span&gt;相当于获取计算后的state&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。&lt;/p&gt;
&lt;p&gt;　　就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，&lt;/p&gt;
&lt;p&gt;　　且只有当它的依赖值发生了改变才会被重新计算。&lt;/p&gt;

&lt;p&gt;　　Getter 接受 state 作为其第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    todos: [
      { id: &lt;/span&gt;1, text: '...', done: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
      { id: &lt;/span&gt;2, text: '...', done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; }
    ]
  },
  getters: {
    doneTodos: state &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.filter(todo =&amp;gt;&lt;span&gt; todo.done)
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Getter 会暴露为 &lt;code&gt;store.getters&lt;/code&gt; 对象，你可以以属性的形式访问这些值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
store.getters.doneTodos &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; [{ id: 1, text: '...', done: true }]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Getter 也可以接受其他 getter 作为第二个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;getters: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  doneTodosCount: (state, getters) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getters.doneTodos.length
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;getters: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  getTodoById: (state) =&amp;gt; (id) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state.todos.find(todo =&amp;gt; todo.id ===&lt;span&gt; id)
  }
}



store.getters.getTodoById(&lt;/span&gt;2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; { id: 2, text: '...', done: false }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;mapGetters辅助函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　仅仅是将 store 中的 getter 映射到局部计算属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import { mapGetters } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  computed: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用对象展开运算符将 getter 混入 computed 对象中&lt;/span&gt;
&lt;span&gt;    ...mapGetters([
      &lt;/span&gt;'doneTodosCount'&lt;span&gt;,
      &lt;/span&gt;'anotherGetter'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    ])
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;4、详解(Mutation)&lt;/p&gt;
&lt;p&gt;　　更改 Vuex 的 store 中的状态的唯一方法是提交 mutation&lt;/p&gt;
&lt;p&gt;　　Vuex 中的 mutation 非常类似于事件：&lt;/p&gt;
&lt;p&gt;　　每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。&lt;/p&gt;
&lt;p&gt;　　这个回调函数就是我们实际进行状态更改的地方，&lt;/p&gt;
&lt;p&gt;　　并且它会接受 state 作为第一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const store = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
  state: {
    count: &lt;/span&gt;1&lt;span&gt;
  },
  mutations: {
    increment (state) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变更状态&lt;/span&gt;
      state.count++&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;language-js&quot;&gt;
&lt;code&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;commit&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token string&quot;&gt;'increment'&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以向 &lt;code&gt;store.commit&lt;/code&gt; 传入额外的参数，即 mutation 的 载荷（payload）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;mutations: {
  increment (state, n) {
    state.count &lt;/span&gt;+=&lt;span&gt; n
  }
}



store.commit(&lt;/span&gt;'increment', 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　mutation 必须是同步函数&lt;/p&gt;
&lt;p&gt;　　&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
　　你可以在组件中使用 &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; 提交 mutation，&lt;/p&gt;
&lt;p&gt;　　或者使用 &lt;code&gt;mapMutations&lt;/code&gt; 辅助函数将组件中的 methods 映射为 &lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;store.commit&lt;/code&gt; 调用（需要在根节点注入 &lt;code&gt;store&lt;/code&gt;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import { mapMutations } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  methods: {
    ...mapMutations([
      &lt;/span&gt;'increment', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.increment()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;

      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; `mapMutations` 也支持载荷：&lt;/span&gt;
      'incrementBy' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`&lt;/span&gt;
&lt;span&gt;    ]),
    ...mapMutations({
      add: &lt;/span&gt;'increment' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.add()` 映射为 `this.$store.commit('increment')`&lt;/span&gt;
&lt;span&gt;    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;5、详解（Action)&lt;/p&gt;
&lt;p&gt;　　Action 类似于 mutation，不同在于：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Action 提交的是 mutation，而不是直接变更状态。&lt;/li&gt;
&lt;li&gt;Action 可以包含任意异步操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;　　我们可以在 action 内部执行异步操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  incrementAsync ({ commit }) {
    setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      commit(&lt;/span&gt;'increment'&lt;span&gt;)
    }, &lt;/span&gt;1000&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Actions 支持同样的载荷方式和对象方式进行分发： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以载荷形式分发&lt;/span&gt;
store.dispatch('incrementAsync'&lt;span&gt;, {
  amount: &lt;/span&gt;10&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以对象形式分发&lt;/span&gt;
&lt;span&gt;store.dispatch({
  type: &lt;/span&gt;'incrementAsync'&lt;span&gt;,
  amount: &lt;/span&gt;10&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在组件中使用 &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; 分发 action，&lt;/p&gt;
&lt;p&gt;　　或者使用 &lt;code&gt;mapActions&lt;/code&gt; 辅助函数将组件的 methods 映射为 &lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;store.dispatch&lt;/code&gt; 调用（需要先在根节点注入 &lt;code&gt;store&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import { mapActions } from 'vuex'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  methods: {
    ...mapActions([
      &lt;/span&gt;'increment', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`&lt;/span&gt;

      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; `mapActions` 也支持载荷：&lt;/span&gt;
      'incrementBy' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`&lt;/span&gt;
&lt;span&gt;    ]),
    ...mapActions({
      add: &lt;/span&gt;'increment' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 `this.add()` 映射为 `this.$store.dispatch('increment')`&lt;/span&gt;
&lt;span&gt;    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;code&gt;store.dispatch&lt;/code&gt; 可以处理被触发的 action 的处理函数返回的 Promise，&lt;/p&gt;
&lt;p&gt;　　并且 &lt;code&gt;store.dispatch&lt;/code&gt; 仍旧返回 Promise：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  actionA ({ commit }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        commit(&lt;/span&gt;'someMutation'&lt;span&gt;)
        resolve()
      }, &lt;/span&gt;1000&lt;span&gt;)
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一个action中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
store.dispatch('actionA').then(() =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　另一个action中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;actions: {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  actionB ({ dispatch, commit }) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dispatch('actionA').then(() =&amp;gt;&lt;span&gt; {
      commit(&lt;/span&gt;'someOtherMutation'&lt;span&gt;)
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们利用 &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;async / await&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设 getData() 和 getOtherData() 返回的是 Promise&lt;/span&gt;
&lt;span&gt;
actions: {
  async actionA ({ commit }) {
    commit(&lt;/span&gt;'gotData'&lt;span&gt;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&lt;/span&gt;'actionA') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待 actionA 完成&lt;/span&gt;
    commit('gotOtherData'&lt;span&gt;, await getOtherData())
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一个 &lt;code&gt;store.dispatch&lt;/code&gt; 在不同模块中可以触发多个 action 函数。&lt;/p&gt;
&lt;p&gt;　　在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。&lt;/p&gt;





&lt;p&gt;以后再更。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 07:00:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>vuex详解 yarn add vuex 1、vuex流程图 vuex可以帮助我们管理组件间公共的数据 创建一个 store 现在，你可以通过 store.state 来获取状态对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10096540.html</dc:identifier>
</item>
<item>
<title>多线程学习笔记四之Condition实现分析 - 默数至天亮</title>
<link>http://www.cnblogs.com/rain4j/p/10096513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rain4j/p/10096513.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;  在使用内置锁synchronized时，通过调用java.lang.Objec中定义的监视器方法，主要有wait()、wait(long timeout)、notify()和notifyAll()方法，可以实现等待/通知模式。Codition接口中也定义了类似的监视器方法，与显示锁Lock配合使用也可以实现等待/通知模式。&lt;br/&gt;  当线程需要利用Condition对象进行等待时，需要提前获取到Condition对象关联的显示锁Lock对象，使用案例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    //等待
    public void coditionWait() throws InterruptedException {
        lock.lock();
        try {
            condition.await();
        }finally {
            lock.unlock();
        }
    }

    //通知
    public void coditionSignal() throws InterruptedException {
        lock.lock();
        try {
            condition.signal();
        }finally {
            lock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  Condition接口由同步器AbstractQueuedSynchronizer内部类ConditionObject提供实现，而显示锁Lock对象实现时内部类Sync会继承AQS,从而把Condition对象与Lock对象关联起来。&lt;/p&gt;
&lt;h3 id=&quot;等待队列&quot;&gt;等待队列&lt;/h3&gt;
&lt;p&gt;  在上一篇博客中介绍到为了处理多个线程竞争同一把锁，同步器AQS中维护了一个先入先出的双向同步队列，让竞争失败的线程进入同步队列等待。同样，AQS在实现Condition接口也维护了一个先入先出的单向等待队列，当一个与Lock对象关联的Condition对象调用await方法，获得锁的线程就要释放锁，并推出同步队列head头节点，进入condition等待队列。condition队列规定了头节点firstWaiter和尾节点lastWaiter。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConditionObject implements Condition, java.io.Serializable {
        private static final long serialVersionUID = 1173984872572414699L;
        /** First node of condition queue. */
        private transient Node firstWaiter;
        /** Last node of condition queue. */
        private transient Node lastWaiter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156589/201812/1156589-20181210145631272-455872242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS中构建等待队列复用了内部类Node结点类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final class Node {
        //等待状态
        volatile int waitStatus;

        //前驱结点
        volatile Node prev;
    
        //后继节点
        volatile Node next;
        
        //等待获取锁的线程
        volatile Thread thread;
        
        //condition队列的后继节点
        Node nextWaiter;      
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nextwaiter&quot;&gt;nextWaiter&lt;/h3&gt;
&lt;p&gt;  从上图可以发现，Condition等待队列是一个先入先出的单向链表，从链表尾部加入元素，头部移出链表。使用nextWaiter指向下一个等待节点，构成链表的基本元素是节点Node，复用了AQS中的Node类，nextWaiter并不单单在Condition链表指向下一个等待节点。这是Node类定义nextWaiter的注释：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Link to next node waiting on condition, or the special value SHARED. Because condition queues are accessed only when holding in exclusive mode, we just need a simple linked queue to hold nodes while they are waiting on conditions. They are then transferred to the queue to re-acquire. And because conditions can only be exclusive,we save a field by using special value to indicate sharedmode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意是只有独占锁才会关联Condition队列，通过nextWaiter变量在构成同步队列节点标识同步锁是独占锁还是共享锁，从以下方法可以看出AQS使用nextWaiter来表示锁：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    //判断是否是共享锁
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    //构建同步队列节点，nextWaiter标识同步锁是独占锁还是共享锁
    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    //构建等待队列节点，nextWaiter指向单向链表下一个节点
    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上分析可以看出：AQS复用了Node类来构建同步队列和等待队列，Node用来构建同步队列节点，nextWaiter标识同步锁是独占锁还是共享锁；Node用来构建等待队列节点，nextWaiter指向单向链表下一个节点。刚开始看这一部分时，对我造成了很大的困扰，所以特地写出来。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;await&quot;&gt;await()&lt;/h3&gt;
&lt;p&gt;  await实现等待考虑到了中断，若当前线程等待期间发生中断，抛出InterruptedException异常。线程在等待期间会被阻塞，直到发生中断或者Condition对象调用signal方法。基本流程：首先将node加入condition队列，然后释放锁，挂起当前线程等待唤醒，唤醒后线程重新进入同步队列并调用acquireQueued获取锁。流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156589/201812/1156589-20181210145705552-315691163.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        //将当前线程加入Condition等待队列          
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        //判断当前线程是否在同步队列中
        while (!isOnSyncQueue(node)) {
            //阻塞当前线程
            LockSupport.park(this);
            //在阻塞的过程中发生中断
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        //被其他线程唤醒，退出Condition等待队列加入同步队列
        //获取锁
        if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;addConditionWaiter()&lt;br/&gt;  以当前线程构成节点Node加入等待队列，因为加入Condition等待队列在释放锁之前，所以不需要考虑并发的情况，就不需要像加入同步队列采用循环加CAS的机制。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private Node addConditionWaiter() {
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        //如果尾节点lastWaiter等待状态是CANCELLED，将队列所有CANCELLED节点清除
        if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        //以当前线程构成节点
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        //尾节点为空，等待队列为空，进行初始化，当前节点是等待队列的头节点
        if (t == null)
            firstWaiter = node;
        //否则添加到等待队列的尾部，当前节点是等待队列新的lastWaiter
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }


    //unlinkCancelledWaiters方法遍历CONDITION队列，删除状态为CANCELLED的节点。
    private void unlinkCancelledWaiters() {
        //首节点
        Node t = firstWaiter;
        //保存遍历节点前驱节点的引用
        Node trail = null;
        //单向链表从前往后遍历
        while (t != null) {
            //下一个节点
            Node next = t.nextWaiter;
            //节点t的waitStatus为CANCELLED
            if (t.waitStatus != Node.CONDITION) {
                 t.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                     trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            }
            else
                trail = t;
            t = next;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;fullyRelease(Node node)&lt;br/&gt;  完全释放锁,释放成功则返回，失败则将当前节点(在Condition队列)的状态设置成CANCELLED表示当前节点失效&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            //获取同步状态
            int savedState = getState();
            //如果是重入锁，要多次释放
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;isOnSyncQueue(Node node)&lt;br/&gt;  判断node节点是否被signal方法从condition队列转移到同步队列&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final boolean isOnSyncQueue(Node node) {
        //转移到同步队列，CONDITION状态会被清除
        //同步队列prev表示前驱结点，不为null
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        //同步队列next表示后继节点，不为null
        if (node.next != null) // If has successor, it must be on queue
            return true;
        /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
        //遍历同步队列，一个一个找
        return findNodeFromTail(node);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;checkInterruptWhileWaiting(Node node)&lt;br/&gt;  检查当前线程在等待状态时中断状态，返回REINTERRUPT标志位，退出等待状态时调用selfInterrupt方法产生中断；返回THROW_IE标志位，线程退出等待状态时会抛出InterruptedException异常。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        //表示从等待状态退出时会重新产生一个中断，但不会抛出异常
        private static final int REINTERRUPT =  1;
        //从等待状态退出时抛出InterruptedException异常
        private static final int THROW_IE    = -1;

        /**
         * Checks for interrupt, returning THROW_IE if interrupted
         * before signalled, REINTERRUPT if after signalled, or
         * 0 if not interrupted.
         */
        private int checkInterruptWhileWaiting(Node node) {
            return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;reportInterruptAfterWait(int interruptMode)&lt;br/&gt;  根据interruptMode对应的标志位响应中断&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void reportInterruptAfterWait(int interruptMode)
        throws InterruptedException {
        //产生异常
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        //产生中断
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signal&quot;&gt;signal()&lt;/h3&gt;
&lt;p&gt;  检查当前线程是否占据独占锁，唤醒等待在当前Condition对象等待最久的线程（等待队列的头节点）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public final void signal() {
        //检查当前线程是否占据独占锁，如果不是没有权限唤醒等待线程，抛出异常
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }

    private void doSignal(Node first) {
        do {
            if ( (firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
        } while (!transferForSignal(first) &amp;amp;&amp;amp;
                (first = firstWaiter) != null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;transferForSignal(Node node)&lt;br/&gt;  将当前线程从Condition等待队列转移到同步队列中，看到这里应该明白为什么await方法以节点是否在同步队列（isOnSyncQueue(node)）做为循环条件了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        //如果CAS设置失败，说明节点在signal之前被取消了，返回false
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
        
        //CAS设置成功，入队
        //插入节点的前驱节点
        Node p = enq(node);
        //前驱节点的等待状态
        int ws = p.waitStatus;
        //如果p等待状态为CANECLLED或对p进行CAS设置失败，则唤醒线程，让node中线程进入acquireQueued方法。否则
        //由于前驱节点等待状态为signal，由同步器唤醒线程
        if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signalall&quot;&gt;signalAll()&lt;/h3&gt;
&lt;p&gt;  将等待队列所有节点依次转移到同步队列末尾。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignalAll(first);
    }

    private void doSignalAll(Node first) {
        lastWaiter = firstWaiter = null;
        do {
            //first节点从condition队列移出
            Node next = first.nextWaiter;
            first.nextWaiter = null;
            //first节点加入同步队列
            transferForSignal(first);
            //更新first节点指向
            first = next;
        } while (first != null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;  以上是对AQS中内部类ConditionObject对Condition接口实现的简单分析。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 06:58:00 +0000</pubDate>
<dc:creator>默数至天亮</dc:creator>
<og:description>[TOC] 简介   在使用内置锁synchronized时，通过调用java.lang.Objec中定义的监视器方法，主要有wait()、wait(long timeout)、n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rain4j/p/10096513.html</dc:identifier>
</item>
</channel>
</rss>