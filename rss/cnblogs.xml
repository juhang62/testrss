<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>if语句的嵌套以及条件运算符和条件表达式（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10226712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10226712.html</guid>
<description>&lt;p&gt;1、当if语句中的执行语句又是if语句时，则构成了if语句的嵌套情形。&lt;/p&gt;
&lt;p&gt;其一般形式可表示为：&lt;/p&gt;
&lt;p&gt;if()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;　　if()……;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;if()&lt;/p&gt;
&lt;p&gt;　　if()语句1；&lt;/p&gt;
&lt;p&gt;　　else 语句2；&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;　　if()语句3；&lt;/p&gt;
&lt;p&gt;　　else 语句4；&lt;/p&gt;
&lt;p&gt;注：if语句的嵌套不要太多，最好不超过5个。（避免逻辑错误）&lt;/p&gt;
&lt;p&gt;在嵌套内的if语句可能又是if-else型，这将会出现多个if和多个else重叠的情况，这时要特别注意if和else的配对问题。&lt;/p&gt;
&lt;p&gt;例：if（表达式1）&lt;/p&gt;
&lt;p&gt;　　if（表达式2）&lt;/p&gt;
&lt;p&gt;　　　　语句1；&lt;/p&gt;
&lt;p&gt;　　else&lt;/p&gt;
&lt;p&gt;　　　　语句2；&lt;/p&gt;
&lt;p&gt;思考：else究竟与哪一个if配对呢？&lt;/p&gt;
&lt;p&gt;就近原则：为避免二义性，C语言规定，else总是与它前面最近的if配对。所以应理解为;&lt;/p&gt;
&lt;p&gt;if(表达式1)&lt;/p&gt;
&lt;p&gt;　　if(表达式2)&lt;/p&gt;
&lt;p&gt;　　　　语句1；&lt;/p&gt;
&lt;p&gt;　　else&lt;/p&gt;
&lt;p&gt;　　　　语句2；&lt;/p&gt;
&lt;p&gt;比较下列两例，哪一个是运用嵌套方法？&lt;/p&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input A,B &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a!=&lt;span&gt;b)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;gt;b)  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&amp;gt;B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&amp;lt;B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A=B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input A,B &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==b) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A=B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(a&amp;gt;b)  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&amp;gt;B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&amp;lt;B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：采用嵌套结构实质上是为了进行多分支选择，实际上有三种选择，即：A&amp;gt;B、A&amp;lt;B或A=B。这种问题用if-else-if语句也可以完成，而且程序更加清晰。因此，在一般情况下较少使用if语句的嵌套结构，以使程序更便于阅读理解。&lt;/p&gt;
&lt;p&gt;2、条件运算符和条件表达式&lt;/p&gt;
&lt;p&gt;条件运算符为“？和：”是一个三目运算符。&lt;/p&gt;
&lt;p&gt;由条件运算符组成的条件表达式的一般形式为：&lt;/p&gt;
&lt;p&gt;表达式1？表达式2：表达式3&lt;/p&gt;
&lt;p&gt;其求值规则为：若表达式1的值为真，则以表达式2的值作为条件表达式的值，否则以表达式3的值作为整个条件表达式的值&lt;/p&gt;
&lt;p&gt;条件表达式通常用于赋值语句之中：&lt;/p&gt;
&lt;p&gt;例：if(a&amp;gt;b) max=a;&lt;/p&gt;
&lt;p&gt;　　　　else max=b;&lt;/p&gt;
&lt;p&gt;可用条件表达式写为：&lt;/p&gt;
&lt;p&gt;max=(a&amp;gt;b)?a:b;&lt;/p&gt;
&lt;p&gt;语义：若a&amp;gt;b为真，则把a赋予max，否则把b赋予max。&lt;/p&gt;
&lt;p&gt;注意：（1）条件运算符的运算优先级低于关系运算符和算术运算符，但高于赋值运算符。因此max=(a&amp;gt;b)?a:b;可改为max=a&amp;gt;b?a:b;&lt;/p&gt;
&lt;p&gt;（2）条件运算符？和：是一对运算符，&lt;span&gt;&lt;strong&gt;不能分开单独使用&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（3）条件运算符的结合方向是&lt;span&gt;&lt;strong&gt;自右向左&lt;/strong&gt;&lt;/span&gt;。如：a&amp;gt;b?a:c&amp;gt;d?c:d应理解为a&amp;gt;b?a:(c&amp;gt;d?c:d)&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,max;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n please input two nubers &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a&amp;gt;b?&lt;span&gt;a:b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补例：输入一个字符，判断它是否为大写字母，如果是，把它转换成小写字母，如果不是，不转换。然后输出最后得到的字符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;ch);
    ch&lt;/span&gt;=(ch&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;ch&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)?(ch+&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):ch;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ch);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 05 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>1、当if语句中的执行语句又是if语句时，则构成了if语句的嵌套情形。 其一般形式可表示为： if() { if()……; } 或： if() if()语句1； else 语句2； else if()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10226712.html</dc:identifier>
</item>
<item>
<title>Java项目排查cpu负载高 - WindsJune</title>
<link>http://www.cnblogs.com/wind-june/p/10212609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-june/p/10212609.html</guid>
<description>&lt;p&gt;　　我负责的其中一个项目在空负载的情况下，CPU占用率依然保持着100%左右，线上、测试、开发的服务都一样；是什么导致的呢？在开发环境我查看了请求流量，这个流量可以忽略但CPU占用率一直在60%-100%之间浮动。&lt;/p&gt;

&lt;p&gt;　　流量可以忽略，但CPU占用依然极其高说明不是请求多导致的资源占用，原因应该是项目本身自发导致的；自发包括定时任务与死循环，而具体哪一段代码现在也确定不了。现在我们就可以借助原生的jdk分析工具来定位是项目哪块出现了问题(你可以用更高级的jprofilter等，一连接，问题一目了然)，以下我就采用jdk自带工具jstack、jstat 、jmap等来逐步定位。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在Linux环境下用top查看cpu、内存等资源占用情况(可采用: top -p pid 具体查看某个应用)。发现pid=4179的java应用占用cpu很高　　&lt;/strong&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201901/1485316-20190103094724716-418750385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 查看pid=4179的应用各个线程占用cpu的时间片情况：ps -mp 4179 -o THREAD,tid,time (ps -mp pid -o THREAD,tid,time)。发现tid =4528的线程一直长时间占有着cpu并且占用率达100%&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201901/1485316-20190103095039469-655671724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将 4528转为16进制，便于在堆栈信息中查询定位代码块：printf &quot;%x\n&quot; 4528，转成16进制为 11b0&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201901/1485316-20190103095509051-688083691.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在堆栈信息中定位报错代码块：jstack 4179|grep 11b0 -A 30 ( jstack pid|grep TID(16进制) -A 30 )&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201901/1485316-20190103095630877-577327286.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　从堆栈信息中我们可以看到是 WAITING导致，这个说明有一个线程长时间占用资源，而其他线程一直处于等待的状态。最终定位出是在一个分布式锁实现的模块中有一个保持锁的代码块有问题。然后通过优化这个分布式锁最终解决了这个问题。通过此次优化，大大节省出了服务器资源(目前这个系统在线上是4台集群，相当于节省了1*4 个cpu，如果是一个上百甚至上千的集群，那么这个资源占用是无法想象的)，最主要的是避免了这种情况对系统本身的影响，避免了对正常请求的阻塞。&lt;/p&gt;

</description>
<pubDate>Sat, 05 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>WindsJune</dc:creator>
<og:description>背景 我负责的其中一个项目在空负载的情况下，CPU占用率依然保持着100%左右，线上、测试、开发的服务都一样；是什么导致的呢？在开发环境我查看了请求流量，这个流量可以忽略但CPU占用率一直在60%-1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-june/p/10212609.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记一：code-first简单创建数据库、表的一些过程 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10226763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10226763.html</guid>
<description>
&lt;p&gt;我的EF学习笔记是按照 汪鹏（网名Jeffcky） 大侠《你必须掌握的Entity Framework 6.x与Core 2.0》来弄的。&lt;/p&gt;
&lt;p&gt;这也是我第一篇博客，感觉这东西不能乱写啊，算了，干吧。&lt;/p&gt;
&lt;p&gt;EF我之前是做过的，但是只是一些零碎的东西，不成系统。&lt;/p&gt;
&lt;p&gt;EF是什么呢？ORM框架object renational mapping 对象关系映射，下面我就用自己的话来了。&lt;/p&gt;
&lt;p&gt;数据库里面存放数据用表，而我们程序代码使用类，一个是数据世界的弄法，一个是对象世界的弄法。EF就是为我们做这种对象映射的处理，让我可以不用关心数据库，只关系类 怎么设计就行了。&lt;/p&gt;
&lt;p&gt;我说完了。它主要就是这个对吧，当然会有其他的很多东西，通过程序直接创建数据库，然后更多的精力放到了类上，业务逻辑上，突然多出来的精力没处使，是不是就弄出了什么领域驱动设计？&lt;/p&gt;

&lt;p&gt;现在来创建一个控制台程序，安装EF，打开程序包管理控制台输入命令：install-package entityframework &lt;/p&gt;
&lt;p&gt;创建Blog类，写一个EFDbContext类,这个类派生自DbContext,为blog公开一个DbSet属性&lt;/p&gt;
&lt;p&gt;然后在main方法里面实例化上下文对象，添加一个blog实例，接着查询这个实例，打印出来&lt;/p&gt;
&lt;p&gt;然后控制台大概过了十多秒，看到了刚刚添加的数据，那么简单的创建数据库、表就完了~&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
namespace _20190105
{
    public class Blog
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Url { get; set; }
        public DateTime? CreatedTime { get; set; }
        public double Double { get; set; }
        public float Float { get; set; }
        
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace _20190105
{
    //  此上下文是与数据库交互的一个中间桥梁，可以称之为会话，为每一个模型公开一个DbSet&amp;lt;&amp;gt;,定义DbSet有三种方式
    public class EFDbContext:DbContext
    {
        // DbSet 三种设计方式，不太懂，我随便弄了一种
        //public DbSet&amp;lt;Blog&amp;gt; Blog { get; set; }
        //public IDbSet&amp;lt;Blog&amp;gt; Blog { get; set; }
        public DbSet&amp;lt;Blog&amp;gt; Blog {
            get { return Set&amp;lt;Blog&amp;gt;(); }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace _20190105
{
    class Program
    {
        static void Main(string[] args)
        {
            //  上下文实例化，添加一个blog实例
            using (EFDbContext db = new EFDbContext())
            {
                db.Blog.Add(new Blog
                {
                    CreatedTime = DateTime.Now,
                    Double = 11.11,
                    Float = 2.2f,
                    ID = 1,
                    Name = &quot;第er篇博客&quot;,
                    Url = &quot;http://localhost:8080&quot;
                });
                db.SaveChanges();

                Console.WriteLine(JsonConvert.SerializeObject(db.Blog.ToList()));
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105223444620-1052192464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;hr/&gt;

&lt;p&gt;来看看数据库，对照着模型看一下，数据库和表是什么样子的。这里要注意一点，如果是按照上面的几步操作，EF默认会给我们把数据库创建到localdb里面&lt;/p&gt;
&lt;p&gt;localdb是个什么玩意，他也是个数据库，但是这和我们SQL server数据库管理工具创建的数据库有什么不一样呢？网上说这个localdb完全是为了针对开发人员使用的，一个数据库最大容量为10G，那他到底是在安装VS的时候安装的，还是在装SQLserver安装的呢？&lt;/p&gt;
&lt;p&gt;要查看刚刚创建的数据库，在VS上点击“视图”--&amp;gt;&quot;SQL server数据库对象资源管理器&quot;，也可以通过SQL server去连接它&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105224005349-621583517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过SQL server管理工具连接到这个localdb,有可能你的机器上没有安装这个localdb，我这个没有刻意去安装，反正就是有这个东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105224124687-976214349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，数据库创建在localdb里面，数据库的名称是我们项目命名空间+上下文类名&lt;/p&gt;
&lt;p&gt;然后我们看表名，我们的DbSet&amp;lt;&amp;gt;属性是Blog,但是在数据库里面表明成了Blogs，变成复数形式了&lt;/p&gt;
&lt;p&gt;然后我们看字段，ID默认给我弄成了主键，并且设置为自增长&lt;/p&gt;
&lt;p&gt;string类型对应nvarchar(max),并且允许为空&lt;/p&gt;
&lt;p&gt;double类型对应float&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;float类型对应real&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;datetime?可空类型对应datetime,可空&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;刚刚我添加一个条数据，ID为1，现在我又添加一个blog实例，ID还是1，但是没有报错，正确插入进去了，ID自增长为2&lt;/p&gt;


&lt;p&gt;然后我在Blog中添加一个字段Test，再次运行，报错&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;未经处理的异常:  System.InvalidOperationException: The model backing the 'EFDbContext' context has changed since the database was created. Consider using Code First Migrations to update the database (&lt;img alt=&quot;&quot;/&gt;http://go.microsoft.com/fwlink/?LinkId=238269).&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;他说模型放生了改变，让我用codefirst 迁移来更新数据库 &lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;行，然后我在程序包管理器控制台输入 add-migration jinshantest，报错&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;No migrations configuration type was found in the assembly '20190105'. (In Visual Studio you can use the Enable-Migrations command from Package Manager Console to add a migrations configuration).&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;54&quot;&gt;
&lt;p&gt;他说没有在程序集中发现迁移配置类型，可以使用enable-migrations添加配置&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;就是说要用这个迁移，要先执行 enable-migrations 命令来开启一下迁移，这些命令不区分大小写&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我执行了命令：enable-migrations 发现我的项目中被创建了一个Migrations文件夹，里面有两个文件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105225111607-1112551120.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;但是我并没有看到刚刚添加的那个Test属性，先不管，我们直接更新看看&lt;br/&gt;输入命令:update-database&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105225319555-1684083947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后他说没有挂起的显示迁移，什么意思，不就是说没什么可以更新的吗？&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;然后我再次生成一个新的迁移类文件，&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;输入命令：add-magration jinshantest  这个jinshantest就是你为这个迁移文件取的一个名字&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105225527689-494821909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就有了。&lt;/p&gt;
&lt;p&gt;那么现在就更新到数据库里面吧，现在我们再来执行迁移：update-database -verbose   加上-verbose就是显示迁移的详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105225830717-2050836156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到它根据迁移文件的内容，生成了创建列的SQL语句，并更新到了数据库&lt;/p&gt;


&lt;p&gt; 我现在又想到，我再添加一个字段“Test2”并且设置为非空，看看它能不能给我更新到数据库，更新之后是什么样子，这需求很正常吧&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105230021574-1341830767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改动了模型就要做数据迁移，继续add-migration jinshantest2 生成迁移文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105230200470-989556924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以的，他生成的SQL语句是下面这样的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ALTER TABLE [dbo].[Blogs] ADD [Test2] [nvarchar](max) NOT NULL DEFAULT ''&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;hr/&gt;
&lt;p&gt;现在我想要EF面向我的SQL server 而不是localDB&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;那么我需要在app.config文件中加上数据库连接字符串的配置，他要其他的我也不会去配，因为Code-first不就是不用到处配东西，直接写代码就行吗？ Initial Catlog=TestDB,这个TestDB在我数据库里面不存在，我当然不会弄一个已存在的数据库，我的目的就是要让它给我创建数据库&lt;/em&gt;&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105230706969-217826111.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;然后修改我们的Dbcontext文件，告诉EF我们的数据库连接字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190105230813178-2104591140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我运行程序，报错了：&lt;span&gt;找不到对象“dbo.Blogs”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我检查我的的SQL server 里面什么都没有。&lt;/p&gt;
&lt;p&gt;难道是因为我Main方法里有做数据持久化的代码，他在插入数据的时候找不到表，就报错了？&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;刚刚在localDB里面不是好好的吗？在对localDB操作的时候，我什么都没做，他自动给我创建数据库，创建表&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;难道我现在还要在SQL server中创建一个数据库然后创建一个表？那要你做什么？&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;行，我弄了下，大概知道了，我要先做数据迁移才行，就是把刚刚的那些迁移文件现在针对我的SQL server执行，于是命令行输入：update-database -verbose&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;行了，数据库和表都有了。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; SQLserver 和localDB就是这一点区别，localDB不用先迁移。&lt;/p&gt;
&lt;p&gt;后面还有其他的很多配置，不过总算是能够简单地创建数据库和表了，并且修改model后，我们利用数据迁移对数据库做更新，还是比较完整吧。&lt;/p&gt;
&lt;p&gt;书中的内容都是一点点讲起的，数据迁移在后面才会讲到。书有目录啊，必须跟着目录走啊。我自己随便弄，还是觉得要用一个完整的东西把这些散碎的东西串起来好一些。&lt;/p&gt;

</description>
<pubDate>Sat, 05 Jan 2019 15:31:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>我的EF学习笔记是按照 汪鹏（网名Jeffcky） 大侠《你必须掌握的Entity Framework 6.x与Core 2.0》来弄的。 这也是我第一篇博客，感觉这东西不能乱写啊，算了，干吧。 EF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10226763.html</dc:identifier>
</item>
<item>
<title>java实现12种排序算法 - stringer123</title>
<link>http://www.cnblogs.com/cuilongfei/p/10226750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cuilongfei/p/10226750.html</guid>
<description>&lt;h2 align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;strong&gt;实现的&lt;/strong&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;strong&gt;种排序&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2019-01-05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;一．冒泡排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;二．希尔排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;三．插入排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;四．插入排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;五．快速排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;六．合并排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;七．计数排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;八．基数排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;九．   桶排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; 十．    堆排序及其实现&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;   十一.二叉树排序及有序集合&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;         十二.利用集合的4种排序排序方式&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p align=&quot;center&quot;&gt;一．冒泡排序及其实现&lt;/p&gt;
&lt;p&gt;一．home→包&lt;/p&gt;
&lt;p&gt;BubbleSort→类&lt;/p&gt;
&lt;p&gt;           main→主函数&lt;/p&gt;
&lt;p&gt;                      bubbleSort1()→冒泡排序1&lt;/p&gt;
&lt;p&gt;                      bubbleSort2()→冒泡排序优化1&lt;/p&gt;
&lt;p&gt;                      bubbleSort3()→冒泡排序优化2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 冒泡排序的三种写法
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Stringer123
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BubbleSort {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arr = { 1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; int[] b1 = bubbleSort1(arr);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; int[] b1 = bubbleSort2(arr);&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] b1 =&lt;span&gt; bubbleSort3(arr);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历方式1：java 8新特性（利用Lambda表达式）→通过转成流输出数组&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         Arrays.stream(b1).forEach(item -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             System.out.print(item + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历方式2:通过传统for循环遍历&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; b1.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             System.out.print(b1[i] + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历方式3:通过增强for循环遍历（也成for-each循环）&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : b1) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             System.out.print(i + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p align=&quot;left&quot;&gt;(1) &lt;strong&gt;冒泡排序的第一种实现，没有任何优化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] bubbleSort1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        System.out.println(&lt;/span&gt;&quot;bubbleSort1的排序结果：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; n; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 1; j &amp;lt; n - i; j++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面的数字大于后面的数字就交换&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (a[j - 1] &amp;gt; a[j]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[j-1]和a[j]&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
                    temp &lt;/span&gt;= a[j - 1&lt;span&gt;];
                    a[j &lt;/span&gt;- 1] =&lt;span&gt; a[j];
                    a[j] &lt;/span&gt;=&lt;span&gt; temp;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;(2)&lt;/strong&gt; &lt;strong&gt;冒泡排序的第一种优化实现&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面开始考虑优化，如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，上面的算法就会浪费很多的时间开销，这里设置一个标志flag，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置一个标志，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] bubbleSort2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        System.out.println(&lt;/span&gt;&quot;bubbleSort2的排序结果：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (flag) {
            flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次开始排序前，都设置flag为未排序过&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (j = 1; j &amp;lt; n; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a[j - 1] &amp;gt; a[j]) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面的数字大于后面的数字就交换
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[j-1]和a[j]&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
                    temp &lt;/span&gt;= a[j - 1&lt;span&gt;];
                    a[j &lt;/span&gt;- 1] =&lt;span&gt; a[j];
                    a[j] &lt;/span&gt;=&lt;span&gt; temp;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示交换过数据;&lt;/span&gt;
                    flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            n&lt;/span&gt;--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减小一次排序的尾边界&lt;/span&gt;
        } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; end while&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;(3)&lt;/strong&gt; &lt;strong&gt;冒泡排序的第一种优化实现&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;再进一步做优化。比如，现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字，那么在第一趟遍历后，最后发生交换的位置必定小于100，且这个位置之后的数据必定已经有序了，也就是这个位置以后的数据不需要再排序了，于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，但是前面的100次排序每次都要对后面的900个数据进行比较，而对于现在的排序算法3，只需要有一次比较后面的900个数据，之后就会设置尾边界，保证后面的900个数据不再被排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置一个标志，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] bubbleSort3(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        System.out.println(&lt;/span&gt;&quot;bubbleSort3的排序结果：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (flag) {
            flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次开始排序前，都设置flag为未排序过&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (j = 1; j &amp;lt; n; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a[j - 1] &amp;gt; a[j]) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面的数字大于后面的数字就交换
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[j-1]和a[j]&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
                    temp &lt;/span&gt;= a[j - 1&lt;span&gt;];
                    a[j &lt;/span&gt;- 1] =&lt;span&gt; a[j];
                    a[j] &lt;/span&gt;=&lt;span&gt; temp;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示交换过数据;&lt;/span&gt;
                    flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            n&lt;/span&gt;--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减小一次排序的尾边界&lt;/span&gt;
        } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; end while&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;(4)&lt;/strong&gt; &lt;strong&gt;三种方法&lt;/strong&gt;&lt;strong&gt;console&lt;/strong&gt;&lt;strong&gt;输出显示：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225131631-681373539.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225154401-2013165561.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225210272-1286490211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;二．希尔排序及其实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）操作方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 选择一个增量序列t1，t2，…，tk，其中ti&amp;gt;tj，tk=1；&lt;/p&gt;
&lt;p&gt;2. 按增量序列个数k，对序列进行k 趟排序；&lt;/p&gt;
&lt;p&gt;3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;）希尔排序示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225418395-513239557.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;）希尔排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShellSort {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;希尔排序的原理:根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值
     * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，可以说希尔排序是加强
     * 版的插入排序
     * 拿数组5, 2, 8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列
     * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较
     * 此例子是按照从大到小排列，所以大的会排在前面，第一次排序后数组为9, 2, 8, 5, 1, 3，4
     * 第一次后increment的值变为3/2=1,此时对数组进行插入排序，
     *实现数组从大到小排
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt;[] arr = { 5, 2, 8, 9, 1, 3,4&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] b1 =&lt;span&gt; shellSort(arr);

        System.out.println(&lt;/span&gt;&quot;shellSort排序结果：&quot;&lt;span&gt;);

        Arrays.stream(b1).forEach(item &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            System.out.print(item &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        });

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] shellSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次将步长缩短为原来的一半,increment为步长&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; increment = a.length / 2; increment &amp;gt; 0; increment /= 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = increment; i &amp;lt; a.length; i++&lt;span&gt;) {
                temp &lt;/span&gt;=&lt;span&gt; a[i];
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt;= increment; j -=&lt;span&gt; increment) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp &amp;gt; a[j - increment])&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如想从小到大排只需修改这里&lt;/span&gt;
&lt;span&gt;                    {
                        a[j] &lt;/span&gt;= a[j -&lt;span&gt; increment];
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }

                }
                a[j] &lt;/span&gt;=&lt;span&gt; temp;
            }

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;）控制台输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225551960-858308220.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;三．插入排序及其实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）插入排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InsertSort {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入排序
     * 
     * 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描
     * 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; numbers
     *            待排序数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = { 1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] b1 =&lt;span&gt; insertSort(arr);
        
        System.out.println(&lt;/span&gt;&quot;insertSort排序结果：&quot;&lt;span&gt;);
        Arrays.stream(b1).forEach(item &lt;/span&gt;-&amp;gt; {System.out.print(item + &quot; &quot;&lt;span&gt;);});
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] insertSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++&lt;span&gt;) {
            temp &lt;/span&gt;=&lt;span&gt; a[i];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假如temp比前面的值小，则将前面的值后移&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt; 0 &amp;amp;&amp;amp; temp &amp;lt; a[j - 1]; j--&lt;span&gt;) {
                a[j] &lt;/span&gt;= a[j - 1&lt;span&gt;];
            }
            a[j] &lt;/span&gt;=&lt;span&gt; temp;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105225818864-1395867195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;四．插入排序及其实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）选择排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChooseSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] arr = { 1, 3, 2, 45, 65, 33, 12&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; arr.length;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择排序的优化&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n - 1; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做第i趟排序&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; k =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = k + 1; j &amp;lt; n; j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选最小的记录&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (arr[j] &amp;lt;&lt;span&gt; arr[k]) {
                    k &lt;/span&gt;= j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记下目前找到的最小值所在的位置&lt;/span&gt;
&lt;span&gt;                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i != k) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[i]和a[k]&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[i];
                arr[i] &lt;/span&gt;=&lt;span&gt; arr[k];
                arr[k] &lt;/span&gt;=&lt;span&gt; temp;
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num : arr) {
            System.out.print(num &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105230631654-1289973896.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;五．快速排序及其实现&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一．快速排序&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;//固定的切分方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChooseSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;chooseSort排序结果：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = { 1, 3, 2, 45, 65, 33, 12&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; arr.length;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择排序的优化&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n - 1; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做第i趟排序&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; k =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = k + 1; j &amp;lt; n; j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选最小的记录&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (arr[j] &amp;lt;&lt;span&gt; arr[k]) {
                    k &lt;/span&gt;= j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记下目前找到的最小值所在的位置&lt;/span&gt;
&lt;span&gt;                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i != k) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换a[i]和a[k]&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[i];
                arr[i] &lt;/span&gt;=&lt;span&gt; arr[k];
                arr[k] &lt;/span&gt;=&lt;span&gt; temp;
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num : arr) {
            System.out.print(num &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105230801313-1021718551.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二．&lt;strong&gt;快速排序的优化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于基准位置的选取：随机切分和三取样切分。固定切分的效率并不是太好，随即切分是常用的一种切分，效率比较高，最坏情况下复杂度有可能为O(N^2)，对于三数取中选择基准点是最理想的一种.&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuickSort1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;快速排序优化算法：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] a = {12,20,5,16,15,1,30,45,23,9&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end = a.length-1&lt;span&gt;;
        sort(a,start,end);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt;a.length; i++&lt;span&gt;){
             System.out.print(a[i]&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
         }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; partition(&lt;span&gt;int&lt;/span&gt; []array,&lt;span&gt;int&lt;/span&gt; lo,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hi){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三数取中&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; mid=lo+(hi-lo)/2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(array[mid]&amp;gt;&lt;span&gt;array[hi]){
            swap(array[mid],array[hi]);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(array[lo]&amp;gt;&lt;span&gt;array[hi]){
            swap(array[lo],array[hi]);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(array[mid]&amp;gt;&lt;span&gt;array[lo]){
            swap(array[mid],array[lo]);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; key=&lt;span&gt;array[lo];
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(lo&amp;lt;&lt;span&gt;hi){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(array[hi]&amp;gt;=key&amp;amp;&amp;amp;hi&amp;gt;&lt;span&gt;lo){
                hi&lt;/span&gt;--&lt;span&gt;;
            }
            array[lo]&lt;/span&gt;=&lt;span&gt;array[hi];
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(array[lo]&amp;lt;=key&amp;amp;&amp;amp;hi&amp;gt;&lt;span&gt;lo){
                lo&lt;/span&gt;++&lt;span&gt;;
            }
            array[hi]&lt;/span&gt;=&lt;span&gt;array[lo];
        }
        array[hi]&lt;/span&gt;=&lt;span&gt;key;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hi;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;a;
        a&lt;/span&gt;=&lt;span&gt;b;
        b&lt;/span&gt;=&lt;span&gt;temp;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] array,&lt;span&gt;int&lt;/span&gt; lo ,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hi){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lo&amp;gt;=&lt;span&gt;hi){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index=&lt;span&gt;partition(array,lo,hi);
        sort(array,lo,index&lt;/span&gt;-1&lt;span&gt;);
        sort(array,index&lt;/span&gt;+1&lt;span&gt;,hi);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231003378-1360668727.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;六．合并排序及其实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）合并排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;合并排序算法：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] a = {12,20,5,16,15,1,30,45,23,9&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end = a.length-1&lt;span&gt;;
        sort(a,start,end);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt;a.length; i++&lt;span&gt;){
             System.out.print(a[i]&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
         }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] sort(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = (low + high) / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (low &amp;lt;&lt;span&gt; high) {
            sort(a, low, mid);
            sort(a, mid &lt;/span&gt;+ 1&lt;span&gt;, high);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左右归并&lt;/span&gt;
&lt;span&gt;            merge(a, low, mid, high);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[high - low + 1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; low;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = mid + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把较小的数先移到新数组中&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=&lt;span&gt; high) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a[i] &amp;lt;&lt;span&gt; a[j]) {
                temp[k&lt;/span&gt;++] = a[i++&lt;span&gt;];
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                temp[k&lt;/span&gt;++] = a[j++&lt;span&gt;];
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把左边剩余的数移入数组&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (i &amp;lt;=&lt;span&gt; mid) {
            temp[k&lt;/span&gt;++] = a[i++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把右边边剩余的数移入数组&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (j &amp;lt;=&lt;span&gt; high) {
            temp[k&lt;/span&gt;++] = a[j++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把新数组中的数覆盖nums数组&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = 0; x &amp;lt; temp.length; x++&lt;span&gt;) {
            a[x &lt;/span&gt;+ low] =&lt;span&gt; temp[x];
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231124342-1824291072.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;七．计数排序及其实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）计数排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountingSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] arr = { 1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] b1 =&lt;span&gt; CountingSort(arr);
        System.out.println(&lt;/span&gt;&quot;基计数排序结果：&quot;&lt;span&gt;);
        Arrays.stream(b1).forEach(item &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            System.out.print(item &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        });
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] CountingSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array.length == 0) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bias, min = array[0], max = array[0&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; array.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array[i] &amp;gt;&lt;span&gt; max)
                max &lt;/span&gt;=&lt;span&gt; array[i];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array[i] &amp;lt;&lt;span&gt; min)
                min &lt;/span&gt;=&lt;span&gt; array[i];
        }
        bias &lt;/span&gt;= 0 -&lt;span&gt; min;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] bucket = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[max - min + 1&lt;span&gt;];
        Arrays.fill(bucket, &lt;/span&gt;0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; array.length; i++&lt;span&gt;) {
            bucket[array[i] &lt;/span&gt;+ bias]++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0, i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (index &amp;lt;&lt;span&gt; array.length) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bucket[i] != 0&lt;span&gt;) {
                array[index] &lt;/span&gt;= i -&lt;span&gt; bias;
                bucket[i]&lt;/span&gt;--&lt;span&gt;;
                index&lt;/span&gt;++&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                i&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231241060-994504984.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;八．基数排序及其实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）基数排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；&lt;/p&gt;
&lt;p&gt;基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）算法描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt;  1.取得数组中的最大数，并取得位数。&lt;/p&gt;
&lt;p&gt;     2. arr为原始数组，从最低位开始取每个位组成radix数组。&lt;/p&gt;
&lt;p&gt;     3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;）基数排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RadixSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] arr = { 1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] b1 =&lt;span&gt; RadixSort(arr);
        System.out.println(&lt;/span&gt;&quot;基数排序结果：&quot;&lt;span&gt;);
        Arrays.stream(b1).forEach(item &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            System.out.print(item &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        });
    }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] RadixSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt; || array.length &amp;lt; 2&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.先算出最大数的位数；&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; max = array[0&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; array.length; i++&lt;span&gt;) {
                max &lt;/span&gt;=&lt;span&gt; Math.max(max, array[i]);
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxDigit = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (max != 0&lt;span&gt;) {
                max &lt;/span&gt;/= 10&lt;span&gt;;
                maxDigit&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mod = 10, div = 1&lt;span&gt;;
            ArrayList&lt;/span&gt;&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;)
                bucketList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; maxDigit; i++, mod *= 10, div *= 10&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; array.length; j++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = (array[j] % mod) /&lt;span&gt; div;
                    bucketList.get(num).add(array[j]);
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; bucketList.size(); j++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; bucketList.get(j).size(); k++&lt;span&gt;)
                        array[index&lt;/span&gt;++] =&lt;span&gt; bucketList.get(j).get(k);
                    bucketList.get(j).clear();
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231353962-1973514936.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;九．桶排序及其实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）桶排序代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BucketSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] arr = { 1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22&lt;span&gt; };
        ArrayList &lt;/span&gt;&amp;lt;Integer&amp;gt; n = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
            n.add(arr[i]);
        }
        System.out.println(&lt;/span&gt;&quot;桶排序后的结果&quot;&lt;span&gt;);
        ArrayList resultArr&lt;/span&gt;=&lt;span&gt;BucketSort(n, arr.length);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历方式1&lt;/span&gt;
        System.out.println(&quot;遍历方式1：&quot;&lt;span&gt;);
        Iterator it1 &lt;/span&gt;=&lt;span&gt; resultArr.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it1.hasNext()){
            System.out.print(it1.next()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
        
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历方式2&lt;/span&gt;
&lt;span&gt;        System.out.println();
        System.out.println(&lt;/span&gt;&quot;遍历方式2：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Iterator it2 =&lt;span&gt; resultArr.iterator();it2.hasNext();){
            System.out.print(it2.next()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
       }
        
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历方式3&lt;/span&gt;
&lt;span&gt;        System.out.println();
        System.out.println(&lt;/span&gt;&quot;遍历方式3：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; resultArr.size(); i ++&lt;span&gt;){
            System.out.print(resultArr.get(i)&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
            
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; BucketSort(ArrayList&amp;lt;Integer&amp;gt; array, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt; || array.size() &amp;lt; 2&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max = array.get(0), min = array.get(0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到最大值最小值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; array.size(); i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array.get(i) &amp;gt;&lt;span&gt; max)
                max &lt;/span&gt;=&lt;span&gt; array.get(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array.get(i) &amp;lt;&lt;span&gt; min)
                min &lt;/span&gt;=&lt;span&gt; array.get(i);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bucketCount = (max - min) / bucketSize + 1&lt;span&gt;;
        ArrayList&lt;/span&gt;&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(bucketCount);
        ArrayList&lt;/span&gt;&amp;lt;Integer&amp;gt; resultArr = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; bucketCount; i++&lt;span&gt;) {
            bucketArr.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;());
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; array.size(); i++&lt;span&gt;) {
            bucketArr.get((array.get(i) &lt;/span&gt;- min) /&lt;span&gt; bucketSize).add(array.get(i));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; bucketCount; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bucketSize == 1) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果带排序数组中有重复数字时  &lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; bucketArr.get(i).size(); j++&lt;span&gt;)
                    resultArr.add(bucketArr.get(i).get(j));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bucketCount == 1&lt;span&gt;)
                    bucketSize&lt;/span&gt;--&lt;span&gt;;
                ArrayList&lt;/span&gt;&amp;lt;Integer&amp;gt; temp =&lt;span&gt; BucketSort(bucketArr.get(i), bucketSize);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; temp.size(); j++&lt;span&gt;)
                    resultArr.add(temp.get(j));
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultArr;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231527174-1990879693.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;十．堆排序及其实现&lt;/p&gt;
&lt;p&gt;（1）java实现堆排序&lt;/p&gt;
&lt;p&gt;堆排序是一种树形选择排序方法，它的特点是：在排序的过程中，将array[0，...，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若array[0，...，n-1]表示一颗完全二叉树的顺序存储模式，则双亲节点指针和孩子结点指针之间的内在关系如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;任意一节点指针 i：父节点：i==0 ? null : (i-1)/2&lt;/p&gt;
&lt;p&gt;                 左孩子：2*i + 1&lt;/p&gt;
&lt;p&gt;                 右孩子：2*i + 2&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;堆的定义：n个关键字序列array[0，...，n-1]，当且仅当满足下列要求：(0 &amp;lt;= i &amp;lt;= (n-1)/2)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;①        array[i] &amp;lt;= array[2*i + 1] 且 array[i] &amp;lt;= array[2*i + 2]；称为小根堆；&lt;/p&gt;
&lt;p&gt;②       array[i] &amp;gt;= array[2*i + 1] 且 array[i] &amp;gt;= array[2*i + 2]； 称为大根堆&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立大根堆：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;n个节点的完全二叉树array[0，...，n-1]，最后一个节点n-1是第(n-1-1)/2个节点的孩子。对第(n-1-1)/2个节点为根的子树调整，使该子树称为堆&lt;/p&gt;
&lt;p&gt;对于大根堆，调整方法为：若【根节点的关键字】小于【左右子女中关键字较大者】，则交换。&lt;/p&gt;
&lt;p&gt;之后向前依次对各节点（(n-2)/2 - 1）~ 0为根的子树进行调整，看该节点值是否大于其左右子节点的值，若不是，将左右子节点中较大值与之交换，交换后可能会破坏下一级堆，于是继续采用上述方法构建下一级的堆，直到以该节点为根的子树构成堆为止。&lt;/p&gt;
&lt;p&gt;反复利用上述调整堆的方法建堆，直到根节点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;堆排序：（大根堆）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;                   ①   将存放在array[0，...，n-1]中的n个元素建成初始堆；&lt;/p&gt;
&lt;p&gt;                   ②   将堆顶元素与堆底元素进行交换，则序列的最大值即已放到正确的位置；&lt;/p&gt;
&lt;p&gt;                   ③   但此时堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质，再重复第②③步，直到堆中仅剩下一个元素为止。&lt;/p&gt;
&lt;p&gt;空间复杂度:o(1)；&lt;/p&gt;
&lt;p&gt;时间复杂度:建堆：o(n)，每次调整o(log n)，故最好、最坏、平均情况下：o(n*logn);&lt;/p&gt;
&lt;p&gt;稳定性：不稳定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;java&lt;/strong&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HeapSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        HeapSort hs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeapSort();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] array = { 87, 45, 78, 32, 17, 65, 53, 9, 122&lt;span&gt; };
        System.out.print(&lt;/span&gt;&quot;构建大根堆：&quot;&lt;span&gt;);
        hs.toString(hs.buildMaxHeap(array));
        System.out.print(&lt;/span&gt;&quot;\n&quot; + &quot;删除堆顶元素：&quot;&lt;span&gt;);
        hs.toString(hs.deleteMax(array));
        System.out.print(&lt;/span&gt;&quot;\n&quot; + &quot;插入元素63:&quot;&lt;span&gt;);
        hs.toString(hs.insertData(array, &lt;/span&gt;63&lt;span&gt;));
        System.out.print(&lt;/span&gt;&quot;\n&quot; + &quot;大根堆排序：&quot;&lt;span&gt;);
        hs.toString(hs.heapSort(array));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除堆顶元素操作&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] deleteMax(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将堆的最后一个元素与堆顶元素交换，堆底元素值设为-99999&lt;/span&gt;
        array[0] = array[array.length - 1&lt;span&gt;];
        array[array.length &lt;/span&gt;- 1] = -99999&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对此时的根节点进行向下调整&lt;/span&gt;
        adjustDownToUp(array, 0&lt;span&gt;, array.length);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将元素array[k]自下往上逐步调整树形结构&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; adjustDownToUp(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; array[k];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 2 * k + 1; i &amp;lt; length - 1; i = 2 * i + 1) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i为初始化为节点k的左孩子，沿节点较大的子节点向下调整&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i &amp;lt; length &amp;amp;&amp;amp; array[i] &amp;lt; array[i + 1]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取节点较大的子节点的下标&lt;/span&gt;
                i++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果节点的右孩子&amp;gt;左孩子，则取右孩子节点的下标&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp &amp;gt;= array[i]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根节点 &amp;gt;=左右子女中关键字较大者，调整结束&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根节点 &amp;lt;左右子女中关键字较大者&lt;/span&gt;
                array[k] = array[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将左右子结点中较大值array[i]调整到双亲节点上&lt;/span&gt;
                k = i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 【关键】修改k值，以便继续向下调整&lt;/span&gt;
&lt;span&gt;            }
        }
        array[k] &lt;/span&gt;= temp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被调整的结点的值放人最终位置&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; toString(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : array) {
            System.out.print(i &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建大根堆：将array看成完全二叉树的顺序存储结构&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] buildMaxHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (array.length - 2) / 2; i &amp;gt;= 0; i--&lt;span&gt;) {
            adjustDownToUp(array, i, array.length);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入操作:向大根堆array中插入数据data&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] insertData(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        array[array.length - 1] = data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将新节点放在堆的末端&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; k = array.length - 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要调整的节点&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; parent = (k - 1) / 2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲节点&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (parent &amp;gt;= 0 &amp;amp;&amp;amp; data &amp;gt;&lt;span&gt; array[parent]) {
            array[k] &lt;/span&gt;= array[parent]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲节点下调&lt;/span&gt;
            k =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent != 0&lt;span&gt;) {
                parent &lt;/span&gt;= (parent - 1) / 2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续向上比较&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根节点已调整完毕，跳出循环&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        array[k] &lt;/span&gt;= data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将插入的结点放到正确的位置&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 堆排序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] heapSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        array = buildMaxHeap(array); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始建堆，array[0]为第一趟值最大的元素&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = array.length - 1; i &amp;gt; 1; i--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = array[0]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将堆顶元素和堆低元素交换，即得到当前最大元素正确的排序位置&lt;/span&gt;
            array[0] =&lt;span&gt; array[i];
            array[i] &lt;/span&gt;=&lt;span&gt; temp;
            adjustDownToUp(array, &lt;/span&gt;0, i); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整理，将剩余的元素整理成堆&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105231739780-1402815257.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;十一.二叉树排序及有序集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BinaryTree类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinaryTree {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Node { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明一个节点类&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Comparable data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的数据类型为Comparable&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Node left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存左子树&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Node right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存右子树&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; Node(Comparable data) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addNode(Node newNode) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确定是放在左子树还是右子树&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (newNode.data.compareTo(&lt;span&gt;this&lt;/span&gt;.data) &amp;lt; 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新节点值小于当前节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = newNode; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左子树为空的话，新节点设为左子树&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left.addNode(newNode); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则继续向下判断&lt;/span&gt;
&lt;span&gt;                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新节点的值大于或等于当前节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.right == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right =&lt;span&gt; newNode;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.right.addNode(newNode);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printNode() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 采用中序遍历&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.left != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不为空先输出左子树&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.left.printNode();
            }
            System.out.print(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data + &quot;\t&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出当前根节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.right != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出右子树&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.right.printNode();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node root; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示根元素&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(Comparable data) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向二叉树中插入元素&lt;/span&gt;
        Node newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(data);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有根节点&lt;/span&gt;
            root =&lt;span&gt; newNode;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            root.addNode(newNode); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断放在左子树还是右子树&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        root.printNode(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据根节点输出&lt;/span&gt;
&lt;span&gt;    }
}
BinaryTreeSort类：
&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinaryTreeSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        BinaryTree bt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryTree();
        bt.add(&lt;/span&gt;3&lt;span&gt;);
        bt.add(&lt;/span&gt;5&lt;span&gt;);
        bt.add(&lt;/span&gt;4&lt;span&gt;);
        bt.add(&lt;/span&gt;8&lt;span&gt;);
        bt.add(&lt;/span&gt;7&lt;span&gt;);
        bt.add(&lt;/span&gt;8&lt;span&gt;);
        bt.add(&lt;/span&gt;1&lt;span&gt;);
        bt.print();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105232347696-620908417.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;十二.利用集合的4种排序排序方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; home;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Comparator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.IntSummaryStatistics;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeSet;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt;[] b = { 1, 2, 4, 3, 6, 9, 7, 11, 13, 15&lt;span&gt;, 
                &lt;/span&gt;18, 19, 23, 34, 56, 1000, 23, 78, 890, 908&lt;span&gt; };
       
        System.out.println(&lt;/span&gt;&quot;sort1()结果显示：&quot;&lt;span&gt;);
        Sort1(b);
        huanhang();
        
        System.out.println(&lt;/span&gt;&quot;sort2()结果显示：&quot;&lt;span&gt;);
        Sort2(b);
        huanhang();
        
        System.out.println(&lt;/span&gt;&quot;sort3()结果显示：&quot;&lt;span&gt;);
        Sort3(b);
        huanhang();
        
        System.out.println(&lt;/span&gt;&quot;sort4()结果显示：&quot;&lt;span&gt;);
        sort4(b);
        huanhang();

    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;换两次行&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; huanhang() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=2;i++&lt;span&gt;){
            System.out.println();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort4(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] b) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; b.length; i++&lt;span&gt;) {
            lists.add(b[i]);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排序，直接调用sort方法排序，排序方式是自然排序，即升序排序&lt;/span&gt;
        System.out.println(&quot;利用collections.sort()方法给list排序（默认为升序）：&quot;&lt;span&gt;);
        Collections.sort(lists);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:lists){
            System.out.print(i&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }    
        System.out.println();
        System.out.println(&lt;/span&gt;&quot;利用collections.sort()方法给list降序排序&quot;
                + &quot;（先升序后用collections.reverse()反转）：&quot;&lt;span&gt;);
        System.out.print(&lt;/span&gt;&quot;=============&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;java8使用lamda表达式(forEach方法)对集合进行遍历:&quot;&lt;span&gt;);
        Collections.reverse(lists);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java8使用lamda表达式(forEach方法)对集合进行遍历&lt;/span&gt;
        lists.forEach(obj -&amp;gt; System.out.print(obj+&quot;  &quot;&lt;span&gt;));
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java8使用lamda表达式Iterator的forEachRemaining方法)对集合进行遍历&lt;/span&gt;
        System.out.println(&quot;&quot;&lt;span&gt;);
        System.out.print(&lt;/span&gt;&quot;=============&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;java8使用lamda表达式Iterator的forEachRemaining方法)&quot;
                + &quot;对集合进行遍历:&quot;&lt;span&gt;);
        Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt;lists.iterator();
        it.forEachRemaining(obj&lt;/span&gt;-&amp;gt;System.out.print(obj+&quot;  &quot;&lt;span&gt;));
    }
     
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sort3(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] b) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int数组转化为Integer数组&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; b.length;
        Integer[] iarr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer[n];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++&lt;span&gt;) {
            iarr[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(b[i]);
        }

        List&lt;/span&gt;&amp;lt;Integer&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(iarr.length);
        Collections.addAll(resultList, iarr);

        
        System.out.println(&lt;/span&gt;&quot;利用collections给list排序：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : resultList) {
            System.out.print(i &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sort2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] b) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        @SuppressWarnings(&quot;unused&quot;&lt;span&gt;)

        TreeSet&lt;/span&gt;&amp;lt;Integer&amp;gt; ts = &lt;span&gt;new&lt;/span&gt; &amp;lt;Integer&amp;gt;TreeSet&amp;lt;Integer&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; b.length; i++&lt;span&gt;) {
            ts.add(b[i]);
        }

        System.out.println(&lt;/span&gt;&quot;利用TreeSet方集合排序（会去掉重复的元素）:&quot;&lt;span&gt;);
        Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt; ts.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            System.out.print(it.next() &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sort1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] b) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        Arrays.sort(b);
        System.out.println(&lt;/span&gt;&quot;利用Arrays.sort()方法排序:&quot;&lt;span&gt;);
        Arrays.stream(b).forEach(item &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            System.out.print(item &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        });
        System.out.println();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）控制台输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576640/201901/1576640-20190105232541506-434465488.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 05 Jan 2019 15:27:00 +0000</pubDate>
<dc:creator>stringer123</dc:creator>
<og:description>Java实现的12种排序 2019-01-05 一．冒泡排序及其实现 二．希尔排序及其实现 三．插入排序及其实现 四．插入排序及其实现 五．快速排序及其实现 六．合并排序及其实现 七．计数排序及其实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cuilongfei/p/10226750.html</dc:identifier>
</item>
<item>
<title>迪米特法则 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10226711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10226711.html</guid>
<description>&lt;p&gt;个人博客原文:&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com/law-of-demeter&quot;&gt;迪米特法则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/60575da7017a435081bab091c2036aaf_0016_01.jpg&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设计模式六大原则之五：迪米特法则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt;：迪米特法则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文名&lt;/strong&gt;：Law of Demeter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小名&lt;/strong&gt;：最少知识原则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小名英文名&lt;/strong&gt;：Least Knowledge Principle&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价值观&lt;/strong&gt;：妈妈说不和陌生人说话&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Each unit should have only limited knowledge about other units: only units &quot;closely&quot; related to the current unit. (每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元)&lt;/li&gt;
&lt;li&gt;Each unit should only talk to its friends; don't talk to strangers. (每个单元只能和它的朋友交谈：不能和陌生单元交谈)&lt;/li&gt;
&lt;li&gt;Only talk to your immediate friends. (只和自己直接的朋友交谈)&lt;br/&gt;(来自维基百科)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还是脑洞大开来个小故事。这故事还是比较现实一些，其实也不算是故事，就是咱们经常经历的事情，现在知识付费已经广受欢迎，18 年底更是快速猛涨，各种各样的培训、读书、音频学习软件如雨后春笋一般涌现出来。我们就拿一个读书的例子。&lt;/p&gt;
&lt;p&gt;有一天，设计模式老师讲解了迪米特法则，同学们听得云里雾里的，老师怕同学们没掌握这个知识点，就给同学们布置了一个作业，需要同学们按迪米特法则实现。&lt;/p&gt;
&lt;p&gt;作业是这样子的：平常在零碎的时间里，喜欢看一些书籍，一般都是电子书，现在我们看书的操作是这样的：唤醒手机，打开阅读软件，选择书籍，然后阅读。总共 3 个步骤，涉及了 3 样东西：手机、软件、书籍。同学们用代码实现这个过程。&lt;/p&gt;
&lt;p&gt;第二天上课，同学们纷纷交了作业，老师随手一番，就看到了 2 个鲜明的例子，很明显，就是一好一坏。老师便给同学们讲解了这 2 个例子，让学生感受一番迪米特法则。&lt;/p&gt;
&lt;h2 id=&quot;错误例子&quot;&gt;错误例子&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LODErrorTest {

    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.readBook();
    }

}


/**
 * 错误的示范
 */
class Phone {
    App app = new App();
    Book book = new Book(&quot;设计模式&quot;);
    public void readBook() {
        app.read(book);
    }

}


class App {
    
    public void read(Book book) {
        System.out.println(book.getTitle());
    }

}

class Book {

    private String title;

    public Book(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/lod/LODErrorTest.java&quot;&gt;LODErrorTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码是完成了读书这个过程，看样子是功能实现了，细看会发现代码的逻辑不对。哪里不对呢？书籍和应用对象都在手机上，现实是我们唤醒手机，这时手机是没有书籍的，只有当我们打开阅读软件，才有书籍可以看，没有阅读软件，书籍是看不了的。因此，手机和书籍没有一毛钱关系，书籍不应该在手机里面。正常的设计是：手机里面有阅读软件，阅读软件里面有书籍，这才符合迪米特法则，按定义来说：手机和阅读软件是朋友，阅读软件和书籍是朋友，可是朋友的朋友不是朋友，也就是手机和书籍不是朋友，所以它们不应该有交集，应该离得远远的。&lt;/p&gt;
&lt;p&gt;思考一下现实：工作中如果缺少代码复核这个步骤，就会出现这样子，后果是怎么样呢？会给后人挖坑，而且是大坑，因为和现实中的逻辑是对不上的，况且后人不知道当时的业务背景，只能看代码去熟悉，就会一步错、步步错，所以要好好把控代码质量这一关，因为代码千人千面，没法要求代码风格全部一致，但至少需要实现逻辑是清晰易懂的。&lt;/p&gt;
&lt;h2 id=&quot;正确例子&quot;&gt;正确例子&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LODRightTest {

    public static void main(String[] args) {
        Phone2 phone2 = new Phone2();
        phone2.readBook();
    }

}

/**
 * 正确的示范
 */
class Phone2 {

    private App2 app2 = new App2();

    public void readBook() {
        app2.read();
    }

}


class App2 {
    private Book2 book2 = new Book2(&quot;设计模式&quot;);

    public void read() {
        System.out.println(book2.getTitle());
    }

}

class Book2 {

    private String title;

    public Book2(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/lod/LODRightTest.java&quot;&gt;LODRightTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段代码就符合迪米特法则，手机中有阅读软件，阅读软件中有书籍，手机没有书籍任何影子。正确代码不用细讲，用心去感受就可以体会到。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;迪米特法则主要讲述的观点是高内聚、低耦合。我理解为：&lt;strong&gt;是你的，就别给别人；不是你的，就别拿&lt;/strong&gt;。上面定义的朋友也是这个意思。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》&lt;/p&gt;
&lt;p&gt;写到这，第五个原则了，六大原则就剩下最后一个开闭原则，凑齐 6 把大刀就可以准备去大干 23 个大汉啦。。。想想都激动。&lt;/p&gt;
&lt;p&gt;希望文章对您有所帮助，设计模式系列会持续更新，感兴趣的同学可以关注公众号，第一时间获取文章推送阅读，也可以一起交流，交个朋友。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 05 Jan 2019 15:10:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>设计模式六大原则之五：迪米特法则。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10226711.html</dc:identifier>
</item>
<item>
<title>Nginx内置模块简介 - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/10226651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/10226651.html</guid>
<description>&lt;p&gt;经常编译Nginx的时候看到&lt;code&gt;./configure&lt;/code&gt;后面跟着很多&lt;code&gt;--with&lt;/code&gt;命令，虽然知道是添加模块，但一直也没有仔细去研究这些模块究竟是什么作用。本文会对常用的内置模块做个简单介绍，方便后续检索查看。由于模块之多，不会一一详细介绍，但是会留有参考链接，如感兴趣，可以仔细去研究。&lt;/p&gt;
&lt;blockquote readability=&quot;4.9446808510638&quot;&gt;
&lt;p&gt;这里建议大家一定要多看官方文档！！！官方文档里的内容才是最全的：包括说明、指令、作用域等等。&lt;br/&gt;官方文档 &lt;a href=&quot;http://nginx.org/en/docs&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs&lt;/a&gt;&lt;br/&gt;中文文档 &lt;a href=&quot;http://tengine.taobao.org/nginx_docs/cn/docs/&quot; class=&quot;uri&quot;&gt;http://tengine.taobao.org/nginx_docs/cn/docs/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;http_auth_basic_module-http基本认证&quot;&gt;http_auth_basic_module HTTP基本认证&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：提供HTTP基本认证功能。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：是。如果需要禁用，编译Nginx时使用&lt;code&gt;--without-http_auth_basic_module&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;作用域&lt;/strong&gt;：http, server, location, limit_except&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;server {
    listen       80;   
    server_name  test.com;

    auth_basic   &quot;登录认证&quot;;  
    auth_basic_user_file /etc/nginx-htpasswd;

    root   /mnt/html/www;
    index  index.html;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启Nginx服务后，访问test.com 就会要求输入用户名、密码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一定要注意auth_basic_user_file路径，如果文件不存在，会不厌其烦的出现403。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;br/&gt;使用crypt配置Basic Auth登录认证 - 飞鸿影~ - 博客园&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/52fhy/p/9657293.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/52fhy/p/9657293.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_stub_status_module-状态信息&quot;&gt;http_stub_status_module 状态信息&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：该模块可以提供 &lt;code&gt;Nginx&lt;/code&gt; 的状态信息。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_stub_status_module&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;作用域&lt;/strong&gt;：server, location&lt;/p&gt;
&lt;p&gt;该模块仅有&lt;code&gt;stub_status&lt;/code&gt;这一个指令。&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /nginx_status {
  stub_status on;
  access_log   off;
  allow 127.0.0.1;
  deny all;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问会看到这样的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Active connections: 291
server accepts handled requests
  16630948 16630948 31070465
Reading: 6 Writing: 179 Waiting: 106&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一行&lt;br/&gt;当前的活跃连接数：291&lt;/li&gt;
&lt;li&gt;第二行&lt;br/&gt;服务器已接受的连接数：16630948（accepted connection #）&lt;br/&gt;服务器已处理的连接数：16630948（handled connection #）&lt;br/&gt;服务器已处理的请求：31070465（可以算出，平均每个连接有 1.8 个请求）（handled connection #）&lt;/li&gt;
&lt;li&gt;第三行&lt;br/&gt;Reading – Nginx 读取的请求头次数为 6；&lt;br/&gt;Writting – Nginx 读取请求体、处理请求并发送响应给客户端的次数为 179；&lt;br/&gt;Waiting – 当前活动的长连接数：106。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考：&lt;br/&gt;1、解剖Nginx·模块开发篇（5）解读内置非默认模块&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/Poechant/article/details/7627843&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/Poechant/article/details/7627843&lt;/a&gt;&lt;br/&gt;2、Module ngx_http_stub_status_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_stub_status_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_stub_status_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_gzip_module-压缩资源&quot;&gt;http_gzip_module 压缩资源&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于支持&lt;code&gt;gzip on&lt;/code&gt;等指令，用来减轻服务器的带宽问题，经过gzip压缩后的页面大小可以变为原来的30%甚至更小。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：是。如果需要禁用，编译Nginx时使用&lt;code&gt;--without-http_gzip_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
#gzip_http_version 1.0;
gzip_comp_level 2;
gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
gzip_vary off;
gzip_disable &quot;MSIE [1-6]\.&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、nginx的gzip压缩功能参数介绍(ngx_http_gzip_module)&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/gnail_oug/article/details/53246026&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/gnail_oug/article/details/53246026&lt;/a&gt;&lt;br/&gt;2、Module ngx_http_gzip_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_gzip_static_module-支持.gz资源&quot;&gt;http_gzip_static_module 支持.gz资源&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：允许发送以&lt;code&gt;.gz&lt;/code&gt;作为文件扩展名的预压缩文件，以替代发送普通文件。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_gzip_static_module&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此模块的作用就是在接到请求后，会到url相同的路径的文件系统去找扩展名为&lt;code&gt;.gz&lt;/code&gt;的文件，如果存在直接把它发送出去，如果不存在，再将目标文件进行gzip压缩，再发送出去，这样可以避免重复的压缩无谓的消耗资源，这个模块不受&lt;code&gt;gzip_types&lt;/code&gt;限制，会对所有请求有效。所以建议不要在全局上使用，因为一般来说大部分都是动态请求，是不会有&lt;code&gt;.gz&lt;/code&gt;这个文件的，建议只在局部我们确认有&lt;code&gt;.gz&lt;/code&gt;的目录中使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该模块仅有gzip_static这一个指令。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip_static  on;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、Nginx中gzip_static模块的使用介绍 - yancheng的专栏 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/yc1022/article/details/21657547&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/yc1022/article/details/21657547&lt;/a&gt;&lt;br/&gt;2、Module ngx_http_gzip_static_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_sub_module-字符串替换&quot;&gt;http_sub_module 字符串替换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：该模块用于实现响应内容固定字符串替换。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_sub_module&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;作用域&lt;/strong&gt;：http, server, location&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location / {
    sub_filter '&amp;lt;a href=&quot;http://127.0.0.1:8080/'  '&amp;lt;a href=&quot;https://$host/';
    sub_filter 'nginx.com' 'baidu.com';
    # 是否仅替换一次，如果为off，则全局替换
    sub_filter_once on;
    # 替换的响应类型，*表示替换所有类型
    sub_filter_types text/html;
    # 是否保留原始的Last-Modified。默认是on
    sub_filter_last_modified on;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.1666666666667&quot;&gt;
&lt;p&gt;该模块不支持正则替换，灵活性不够。支持正则匹配替换的第三方模块：&lt;br/&gt;1、ngx_http_substitutions_filter_module：&lt;a href=&quot;https://github.com/yaoweibin/ngx_http_substitutions_filter_module&quot; class=&quot;uri&quot;&gt;https://github.com/yaoweibin/ngx_http_substitutions_filter_module&lt;/a&gt;&lt;br/&gt;2、replace-filter-nginx-module：&lt;a href=&quot;https://github.com/agentzh/replace-filter-nginx-module&quot; class=&quot;uri&quot;&gt;https://github.com/agentzh/replace-filter-nginx-module&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;br/&gt;1、nginx ngx_http_sub_module使用 - iuwai - 博客园&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/iuwai/p/4432084.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/iuwai/p/4432084.html&lt;/a&gt;&lt;br/&gt;2、nginx的with-http_sub_module模块使用之替换字符串 - 凉生墨客 - 博客园&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/heruiguo/p/9076239.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/heruiguo/p/9076239.html&lt;/a&gt;&lt;br/&gt;3、nginx使用replace-filter-nginx-module实现内容替换 - 飞鸿影~ - 博客园&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/52fhy/p/7956099.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/52fhy/p/7956099.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_addition_module-追加内容&quot;&gt;http_addition_module 追加内容&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于在响应之前或者之后追加文本内容，比如想在站点底部追加一个js或者css，可以使用这个模块来实现。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_addition_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location / {
        addition_types text/html;
        add_before_body /2013/10/header.html;
        add_after_body  /2013/10/footer.html;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、nginx向响应内容中追加内容（ngx_http_addition_module模块） – 运维生存时间&lt;br/&gt;&lt;a href=&quot;http://www.ttlsa.com/linux/nginx-modules-ngx_http_addition_module/&quot; class=&quot;uri&quot;&gt;http://www.ttlsa.com/linux/nginx-modules-ngx_http_addition_module/&lt;/a&gt;&lt;br/&gt;2、Module ngx_http_addition_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_addition_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_addition_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_realip_module-获取实际ip&quot;&gt;http_realip_module 获取实际IP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于配置&lt;code&gt;REMOTE_ADDR&lt;/code&gt;实际IP。 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如，X-Real-IP 或 X-Forwarded-For)。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_realip_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一般是在客户端和服务端中间增加了代理服务器或者负载均衡，才需要使用这个模块，如果不使用，服务端获取的&lt;code&gt;REMOTE_ADDR&lt;/code&gt;就不是客户端的真实IP。&lt;/p&gt;
&lt;p&gt;配置：&lt;br/&gt;在后端服务器 location 里头插入&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt; #指定接收来自哪个前端发送的 IP head 可以是单个IP或者IP段
set_real_ip_from  192.168.1.0/24;
set_real_ip_from 192.168.2.1; 
#IP head  的对应参数，默认即可。
real_ip_header X-Real-IP; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、Module ngx_http_realip_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_realip_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_realip_module.html&lt;/a&gt;&lt;br/&gt;2、--with-http_realip_module选项（后台Nginx服务器记录原始客户端的IP地址 ） - purple尘的专栏 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/cscrazybing/article/details/50789234&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/cscrazybing/article/details/50789234&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_ssl_module-支持https&quot;&gt;http_ssl_module 支持HTTPS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：此模块为Nginx提供HTTPS支持。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_ssl_module&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该模块需要 OpenSSL 库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;yum install openssl openssl-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;server {                                                                                                                            
    listen      443 ssl;
    listen       80; 
    server_name  52fhy.com www.52fhy.com;
    index index.php index.html index.htm;
    root /www/52fhy.com/;
    
    #ssl on;  #这个开启后导致只能https访问
    ssl_certificate_key  /usr/local/nginx/conf/52fhy.com.key;
    ssl_certificate  /usr/local/nginx/conf/1_52fhy.com_bundle.crt;
    
    if ($scheme = http) {
     rewrite ^(.*)$  https://$host$1 permanent;
    }   
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、网站使用https协议 - 飞鸿影~ - 博客园&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/52fhy/p/6139303.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/52fhy/p/6139303.html&lt;/a&gt;&lt;br/&gt;2、Module ngx_http_ssl_module&lt;br/&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_ssl_module.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_image_filter_module-图片处理&quot;&gt;http_image_filter_module 图片处理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：实现图片裁剪、缩放、旋转功能，支持jpg、gif、png格式。&lt;br/&gt;&lt;strong&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_image_filter_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;依赖GD库：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yum install gd-devel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;按比例裁剪图片：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location ~* .*_(\d+)x(\d+)\.(JPG|jpg|gif|png|PNG)$ {
    set $img_width $1;
    set $img_height $2;
    image_filter   crop  $img_width $img_height;
    image_filter_jpeg_quality  80;
    image_filter_buffer 10M;
    error_page      415  = /empty;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以只指定一个尺寸，另一个尺寸用“-”。如果遇到错误，服务器返回415错误码。&lt;/p&gt;
&lt;p&gt;按比例对图像进行缩放：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location ~* .*_(\d+)x(\d+)\.(JPG|jpg|gif|png|PNG)$ {
    set $img_width $1;
    set $img_height $2;
    image_filter   resize  $img_width $img_height;
    image_filter_jpeg_quality  80;
    image_filter_buffer 10M;
    error_page      415  = /empty;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、Nginx的 http_image_filter_module 模块使用说明 - 学习印记 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/revitalizing/article/details/55505853&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/revitalizing/article/details/55505853&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_geoip_module-支持geoip&quot;&gt;http_geoip_module 支持GeoIP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：GeoIP支持，可以用于IP访问限制。&lt;br/&gt;内置模块&lt;strong&gt;：是。&lt;br/&gt;&lt;/strong&gt;默认启用**：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_geoip_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;nginx使用GeoIP限制访问并支持白名单 - 阅心笔记&lt;br/&gt;&lt;a href=&quot;http://www.52os.net/articles/configure-nginx-using-geoip-allow-whitelist.html&quot; class=&quot;uri&quot;&gt;http://www.52os.net/articles/configure-nginx-using-geoip-allow-whitelist.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_auth_request_module-第三方auth支持&quot;&gt;http_auth_request_module 第三方auth支持&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：Nginx默认支持使用&lt;code&gt;auth_basic&lt;/code&gt;进行本机验证，也可以使用该模块以支持第三方认证。提供&lt;code&gt;auth_request&lt;/code&gt;指令，Nginx 服务器通过 header &lt;strong&gt;的返回状态判断是否认证通过。&lt;br/&gt;内置模块&lt;/strong&gt;：是。&lt;br/&gt;&lt;strong&gt;默认启用&lt;/strong&gt;：否。如果需要启用，编译Nginx时使用&lt;code&gt;--with-http_auth_request_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;server {
    listen 80;
    server_name local.server.com;

    auth_request /auth;

    location / {
        root   html;
        index  index.html;
    }

    location /auth {
        proxy_pass http://auth.server.com/HttpBasicAuthenticate.php;
        proxy_pass_request_body off;
        proxy_set_header Content-Length &quot;&quot;;
        proxy_set_header X-Original-URI $request_uri;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;Nginx 的两种认证方式 - WangXiaoQiang - 博客园&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wangxiaoqiangs/p/6184181.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/wangxiaoqiangs/p/6184181.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;http_flv_module-流媒体点播&quot;&gt;http_flv_module 流媒体点播&lt;/h2&gt;
&lt;p&gt;一般配合nginx-rtmp-module实现流媒体服务器。相关模块：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http_flv_module: 支持flv。内置模块。&lt;/li&gt;
&lt;li&gt;http_mp4_module: 支持mp4。内置模块。&lt;/li&gt;
&lt;li&gt;nginx_mod_h264_streaming: 使nginx支持h264编码的视频&lt;/li&gt;
&lt;li&gt;nginx-rtmp-module: 支持rtmp协议&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中&lt;code&gt;http_flv_module&lt;/code&gt;和&lt;code&gt;http_mp4_module&lt;/code&gt;两个模块是nginx自带的， 可以在编译的时候加上相应的选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nginx_mod_h264_streaming&lt;/code&gt;的下载地址: &lt;a href=&quot;http://h264.code-shop.com/trac/wiki/Mod-H264-Streaming-Nginx-Version2&quot; class=&quot;uri&quot;&gt;http://h264.code-shop.com/trac/wiki/Mod-H264-Streaming-Nginx-Version2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nginx_mod_h264_streaming 安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd ~
wget http://h264.code-shop.com/download/nginx_mod_h264_streaming-2.2.7.tar.gz
$ tar -zxvf nginx_mod_h264_streaming-2.2.7.tar.gz

$ cd ~/nginx-1.7.9
$ ./configure --add-module=$HOME/nginx_mod_h264_streaming-2.2.7 --sbin-path=/usr/local/sbin --with-debug

$ make
$ sudo make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nginx-rtmp-module&lt;/code&gt;托管在GitHub上: &lt;a href=&quot;https://github.com/arut/nginx-rtmp-module&quot; class=&quot;uri&quot;&gt;https://github.com/arut/nginx-rtmp-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http_flv_module 配置示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location ~ \.flv$ {
    flv;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;http_mp4_module 配置示例：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /video/ {
    mp4;
    mp4_buffer_size       1m;
    mp4_max_buffer_size   5m;
    mp4_limit_rate        on;
    mp4_limit_rate_after  30s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1、Nginx搭建flv视频点播服务器 - wanghetao - 博客园&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wanghetao/p/3418744.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/wanghetao/p/3418744.html&lt;/a&gt;&lt;br/&gt;2、nginx实现rtmp,flv,mp4流媒体服务器 - 小雨伞漂流记 - 开源中国&lt;br/&gt;&lt;a href=&quot;https://my.oschina.net/ososchina/blog/833909&quot; class=&quot;uri&quot;&gt;https://my.oschina.net/ososchina/blog/833909&lt;/a&gt;&lt;br/&gt;3、从零搭建流媒体服务器+obs推流直播 - qzcsu的博客 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qzcsu/article/details/72782759&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qzcsu/article/details/72782759&lt;/a&gt;&lt;br/&gt;4、nginx搭建支持http和rtmp协议的流媒体服务器之一-andersonyan-ChinaUnix博客&lt;br/&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-26000296-id-4335063.html&quot; class=&quot;uri&quot;&gt;http://blog.chinaunix.net/uid-26000296-id-4335063.html&lt;/a&gt;&lt;br/&gt;5、nginx搭建支持http和rtmp协议的流媒体服务器之二-andersonyan-ChinaUnix博客&lt;br/&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-26000296-id-4335079.html&quot; class=&quot;uri&quot;&gt;http://blog.chinaunix.net/uid-26000296-id-4335079.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;h3 id=&quot;配置信息&quot;&gt;配置信息&lt;/h3&gt;
&lt;p&gt;输入&lt;code&gt;./configure --help&lt;/code&gt;可以查看Nginx所有支持配置的内置模块的配置信息。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;with开头的表示该模块默认是未开启的，可以使用&lt;code&gt;--with&lt;/code&gt;开启。&lt;/li&gt;
&lt;li&gt;without开头的表示该模块默认是启用的，可以使用&lt;code&gt;--without&lt;/code&gt;禁用。&lt;/li&gt;
&lt;li&gt;第三方模块使用&lt;code&gt;--add-module=PATH&lt;/code&gt;添加。如果支持动态加载，使用&lt;code&gt;--add-dynamic-module=PATH&lt;/code&gt;添加。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$ ./configure --help

  --help                             print this message

  --prefix=PATH                      set installation prefix
  --sbin-path=PATH                   set nginx binary pathname
  --modules-path=PATH                set modules path
  --conf-path=PATH                   set nginx.conf pathname
  --error-log-path=PATH              set error log pathname
  --pid-path=PATH                    set nginx.pid pathname
  --lock-path=PATH                   set nginx.lock pathname

  --user=USER                        set non-privileged user for
                                     worker processes
  --group=GROUP                      set non-privileged group for
                                     worker processes

  --build=NAME                       set build name
  --builddir=DIR                     set build directory

  --with-select_module               enable select module
  --without-select_module            disable select module
  --with-poll_module                 enable poll module
  --without-poll_module              disable poll module

  --with-threads                     enable thread pool support

  --with-file-aio                    enable file AIO support

  --with-http_ssl_module             enable ngx_http_ssl_module
  --with-http_v2_module              enable ngx_http_v2_module
  --with-http_realip_module          enable ngx_http_realip_module
  --with-http_addition_module        enable ngx_http_addition_module
  --with-http_xslt_module            enable ngx_http_xslt_module
  --with-http_xslt_module=dynamic    enable dynamic ngx_http_xslt_module
  --with-http_image_filter_module    enable ngx_http_image_filter_module
  --with-http_image_filter_module=dynamic
                                     enable dynamic ngx_http_image_filter_module
  --with-http_geoip_module           enable ngx_http_geoip_module
  --with-http_geoip_module=dynamic   enable dynamic ngx_http_geoip_module
  --with-http_sub_module             enable ngx_http_sub_module
  --with-http_dav_module             enable ngx_http_dav_module
  --with-http_flv_module             enable ngx_http_flv_module
  --with-http_mp4_module             enable ngx_http_mp4_module
  --with-http_gunzip_module          enable ngx_http_gunzip_module
  --with-http_gzip_static_module     enable ngx_http_gzip_static_module
  --with-http_auth_request_module    enable ngx_http_auth_request_module
  --with-http_random_index_module    enable ngx_http_random_index_module
  --with-http_secure_link_module     enable ngx_http_secure_link_module
  --with-http_degradation_module     enable ngx_http_degradation_module
  --with-http_slice_module           enable ngx_http_slice_module
  --with-http_stub_status_module     enable ngx_http_stub_status_module

  --without-http_charset_module      disable ngx_http_charset_module
  --without-http_gzip_module         disable ngx_http_gzip_module
  --without-http_ssi_module          disable ngx_http_ssi_module
  --without-http_userid_module       disable ngx_http_userid_module
  --without-http_access_module       disable ngx_http_access_module
  --without-http_auth_basic_module   disable ngx_http_auth_basic_module
  --without-http_autoindex_module    disable ngx_http_autoindex_module
  --without-http_geo_module          disable ngx_http_geo_module
  --without-http_map_module          disable ngx_http_map_module
  --without-http_split_clients_module disable ngx_http_split_clients_module
  --without-http_referer_module      disable ngx_http_referer_module
  --without-http_rewrite_module      disable ngx_http_rewrite_module
  --without-http_proxy_module        disable ngx_http_proxy_module
  --without-http_fastcgi_module      disable ngx_http_fastcgi_module
  --without-http_uwsgi_module        disable ngx_http_uwsgi_module
  --without-http_scgi_module         disable ngx_http_scgi_module
  --without-http_memcached_module    disable ngx_http_memcached_module
  --without-http_limit_conn_module   disable ngx_http_limit_conn_module
  --without-http_limit_req_module    disable ngx_http_limit_req_module
  --without-http_empty_gif_module    disable ngx_http_empty_gif_module
  --without-http_browser_module      disable ngx_http_browser_module
  --without-http_upstream_hash_module
                                     disable ngx_http_upstream_hash_module
  --without-http_upstream_ip_hash_module
                                     disable ngx_http_upstream_ip_hash_module
  --without-http_upstream_least_conn_module
                                     disable ngx_http_upstream_least_conn_module
  --without-http_upstream_keepalive_module
                                     disable ngx_http_upstream_keepalive_module
  --without-http_upstream_zone_module
                                     disable ngx_http_upstream_zone_module

  --with-http_perl_module            enable ngx_http_perl_module
  --with-http_perl_module=dynamic    enable dynamic ngx_http_perl_module
  --with-perl_modules_path=PATH      set Perl modules path
  --with-perl=PATH                   set perl binary pathname

  --http-log-path=PATH               set http access log pathname
  --http-client-body-temp-path=PATH  set path to store
                                     http client request body temporary files
  --http-proxy-temp-path=PATH        set path to store
                                     http proxy temporary files
  --http-fastcgi-temp-path=PATH      set path to store
                                     http fastcgi temporary files
  --http-uwsgi-temp-path=PATH        set path to store
                                     http uwsgi temporary files
  --http-scgi-temp-path=PATH         set path to store
                                     http scgi temporary files

  --without-http                     disable HTTP server
  --without-http-cache               disable HTTP cache

  --with-mail                        enable POP3/IMAP4/SMTP proxy module
  --with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP proxy module
  --with-mail_ssl_module             enable ngx_mail_ssl_module
  --without-mail_pop3_module         disable ngx_mail_pop3_module
  --without-mail_imap_module         disable ngx_mail_imap_module
  --without-mail_smtp_module         disable ngx_mail_smtp_module

  --with-stream                      enable TCP/UDP proxy module
  --with-stream=dynamic              enable dynamic TCP/UDP proxy module
  --with-stream_ssl_module           enable ngx_stream_ssl_module
  --with-stream_realip_module        enable ngx_stream_realip_module
  --with-stream_geoip_module         enable ngx_stream_geoip_module
  --with-stream_geoip_module=dynamic enable dynamic ngx_stream_geoip_module
  --with-stream_ssl_preread_module   enable ngx_stream_ssl_preread_module
  --without-stream_limit_conn_module disable ngx_stream_limit_conn_module
  --without-stream_access_module     disable ngx_stream_access_module
  --without-stream_geo_module        disable ngx_stream_geo_module
  --without-stream_map_module        disable ngx_stream_map_module
  --without-stream_split_clients_module
                                     disable ngx_stream_split_clients_module
  --without-stream_return_module     disable ngx_stream_return_module
  --without-stream_upstream_hash_module
                                     disable ngx_stream_upstream_hash_module
  --without-stream_upstream_least_conn_module
                                     disable ngx_stream_upstream_least_conn_module
  --without-stream_upstream_zone_module
                                     disable ngx_stream_upstream_zone_module

  --with-google_perftools_module     enable ngx_google_perftools_module
  --with-cpp_test_module             enable ngx_cpp_test_module

  --add-module=PATH                  enable external module
  --add-dynamic-module=PATH          enable dynamic external module

  --with-compat                      dynamic modules compatibility

  --with-cc=PATH                     set C compiler pathname
  --with-cpp=PATH                    set C preprocessor pathname
  --with-cc-opt=OPTIONS              set additional C compiler options
  --with-ld-opt=OPTIONS              set additional linker options
  --with-cpu-opt=CPU                 build for the specified CPU, valid values:
                                     pentium, pentiumpro, pentium3, pentium4,
                                     athlon, opteron, sparc32, sparc64, ppc64

  --without-pcre                     disable PCRE library usage
  --with-pcre                        force PCRE library usage
  --with-pcre=DIR                    set path to PCRE library sources
  --with-pcre-opt=OPTIONS            set additional build options for PCRE
  --with-pcre-jit                    build PCRE with JIT compilation support

  --with-zlib=DIR                    set path to zlib library sources
  --with-zlib-opt=OPTIONS            set additional build options for zlib
  --with-zlib-asm=CPU                use zlib assembler sources optimized
                                     for the specified CPU, valid values:
                                     pentium, pentiumpro

  --with-libatomic                   force libatomic_ops library usage
  --with-libatomic=DIR               set path to libatomic_ops library sources

  --with-openssl=DIR                 set path to OpenSSL library sources
  --with-openssl-opt=OPTIONS         set additional build options for OpenSSL

  --with-debug                       enable debug logging&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译示例&quot;&gt;编译示例&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module --with-http_sub_module --with-http_gzip_static_module --with-pcre
$ make -j2
$ make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（完）&lt;/p&gt;
</description>
<pubDate>Sat, 05 Jan 2019 14:52:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<og:description>经常编译Nginx的时候看到 后面跟着很多 命令，虽然知道是添加模块，但一直也没有仔细去研究这些模块究竟是什么作用。本文会对常用的内置模块做个简单介绍，方便后续检索查看。由于模块之多，不会一一详细介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/10226651.html</dc:identifier>
</item>
<item>
<title>WebRTC服务器——Licode 环境搭建 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/10226614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/10226614.html</guid>
<description>&lt;h2 id=&quot;系统配置&quot;&gt;系统配置&lt;/h2&gt;
&lt;p&gt;阿里云服务器&lt;/p&gt;
&lt;p&gt;Ubuntu 14.04.5 LTS&lt;/p&gt;
&lt;h2 id=&quot;docker-环境搭建&quot;&gt;Docker 环境搭建&lt;/h2&gt;
&lt;p&gt;在一台空的机器上搭建docker环境，先要安装docker，执行下面的命令即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get update
apt-get install docker.io&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行下面的shell脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh

MIN_PORT=30000;
MAX_PORT=30050;
docker run --name licode -p  3000:3000 -p $MIN_PORT-$MAX_PORT:$MIN_PORT-$MAX_PORT/udp -p 3001:3001  -p 8080:8080 -e &quot;MIN_PORT=$MIN_PORT&quot; -e &quot;MAX_PORT=$MAX_PORT&quot; -e &quot;PUBLIC_IP=your_ip_address&quot; lynckia/licode&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错任何错误的话，licode服务会自动运行起来，查看port：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@test:/git/docker# netstat -nltp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      865/sshd        
tcp6       0      0 :::8080                 :::*                    LISTEN      4732/docker-proxy
tcp6       0      0 :::3000                 :::*                    LISTEN      4496/docker-proxy
tcp6       0      0 :::3001                 :::*                    LISTEN      4856/docker-proxy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有几点注意&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要把相关端口在阿里云服务器上打开，这里用到的端口有:&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;TCP 端口：8080 3000 3001&lt;/li&gt;
&lt;li&gt;UDP 端口：30000/30050 UDP端口需要按照官方文档写，我自己开始使用了另外一个范围的端口，死活跑不起来。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;不要用国外的服务器，这点当初没有注意到，开始在一台香港的服务器上搭建，一直报一个TURN服务器的问题，后来在国内的机器上的试了一下才通过，应该是TURN服务器穿透的时候有问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后可以在Chrome或者火狐浏览器中输入地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://your_ip_address:3001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作者在一台Mac和一台andorid上测试的，看一下效果，就不露脸了~~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/830862/201901/830862-20190105223925695-1534154526.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编译环境搭建&quot;&gt;编译环境搭建&lt;/h2&gt;
&lt;p&gt;先按照官方文档的步骤操作：&lt;/p&gt;
&lt;h3 id=&quot;克隆代码&quot;&gt;克隆代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/lynckia/licode.git
cd licode&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h3&gt;
&lt;p&gt;安装Licode依赖的组件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./scripts/installUbuntuDeps.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装licode&quot;&gt;安装Licode&lt;/h3&gt;
&lt;p&gt;安装LIcode的各个组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./scripts/installNuve.sh
./scripts/installErizo.sh  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装实例&quot;&gt;安装实例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;./scripts/installBasicExample.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置环境&quot;&gt;配置环境&lt;/h3&gt;
&lt;p&gt;因为是在阿里云服务器上搭建环境，有些关于服务器地址的配置需要修改，在licode_config.js中把下面的字段改成阿里云服务器的外网IP或者域名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config.erizoController.publicIP = 'your_ip_address'; 
config.erizoController.hostname = 'your_ip_address';
config.erizoAgent.publicIP = 'your_ip_address'; //default value: ''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改一下网卡的名字，一般都是eth0:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config.erizoAgent.networkinterface = 'eth0'; //default value: ''：w&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行licode&quot;&gt;运行Licode&lt;/h3&gt;
&lt;p&gt;启动Licode服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./scripts/initLicode.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动Licode实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./scripts/initBasicExample.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于配置的一些问题&quot;&gt;关于配置的一些问题&lt;/h3&gt;
&lt;p&gt;在浏览器里面输入下面的URL之后:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://your_ip_address:3001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器会报下面的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ICE failed, add a TURN server and see about:webrtc for more details&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下licode的配置文件licode_config.js，配置ICE server的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; config.erizoController.iceServers = [{'url': 'stun:stun.l.google.com:19302'}]; // default value: [{'url': 'stun:stun.l.google.com:19302'}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有一个STUN服务器链接，看来是需要自己添加一个TURN服务器，作者自己在本地搭建了一个coturn服务器，具体流程可以参考&lt;a href=&quot;https://blog.csdn.net/day_day_up1991/article/details/52253892&quot;&gt;此链接&lt;/a&gt;,作者采用的是编译安装。&lt;/p&gt;
&lt;h4 id=&quot;配置coturn服务&quot;&gt;配置coturn服务&lt;/h4&gt;
&lt;p&gt;在网络上搜索了很多资料来配置coturn，很多都没有成功，下面是作者自己机器上的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#如果多网卡，记得此处设置为和你所用监听的IP相对应的eth 
listening-device=eth0
listening-ip=your_local_address
external-ip=your_external_address
listening-port=3478
relay-device=eth0
min-port=30000
max-port=30050
Verbose
fingerprint
#webrtc需要使用此选项 
lt-cred-mech
#use-auth-secret
#static-auth-secret=123456
#之前turnadmin中-r参数的值，此处要对应 
realm=demo
stale-nonce
#可以添加用户名和密码 
user=demo:123456

#测试期间可以使用example/etc中的pem，自己计算的话需要用到openssl，方法为： #sudo openssl req -x509 -newkey rsa:2048 -keyout /etc/    turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes 

#填写pem目录即可，如 
#cert=/root/cert/_cert.pem
cert=/root/cert/mycert.pem
#pkey=/root/cert/_pkey.pem
pkey=/root/cert/mycert.key
no-loopback-peers
no-multicast-peers
mobility
no-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于如何添加用户名和密码，如何配置证书需要自行解决。&lt;/p&gt;
&lt;h4 id=&quot;启动coturn服务&quot;&gt;启动coturn服务&lt;/h4&gt;
&lt;p&gt;执行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;turnserver -c path/turnserver.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;碰到下面一堆log不要惊慌，这不是错误的log，只是在监听事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1112: timer_event_handler: timeout 0xc449b0: timer_handler
1113: timer_event_handler: timeout 0xc461b0: rtcp_map_timeout_handler
1113: timer_event_handler: timeout 0x7f2acc001c90: timer_handler
1113: timer_event_handler: timeout 0x7f2acc002ea0: timer_timeout_handler
1113: timer_event_handler: timeout 0x7f2ac4001c90: timer_handler
1113: timer_event_handler: timeout 0x7f2ac4002ea0: timer_timeout_handler
1113: timer_event_handler: timeout 0x7f2ac8001d30: timer_handler&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;修改licode配置文件&quot;&gt;修改Licode配置文件&lt;/h4&gt;
&lt;p&gt;添加了turn 选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config.erizoController.iceServers = [{'url': 'stun:stun.l.google.com:19302'},{'url':'turn:your_external_address:3478','username':'demo','credential':'123456'}]; // &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后重启licode服务和实例，在地址栏在此输入地址，如果请求TURN穿透，coturn服务会有类似下面的log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;86: read_client_connection:4436:start
86: read_client_connection: data.buffer=0x7f26040033ec, data.len=100
86: session 000000000000000005: peer 10.0.42.1 lifetime updated: 300
86: session 000000000000000005: realm &amp;lt;demo&amp;gt; user &amp;lt;demo&amp;gt;: incoming packet CREATE_PERMISSION processed, success
86: write_client_connection:4220:start
86: write_client_connection: prepare to write to s 0x7f2604028170
86: write_client_connection:4243:end
86: read_client_connection:4542:end
86: udp_server_input_handler:666:end
86: udp_server_input_handler:628:start
86: read_client_connection:4436:start
86: read_client_connection: data.buffer=0x7f26040033ec, data.len=140
86: handle_turn_send:2916:start
86: handle_turn_send:3011:end
86: session 000000000000000005: realm &amp;lt;demo&amp;gt; user &amp;lt;demo&amp;gt;: incoming packet SEND processed, success
86: udp_server_input_handler:666:end
86: udp_server_input_handler:628:start
86: read_client_connection:4436:start
86: read_client_connection: data.buffer=0x7f260401816c, data.len=140&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器控制台上有时会有下面的log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ICE failed, your TURN server appears to be broken, see about:webrtc for more details
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是你的turnserver没有配置好，如果连接成功，最终浏览器控制台会有下面的链接成功的log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG:  Event: ice-state-change erizo.js:28:39
DEBUG:  Event: icestatechanged erizo.js:28:39
INFO:  341271403301651300 - iceConnectionState: connected erizo.js:28:39
DEBUG:  Event: onAddStream erizo.js:28:39
DEBUG:  Event: stream-added erizo.js:28:39
DEBUG:  Event: signaling_message_erizo&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 05 Jan 2019 14:40:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>WebRTC服务器——Licode 环境搭建 系统配置 阿里云服务器 Ubuntu 14.04.5 LTS Docker 环境搭建 在一台空的机器上搭建docker环境，先要安装docker，执行下面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/10226614.html</dc:identifier>
</item>
<item>
<title>EnjoyingSoft之Mule ESB开发教程第四篇：Mule Expression Language - MEL表达式 - EnjoyingSoft</title>
<link>http://www.cnblogs.com/enjoyingsoft/p/10224648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoyingsoft/p/10224648.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;本篇主要介绍Mule表达式语言，Mule Expression Language，简称MEL。MEL是一种轻量级，在Mule ESB使用的表达式语言，可用于访问和计算Mule Message的Payload，Property和Variable。几乎每一个Mule组件都可以使用MEL表达式。MEL表达式能够帮助开发者高效和优雅地过滤，路由，处理Mule message。关于Mule message基本概念，请参考&lt;a href=&quot;https://www.cnblogs.com/enjoyingsoft/p/10153082.html&quot;&gt;第二篇&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/enjoyingsoft/p/10165617.html&quot;&gt;第三篇&lt;/a&gt;文章。&lt;/p&gt;
&lt;p&gt;Mule ESB是一个使用Java语言，基于Spring框架编写的开源企业服务总线，其相关源代码托管在&lt;a href=&quot;https://github.com/mulesoft/mule&quot;&gt;GitHub&lt;/a&gt;上。企业服务总线英文Enterprise Service Bus，简称ESB。&lt;/p&gt;
&lt;p&gt;MuleESB在众多开源的ESB中处于领先者的地位，拥有来自世界各地数十万个开发人员，超过数百万的下载量。MuleSoft公司也作为开源软件中的独角兽，2017年在纽交所成功上市。我们作为MuleSoft的重要合作伙伴也参与其中，在六年多的时间里，使用Mule ESB企业版开发，或者Mule ESB社区版开发，构建了众多Mule ESB实施案例，帮助国内众多的企业成功上线企业集成项目。&lt;/p&gt;
&lt;p&gt;我们使用Mule ESB开发的过程中，体会到它优秀的架构设计和高效的开发速度。同时也深感Mule ESB开发书籍，Mule ESB中文文档资料非常稀少，所以使用8篇文章来写基础Mule ESB开发教程，讲解如何使用Mule ESB开发。&lt;/p&gt;
&lt;h2 id=&quot;mel的优势&quot;&gt;1. MEL的优势&lt;/h2&gt;
&lt;p&gt;在Mule ESB上有很多方法可以操作Mule Message，比如Java语言或者其他脚本语言(比如JavaScript等)。但是MEL表达式是Mule推荐使用，在Mule应用中的一个统一和标准的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MEL表达式为开发人员提供了一个一致的标准化语言，用来访问和计算Mule Message的Payload（负载），Property（属性）和Variable（变量）。&lt;/li&gt;
&lt;li&gt;MEL基于Mule特定的对象，Studio中提供auto-complete（自动完成，语法提示）的功能，帮助开发者快速编码。&lt;/li&gt;
&lt;li&gt;更重要的是，Mule的绝大多数组件都支持MEL，比如路由组件，过滤组件等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MEL的示例，这个示例在在Mule的Logger组件中使用MEL表达式获取FlowVars。&lt;/p&gt;
&lt;p&gt;从下图可以看到，我们在Logger组件中使用MEL表达式，能够提供语法提示，该提示带出了上一步设定的customerNo变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490365/201901/1490365-20190105220627556-1229927918.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;XML配置如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;flow name=&quot;mel-flow&quot;&amp;gt;
        &amp;lt;http:listener config-ref=&quot;HTTP_Listener_Configuration&quot; path=&quot;/&quot; doc:name=&quot;HTTP&quot;/&amp;gt;
        &amp;lt;set-variable variableName=&quot;customerNo&quot; value=&quot;#[1008]&quot; doc:name=&quot;customerNo&quot;/&amp;gt;
        &amp;lt;logger message=&quot;The customerNo is #[flowVars.customerNo]&quot; level=&quot;INFO&quot; doc:name=&quot;Logger&quot;/&amp;gt;
&amp;lt;/flow&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：MEL是一种表达式，和脚本语言类似，但并不相同。表达式通常用于动态获取值或者设定值，或对数据进行简单的操作。表达式语言和脚本语言之间在功能上存在重叠，但如果您编写的内容非常复杂，需要的不仅仅是几行代码，或者您需要包含条件逻辑，那么脚本语言通常会更有用。如果简单的获取或设定值，调用方法或执行函数，则使用表达式则更方便。&lt;/p&gt;
&lt;h2 id=&quot;mel的使用场景&quot;&gt;2. MEL的使用场景&lt;/h2&gt;
&lt;p&gt;MEL表达式常用的使用场景大概可以分成三种。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取值
&lt;ul&gt;&lt;li&gt;&lt;code&gt;#[payload]&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;表示获取message的负载&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#[message.inboundProperties.'http.query.params'.customerNo]&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;表示获取查询参数customerNo&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#[payload.callMethod(parameters)&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;表示调用payload对象的callMethod方法，并获取方法返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#[xpath('//root/element')]&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;表示使用xpath语法解析并获取相应节点内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;条件比较，返回的结果就是布尔变量
&lt;ul&gt;&lt;li&gt;&lt;code&gt;#[payload.amount &amp;gt; 2000]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#[message.inboundProperties.'http.method' == 'GET']&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;表示判断HTTP请求是不是GET方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设定值，通常用于Message Enricher组件。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;#[flowVars.dbResult]&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;这里表示相应的值设定到dbResult变量中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mel的示例&quot;&gt;3. MEL的示例&lt;/h2&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;使用表达式提取值，根据消息的内容，属性决定执行流程。在下面的示例中，payload是一个Java对象，我们根据购买类型，将订单分发路由到不同的JMS消息队列中。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;choice&amp;gt;
   &amp;lt;when expression=&quot;#[payload.getOrderType() == 'book']&quot;&amp;gt;
        &amp;lt;jms:outbound-endpoint queue=&quot;bookQueue&quot; /&amp;gt;
    &amp;lt;/when&amp;gt;
   &amp;lt;when expression=&quot;#[payload.getOrderType() == 'music']&quot;&amp;gt;
        &amp;lt;jms:outbound-endpoint queue=&quot;musicQueue&quot; /&amp;gt;
    &amp;lt;/when&amp;gt;
&amp;lt;/choice&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用表达式提取值，并将值传递给Connector，如下示例就是使用MEL计算的值设定SMTP Connector的邮件标题，邮件接收人等。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;smtp:outbound-endpoint from=&quot;#[flowVars.mailFrom]&quot; to=&quot;#[flowVars.mailTo]&quot; subject=&quot;#[payload.mailSubject]&quot;  doc:name=&quot;SMTP&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果payload是Java对象，可以调用payload方法，获取方法的返回值。示例就说调用calAmount方法，并打印计算出来的金额。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;logger message=&quot;#[payload.calAmount()]&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;mel的上下文对象&quot;&gt;4. MEL的上下文对象&lt;/h2&gt;
&lt;p&gt;我们在上述的MEL表达式示例中可以看到MEL有多个部分组成，第一部分就是上下文对象。MEL常见的上下文对象如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;#[server]&lt;/td&gt;
&lt;td&gt;当前服务器，可以获取服务器的时间，JDK版本等，如#[server.dateTime]，#[server.javaVersion]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;#[mule]&lt;/td&gt;
&lt;td&gt;当前Mule实例，可以获取Mule的版本，目录等。如#[mule.version]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;#[app]&lt;/td&gt;
&lt;td&gt;当前Mule应用的实例，可以获取应用的名称等。如#[app.name]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;#[message]&lt;/td&gt;
&lt;td&gt;这个是我们最经常使用的对象，就说Mule message。如#[message.payload]，#[message.inboundProperties.'http.query.params'.customerNo]等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;server上下文对象的常用属性:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dateTime&lt;/td&gt;
&lt;td&gt;系统当前时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ip&lt;/td&gt;
&lt;td&gt;主机IP&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;osName&lt;/td&gt;
&lt;td&gt;操作系统名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;userName&lt;/td&gt;
&lt;td&gt;当前用户&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;userDir&lt;/td&gt;
&lt;td&gt;当前用户工作目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;mule上下文对象的常用属性:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;home&lt;/td&gt;
&lt;td&gt;Mule Runtime的安装目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;Mule Runtime的版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;nodeId&lt;/td&gt;
&lt;td&gt;集群下的本机ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;clusterId&lt;/td&gt;
&lt;td&gt;集群ID&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;app上下文对象的常用属性:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Mule App应用名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;workdir&lt;/td&gt;
&lt;td&gt;Mule App工作目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;message上下文对象的常用属性:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;message的唯一ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;rootId&lt;/td&gt;
&lt;td&gt;message的根ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;payload&lt;/td&gt;
&lt;td&gt;message的负载&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inboundProperties&lt;/td&gt;
&lt;td&gt;message的inbound头信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inboundAttachments&lt;/td&gt;
&lt;td&gt;message的inbound附件信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;outboundProperties&lt;/td&gt;
&lt;td&gt;message的outbound头信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;outboundAttachments&lt;/td&gt;
&lt;td&gt;message的outbound附件信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;mel的variable&quot;&gt;5. MEL的Variable&lt;/h2&gt;
&lt;p&gt;不同于第4点提到的上下文对象，MEL中还可以使用变量，使用变量并不要求在表达式中使用上下文对象。变量是顶层的标识符。MEL中常见的变量如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flowVars - flowVars的有效范围是在一个Flow中，定义flowVars之后，后续的Message Processor都可以使用。&lt;/li&gt;
&lt;li&gt;sessionVars - 在跨Flow通信时，可以使用sessionVars来传递变量。需要注意的是，sessionVars并不总是有效的，其实取决于Inboud Endpoint的类型。后续再出专题介绍flowVars和sessionVars等之间的区别。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#[flowVars.foo = sessionVars.bar]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的表达式的意思是，将session变量赋值给flow变量。&lt;/p&gt;
&lt;h2 id=&quot;mel访问属性&quot;&gt;6. MEL访问属性&lt;/h2&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;点语法。适用对象通常是Java Pojo。MEL中可以使用点语法来访问相关的对象属性，同样对象属性的属性也是可以用点号来访问的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#[message.payload.item.name]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Null安全性访问。Java编程中经常遇到NullPointerException错误，也就是说对空对象进行访问操作会报错。而在MEL表达式，可以通过点语法.?来避免出错。如下示例，即使item为null，该表达式仍然不会报错，它会返回null值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#[message.payload.?item.name]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;属性名称的转义。如果属性名称有特殊字符，那么使用点语法会遇到问题，这个时候可以单引号进行转义。如下示例，http.query.params是一个整体。我们访问这个属性名，必须使用单引号进行转义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#[message.inboundProperties.'http.query.params'.customerNo]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;中括号语法。如果对象是数组，或者Map，那么可以使用中括号进行访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#[payload[5]]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#[payload['userName']]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;mel操作符&quot;&gt;7. MEL操作符&lt;/h2&gt;
&lt;p&gt;常用的操作符如下，和普通的开发语言类似。还有更多的操作符可以查阅官方手册。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;算术运算符 + - / * %&lt;/li&gt;
&lt;li&gt;比较运算符 == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&lt;/li&gt;
&lt;li&gt;逻辑运算符 &amp;amp;&amp;amp; ||&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文同步发文于&lt;a href=&quot;http://www.enjoyingsoft.com/blogs/2019/01/05/mule-base-04/&quot;&gt;EnjoyingSoft之Mule ESB开发教程第四篇：Mule Expression Language - MEL表达式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;a href=&quot;http://www.enjoyingsoft.com&quot;&gt;EnjoyingSoft&lt;/a&gt; 网站，获取更多&lt;a href=&quot;http://www.enjoyingsoft.com&quot;&gt;Mule ESB 实施，Mule ESB 社区版 实施，Mule ESB实施，Mule ESB社区版实施&lt;/a&gt;帮助。&lt;/p&gt;
&lt;p&gt;欢迎转载，但必须保留原文和此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利。&lt;/p&gt;
</description>
<pubDate>Sat, 05 Jan 2019 14:13:00 +0000</pubDate>
<dc:creator>EnjoyingSoft</dc:creator>
<og:description>本篇主要介绍Mule表达式语言，Mule Expression Language，简称MEL。MEL是一种轻量级，在Mule ESB使用的表达式语言，可用于访问和计算Mule Message的Payl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoyingsoft/p/10224648.html</dc:identifier>
</item>
<item>
<title>手写DotNetCore 认证授权代码 - Cfan1236</title>
<link>http://www.cnblogs.com/rui1236/p/10226063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rui1236/p/10226063.html</guid>
<description>&lt;p&gt;在普通的MVC项目中 我们普遍的使用Cookie来作为认证授权方式，使用简单。登录成功后将用户信息写入Cookie；但当我们做WebApi的时候显然Cookie这种方式就有点不适用了。&lt;/p&gt;
&lt;p&gt;在dotnet core 中 WebApi中目前比较流行的认证授权方式是Jwt  (Json Web Token) 技术。Jwt 是一种无状态的分布式身份验证方式，Jwt 是将用户登录信息加密后存放到返回的Token中 ，相当于用户信息是存储在客户端。Jwt的加密方式有两种 ：对称加密与非对称加密，非对称加密即 RSA 加密的方式。&lt;/p&gt;
&lt;p&gt;自己手写认证授权代码和Jwt的思路是一样的；不同之处在于：&lt;/p&gt;
&lt;p&gt;1、加密方式仅仅是采用的对称加密方式 简单高效。哈哈！(弊端就是没有非对称加密更安全)；&lt;/p&gt;
&lt;p&gt;2、用户登录信息主要保存在Redis中，即服务端。&lt;/p&gt;
&lt;p&gt;自己写的好处：&lt;/p&gt;
&lt;p&gt;1、扩展性强，可根据自己的需要进行各种扩展，比如在验证授权时可很方便的添加多设备登录挤下线功能等。&lt;/p&gt;
&lt;p&gt;2、可随时调整用户的Token失效时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证及授权流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、先请求登录接口，登录成功，为用户产生一个Token，&lt;/p&gt;
&lt;p&gt;登录获取Token　图片中ticket字段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201901/554879-20190105204308596-578231215.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、 客户端拿到Token在其他请求中将Token信息添加到请求头中传递到服务端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201901/554879-20190105204757269-1891767225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、添加一个过滤器。在Startup 中ConfigureServices方法里添加一个Filters 即我们自己授权代码类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
public void ConfigureServices(IServiceCollection services)
 {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
            services.AddMvc(mvc =&amp;gt;
            {
                //添加自己的授权验证
                mvc.Filters.Add(typeof(AuthorizeFilter));
            });
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 添加过滤器之后我们的每次请求都会优先执行过滤器的代码。在这里我们就可以判断用户是否已经登录，从而进行拦截没有授权的的请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 安全认证过滤器
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorizeFilter : IActionFilter, IAuthorizationFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationFilterContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许匿名访问&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (context.HttpContext.User.Identity.IsAuthenticated ||&lt;span&gt;
                context.Filters.Any(item &lt;/span&gt;=&amp;gt; item &lt;span&gt;is&lt;/span&gt;&lt;span&gt; IAllowAnonymousFilter))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext =&lt;span&gt; context.HttpContext;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claimsIdentity = httpContext.User.Identity &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ClaimsIdentity;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request =&lt;span&gt; context.HttpContext.Request;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authorization = request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (authorization != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; authorization.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BasicAuth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求头中传递的ticket&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; current_ticket = authorization.Split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验ticket并获取用户信息&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; userInfo = TicketEncryption.VerifyTicket(current_ticket, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; dec_client);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同一个终端多次登录挤下线功能 返回403&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (userInfo.ticket != current_ticket &amp;amp;&amp;amp; userInfo.client.ToString() ==&lt;span&gt; dec_client)
                    {
                        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 多设备挤下线代码
                        &lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseMessage();
                        context.HttpContext.Response.StatusCode &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)HttpStatusCode.Forbidden;
                        context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Forbidden:The current authorization has expired&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 401 未授权&lt;/span&gt;
            context.HttpContext.Response.StatusCode = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)HttpStatusCode.Unauthorized;
            context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Forbidden:Tiket Invalid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、登录并获取Token&lt;/p&gt;
&lt;p&gt;由于添加了IAuthorizationFilter类型的过滤器，所以每个请求都会被拦截。所以登录接口我们需要允许匿名访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/554879/201901/554879-20190105210757710-1282478464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、加解密Token&lt;/p&gt;
&lt;p&gt;加密：登录成功后就要产生个Token了，产生也简单。将用户的唯一信息比如uid或者guid进行对称式加密。当然如果需要对登录设备做区分或者多设备登录挤下线功能时最好也将登录设备一起加密进去。&lt;/p&gt;
&lt;p&gt;我们都知道 在加密中一般情况下只要加密的数据及加密key不变；那么加密后的内容也会一直保持不变。如果我们每次登录产生的Token一直没有任何变化只要这个Token被泄露了那将很危险的。竟然我们希望每次登录产生的Token都有变化。那就要改变加密数据或者加密key了。加密数据是用户唯一信息这个显然不可能产生变化。所以我们能改变的地方只能是加密key了；我们采用固定key+随机key的方式。&lt;/p&gt;
&lt;p&gt;因为加密key在我们解密时也是需要一一对应的。所以我们得想办法将我们的随机key告诉我们解密的代码中。办法就是 我们将加密后的内容(一般情况进行base64编码)再加上随机key。(随机key一定是固定长度 不然后面无法解析拆分)&lt;/p&gt;
&lt;p&gt;比如加密内容是guid=73e01eab-210d-4d19-a72a-d0d64e053ec0+client=ios  固定key=123654+随机key=FEZaaWbyimaWiJHah &lt;/p&gt;
&lt;p&gt;即加密过程:&lt;/p&gt;
&lt;p&gt;加密(73e01eab-210d-4d19-a72a-d0d64e053ec0&amp;amp;ios,123654FEZaaWbyimaWiJHah)=M0EzM0ZGRjk2QzgwRDY2RDJDMTdFOEJGRUE0NDI3NEE1RDlFNkU4NDQ0MERFNEIyMkQ5QjM4MjAxODcwj加随机keyFEZaaWbyimaWiJHah&lt;/p&gt;
&lt;p&gt;所以我们返回给用户的Token实际上是包含了随机key的。当然这个随机key只有我们自己知道。因为随机key的长度以及位置只有我们自己知道。这种方式即使我们固定key被泄露了 只要别人不知道我们随机key处理方法也无济于事。&lt;/p&gt;
&lt;p&gt;解密：知道加密过程后就好解密了。拿到用户提交的Token后首先按照随机key的固定位置进行截取。将加密内容和随机key拆开。然后将固定key和随机key组合一起解密加密的内容，取得用户guid和登录的客户端类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整加解密代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;代码中的ticket代表本文中的Token。代码中使用的是DES加解密&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TicketEncryption
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密key 实际中请用配置文件配置&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yvDlky7GXGtlPCGr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取一个新的ticket
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;guid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户的guid&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;client&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GenerateTicket(&lt;span&gt;string&lt;/span&gt; guid, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; client)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机key&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; randomKey = Randoms.GetRandomString(&lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys = key +&lt;span&gt; randomKey;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; desStr = Encryption.DesEncrypt(guid + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; client, keys);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base64Str = Encryption.Base64Encrypt(desStr) +&lt;span&gt; randomKey;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; base64Str;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 校验ticket
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;encryptStr&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo VerifyTicket(&lt;span&gt;string&lt;/span&gt; encryptStr,&lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; client)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                RedisHelper redisHelper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RedisHelper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密原型:guid&amp;amp;client; 如:08e80f78-95ad-427c-b506-a5f1504e29ac&amp;amp;ios&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; randomKey = encryptStr.Substring(encryptStr.Length - &lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base64 = encryptStr.Substring(&lt;span&gt;0&lt;/span&gt;, encryptStr.Length - &lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deBase64 =&lt;span&gt; Encryption.Base64Decrypt(base64);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys = key +&lt;span&gt; randomKey;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ticketInfo =&lt;span&gt; Encryption.DesDecrypt(deBase64, keys);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; guid = ticketInfo.Split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                client &lt;/span&gt;= ticketInfo.Split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; redisKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ticket_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; guid;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = redisHelper.Get&amp;lt;UserInfo&amp;gt;&lt;span&gt;(redisKey);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整demo代码请看github&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cfan1236/NetCoreAuthorize&quot; target=&quot;_blank&quot;&gt;https://github.com/cfan1236/NetCoreAuthorize&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 05 Jan 2019 14:12:00 +0000</pubDate>
<dc:creator>Cfan1236</dc:creator>
<og:description>在普通的MVC项目中 我们普遍的使用Cookie来作为认证授权方式，使用简单。登录成功后将用户信息写入Cookie；但当我们做WebApi的时候显然Cookie这种方式就有点不适用了。 在dotnet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rui1236/p/10226063.html</dc:identifier>
</item>
<item>
<title>word2vec初探 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10212858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10212858.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10162500.html&quot; target=&quot;_blank&quot;&gt;自然语言处理入门&lt;/a&gt;里我们提到了词向量的概念,tf-idf的概念,并且在实际的影评正负面预测项目中使用了tf-idf，取得了还算不错的效果.&lt;br/&gt;这一篇,我们来尝试一下使用来自google的大名鼎鼎的word2vec。&lt;/p&gt;
&lt;p&gt;gensim是一个常用的python自然语言处理库.其中封装了c语言版本的word2vec。&lt;/p&gt;
&lt;p&gt;gensim的安装很简单,pip install gensim即可.&lt;/p&gt;
&lt;p&gt;直接进入主题,看一下word2vec的API。&lt;a href=&quot;https://radimrehurek.com/gensim/models/word2vec.html&quot; target=&quot;_blank&quot;&gt;官方link戳这里&lt;/a&gt;,值得好好看看.&lt;/p&gt;
&lt;blockquote readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;gensim.models.word2vec.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;Word2Vec&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;sentences=None&lt;/em&gt;, &lt;em&gt;corpus_file=None&lt;/em&gt;, &lt;em&gt;size=100&lt;/em&gt;, &lt;em&gt;alpha=0.025&lt;/em&gt;, &lt;em&gt;window=5&lt;/em&gt;, &lt;em&gt;min_count=5&lt;/em&gt;, &lt;em&gt;max_vocab_size=None&lt;/em&gt;, &lt;em&gt;sample=0.001&lt;/em&gt;, &lt;em&gt;seed=1&lt;/em&gt;, &lt;em&gt;workers=3&lt;/em&gt;, &lt;em&gt;min_alpha=0.0001&lt;/em&gt;, &lt;em&gt;sg=0&lt;/em&gt;, &lt;em&gt;hs=0&lt;/em&gt;, &lt;em&gt;negative=5&lt;/em&gt;, &lt;em&gt;ns_exponent=0.75&lt;/em&gt;, &lt;em&gt;cbow_mean=1&lt;/em&gt;, &lt;em&gt;hashfxn=&amp;lt;built-in function hash&amp;gt;&lt;/em&gt;, &lt;em&gt;iter=5&lt;/em&gt;, &lt;em&gt;null_word=0&lt;/em&gt;, &lt;em&gt;trim_rule=None&lt;/em&gt;, &lt;em&gt;sorted_vocab=1&lt;/em&gt;, &lt;em&gt;batch_words=10000&lt;/em&gt;, &lt;em&gt;compute_loss=False&lt;/em&gt;, &lt;em&gt;callbacks=()&lt;/em&gt;, &lt;em&gt;max_final_vocab=None&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table class=&quot;docutils field-list&quot; frame=&quot;void&quot; rules=&quot;none&quot;&gt;&lt;colgroup&gt;&lt;col class=&quot;field-name&quot;/&gt;&lt;col class=&quot;field-body&quot;/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;35.137900874636&quot;&gt;&lt;tr class=&quot;field-odd field&quot; readability=&quot;70.275801749271&quot;&gt;&lt;th class=&quot;field-name&quot;&gt;Parameters:&lt;/th&gt;
&lt;td class=&quot;field-body&quot;&gt;
&lt;ul class=&quot;first last simple&quot; readability=&quot;4.3316773816482&quot;&gt;&lt;li&gt;&lt;strong&gt;sentences&lt;/strong&gt; (&lt;em&gt;iterable of iterables&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – The &lt;cite&gt;sentences&lt;/cite&gt; iterable can be simply a list of lists of tokens, but for larger corpora, consider an iterable that streams the sentences directly from disk/network. See &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.BrownCorpus&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.BrownCorpus&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;BrownCorpus&lt;/code&gt;&lt;/a&gt;, &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.Text8Corpus&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Text8Corpus&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;Text8Corpus&lt;/code&gt;&lt;/a&gt; or &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.LineSentence&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.LineSentence&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;LineSentence&lt;/code&gt;&lt;/a&gt; in &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec: Word2vec embeddings&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#module-gensim.models.word2vec&quot;&gt;&lt;code class=&quot;xref py py-mod docutils literal notranslate&quot;&gt;word2vec&lt;/code&gt;&lt;/a&gt; module for such examples. See also the &lt;a class=&quot;reference external&quot; href=&quot;https://rare-technologies.com/data-streaming-in-python-generators-iterators-iterables/&quot;&gt;tutorial on data streaming in Python&lt;/a&gt;. If you don’t supply &lt;cite&gt;sentences&lt;/cite&gt;, the model is left uninitialized – use if you plan to initialize it in some other way.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;corpus_file&lt;/strong&gt; (&lt;em&gt;str&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Path to a corpus file in &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.LineSentence&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.LineSentence&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;LineSentence&lt;/code&gt;&lt;/a&gt; format. You may use this argument instead of &lt;cite&gt;sentences&lt;/cite&gt; to get performance boost. Only one of &lt;cite&gt;sentences&lt;/cite&gt; or &lt;cite&gt;corpus_file&lt;/cite&gt; arguments need to be passed (or none of them).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;size&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Dimensionality of the word vectors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;window&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Maximum distance between the current and predicted word within a sentence.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_count&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Ignores all words with total frequency lower than this.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;workers&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Use these many worker threads to train the model (=faster training with multicore machines).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sg&lt;/strong&gt; (&lt;em&gt;{0&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;1}&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Training algorithm: 1 for skip-gram; otherwise CBOW.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hs&lt;/strong&gt; (&lt;em&gt;{0&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;1}&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – If 1, hierarchical softmax will be used for model training. If 0, and &lt;cite&gt;negative&lt;/cite&gt; is non-zero, negative sampling will be used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;negative&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – If &amp;gt; 0, negative sampling will be used, the int for negative specifies how many “noise words” should be drawn (usually between 5-20). If set to 0, no negative sampling is used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ns_exponent&lt;/strong&gt; (&lt;em&gt;float&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – The exponent used to shape the negative sampling distribution. A value of 1.0 samples exactly in proportion to the frequencies, 0.0 samples all words equally, while a negative value samples low-frequency words more than high-frequency words. The popular default value of 0.75 was chosen by the original Word2Vec paper. More recently, in &lt;a class=&quot;reference external&quot; href=&quot;https://arxiv.org/abs/1804.04212&quot;&gt;https://arxiv.org/abs/1804.04212&lt;/a&gt;, Caselles-Dupré, Lesaint, &amp;amp; Royo-Letelier suggest that other values may perform better for recommendation applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cbow_mean&lt;/strong&gt; (&lt;em&gt;{0&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;1}&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – If 0, use the sum of the context word vectors. If 1, use the mean, only applies when cbow is used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt; (&lt;em&gt;float&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – The initial learning rate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min_alpha&lt;/strong&gt; (&lt;em&gt;float&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Learning rate will linearly drop to &lt;cite&gt;min_alpha&lt;/cite&gt; as training progresses.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;seed&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Seed for the random number generator. Initial vectors for each word are seeded with a hash of the concatenation of word + &lt;cite&gt;str(seed)&lt;/cite&gt;. Note that for a fully deterministically-reproducible run, you must also limit the model to a single worker thread (&lt;cite&gt;workers=1&lt;/cite&gt;), to eliminate ordering jitter from OS thread scheduling. (In Python 3, reproducibility between interpreter launches also requires use of the &lt;cite&gt;PYTHONHASHSEED&lt;/cite&gt; environment variable to control hash randomization).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_vocab_size&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Limits the RAM during vocabulary building; if there are more unique words than this, then prune the infrequent ones. Every 10 million word types need about 1GB of RAM. Set to &lt;cite&gt;None&lt;/cite&gt; for no limit.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_final_vocab&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Limits the vocab to a target vocab size by automatically picking a matching min_count. If the specified min_count is more than the calculated min_count, the specified min_count will be used. Set to &lt;cite&gt;None&lt;/cite&gt; if not required.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sample&lt;/strong&gt; (&lt;em&gt;float&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – The threshold for configuring which higher-frequency words are randomly downsampled, useful range is (0, 1e-5).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hashfxn&lt;/strong&gt; (&lt;em&gt;function&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Hash function to use to randomly initialize weights, for increased training reproducibility.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;iter&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Number of iterations (epochs) over the corpus.&lt;/li&gt;
&lt;li readability=&quot;11.727636849132&quot;&gt;&lt;strong&gt;trim_rule&lt;/strong&gt; (&lt;em&gt;function&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) –
&lt;p&gt;Vocabulary trimming rule, specifies whether certain words should remain in the vocabulary, be trimmed away, or handled using the default (discard if word count &amp;lt; min_count). Can be None (min_count will be used, look to &lt;a class=&quot;reference internal&quot; title=&quot;gensim.utils.keep_vocab_item&quot; href=&quot;https://radimrehurek.com/gensim/utils.html#gensim.utils.keep_vocab_item&quot;&gt;&lt;code class=&quot;xref py py-func docutils literal notranslate&quot;&gt;keep_vocab_item()&lt;/code&gt;&lt;/a&gt;), or a callable that accepts parameters (word, count, min_count) and returns either&lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;gensim.utils.RULE_DISCARD&lt;/code&gt;, &lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;gensim.utils.RULE_KEEP&lt;/code&gt; or &lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;gensim.utils.RULE_DEFAULT&lt;/code&gt;. The rule, if given, is only used to prune vocabulary during build_vocab() and is not stored as part of the model.&lt;/p&gt;
&lt;dl class=&quot;docutils&quot;&gt;&lt;dt&gt;The input parameters are of the following types:&lt;/dt&gt;
&lt;dd&gt;
&lt;ul class=&quot;first last&quot;&gt;&lt;li&gt;&lt;cite&gt;word&lt;/cite&gt; (str) - the word we are examining&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;count&lt;/cite&gt; (int) - the word’s frequency count in the corpus&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;min_count&lt;/cite&gt; (int) - the minimum count threshold.&lt;/li&gt;
&lt;/ul&gt;&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sorted_vocab&lt;/strong&gt; (&lt;em&gt;{0&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;1}&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – If 1, sort the vocabulary by descending frequency before assigning word indexes. See &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.Word2VecVocab.sort_vocab&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2VecVocab.sort_vocab&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal notranslate&quot;&gt;sort_vocab()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;batch_words&lt;/strong&gt; (&lt;em&gt;int&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – Target size (in words) for batches of examples passed to worker threads (and thus cython routines).(Larger batches will be passed if individual texts are longer than 10000 words, but the standard cython code truncates to that maximum.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;compute_loss&lt;/strong&gt; (&lt;em&gt;bool&lt;/em&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;optional&lt;/em&gt;) – If True, computes and stores loss value which can be retrieved using&lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.Word2Vec.get_latest_training_loss&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2Vec.get_latest_training_loss&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal notranslate&quot;&gt;get_latest_training_loss()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;callbacks&lt;/strong&gt; (iterable of &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.callbacks.CallbackAny2Vec&quot; href=&quot;https://radimrehurek.com/gensim/models/callbacks.html#gensim.models.callbacks.CallbackAny2Vec&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;CallbackAny2Vec&lt;/code&gt;&lt;/a&gt;, optional) – Sequence of callbacks to be executed at specific stages during training.&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;sentences: 我们要分析的语料。&lt;/p&gt;
&lt;p&gt;min_count:词频低于这个的词将被忽略.默认为5.&lt;/p&gt;
&lt;p&gt;size:词向量化以后的维度.即特征个数.默认100.&lt;/p&gt;
&lt;p&gt;window: 词向量上下文最大距离&lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;。默认值为5  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他的一些参数,与词向量模型训练的具体算法有关,暂时还不太清楚具体含义,使用的时候暂时取默认值.待日后有了更深理解后补充这篇博文.&lt;/p&gt;

&lt;p&gt;一些比较重要的属性如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;dl class=&quot;attribute&quot; readability=&quot;0.94250871080139&quot;&gt;&lt;dt&gt;wv&lt;/dt&gt;
&lt;dt&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;   &lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.keyedvectors.Word2VecKeyedVectors&quot; href=&quot;https://radimrehurek.com/gensim/models/keyedvectors.html#gensim.models.keyedvectors.Word2VecKeyedVectors&quot;&gt;Word2VecKeyedVectors&lt;/a&gt;&lt;/code&gt; – This object essentially contains the mapping between words and embeddings. After training, it can be used directly             to query those embeddings in various ways. See the module level docstring for examples.&lt;/dt&gt;
&lt;dt id=&quot;gensim.models.word2vec.Word2Vec.vocabulary&quot;&gt;&lt;code class=&quot;descname&quot;&gt;vocabulary&lt;/code&gt;&lt;/dt&gt;
&lt;dd readability=&quot;4.788961038961&quot;&gt;
&lt;p&gt;&lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.Word2VecVocab&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2VecVocab&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;Word2VecVocab&lt;/code&gt;&lt;/a&gt; – This object represents the vocabulary (sometimes called Dictionary in gensim) of the model. Besides keeping track of all unique words, this object provides extra functionality, such as constructing a huffman tree (frequent words are closer to the root), or discarding extremely rare words.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;dl class=&quot;attribute&quot; readability=&quot;-0.48030634573304&quot;&gt;&lt;dt id=&quot;gensim.models.word2vec.Word2Vec.trainables&quot;&gt;&lt;code class=&quot;descname&quot;&gt;trainables&lt;/code&gt;&lt;/dt&gt;
&lt;dd readability=&quot;1.9192825112108&quot;&gt;
&lt;p&gt;&lt;a class=&quot;reference internal&quot; title=&quot;gensim.models.word2vec.Word2VecTrainables&quot; href=&quot;https://radimrehurek.com/gensim/models/word2vec.html#gensim.models.word2vec.Word2VecTrainables&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;Word2VecTrainables&lt;/code&gt;&lt;/a&gt; – This object represents the inner shallow neural network used to train the embeddings. The semantics of the network differ slightly in the two available training modes (CBOW or SG) but you can think of it as a NN with a single projection and hidden layer which we train on the corpus. The weights are then used as our embeddings (which means that the size of the hidden layer is equal to the number of features &lt;cite&gt;self.size&lt;/cite&gt;).&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;dl class=&quot;attribute&quot;/&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;这里注意一下下面的问题&lt;/span&gt;,在第一次用word2vec api的时候我踩了坑了.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个参数sentences是一系列sentence,每一个sentence又是一系列word。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如sentences = [['first', 'sentence'], ['second', 'sentence']]&lt;/p&gt;
&lt;p&gt;则经过word2vec以后,得到'first', 'sentence','second'几个词的词向量.&lt;/p&gt;
&lt;p&gt;如果sentences = [['first sentence'], ['second sentence']]，&lt;/p&gt;
&lt;p&gt;则经过word2vec以后,得到'first sentence', 'second sentence'几个词的词向量.这里word2vec把'first sentence','second sentence'视为是一个词.&lt;/p&gt;
&lt;p&gt;如果sentences = ['first', 'sentence']，则'firsst'被认为是一个句子,‘sentence’被认为是一个句子,‘first’对应的words为‘f’,'i','r','s','t'，经过word2vec以后得到的词向量中的词是‘f’,'i','r','s','t'....而没有'first'。具体参考&lt;a href=&quot;https://stackoverflow.com/questions/45420466/gensim-keyerror-word-not-in-vocabulary&quot; target=&quot;_blank&quot;&gt;stackoverflow的这个回答&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;获取词向量的具体用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
%%&lt;span&gt;time
X_all &lt;/span&gt;= train_words +&lt;span&gt; test_words 
model &lt;/span&gt;= word2vec.Word2Vec(X_all,min_count=1,window=5,size=100&lt;span&gt;) 
model.save(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;words.model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中X_all形如[ ['i','love','you'], ['do','you','know'] ]。这样我们就把X_all中涉及到的words转换成了对应的向量.&lt;/p&gt;
&lt;p&gt;我们可以通过model.wv['love']这样的方式来得到一个词对应的向量.   wv是一个k-v结构,表示word--&amp;gt;vector。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求得词向量后有一些常用的方法如下&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(model.wv.similar_by_word(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;family&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出与'family'最相近的10个词.&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(model.wv.similarity(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;family&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#求出相似程度&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(model.wv.doesnt_match([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;family&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;father&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wife&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出给定词中有别于其他词的词&lt;/span&gt;
&lt;span&gt;
[(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parents&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6177123785018921), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;father&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5987046957015991), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;families&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5883874297142029), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mother&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5699872970581055), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5613149404525757), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5575612783432007), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;community&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5537818074226379), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;friendship&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5431720018386841), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;life&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5359925627708435), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wife&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.5311812162399292&lt;span&gt;)]
&lt;/span&gt;0.6177124&lt;span&gt; 
dog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;word2vec还支持从文件中加载已经训练好的模型.用法如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　model = word2vec.Word2Vec.load('./words.model')   ##载入词向量模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就可以直接下载别人训练好的词向量模型文件直接使用了,节省了训练的时间.&lt;/p&gt;
&lt;p&gt;并且可以恢复训练.例如我们有了更多的语料,我们想训练出新的model。则可以&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;model = gensim.models.Word2Vec.load(&lt;span class=&quot;hljs-string&quot;&gt;'/tmp/mymodel')
model.train(more_sentences)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;至此,我们把每个词转换为了一个100维的向量.&lt;span&gt;网上搜到的绝大部分有关word2vec的资料就到此为止了,并没讲得到词向量以后怎么继续获得样本的特征矩阵.那之后我们要怎么做呢？&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;注意,我们之前用词的tf-idf作为词的特征.每一个句子中的每个词用tf-idf替代,则将一个句子转换为一个N维向量.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而使用word2vec的话,假如一个句子有50个词,假设经过word2vec以后,每个词转变为一个100维的向量. 直接替换的话,那每个句子就变成了5000个特征,样本就变成了了M*5000的矩阵.维度太高了,机器学习的训练速度将大大降低,显然不能这么做.&lt;br/&gt;我们采用取均值的方法,可以这么理解：&lt;span&gt;我们有一个N维空间,每个词就是N维空间里的一个点(或者说向量).一个句子有50个词,也就是说这个句子由N维空间里的50个点组成,现在我们想用N维空间中的某一个点来表示这个句子,则我们把这N个点的向量加起来,(向量的加法,各个维度相加)，再取平均.这样我们就用N维空间里的一个点把这个句子表达了出来.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;X_all_new = []&lt;br/&gt;for sent in X_all:&lt;br/&gt;　　X_all_new.append(np.mean([model.wv[w] for w in sent if w in model.wv],axis=0))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就得到了X_all_new，一个M*N的特征矩阵.然后继续上我们的机器学习算法.&lt;/p&gt;
&lt;p&gt;不过我用了word2vec之后再用逻辑回归预测的结果,并没有比tf-idf更好,只取得了0.85的准确率,并没有比直接用tf-idf取的更好的结果.当然,这不能说明word2vec效果不好,毕竟数据集比较小,而且也只用了一直机器学习算法，只是说在这个影评预测比赛中tf-idf的效果还不错.&lt;/p&gt;

&lt;p&gt;完整代码见：&lt;a href=&quot;https://github.com/sdu2011/nlp/blob/master/nlp_word2vec.ipynb&quot; target=&quot;_blank&quot;&gt;戳这里&lt;/a&gt;.&lt;/p&gt;

</description>
<pubDate>Sat, 05 Jan 2019 14:06:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>在自然语言处理入门里我们提到了词向量的概念,tf-idf的概念,并且在实际的影评正负面预测项目中使用了tf-idf，取得了还算不错的效果.这一篇,我们来尝试一下使用来自google的大名鼎鼎的word</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10212858.html</dc:identifier>
</item>
</channel>
</rss>