<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>三种方法为QLineEdit添加清除内容按钮 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10367521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10367521.html</guid>
<description>&lt;p&gt;很多时候我们会发现输入的一长串内容不得不全部删除重新输入，这时比起一直按着退格键不放一个清除内容按钮更受欢迎。&lt;/p&gt;
&lt;p&gt;今天我将介绍三种为QLineEdit添加清除内容按钮的方法，其中两种方法有较强的功能针对性，另一种方法则是通用的，不仅可以用来实现清除输入内容，还可以扩展出其他功能。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;plan1&quot;&gt;方法1：setClearButtonEnabled显示清除按钮&lt;/h2&gt;
&lt;p&gt;这是Qt5.2之后提供的方法，当使用了&lt;code&gt;setClearButtonEnabled(true);&lt;/code&gt;之后会在 QLineEdit的右侧显示一个图标为&lt;code&gt;QStyle::SP_DialogResetButto&lt;/code&gt;的QAction，点击后会清除输入内容：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案1
auto edit1 = new QLineEdit;
edit1-&amp;gt;setClearButtonEnabled(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230823154-2067997125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到右边那个图标，如果是Qt自带的话会是一个类似扫把的图形，如果使用了系统主题那么会有些许差异，点击它，输入内容就会全部清除。&lt;/p&gt;
&lt;h2 id=&quot;plan2&quot;&gt;方法2：使用QAction实现清除按钮&lt;/h2&gt;
&lt;p&gt;如前所述，&lt;code&gt;setClearButtonEnabled&lt;/code&gt;其实只是让实现存在的QAction显示出来而已，所以我们也可以自己实现这一过程。&lt;/p&gt;
&lt;p&gt;要实现这一功能，需要Qt5.2之后提供的&lt;code&gt;addAction&lt;/code&gt;方法。它负责把一个QAction添加到edit的指定位置。&lt;/p&gt;
&lt;p&gt;不过要注意的是，这个QAction只能显示出图标，文字内容的显示不出的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案2
auto clearAction = new QAction;
clearAction-&amp;gt;setIcon(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
auto edit2 = new QLineEdit;
// QLineEdit::TrailingPosition表示将action放置在右边
edit2-&amp;gt;addAction(clearAction, QLineEdit::TrailingPosition);
QObject::connect(clearAction,
      &amp;amp;QAction::triggered,
      edit2,
      [edit2]{ edit2-&amp;gt;setText(&quot;&quot;); });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们知道lineedit默认使用的清除按钮的图标，也知道如何清除输入，所以可以自己实现这一过程。&lt;/p&gt;
&lt;p&gt;这是效果，与方法1时几乎没什么区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230758946-1389389609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过方法二的威力不止于此，基于我们可以使用自己的QAction，那么就可以定制一些操作，比如使用我们自己的图标:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;clearAction-&amp;gt;setIcon(QIcon(&quot;:/clear.png&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230746750-260459178.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法相比前一种略显复杂，然而却提供了更好的扩展性。&lt;/p&gt;
&lt;p&gt;接下来要介绍的最后一种方法更加的灵活，你不仅可以显示自定义图标，还可以显示自定义文字，当然作为代价它比第二种方法要复杂不少。&lt;/p&gt;
&lt;h2 id=&quot;plan3&quot;/&gt;
&lt;p&gt;方法3：自定义QLineEdit为其添加按钮&lt;br/&gt;这种方法对Qt的版本没有什么要求，所以它也足够通用。&lt;/p&gt;
&lt;p&gt;想要在QLineEdit上添加一个widget一点也不复杂，首先我们要弄清以下几个原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qt的widget和layout是可以堆叠的，之前在&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/10268108.html&quot;&gt;实现半透明遮罩&lt;/a&gt;中有提过&lt;/li&gt;
&lt;li&gt;你可以为QLineEdit设置layout，如你所料layout会堆叠在edit的输入框上&lt;/li&gt;
&lt;li&gt;edit的layout会只使用控件的最小尺寸，这样不会导致将整个输入框遮盖掉&lt;/li&gt;
&lt;li&gt;edit的可输入区域是可以设置的，你可以合理的设置输入区的大小避免文字进入layout之下被遮盖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以如果我们想为QLineEdit或是其派生类添加一个widget比如QPushButton，那么需要如下几部：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建你需要的widget以及一个布局管理器&lt;/li&gt;
&lt;li&gt;添加拉伸因子和widget至布局管理器，拉伸因子可以不添加，只要设置好布局管理器的排列方向即可&lt;/li&gt;
&lt;li&gt;设置布局管理器里组件的排列方向并把布局管理器添加到QLineEdit&lt;/li&gt;
&lt;li&gt;获取你添加的widget的宽度，然后在加上合适的边框距离，将QLineEdit的输入区域限制在合理的大小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说起来简单做起来难，我们边看代码边讲解。&lt;/p&gt;
&lt;p&gt;我们先看类的定义，&lt;code&gt;ButtonEdit&lt;/code&gt;是一个带有按钮的QLineEdit：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QLineEdit&amp;gt;
#include &amp;lt;QPushButton&amp;gt;
#include &amp;lt;QString&amp;gt;
#include &amp;lt;QIcon&amp;gt;

class ButtonEdit: public QLineEdit {
    Q_OBJECT
public:
    explicit ButtonEdit(const QString &amp;amp;btnText, QWidget *parent = nullptr);
    explicit ButtonEdit(const QIcon &amp;amp;icon, QWidget *parent = nullptr);
    ~ButtonEdit() override = default;

private:
    // 设置文本按钮或图标按钮的大小和外观
    void setTextButton();
    void setIconButton();
    // 将按钮添加到edit
    void addButton();

    QPushButton *button;

Q_SIGNALS:
    void buttonClicked(bool);
};

// 按钮和输入内容的边距
constexpr int buttonMargin = 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的类可以从一个string或者icon构建，当edit的按钮被点击那么我们就发出&lt;code&gt;buttonClicked&lt;/code&gt;信号。&lt;/p&gt;
&lt;p&gt;也许你会觉得对于按钮的设置分成两类没什么必要。事实不然，图形应用的开发有很多麻烦事，而其中比较头疼的要数如何让控件保持一个恰到好处的尺寸，而对于图标的处理和文本是不一样的，所以有分开的必要。当然，如果你不介意文字或者图标只显示一半或者突出到编辑框的话也可以跳过这一步。&lt;/p&gt;
&lt;p&gt;下面我们来看下类成员的实现，构造函数没什么亮点，无非构造button，然后交由其他成员去处理：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ButtonEdit::ButtonEdit(const QString &amp;amp;btnText, QWidget *parent)
 : QLineEdit(parent)
{
    button = new QPushButton(btnText);
    setTextButton();
    addButton();
}

ButtonEdit::ButtonEdit(const QIcon &amp;amp;icon, QWidget *parent)
 : QLineEdit(parent)
{
    button = new QPushButton;
    button-&amp;gt;setIcon(icon);
    setIconButton();
    addButton();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着是&lt;code&gt;addButton&lt;/code&gt;，在这里我们先把button添加进layout，随后又设置了输入区域的大小避免输入内容被遮住：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ButtonEdit::addButton() {
    connect(button,
            &amp;amp;QPushButton::clicked,
            this,
            &amp;amp;ButtonEdit::buttonClicked);
    // 按钮已经是edit的一部分了，不应该再能被单独聚焦，否则可能导致误触
    button-&amp;gt;setFocusPolicy(Qt::NoFocus);
    // 设置鼠标，否则点击按钮时仍然会显示输入内容是的鼠标图标
    button-&amp;gt;setCursor(Qt::ArrowCursor);

    auto btnLayout = new QHBoxLayout;
    btnLayout-&amp;gt;addStretch();
    btnLayout-&amp;gt;addWidget(button);
    // 设置组件右对齐，按钮会显示在edit的右侧
    btnLayout-&amp;gt;setAlignment(Qt::AlignRight);
    btnLayout-&amp;gt;setContentsMargins(0, 0, 0, 0);
    setLayout(btnLayout);
    // 设置输入区域的范围，从edit的最左到按钮的最左(包含了按钮设置的buttonMargin)
    setTextMargins(0, 0, button-&amp;gt;width(), 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是如何设置button的大小和样式了，大小我们设置和图标/文本的大小一样大，然后两边加上&lt;code&gt;buttonMargin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于图标按钮我们还要设置按钮背景平时不可见，毕竟图标周围有个&lt;code&gt;buttonMargin&lt;/code&gt;宽度的框不太好看：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 帮助函数，设置按钮的width，大小策略为fixed，不可放大或缩小
static void setButtonSize(QPushButton *button, int width) {
    auto policy = button-&amp;gt;sizePolicy();
    policy.setHorizontalPolicy(QSizePolicy::Fixed);
    button-&amp;gt;setSizePolicy(policy);
    // 固定宽度，加上边距
    button-&amp;gt;setFixedWidth(width + buttonMargin*2);
}

void ButtonEdit::setTextButton() {
    if (!button) {
        return;
    }

    // 获得当前字体下文本内容的像素宽度
    auto width = QWidget::fontMetrics().width(button-&amp;gt;text());
    setButtonSize(button, width);
}

void ButtonEdit::setIconButton() {
    if (!button) {
        return;
    }

    // 获取图标的width简单得多
    auto width = button-&amp;gt;iconSize().width();
    setButtonSize(button, width);
    // 设置背景和边框在非点击时不可见
    button-&amp;gt;setFlat(true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在工作完成了，不管我们添加什么样的图标还是多长的文本，按钮都可以保证有一个合适的大小，输入内容也不会被按钮遮住。&lt;/p&gt;
&lt;p&gt;现在我们看下使用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案3
// 使用文本按钮
auto edit3_1 = new ButtonEdit(&quot;clear&quot;);
QObject::connect(edit3_1,
                &amp;amp;ButtonEdit::buttonClicked,
                edit3_1,
                [edit3_1]{ edit3_1-&amp;gt;setText(&quot;&quot;); });
// 使用图标按钮
auto edit3_2 = new ButtonEdit(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
QObject::connect(edit3_2,
                &amp;amp;ButtonEdit::buttonClicked,
                edit3_2,
                [edit3_2]{ edit3_2-&amp;gt;setText(&quot;&quot;); });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230705789-129055682.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方案是最复杂的，但也是最灵活的，我们可以定制button的外观，通过&lt;code&gt;buttonClicked&lt;/code&gt;信号我们可以定制按钮按下后的行为。所以我在上一节才说这是扩展性最好的方法。&lt;/p&gt;
&lt;p&gt;不过方案二和三都有一个显著的缺点，即使输入框中没有内容按钮或QAction也会一直显示，有些时候这不是我们需要的行为。解决办法也很简单，合理利用QLineEdit的信号加上&lt;code&gt;QWidget::hide&lt;/code&gt;和&lt;code&gt;QAction::setVisible&lt;/code&gt;就能实现按钮的隐藏，这一功能的实现就当做练习吧。&lt;/p&gt;
&lt;h2 id=&quot;最终的显示效果&quot;&gt;最终的显示效果&lt;/h2&gt;
&lt;p&gt;现在我们将三种方法合并显示在一起，以便大家看到各个方案带来的显示效果：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QLineEdit&amp;gt;
#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QAction&amp;gt;
#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QIcon&amp;gt;
#include &amp;lt;QFormLayout&amp;gt;
#include &amp;lt;QStyle&amp;gt;

#include &quot;ButtonEdit&quot;

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    // 方案1
    auto edit1 = new QLineEdit;
    edit1-&amp;gt;setClearButtonEnabled(true);

    // 方案2
    auto clearAction = new QAction;
    clearAction-&amp;gt;setIcon(QIcon(&quot;:/clear.png&quot;));
    auto edit2 = new QLineEdit;
    edit2-&amp;gt;addAction(clearAction, QLineEdit::TrailingPosition);
    QObject::connect(clearAction,
            &amp;amp;QAction::triggered,
            edit2,
            [edit2]{ edit2-&amp;gt;setText(&quot;&quot;); });

    // 方案3
    // 使用文本按钮
    auto edit3_1 = new ButtonEdit(&quot;clear&quot;);
    QObject::connect(edit3_1,
                     &amp;amp;ButtonEdit::buttonClicked,
                     edit3_1,
                     [edit3_1]{ edit3_1-&amp;gt;setText(&quot;&quot;); });
    // 使用图标按钮
    auto edit3_2 = new ButtonEdit(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
    QObject::connect(edit3_2,
                     &amp;amp;ButtonEdit::buttonClicked,
                     edit3_2,
                     [edit3_2]{ edit3_2-&amp;gt;setText(&quot;&quot;); });

    auto win = new QWidget;
    auto layout = new QFormLayout;
    layout-&amp;gt;addRow(&quot;方案1：&quot;, edit1);
    layout-&amp;gt;addRow(&quot;方案2：&quot;, edit2);
    layout-&amp;gt;addRow(&quot;方案3_1：&quot;, edit3_1);
    layout-&amp;gt;addRow(&quot;方案3_2：&quot;, edit3_2);
    win-&amp;gt;setLayout(layout);

    win-&amp;gt;show();

    return app.exec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当无输入内容时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230638647-2099047190.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当有输入内容时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230621036-1065914811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样三种方法都介绍完了，选用哪种需要自己决定。&lt;/p&gt;
&lt;p&gt;当然最后两种方案不仅仅能用来做清除内容按钮，只要加入一点点想象力还有更高级的功能可以用它们来实现。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 15:10:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>很多时候我们会发现输入的一长串内容不得不全部删除重新输入，这时比起一直按着退格键不放一个清除内容按钮更受欢迎。 今天我将介绍三种为QLineEdit添加清除内容按钮的方法，其中两种方法有较强的功能针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10367521.html</dc:identifier>
</item>
<item>
<title>Oracle在线重定义(online redefinition)--将普通表改为分区表 - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/9985346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/9985346.html</guid>
<description>&lt;p&gt;使用Oracle的在线重定义技术，可以将Oracle的普通表改为分区表。操作如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;STEP1&lt;/span&gt;：测试表是否可以在线重定义，这里以unixdev数据库的LIJIAMAN.BSTEST为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;EXEC&lt;/span&gt; DBMS_REDEFINITION.CAN_REDEF_TABLE(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, DBMS_REDEFINITION.CONS_USE_PK);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果表上没有主键，则会报错：&lt;br/&gt;SQL&amp;gt; exec dbms_redefinition.start_redef_table('LIJIAMAN', 'BSTEST', 'BSTEST_TMP');&lt;br/&gt;&lt;span&gt;ORA-12089: 不能联机重新定义无主键的表 &quot;LIJIAMAN&quot;.&quot;BSTEST&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ORA-06512: 在 &quot;SYS.DBMS_REDEFINITION&quot;, line 56&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ORA-06512: 在 &quot;SYS.DBMS_REDEFINITION&quot;, line 1498&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ORA-06512: 在 line 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;STEP2&lt;/span&gt;：创建中间表&lt;br/&gt;除了表名称外，该中间表的形式需要与我们最终的分区表的形式一模一样，如列名，列的数据类型、分区字段，分区方法等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; BSTEST_tmp
( TIMEKEY &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;), 
ITEMNAME &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;), 
SITENAME &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;), 
SITEVALUE &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;) 
) 
partition &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; range (timekey) 
( partition part_201711 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201712010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201712 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201801010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201801 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201802010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201802 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201803010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
partition part_201803 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201804010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201804 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201805010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201805 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201806010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201806 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201807010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201807 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201808010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201808 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201809010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201809 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201810010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201810 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201811010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201811 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201812010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201812 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201901010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201901 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201902010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201902 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201903010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201903 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201904010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201904 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201905010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201905 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201906010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201906 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201907010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201907 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201908010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201908 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201909010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201909 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201910010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201910 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201911010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201911 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;201912010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_201912 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;202001010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_202001 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;202002010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_202002 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;202003010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_202003 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;202004010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_202004 &lt;/span&gt;&lt;span&gt;values&lt;/span&gt; less than(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;202005010000000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
partition part_max &lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt; less than(maxvalue) 
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;STEP3&lt;/span&gt;：执行在线重定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; dbms_redefinition.start_redef_table(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST_TMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：该步骤执行时间较长，3.7GB的表执行了60s&lt;/p&gt;

&lt;p&gt;&lt;span&gt;STEP4&lt;/span&gt;：将中间表的内容与数据源同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;execute&lt;/span&gt; dbms_redefinition.sync_interim_table(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST_TMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;STEP5&lt;/span&gt;：结束在线重定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; dbms_redefinition.finish_redef_table(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST_TMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;STEP6&lt;/span&gt;：创建index、创建约束，两种方法创建速度差不多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; session &lt;span&gt;set&lt;/span&gt; db_file_multiblock_read_count&lt;span&gt;=&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; BSTEST &lt;span&gt;add&lt;/span&gt; &lt;span&gt;constraint&lt;/span&gt; BSPANELPROCESSDATAITEM_PKS &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(timekey,itemname,sitename) using &lt;span&gt;index&lt;/span&gt; local tablespace users;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;STEP7&lt;/span&gt;：收集统计信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; dbms_stats.gather_table_stats(ownname&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LIJIAMAN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, tabname&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BSTEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, method_opt&lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FOR ALL INDEXED COLUMNS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, estimate_percent &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;cascade&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;true);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：该步骤执行时间较长，3.7GB的表执行了36s，如果嫌慢，可以并行收集&lt;/p&gt;

&lt;p&gt;&lt;span&gt;STEP8&lt;/span&gt;：确认无误之后，删除STEP2创建的中间表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; BSTEST_TMP;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;p&gt;如果要了解在线重定义的详细用法及使用注意事项，可参阅官方文档：&lt;br/&gt;1. https://docs.oracle.com/cd/E11882_01/server.112/e25494/tables.htm#ADMIN11677&lt;br/&gt;2. How To Partition Existing Table Using DBMS_REDEFINITION (文档 ID 472449.1)&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 15:01:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<og:description>使用Oracle的在线重定义技术，可以将Oracle的普通表改为分区表。操作如下： STEP1：测试表是否可以在线重定义，这里以unixdev数据库的LIJIAMAN.BSTEST为例 如果表上没有主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiaman/p/9985346.html</dc:identifier>
</item>
<item>
<title>逆向分析-之深入理解函数 - 秃桔子</title>
<link>http://www.cnblogs.com/godoforange/p/10367470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godoforange/p/10367470.html</guid>
<description>&lt;p&gt;程序都是由具有不同功能的函数组成的，&lt;/p&gt;
&lt;p&gt;因此在逆向分析中将重点放在 函数的识别 和 参数的传递 上是明智的，&lt;/p&gt;
&lt;p&gt;这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包括函数名，入口参数，返回值，函数功能等部分。&lt;/p&gt;
&lt;p&gt;1. 函数的识别&lt;/p&gt;
&lt;p&gt;　　程序通过调用程序来调用函数,在函数执行后又返回调用程序继续执行。函数如何知道要返回的函数的地址呢？&lt;/p&gt;
&lt;p&gt;　　实际上，调用函数的代码中保存了一个返回地址，该地址会与参数一起传递给被调用的函数。有多种方法可以实现这个功能，在绝大多数情况下，编译器都使用&lt;span&gt;call和ret 指令&lt;/span&gt;来调用函数及返回调用指令。&lt;/p&gt;
&lt;p&gt;　　call指令与跳转指令类似。&lt;/p&gt;
&lt;p&gt;　　不同的是，call指令保存返回信息，即将其之后的指令地址压入栈顶，当遇到ret指令时返回这个地址。&lt;/p&gt;
&lt;p&gt;　　也就是说，call指令给出的地址就是被调用函数的起始地址。ret指令则用于结束函数的执行(当然,不是所有的ret指令都标志着函数的结束)。&lt;/p&gt;
&lt;p&gt;　　通过这一机制可以很容易地把函数调用和其他跳转指令区分开来。&lt;/p&gt;
&lt;p&gt;　　因此，可以通过定位call机器指令或利用ret指令结束的标志来识别函数。call指令的操作数就是所调用函数的首地址。&lt;/p&gt;
&lt;p&gt;　　这种函数直接调用方式使程序变得很简单。&lt;/p&gt;
&lt;p&gt;2.函数的参数&lt;/p&gt;
&lt;p&gt;　　函数传递参数有3种方式，&lt;span&gt;栈方式&lt;/span&gt;，&lt;span&gt;寄存器方式&lt;/span&gt;以及通过全局变量进行&lt;span&gt;隐含参数传递方式&lt;/span&gt;。如果参数是通过栈传递的，就需要定义参数在栈中的顺序，并约定函数被调用后由谁来平衡栈。如果参数是通过寄存器传递的，就要确定参数存放在哪个寄存器中。&lt;/p&gt;
&lt;p&gt;　　每种机制都有优缺点，并且和使用的编译语言有关。&lt;/p&gt;
&lt;p&gt;　　(1)栈方式&lt;/p&gt;
&lt;p&gt;　　　　栈是一种先进后出的存储区，栈顶指针esp 指向栈中第一个可用的数据项。在调用函数时，调用者依此把参数压入栈，然后调用函数，函数被调用后，在栈中取得数据并进行计算。函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样。即平衡。&lt;/p&gt;
&lt;p&gt;　　　　在参数的传递中有俩个很重要的问题：&lt;/p&gt;
&lt;p&gt;　　　　1.当参数个数多于1个时，按照什么顺序把参数压入栈？&lt;/p&gt;
&lt;p&gt;　　　　2.函数结束后,由谁来平衡栈？这些都必须有约定。这种在程序设计语言中为了实现函数调用而建立的协议称为调用约定。这种协议规定了函数中的参数传送方式，参数是否可变和由谁处理栈问题等。&lt;/p&gt;
&lt;p&gt;　　　　C举例子。C的参数传递顺序为从右到左，平衡栈者是调用者。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
push param3//参数从右到左
push param2
push param1
call test1
add esp,0C;//平衡栈
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　函数对参数的存取及局部变量都是通过栈定义的，非优化编译器用一个专门的寄存器(通常是 ebp)对参数进行寻址。C,C++,pascal等高级语言的函数执行过程基本一致情况如下：&lt;/p&gt;
&lt;p&gt;　　　　调用者将函数（子程序）执行完毕时应返回的地址，参数压入栈。&lt;/p&gt;
&lt;p&gt;　　　　子程序使用 ”ebp指针+偏移量“对栈中的参数进行寻址并取出，完成操作&lt;/p&gt;
&lt;p&gt;　　　　子程序使用ret或retf返回 。此时CPU将eip置为栈中保存的地址，并继续执行它。&lt;/p&gt;
&lt;p&gt;　　　　栈在整个过程中发挥着非常重要的作用。栈是一个先进后出的区域，只有一个出口，即当前栈顶。栈操作的对象只能说双操作数(占4字节) 。&lt;/p&gt;
&lt;p&gt;　　　　在许多时候，编译器会按优化方式来编译程序，栈寻址稍有不同。这时，编译器为了节省ebp寄存器或尽可能减少代码以提高速度，会直接通过esp对参数进行寻址。esp的值在函数执行期间会发生变化，该变化出现在每次有数据进出栈时。要想确定对那个变量进行寻址，就要知道程序当前位置的esp的值，为此必须从函数的开始部分进行跟踪。&lt;/p&gt;
&lt;p&gt;　　　(2)利用寄存器传递参数&lt;/p&gt;
&lt;p&gt;　　　　寄存器传递参数的方式没有标准，所有与平台相关的方式都是由编译器开发人员制定的。尽管没有标准，但绝大多数编译器提供商都在不对兼容性进行声明的情况下遵循相应的规范，即fastcall规范。fastcall 顾名思义，特点就是快(因为它是靠寄存器传递参数的)&lt;/p&gt;
&lt;p&gt;　　　　不同编译器实现的Fastcall 稍有不同。Microsoft Visual C++ 编译器在采用Fastcall 规范传递参数时，左边的2个不大于4字节的参数分别放在ecx和edx寄存器中，寄存器用完后就要使用栈，其余参数仍按照从左到右的顺序压入栈，被调用的函数在返回前清理传送参数的栈，浮点值，远指针和__int64 类型总是通过栈来传递的。而Borland Delphi/C++ 编译器在采用Fastcall 规范传递参数时候，左边的3个不大于4字节(dword)的参数分别放在eax,edx,和ecx寄存器中，寄存器使用完之后，其余参数按照从左到右的PASCAL方式压入栈。&lt;/p&gt;
&lt;p&gt;　　　　另有一款编译器Watcom C 总是通过寄存器来传递参数，它严格为每一个参数分配一个寄存器，默认情况下第一个参数用eax，第二个参数用edx，第三个参数用ebx，第四个阐述用ecx。如果寄存器用完，就会用栈来传递参数。因此，其参数实际上可能通过任何寄存器进行传递。&lt;/p&gt;
&lt;p&gt;　　　(3)名称修饰约定&lt;/p&gt;
&lt;p&gt;　　　　为了允许使用操作符和函数重载，C++编译器往往会按照某种规则改写每一个入口点的符号名，从而允许同一个名字(具有不同的参数类型或者不同的作用域) 有多个用法且不会破坏现有的基于C的链接器。这项技术通常称为名称改编或者名称修饰。许多C++编译器厂商都制定了自己的名称修饰方案。&lt;/p&gt;
&lt;p&gt;　　　　在VC++中，函数修饰名由变异类型（C或C++），函数名，类名，调用约定，返回类型，参数等共同决定。关于名称的内容很多，&lt;/p&gt;
&lt;p&gt;　　　　　stdcall调用约定在输出函数名前面加一个下划线前缀，在后面加一个”@“符号以及参数的字节数，格式为”_functionname@number“&lt;/p&gt;
&lt;p&gt;　　　　_cdecl调用约定仅在输出函数名前面加一个下划线前缀，格式为”_functionname“&lt;/p&gt;
&lt;p&gt;　　　　Fastcall 调用约定在输出函数名前面加一个”@“符号，在后面加一个”@“符号及其参数的字节数，格式为”@functionname@number“&lt;/p&gt;
&lt;p&gt;3.函数的返回值&lt;/p&gt;
&lt;p&gt;　　函数被调用执行后，将向调用者返回1个或多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过参数按传引用的方式返回值，通过全局变量返回值等。&lt;/p&gt;
&lt;p&gt;　　(1) 用return 操作符返回值&lt;/p&gt;
&lt;p&gt;　　　　在一般情况下，函数的返回值放在eax寄存器中返回，如果处理结果的大小超过eax寄存器的容量，其高32位就会放到edx寄存器中。&lt;/p&gt;
&lt;p&gt;　　(2)通过参数按照引用方式返回值&lt;/p&gt;
&lt;p&gt;　　　　给参数传递的方式有俩种，分别是传值和传引用。进行传值调用时，会建立参数的一份复本，并把它传给调用函数，在调用函数中修改参数的复本不会影响原始的变量值。&lt;/p&gt;
&lt;p&gt;　　　　传引用调用允许调用参数修改原始变量的值。调用某个函数，当把变量的地址传递给函数时，可以在函数中用间接运算符修改调用函数内存单元该变量的值。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:56:00 +0000</pubDate>
<dc:creator>秃桔子</dc:creator>
<og:description>程序都是由具有不同功能的函数组成的， 因此在逆向分析中将重点放在 函数的识别 和 参数的传递 上是明智的， 这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/godoforange/p/10367470.html</dc:identifier>
</item>
<item>
<title>聊聊银企直联服务那些事 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10367408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10367408.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;相关 &lt;a href=&quot;https://wiki.mbalib.com/wiki/%E9%93%B6%E4%BC%81%E7%9B%B4%E8%81%94&quot;&gt;wiki&lt;/a&gt; 定义。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;银企直联是指集团企业在集团内部建立自己的资金管理系统，通过数据接口将内部资金管理系统与商业银行核心系统、网银或者现金管理平台实现联接。通过银企直联系统企业可实现实时帐户信息查询、明细查询、自动转帐、交易查询等功能。并且交易的实时性和方便性得到大幅提高。“银企直联”的应用特点是连接手段不限，公网、专线均可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面说说一些使用银企直联的实际场景。&lt;/p&gt;
&lt;p&gt;公司一般都会在某个银行开设对公账户，相关款项需要通过该对公账户出款。使用对公账户出款需要使用企业网银，出款流程类似我们使用个人网银出款流程。&lt;/p&gt;
&lt;p&gt;若业务场景需要将商家的当天收款金额转账至其银行卡。未接入银企之前，财务同学需要登录企业网银，创建出款信息，然后插入银行 U 盾，确认出款。接入银企之后，可以实现自动将商家的金额汇总然后转账出款，无需繁琐的网银流程。这样可以与内部服务关联，实现线上化。&lt;/p&gt;
&lt;p&gt;当然银企服务还可以实现查找银行流水等功能。&lt;/p&gt;
&lt;p&gt;我司基于银企直联服务，开发了公司内部服务，很大程度解决财务打款，后期做账核对繁琐问题。&lt;/p&gt;
&lt;p&gt;现就将本人接入几家银行经历，谈谈银企直联服务接入流程。&lt;/p&gt;
&lt;h2 id=&quot;银企接入流程&quot;&gt;银企接入流程&lt;/h2&gt;
&lt;p&gt;银企接入流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;与银行签订相关服务，获取相关开发文档，以及生产相关配置参数。&lt;/li&gt;
&lt;li&gt;安装银企前置服务。&lt;/li&gt;
&lt;li&gt;根据文档接入相关接口。&lt;/li&gt;
&lt;li&gt;相关接口测试环境测试，完成测试报告，提交给银行。银行开通正式环境权限，然后在正式环境测试连通性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一步一般由公司财务相关人员与银行客户经理商谈即可。&lt;/p&gt;
&lt;p&gt;第二步安装银企前置服务软件。整个银企服务一般由企业应用程序，银企前置程序，银行服务构成。三者关系见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1549888516180-435a0ff2-4799-411f-8f49-e338fbfdb6a4.png&quot; alt=&quot;部署图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;企业内部程序根据银行文档组装报文，报文格式一般以 xml 为主。然后内部程序将报文通过 HTTP 或 Socket 方式发送至银行前置程序。银行前置程序接受报文，先进行相关报文格式校验，然后使用数字证书加密报文，发送至银行服务。最后银行前置程序验证银行服务返回报文，再将解析后报文返回企业内部程序。&lt;/p&gt;
&lt;p&gt;银行前置程序与银行服务连接有两种方式：&lt;/p&gt;
&lt;p&gt;公网连接，特点成本低，网速容易受外部网络环境影响。&lt;/p&gt;
&lt;p&gt;专线连接，采用专门线路物理连接企业与银行两端。该方式网速稳定，不易受外部网络环境影响。但是成本相对较高。&lt;/p&gt;
&lt;p&gt;需要注意的是，银企前置程序大都只能安装在 Windows 上，可能与银企直联所需要的 U 盾驱动只兼容 Windows 有关。有的银企前置程序为单独软件，需要安装，有的为 Java 程序，无需单独安装。&lt;/p&gt;
&lt;p&gt;第三步，根据银行开发文档接入相关接口。&lt;/p&gt;
&lt;p&gt;银企服务一般会提供转账，查询流水，查询余额等接口。&lt;/p&gt;
&lt;p&gt;第四步测试相关银企服务，有的银行需要在测试环境测试通过后，才能开通正式生产环境。&lt;/p&gt;
&lt;p&gt;目前已经开发的银行如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[x] 招商银行&lt;/li&gt;
&lt;li&gt;[x] 建设银行&lt;/li&gt;
&lt;li&gt;[x] 宁波银行&lt;/li&gt;
&lt;li&gt;[x] 平安银行&lt;/li&gt;
&lt;li&gt;[x] 工商银行&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;相关银行开发经验&quot;&gt;相关银行开发经验&lt;/h2&gt;
&lt;h3 id=&quot;招商银行&quot;&gt;招商银行&lt;/h3&gt;
&lt;p&gt;招行银企前置程序需要单独安装，相关接口按照文档开发即可。招行开发文档比较完善，且存在相关 Demo，接入比较简单。&lt;/p&gt;
&lt;h3 id=&quot;建设银行&quot;&gt;建设银行&lt;/h3&gt;
&lt;p&gt;建行银企前置服务为 Java 程序，需要安装 JDK5+ 。&lt;/p&gt;
&lt;p&gt;建行银企前置程序需要设置操作员，需要提前在企业网银处设置，设置过程比较繁琐。&lt;/p&gt;
&lt;p&gt;建行开发文档未提供开发 Demo，可以向银行支持技术索取。企业程序向建行前置服务发送报文需要使用以下方式 &lt;strong&gt;requestXML='xml'&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;宁波银行&quot;&gt;宁波银行&lt;/h3&gt;
&lt;p&gt;这家银行相对坑爹，前期银行技术支持给错文档，且支持人员不知道前置机软件怎么安装。后经与其总行交谈，才获取接口等文档。&lt;/p&gt;
&lt;p&gt;前置程序需要单独安装，设置也比较麻烦，需要指定两个端口，一个为报文接受端口，一个为加密端口。&lt;/p&gt;
&lt;p&gt;宁波银行与上面银行不同之处在于，其每笔报文需要先通过登陆接口获取 session，然后再构建报文。转账接口报文需要先将报文发送到前置机加密，获取签名数据，然后将签名数据组装到报文中构成完整 xml。&lt;/p&gt;
&lt;p&gt;宁波银行前置程序使用 U 盾驱动兼容性较差，长时间使用过程中会出现 U 盾突然无法识别情况，需要重新插拔。&lt;/p&gt;
&lt;h3 id=&quot;平安银行&quot;&gt;平安银行&lt;/h3&gt;
&lt;p&gt;银行前置程序为 Java web，需要使用 JDK 6+ 版本。&lt;/p&gt;
&lt;p&gt;平安银行报文由报头加报文体构成。报文头按照固定格式拼接，报文体根据接口拼接。部分接口需要前置机加密，需要在前置机软件后台提前设置。&lt;/p&gt;
&lt;h3 id=&quot;工商银行&quot;&gt;工商银行&lt;/h3&gt;
&lt;p&gt;工行前期接入过程需要注意 U 盾自带驱动存在问题，需要使用特殊的驱动程序。&lt;/p&gt;
&lt;p&gt;U 盾证书刚开始拿到可能无法用于交易，需要银行人员分配证书权限。&lt;/p&gt;
&lt;h3 id=&quot;相关问题&quot;&gt;相关问题&lt;/h3&gt;
&lt;p&gt;下面说说接入或日常运维中中可能碰到的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转账掉单问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口，未返回一个不明确状态（成功或失败），这种情况我们称为掉单。&lt;/p&gt;
&lt;p&gt;导致掉单的原因可能为银行内部服务出错，或网络问题。&lt;/p&gt;
&lt;p&gt;对于这种掉单情况，需要配合使用银企查询接口，查询最终状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;银企前置程序并发问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企前置程序一般无法支持很高并发交易量，如招商银行文档就建议同时不超过 50 。若企业程序调用转账接口并发数较大，可以采用批量打包方式，每隔一段时间将所有交易组装成报文，然后调用银企批量转账接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;企业内部服务与银企前置服务通讯报文一般都是未加密的明文，这个通讯过程比较容易被监听，篡改，安全性较低。&lt;/p&gt;
&lt;p&gt;我们之前做法为将银企服务与企业内部程序部署在企业内网。外部网络访问需通过相关 VPN 才能访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转账时效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口通常内部使用人行大小额系统或超级网银系统。采用系统不同，转账时效性也不同。&lt;/p&gt;
&lt;p&gt;大小额系统由大额支付系统与小额支付系统构成。小额系统全年无休，7x24 小时工作，金额小于 5W 的交易会采用小额系统。大额系统运行在工作日的 8:00 ~ 17:00，金额大于 5 W 以上的以上会使用大额系统。&lt;/p&gt;
&lt;p&gt;超级网银系统，央行第二代支付系统，交易限额为 5w,到账速度非常快，但是相对转账费率较高。&lt;/p&gt;
&lt;p&gt;对于非工作日大于 5w 的交易若想保证时效性，可以采用拆单方法，将一笔转账拆分成多笔转账出去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联行号/超级行号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口，一般对于跨行转账，接口需要传入他行卡所在行的联行号/超级行号。联行号/超级行号相关资料可以让银行提供，但是不同银行给的资料可能不太相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;企业网银设置问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前期接入过程，若报文组装正确，但是报文始终无法通过，多半由于权限未正常设置导致。一般需要登录企业网银单独设置权限，设置比较繁琐，且每家银行都不太一样，详情咨询银行客户经理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;银行 U 盾密码问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企程序每次启动运行前会读取加载 U 盾数字证书，读取过程需要输入 U 盾数字密码。需要注意输入正确密码，输错次数过多，会导致 U 盾被银行锁死无法使用。需要去银行解锁或重新申请新 U 盾。这个说多了都是泪。：（&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E9%93%B6%E4%BC%81%E7%9B%B4%E8%81%94&quot;&gt;&lt;strong&gt;银企直联系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E5%B0%8F%E9%A2%9D%E6%89%B9%E9%87%8F%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F&quot;&gt;&lt;strong&gt;小额批量支付系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E5%A4%A7%E9%A2%9D%E5%AE%9E%E6%97%B6%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F&quot;&gt;&lt;strong&gt;大额实时支付系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E8%B6%85%E7%BA%A7%E7%BD%91%E9%93%B6&quot;&gt;&lt;strong&gt;超级网银&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:37:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>背景 相关 'wiki' 定义。 银企直联是指集团企业在集团内部建立自己的资金管理系统，通过数据接口将内部资金管理系统与商业银行核心系统、网银或者现金管理平台实现联接。通过银企直联系统企业可实现实时帐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10367408.html</dc:identifier>
</item>
<item>
<title>Golang之轻松化解defer的温柔陷阱 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10367346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10367346.html</guid>
<description>&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;f, _ := os.Open(&quot;defer.txt&quot;)
defer f.Close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断&lt;code&gt;f&lt;/code&gt;是否为空，如果&lt;code&gt;f&lt;/code&gt;为空，就不能调用&lt;code&gt;f.Close()&lt;/code&gt;函数了，会直接panic的。&lt;/p&gt;

&lt;p&gt;程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供&lt;code&gt;defer&lt;/code&gt;关键字，在打开资源语句的下一行，就可以直接用&lt;code&gt;defer&lt;/code&gt;语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。&lt;/p&gt;

&lt;p&gt;defer的使用其实非常简单：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;f,err := os.Open(filename)
if err != nil {
    panic(err)
}

if f != nil {
    defer f.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。&lt;/p&gt;
&lt;p&gt;当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。&lt;/p&gt;

&lt;h2 id=&quot;defer的底层原理是什么&quot;&gt;defer的底层原理是什么？&lt;/h2&gt;
&lt;p&gt;我们先看一下官方对&lt;code&gt;defer&lt;/code&gt;的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下：每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.&lt;/p&gt;
&lt;p&gt;defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进先出的顺序执行。也说是说最先被定义的defer语句最后执行。先进先出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。&lt;/p&gt;
&lt;p&gt;在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。&lt;/p&gt;
&lt;p&gt;defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var whatever [3]struct{}
    
    for i := range whatever {
        defer func() { 
            fmt.Println(i) 
        }()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2
2
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defer后面跟的是一个闭包（后面会讲到），i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2.&lt;/p&gt;
&lt;p&gt;有了上面的基础，我们来检验一下成果：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type number int

func (n number) print()   { fmt.Println(n) }
func (n *number) pprint() { fmt.Println(*n) }

func main() {
    var n number

    defer n.print()
    defer n.pprint()
    defer func() { n.print() }()
    defer func() { n.pprint() }()

    n = 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果是：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;3
3
3
0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四个defer语句是闭包，引用外部函数的n, 最终结果是3;&lt;br/&gt;第三个defer语句同第四个；&lt;br/&gt;第二个defer语句，n是引用，最终求值是3.&lt;br/&gt;第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0;&lt;/p&gt;
&lt;h2 id=&quot;利用defer原理&quot;&gt;利用defer原理&lt;/h2&gt;
&lt;p&gt;有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func mergeFile() error {
    f, _ := os.Open(&quot;file1.txt&quot;)
    if f != nil {
        defer func(f io.Closer) {
            if err := f.Close(); err != nil {
                fmt.Printf(&quot;defer close file1.txt err %v\n&quot;, err)
            }
        }(f)
    }

    // ……

    f, _ = os.Open(&quot;file2.txt&quot;)
    if f != nil {
        defer func(f io.Closer) {
            if err := f.Close(); err != nil {
                fmt.Printf(&quot;defer close file2.txt err %v\n&quot;, err)
            }
        }(f)
    }

    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中就用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，妙哉！可以想像一下如果不这样将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了，都是最后一个打开的文件。&lt;/p&gt;
&lt;p&gt;不过在调用close()函数的时候，要注意一点：先判断调用主体是否为空，否则会panic. 比如上面的代码片段里，先判断&lt;code&gt;f&lt;/code&gt;不为空，才会调用&lt;code&gt;Close()&lt;/code&gt;函数，这样最安全。&lt;/p&gt;
&lt;h2 id=&quot;defer命令的拆解&quot;&gt;defer命令的拆解&lt;/h2&gt;
&lt;p&gt;如果defer像上面介绍地那样简单（其实也不简单啦），这个世界就完美了。事情总是没这么简单，defer用得不好，是会跳进很多坑的。&lt;/p&gt;
&lt;p&gt;理解这些坑的关键是这条语句：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;return xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这条语句经过编译之后，变成了三条指令：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;1. 返回值 = xxx
2. 调用defer函数
3. 空的return&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1,3步才是Return 语句真正的命令，第2步是defer定义的语句，这里可能会操作返回值。&lt;/p&gt;
&lt;p&gt;下面我们来看两个例子，试着将return语句和defer语句拆解到正确的顺序。&lt;/p&gt;
&lt;p&gt;第一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     t := 5
     defer func() {
       t = t + 5
     }()
     return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拆解后：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     t := 5
     
     // 1. 赋值指令
     r = t
     
     // 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过
     func() {        
         t = t + 5
     }
     
     // 3. 空的return指令
     return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里第二步没有操作返回值r, 因此，main函数中调用f()得到5.&lt;/p&gt;
&lt;p&gt;第二个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
    defer func(r int) {
          r = r + 5
    }(r)
    return 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拆解后：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     // 1. 赋值
     r = 1
     
     // 2. 这里改的r是之前传值传进去的r，不会改变要返回的那个r值
     func(r int) { 
          r = r + 5
     }(r)
     
     // 3. 空的return
     return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，main函数中调用f()得到1.&lt;/p&gt;
&lt;h2 id=&quot;defer语句的参数&quot;&gt;defer语句的参数&lt;/h2&gt;
&lt;p&gt;defer语句表达式的值在定义时就已经确定了。下面展示三个函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f1() {
    var err error
    
    defer fmt.Println(err)

    err = errors.New(&quot;defer error&quot;)
    return
}

func f2() {
    var err error
    
    defer func() {
        fmt.Println(err)
    }()

    err = errors.New(&quot;defer error&quot;)
    return
}

func f3() {
    var err error
    
    defer func(err error) {
        fmt.Println(err)
    }(err)

    err = errors.New(&quot;defer error&quot;)
    return
}

func main() {
    f1()
    f2()
    f3()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;nil&amp;gt;
defer error
&amp;lt;nil&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1，3个函数是因为作为函数参数，定义的时候就会求值，定义的时候err变量的值都是nil, 所以最后打印的时候都是nil. 第2个函数的参数其实也是会在定义的时候求值，只不过，第2个例子中是一个闭包，它引用的变量err在执行的时候最终变成&lt;code&gt;defer error&lt;/code&gt;了。关于闭包在本文后面有介绍。&lt;/p&gt;
&lt;p&gt;第3个函数的错误还比较容易犯，在生产环境中，很容易写出这样的错误代码。最后defer语句没有起到作用。&lt;/p&gt;
&lt;h2 id=&quot;闭包是什么&quot;&gt;闭包是什么？&lt;/h2&gt;
&lt;p&gt;闭包是由函数及其相关引用环境组合而成的实体,即：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;闭包=函数+引用环境&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。&lt;/p&gt;
&lt;p&gt;有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var a = Accumulator()

    fmt.Printf(&quot;%d\n&quot;, a(1))
    fmt.Printf(&quot;%d\n&quot;, a(10))
    fmt.Printf(&quot;%d\n&quot;, a(100))

    fmt.Println(&quot;------------------------&quot;)
    var b = Accumulator()

    fmt.Printf(&quot;%d\n&quot;, b(1))
    fmt.Printf(&quot;%d\n&quot;, b(10))
    fmt.Printf(&quot;%d\n&quot;, b(100))


}

func Accumulator() func(int) int {
    var x int

    return func(delta int) int {
        fmt.Printf(&quot;(%+v, %+v) - &quot;, &amp;amp;x, x)
        x += delta
        return x
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;(0xc420014070, 0) - 1
(0xc420014070, 1) - 11
(0xc420014070, 11) - 111
------------------------
(0xc4200140b8, 0) - 1
(0xc4200140b8, 1) - 11
(0xc4200140b8, 11) - 111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。&lt;/p&gt;
&lt;h2 id=&quot;defer配合recover&quot;&gt;defer配合recover&lt;/h2&gt;
&lt;p&gt;Golang被诟病比较多的就是它的error, 经常是各种error满天飞。编程的时候总是会返回一个error, 留给调用者处理。如果是那种致命的错误，比如程序执行初始化的时候出问题，直接panic掉，省得上线运行后出更大的问题。&lt;/p&gt;
&lt;p&gt;但是有些时候，我们需要从异常中恢复。比如服务器程序遇到严重问题，产生了panic, 这时我们至少可以在程序崩溃前做一些“扫尾工作”，如关闭客户端的连接，防止客户端一直等待等等。&lt;/p&gt;
&lt;p&gt;panic会停掉当前正在执行的程序，不只是当前协程。在这之前，它会有序地执行完当前协程defer列表里的语句，其它协程里挂的defer语句不作保证。因此，我们经常在defer里挂一个recover语句，防止程序直接挂掉，这起到了&lt;code&gt;try...catch&lt;/code&gt;的效果。&lt;/p&gt;
&lt;p&gt;注意，recover()函数只在defer的上下文中才有效（且只有通过在defer中用匿名函数调用才有效），直接调用的话，只会返回&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    defer fmt.Println(&quot;defer main&quot;)
    var user = os.Getenv(&quot;USER_&quot;)
    
    go func() {
        defer func() {
            fmt.Println(&quot;defer caller&quot;)
            if err := recover(); err != nil {
                fmt.Println(&quot;recover success. err: &quot;, err)
            }
        }()

        func() {
            defer func() {
                fmt.Println(&quot;defer here&quot;)
            }()

            if user == &quot;&quot; {
                panic(&quot;should set user env.&quot;)
            }

            // 此处不会执行
            fmt.Println(&quot;after panic&quot;)
        }()
    }()

    time.Sleep(100)
    fmt.Println(&quot;end of main function&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的panic最终会被recover捕获到。这样的处理方式在一个http server的主流程常常会被用到。一次偶然的请求可能会触发某个bug, 这时用recover捕获panic, 稳住主流程，不影响其他请求。&lt;/p&gt;
&lt;p&gt;程序员通过监控获知此次panic的发生，按时间点定位到日志相应位置，找到发生panic的原因，三下五除二，修复上线。一看四周，大家都埋头干自己的事，简直完美：偷偷修复了一个bug, 没有发现！嘿嘿！&lt;/p&gt;

&lt;p&gt;defer非常好用，一般情况下不会有什么问题。但是只有深入理解了defer的原理才会避开它的温柔陷阱。掌握了它的原理后，就会写出易懂易维护的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【defer那些事】&lt;a href=&quot;https://xiaozhou.net/something-about-defer-2014-05-25.html&quot; class=&quot;uri&quot;&gt;https://xiaozhou.net/something-about-defer-2014-05-25.html&lt;/a&gt;&lt;br/&gt;【defer代码案例】&lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html&quot; class=&quot;uri&quot;&gt;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;https://www.kancloud.cn/liupengjie/go/576456&quot; class=&quot;uri&quot;&gt;https://www.kancloud.cn/liupengjie/go/576456&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;http://blog.51cto.com/speakingbaicai/1703229&quot; class=&quot;uri&quot;&gt;http://blog.51cto.com/speakingbaicai/1703229&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;https://blog.csdn.net/zhangzhebjut/article/details/25181151&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zhangzhebjut/article/details/25181151&lt;/a&gt;&lt;br/&gt;【延迟】&lt;a href=&quot;http://liyangliang.me/posts/2014/12/defer-in-golang/&quot; class=&quot;uri&quot;&gt;http://liyangliang.me/posts/2014/12/defer-in-golang/&lt;/a&gt;&lt;br/&gt;【defer三条原则】&lt;a href=&quot;https://leokongwq.github.io/2016/10/15/golang-defer.html&quot; class=&quot;uri&quot;&gt;https://leokongwq.github.io/2016/10/15/golang-defer.html&lt;/a&gt;&lt;br/&gt;【defer代码例子】&lt;a href=&quot;https://juejin.im/post/5b948b3e6fb9a05d3827beda&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5b948b3e6fb9a05d3827beda&lt;/a&gt;&lt;br/&gt;【defer panic】&lt;a href=&quot;https://ieevee.com/tech/2017/11/23/go-panic.html&quot; class=&quot;uri&quot;&gt;https://ieevee.com/tech/2017/11/23/go-panic.html&lt;/a&gt;&lt;br/&gt;【defer panic】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33743255&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/33743255&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:20:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>defer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。深受Go开发者的欢迎，但一不小心就会掉进它的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10367346.html</dc:identifier>
</item>
<item>
<title>C# Lambda表达式 - 阡陌染</title>
<link>http://www.cnblogs.com/forever-Ys/p/10344247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forever-Ys/p/10344247.html</guid>
<description>&lt;h2&gt;一、简介　　&lt;/h2&gt;
&lt;p&gt;　　Lambda表达式来源于数学家Alonzo Church等人在1920~1930期间发明的Lambad积分。Lambda积分是用于表示函数的一套系统，它使用希腊字母Lambda（ λ ）来表示无名函数。&lt;/p&gt;
&lt;p&gt;　　C# 3.0引入了Lambda表达式，它是一种简化的匿名函数，可用于创建委托或表达式目录树。你也可以将 Lambda 表达式作为参数进行传递，或者将它作用于函数调用值调用后返回的一个函数来使用。&lt;/p&gt;

&lt;h2&gt;二、基础&lt;/h2&gt;
&lt;p&gt;　　它的语法形式是： &lt;span&gt;&lt;span&gt;输入参数 =&amp;gt; 表达式或语句块&lt;/span&gt;　　&lt;span&gt;即运算符的左边是输入参数(如果有)，右边是表达式或语句块。 （ “ =&amp;gt; ” 读作 “ goes to ” ）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;　　2.1 表达式Lambda&lt;/h3&gt;
&lt;p&gt;　　      &lt;span id=&quot;mt20&quot; data-guid=&quot;a858e2d952158bf6851beccbb9fa2be6&quot; data-source=&quot;A lambda expression with an expression on the right side of the =&amp;amp;gt; operator is called an &amp;lt;span class=&amp;quot;parameter&amp;quot;&amp;gt;expression lambda.&quot;&gt;表达式位于 =&amp;gt; 运算符右侧的 lambda 表达式称为“表达式 lambda”。&lt;span id=&quot;mt20&quot; data-guid=&quot;a858e2d952158bf6851beccbb9fa2be6&quot; data-source=&quot;A lambda expression with an expression on the right side of the =&amp;amp;gt; operator is called an &amp;lt;span class=&amp;quot;parameter&amp;quot;&amp;gt;expression lambda.&quot;&gt;&lt;span id=&quot;mt21&quot; data-guid=&quot;7a917f4505a3fade6bfa2a6b684acc36&quot; data-source=&quot;Expression lambdas are used extensively in the construction of &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;Expression Trees (C# and Visual Basic).&quot;&gt; &lt;span id=&quot;mt22&quot; data-guid=&quot;e0853a0372a587eee38648f09324a192&quot; data-source=&quot;An expression lambda returns the result of the expression and takes the following basic form:&quot;&gt;&lt;span&gt;表达式 Lambda 会返回表达式的结果&lt;/span&gt;，并采用以下基本形式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;code-snippet-3&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;CodeSnippetContainerCode_15792d55-be25-4dc3-9100-9a9a6111fd13&quot; dir=&quot;ltr&quot; readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (input parameters) =&amp;gt; expression&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myDel(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            myDel del &lt;/span&gt;= (x,y) =&amp;gt;  x+&lt;span&gt;y;&lt;/span&gt;    &lt;span&gt;//返回x+y的结果&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,del(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出13&lt;/span&gt; &lt;span&gt; 　　　　　 Console.ReadKey(); &lt;br/&gt;　　　　　} &lt;br/&gt;　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有关Lambda表达式的参数列表要点如下：&lt;/p&gt;
&lt;p&gt;♥　Lambda表达式参数列表中的参数必须在参数数量、类型和位置上&lt;span&gt;与委托相匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;♥    表达式参数列表中的参数不一定需要包含类型（隐式类型），除非委托有ref或out参数----此时必须注明类型（显式类型）&lt;/p&gt;
&lt;p&gt;♥    如果只有一个参数，并且是隐式类型的，周围的圆括号可以被省略，否则必须有括号&lt;/p&gt;
&lt;p&gt;♥    &lt;span&gt;如果没有参数，必须使用一组空的圆括号&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;　　2.2  语句Lambda&lt;/h3&gt;
&lt;p&gt;　　　　当lambda表达式中，有多个语句时，写成如下形式：&lt;/p&gt;
&lt;p&gt;　　　　(input parameters) =&amp;gt; {  statement； }&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myDel(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str);

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            myDel del &lt;/span&gt;= (str) =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;
            };
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、运用&lt;/h2&gt;
&lt;p&gt;　　知道了Lamda的基本用法，下面看看怎么在LINQ和异步中使用它&lt;/p&gt;

&lt;h3&gt;　　3.1   LINQ查询中使用Lambda表达式参数的示例&lt;/h3&gt;
&lt;p&gt; 　　　引用MSDN中的例子。&lt;span data-ttu-id=&quot;ede37-107&quot;&gt;下面的示例演示如何通过 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.where&quot; data-linktype=&quot;absolute-path&quot;&gt;Enumerable.Where&lt;/a&gt; 标准查询运算符，在基于方法的查询中使用 lambda 表达式。 &lt;span data-ttu-id=&quot;ede37-108&quot;&gt;请注意，此示例中的 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.where&quot; data-linktype=&quot;absolute-path&quot;&gt;Where&lt;/a&gt; 方法具有一个 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.func-1&quot; data-linktype=&quot;absolute-path&quot;&gt;Func&amp;lt;TResult&amp;gt;&lt;/a&gt; 委托类型的输入参数，该委托采用整数作为输入并返回一个布尔值。 &lt;span data-ttu-id=&quot;ede37-109&quot;&gt;Lambda 表达式可以转换为该委托。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleLambda
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Data source.&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] scores = { &lt;span&gt;90&lt;/span&gt;, &lt;span&gt;71&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;, &lt;span&gt;93&lt;/span&gt;, &lt;span&gt;75&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;&lt;span&gt; };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The call to Count forces iteration of the source&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; highScoreCount = scores.Where(n =&amp;gt; n &amp;gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;).Count();

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} scores are greater than 80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, highScoreCount);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Outputs: 4 scores are greater than 80            &lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　3.2   使用异步Lambda表达式&lt;/h3&gt;
&lt;p&gt; 　　&lt;span data-ttu-id=&quot;666f1-144&quot;&gt;你可以使用异步 lambda 添加事件处理程序。 &lt;span data-ttu-id=&quot;666f1-145&quot;&gt;若要添加此处理程序，请在 lambda 参数列表前添加一个 &lt;code&gt;async&lt;/code&gt; 修饰符，如下例，lambda表达式被注册为一个按钮点击事件的事件处理程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()  
    {  
        InitializeComponent();  
        button1.Click &lt;/span&gt;+= &lt;span&gt;async&lt;/span&gt; (sender, e) =&amp;gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步Lambda表达式&lt;/span&gt;
&lt;span&gt;        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ExampleMethodAsync returns a Task.  &lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ExampleMethodAsync();  
            textBox1.Text &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nControl returned to Click event handler.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;  
        };  
    }  
  
    &lt;/span&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ExampleMethodAsync()  
    {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The following line simulates a task-returning asynchronous process.  &lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有关异步和LINQ的知识，可以参阅我以前写过的博客&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 14:02:00 +0000</pubDate>
<dc:creator>阡陌染</dc:creator>
<og:description>一、简介 Lambda表达式来源于数学家Alonzo Church等人在1920~1930期间发明的Lambad积分。Lambda积分是用于表示函数的一套系统，它使用希腊字母Lambda（ λ ）来表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forever-Ys/p/10344247.html</dc:identifier>
</item>
<item>
<title>ML.NET 0.10特性简介 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10367137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10367137.html</guid>
<description>&lt;p&gt;IDataView组件为表格式数据提供了非常高效的处理方式，尤其是用于机器学习和高级分析应用。它被设计为可以高效地处理高维数据和大型数据集。并且也适合处理属于更大的分布式数据集中的单个数据区块结点。&lt;/p&gt;
&lt;p&gt;在ML.NET 0.10中，IDataView被拆分成单个程序集和NuGet类库包。这对于与其它API及框架交互是极重要的一步。&lt;/p&gt;
&lt;p&gt;在被拆分后，其它的类库将能直接引用它，而不需要引用整个ML.NET。这样有助于第三方类库也能使用IDataView所提供的强大功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212205901864-1632817045.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在之前的ML.NET版本中，当使用场感知分解机(FFM)训练器时，仅可以提供单个特征列。&lt;/p&gt;
&lt;p&gt;在新的版本里，支持在Options参数里添加额外的特征列。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var ffmArgs = new FieldAwareFactorizationMachineTrainer.Options();

// Create the multiple field names.
ffmArgs.FeatureColumn = nameof(MyObservationClass.MyField1); // 首个字段
ffmArgs.ExtraFeatureColumns = new[]{ nameof(MyObservationClass.MyField2), nameof(MyObservationClass.MyField3) }; // 额外的字段

var pipeline = mlContext.BinaryClassification.Trainers.FieldAwareFactorizationMachine(ffmArgs);

var model = pipeline.Fit(dataView);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前的版本里，即使预测多类别分类问题，也只能返回单一的标签。&lt;/p&gt;
&lt;p&gt;现在，这一缺陷终于被修复了。(其实在内部逻辑里已经对多项预测完成处理，但过去的API只返回了单一的结果)&lt;/p&gt;

&lt;p&gt;作为ML.NET Samples的一部分，现在新增了一个特殊&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/blob/master/docs/COMMUNITY-SAMPLES.md&quot;&gt;页面&lt;/a&gt;——由社区提供的多个示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211755135-1044449696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有不少很好的例子：&lt;/p&gt;
&lt;p&gt;照片查询的WPF应用，其内部运行TensorFlow模型，并导出为ONNX格式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211806011-1669319724.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ML.NET的UWP应用：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211817479-517026897.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，欢迎有越来越多的贡献者加入其中，提供更多的示例。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 13:26:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>IDataView被单独作为一个类库包 IDataView组件为表格式数据提供了非常高效的处理方式，尤其是用于机器学习和高级分析应用。它被设计为可以高效地处理高维数据和大型数据集。并且也适合处理属于更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10367137.html</dc:identifier>
</item>
<item>
<title>JDK源码分析（9）之 WeakHashMap 相关 - 三枣</title>
<link>http://www.cnblogs.com/sanzao/p/10367123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanzao/p/10367123.html</guid>
<description>&lt;p&gt;平时我们使用最多的数据结构肯定是 HashMap，但是在使用的时候我们必须知道每个键值对的生命周期，并且手动清除它；但是如果我们不是很清楚它的生命周期，这时候就比较麻烦；通常有这样几种处理方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由一个线程定时处理，可以是&lt;code&gt;Timer&lt;/code&gt;或者&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;利用重写&lt;code&gt;LinkedHashMap.removeEldestEntry()&lt;/code&gt;，实现 FIFOCache 或者 LRUCache；可以参考我之前写的一篇博客 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10297220.html&quot;&gt;LinkedHashMap 相关&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;WeakHashMap&lt;/code&gt; 的特性，如果逻辑比较复杂还可以直接使用&lt;code&gt;Reference&lt;/code&gt;；这里可以参考 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10343166.html&quot;&gt;Reference 完全解读&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10337291.html&quot;&gt;Reference 框架概览&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以本文将主要介绍&lt;code&gt;WeakHashMap&lt;/code&gt;的特性，以及补充一些关于 HashMap 实现的对比；相关 HashMap 的介绍也可以参考 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10245212.html&quot;&gt;HashMap 相关&lt;/a&gt;；&lt;/p&gt;
&lt;h2 id=&quot;一使用场景&quot;&gt;一、使用场景&lt;/h2&gt;
&lt;p&gt;上面也介绍了，&lt;code&gt;WeakHashMap&lt;/code&gt;适用于不是非常重要的缓存类似的场景；例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;WeakHashMap&amp;lt;Object, Integer&amp;gt; map = new WeakHashMap&amp;lt;&amp;gt;();

for (int i = 0; i &amp;lt; 100; i++) {
  map.put(new Object(), i);
}

System.out.println(map.size());  // 1
System.gc();                     // 2
System.out.println(map.size());  // 3
System.out.println(map.size());  // 4
System.out.println(map.size());  // 5
System.out.println(map);         // 6
System.out.println(map.size());  // 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 打印：&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;46&lt;br/&gt;{}&lt;br/&gt;0&lt;/p&gt;
&lt;p&gt;对于以上的结果你可能和我打印的不一样，&lt;code&gt;WeakHashMap&lt;/code&gt;按照语义应该是，当 key 没有强引用指向的时候，会自动清除 key 和 value；我这里先解释它的释放过程，如果你觉得很清晰，那&lt;code&gt;WeakHashMap&lt;/code&gt;你就算是掌握了；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先 for 循环结束的时候，key 已经没用强引用指向了，此时所有的 key 都是弱引用了；&lt;/li&gt;
&lt;li&gt;接下来执行1，因为我这里只有一个方法，新生代还有足够的空间，所以不会触发 GC，所以所有的 key 任然在堆里面，所以打印100；&lt;/li&gt;
&lt;li&gt;然后手动触发 GC，虽然&lt;code&gt;System.gc();&lt;/code&gt;不一定会立即执行，但是我这里只有一个方法，所以肯定会执行 GC，这里可以打开 GC 日志查看，&lt;code&gt;-verbose:gc&lt;/code&gt;；因为 所有的 key 都是弱引用，所以&lt;code&gt;referent&lt;/code&gt;被致为 null，同时将 key 注册到 &lt;code&gt;ReferenceQueue&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;在执行 3-7 的时候，按语义 map 应该为空；但是将 key 注册到 &lt;code&gt;ReferenceQueue&lt;/code&gt;并非原子性一次完成的，所以这里会打印不同的值，每注册完成一个，在 map 进行操作的时候，就会将其移除；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上面的代码改成多线程分析思路也是一样的，如果你觉得有不清楚的地方可以查看下文；&lt;/p&gt;
&lt;h2 id=&quot;二weakhashmap-源码分析&quot;&gt;二、WeakHashMap 源码分析&lt;/h2&gt;
&lt;h3 id=&quot;类定义&quot;&gt;1. 类定义&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeakHashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到虽然&lt;code&gt;WeakHashMap&lt;/code&gt;也是基于哈希表，但是却并非像&lt;code&gt;LinkedHashMap&lt;/code&gt;一样是继承于&lt;code&gt;HashMap&lt;/code&gt;，并且&lt;code&gt;WeakHashMap&lt;/code&gt;也没有实现&lt;code&gt;Cloneable, Serializable&lt;/code&gt;两个接口，这是因为&lt;code&gt;WeakHashMap&lt;/code&gt;基于&lt;code&gt;WeakReference&lt;/code&gt;实现的，弱引用并不建议实现序列化，同时弱引用一般用于不是很重要的缓存，也就没必要实现&lt;code&gt;Cloneable, Serializable&lt;/code&gt;两个接口了；&lt;/p&gt;
&lt;h3 id=&quot;核心方法&quot;&gt;2. 核心方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final ReferenceQueue&amp;lt;Object&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();

private static class Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
  V value;
  final int hash;
  Entry&amp;lt;K,V&amp;gt; next;

  Entry(Object key, V value, ReferenceQueue&amp;lt;Object&amp;gt; queue, int hash, Entry&amp;lt;K,V&amp;gt; next) {
    super(key, queue);
    this.value = value;
    this.hash  = hash;
    this.next  = next;
  }

  public K getKey() { }
  public V getValue() {
  public V setValue(V newValue) {
  public int hashCode() {
  public String toString() {
}

private void expungeStaleEntries() {
  for (Object x; (x = queue.poll()) != null; ) {
    synchronized (queue) {
      @SuppressWarnings(&quot;unchecked&quot;)
        Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) x;
      int i = indexFor(e.hash, table.length);

      Entry&amp;lt;K,V&amp;gt; prev = table[i];
      Entry&amp;lt;K,V&amp;gt; p = prev;
      while (p != null) {
        Entry&amp;lt;K,V&amp;gt; next = p.next;
        if (p == e) {
          if (prev == e)
            table[i] = next;
          else
            prev.next = next;
          // Must not null out e.next;
          // stale entries may be in use by a HashIterator
          e.value = null; // Help GC
          size--;
          break;
        }
        prev = p;
        p = next;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码所列的&lt;code&gt;ReferenceQueue，Entry，expungeStaleEntries()&lt;/code&gt;就是&lt;code&gt;WeakHashMap&lt;/code&gt;实现的核心了；这里强烈建议要先看 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10343166.html&quot;&gt;Reference 完全解读&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10337291.html&quot;&gt;Reference 框架概览&lt;/a&gt; 这两篇博客，里面同样的内容我也不会再赘述了；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt;&lt;/code&gt;， 表明所有的节点都是&lt;code&gt;WeakReference&lt;/code&gt;，而 key 则是 referent；&lt;/li&gt;
&lt;li&gt;queue，所有 key 使用同一个&lt;code&gt;ReferenceQueue&lt;/code&gt;监听器，每当 key 被回收的时候，entry 将会被注册到&lt;code&gt;ReferenceQueue&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;expungeStaleEntries，将注册到&lt;code&gt;ReferenceQueue&lt;/code&gt;中的 entry 移除，并将 value 置为 null；&lt;code&gt;WeakHashMap&lt;/code&gt;的所有操作都先执行&lt;code&gt;expungeStaleEntries&lt;/code&gt;，这样&lt;code&gt;WeakHashMap&lt;/code&gt;就实现了自动回收不在需要的 key 和 value；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三性能对比&quot;&gt;三、性能对比&lt;/h2&gt;
&lt;p&gt;其实上面的内容就已经将&lt;code&gt;WeakHashMap&lt;/code&gt;的主要实现讲完了，但是我之前在看&lt;code&gt;HashMap&lt;/code&gt;源码的时候，并没有对比 JDK1.7 和 JDK1.8，但是在这里发现其实&lt;code&gt;WeakHashMap&lt;/code&gt;的实现和 JDK1.7 差不多，所以接下来我将主要对比一下&lt;code&gt;WeakHashMap&lt;/code&gt;和&lt;code&gt;HashMap&lt;/code&gt;；&lt;/p&gt;
&lt;h3 id=&quot;容量计算&quot;&gt;1. 容量计算&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;WeakHashMap&lt;/code&gt;和&lt;code&gt;HashMap&lt;/code&gt;中都要求容量是2的幂，因为当容量为2的幂时，使用除留余数法计算哈希桶位置时可以使用&lt;code&gt;hash % length = hash &amp;amp; (length-1)&lt;/code&gt;的性质进行优化；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// WeakHashMap
int capacity = 1;
while (capacity &amp;lt; initialCapacity)
  capacity &amp;lt;&amp;lt;= 1;

// HashMap
static final int tableSizeFor(int cap) {
  int n = cap - 1;
  n |= n &amp;gt;&amp;gt;&amp;gt; 1;
  n |= n &amp;gt;&amp;gt;&amp;gt; 2;
  n |= n &amp;gt;&amp;gt;&amp;gt; 4;
  n |= n &amp;gt;&amp;gt;&amp;gt; 8;
  n |= n &amp;gt;&amp;gt;&amp;gt; 16;
  return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单测试可以得到：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;WeakHashMap&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;代码比较简单我就不贴了，从上表也可以看到了&lt;code&gt;tableSizeFor&lt;/code&gt;不仅高效而且稳定；&lt;/p&gt;
&lt;h3 id=&quot;哈希计算&quot;&gt;2. 哈希计算&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// WeakHashMap
final int hash(Object k) {
  int h = k.hashCode();
  h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
  return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}

// HashMap
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种hash算法都是要避免极端的&lt;code&gt;hashCode()&lt;/code&gt;，但是&lt;code&gt;HashMap&lt;/code&gt;却更为透彻，因为影响哈希桶位置的只有 hash 的低位（容量2的n次方，n个低位），直接将高位与上低位，使高位 hash 参与位置计算，简洁且高效；&lt;/p&gt;
&lt;p&gt;此外还有&lt;code&gt;put&lt;/code&gt;方法，但是里面还牵涉红黑树，对于本文就扯得有点远了，所以暂不讲；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WeakHashMap&lt;/code&gt;是&lt;code&gt;WeakReference&lt;/code&gt;的典型应用，在灵活应用&lt;code&gt;WeakHashMap&lt;/code&gt;之后，如果有更为复杂的逻辑，可以直接使用&lt;code&gt;Reference&lt;/code&gt;实现；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 12 Feb 2019 13:14:00 +0000</pubDate>
<dc:creator>三枣</dc:creator>
<og:description>平时我们使用最多的数据结构肯定是 HashMap，但是在使用的时候我们必须知道每个键值对的生命周期，并且手动清除它；但是如果我们不是很清楚它的生命周期，这时候就比较麻烦；通常有这样几种处理方式： 由一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanzao/p/10367123.html</dc:identifier>
</item>
<item>
<title>自制简单的诗歌搜索系统 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10367113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10367113.html</guid>
<description>&lt;h3 id=&quot;项目简介&quot;&gt;项目简介&lt;/h3&gt;
&lt;p&gt;  本文将介绍一个笔者自己的项目：自制简单的诗歌搜索系统。该系统主要的实现功能如下：指定一个关键词，检索出包含这个关键词的诗歌，比如关键词为“白云”，则检索出的诗歌可以为王维的《送别》，内容为“下马饮君酒，问君何所之？君言不得意，归卧南山陲。但去莫复问，白云无尽时。”&lt;br/&gt;  该项目使用的Python模块为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;BeautifulSoup&lt;/li&gt;
&lt;li&gt;pymongo&lt;/li&gt;
&lt;li&gt;tornado&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，requests模块和BeautifulSoup模块用来制作爬虫，爬取网上的诗歌。pymongo模块用来将爬取的诗歌写入到MongoDB数据库。tornado模块用于网页端展示。&lt;br/&gt;  该项目主要分以下三步实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收集数据：使用爬虫，爬取网上的诗歌作为项目的数据集；&lt;/li&gt;
&lt;li&gt;存入数据库：将爬取到的诗歌写入到MongoDB数据库；&lt;/li&gt;
&lt;li&gt;网页展示：利用tornado框架实现诗歌搜索功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该项目的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-afaa1770637eb0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;poem_search项目结构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据收集&quot;&gt;数据收集&lt;/h3&gt;
&lt;p&gt;  首先，我们利用Python爬虫来爬取诗歌，存为CSV文件poem.csv。爬取的网址为：&lt;a href=&quot;https://www.gushiwen.org/&quot;&gt;https://www.gushiwen.org&lt;/a&gt; 。由于仅是展示该项目的思路，因此，只爬取了该页面中的唐诗三百首、古诗三百、宋词三百、宋词精选，一共大约1100多首诗歌。&lt;br/&gt;  实现该爬虫的代码文件为poem_scrape.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import re
import requests
from bs4 import BeautifulSoup
import pandas as pd

# 爬取的诗歌网址
urls = ['https://www.gushiwen.org/gushi/tangshi.aspx',
        'https://www.gushiwen.org/gushi/sanbai.aspx',
        'https://www.gushiwen.org/gushi/songsan.aspx',
        'https://www.gushiwen.org/gushi/songci.aspx'
        ]

poem_links = []
# 诗歌的网址
for url in urls:
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)

    soup = BeautifulSoup(req.text, &quot;lxml&quot;)
    content = soup.find_all('div', class_=&quot;sons&quot;)[0]
    links = content.find_all('a')

    for link in links:
        poem_links.append(link['href'])

# print(poem_links)
# print(len(poem_links))

content_list = []
title_list = []
dynasty_list = []
poet_list = []

# 爬取诗歌页面
def get_poem(url):
    #url = 'https://so.gushiwen.org/shiwenv_45c396367f59.aspx'
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)
    soup = BeautifulSoup(req.text, &quot;lxml&quot;)

    # 诗歌内容
    poem = soup.find('div', class_='contson').text.strip()
    poem = poem.replace(' ', '')
    poem = re.sub(re.compile(r&quot;\([\s\S]*?\)&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;（[\s\S]*?）&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;。\([\s\S]*?）&quot;), '', poem)
    poem = poem.replace('!', '！').replace('?', '？').replace('\n', '')
    content = poem

    if content:
        content_list.append(content)
    else:
        content_list.append('')

    # 诗歌朝代，诗人
    dynasty_poet = soup.find('p', class_='source').text
    if '：' in dynasty_poet:
        dynasty, poet = dynasty_poet.split('：')
    else:
        dynasty, poet = '', ''

    dynasty_list.append(dynasty)
    poet_list.append(poet)

    # 诗歌标题
    title = soup.find('h1').text
    if title:
        title_list.append(title)
    else:
        title_list.append('')

# 爬取诗歌
for url in poem_links:
    get_poem(url)

# 写入至csv文件
df = pd.DataFrame({'title': title_list,
                   'dynasty': dynasty_list,
                   'poet': poet_list,
                   'content': content_list
                   })
print(df.head())

df.to_csv('./poem.csv', index=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;储存的poem.csv的前几行如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-3b0329016475f4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;poem.csv文件&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;p&gt;  数据收集完毕后，我们需要将这些数据出访到数据库中，便于后续的调用，在这里选择MongoDB。利用文件write2mongodb.py文件可以将刚才爬取到的诗歌存放至MongoDB数据库中，完整的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
from pymongo import MongoClient

# 连接MongoDB
conn = MongoClient('mongodb://localhost:27017/')
db = conn[&quot;test&quot;]

# 插入诗歌
df = pd.read_csv('poem.csv')
columns = ['title', 'dynasty', 'poet', 'content']
for i in range(df.shape[0]):
    print(i)
    row = df.iloc[i, :]
    db.poem.insert(dict(zip(columns, row[columns])))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  不到一分钟，我们可以看到MongoDB中的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-c8bcb306580ba479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mongodb数据&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前端展示&quot;&gt;前端展示&lt;/h3&gt;
&lt;p&gt;  准备好数据集后，我们需要可视化地展示诗歌检索功能，我们选择tornado这个框架来实现。诗歌检索功能为：指定一个关键词，检索出包含这个关键词的诗歌。关键词由用户输入，提交HTTP请求，在后台实现诗歌检索功能，然后在前端页面展示出来。&lt;br/&gt;  实现的server.py的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import random
import os.path
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
from tornado.options import define, options
from pymongo import MongoClient

# 连接MongoDB
conn = MongoClient('mongodb://localhost:27017/')
coll = conn[&quot;test&quot;].poem

#定义端口为8000
define(&quot;port&quot;, default=8000, help=&quot;run on the given port&quot;, type=int)

# GET请求
class QueryHandler(tornado.web.RequestHandler):
    # get函数
    def get(self):
        self.render('query.html')

# POST请求
# POST请求参数：query_string
class ResultHandler(tornado.web.RequestHandler):
    # post函数
    def post(self):
        query = self.get_argument('query_string')
        res = list(coll.find({'content': {'$regex': query}}))

        if len(res) &amp;gt; 0:
            result = random.sample(res, 1)[0]
            del result[&quot;_id&quot;]
            title = result['title']
            dynasty = result['dynasty']
            poet = result['poet']
            content = result['content']
        else:
            title = ''
            dynasty = ''
            poet = ''
            content = ''

        self.render('result.html', query=query, title=title, dynasty=dynasty, poet=poet, content=content)

# 主函数
def main():
    tornado.options.parse_command_line()
    # 定义app
    app = tornado.web.Application(
            handlers=[(r'/query', QueryHandler), (r'/result', ResultHandler)], #网页路径控制
            template_path=os.path.join(os.path.dirname(__file__), &quot;templates&quot;) # 模板路径
          )
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，query路径对应的网页query.html的代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Poem Query&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;请输入查询&amp;lt;/h2&amp;gt;
&amp;lt;form method=&quot;post&quot; action=&quot;/result&quot;&amp;gt;
&amp;lt;p&amp;gt;包含文字: &amp;lt;input type=&quot;text&quot; name=&quot;query_string&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;result路径对应的网页result.html如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Result&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
    //highlight query word in the page
    function Func(){
        var query = document.getElementById(&quot;query&quot;).innerHTML;
        query = query.split('：')[1];
        if(query == ''){alert('查询词为空!')}
        else{
            document.getElementById(&quot;result&quot;).innerHTML = document.getElementById(&quot;result&quot;).innerHTML.replace(new RegExp(query,'g'),'&amp;lt;mark&amp;gt;'+query+'&amp;lt;/mark&amp;gt;');
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;font color=&quot;red&quot;&amp;gt;&amp;lt;p id=&quot;query&quot;&amp;gt;查询词：{{query}}&amp;lt;/p&amp;gt;&amp;lt;/font&amp;gt;
&amp;lt;p&amp;gt;标题：{{title}}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;朝代：{{dynasty}}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;诗人：{{poet}}&amp;lt;/p&amp;gt;
&amp;lt;p id=&quot;result&quot;&amp;gt;内容：{{content}}&amp;lt;/p&amp;gt;
&amp;lt;a href=&quot;/query&quot;&amp;gt;&amp;lt;button type=&quot;button&quot;&amp;gt;返回&amp;lt;/button&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;button type=&quot;button&quot; onclick=&quot;Func()&quot;&amp;gt;查询词高亮&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;
&lt;p&gt;  运行server.py, 在浏览器中输入网址：&lt;a href=&quot;http://localhost:8000/query&quot; class=&quot;uri&quot;&gt;http://localhost:8000/query&lt;/a&gt; ，界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-f485b09461d3d6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;诗歌搜索界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在其中输入搜索关键词，比如“白云”，则会显示一条随机的结果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-420f5651f645b917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;诗歌搜索结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“查询词高亮”，则查询词部分会高亮显示。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  本项目仅为展示诗歌检索的一种实现思路，仍有许多功能还待完善，后续将进一步补充实现。本项目的github地址为：&lt;a href=&quot;https://github.com/percent4/Poem-Search&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/Poem-Search&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 13:09:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>自制简单的诗歌搜索系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10367113.html</dc:identifier>
</item>
<item>
<title>一行js代码识别Selenium+Webdriver及其应对方案 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/hide-webdriver.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/hide-webdriver.html</guid>
<description>&lt;p&gt;有不少朋友在开发爬虫的过程中喜欢使用Selenium + Chromedriver，以为这样就能做到不被网站的反爬虫机制发现。&lt;/p&gt;
&lt;p&gt;先不说淘宝这种基于用户行为的反爬虫策略，仅仅是一个普通的小网站，使用一行Javascript代码，就能轻轻松松识别你是否使用了Selenium + Chromedriver模拟浏览器。&lt;/p&gt;
&lt;p&gt;我们来看一个例子。&lt;/p&gt;
&lt;p&gt;使用下面这一段代码启动Chrome窗口：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium.webdriver import Chrome

driver = Chrome()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，在这个窗口中打开开发者工具，并定位到Console选项卡，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499558287238.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，在这个窗口输入如下的js代码并按下回车键：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;window.navigator.webdriver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，开发者工具返回了&lt;code&gt;true&lt;/code&gt;。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499559010932.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，如果你打开一个普通的Chrome窗口，执行相同的命令，可以发现这行代码的返回值为&lt;code&gt;undefined&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499560533146.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，如果网站通过js代码获取这个参数，返回值为&lt;code&gt;undefined&lt;/code&gt;说明是正常的浏览器，返回&lt;code&gt;true&lt;/code&gt;说明用的是Selenium模拟浏览器。一抓一个准。这里给出一个检测Selenium的js代码例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;webdriver = window.navigator.webdriver;
if(webdriver){
    console.log('你这个傻逼你以为使用Selenium模拟浏览器就可以了？')
} else {
    console.log('正常浏览器')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网站只要在页面加载的时候运行这个js代码，就可以识别访问者是不是用的Selenium模拟浏览器。如果是，就禁止访问或者触发其他反爬虫的机制。&lt;/p&gt;
&lt;p&gt;那么对于这种情况，在爬虫开发的过程中如何防止这个参数告诉网站你在模拟浏览器呢？&lt;/p&gt;
&lt;p&gt;可能有一些会js的朋友觉得可以通过覆盖这个参数从而隐藏自己，但实际上这个值是不能被覆盖的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499566165239.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对js更精通的朋友，可能会使用下面这一段代码来实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Object.defineProperties(navigator, {webdriver:{get:()=&amp;gt;undefined}});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499575706517.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实修改成功了。这种写法就万无一失了吗？并不是这样的，如果此时你在模拟浏览器中通过点击链接、输入网址进入另一个页面，或者开启新的窗口，你会发现，&lt;code&gt;window.navigator.webdriver&lt;/code&gt;又变成了&lt;code&gt;true&lt;/code&gt;。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499577743175.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么是不是可以在每一个页面都打开以后，再次通过webdriver执行上面的js代码，从而实现在每个页面都把&lt;code&gt;window.navigator.webdriver&lt;/code&gt;设置为&lt;code&gt;undefined&lt;/code&gt;呢？也不行。&lt;/p&gt;
&lt;p&gt;因为当你执行：&lt;code&gt;driver.get(网址)&lt;/code&gt;的时候，浏览器会打开网站，加载页面并运行网站自带的js代码。所以在你重设&lt;code&gt;window.navigator.webdriver&lt;/code&gt;之前，实际上网站早就已经知道你是模拟浏览器了。&lt;/p&gt;
&lt;p&gt;接下来，又有朋友提出，可以通过编写Chrome插件来解决这个问题，让插件里面的js代码在网站自带的所有js代码之前执行。&lt;/p&gt;
&lt;p&gt;这样做当然可以，不过有更简单的办法，只需要设置Chromedriver的启动参数即可解决问题。&lt;/p&gt;
&lt;p&gt;在启动Chromedriver之前，为Chrome开启实验性功能参数&lt;code&gt;excludeSwitches&lt;/code&gt;，它的值为&lt;code&gt;['enable-automation']&lt;/code&gt;，完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium.webdriver import Chrome
from selenium.webdriver import ChromeOptions

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])
driver = Chrome(options=option)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时启动的Chrome窗口，在右上角会弹出一个提示，不用管它，不要点击&lt;code&gt;停用&lt;/code&gt;按钮。&lt;/p&gt;
&lt;p&gt;再次在开发者工具的Console选项卡中查询&lt;code&gt;window.navigator.webdriver&lt;/code&gt;，可以发现这个值已经自动变成&lt;code&gt;undefined&lt;/code&gt;了。并且无论你打开新的网页，开启新的窗口还是点击链接进入其他页面，都不会让它变成&lt;code&gt;true&lt;/code&gt;。运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499583523223.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;截至2019年02月12日20:46分，本文所讲的方法可以用来登录知乎。如果使用 Selenium 直接登录知乎，会弹出验证码；先使用本文的方法再登录知乎，能够成功伪装成真实的浏览器，不会弹出验证码。&lt;/p&gt;
&lt;p&gt;实际上，Selenium+Chromedriver还有很多个特征可以被网站发现，如何隐藏其他特征？请扫描下面的二维码，关注我的微信公众号。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 12:55:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<og:description>写爬虫并不是使用Selenium + webdriver就万事大吉了。一行js代码就能识别Selenium+webdriver。本文给出了应对方案。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/hide-webdriver.html</dc:identifier>
</item>
</channel>
</rss>