<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Visual Studio Online 的 FAQ：iPad 支持、自托管环境、Web 版 VS Code、Azure 账号等 - formulahendry</title>
<link>http://www.cnblogs.com/formulahendry/p/11828836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/formulahendry/p/11828836.html</guid>
<description>&lt;p&gt;北京时间 2019 年 11 月 4 日，在 Microsoft Ignite 2019 大会上，&lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/90094288&quot; data-za-detail-view-id=&quot;1043&quot;&gt;微软正式发布了 Visual Studio Online 公开预览版&lt;/a&gt;！发布之后，开发者们都为之振奋。同时，许多童鞋也纷纷询问各种与 Visual Studio Online 相关的问题。于是，韩老师就决定写一篇 FAQ，来统一回答一下大家的疑问~&lt;/p&gt;
&lt;h2&gt;iPad 支持&lt;/h2&gt;
&lt;p&gt;目前，Web 版 VS Code 只支持基于 Chromium 的浏览器，还不支持 iPad 上的浏览器。但对于 Safari 的支持，是 Visual Studio Online 团队的一件高优先级的任务。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-7be9a0cf9e54ed37e38295ca1cf335dc_hd.jpg&quot; alt=&quot;&quot; width=&quot;1611&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1611&quot; data-rawheight=&quot;764&quot; data-original=&quot;https://pic1.zhimg.com/v2-7be9a0cf9e54ed37e38295ca1cf335dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7be9a0cf9e54ed37e38295ca1cf335dc_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多详情，可以关注 &lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MicrosoftDocs/vsonline/issues/108&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;github.com/MicrosoftDoc&lt;span class=&quot;invisible&quot;&gt;s/vsonline/issues/108&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相信过不了多久，就能在 iPad 上玩 VS Code 啦！iPad 可以准备起来了！&lt;/p&gt;
&lt;h2&gt;自托管环境&lt;/h2&gt;
&lt;p&gt;自托管环境的搭建已经在官方文档中说明了： &lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.microsoft.com/visualstudio/online/how-to/vscode%23self-hosted&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;docs.microsoft.com/visu&lt;span class=&quot;invisible&quot;&gt;alstudio/online/how-to/vscode#self-hosted&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤其实很简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在要作为自托管环境的机器上安装 VS Code&lt;/li&gt;
&lt;li&gt;安装 &lt;a class=&quot; wrap external&quot; href=&quot;https://marketplace.visualstudio.com/items?itemName=MS-vsonline.vsonline&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;Visual Studio Online 插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;a class=&quot; wrap external&quot; href=&quot;https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;command palette&lt;/a&gt; 中调用 VS Online: Register Local Environment 命令&lt;/li&gt;
&lt;li&gt;完成注册后，你就可以在 VS Code 或者 Web 版 VS Code 中看到 self-hosted environments 并进行连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本地版 VS Code 查看自托管环境：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-3e56612f166d37f4622d0839c606d6c3_hd.jpg&quot; alt=&quot;&quot; width=&quot;610&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;610&quot; data-rawheight=&quot;328&quot; data-original=&quot;https://pic4.zhimg.com/v2-3e56612f166d37f4622d0839c606d6c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3e56612f166d37f4622d0839c606d6c3_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Web 版 VS Code 查看自托管环境：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-41ad829eb253c564ed1f26183bad76b8_hd.jpg&quot; alt=&quot;&quot; width=&quot;2626&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2626&quot; data-rawheight=&quot;790&quot; data-original=&quot;https://pic1.zhimg.com/v2-41ad829eb253c564ed1f26183bad76b8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-41ad829eb253c564ed1f26183bad76b8_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;自建 Web 版 VS Code&lt;/h2&gt;
&lt;p&gt;在 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/90360705&quot; data-za-detail-view-id=&quot;1043&quot;&gt;VS Code 1.40 的发布&lt;/a&gt;中已经说明，可以通过运行 yarn web，自建 Web 版 VS Code，在 &lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//localhost%3A8080/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;span class=&quot;visible&quot;&gt;localhost:8080/&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 访问。如果之前没有在本地构建过，&lt;a class=&quot; wrap external&quot; href=&quot;https://github.com/microsoft/vscode/wiki/How-to-Contribute&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;需要在本地先构建 VS Code&lt;/a&gt;，然后再运行 yarn web。&lt;/p&gt;
&lt;h2&gt;Azure 账号&lt;/h2&gt;
&lt;p&gt;使用 Visual Studio Online 的确是要用国际版的 Azure，需要信用卡进行注册。不过学生朋友就有福啦~ 对于学生，Azure 有免费额度，不需要信用卡注册，只需有效的 edu 邮箱即可。&lt;a href=&quot;https://azure.microsoft.com/zh-cn/free/students/%20&quot; target=&quot;_blank&quot;&gt;https://azure.microsoft.com/zh-cn/free/students/ &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;LinkCard LinkCard--hasImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//azure.microsoft.com/zh-cn/free/students/&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-4a04df31761de2255c6e1ae9785fc442_ipico.jpg&quot; data-image-width=&quot;250&quot; data-image-height=&quot;250&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多最新的 VS Code 热门文章、使用技巧、插件推荐、插件开发攻略等，请关注“玩转VS Code”公众号！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-d5fe6c174c4bb4cadab0096617b62250_hd.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;258&quot; data-rawheight=&quot;258&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d5fe6c174c4bb4cadab0096617b62250_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 23:41:00 +0000</pubDate>
<dc:creator>formulahendry</dc:creator>
<og:description>北京时间 2019 年 11 月 4 日，在 Microsoft Ignite 2019 大会上，微软正式发布了 Visual Studio Online 公开预览版！发布之后，开发者们都为之振奋。同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/formulahendry/p/11828836.html</dc:identifier>
</item>
<item>
<title>Redis开发与运维：SDS - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/11754048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/11754048.html</guid>
<description>&lt;p&gt;我们会经常打交道的string类型，在redis中拥有广泛的使用。也是开启redis数据类型的基础。&lt;/p&gt;
&lt;p&gt;在我最最开始接触的redis的时候，总是以为字符串类型就是值的类型是字符串。&lt;/p&gt;
&lt;p&gt;比如：SET key value&lt;/p&gt;
&lt;p&gt;我的理解是value数据类型是stirng类型，现在来看呢，这句话说得不够具体全面。&lt;/p&gt;
&lt;p&gt;这里也就引出了，另一个概念：外部类型和内部类型&lt;/p&gt;
&lt;h3 id=&quot;外部类型-vs-内部类型&quot;&gt;外部类型 vs 内部类型&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;这里的外部类型，就是我们所熟知的：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序结合(zset)等 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Q1：那么什么是内部类型呢？&lt;/p&gt;
&lt;p&gt;Q2：外部类型和内部类型是什么时候出现的？&lt;/p&gt;
&lt;p&gt;Q3：为什么要这样设计？&lt;/p&gt;
&lt;p&gt;我们先来看问题1，可以这样理解，对外数据结构就像是我们的API，对外提供着一定组织结构的数据。&lt;/p&gt;
&lt;p&gt;对内来说，我们可以更换里面的逻辑算法，甚至更换数据存储方式，比如将Mysql换成Redis.&lt;/p&gt;
&lt;p&gt;内部类型其实就是数据存储的形式。举现在我们所讨论的stirng来说。&lt;/p&gt;
&lt;p&gt;string的外部类型就是string，而它对应的数据内部存储结构分为三种。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int：8个字节的长整形
embstr：&amp;lt;=39个字节的字符串（3.2 版本变成了44）
raw：&amp;gt;39个字节的字符串（3.2 版本变成了44）&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;所以，string类型会根据当前字符串的长度来决定到底使用哪种内部数据结构。&lt;/p&gt;
&lt;p&gt;现在我们再回到问题上：什么是内部类型？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;就是数据真正存储在内存上的数据结构。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实第二个问题：外部类型和内部类型是什么时候出现的？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这里也算是有答案了，外部类型就是对外公开的数据类型也可以说是API，内部类型根据长度判断哪种内部结构。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三个问题：为什么这样设计？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;前后分离，如果有更好地内部数据类型，我们可以替换后面的数据类型，但不影响前面的Api.

还有一点也是根据不同情况，选择更好地数据结构，节省内存。毕竟是内存数据库，资源珍贵。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何查看外部类型和内部类型&quot;&gt;如何查看外部类型和内部类型&lt;/h3&gt;
&lt;h4 id=&quot;查看外部类型type&quot;&gt;查看外部类型：type&lt;/h4&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; SET sc sunchong   // 对外类型：string
OK
127.0.0.1:6999[1]&amp;gt; type sc
string
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; HSET hsc sun chong    // 对外类型：hash
(integer) 1
127.0.0.1:6999[1]&amp;gt; type hsc
hash
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;127.0.0.1:6999&amp;gt; RPUSH rsc s un ch hong
(integer) 4
127.0.0.1:6999&amp;gt; TYPE rsc
list
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查看内部类型object&quot;&gt;查看内部类型：object&lt;/h4&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 1234567890123456789   // 对内类型：int
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 19
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc
&quot;int&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;int -&amp;gt; embstr&lt;/p&gt;
&lt;p&gt;（int 8位的长整形，最大存储十进制位数为19位）&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 12345678901234567890   // 对内类型：embstr
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 20
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc   
&quot;embstr&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;embstr -&amp;gt; raw&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 123456789012345678901234567890123456789  
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 39
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc
&quot;embstr&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 12345678901234567890123456789012345678901  
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 41
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc
&quot;embstr&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;额，这里我看《Redis 开发与运维》一书&lt;/p&gt;
&lt;p&gt;39字节，embstr 转raw。写错了？&lt;/p&gt;
&lt;p&gt;我的本机redis版本是5.0+，这本书是3.0，中间肯定是有了版本更新。&lt;/p&gt;
&lt;p&gt;试试看看源码和提交记录 (&lt;a href=&quot;https://github.com/antirez/redis/commit/f15df8ba5db09bdf4be58c53930799d82120cc34#diff-43278b647ec38f9faf284496e22a97d5&quot; class=&quot;uri&quot;&gt;https://github.com/antirez/redis/commit/f15df8ba5db09bdf4be58c53930799d82120cc34#diff-43278b647ec38f9faf284496e22a97d5&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201910/406456-20191029233842478-1102253314.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续尝试 embstr -&amp;gt; raw&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 12345678901234567890123456789012345678901234
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 44
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc
&quot;embstr&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; set sc 123456789012345678901234567890123456789012345  // 对内类型：raw
OK
127.0.0.1:6999[1]&amp;gt; STRLEN sc
(integer) 45
127.0.0.1:6999[1]&amp;gt; OBJECT encoding sc
&quot;raw&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;set-key-value-ex-seconds-px-milliseconds-nxxx&quot;&gt;set key value [EX seconds] [PX milliseconds] [NX|XX]&lt;/h2&gt;
&lt;p&gt;-- ex 秒级过期时间&lt;/p&gt;
&lt;p&gt;-- px 毫秒级过期时间&lt;/p&gt;
&lt;p&gt;-- nx 不存在才能执行成功，类似添加&lt;/p&gt;
&lt;p&gt;-- xx 必须存在才能执行成功，类似修改&lt;/p&gt;
&lt;p&gt;nx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; EXISTS bus
(integer) 0
127.0.0.1:6999[1]&amp;gt; SET bus Q xx
(nil)
127.0.0.1:6999[1]&amp;gt; SET bus Q nx
OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999[1]&amp;gt; EXISTS car
(integer) 0
127.0.0.1:6999[1]&amp;gt; SET car B
OK
127.0.0.1:6999[1]&amp;gt; SET car C nx
(nil)
127.0.0.1:6999[1]&amp;gt; SET car C xx
OK
127.0.0.1:6999[1]&amp;gt; GET car
&quot;C&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;setnx-setxx&quot;&gt;setnx / setxx&lt;/h2&gt;
&lt;p&gt;这两个命令会逐步弃用&lt;/p&gt;

&lt;h2 id=&quot;sds-数据结构&quot;&gt;SDS 数据结构&lt;/h2&gt;
&lt;p&gt;为什么Redis要自己实现一套简单的动态字符串？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 效率
2. 安全（二进制安全：C语言中的字符串已 “\0” 为结束标志。）
3. 扩容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说，有一辆车，到站前提前告知车站乘客，本次列车还有多少余座。&lt;/p&gt;
&lt;p&gt;此时，如果有个计数器可以计算一下当前坐了多少乘客，同时还有多少空位就好了。&lt;/p&gt;
&lt;p&gt;这样司机师傅就不必每次停车上客前，数数还有多少座位可以坐。可以专心开车。&lt;/p&gt;
&lt;p&gt;同样，Redis SDS 也使用了这样一些小小的记录，&lt;/p&gt;
&lt;p&gt;使用时候获取这个记录，时间复杂度是O(1)，效率是很高的。不用每次都去统计。&lt;/p&gt;
&lt;p&gt;redis做了这样的设计：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;len 已用字节数

free 未用字节数

buf[]  字符数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样设计有什么好处？&lt;br/&gt;1. 方便统计当前长度等，时间复杂度是O(1)&lt;br/&gt;2. 有了长度这些关键属性，可以不依赖“\0” 终止符。二进制安全。&lt;br/&gt;3. 指针返回的是buf[]，这样可以复用C字符串相关的函数。避免重复造轮子，兼容C字符串操作&lt;br/&gt;4. 前面的len和free以及数组指针buf，内存分配上地址是连续的。所以很容易使用buf地址找到len和free.&lt;/p&gt;
&lt;p&gt;我们先来看看，这个数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201911/406456-20191109133830556-336673708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题来了，是否还有优化的空间呢？&lt;/p&gt;
&lt;p&gt;这样问比较笼统。我们思考一种场景：是不是所有的字符串存储都需要这样的结构？&lt;/p&gt;
&lt;p&gt;到这里，有经验的你已经想到，所有的情况用没问题，但是Redis是内存数据库，&lt;/p&gt;
&lt;p&gt;内存是资源，如何在资源上斤斤计较是Redis必须权衡的问题。&lt;/p&gt;
&lt;p&gt;现在我们坐下来仔细分析一下：&lt;/p&gt;
&lt;p&gt;unsigned int len 可以存的数据范围是：0 ~ 4294967295 (4 Bytes)&lt;/p&gt;
&lt;p&gt;Redis中的字符串长度往往不需要这么大，多大合适呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1字节（Byte）? 这样？&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;struct sdshdr {
    char len;
    char free;
    char buf[];
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;呀， 1字节是0~255，一般长度的字符串足够用。&lt;/p&gt;
&lt;p&gt;如果真的存储了1个字节的字符串，len和free加起来也占了两个字节。&lt;/p&gt;
&lt;p&gt;本来数据就1字节大，我为了存数据，额外信息都占2字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;再优化，只能使用位来存储长度&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设，我们从全局来看，将字符串长度（小于1KB，1KB，2KB，4KB，8KB）来表示。&lt;/p&gt;
&lt;p&gt;对于1字节，至少要拿出3个位，才能覆盖这5种情况（ 2^3=8），那么剩下的5位才能存储长度。&lt;/p&gt;
&lt;p&gt;现在我们已经进入到了Redis5.0 数据结构时代：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3个低位标识类型，5个高位存长度（2^5=32）&lt;/p&gt;
&lt;p&gt;说到这，长度大于31（'\0'结束符）的字符串，1个字节是存不下的。&lt;/p&gt;
&lt;p&gt;我们还是按照之前的逻辑 len和free再结合刚才的按位看长度类型，来看看大于1字节的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用了多少len分配了多大alloc长度类型标识flags------这些表头-1字节1字节1字节-共3字节&quot;&gt;使用了多少(len)、分配了多大(alloc)、长度类型标识(flags) ---- 这些表头= 1字节+1字节+1字节 ，共3字节&lt;/h6&gt;
&lt;h6 id=&quot;所以redis对字符串大小的界限就有了对应的宏定义&quot;&gt;所以Redis对：字符串大小的界限就有了对应的宏定义&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;#define SDS_TYPE_5  0     // 小于1KB
#define SDS_TYPE_8  1     
#define SDS_TYPE_16 2    
#define SDS_TYPE_32 3    
#define SDS_TYPE_64 4    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;对应的数据结构就是&quot;&gt;对应的数据结构就是：&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建字符串&quot;&gt;创建字符串&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;sds sdsnewlen(const void *init, size_t initlen);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看注释，非常明白：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Create a new sds string with the content specified by the 'init' pointer
 * and 'initlen'.
 * If NULL is used for 'init' the string is initialized with zero bytes.
 * If SDS_NOINIT is used, the buffer is left uninitialized;
 *
 * The string is always null-termined (all the sds strings are, always) so
 * even if you create an sds string with:
 *
 * mystring = sdsnewlen(&quot;abc&quot;,3);
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the sds header. */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取SDS类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char type = sdsReqType(initlen);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SDS_TYPE_5 一般用于字符串追加，所以还是用8这个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (type == SDS_TYPE_5 &amp;amp;&amp;amp; initlen == 0) type = SDS_TYPE_8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取头长度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int hdrlen = sdsHdrSize(type);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;申请内存（头+数据体+终止符）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sh = s_malloc(hdrlen+initlen+1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s=数据体buf[]指针&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = (char*)sh+hdrlen;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buf[]指针-1，就找到了长度类型flag&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fp = ((unsigned char*)s)-1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后缀上结束符，然后返回的是buf[]指针，兼容C语言字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    s[initlen] = '\0';
    return s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;释放字符串&quot;&gt;释放字符串&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;void sdsfree(sds s) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接释放内存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (s == NULL) return;
  s_free((char*)s-sdsHdrSize(s[-1]));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了避免频繁申请关释放内存, 把使用量len重置为0，同时清空数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void sdsclear(sds s) {
  sdssetlen(s, 0); 
  s[0] = '\0';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好处数据可以复用，避免重新申请内存&lt;/p&gt;

&lt;h2 id=&quot;用户信息&quot;&gt;用户信息&lt;/h2&gt;
&lt;p&gt;最近用户中心的访问压力极大，数据库已经扛不住。&lt;/p&gt;
&lt;p&gt;我们使用比家里快而且成熟的技术，就是再加一层缓存。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;uid：ui01&lt;/p&gt;
&lt;p&gt;username： sunchong&lt;/p&gt;
&lt;p&gt;nickname：二中&lt;/p&gt;
&lt;p&gt;roletype：01&lt;/p&gt;
&lt;p&gt;level：0&lt;/p&gt;
&lt;p&gt;需求是：用户中心的用户数据，可以用uid拿到，也可以根据username拿到（uid和username 都是唯一不重复的）&lt;/p&gt;
&lt;p&gt;我根据uid可以获取查询到用户，也可以根据username获取到用户。&lt;/p&gt;
&lt;p&gt;首先，使用哈希进行数据的缓存 — HSET user:ui01 key1 value1 key2 value2 key3 value3 ...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999&amp;gt; HSET user:ui01 username sunchong nickname 二中 roletype 01 level 0
(integer) 4
127.0.0.1:6999&amp;gt; HKEYS user:ui01
1) &quot;username&quot;
2) &quot;nickname&quot;
3) &quot;roletype&quot;
4) &quot;level&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建映射关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999&amp;gt; SET user:sunchong ui01
OK
127.0.0.1:6999&amp;gt; GET user:sunchong
&quot;ui01&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 username 找到主键uid，然后根据主键获取用户信息。&lt;/p&gt;
&lt;p&gt;数据量较多时，过期时间设置为一定区间内的随机数。避免缓存穿透。&lt;/p&gt;
&lt;h2 id=&quot;接口请求次数&quot;&gt;接口请求次数&lt;/h2&gt;
&lt;p&gt;当前我们有对用户开放的API，用户充值后使用，使用次数累加，剩余次数递减。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6999&amp;gt; SET user-ui01:times 1000
OK

127.0.0.1:6999&amp;gt; INCR user-ui01:times
(integer) 1001

127.0.0.1:6999&amp;gt; GET user-ui01:times
&quot;1001&quot;
127.0.0.1:6999&amp;gt; DECR user-ui01:times
(integer) 1000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;短信验证码&quot;&gt;短信验证码&lt;/h2&gt;
&lt;p&gt;就在前几天，我们刚刚对接了阿里云短信码服务。&lt;/p&gt;
&lt;p&gt;起初，我自己认为短信验证码为了实时性不需要进行实际的缓存处理。&lt;/p&gt;
&lt;p&gt;但是完全可以根据实际情况进行设计魂村策略。&lt;/p&gt;
&lt;p&gt;为了防止接口的频繁调用，我们可以像网关一样进行设置。&lt;/p&gt;
&lt;p&gt;现在就有这样一个需求：1个手机号，1分钟最多获取10次验证码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET Catch:Limit:13355222226 1 ex 60 nx &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化手机号，起始次数是1，默认过期时间60秒&lt;/p&gt;
&lt;p&gt;再剩下的就是代码判断次数即可。&lt;/p&gt;

&lt;p&gt;字符串类型结合命令有很多的应用场景，这个有待去收集和发现。&lt;/p&gt;
&lt;p&gt;Redis 比较容易上手，文档全，代码整洁高效。&lt;/p&gt;
&lt;p&gt;当然更需要我们去深入其运行原理，来更好使用这个工具来服务我们的业务。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 16:09:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>STRING 我们会经常打交道的string类型，在redis中拥有广泛的使用。也是开启redis数据类型的基础。 在我最最开始接触的redis的时候，总是以为字符串类型就是值的类型是字符串。 比如：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunchong/p/11754048.html</dc:identifier>
</item>
<item>
<title>从零开始搭建前后端分离的NetCore2.2（EF Core CodeFirst+Autofac）+Vue的项目框架之九如何进行用户权限控制 - Levy-伟</title>
<link>http://www.cnblogs.com/levywang/p/coreframe_9.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levywang/p/coreframe_9.html</guid>
<description>&lt;p&gt;　　在一般的前后端分离的web系统开发中，在服务端除了对用户数据的缓存之外，往往&lt;strong&gt;在某些接口上，还涉及到对用户权限的限制，有的接口只能让具有特定权限的人员才可以访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　这样以来就可以加强系统的安全性，在前面章节中简单讲了 &lt;a href=&quot;https://www.cnblogs.com/levywang/p/coreframe_8.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;MemoryCache与redis缓存的使用&lt;/strong&gt;&lt;/a&gt; ，方便将用户数据缓存到服务器上在需要的时候快速取出使用与验证，&lt;/p&gt;
&lt;p&gt;　　下面我们就讲讲如何进行用户权限的验证，以下将是一个简单的示例，可以根据需求自行调节，权限组也可以根据数据库配置实现等等&lt;/p&gt;
&lt;p&gt;　　在前面已经有 Token 验证 以及 用户数据 缓存的情况下，新建 用户验证 的 过滤器 类  &lt;span class=&quot;cnblogs_code&quot;&gt;UserAuthorize&lt;/span&gt;  继承  &lt;span class=&quot;cnblogs_code&quot;&gt;ActionFilterAttribute&lt;/span&gt; 属性　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户权限验证
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAuthorize : ActionFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserAuthorize()
        {
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;long&lt;/span&gt;&amp;gt; Popedoms { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;驼峰命名   首字母大写&lt;/span&gt;


        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;popedom&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;权限组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; UserAuthorize(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[] popedom)
        {
            Popedoms &lt;/span&gt;=&lt;span&gt; popedom.ToList();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个类是否设置了都可以访问&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (filterContext.ActionDescriptor &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ControllerActionDescriptor controllerActionDescriptor)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isDefined = controllerActionDescriptor.MethodInfo.GetCustomAttributes(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    .Any(a &lt;/span&gt;=&amp;gt; a.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AllowAnonymousAttribute));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDefined)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = UserCache.GetCurrentUser();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (user != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; Popedoms?.Contains(user.PopedomId) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CustomHttpStatusCodeResult(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;401&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;授权已失效请重新登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CustomHttpStatusCodeResult(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;402&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您无权进行该操作，请联系管理员！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　涉及到的相关代码  在之前添加的  &lt;span class=&quot;cnblogs_code&quot;&gt;UserCache&lt;/span&gt;  类中添加代码如下：  &lt;span&gt;&lt;strong&gt;完整代码，文章最下面有GitHub 地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取当前用户
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; UserDto GetCurrentUser()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = DemoWeb.HttpContext.Request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user =&lt;span&gt; Get(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(user))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; user.ToNetType&amp;lt;UserDto&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来 我们添加登录测试伪代码 然后将用户数据存进缓存 再调用添加了权限验证的接口，来验证权限验证是否可用，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　新建用户相关控制器  &lt;span class=&quot;cnblogs_code&quot;&gt;UserController&lt;/span&gt; ，继承之前的用户基础控制器 &lt;span class=&quot;cnblogs_code&quot;&gt;BaseUserController&lt;/span&gt; ，要有权限验证，肯定得先登录，示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : BaseUserController
    {
        [HttpPost, Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),AllowAnonymous]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AllowAnonymous加上这一句 为任何用户可访问，在基础控制器中有设置&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Login()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用登录方法进行登录 在业务层处理  将登录成功的用户信息缓存 以及生成token
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处示例 为了方便就直接在控制器中编写&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; token = TokenManager.GenerateToken(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试token的生成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Response.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; token;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Response.Headers[&quot;Access-Control-Expose-Headers&quot;] = &quot;token&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要同时设置 不然后者会冲突掉前者&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDto()
            {
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Levy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;levy_w_wang@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Age &lt;/span&gt;= &lt;span&gt;23&lt;/span&gt;&lt;span&gt;,
                PopedomId &lt;/span&gt;= &lt;span&gt;999&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sessionId = Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            DemoWeb.HttpContext.Response.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; sessionId;
            UserCache.Set(sessionId,user.ToJson());
            DemoWeb.HttpContext.Response.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Access-Control-Expose-Headers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token,sid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前后端分离 跨域的情况下  加上这句 前端才能拿到 sid 字段对应值 多个用英文逗号分隔&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Succeed(user);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户权限为888 或者为 999 的才能访问
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        [HttpPost,Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;popedom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),UserAuthorize(&lt;span&gt;888&lt;/span&gt;,&lt;span&gt;999&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult PopedomTest()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Succeed(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功访问&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行程序，打开接口测试工具，先访问登录接口，然后将得到的 Token 和 sid 拿来 调用 权限测试接口 我们就可以得到如下结果：截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1750888/201911/1750888-20191109235923718-1078528685.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;385&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1750888/201911/1750888-20191110000004496-416867752.png&quot; alt=&quot;&quot; width=&quot;850&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再然后调试登录，把登录的权限改为不在权限控制的值之类，再次拿着返回的sid 及 Token 来访问权限测试接口，就会得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1750888/201911/1750888-20191110000221941-417435111.png&quot; alt=&quot;&quot; width=&quot;1161&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只是做了一个简单权限验证测试，灵活运用需结合数据库及缓存，也可以根据权限设置好响应的过滤器等等方式。&lt;/p&gt;

&lt;p&gt;有需要源码的可通过此 &lt;a title=&quot;github&quot; href=&quot;https://github.com/levy-w-wang/Blogs-demo&quot; target=&quot;_blank&quot;&gt;GitHub &lt;/a&gt;链接拉取 觉得还可以的给个 start 和点个 下方的推荐哦~~谢谢！&lt;/p&gt;
&lt;p&gt;下一篇可能会讲到如何将数据库访问封装基础方法来方便使用或者常用加密等~&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 16:09:00 +0000</pubDate>
<dc:creator>Levy-伟</dc:creator>
<og:description>在一般的前后端分离的web系统开发中，在服务端除了对用户数据的缓存之外，往往在某些接口上，还涉及到对用户权限的限制，有的接口只能让具有特定权限的人员才可以访问。 这样以来就可以加强系统的安全性，在前面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/levywang/p/coreframe_9.html</dc:identifier>
</item>
<item>
<title>Linux基于webRTC的二次开发(一) - Notaregular</title>
<link>http://www.cnblogs.com/luckydml/p/11828599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luckydml/p/11828599.html</guid>
<description>&lt;p&gt;最近在做Linux平台下webRTC的二次开发，一路摸索，中间踩了不少坑，这一篇博客先来简单介绍下Linux上如何使用GCC编译webRTC。&lt;/p&gt;
&lt;h3 id=&quot;为什么使用gcc编译&quot;&gt;为什么使用GCC编译？&lt;/h3&gt;
&lt;p&gt;这其实是无奈之举，Linux下webRTC中的ninja工程使用的是Clang进行编译，且依赖其内置的stdc标准库。然而我现有的开发环境所使用的编译器为GCC,在使用Clang进行webRTC二次开发时遇到各种编译错误，只好改用GCC重新编译webRTC。&lt;/p&gt;
&lt;h3 id=&quot;获取webrtc源码&quot;&gt;1.获取webRTC源码&lt;/h3&gt;
&lt;p&gt;需要准备一个梯子，同时使用工具进行终端穿墙。&lt;br/&gt;获取源码流程可以查看官方文档&lt;a href=&quot;https://webrtc.org/native-code/development/&quot; class=&quot;uri&quot;&gt;https://webrtc.org/native-code/development/&lt;/a&gt;&lt;br/&gt;首先安装Chromium depot tools;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将depot tools路径添加道环境变量中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export PATH=$PATH:/path/to/depot_tools&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后获取webRTC源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir webrtc-checkout
cd webrtc-checkout
fetch --nohooks webrtc
gclient sync&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;webrtc源码下载下来很大，确保翻墙工具有足够的流量&lt;/p&gt;
&lt;h3 id=&quot;修改build.gn&quot;&gt;2.修改BUILD.gn&lt;/h3&gt;
&lt;p&gt;如果不修改GN files会出现一堆错误，编译无法通过&lt;br/&gt;关闭-Werror编译选项&lt;br/&gt;&lt;strong&gt;build/config/complier/BUILD.gn&lt;/strong&gt;&lt;br/&gt;修改treat_warnings_as_errors=false&lt;br/&gt;使用系统stdc标准库&lt;br/&gt;&lt;strong&gt;build/config/c++/BUILD.gn&lt;/strong&gt;&lt;br/&gt;注释掉&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cflags_cc += [
    &quot;-nostdinc++&quot;
]
cflags += [&quot;-fno-builtin-abs&quot;]
ldflags += [&quot;-nodefaultlibs&quot;]
libs += [
    &quot;c&quot;,
    &quot;gcc_s&quot;,
    &quot;m&quot;,
    &quot;rt&quot;,
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用gcc编译命令为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gn gen webrtc-checkout/src/out/Default --args=&quot;is_clang=false&quot;
ninja -C webrtc-checkout/src/out/Default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译过程中可能会遇到因为源码问题导致编译出错，修改即可&lt;br/&gt;编译成功后，即可使用gcc二次编译开发&lt;br/&gt;注意编译时需添加一些编译选项&lt;br/&gt;使用cmake构建工程时添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set(CMAKE_CXX_FLAGS &quot;-fno-rtti&quot;)
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -DWEBRTC_LINUX=1 -DWEBRTC_POSIX=1&quot;)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 09 Nov 2019 15:59:00 +0000</pubDate>
<dc:creator>Notaregular</dc:creator>
<og:description>最近在做Linux平台下webRTC的二次开发，一路摸索，中间踩了不少坑，这一篇博客先来简单介绍下Linux上如何使用GCC编译webRTC。 为什么使用GCC编译？ 这其实是无奈之举，Linux下w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luckydml/p/11828599.html</dc:identifier>
</item>
<item>
<title>MinIO 搭建 - 耳东-Erdong</title>
<link>http://www.cnblogs.com/erdongx/p/11828546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erdongx/p/11828546.html</guid>
<description>&lt;p&gt;MinIO 是一个基于 Apache License v2.0 开源协议的对象存储服务。它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几 kb 到最大 5T 不等。&lt;/p&gt;
&lt;p&gt;MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL。&lt;/p&gt;
&lt;p&gt;官方对 Minio 的定义是一个高性能的对象存储。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Build high performance data infrastructure&lt;br/&gt;for machine learning, analytics and&lt;br/&gt;application data workloads with MinIO 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Minio 的官方网站是 &lt;a href=&quot;https://min.io&quot; class=&quot;uri&quot;&gt;https://min.io&lt;/a&gt; ，&lt;br/&gt;Minio 的官方文档是 &lt;a href=&quot;https://docs.min.io/cn/&quot; class=&quot;uri&quot;&gt;https://docs.min.io/cn/&lt;/a&gt; ，&lt;br/&gt;GitHub 仓库地址是：&lt;a href=&quot;https://github.com/minio/minio&quot; class=&quot;uri&quot;&gt;https://github.com/minio/minio&lt;/a&gt; ，目前有 18.8k Stars (2019.11.9)&lt;/p&gt;
&lt;p&gt;Minio 的 benchmark 说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://min.io/resources/docs/MinIO-vs-HDFS-MapReduce-performance-comparison.pdf&quot; class=&quot;uri&quot;&gt;https://min.io/resources/docs/MinIO-vs-HDFS-MapReduce-performance-comparison.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://min.io/resources/docs/MinIO-throughput-benchmarks-on-NVMe-SSD.pdf&quot; class=&quot;uri&quot;&gt;https://min.io/resources/docs/MinIO-throughput-benchmarks-on-NVMe-SSD.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://min.io/resources/docs/Performance-comparison-Starburst-Presto-SQL.pdf&quot; class=&quot;uri&quot;&gt;https://min.io/resources/docs/Performance-comparison-Starburst-Presto-SQL.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://min.io/resources/docs/MinIO-throughput-benchmarks-on-HDD.pdf&quot; class=&quot;uri&quot;&gt;https://min.io/resources/docs/MinIO-throughput-benchmarks-on-HDD.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://min.io/resources/docs/Performance-comparison-Apache-Spark.pdf&quot; class=&quot;uri&quot;&gt;https://min.io/resources/docs/Performance-comparison-Apache-Spark.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MinIO 分为服务端和客户端，服务端提供一个对象存储，也提供一个 Web 的管理页面。客户端是用来管理、查看服务端的一个工具。服务端的二进制文件是 &lt;code&gt;minio&lt;/code&gt; ，客户端的二进制文件是 &lt;code&gt;mc&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;使用二进制文件启动&quot;&gt;使用二进制文件启动&lt;/h2&gt;
&lt;p&gt;首先先下载服务端的二进制文件，其次准备一个用来存储的磁盘或者目录，&lt;/p&gt;
&lt;p&gt;下载好以后赋予执行权限，可以使用如下命令快速启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chmod +x minio
./minio server /erdong/data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后可以通过访问 &lt;a href=&quot;http://localhost:9000&quot; class=&quot;uri&quot;&gt;http://localhost:9000&lt;/a&gt; 来访问你的对象存储。&lt;/p&gt;
&lt;h2 id=&quot;使用-docker-启动&quot;&gt;使用 Docker 启动&lt;/h2&gt;
&lt;p&gt;MinIO 需要一个持久卷来存储配置和应用数据。不过, 如果只是为了测试一下, 您可以通过简单地传递一个目录（在下面的示例中为 &lt;code&gt;/erdong/data&lt;/code&gt;）启动 MinIO 。这个目录会在容器启动时在容器的文件系统中创建，不过所有的数据都会在容器退出时丢失。&lt;/p&gt;
&lt;p&gt;要创建具有永久存储的 MinIO 容器，您需要将本地持久目录从主机操作系统映射到虚拟配置 ~/.minio 并导出 /data 目录。 为此，请运行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -p 9000:9000 --name minio \
  -e &quot;MINIO_ACCESS_KEY=minioadmin&quot; \
  -e &quot;MINIO_SECRET_KEY=minioadminpassword&quot; \
  -v /erdong/minio/data:/data \
  -v /erdong/minio/config:/root/.minio \
  minio/minio server /data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后，即可访问 &lt;a href=&quot;http://localhost:9000&quot; class=&quot;uri&quot;&gt;http://localhost:9000&lt;/a&gt; 来访问你的对象存储。&lt;/p&gt;
&lt;p&gt;上述命令中设置了如下参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MINIO_ACCESS_KEY 管理员的访问秘钥&lt;/li&gt;
&lt;li&gt;MINIO_SECRET_KEY 管理员的秘钥&lt;/li&gt;
&lt;li&gt;/erdong/minio/&lt;a href=&quot;data:/data&quot; class=&quot;uri&quot;&gt;data:/data&lt;/a&gt; 挂载持久化数据目录&lt;/li&gt;
&lt;li&gt;/erdong/minio/config:/root/.minio 挂载配置文件&lt;/li&gt;
&lt;li&gt;server 启动 Server 模式，除了该模式还有一个 Gateway 模式。&lt;/li&gt;
&lt;li&gt;/data 指定数据目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要指定端口可以使用如下参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--address &quot;:9000&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;接下来我们看看如何在 linux 上配置 MinIO 服务使用 TLS 。&lt;/p&gt;
&lt;p&gt;使用 TLS 的前提是先下载好 MinIO Server 。&lt;/p&gt;
&lt;p&gt;如果你已经有私钥和公钥证书，你需要将他们拷贝到 MinIO 的 &lt;code&gt;$HOME/.minio/certs&lt;/code&gt; 文件夹，私钥的名字必须是 &lt;code&gt;private.key&lt;/code&gt; ，公钥证书的名字必须是 &lt;code&gt;public.crt&lt;/code&gt; 。 MinIO 在 Linux 只支持使用 PEM 格式的秘钥和证书，在 Windows 上只支持 PEM 格式的秘钥和证书，目前不支持 PFX 证书。&lt;/p&gt;
&lt;p&gt;如果这个证书是被证书机构签发的，&lt;code&gt;public.crt&lt;/code&gt; 应该是服务器的证书。&lt;/p&gt;
&lt;p&gt;Linux 可以使用如下工具来生成证书&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Let‘s Encrypt&lt;/li&gt;
&lt;li&gt;generate_cert.go&lt;/li&gt;
&lt;li&gt;OpenSSL&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Windows 可以使用如下工具来生成证书&lt;/p&gt;
&lt;p&gt;Minio 也可以配置成连接其它服务，不管是 Minio 节点还是像 NATs、Redis 这些。如果这些服务用的不是在已知证书机构注册的证书，你可以让 Minio 服务信任这些 CA ，怎么做呢，将这些证书放到Minio配置路径下(~/.minio/certs/CAs/ Linux 或者 C:\Users&amp;lt;Username&amp;gt;.minio\certs\CAs Windows).&lt;/p&gt;
&lt;h2 id=&quot;如何使用-openssl-来生成自签证书&quot;&gt;如何使用 OpenSSL 来生成自签证书&lt;/h2&gt;
&lt;p&gt;使用如下命令生成私钥，私钥会生成在执行命令的目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl genrsa -out private.key 2048&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成自签名的证书，证书会生成在执行命令的目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl req -new -x509 -days 3650 -key private.key -out public.crt -subj &quot;/C=US/ST=state/L=location/O=organization/CN=domain&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中相关内容可以按照实际情况修改，比如 &lt;code&gt;/C&lt;/code&gt; 是国家，中国是 CN ，&lt;code&gt;/ST&lt;/code&gt; 是州或者省， &lt;code&gt;/L&lt;/code&gt; 是市或者区， &lt;code&gt;/CN&lt;/code&gt; 是域名。&lt;/p&gt;
&lt;p&gt;秘钥和证书生成好以后，按照上边的要求放置在对应的目录即可。&lt;/p&gt;

&lt;p&gt;Thanos 在连接 MinIO 的时候遇到了一些问题，日志里有很多错误提示，列在下边供参考。&lt;/p&gt;
&lt;h2 id=&quot;提示冒号太多&quot;&gt;1. 提示冒号太多&lt;/h2&gt;
&lt;p&gt;日志报错如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;level=info ts=2019-11-08T02:43:40.981858805Z caller=main.go:170 msg=&quot;Tracing will be disabled&quot;
level=info ts=2019-11-08T02:43:40.982326667Z caller=factory.go:39 msg=&quot;loading bucket configuration&quot;
level=error ts=2019-11-08T02:43:40.982682262Z caller=main.go:200 err=&quot;store command failed: create bucket client: create S3 client: initialize s3 client: address http://127.0.0.1:9000: too many colons in address&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志描述直译过来就是冒号太多了，原因是在配置文件中，填写了 MinIO 提供的 S3 协议的 endpoint 的时候，多填写了 &lt;code&gt;http://&lt;/code&gt; ，导致提示该错误。本意是在内网使用， HTTP 协议就可以了，不需要要开启 HTTPS ，但是 Thanos 在连接 S3 存储的时候默认是使用 HTTPS 的，不能通过这种方式来使用 HTTP 。&lt;/p&gt;
&lt;p&gt;错误的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type: S3
config:
  bucket: &quot;disk1&quot;
  endpoint: &quot;http://127.0.0.1:9000&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正确的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type: S3
config:
  bucket: &quot;disk1&quot;
  endpoint: &quot;127.0.0.1:9000&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;提示对方没有使用-https&quot;&gt;2. 提示对方没有使用 HTTPS&lt;/h2&gt;
&lt;p&gt;日志报错如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;level=info ts=2019-11-08T02:42:04.366000876Z caller=main.go:170 msg=&quot;Tracing will be disabled&quot;
level=info ts=2019-11-08T02:42:04.366417674Z caller=factory.go:39 msg=&quot;loading bucket configuration&quot;
level=info ts=2019-11-08T02:42:04.384413714Z caller=cache.go:172 msg=&quot;created index cache&quot; maxItemSizeBytes=131072000 maxSizeBytes=262144000 maxItems=math.MaxInt64
level=error ts=2019-11-08T02:42:04.385632149Z caller=main.go:200 err=&quot;store command failed: bucket store initial sync: sync block: iter: Get https://127.0.0.1:9000/prometheus-store/?delimiter=%2F&amp;amp;max-keys=1000&amp;amp;prefix=: http: server gave HTTP response to HTTPS client&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 Thanos 连接的对象存储只提供了 HTTP ，没有提供 HTTPS，这个时候需要让对象存储添加证书，启用 HTTPS 。&lt;/p&gt;
&lt;h2 id=&quot;不能够认证某个域名&quot;&gt;3. 不能够认证某个域名&lt;/h2&gt;
&lt;p&gt;日志报错如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;level=info ts=2019-11-08T03:06:57.90508837Z caller=main.go:170 msg=&quot;Tracing will be disabled&quot;
level=info ts=2019-11-08T03:06:57.905445182Z caller=factory.go:39 msg=&quot;loading bucket configuration&quot;
level=info ts=2019-11-08T03:06:57.923283984Z caller=cache.go:172 msg=&quot;created index cache&quot; maxItemSizeBytes=131072000 maxSizeBytes=262144000 maxItems=math.MaxInt64
level=error ts=2019-11-08T03:06:57.927125234Z caller=main.go:200 err=&quot;store command failed: bucket store initial sync: sync block: iter: Get https://10.23.80.18:9000/prometheus-store/?delimiter=%2F&amp;amp;max-keys=1000&amp;amp;prefix=: x509: cannot validate certificate for minio-erdong.site because it doesn't contain any IP SANs&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 Thanos 连接 Minio 的 HTTP 配置里，有一个 &lt;code&gt;insecure_skip_verify&lt;/code&gt; 选项，该选项默认为 false ，需要对域名的证书进行验证，由于使用了自签证书，没有在权威的 CA 机构做认证，所以在连接过程中会提示不安全，将值改为 true，跳过这个验证就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  http_config:
    idle_conn_timeout: 90s
    response_header_timeout: 2m
    insecure_skip_verify: true&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 09 Nov 2019 15:39:00 +0000</pubDate>
<dc:creator>耳东-Erdong</dc:creator>
<og:description>MinIO 搭建 MinIO 是一个基于 Apache License v2.0 开源协议的对象存储服务。它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/erdongx/p/11828546.html</dc:identifier>
</item>
<item>
<title>Go服务监控 - 飞鸿影</title>
<link>http://www.cnblogs.com/52fhy/p/11828448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/11828448.html</guid>
<description>&lt;p&gt;使用Golang可以开发出高性能的HTTP、GRPC服务。一般项目运行后，我们也需要监控服务的性能或者进行调试。除了打日志，还有没有其他可视化的方案呢？答案是有的。&lt;/p&gt;
&lt;p&gt;本文将会介绍几种常用的监控方案。&lt;/p&gt;
&lt;h2 id=&quot;pprof&quot;&gt;pprof&lt;/h2&gt;
&lt;p&gt;这个是go语言自带的。启用很简单：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;_ &quot;net/http/pprof&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅需显式的在 main 包的 import 里增加上面一行即可。完整使用示例：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
)

func main(){
    //提供给负载均衡探活以及pprof调试
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte(&quot;ok&quot;))
    })

    http.ListenAndServe(&quot;:10108&quot;, nil)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，在浏览器打开 &lt;code&gt;http://127.0.0.1:10108/debug/pprof/&lt;/code&gt;就能看到监控的一些信息了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201911/663847-20191109231138364-633001314.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：生产环境一般不会按上面那么写，都是开个协程：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go http.ListenAndServe(&quot;:10108&quot;, nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何启动 PProf 可视化界面？&lt;/p&gt;
&lt;blockquote readability=&quot;4.5547445255474&quot;&gt;
&lt;p&gt;需要&lt;code&gt;graphviz&lt;/code&gt;支持，可以到 &lt;a href=&quot;http://www.graphviz.org/download/&quot; class=&quot;uri&quot;&gt;http://www.graphviz.org/download/&lt;/a&gt; 下载，并把bin加入到环境变量。Mac可以使用brew安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面以&lt;code&gt;heap&lt;/code&gt;为例：&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go tool pprof -http=:8081 http://localhost:10108/debug/pprof/heap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go tool pprof http://localhost:10108/debug/pprof/heap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在交互式命令行输入&lt;code&gt;web&lt;/code&gt;即可跳转到默认浏览器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201911/663847-20191109231211647-1240640016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看协程信息：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;go tool pprof -http=:8081 http://localhost:10108/debug/pprof/goroutine&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;debugcharts&quot;&gt;debugcharts&lt;/h2&gt;
&lt;p&gt;一个可以实时查看golang程序内存、CPU、GC、协程等变化情况的可视化工具。&lt;/p&gt;
&lt;p&gt;跟pprof一样， import引入， 然后开端口监听就行了：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;_ &quot;github.com/mkevac/debugcharts&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//省略其它代码...
http.ListenAndServe(&quot;:10108&quot;, nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后，浏览器打开 &lt;a href=&quot;http://localhost:10108/debug/charts/&quot; class=&quot;uri&quot;&gt;http://localhost:10108/debug/charts/&lt;/a&gt; 就能看到了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201911/663847-20191109231239780-383614762.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;prometheus&quot;&gt;prometheus&lt;/h2&gt;
&lt;p&gt;prometheus是grafana的插件，支持go监控的可视化。&lt;/p&gt;
&lt;p&gt;首先需要代码里引入包：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后增加路由：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//prometheus
http.Handle(&quot;/metrics&quot;, promhttp.Handler())
http.ListenAndServe(&quot;:10108&quot;, nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置grafana后，效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201911/663847-20191109231323653-1640901497.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个端口开启-pprofchartsprometheus&quot;&gt;一个端口开启 pprof+charts+prometheus&lt;/h2&gt;
&lt;p&gt;如果每一个监控都开一个端口就有点浪费端口了。可以在一个端口里开启 pprof+charts+prometheus 。&lt;/p&gt;
&lt;p&gt;1、入口文件增加代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//监控
go func() {
   //提供给负载均衡探活
   http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
      w.Write([]byte(&quot;ok&quot;))

   })

   //prometheus
   http.Handle(&quot;/metrics&quot;, promhttp.Handler())

   //pprof, go tool pprof -http=:8081 http://$host:$port/debug/pprof/heap
   http.ListenAndServe(&quot;:10108&quot;, nil)
}()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、import增加&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;_ &quot;github.com/mkevac/debugcharts&quot;
&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;
&quot;net/http&quot;
_ &quot;net/http/pprof&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、Golang pprof详解&lt;br/&gt;&lt;a href=&quot;https://studygolang.com/articles/14519&quot; class=&quot;uri&quot;&gt;https://studygolang.com/articles/14519&lt;/a&gt;&lt;br/&gt;2、mkevac/debugcharts: Very simple charts with some debug data for Go programs&lt;br/&gt;&lt;a href=&quot;https://github.com/mkevac/debugcharts&quot; class=&quot;uri&quot;&gt;https://github.com/mkevac/debugcharts&lt;/a&gt;&lt;br/&gt;3、prometheus/client_golang: Prometheus instrumentation library for Go applications&lt;br/&gt;&lt;a href=&quot;https://github.com/prometheus/client_golang/&quot; class=&quot;uri&quot;&gt;https://github.com/prometheus/client_golang/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 15:14:00 +0000</pubDate>
<dc:creator>飞鸿影</dc:creator>
<og:description>使用Golang可以开发出高性能的HTTP、GRPC服务。一般项目运行后，我们也需要监控服务的性能或者进行调试。除了打日志，还有没有其他可视化的方案呢？答案是有的。 本文将会介绍几种常用的监控方案。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/52fhy/p/11828448.html</dc:identifier>
</item>
<item>
<title>SpringBoot系列：Spring Boot集成定时任务Quartz - 杨小格子</title>
<link>http://www.cnblogs.com/imyanger/p/11828301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyanger/p/11828301.html</guid>
<description>&lt;h3 id=&quot;一关于quartz&quot;&gt;一、关于Quartz&lt;/h3&gt;
&lt;p&gt;Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。在java企业级应用中，Quartz是使用最广泛的定时调度框架。&lt;/p&gt;
&lt;p&gt;在Quartz中的主要概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scheduler：调度任务的主要API&lt;/li&gt;
&lt;li&gt;ScheduleBuilder：用于构建Scheduler，例如其简单实现类SimpleScheduleBuilder&lt;/li&gt;
&lt;li&gt;Job：调度任务执行的接口，也即定时任务执行的方法&lt;/li&gt;
&lt;li&gt;JobDetail：定时任务作业的实例&lt;/li&gt;
&lt;li&gt;JobBuilder：关联具体的Job，用于构建JobDetail&lt;/li&gt;
&lt;li&gt;Trigger：定义调度执行计划的组件，即定时执行&lt;/li&gt;
&lt;li&gt;TriggerBuilder：构建Trigger&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一quartz演示示例&quot;&gt;一、Quartz演示示例&lt;/h3&gt;
&lt;p&gt;在SpringBoot中，我们需要引入quartz的依赖。&lt;/p&gt;
&lt;pre class=&quot;pom&quot;&gt;
&lt;code&gt; &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--quartz定时调度依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定义定时具体执行逻辑Job，创建类QuartzJob1，这里集继承QuartzJobBean实现executeInternal即可，该方法即定时执行任务逻辑，这里简单打印了下当前时间。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QuartzJob1 extends QuartzJobBean {

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(&quot;QuartzJob1----&quot; + sdf.format(new Date()));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建QuartzConfig，接着定义JobDetail，JobDetail由JobBuilder构建，同时关联了任务QuartzJob1。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail jobDetail1(){
        return JobBuilder.newJob(QuartzJob1.class).storeDurably().build();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们需要定义定时调度Trigger，简单实现类SimpleScheduleBuilder用于构建Scheduler，TriggerBuilder则用于构建Trigger，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail jobDetail1(){
        return JobBuilder.newJob(QuartzJob1.class).storeDurably().build();
    }

    @Bean
    public Trigger trigger1(){
        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1) //每一秒执行一次
                .repeatForever(); //永久重复，一直执行下去
        return TriggerBuilder.newTrigger()
                .forJob(jobDetail1())
                .withSchedule(scheduleBuilder)
                .build();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个Quartz定时任务就配置完成了。&lt;/p&gt;
&lt;p&gt;其实Job的定义也可以使用内部类，这样可以省去Job类的创建，例如下面定时任务2 jobDetail2和trigger2。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public JobDetail jobDetail2(){
    QuartzJobBean quartzJob2 = new QuartzJobBean() {
        @Override
        protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
            SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            System.out.println(&quot;内部类quartzJob2----&quot; + sdf.format(new Date()));
        }
    };
    return JobBuilder.newJob(quartzJob2.getClass()).storeDurably().build();
}

@Bean
public Trigger trigger2(){
    //JobDetail的bean注入不能省略
    //JobDetail jobDetail3 = JobBuilder.newJob(QuartzJob2.class).storeDurably().build();
    SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
            .withIntervalInSeconds(2) //每2秒执行一次
            .repeatForever(); //永久重复，一直执行下去
    return TriggerBuilder.newTrigger()
            .forJob(jobDetail2())
            .withSchedule(scheduleBuilder).build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动程序，我们就可以看到控制台的时间输出了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191109230147899-858887690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时Quartz是支持数据持久化的，可以将定时调度信息持久化到数据库。&lt;/p&gt;
&lt;p&gt;选择持久化到数据库，我们需要创建对应的表，建表语句可以在&lt;a href=&quot;http://www.quartz-scheduler.org/downloads/&quot;&gt;Quartz官网&lt;/a&gt;进行下载，解压后在docs\dbTables目录下寻找对应数据库的SQL脚本。&lt;/p&gt;
&lt;p&gt;为了方便，我也将该文件放在了项目源码resources里。&lt;/p&gt;
&lt;p&gt;操作数据库，我们引入相关的依赖。若有ORM框架，例如mybatis，hibernate或者jpa，则无需再引入jdbc依赖。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;!--mysql连接--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--druid连接池--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--jdbc依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在application.yml配置文件中，我们对quartz持久化方式进行声明。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;server:
  port: 10900

spring:
  profiles:
    active: dev
  quartz:
    job-store-type: jdbc #持久化到数据库
    properties:
      org:
        quartz:
          datasource:
            # 新版驱动从com.mysql.jdbc.Driver变更为com.mysql.cj.jdbc.Driver
            driver-class-name: com.mysql.cj.jdbc.Driver
            # 数据源需要添加时间标准和指定编码格式解决乱码 You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.
            url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC
            username: root
            password: 1234
          scheduler:
            instancName: clusteredScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate #StdJDBCDelegate说明支持集群
            tablePrefix: QRTZ_
            isClustered: true
            clusterCheckinInterval: 1000
            useProperties: false
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 20
            threadPriority: 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要就是job-store-type: jdbc，表示持久化到数据库，然后就是数据源，由于该演示项目没有其他ORM的数据源，所以这里将数据源信息定义在了quartz节点下的datasource节点，如果已经存在，可使用同一个属性配置，当然最关键的是QuartzDataSource声明。&lt;/p&gt;
&lt;p&gt;这里关键的是@QuartzDataSource，这个要和项目中已经存在的数据源区分开。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Error:EmbeddedDatabaseType class not found，Druid数据源初始化需要引入spring-jdbc依赖，JPA或mybatis依赖已经包含该依赖
@Bean
@QuartzDataSource
@ConfigurationProperties(prefix = &quot;spring.quartz.properties.org.quartz.datasource&quot;)
DataSource quartzDataSource(){
    return DruidDataSourceBuilder.create().build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样持久化就已经配置好了，我们执行sql，再启动项目，启动完成后，我们可以看到数据库中已经有我们的定时调度数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191109230148272-1932709898.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/imyanger/springboot-project/tree/master/p25-springboot-quartz&quot; class=&quot;uri&quot;&gt;https://github.com/imyanger/springboot-project/tree/master/p25-springboot-quartz&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 15:02:00 +0000</pubDate>
<dc:creator>杨小格子</dc:creator>
<og:description>一、关于Quartz Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。在java企业级应用中，Q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imyanger/p/11828301.html</dc:identifier>
</item>
<item>
<title>Spring Boot实战之定制type Formatters - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/11828288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/11828288.html</guid>
<description>&lt;blockquote readability=&quot;2.112676056338&quot;&gt;
&lt;p&gt;本文首发于个人网站：&lt;a href=&quot;http://www.javaadu.online/?p=652&quot;&gt;Spring Boot实战之定制type Formatters&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们&lt;a href=&quot;http://www.javaadu.online/?p=593&quot;&gt;有篇文章&lt;/a&gt;介绍了PropertyEditors，是用来将文本类型转换成指定的Java类型，不过，考虑到&lt;em&gt;PropertyEditor&lt;/em&gt;的无状态和非线程安全特性，Spring 3增加了一个&lt;em&gt;Formatter&lt;/em&gt;接口来替代它。Formatters提供和PropertyEditor类似的功能，但是提供线程安全特性，也可以实现字符串和对象类型的互相转换。&lt;/p&gt;
&lt;p&gt;假设在我们的程序中，需要根据一本书的ISBN字符串得到对应的book对象。通过这个类型格式化工具，我们可以在控制器的方法签名中定义Book参数，而URL参数只需要包含ISBN号和数据库ID。&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;实战&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先在项目根目录下创建&lt;em&gt;formatters&lt;/em&gt;包&lt;/li&gt;
&lt;li&gt;然后创建BookFormatter，它实现了Formatter接口，实现两个函数：parse用于将字符串ISBN转换成book对象；print用于将book对象转换成该book对应的ISBN字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.test.bookpub.formatters;

import com.test.bookpub.domain.Book;
import com.test.bookpub.repository.BookRepository;
import org.springframework.format.Formatter;
import java.text.ParseException;
import java.util.Locale;

public class BookFormatter implements Formatter&amp;lt;Book&amp;gt; {
    private BookRepository repository;

    public BookFormatter(BookRepository repository) {
        this.repository = repository;
    }
  
    @Override
    public Book parse(String bookIdentifier, Locale locale) throws ParseException {
        Book book = repository.findBookByIsbn(bookIdentifier);
        return book != null ? book : repository.findOne(Long.valueOf(bookIdentifier));
    }
  
    @Override
    public String print(Book book, Locale locale) {
        return book.getIsbn();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在WebConfiguration中添加我们定义的formatter，重写（@Override修饰）&lt;em&gt;addFormatter(FormatterRegistry registry)&lt;/em&gt;函数。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
private BookRepository bookRepository;

@Override
public void addFormatters(FormatterRegistry registry) {
    registry.addFormatter(new BookFormatter(bookRepository));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后，需要在BookController中新加一个函数getReviewers，根据一本书的ISBN号获取该书的审阅人。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(value = &quot;/{isbn}/reviewers&quot;, method = RequestMethod.GET)
public List&amp;lt;Reviewer&amp;gt; getReviewers(@PathVariable(&quot;isbn&quot;) Book book) {
    return book.getReviewers();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;mvn spring-boot:run&lt;/code&gt;运行程序&lt;/li&gt;
&lt;li&gt;通过httpie访问URL——http://localhost:8080/books/9781-1234-1111/reviewers，得到的结果如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Date: Tue, 08 Dec 2015 08:15:31 GMT
Server: Apache-Coyote/1.1
Transfer-Encoding: chunked

[]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Formatter&lt;/em&gt;工具的目标是提供跟PropertyEditor类似的功能。通过FormatterRegistry将我们自己的formtter注册到系统中，然后Spring会自动完成文本表示的book和book实体对象之间的互相转换。由于Formatter是无状态的，因此不需要为每个请求都执行注册formatter的动作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用建议：&lt;/strong&gt;如果需要通用类型的转换——例如String或Boolean，最好使用PropertyEditor完成，因为这种需求可能不是全局需要的，只是某个Controller的定制功能需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在WebConfiguration中引入（@Autowired）了&lt;em&gt;BookRepository&lt;/em&gt;（需要用它创建BookFormatter实例），Spring给配置文件提供了使用其他bean对象的能力。Spring本身会确保BookRepository先创建，然后在WebConfiguration类的创建过程中引入。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-1.x系列&quot;&gt;Spring Boot 1.x系列&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=487&quot;&gt;Spring Boot的自动配置、Command-line-Runner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=495&quot;&gt;了解Spring Boot的自动配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=499&quot;&gt;Spring Boot的@PropertySource注解在整合Redis中的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=515&quot;&gt;Spring Boot项目中如何定制HTTP消息转换器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=518&quot;&gt;Spring Boot整合Mongodb提供Restful接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=521&quot;&gt;Spring中bean的scope&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=526&quot;&gt;Spring Boot项目中使用事件派发器模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=530&quot;&gt;Spring Boot提供RESTful接口时的错误处理实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=535&quot;&gt;Spring Boot实战之定制自己的starter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=538&quot;&gt;Spring Boot项目如何同时支持HTTP和HTTPS协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=546&quot;&gt;自定义的Spring Boot starter如何设置自动配置注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=575&quot;&gt;Spring Boot项目中使用Mockito&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=588&quot;&gt;在Spring Boot项目中使用Spock测试框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=590&quot;&gt;Spring Boot项目中如何定制拦截器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=593&quot;&gt;Spring Boot项目中如何定制PropertyEditors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=633&quot;&gt;Spring Boot构建的Web项目如何在服务端校验表单输入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=637&quot;&gt;Spring Boot应用的健康监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=646&quot;&gt;Spring Boot项目中如何定制servlet-filters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/?p=649&quot;&gt;Spring Boot实战之定制URL匹配规则&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/721786/201911/721786-20191109225747248-427887916.png&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 14:58:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>本文首发于个人网站： 'Spring Boot实战之定制type Formatters' 前面我们 '有篇文章' 介绍了PropertyEditors，是用来将文本类型转换成指定的Java类型，不过，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaadu/p/11828288.html</dc:identifier>
</item>
<item>
<title>WebGL简易教程(十二)：包围球与投影 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/11828120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/11828120.html</guid>
<description>&lt;p&gt;在之前的教程中，都是通过物体的包围盒来设置模型视图投影矩阵（MVP矩阵），来确定物体合适的位置的。但是在很多情况下，使用包围盒并不方便计算，可以利用包围盒再生成一个包围球，利用包围球来设置MVP矩阵。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/11668014.html&quot;&gt;《WebGL简易教程(十)：光照》&lt;/a&gt;中，给地形赋予了固定方向的平行光。这篇教程的例子就是想模拟在平行光的视角下地形的情况。对于点光源光，可以用透视投影来实现渲染的效果；而平行光就需要通过正射投影来模拟。并且，这种正射并不是垂直到达地面，而是附带一定角度&lt;sup&gt;[1]&lt;/sup&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201911/1000410-20191109220902993-929609328.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下使用包围盒来计算合适的位置有点难度，使用包围球来设置MVP矩阵更加方便。&lt;/p&gt;

&lt;p&gt;包围球是利用包围盒生成的，所以首先需要定义一个球体对象:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//定义一个球体
function Sphere(cuboid) {
  this.centerX = cuboid.CenterX();
  this.centerY = cuboid.CenterY();
  this.centerZ = cuboid.CenterZ();
  this.radius = Math.max(Math.max(cuboid.LengthX(), cuboid.LengthY()), cuboid.LengthZ()) / 2.0;
}

Sphere.prototype = {
  constructor: Sphere
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个球体对象的构造函数传入了一个包围盒对象，以包围盒的中心为球体的中心，包围盒长、宽、高的最大值作为包围球的直径。在构造出包围盒之后，利用包围盒参数构造出包围球，将其保存在自定义的Terrain对象中：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var terrain = new Terrain();
//....
terrain.cuboid = new Cuboid(minX, maxX, minY, maxY, minZ, maxZ);
terrain.sphere = new Sphere(terrain.cuboid);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是改进设置MVP矩阵的函数setMVPMatrix()了。如果仍然想像之前那样进行透视投影，几乎可以不用做改动：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//设置MVP矩阵
function setMVPMatrix(gl, canvas, sphere, lightDirection) {    
  //...

  //投影矩阵
  var fovy = 60;
  var projMatrix = new Matrix4();
  projMatrix.setPerspective(fovy, canvas.width / canvas.height, 1, 10000);

  //计算lookAt()函数初始视点的高度
  var angle = fovy / 2 * Math.PI / 180.0;
  var eyeHight = (sphere.radius * 2 * 1.1) / 2.0 / angle;

  //视图矩阵  
  var viewMatrix = new Matrix4(); // View matrix   
  viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);
  
  //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前是通过透视变换的张角和包围盒的Y方向长度来计算合适的视野高度，现在只不过将包围盒的Y方向长度换成包围球的直径。这样的写法兼容性更高，因为包围球的直径是包围盒XYZ三个方向的最大长度。这个时候的初始渲染状态为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201911/1000410-20191109220920365-1587574412.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;最后实现下特定角度平行光视角下的地形渲染情况。前面说到过这种情况下是需要设置正射投影的，具体设置过程如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//设置MVP矩阵
function setMVPMatrix(gl, canvas, sphere, lightDirection) {    
  //...

  //模型矩阵
  var modelMatrix = new Matrix4();
  modelMatrix.scale(curScale, curScale, curScale);
  modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
  modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis 
  modelMatrix.translate(-sphere.centerX, -sphere.centerY, -sphere.centerZ);

  //视图矩阵  
  var viewMatrix = new Matrix4();
  var r = sphere.radius + 10;
  viewMatrix.lookAt(lightDirection.elements[0] * r, lightDirection.elements[1] * r, lightDirection.elements[2] * r, 0, 0, 0, 0, 1, 0);

  //投影矩阵
  var projMatrix = new Matrix4();
  var diameter = sphere.radius * 2.1;
  var ratioWH = canvas.width / canvas.height;
  var nearHeight = diameter;
  var nearWidth = nearHeight * ratioWH;
  projMatrix.setOrtho(-nearWidth / 2, nearWidth / 2, -nearHeight / 2, nearHeight / 2, 1, 10000);
  
  //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;通过模型变换，将世界坐标系的中心平移到包围球的中心。&lt;/li&gt;
&lt;li&gt;设置视图矩阵的时候将观察点放到这个(0,0,0)，也就是这个包围球中心；由于视野的方向也就是光线的方向知道，那么可以通过这个方向将视点位置设在与(0,0,0)相距比包围球半径远一点点的位置，就可以保证这个地形都能够被看见。&lt;/li&gt;
&lt;li&gt;通过包围球的直径，来计算正射投影的盒装可视空间的最小范围。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个时候的初始渲染状态为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201911/1000410-20191109220949166-1713860061.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 顶点着色器程序
var VSHADER_SOURCE =
  'attribute vec4 a_Position;\n' + //位置
  'attribute vec4 a_Color;\n' + //颜色
  'attribute vec4 a_Normal;\n' + //法向量
  'uniform mat4 u_MvpMatrix;\n' +
  'varying vec4 v_Color;\n' +
  'varying vec4 v_Normal;\n' +
  'void main() {\n' +
  '  gl_Position = u_MvpMatrix * a_Position;\n' + //设置顶点的坐标
  '  v_Color = a_Color;\n' +
  '  v_Normal = a_Normal;\n' +
  '}\n';

// 片元着色器程序
var FSHADER_SOURCE =
  'precision mediump float;\n' +
  'uniform vec3 u_DiffuseLight;\n' + // 漫反射光颜色
  'uniform vec3 u_LightDirection;\n' + // 漫反射光的方向
  'uniform vec3 u_AmbientLight;\n' + // 环境光颜色
  'varying vec4 v_Color;\n' +
  'varying vec4 v_Normal;\n' +
  'void main() {\n' +
  //对法向量归一化
  '  vec3 normal = normalize(v_Normal.xyz);\n' +
  //计算光线向量与法向量的点积
  '  float nDotL = max(dot(u_LightDirection, normal), 0.0);\n' +
  //计算漫发射光的颜色 
  '  vec3 diffuse = u_DiffuseLight * v_Color.rgb * nDotL;\n' +
  //计算环境光的颜色
  '  vec3 ambient = u_AmbientLight * v_Color.rgb;\n' +
  '  gl_FragColor = vec4(diffuse+ambient, v_Color.a);\n' +
  '}\n';

//定义一个矩形体：混合构造函数原型模式
function Cuboid(minX, maxX, minY, maxY, minZ, maxZ) {
  this.minX = minX;
  this.maxX = maxX;
  this.minY = minY;
  this.maxY = maxY;
  this.minZ = minZ;
  this.maxZ = maxZ;
}

Cuboid.prototype = {
  constructor: Cuboid,
  CenterX: function () {
    return (this.minX + this.maxX) / 2.0;
  },
  CenterY: function () {
    return (this.minY + this.maxY) / 2.0;
  },
  CenterZ: function () {
    return (this.minZ + this.maxZ) / 2.0;
  },
  LengthX: function () {
    return (this.maxX - this.minX);
  },
  LengthY: function () {
    return (this.maxY - this.minY);
  },
  LengthZ: function () {
    return (this.maxZ - this.minZ);
  }
}

//定义一个球体
function Sphere(cuboid) {
  this.centerX = cuboid.CenterX();
  this.centerY = cuboid.CenterY();
  this.centerZ = cuboid.CenterZ();
  this.radius = Math.max(Math.max(cuboid.LengthX(), cuboid.LengthY()), cuboid.LengthZ()) / 2.0;
}

Sphere.prototype = {
  constructor: Sphere
}

//定义DEM
function Terrain() { }
Terrain.prototype = {
  constructor: Terrain,
  setWH: function (col, row) {
    this.col = col;
    this.row = row;
  }
}

var currentAngle = [0.0, 0.0]; // 绕X轴Y轴的旋转角度 ([x-axis, y-axis])
var curScale = 1.0; //当前的缩放比例

function main() {
  var demFile = document.getElementById('demFile');
  if (!demFile) {
    console.log(&quot;Failed to get demFile element!&quot;);
    return;
  }

  demFile.addEventListener(&quot;change&quot;, function (event) {
    //判断浏览器是否支持FileReader接口
    if (typeof FileReader == 'undefined') {
      console.log(&quot;你的浏览器不支持FileReader接口！&quot;);
      return;
    }

    var input = event.target;
    var reader = new FileReader();
    reader.onload = function () {
      if (reader.result) {

        //读取
        var terrain = new Terrain();
        if (!readDEMFile(reader.result, terrain)) {
          console.log(&quot;文件格式有误，不能读取该文件！&quot;);
        }

        //绘制
        onDraw(gl, canvas, terrain);
      }
    }

    reader.readAsText(input.files[0]);
  });

  // 获取 &amp;lt;canvas&amp;gt; 元素
  var canvas = document.getElementById('webgl');

  // 获取WebGL渲染上下文
  var gl = getWebGLContext(canvas);
  if (!gl) {
    console.log('Failed to get the rendering context for WebGL');
    return;
  }

  // 初始化着色器
  if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
    console.log('Failed to intialize shaders.');
    return;
  }

  // 指定清空&amp;lt;canvas&amp;gt;的颜色
  gl.clearColor(0.0, 0.0, 0.0, 1.0);

  // 开启深度测试
  gl.enable(gl.DEPTH_TEST);

  //清空颜色和深度缓冲区
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}

//绘制函数
function onDraw(gl, canvas, terrain) {
  // 设置顶点位置
  var n = initVertexBuffers(gl, terrain);
  if (n &amp;lt; 0) {
    console.log('Failed to set the positions of the vertices');
    return;
  }

  //注册鼠标事件
  initEventHandlers(canvas);

  //设置灯光
  var lightDirection = setLight(gl);

  //绘制函数
  var tick = function () {
    //设置MVP矩阵
    setMVPMatrix(gl, canvas, terrain.sphere, lightDirection);

    //清空颜色和深度缓冲区
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //绘制矩形体
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);

    //请求浏览器调用tick
    requestAnimationFrame(tick);
  };

  //开始绘制
  tick();
}

//设置灯光
function setLight(gl) {
  var u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
  var u_DiffuseLight = gl.getUniformLocation(gl.program, 'u_DiffuseLight');
  var u_LightDirection = gl.getUniformLocation(gl.program, 'u_LightDirection');
  if (!u_DiffuseLight || !u_LightDirection || !u_AmbientLight) {
    console.log('Failed to get the storage location');
    return;
  }

  //设置漫反射光
  gl.uniform3f(u_DiffuseLight, 1.0, 1.0, 1.0);

  // 设置光线方向(世界坐标系下的)
  var solarAltitude = 45.0;
  var solarAzimuth = 315.0;
  var fAltitude = solarAltitude * Math.PI / 180; //光源高度角
  var fAzimuth = solarAzimuth * Math.PI / 180; //光源方位角

  var arrayvectorX = Math.cos(fAltitude) * Math.cos(fAzimuth);
  var arrayvectorY = Math.cos(fAltitude) * Math.sin(fAzimuth);
  var arrayvectorZ = Math.sin(fAltitude);

  var lightDirection = new Vector3([arrayvectorX, arrayvectorY, arrayvectorZ]);
  lightDirection.normalize(); // Normalize
  gl.uniform3fv(u_LightDirection, lightDirection.elements);

  //设置环境光
  gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);

  return lightDirection;
}

//读取DEM函数
function readDEMFile(result, terrain) {
  var stringlines = result.split(&quot;\n&quot;);
  if (!stringlines || stringlines.length &amp;lt;= 0) {
    return false;
  }

  //读取头信息
  var subline = stringlines[0].split(&quot;\t&quot;);
  if (subline.length != 6) {
    return false;
  }
  var col = parseInt(subline[4]); //DEM宽
  var row = parseInt(subline[5]); //DEM高
  var verticeNum = col * row;
  if (verticeNum + 1 &amp;gt; stringlines.length) {
    return false;
  }
  terrain.setWH(col, row);

  //读取点信息
  var ci = 0;
  var pSize = 9;
  terrain.verticesColors = new Float32Array(verticeNum * pSize);
  for (var i = 1; i &amp;lt; stringlines.length; i++) {
    if (!stringlines[i]) {
      continue;
    }

    var subline = stringlines[i].split(',');
    if (subline.length != pSize) {
      continue;
    }

    for (var j = 0; j &amp;lt; pSize; j++) {
      terrain.verticesColors[ci] = parseFloat(subline[j]);
      ci++;
    }
  }

  if (ci !== verticeNum * pSize) {
    return false;
  }

  //包围盒
  var minX = terrain.verticesColors[0];
  var maxX = terrain.verticesColors[0];
  var minY = terrain.verticesColors[1];
  var maxY = terrain.verticesColors[1];
  var minZ = terrain.verticesColors[2];
  var maxZ = terrain.verticesColors[2];
  for (var i = 0; i &amp;lt; verticeNum; i++) {
    minX = Math.min(minX, terrain.verticesColors[i * pSize]);
    maxX = Math.max(maxX, terrain.verticesColors[i * pSize]);
    minY = Math.min(minY, terrain.verticesColors[i * pSize + 1]);
    maxY = Math.max(maxY, terrain.verticesColors[i * pSize + 1]);
    minZ = Math.min(minZ, terrain.verticesColors[i * pSize + 2]);
    maxZ = Math.max(maxZ, terrain.verticesColors[i * pSize + 2]);
  }

  terrain.cuboid = new Cuboid(minX, maxX, minY, maxY, minZ, maxZ);
  terrain.sphere = new Sphere(terrain.cuboid);

  return true;
}


//注册鼠标事件
function initEventHandlers(canvas) {
  var dragging = false; // Dragging or not
  var lastX = -1,
    lastY = -1; // Last position of the mouse

  //鼠标按下
  canvas.onmousedown = function (ev) {
    var x = ev.clientX;
    var y = ev.clientY;
    // Start dragging if a moue is in &amp;lt;canvas&amp;gt;
    var rect = ev.target.getBoundingClientRect();
    if (rect.left &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; rect.right &amp;amp;&amp;amp; rect.top &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; rect.bottom) {
      lastX = x;
      lastY = y;
      dragging = true;
    }
  };

  //鼠标离开时
  canvas.onmouseleave = function (ev) {
    dragging = false;
  };

  //鼠标释放
  canvas.onmouseup = function (ev) {
    dragging = false;
  };

  //鼠标移动
  canvas.onmousemove = function (ev) {
    var x = ev.clientX;
    var y = ev.clientY;
    if (dragging) {
      var factor = 100 / canvas.height; // The rotation ratio
      var dx = factor * (x - lastX);
      var dy = factor * (y - lastY);
      currentAngle[0] = currentAngle[0] + dy;
      currentAngle[1] = currentAngle[1] + dx;
    }
    lastX = x, lastY = y;
  };

  //鼠标缩放
  canvas.onmousewheel = function (event) {
    if (event.wheelDelta &amp;gt; 0) {
      curScale = curScale * 1.1;
    } else {
      curScale = curScale * 0.9;
    }
  };
}

//设置MVP矩阵
function setMVPMatrix(gl, canvas, sphere, lightDirection) {
  // Get the storage location of u_MvpMatrix
  var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
  if (!u_MvpMatrix) {
    console.log('Failed to get the storage location of u_MvpMatrix');
    return;
  }

  //模型矩阵
  var modelMatrix = new Matrix4();
  modelMatrix.scale(curScale, curScale, curScale);
  modelMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0); // Rotation around x-axis 
  modelMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0); // Rotation around y-axis 
  modelMatrix.translate(-sphere.centerX, -sphere.centerY, -sphere.centerZ);

  /*
  //----------------------透视---------------------
  //投影矩阵
  var fovy = 60;
  var projMatrix = new Matrix4();
  projMatrix.setPerspective(fovy, canvas.width / canvas.height, 1, 10000);

  //计算lookAt()函数初始视点的高度
  var angle = fovy / 2 * Math.PI / 180.0;
  var eyeHight = (sphere.radius * 2 * 1.1) / 2.0 / angle;

  //视图矩阵  
  var viewMatrix = new Matrix4(); // View matrix   
  viewMatrix.lookAt(0, 0, eyeHight, 0, 0, 0, 0, 1, 0);
  //----------------------透视---------------------
  */
  
  //----------------------正射---------------------
  //视图矩阵  
  var viewMatrix = new Matrix4();
  var r = sphere.radius + 10;
  viewMatrix.lookAt(lightDirection.elements[0] * r, lightDirection.elements[1] * r, lightDirection.elements[2] * r, 0, 0, 0, 0, 1, 0);

  //投影矩阵
  var projMatrix = new Matrix4();
  var diameter = sphere.radius * 2.1;
  var ratioWH = canvas.width / canvas.height;
  var nearHeight = diameter;
  var nearWidth = nearHeight * ratioWH;
  projMatrix.setOrtho(-nearWidth / 2, nearWidth / 2, -nearHeight / 2, nearHeight / 2, 1, 10000);
  //----------------------正射---------------------
 
  //MVP矩阵
  var mvpMatrix = new Matrix4();
  mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);

  //将MVP矩阵传输到着色器的uniform变量u_MvpMatrix
  gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
}

//
function initVertexBuffers(gl, terrain) {
  //DEM的一个网格是由两个三角形组成的
  //      0------1            1
  //      |                   |
  //      |                   |
  //      col       col------col+1    
  var col = terrain.col;
  var row = terrain.row;

  var indices = new Uint16Array((row - 1) * (col - 1) * 6);
  var ci = 0;
  for (var yi = 0; yi &amp;lt; row - 1; yi++) {
    //for (var yi = 0; yi &amp;lt; 10; yi++) {
    for (var xi = 0; xi &amp;lt; col - 1; xi++) {
      indices[ci * 6] = yi * col + xi;
      indices[ci * 6 + 1] = (yi + 1) * col + xi;
      indices[ci * 6 + 2] = yi * col + xi + 1;
      indices[ci * 6 + 3] = (yi + 1) * col + xi;
      indices[ci * 6 + 4] = (yi + 1) * col + xi + 1;
      indices[ci * 6 + 5] = yi * col + xi + 1;
      ci++;
    }
  }

  //
  var verticesColors = terrain.verticesColors;
  var FSIZE = verticesColors.BYTES_PER_ELEMENT; //数组中每个元素的字节数

  // 创建缓冲区对象
  var vertexColorBuffer = gl.createBuffer();
  var indexBuffer = gl.createBuffer();
  if (!vertexColorBuffer || !indexBuffer) {
    console.log('Failed to create the buffer object');
    return -1;
  }

  // 将缓冲区对象绑定到目标
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
  // 向缓冲区对象写入数据
  gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);

  //获取着色器中attribute变量a_Position的地址 
  var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
  if (a_Position &amp;lt; 0) {
    console.log('Failed to get the storage location of a_Position');
    return -1;
  }
  // 将缓冲区对象分配给a_Position变量
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);

  // 连接a_Position变量与分配给它的缓冲区对象
  gl.enableVertexAttribArray(a_Position);

  //获取着色器中attribute变量a_Color的地址 
  var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
  if (a_Color &amp;lt; 0) {
    console.log('Failed to get the storage location of a_Color');
    return -1;
  }
  // 将缓冲区对象分配给a_Color变量
  gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);
  // 连接a_Color变量与分配给它的缓冲区对象
  gl.enableVertexAttribArray(a_Color);

  // 向缓冲区对象分配a_Normal变量,传入的这个变量要在着色器使用才行
  var a_Normal = gl.getAttribLocation(gl.program, 'a_Normal');
  if (a_Normal &amp;lt; 0) {
    console.log('Failed to get the storage location of a_Normal');
    return -1;
  }
  gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);
  //开启a_Normal变量
  gl.enableVertexAttribArray(a_Normal);

  // 将顶点索引写入到缓冲区对象
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  return indices.length;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本来部分代码和插图来自《WebGL编程指南》，源代码链接：&lt;a href=&quot;https://github.com/fafa1899/WebGLTutorial&quot;&gt;地址&lt;/a&gt; 。会在此共享目录中持续更新后续的内容。&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://blog.csdn.net/qq_29523119/article/details/53056755&quot;&gt;Directx11教程三十一之ShadowMap(阴影贴图)之平行光成影&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 14:11:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>通过包围球来设置模型视图投影变换，显示合适的渲染位置。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlee44/p/11828120.html</dc:identifier>
</item>
<item>
<title>机器学习基础知识整理归纳 - GOLDEN_STAGE</title>
<link>http://www.cnblogs.com/my-python-learning/p/11827852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/my-python-learning/p/11827852.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;1.机器学习是一门致力于研究如何通过计算的手段，利用经验来改善系统自身的性能的学科。1997年Mitchell给出一个更形式化的定义，假设用P来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验E在T中任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”的算法，即学习算法(learning algorithm)。“数据”即是现实生活中的“经验”。&lt;/li&gt;
&lt;li&gt;关于产生的模型（model），可以泛指从数据中学得的结果。但也有不同说法。Hand在2001年发表的一篇文献中就提到，模型是全局结果（例如一颗决策树），模式指的是局部性结果（例如一条规则）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基本术语&quot;&gt;2. 基本术语&lt;/h2&gt;
&lt;p&gt;引例，假设搜集到一些关于西瓜的数据（色泽 = 青绿；根蒂 = 蜷缩；敲声 = 浊响），（色泽 = 乌黑；根蒂 = 稍蜷；敲声 = 沉闷），（色泽 = 浅白；根蒂 = 硬挺；敲声 = 清脆），......&lt;/p&gt;
&lt;p&gt;上述引例中，每对括号内是关于西瓜的（也可是任何一个事件或者对象的）一条记录，则有：&lt;/p&gt;
&lt;p&gt;数据集 (data set)： 一组记录的集合&lt;/p&gt;
&lt;p&gt;示例/样本(instance/sample)：上述都每一条记录，均可称为示例/样本&lt;/p&gt;
&lt;p&gt;属性/特征(attribute/feature)：反映事件或者对象在某方面的表现或者性质的事项。例如上述色泽，根蒂，敲声&lt;/p&gt;
&lt;p&gt;属性值(attribute value)： 属性上的取值，例如青绿，乌黑，等等&lt;/p&gt;
&lt;p&gt;特征向量(feature vector)： 属性空间上每一个点相对原点构成的坐标向量&lt;/p&gt;
&lt;p&gt;样本维数(sample dimensionality)： 每一个样本（示例）所包含的不同属性的数量&lt;/p&gt;
&lt;p&gt;学习/训练(learning/training) ： 从数据中学得模型的过程&lt;/p&gt;
&lt;p&gt;训练数据(training data)： 训练过程中使用的数据&lt;/p&gt;
&lt;p&gt;训练样本(training sample)： 训练数据中的样本&lt;/p&gt;
&lt;p&gt;训练集(training set)： 训练样本的集合&lt;/p&gt;
&lt;p&gt;假设(hypothesis)： 值得是学得模型。因为这个模型对应了关于数据的某种潜在规律&lt;/p&gt;
&lt;p&gt;真相/真实(ground-truth)： 潜在规律本身&lt;/p&gt;
&lt;p&gt;标记(label)： 训练样本的结果信息&lt;/p&gt;
&lt;p&gt;样例(example)： 拥有了标记信息的示例。一般的，用（&lt;span class=&quot;math inline&quot;&gt;\(x_i,y_i\)&lt;/span&gt;）来表示第i个样例。其中&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;是示例&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;的标记&lt;/p&gt;
&lt;p&gt;标记空间/输出集合(label space)： 所有标记的集合&lt;/p&gt;
&lt;p&gt;属性空间/样本空间/输入空间(attribute/sample space)： 属性张成的空间。例如，如果把色泽，根蒂，敲声作为三个坐标轴，则他们张成一个用于描述西瓜的三维空间，每个西瓜都可以找到自己的位置。&lt;/p&gt;
&lt;p&gt;分类(classification)： 在关于利用训练集学得的预测模型中，预测值是离散值。这样的学习任务称为分类&lt;/p&gt;
&lt;p&gt;回归(regression)： 与分类相似，只是预测值是连续值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\({\color{red} 补充一句：（预测的任务是希望通过对训练集{(x_1,y_1),(x_2,y_2),...}进行学习，建立一个从输入空间到输出空间的映射关系）}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二分类任务(binary classification)： 预测结果只有两个类别。通常将其中的一个称为正类(positive class)，另一个称为反类(negative class)。而涉及多个，类别则称为多分类(multi-class)任务&lt;/p&gt;
&lt;p&gt;测试(testing)： 学得模型以后，使用其进行预测的过程&lt;/p&gt;
&lt;p&gt;测试样本(testing sample)： 被预测的样本，例如，在学得&lt;span class=&quot;math inline&quot;&gt;\(\mathit{f}\)&lt;/span&gt; 以后，对测试例&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; 可得到其预测标记&lt;span class=&quot;math inline&quot;&gt;\(y=f(x_i)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;聚类(clustering)： 将训练集中的示例分成若干组，每组称为一个簇(cluster)。这些自动形成的簇可能对应一些潜在的概念划分，例如本例中的西瓜可以分成浅色瓜，深色瓜...在聚类学习中，这些浅色瓜，深色瓜的概念事先是不知道的，而且学习过程中使用的训练样本通常也没有标记信息&lt;/p&gt;
&lt;p&gt;​ 学习任务大致可以划分成两类：&lt;/p&gt;
&lt;p&gt;（1）监督学习（supervised learning）:训练数据带有标记，例如分类与分归&lt;/p&gt;
&lt;p&gt;（2）无监督学习（unsupervised learning）:训练数据不带有标记，例如聚类&lt;/p&gt;
&lt;p&gt;泛化能力： 学得模型适用于新样本的能力&lt;/p&gt;
&lt;p&gt;（目前机器学习仍然假设样本空间的全体样本满足独立同分布假设，因此经典概率论得以适用）&lt;/p&gt;
&lt;h2 id=&quot;假设空间&quot;&gt;3.假设空间&lt;/h2&gt;
&lt;p&gt;​ 前言：归纳（induction）和假设(deduction)是科学推理的两大基本手段。前者是从特殊到一般的泛化（generalization），即从具体的事实归结出一般性规律；后者则是从一般到特殊的特化(specialization)过程，即从基础原理推演出具体状况。 在机器学习中，“从样例中学习”显然是一个归纳过程。因此，又被称为归纳学习（inductive learning）&lt;/p&gt;
&lt;p&gt;广义的归纳学习：相当于从样例中学习&lt;/p&gt;
&lt;p&gt;狭义的归纳学习：从训练数据中学得概念(concept)。因此也称为“概念学习”或者“概念形成” .概念学习中最基本的是布尔概念学习，即是或者不是的结果表述&lt;/p&gt;
&lt;p&gt;假设空间（hypothesis space）： 所有假设组成的空间&lt;/p&gt;
&lt;p&gt;​ 我们可以将学习的过程看作一个在所有假设组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设，即能够将训练集中的样本判断正确的假设，假设的表示一旦确定，假设空间及其规模大小就确定了。&lt;/p&gt;
&lt;p&gt;​ 可以有许多策略对假设空间进行搜索，搜索过程中可以不断删除与正例不一致的假设，或者与反例一致的假设。最终将会获得与训练集一致的假设，就这是学得的结果。&lt;/p&gt;
&lt;p&gt;版本空间(version space)：现实生活中，我们常常面临很大的假设空间，但是学习的过程是基于有限的样本训练集进行的，因此，可能有多个假设与训练集一致，即存在一个与训练集一致的假设集合，这个假设集合就是版本空间&lt;/p&gt;
&lt;h2 id=&quot;归纳偏好&quot;&gt;4.归纳偏好&lt;/h2&gt;
&lt;p&gt;​ 归纳偏好（inductive bias）：机器学习算法在学习过程中对某种类型假设的偏好。偏好要起作用，是发生在形成版本空间的时候。而学习算法又必须产生一个模型。这样，偏好会起作用&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\({\color{red}任何一个有效的机器学习算法都必有其偏好，否则它将被假设空间中看似在训练集上等效的假设所迷惑，而无法产生正确的学习结果}\)&lt;/span&gt; 对于归纳偏好的看法: 归纳偏好可以看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或价值观。有一个一般性的原则来引导算法确立正确的偏好，即&lt;/p&gt;
&lt;p&gt;奥卡姆剃刀（Occam's razor）：若有多个假设与观察一致，则选择最简单的那个。&lt;span class=&quot;math inline&quot;&gt;\({\color{red}然而奥卡姆原则并非唯一可用原则}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;事实上，归纳偏好对应了学习算法本身所做出的关于&quot;什么样的模型更好的假设&quot;。在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能。&lt;/p&gt;
&lt;p&gt;​ 假设学习算法&lt;span class=&quot;math inline&quot;&gt;\(\zeta_a\)&lt;/span&gt; 是基于某种归纳偏好产生的模型，学习算法&lt;span class=&quot;math inline&quot;&gt;\(\zeta_b\)&lt;/span&gt;是基于另一种归纳偏好产生的模型。对于学习算法&lt;span class=&quot;math inline&quot;&gt;\(\zeta_a\)&lt;/span&gt;若它在某些问题上比学习算法&lt;span class=&quot;math inline&quot;&gt;\(\zeta_b\)&lt;/span&gt;好，则必然存在一个问题，&lt;span class=&quot;math inline&quot;&gt;\(\zeta_a\)&lt;/span&gt;比&lt;span class=&quot;math inline&quot;&gt;\(\zeta_b\)&lt;/span&gt;好在哪里？根据NFL定理，无论两种算法怎样产生，两者出错概论的期望是相同的（但是NFL定理前提是，所有问题出现的机会相同，或者所有问题同等重要，但是实际情形我们只需要关注我们目前试图解决的问题即可，因此&lt;span class=&quot;math inline&quot;&gt;\(\zeta_a\)&lt;/span&gt;与$ \zeta_b$ 还是有区别的。NFL定理其实是想说明，脱离具体问题讨论学习算法好坏是无意义的。学习算法自身的归纳偏好与问题是否匹配，往往起到决定性作用。）&lt;/p&gt;
</description>
<pubDate>Sat, 09 Nov 2019 12:59:00 +0000</pubDate>
<dc:creator>GOLDEN_STAGE</dc:creator>
<og:description>关于机器学习的一些基本概念的整理 1.前言 1.机器学习是一门致力于研究如何通过计算的手段，利用经验来改善系统自身的性能的学科。1997年Mitchell给出一个更形式化的定义，假设用P来评估计算机程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/my-python-learning/p/11827852.html</dc:identifier>
</item>
</channel>
</rss>