<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Posix信号量 - 原野追逐</title>
<link>http://www.cnblogs.com/songhe364826110/p/11520386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songhe364826110/p/11520386.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;以下三种类型的IPC合称为Posix IPC：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Posix信号量&lt;/li&gt;
&lt;li&gt;Posix消息队列&lt;/li&gt;
&lt;li&gt;Posix共享内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Posix IPC在访问它们的函数和描述它们的信息上有一些类似点，主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IPC名字&lt;/li&gt;
&lt;li&gt;创建或打开时指定的读写权限、创建标志以及用户访问权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下表汇总了所有Posix IPC函数。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;头文件&lt;/td&gt;
&lt;td&gt;semaphore.h&lt;/td&gt;
&lt;td&gt;mqueue.h&lt;/td&gt;
&lt;td&gt;sys/mman.h&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;8&quot;&gt;&lt;td&gt;创建、打开或删除IPC的函数&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt;sem_open&lt;br/&gt;sem_close&lt;br/&gt;sem_unlink&lt;br/&gt; &lt;br/&gt;sem_init&lt;br/&gt;sem_destroy&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;mq_open&lt;br/&gt;mq_close&lt;br/&gt;mq_unlink&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt;shm_open&lt;br/&gt;shm_unlink&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;控制IPC操作的函数&lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt;mq_getattr&lt;br/&gt;mq_setattr&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;ftruncate&lt;br/&gt;fstat&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;IPC操作函数&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt;sem_wait&lt;br/&gt;sem_trywait&lt;br/&gt;sem_post&lt;br/&gt;sem_getvalue&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;mq_send&lt;br/&gt;mq_receive&lt;br/&gt;mq_notify&lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;td&gt;mmap&lt;br/&gt;munmap&lt;br/&gt; &lt;br/&gt; &lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;ipc名字&quot;&gt;IPC名字&lt;/h2&gt;
&lt;p&gt;除了Posix无名信号量，其余三种类型的Posix IPC都使用&quot;Posix IPC&quot;名字进行标识，&lt;span&gt;它可能是文件系统中真实存在的一个路径名，也可能不是。&lt;/span&gt;Posix.1是这么描述的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它必须符合系统规定的路径名规则&lt;/li&gt;
&lt;li&gt;如果它以斜杠符开头，那么Posix IPC函数的不同调用将访问同一个IPC对象；否则，具体效果取决于系统实现&lt;/li&gt;
&lt;li&gt;对IPC名字中额外斜杠符的解释取决于系统实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，&lt;span&gt;为了便于代码移植&lt;/span&gt;，通常在实际项目中遵循下面两条规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Posix IPC名字&lt;span&gt;必须以一个斜杠符开头，且不能再含有任何其他斜杠符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;把所有Posix IPC名字的宏定义&lt;span&gt;统一放在一个便于修改的头文件中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建与打开ipc&quot;&gt;创建与打开IPC&lt;/h2&gt;
&lt;p&gt;以下是三种Posix IPC的创建与打开函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sem_open&lt;/code&gt;用于创建或打开一个Posix有名信号量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mq_open&lt;/code&gt;用于创建或打开一个Posix消息队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shm_open&lt;/code&gt;用于创建或打开一个Posix共享内存&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;读写权限与创建标志&quot;&gt;读写权限与创建标志&lt;/h3&gt;
&lt;p&gt;这三个函数的第二个参数都是oflag，作用是指定IPC的读写权限与创建标志，下表给出了可组合构成该参数的所有常值。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;只读&lt;br/&gt;只写&lt;br/&gt;读写&lt;br/&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;O_RDONLY&lt;br/&gt;O_WRONLY&lt;br/&gt;O_RDWR&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;O_RDONLY&lt;p&gt;O_RDWR&lt;br/&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;若不存在则创建&lt;br/&gt;排他性创建&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;O_CREAT&lt;br/&gt;O_EXCL&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;O_CREAT&lt;br/&gt;O_EXCL&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;O_CREAT&lt;br/&gt;O_EXCL&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;非阻塞模式&lt;br/&gt;若已存在则截短&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;O_NONBLOCK&lt;br/&gt;O_EXCL&lt;br/&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;&lt;br/&gt;O_TRUNC&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;前三行指定读写权限：只读、只写、读写，从表中可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;有名信号量不指定该标志&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;消息队列可指定任意模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;共享内存不能以只写方式打开&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后面四行指定创建标志：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;O_CREAT&lt;/code&gt;：&lt;span&gt;若函数第一个参数指定的IPC不存在，则进行创建，&lt;/span&gt;此时至少需要第三个参数mode指定用户访问权限（详见后续）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O_EXCL&lt;/code&gt;：如果和O_CREAT一起指定，那么当IPC已存在且指定了O_CREAT | O_EXCL标志时，会出错返回EEXIST&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O_NONBLOCK&lt;/code&gt;：仅适用于Posix消息队列，作用是&lt;span&gt;队列为空时的读操作&lt;/span&gt;和&lt;span&gt;队列为满时的写操作&lt;/span&gt;不会阻塞&lt;/li&gt;
&lt;li&gt;O_TRUNC：仅适用于Posix共享内存，作用是&lt;span&gt;当共享内存对象已存在时，将其长度截为0&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用户访问权限&quot;&gt;用户访问权限&lt;/h3&gt;
&lt;p&gt;创建一个新的Posix IPC时，需要使用第三个参数指定用户访问权限，它是由下表所示常值按位或构成的，&lt;span&gt;常值的格式为S_IRXXX和S_IWXXX，其中XXX代表访问用户。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;S_IRUSR&lt;br/&gt;S_IWUSR&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;用户读&lt;br/&gt;用户写&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;S_IRGRP&lt;br/&gt;S_IWGRP&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;组成员读&lt;br/&gt;组成员写&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;S_IROTH&lt;br/&gt;S_IWOTH&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;其他用户读&lt;br/&gt;其他用户写&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;ipc对象的持续性&quot;&gt;IPC对象的持续性&lt;/h2&gt;
&lt;p&gt;IPC对象的持续性，指的是该类型的一个对象一直存在多长时间，IPC的持续性有三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随进程持续：IPC对象一直存在到&lt;span&gt;打开该对象的最后一个进程关闭&lt;/span&gt;该对象&lt;/li&gt;
&lt;li&gt;随内核持续：IPC对象一直存在到&lt;span&gt;内核重新自举&lt;/span&gt;或&lt;span&gt;显式删除该对象&lt;/span&gt;为止&lt;/li&gt;
&lt;li&gt;随文件系统持续：IPC对象一直存在到&lt;span&gt;显式删除该对象&lt;/span&gt;为止，&lt;span&gt;即使内核重新自举，该对象依然存在&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在默认情况下，除了Posix无名信号量是随进程持续，其余所有Posix IPC和System V IPC都是随内核持续。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;信号量定义及分类&quot;&gt;信号量定义及分类&lt;/h2&gt;
&lt;p&gt;信号量是一种用于进程间同步或线程间同步的机制，共有三种类型的信号量IPC：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Posix有名信号量&lt;/li&gt;
&lt;li&gt;Posix无名信号量&lt;/li&gt;
&lt;li&gt;System V信号量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按信号量值的范围，可分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录信号量：信号量的值可以为负数，负数的绝对值代表当前因等待该信号量的值变为正数而阻塞的进程和线程数&lt;/li&gt;
&lt;li&gt;计数信号量：&lt;span&gt;信号量的值必须是非负整数，&lt;/span&gt;二值信号量（信号量值只能为0或1）是其特殊情况，&lt;span&gt;&lt;strong&gt;Linux采用计数信号量&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;信号量操作&quot;&gt;信号量操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建（create）：创建信号量时需要指定初始值&lt;/li&gt;
&lt;li&gt;等待（wait）：也叫P操作，若信号量的值大于0就将它减1并结束操作，否则就阻塞等待&lt;/li&gt;
&lt;li&gt;挂出（post）：也叫V操作，该操作将信号量的值加1&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;信号量互斥锁和条件变量的差异&quot;&gt;信号量、互斥锁和条件变量的差异&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;互斥锁必须由给他上锁的线程解锁，而信号量的等待和挂出没有这种限制&lt;/li&gt;
&lt;li&gt;互斥锁只有上锁和解锁两种状态，信号量可以有多个状态，因为信号量的值可以有多个&lt;/li&gt;
&lt;li&gt;信号量挂出后的状态是持续的，即使挂出时没有线程阻塞于该信号量，挂出操作也不会丢失&lt;/li&gt;
&lt;li&gt;条件变量给线程发信号时，若没有相应的线程阻塞，那么给该信号将会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Posix有名信号量由IPC路径名标识，因此它&lt;span&gt;天生既可用于线程同步，又可用于进程同步，&lt;/span&gt;相关API在头文件&lt;code&gt;&amp;lt;semaphore.h&amp;gt;&lt;/code&gt;中，编译时需要指定链接&lt;code&gt;-lrt&lt;/code&gt;或&lt;code&gt;-pthread&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;创建和打开&quot;&gt;创建和打开&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sem_open&lt;/code&gt;用于创建一个新的信号量或打开一个已存在的信号量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//成功返回信号量指针，失败返回SEM_FAILED，链接时需指定 -lrt or -pthread
sem_t *sem_open(const char *name, int oflag, ... /*mode_t mode, unsigned int value*/);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数参数说明在概述中基本都有介绍，这里不再赘述，只强调两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;oflag只能指定为&lt;span&gt;0、O_CREAT或O_CREAT | O_EXCL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;value为&lt;span&gt;信号量的初始值，&lt;/span&gt;可设范围为&lt;span&gt;[0, SEM_VALUE_MAX]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Linux中，&lt;span&gt;创建的Posix有名信号量存放在&lt;code&gt;/dev/shm/&lt;/code&gt;目录下，&lt;/span&gt;可通过ls命令查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190914214233944-1999109560.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;semaphore.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;           /* For O_* constants */
#include &amp;lt;sys/stat.h&amp;gt;        /* For mode constants */
#include &amp;lt;stdio.h&amp;gt;

#define POSIX_SEM_NAME  &quot;sem_test&quot;

int main()
{
    sem_t *sem = sem_open(POSIX_SEM_NAME, O_CREAT, 0666, 1);
    
    if (sem != SEM_FAILED)
    {
        printf(&quot;sem_open() success\n&quot;);
    } 
    
    return 0;   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190914214251636-576040186.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关闭和删除&quot;&gt;关闭和删除&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//两个函数返回值：成功返回0，失败返回-1
int sem_close(sem_t *sem);
int sem_unlink(const char *name);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sem_close&lt;/code&gt;用于关闭已经打开的有名信号量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sem_unlink&lt;/code&gt;用于从系统中删除有名信号量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进程终止时，会自动关闭所有已打开的IPC对象（包括有名信号量、消息队列和共享内存），但关闭不等于删除，因为它们都至少具有随内核的持续性，这一点从上面示例代码的执行结果也可以看出来——进程已终止，但/dev/shm/目录下刚刚创建的信号量依然存在。事实上，&lt;span&gt;所有以路径名标识的Posix IPC都有一个引用计数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;close和unlink会使引用计数减1&lt;/li&gt;
&lt;li&gt;&lt;span&gt;IPC名字本身也占用一个引用计数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当引用计数大于0时，unlink就能够从文件系统中删除IPC对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果在引用计数大于1时调用unlink，IPC对象会被删除，但不会被析构&lt;/li&gt;
&lt;li&gt;&lt;span&gt;只有当引用计数变为0，即在引用计数为1时调用unlink，内核才会对IPC对象进行析构&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;semaphore.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;           /* For O_* constants */
#include &amp;lt;sys/stat.h&amp;gt;        /* For mode constants */
#include &amp;lt;stdio.h&amp;gt;

#define POSIX_SEM_NAME  &quot;sem_test&quot;

int main()
{
    sem_t *sem = sem_open(POSIX_SEM_NAME, O_CREAT, 0666, 1);
    
    if (sem != SEM_FAILED)
    {
        printf(&quot;sem_open() success\n&quot;);
        
        printf(&quot;before sem_unlink()\n&quot;);
        system(&quot;ls /dev/shm/&quot;);
        
        sem_close(sem);
        sem_unlink(POSIX_SEM_NAME);
        
        printf(&quot;after sem_unlink()\n&quot;);
        system(&quot;ls /dev/shm/&quot;);
    } 
    
    return 0;   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190914214312757-1612763475.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;等待和挂出&quot;&gt;等待和挂出&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//两个函数返回值：成功返回0，失败返回-1
int sem_wait(sem_t *sem);
int sem_post(sem_t *name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sem_wait&lt;/code&gt;用于等待有名信号量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若信号量的值等于0，调用线程将阻塞，直到该值变为大于0&lt;/li&gt;
&lt;li&gt;若信号量的值大于0，就将它减1并立即返回&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;sem_post&lt;/code&gt;用于挂出有名信号量，该函数把信号量的值加1，然后阻塞于sem_wait等待该信号量的线程就能够被唤醒。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;semaphore.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#define POSIX_SEM_NAME  &quot;sem_test&quot;

pthread_t tid[2];
sem_t *sem;

/*thread0先处理自己的工作，之后调用sem_post将信号量的值加1，通知thread1可以执行了*/
void *thread0(void *arg)
{
    int value;
    
    while (1)
    {
        /* do work thread0 */
        
        sem_post(sem);
        sem_getvalue(sem, &amp;amp;value);
        printf(&quot;thread 0: sem value is %d\n&quot;, value);
        sleep(2);
    }
}

/*thread1等待时间比thread0少，但也必须等待thread0调用sem_post将信号量的值加1，才能继续执行*/
void *thread1(void *arg)
{
    int value;
    
    while (1)
    {
        sem_wait(sem);
        sem_getvalue(sem, &amp;amp;value);
        printf(&quot;thread 1: sem value is %d\n&quot;, value);
        sleep(1);
    } 
}

int main()
{    
    sem = sem_open(POSIX_SEM_NAME, O_CREAT, 0666, 0);
     
    pthread_create(&amp;amp;tid[0], NULL, thread0, NULL);
    pthread_create(&amp;amp;tid[1], NULL, thread1, NULL);  
    sleep(10);

    pthread_cancel(tid[0]);
    pthread_join(tid[0], NULL);
    
    pthread_cancel(tid[1]);
    pthread_join(tid[1], NULL);
    
    sem_close(sem);
    sem_unlink(POSIX_SEM_NAME);
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190914214331148-1017761275.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取信号量的值&quot;&gt;获取信号量的值&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//成功返回0，失败返回-1
int sem_getvalue(sem_t *sem, int *sval);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sem_getvalue&lt;/code&gt;用于获取信号量sem的当前值，该值通过参数sval返回。如果有线程或进程正阻塞于sem_wait，POSIX.1-2001允许通过sval返回两种结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;返回0，这也是Linux的选择，因为Linux采用计数信号量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;返回一个负值，其绝对值代表当前阻塞于sem_wait调用的进程和线程数，对应记录信号量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Posix无名信号量是基于内存的信号量，也就是说它没有IPC路径名，而是像普通变量一样创建在内存中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Posix无名信号量由&lt;code&gt;sem_init&lt;/code&gt;初始化，由&lt;code&gt;sem_destroy&lt;/code&gt;销毁&lt;/li&gt;
&lt;li&gt;Posix无名信号量没有close和unlink之分，销毁即彻底删除&lt;/li&gt;
&lt;li&gt;Posix无名信号量等待、挂出、获取信号量的值使用和有名信号量相同的API&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//两个函数返回值：成功返回0，失败返回-1
int sem_init(sem_t *sem, int shared, unsigned int value);
int sem_destroy(sem_t *sem);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sem_init的sem参数指向要初始化的信号量，&lt;span&gt;shared参数用于指定信号量在线程间共享还是在进程间共享：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shared = 0：&lt;span&gt;在线程间共享&lt;/span&gt;，信号量创建在&lt;span&gt;当前进程地址空间中，&lt;/span&gt;可用于&lt;span&gt;线程间同步，随进程持续&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;shared ≠ 0：&lt;span&gt;在进程间共享，&lt;/span&gt;信号量&lt;span&gt;必须创建在共享内存中，&lt;/span&gt;可用于&lt;span&gt;进程间同步，随内核持续&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，线程间同步使用有名信号量和无名信号量都可以，而进程间同步直接使用有名信号量就可以了，除非对通讯速度有特殊需求，才考虑shared ≠ 0的无名信号量。&lt;/p&gt;
&lt;p&gt;把第3章的示例代码改为使用shared = 0的无名信号量，只有main函数发生了变动，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{    
    sem = (sem_t *)malloc(sizeof(sem_t)); //这里使用动态分配，也可以使用静态分配sem，然后给sem_init传&amp;amp;sem
    sem_init(sem, 0, 0);
     
    pthread_create(&amp;amp;tid[0], NULL, thread0, NULL);
    pthread_create(&amp;amp;tid[1], NULL, thread1, NULL);  
    sleep(10);

    pthread_cancel(tid[0]);
    pthread_join(tid[0], NULL);
    
    pthread_cancel(tid[1]);
    pthread_join(tid[1], NULL);
    
    free(sem);
    sem_destroy(sem);
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1053346/201909/1053346-20190914214348212-1301643382.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Posix定义了两个信号量限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SEM_NSEMS_MAX&lt;/code&gt;：一个进程可同时打开的最大信号量个数，该值至少为256&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEM_VALUE_MAX&lt;/code&gt;：信号量的最大值，该值至少为32767&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 15 Sep 2019 00:37:00 +0000</pubDate>
<dc:creator>原野追逐</dc:creator>
<og:description>[TOC] 1. Posix IPC 概述 以下三种类型的IPC合称为Posix IPC： Posix信号量 Posix消息队列 Posix共享内存 Posix IPC在访问它们的函数和描述它们的信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songhe364826110/p/11520386.html</dc:identifier>
</item>
<item>
<title>C# 表达式树讲解（一） - 园子的蜗牛</title>
<link>http://www.cnblogs.com/snailblog/p/11521043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snailblog/p/11521043.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;一直想写一篇Dpper的定制化扩展的文章，但是里面会设计到对Lambda表达式的解析，而解析Lambda表达式，就必须要知道表达式树的相关知识点。我希望能通过对各个模块的知识点或者运用能够多一点的讲解，能够帮助到园友了解得更多。虽然讲解得不全面，如果能成为打开这块的一把钥匙，也是蜗牛比较欣慰的。&lt;/p&gt;
&lt;h2&gt;二、表达树理解&lt;/h2&gt;
&lt;p&gt;表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，它将我们原来可以直接由代码编写的逻辑以表达式的方式存储在树状的结构里，从而可以在运行时去解析这个树，然后执行，实现动态的编辑和执行代码。在.Net 里面的Linq to SQL就是对表达式树的解析。&lt;/p&gt;
&lt;p&gt;这里先讲解下表达式和表达式树，表达式相信大家都知道，比如x+5或者5，都可以算是表达式，而表达式树里面的树指的二叉树，也就是表达式的集合，C#中的Expression类就是表达式类。对于一棵表达式树，其叶子节点都是参数或者常数，非叶子节点都是运算符或者控制符。&lt;/p&gt;
&lt;h3&gt;2.1、表达式的创建&lt;/h3&gt;
&lt;p&gt;Lambda表达式方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Expression&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;,&lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; fun = (x, y) =&amp;gt; x &amp;lt; y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法创建出的表达式根节点类型为ExpressionType.Lambda，Type类型为返回值类型typeof(bool)&lt;/p&gt;
&lt;p&gt;组装法（通过 API 创建表达式树）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
ParameterExpression numParam = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &quot;&lt;span&gt;num&lt;/span&gt;&quot;);
ConstantExpression five = Expression.Constant(5, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));
BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);
Expression&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; lambda1 =
    Expression.Lambda&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;(
        numLessThanFive,
        &lt;span&gt;new&lt;/span&gt; ParameterExpression[] { numParam });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先创建了两个参数表达式num和5，然后用LessThan组装在一起，最终的表达式为“num&amp;lt;5”，expr的节点类型为LessThan，Type类型为typeof(bool)&lt;/p&gt;
&lt;p&gt;我们先看看表达式树里面的构造&lt;/p&gt;
&lt;p&gt;首先Expression&amp;lt;TDelegate&amp;gt;的功能是将强类型Lambda表达式表示为表达式树形式的数据结构，他的父类是LambdaExpression，比较他们代码可知，Lambda表达式的主体，名称和参数全部保存在LambdaExpression里面。&lt;/p&gt;
&lt;p&gt;Expression&amp;lt;TDelegate&amp;gt;与LambdaExpression代码截图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071754137-2086334705.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071754702-320340030.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071755051-290137207.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071755512-1913334399.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;376&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LambdaExpression里面的Body就是我们的表达式。&lt;/p&gt;
&lt;p&gt;C#表达式给我们提供了丰富的表达式类，进入到LambdaExpression类里面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071756183-938814028.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071757015-1549131452.png&quot; alt=&quot;image&quot; width=&quot;542&quot; height=&quot;373&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方法返回类型以“Expression”结尾的，基本上都是一个表达式类。&lt;/p&gt;
&lt;p&gt;每个表达式代表的定义和创建方法，可以参照微软官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.binaryexpression?view=netframework-4.8&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.binaryexpression?view=netframework-4.8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是平常使用最多的表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConstantExpression&lt;/span&gt;：常量表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ParameterExpression&lt;/span&gt;：参数表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UnaryExpression&lt;/span&gt;：一元运算符表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BinaryExpression&lt;/span&gt;：二元运算符表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TypeBinaryExpression&lt;/span&gt;：is运算符表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConditionalExpression&lt;/span&gt;：条件表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MemberExpression&lt;/span&gt;：访问字段或属性表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MethodCallExpression&lt;/span&gt;：调用成员函数表达式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Expression&amp;lt;TDelegate&amp;gt;：&lt;/span&gt;委托表达式&lt;/p&gt;
&lt;h3&gt;2.2、表达式的解析&lt;/h3&gt;
&lt;p&gt;表达式树解析&lt;/p&gt;
&lt;p&gt;通过LambdaExpression类我们可以知道，表达式树包含：参数[Parameters]，表达式树类型[NodeType]，表达式[Body]，返回类型[ReturnType]，Lambda表达式的委托[Compile]以及Lambda表达式名称[name]，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071757461-354039163.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071757908-665869398.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;240&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表达式解析：&lt;/p&gt;
&lt;p&gt;所有的表达式都包含：左节点【Left】，右节点【Right】，类型【NodeType】，不同的表达式还会有其他属性，这里的左右节点依旧是表达式。&lt;/p&gt;
&lt;p&gt;下图是BinaryExpression表达式截图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071758295-213967368.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071758702-744533449.png&quot; alt=&quot;image&quot; width=&quot;854&quot; height=&quot;266&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表达式树和表达式里面的类型NodeType是一个枚举，一共有85个类型，有兴趣的朋友可以去了解下。&lt;/p&gt;
&lt;p&gt;常用的类型如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.And&lt;/span&gt;：C#中类似于&amp;amp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.AndAlso&lt;/span&gt;：C#中类似于&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Or&lt;/span&gt;：C#中类似于|&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.OrElse&lt;/span&gt;：C#中类似于||&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Equal&lt;/span&gt;：C#中类似于==&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.NotEqual&lt;/span&gt;：C#中类似于!=&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.GreaterThan&lt;/span&gt;：C#中类似于&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.GreaterThanOrEqual&lt;/span&gt;：C#中类似于&amp;gt;=&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.LessThan&lt;/span&gt;：C#中类似于&amp;lt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.LessThanOrEqual&lt;/span&gt;：C#中类似于&amp;lt;=&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Add&lt;/span&gt;：C#中类似于+&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.AddChecked&lt;/span&gt;：C#中类似于+&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Subtract&lt;/span&gt;：C#中类似于-&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.SubtractChecked&lt;/span&gt;：C#中类似于-&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Divide&lt;/span&gt;：C#中类似于/&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.Multiply&lt;/span&gt;：C#中类似于*&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ExpressionType.MultiplyChecked&lt;/span&gt;：C#中类似于*&lt;/p&gt;
&lt;h3&gt;2.3、编译表达式树&lt;/h3&gt;
&lt;p&gt;在表达式创建那，我们组合创建了一个Lambda表达式，那么应该怎么使用它呢？在“表达式的解析”里面，LambdaExpression类和Expression&amp;lt;TDelegate&amp;gt;类都有一个Compile的方法，学名是Lambda表达式的委托，其实就是Lambda表达式编译函数的委托，所以我们只需要调用他，得到的结果就是一个函数方法。&lt;/p&gt;
&lt;p&gt;代码修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
ParameterExpression numParam = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &quot;&lt;span&gt;num&lt;/span&gt;&quot;);
ConstantExpression five = Expression.Constant(5, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));
BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);
Expression&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; lambda1 =
    Expression.Lambda&amp;lt;Func&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;(
        numLessThanFive,
        &lt;span&gt;new&lt;/span&gt; ParameterExpression[] { numParam });

Console.WriteLine($&quot;&lt;span&gt;Lambda的内容：{lambda1.ToString()}&lt;/span&gt;&quot;);

&lt;span&gt;//表达式的编译&lt;/span&gt;
var func = lambda1.Compile();
Console.WriteLine($&quot;&lt;span&gt;Lambda的运行结果：{func(6)}&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071759024-1214255219.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1764554/201909/1764554-20190915071759355-1661090116.png&quot; alt=&quot;image&quot; width=&quot;410&quot; height=&quot;114&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt;这里我们对表达式做了基本的讲解，相信大家对Lambda表达式有了初步的了解，下面我们将继续讲解对一个表达式树的遍历。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Sep 2019 23:19:00 +0000</pubDate>
<dc:creator>园子的蜗牛</dc:creator>
<og:description>一、前言 一直想写一篇Dpper的定制化扩展的文章，但是里面会设计到对Lambda表达式的解析，而解析Lambda表达式，就必须要知道表达式树的相关知识点。我希望能通过对各个模块的知识点或者运用能够多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snailblog/p/11521043.html</dc:identifier>
</item>
<item>
<title>深入动态代理源码 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/11514343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/11514343.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：  早期学习了动态代理在实际开发中的使用场景和使用方法，我们也知道了最经典的mybatis的mapper就是采用动态代理来实现的，那么动态代理的背后是怎样的原理？为什么能实现动态代理？为什么动态代理只可以代理接口，而无法代理普通类？为什么动态代理需要传入类的classLoder和接口？带着这些疑问，我们来开启本期的主题：探究动态代理的内部原理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇博客的目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：动态代理的基本使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：动态代理的内部运行过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：几个相关的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：动态代理的基本使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.1:简单例子&lt;/p&gt;
&lt;p&gt;首先我们来模拟一个简单的动态代理的过程：某歌手去参加一个晚会,需要唱歌，他在演奏的过程中需要别人来报幕:演奏开始、演奏结束，每个歌手都遵循这样的过程，在歌手进行表演的过程，穿插着主持人的开场白和结语，我们来用代码模拟这个场景：&lt;/p&gt;
&lt;p&gt;1.2:代理接口&lt;/p&gt;
&lt;p&gt;首先我们来定义一个singer接口表示我们将要代理的接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Singer {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表演
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; soonName
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String soonName);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3:接口的具体实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Jay &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Singer {
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String soonName) {
        System.out.println(&lt;/span&gt;&quot;接下来我为大家唱一首&quot;+&lt;span&gt;soonName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4:辅助类,用来模拟注册人的前后台词&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Presenter  {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;请开始你的表演!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;表演结束,大家鼓掌!&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.5:具体的代理类&lt;/p&gt;
&lt;p&gt;  这里用proxy.newProxyInstance来创建一个代理类，传入原始类的类加载器和接口与接口InvocationHandler，同时插入Presenter类的before与after方法，用于前置和后置处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingerProxy {

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Presenter presenter;

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SingerProxy(Presenter presenter){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.presenter =&lt;span&gt; presenter;
   }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取代理对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Singer getProxy(){

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Singer jay = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Jay();
        Singer singerProxy &lt;/span&gt;= (Singer)Proxy.newProxyInstance(jay.getClass().getClassLoader(), jay.getClass().getInterfaces(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvocationHandler() {」
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
                presenter.before();
                method.invoke(jay, args);
                presenter.after();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singerProxy;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.6:测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SingerProxy singerProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SingerProxy(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presenter());
        Singer proxy &lt;/span&gt;=&lt;span&gt; singerProxy.getProxy();
        proxy.perform(&lt;/span&gt;&quot;《夜曲》&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201909/1066538-20190913200636134-432124553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 二：动态代理的内部探究&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的例子可以看出我们首先生成了一个代理类，然后用代理类来调用原始接口的方法，就可以实现我们的预设的逻辑,在原始接口的前后(或者出现异常的时候)插入我们想要的逻辑，那么究竟是为什么呢？&lt;/p&gt;
&lt;p&gt;2.1:找到生成的代理类&lt;/p&gt;
&lt;p&gt;我们如果需要打开生成的类,首先需要在测试类中添加这行代码,设置系统属性来保存生成的代理类的class文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2:singerProxy类&lt;/p&gt;
&lt;p&gt;通过动态代理生成的代理类名为：$Proxy0.class然后通过intelj idea反编译之后源代码是这样的，这里主要看到有4个方法，method的m1\m2\m3\m0;分别由反射获取的equals()、toString()、perform()、hashcode()方法,同时代理类继承了proxy并且实现了原始Singer接口，重写了perform()方法，所以这就解释了为什么代理类可以调用perform()方法,在perform方法中，又调用了父类中的InvoationHander的invoke方法，并且传入原始接口中的方法,而invoke方法在我们在创建代理类的时候重写过，所以就会按照我们自定义的逻辑调用invoke方法,按照顺序执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.UndeclaredThrowableException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; main.learn.proxy.Singer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; $Proxy0 &lt;span&gt;extends&lt;/span&gt; Proxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Singer {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m2;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m3;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m0;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; $Proxy0(InvocationHandler var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(var1);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; equals(Object var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Boolean)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{var1});
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var3;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var4) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var4);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String toString() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m2, (Object[])&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var2;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var3);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; perform(String var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{var1});
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var3;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var4) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var4);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashCode() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Integer)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m0, (Object[])&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var2;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var3);
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            m1 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;));
            m2 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;&lt;span&gt;);
            m3 &lt;/span&gt;= Class.forName(&quot;main.learn.proxy.Singer&quot;).getMethod(&quot;perform&quot;, Class.forName(&quot;java.lang.String&quot;&lt;span&gt;));
            m0 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodError(var2.getMessage());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoClassDefFoundError(var3.getMessage());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.3:生成代理类的过程&lt;/p&gt;
&lt;p&gt;上面我们弄明白了，在代理类中会自动继承原始接口类并且会调用InvocationHandler将接口类中的方法传入进去,那么这个类是如何生成的呢？这就要翻生成代理类的源码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object newProxyInstance(ClassLoader loader,
                                          Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces,
                                          InvocationHandler h)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
    {
        Objects.requireNonNull(h);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs =&lt;span&gt; interfaces.clone();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SecurityManager sm =&lt;span&gt; System.getSecurityManager();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Look up or generate the designated proxy class.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Class&lt;/span&gt;&amp;lt;?&amp;gt; cl =&lt;span&gt; getProxyClass0(loader, intfs);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Invoke its constructor with the designated invocation handler.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;?&amp;gt; cons =&lt;span&gt; cl.getConstructor(constructorParams);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InvocationHandler ih =&lt;span&gt; h;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;&lt;span&gt;() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run() {
                        cons.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
                });
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{h});
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IllegalAccessException|&lt;span&gt;InstantiationException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            Throwable t &lt;/span&gt;=&lt;span&gt; e.getCause();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(t.toString(), t);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码由下来解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.1:安全管理器检查与代理权限检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.2:判断接口的长度是否大于65535，大于不可往下进行。然后从WeakCache缓存中获取代理类,如果找不到则通过proxyClassFactory生成代理类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.2.1:生成代理类的class过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1⃣️验证传入的interface是否可被传入的classloader装载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2⃣️验证传入的是否是一个接口,如果不是一个接口，直接抛出&lt;/strong&gt;IllegalArgumentException异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3⃣️判断传入的是否重复，这里是通过一个&lt;/strong&gt;IdentityHashMap往里面put接口的class类，如果返回值不为null表示这个接口已经注册过了(如果第一次put会返回null，按照传统的做法是先get是否为null,如果不为null再put,这行代码很妙省去了这个步骤)，IdentityHashMap也是map的一种，不过它与我们普通的HashMap最大的不同在于它不会通过equals方法和hashCode方法去判断key是否重复,而是通过==运算符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4⃣️拼接代理类的名字固定为：com.sun.proxy.$Proxy+原子自增序号，为了防止并发调用，在生成代理类名字的时候，采用了&lt;/strong&gt;AtomicLong的getAndIncrement方法去原子递增代理类的序列号，这个方法是原子的，所以不会产生并发问题。这里也就是我们为什么看到最后的代理类是$Proxy0的原因(生成的代理类的序号是从0开始的)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5⃣️调用ProxyGenerator.generateProxyClass方法来生成代理的class类(过程较为复杂、通过一些jvm指令去生成字节码,包括遍历方法类型、返回值、参数类型等)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6⃣️通过defineClass将上一步产生的class字节码生成class文件，该方法也是一个native方法，需要传入类的classloader来进行装载生成的类字节码进而生成class&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.3: 通过反射获取构造器constractor创建一个反射实例,这个过程进行了强制构造器的private私有化反射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：几个相关的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 3.1:为什么动态代理需要传入classLoader?&lt;/p&gt;
&lt;p&gt;  主要原因有以下几个：&lt;/p&gt;
&lt;p&gt;1⃣️需要校验传入的接口是否可被当前的类加载器加载,假如无法加载，证明这个接口与类加载器不是同一个，按照双亲委派模型，那么类加载层次就被破坏了&lt;/p&gt;
&lt;p&gt;2⃣️需要类加载器去根据生成的类的字节码去通过defineClass方法生成类的class文件，也就是说没有类加载的话是无法生成代理类的&lt;/p&gt;
&lt;p&gt;3.2:为什么动态代理需要传入接口和只能代理接口？&lt;/p&gt;
&lt;p&gt; 需要接口去通过ProxyGenerator类来生成代理类的字节码，在生成的过程中，需要遍历接口中的方法，包括方法签名、参数类型、返回类型从而生成新的代理类，而代理类也需要继承原始接口的方法，所以接口必须要传&lt;/p&gt;
&lt;p&gt;3.3:如果同一个接口创建多次代理会怎么办？&lt;/p&gt;
&lt;p&gt;在获取代理对象的时候首先会从缓存(&lt;strong&gt;WeakCache&lt;/strong&gt;)里面取，如果取不到才会通过代理工厂去创建，所以如果创建多个代理类的话，最终只会产生一个代理类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201909/1066538-20190915012342953-1566750806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;四:总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    本篇博客通过一个动态代理的实际例子来分析了具体创建动态代理的过程，分析了动态代理的内部运行原理，以及分析了生成的代理类的源码，动态代理在我们的开发过程中可谓是非常常见，比如最典型的mybatis的mapper代理原理、spring的aop实现原理，进行前置增强、后置增强等就是借助了动态代理。理解了动态代理能帮助我们进一步理解一些源码，或许在以后的某些特定场景我们也可以采用动态代理来造出合适的轮子。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Sep 2019 17:29:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言： 早期学习了动态代理在实际开发中的使用场景和使用方法，我们也知道了最经典的mybatis的mapper就是采用动态代理来实现的，那么动态代理的背后是怎样的原理？为什么能实现动态代理？为什么动态代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq178/p/11514343.html</dc:identifier>
</item>
<item>
<title>Django-手撸简易web框架-实现动态网页-wsgiref初识-jinja2初识-python主流web框架对比-00 - suwanbin</title>
<link>http://www.cnblogs.com/suwanbin/p/11520959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suwanbin/p/11520959.html</guid>
<description>&lt;p&gt;在了解python的三大web框架之前，我们先自己动手实现一个。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分重在掌握实现思路，代码不是重点&lt;/p&gt;
&lt;p&gt;代码中也有许多细节并未考虑，重在实现思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;手撸一个web服务端&quot;&gt;手撸一个web服务端&lt;/h2&gt;
&lt;p&gt;我们一般是使用浏览器当做客户端，然后&lt;strong&gt;基于HTTP协议自己写服务端代码&lt;/strong&gt;作为服务端&lt;/p&gt;
&lt;blockquote readability=&quot;4.0909090909091&quot;&gt;
&lt;p&gt;先自行去回顾一下&lt;a href=&quot;https://www.cnblogs.com/suwanbin/p/11456653.html#autoid-2-1-0&quot;&gt;HTTP协议&lt;/a&gt;这一块儿的知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket
server = socket.socket()  # 基于socket通信（TCP）
server.bind(('127.0.0.1', 8080))
server.listen(5)
while True:
    conn, addr = server.accept()
    data = conn.recv(2048)  # 接收请求
    print(str(data, encoding='utf-8'))
    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')  # 依据HTTP协议，发送响应给客户端（浏览器），这里是响应首行 + 响应头 + 空行
    # response = bytes('&amp;lt;h3&amp;gt;这是响应内容&amp;lt;/h3&amp;gt;', encoding='GBK')
    response = '&amp;lt;h3&amp;gt;这是响应内容&amp;lt;/h3&amp;gt;'.encode('GBK')  # 我电脑上是GBK编码，所以使用GBK编码将字符串转成二进制
    conn.send(response)  #  继续发送响应体
    conn.close()  # 断开连接（无状态、无连接）

# 浏览器发过来的数据如下
'''
GET / HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: _qddaz=QD.w3c3g1.j2bfa7.jvp70drt; csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs


GET /favicon.ico HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36
Accept: image/webp,image/apng,image/*,*/*;q=0.8
Referer: http://127.0.0.1:8080/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: _qddaz=QD.w3c3g1.j2bfa7.jvp70drt; csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs
'''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后右键运行，在浏览器访问 &lt;code&gt;127.0.0.1:8080&lt;/code&gt; 即可看到响应数据&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于启动服务器与页面请求（在我处理的时候，页面网络请求会经常处于 pending状态，不是很清楚原因，一般这个情况下，直接重启一下服务器即可）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012206786-1284670708.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;根据请求-url-做不同的响应处理&quot;&gt;根据请求 url 做不同的响应处理&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面的代码已经实现了基本请求响应，那如何根据不同的请求作出不同的响应呢？&lt;/p&gt;
&lt;p&gt;我们输入不同的url，看看服务器端会返回什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分析请求&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;浏览器访问 http://127.0.0.1:8080/index
GET /index HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: _qddaz=QD.w3c3g1.j2bfa7.jvp70drt; csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs
    

浏览器访问 http://127.0.0.1:8080/home   
GET /home HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: _qddaz=QD.w3c3g1.j2bfa7.jvp70drt; csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来请求首行的 &lt;strong&gt;GET&lt;/strong&gt; 后面跟的就是请求我们想要信息（&lt;strong&gt;/index&lt;/strong&gt; 首页、&lt;strong&gt;/home&lt;/strong&gt; 家）&lt;/p&gt;
&lt;p&gt;这些信息也是我们接收到的（&lt;code&gt;data = conn.recv(2048)&lt;/code&gt; &lt;code&gt;print(str(data, encoding='utf-8'))&lt;/code&gt;），那可不可以取出来，根据值的不同作不同处理呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理请求，获取 url&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data = '''GET /home HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: _qddaz=QD.w3c3g1.j2bfa7.jvp70drt; csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs'''
print(data.split('\n')[0].split(' ')[1])  # ... ---&amp;gt; GET /home HTTP/1.1 --&amp;gt; ['GET', '/home', 'HTTP/1.1']  --&amp;gt; /home
# /home&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据上述切割规则，我们来对不同的请求&lt;strong&gt;作出不同的响应&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket
server = socket.socket()
server.bind(('127.0.0.1', 8080))
server.listen(5)
while True:
    conn, addr = server.accept()
    data = conn.recv(2048).decode('utf-8')
    data = data.split('\n')[0].split(' ')[1]
    print(data)
    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')
    if data == '/index':
        response = '&amp;lt;h3&amp;gt;这里是 index...&amp;lt;/h3&amp;gt;'.encode('GBK')
    elif data == '/home':
        response = '&amp;lt;h3&amp;gt;这里是 home...&amp;lt;/h3&amp;gt;'.encode('GBK')
    else:
        response = '&amp;lt;h3&amp;gt;404 NOT FOUND...\n找不到您要找的资源...&amp;lt;/h3&amp;gt;'.encode('GBK')
    conn.send(response)
    conn.close()

# --- 浏览器请求 http://127.0.0.1:8080/index 的打印信息
# /index
# /favicon.ico
# --- 浏览器请求 http://127.0.0.1:8080/home 的打印信息
# /home
# /favicon.ico
# --- 浏览器请求 http://127.0.0.1:8080/de2332f 的打印信息
# /de2332f
# /favicon.ico
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;页面成功显示不同的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://127.0.0.1:8080/index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012146440-1854820402.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://127.0.0.1:8080/home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012136125-688240817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://127.0.0.1:8080/de2332f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012117075-1589172819.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;404页面&lt;/strong&gt;也应该算作设计网站的一部分，可以给人不一样的感觉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前面处理 scoket 和 http 的那堆代码通常是不变的，且与业务逻辑没什么关系，如果每个项目都要写一遍，那岂不是很麻烦？那封装成模块嘛~&lt;/p&gt;
&lt;p&gt;不过这个操作已经有人帮我们做了，并且封装的更加强大，就是 wsgiref 模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;用wsgiref-模块的做的两件事&quot;&gt;用wsgiref 模块的做的两件事&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在请求来的时候，自动解析 HTTP 数据，并打包成一个字典，便于对请求发过来的数据进行操作&lt;/li&gt;
&lt;li&gt;发响应之前，自动帮忙把数据打包成符合 HTTP 协议的格式（响应数据格式，不需要再手动写 &lt;code&gt;conn.send(b'HTTP/1.1 200 OK\r\n\r\n')&lt;/code&gt; 了），返回给服务端&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from wsgiref.simple_server import make_server  # 导模块


def run(env, response):
    &quot;&quot;&quot;
    先不管这里的 env 和 response 什么个情况

    env：是请求相关的数据，wsgiref帮我们把请求包装成了一个大字典，方便取值
    response：是响应相关的数据
    &quot;&quot;&quot;
    response('200 OK', [])
    print(env)
    current_path = env.get('PATH_INFO')
    print(current_path)

    if current_path == '/index':
        return ['hello, there is index...'.encode('utf-8')]
    elif current_path == '/login':
        return ['hello, there is login...'.encode('utf-8')]
    else:
        return ['sorry... that pages you want is not found...'.encode('utf-8')]


if __name__ == '__main__':
    # 实时监测 127.0.0.1:8080 地址，一旦有客户端连接，会自动加括号调用 run 方法
    server = make_server('127.0.0.1', 8080, run)
    server.serve_forever()  # 启动服务器


# /index
# ---&amp;gt; env 的数据（手动删减了一些），可以看到其中有个 PATH_INFO 是我们要的东西（还有浏览器版本啊，USER-AGENT啊，客户端系统环境变量啊之类的信息）
'''{'ALLUSERSPROFILE': 'C:\\ProgramData', ...省略部分... , 'COMSPEC': 'C:\\Windows\\system32\\cmd.exe', 'PROCESSOR_IDENTIFIER': 'Intel64 Family 6 Model 60 Stepping 3, GenuineIntel', 'PROCESSOR_LEVEL': '6', 'PROCESSOR_REVISION': '3c03', 'PYTHONIOENCODING': 'UTF-8',  'SESSIONNAME': 'Console', 'SYSTEMDRIVE': 'C:', 'SERVER_PORT': '8080', 'REMOTE_HOST': '', 'CONTENT_LENGTH': '', 'SCRIPT_NAME': '', 'SERVER_PROTOCOL': 'HTTP/1.1', 'SERVER_SOFTWARE': 'WSGIServer/0.2', 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/index', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', 'CONTENT_TYPE': 'text/plain', 'HTTP_HOST': '127.0.0.1:8080', 'HTTP_CONNECTION': 'keep-alive', 'HTTP_UPGRADE_INSECURE_REQUESTS': '1', 'HTTP_USER_AGENT': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36', 'HTTP_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', csrftoken=kJHVGICQOglLxJNiui0o0UyxNtR3cXbJPXqaUFs5FoxeezuskRO7jlQE0JNwYXJs', mode='w' encoding='UTF-8'&amp;gt;, 'wsgi.version': (1, 0), }'''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;伏笔&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012050943-2116713371.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;拆分服务端代码&quot;&gt;拆分服务端代码&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务端代码、路由配置、视图函数，照目前的写法全都冗在一块儿，后期功能扩展时，这个文件会变得很长，不方便维护，所以选择把他拆分开来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是将服务端代码拆分成如下三部分：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;server.py 放服务端代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;urls.py 放路由与视图函数对应关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;views.py 放视图函数/类（处理业务逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from views import *

urls = [
    ('/index', index),
    ('/login', login),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;server.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from wsgiref.simple_server import make_server  # 导模块
from urls import urls  # 引入 urls.py 里的 urls列表（命名的不是很规范）


def run(env, response):
    response('200 OK', [])
    current_path = env.get('PATH_INFO')

    func = None
    for url in urls:
        if current_path == url[0]:
            func = url[1]
            break

    if func:
        res = func(env)
    else:
        res = '404 Not Found.'
    return [res.encode('utf-8')]  # 注意这里返回的是一个列表（可迭代对象才行），wsgiref 模块规定的，可能还有其他的用途吧


if __name__ == '__main__':
    server = make_server('127.0.0.1', 8080, run)
    server.serve_forever()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;支持新的请求地址添加新页面新功能&quot;&gt;支持新的请求地址（添加新页面/新功能）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;经过上面的拆分后，后续想要支持其他 url，只需要在 urls.py 中添加一条对应关系，在 views.py 中把该函数实现，重启服务器即可访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以支持 &lt;code&gt;http://127.0.0.1:8080/new_url&lt;/code&gt; 访问为例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from views import *

urls = [
    ('/index', index),
    ('/login', login),
    ('/new_url', new_url),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'


def new_url(env):
    # 这里可以写一堆逻辑代码
    return 'new_url'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启服务器&lt;/strong&gt;，打开浏览器即可访问 &lt;code&gt;http://127.0.0.1:8080/new_url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012027987-303037309.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;扩展性高了很多，且逻辑更清晰了，更不容易弄错（框架的好处提现，也是为什么脱离了框架不会写的原因，这块代码写的太少，不常用到，没了框架又写不出来）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前面写了那么多，都只是一直在返回纯文本信息，而我们一般请求页面返回的都是浏览器渲染好的华丽的页面，那要怎么放回华丽的页面呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;页面嘛，就是 HTML + CSS + JS 渲染出来的，所以我们也可以把 HTML文件当成数据放在响应体里直接返回回去&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;新建一个功能的步骤&lt;/strong&gt;还是复习一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 urls.py 里面加一条路由与视图函数的对应关系&lt;/li&gt;
&lt;li&gt;在 views.py 里面加上那个视图函数，并写好内部逻辑代码&lt;/li&gt;
&lt;li&gt;重启服务器，浏览器打开页面访问&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;返回静态页面--案例&quot;&gt;返回静态页面--案例&lt;/h2&gt;
&lt;p&gt;这里咱们就接着上面的 new_url 写，用他来返回 一个网页&lt;/p&gt;
&lt;p&gt;新建一个 &lt;strong&gt;templates&lt;/strong&gt; 文件夹，专门用来放 HTML 文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;templates/new_url.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;New URL&amp;lt;/h1&amp;gt;
    &amp;lt;h5&amp;gt;Wellcome!&amp;lt;/h5&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'


def new_url(env):
    # 读取并把 new_url 文件返回给客户端（浏览器）
    with open(r'templates/new_url.html', 'rb') as f:
        html_data = f.read()
    return html_data.decode('utf-8')  # 因为 run 函数那里做了 encode， 而二进制数据没有 encode这个方法，所以这里先解码一下，然后那边再编码一下&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启服务器，使用浏览器访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915012013685-1716272558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面提到了静态页面，那什么是静态页面？什么又是动态页面呢？&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;静态网页：&lt;/strong&gt;纯html网页，数据是写死的，所有同url的请求拿到的数据都是一样的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;动态网页：&lt;/strong&gt;后端数据拼接，数据不是写死的，是动态拼接的，比如：&lt;/p&gt;
&lt;p&gt;​ 后端实时获取当前时间“传递”（塞）给前端页面展示&lt;/p&gt;
&lt;p&gt;​ 后端从数据库获取数据“传递”给前端页面展示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;要怎么在 html 里插入时间呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;往 html 里的插入？那替换好像也可以达到效果啊？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;html_data = f.read()&lt;/code&gt; ？ 好像 html 被读出出来了，而且还是二进制的，二进制可以 decode 变成字符串，字符串有 replace方法可以替换字符串，那我随便在网页里写点内容，然后替换成时间？&lt;/p&gt;
&lt;p&gt;先把基础歩鄹做好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;templates/get_time.html&lt;/strong&gt; 编写展示页面&lt;/p&gt;
&lt;p&gt;put_times_here 用来做占位符，一会儿给他替换成时间&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;北京时间：&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;put_time_here&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt; 路由与视图函数对应关系&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from views import *

urls = [
    ('/index', index),
    ('/login', login),
    ('/new_url', new_url),
    ('/get_time', get_time),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt; 实现视图函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'


def new_url(env):
    # 读取并把 new_url 文件返回给客户端（浏览器）
    with open(r'templates/new_url.html', 'rb') as f:
        html_data = f.read()
    return html_data


def get_time(env):
    # 读取并把 get_time 文件返回给客户端（浏览器）
    with open(r'templates/get_time.html', 'rb') as f:
        html_data = f.read().decode('utf-8')
    import time
    html_data = html_data.replace('put_time_here', time.strftime(&quot;%Y-%m-%d %X&quot;))
    return html_data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启服务器并打开浏览器访问 &lt;code&gt;http://127.0.0.1:8080/get_time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915011959639-861705325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键思路：&lt;/strong&gt;相当于占位符，字符串替换，后期把前端要替换的字符的格式统一规定下，方便阅读与统一处理，这其实也就是目前的模版语法的&lt;strong&gt;雏形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们只需要把处理好的字符串（HTML格式的）返回给浏览器，待浏览器渲染即可有页面效果&lt;/p&gt;

&lt;p&gt;jinja2模块有着一套 模板语法，可以帮我更方便地在 html 写代码（就想写后台代码一样），让前端也能够使用后端的一些语法操作后端传入的数据&lt;/p&gt;
&lt;h2 id=&quot;安装-jinja2&quot;&gt;安装 jinja2&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;jinja2 并不是 python 解释器自带的，所以需要我们自己安装&lt;/p&gt;
&lt;p&gt;​ 由于 flask 框架是依赖于 jinja2 的，所下载 flask 框架也会自带把 jinja2 模块装上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令行执行，&lt;code&gt;pip3 install jinja2&lt;/code&gt; 或&lt;a href=&quot;https://www.cnblogs.com/suwanbin/p/11515605.html#autoid-3-1-0&quot;&gt;图形化操作安装&lt;/a&gt;（参考 Django 的安装方法）&lt;/p&gt;
&lt;h2 id=&quot;初步使用&quot;&gt;初步使用&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里只是知道有模板语法这么一个东西可以让我们很方便的往 html 写一些变量一样的东西，并不会讲 jinja2 的语法，后续会有的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;案例--展示字典信息&quot;&gt;案例--展示字典信息&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from views import *

urls = [
    ('/index', index),
    ('/login', login),
    ('/new_url', new_url),
    ('/get_time', get_time),
    ('/show_dic', show_dic),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'


def new_url(env):
    # 读取并把 new_url 文件返回给客户端（浏览器）
    with open(r'templates/new_url.html', 'rb') as f:
        html_data = f.read()
    return html_data


def get_time(env):
    # 读取并把 get_time 文件返回给客户端（浏览器）
    with open(r'templates/get_time.html', 'rb') as f:
        html_data = f.read().decode('utf-8')
    import time
    html_data = html_data.replace('put_time_here', time.strftime(&quot;%Y-%m-%d %X&quot;))
    return html_data


def show_dic(env):
    user = {
        &quot;username&quot;: &quot;jason&quot;,
        &quot;age&quot;: 18,
    }
    with open(r'templates/show_dic.html', 'rb') as f:
        html_data = f.read()

    # 使用 jinja2 的模板语法来将数据渲染到页面上（替换占位符）
    from jinja2 import Template
    tmp = Template(html_data)
    res = tmp.render(dic=user)  # 将字典 user 传递给前端页面，前端页面通过变量名 dic 就能够获取到该字典
    return res&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;templates/show_dic.html&lt;/strong&gt; 写页面&lt;/p&gt;
&lt;p&gt;jinja2 给字典扩展了点语法支持（&lt;code&gt;{{ dic.username }}&lt;/code&gt;）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Nice to meet you~ i'm {{ dic.username }} , and i'm {{ dic.age }} years old.&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;username: {{ dic['username']}}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;age: {{ dic.get('age')}}&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启服务器并打开浏览器访问 &lt;code&gt;http://127.0.0.1:8080/show_dic&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915011940565-583503737.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么说动态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你改变了字典里的值，那么请求这个页面，显示的数据也会跟着改变（注意这个字典一般都是其他地方获取过来的）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
模板语法（贴近python语法）: 前端也能够使用后端的一些语法操作后端传入的数据
    {{data.password}}  # jinja2 多给字典做了 点语法支持
    ... 其他的语法，写法
    
    for 循环
    {%for user_dict in user_list%}
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;{{user_dict.id}}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;{{user_dict.name}}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;{{user_dict.password}}&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    {%endfor%}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进阶案例--渲染数据库数据到页面&quot;&gt;进阶案例--渲染数据库数据到页面&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pymsql 从数据库取数据（指定成 列表套字典 的格式（DictCursor））
后台 python 代码处理数据
交由 jinja2 模块语法渲染到 html 页面上

数据条数不定怎么办？
    有多少条记录就显示多少条呗...循环？
    表格格式先写好，然后循环渲染数据到标签上（特定语法表示循环）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据准备&quot;&gt;数据准备&lt;/h4&gt;
&lt;p&gt;创建数据库 &lt;strong&gt;django_test_db&lt;/strong&gt;，然后执行如下 SQL 命令&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;/*
 Navicat MySQL Data Transfer

 Source Server         : localhost-E
 Source Server Type    : MySQL
 Source Server Version : 50645
 Source Host           : localhost:3306
 Source Schema         : django_test_db

 Target Server Type    : MySQL
 Target Server Version : 50645
 File Encoding         : 65001

 Date: 15/09/2019 00:41:09
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for user_info
-- ----------------------------
DROP TABLE IF EXISTS `user_info`;
CREATE TABLE `user_info`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of user_info
-- ----------------------------
INSERT INTO `user_info` VALUES (1, 'jason', '123');
INSERT INTO `user_info` VALUES (2, 'tank', '123');
INSERT INTO `user_info` VALUES (3, 'jerry', '123');
INSERT INTO `user_info` VALUES (4, 'egon', '456');

SET FOREIGN_KEY_CHECKS = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配路由与视图函数&quot;&gt;配路由与视图函数&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from views import *

urls = [
    ('/index', index),
    ('/login', login),
    ('/new_url', new_url),
    ('/get_time', get_time),
    ('/show_dic', show_dic),
    ('/get_users', get_users),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def index(env):
    return 'index'


def login(env):
    return 'login'


def new_url(env):
    # 读取并把 new_url 文件返回给客户端（浏览器）
    with open(r'templates/new_url.html', 'rb') as f:
        html_data = f.read()
    return html_data


def get_time(env):
    # 读取并把 get_time 文件返回给客户端（浏览器）
    with open(r'templates/get_time.html', 'rb') as f:
        html_data = f.read().decode('utf-8')
    import time
    html_data = html_data.replace('put_time_here', time.strftime(&quot;%Y-%m-%d %X&quot;))
    return html_data


def show_dic(env):
    user = {
        &quot;username&quot;: &quot;jason&quot;,
        &quot;age&quot;: 18,
    }
    with open(r'templates/show_dic.html', 'rb') as f:
        html_data = f.read()

    # 使用 jinja2 的模板语法来将数据渲染到页面上（替换占位符）
    from jinja2 import Template
    tmp = Template(html_data)
    res = tmp.render(dic=user)  # 将字典 user 传递给前端页面，前端页面通过变量名 dic 就能够获取到该字典
    return res


# 先写个空函数在这里占位置，去把 pymysql 查数据的写了再过来完善
def get_users(env):
    # 从数据库取到数据
    import op_mysql
    user_list = op_mysql.get_users()

    with open(r'templates/get_users.html', 'r', encoding='utf-8') as f:
        html_data = f.read()

    from jinja2 import Template  # 其实这个引入应该放在页面最上方去的，但为了渐进式演示代码推进过程，就放在这里了
    tmp = Template(html_data)
    res = tmp.render(user_list=user_list)
    return res&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;op_mysql.py&lt;/strong&gt; 如果你的配置不一样要自己改过来&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pymysql


def get_cursor():
    server = pymysql.connect(
        # 根据自己电脑上 mysql 的情况配置这一块的内容
        host='127.0.0.1',
        port=3306,
        user='root',
        password='000000',
        charset='utf8',  # 千万注意这里是 utf8 ！
        database='django_test_db',
        autocommit=True
    )
    cursor = server.cursor(pymysql.cursors.DictCursor)
    return cursor


def get_users():
    cursor = get_cursor()  # 连接数据库

    sql = &quot;select * from user_info&quot;  # 把用户的所有信息查出来（一般不会把密码放回给前端的，这里只是为了做演示）
    affect_rows = cursor.execute(sql)
    user_list = cursor.fetchall()
    return user_list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;templates/get_users.html&lt;/strong&gt; 用户信息展示页面&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;!--  引入jquery bootstrap 文件的 CDN  --&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;link href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;

            &amp;lt;div class=&quot;col-md-8 col-md-offset-2&quot;&amp;gt;
                &amp;lt;h2 class=&quot;text-center&quot;&amp;gt;用户数据展示&amp;lt;/h2&amp;gt;
                &amp;lt;table class=&quot;table table-hover table-bordered table-striped&quot;&amp;gt;
                    &amp;lt;thead&amp;gt;
                    &amp;lt;tr&amp;gt;
                        &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt;
                        &amp;lt;th&amp;gt;username&amp;lt;/th&amp;gt;
                        &amp;lt;th&amp;gt;password&amp;lt;/th&amp;gt;
                    &amp;lt;/tr&amp;gt;
                    &amp;lt;/thead&amp;gt;
                    &amp;lt;tbody&amp;gt;
                    &amp;lt;!-- jinja2 的模版语法（for循环） --&amp;gt;
                    {%for user_dict in user_list%}
                    &amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt;{{user_dict.id}}&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;{{user_dict.username}}&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;{{user_dict.password}}&amp;lt;/td&amp;gt;
                    &amp;lt;/tr&amp;gt;
                    {%endfor%}
                    &amp;lt;/tbody&amp;gt;
                &amp;lt;/table&amp;gt;
            &amp;lt;/div&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用浏览器访问 &lt;code&gt;http://127.0.0.1:8080/get_users&lt;/code&gt;，重启服务器，在切回浏览器即可看到页面效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915011902104-829550490.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1.纯手撸web框架
    1.手动书写socket代码
    2.手动处理http数据
    
2.基于wsgiref模块帮助我们处理scoket以及http数据（顶掉上面的歩鄹）
    wsgiref模块
        1.请求来的时候 解析http数据帮你打包成一个字典传输给你 便于你操作各项数据
        2.响应走的时候 自动帮你把数据再打包成符合http协议格式的样子 再返回给前端
    
3.封装路由与视图函数对应关系 以及视图函数文件 网站用到的所有的html文件全部放在了templates文件夹下
    1.urls.py 路由与视图函数对应关系
    2.views.py 视图函数 (视图函数不单单指函数 也可以是类)
    3.templates 模板文件夹
    
4.基于jinja2实现模板的渲染
    模板的渲染
        后端生成好数据 通过某种方式传递给前端页面使用(前端页面可以基于模板语法更加快捷简便使用后端传过来的数据)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;流程图&quot;&gt;流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190915011827519-2084620178.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小扩展&quot;&gt;小扩展&lt;/h2&gt;
&lt;p&gt;在不知道是要 encode 还是 decode 的时候，可以用一下方法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;二进制数据对应的肯定是 decode 解码 成字符串呀&lt;/p&gt;
&lt;p&gt;字符串对应的肯定是 encode 编码成二进制数据呀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据类型转换技巧（处理编码）&lt;/strong&gt;（数据 + encoding）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 转成 bytes 类型
bytes(data, encoding='utf-8')

# 转成 str 类型
str(data, encoding='utf-8')&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;django&quot;&gt;Django&lt;/h2&gt;
&lt;p&gt;大而全，自带的功能特别特别多，就类似于航空母舰&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;有时过于笨重（小项目很多用不到）&lt;/p&gt;
&lt;h2 id=&quot;flask&quot;&gt;Flask&lt;/h2&gt;
&lt;p&gt;短小精悍，自带的功能特别少，全都是依赖于第三方组件（模块）&lt;/p&gt;
&lt;p&gt;第三方组件特别多 --&amp;gt; 如果把所有的第三方组件加起来，完全可以盖过django&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;比较受限于第三方的开发者（可能有bug等）&lt;/p&gt;
&lt;h2 id=&quot;tornado&quot;&gt;Tornado&lt;/h2&gt;
&lt;p&gt;天生的异步非阻塞框架，速度特别快，能够抗住高并发&lt;/p&gt;
&lt;p&gt;​ 可以开发游戏服务器（但开发游戏，还是 C 和C++用的多，执行效率更快）&lt;/p&gt;
&lt;h2 id=&quot;手撸三大部分在框架中的情况对比&quot;&gt;手撸三大部分在框架中的情况对比&lt;/h2&gt;
&lt;p&gt;前面的手撸推导过程，整个框架过程大致可以分为以下三部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：socket处理请求的接收与响应的发送&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B：路由与视图函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C：模板语法给动态页面渲染数据&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;django-1&quot;&gt;Django&lt;/h3&gt;
&lt;p&gt;A：用的&lt;u&gt;别人&lt;/u&gt;的 wsgiref 模块&lt;br/&gt;B：自带路由与视图函数文件&lt;br/&gt;C：自带一套模板语法&lt;/p&gt;
&lt;h3 id=&quot;flask-1&quot;&gt;Flask&lt;/h3&gt;
&lt;p&gt;A：用的&lt;u&gt;别人&lt;/u&gt;的werkzeug 模块（基于 wsgiref 封装的）&lt;br/&gt;B：自带路由与视图函数文件&lt;br/&gt;C：用的&lt;u&gt;别人&lt;/u&gt;的jinja2&lt;/p&gt;
&lt;h3 id=&quot;tornado-1&quot;&gt;Tornado&lt;/h3&gt;
&lt;p&gt;A，B，C全都有自己的实现&lt;/p&gt;

&lt;blockquote readability=&quot;1.5463917525773&quot;&gt;
&lt;p&gt;参见我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/suwanbin/p/11515605.html&quot;&gt;Django-下载安装-配置-创建django项目-三板斧简单使用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 14 Sep 2019 17:23:00 +0000</pubDate>
<dc:creator>suwanbin</dc:creator>
<og:description>[TOC] 自己动手实现一个简易版本的web框架 在了解python的三大web框架之前，我们先自己动手实现一个。 备注： 这部分重在掌握实现思路，代码不是重点 代码中也有许多细节并未考虑，重在实现思</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suwanbin/p/11520959.html</dc:identifier>
</item>
<item>
<title>同步、异步、阻塞、非阻塞 - luyuze95</title>
<link>http://www.cnblogs.com/luyuze95/p/11520945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luyuze95/p/11520945.html</guid>
<description>&lt;h2 id=&quot;同步&quot;&gt;1、同步&lt;/h2&gt;
&lt;p&gt;所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。&lt;br/&gt;简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。&lt;br/&gt;例如：B/S模式中的表单提交，具体过程是：客户端提交请求-&amp;gt;等待服务器处理-&amp;gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。&lt;/p&gt;
&lt;h2 id=&quot;异步&quot;&gt;2、异步&lt;/h2&gt;
&lt;p&gt;异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。&lt;/p&gt;
&lt;p&gt;对于通知调用者的三种方式，具体如下：&lt;/p&gt;
&lt;p&gt;即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。&lt;/p&gt;
&lt;p&gt;当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。&lt;/p&gt;
&lt;p&gt;与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。&lt;/p&gt;
&lt;p&gt;例如：B/S模式中的ajax请求，具体过程是：客户端发出ajax请求-&amp;gt;服务端处理-&amp;gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。&lt;/p&gt;
&lt;h2 id=&quot;同步与异步的区别&quot;&gt;3、同步与异步的区别&lt;/h2&gt;
&lt;p&gt;总结来说，同步和异步的区别：请求发出后，是否需要等待结果，才能继续执行其他操作。&lt;/p&gt;
&lt;h2 id=&quot;阻塞与非阻塞&quot;&gt;4、阻塞与非阻塞&lt;/h2&gt;
&lt;p&gt;阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。&lt;/p&gt;
&lt;p&gt;阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.&lt;/p&gt;
&lt;p&gt;阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。&lt;/p&gt;
&lt;p&gt;非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。&lt;/p&gt;
&lt;h2 id=&quot;阻塞非阻塞与同步异步的区别故事篇&quot;&gt;5、阻塞非阻塞与同步异步的区别？（故事篇）&lt;/h2&gt;
&lt;p&gt;理解同步阻塞、同步非阻塞、异步阻塞、异步阻塞、异步非阻塞&lt;/p&gt;
&lt;p&gt;同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。&lt;/p&gt;
&lt;p&gt;以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能够更好的促进大家的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;：小明一直盯着下载进度条，到 100% 的时候就完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步体现在：等待下载完成通知。&lt;/li&gt;
&lt;li&gt;阻塞体现在：等待下载完成通知过程中，不能做其他任务处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;同步非阻塞&lt;/strong&gt;：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步体现在：等待下载完成通知。&lt;/li&gt;
&lt;li&gt;非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。【小明必须要在两个任务间切换，关注下载进度】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;异步阻塞&lt;/strong&gt;：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明不做别的事，仍然一直等待“叮”的声音。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步体现在：下载完成“叮”一声通知。&lt;/li&gt;
&lt;li&gt;阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;异步非阻塞&lt;/strong&gt;：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步体现在：下载完成“叮”一声通知。&lt;/li&gt;
&lt;li&gt;非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务），在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。&lt;/p&gt;
&lt;p&gt;所以，综上所述，同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。也就是说，同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁。在小明的例子中，这个桥梁就是软件“叮”的声音。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Sep 2019 17:08:00 +0000</pubDate>
<dc:creator>luyuze95</dc:creator>
<og:description>简单介绍同步、异步、阻塞、非阻塞的概念。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luyuze95/p/11520945.html</dc:identifier>
</item>
<item>
<title>HBase工作中的一些优化方法 - crazy_orange</title>
<link>http://www.cnblogs.com/liufei-yes/p/11520801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liufei-yes/p/11520801.html</guid>
<description>&lt;div id=&quot;home&quot; readability=&quot;6.6951033430434&quot;&gt;
&lt;div id=&quot;header&quot;&gt;
&lt;div id=&quot;blogTitle&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liufei-yes/&quot;&gt;&lt;img id=&quot;blogLogo&quot; src=&quot;https://www.cnblogs.com/skins/custom/images/logo.gif&quot; alt=&quot;返回主页&quot;/&gt;&lt;/a&gt; 

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot; readability=&quot;5.7597970115591&quot;&gt;
&lt;div id=&quot;navigator&quot; readability=&quot;3.4578313253012&quot;&gt;
&lt;p&gt;随笔- 6  文章- 0  评论- 0 &lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;

&lt;p&gt;1、表的设计&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pre-creating Regions（预分区）
&lt;ul&gt;&lt;li&gt;　　默认情况下，在创建Hbase表的时候会自动创建一个region分区，当导入数据的时候，所有的Hbase客户端都向这一个region写数据，直到这个region足够大了才进行切分。一种可以加快批量写入速度的方法是通过预先创建一些空的regions，这样当数据写入Hbase时，会按照region分区情况，在集群内做数据的负载均衡。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;rowkey：Hbase中rowkey用来检索表中的记录，支持一下三种方式
&lt;ul&gt;&lt;li&gt;通过单个rowkey访问：即按照某个rowkey键值进行get操作&lt;/li&gt;
&lt;li&gt;通过rowkey的range进行scan：通过startRowkey和endRowkey，在这个范围内进行扫描&lt;/li&gt;
&lt;li&gt;全表扫描：即直接扫描整张表中所有行记录&lt;/li&gt;
&lt;li&gt;在Hbase中rowkey可以是任意字符串，最大长度64K，一般为10～100bytes，一般设计为定长&lt;/li&gt;
&lt;li&gt;rowkey规则
&lt;ul&gt;&lt;li&gt;越小越好&lt;/li&gt;
&lt;li&gt;rowkey的设计是要根据实际业务来&lt;/li&gt;
&lt;li&gt;散列性：
&lt;ul&gt;&lt;li&gt;取反&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;column family
&lt;ul&gt;&lt;li&gt;　　不要在Hbase一张表里定义太多的column family。目前Hbase并不能很好的处理超过2～3个column family的表。因为某个column family在flush的时候，它邻近的column family也会因关联效应出发flush，最终导致系统产生更多的I/O。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In memory：创建表时，可以通过HColumnDescriptor.setInMemory(true) 将表放到RS的缓存中，保证在读取的时候被chache命中&lt;/li&gt;
&lt;li&gt;Max version：创建表时，可以通过HColumnDescriptor.setMaxVersions(int maxVersions)设置表中数据的最大版本，如果只需要保存最新版本的数据，那么可以设置setMaxVersions(1)&lt;/li&gt;
&lt;li&gt;Time to live：创建表时，可以通过HColumnDescriptor.setTimeToLive(int timeToLive)设置表中数据的存储生命周期，国企数据将自动被删除，例如如果只需要存储最近两天的数据，那么可以设置setTimeToLive(2 * 24 * 60 * 60)&lt;/li&gt;
&lt;li&gt;Compact &amp;amp; split：
&lt;ul&gt;&lt;li&gt;在Hbase中，数据在更新时首先写入WAL日志（HLog）和内存（MemStore）中，Memstore中的数据是排序的，当memstore累计到一定阀值时，就会创建一个新的Memstore，并且将老的Memstore添加到flush对了，由单独的线程flush到磁盘上，成为一个StoreFile。与此同时，系统会在zookeeper中记录一个redo point，表示这个时刻之前的变更已经持久化了（minor compact）。&lt;/li&gt;
&lt;li&gt;StoreFile是只读的，一旦创建后就不可以在修改。因此Hbase的更新其实是不断追加的操作。当一个store中的storeFile达到一定的阀值后，就会进行一个合并（major compact），将对同一个key的修改合并到一起，形成一个大的storeFile，当storeFile的大小达到一定阀值后，又回对storeFile进行分割（split），等分为两个storeFile。&lt;/li&gt;
&lt;li&gt;由于对表的更新是不断追加的，处理读请求是，需要访问store中全部storeFile和memstore，将他们按照rowkey进行合并，由于storeFile和Memstore都是经过排序的，并且storeFile带有内存中索引，通常合并过程还是比较快的&lt;/li&gt;
&lt;li&gt;实际应用中，可以考虑必要时手动进行major compact，将同一个rowkey的修改进行合并形成一个较大的storeFile。同时将storeFile设置大些，减少split的发生&lt;/li&gt;
&lt;li&gt;Hbase为了防止小文件（被刷到磁盘的memstore）过多，以保证查询效率，Hbase需要在必要的时候将这些小的storeFile合并成相对较大的storeFile，这个过程称之为compact。在Hbase中，主要存在两种类型的compact：minor compaction和major compaction
&lt;ul&gt;&lt;li&gt;minor compaction：是较小、很少文件的合并&lt;/li&gt;
&lt;li&gt;major compaction：将所有的storeFile合并成一个，触发major compaction的可能条件有：major_compact命令、majorCompact() API、RS自动运行(相关参数：hbase.hregion.majorcompaction 默认为24小时、hbase.hregion.majorcompaction.jetter 默认0.2、防止RS在同一时间进行major compaction)&lt;/li&gt;
&lt;li&gt;hbase.hregion.majorcompaction.jetter 作用：对参数hbase.hregion.majorcompaction规定的值起到浮动的作用，假如两个参数都为默认值24和0.2，那么major compact最终使用的数值为：19.2～28.8这个范围&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关闭自动 major compaction&lt;/li&gt;
&lt;li&gt;手动编程 major compaction&lt;/li&gt;
&lt;li&gt;minor compaction的运行机制要复杂一些，它由一下几个参数共同决定：&lt;/li&gt;
&lt;li readability=&quot;-1.1860465116279&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.4757281553398&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.496062992126&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.4234234234234&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1.2020547945205&quot;&gt;
&lt;div readability=&quot;6.4109589041096&quot;&gt;&lt;a href=&quot;http://hbase.hstore.compaction.ratio&quot;&gt;hbase.hstore.compaction.ratio&lt;/a&gt; 将store file 按照文件年龄排序（older to younger），minor compaction总是从older store file开始选择&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、写表操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;多个HTable并发写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;HTable参数设置
&lt;ul&gt;&lt;li&gt;Auto flush：HTable.setAutoFlush(false)，关闭客户端的自动flush，这样可以批量写入数据到Hbase，而不是有一条put就执行一次更新，只有当put填满客户端写缓存时，才实际向Hbase服务端发起写情趣。默认auto flush是开启的&lt;/li&gt;
&lt;li&gt;write buffer：设置客户端的buffer大小，如果新设的buffer小于当前写buffer中的数据，buffer将会被flush到服务端&lt;/li&gt;
&lt;li&gt;WAL Flag
&lt;ul&gt;&lt;li&gt;　　注意：谨慎选择关闭WAL日志，因为这样，如果RS宕机，put/delete的数据将无法根据WAL日志进行恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;批量写&lt;/li&gt;
&lt;li&gt;多线程并发写 &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、读表操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scan caching
&lt;ul&gt;&lt;li&gt;Hbase的conf配置文件中配置&lt;/li&gt;
&lt;li&gt;通过调用HTable.setScannerCaching()进行配置&lt;/li&gt;
&lt;li&gt;通过调用scan.setCaching() 进行配置&lt;/li&gt;
&lt;li&gt;三者的优先级越来越高级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;批量读&lt;/li&gt;
&lt;li&gt;多线程并发读 &lt;/li&gt;
&lt;li&gt;缓存查询结果&lt;/li&gt;
&lt;li&gt;Blockcache
&lt;ul&gt;&lt;li&gt;Hbase上RS的内存分为两个部分，一部分作为Memstore，主要用来写，另外一部分作为BlockCache，主要用来读&lt;/li&gt;
&lt;li&gt;写请求会先写入memstore，RS会给每个region提供一个memstore，当memstore满64M以后，会启动flush刷新到磁盘。当memstore的总大小超过限制时（heapsize * hbase.regionserver.global.memstore.upperlimit * 0.9），会强行启动flush进程，从最大的memstore开始flush直到低于限制&lt;/li&gt;
&lt;li&gt;读请求先到memstore中查数据，查不到就到BlockCache中查，再查不到就会到磁盘上读，并把结果放入BlockCache。由于BlockCache采用LRU策略，因此BlockCache达到上线（heap size * hfile.block.cache.size * 0.85）后，会启动淘汰机制，淘汰掉最老的一批数据&lt;/li&gt;
&lt;li&gt;一个RS上有一个BlockCache和N个Memstore，他们的大小和不能大于等于heapsize * 0.8，否则Hbase不能启动。默认BlockCache为0.2，memstore为0.4。对于注重读响应时间的系统，可以将BlockCache设大些，比如BlockCache=0.4，memstore=0.39，以加大缓存的命中率 &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2019-09-14 23:45&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/liufei-yes/&quot;&gt;crazy_orange&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论(&lt;span id=&quot;post_comment_count&quot;&gt;...&lt;/span&gt;) &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=11520801&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;AddToWz(11520801); return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;

&lt;p&gt;Copyright © 2019 crazy_orange&lt;br/&gt;&lt;span id=&quot;poweredby&quot;&gt;Powered by .NET Core 3.0.0-preview9-19423-09 on Linux&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 14 Sep 2019 15:45:00 +0000</pubDate>
<dc:creator>crazy_orange</dc:creator>
<og:description>1、表的设计 Pre-creating Regions（预分区） 默认情况下，在创建Hbase表的时候会自动创建一个region分区，当导入数据的时候，所有的Hbase客户端都向这一个region写数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liufei-yes/p/11520801.html</dc:identifier>
</item>
<item>
<title>Vue 利用指令实现禁止反复发送请求 - 悠悠洛</title>
<link>http://www.cnblogs.com/youyouluo/p/11520783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyouluo/p/11520783.html</guid>
<description>&lt;p&gt;　　前端做后台管控系统，在某些接口请求时间过长的场景下，需要防止用户反复发起请求。&lt;/p&gt;
&lt;p&gt;　　假设某场景下用户点击查询按钮后，后端响应需要长时间才能返回数据。那么要规避用户返回点击查询按钮无外乎是让用户无法在合理时间内再次点击按钮。实现方式也有好几种：&lt;/p&gt;
&lt;p&gt;　　　　1、在按钮点击发起请求后，弹个蒙层，显示个loading，等请求数据返回了将蒙层隐藏掉。&lt;/p&gt;
&lt;p&gt;　　　　2、在按钮点击发起请求后，将按钮禁用掉，同样等数据返回了将按钮禁用解除。&lt;/p&gt;
&lt;p&gt;　　以上是比较常见的2种方案。&lt;/p&gt;
&lt;p&gt;　　实现上最简单的肯定是在需要的页面种在请求前和拿到数据后，单独处理。这种方案优点仅仅是简单，但是每个需要处理的页面都要单独写一串重复的代码，哪怕利用mixin也要多不少冗余代码。&lt;/p&gt;
&lt;p&gt;　　如果是利用指令的方式仅仅需要在合适的地方加上个一条v-xxxx，其他都在指令的逻辑内统一处理。&lt;/p&gt;
&lt;p&gt;　　以第二种方式为例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
clickForbidden.js

let forbidClick = null;
export default {
  bind(e) {
    const el = e;
    let timer = null;
    forbidClick = () =&amp;gt; {
      el.disabled = true;
      el.classList.add('is-disabled');
      timer = setTimeout(() =&amp;gt; {
　　     el.disabled = false;　
        el.classList.remove('is-disabled');
      }, 3000);
    };
    el.addEventListener('click', forbidClick);
  },
  unbind() {
    document.removeEventListener('click', forbidClick);
  },
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　指令的逻辑很简单，当按钮插入到DOM节点后，添加一个监听click的事件，当按钮点击后，就将按钮禁用，并加上一个禁用样式，并在3s后将该按钮解除禁用。&lt;/p&gt;
&lt;p&gt;　　再考虑请求，以axios为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
api.js
import axios from 'axios';

export baseURL = 'xxxx';
const api = axios.create({
  baseURL,&lt;br/&gt;　timeout: 3000,
});

/* 记录当前请求是否完成 */
window.currentResq = {
  done: true,
  config: {},
};

api.interceptors.request.use(function(config) {
  clearTimeout(resqTimer);
  window.currentResq = {
    done: false,
    config,
  };
  // 接口请求时长超过3s，则视为完成，不管请求结果成功或失败
  resqTimer = setTimeout(() =&amp;gt; {
    window.currentResq = {
      done: true,
      config: {},
    };
  }, 3000);
});

api.interceptors.response.use(function(response) {
  const { config } = window.currentResq;
  const { url, method, data } = response.config;
  if (config.url === url &amp;amp;&amp;amp; config.method === method &amp;amp;&amp;amp; config.data === data) {
    clearTimeout(resqTimer);
    window.currentResq.done = true;
  }
  return response;
}, function (error) {
  return error;
});

export default api;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用一个全局的currentResq来作为请求是否完成的标志。在axios请求拦截器种，将当前请求的数据记录在currentResq中，并将done设置为false。在axios响应拦截器中，约定url，method，data3个参数一样时，就是当前currentResq中记录的请求返回数据，并将done设置为true。&lt;/p&gt;
&lt;p&gt;　　同样的在指令逻辑中加入一个轮询监听currentResq的done是否完成。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
clickForbidden.js

let forbidClick = null;
export default {
  bind(e) {
    const el = e;
    let timer = null;
    forbidClick = () =&amp;gt; {
      el.disabled = true;
      el.classList.add('is-disabled');
      timer = setInterval(() =&amp;gt; {
        if (window.currentResq.done) {
          clearInterval(timer);
          el.disabled = false;
          el.classList.remove('is-disabled');
        }
      }, 500);
    };
    el.addEventListener('click', forbidClick);
  },
  unbind() {
    document.removeEventListener('click', forbidClick);
  },
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就实现了只要在按钮上加上了v-clickForbidden。按钮点击后就会被禁用，仅当某个请求返回数据或者3s后将按钮的禁用解除。&lt;/p&gt;
&lt;p&gt;　　现在仅仅考虑按钮一次仅发送了一个请求的场景，在currentResq中也可以用一个数据来记录请求。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Sep 2019 15:38:00 +0000</pubDate>
<dc:creator>悠悠洛</dc:creator>
<og:description>前端做后台管控系统，在某些接口请求时间过长的场景下，需要防止用户反复发起请求。 假设某场景下用户点击查询按钮后，后端响应需要长时间才能返回数据。那么要规避用户返回点击查询按钮无外乎是让用户无法在合理时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youyouluo/p/11520783.html</dc:identifier>
</item>
<item>
<title>java架构之路-（11）JVM的对象和堆 - oO从零开始Oo</title>
<link>http://www.cnblogs.com/cxiaocai/p/11520731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxiaocai/p/11520731.html</guid>
<description>&lt;p&gt;　　上次博客，我们说了jvm运行时的内存模型，堆，栈，程序计数器，元空间和本地方法栈。我们主要说了堆和栈，栈的流程大致也说了一遍，同时我们知道堆是用来存对象的，分别年轻代和老年代。但是具体的堆是怎么来存放对象的呢？什么时候可以将对象放置在老年代呢。下面我来看一下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914203926330-720143448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 如果都为默认设置，大致就是这样的。假设我们设置内存堆的大小为600M，那么老年代就大概是400M，我们的年轻代就是200M，然后年轻代的eden区域占160M也就是200M的8/10，一般新建的对象都在这，我是说一般啊。后面会用这个600M来详细说明，from和 to区域各占20M，也就是Survivor区域占用40M，每次做完minor GC，对象就放在这个区域。&lt;/p&gt;
&lt;p&gt;　　我刚才说到，有时候对象不在年轻代，那么我来具体分析一下，什么情况放置在年轻代，而什么时候又放置在老年代。&lt;/p&gt;
&lt;p&gt;1，Minor GC之后，存活的对象Survivor区域放不下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bt1;
        bt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[60000 * 1024&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入堆内存日志，我们得到打印结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914212631105-228318777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们得到bt1新建以后，我们的堆内存几乎占满了，现在已经99%了，那么我们再来看一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bt1,bt2;
        bt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[60000 * 1024&lt;span&gt;];
        bt2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[10000 * 1024&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码里我们可以得知，我们新建了bt1之后又新建了bt2，这时我们的eden区域应该不够用了，那么我们的内存会怎么来处理呢。我们来看一下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914213011440-614019088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到已经做了一次GC了，但是还是放不下，那么我们直接将较大的对象直接放置在了堆内存上。&lt;/p&gt;
&lt;p&gt;2，长期存活的对象移到老年代。也就是经过多次minorGC以后，对象还是存活的，我们将该对象移置老年代，一般是15次，也就是对象头内的分代年龄达到15岁时，我们将该对象移置老年代。&lt;/p&gt;
&lt;p&gt;3，对象动态年龄判断。&lt;/p&gt;
&lt;p&gt;　　这个很重要的一个理论知识，大概来说一下，当我们做完minorGC以后，对象放在to区域，也就是我们Survivor的to区域，可能对象是放不下的，这时会来计算分类年龄，大致是这样来算的将所有分代年龄为1的相加，再加上分代年龄为2的，再加分代年龄为3的，依次相加，一直加到最大的分代年龄，但在相加过程中，你会发现加到分代年龄为m的对象，总大小已经放满了to区域，这时就将m到n分代年龄的对象都移置到老年代，包含m。也就是大于Survivor区域的50%时，则后面的对象，包含该年龄的对象都放置在老年代。&lt;/p&gt;
&lt;p&gt;4，大对象直接放在老年代。再来看段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bt1;
        bt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[90000 * 1024&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914213851098-1902048217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面我知道我们创建一个大概600M的对象放置在eden时，占了99%，那么我们创建大于600M的对象，eden一定放不下了。那么直接放置在老年代。这里参数也是可以设置的。我来设置一个参数再看看，设置参数为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-XX:PretenureSizeThreshold=10000000 -XX:+UseSerialGC -XX:+PrintGCDetails   &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bt1;
        bt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[20000 * 1024&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914214424467-786899603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们设置了参数，声明10M的对象就为大对象，我们创建了一个大概20M的对象，就直接放置在了老年代上。就是对象经历那么多次的minorGC了，jvm虚拟机会认为你可能会一直存活，趁着这次放不下了，你就趁早过来吧，来我们老年代混吧。&lt;/p&gt;
&lt;p&gt;5，老年代空间分配担保机制。&lt;/p&gt;
&lt;p&gt;　　其实我们每次进行minorGC前，会有一系列操作的，可能会进行full GC的，那么我们来看一下流程吧。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201909/1506597-20190914223931983-1616243805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我来解释一下上面那个五彩缤纷的图。等我们的eden区满时，需要进行minorGC，这时会优先看一下老年代的剩余空间大小，如果老年代剩余的空间不多了，我们就&lt;span&gt;&lt;strong&gt;可能&lt;/strong&gt;&lt;/span&gt;进行full GC，也就是我们老年代的剩余空间小于我们的eden区内将要进行minorGC对象的总和。&lt;/p&gt;
&lt;p&gt;如果真的小了，那么我们往下走，我们会判断时候配置了-XX:-HandlePromotionFailure （jdk8以上默认设置）这个参数，如果没配置，直接进行fullGC，如果配置了就去判断老年代的剩余空间是否小于我们每次minorGC后每次要放在老年代对象大小的平均值，如果老年代小于minorGC了，那么进行fullGC。否则不需要进行full GC。&lt;/p&gt;
&lt;p&gt;eden和Survivor（from和to）默认比例是8：1：1，但是jvm可能会将我们的参数优化，也就是-XX:+UseAdaptiveSizePolicy这个默认参数，我将其改为-XX:-UseAdaptiveSizePolicy不进行优化，保持8：1：1的比例了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;我们再来看一下什么样的对象是可以被回收的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，引用计数法（基本不用，循环引用对象永远无法销毁，可能内存溢出）&lt;/p&gt;
&lt;p&gt;　　给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用 失效，计数器就减1;任何时候计数器为0的对象就是不可能再被使用的。 &lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 7&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　GC Roots根节点一般为线程栈的本地变量、静态变量、本地方法栈的变量等等。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2，可达性分析算法。&lt;/p&gt;
&lt;p&gt;　　这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点， 从这些节点开始向下搜索，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象&lt;/p&gt;
&lt;p&gt;3，常见的引用类型。&lt;/p&gt;
&lt;p&gt;　　java的引用类型一般分为四种:强引用、软引用、弱引用、虚引用 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.ref.SoftReference;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.ref.WeakReference;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强引用&lt;/span&gt;
        WeakReference&amp;lt;User&amp;gt; user2 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;User&amp;gt;(&lt;span&gt;new&lt;/span&gt; User());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弱引用&lt;/span&gt;
        SoftReference&amp;lt;User&amp;gt; user3 = &lt;span&gt;new&lt;/span&gt; SoftReference&amp;lt;User&amp;gt;(&lt;span&gt;new&lt;/span&gt; User());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;软引用&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一般将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。 &lt;/p&gt;
&lt;p&gt;4，finalize最终判断对象存活。&lt;/p&gt;
&lt;p&gt;　　finalize是在对象马上要被收回之前运行的最后一个方法，可以写逻辑，但是完全不建议去这样去写，很可能出现对象永远不会被回收，造成内存溢出，也就是说在finalize方法内还可能“救活”我们的对象。&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 9&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;　　即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;如何判断一个类是无用的类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 9&quot; readability=&quot;40.5&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;28&quot;&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 10&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1.该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何 实例。&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 10&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;2.加载该类的 ClassLoader 已经被回收。&lt;/p&gt;
&lt;p&gt;3.该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;最后我们来看一下逃逸分析。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　   JVM的运行模式用三种，分别是解释模式，编译模式和混合模式，这里简单说一下这个问题，不然后面会蒙圈的。&lt;/p&gt;
&lt;p&gt;解释模式就是执行一行JVM字节码就编译一行为机器码，这样的好处就是很节省内存空间，不用把所有的字节码都塞到内存里面去，运行效率低，但是启动快。&lt;/p&gt;
&lt;p&gt;编译模式和解释模式恰恰相反，是先将所有JVM字节码一次编译为机器码，然后一次性执行所有机器码。这样会提高我们的运行效率，但是消耗空间资源。&lt;/p&gt;
&lt;p&gt;混合模式是上面的总和，依然使用解释模式执行代码，但是对于一些 &quot;热点&quot; 代码采用编译模式执行，JVM一般采用混合模式执行代码。&lt;/p&gt;
&lt;p&gt;我们来看一段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUserBeanTest() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放置在堆上&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; userBeanTest() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;优先和方法一起发放置在栈上.&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说明，对象也是有很小的可能放置在栈上的。中秋放假了，明天补一下mybatis的底层是实现原理。过几天继续来说我们的jvm优化&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 14 Sep 2019 15:18:00 +0000</pubDate>
<dc:creator>oO从零开始Oo</dc:creator>
<og:description>上次博客，我们说了jvm运行时的内存模型，堆，栈，程序计数器，元空间和本地方法栈。我们主要说了堆和栈，栈的流程大致也说了一遍，同时我们知道堆是用来存对象的，分别年轻代和老年代。但是具体的堆是怎么来存放</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxiaocai/p/11520731.html</dc:identifier>
</item>
<item>
<title>Spring之IOC - 奋进的小样</title>
<link>http://www.cnblogs.com/fenjyang/p/11520646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fenjyang/p/11520646.html</guid>
<description>&lt;p&gt;​ 本篇博客分享一些关于Spring中一个核心概念，IOC。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;IOC：&lt;/code&gt;Inversion of Control ，控制反转。&lt;/p&gt;
&lt;p&gt;​ 通常情况下对于实例化一个对象，我们会通过关键字new创建出来。但是在实际项目开发中不可能有一个实例化对象，而多个对象就需要多个new创建。显然，这势必造成多个对象之间的耦合，以及对程序的维护性带来困难。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;控制反转&lt;/strong&gt; ，顾名思义就是将控制权力交给Spring容器。简单理解就是将创建bean的工作交给Spring来做，对于开发人员来说就不需要再手动创建。并且Spring容器会自动维护bean之间的关系，及bean的生命周期等，大大降低了程序之间的耦合。&lt;/p&gt;
&lt;p&gt;​ 接着再说说和IOC相关的另一个概念：&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;DI：&lt;/code&gt;Dependency Injection，依赖注入。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;依赖注入&lt;/strong&gt;，在程序运行时，动态的向对象中注入它所依赖的对象。举例，A对象依赖B对象中的某些属性或方法，但是在Spring容器创建A对象之前，并不知道A的依赖关系。因此在真正创建A对象时，发现依赖了B对象，则此时也会将B对象创建出来并注入到A中，这就是依赖注入。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;我个人的理解就是DI是IOC的一种体现方式，这也是DI和IOC两者的区别。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​ &lt;code&gt;BeanFactory&lt;/code&gt;和&lt;code&gt;ApplicationContext&lt;/code&gt;是IOC容器体现形态的两大核心接口，请看下图两者之间的联系。&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1655301/201909/1655301-20190914224419600-801652541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 两者之间是继承关系，&lt;code&gt;BeanFactory&lt;/code&gt;作为最顶层接口，里面只实现了容器的基本功能，是一种&lt;strong&gt;简单容器&lt;/strong&gt;。而&lt;code&gt;ApplicationContext&lt;/code&gt;作为最底层的子类，则自然拥有父类的基本功能，并且还增加了很多面向框架的特性，如国际化，时间发布等，是一种&lt;strong&gt;高级容器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext：&lt;/code&gt;&lt;br/&gt;​ 它在构建容器时，创建对象采用的策略是采用&lt;strong&gt;立即加载&lt;/strong&gt;的方式，也就是说当读取完配置文件时，容器就是马上创建对象。&lt;br/&gt;&lt;code&gt;BeanFactory:&lt;/code&gt;&lt;br/&gt;​ 它在构建核心容器时，创建对象采取的策略是&lt;strong&gt;延时加载&lt;/strong&gt;，什么时候根据id获取对象时，容器才会真正创建对象。&lt;/p&gt;
&lt;p&gt;​ 这里我们只总结关于ApplicationContext接口的使用。&lt;/p&gt;

&lt;p&gt;​ &lt;code&gt;ApplicationContext&lt;/code&gt;是一个接口，那么要想使用该接口就要实例化它的实现类，请看如下所示：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1655301/201909/1655301-20190914224433268-1029239507.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 其中常用的三个实现类为：&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;ClassPathXmlApplicationContext：&lt;/code&gt;加载类路径下的配置文件。&lt;br/&gt;​ &lt;code&gt;FileSystemXmlApplicationContext：&lt;/code&gt;加载磁盘中任意位置的配置文件（&lt;strong&gt;要有访问权限）&lt;/strong&gt;。&lt;br/&gt;​ &lt;code&gt;AnnotationConfigApplicationContext：&lt;/code&gt;读取注解标记。&lt;/p&gt;
&lt;p&gt;​ 以上三种都是获取bean的实例化对象，那么我们又如何定义bean对象呢，同样也是有三种方式。&lt;/p&gt;
&lt;h2 id=&quot;第一种使用默认的构造函数创建&quot;&gt;第一种：使用默认的构造函数创建&lt;/h2&gt;
&lt;p&gt;​ 在spring的配置文件中使用bean标签，配置id和class属性使用就是&lt;code&gt;默认的构造函数&lt;/code&gt;创建的对象。&lt;/p&gt;
&lt;p&gt;​ 注意：如果类中没有无参构造函数，则创建对象失败。&lt;/p&gt;
&lt;p&gt;​ 首先定义bean.cml文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
        
        &amp;lt;!-- 第一种方式，使用默认的构造函数--&amp;gt;
        &amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.service.impl.UserServiceImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 定义接口IUserService的实现类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl implements IUserService {
    /**
     * 无参构造
     */
    public UserServiceImpl() {
        System.out.println(&quot;创建对象&quot;);
    }
    @Override
    public void addUser() {
        System.out.println(&quot;添加用户&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 主方法中获取该实例对象：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public class Demo {
    public static void main(String[] args) {
    // 1，加载类路径下的配置文件
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    // 2，通过getBean()获取实例化对象
    IUserService userService = (IUserService) ac.getBean(&quot;userService&quot;);
    // 3，通过bean对象调用方法
    userService.addUser();
    }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 运行结果为：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1655301/201909/1655301-20190914224446543-723372376.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第二种普通工厂模式&quot;&gt;第二种，普通工厂模式&lt;/h2&gt;
&lt;p&gt;​ 使用类中的方法创建对象，并注入到spring容器中。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;思路：&lt;/strong&gt;模拟一个工厂，创建并返回上述实现类对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 模拟bean工厂
public class InstanceBean {
    public IUserService userservice(){
        return new UserServiceImpl();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;instanceBean&quot; class=&quot;com.frame.factory.InstanceBean&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;userService&quot; factory-bean=&quot;instanceBean&quot; factory-method=&quot;userservice&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 而主方法中的代码和上面是一样的，这种创建bean的方式比较灵活，通过配置文件去加载自定义的工厂。&lt;/p&gt;
&lt;h2 id=&quot;第三种普通工厂模式中的静态方法&quot;&gt;第三种，普通工厂模式中的静态方法&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 将方法用static修饰
public class StaticInstanceBean {
    public static IUserService userservice(){
        return new UserServiceImpl();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.factory.StaticInstanceBean&quot; factory-method=&quot;userservice&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;​ 通过IOC可以将创建对象这个事交给Spring容器，那么Bean的作用范围容器是怎么定义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bean标签的scope属性：&lt;/strong&gt;&lt;br/&gt;​ &lt;code&gt;singleton：&lt;/code&gt;单例模式&lt;strong&gt;（默认使用）&lt;/strong&gt;&lt;br/&gt;​ &lt;code&gt;prototype：&lt;/code&gt;多例模式&lt;br/&gt;​ &lt;code&gt;request：&lt;/code&gt;（Spring2.0之后）web应用的请求范围&lt;br/&gt;​ &lt;code&gt;session：&lt;/code&gt;（Spring2.0之后）web用用的会话范围&lt;br/&gt;​ &lt;code&gt;global-session：&lt;/code&gt;（Spring2.0之后）全局会话范围。&lt;/p&gt;
&lt;p&gt;​ 在Spring容器中，默认是使用单例模式，如下代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.service.impl.UserServiceImpl&quot; scope=&quot;singleton&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 1，加载配置文件
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
// 2，获取Bean对象
IUserService userService = (IUserService) ac.getBean(&quot;userService&quot;);
// 3，再次获取
IUserService userService1 = (IUserService) ac.getBean(&quot;userService&quot;);
        System.out.println(userService == userService1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 运行结果为：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1655301/201909/1655301-20190914224503011-102803586.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 证明多次获取Bean对象，在单例模式下是同一个对象。同样，将配置文件中scope值改为多例模式，如下代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.service.impl.UserServiceImpl&quot; scope=&quot;prototype&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 主方法中的代码同上，那么我们直接看运行结果：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2018.cnblogs.com/blog/1655301/201909/1655301-20190914224514310-421758804.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 很明显，在多例模式下IOC创建了两次对象。&lt;/p&gt;

&lt;p&gt;​ 上面我们总结了DI的概念，那么依赖注入都能注入什么类型呢，又可以使用什么方式进行进入呢。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;注入的数据有三类：&lt;/strong&gt;&lt;br/&gt;​ 1，基本数据类型&lt;br/&gt;2，其他bean类型&lt;br/&gt;3，复杂类型（Array，List，Map，Set等）&lt;br/&gt;​ &lt;strong&gt;注入的三种方式：&lt;/strong&gt;&lt;br/&gt;1，使用函数构造&lt;br/&gt;​ 2，使用set方法提供&lt;br/&gt;​ 3，使用注解提供&lt;/p&gt;
&lt;h2 id=&quot;第一种使用函数构造&quot;&gt;第一种，使用函数构造&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl{
    private Integer id;
    private String name;
    private Date birthday;

    public UserServiceImpl(){}
    public UserServiceImpl(Integer id,String name,Date birthday) {
        this.id = id;
        this.name = name;
        this.birthday = birthday;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.service.impl.UserServiceImpl&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;id&quot; value=&quot;10010&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;小明&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;!-- 声明Date对象 --&amp;gt;
     &amp;lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 标签中属性使用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：指定要注入数据的数据类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index：&lt;/code&gt;指定要注入的数据的索引位置的参数进行赋值，索引值从0开始。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name：&lt;/code&gt;指定给构造函数中指定名称的参数赋值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value：&lt;/code&gt;提供基本类型和String类型的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref：&lt;/code&gt;引用其他bean类型数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第二种使用set方法提供&quot;&gt;第二种，使用set方法提供&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserServiceImpl{

    private Integer id;
    private String name;
    private Date birthday;

    public void setId(Integer id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.frame.service.impl.UserServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;10010&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;张三&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;!-- 声明Date对象 --&amp;gt;
     &amp;lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 标签的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;name：&lt;/code&gt;指定注入时set方法名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value：&lt;/code&gt;提供基本类型和String类型的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref：&lt;/code&gt;引用其他bean类型数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第三种注解形式&quot;&gt;第三种，注解形式&lt;/h2&gt;
&lt;p&gt;​ &lt;code&gt;@Autowired：&lt;/code&gt;自动注入&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;@Qualifier：&lt;/code&gt;与@Autowired搭配使用，按照名称进行注入。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;@Resource：&lt;/code&gt;通过id进行注入，可单独使用。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;注意：这三种只能注入bean类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;@Value：&lt;/code&gt;用于注入基本类型和String类型的数据。&lt;/p&gt;

&lt;p&gt;​ 本篇博客是帮助理解IOC的概念，通过上述总结能有一个更好更简单的理解。对于Spring还有一个核心概念就是AOP思想，这将会在下一篇博客种总结分享。&lt;/p&gt;
&lt;p&gt;​ 以上内容均是自主学习总结，如有不适之处欢迎留言指正。&lt;/p&gt;
&lt;p&gt;感谢阅读！&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sat, 14 Sep 2019 14:46:00 +0000</pubDate>
<dc:creator>奋进的小样</dc:creator>
<og:description>一，前言 ​	本篇博客分享一些关于Spring中一个核心概念，IOC。 ​ Inversion of Control ，控制反转。 ​	通常情况下对于实例化一个对象，我们会通过关键字new创建出来。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fenjyang/p/11520646.html</dc:identifier>
</item>
<item>
<title>Mac开发必设置的Finder设置项，你设置了吗？ - 元宝爸爸</title>
<link>http://www.cnblogs.com/wozixiaoyao/p/11520610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wozixiaoyao/p/11520610.html</guid>
<description>&lt;p&gt;1、显示标签页、显示路径栏、显示状态栏的设置位置，在访达-&amp;gt;显示-&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914220751114-1523500353.png&quot; alt=&quot;&quot; width=&quot;493&quot; height=&quot;653&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;显示状态栏&lt;/h3&gt;
&lt;p&gt;个人三个都设置了，但是觉得显示状态栏用的并不多，反而多一行，下面是显示状态栏的效果，主要可以一眼看出有多少项目和多少存储空间可用。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221004317-1217198116.png&quot; alt=&quot;&quot; width=&quot;1111&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;显示标签页&lt;/h3&gt;
&lt;p&gt;设置之后，可以在一个finder窗口打开多个finder标签，就像浏览器的便签也一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221220325-1386170205.png&quot; alt=&quot;&quot; width=&quot;998&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击右边的加号＋可以打开多个标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221258679-603373223.png&quot; alt=&quot;&quot; width=&quot;1083&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这个功能自己用的非常多&lt;/p&gt;

&lt;h3&gt;显示路径栏 &lt;/h3&gt;
&lt;p&gt;设置后的效果，在Finder窗口下面可以看到路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221651514-1414986119.png&quot; alt=&quot;&quot; width=&quot;821&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 选中文件也能看到文件的路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221744258-274924328.png&quot; alt=&quot;&quot; width=&quot;967&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里把文件路径或者文件夹路径显示出来之后，就可以接着设置更方便的功能了，接着看下面的。&lt;/p&gt;

&lt;h3&gt;拷贝文件路径，拷贝文件夹路径&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914221947815-584874820.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 右键或者两指同时选中路径，就能看到拷贝为路径的选项。&lt;/p&gt;
&lt;p&gt;拷贝文件路径操作类似，先选中文件，然后选中路径，调出上下文菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914222207606-249057846.png&quot; alt=&quot;&quot; width=&quot;806&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;在终端打开文件夹&lt;/h3&gt;
&lt;p&gt;开发中这个功能也很实用。&lt;/p&gt;
&lt;p&gt;Linux系统默认就有。&lt;/p&gt;
&lt;p&gt;Windows也有，按住shift，并右键文件管理器空白区域，就可以看到在此处打开命令行窗口，或者在此处打开PowerShell窗口&lt;/p&gt;

&lt;p&gt;下面说说Mac的设置&lt;/p&gt;

&lt;p&gt;就是接着上面的拷贝文件夹路径的部分，前提就是把显示路径栏设置一下。&lt;/p&gt;
&lt;p&gt;具体看下面的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914222603623-1557983483.png&quot; alt=&quot;&quot; width=&quot;1012&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果你的默认没有，在访达的服务偏好设置中设置一下：&lt;/p&gt;
&lt;p&gt;1、打开服务偏好设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914222739137-1471230973.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2、在如图位置看看这两个有没有勾选：新建位于文件夹位置的终端标签页、新建位于文件夹位置的终端窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842139/201909/842139-20190914222901635-1374477916.png&quot; alt=&quot;&quot; width=&quot;943&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;



&lt;p&gt;相信看到这里，聪明的读者应该对Mac的自动化有个了解了，结合自带的&quot;自动操作&quot;这款app，就可以发挥你的想象设置一个服务了。&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;当然，这个以实用为主，当你有一个想提高效率的想法，先想想mac是否提供了这个设置，如果你有经验，直接根据想法然后自己动手，另外，优先使用Google。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Sep 2019 14:33:00 +0000</pubDate>
<dc:creator>元宝爸爸</dc:creator>
<og:description>1、显示标签页、显示路径栏、显示状态栏的设置位置，在访达-&amp;gt;显示-&amp;gt; 显示状态栏 个人三个都设置了，但是觉得显示状态栏用的并不多，反而多一行，下面是显示状态栏的效果，主要可以一眼看出有多少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wozixiaoyao/p/11520610.html</dc:identifier>
</item>
</channel>
</rss>