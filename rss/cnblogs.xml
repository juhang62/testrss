<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>spaCy 学习 第二篇：语言模型 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/10762035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/10762035.html</guid>
<description>&lt;p&gt;spaCy处理文本的过程是模块化的，当调用nlp处理文本时，spaCy首先将文本标记化以生成Doc对象，然后，依次在几个不同的组件中处理Doc，这也称为处理管道。语言模型默认的处理管道依次是：tagger、parser、ner等，每个管道组件返回已处理的Doc，然后将其传递给下一个组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201905/628084-20190509184437284-515687715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一，加载语言模型&lt;/h2&gt;
&lt;p&gt;spaCy使用的语言模型是预先训练的统计模型，能够预测语言特征，对于英语，共有en_core_web_sm、en_core_web_md和en_core_web_lg三种语言模型，使用spacy.load()函数来加载语言模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
spacy.load(name,disable)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，name参数是语言模型的名词，disable参数是禁用的处理管道列表，例如，创建en_core_web_sm语言模型，并禁用ner：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nlp = spacy.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_core_web_sm&lt;/span&gt;&lt;span&gt;&quot;, disable=['ner']&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语言模型中不仅预先定义了Language管道，还定义了处理文本数据的处理管道（pipeline），其中分词器是一个特殊的管道，它是由Language管道确定的，不属于pipeline。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;core_web_sm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Example model for spaCy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pipeline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tagger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在加载语言模型nlp之后，可以查看该语言模型预先定义的处理管道，也就是说，处理管道依赖于统计模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，查看nlp对象的管道&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; nlp.pipe_names
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tagger&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;parser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，移除nlp的管道&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
nlp.remove_pipe(name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，向nlp的处理管道中增加管道&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
nlp.add_pipe(component, name=None, before=None, after=None, first=None, last=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二，语言管道和分词器管道&lt;/h2&gt;
&lt;p&gt;Language管道是一个特殊的管道，当调用spacy.load()加载语言模型时，spaCy自动创建Lanuage管道，用于存储共享的词汇表、分词规则（Tokenization Rule）和文本注释。&lt;/p&gt;
&lt;p&gt;分词器管道是跟Language管道息息相关的一个管道，当创建Language管道之后，spaCy根据Language管道提供的词汇表来创建分词器。分词器用于把文本分为单词，标点符号，空格等标记，除了使用默认的分词器之外，spaCy允许用户根据需要对分词器进行调整：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; spacy.tokenizer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Tokenizer
tokenizer &lt;/span&gt;= Tokenizer(vocab=nlp.vocab,rules,prefix_search, suffix_search, infix_search, token_match)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;vocab&lt;/strong&gt;：词汇表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rules&lt;/strong&gt;：dict类型，分词器的特殊规则，把匹配到特殊规则的单词作为一个token，主要是用于设置token的注释（annotation）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prefix_search、suffix_search：&lt;/strong&gt;类型是re.compile(string).search&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;infix_finditer&lt;/strong&gt;：类型是re.compile(string).finditer，把匹配到这前缀、后缀或中缀的字符串作为一个token；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;token_match&lt;/strong&gt;：返回boolean值的函数类型，把匹配到的字符串识别为一个token；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在文本处理的过程中，&lt;strong&gt;spaCy首先对文本分词，原始文本在空格处分割&lt;/strong&gt;，类似于text.split(' ')，然后分词器（Tokenizer）从左向右依次处理token，在处理token时，spaCy做了两个check：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否匹配特殊规则（execption rule）&lt;/li&gt;
&lt;li&gt;是否前缀、中缀或后缀可以分割&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个可选的布尔函数token_match，它匹配的字符串不会被拆分，覆盖以前的规则，对URL或数字之类的东西很有用。&lt;/p&gt;
&lt;h2&gt;三，扩展语言&lt;/h2&gt;
&lt;p&gt;每一种语言都是不同的，通常充满异常和特殊情况，尤其是最常见的单词。 其中一些例外是跨语言共享的，而其他例外则完全具体，通常非常具体，需要进行硬编码。 spaCy.lang模块包含所有特定于语言的数据，以简单的Python文件组织,这使得数据易于更新和扩展。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201905/628084-20190509190558744-1199806452.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个单独的组件可以在语言模块种导入遍历，并添加到语言的Defaults对象种，某些组件（如标点符号规则）通常不需要自定义，可以从全局规则中导入。 其他组件，比如tokenizer和norm例外，则非常具体，会对spaCy在特定语言上的表现和训练语言模型产生重大影响。&lt;/p&gt;
&lt;p&gt;例如，导入English模块，查看该模块的帮助：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; spacy.lang.en &lt;span&gt;import&lt;/span&gt;&lt;span&gt; English
help(English)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这些模块来扩展语言，处理特殊的语法，通常在分词器（Tokenizer）中添加特殊规则和Token_Match函数来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，向分词器中添加特殊的规则&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spacy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; spacy.symbols &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ORTH, LEMMA, POS, TAG

nlp &lt;/span&gt;= spacy.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_core_web_sm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; add special case rule&lt;/span&gt;
special_case = [{ORTH: u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gim&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, LEMMA: u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;give&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, POS: u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VERB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {ORTH: u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;me&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]
nlp.tokenizer.add_special_case(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gimme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, special_case)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，设置特殊的规则来匹配token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个自定义的分词器，使分词把https作为一个token：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spacy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; spacy.lang.en &lt;span&gt;import&lt;/span&gt;&lt;span&gt; English

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_en_tokenizer(nlp):
    prefix_re &lt;/span&gt;=&lt;span&gt; spacy.util.compile_prefix_regex(English.Defaults.prefixes)
    suffix_re &lt;/span&gt;=&lt;span&gt; spacy.util.compile_suffix_regex(English.Defaults.suffixes)
    infix_re &lt;/span&gt;=&lt;span&gt; spacy.util.compile_infix_regex(English.Defaults.infixes)
    pattern_re &lt;/span&gt;= re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^https?://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; spacy.tokenizer.Tokenizer(nlp.vocab,
                                     English.Defaults.tokenizer_exceptions,
                                     prefix_re.search,
                                     suffix_re.search,
                                     infix_re.finditer,
                                     token_match&lt;/span&gt;=pattern_re.match)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在处理文本时调用该分词器，把匹配到正则的文本作为一个token来处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nlp = spacy.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_core_web_sm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
nlp.tokenizer &lt;/span&gt;=&lt;span&gt; my_en_tokenizer(nlp)
doc &lt;/span&gt;= nlp(u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spacy is breaking when combining custom tokenizer's token_match, access https://github.com/explosion/spaCy to get details&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([t.text &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; doc])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，自定义分词器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预先定义的分词器是按照空格来分词的，用于可以自定义分词器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## customer tokenizer&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; myTokenizer(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, vocab):
        self.vocab &lt;/span&gt;=&lt;span&gt; vocab

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self, text):
        words&lt;/span&gt;=&lt;span&gt;[]
        re_search&lt;/span&gt;=&lt;span&gt;my_token_match(text)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; re_search:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; start,end &lt;span&gt;in&lt;/span&gt;&lt;span&gt; re_search.regs:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; start &amp;gt;=0 &lt;span&gt;and&lt;/span&gt; end&amp;gt;=&lt;span&gt;0:
                    words.append(text[start:end])
        text&lt;/span&gt;=&lt;span&gt;my_token_replace(text)
        split_words&lt;/span&gt;=&lt;span&gt;my_token_split(text)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(split_words)

        words.extend([w &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; split_words &lt;span&gt;if&lt;/span&gt; w!=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;])

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; All tokens 'own' a subsequent space character in this tokenizer&lt;/span&gt;
        spaces = [True] *&lt;span&gt; len(words)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Doc(self.vocab, words=words, spaces=&lt;span&gt;spaces)&lt;/span&gt;

&lt;span&gt;###&lt;/span&gt;&lt;span&gt; parse the synonyms&lt;/span&gt;
RE_SYNONYMS=&lt;span&gt;parse_synonyms()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_token_match(text):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt;  RE_SYNONYMS

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re.compile(RE_SYNONYMS).search(text)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_token_replace(text):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt;  RE_SYNONYMS

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; re.compile(RE_SYNONYMS).sub(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,text)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_token_split(text):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;return re.compile('\s+|\W+|_+').split(text)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\s+|\\+|_+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(text)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引用自定义的分词器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nlp=spacy.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_core_web_sm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
nlp.tokenizer &lt;/span&gt;= myTokenizer(nlp.vocab)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spacy.io/usage/linguistic-features#tokenization&quot; target=&quot;_blank&quot;&gt;Linguistic Features-Tokenization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spacy.io/api/language&quot; target=&quot;_blank&quot;&gt;Pipeline&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spacy.io/usage/processing-pipelines&quot; target=&quot;_blank&quot;&gt;Processing Pipelines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spacy.io/usage/adding-languages#language-data&quot; target=&quot;_blank&quot;&gt;Adding Languages&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 07:37:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>spaCy处理文本的过程是模块化的，当调用nlp处理文本时，spaCy首先将文本标记化以生成Doc对象，然后，依次在几个不同的组件中处理Doc，这也称为处理管道。语言模型默认的处理管道依次是：tagg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/10762035.html</dc:identifier>
</item>
<item>
<title>在kubernetes 集群内访问k8s API服务 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10856916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10856916.html</guid>
<description>&lt;p&gt;所有的 kubernetes 集群中账户分为两类，Kubernetes 管理的 serviceaccount(服务账户) 和 useraccount（用户账户）。基于角色的访问控制（“RBAC”）使用“rbac.authorization.k8s.io”API 组来实现授权控制，允许管理员通过Kubernetes API动态配置策略。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153105626-432531399.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153106145-1554393196.png&quot; alt=&quot;image&quot; width=&quot;326&quot; height=&quot;241&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;API Server 内部通过用户认证后，然后进入授权流程。对合法用户进行授权并且随后在用户访问时进行鉴权，是权限管理的重要环节。&lt;br/&gt;在 kubernetes 集群中，各种操作权限是赋予角色(Role 或者 ClusterRole）的。通过创建 RoleBinding 或者 ClusterBinding 把 用户(User),用户组（Group）或服务账号（Service Account）绑定在 Role 或 ClusterRole 上。这样用户，用户组或者服务账号就有了相对应的操作权限。&lt;br/&gt;&lt;code&gt;这里有个需要注意的地方&lt;/code&gt;&lt;br/&gt;ClusterRoleBinding 只能绑定 ClusterRole,而 RoleBinding 可以绑定 Role 或者 ClusterRole。&lt;br/&gt;根据上图：&lt;br/&gt;&lt;code&gt;1&lt;/code&gt;.User1 通过 RoleBinding 把 Role 绑定，可以在 Namespace A 获得 Role 中的权限；&lt;br/&gt;&lt;code&gt;2&lt;/code&gt;.User2 和 User3 通过 RoleBinding 把 ClusterRole 绑定，这两个用户即可以在 Namespace B 空间中获得 ClusterRole 权限；&lt;br/&gt;&lt;code&gt;3&lt;/code&gt;.如果 User1 通过 ClusterRoleBinding 把 ClusterRole 绑定，这个用户即可在所有的 Namespace 空间中获得 ClusterRole 权限；&lt;/p&gt;
&lt;p&gt;Service account是为了方便Pod里面的进程调用Kubernetes API或其他外部服务而设计的。它与User account不同，具体参看 &lt;a title=&quot;https://www.kubernetes.org.cn/service-account&quot; href=&quot;https://www.kubernetes.org.cn/service-account&quot;&gt;https://www.kubernetes.org.cn/service-account&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;需要访问 apiserver 需要经过 认证，授权，准入控制 三关。首先需要进行认证，认证通过后再进行授权检查，因有些增删等某些操作需要级联到其他资源或者环境，这时候就需要准入控制来检查级联环境是否有授权权限了。默认情况下，RBAC策略授予控制板组件、Node和控制器作用域的权限，但是未授予“kube-system”命名空间外服务帐户的访问权限。这就允许管理员按照需要将特定角色授予服务帐户。具体授权可以参看 Kubernetes-基于RBAC的授权： &lt;a title=&quot;https://www.kubernetes.org.cn/4062.html&quot; href=&quot;https://www.kubernetes.org.cn/4062.html&quot;&gt;https://www.kubernetes.org.cn/4062.html&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在k8s集群的Pod 访问API Server，就是需要使用Servive account 的RBAC的授权。下面的代码就是K&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10632282.html&quot;&gt;ubernetes 客户端KubeClient&lt;/a&gt; 的实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153106549-1562364876.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153107197-254945370.png&quot; alt=&quot;image&quot; width=&quot;782&quot; height=&quot;325&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从k8s 带给pod的环境变量、token以及证书去访问k8s API Server。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153107680-1291184819.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201905/510-20190513153108301-1117311468.png&quot; alt=&quot;image&quot; width=&quot;487&quot; height=&quot;614&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以这里就是要给Service Account 授权，授权可以参考Kubernetes-基于RBAC的授权： &lt;a title=&quot;https://www.kubernetes.org.cn/4062.html&quot; href=&quot;https://www.kubernetes.org.cn/4062.html&quot;&gt;https://www.kubernetes.org.cn/4062.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 07:31:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>所有的 kubernetes 集群中账户分为两类，Kubernetes 管理的 serviceaccount(服务账户) 和 useraccount（用户账户）。基于角色的访问控制（“RBAC”）使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10856916.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：微处理器CPU性能测试基准(Dhrystone) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/10856831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/10856831.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;微处理器CPU性能测试基准Dhrystone&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　在嵌入式系统行业用于评价CPU性能指标的标准主要有三种：Dhrystone、MIPS、CoreMark，其中Dhrystone是一种古老的却历时30年而不衰的嵌入式系统处理器测试基准，至今仍为各大处理器生产厂商所采用。今天痞子衡就和大家详细聊一聊Dhrystone。&lt;/p&gt;
&lt;h3 id=&quot;一经典性能测试标准集&quot;&gt;一、经典性能测试标准集&lt;/h3&gt;
&lt;p&gt;　　在讲Dhrystone之前，痞子衡想先给大家简介一下19世纪70-80年代开始流行的几个性能测试标准，它们分别是Livermore、Whetstone、Linpack、Dhrystone，这四个性能测试标准也被合称为Classic Benchmark。这个网址简单介绍了四大经典性能测试标准历史 &lt;a href=&quot;http://www.roylongbottom.org.uk/classic.htm&quot; class=&quot;uri&quot;&gt;http://www.roylongbottom.org.uk/classic.htm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/Dhrystone_classic_benchmarks.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　细心的朋友应该会注意到Dhrystone与另一标准Whetsone名字有点类似，其实Dhrystone就是为了与算法Whetsone区分而设计的。Whetsone于1972年所开发，主要目的是模仿60个1970年后的程序算法。其最有名的版本为Fortran版，高度反映了60年代数字计算方向。Dhrystone与Whetsone不同之处在于其并不包括浮点运算。&lt;/p&gt;
&lt;h3 id=&quot;二dhrystone标准&quot;&gt;二、Dhrystone标准&lt;/h3&gt;
&lt;p&gt;　　Dhrystone是由Reinhold P. Weicker在1984年提出来的一个基准测试程序，其主要目的是测试处理器的整数运算和逻辑运算的性能。Dhrystone首先用Ada语言发布，后来Rick Richardson为Unix开发了用C语言编写的Version 1.1，这个版本也成功的推动了Dhrystone的广泛应用。&lt;br/&gt;　　Dhrystone标准的测试方法很简单，就是单位时间内跑了多少次Dhrystone程序，其指标单位为DMIPS/MHz。MIPS是Million Instructions Per Second的缩写，每秒处理的百万级的机器语言指令数。DMIPS中的D是Dhrystone的缩写，它表示了在Dhrystone标准的测试方法下的MIPS。&lt;/p&gt;
&lt;h4 id=&quot;获取程序&quot;&gt;2.1 获取程序&lt;/h4&gt;
&lt;p&gt;　　Dhrystone程序的最新版本是2.1，其实际上于1988年便已停更。Dhrystone并没有官网，所以想下载其源程序可能会有很多来源，有各种语言版本的实现，以及各种平台下的移植程序。&lt;br/&gt;　　Roy Longbottom，是一个来自英国政府计算机采购部门Central Computer and Telecommunications Agency (CCTA)的职员，他制作了一个PC性能测试结果网站，搜集了很多性能测试程序以及结果，其中便有Dhrystone，我们可以从他的网站下载Dhrystone源码(C语言版)。&lt;/p&gt;
&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;核心程序下载 &lt;a href=&quot;http://www.roylongbottom.org.uk/classic_benchmarks.tar.gz&quot; class=&quot;uri&quot;&gt;http://www.roylongbottom.org.uk/classic_benchmarks.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　核心程序包下载后，在\classic_benchmarks\source_code\dhrystone2\下可找到源代码。详细文件目录如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;\classic_benchmarks\source_code\dhrystone2
                                          \dhry.h          --关于兼容性的原型定义
                                          \dhry_1.c        --主程序入口
                                          \dhry_2.c        --算法子程序&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　如果是移植到ARM Cortex-M平台下裸系统运行，一般只需要简单修改dhry.h和dhry_1.c文件即可，Dhrystone本身并没有太多移植工作，其源码本是用作在PC上运行的，而在嵌入式系统里运行仅需要把一些文件I/O的相关代码删除即可，此外就是计时函数和打印函数的重实现。&lt;/p&gt;
&lt;h4 id=&quot;配置参数&quot;&gt;2.2 配置参数&lt;/h4&gt;
&lt;p&gt;　　Dhrystone源码几乎没有提供配置选项，唯一一个能算得上的配置就是关于REG的宏定义，即你所选用的IDE和嵌入式平台是否支持regiser关键字。&lt;/p&gt;
&lt;h4 id=&quot;程序解析&quot;&gt;2.3 程序解析&lt;/h4&gt;
&lt;p&gt;　　让我们尝试分析Dhrystone主函数入口main：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void main (int argc, char *argv[])
{
          One_Fifty   Int_1_Loc;
    REG   One_Fifty   Int_2_Loc;
          One_Fifty   Int_3_Loc;
    REG   char        Ch_Index;
          Enumeration Enum_Loc;
          Str_30      Str_1_Loc;
          Str_30      Str_2_Loc;
    REG   int         Run_Index;
    REG   int         Number_Of_Runs;
          int         endit, count = 10;
    // ...

    // 定义和初始化关键buffer
    Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
    Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
    Ptr_Glob-&amp;gt;Ptr_Comp                    = Next_Ptr_Glob;
    // ...

    // 设置循环跑Dhrystone核心算法程序次数
    Number_Of_Runs = 5000;

    do
    {
        Number_Of_Runs = Number_Of_Runs * 2;
        count = count - 1;

        // 开始循环跑Dhrystone核心算法程序且记录累计消耗时间
        start_time();
        for (Run_Index = 1; Run_Index &amp;lt;= Number_Of_Runs; ++Run_Index)
        {
            Proc_5();
            Proc_4();
            // ...
        }
        end_time();
        User_Time = secs;

        printf (&quot;%12.0f runs %6.2f seconds \n&quot;,(double) Number_Of_Runs, User_Time);
        if (User_Time &amp;gt; 2)
        {
            count = 0;
        }
        else
        {
            if (User_Time &amp;lt; 0.05)
            {
                Number_Of_Runs = Number_Of_Runs * 5;
            }
        }
    }
    while (count &amp;gt;0);

    // ...
    // 最终信息的打印
    if (User_Time &amp;lt; Too_Small_Time)
    {
        printf (&quot;Measured time too small to obtain meaningful results\n&quot;);
        printf (&quot;Please increase number of runs\n&quot;);
        printf (&quot;\n&quot;);
    }
    else
    {
        Microseconds = User_Time * Mic_secs_Per_Second / (double) Number_Of_Runs;
        Dhrystones_Per_Second = (double) Number_Of_Runs / User_Time;
        Vax_Mips = Dhrystones_Per_Second / 1757.0;

        printf (&quot;Microseconds for one run through Dhrystone: &quot;);
        printf (&quot;%12.2lf \n&quot;, Microseconds);
        printf (&quot;Dhrystones per Second:                      &quot;);
        printf (&quot;%10.0lf \n&quot;, Dhrystones_Per_Second);
        printf (&quot;VAX  MIPS rating =                          &quot;);
        printf (&quot;%12.2lf \n&quot;,Vax_Mips);
        printf (&quot;\n&quot;);
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果格式&quot;&gt;2.4 结果格式&lt;/h4&gt;
&lt;p&gt;　　当移植好Dhrystone程序后，便可以开始跑起来了，下面是一个主频100MHz的Pentium处理器跑分结果：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt; Dhrystone Benchmark  Version 2.1 (Language: C)

 Final values:

 Int_Glob:      O.K.  5
 Bool_Glob:     O.K.  1
 Ch_1_Glob:     O.K.  A
 Ch_2_Glob:     O.K.  B
 Arr_1_Glob[8]: O.K.  7
 Arr_2_Glob8/7: O.K.     1600010
 Ptr_Glob-&amp;gt;
   Ptr_Comp:       *  98008
   Discr:       O.K.  0
   Enum_Comp:   O.K.  2
   Int_Comp:    O.K.  17
   Str_Comp:    O.K.  DHRYSTONE PROGRAM, SOME STRING
 Next_Ptr_Glob-&amp;gt;
   Ptr_Comp:       *  98008 same as above
   Discr:       O.K.  0
   Enum_Comp:   O.K.  1
   Int_Comp:    O.K.  18
   Str_Comp:    O.K.  DHRYSTONE PROGRAM, SOME STRING
 Int_1_Loc:     O.K.  5
 Int_2_Loc:     O.K.  13
 Int_3_Loc:     O.K.  7
 Enum_Loc:      O.K.  1
 Str_1_Loc:     O.K.  DHRYSTONE PROGRAM, 1'ST STRING
 Str_2_Loc:     O.K.  DHRYSTONE PROGRAM, 2'ND STRING

 Register option      Selected.

 Microseconds 1 loop:          4.53
 Dhrystones / second:      220690
 VAX MIPS rating:            125.61&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　其中最核心的数据便是Dhrystones / second的数值。&lt;/p&gt;
&lt;h4 id=&quot;跑分榜&quot;&gt;2.5 跑分榜&lt;/h4&gt;
&lt;p&gt;　　Roy Longbottom的网站收集记录了很多款处理器的Dhrystone跑分结果，可移步他的网站链接查看 &lt;a href=&quot;http://www.roylongbottom.org.uk/dhrystone%20results.htm#anchorAndroid&quot;&gt;http://www.roylongbottom.org.uk/dhrystone%20results.htm#anchorAndroid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　至此，微处理器CPU性能测试基准Dhrystone痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 07:21:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>在嵌入式系统行业用于评价CPU性能指标的标准主要有三种：Dhrystone、MIPS、CoreMark，其中Dhrystone是一种古老的却历时30年而不衰的嵌入式系统处理器测试基准，至今仍为各大处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/10856831.html</dc:identifier>
</item>
<item>
<title>考勤系统+（小项目） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10855933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10855933.html</guid>
<description>&lt;p&gt;&lt;strong&gt;时间：2018年5月&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段：大二下学期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景：射频识别应用系统课设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名称：考勤系统+&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;考勤系统+，是传统考勤系统的升级版，采用了无线技术进行考勤信息的实时传送，系统可对考勤信息进行准确分析得出考勤结果并实时反馈给对应考勤机，达到员工告知效果，并将考勤数据存入数据库，系统集成有员工信息入录、刷卡信息实时监控、员工管理、网页及安卓端员工个人信息及考勤信息查询、系统安全等。&lt;/p&gt;
&lt;p&gt;考勤系统对一个公司的员工管理是必不可少的，而无线考勤系统，为公司考勤提供了更多高效的运作方式，减少了公司的线材花费及维护，并集成了管理员模块及员工模块，是一种绿色与智能的体现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;考勤系统；无线；可扩展；安全&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;h3&gt;2.1  课题描述&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;考勤系统是企业必不可少的管理利器，考勤是为维护企业的正常工作秩序，提高办事效率，严肃企业纪律，使员工自觉遵守工作时间和劳动纪律。&lt;/p&gt;
&lt;h3&gt;2.2  系统目标&lt;/h3&gt;
&lt;p&gt;         对员工的考勤和考核是企业人力资源管理中的一项重要内容，传统的考勤主要是人工签到考勤和考勤机考勤， 人工考勤比较费时费人工，而且还麻烦，准确率又不高；而传统的考勤机对考勤数据处理一般是采用RS-232或RS-485串口布线传输数据给主机的控制台进行数据保存或本地存储考勤数据，第一种数据处理方式：其一，它们都是有传输距离限制的，其二，如果考勤机较主机控制台距离远的话或者公司考勤机较多的话，将会带来大量的布线，为后期的维护工作带来诸多不便之处；而第二种数据处理方式：对后期的人工数据处理依赖很大，且容易造成数据丢失。&lt;/p&gt;
&lt;p&gt;        考勤系统+，是传统考勤机的升级版，采用了无线技术进行考勤信息的实时传送，系统可对考勤信息进行准确分析得出考勤结果并实时反馈给对应考勤机，达到员工告知效果，并将考勤数据存入数据库，系统集成有员工信息入录、刷卡信息实时监控、员工管理、网页及安卓端员工个人信息及考勤信息查询、系统安全等。&lt;/p&gt;
&lt;p&gt;系统将会带来更加高效的公司员工考勤管理。&lt;/p&gt;
&lt;h3&gt;2.3  环境&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) &lt;/strong&gt; &lt;strong&gt;操作系统&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;      Windows10家庭版 64位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b) &lt;/strong&gt; &lt;strong&gt;使用软件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       总控制台开发：eclipse&lt;/p&gt;
&lt;p&gt;      安卓开发：Android Studio2.0&lt;/p&gt;
&lt;p&gt;      网页开发：Adobe Dreamweaver CC 2017&lt;/p&gt;
&lt;p&gt;       数据库：Microsoft SQL Server 2016&lt;/p&gt;
&lt;p&gt;       WiFi开发：ESP8266IDE&lt;/p&gt;
&lt;p&gt;       CC2530模块开发：IAR Embedded Workbench&lt;/p&gt;
&lt;p&gt;       文档编写：Microsoft Word 2016&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) &lt;/strong&gt;  &lt;strong&gt;开发语言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Java&lt;/p&gt;
&lt;p&gt;        PHP&lt;/p&gt;
&lt;p&gt;        html5&lt;/p&gt;
&lt;h2&gt;系统需求分析&lt;/h2&gt;
&lt;p&gt;        相比于传统的考勤系统，本考勤系统+，最为突出的是实现了无线实时传输的功能，只要考勤机与主机在同一网络环境下，不管是局域网还是互联网，其都可以实现实时而可靠 的数据交互。&lt;/p&gt;
&lt;p&gt;       考勤系统对一个公司的员工管理是必不可少的，而无线考勤系统，为公司考勤提供了更多高效的运作方式，减少了公司的线材花费及维护，并集成了管理员模块及员工&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513121323011-1777956522.png&quot; alt=&quot;&quot;/&gt;图3.1  系统总体设计图&lt;/p&gt;

&lt;h3&gt;3.1  系统功能&lt;/h3&gt;
&lt;p&gt;1) 员工信息入录：员工入职时管理员将员工个人信息保存进入公司数据库网络；&lt;/p&gt;
&lt;p&gt;2) 员工信息管理：管理员可通过控制台对所有员工信息进行查看及管理；&lt;/p&gt;
&lt;p&gt;3) 实时监测平台：管理员可通过实时监控平台对员工的刷卡情况进行实时监控；&lt;/p&gt;
&lt;p&gt;4) 无线刷卡机：无线刷卡机带有蜂鸣器及显示屏等，可将员工的刷卡信息通过无线的方式发送给公司控制台；&lt;/p&gt;
&lt;p&gt;5) 公司网页端：员工可通过自己的工号和姓名登入公司网站，进行个人信息的查询及本月的的刷卡记录查询；&lt;/p&gt;
&lt;p&gt;6) 公司安卓端：员工可下载公司APP，通过自己的工号和姓名登入，进行个人信息的查询及本月的的刷卡记录查询。&lt;/p&gt;
&lt;h3&gt;3.2  系统特点&lt;/h3&gt;
&lt;p&gt;1)  无线技术：通过WiFi组网，进行数据的无线传输；&lt;/p&gt;
&lt;p&gt;2)  图片保存：图片通过PHP表单提交文件方式，将员工头像图片保存在web服务器，而不是将图片以二进制方式保存在数据库，以减少数据库的并发危险；&lt;/p&gt;
&lt;p&gt;3)  系统安全：管理员通过实时监测平台，可了解每个无线刷卡机的工作状态，也可以监测到每个刷卡机的实时刷卡情况，如果发现有异常卡一直占用考勤机机，管理员可通过控制台暂停考勤机的使用，此时刷卡机将不能进行刷卡，并且蜂鸣器会一直处于报警状态。管理员也可以恢复刷卡机的工作；&lt;/p&gt;
&lt;p&gt;4)  准确性：员工刷卡之后，刷卡信息会实时的传送到控制台，控制台会对信息进行快速分析并返回给刷卡机，刷卡机会将返回的信息显示在屏幕上，以达到准确的告知；&lt;/p&gt;
&lt;p&gt;5)  方便性：员工可通过公司管网及公司手机客户端多渠道获取到本月考勤信息，出现问题可及时反馈；&lt;/p&gt;
&lt;p&gt;6)  可扩展性：读取卡号使用的是物联网单片机CC2530,该单片机功耗低，性能稳定，为未来的系统扩展提供了无限可能。&lt;/p&gt;
&lt;h2&gt;详细设计&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;4.1 员工信息录入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择好对应的串口，点击获取卡号后P将会通过串口向CC2530模块发送相应的指令，CC2530模块接收到PC串口发来的指令后将会进行读卡操作，读卡成功将会通过串口发送卡号给PC机，否则将会发送相应的错误信息给PC。信息入录不可存在未输入项，图片信息将通过PHP提交给web服务器保存信息，其他信息将通过JDBC自接保存入数据库。IC卡号和工号不可重复使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144231029-463188859.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       图4.1 员工信息入录页&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144400823-80812825.png&quot; alt=&quot;&quot; width=&quot;675&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图 4.2  员工信息入录设计图&lt;/p&gt;
&lt;h3&gt;4.2  员工信息管理&lt;/h3&gt;
&lt;p&gt;管理员可在此页总览员工所有信息，并可一键删除上月的考勤数据，输入工号删除员工，带有刷新按钮，可检测新增加员工。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144548978-96778979.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;316&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图4.3  员工信息管理页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144558174-1344208224.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       图4.4  员工信息管理页&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3&lt;/span&gt; &lt;span&gt;员工考勤信息查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;员工可通过公司管网及公司手机客户端多渠道获取到本月考勤信息，在网页或手机端输入工号和姓名，系统将通过PHP的post提交请求，web服务器将会返回相应数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144729079-1834227014.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;210&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 图4.5 员工考勤信息查询&lt;/p&gt;
&lt;h3&gt;4.4 实时监测平台&lt;/h3&gt;
&lt;p&gt;CC2530一直处于寻卡状态，当RC522感应区出现IC卡时，读卡成功后蜂鸣器将会滴一声，CC2530将会把卡号发送给ESP8266，ESP8266随即将卡号发送给PC实时监测平台，平台会将卡号与数据库信息进行比对，并将比对结果信息显示在监测平台对应位置，将比对结果返回给ESP8266，ESP8266将返回结果显示在OLED显示屏模块上。&lt;/p&gt;
&lt;p&gt;管理员可观察刷卡信息页，了解每一台考勤机的状态即对应的刷卡信息，出现异常可通过关闭按钮使考勤机处于报警状态，也可再次按下解除考勤机的报警状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144740162-661095726.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图4.6  实时监测平台页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513144757375-335028921.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4.7  实时监测平台设计图&lt;/p&gt;
&lt;h2&gt;系统测试&lt;/h2&gt;
&lt;h3&gt;5.1 系统总览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145556912-1998574502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.1  PC控制台总览图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145606877-1889643115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图5.2  可复制的无线考勤机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513150405850-383010045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.3  信息录入模块图&lt;/p&gt;

&lt;h3&gt;5.2 系统主要功能测试&lt;/h3&gt;
&lt;p&gt;准备工作，打开数据库服务器，打开web服务器，使整个系统处于同一网路下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145623849-705998032.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图5.4  web服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145649972-324120016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.5  员工信息入录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145655675-997785286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.6  数据库信息变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145705091-1023485427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.7 员工管理页数据变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145710223-1667867684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.8 刷卡实时监测台&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145716631-397300579.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;224&quot;/&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145735200-653286459.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.9 非公司卡刷卡后显示                       图5.10 公司卡刷卡后显示工号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145757623-163020973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图5.11 公司网页端查询信息登入页&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145750867-1035379027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图5.12  公司网页端查询结果展示页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145807314-527625854.png&quot; alt=&quot;&quot;/&gt;                          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201905/1485202-20190513145817624-1924353390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.13手机客户端查询信息登入页                               图5.14 手机客户端查询结果展示页&lt;/p&gt;
&lt;h2&gt;课程设计总结或结论 &lt;/h2&gt;

&lt;p&gt;考勤系统+是传统考勤系统的升级版，本考勤系统已经实现了大体的逻辑，但也存在小许的不足之处，界面的美观，系统功能的扩展都是接下来应该花时间与心思去完成的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;现在处于物联网时代的我们，视乎可以有更多的可能，本系统使用的刷卡机只能短距离实现 IC 卡识别，我想接下来可以将距离慢慢拉远，使用高频识别，加入人脸识别等AI 技术，使考勤系统更具科技感，更有实用性。&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 07:15:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>时间：2018年5月 阶段：大二下学期 背景：射频识别应用系统课设 名称：考勤系统+ 摘要 考勤系统+，是传统考勤系统的升级版，采用了无线技术进行考勤信息的实时传送，系统可对考勤信息进行准确分析得出考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10855933.html</dc:identifier>
</item>
<item>
<title>Vue2.0源码阅读笔记（四）：nextTick - 雾雪天涯</title>
<link>http://www.cnblogs.com/lidengfeng/p/10856352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lidengfeng/p/10856352.html</guid>
<description>&lt;p&gt;  在阅读 nextTick 的源码之前，要先弄明白 JS 执行环境运行机制，介绍 JS 执行环境的&lt;strong&gt;事件循环&lt;/strong&gt;机制的文章很多，大部分都阐述的比较笼统，甚至有些文章说的是错误的，以下为个人理解，如有错误，欢迎指正。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一浏览器中的进程与线程&quot;&gt;一、浏览器中的进程与线程&lt;/h2&gt;
&lt;p&gt;  以 chorme 浏览器为例，浏览器中的每个页面都是一个独立的进程，在该进程中拥有多个线程，通常有以下几个常驻线程：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、GUI 渲染线程&lt;/p&gt;&lt;p&gt;2、JavaScript引擎线程&lt;/p&gt;&lt;p&gt;3、定时触发器线程&lt;/p&gt;&lt;p&gt;4、事件触发线程&lt;/p&gt;&lt;p&gt;5、异步http请求线程&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  &lt;strong&gt;GUI 渲染线程&lt;/strong&gt;解析 html 生成 DOM 树，解析 css 生成 CSSOM 树，然后将两棵树合并成渲染树，最后根据渲染树画出界面。当 DOM 的修改导致了样式非几何属性的变化时，渲染线程重新绘制新的样式，称为“重绘”；当 DOM 的修改导致了样式几何属性的变化，渲染线程会重新计算元素的集合属性，然后将结果绘制出来，称为“回流”。&lt;/p&gt;&lt;p&gt;  &lt;strong&gt;JS 引擎线程&lt;/strong&gt;负责处理Javascript脚本程序，且与GUI 渲染线程是互斥的，因为 js 是可以操控 DOM 的，如果这两个线程并行会导致错误。JS 引擎线程与其他可以并行的线程配合来实现称为&lt;strong&gt;Event Loop&lt;/strong&gt;的 javaScript 执行环境运行机制。&lt;/p&gt;&lt;p&gt;  JS 的运行环境是单线程的，在代码中如果调用形如 setTimeout() 这样的计时功能的 API ，JS 引擎线程会将该任务交给&lt;strong&gt;定时触发器线程&lt;/strong&gt;。定时触发器线程在定时结束之后会将任务放入任务队列中，等待 JS 引擎线程读取。&lt;/p&gt;&lt;p&gt;  JS 与 HTML 之间的交互是通过&lt;strong&gt;事件&lt;/strong&gt;来实现的。在 JS 代码中使用&lt;strong&gt;侦听器&lt;/strong&gt;来预定事件，以便事件发生时执行相应的代码，该代码称为&lt;strong&gt;事件处理程序&lt;/strong&gt;或者&lt;strong&gt;事件侦听器&lt;/strong&gt;。例如点击事件的事件侦听器是 onclick 。&lt;strong&gt;JS 引擎线程&lt;/strong&gt;在执行侦听 DOM 元素的代码时，会将该任务交给&lt;strong&gt;事件触发线程&lt;/strong&gt;处理，当事件被触发时，&lt;strong&gt;事件触发线程&lt;/strong&gt;会将任务放入任务队列中，等待 JS 引擎线程读取。&lt;/p&gt;&lt;p&gt;  JS 代码中通过 XMLHttpRequest 发起 ajax 请求时，会使用&lt;strong&gt;异步http请求线程&lt;/strong&gt;来管理，在状态改变时，该线程会将对应的回调放入任务队列中，等待 JS 引擎线程读取。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二event-loop&quot;&gt;二、Event Loop&lt;/h2&gt;
&lt;p&gt;  Javascript 任务分为&lt;strong&gt;同步任务&lt;/strong&gt;和&lt;strong&gt;异步任务&lt;/strong&gt;，同步任务是指调用之后立刻得到结果的任务；异步任务是指调用之后无法立刻得到结果，需要进行额外操作的任务。&lt;/p&gt;&lt;p&gt;  JS 引擎线程顺序执行&lt;strong&gt;执行栈&lt;/strong&gt;中的任务，&lt;strong&gt;执行栈中只有同步任务&lt;/strong&gt;，遇到异步任务就交给相应的线程处理。例如在代码块中有 setTimeout() 方法的调用，则将其交由&lt;strong&gt;定时触发器线程&lt;/strong&gt;处理，定时结束之后&lt;strong&gt;定时触发器线程&lt;/strong&gt;将方法的回调放入自身的任务队列中，当执行栈中的任务处理完之后会读取各线程中任务队列中的事件。&lt;/p&gt;&lt;p&gt;  前面是从同步异步的角度来划分任务的，从执行顺序来说，任务也分为两种：macrotask（宏任务）、microtask（微任务）。异步的 macrotask 执行完之后返回的事件会放在各线程的任务队列中，microtask 执行完之后返回的事件会放在微任务队列中。&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;macrotask包括：script（JS文件）、MessageChannel、setTimeout、setInterval、setImmediate、I/O、ajax、eventListener、UI rendering。&lt;/p&gt;&lt;p&gt;microtask包括：Promise、MutationObserver、已废弃的Object.observe()、Node中的process.nextTick&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其中需要注意的是&lt;strong&gt;GUI 渲染线程&lt;/strong&gt;去渲染页面也是以 macrotask 的形式进行的，这个之后详谈。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/948021/201905/948021-20190513141842062-1572036190.jpg&quot;/&gt;&lt;br/&gt;  JS 执行环境运行机制——Event Loop（事件循环）的过程如上图所示：&lt;/p&gt;&lt;p&gt;1、&lt;strong&gt;JS 引擎线程&lt;/strong&gt;顺序执行&lt;strong&gt;执行栈&lt;/strong&gt;中的任务，以一个 macrotask 为单位，在单个宏任务没有处理完之前，&lt;strong&gt;JS 引擎线程&lt;/strong&gt;不会将程序交由&lt;strong&gt;GUI 渲染线程&lt;/strong&gt;接管。也就是说耗时的任务会阻塞渲染，导致页面卡顿的情况发生。典型浏览器一般1秒钟插入60个渲染帧，也就是说16ms进行一次渲染，单个任务超过16ms，如果渲染树发生改变将得不到及时更新渲染。&lt;/p&gt;&lt;p&gt;  流畅的页面中一般任务执行情况如下所示：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/948021/201905/948021-20190513141911047-650233072.jpg&quot;/&gt;&lt;br/&gt;  单个任务耗时较多，则会发生丢帧的情况：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/948021/201905/948021-20190513141923234-2100644019.jpg&quot;/&gt;&lt;br/&gt;2、&lt;strong&gt;JS 引擎线程&lt;/strong&gt;在执行 macrotask 时，会将遇到的异步任务交给指定的线程处理。当异步任务为 macrotask 时，对应线程处理完毕之后&lt;strong&gt;放入线程自身的任务队列中&lt;/strong&gt;；若异步任务为 microtask 时，对应线程处理完毕之后&lt;strong&gt;放入微任务队列中&lt;/strong&gt;。macrotask 执行完之后会遍历微任务队列中的任务加以执行，清空微任务队列。&lt;/p&gt;&lt;p&gt;3、当&lt;strong&gt;执行栈&lt;/strong&gt;中的任务执行完毕后，会读取各个线程中的任务队列，将各任务队列中的事件添加到&lt;strong&gt;执行栈&lt;/strong&gt;中开始执行。从读取各任务队列中的事件放入&lt;strong&gt;执行栈&lt;/strong&gt;中到清空微任务队列的过程称为一个“tick”。JS引擎线程会循环不断地读取任务、处理任务，这个就称为&lt;strong&gt;Event Loop&lt;/strong&gt;（事件循环）机制。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三nexttick的实现&quot;&gt;三、nextTick的实现&lt;/h2&gt;
&lt;p&gt;  Vue的数据更新采用的是异步更新的方式，这样的好处是数据属性多次求值只不用重复调用渲染函数，能够大幅提高性能。其中，异步更新队列是通过调用 nextTick 方法完成的。&lt;/p&gt;&lt;p&gt;  Vue是数据驱动的框架，最好的情况是在页面重新渲染前完成数据的更新。从前面的讲述中可以知道，浏览器的运行机制是首先执行 macrotask，然后执行 microtask ，清空微任务队列后，再从各线程的任务队列中读取新的事件之前，GUI 渲染线程有可能接管程序，完成页面重新渲染。&lt;/p&gt;&lt;p&gt;  nextTick() 在2.5版本之后被单独提取到一个 js 文件中，并且改变了其实现方式。下面分别介绍两种具体实现情况：&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vue2.5-版本实现方式&quot;&gt;1、Vue2.5+ 版本实现方式&lt;/h3&gt;
&lt;p&gt;  Vue2.5.22 版本的 nextTick() 实现如下所示：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() =&amp;gt; {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  if (!cb &amp;amp;&amp;amp; typeof Promise !== 'undefined') {
    return new Promise(resolve =&amp;gt; {
      _resolve = resolve
    })
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  首先说明其中三个变量，callbacks 是存储异步更新回调的任务队列、pending 标识任务队列是否正在刷新、useMacroTask 变量表明是否强制使用 macrotask 方式执行回调。&lt;/p&gt;&lt;p&gt;  nextTick() 注册一个执行传入回调的函数放入到 callbacks 数组中，如果没有传入回调则返回 Promise 对象。如果队列没有开始刷新，则将等待刷新标识设为 true，开始刷新任务。如果没有强制指明需要使用 macrotask 的方式刷新，则默认调用 microTimerFunc 方法来执行。&lt;/p&gt;&lt;p&gt;  microTimerFunc 方法的实现如下代码所示：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;if (typeof setImmediate !== 'undefined' &amp;amp;&amp;amp; isNative(setImmediate)) {
  macroTimerFunc = () =&amp;gt; { setImmediate(flushCallbacks) }
} else if (typeof MessageChannel !== 'undefined' &amp;amp;&amp;amp; (
  isNative(MessageChannel) ||
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () =&amp;gt; { port.postMessage(1) }
} else {
  macroTimerFunc = () =&amp;gt; { setTimeout(flushCallbacks, 0) }
}

if (typeof Promise !== 'undefined' &amp;amp;&amp;amp; isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () =&amp;gt; {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
} else {
  microTimerFunc = macroTimerFunc
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  microTimerFunc 方法实质就是将 flushCallbacks 方法注册成异步任务加以执行。&lt;/p&gt;&lt;p&gt;  优先使用 Promise 的方式将 flushCallbacks() 的执行注册成 microtask；其中需要注意的是在有的ios环境下，即使将任务推到微任务队列中，队列也不会马上刷新，直到浏览器需要做一些其它的工作，因此在此处添加一个空的计时器来使微任务队列刷新。&lt;/p&gt;&lt;p&gt;  如果环境不兼容 Promise，则将 flushCallbacks() 的执行注册成 macrotask。优先使用 setImmediate 注册任务，setImmediate() 性能好、优先级高，但是兼容性很差，目前只有 IE 浏览器支持。其次使用 MessageChannel 实现，如果都不支持，则调用 setTimeout() 实现。&lt;/p&gt;&lt;p&gt;  flushCallbacks() 的实现方式如下所示：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i &amp;lt; copies.length; i++) {
    copies[i]()
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  首先将是否刷新的标识设为 false ，然后复制 callbacks 数组到 copies ，再清空 callbacks 数组，遍历 copies 执行每一个回调。这里将 callbacks 清空、遍历复制数组 copies 的原因是为了防止在遍历执行回调的过程中，不断有新的回调添加到 callbacks 数组中的情况发生。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;老版本实现方式&quot;&gt;2、老版本实现方式&lt;/h3&gt;
&lt;p&gt;  Vue2.4.4 版本的 nextTick() 实现与2.5+ 版本的差异主要是下面这段代码：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  if (typeof Promise !== 'undefined' &amp;amp;&amp;amp; isNative(Promise)) {
    var p = Promise.resolve()
    var logError = err =&amp;gt; { console.error(err) }
    timerFunc = () =&amp;gt; {
      p.then(nextTickHandler).catch(logError)
      if (isIOS) setTimeout(noop)
    }
  } else if (!isIE &amp;amp;&amp;amp; typeof MutationObserver !== 'undefined' &amp;amp;&amp;amp; (
    isNative(MutationObserver) ||
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, { characterData: true })
    timerFunc = () =&amp;gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
  } else {
    timerFunc = () =&amp;gt; {setTimeout(nextTickHandler, 0)}
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  老版本的 nextTick() 与2.5+ 版本的最主要区别是将任务注册成异步队列的方式不同。优先使用 Promise 将任务注册成 microtask，其次使用 MutationObserver 将任务注册成 microtask。如果环境不允许将任务注册成 microtask，则直接使用 setTimeout() 将任务注册成 macrotask。&lt;/p&gt;&lt;p&gt;  可以看出老版本的 nextTick() 对性能的追求特别高，基本上都是采用 microtask 来实现异步更新的，macrotask 没有区分层级，直接使用 setTimeout() 来最后兜底。&lt;/p&gt;&lt;p&gt;  MutationObserver 的优先级特别高，在某些场景下它甚至要比事件冒泡还要快，会导致很多问题。如果全部使用 macrotask 则对一些有重绘和动画的场景也会有性能影响。所以 Vue2.5+ 版本删除了对 MutationObserver 的使用，增强了 macrotask 的使用。&lt;/p&gt;&lt;p&gt;如需转载，烦请注明出处：&lt;a href=&quot;https://www.cnblogs.com/lidengfeng/p/10856352.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lidengfeng/p/10856352.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 06:18:00 +0000</pubDate>
<dc:creator>雾雪天涯</dc:creator>
<og:description>  在阅读 nextTick 的源码之前，要先弄明白 JS 执行环境运行机制，介绍 JS 执行环境的 事件循环 机制的文章很多，大部分都阐述的比较笼统，甚至有些文章说的是错误的，以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lidengfeng/p/10856352.html</dc:identifier>
</item>
<item>
<title>Apollo源码解析看一文就够 - lewis09</title>
<link>http://www.cnblogs.com/lewis09/p/10822020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lewis09/p/10822020.html</guid>
<description>&lt;p&gt;对于配置中心我们先抛出问号三连，什么是配置中心？为什么要用配置中心？配置中心怎么用？&lt;/p&gt;
&lt;p&gt;笔者说说自己理解的配置中心，个人观点的十六字&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;消息存储　　消息推送　　环境隔离　　灰度发布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们先来看Apollo配置中心怎么用，小伙伴可能会说，这不是很简单嘛，no，我们同时要来揭开配置保存的实现原理。&lt;/p&gt;
&lt;p&gt;apollo配置都是通过表来保存，那么我们来一步一步揭开模型关系。&lt;/p&gt;
&lt;p&gt;看笔者这篇文章的同时，或者你已经熟悉Apollo基本的操作，比如创建集群、创建Namespace、创建灰度发布等。如果不熟悉，可以参考小编上篇文章&lt;a href=&quot;https://www.cnblogs.com/lewis09/p/10815898.html&quot; target=&quot;_blank&quot;&gt;自己构建Apollo调试环境&lt;/a&gt;，参考官方 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;Apollo使用指南&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;创建项目&lt;/h2&gt;
&lt;p&gt;为了小伙伴能看的清楚，笔者特意把表数据全部清理了，包括原始项目，项目id是100004458&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506201140601-636294248.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们先创建一个项目，这个项目可以匹配我们自己的服务，比如platform-base-service&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506201605642-1901460561.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里解答两个问题，应用负责人是在管理员工具-用户管理中配置，对应表是ApolloPortalDB.Users&lt;/p&gt;
&lt;p&gt;                          部门是可选项，配置的是ApolloPortalDB.ServerConfig中 organizations对应value，可以看到笔者这里配置的造火箭的部门和拧螺丝的部门&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506202006702-243548155.png&quot; alt=&quot;&quot; width=&quot;1288&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然可以在系统工具--管理员参数 配置key=organizations和value=[{&quot;orgId&quot;:&quot;TEST1&quot;,&quot;orgName&quot;:&quot;造火箭部门&quot;},{&quot;orgId&quot;:&quot;TEST2&quot;,&quot;orgName&quot;:&quot;拧螺丝部门&quot;}]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506202244783-183322338.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们也可以扩展一点，&lt;/p&gt;
&lt;p&gt; 到此我们项目已经创建完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506202744458-227577844.png&quot; alt=&quot;&quot; width=&quot;1169&quot; height=&quot;389&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;环境列表&lt;/h2&gt;
&lt;p&gt;这个看过笔者写的&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lewis09/p/10815898.html&quot;&gt;Apollo源码搭建调试看一文就够&lt;/a&gt;，应该知道，笔者特意强调了只配置dev环境，也就是ApolloPortalDB.ServerConfig中Key=apollo.portal.envs和Value=dev&lt;/p&gt;
&lt;div class=&quot;clear&quot;&gt;
&lt;div class=&quot;clear&quot; readability=&quot;20.560209424084&quot;&gt;
&lt;div class=&quot;clear&quot; readability=&quot;36.225130890052&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506203102368-1376557233.png&quot; alt=&quot;&quot; width=&quot;1195&quot; height=&quot;87&quot;/&gt;&lt;p&gt;这里再强调一次ApolloPortalDB所有环境只需要部署一个即可，而ApolloConfigDB需要在每个环境部署一套，如dev、fat、uat和pro分别部署4套ApolloConfigDB。&lt;/p&gt;
&lt;p&gt;每个环境下ApolloConfigDB 配置独立。这里也是我们说到的配置中心需要实现的&lt;span&gt;环境隔离&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果需要配置多环境，按照工程源码下../apollo/scripts/apollo-on-kubernetes/db下对应环境创建自己的ApolloConfigDB数据度，然后配置apollo.portal.envs，当然也可以自定义环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513101405694-694674122.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;添加集群 Cluster&lt;/h2&gt;
&lt;p&gt;集群使用场景，类似异地多活，同一个项目不用城市获取的配置项是不同的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过添加集群，可以使同一份程序在不同的集群（如不同的数据中心）使用不同的配置&lt;/li&gt;
&lt;li&gt;如果不同集群使用一样的配置，则没有必要创建集群&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表结构比较简单，ApolloConfigDB.Cluster表中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506205411315-440107467.png&quot; alt=&quot;&quot; width=&quot;1088&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;添加NameSpaces&lt;/h2&gt;
&lt;p&gt;Apollo在创建项目的时候，都会默认创建一个“application”的Namespace。&lt;/p&gt;
&lt;p&gt;对于概念不够理解，可以看看官方提供的解释 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E2%80%9CNamespace%E2%80%9D&quot; target=&quot;_blank&quot;&gt;Apollo核心概念之“Namespace”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们来看看表数据流向，创建App也是同种方式，数据都是从portal Service到Admin Service。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506215213990-1004025031.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们简单看下ApolloConfigDB中数据模型关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190506214719629-60187946.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结如下：&lt;/p&gt;
&lt;p&gt;1、创建App后，会自动创建默认的Namespace，默认的Cluster，即同时App、Cluster、AppNamespace、Namespace数据。&lt;br/&gt;2、创建Cluster后，Namespace就是关联AppNamespace和Cluster，即为每个 AppNamespace 创建 不同集群的Namespace。&lt;/p&gt;
&lt;p&gt;借用官方作者的话，如果把appnamespace比作class的话，namespace就可以比作是实例化的对象，它在不同的环境，不同的集群都有实例。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;clear&quot; readability=&quot;21.942771084337&quot;&gt;
&lt;div class=&quot;clear&quot; readability=&quot;51.822289156627&quot;&gt;
&lt;p&gt;这里笔者也有一个疑惑，创建namespace会创建所有环境、所有集群，具体后面可以跟踪下 &lt;a href=&quot;https://github.com/ctripcorp/apollo/issues/2188&quot;&gt;https://github.com/ctripcorp/apollo/issues/2188&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;新增配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190510213954238-2098691304.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个Item ，配置项，是 Namespace 下最小颗粒度的单位。在 Namespace 分成五种类型：properties yml yaml json xml&lt;/p&gt;
&lt;p&gt;数据存储在ApolloConfigDB.Item&lt;/p&gt;
&lt;h2&gt;发布配置&lt;/h2&gt;
&lt;p&gt;这里也是我们说到的配置中心需要实现的&lt;span&gt;消息推送&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里也就是全文的重点&lt;/p&gt;
&lt;h3 id=&quot;6012-1556355675483&quot;&gt;服务端实时推送如何设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190510214738886-1440866152.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/4BC1BD75364D41D489F1BD047BAC1268&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/4BC1BD75364D41D489F1BD047BAC1268&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;重点来看看 ReleaseMessage实现方式&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.0175438596491&quot;&gt;1、Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace，参见&lt;a href=&quot;https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/DatabaseMessageSender.java&quot;&gt;DatabaseMessageSender&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;6.8169014084507&quot;&gt;2、Apollo.ReleaseMessageScanner线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录，参见&lt;a href=&quot;https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/ReleaseMessageScanner.java&quot;&gt;ReleaseMessageScanner&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;4、NotificationControllerV2得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端&lt;/p&gt;
&lt;div readability=&quot;24.450331125828&quot;&gt;
&lt;p id=&quot;5732-1556356042998&quot;&gt;Config Service 通知客户端的实现方式&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190510214826659-979664192.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;562&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面有提到其实就是NotificationControllerV2在得知有配置发布后通知客户端，实现如下&lt;/p&gt;


&lt;p&gt;3、如果在60秒内没有该客户端关心的配置发布，那么会返回Http状态码304给客户端&lt;/p&gt;
&lt;div readability=&quot;10.696319018405&quot;&gt;4、如果有该客户端关心的配置发布，NotificationControllerV2会调用DeferredResult的&lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html#setResult-T-&quot;&gt;setResult&lt;/a&gt;方法，传入有配置变化的namespace信息，同时该请求会立即返回。客户端从返回的结果中获取到配置变化的namespace后，会立即请求Config Service获取该namespace的最新配置。&lt;/div&gt;
&lt;p&gt;抛出几个问题：&lt;br/&gt;1、客户端收到通知消息后，从返回的结果中获取到配置变化的 namespace 后，会立即请求 Config Service 获取该 namespace 的最新配置，问题就是为什么不在通知消息中带过去message，而需要重新获取？&lt;/p&gt;
&lt;p&gt;2、假设一个公共 Namespace 有10W台机器使用，该公共 Namespace 发布时直接下发配置更新消息的话，就会导致这 10W 台机器同时来请求配置，对Config Service的压力也会特别大如何处理？&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/3AB50BE989F04A02ABC531FF0E75FE00&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;实例列表&lt;/h2&gt;
&lt;p&gt;实例( Instance )，实际就是 Apollo 的客户端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190510224351834-327367861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们启动服务 SpringBootSampleApplication，即启动了一个Apollo客户端，可以查询到实例列表。&lt;br/&gt;对应我们的数据库即ApolloConfigDB.Instance&lt;/p&gt;
&lt;h2&gt;灰度发布&lt;/h2&gt;
&lt;p&gt;这里也是我们说到的配置中心需要实现的&lt;span&gt;灰度发布&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们可以理解灰度和分支等价，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建 Namespace 灰度时：
&lt;ul&gt;&lt;li&gt;会创建子 Cluster ，指向父 Cluster 。&lt;/li&gt;
&lt;li&gt;会创建子 Namespace ，关联子 Namespace 。实际上，子 Namespace 和 父 Namespace 无任何数据字段上的关联。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;向子 Namespace 添加 Item 时，该 Item 指向子 Namespace 。虽然，代码实现和父 Namespace 是一模一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;灰度发布模型&lt;/h3&gt;
&lt;p&gt;灰度 Namespace 发布 Release 。灰度 Namespace 会自动继承 父 Namespace 已经发布的配置。若有相同的配置项，使用 子 Namespace 的。配置处理的逻辑上，和关联 Namespace 是一致的。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513095809423-1004484848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 灰度全量发布&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513094615624-1529186436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据库对应模型&lt;/h2&gt;
&lt;p&gt;前面我们已经讲了每个流程操作的数据库和关系，这里我们总结下。&lt;/p&gt;
&lt;h3&gt;创建项目、集群、namespace数据关系模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513140035337-1174832801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加配置项数据关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513140123850-1400096104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;发布配置数据关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1537085/201905/1537085-20190513140204491-1573934703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面操作都设计到日志审计表ApolloConfigDB.Audit，只是图这里没有表示出来。&lt;/p&gt;

&lt;p&gt;我们这里只聊聊实现原理，具体的操作可以参考官方&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#%E4%BA%94%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;灰度发布指南&lt;/a&gt;。如果有任何问题可以留言一起讨论。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 13 May 2019 06:06:00 +0000</pubDate>
<dc:creator>lewis09</dc:creator>
<og:description>对于配置中心我们先抛出问号三连，什么是配置中心？为什么要用配置中心？配置中心怎么用？ 笔者说说自己理解的配置中心，个人观点的十六字 消息存储 消息推送 环境隔离 灰度发布 今天我们先来看Apollo配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lewis09/p/10822020.html</dc:identifier>
</item>
<item>
<title>设计模式之命令模式（一） - 小酒窝</title>
<link>http://www.cnblogs.com/dimple91/p/10856270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dimple91/p/10856270.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在本次学习过程中，我们把封装带到一个全新的境界：把方法调用（method invocation）封装起来&lt;/strong&gt;。没错，通过封装方法调用，我们可以把运算块包装成形。&lt;/p&gt;
&lt;p&gt;所以调用此运算的对象不需要关心事情是如何进行的，只要知道如何使用包装成形的方法来完成它就可以。通过封装方法调用，也可以做一些很聪明的事情，例如记录日志，或者重复使用这些封装来实现撤销。让我们开始吧&lt;/p&gt;
&lt;p&gt;现在有一个用户A，他们家有很多家电，在装修的时候，他让装修公司把这些家电当成了一个整体，想要通过一个遥控器就能控制家里的电灯、风扇、热水器、音响设备和其他的类似的可控制装置，这样的话就显得很高大上。&lt;/p&gt;
&lt;p&gt;所以呢，他让每个厂商投提供了一组Java类，用来控制家电。手上又有一个遥控器，希望我们能够创建一组控制遥控器的API，让每个插槽都能控制一个或一组装置，即通过一个遥控器就能控制所有家电，是不是很酷。&lt;/p&gt;
&lt;p&gt;我们先来看下厂商给的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw690/62b02411ly1g2qiiqqn2kj20lq0lbn3b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类确实不少呀，而且接口也各有差异。还有更麻烦的，随着家电数量的增加，这样的类还会越来越多。那么，如何设计一个遥控器API就变得很有挑战性了是吧。&lt;/p&gt;
&lt;p&gt;所以，命令模式应运而生了。在我们的设计中，采用“命令模式”，利用命令对象，把请求（例如打开电灯）封装成一个特定对象（例如客厅电灯对象）。所以，如果对每个按钮都存储一个命令对象，那么当按钮被按下的时候，就可以请命令对象做相关的工作。遥控器并不需要知道工作内容是什么，只要有个命令对象能和正确的对象沟通，把事情做好就可以了。这样，遥控器和电灯对象都解耦了。&lt;/p&gt;
&lt;p&gt;可能把遥控器换成餐厅点餐，大家会更容易理解。我在这里简单描述下：首先顾客到了餐厅，根据菜单点了一部分菜，把菜单给服务员；服务员拿到了订单，就提交到柜台上，并向后厨喊了一声“xx号桌xx订单”来了；后厨根据菜单进行配菜，烧菜。全称服务员都不需要知道订单具体内容是什么，只要将桌上的客户点的餐提供给后厨即可，这和我们的遥控器就是一个道理了。&lt;/p&gt;
&lt;h4 id=&quot;第一个命令对象&quot;&gt;第一个命令对象&lt;/h4&gt;
&lt;h4 id=&quot;实现命令接口&quot;&gt;实现命令接口&lt;/h4&gt;
&lt;p&gt;那我们就来创建我们的命令对象吧。首先，我们得让所有的命令对象实现相同的包含一个方法的接口。在餐厅订餐的例子上，就是创建订单，我们在程序的世界里，取名叫做execute()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Command {
    public void execute();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现一个打开电灯的命令&quot;&gt;实现一个打开电灯的命令&lt;/h5&gt;
&lt;p&gt;现在，假设想实现一个打开电灯的命令。根据之前看到的厂商提供的类，Light类有两个方法，on和off。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这是一个命令，所以需要实现Command接口
public class LightOnCommand implements Command {
    Light light;

// 构造器传入某个电灯，以便让这个命令控制，然后记录在实例变量中
    public LightOnCommand(Light light) {
        this.light = light;
    }

// 这个execute方法调用接收对象的on方法
    public void execute() {
        light.on();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用命令对象&quot;&gt;使用命令对象&lt;/h4&gt;
&lt;p&gt;现在，我们让遥控器工作起来，先来点简单的。假设遥控器只有一个按钮和对应的插槽，可以控制一个装置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SimpleRemoteControl {
// 有一个插槽持有命令，而这个命令控制着一个装置
    Command slot;
 
    public SimpleRemoteControl() {}
 
// 这个方法用来设置插槽控制的命令
    public void setCommand(Command command) {
        slot = command;
    }
 
// 当按下按钮时，这个方法就会被调用，使得当前命令衔接插槽，并调用它的execute方法
    public void buttonWasPressed() {
        slot.execute();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样我们就能实现一个简单的遥控器了。请看我们的测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RemoteControlTest {
    public static void main(String[] args) {
    // 遥控器就是调用者，会传入一个命令对象，可以用来发出请求
        SimpleRemoteControl remote = new SimpleRemoteControl();
    // 现在创建一个电灯对象，此对象也就是请求的接收者
        Light light = new Light();
    // 这里创建一个命令，然后将接收者传给它
        LightOnCommand lightOn = new LightOnCommand(light);
    
    // 把命令传给调用者
        remote.setCommand(lightOn);
    // 模拟按下按钮
        remote.buttonWasPressed();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义命令模式&quot;&gt;定义命令模式&lt;/h4&gt;
&lt;p&gt;经过订餐流程的理解，以及刚才这个小练习，相信你也对命令模式内的类 和对象如何互动理解得很清楚了吧。那我们在这里趁热打铁，定义一下命令模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式&lt;/strong&gt;将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。&lt;/p&gt;
&lt;p&gt;仔细想想，我们知道有一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露出一个execute()方法，当此方法被调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute()方法，请求的目的就能达到。&lt;/p&gt;
&lt;p&gt;让我们来看下命令模式的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/62b02411ly1g2qjcrobwhj20mq0ipn60.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，通过这个简单的小练习，我们知道如何控制电灯的开关了。在前面厂商给的类中，还有好多方法，比如电风扇、吊灯、电视机、音响等等。控制单个我们已经能搞定了，那控制多个呢？是不是同理呢？还是你有更好的方式呢？小编想请你先动动你的小手，我们下次见分晓。&lt;/p&gt;
&lt;p&gt;爱生活，爱学习，爱感悟，爱挨踢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/62b02411ly1g1h6i45avyj207607674r.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 06:03:00 +0000</pubDate>
<dc:creator>小酒窝</dc:creator>
<og:description>在本次学习过程中，我们把封装带到一个全新的境界：把方法调用（method invocation）封装起来 。没错，通过封装方法调用，我们可以把运算块包装成形。 所以调用此运算的对象不需要关心事情是如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dimple91/p/10856270.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离【再会】║最全的部署方案 &amp; 最丰富的错误分析 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/beautifulPublish-mostBugs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/beautifulPublish-mostBugs.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 哈喽大家好！今天是周一了，这几天趁着午休的时间又读了一本书《偷影子的人》，可以看看🙃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天也是入园的第九个月了，前后端分离系列到了今天正好是 43 篇，也写了 20 万字了，内心也是经历了各种曲折，是时候给《前后端分离》来一个句号了，为啥突然有了这个想法了呢？😮，周末两天在学习的时候，发现其他有的博主已经把自己的开源项目关闭更新了，刚开始还有点儿不理解，后来想了想，也确实无可厚非，吃完饭做了下思考：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;1、我写的这个项目，当时不是为了写框架，只是想给大家提供下学习的参考，对比错误的，我很害怕会出现把注意力过多的放在框架上的，而忽略了基础知识学习的尴尬情况，这个在以后的新公司入职中，会比较被动，比如我前天面试遇到的，1： &lt;strong&gt;Vue运行时版本和完整版有啥区别和联系，2：Vue 异步更新DOM的机制有什么好处？如何实现的？&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;2、当然，有一些基础比较好的小伙伴，不仅能看懂我的代码，还能在我的项目基础上，进行封装，我还是很欢迎使用的，用在生产环境，如果我还一直进行大的迭代更新的话，可能对大家有一定的影响；&lt;/p&gt;
&lt;p&gt;3、前两天群里有小伙伴问了一些部署的相关问题，我才发现，我竟忽略了这一部分，诚然，我也写了一些，但是没有统一起来，那就用这篇详细的部署文章来画个句号吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本篇文章会一直更新，内容十分丰富，包含了NetCore+vue 的各种部署方案，以及遇到的主要错误分析，目的就是为了让初学者可以有章可循。&lt;/p&gt;



&lt;h3&gt;友1、WIN_独立部署&lt;/h3&gt;
&lt;p&gt;感谢群里&lt;span&gt;（白云）&lt;/span&gt;小伙伴，博主 @&lt;a title=&quot;小淋科技&quot; href=&quot;https://home.cnblogs.com/u/1686827/&quot; target=&quot;_blank&quot;&gt;小淋科技&lt;/a&gt;  提出的方案，我竟然忽略了，该打该打，官档都读不仔细，果然三人行必有我师！&lt;/p&gt;
&lt;p id=&quot;self-contained-deployments-scd&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;371c5-139&quot;&gt;微软官方文档 ——《&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/deploying/index#self-contained-deployments-scd&quot; target=&quot;_blank&quot;&gt;独立部署 (SCD)&lt;/a&gt;》，使用这个方法很简单，只需要部署的时候，选择指定的平台，就可以不用安装其他，比如运行时、托管、SDK等，不过这样的话，可能下文的命令行操作不适用，不过还是很好很简单的方案，欢迎尝试。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;371c5-139&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513143943963-773741903.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;




&lt;h3&gt;1、WIN_IIS 部署，前后端不同站点&lt;/h3&gt;
&lt;p&gt;为了能有一个全新的环境，我还特地新买一台服务，要做好部署的准备，就必须要先进行初始化操作，也就是先准备好我们用到的原材料：&lt;/p&gt;
&lt;p&gt;在服务器开启 IIS 就不多说了，相信每一个 Dotnet 开发者百分比必须要会的，其他的操作流程请看下边的步骤，具体的看动图：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;先给自己的两个站点想好端口，比如我想的：core（1001端口）、Vue（1002端口）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.957559681698&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NetCore 部分&lt;/span&gt;

&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&lt;span&gt;、编译项目，保证代码没问题，并配置 CORS 跨域服务；//下边动图中没有配置CORS，大家自己要注意&lt;/span&gt;

①、发布项目；

②、拷贝到服务器指定文件夹；

③、IIS 添加站点；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 端口 1001&lt;/span&gt;
&lt;span&gt;
④、修改应用程序池为“无托管”；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这也是为啥要安装 windows hosting 的原因&lt;/span&gt;
&lt;span&gt;
⑤、安装 windows hosting（服务托管）；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个捆包，已经包含 Runtime&lt;/span&gt;
&lt;span&gt;
⑥、检查是否有指定的 Runtime（运行时）；

⑦、重启项目，查看是否正常；&lt;a href=&quot;http://62.234.90.153:1001/&quot;&gt;http://localhost:1001/&lt;/a&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vue 部分&lt;/span&gt;
&lt;span&gt;
①、Build 项目；

②、拷贝到服务器指定文件夹；

③、IIS 添加站点；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 端口 1002&lt;/span&gt;
&lt;span&gt;
④、运行项目，查看是否正常；&lt;a href=&quot;http://62.234.90.153:1001/&quot;&gt;http://&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;a href=&quot;http://62.234.90.153:1001/&quot;&gt;localhost&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;a href=&quot;http://62.234.90.153:1001/&quot;&gt;:1002/&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;动图1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190512225543876-1182186359.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 修改好 hash 模式后，就成功了，注意要在 Core 项目中配置 CORS 跨域：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 c.AddPolicy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LimitRequests&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt;&lt;span&gt;
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支持多个域名端口，注意端口号后不要带/斜杆：比如localhost:8000/，是错的
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，&lt;/span&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;span&gt;:1818 和 &lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:1818 是不一样的，尽量写两个&lt;/span&gt;
&lt;span&gt;     policy
     .WithOrigins(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:&lt;strong&gt;&lt;span&gt;1002&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;strong&gt;&lt;span&gt;1002&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     .AllowAnyHeader()
     .AllowAnyMethod();
 });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190512232650720-1837641734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2、WIN_IIS 部署，前后端一个站点&lt;/h3&gt;
&lt;p&gt; 从上边的过程中，可以看出来还是比较简单的，一气呵成，行云流水，不过可能自己操作的时候会出现这样那样的问题，毕竟我也是给很多小伙伴都部署过，没有上百，也有五十次了，如果你有错误，请看我文章下边第二章的 常见错误 ，找到你遇到的错误。&lt;/p&gt;
&lt;p&gt;上边的操作中，我们是把两个项目部署到了 IIS 中的不同站点，当然，我们也可以部署到一个站点，这样的话，就是一个域名了，但是丝毫没有影响我们分开开发，我们前后端攻城狮还是和以前一样的开发，只是将发布的文件上传到指定服务器文件夹中就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513160023771-241537530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;操作步骤和上边的其实是几乎一样的，只不过我们不需要配置 CORS 跨域了，因为是同一个站点，且是只需要一个端口号，我们定为 1003端口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NetCore 部分，&lt;strong&gt;和上边的几乎一样，只不过不用进行 CORS 跨域设置&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;
①、发布项目；

②、拷贝到服务器指定文件夹；

③、IIS 添加站点；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 端口 1003&lt;/span&gt;
&lt;span&gt;
④、修改应用程序池为“无托管”；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这也是为啥要安装 windows hosting 的原因&lt;/span&gt;
&lt;span&gt;
⑤、安装 windows hosting（服务托管）；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个捆包，已经包含 Runtime&lt;/span&gt;
&lt;span&gt;
⑥、检查是否有指定的 Runtime（运行时）；

⑦、重启项目，查看是否正常；http:&lt;/span&gt;&lt;span&gt;//localhost&lt;/span&gt;&lt;span&gt;:1003/

 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vue 部分&lt;/span&gt;
&lt;span&gt;
①、&lt;span&gt;修改根路径&lt;/span&gt;，并且 Build 项目；// 还要修改接口api的路径，剩下的自己处理吧，不要项目后期用这个方法，路径修改麻烦

②、拷贝到服务器指定文件夹；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以和 core 项目放到一起&lt;/span&gt;
&lt;span&gt;
③、修改 Core 的 IIS 站点，在它的站点内，嵌套一个vue站点；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取名为 Vue&lt;/span&gt;
&lt;span&gt;
④、运行项目，查看是否正常；http:&lt;/span&gt;&lt;span&gt;//localhost&lt;/span&gt;&lt;span&gt;:1003/vue/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 动图2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513000257884-866412584.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h3&gt;3、WIN_Git_Nginx_Kestrel 常规部署&lt;/h3&gt;
&lt;p&gt;上边的 IIS 部署咱们说完了，大家发现，存在一些问题：&lt;/p&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1、过分的依赖 IIS，并没有完完全全的达到跨平台的目的；&lt;/p&gt;
&lt;p&gt;2、操作步骤偏多，还需要拷贝文件，并且一个都不能少；&lt;/p&gt;
&lt;p&gt;3、因为 IIS 会存在占资源的问题，每次如果我们更新 Blog.Core.dll 文件，都需要关闭站点，然后更新，再启动；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那接下来咱们就说说如何使用 Nginx+Kestrel 来简单的解决这些问题，步骤如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里需要安装 Ngxin （&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;）、Git（&lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;）、SDK（&lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkID=287120&quot;&gt;http://go.microsoft.com/fwlink/?LinkID=287120&lt;/a&gt;），过程省略，大家自行安装，这里我们把端口定为，NetCore（1004端口）、Vue（1005端口）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NetCore 部分&lt;/span&gt;&lt;span&gt;

①、执行 Blog.Core.Build.bat 文件；&lt;span&gt;// 主要是 git pull ，dotnet build 和 dotnet run&lt;/span&gt;

②、Nginx 代理服务，将 &lt;/span&gt;&lt;span&gt;8081&lt;/span&gt; 端口，代理到 &lt;span&gt;1004&lt;/span&gt;；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的代码在下边&lt;br/&gt;&lt;/span&gt;
③、查看是否正常；&lt;span&gt;//&lt;/span&gt; &lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:1004/
 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vue 部分&lt;/span&gt;
&lt;span&gt;
①、执行 BS 命令；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cnpm run BS，这里是我自己的命令，主要是git pull 和 build&lt;/span&gt;
&lt;span&gt;
②、Nginx 代理 Vue 服务，并配置跨域，代理到1005；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的代码在下边&lt;/span&gt;
&lt;span&gt;
③、查看是否正常；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:1005/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大家可以看看，或者直接感受一下，这种部署方案，和 IIS 的方案，哪一个更好一些？三步走，也是很简单，而也很直观的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 红色是 NetCore 的 Nginx 相关配置；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 绿色的是 Vue 的 Nginx 的相关配置；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#user  nobody;
worker_processes  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;


events {
    worker_connections  &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
}


http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;
&lt;/span&gt;&lt;span&gt;
    sendfile        on;

    #keepalive_timeout  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;;
    proxy_read_timeout &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;; 
    proxy_send_timeout &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;; 

    &lt;span&gt;# dotnet core&lt;/span&gt;
&lt;span&gt;    upstream dotnetblogserver1 {
            server &lt;/span&gt;&lt;/span&gt;&lt;span&gt;127.0.0.1:8081;
    }
    server {
       listen   1004;
       server_name localhost;
        location /{
            proxy_pass   http://dotnetblogserver1;
            index  index.html index.htm;
        }
        location = /50x.html {
            root   html;
        }
    }

&lt;/span&gt;&lt;span&gt;
    # vue
    server {
        listen       &lt;span&gt;1005&lt;/span&gt;;
        server_name  localhost;
        location / {
            &lt;span&gt;root&lt;/span&gt;   nuxt\Blog.Admin\dist;
            index  index.html index.htm;
        }
        location /api {
            rewrite  ^.+apb/?(.*)$ /$1 break;
               include  uwsgi_params;
            proxy_pass   http://localhost:&lt;span&gt;1004&lt;/span&gt;; #// 这是 netcore 端口
        }
        error_page  404              /404.html;
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    }&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 从上边的部署中，我们可以看到，过程中我们几乎都没有进行什么配置，或者说都是一次性的配置，比如 Git 安装，比如 Nginx 的学习，只要我们配置了一次，以后多个项目就可以很快的操作了，比 IIS 每一个都要 Publish 并且各种配置来的快些。&lt;/p&gt;
&lt;p&gt;不仅如此，我们也换掉了 IIS ，使用了 netcore 自带的 Kestrel 应用服务器，并且不会出现任何不同步的问题，&lt;strong&gt;只要你本地调试好代码，并 push 到 git 上！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 动图3：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513135517499-781201488.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;4、WIN 部署到 Windows 服务&lt;/h3&gt;

&lt;p&gt;微软有提供 &lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如何在windows服务托管asp.net core&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; ,不过步骤比较麻烦，还需要改源码，网上找到一种方法 &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/emrys5/p/nssm-netcore.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;使用NSSM把.Net Core部署至windows服务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简单说一下步骤&lt;/p&gt;
&lt;p&gt;1. 下载nssm：&lt;span&gt;&lt;a href=&quot;http://www.nssm.cc/download&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.nssm.cc/download&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. 运行cmd，定位到nssm.exe文件路径，运行nssm install&lt;/p&gt;
&lt;p&gt;3. 在弹出的窗口配置：　　　　&lt;/p&gt;
&lt;p&gt;　　Path：dotnet所在的目录，一般默认是在C:\Program Files\dotnet\dotnet.exe；&lt;/p&gt;
&lt;p&gt;　　Startup directory：程序所在的目录，就是最后程序dll所在的目录；&lt;/p&gt;
&lt;p&gt;　　Arguments：程序dll的名称，一般是项目名加上.dll；&lt;/p&gt;
&lt;p&gt;　　Service name：在此写上服务的名称即可。&lt;/p&gt;
&lt;p&gt;　　最后点击install service 完成windows服务安装。&lt;/p&gt;
&lt;p&gt;　　在windows服务找到对应服务名，启动，然后根据launchSettings.json配置的端口访问，即可调取接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201904/1468246-20190415125117921-1835365606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;5、Linux_Ubuntu_Nginx 部署&lt;/h3&gt;

&lt;h4 id=&quot;autoid-7-0-0&quot;&gt;1、安装.NET Core &lt;/h4&gt;
&lt;p&gt;首先需要安装.NET Core Runtime: &lt;span&gt;&lt;a href=&quot;https://www.microsoft.com/net/download&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.microsoft.com/net/download&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510142835633-322291841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击之后，根据您的Linux发行版不同，选择相应的操作步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915074859631-636287454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915074906784-626198497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后执行dotnet --info验证安装是否成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915075134606-1969928214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;autoid-7-1-0&quot;&gt;2、安装Nginx&lt;/h4&gt;
&lt;p&gt;另外还需要安装Nginx，查看官网文档：&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x#install-nginx&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x#install-nginx&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装好后，访问这个页面：http://&lt;span&gt;yourIPAddress&lt;/span&gt;/index.nginx-debian.html，如果看到如下效果说明安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915074622604-1416250480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;autoid-7-2-0&quot;&gt;3、在服务器构建源码并发布&lt;/h4&gt;
&lt;p&gt;然后就是发布程序了，发布有两种办法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在开发机上执行 dotnet publish 然后把发布的文件远程到服务器上&lt;/li&gt;
&lt;li&gt;直接在服务器上使用源码构建并发布，我一般是这样做的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果直接在服务器上构建发布，所以需要安装.NET Core SDK：&lt;span&gt;&lt;a href=&quot;https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915075450959-521136531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后就可以使用发布命令了：&lt;strong&gt;dotnet publish --configuration Release&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;发布好的文件在 &lt;strong&gt;bin/Release/netcoreapp*.*/publish &lt;/strong&gt;下面。&lt;/p&gt;
&lt;p&gt;再把publish下的所有文件复制到我的目标文件夹即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915080351417-1963550379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在我的目标目录下，有这些文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915080442957-955897263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果执行 dotnet test.dll，这个程序就会在localhost:5000运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915080553082-360824715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;autoid-7-3-0&quot;&gt;4、配置Nginx&lt;/h4&gt;
&lt;p&gt;然后我们再回来配置Nginx，进入 /etc/nginx/sites-available ，里面有一个Default文件，把它改个名，然后我们再建立一个新的Default文件：&lt;/p&gt;
&lt;p&gt;&lt;em class=&quot;x-hidden-focus&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915081254344-1627513315.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;保存后执行 sudo nginx -t  检验这个配置文件。&lt;/p&gt;
&lt;p&gt;然后再执行 nginx -s reload 来重启nginx。&lt;/p&gt;
&lt;p&gt;随后需要再把发布后的程序运行一下：dotnet test.dll：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915082258705-1408419635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在我使用网址访问80端口的时候，会自动跳转到 &lt;span&gt;https&lt;/span&gt;//localhost:5001端口，导致连接失败：&lt;/p&gt;

&lt;p&gt;可以在开发的时候，就直接去掉项目中使用 https 地址就行，在 launchSettions.json 文件中：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510143234141-1146829596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;或者禁用 https 中间件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201809/986268-20180915082553379-547788795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;打开浏览器访问试试：&lt;span&gt;http://yourdomian.com/swagger/index.html&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;6、Linux_Docker 部署&lt;/h3&gt;

&lt;h4&gt;1、docker安装&lt;/h4&gt;
&lt;p&gt;依次执行下列命令&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sudo yum install -y yum-utils device-mapper-persistent-&lt;span&gt;data lvm2

sudo yum&lt;/span&gt;-config-manager --add-repo http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;
&lt;span&gt; 
sudo yum makecache fast

sudo yum &lt;/span&gt;-y install docker-ce
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;检查docker是否安装成功：&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker version
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;若成功显示如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510141019220-590433474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;2、docker部署&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;2.1、上传文件到 linux 服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 linux 下创建文件夹 BlogCoreAPI&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir BlogCoreAPI &lt;span&gt;//创建文件夹&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;用 ftp 把发布的文件全部上传到 BlogCoreAPI&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2、添加 Dockerfile 文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入目录 BlogCoreAPI&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd BlogCoreAPI
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;创建文件 Dockerfile&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim Dockerfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内容如下，说明：镜像里创建 blogcore 文件夹，复制 linux 上的文件到镜像目录，对外暴露 8101 端口，运行程序&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FROM microsoft/aspnetcore:&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt;

RUN cd &lt;/span&gt;/usr/local/&lt;span&gt;src

RUN mkdir blogcore

WORKDIR &lt;/span&gt;/usr/local/src/&lt;span&gt;blogcore 

COPY &lt;/span&gt;*.* ./&lt;span&gt;

EXPOSE &lt;/span&gt;&lt;span&gt;8101&lt;/span&gt;&lt;span&gt; 

CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog.Core.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;保存&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3、构建镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;镜像名字叫 blogcore-image，禁用缓存，否则迭代时会出问题&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build --no-cache -t cchr-image .  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个点 . 表示当前目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.4、运行容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用镜像 blogcore-image 创建容器，指定容器名称是 blogcore-container，指定时区（默认是美国时间，相差8小时）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker run  --name=blogcore-container -dp  &lt;span&gt;8101&lt;/span&gt;:&lt;span&gt;8101&lt;/span&gt;--restart=always  -e LC_ALL=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_US.UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -e TZ=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Asia/Beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; blogcore-image &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改默认时区到亚洲/北京，并且将容器里的 8101 端口映射到 linux 主机的 8101 端口，最后每次运行失败后自动重启&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你想要查看刚刚创建的容器的时区是否成功，可以执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker exec blogcore-container date &lt;span&gt;//查询当前容器时区&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打开浏览器访问试试：&lt;span&gt;http://yourdomian.com/swagger/index.html&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5、发布更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面说的是第一次发布，后期迭代，需要把容器删除，再构建镜像，运行容器。&lt;/p&gt;
&lt;p&gt;2.5.1 删除容器&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker container rm -f cchr-container
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.5.2 构建镜像&amp;amp;运行容器&lt;/p&gt;
&lt;p&gt;就和上边的一样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker build --no-cache -t cchr-&lt;span&gt;image . 
docker run  &lt;/span&gt;--name=blogcore-container -dp  &lt;span&gt;8101&lt;/span&gt;:&lt;span&gt;8101&lt;/span&gt;--restart=always  -e LC_ALL=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en_US.UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -e TZ=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Asia/Beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; blogcore-image 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我还不知道有没有更快的方法，欢迎提建议。 &lt;/p&gt;

&lt;h3&gt;7、PM2 做进程管理&lt;/h3&gt;
&lt;p&gt;我看到了很多教程，但是这里我尝试的时候依然不行，这里先留一个坑，提供有偿帮忙，如果有哪位会的话，可以联系我，或者下边留言 💴。&lt;/p&gt;




&lt;p&gt;下边的都是我平时遇到的常见的错误，如果大家还有其他错误，可以留言下来，我补充到文章中，让更多的小伙伴都看到，避免麻烦。&lt;/p&gt;
&lt;h3&gt;1、错误码 —— 500.00 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513144308283-1220808933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解析：发布后启动失败，进程内，网友提供，暂时我还没遇到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;h3&gt;方法1：&lt;/h3&gt;
&lt;p&gt;应用池高级配置 - 启动32位应用程序 - 设置为True&lt;/p&gt;
&lt;h3&gt;方法2：&lt;/h3&gt;
&lt;p&gt;web.config &lt;/p&gt;
&lt;p&gt; &amp;lt;aspNetCore processPath=&quot;%LAUNCHER_PATH%&quot; arguments=&quot;%LAUNCHER_ARGS%&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\logs\stdout&quot; forwardWindowsAuthToken=&quot;false&quot; startupTimeLimit=&quot;3600&quot; requestTimeout=&quot;23:00:00&quot; &lt;strong&gt;hostingModel=&quot;InProcess&quot;&lt;/strong&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;删除 hostingModel=&quot;InProcess&quot;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3&gt;2、错误码 —— 500.19&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509142539152-1710914187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509180214846-688686183.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;：未安装 windows 服务器托管，打不开当前项目的 模块 选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.8655172413793&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;安装和项目匹配的 服务器托管（ windows hosting ），这个是捆绑的可执行文件，除了托管，也把x86 和 x64的运行时都一起安装好了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.4-windows-hosting-bundle-installer&quot; target=&quot;_blank&quot;&gt;https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.4-windows-hosting-bundle-installer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509181018781-2049031032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510112600127-648169755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;


&lt;h3&gt;3、错误码 —— 500.21&lt;/h3&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510110200834-193532689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;：没有安装指定的模块，如果你想问这个模块是在项目哪里写的，可以查看发布后的 web.config 文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510112246627-1821531234.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;

&lt;p&gt;1、如果你没有安装上边的 windows-hosting ，直接安装就可以解决这个问题；&lt;/p&gt;
&lt;p&gt;2、如果已经安装了服务器托管，发现还没有这个 V2 模块，就是你项目的问题了，这个时候你可以从本地再发布 publish 一次，然后拷贝到服务器即可。&lt;/p&gt;
&lt;p&gt;     但是，如果还没有的话，证明你本地开发的项目异常了，不过这个情况基本可以排除，只要是 SDK 2.2 开发的，本地&lt;/p&gt;

&lt;p&gt;最终要确保 AspNetCoreModuleV2 模块被安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509233640606-339886493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;



&lt;h3&gt;4、错误码 —— 500.30&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509175722560-2010333741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析：进程内失败，这个我没有遇到，有群里小伙伴说的。&lt;/p&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509180750390-2057222811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;5、错误码 —— 502.5&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509180537198-1608402926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;：没有安装指定的运行时，进程外启动失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13.415185783522&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;安装指定版本的 Runtime 运行时。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，只要安装了服务器托管的话，会自动安装对应版本的运行时，但是有时候安装好了，还是会遇到这个错误，是因为我们后期项目迭代升级了：&lt;/p&gt;
&lt;p&gt;举个栗子，本来我们的项目是 Netcore 2.1 版本，后来更新到了 2.2 ，但是服务器的运行时还是旧的 Runtime 2.1 运行时，我们把代码部署到服务器，发现没有指定运行时，就会出现这个问题。&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;https://dotnet.microsoft.com/download/visual-studio-sdks?utm_source=getdotnetsdk&amp;amp;utm_medium=referral&quot;&gt;https://dotnet.microsoft.com/download/visual-studio-sdks?utm_source=getdotnetsdk&amp;amp;utm_medium=referral&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509191703944-561609053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;



&lt;h3&gt;6、错误码 —— 503&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509185534826-493959220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析：IIS 项目应用程序池未开启&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方案：开启程序池即可，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;

&lt;p&gt;但是经过测试发现，&lt;span&gt;不&lt;/span&gt;使用 “无托管代码” 也可以，这是&lt;span&gt;为什么&lt;/span&gt;，很好奇？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509191214774-1675503617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;


&lt;h3&gt;7、An error occurred while starting the application&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509180516322-592834320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解析&lt;/span&gt;：项目已经可以启动，证明环境已经正常，只不过在项目启动的时候，出现了错误，也就是说是项目代码的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案&lt;/span&gt;：查看日志，看项目文件是否齐全。&lt;/p&gt;

&lt;blockquote readability=&quot;7.0917721518987&quot;&gt;

&lt;p&gt;如果你不知道如何打开日志，请看另一篇文章的这一节：&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9565227.html#autoid-5-5-0&quot;&gt;https://www.cnblogs.com/laozhang-is-phi/p/9565227.html#autoid-5-5-0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下边这个错误，就是因为分离的原因，导致 Service.dll 和 Repository.dll 没有拷贝到发布文件夹下，从而导致项目没有启动起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190509181718531-157990808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;






&lt;h3&gt;8、总结&lt;/h3&gt;
&lt;p&gt;经过上边多个错误分析，如果我们第一次再服务器中部署，只需要安装 服务器托管 Windows-hosting 即可：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core/2.2&quot;&gt;https://dotnet.microsoft.com/download/dotnet-core/2.2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190510115402884-788749680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;h3&gt;1、跨域失败&lt;/h3&gt;
&lt;p&gt; 这都是很简单的错误，根据上边的动图，咱们也能看出来，关于跨域有以下几个方法：&lt;/p&gt;
&lt;p&gt;1、IIS 部署，一定要在后端 NetCore 项目，进行 CORS 跨域；&lt;/p&gt;
&lt;p&gt;2、除非你是在 IIS 中的同一个站点配置前后端两个项目；&lt;/p&gt;
&lt;p&gt;3、如果是 nginx+kestrel 的话，记得在 nginx 中配置跨域代理；&lt;/p&gt;
&lt;p&gt;4、其他方案，略；&lt;/p&gt;

&lt;h3&gt;2、页面刷新 404 &lt;/h3&gt;
&lt;p&gt;为了这个错误，我上边的第一个动图，还特地的故意做了这个错误，就是 history 和 hash 的情况，当然也是有两个方案：&lt;/p&gt;
&lt;p&gt;1、如果你是 IIS 部署，就得使用 hash 模式，不能用 history 模式；&lt;/p&gt;
&lt;p&gt;2、不过如果用 nginx 的话，可以利用 404 页面的机制，将 index.html 页面 copy 一份，重命名成 404.html 即可；&lt;/p&gt;




&lt;p&gt; 这篇文章会一直补充，尽量成为前后端分离的一个优质文章吧，希望大家能尽自己的力量，补充下。&lt;/p&gt;
&lt;p&gt;前后端分离到这里就差不多了，江湖很大，各位有缘再会！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201905/1468246-20190513001509105-1759512088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/Blog.Core&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;---   ---   --- &lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 05:57:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 哈喽大家好！今天是周一了，这几天趁着午休的时间又读了一本书《偷影子的人》，可以看看🙃。 今天也是入园的第九个月了，前后端分离系列到了今天正好是 43 篇，也写了 20 万字了，内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/beautifulPublish-mostBugs.html</dc:identifier>
</item>
<item>
<title>关于注解我们应该知道的 - 宁愿呢</title>
<link>http://www.cnblogs.com/liyus/p/10856236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyus/p/10856236.html</guid>
<description>&lt;p&gt;从JDK5开始,Java增加对注解的支持，注解可以在编译，类加载和运行时被读取，并执行相应一些定义好的处理。通过注解可以在不改变原有代码和逻辑的情况下进行一些其他的补充操作。&lt;/p&gt;
&lt;h2 id=&quot;系统注解&quot;&gt;系统注解&lt;/h2&gt;
&lt;h3 id=&quot;元注解&quot;&gt;元注解&lt;/h3&gt;
&lt;p&gt;在java中系统为我们预置了一部分注解，我们可以通过这些注解来定义其他注解的作用和有效范围等特性。&lt;/p&gt;
&lt;h4 id=&quot;target&quot;&gt;@Target&lt;/h4&gt;
&lt;p&gt;@Target用于说明Annotation所修饰的对象范围，所能修饰的范围都被定义在枚举类&lt;code&gt;ElementType&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum ElementType {
    TYPE,//表示可以用于类，接口，注解或者枚举定义中
    FIELD,//字段
    METHOD,//方法(不包括构造方法)
    PARAMETER,//方法的参数
    CONSTRUCTOR,//构造方法上
    LOCAL_VARIABLE,//局部变量
    ANNOTATION_TYPE,//只能用在注解上
    PACKAGE,//作用包上 package-info.java 
    TYPE_PARAMETER,//表示注解能写在类型变量(泛型参数)的声明语句中如 List&amp;lt;Integer&amp;gt; list = new @Save ArrayList&amp;lt;&amp;gt;();
    TYPE_USE //表示注解能写在使用类型的任何语句中（声明语句、泛型和强制转换语句中的类型）。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;type_parameter&quot;&gt;TYPE_PARAMETER&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@Target(ElementType.TYPE_PARAMETER)
public @interface Save {
}

public class Test&amp;lt;@Save T&amp;gt; {
    List&amp;lt;Integer&amp;gt; list = new @Save ArrayList&amp;lt;&amp;gt;();//仅用于展示可以用到的地方
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;retention&quot;&gt;@Retention&lt;/h3&gt;
&lt;p&gt;Retention 定义了该Annotation被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即被描述的注解在什么范围内有效），取值被定义在枚举类&lt;code&gt;RetentionPolicy&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum RetentionPolicy {
    SOURCE,//表示在源代码时有效，编译后的文件没有该注解，一般该类注解仅用于标识如@SuppressWarnings

    CLASS, //默认行为 自定义注解如果没有显示的声明则默认为该行为 在编译时不会被抛弃，但是会被虚拟机抛弃

    RUNTIME //保留到运行时，可以通过反射来获取 一般该类注解会影响系统的运行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;documented&quot;&gt;@Documented&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从注解定义可以看到该注解用在注解定义上。&lt;/p&gt;
&lt;p&gt;@Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因&lt;br/&gt;此可以被如javadoc之类的工具文档化。但是实际使用并不多，有其他更好的替代。&lt;/p&gt;
&lt;h3 id=&quot;inherited&quot;&gt;@Inherited&lt;/h3&gt;
&lt;p&gt;@Inherited是一个标记注解，@Inherited表示被其标注的类型是被继承的。如果一&lt;br/&gt;个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。&lt;/p&gt;
&lt;p&gt;简单来说就是在子类中如果想要获取父类被那些注解修饰，那么子类能拿到的仅仅是被@Inherited标注过得注解。而其他没有使用 @Inherited的注解是无法再子类获取的。&lt;/p&gt;
&lt;h2 id=&quot;标准注解&quot;&gt;标准注解&lt;/h2&gt;
&lt;p&gt;上面介绍的几种元注解是在我们进行自定义注解的时候会用到的，而下面我们介绍几种平时业务开发会经常使用的注解。&lt;/p&gt;
&lt;h3 id=&quot;deprecated&quot;&gt;@Deprecated&lt;/h3&gt;
&lt;p&gt;@Deprecated用来描述在当前系统中已经被废弃不推荐使用的类或方法等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们使用了被@Deprecated标注的类或方法等，在进行编译的时候会显示相应的提示信息。&lt;/p&gt;
&lt;h3 id=&quot;override&quot;&gt;@Override&lt;/h3&gt;
&lt;p&gt;@Override是我们使用很频繁的一个注解，由于重写的操作仅存在于方法中，所以@Override也只能对方法进行标注。&lt;/p&gt;
&lt;p&gt;@Override功能主要是用来校验当前被标注的方法是否为重写方法，平时我们在继承抽象类或实现接口时都应使用该注解来标注被重写的方法。&lt;/p&gt;
&lt;h3 id=&quot;suppresswarnings&quot;&gt;@SuppressWarnings&lt;/h3&gt;
&lt;p&gt;@SuppressWarnings用于可选择的抑制编译器在编译时产生警告信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//作用范围
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@SuppressWarnings可选择的值有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;deprecation:不产生使用过期方法(...)的警告，@SuppressWarnings(&quot;deprecation&quot;)&lt;/li&gt;
&lt;li&gt;unchecked:执行了未检查的转换的警告&lt;/li&gt;
&lt;li&gt;finally:finally语句无法正常完成时的警告&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;all:任意类型的警告&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自定义注解与解析&quot;&gt;自定义注解与解析&lt;/h2&gt;
&lt;h3 id=&quot;定义注解&quot;&gt;定义注解&lt;/h3&gt;
&lt;p&gt;自定义一个注解及其简单，使用@interface关键字即可完成。同时我们需要确定我们定义的注解使用范围和其具体用途，根据此来确定使用元注解的哪些参数来修饰我们定义的注解。&lt;/p&gt;
&lt;p&gt;这里我们定义一个@Log注解用于在对数据库进行增删改时插入一条日志进行记录。由于该注解需要在运行时对数据库进行修改，所以很明显作用有效期为RUNTIME，作用范围可以使方法也可以使类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Log {
    String value();//value的值为本次操作类型：insert，delete等
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注解解析&quot;&gt;注解解析&lt;/h3&gt;
&lt;p&gt;定义接口并实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserService {
    @Log(OperationType.INSERT)
    void save(User user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class LogProxyExt implements InvocationHandler {

    private Object obj;

    static Connection connection = null;

    public static Connection getConnection() throws ClassNotFoundException, SQLException {
        if(connection == null){
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            connection = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/fuxi?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;root&quot;);
        }
        return connection;
    }

    public LogProxyExt(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //查找方法上是否存在该注解
        Log annotation = method.getAnnotation(Log.class);
        if(annotation != null){
            User user = (User) args[0];
            if(user!=null &amp;amp;&amp;amp; StringUtils.isNotBlank(user.getName())){
                connection = getConnection();
                PreparedStatement statement = connection.prepareStatement(&quot;insert into log(`log_detail`,`operation`) values(?,?)&quot;);
                statement.setString(1, user.getName());
                statement.setString(2, annotation.value());
                statement.executeUpdate();
            }
        }

        //查找类上是否存在该注解
        proxy.getClass().getAnnotation(Log.class);
        //对类上的注解进行解析
        //todo
        Object invoke = method.invoke(obj, args);

        return invoke;
    }

    public static void main(String[] args) {
        UserService operat = new UserServiceImpl();
        LogProxyExt ext = new LogProxyExt(operat);
        //这里不能是具体的类，必须是接口 否则会抛出类转换异常
        UserService proxy = (UserService) Proxy.newProxyInstance(operat.getClass().getClassLoader(), operat.getClass().getInterfaces(), ext);
        User user = new User();
        user.setName(&quot;lisi&quot;);
        proxy.save(user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述解析通过JDK动态代理进行实现，对UserService接口进行代理，保证在UserService中任意位置使用@Log注解都能完成插入日志操作。实际使用可以配合Spring Aop或者拦截器之类的对全局请求进行处理。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;注解是一个很有用的特性，在现有的框架中大多数都已经支持或正在支持注解。使用注解可以大大提升我们平时的开发速度，保证代码的简洁性。除了框架和JDK自带的注解之外，我们也可以通过自定义注解来对我们的代码功能进行检查和增强。&lt;/p&gt;
</description>
<pubDate>Mon, 13 May 2019 05:56:00 +0000</pubDate>
<dc:creator>宁愿呢</dc:creator>
<og:description>从JDK5开始,Java增加对注解的支持，注解可以在编译，类加载和运行时被读取，并执行相应一些定义好的处理。通过注解可以在不改变原有代码和逻辑的情况下进行一些其他的补充操作。 系统注解 元注解 在ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyus/p/10856236.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 63 领域模型架构 eShopOnWeb项目分析 上 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10855824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10855824.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　本篇继续探讨web应用架构，讲基于DDD风格下最初的领域模型架构，不同于DDD风格下CQRS架构，二者架构主要区别是领域层的变化。 架构的演变是从领域模型到CQRS,  一开始DDD是用领域模型的分层架构，用单一的领域模型处理业务逻辑的所有方法，特别是命令和查询，这可能导致复杂性直线上升，CQRS是留住了DDD的优点又能使实现变得简单高效。&lt;/p&gt;
&lt;p&gt;　　 同样作为DDD领域驱动设计下的支持架构包括：领域模型架构和CQRS架构。虽然CQRS架构相比领域模型架构更受欢迎推荐，但领域模型架构也同样需要了解和掌握。&lt;/p&gt;
&lt;p&gt;　　在软件行业经过多年的传统三层开发后，演变出了DDD领域驱动设计。传统三层是UI层调用BLL层，BLL层调用DAL层，每层都有自己熟知的职责。但是缺点是编译时依赖关系由上而下运行，是一种高藕合，依赖程序太大，&lt;span&gt;而在设计原则中应该是低藕合，越低越好&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　1.1  Clean architecture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Clean  architecture 被称为“干净架构&quot;。遵循依赖倒置原则以及领域驱动设计原则 (DDD) 的应用程序倾向于达到类似的架构。&lt;span&gt;此依赖关系被倒置是:基础架构层和实现细节依赖于领域层，通过在领域层定义抽象或接口。然后由基础设施层中定义的具体类型来实现接口。理解这点很重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;比例在上篇项目中，由Equinox.Infra.Data数据访问层的Repository文件夹来实现领域层的IRepository接口。由Equinox.Infra.CrossCutting.Bus 层 命令总线的InMemoryBus类实现领域层的IMediatorHandler接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;下图是DDD干净架构多层以&quot;同心圆&quot;形式展示。通过下图可以了解到：&lt;span&gt;依赖关系流向最里面的圆。application core位于此关系图的核心位置而得名，该application core没有任何依赖项。application core的Entities和Interfaces位于正中心，正中心外圈是application core的域服务，域服务通常调用内圈中定义的Interfaces接口。application core外面UI(应用服务层)和基础设施层都依赖于application core。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513114404713-1118888650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　User Interface是表现层包括:控制器和视图模型（包括了应用服务层）。&lt;/p&gt;
&lt;p&gt;　　　　　　Infrastructure是基础设施层包括：仓储，其它服务实现。&lt;/p&gt;
&lt;p&gt;　　　　　　application core是领域层包括：领域服务，领域实体，领域接口 (来基础设施层来实现)。&lt;/p&gt;

&lt;p&gt;　　　　下图更好的反映了DDD各层的依赖关系，实线箭头表示编译时依赖关系，而虚线箭头表示仅运行时依赖关系。领域层是架构的核心层，不依赖于基础设施层，该层是可测试的。基础设施层引用领域层来实现数据持久化或横切关注点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513114459349-931775265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　下图是asp.net core web应用程序在DDD领域模型方案中完整构架,展现了各层明确的职责分布，虚线指编译依赖关系，也可以理解为项目引用关系，实线则是运行依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513114625032-1729115641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　在了解DDD领域模型构架分层后。接下来分析eShopOnWeb项目，来掌握DDD下的领域模型架构。下面是二个有代表性的领域模型架构项目，以微软的官方示例eShopOnWeb项目做重点分析。在分析中主要去了解领域层内部是怎么实现的，以及业务处理流程代码实现。&lt;/p&gt;

&lt;h3&gt;二.项目介绍 &lt;/h3&gt;
&lt;p&gt;　&lt;strong&gt;　2.1.  IBuyStuff-dm项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　&lt;a href=&quot;https://github.com/ElderJames/naa4e&quot; target=&quot;_blank&quot;&gt;IBuyStuff-dm&lt;/a&gt;项目是&quot;Microsoft.net企业级应用架构设计&quot;一书的项目案例(asp.net mvc项目)。从github上下载源码，需要在IBuyStuff.Server项目中安装mvc5(没果没有mvc5), 安装命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     Install-Package Microsoft.AspNet.Mvc -Version &lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　项目结构如下所示(左图为项目结构，右图为领域层二个类库)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513114909920-1350826801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;         　　项目分层说明: IBuyStuff.Server为表现层&lt;/p&gt;
&lt;p&gt;                                        IBuyStuff.Application为应用服务层&lt;/p&gt;
&lt;p&gt;                                        IBuyStuff.Domain为领域模型层&lt;/p&gt;
&lt;p&gt;                                        IBuyStuff.Domain.Services为领域服务层&lt;/p&gt;
&lt;p&gt;                                        IBuyStuff.Persistence为基础设施层    &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.2  eShopOnWeb项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在ASP.NET Core技术出来后，微软官方给出了一个&lt;a href=&quot;https://github.com/dotnet/eShopOnWeb&quot; target=&quot;_blank&quot;&gt;eShopOnWeb&lt;/a&gt;项目案例(asp.net core mvc项目)。该项目演示了一些原则和建议， 是一个简单在线商店，支持浏览衬衫、咖啡杯和其他市场产品名录。项目结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513115121336-1124647716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        　　 项目分层说明:&lt;/p&gt;
&lt;p&gt;                   　　Web包括表现层，应用服务层。其中Services文件夹和Interfaces文件夹代表是应用服务层，在上篇中说到，表现层和应用服务层都属于前端系统范围。&lt;/p&gt;
&lt;p&gt;                  　　 ApplicationCore领域层，包括了领域内部的所有实现。&lt;/p&gt;
&lt;p&gt;                  　　 Infrastructure基础设施层。主要是EF数据持久化。&lt;/p&gt;
&lt;p&gt;                 　　  tests文件夹包括了一系列完整的测试项目。&lt;/p&gt;

&lt;h3&gt;三. 项目配置&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;3.1 启用数据库类型　　&lt;/strong&gt;　　　　&lt;/p&gt;
&lt;p&gt; 　　　　下载了eShopOnWeb项目后，在Startup.cs的ConfigureDevelopmentServices方法中，可以选择是基于内存或sql server存储,我们选择使用sql server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureDevelopmentServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use in-memory database
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConfigureInMemoryDatabases(services);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use real database&lt;/span&gt;
&lt;span&gt;             ConfigureProductionServices(services);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;3.2 修改数据库链接地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;修改appsettings.json文件中的数据库连接，对应的两个数据库CatalogDb，Identity。&lt;/p&gt;
&lt;p&gt;         　　CatalogDb数据库用于商店的目录数据和购物车信息，Identity数据库用于应用程序的用户凭据和身份数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　3.3 同步到数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在vs2017中使用“程序包管理器控制台“默认项目选择Infrastructure，同步两个EF上下文到数据库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        PM&amp;gt; Update-Database  -&lt;span&gt;C AppIdentityDbContext
        PM&lt;/span&gt;&amp;gt; Update-Database  -C CatalogContext
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　同步后，生成的两个数据库，下面展示了CatalogDb业务数据库的关系图，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513115615933-1927239113.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　　　Orders表是用户订单信息，包含了送货地址信息。&lt;/p&gt;
&lt;p&gt;　　　　OrderItems表是订单商品信息。&lt;/p&gt;
&lt;p&gt;　　　　Catalog是商城商品信息&lt;/p&gt;
&lt;p&gt;　　　　CatalogBrand是商城商品品牌信息&lt;/p&gt;
&lt;p&gt;　　　　CatalogType是商城商品类别。比如T-Shirt衬衫，Mug杯子&lt;/p&gt;
&lt;p&gt;　　　　Baskets 是购物车&lt;/p&gt;
&lt;p&gt;　　　　BasketItem是购物车商品信息。&lt;/p&gt;

&lt;p&gt;　　　　启动运行eShopOnWeb程序，使用默认的用户名和密码进行登录: demouser@microsoft.com   Pass@word1。 项目包括二个模块功能，一个是订单管理，一个是用户管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201905/151560-20190513115722297-1346751156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　参考资料&lt;/p&gt;
&lt;p&gt;　　　　Microsoft.NET企业级应用架构设计 第二版&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/common-web-application-architectures&quot; target=&quot;_blank&quot;&gt;常用的web架构&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 May 2019 05:45:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 本篇继续探讨web应用架构，讲基于DDD风格下最初的领域模型架构，不同于DDD风格下CQRS架构，二者架构主要区别是领域层的变化。 架构的演变是从领域模型到CQRS, 一开始DDD是用领域模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10855824.html</dc:identifier>
</item>
</channel>
</rss>