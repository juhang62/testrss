<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《HelloGitHub》第 52 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13387691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13387691.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727211219807-967660113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;c-项目&quot;&gt;C 项目&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Simple-XX/SimpleKernel&quot;&gt;SimpleKernel&lt;/a&gt;：一个用来练手的简单内核项目。提供了各个阶段完成度不同的内核，可以选择从自己喜欢的地方开始&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727205922645-1042626650.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/s-matyukevich/raspberry-pi-os&quot;&gt;raspberry-pi-os&lt;/a&gt;：基于树莓派的操作系统开发教程（还未完结）。你的树莓派在吃灰吗？把它插上电用来学习开发操作系统吧&lt;/p&gt;
&lt;h3 id=&quot;c-项目-2&quot;&gt;C# 项目&lt;/h3&gt;
&lt;p&gt;3、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/microsoft/perfview&quot;&gt;perfview&lt;/a&gt;：微软开源的性能分析工具。配套的教程&lt;a href=&quot;https://channel9.msdn.com/Series/PerfView-Tutorial&quot;&gt;视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727205952460-1880014927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;c-项目-3&quot;&gt;C++ 项目&lt;/h3&gt;
&lt;p&gt;4、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/idea4good/GuiLite&quot;&gt;GuiLite&lt;/a&gt;：引用方便的 C++ 全平台 GUI 库。能够使用在 PC 端、移动设备、物联网设备甚至是没有操作系统的单片机，还支持多种开发语言和三方库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210009177-2138000909.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/csb6/html-plus-plus&quot;&gt;html-plus-plus&lt;/a&gt;：这个库让你可以使用 C++ 模板编写 HTML。HTML 文档被表示为一个单一的、深层嵌套的类型，相当于 HTML 的模版引擎。代码简单可供新手学习和使用，示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;html++.h&quot;

int main()
{
  html&amp;lt;
    head&amp;lt;
      title&amp;lt;&quot;Help Me.&quot;&amp;gt;
    &amp;gt;,
    body&amp;lt;
      h1&amp;lt;&quot;The horror!&quot;&amp;gt;,
      p&amp;lt;&quot;Someone has probably done this before, but I can see why it didn't catch on.&quot;&amp;gt;,
      a&amp;lt;&quot;href=https://github.com/csb6/html-plus-plus&quot;, &quot;For science&quot;&amp;gt;
    &amp;gt;
  &amp;gt; page;

  std::cout &amp;lt;&amp;lt; page.content;
  return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h3&gt;
&lt;p&gt;6、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/yudai/gotty&quot;&gt;gotty&lt;/a&gt;：能够把终端执行的命令展示到网页上的工具。安装和运行命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;安装：go get github.com/yudai/gotty
运行：gotty [options] &amp;lt;command&amp;gt; [&amp;lt;arguments...&amp;gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210100001-595949880.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/hoanhan101/algo&quot;&gt;algo&lt;/a&gt;：Golang 程序员面试中的问题和解答集合。该项目目前完成了大部分的数据结构和算法部分，准备相关面试的小伙伴可以阅读学习起来了&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/sirupsen/logrus&quot;&gt;logrus&lt;/a&gt;：可能是 Go 目前最受欢迎的第三方日志库。日志首先要能让人看懂，其次是程序易于处理日志包含的内容，logrus 也许能让你轻松快速实现上述两点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210117645-41578043.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/gorilla/websocket&quot;&gt;websocket&lt;/a&gt;：Go 的 websocket 三方库。看看它和标准库的对比，你就知道为什么它会出现在本期月刊中了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210134747-1535227323.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h3&gt;
&lt;p&gt;10、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/kingyuluk/FlappyBird&quot;&gt;FlappyBird&lt;/a&gt;：Java 标准库实现的 Flappy Bird。优化了游戏难度并加入移动型水管，增加可玩性。没有采用第三方库和游戏引擎、项目结构简单、代码注释完整，适合 Java 初学者做为编程入门实战项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210224288-1238923353.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/metersphere/metersphere&quot;&gt;metersphere&lt;/a&gt;：一站式的开源企业级持续测试平台。适应场景包括：测试跟踪、接口测试、性能测试等，兼容 JMeter 等开源标准，能够帮助开发和测试团队充分利用云弹性进行高度可扩展的自动化测试。测试同学的福音&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210254862-756411208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/apache/incubator-iotdb&quot;&gt;incubator-iotdb&lt;/a&gt;：清华大学软件学院自主研发并开源的时间序列数据管理引擎。能够有效应对工业物联网领域时间序列数量多、写入频率高、数据乱序到达、秒级聚合等场景。官方网站有系统设计文档和使用手册，作为初学者，可以系统的学习数据库系统的完整设计和实现。在 IoTDB 社区可以与国内用户直接交流、收集需求、设计功能、性能优化，每个改进点都可以看到直接效果。还可以体验 Apache 开源软件的工作模式，与世界各地的开发者交流想法，也有机会成为 Apache Committer、PMC 等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210312973-1831011124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/gedoor/MyBookshelf&quot;&gt;MyBookshelf&lt;/a&gt;：免费开源的安卓小说阅读软件，能够自定义订阅小说数据源。支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局状态栏沉浸&lt;/li&gt;
&lt;li&gt;自定义多线程搜索、缓存&lt;/li&gt;
&lt;li&gt;支持一键缓存&lt;/li&gt;
&lt;li&gt;点击章节名跳转小说目录&lt;/li&gt;
&lt;li&gt;自定义字体、阅读背景、文字颜色、背景颜色&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210336046-1439699473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Tencent/QMUI_Android&quot;&gt;QMUI_Android&lt;/a&gt;：用于辅助快速搭建一个具备基本还原设计效果的 Android 项目。快速搭建一个 Demo App 的必备利器，&lt;a href=&quot;https://qmuiteam.com/android&quot;&gt;官网&lt;/a&gt;还提供示例 App 下载，感兴趣的小伙伴快去试试吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210352743-1330979652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h3&gt;
&lt;p&gt;15、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Summer-andy/chrome-extensions-searchReplace&quot;&gt;chrome-extensions-searchReplace&lt;/a&gt;：一款搜索并且替换文本的谷歌插件。在做产品 PPT 的时候，需要对某些个页面中的一些名词进行统一替换，这个插件就是为了解决这个问题而诞生的。同时作者也是调研了其他类似功能的插件，它们都包含或多或少的问题，最终作者自己动手做了这个项目。可以说这款替换插件应该就是你最终的选择了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210409207-422853362.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/apidoc/apidoc&quot;&gt;apidoc&lt;/a&gt;：根据代码中的注释生成 RESTful 风格的 API 文档。注释示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @api {get} /user/:id Request User information
 * @apiName GetUser
 * @apiGroup User
 *
 * @apiParam {Number} id User's unique ID.
 *
 * @apiSuccess {String} firstname Firstname of the User.
 * @apiSuccess {String} lastname  Lastname of the User.
 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;17、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/mongo-express/mongo-express&quot;&gt;mongo-express&lt;/a&gt;：使用 Node.js、Express 和 Bootstrap3 编写的 MongoDB 管理平台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210441256-333728560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Zettlr/Zettlr&quot;&gt;Zettlr&lt;/a&gt;：开源免费支持多种操作系统的 Markdown 编辑器。如果你想尝试一款新的 Markdown 编辑器，它或许能满足你对编辑器所有想法，如果还不够那就自己动手增加吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210457845-157327613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/skygragon/leetcode-cli&quot;&gt;leetcode-cli&lt;/a&gt;：LeetCode 的命令行工具。之前我们推荐过命令行斗地主、划水逛社区等，真正努力的人用命令行来刷算法题！我颤抖了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210517936-1921552582.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h3&gt;
&lt;p&gt;20、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/wstyres/Zebra&quot;&gt;Zebra&lt;/a&gt;：用于越狱的 iOS 设备的软件包管理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210535184-1946630937.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h3&gt;
&lt;p&gt;21、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/cyrildiagne/ar-cutpaste&quot;&gt;ar-cutpaste&lt;/a&gt;：AR 拷贝实物照片到 PS 软件的工具。它可以通过 iPhone 或者 Android 手机将真实物品从周围环境中抠出来，并粘贴到 Photoshop 中，未来还会支持其它软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210550025-102771348.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/nondanee/ncmdump&quot;&gt;ncmdump&lt;/a&gt;：网易云音乐下载的 NCM 文件转化工具&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/schenkd/nginx-ui&quot;&gt;nginx-ui&lt;/a&gt;：在线修改 Nginx 配置的服务。总的来说还是能减少修改配置出错的概率，而且不用面对漆黑枯燥的命令行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210625398-1938606771.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/theskumar/python-dotenv&quot;&gt;python-dotenv&lt;/a&gt;：帮你更好的管理 Python 项目中敏感配置信息的开源三方库。在项目中会有一些数据库、账户、KEY 等敏感信息，这些信息最好不要写在源代码中。为了降低泄漏风险，一般会通过环境变量来设置，这个库可以很方便帮你在 Python 项目中管理这些信息。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 安装：pip install -U python-dotenv
# 目录结构：
.
├── .env
└── settings.py
# 示例代码
# settings.py
import os
from dotenv import load_dotenv
load_dotenv()

SECRET_KEY = os.getenv(&quot;EMAIL&quot;)
DATABASE_PASSWORD = os.getenv(&quot;DATABASE_PASSWORD&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;p&gt;25、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/plausible/analytics&quot;&gt;analytics&lt;/a&gt;：一个开源的轻量级 Web 访问分析工具。如果你不想侵犯用户的隐私，只获取自己网站访问的基本数据，可以试试这个项目，用来代替谷歌分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210643148-1823761204.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/MrMimic/data-scientist-roadmap&quot;&gt;data-scientist-roadmap&lt;/a&gt;：数据科学技能路线图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210701666-980323179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;27、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/nvaccess/nvda&quot;&gt;nvda&lt;/a&gt;：一个微软开源的免费 Windows 操作系统的无视觉桌面访问阅读器。通过合成器语音或者盲文点字的反馈，方便盲人和低视力人群使用运行在 Windows 操作系统下运作的电脑。也能够让开发者了解微软的常见的辅助功能接口，如微软 Active Accessibility、Java Access Bridge、IAccessible2 和 UI automation。希望有更多的人了解无障碍，&lt;a href=&quot;https://www.nvdacn.com/&quot;&gt;NVDA 中文站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;28、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/afatcoder/LeetcodeTop&quot;&gt;LeetcodeTop&lt;/a&gt;：国内各大互联网公司常考的 LeetCode 题目&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/pomber/git-history&quot;&gt;git-history&lt;/a&gt;：在线查看 GitHub 开源项目中文件的改动历史的工具。使用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 打开 GitHub 上任意一个项目的文件
2. 把地址中的 github.com 替换成 githistory.xyz
3. 访问替换后的地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210721274-1706295003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/anuraghazra/github-readme-stats&quot;&gt;github-readme-stats&lt;/a&gt;：在你的 README 中展示动态生成的 GitHub 统计信息。使用简单、样式多样，使用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[![Anurag's github stats](https://github-readme-stats.vercel.app/api?username=521xueweihan)](https://github.com/anuraghazra/github-readme-stats)

替换“521xueweihan”为你的 GitHub 用户名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210751669-920420896.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;31、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/PapirusDevelopmentTeam/papirus-icon-theme&quot;&gt;papirus-icon-theme&lt;/a&gt;：适用于 Linux 系统的免费开源 SVG 图标主题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210820592-1670902463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;机器学习&lt;/h3&gt;
&lt;p&gt;32、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/vt-vl-lab/3d-photo-inpainting&quot;&gt;3d-photo-inpainting&lt;/a&gt;：一个把单张静态照片转化成 3D 图片的项目。快来尝鲜啦，不要等朋友圈 3D 照片刷屏后才“后知后觉”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210835687-1550151745.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你发现了 GitHub 上有趣的项目，欢迎在 HelloGitHub 项目提 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;issues&lt;/a&gt; 告诉我们。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200727210902998-1464727091.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Jul 2020 00:18:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>兴趣是最好的老师，HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向编程新手、热爱编程、对开源社区感兴趣 人群的月刊，月刊的内容包括：各种编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13387691.html</dc:identifier>
</item>
<item>
<title>python工业互联网应用实战3—模型层构建 - wuch</title>
<link>http://www.cnblogs.com/haozi0804/p/13379316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haozi0804/p/13379316.html</guid>
<description>&lt;p&gt;本章开始我们正式进入到实战项目开发过程，如何从需求分析获得的实体数据转到模型设计中来，变成Django项目中得模型层&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;231.87193596798&quot;&gt;
&lt;p&gt;&lt;span&gt;  本章开始我们正式进入到实战项目开发过程，如何从需求分析获得的实体数据转到模型设计中来，变成&lt;/span&gt;Django&lt;span&gt;项目中得模型层。当然，第一步还是在&lt;/span&gt;&lt;span&gt;VS2019 IDE&lt;/span&gt;&lt;span&gt;环境重创建一个工程项目，本文我们把工程名称命名为&lt;/span&gt;&lt;span&gt;IndDemo&lt;/span&gt;&lt;span&gt;，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090351735-1218238776.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; VS2019&lt;span&gt;创建的&lt;/span&gt;&lt;span&gt;Django&lt;/span&gt;&lt;span&gt;项目结构如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090413343-1787422379.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;现在按&lt;/span&gt;F5&lt;span&gt;调试程序，又来到&lt;/span&gt;&lt;span&gt;Django&lt;/span&gt;&lt;span&gt;熟悉的欢迎页面了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090434878-997465215.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;接下来让开始这趟实战之旅吧&lt;/span&gt;!&lt;/p&gt;
&lt;h3&gt;1.1. &lt;strong&gt;实体关系图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   从上一章需求涉及到的实体，来构建我们的实体关系图吧，这里的步骤也相当于早期开发设计的表结构设计，只是如前面章节说的有了&lt;/span&gt;ORM&lt;span&gt;机制后，我们讨论采用对象模型来设计和讨论实体可能更适合于实际的场景讨论，便于团队在同一个频道下沟通，当然这里实质上与表设计没有太多本质的区别，但是多对多等中间表在实体关系图中就看不到了，表结构设计时就不能忽略这个中间表的存在。产品经理更专注于需求而不是数据库存储结构是不是更符合专业分工？开发人员也不用大费周章来折腾表结构的优化了。嗯，这些可以丢给&lt;/span&gt;&lt;span&gt;DBA&lt;/span&gt;&lt;span&gt;来优化吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090512333-1644265266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;本图采用网址&lt;/span&gt;ponyorm&lt;span&gt;网站在线绘制，网址：&lt;/span&gt;&lt;a href=&quot;https://editor.ponyorm.com/&quot;&gt;&lt;span&gt;https://editor.ponyorm.com/&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;1.2. &lt;strong&gt;Django model&lt;span&gt;层&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  为了便于对照学习和理解，我们新增一个新的&lt;/span&gt;APP &lt;span&gt;命名为：&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt;&lt;span&gt;来专门处理这个业务，不修改默认的&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;里的代码，也便于过程中可以通过这个默认&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;功能，参照它的结构和语法等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090600892-98803371.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 现在我们的工程目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090618445-1636542769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;打开&lt;/span&gt;Task.models.py&lt;span&gt;文件编写我们实体关系图的模型代码吧，作者本人比较习惯“大驼峰”命名法也就是首字母都大写的模式&lt;/span&gt;&lt;span&gt;TaskNum&lt;/span&gt;&lt;span&gt;，后面很多命名都会采用这个方式，不采用&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;主流的蛇形命名法的&lt;/span&gt;&lt;span&gt;task_num&lt;/span&gt;&lt;span&gt;方式，纯属个人习惯。我们依据设计我们开始构建我们的&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;122&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; User

PRIORITY&lt;/span&gt;=((1,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;正常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;急&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(3,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;紧急&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Task(models.Model):
    TASK_STATE&lt;/span&gt;=((1,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;未处理&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(4,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;处理成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(5,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行中&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(99,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;完成&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(-1,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;已取消&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    TaskId &lt;/span&gt;= models.AutoField(primary_key=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    TaskNum &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Source &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;源地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Target &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;目标地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Barcode &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;容器条码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;barcode&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    State &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, choices=TASK_STATE, null=False, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Priority &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;优先级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, choices=PRIORITY, null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;priority&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    BeginDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    EndDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    SystemDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;系统时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, auto_now_add=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;system_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    User &lt;/span&gt;= models.ForeignKey(User, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;操作员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, on_delete=models.CASCADE,db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        db_table &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        ordering &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-Priority&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TaskId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        verbose_name &lt;/span&gt;= verbose_name_plural = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str(self.TaskNum)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job(models.Model):
    JOB_STATE&lt;/span&gt;=((1,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;新作业&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;下达执行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (99,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;完成&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(-1,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;已取消&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    JobId &lt;/span&gt;= models.AutoField(primary_key=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Task &lt;/span&gt;= models.ForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, blank=True, on_delete=&lt;span&gt;models.CASCADE)
    TaskNum &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    OrderNo &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;顺序号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;order_no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Source &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;源地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=True, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Target &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;目标地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=True, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Executor &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False,blank=True, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;executor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    State &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, choices=JOB_STATE, null=False, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Priority &lt;/span&gt;= models.IntegerField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;优先级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, choices=PRIORITY, null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;priority&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    BeginDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;begin_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    EndDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结束时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,null=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    SystemDate &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;系统时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, auto_now_add=True, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;system_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    Barcode &lt;/span&gt;= models.CharField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;条码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, null=False, max_length=50, db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;barcode&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    User &lt;/span&gt;= models.ForeignKey(User, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;操作员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, on_delete=models.CASCADE,db_column=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        db_table &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        ordering &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JobId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        verbose_name &lt;/span&gt;= verbose_name_plural = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;作业&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str(self.TaskNum) +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+str(self.OrderNo)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 1.3. &lt;strong&gt;make migrations&lt;span&gt;创建数据库迁移&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　&lt;span&gt;首先，我们在项目的&lt;/span&gt;settings.py&lt;span&gt;文件里登记我们新增加的&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Add your apps here to enable them&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.contenttypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.staticfiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后，在&lt;/span&gt;IDE&lt;span&gt;通过菜单就可以创建新建&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;产生的数据库迁移，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090836963-346125326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090850897-1245088553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.4. &lt;strong&gt;migrate&lt;/strong&gt; &lt;strong&gt;迁移数据库&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  同样在&lt;/span&gt;IDE&lt;span&gt;窗口可以直接执行迁移命令，执行完数据迁移命令，工程默认链接的&lt;/span&gt;&lt;span&gt;SQLite&lt;/span&gt;&lt;span&gt;数据库就包含这次我们创建的数据表了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726090927014-956398545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过数据库工具查看数据文件里面的表创建情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726091018234-1341408232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.5. &lt;strong&gt;Create Superuser&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  由于我们的&lt;/span&gt;model Task&lt;span&gt;中定义了&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;这个引用&lt;/span&gt;django.contrib.auth.models.User&lt;span&gt;的外键非空属性，我们需要创建一个&lt;/span&gt;Django Admin&lt;span&gt;的超级用户，才能正常的保存&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt; &lt;span&gt;模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726091052210-12192436.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  按照命令提示创建好超级用户我们就可以通过&lt;/span&gt;ORM&lt;span&gt;操作数据库了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.6. &lt;strong&gt;Django ORM&lt;span&gt;操作&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;    Django ORM&lt;span&gt;提供了诸多的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;接口，详情请参考官网文档或网上教程，笔者的项目实战也是遇到某类问题了，也是大量通过搜索引擎来找到相关的使用方法来改进功能代码的。 实战项目使用到&lt;/span&gt;&lt;span&gt;ORM&lt;/span&gt;&lt;span&gt;的操作很多，未来我们会逐步的使用到时，会进一步说明。本章节只举一些常用的例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 通过&lt;/span&gt;ORM&lt;span&gt;我们可以不关心数据库表结构，采用&lt;/span&gt;&lt;span&gt;ORM&lt;/span&gt;&lt;span&gt;机制就可以&lt;/span&gt;&lt;span&gt;CRUD&lt;/span&gt;&lt;span&gt;表里的数据了，数据将按照对象的方式的方式返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726091135440-1118424249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;1.返回所有的&lt;/span&gt;Task&lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; Task.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Task

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Task.objects.all()

&lt;/span&gt;&amp;lt;QuerySet []&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;2.新增&lt;/span&gt;Task&lt;span&gt;对象&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; a=Task(None,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-1-1001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2002001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1,1,None,None,None,1&lt;span&gt;)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a.save()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Task.objects.all()

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过数据库工具也能看到这条新创建的&lt;/span&gt;Task&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202007/67400-20200726091207942-1899096433.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;3.通过&lt;/span&gt;TaskId&lt;span&gt;获取&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.get(TaskId=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;Task: 1001&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;上面&lt;/span&gt;get&lt;span&gt;方法的两个不同的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 4.&lt;span&gt;通过&lt;/span&gt;dict&lt;span&gt;对象创建&lt;/span&gt;&lt;span&gt;Task&lt;/span&gt;&lt;span&gt;对象，这个模式后面用在以&lt;/span&gt;&lt;span&gt;Json&lt;/span&gt;&lt;span&gt;格式从前台提交数据会非常方便&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;data={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TaskNum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1-1-1002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Barcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2002002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;State&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Priority&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1&lt;span&gt;}

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; model=Task(**&lt;span&gt;data)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; model.save()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Task.objects.all()

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;User&lt;span&gt;外键对象必须通过&lt;/span&gt;_id赋值&quot;User_id&quot;:1，&lt;span&gt;通常在变量前加一个星号&lt;/span&gt;(*)&lt;span&gt;表示这个变量是元组&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;列表，加两个星号表示这个参数是字典。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;em&gt;5.匹配条件&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(TaskNum=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;6.不匹配条件&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.exclude(TaskNum=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;7.获取单条数据（主键唯一）&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.get(pk=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;Task: 1001&amp;gt;

&amp;gt;&amp;gt;&amp;gt; Task.objects.get(TaskId=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;Task: 1001&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;8.大于 &lt;/em&gt;__gt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__gt=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;9.大于等于&lt;/span&gt; __gte&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__gte=1&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt; 10.&lt;span&gt;小于&lt;/span&gt; __lt&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__lt=2&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;11.小于等于&lt;/span&gt; __lte&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__lte=2&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt; 12.&lt;span&gt;大于和小于，&lt;/span&gt; 1 &amp;lt; TaskId &amp;lt; 5&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__gt=1,pk__lt=5&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;13.包含 __in []&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__in=[1,2,3,4,5&lt;span&gt;])

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt; 14.&lt;span&gt;不包含，&lt;/span&gt;not in&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.exclude(pk__in=[2,3,4,5&lt;span&gt;])

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt; 15.&lt;span&gt;为空：&lt;/span&gt;isnull=True&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(BeginDate__isnull=&lt;span&gt;True)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;span&gt;16.匹配，大小写敏感&lt;/span&gt; __contains&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(Barcode__contains=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt; 17.&lt;span&gt;匹配，大小写不敏感&lt;/span&gt; __icontains&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(Barcode__icontains=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt; 18.&lt;span&gt;范围&lt;/span&gt;,__range&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.filter(pk__range=[2,6&lt;span&gt;])

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1002&amp;gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt; 19.&lt;span&gt;排序，&lt;/span&gt;order by&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.all().order_by(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1001&amp;gt;, &amp;lt;Task: 1002&amp;gt;]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;20.倒排序，&lt;/span&gt;order by&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Task.objects.all().order_by(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;QuerySet [&amp;lt;Task: 1002&amp;gt;, &amp;lt;Task: 1001&amp;gt;]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　更多的&lt;/span&gt;ORM&lt;span&gt;查询操作查阅官网文档，上面是业务编程过程用得比较多的一些过滤查询方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;span&gt;1.7. &lt;/span&gt;&lt;strong&gt;&lt;span&gt;小节&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;本章我们着重在通过构建实体和实体关系图，实体的属性通常来自业务需求分析和设计时增加的一些必要的字段，如：时间戳、创建对象的用户等就是为了便于查找、定位、过滤数据，以及业务管理上考虑必要增加的一些多出来的实体属性。这里笔者由于历史习惯，表字段命名又采用蛇形命名法，所以增加了一个强制字段名称的属性&lt;/span&gt;&lt;span&gt;db_column=&lt;/span&gt;&lt;span&gt;'user_id'&lt;/span&gt;&lt;span&gt;&lt;span&gt;都是个人习惯缘故，如果全部采用蛇形命名法这个属性就可以去掉了。完成了&lt;/span&gt;model&lt;span&gt;的构建后，我们就可以进行展开业务逻辑的开发了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;下一章我们讲讲&lt;/span&gt;Django&lt;span&gt;后台开发的利器&lt;/span&gt; &lt;span&gt;Django Admin&lt;/span&gt;&lt;span&gt;，来快速的构建一个后台管理框架，你会发现&lt;/span&gt;&lt;span&gt;Django&lt;/span&gt;&lt;span&gt;给我们省了好多好多事情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 27 Jul 2020 23:43:00 +0000</pubDate>
<dc:creator>wuch</dc:creator>
<og:description>本章开始我们正式进入到实战项目开发过程，如何从需求分析获得的实体数据转到模型设计中来，变成Django项目中得模型层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haozi0804/p/13379316.html</dc:identifier>
</item>
<item>
<title>【评价指标】详解F1-score与多分类MacroF1&amp;MicroF1 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13358409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13358409.html</guid>
<description>&lt;p&gt;文章来自：一个宝藏微信公众号【机器学习炼丹术】&lt;/p&gt;

&lt;p&gt;首先，要背住的几个概念就是：accuracy,precision,recal, TP,FP,TN,FN&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TP:true positive。预测是正确的正样本&lt;/li&gt;
&lt;li&gt;FP:false positive。预测是错误的正样本&lt;/li&gt;
&lt;li&gt;TN：true negative。预测是正确的负样本&lt;/li&gt;
&lt;li&gt;FP:false positive。预测是错误的负样本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常我们会做出这样的一个混淆矩阵：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_9cb89fde6949def09e1b93f8f16f6fe7.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;左边的positive，negative表示样本真实值，表格上边的positive，negative表示样本的预测结果。&lt;/p&gt;
&lt;p&gt;现在我们有这样的一个例子：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_f495f9cdb74c4e84f6c5691d71eb17a1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图中的TP，FP等是一个比例，假设总共有100个样本，有40个是TP，有20个是FP……(不过混淆矩阵一般不用除以总样本数量)&lt;/p&gt;
&lt;p&gt;现在我们有了&lt;span class=&quot;math inline&quot;&gt;\(TP=0.3,FP=0.1,TN=0.4,FN=0.2\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;准确率是指，对于给定的测试数据集，分类器正确分类的样本书与总样本数之比，也就是预测正确的概率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_e3ac0c1826bd94ae3f5b59c12e7a23ec.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应上面的例子，可以得到Accuracy=0.7。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【准确率Accuracy的弊端】&lt;/strong&gt;&lt;br/&gt;准确率作为我们最常用的指标，当出现样本不均衡的情况时，并不能合理反映模型的预测能力。例如测试数据集有90%的正样本，10%的负样本，假设模型预测结果全为正样本，这时准确率为90%，然而模型对负样本没有识别能力，此时高准确率不能反映模型的预测能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表示预测为正的样本中，实际的正样本的数量。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_31bd3dd4d4f84f71da17e9463bc6d809.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应上面的例子，&lt;span class=&quot;math inline&quot;&gt;\(precision=\frac{0.3}{0.3+0.1}=0.75\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【个人理解】&lt;/strong&gt;&lt;br/&gt;Precision是针对预测结果而言的。预测结果中，预测为正的样本中预测正确的概率。&lt;strong&gt;类似于一个考生在考卷上写出来的答案中，正确了多少。&lt;/strong&gt;体现模型的精准度，模型说：我说哪个对哪个就是对的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recall表示实际为正的样本被判断为正样本的比例&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_332c50f0bf41ee3aae839dd824c1ff12.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;对应上述的例子，得到&lt;span class=&quot;math inline&quot;&gt;\(Recall=\frac{0.3}{0.3+0.2}=0.6\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【个人理解】&lt;/strong&gt;&lt;br/&gt;Recall是针对数据样本而言的。数据样本中，正样本中预测正确的概率。&lt;strong&gt;类似于一个考生在考卷上回答了多少题。&lt;/strong&gt;体现一个模型的全面性，模型说：所有对的我都能找出来。&lt;/p&gt;

&lt;p&gt;Precision和Recall是一对矛盾的度量，一般来说，Precision高时，Recall值往往偏低；而Precision值低时，Recall值往往偏高。当分类置信度高时，Precision偏高；分类置信度低时，Recall偏高。为了能够综合考虑这两个指标，F-measure被提出（Precision和Recall的加权调和平均），即：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_f41970ed01d1ef63028648d826da2f5b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F1的核心思想在于，在尽可能的提高Precision和Recall的同时，也希望两者之间的差异尽可能小。F1-score适用于二分类问题，对于多分类问题，将二分类的F1-score推广，有Micro-F1和Macro-F1两种度量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【Micro-F1】&lt;/strong&gt;&lt;br/&gt;统计各个类别的TP、FP、FN、TN，加和构成新的TP、FP、FN、TN，然后计算Micro-Precision和Micro-Recall，得到Micro-F1。具体的说，统计出来各个类别的混淆矩阵，然后把混淆矩阵“相加”起来，得到一个多类别的混淆矩阵，然后再计算F1score&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【Macro-F1】&lt;/strong&gt;&lt;br/&gt;我感觉更常用的是Macro-F1。统计各个类别的TP、FP、FN、TN，分别计算各自的Precision和Recall，得到各自的F1值，然后取平均值得到Macro-F1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【总结】&lt;/strong&gt;&lt;br/&gt;从上面二者计算方式上可以看出，Macro-F1平等地看待各个类别，它的值会受到稀有类别的影响；而Micro-F1则更容易受到常见类别的影响。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1]&lt;a href=&quot;http://zjmmf.com/2019/08/13/F1-Score%E8%AE%A1%E7%AE%97/&quot;&gt;http://zjmmf.com/2019/08/13/F1-Score计算/&lt;/a&gt;&lt;br/&gt;[2]&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49895905&quot;&gt;https://zhuanlan.zhihu.com/p/49895905&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlQTAlODclRTklQTIlOThfJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUJBJUJGXzIwMjAtMDctMjAtMC5naWY&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy93cF9lZGl0b3JfbWRfMzEyZGQyZDliYmNmZmNiZDk0Y2YwODlkYTE4YzVjNGEuanBn?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlOTYlODclRTQlQkIlQjYxNTk1MjUxNjIxMTEyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 22:03:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章来自：一个宝藏微信公众号【机器学习炼丹术】 基本概念 首先，要背住的几个概念就是：accuracy,precision,recal, TP,FP,TN,FN TP:true positive。预测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13358409.html</dc:identifier>
</item>
<item>
<title>浪里来浪里去！网络协议如何成就网上冲浪？ - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/13388701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/13388701.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们网上冲浪也冲了这么多年，也该上岸好好看看这些浪的形状了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; 我们知道计算机之间的通过其实都是通过&lt;strong&gt;IP+端口&lt;/strong&gt;的形式，但是我们平时访问的时候根本就没涉及到这两个东西，还是能访问到资源，&lt;strong&gt;为啥呢？&lt;/strong&gt;这得问问我们神奇的&lt;strong&gt;DNS&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，举个例子，我们输入&lt;code&gt;www.bilibili.com&lt;/code&gt;，这个时候&lt;strong&gt;需要通过DNS将其转化为IP地址&lt;/strong&gt;才能继续访问，其流程大概是这样的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/27/kDrwzjCFYV3M2ig.png&quot; alt=&quot;DNS请求流程图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;从当前的浏览器中查询是否存在当前域名，如果有则返回其对应的IP地址，否则的话向本机操作系统中查询。&lt;/li&gt;
&lt;li&gt;操作系统如果有，则返回，浏览器将其缓存起来之后返回；如果操作系统查询不到的话，那么则向路由器缓存上查询。&lt;/li&gt;
&lt;li&gt;同上，有返回并且缓存到操作系统，操作系统返回并缓存到浏览器；无则向本地服务器请求。&lt;/li&gt;
&lt;li&gt;本地服务器就是运营商，比如说电信或者移动。操作过程同上，还没有的话就要向根服务器请求了。&lt;/li&gt;
&lt;li&gt;根服务器就是终点站了，操作跟上面一样，如果还没有的话，服务器就要请你检查你的域名了。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;okay&lt;/strong&gt;，上面绕了一圈之后我们现在拿到了B站的&lt;strong&gt;IP：假设为139.159.246.60&lt;/strong&gt;，接下来就可以访问了。&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200727161741%E5%81%9C%E4%B8%80%E4%B8%8Bj.jpg&quot; alt=&quot;停一下&quot;/&gt;&lt;p&gt; 是不是还少点了什么？哦，是了，&lt;strong&gt;少了端口&lt;/strong&gt;，那端口咋办呢？不用办，每个协议都有默认的端口，如果你不输入端口号的话就会使用默认的，例如&lt;strong&gt;http&lt;/strong&gt;协议默认&lt;code&gt;80&lt;/code&gt;，而&lt;strong&gt;https&lt;/strong&gt;默认&lt;code&gt;443&lt;/code&gt;，所以实际上输入&lt;code&gt;www.bilibili.com&lt;/code&gt;实际上请求的是&lt;code&gt;139.159.246.60:80&lt;/code&gt;，也就是机器IP地址为&lt;code&gt;139.159.246.60上&lt;/code&gt;的&lt;code&gt;80&lt;/code&gt;端口的&lt;strong&gt;程序&lt;/strong&gt;，所以&lt;strong&gt;B站服务器的服务要占用监听80端口&lt;/strong&gt;，当然那边肯定还做了&lt;strong&gt;负载均衡&lt;/strong&gt;，这就不扯了。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;现在知道具体地址地址还需要做什么呢，还需要&lt;strong&gt;建立连接&lt;/strong&gt;，要保证等下进行数据传输的时候是okay的，所以这边会&lt;strong&gt;跟服务器建立TCP连接&lt;/strong&gt;，完成之后进入下一步。&lt;/li&gt;
&lt;li&gt;连接okay了，&lt;strong&gt;浏览器这边就组装好请求头准备发送请求&lt;/strong&gt;，请求头包含了一些重要的信息如请求的方式、代理、请求格式，接收格式等，组装完成后发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器收到请求解析之后包装所需信息返回。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端（一般是浏览器或者APP）这边接收到之后进行&lt;strong&gt;渲染&lt;/strong&gt;，然后就是我们平时看到的图形界面了。&lt;/li&gt;
&lt;li&gt;最后根据是否保持连接来决定是否关闭。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样一次对B站的访问就完成了。但是这都是表面，我们甚至都不知道浪里的是水还是盐，计算机究竟是如何通过网络来通信的，接下来让我们走进《网络》。&lt;/p&gt;

&lt;p&gt; 上面说到一个请求的完整路径，但那只是站在应用层的角度来看的，而在网络中应用层只是属于某个模型的一部分。&lt;/p&gt;
&lt;p&gt; 平时所说的网络模型有三种：&lt;strong&gt;&lt;code&gt;OSI七层&lt;/code&gt;、&lt;code&gt;TCP/IP五层&lt;/code&gt;、&lt;code&gt;TCP/IP四层&lt;/code&gt;。&lt;/strong&gt;这三种模型都是&lt;strong&gt;概念模型&lt;/strong&gt;，注意是概念模型，也就是说实现的方式并不是固定的，三兄弟来亮个相吧。&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2020/07/27/qnj8bx7y9f3c1Lw.png&quot; alt=&quot;网络模型&quot;/&gt;&lt;p&gt; 这几层背起来还不用一分钟，但那没用，就跟名字一样，需要的是灵魂，而不是枯燥的文字，所以需要理解。&lt;/p&gt;
&lt;h2 id=&quot;七层模型&quot;&gt;七层模型&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;七层懂了，四、五层还难吗。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道&lt;strong&gt;数据在计算机底层最终都会变成0和1&lt;/strong&gt;，那么可能有人问了，现在计算机那么牛逼，底层给整个&lt;strong&gt;2&lt;/strong&gt;或者&lt;strong&gt;3&lt;/strong&gt;出来总可以吧，老是纠结&lt;strong&gt;0&lt;/strong&gt;和&lt;strong&gt;1&lt;/strong&gt;干嘛？说实话，实在是办不到。&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200727161701image-20200723225424711.png&quot; alt=&quot;变3&quot;/&gt;&lt;p&gt; 计算机通过电缆的电信号来实现通信，而&lt;strong&gt;电信号只有高低两种&lt;/strong&gt;，所以也就分别&lt;strong&gt;对应计算机数字的1和0&lt;/strong&gt;，这也是&lt;strong&gt;物理层的作用&lt;/strong&gt;，将数字转化为电信号发给其他计算机。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;物理层：&lt;/strong&gt;将接收到的数据从1和0转化成高低信号发送给其他计算机。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但发是发出来了，其他计算机怎么知道你阿巴阿巴在说什么呢，不懂也没意义啊。所以需要定义一些规则，例如发送&lt;strong&gt;32&lt;/strong&gt;位，前&lt;strong&gt;8&lt;/strong&gt;位是文件信息，后&lt;strong&gt;24&lt;/strong&gt;位才是数据，这样就知道了，&lt;strong&gt;这种规则就叫做协议。&lt;/strong&gt;但是协议人人都可以定，一千个哈姆雷特就有一千种协议，这么多个哈姆雷特有点渗人，所以&lt;strong&gt;需要一个标准来进行统一，这才出现了以太网协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;以太网协议&lt;/strong&gt;的内容大致为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;每组信号构成一个数据包，即&quot;帧&quot;。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个数据包都包含两个部分。&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;head：&lt;/strong&gt;固定18个字节，包含发送者、接收者和数据类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据体data：&lt;/strong&gt;真正的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;有了统一的标准，现在知道发送的是什么了，但是怎么知道要发给谁呢？那就是通过&lt;strong&gt;mac地址&lt;/strong&gt;，每台计算机都有着世界上&lt;strong&gt;独一无二&lt;/strong&gt;的&lt;strong&gt;mac&lt;/strong&gt;地址，通过这个地址能够标识唯一的一台计算机，将这当做地址再适合不过了。okay，现在发送内容有了，发给谁也知道了，那咋发呢？能不能通过一条准确的通道能够直达接收者呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/27/QOHbktEsnAYRldu.jpg&quot; alt=&quot;抱歉不能&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 计算机之间的通信方式是通过原始的&lt;strong&gt;广播&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2020/07/27/nlFjR4KOStkwgBv.jpg&quot; alt=&quot;没想到吧&quot;/&gt;&lt;p&gt; 什么意思呢？意思就是说，我要发送一条消息，这条消息的头部包含了是谁发的，发给谁的，那么我将这条消息发给&lt;strong&gt;同一个局域网下的所有计算机&lt;/strong&gt;，他们收到了就看下是不是发给自己的，如果是则进行响应，否则就不管。&lt;/p&gt;
&lt;p&gt; 可能有人会质疑，&quot;老哥，照你这么说，那全世界的计算机要通信的话不就得都在一个局域网内，这样的话，不就可以联机打&lt;strong&gt;CS&lt;/strong&gt;了？&quot; 我没说过这句话，周树人也没说过。确实，如果只按照上面的方式，全世界的计算机需要进行通信的话必须要求在同一个局域网内，但这是不可能的，即便可能也是一种灾难。所以需要更好的方法，这时候&lt;strong&gt;网络层&lt;/strong&gt;的&lt;strong&gt;IP协议&lt;/strong&gt;就登场了，IP协议的主要作用有&lt;strong&gt;两个：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;给每台计算机分配IP地址和路由。&lt;/li&gt;
&lt;li&gt;判断两台计算机是否在同一局域网内：计算的方式大致为两个IP地址跟子网掩码做于（&amp;amp;）运算，如果结果相同就在同一子网内，否则则不在。（子网掩码有兴趣可以自己搜一下）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt; 嗯？你说的这个&lt;strong&gt;IP&lt;/strong&gt;，它跟通信所需要的&lt;strong&gt;mac&lt;/strong&gt;有关系吗？计算机之间是通过mac地址识别的，现在只有&lt;strong&gt;IP&lt;/strong&gt;地址是对不上号的，所以我们需要一个&lt;strong&gt;转换器&lt;/strong&gt;，这个转换器叫做&lt;strong&gt;ARP协议(OSI七层中属于链路层)&lt;/strong&gt;，ARP协议的作用就是&lt;strong&gt;将IP地址转化为mac地址&lt;/strong&gt;。有了这个协议，加上之前的那些，全世界的计算机都可以进行通信啦。鼓掌！鼓掌！鼓掌！&lt;/p&gt;
&lt;p&gt; 但是！不好意思，我还是得说但是，这样的话计算机之间貌似只能一对一，我们平时一台计算机肯定不止只运行一个程序，像下面这样都得有几个了。&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2020/07/27/1BlyObekLJYRvxW.png&quot; alt=&quot;image-20200727223838468&quot;/&gt;&lt;p&gt; 肯定还有东西将其拆得更细，从而给程序定位，这时候&lt;strong&gt;传输层&lt;/strong&gt;的端口协议&lt;strong&gt;TCP&lt;/strong&gt;和&lt;strong&gt;UDP&lt;/strong&gt;就上线了，&lt;strong&gt;TCP&lt;/strong&gt;和&lt;strong&gt;UDP&lt;/strong&gt;提供了端口的概念，这样我们&lt;strong&gt;通过ip转mac确定一台计算机，再通过端口确定具体的一个程序&lt;/strong&gt;，从而实现端对端的通信，一台计算机运行多个程序，程序可以跟另一台计算机的程序进行通信，瞬间形成N×N。到了这一层网络协议的基本就结束了，往上还有三层可以理解为辅助和加强作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话层：&lt;/strong&gt;管理TCP连接、流量控制等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示层：&lt;/strong&gt;格式、字符、加密等翻译工作和转化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层：&lt;/strong&gt;展示给用户的东西，例如HTTP协议就是一个页面，FTP用于传输等。&lt;/p&gt;

&lt;p&gt; 本文的叙述方式比较口语化，但如果能简单理解那就足够了。首先一开始讲输入一个网址发生的事情，接而引出下方的网络协议，在网络协议中从底层物理层的电信号到最上层应用层的http协议，大致的讲述模式为：&lt;strong&gt;当前的问题&lt;/strong&gt;—&amp;gt;&lt;strong&gt;为了解决当前的问题需要怎么做&lt;/strong&gt; 的这种模式，相信理解起来并不困难。&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;4.0909090909091&quot;&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kongmin_123/article/details/82555936&quot;&gt;https://blog.csdn.net/kongmin_123/article/details/82555936&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linhaifeng/articles/5937962.html&quot;&gt;https://www.cnblogs.com/linhaifeng/articles/5937962.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果文章有帮到你的话，希望关注没事。（免费的哦！[恳求]）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 27 Jul 2020 16:19:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>我们网上冲浪也冲了这么多年，也该上岸好好看看这些浪的形状了。 1. 从一个网址了解浪来浪去 我们知道计算机之间的通过其实都是通过IP+端口的形式，但是我们平时访问的时候根本就没涉及到这两个东西，还是能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/13388701.html</dc:identifier>
</item>
<item>
<title>看完这篇。再也不怕被问 HandlerThread 的原理 - DMingO</title>
<link>http://www.cnblogs.com/DMingO/p/13388696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DMingO/p/13388696.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;http://picbed-dmingou.oss-cn-shenzhen.aliyuncs.com/img/image-20200728000754030.png&quot; class=&quot;desc_img&quot;/&gt;看完这篇。再也不怕被面试官问到 HandlerThread 的原理啦&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153.5&quot;&gt;
&lt;h3 id=&quot;handlerthread是什么&quot;&gt;HandlerThread是什么&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://picbed-dmingou.oss-cn-shenzhen.aliyuncs.com/img/image-20200728000754030.png&quot; alt=&quot;image-20200728000754030&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官网介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A Thread that has a Looper. The Looper can then be used to create Handlers.
Note that just like with a regular Thread, Thread.start() must still be called.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译：&lt;/p&gt;
&lt;p&gt;HandlerThread，持有一个可用来构建Handlers的&lt;strong&gt;Looper&lt;/strong&gt;，像一个常规的&lt;strong&gt;线程类&lt;/strong&gt;，必须要调用&lt;code&gt;start()&lt;/code&gt;才能正常工作。&lt;/p&gt;
&lt;p&gt;HandlerThread的父类是&lt;code&gt;Thread&lt;/code&gt;，所以HandlerThread的本质还是一个线程，但是它并非像&lt;code&gt;Thread&lt;/code&gt;需要在&lt;code&gt;run&lt;/code&gt;代码块内执行耗时的任务，HandlerThread是通过搭配外部的Handler分发处理消息执行任务的，可以很简单地返回和管理子线程的一个Looper对象。&lt;/p&gt;
&lt;h3 id=&quot;handlerthread常见的使用场景&quot;&gt;HandlerThread常见的使用场景&lt;/h3&gt;
&lt;p&gt;有两个耗时任务A、B，任务B的执行需要A执行结果，即 A，B不可以并行执行，而是要串行按顺序执行任务。&lt;/p&gt;
&lt;p&gt;下面给出模拟这种场景HandlerThread使用的实例代码：（代码可直接复制运行，有点长有点渣，见谅）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getResultA()&lt;/code&gt;，&lt;code&gt;doThingB()&lt;/code&gt;，模拟了A，B两个不可以并行执行的耗时任务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;taskHandler&lt;/code&gt;是&lt;strong&gt;Handler&lt;/strong&gt;子类的实例，通过获取handlerThread开启后创建的Looper，串行发送了消息A，消息B，Looper自然也是先取出消息A，给&lt;code&gt;taskHandler.handleMessage&lt;/code&gt;处理，再取出消息B完成了串行执行耗时任务A、B。&lt;/p&gt;
&lt;p&gt;完成了串行执行耗时任务A、B。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HandlerThreadActivity extends AppCompatActivity {

    private Handler taskHandler;
    private HandlerThread handlerThread;

    private static String resultA;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        handlerThread = new HandlerThread(&quot;HandlerThread-1&quot;);
        //!!关键:HandlerThread需要调用start开启线程，否则持有Looper为null
        handlerThread.start();
        //使用handlerThread线程持有的Looper构建 taskHandler实例
        taskHandler = new TaskHandler(handlerThread.getLooper());
        //发送消息A
        Message msgA = Message.obtain();
        msgA.what = 0;
        msgA.obj = &quot;Task-A&quot;;
        taskHandler.sendMessage(msgA);
        //发送消息B
        Message msgB = Message.obtain();
        msgB.what = 1;
        msgB.obj = &quot;Task-B&quot;;
        taskHandler.sendMessage(msgB);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //手动退出HandlerThread的Looper
        handlerThread.quitSafely();
    }

    @WorkerThread
    private static String  getResultA() {
        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;DMingO&quot;;
    }

    @WorkerThread
    private static void  doThingB() {
        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; :&quot;+resultA + &quot; 's blog&quot;);
    }

    private static class TaskHandler extends Handler{

        public TaskHandler(@NonNull Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);
            switch (msg.what){
                case 0:
                    //执行耗时任务 getResultA()
                    resultA = getResultA();
                    break;
                case 1:
                    if(! &quot;&quot;.equals(resultA)){
                        //拿到任务A的返回结果才能执行任务B
                        doThingB();
                    }
                    break;
                default:
                    break;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;可以看到TaskHandler.handleMessage是运行在HandlerThread这一个线程上，归根结底还是HandlerThread把它线程的Looper给了TaskHandler实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I/System.out: HandlerThread-1 :DMingO 's blog
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HandlerThread起的最大作用就是 很简便地提供了一个可设置命名和优先级的线程的&lt;strong&gt;Looper对象&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;handlerthread源码分析&quot;&gt;HandlerThread源码分析&lt;/h3&gt;
&lt;p&gt;通过最简单的使用入手分析&lt;code&gt;HandlerThread&lt;/code&gt;作为一个线程，提供一个子线程的&lt;code&gt;Looper&lt;/code&gt;的背后原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        handlerThread = new HandlerThread(&quot;HandlerThread-1&quot;);
        handlerThread.start();
                taskHandler = new TaskHandler(handlerThread.getLooper());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下&lt;code&gt;getLooper()&lt;/code&gt;葫芦里什么药：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public Looper getLooper() {
        //isAlive()判断当前线程是否已经开启
        //如果线程未开启（未调用HandlerThread.start)，会返回null
        //所以必须执行了start()后，才能调用 getLooper()，否则会有空指针异常
        if (!isAlive()) {
            return null;
        }
        
        // 如果线程已开启但Looper未被创建，会进入同步代码块，阻塞--&amp;gt;直到Looper被创建
        synchronized (this) {
            while (isAlive() &amp;amp;&amp;amp; mLooper == null) {
                try {
                    //mLooper==null--&amp;gt;线程进入阻塞状态
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        //确保 返回的mLooper不为null
        return mLooper;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过分析，&lt;code&gt;getLooper()&lt;/code&gt; 方法确保可以返回一个HandlerThread线程持有的且非空的&lt;strong&gt;Looper&lt;/strong&gt;对象。前提是HandlerThread线程已经开启。如果线程已开启但Looper未被创建，线程会阻塞，直到Looper被创建了。&lt;/p&gt;
&lt;p&gt;那么在哪个方法，mLooper才被赋值，Looper对象才被创建呢？还记得 &lt;code&gt;getLooper()&lt;/code&gt; 方法在最初如果发现线程未被开启，直接就返回null，这不就说明&lt;code&gt;HandlerThread&lt;/code&gt;线程的开启与否与它的&lt;code&gt;Looper&lt;/code&gt;创建，这两者息息相关嘛。&lt;/p&gt;
&lt;p&gt;那就再看下HandlerThread的&lt;code&gt;run()&lt;/code&gt;方法有什么名堂：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Override
    public void run() {
        mTid = Process.myTid();
        //创建此线程的Looper和MessageQueue
        Looper.prepare();
        synchronized (this) {
            //给 mLooper 赋值
            mLooper = Looper.myLooper();
            //此时mLooper!=null--&amp;gt;取消线程阻塞
            notifyAll();
        }
        //为线程设置mPriority优先级
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        //开始运行 Looper
        Looper.loop();
        mTid = -1;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启HandlerThread线程后，会创建此线程的Looper和MessageQueue，设置线程优先级，开始Looper的循环取消息。&lt;/p&gt;
&lt;p&gt;欸，HandlerThread这名字，它的Handler又去哪儿了呢？emmmm目前被&lt;strong&gt;隐藏&lt;/strong&gt;了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private @Nullable Handler mHandler;
    
    /**
     * 返回与此线程相关联的一个Handler实例
     * @hide 目前此方法是被隐藏的，无法正常直接调用
     */
        @NonNull
    public Handler getThreadHandler() {
        if (mHandler == null) {
            mHandler = new Handler(getLooper());
        }
        return mHandler;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，&lt;code&gt;HandlerThread&lt;/code&gt;的&lt;strong&gt;mHandler&lt;/strong&gt;的实例化是属于懒加载方式，只能在外界调用 getThreadHandler()的时候，才会对&lt;code&gt;mHandler&lt;/code&gt;判空&amp;amp;进行实例化。实例化时传入的Looper对象自然是HandlerThread这一线程创建的&lt;code&gt;Looper&lt;/code&gt;。因此若&lt;code&gt;Looper&lt;/code&gt;还未被初始化，方法也会一直阻塞直到Looper创建完成，也需要线程已开启。&lt;/p&gt;
&lt;p&gt;毫无疑问，&lt;code&gt;mHandler&lt;/code&gt; 也自然也是只能去处理&lt;code&gt;HandlerThread&lt;/code&gt;这一个线程的消息。&lt;/p&gt;
&lt;p&gt;可以看出HandlerThread这个类与Looper的关系是密不可分的，自然也会有退出Looper的办法，看以下两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public boolean quit() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quit();
            return true;
        }
        return false;
    }
    
    public boolean quitSafely() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quitSafely();
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是觉得高度相似，而这两个方法相同的地方是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程未开启时(looper自然也为null)，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果线程已经开启了，则会调用 Looper类的&lt;code&gt;quit()&lt;/code&gt; / &lt;code&gt;quitSafely()&lt;/code&gt;方法，并返回 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同的是，根据官方描述，建议使用&lt;code&gt;quitSafely()&lt;/code&gt;，这会允许消息队列中还在排队的消息都被取出后再关闭，避免所有挂起的任务无法有序的被完成。&lt;/p&gt;
&lt;h3 id=&quot;handlerthread分析总结&quot;&gt;HandlerThread分析总结&lt;/h3&gt;
&lt;p&gt;HandlerThread 本质是一个Thread，却和普通的 Thread很不同的是：普通的 Thread 主要被用在 run 方法中执行耗时任务，而 HandlerThread 在线程开启后(run方法中)创建了该线程的Looper和消息队列，外界Handler可以很方便获取到这个Looper，搭配执行耗时任务，适合串行执行耗时任务等场景。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 27 Jul 2020 16:15:00 +0000</pubDate>
<dc:creator>DMingO</dc:creator>
<og:description>HandlerThread是什么 官网介绍 A Thread that has a Looper. The Looper can then be used to create Handlers. No</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/DMingO/p/13388696.html</dc:identifier>
</item>
<item>
<title>.NET Core学习笔记(7)——Exception最佳实践 - 楼上那个蜀黍</title>
<link>http://www.cnblogs.com/manupstairs/p/13388577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manupstairs/p/13388577.html</guid>
<description>&lt;h3&gt;1.为什么不要给每个方法都写try catch&lt;/h3&gt;
&lt;p&gt;为每个方法都编写try catch是错误的做法，理由如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.重复嵌套的try catch是无用的，多余的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一点非常容易理解，下面的示例代码中，OutsideMethodA中的try catch是不起作用的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NestedTryCatch
            {
                &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OutsideMethodA()
                {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.InsideMethodB();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                    }
                }
        
                &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InsideMethodB()
                {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ExceptionMethod();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                    }
                }
        
                &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ExceptionMethod() 
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NotImplementedException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You did't implement this method!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;b.多余的try catch会掩盖严重的bug，将bug珍藏在log里并不会增值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的代码中，一旦参数uri为null，意味着程序逻辑必然有bug，存在错误的调用。与其将这个bug和HttpRequestException混在一起写log，然后相忘于江湖。不如大大方方在开发阶段就每次crash，强迫必须修复隐藏的逻辑错误。&lt;/p&gt;
&lt;p&gt;同时我们可以看到，catch里再次返回了null，这又是一种不负责任给上层代码挖坑的行为。上层代码两眼一黑，就得一个null，啥也不知道，估计也不敢问。&lt;br/&gt;注释的部分给出了两种解决方案，Assert或者主动throw。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; DownloadContent(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; uri)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Debug.Assert(!string.IsNullOrEmpty(uri));
        
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (string.IsNullOrEmpty(uri))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    throw new ArgumentNullException(&quot;uri is null&quot;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
        
                    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
                        {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.GetStringAsync(uri);
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;c.当程序因Exception进入不可继续的状态时，通过try catch避免程序crash，除了可以稍微体面地退出，并没有更大意义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如网络游戏在运行过程中，发生了错误。本地数据与服务器不再同步，是不会允许继续运行，也不会承认期间产生的本地数据。&lt;br/&gt;硬用代码举例的话，就比如在构造函数里搞个try catch吞掉Exception，这个new出来的实例谁还敢用的，请站出来……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d.都知道空的try catch是错误的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
    ……
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;{ }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 难道加个日志就会产生质变了嘛？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
    ……
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
    Log.Error(“xxxx方法失败了！”);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  2.何时使用try catch？只提出问题不给出解决方案，会被骂耍流氓。下面我们来分析几个适于添加try catch的场景。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a.仅在你真的打算，并且知道如何处理当前的Exception时，加try catch。比较明显的场景是网络请求中的retry。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; HandleHttpRequestExceptionAsync()
        {
            HttpClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.ajshdgasjhdgajdhgasjhdgasjdhgasjdhgas.tk/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (HttpRequestException ex)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Simulate to try again.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;log here then retry&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.dell.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                client&lt;/span&gt;?&lt;span&gt;.Dispose();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;b.当常规流程控制无法避免异常时，加try catch。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常可以用if来避免的问题，就不应通过try catch处理。反例如IO处理，无法确认用户会不会拔U盘，该情况下需catch IOException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.功能性的类库中的API缺乏业务逻辑，不知道如何处理Exception时，不应加try catch。应将错误抛给上层，由存在业务逻辑的调用方处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较典型的，在使用Microsoft UI Automation的API时，找元素的API可能会抛出COMException。API本身认为调用方传参错误，传入了不存在元素的ID。但上层的调用代码会知道，是因为当前页面未加载完全。如果我们希望在这里retry或者忽略这个错误，try catch是合理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d.为了体面的退出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在顶层加入try catch记录log是可行的。调用堆栈的信息会完整的保存下来。（针对Task的异常堆栈丢失问题，请看&lt;a href=&quot;https://www.cnblogs.com/manupstairs/p/12196909.html&quot; target=&quot;_blank&quot;&gt;《.NET Core学习笔记（3）——async/await中的Exception处理》&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/362529/202007/362529-20200727232317604-633752754.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;301&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.在顶层代码应用try catch的一些可行做法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a.如果我们真的害怕且不能接受crash。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以试着在Main方法里加个try catch，然后记录log。&lt;br/&gt;&lt;strong&gt;b.不是主线程的UnHandle Exception。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过AppDomain.UnhandledException来处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            AppDomain currentDomain &lt;/span&gt;=&lt;span&gt; AppDomain.CurrentDomain;
            currentDomain.UnhandledException &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnhandledExceptionEventHandler(MyHandler);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catch clause caught : {0} \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e.Message);
            }

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyHandler(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, UnhandledExceptionEventArgs args)
        {
            Exception e &lt;/span&gt;=&lt;span&gt; (Exception)args.ExceptionObject;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyHandler caught : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Message);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Runtime terminating: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, args.IsTerminating);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下.NET 程序将会退出，因为此时的程序因为这个unhandle exception，被认为进入了未知，且不可继续的状态。&lt;br/&gt;此时即使通过某些特殊手段保持程序不退出，也没有任何意义。unhandle exception的意思就是有crash bug没处理。开发阶段干嘛去了。&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/threading/exceptions-in-managed-threads#application-compatibility-flag&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/standard/threading/exceptions-in-managed-threads#application-compatibility-flag&lt;/a&gt;&lt;br/&gt;上述链接提供了程序不退出的可能选项，但我认为实不可取。&lt;/p&gt;
&lt;h3&gt;4.判断Exception类型的一些技巧，&lt;/h3&gt;
&lt;p&gt;仍然以HttpClient.GetStringAsync举例，我们可以通过查看MSDN得知该方法可能抛出如下几个Exceptions：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/362529/202007/362529-20200727233840353-622290523.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;231&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.AugumentNullException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们上文提过了，上层调用代码可以通过null check来避免，或者主动抛出exception。&lt;br/&gt;&lt;strong&gt;b.HttpRequestException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络错误都会抛这个异常，通常我们需要捕获该异常，并通过异常中返回的Status或是其他信息来针对性处理。&lt;br/&gt;&lt;strong&gt;c.TaskCanceledException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以下两种情况会被抛出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;指定了HttpClient.Timeout同时本次网络请求超出指定时间&lt;/li&gt;
&lt;li&gt;在使用Task异步编程时，在Task Completed之前调用CancellationTokenSource对象的Cancel()方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么在写代码的时候，就要判断是否是.NET Core，同时符合以上两点。否则就无需对该异常添加处理。&lt;br/&gt;举该例子更重要的目的是想说，除了顶层代码的最后一道用于记录log的try catch。没有任何理由用到基类Exception。&lt;/p&gt;
&lt;p&gt;文中提到的示例代码可以在这里找到：&lt;br/&gt;&lt;a href=&quot;https://github.com/manupstairs/PracticeOfException&quot; target=&quot;_blank&quot;&gt;https://github.com/manupstairs/PracticeOfException&lt;/a&gt;&lt;br/&gt;本篇提到了处理Exception时的一些实践经验，且为一家之言，如有错误的地方还请指出。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 15:55:00 +0000</pubDate>
<dc:creator>楼上那个蜀黍</dc:creator>
<og:description>1.为什么不要给每个方法都写try catch 为每个方法都编写try catch是错误的做法，理由如下： a.重复嵌套的try catch是无用的，多余的。 这一点非常容易理解，下面的示例代码中，O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/manupstairs/p/13388577.html</dc:identifier>
</item>
<item>
<title>Java线程池ThreadPoolExecutor面试总结思维导图速记 - NeverTh</title>
<link>http://www.cnblogs.com/neverth/p/13388627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neverth/p/13388627.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/neverth/1592425/t_200727154751Java%E5%B9%B6%E5%8F%91-min.png&quot; class=&quot;desc_img&quot;/&gt;Java线程池ThreadPoolExecutor面试总结思维导图速记，优点降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度，当任务到达时，可以不需要等待线程创建就能立即执行。提高线程的可管理性类关系接 Executor 一个无返回值的execute方法接 ExecutorService 返回值为Future类型的submit方法类 AbstractExecutorService类 ThreadPoolExecutor&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;85&quot;&gt;
&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度，当任务到达时，可以不需要等待线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;类关系&quot;&gt;类关系&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;接 Executor 一个无返回值的execute方法&lt;br/&gt;接 ExecutorService 返回值为Future类型的submit方法&lt;br/&gt;类 AbstractExecutorService&lt;br/&gt;类 ThreadPoolExecutor&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;threadpoolexecutor类&quot;&gt;ThreadPoolExecutor类&lt;/h3&gt;
&lt;p&gt;包含参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;corePoolSize： 核心线程数最大值
maximumPoolSize： 最大线程数大小
keepAliveTime： 非核心线程空闲的存活时间大小
unit： 线程空闲存活时间单位
workQueue： 存放任务的阻塞队列
threadFactory： 用于设置创建线程的工厂
handler：  线城池的饱和策略事件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数workQueue有如下几种队列&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ArrayBlockingQueue; 必须带参构造，数组，默认非公平可指定，FIFO&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue; 可带参构造，大小默认int最大，FIFO&lt;/li&gt;
&lt;li&gt;SynchronousQueue;不存储元素，每个插入操作必须等到另一个线程调用移除操作，否则堵塞&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue;优先级，数组&lt;/li&gt;
&lt;li&gt;DelayQueue; 基于PriorityQueue，延时阻塞队列，只有当其指定的延迟时间到了，才能够从队列中获取到该元素。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参数hander有如下几种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AbortPolicy 丢弃任务并抛异常，默认&lt;/li&gt;
&lt;li&gt;DiscardPolicy 直接丢弃任务&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy 由调用线程处理该任务&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;executors类&quot;&gt;Executors类&lt;/h3&gt;
&lt;p&gt;阿里巴巴开发规范不允许使用Executors去创建，因为队列OOM。&lt;br/&gt;主要有如下几种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;newCachedThreadPool()：一个任务创建一个线程，使用SynchronousQueue，用于并发执行大量短期的小任务。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool(nThreads)：所有任务使用固定大小的线程池，使用LinkedBlockingQueue，适用执行长期的任务&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor()：只有一个线程的线程池，使用LinkedBlockingQueue，适用于串行执行任务的场景，&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;执行流程&quot;&gt;执行流程&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;在 execute() 中实现，当提交一个线程时&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果正在运行的线程数 &amp;lt; coreSize，马上创建线程执行该task，不排队等待；&lt;/li&gt;
&lt;li&gt;如果正在运行的线程数 &amp;gt;= coreSize，把该task放入队列；&lt;/li&gt;
&lt;li&gt;如果队列已满 &amp;amp;&amp;amp; 正在运行的线程数 &amp;lt; maximumPoolSize，创建新的线程执行该task；&lt;br/&gt;4 . 如果队列已满 &amp;amp;&amp;amp; 正在运行的线程数 &amp;gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;异常捕获&quot;&gt;异常捕获&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;默认不捕获异常，捕获方法如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;try-catch&lt;/li&gt;
&lt;li&gt;submit执行，Future.get接受异常&lt;/li&gt;
&lt;li&gt;重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用&lt;/li&gt;
&lt;li&gt;为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程池状态&quot;&gt;线程池状态&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;running&lt;/strong&gt;&lt;br/&gt;该状态的线程池会接收新任务，并处理阻塞队列中的任务;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;shutdown() -&amp;gt; shutdown&lt;/li&gt;
&lt;li&gt;shutdownNow() -&amp;gt; stop&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;shutdown&lt;/strong&gt;&lt;br/&gt;该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;队列为空，并且线程池中执行的任务也为空,进入tidying状态;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;stop&lt;/strong&gt;&lt;br/&gt;该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程池中执行的任务为空,进入tidying状态;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;tidying&lt;/strong&gt;&lt;br/&gt;该状态表明所有的任务已经运行终止，记录的任务数量为0。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;terminated() -&amp;gt; terminated&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;terminated&lt;/strong&gt;&lt;br/&gt;该状态表示线程池彻底终止&lt;/p&gt;
&lt;h2 id=&quot;线程大小设置&quot;&gt;线程大小设置&lt;/h2&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 N(cpu) + 1&lt;/li&gt;
&lt;li&gt;如果是IO密集型任务，参考值可以设置为2 * N(cpu)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;思维导图右键另存为下载&quot;&gt;思维导图(右键另存为下载)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/neverth/1592425/o_200727154751Java%E5%B9%B6%E5%8F%91-min.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;喜欢可以点个赞，感谢！&quot;&gt;喜欢可以点个赞，感谢！&lt;/h2&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 27 Jul 2020 15:52:00 +0000</pubDate>
<dc:creator>NeverTh</dc:creator>
<og:description>优点 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度，当任务到达时，可以不需要等待线程创建就能立即执行。 提高线程的可管理性 类关系 接 Executor 一个无返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/neverth/p/13388627.html</dc:identifier>
</item>
<item>
<title>【高并发】高并发环境下构建缓存服务需要注意哪些问题？我和阿里P9聊了很久！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13388418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13388418.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;周末，跟阿里的一个朋友（去年晋升为P9了）聊了很久，聊的内容几乎全是技术，当然了，两个技术男聊得最多的话题当然就是技术了。从基础到架构，从算法到AI，无所不谈。中间又穿插着不少天马行空的想象，虽然现在看起来不太实际，但是随着技术的进步，相信五年、十年之后都会实现的。&lt;/p&gt;
&lt;p&gt;不知道是谁提起了在高并发环境下如何构建缓存服务，结果一路停不下来了！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;缓存特征&quot;&gt;缓存特征&lt;/h2&gt;
&lt;p&gt;（1）命中率：命中数/(命中数+没有命中数)&lt;/p&gt;
&lt;p&gt;（2）最大元素（空间）：代表缓存中可以存放的最大元素的数量，一旦缓存中元素的数量超过这个值，或者缓存数据所占的空间超过了最大支持的空间，将会触发缓存清空策略。根据不同的场景，合理设置最大元素（空间）的值，在一定程度上可以提高缓存的命中率，从而更有效的使用缓存。&lt;/p&gt;
&lt;p&gt;（3）清空策略：FINO（先进先出）、LFU（最少使用）、LRU（最近最少使用）、过期时间、随机等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FINO（先进先出）：最先进入缓存的数据，在缓存空间不够或超出最大元素限制的情况下，会优先被清除掉，以腾出新的空间来接收新的数据。这种策略的算法主要是比较缓存元素的创建时间，在数据实时性较高的场景下，可以选择这种策略，优先保证最新策略可用。&lt;/li&gt;
&lt;li&gt;LFU（最少使用）：无论元素是否过期，根据元素的被使用次数来判断，清除使用次数最少的元素来释放空间。算法主要是比较元素的命中次数，在保证高频数据有效的场景下，可以选择这种策略。&lt;/li&gt;
&lt;li&gt;LRU（最近最少使用）：无论元素是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素，释放空间。算法主要是比较元素最近一次被获取的时间，在热点数据场景下，可以选择这种策略。&lt;br/&gt;过期时间：根据过期时间判断，清理过期时间最长的元素，或者清理最近要过期的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缓存命中率影响因素&quot;&gt;缓存命中率影响因素&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）业务场景和业务需求&lt;/strong&gt;&lt;br/&gt;缓存往往适合读多写少的场景。业务需求对实时性的要求，直接会影响到缓存的过期时间和更新策略。实时性要求越低，就越适合缓存。在相同Key和相同请求数的情况下，缓存的时间越长，命中率就会越高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）缓存的设计（粒度和策略）&lt;/strong&gt;&lt;br/&gt;通常情况下，缓存的粒度越小，命中率越高。缓存的更新和命中策略也会影响缓存的命中率，当数据发生变化时，直接更新缓存的值会比移除缓存或使缓存过期的命中率更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）缓存容量和基础设施&lt;/strong&gt;&lt;br/&gt;缓存的容量有限，则容易引起缓存失效和被淘汰（目前多数的缓存框架或中间件都采用了LRU算法）。同时，缓存的技术选型也是至关重要的，比如采用应用内置的本地缓存就比较容易出现单机瓶颈，而采用分布式缓存则毕竟容易扩展。所以需要做好系统容量规划，并考虑是否可扩展。此外，不同的缓存框架或中间件，其效率和稳定性也是存在差异的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）其他因素&lt;/strong&gt;&lt;br/&gt;当缓存节点发生故障时，需要避免缓存失效并最大程度降低影响，这种特殊情况也是架构师需要考虑的。业内比较典型的做法就是通过一致性Hash算法，或者通过节点冗余的方式。&lt;/p&gt;
&lt;p&gt;有些朋友可能会有这样的理解误区：既然业务需求对数据时效性要求很高，而缓存时间又会影响到缓存命中率，那么系统就别使用缓存了。其实这忽略了一个重要因素--并发。通常来讲，在相同缓存时间和key的情况下，并发越高，缓存的收益会越高，即便缓存时间很短。&lt;/p&gt;
&lt;h2 id=&quot;提高缓存命中率的方法&quot;&gt;提高缓存命中率的方法&lt;/h2&gt;
&lt;p&gt;从架构师的角度，需要应用尽可能的通过缓存直接获取数据，并避免缓存失效。这也是比较考验架构师能力的，需要在业务需求，缓存粒度，缓存策略，技术选型等各个方面去通盘考虑并做权衡。尽可能的聚焦在高频访问且时效性要求不高的热点业务上，通过缓存预加载（预热）、增加存储容量、调整缓存粒度、更新缓存等手段来提高命中率。&lt;/p&gt;
&lt;p&gt;对于时效性很高（或缓存空间有限），内容跨度很大（或访问很随机），并且访问量不高的应用来说缓存命中率可能长期很低，可能预热后的缓存还没来得被访问就已经过期了。&lt;/p&gt;
&lt;h2 id=&quot;缓存的分类和应用场景&quot;&gt;缓存的分类和应用场景&lt;/h2&gt;
&lt;p&gt;（1）本地缓存：编程实现（成员变量、局部变量、静态变量）、Guava Cache&lt;br/&gt;（2）分布式缓存：Memcached、Redis&lt;/p&gt;
&lt;h2 id=&quot;高并发场景下缓存常见问题&quot;&gt;高并发场景下缓存常见问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）缓存的一致性&lt;/strong&gt;&lt;br/&gt;更新数据库成功——更新缓存失败&lt;br/&gt;更新缓存成功——更新数据库失败&lt;br/&gt;更新数据库成功——淘汰缓存失败&lt;br/&gt;淘汰缓存成功——更新数据库失败&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）缓存并发&lt;/strong&gt;&lt;br/&gt;并发时请求缓存时已过期或者没有命中或者更新的情况下有大量的请求访问数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：在缓存更新或者过期的情况下,先尝试获取到lock,当更新完成后,尝试释放锁,其他的请求只需要牺牲一定的等待时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）缓存穿透&lt;/strong&gt;&lt;br/&gt;在高并发的场景下,如果某一个key被高并发的访问没有被命中,出于对容错性的考虑会尝试从后端的数据库获取，从而导致大量的请求访问了数据库,主要是当key对应的数据为空或者为null的情况下，这就导致数据库中并发的执行了很多不必要的查询操作。从而导致了巨大的冲击和压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法:&lt;/strong&gt;&lt;br/&gt;缓存空对象：对查询结果为空的对象也进行缓存，如果是集合可以缓存一个空的集合，而不是null,如果是单个对象可以通过字段标识来区分,需要保证缓存数据的时效性(实现相对简单)，适合命中不高但可能会频繁更新的数据。&lt;br/&gt;单独过滤处理：对所有可能对应数据为空的key进行统一的存放,并在请求前做拦截(实现相对复杂)，适合命中不高更新不频繁的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）缓存颠簸问题&lt;/strong&gt;&lt;br/&gt;缓存的颠簸问题，有些地方可能被称为“缓存抖动”，可以看作是一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响。一般是由于缓存节点故障导致。业内推荐的做法是通过一致性Hash算法来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）缓存雪崩现象&lt;/strong&gt;&lt;br/&gt;缓存雪崩就是指由于缓存的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。导致这种现象的原因有很多种，上面提到的“缓存并发”，“缓存穿透”，“缓存颠簸”等问题，其实都可能会导致缓存雪崩现象发生。这些问题也可能会被恶意攻击者所利用。还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。&lt;/p&gt;
&lt;p&gt;从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难。&lt;/p&gt;
&lt;p&gt;此外，从整个研发体系流程的角度，应该加强压力测试，尽量模拟真实场景，尽早的暴露问题从而防范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）缓存无底洞现象&lt;/strong&gt;&lt;br/&gt;该问题由 facebook 的工作人员提出的， facebook 在 2010 年左右，memcached 节点就已经达3000 个，缓存数千 G 内容。他们发现了一个问题---memcached 连接频率，效率下降了，于是加 memcached 节点，添加了后，发现因为连接频率导致的问题，仍然存在，并没有好转，称之为”无底洞现象”&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “设计模式” 关键字领取《深入浅出Java 23种设计模式》PDF文档。回复“Java8”关键字领取《Java8新特性教程》PDF文档。两本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 15:31:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 周末，跟阿里的一个朋友（去年晋升为P9了）聊了很久，聊的内容几乎全是技术，当然了，两个技术男聊得最多的话题当然就是技术了。从基础到架构，从算法到AI，无所不谈。中间又穿插着不少天马行空的想象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13388418.html</dc:identifier>
</item>
<item>
<title>REST是什么？RESTFul又是什么？这二者的关系是怎样的？ - 嗨，阿良</title>
<link>http://www.cnblogs.com/fengting0913/p/13388359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengting0913/p/13388359.html</guid>
<description>&lt;p&gt;REST是什么？RESTFul又是什么？这二者的关系是怎样的？ RESTFul 和 RPC 的区别是什么？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;214.02193561844&quot;&gt;
&lt;h3 id=&quot;rest（一种软件架构风格）&quot;&gt;REST（一种软件架构风格）&lt;/h3&gt;
&lt;h4 id=&quot;全称：representational-state-transfer&quot;&gt;全称：Representational State Transfer&lt;/h4&gt;
&lt;h4 id=&quot;含义：（表述性-状态-转移）&quot;&gt;含义：（表述性 状态 转移）&lt;/h4&gt;
&lt;blockquote readability=&quot;10.731707317073&quot;&gt;
&lt;p&gt;是一种针对&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/2196523&quot;&gt;网络应用&lt;/a&gt;的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。&lt;/p&gt;
&lt;p&gt;在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单、轻量的方法设计和实现。&lt;strong&gt;值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;原则条件&quot;&gt;原则条件&lt;/h4&gt;
&lt;p&gt;REST 指的是一组架构&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6&quot;&gt;约束条件&lt;/a&gt;和原则，如果你在设计应用程序时能坚持REST原则，那就预示着你将会得到一个使用了优质Web架构的系统。Web 应用程序最重要的 REST 原则是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端和服务器之间的交互在请求之间是&lt;strong&gt;无状态的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;从客户端到服务器的&lt;strong&gt;每个请求都必须包含理解请求所必需的信息&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果服务器在请求之间的&lt;strong&gt;任何时间点重启，客户端不会得到通知&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;无状态请求&lt;strong&gt;可以由任何可用服务器回答&lt;/strong&gt;，这十分适合&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97&quot;&gt;云计算&lt;/a&gt;之类的环境。&lt;/li&gt;
&lt;li&gt;客户端&lt;strong&gt;可以缓存数据&lt;/strong&gt;以改进性能。&lt;/li&gt;
&lt;li&gt;在服务器端，&lt;strong&gt;应用程序状态和功能可以分为各种资源&lt;/strong&gt;。资源是一个概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。&lt;/li&gt;
&lt;li&gt;使用的是&lt;strong&gt;标准的 HTTP 方法，比如 GET、PUT、&lt;a href=&quot;https://baike.baidu.com/item/POST&quot;&gt;POST&lt;/a&gt; 和 &lt;a href=&quot;https://baike.baidu.com/item/DELETE&quot;&gt;DELETE&lt;/a&gt;。&lt;a href=&quot;https://baike.baidu.com/item/Hypermedia&quot;&gt;Hypermedia&lt;/a&gt; 是应用程序状态的&lt;a href=&quot;https://baike.baidu.com/item/%E5%BC%95%E6%93%8E/2874935&quot;&gt;引擎&lt;/a&gt;，资源表示通过&lt;a href=&quot;https://baike.baidu.com/item/%E8%B6%85%E9%93%BE%E6%8E%A5&quot;&gt;超链接&lt;/a&gt;互联&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注意：&quot;&gt;注意：&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;REST除了给我们带来了一个崭新的架构以外，还有一个重要的贡献是在开发系统过程中的一种新的思维方式：通过url来设计系统的结构。根据REST，每个url都代表一个resource，而整个系统就是由这些resource组成的。因此，如果url是设计良好的，那么系统的结构就也应该是设计良好的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;restful：rest式的&quot;&gt;RESTful：(REST式的)&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;基于REST这种软件架构风格设计的 API接口 即称为：RESTful API&lt;/p&gt;
&lt;p&gt;即&lt;strong&gt;设计的这些接口满足 RESTful 接口设计规范&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;接口设计规范的具体内容为：&quot;&gt;接口设计规范的具体内容为：&lt;/h4&gt;
&lt;h5 id=&quot;1-域名&quot;&gt;1. 域名&lt;/h5&gt;
&lt;p&gt;应该尽量将API部署在专用域名之下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;https://api.example.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;https://example.org/api/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;2-版本（versioning）&quot;&gt;2. 版本（Versioning）&lt;/h5&gt;
&lt;p&gt;应该将API的版本号放入URL。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;http://www.example.com/app/1.0/foo

http://www.example.com/app/1.1/foo

http://www.example.com/app/2.0/foo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。&lt;a href=&quot;https://developer.github.com/v3/media/#request-specific-version&quot;&gt;Github&lt;/a&gt;就采用了这种做法。&lt;/p&gt;
&lt;p&gt;因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见&lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1566460&quot;&gt;Versioning REST Services&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept: vnd.example-com.foo+json; version=1.0

Accept: vnd.example-com.foo+json; version=1.1

Accept: vnd.example-com.foo+json; version=2.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;3-路径（endpoint）&quot;&gt;3. 路径（Endpoint）&lt;/h5&gt;
&lt;p&gt;路径又称&quot;终点&quot;（endpoint），表示API的具体网址，每个网址代表一种资源（resource）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 资源作为网址，只能有名词，不能有动词，而且所用的名词往往与数据库的表名对应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说，以下是不好的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;/getProducts
/listOrders
/retreiveClientByOrder?orderId=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于一个简洁结构，你应该始终用名词。 此外，利用的HTTP方法可以分离网址中的资源名称的操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /products ：将返回所有产品清单
POST /products ：将产品新建到集合
GET /products/4 ：将获取产品 4
PATCH（或）PUT /products/4 ：将更新产品 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2) API中的名词应该使用复数。无论子资源或者所有资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说，获取产品的API可以这样定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;获取单个产品：http://127.0.0.1:8080/AppName/rest/products/1
获取所有产品: http://127.0.0.1:8080/AppName/rest/products
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;4-http动词&quot;&gt;4. HTTP动词&lt;/h5&gt;
&lt;p&gt;对于资源的具体操作类型，由HTTP动词表示。&lt;/p&gt;
&lt;p&gt;常用的HTTP动词有下面四个（括号里是对应的SQL命令）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET（SELECT）：从服务器取出资源（一项或多项）。&lt;/li&gt;
&lt;li&gt;POST（CREATE）：在服务器新建一个资源。&lt;/li&gt;
&lt;li&gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/li&gt;
&lt;li&gt;DELETE（DELETE）：从服务器删除资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有三个不常用的HTTP动词。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PATCH（UPDATE）：在服务器更新(更新)资源（客户端提供改变的属性）。&lt;/li&gt;
&lt;li&gt;HEAD：获取资源的元数据。&lt;/li&gt;
&lt;li&gt;OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一些例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /zoos：列出所有动物园
POST /zoos：新建一个动物园（上传文件）
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;5-过滤信息（filtering）&quot;&gt;5. 过滤信息（Filtering）&lt;/h5&gt;
&lt;p&gt;如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。&lt;/p&gt;
&lt;p&gt;下面是一些常见的参数。query_string 查询字符串,地址栏后面问号后面的数据,格式: name=xx&amp;amp;sss=xxx&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&amp;amp;per_page=100：指定第几页，以及每页的记录数。
?sortby=name&amp;amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoos/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。&lt;/p&gt;
&lt;h5 id=&quot;6-状态码（status-codes）&quot;&gt;6. 状态码（Status Codes）&lt;/h5&gt;
&lt;p&gt;服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;200 OK - [GET]：服务器成功返回用户请求的数据&lt;/li&gt;
&lt;li&gt;201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。&lt;/li&gt;
&lt;li&gt;202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）&lt;/li&gt;
&lt;li&gt;204 NO CONTENT - [DELETE]：用户删除数据成功。&lt;/li&gt;
&lt;li&gt;400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作&lt;/li&gt;
&lt;li&gt;401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。&lt;/li&gt;
&lt;li&gt;403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。&lt;/li&gt;
&lt;li&gt;404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。&lt;/li&gt;
&lt;li&gt;406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。&lt;/li&gt;
&lt;li&gt;410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。&lt;/li&gt;
&lt;li&gt;422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。&lt;/li&gt;
&lt;li&gt;500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;状态码的完全列表参见&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;这里&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h5 id=&quot;7-错误处理（error-handling）&quot;&gt;7. 错误处理（Error handling）&lt;/h5&gt;
&lt;p&gt;如果状态码是4xx，服务器就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    error: &quot;Invalid API key&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;8-返回结果&quot;&gt;8. 返回结果&lt;/h5&gt;
&lt;p&gt;针对不同操作，服务器向用户返回的结果应该符合以下规范。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET /collection：返回资源对象的列表（数组）&lt;/li&gt;
&lt;li&gt;GET /collection/ID：返回单个资源对象(json)&lt;/li&gt;
&lt;li&gt;POST /collection：返回新生成的资源对象(json)&lt;/li&gt;
&lt;li&gt;PUT /collection/ID：返回完整的资源对象(json)&lt;/li&gt;
&lt;li&gt;DELETE /collection/ID：返回一个空文档(空字符串)&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;9-超媒体（hypermedia-api）&quot;&gt;9. 超媒体（Hypermedia API）&lt;/h5&gt;
&lt;p&gt;RESTful API最好做到Hypermedia（即返回结果中提供链接，连向其他API方法），使得用户不查文档，也知道下一步应该做什么。&lt;/p&gt;
&lt;p&gt;比如，Github的API就是这种设计，访问&lt;a href=&quot;https://api.github.com/&quot;&gt;api.github.com&lt;/a&gt;会得到一个所有可用API的网址列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,
&quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,
// ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看到，如果想获取当前用户的信息，应该去访问&lt;a href=&quot;https://api.github.com/user&quot;&gt;api.github.com/user&lt;/a&gt;，然后就得到了下面结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;message&quot;: &quot;Requires authentication&quot;,
  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码表示，服务器给出了提示信息，以及文档的网址。&lt;/p&gt;
&lt;h5 id=&quot;10-其他&quot;&gt;10. 其他&lt;/h5&gt;
&lt;p&gt;服务器返回的数据格式，应该尽量使用JSON，避免使用XML。&lt;/p&gt;
&lt;h4 id=&quot;restful架构&quot;&gt;RESTful架构&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.7781690140845&quot;&gt;
&lt;p&gt;RESTful架构将&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571&quot;&gt;服务器&lt;/a&gt;分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;项目开发引入RESTful架构，利于团队并行开发。在RESTful架构中，将多数HTTP请求转移到前端服务器上，降低服务器的负荷，使视图获取后端模型失败也能呈现。但RESTful架构却不适用于所有的项目，当项目比较小时无需使用RESTful架构，项目变得更加复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;restful与-rpc&quot;&gt;RESTful与 RPC&lt;/h4&gt;
&lt;blockquote readability=&quot;7.9584055459272&quot;&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://baike.baidu.com/item/RPC/609861&quot;&gt;RPC&lt;/a&gt; 样式架构构建的基于 SOAP 的 Web 服务成为实现 SOA 最常用的方法。RPC 样式的 Web 服务客户端将一个装满数据的信封（包括方法和参数信息）通过 HTTP 发送到服务器。服务器打开信封并使用传入参数执行指定的方法。方法的结果打包到一个信封并作为响应发回客户端。客户端收到响应并打开信封。每个对象都有自己独特的方法以及仅公开一个 URI 的 RPC 样式 Web 服务，URI 表示单个端点。它忽略 HTTP 的大部分特性且仅支持 POST 方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEAD 和 OPTIONS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.7509881422925&quot;&gt;
&lt;p&gt;在 RPC 样式的架构中，关注点在于方法，而在 REST 样式的架构中，关注点在于资源 —— 将使用标准方法检索并操作信息片段（使用表示的形式）。资源表示形式在表示形式中使用&lt;a href=&quot;https://baike.baidu.com/item/%E8%B6%85%E9%93%BE%E6%8E%A5&quot;&gt;超链接&lt;/a&gt;互联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Leonard Richardson 和 Sam Ruby 在他们的著作 RESTful Web Services 中引入了术语 REST-RPC 混合架构。REST-RPC 混合 Web 服务不使用信封包装方法、参数和数据，而是直接通过 HTTP 传输数据，这与 REST 样式的 Web 服务是类似的。但是它不使用标准的 HTTP 方法操作资源。它在 HTTP 请求的 URI 部分存储方法信息。好几个知名的 Web 服务，比如 Yahoo 的 Flickr API 和 Delicious API 都使用这种混合架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;rpc&quot;&gt;RPC&lt;/h3&gt;
&lt;h4 id=&quot;rpc是远程过程调用（remote-procedure-call）的缩写形式。&quot;&gt;RPC是远程过程调用（Remote Procedure Call）的缩写形式。&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;原理图示：&quot;&gt;原理图示：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2001508/202007/2001508-20200727232136001-269686228.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;应用场景：&quot;&gt;应用场景：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;RPC在分布式系统中的系统环境建设和应用程序设计中有着广泛的应用，应用包括如下方面:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、分布式操作系统的进程间通讯&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;进程间通讯是操作系统必须提供的基本设施之一,分布式操作系统必须提供分布于异构的结点机上进程间的通讯机制，RPC是实现消息传送模式的分布式进程间通讯的手段之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、构造分布式计算的软件环境&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;由于分布式软件环境本身地理上的分布性, 它的各个组成成份之间存在大量的交互和通讯,R P C 是其基本的实现方法之一。ONC+和DCE两个流行的分式布计算软件环境都是使用RPC构造的，其它一些分布式软件环境也采用了RPC方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、远程数据库服务&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在分布式数据库系统中，数据库一般驻存在服务器上，客户机通过远程数据库服务功能访问数据库服务器，现有的远程数据库服务是使用RPC模式的。例如，Sybase和Oracle都提供了存储过程机制，系统与用户定义的存储过程存储在数据库服务器上，用户在客户端使用RPC模式调用存储过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4、分布式应用程序设计&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;RPC机制与RPC工具为分布式应用程序设计提供了手段和方便, 用户可以无需知道网络结构和协议细节而直接使用RPC工具设计分布式应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5、分布式程序的调试&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RPC可用于分布式程序的调试。使用反向RPC使服务器成为客户并向它的客户进程发出RPC，可以调试分布式程序。例如，在服务器上运行一个远端调试程序，它不断接收客户端的RPC，当遇到一个调试程序断点时，它向客户机发回一个RPC，通知断点已经到达，这也是RPC用于进程通讯的例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ipc：进程间通信&quot;&gt;IPC：进程间通信&lt;/h3&gt;
&lt;blockquote readability=&quot;4.7368421052632&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1&quot;&gt;进程间通信&lt;/a&gt;（IPC）是在&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&quot;&gt;多任务操作系统&lt;/a&gt;或联网的计算机之间运行的程序和进程所用的通信技术。有两种类型的进程间通信（IPC）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;lpc：本地过程调用&quot;&gt;LPC：本地过程调用&lt;/h3&gt;
&lt;blockquote readability=&quot;4.9411764705882&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8&quot;&gt;本地过程调用&lt;/a&gt;(LPC)用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务&lt;a href=&quot;https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98&quot;&gt;共享内存&lt;/a&gt;空间使任务同步和互相发送信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 27 Jul 2020 15:17:00 +0000</pubDate>
<dc:creator>嗨，阿良</dc:creator>
<og:description>REST是什么？RESTFul又是什么？这二者的关系是怎样的？ RESTFul 和 RPC 的区别是什么？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengting0913/p/13388359.html</dc:identifier>
</item>
<item>
<title>深入理解Spring AOP 1.0 - WhaleFall541</title>
<link>http://www.cnblogs.com/whalefall541/p/13388295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whalefall541/p/13388295.html</guid>
<description>&lt;h4 id=&quot;本文相关代码来自官方源码spring-test模块请参见spring-demysify-orgspringframeworkmylearntest包下。&quot;&gt;本文相关代码(来自&lt;a href=&quot;https://github.com/spring-projects/spring-framework.git&quot; title=&quot;官方源码&quot;&gt;官方源码&lt;/a&gt;spring-test模块)请参见&lt;a href=&quot;https://github.com/whalefall541/spring-demysify&quot;&gt;spring-demysify&lt;/a&gt; org.springframework.mylearntest包下。&lt;/h4&gt;
&lt;h3 id=&quot;统称能够实现aop的语言为aol，即aspect-oriented-language，其他aspectj&quot;&gt;统称能够实现AOP的语言为AOL，即(Aspect-Oriented Language)，其他Aspectj&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AspectC&lt;/li&gt;
&lt;li&gt;AspectC++&lt;/li&gt;
&lt;li&gt;Aspect.Net&lt;/li&gt;
&lt;li&gt;AspectL(Lisp)&lt;/li&gt;
&lt;li&gt;AspectPHP&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JAVA中AOP实现方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;动态代理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行期间，为相应的接口动态生成对应的代理对象，将横切关注点逻辑封装到动态代理的InvocationHandler中，然后在系统运行期间，根据横切关注点需要织入的模块位置，将横切逻辑织入到相应的代理类中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态字节码增强&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用ASM或者CGLIB等Java工具库，在程序运行期间，动态构建字节码的class文件。&lt;/li&gt;
&lt;li&gt;在运行期间通过动态字节码增强技术织入横切逻辑，为这些系统模块类生成相应的子类，而将横切逻辑加到这些子类中，让应用程序的执行期间使用的是这些动态生成的子类，从而达到将横切逻辑织入系统的目的。&lt;/li&gt;
&lt;li&gt;如果需要扩展的类以及类中的实例方法等声明为final的话，则无法对其进行子类化的扩展。Spring AOP在无法使用动态代理机制进行AOP功能的扩展的时候，会使用CGLIB库的动态字节码增强技术来实现AOP的扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java代码生成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EJB容器根据部署描述符文件提供了织入信息，会为相应的功能模块类根据描述符所提供的信息生成对应的java代码，然后通过部署工具或者部署接口编译java代码生成对应的java类。之后部署到EJB容器的功能模块类就可以正常工作了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的java程序的class都要通过相应的类加载器(Classloader)加载到Java虚拟机之后才可以运行。默认的类加载器会读取class字节码文件，然后按照class字节码规范，解析并加载这些class文件到虚拟机运行。如果我能够在这个class加载到虚拟机运行期间，将横切逻辑织入到class文件的话，是不是就完成了AOP和OPP的融合呢？&lt;/li&gt;
&lt;li&gt;我们可以通过自定义类加载器的方式完成横切逻辑到系统的织入，自定义类加载器通过读取外部文件规定的织入规则和必要信息，在加载class文件期间就可以将横切逻辑添加到系统模块类的现有逻辑中，然后将改动后的class交给java虚拟机运行。通过类加载器，我们基本可以对大部分类以及相应的实例进行织入，功能于之前的几种方式相比当然强大很多。不过这种方式最大的问题就是类加载器本身的使用。某些应用服务器会控制整个的类加载体系，所以，在这样的场景下会造成一定的问题。&lt;/li&gt;
&lt;li&gt;Jboss AOP 和已经并入AspectJ项目的AspectWerkz框架都是采用自定义类加载器的方式实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOL扩展&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AOL扩展是最强大、也是最难掌握的一种方式，我们之前提到AspectJ就属于这种方式。在这种方式中，AOP的各种概念在AOL中大都有一一对应的实体。我们可以使用扩展过的AOL，实现任何AOP概念实体甚至OPP概念实体，比如Aspect以及Class。所有的AOP概念在AOL中得到了最完美的表达。&lt;/li&gt;
&lt;li&gt;采用扩展的AOL，在AOP概念的表达上颇具实例，使得AOP涉及的所有横切关注点逻辑在进行织入之前，可以自由自在地存活在自己的“国度中”。而像“编译到静态类可以提升系统运行性能”，“java虚拟机可以像加载平常类那种，加载已经织入相应逻辑的AO组件所在的文件并运行”等特点。使用这种方式，需要学习一门扩展的AOL语言。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8b44413c3499ab8c5aaf6884bdd28946b6d.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;一些单词的含义：&lt;/p&gt;
&lt;h3 id=&quot;aspect&quot;&gt;Aspect&lt;/h3&gt;
&lt;p&gt;Aspect是对系统中的横切关注点逻辑进行模块化封装的AOP的概念实体。通常情况下，Aspect可以包含多个Pointcut以及相关Advice定义。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-54403168dcfb0ec2d3084e5f49d0e678cc1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设计模式之代理模式&quot;&gt;设计模式之代理模式&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;静态代理&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.staticproxy;

public interface IRequestable {
        void request();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.staticproxy;

public class RequestableImpl implements IRequestable{
        @Override
        public void request() {
                System.out.println(&quot; request process in RequestableImpl&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.staticproxy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ServiceControlRequestableProxy implements IRequestable{
        private static final Logger logger = LoggerFactory.getLogger(ServiceControlRequestableProxy.class);
        private IRequestable requestable;

        public ServiceControlRequestableProxy(IRequestable target) {
                this.requestable = target;
        }

        @Override
        public void request() {
                System.out.println(&quot;request process in ServiceControlRequestableProxy&quot;);
                requestable.request();
        }

        public static void main(String[] args) {
                IRequestable target = new RequestableImpl();// 需要被代理的对象
                IRequestable proxy = new ServiceControlRequestableProxy(target); // 以构造方法形式将被代理对象传入代理者中
                proxy.request();// 让代理者去处理请求
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;动态代理机制主要由一个类和一个接口组成，即java.lang.reflect.Proxy类和java.lang.reflect.InvocationHadler接口。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.dynamicproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class RequestCtrlInvocationHandler implements InvocationHandler {
        private Object target;

        public RequestCtrlInvocationHandler(Object target) {
                this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(&quot;reflect invoke before target method&quot;);
                if (&quot;request&quot;.equals(method.getName())) {
                        System.out.println(&quot;dynamic proxy target method&quot;);
                        return method.invoke(target, args);
                }
                return null;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.dynamicproxy;

import org.springframework.mylearntest.aop.staticproxy.IRequestable;
import org.springframework.mylearntest.aop.staticproxy.RequestableImpl;

import java.lang.reflect.Proxy;

@SuppressWarnings(&quot;rawtypes&quot;)
public class Test4DynamicProxy {
        public static void main(String[] args) {
                // arg1:类加载器 arg2:接口信息 arg3:实现InvocationHandler的类 并传入需要代理的对象
                IRequestable requestable = (IRequestable) Proxy.newProxyInstance(
                                Test4DynamicProxy.class.getClassLoader(),
                                new Class[]{IRequestable.class},
                                new RequestCtrlInvocationHandler(new RequestableImpl()));
                requestable.request();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想深入了解动态代理，请阅读《java reflect in action》。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;CGLIB字节码生成&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;需要使用CGLIB扩展子类，首先需要实现一个net.sf.cglib.proxy.Callback,不过更多的时候，我们会直接使用net.sf.cglib.proxy.MethodInterceptor接口(MethodInterceptor扩展了Callback接口)。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.CGLIBClassGenerate;

public class Requestable {
        public void request(){
                System.out.println(&quot;req in requestable without implement any interface&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.CGLIBClassGenerate;

import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class RequestCtrlCallback implements MethodInterceptor {
        @Override
        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                if (method.getName().equals(&quot;request&quot;)) {
                        System.out.println(&quot;proxy generated by cglib intercept method request&quot;);
                        return methodProxy.invokeSuper(o, objects);
                }
                return null;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.CGLIBClassGenerate;

import org.springframework.cglib.proxy.Enhancer;

public class Test4CGLIB {
        public static void main(String[] args) {
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(Requestable.class);
                enhancer.setCallback(new RequestCtrlCallback());

                Requestable proxy = (Requestable) enhancer.create();
                proxy.request();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;aop中的pointcut&quot;&gt;AOP中的Pointcut&lt;/h3&gt;
&lt;p&gt;如果Pointcut类型为TruePointcut，默认会对系统中的所有对象，以及对象上所有被支持的Joinpoint进行匹配。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.aop;

springframework.aop.support.MethodMatchers

public interface Pointcut {

        ClassFilter getClassFilter();

        MethodMatcher getMethodMatcher();

        Pointcut TRUE = TruePointcut.INSTANCE;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
package org.springframework.aop;

import java.io.Serializable;

@SuppressWarnings(&quot;serial&quot;)
final class TruePointcut implements Pointcut, Serializable {

        public static final TruePointcut INSTANCE = new TruePointcut();

        private TruePointcut() {
        }

        @Override
        public ClassFilter getClassFilter() {
                return ClassFilter.TRUE;
        }

        @Override
        public MethodMatcher getMethodMatcher() {
                return MethodMatcher.TRUE;
        }

        private Object readResolve() {
                return INSTANCE;
        }

        @Override
        public String toString() {
                return &quot;Pointcut.TRUE&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClassFilter和MethodMatcher分别用于匹配将被执行织入操作的对象以及相应的方法。之所以将类型匹配和方法匹配分开定义，是因为可以重用不同级别的匹配定义，并且可以在不同级别或者相同级别上进行组合操作，或者强制让某个子类只覆盖(Override)相应方法定义等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
package org.springframework.aop;

@FunctionalInterface
public interface ClassFilter {

        boolean matches(Class&amp;lt;?&amp;gt; clazz);

        ClassFilter TRUE = TrueClassFilter.INSTANCE;

}
```java
package org.springframework.aop;

import java.lang.reflect.Method;

public interface MethodMatcher {

        boolean matches(Method method, Class&amp;lt;?&amp;gt; targetClass);

        boolean isRuntime();

        boolean matches(Method method, Class&amp;lt;?&amp;gt; targetClass, Object... args);

        MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当isRuntime返回false时，表示不会考虑具体Joinpoint的方法参数，这种类型的MethodMatcher称之为staticMethodMatcher。因为不用每次都检查参数，那么对于同样类型的方法匹配结果，就可以在框架内部缓存以提高性能。&lt;/li&gt;
&lt;li&gt;当isRuntime返回true时，表明MethodMatcher将会每次都对方法调用的参数进行匹配检查，这种类型的MethodMatcher称之为DynamicMethodMatcher。因为每次都要对方法参数进行检查，无法对匹配的结果进行缓存，所以，匹配效率相对于StaticMethodMatcher来说要差。而且大部门情况下，staticMethodMatcher已经可以满足需要。最好避免使用DynamicMethodMatcher类型。&lt;/li&gt;
&lt;li&gt;如果boolean matches(Method method, Class?&amp;gt;
 targetClass);返回true时，三个参数的matches将会被执行，以进一步检查匹配条件；如果boolean matches(Method method, Class?&amp;gt;
 targetClass);返回false，那么不管这个MethodMatcher是staticMethodMatcher还是DynamicMethodMatcher，该结果已经是最终结果，三个参数的方法肯定不会被执行了。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-56c82a867727a95b1dad667aae23f35016f.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-e2d8234131d2a7bcda1159c35d298a64d3e.png&quot; alt=&quot;常见pointcut&quot; title=&quot;常见pointcut&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;分述各种pointcut&quot;&gt;分述各种Pointcut&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;NameMatchMethodPointcut&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;最简单的Pointcut实现，属于StaticMethodMatcherPointcut的子类，可以根据自身指定一组方法名称与Joinpoint处的方法的方法名称进行匹配。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
pointcut.setMappedName(&quot;matches&quot;);
// 或者传入多个方法名
pointcut.setMappedNames(new String[]{&quot;matches&quot;, &quot;isRuntime&quot;});
// 简单模糊匹配
pointcut.setMappedNames(new String[]{&quot;match*&quot;, &quot;matches&quot;, &quot;mat*es&quot; });
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;此方法无法对重载的方法名进行匹配，因为它仅对方法名进行匹配，不会考虑参数相关信息，而且也没有提供可以指定参数匹配信息的途径。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;StaticMethodMatcherPointcut的子类有一个专门提供基于正则表达式的实现分支，以抽象类AbstractRegexpMethodPointcut为统帅，声明了pattern 和 patterns属性，可以指定一个或者和多个正则表达式的匹配模式。其下设JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut两种具体实现。JdkRegexpMethodPointcut是在JDK 1.4之后引入JDK标准正则表达式。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JdkRegexpMethodPointcut pointcut = new JdkRegexpMethodPointcut();
pointcut.setPattern(&quot;.*match.*&quot;);
pointcut.setPatterns(new String[]{&quot;.*match.&quot;, &quot;.*matches&quot;});
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;注意正则表达式匹配模式必须匹配整个方法签名(Method signature)的形式指定，而不能像NameMatchMethodPointcut那样仅给出匹配的方法名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Perl5RegexpMethodPointcut实现使用jakarta ORO提供正则表达式支持，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以通过pattern或者patterns对象属性指定一个或者多个正则表达式&lt;/li&gt;
&lt;li&gt;指定正则表达式匹配模式应该覆盖匹配整个方法签名，而不是只指定到方法名称部分。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;AnnotationMatchingPointcut&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.annotationmatchingpointcut;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface ClassLevelAnnotation {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.annotationmatchingpointcut;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MethodLevelAnnotation {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.annotationmatchingpointcut;

@ClassLevelAnnotation
public class GenericTargetObject {

        @MethodLevelAnnotation
        public void getMethod1() {
                System.out.println(&quot;getMethod1&quot;);
        }

        public void getMethod2() {
                System.out.println(&quot;getMethod2&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       AnnotationMatchingPointcut pointcut = new AnnotationMatchingPointcut(ClassLevelAnnotation.class);
        // 也可以通过静态方法
        AnnotationMatchingPointcut pointcut1 = AnnotationMatchingPointcut.forClassAnnotation(MethodLevelAnnotation.class);
        // 同时限定
        AnnotationMatchingPointcut pointcut2 = AnnotationMatchingPointcut.forClassAnnotation(ClassLevelAnnotation.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;ComposablePointcut&lt;br/&gt;Spring AOP提供Pointcut逻辑运算的Pointcut实现。它可以进行Pointcut之间的“并”以及“交”运算。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.pointcut.composablePointcut;

import org.junit.Assert;
import org.springframework.aop.ClassFilter;
import org.springframework.aop.MethodMatcher;
import org.springframework.aop.Pointcut;
import org.springframework.aop.support.ComposablePointcut;
import org.springframework.aop.support.Pointcuts;

public class Test4ComposablePointcut {

        public static void main(String[] args) {
                ComposablePointcut pointcut1 = new ComposablePointcut(new ClassFilter() {
                        @Override
                        public boolean matches(Class&amp;lt;?&amp;gt; clazz) {
                                return false;
                        }
                }, MethodMatcher.TRUE);

                ComposablePointcut pointcut2 = new ComposablePointcut(new ClassFilter() {
                        @Override
                        public boolean matches(Class&amp;lt;?&amp;gt; clazz) {
                                return false;
                        }
                }, MethodMatcher.TRUE);

                // union intersection
                ComposablePointcut union = pointcut1.union(pointcut2);
                ComposablePointcut intersection = pointcut1.intersection(union);

                Assert.assertEquals(pointcut1,intersection);

                // combine classFilter with methodMatcher
                pointcut2.union(new ClassFilter() {
                        @Override
                        public boolean matches(Class&amp;lt;?&amp;gt; clazz) {
                                return false;
                        }
                }).intersection(MethodMatcher.TRUE);

                // just compute between pointcut, use org.springframework.aop.support.Pointcuts
                Pointcut pointcut3 = new Pointcut() {
                        @Override
                        public ClassFilter getClassFilter() {
                                return null;
                        }

                        @Override
                        public MethodMatcher getMethodMatcher() {
                                return null;
                        }
                };

                Pointcut pointcut4 = new Pointcut() {
                        @Override
                        public ClassFilter getClassFilter() {
                                return null;
                        }

                        @Override
                        public MethodMatcher getMethodMatcher() {
                                return null;
                        }
                };

                Pointcut union1 = Pointcuts.union(pointcut3, pointcut4);
                Pointcut intersection1 = Pointcuts.intersection(pointcut3, pointcut4);

        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;ControlFlowPointcut&lt;br/&gt;ControlFlowPointcut匹配程序的调用流程，不是对某个方法执行所在Joinpoint处的单一特征进行匹配，而是要被特定的类执行时，才会进行方法拦截。&lt;br/&gt;因为ControlFlowPointcut类型的Pointcut 需要在运行期间检查程序的调用栈，而且每次方法调用都需要检查，所以性能比较差。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spring-aop中的advice&quot;&gt;Spring Aop中的Advice&lt;/h3&gt;
&lt;p&gt;Spring 中各种Advice 和 Aop Alliance标准接口之间的关系。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-22bd58e5adaa1b4d81cedc603cd6a3a4675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Spring中，Advice按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类，即per-calss类型的Advice 和 per-instance类型的Advice。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;per-class&quot;&gt;per-class&lt;/h4&gt;
&lt;p&gt;per-class的Advice是指，该类型的Advice的实例可以在目标对象类的所有实例之间共享。这种类型的Advice通常只是提供方法的拦截功能，不会对目标对象类保存任何状态或者添加新的特性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;BeforeAdvice&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice;

import org.apache.commons.io.FileUtils;
import org.springframework.aop.MethodBeforeAdvice;
import org.springframework.core.io.Resource;

import java.lang.reflect.Method;

public class ResourceSetupBeforeAdvice implements MethodBeforeAdvice {
        private Resource resource;

        public ResourceSetupBeforeAdvice(Resource resource) {
                this.resource = resource;
        }

        @Override
        public void before(Method method, Object[] args, Object target) throws Throwable {
                if (!resource.exists()) {
                        FileUtils.forceMkdir(resource.getFile());
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;ThrowsAdvice&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice;

import org.omg.CORBA.portable.ApplicationException;
import org.springframework.aop.ThrowsAdvice;

import java.lang.reflect.Method;

public class ExceptionBarrierThrowsAdvice implements ThrowsAdvice {
        public void afterThrowing(Throwable t) {
                // 普通异常处理
        }

        public void afterThrowing(RuntimeException t) {
                // 运行时异常处理
        }

        public void afterThrowing(Method m, Object[] args, Object target, ApplicationException e) {
                // 处理应用程序生成的异常
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;AfterReturningAdvice&lt;br/&gt;此Advice可以访问到当前Joinpoint的方法返回值、方法、方法参数以及所在的目标对象，但是不能更改返回值，可以使用Around Advice来更改返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Around Advice&lt;br/&gt;Spring中没有定义Around Advice ，而是直接使用AOP Alliance的标准接口，实现 MethodInterceptor即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;per-instance&quot;&gt;per-instance&lt;/h4&gt;
&lt;p&gt;per-instance类型的Advice不会在目标类所有对象实例之间共享，而是会为不同的实例对象保存它们各自的状态以及相关逻辑。在Spring中Introduction就是唯一的一种per-instance型Advice。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Introduction 可以在不改动目标类定义的情况下，为目标类添加新的属性以及行为。&lt;/li&gt;
&lt;li&gt;在Spring中，为目标对象添加新的属性和行为必须声明相应的接口以及相应的实现。这样，再通过特定的拦截器将新的接口定义以及实现类中的逻辑附加到目标对象之上。之后，目标对象就拥有了新的状态和行为。这个特定的拦截器是org.springframework.aop.IntroductionInterceptor。&lt;/li&gt;
&lt;li&gt;Introduction继承了MethodInterceptor以及DynamicIntroductionAdvice，通过DynamicIntroductionAdvice，我们可以界定当前的IntroductionInterceptor为哪些接口类提供相应的拦截功能。通过MethodInterceptor,IntroductionInterceptor就可以处理新添加的接口上的方法调用了。通常情况下，对于IntroductionInterceptor来说，如果是新增加的接口上的方法调用，不必去调用MethodInterceptor的proceed（）方法。当前被拦截的方法实际上是整个调用链中要最终执行的唯一方法。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-dab617d645b217c3618bf51c07bdfdca5d8.png&quot; alt=&quot;Introduction相关类图&quot; title=&quot;Introduction相关类图&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;delegatingintroductioninterceptor&quot;&gt;DelegatingIntroductionInterceptor&lt;/h5&gt;
&lt;p&gt;DelegatingIntroductionInterceptor不会自己实现将要添加到目标对象上的新逻辑行为，而是委派给其他的实现类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用DelegatingIntroductionInterceptor增强Developer。接口省略。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice.perinstance.delegatingIntroductionInterceptor;

public class Developer implements IDeveloper{
        @Override
        public void developSoftware() {
                System.out.println(&quot; do some developing ...&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;为新的状态和行为定义接口。我们要为实现类添加增强的功能，首先需要将需求的职能以接口定义的形式声明。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice.perinstance.delegatingIntroductionInterceptor;

public interface ITester {
        boolean isBusyAsTester();
        void testSoftware();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;给出新的接口的实现类。接口实现类给出将要添加到目标对象的具体逻辑。当目标对象要行使新的职能的时候，会通过该实现类寻求帮忙。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice.perinstance.delegatingIntroductionInterceptor;

public class Tester implements ITester{
        private  boolean busyAsTester;

        public void setBusyAsTester(boolean busyAsTester) {
                this.busyAsTester = busyAsTester;
        }

        @Override
        public boolean isBusyAsTester() {
                return busyAsTester;
        }

        @Override
        public void testSoftware() {
                System.out.println(&quot;do some developing and test ...&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;通过DelegatingIntroductionInterceptor进行Introduction拦截。有了新增加的职能的接口以及相应的实现类，使用DelegatingIntroductionInterceptor，我们可以把具体的Introduction拦截委托给具体的实现类来完成。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ITester delegator = new Tester();
DelegatingIntroductionInterceptor interceptor = new DelegatingIntroductionInterceptor(delegator);
                
// 进行织入
ITester tester = (ITester)weaver.weave(developer).with(interceptor).getProxy();
tester.testSoftware();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;虽然，DelegatingIntroductionInterceptor是Introduction型Advice的一个实现，但它的实现根本就有兑现Introduction作为per-instance型的承诺。实际上DelegatingIntroductionInterceptor会使用它所持有的同一个&quot;delegate&quot; 接口实例，供同一目标类的所有实例共享使用。如果要想严格达到Introduction型Advice的效果，我们应该使用DelegatePerTargetObjectIntroductionInterceptor。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;delegatepertargetobjectintroductioninterceptor&quot;&gt;DelegatePerTargetObjectIntroductionInterceptor&lt;/h5&gt;
&lt;p&gt;与DelegatingIntroductionInterceptor不同，DelegatePerTargetObjectIntroductionInterceptor会在内部持有一个目标对象与相应Introduction逻辑实现类之间的映射关系。当每个对象上的新定义的接口方法被调用的时候，DelegatePerTargetObjectIntroductionInterceptor会拦截这些调用，然后以目标对象实例作为键，到它持有的那个映射关系中取得对应当前目标对象实例的Introduction实现实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DelegatePerTargetObjectIntroductionInterceptor interceptor1 =
                                new DelegatePerTargetObjectIntroductionInterceptor(Tester.class,ITester.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;扩展DelegatingIntroductionInterceptor&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.advice.perinstance;

import org.aopalliance.intercept.MethodInvocation;
import org.apache.commons.lang3.StringUtils;
import org.springframework.aop.support.DelegatingIntroductionInterceptor;

public class TesterFeatureIntroductionInterceptor extends DelegatingIntroductionInterceptor implements ITester {

        public static final long serialVersionUID = -3387097489523045796L;
        private boolean busyAsTester;

        @Override
        public Object invoke(MethodInvocation mi) throws Throwable {
                if (isBusyAsTester() &amp;amp;&amp;amp; StringUtils.contains(mi.getMethod().getName(), &quot;developSoftware&quot;)) {
                        throw new RuntimeException(&quot;I'am so tired&quot;);
                }
                return super.invoke(mi);
        }

        @Override
        public boolean isBusyAsTester() {
                return busyAsTester;
        }

        public void setBusyAsTester(boolean busyAsTester) {
                this.busyAsTester = busyAsTester;
        }

        @Override
        public void testSoftware() {
                System.out.println(&quot;I will ensure the quality&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring-aop-中的aspect&quot;&gt;Spring AOP 中的Aspect&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Advisor代表Spring中的Aspect，但是与正常的Aspect不同，Advisor通常只持有一个Pointcut和一个Advice。而理论上，Aspect定义中可以有多个Pointcut和多个Advice，所以Advisor是一种特殊的Aspect。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;pointcutadvisor&quot;&gt;PointcutAdvisor&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a07fb97fa23007ab71c566724aef6d68b6f.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-58fd138fecf5bb12603ff296eb439e0360c.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实际上，org.springframework.aop.PointcutAdvisor才是真正定义的有一个Pointcut和一个Advice的Advisor，大部分的Advisor实现全部是在PointcutAdvisor下的。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;DefaultPointcutAdvisor&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;bean id=&quot;pointcut&quot;
          class=&quot;org.springframework.mylearntest.aop.pointcut.selfdefinepointcut.QueryMethodPointcut&quot;/&amp;gt;
        &amp;lt;bean id=&quot;advice&quot; class=&quot;org.springframework.mylearntest.aop.advice.perclass.DiscountMethodInterceptor&quot;/&amp;gt;

        &amp;lt;bean id=&quot;advisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&amp;gt;
                &amp;lt;property name=&quot;pointcut&quot; ref=&quot;pointcut&quot;/&amp;gt;
                &amp;lt;property name=&quot;advice&quot; ref=&quot;advice&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;NameMatchMethodPointcutAdvisor&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;此类内部持有一个NameMatchMethodPointcut类型的Pointcut实例。当通过NameMatchMethodPointcutAdvisor公开的setMappedName和setMappedNames方法设置将要被拦截的方法名的时候，实际上是在操作NameMatchMethodPointcutAdvisor内部的NameMatchMethodPointcut实例。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Advice advice = new DiscountMethodInterceptor();
NameMatchMethodPointcutAdvisor advisor = new NameMatchMethodPointcutAdvisor(advice);
advisor.setMappedName(&quot;invoke&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;RegexpMethodPointcutAdvisor&lt;br/&gt;只能通过正则表达式为其设置相应的Pointcut，内部持有一个AbstractRegexpMethodPointcut的实例。AbstractRegexpMethodPointcut有两个实现类，Perl5RegexpMethodPointcutAdvisor和JdkRegexpMethodPointcut。默认使用JdkRegexpMethodPointcut，如果强制使用Perl5RegexpMethodPointcutAdvisor,那么可以通过RegexpMethodPointcutAdvisor的setPerl5(boolean)实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;DefaultBeanFactoryPointcutAdvisor&lt;br/&gt;DefaultBeanFactoryPointcutAdvisor自身绑定到了BeanFactory,要使用DefaultBeanFactoryPointcutAdvisor，要绑定到Spring IoC容器。通过容器中的Advice注册的beanName来关联对应的Advice。只有当对应的Pointcut匹配成功之后，采取实例化对应的Advice，减少了容器启动初期Advisor和Advice之间的耦合性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;introductionadvisor&quot;&gt;IntroductionAdvisor&lt;/h5&gt;
&lt;p&gt;IntroductionAdvisor只能应用于类级别的拦截，只能使用Introduction型的Advice，而不能像PointcutAdvisor那样，可以使用任意类型的Pointcut，以及差不多任何类型的Advice。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b0477a82d62b94dceeda67d6a8c23eed154.png&quot; alt=&quot;IntroductionAdvisor类结构图&quot; title=&quot;IntroductionAdvisor类结构图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;order的作用&quot;&gt;Order的作用&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;大多数时候，会有多个关注横切点，那么，系统实现中就会有多个Advisor存在。当其中的某些Advisor的Pointcut匹配了同一个Joinpoint的时候，就会在这同一个Joinpoint处执行多个Advice的横切逻辑。一旦这几个需要在同一个Joinpoint处执行的Advice逻辑存在优先顺序依赖的话，就需要我们来干预了。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-306d297c19ff1032402f86643854b045754.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Spring在处理同一Joinpoint处的多个Advisor的时候，会按照指定的顺序有优先级来执行他们。顺序号越小，优先级越高，优先级越高的，越先被执行。(默认情况下，Spring会按照它们的声明顺序来应用它们，最先声明的顺序号最小但优先级最大，其次次之)&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8e8112c31c3e7884c079675a98f834e4df9.png&quot; alt=&quot;order图&quot; title=&quot;order图&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;各个Advisor实现类，其实已经实现了Order接口。在使用的时候我们可以直接指定即可&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;permissionAuthAdvisor&quot; class=&quot;...PermissionAuthAdvisor&quot;&amp;gt;
        &amp;lt;property name=&quot;order&quot; value=&quot;1&quot;&amp;gt;
        ...
&amp;lt;bean&amp;gt;

&amp;lt;bean id=&quot;exceptionBarrierAdvisor&quot; class=&quot;...ExceptionBarrierAdvisor&quot;&amp;gt;
        &amp;lt;property name=&quot;order&quot; value=&quot;0&quot;&amp;gt;
        ...
&amp;lt;bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring-aop的织入&quot;&gt;Spring AOP的织入&lt;/h4&gt;
&lt;p&gt;AspectJ采用ajc编译器作为它的织入器；JBoss AOP使用自定义的ClassLoader作为它的织入器；而在Spring AOP中，使用类org.springframework.aop.framework.ProxyFactory作为织入器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用方法
&lt;ol&gt;&lt;li&gt;传入需要织入的对象&lt;br/&gt;&lt;code&gt;ProxyFactory weaver = new ProxyFactory(target);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将要应用到目标对象的Advisor绑定到织入器上
&lt;ul&gt;&lt;li&gt;如果不是Introduction的Advice类型，Proxy内部就会为这些Advice构造相应的Advisor，只不过在为它们构造Advisor中使用的Pointcut为Pointcut.TRUE。&lt;/li&gt;
&lt;li&gt;如果是Introduction类型，则会根据该Introduction具体类型进行区分；如果是Introduction的子类实现，框架内部会为其构造一个DefaultIntroductionAdvisor；如果是DynamicIntroductionAdvice的子实现类，框架内部将抛出AOPConfigException异常(因为无法从DynamicIntroductionAdvice取得必要的目标对象信息)&lt;br/&gt;&lt;code&gt;weaver.addAdvisor(advisor);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获取代理对象&lt;br/&gt;&lt;code&gt;Object proxyObject = weaver.getProxy();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;基于接口的代理&quot;&gt;基于接口的代理&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver;

import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.support.NameMatchMethodPointcutAdvisor;

import java.util.Date;

/**
 * @Author: whalefall
 * @Date: 2020/7/15 22:53
 */

@SuppressWarnings({&quot;rawtypes&quot;, &quot;Deprecated&quot;})
public class Test4ProxyFactory {
        public static void main(String[] args) {
                /*// 1. 传入需要织入的对象
                ProxyFactory weaver = new ProxyFactory(new Tester());
                // weaver.setTarget(new Tester());

                // 2. 将要应用到目标对象的Advisor绑定到织入器上
                ApplicationContext context = new ClassPathXmlApplicationContext(&quot;advisor/defaultadvisor/defaultadvisor.xml&quot;);
                Advisor advisor = (Advisor) context.getBean(&quot;advisor&quot;);
                weaver.addAdvisor(advisor);

                Object proxyObject =  weaver.getProxy();
                System.out.println(proxyObject.getClass());
                // out: class org.springframework.mylearntest.aop.advice.perinstance.Tester$$EnhancerBySpringCGLIB$$8e739b5b
                */

                // 目标类有实现接口的用法
                // 只要不将ProxyFactory的optimize和proxyTargetClass设置为true
                // 那么ProxyFactory都会按照面向接口进行代理
                MockTask task = new MockTask();
                ProxyFactory weaver = new ProxyFactory(task);
                // weaver.setInterfaces(new Class[]{ITask.class});
                NameMatchMethodPointcutAdvisor advisor = new NameMatchMethodPointcutAdvisor();
                advisor.setMappedNames(&quot;execute&quot;);
                advisor.setAdvice(new PerformanceMethodInterceptor());
                weaver.addAdvisor(advisor);
                ITask proxyObj = (ITask)weaver.getProxy();
                // com.sun.proxy.$Proxy0
                // System.out.println(proxyObj.getClass());
                // 只能强制转化为接口类型，不能转化为实现类类型 否则会抛出ClassCastException
                // ITask proxyObj = (MockTask)weaver.getProxy();
                proxyObj.execute(new Date());

                // 目标类没有实现接口的用法


        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;基于类代理&quot;&gt;基于类代理&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.baseonclass;

import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.support.NameMatchMethodPointcutAdvisor;
import org.springframework.mylearntest.aop.advice.perclass.PerformanceMethodInterceptor;

/**
 * @Author: whalefall
 * @Date: 2020/7/17 23:31
 */
public class Test4CGLib {
        public static void main(String[] args) {
                ProxyFactory weaver = new ProxyFactory(new Executable());
                NameMatchMethodPointcutAdvisor advisor = new NameMatchMethodPointcutAdvisor();

                advisor.addMethodName(&quot;execute&quot;);
                advisor.setAdvice(new PerformanceMethodInterceptor());
                weaver.addAdvisor(advisor);

                Executable proxyObject = (Executable)weaver.getProxy();
                proxyObject.execute();
                // org.springframework.mylearntest.aop.weaver.baseonclass.Executable$$EnhancerBySpringCGLIB$$37e40619
                System.out.println(&quot;proxyObject class: &quot; + proxyObject.getClass());
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果目标类没有实现任何接口，不管proxyTargetClass的属性是什么，ProxyFactoy会采用基于类的代理&lt;/li&gt;
&lt;li&gt;如果ProxyFactoy的proxyTargetClass属性值被设置为true，ProxyFactoy会采用基于类的代理&lt;/li&gt;
&lt;li&gt;如果ProxyFactoy的optimize属性被设置为true，ProxyFactory会采用基于类的代理。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;introduction的织入&quot;&gt;Introduction的织入&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Introduction可以为已经存在的对象类型添加新的行为，只能应用于对象级别的拦截，而不是通常Advice的方法级别的拦截，所以在Introduction的织入过程中，不需要指定Pointcut,而只需要指定目标接口类型。&lt;/li&gt;
&lt;li&gt;Spring的Introduction支持只能通过接口定义为当前对象添加新的行为。所以，我们需要在织入的时机，指定新织入的接口类型。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.introduction;

import org.springframework.aop.framework.ProxyFactory;
import org.springframework.mylearntest.aop.advice.perinstance.Developer;
import org.springframework.mylearntest.aop.advice.perinstance.IDeveloper;
import org.springframework.mylearntest.aop.advice.perinstance.ITester;
import org.springframework.mylearntest.aop.advice.perinstance.TesterFeatureIntroductionInterceptor;

/**
 * @Author: whalefall
 * @Date: 2020/7/19 0:02
 */

@SuppressWarnings(&quot;rawtypes&quot;)
public class Test4Introduction {
        public static void main(String[] args) {
                ProxyFactory weaver = new ProxyFactory(new Developer());
                weaver.setInterfaces(new Class[]{IDeveloper.class, ITester.class});
                TesterFeatureIntroductionInterceptor advice = new TesterFeatureIntroductionInterceptor();
                weaver.addAdvice(advice);
                // DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor(advice,advice);
                // weaver.addAdvisor(advisor);

                Object proxy = weaver.getProxy();
                ((ITester)proxy).testSoftware();
                ((IDeveloper)proxy).developSoftware();
                System.out.println(&quot;proxy = &quot; + proxy);

        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;proxyfactory本质&quot;&gt;ProxyFactory本质&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200720221906281-1367694573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring AOP框架内使用AopProxy对使用的不用的代理实现机制进行了适度的抽象，主要有针对JDK动态代理和CGLIB两种机制的AopProxy两种实现，分别是Cglib2AopProxy和JdkDynamicAopProxy两种实现。动态代理需要通过InvocationHandler提供调用拦截，所以JdkDynamicAopProxy同时实现了InvocationHandler接口。采用抽象工厂模式，通过org.springframework.aop.framework.AopProxyFactory进行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pulic interface AopProxyFactory {
        AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AopProxyFactory根据传入的AdvisedSupport实例提供的相关信息，来决定生成什么类型的AopProxy，具体的工作由AopProxyFactory具体的实现类来完成。即org.springframework.aop.framework.DefaultAopProxyFactory。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
package org.springframework.aop.framework;

import java.io.Serializable;
import java.lang.reflect.Proxy;

import org.springframework.aop.SpringProxy;

@SuppressWarnings(&quot;serial&quot;)
public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

        @Override
        public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
                // 如果传入的AdvisedSupport实例的isOptimize或者isProxyTargetClass方法返回true，
                // 或者目标对象没有实现任何接口，则采用CGLIB生成代理对象，否则使用动态代理。
                if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
                        Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
                        if (targetClass == null) {
                                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                                                &quot;Either an interface or a target is required for proxy creation.&quot;);
                        }
                        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
                                return new JdkDynamicAopProxy(config);
                        }
                        return new ObjenesisCglibAopProxy(config);
                }
                else {
                        return new JdkDynamicAopProxy(config);
                }
        }

        private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
                Class&amp;lt;?&amp;gt;[] ifcs = config.getProxiedInterfaces();
                return (ifcs.length == 0 || (ifcs.length == 1 &amp;amp;&amp;amp; SpringProxy.class.isAssignableFrom(ifcs[0])));
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200720233704438-203646049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;AdvisedSupport是一个生成代理对象所需要的信息的载体。一类为org.springframework.aop.framework.ProxyConfig为首的，记载生成代理对象的控制信息；一类以org.springframework.aop.framework.Advised为首，承载生成代理对象的所需要的必要信息，比如相关目标类、Advice、Advisor等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ProxyConfig就是普通的JavaBean，定义了五个boolean型的属性，分别控制在生成代理代理对象的时候，应该采取哪些措施。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ProxyTargetClass：如果这个属性设置如true，则ProxyFactory将会使用CGLIB对目标对象进行代理。默认值为false。&lt;/li&gt;
&lt;li&gt;optimize：该属性主要用于告知代理对象是否需要采取进一步的优化措施。如果代理对象生成之后，即使为其添加或者移除了相应的人Advice，代理对象也可以忽略这种变动。如果这个属性设置如true，则ProxyFactory将会使用CGLIB对目标对象进行代理。默认值为false。&lt;/li&gt;
&lt;li&gt;opaque：该属性用于控制生成的代理对象是否可以强制转化为Advised，默认值为false，表示任何生成的代理对象都可以强制转型为Advised，我们可以通过Advised查询代理对象的一些状态。&lt;/li&gt;
&lt;li&gt;exposeProxy：设置exposeProxy，可以让Spring AOP框架在生成代理对象时，将当前代理对象绑定到ThreadLocal。如果目标对象需要访问当前代理对象，可以通过AopContext.currentProxy()拿到代理对象。出于性能方面考虑，该属性默认为false。&lt;/li&gt;
&lt;li&gt;frozen：如果将frozen设置为true，那么一旦针对dialing对象生成的各项信息配置完成，则不容许更改。比如ProxyFactory的设置完毕，并且frozen为true，则不能对Advice进行任何变动，这样可以优化代理对象的性能，默认情况下为false。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;要生成代理对象，只有ProxyConfig提供的信息还不够，我们还需要生成代理对象的一些具体信息，比如，要针对哪些目标类生成代理对象，要为代理对象加入何种横切逻辑等，这些信息可以通过org.springframework.aop.framework.Advised设置或者拆线呢。默认情况下Spring AOP框架返回的代理对象都可以强制转型为Advised，已查询代理对象的相关信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们可以使用Advised接口访问相应代理对象所有持有的Advisor，进行添加Advisor、一处Advisor等相关动作。即使代理对象已经生成完毕，也可对其进行操作，直接操作Advised，更多时候用于测试场景，可以帮助我们检查生成的代理对象是否如所期望的那样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;aopproxy、advisedsupport、proxyfactory之间的关系&quot;&gt;AopProxy、AdvisedSupport、ProxyFactory之间的关系&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200720233626519-1408969049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ProxyFactory集AopProxy和AdvisedSupport于一身，可以通过AdvisedSupport设置生成代理对象所需要的相关信息，可以通过AopProxy生成代理对象。为了重用相关逻辑，Spring AOP框架在实现的时候，将一些公用的逻辑抽取到了org.springframework.aop.frameworkx.ProxyCreatorSuppport中，自身继承了AdvisedSupport，所以就能具有设置生成代理对象所需要的相关信息。&lt;/li&gt;
&lt;li&gt;为了简化生成不同类型AopProxy的工作，ProxyCreatorSuppport内部持有一个AopProxyFactory实例，默认采用的是DefaultAopProxyFactory。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200720233603959-1746364099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;proxyfactorybean&quot;&gt;ProxyFactoryBean&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;ProxyFactoryBean的本质&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;ProxyFactoryBean本质上是一个用来产生Proxy的FactoryBean，FactoryBean的作用 -- 如果某个对象持有某个FactoryBean的引用，它取得的不是FactoryBean本身，而是FactoryBean的getObject()方法返回的对象。所以，如果容器中某个对象依赖于ProxyFactoryBean，那么它将会使用到ProxyFactoryBean的getObject()方法返回的代理对象。&lt;/li&gt;
&lt;li&gt;要让ProxyFactoryBean的getObject()方法返回相应目标对象的代理对象其实很简单。因为ProxyFactoryBean继承了ProxyFactory共有的父类ProxyCreatorSupport，而ProxyCreatorSupport基本上已经把要做的事情(设置目标对象、配置其他部件、生成对应的AopProxy等)全部完成了。我们只用在ProxyFactoryBean的getObject()方法中通过父类的createAopProxy()拿到代理对象，然后&lt;code&gt;return AopProxy.getObject()&lt;/code&gt;即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getObject() throws BeansException {
                initializeAdvisorChain();
                if (isSingleton()) {
                        return getSingletonInstance();
                }
                else {
                        if (this.targetName == null) {
                                logger.info(&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot; +
                                                &quot;Enable prototype proxies by setting the 'targetName' property.&quot;);
                        }
                        return newPrototypeInstance();
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ProxyBean定义中要求表明返回的对象是以singleton的scope返回，还是prototype的scope返回。针对这两种情况返回不同的代理对象，以满足FactoryBean的isSingleton()方法的语义。&lt;/li&gt;
&lt;li&gt;如果将ProxyFactoryBean的singleton属性设置为true，则ProxyFactoryBean在第一次生成代理对象之后，会通过内部实例变量singletonInstance(Object类型)缓存生成的代理对象。之后所有的请求都返回这一缓存实例，从而满足singleton的语义。反之，如果将ProxyFactoryBean的singleton属性设置为false，那么，ProxyFactoryBean每次都会重新检测各项设置，并为当前调用准备一套新的环境，然后再根据最新的环境数据，返回一个新的代理对象。因此，如果singleton属性为false，在生成代理对象的性能上存在损失。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;ProxyFactoryBean的使用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;与ProxyFactory一样，通过ProxyFactoryBean，我们可以在生成目标对象的代理对象的时候，指定使用基于接口的代理还是基于类的代理方式，而且，因为它们全部继承自同一个父类，大部分设置项目都相同。ProxyFactoryBean在继承了ProxyCreatorSupport的所有配置属性之外还添加了自己独有的：
&lt;ol&gt;&lt;li&gt;proxyInterfaces：如果我们要采用基于接口的代理方式，那莪需要通过该属性配置相应的接口类型，通过Collection对象传入配置元素的接口信息。ProxyFactoryBean有一个autodetectInterfaces属性，该属性默认为true，如果没有明确指定要代理的接口类型，ProxyFactoryBean会自动检测目标对象实现的接口类型并进行代理。&lt;/li&gt;
&lt;li&gt;interceptorNames：通过该属性，我们可以指定多个将要织入到目标对象的Advice、拦截器以及Advisor，而再也不通过ProxyFactory那样的addAdvice或者addAdvisor方法添加，通常我们会使用配置元素添加需要的拦截器名称
&lt;ul&gt;&lt;li&gt;如果没有设置目标对象，那么可以在interceptorNames的最后一个元素的位置，放置对象的Bean定义名称。建议直接定义目标对象，不采用前面的方法。&lt;/li&gt;
&lt;li&gt;通过指定的interceptorNames某个元素名称之后添加*通配符，可以让ProxyFactoryBean在容器中搜索符合条件的所有Advisro并应用到目标对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;使用通配符的范例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;proxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;target&quot; ref=&quot;...&quot;/&amp;gt;
        &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;global*&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;global_debug&quot; class=&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;/&amp;gt;
&amp;lt;bean id=&quot;global_performance&quot; class=&quot;org.springframework.aop.interceptor.PerformanceMonitorInterceptor&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;singleton：ProxyFactoryBean本质上是一个FactoryBean，所以我们可以通过singleton属性，指定getObject调用是返回同一个代理对象还是新的。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;使用proxyfactorybean生成代理对象案例&quot;&gt;使用ProxyFactoryBean生成代理对象案例&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&amp;gt;

        &amp;lt;!-- 目标对象的Bean定义--&amp;gt;
        &amp;lt;bean id=&quot;task&quot;
                  class=&quot;org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask&quot; scope=&quot;prototype&quot;/&amp;gt;

        &amp;lt;!-- ProxyFactoryBean定义--&amp;gt;
        &amp;lt;bean id=&quot;introducedTask&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; scope=&quot;prototype&quot;&amp;gt;
                &amp;lt;property name=&quot;targetName&quot;&amp;gt;
                        &amp;lt;value&amp;gt;task&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;proxyInterfaces&quot;&amp;gt;
                        &amp;lt;list&amp;gt;
                                &amp;lt;value&amp;gt;org.springframework.mylearntest.aop.weaver.baseoninterface.ITask&amp;lt;/value&amp;gt;
                                &amp;lt;value&amp;gt;org.springframework.mylearntest.aop.weaver.proxyfactorybean.ICounter&amp;lt;/value&amp;gt;
                        &amp;lt;/list&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                        &amp;lt;list&amp;gt;
                                &amp;lt;value&amp;gt;introductionInterceptor&amp;lt;/value&amp;gt;
                        &amp;lt;/list&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;!-- introductionInterceptor定义--&amp;gt;
        &amp;lt;bean id=&quot;introductionInterceptor&quot;
                  class=&quot;org.springframework.aop.support.DelegatingIntroductionInterceptor&quot; scope=&quot;prototype&quot;&amp;gt;
                &amp;lt;constructor-arg&amp;gt;
                        &amp;lt;bean class=&quot;org.springframework.mylearntest.aop.weaver.proxyfactorybean.CounterImpl&quot;/&amp;gt;
                &amp;lt;/constructor-arg&amp;gt;
        &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.proxyfactorybean;

/**
 * @Author: whalefall
 * @Date: 2020/7/22 23:34
 */
public interface ICounter {
        void resetCounter();
        int getCounter();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.proxyfactorybean;

/**
 * @Author: whalefall
 * @Date: 2020/7/22 23:35
 */
public class CounterImpl implements ICounter{
        private int counter;

        @Override
        public void resetCounter() {
                counter = 0;
        }

        @Override
        public int getCounter() {
                counter ++;
                return counter;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.proxyfactorybean;

import org.springframework.aop.support.DelegatingIntroductionInterceptor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @Author: whalefall
 * @Date: 2020/7/22 23:51
 * @see DelegatingIntroductionInterceptor
 */
public class Test4ProxyFactoryBean {
        public static void main(String[] args) {
                ApplicationContext context = new ClassPathXmlApplicationContext(&quot;proxyfactorybean\\proxyfactorybean.xml&quot;);
                Object proxy1 = context.getBean(&quot;introducedTask&quot;);
                Object proxy2 = context.getBean(&quot;introducedTask&quot;);

                System.out.println(((ICounter)proxy1).getCounter());//1
                System.out.println(((ICounter)proxy1).getCounter());//2
                System.out.println(((ICounter)proxy2).getCounter());//1
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;自动代理&quot;&gt;自动代理&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Spring AOP自动代理的实现建立在IoC容器的BeanPostProcessor概念之上，使用一个BeanPostProcessor，然后在BeanPostProcessor内部实现这样的逻辑，即当对象实例化的时候，为其生成代理对象并返回，而不是实例化后的目标对象本身，从而达到自动代理的目的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       for(bean in IoC container){
                // 检查当前bean定义是否满足拦截条件，是则拦截
                if(isAssistentStatement){
                        Object proxy = createProxyFor(bean);
                        return proxy;
                } else {
                        Object instance = createInstance(bean);
                        return instance;
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拦截条件：
&lt;ul&gt;&lt;li&gt;通过外部配置文件传入这些拦截条件信息，比如我们在容器的配置文件中注册的有关Pointcut以及Advisor等就包括这些信息；&lt;/li&gt;
&lt;li&gt;还可以在具体类的定义文件中，通过元数据来知名具体的拦截条件是什么，比如可以通过Jakarta Commons Atrributes或者Java5的注解，直接在代码类中标注Pointcut等拦截信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;spring中可用的自动代理类&quot;&gt;Spring中可用的自动代理类&lt;/h6&gt;
&lt;p&gt;Spring AOP在org.springframework.aop.framework.autoproxy包下提供了两个常用的AutoProxyCreator，即BeanNameAutoProxyCreator和DefaultAdvisorAutoProxyCreator。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;BeanNameAutoProxyCreator&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用BeanNameAutoProxyCreator可以通过指定一组容器内的目标对象对应的BeanName，将指定的一组拦截器应用到这些目标对象之上。&lt;/li&gt;
&lt;li&gt;配置案例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;target1&quot; class=&quot;...&quot;/&amp;gt;
&amp;lt;bean id=&quot;target2&quot; class=&quot;...&quot;/&amp;gt;

&amp;lt;bean id=&quot;mockTask&quot; class=&quot;...&quot;/&amp;gt;
&amp;lt;bean id=&quot;fakeTask&quot; class=&quot;...&quot;/&amp;gt;

&amp;lt;bean id=&quot;taskThrowsAdvice&quot; class=&quot;...TaskThrowsAdvice&quot;/&amp;gt;
&amp;lt;bean id=&quot;performanceInterceptor&quot; class=&quot;...PerformanceInterceptor&quot;&amp;gt;

&amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&amp;gt;
        &amp;lt;!--指定哪些bean自动生成代理对象--&amp;gt;
        &amp;lt;property name=&quot;beanNames&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;target1&amp;lt;/value&amp;gt;
                        &amp;lt;value&amp;gt;target2&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!--指定将要应用到目标对象的拦截器、Advice或者Advisor等--&amp;gt;
        &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;taskThrowsAdvice&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&amp;gt;
        &amp;lt;property name=&quot;beanNames&quot;&amp;gt;
                &amp;lt;!--使用*号进行通配--&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;mockTask*&amp;lt;/value&amp;gt;
                        &amp;lt;value&amp;gt;fakeTask*&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;performanceInterceptor&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&amp;gt;
        &amp;lt;property name=&quot;beanNames&quot;&amp;gt;
                &amp;lt;!--对于*通配符的情况下，也可以使用逗号隔开--&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;target*,*Task,*service&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                        &amp;lt;value&amp;gt;performanceInterceptor&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;DefaultAdvisorAutoProxyCreator&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;只需要在ApplicationContext中注册Bean即可，剩下的任务会由DefaultAdvisorAutoProxyCreator完成。将其注入容器之后，将会自动搜寻容器内的所有Advisor，然后根据各个Advisor所提供的拦截信息，为符合条件的容器中的目标对象生成相应的代理对象。DefaultAdvisorAutoProxyCreator只对Advisor有效，因为只有Advisor才既有Pointcut信息捕捉符合条件的目标对象，又有相应的Advice。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&amp;gt;
                &amp;lt;!--设置对象使用基于类的代理--&amp;gt;
                &amp;lt;property name=&quot;proxyTargetClass&quot;&amp;gt;
                        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;target1&quot; class=&quot;...&quot;/&amp;gt;
        &amp;lt;bean id=&quot;target2&quot; class=&quot;...&quot;/&amp;gt;

        &amp;lt;bean id=&quot;mockTask&quot; class=&quot;...&quot;/&amp;gt;
        &amp;lt;bean id=&quot;fakeTask&quot; class=&quot;...&quot;/&amp;gt;

        &amp;lt;bean id=&quot;logAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&amp;gt;
                &amp;lt;property name=&quot;pointcut&quot;&amp;gt;
                        ...
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;advice&quot;&amp;gt;
                        &amp;lt;bean id=&quot;performanceInterceptor&quot;
                                  class=&quot;org.springframework.mylearntest.aop.advice.perclass.PerformanceMethodInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;logAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&amp;gt;
                &amp;lt;property name=&quot;pointcut&quot;&amp;gt;
                        ...
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;advice&quot;&amp;gt;
                        &amp;lt;bean id=&quot;taskThrowsAdvice&quot; class=&quot;...TaskThrowsAdvice&quot;&amp;gt;&amp;lt;/bean&amp;gt;

                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;扩展AutoProxyCreator&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;可以在Spring AOP提供的AbstractAutoProxyCreator或者AbstractAdvisorAutoProxyCreator基础之上，实现相应的子类。&lt;/li&gt;
&lt;li&gt;Sprig AOP框架中有关自动代理的实现架构
&lt;ul&gt;&lt;li&gt;所有的AutoProxyCreator都是InstantiationAwareBeanPostProcessor，这种类型的BeanPostProcessor与普通的BeanPostProcessor有所不同。当Spring IoC容器检测到有InstantiationAwareBeanPostProcessor类型的BeanPostProcessor的时候，会直接通过InstantiationAwareBeanPostProcessor中的逻辑构造对象实例返回，而不会走正常的对象实例化流程。也就是“短路”。这样AutoProxyCreator会直接构造目标对象的代理对象返回，而不是原来的目标对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200723232128763-918015187.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AspectJAwareAdvisorAutoProxyCreator是Spring 2.0之后的AutoProxyCreator实现，也算是一个AutoProxyCreator的自定义实现。它还有一个子类AnnotationAwareAspectJAutoProxyCreator，可以根据Java5的注解捕获信息以完成自动代理。&lt;/li&gt;
&lt;li&gt;Spring AOP还支持基于Jakarta Commons Atrributes的元数据的自动代理机制，来提供拦截信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;targetsource&quot;&gt;TargetSource&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200727230047191-1011428346.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;TargetSource的作用：TargetSource它是目标对象的容器，当每个针对目标对象的方法调用经过层层拦截而到达调用链的终点的时候，就该调用目标对象上定义的方法了，这时候不是直接调用这个目标对象上的方法，而是通过某个TargetSource与实际目标对象之间交互，然后再调用从TargetSource中取得的目标对象上的相应的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TargetSource的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每次方法调用都会触发TargetSource的getTarget()方法，getTarget()方法将从相应的TargetSource实现类中取得具体的目标对象，这样，我们就可以控制每次方法调用作用到的具体对象实例。
&lt;ul&gt;&lt;li&gt;提供一个目标对象池，每次从TargetSource取得的目标对象都从这个目标对象池中取得。&lt;/li&gt;
&lt;li&gt;让一个TargetSource实现类持有多个目标对象的实例，然后按照某种规则，在每次方法调用时，返回相应的目标对象实例。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;还可以让TargetSource只持有一个目标对象，通常ProxyFactory或者ProyxFactoryBean处理目标对象的方式也是如此，它们内部会构造一个org.springframework.aop.target.SingletonTargetSource实例，而SingletonTargetSource则会针对每次方法调用返回同一个目标对象的实例引用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;targetsource实现类&quot;&gt;TargetSource实现类&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;SingletonTargetSource&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;org.springframework.aop.target.SingletonTargetSource是使用最多的TargetSource实现类，虽然我们可能并不知道。因为通过ProxyFactory的setTarget()设置完目标对象之后，ProxyFactory内部会自行使用一个SingletonTargetSource对设置的目标对象进行封装。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200727225806720-1621121446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;PrototypeTargetSource&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;target&quot; class=&quot;org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask&quot;
                  scope=&quot;prototype&quot;/&amp;gt;

        &amp;lt;bean id=&quot;prototypeTargetSource&quot; class=&quot;org.springframework.aop.target.PrototypeTargetSource&quot;&amp;gt;
                &amp;lt;property name=&quot;targetBeanName&quot;&amp;gt;
                        &amp;lt;value&amp;gt;target&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;targetProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
                &amp;lt;property name=&quot;targetSource&quot;&amp;gt;
                        &amp;lt;ref bean=&quot;prototypeTargetSource&quot;/&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                        &amp;lt;list&amp;gt;
                                &amp;lt;value&amp;gt;anyInterceptor&amp;lt;/value&amp;gt;
                        &amp;lt;/list&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;目标对象的bean定义声明必须为prototype。&lt;/li&gt;
&lt;li&gt;通过targetBeanName属性指定目标对象的bean定义名称，而不是引用。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;HotSwappableTargetSource&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用HotSwappableTargetSource封存目标对象，可以让我们在应用程序运行的时候，根据某种特定条件，动态地替换目标对象类的具体实现，比如，IService有多个实现类，如果程序启动之后，默认的IService实现类出现了问题，我们可以马上切换到Iservice的另一个实现上，而所有这些对于调用者来说都是透明的。&lt;/li&gt;
&lt;li&gt;使用方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

        &amp;lt;bean id=&quot;task&quot; class=&quot;org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask&quot;&amp;gt;

        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;hotSwapTargetSource&quot; class=&quot;org.springframework.aop.target.HotSwappableTargetSource&quot;&amp;gt;
                &amp;lt;constructor-arg&amp;gt;
                        &amp;lt;ref bean=&quot;task&quot;/&amp;gt;
                &amp;lt;/constructor-arg&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;taskProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
                &amp;lt;property name=&quot;targetSource&quot; ref=&quot;hotSwapTargetSource&quot;/&amp;gt;
                &amp;lt;property name=&quot;interceptorNames&quot;&amp;gt;
                        &amp;lt;list&amp;gt;
                                &amp;lt;value&amp;gt;performanceMethodInterceptor&amp;lt;/value&amp;gt;
                        &amp;lt;/list&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;performanceMethodInterceptor&quot;
                  class=&quot;org.springframework.mylearntest.aop.advice.perclass.PerformanceMethodInterceptor&quot;/&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.hotswaptargetsource;

import org.junit.Assert;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.target.HotSwappableTargetSource;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.mylearntest.aop.weaver.baseoninterface.ITask;

import java.util.Date;

/**
 * @Author: whalefall
 * @Date: 2020/7/26 19:47
 */
public class Test4HotSwappableTargetSource {
        public static void main(String[] args) throws Exception {
                ApplicationContext context = new ClassPathXmlApplicationContext(&quot;hotswappabletargetsource\\hotSwappableTargetSource.xml&quot;);
                Object proxy = context.getBean(&quot;taskProxy&quot;);
                Object initTarget = ((Advised)proxy).getTargetSource().getTarget();

                HotSwappableTargetSource hotSwappableTargetSource = (HotSwappableTargetSource)context.getBean(
                                &quot;hotSwapTargetSource&quot;);
                Object oldTarget = hotSwappableTargetSource.swap(new ITask() {
                        @Override
                        public void execute(Date date) {
                                System.out.println(&quot;old target generated by hotSwapTargetSource&quot;);
                        }
                });

                Object newTarget = ((Advised)proxy).getTargetSource().getTarget();

                // initTarget = org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask@72967906
                // oldTarget = org.springframework.mylearntest.aop.weaver.baseoninterface.MockTask@72967906
                // newTarget = org.springframework.mylearntest.aop.weaver.hotswaptargetsource
                // .Test4HotSwappableTargetSource$1@5b8dfcc1

                Assert.assertSame(initTarget,oldTarget);
                Assert.assertNotSame(initTarget,newTarget);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;CommonsPoolTargetSource&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;某些时候，我们可能想返回有限数目的目标对象实例，这些目标对象实例的地位是平等的，就好像数据库连接池中的那些Connection一样，我们可以提供一个目标对象的对象池，然后让某个TargetSource实现每次都从这个对象池中取得目标对象。&lt;/li&gt;
&lt;li&gt;如果不能使用Jakarta Commons Pool，那么也可以通过扩展org.springframework.aop.target.AbstractPoolingTargetSource类，实现相应的提供对象池化的功能的TargetSource。&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;5&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ThreadLocalTargetSource&lt;br/&gt;如果想为不同的线程调用提供不同的目标对象，那么可以使用org.springframework.aop.target.ThreadLocalTargetSource。它可以保证各自线程上目标对象的调用，可以被分配到当前线程对应的那个目标对象的实例上。其实，ThreadLocalTargetSource无非就是对JDK标准的ThreadLocal进行了简单的封装而已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义TargetSource&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.selfdefinetargetsource;

import org.springframework.aop.TargetSource;
import org.springframework.mylearntest.aop.weaver.baseoninterface.ITask;

/**
 * @Author: whalefall
 * @Date: 2020/7/27 22:27
 */
@SuppressWarnings(&quot;rawtypes&quot;)
public class AlternativeTargetSource implements TargetSource {
        private ITask alternativeTask1;
        private ITask alternativeTask2;

        private int counter;

        public AlternativeTargetSource(ITask task1, ITask task2) {
                this.alternativeTask1 = task1;
                this.alternativeTask2 = task2;
        }

        @Override
        public Object getTarget() throws Exception {
                try {
                        if (counter % 2 == 0)
                                return alternativeTask2;
                        else
                                return alternativeTask1;
                } finally {
                        counter ++;
                }
        }

        @Override
        public  Class getTargetClass() {
                return ITask.class;
        }

        @Override
        public boolean isStatic() {
                return false;
        }

        @Override
        public void releaseTarget(Object arg0) throws Exception {

        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.mylearntest.aop.weaver.selfdefinetargetsource;

import org.springframework.aop.TargetSource;
import org.springframework.aop.framework.ProxyFactory;
import org.springframework.mylearntest.aop.weaver.baseoninterface.ITask;

import java.util.Date;

/**
 * @Author: whalefall
 * @Date: 2020/7/27 22:33
 */
public class Test4AlternativeTargetSource {
        public static void main(String[] args) {
                ITask task1 = new ITask() {
                        @Override
                        public void execute(Date date) {
                                System.out.println(&quot;execute in Task1&quot;);
                        }
                };

                ITask task2 = new ITask() {
                        @Override
                        public void execute(Date date) {
                                System.out.println(&quot;execute in Task2&quot;);
                        }
                };

                ProxyFactory pf = new ProxyFactory();
                TargetSource targetSource = new AlternativeTargetSource(task1,task2);
                pf.setTargetSource(targetSource);
                Object proxy = pf.getProxy();
                for (int i = 0; i &amp;lt; 100; i++) {
                        ((ITask)proxy).execute(new Date());
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;欢迎关注微信公众号哦~ ~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2023890/202007/2023890-20200721222259780-783079620.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Jul 2020 15:03:00 +0000</pubDate>
<dc:creator>WhaleFall541</dc:creator>
<og:description>本文相关代码(来自官方源码spring-test模块)请参见spring-demysify org.springframework.mylearntest包下。 统称能够实现AOP的语言为AOL，即(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whalefall541/p/13388295.html</dc:identifier>
</item>
</channel>
</rss>