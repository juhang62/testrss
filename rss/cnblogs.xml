<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>GitHub 热点速览 Vol.16：化身蒙娜丽莎和乔布斯对话 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12733520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12733520.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210035183-183247811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：妙趣横生，上周的 GitHub 热点的关键词。无论是让你化身为爱因斯坦开启会议脑暴模式 avatarify，还是和上周人人都是抠图师项目的同门项目 3D 照片修复：3d-photo-inpainting 都让人觉得，原来程序可以那么 interesting。除了趣味，本周的热点全靠 nbnhhsh 这个让人秒变 00 后解决各种缩写的小工具增添了一丝青春。除了趣味、青春，底蕴的头马最全中文诗歌古典文集数据库——chinese-poetry 表现也不俗，除了诗词歌赋你也可以了解唐宋诗词中高频词为何，知否知否，Spring 主题能否带你开启 Java 新世界大门就在本周的#Spring#主题模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 3D 照片修复：3d-photo-inpainting&lt;/li&gt;
&lt;li&gt;1.2 视频聊天：Zipcall - Decentralized Video Chat&lt;/li&gt;
&lt;li&gt;1.3 30 天吃掉 TensorFlow2.0：eat_tensorflow2_in_30_days&lt;/li&gt;
&lt;li&gt;1.4 社交追踪：opentrace-ios&lt;/li&gt;
&lt;li&gt;1.5 视频头像变身：avatarify&lt;/li&gt;
&lt;li&gt;1.6 xmsl 翻译机：nbnhhsh&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 追踪 bug：git-bug&lt;/li&gt;
&lt;li&gt;2.2 Python 设计的背后原理：wtfpython-cn&lt;/li&gt;
&lt;li&gt;2.3 算法 js 版：javascript-algorithms&lt;/li&gt;
&lt;li&gt;2.4 最全中文诗歌古典文集数据库：chinese-poetry&lt;/li&gt;
&lt;li&gt;2.5 推特白嫖党：twint&lt;/li&gt;
&lt;li&gt;2.6 云原生服务：Cortex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #Spring#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 Spring Boot &amp;amp; MyBatis的种子项目：spring-boot-api-project-seed&lt;/li&gt;
&lt;li&gt;3.2 Spring Boot 专栏：SpringBoot-Labs&lt;/li&gt;
&lt;li&gt;3.3 分布式敏捷开发：zheng&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;11-3d-照片修复：3d-photo-inpainting&quot;&gt;1.1 3D 照片修复：3d-photo-inpainting&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3d-photo-inpainting 是一种将单个 RGB-D 输入图像转换为 3D 照片的方法，即这是一种新的视图合成的多层表示，其中包含了原始视图中被遮挡区域的幻觉颜色和深度结构。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/vt-vl-lab/3d-photo-inpainting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210101302-1197570320.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-视频聊天：zipcall---decentralized-video-chat&quot;&gt;1.2 视频聊天：Zipcall - Decentralized Video Chat&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zipcall - Decentralized Video Chat 是一个基于 Twilio STUN / TURN 的 WebRTC 视频聊天系统。Zipcall 提供了传统技术无法提供的高质量视频和超低延迟。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/ianramzy/decentralized-video-chat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210118752-774438354.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13-脸部检测：dbface&quot;&gt;1.3 脸部检测：DBFace&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DBFace 是一个用于面部检测的实时、单级检测器，具有更快的速度和更高的精度。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/dlunion/DBFace&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210139163-949592831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-社交追踪：opentrace-ios&quot;&gt;1.4 社交追踪：opentrace-ios&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;社交追踪：opentrace-ios 是 BlueTrace 的开源参考实现。BlueTrace 是一种隐私保护协议，用于社区驱动的跨边界联系人跟踪。它允许参与的设备记录彼此的蓝牙接触，以便在保护用户个人数据和隐私的同时方便流行病学接触者的追踪。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/opentrace-community/opentrace-ios&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;15-视频头像变身：avatarify&quot;&gt;1.5 视频头像变身：avatarify&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1950+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了它，你就是爱因斯坦的化身。视频头像变身：avatarify 是一个可变更 Zoom、Skype 等视频软件视频人头像的工具，当你在说话时，你可切换成任意一个你设定的人物头像，例如：蒙娜丽莎。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/alievk/avatarify&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210154333-1915581739.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;16-xmsl-翻译机：nbnhhsh&quot;&gt;1.6 xmsl 翻译机：nbnhhsh&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;xmsl 翻译机：nbnhhsh 「能不能好好说话？」 拼音首字母缩写翻译工具，社交平台上通过拼音首字母缩写指代特定词句的情况越来越多，为了让常人勉强能理解这一门另类沟通方式、做了这一个划词翻译油猴脚本。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/itorr/nbnhhsh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210213406-1974973169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;21-追踪-bug：git-bug&quot;&gt;2.1 追踪 bug：git-bug&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;git-bug 是一个错误跟踪器，特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;已完全嵌入 git：只需在 git 存储库中安装错误跟踪器&lt;/li&gt;
&lt;li&gt;分布式：使用常规 git 远程进行协作，推送和拉出错误&lt;/li&gt;
&lt;li&gt;离线工作：上天下海都在读写 bug&lt;/li&gt;
&lt;li&gt;防止供应商锁定：即便常规服务已关闭或挂了，都有完整备份&lt;/li&gt;
&lt;li&gt;快速：列出错误或打开错误仅需几毫秒&lt;/li&gt;
&lt;li&gt;不会污染项目：不在项目中添加任何文件&lt;/li&gt;
&lt;li&gt;与现有工具集成：使用你喜欢的 UI（CLI，终端，Web）或通过 CLI 或 GraphQL API 与现有工具集成&lt;/li&gt;
&lt;li&gt;与其他错误跟踪器的桥梁：使用桥梁导入和导出至其他跟踪器。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/MichaelMure/git-bug&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210232534-1529448039.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-python-设计的背后原理：wtfpython-cn&quot;&gt;2.2 Python 设计的背后原理：wtfpython-cn&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python 是设计优美的解释型高级语言，有让程序员感到舒适的特性。但有时候，Python 的一些输出结果对于初学者来说似乎并不是那么一目了然。&lt;br/&gt;这个有趣的项目收集 Python 中难以理解和反人类的例子以及鲜为人知的功能特性，讨论这些现象背后的原理。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/leisurelicht/wtfpython-cn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210302741-1474890878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-算法-js-版：javascript-algorithms&quot;&gt;2.3 算法 js 版：javascript-algorithms&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法 js 版：javascript-algorithms 包含了多种基于 JavaScript 的算法与数据结构。每种算法和数据结构都有自己的 README，包含相关说明和链接，以便进一步阅读 (还有 YouTube 视频) 。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/trekhleb/javascript-algorithms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;24-最全中文诗歌古典文集数据库：chinese-poetry&quot;&gt;2.4 最全中文诗歌古典文集数据库：chinese-poetry&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;知否知否，最全中文诗歌古典文集数据库：chinese-poetry 收录唐宋两朝近一万四千古诗人，接近 5.5 万首唐诗加 26 万宋诗。两宋时期 1564 位词人，21050 首词。该项目还针对诗词进行词云分析，罗列了唐诗、宋词高频词。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/chinese-poetry/chinese-poetry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;25-推特白嫖党：twint&quot;&gt;2.5 推特白嫖党：twint&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;推特白嫖党，tweet 爬取：twint 是一个用 Python 实现的、无需使用 Twitter API、匿名也可获取用户的关注者，关注者，推文等内容的工具。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/twintproject/twint&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210323555-1194049643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-云原生服务：cortex&quot;&gt;2.6 云原生服务：Cortex&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生服务：Cortex 是一个开源平台，用于将机器学习模型部署为生产 Web 服务。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多种框架：支持 TensorFlow，PyTorch，scikit-learn，XGBoost 等。&lt;/li&gt;
&lt;li&gt;自动缩放： 自动缩放 API 以处理生产工作负载。&lt;/li&gt;
&lt;li&gt;CPU / GPU支持： Cortex可以在CPU或GPU基础架构上运行推理。&lt;/li&gt;
&lt;li&gt;竞价型实例：支持 EC2 竞价型实例。&lt;/li&gt;
&lt;li&gt;滚动更新：无需中断即可更新已部署的 API。&lt;/li&gt;
&lt;li&gt;日志流：将日志从部署的模型流到 CLI。&lt;/li&gt;
&lt;li&gt;预测监视：监视网络指标并跟踪预测。&lt;/li&gt;
&lt;li&gt;配置简单：在单个 cortex.yaml 文件中定义部署。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/cortexlabs/cortex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-本周-github-trending-spring主题的主力军&quot;&gt;3. 本周 GitHub Trending #Spring#主题的主力军&lt;/h2&gt;
&lt;p&gt;学 Java 不知 Spring 好比一个程序员不知算法一般，在本期的 GitHub 热点，小鱼干为你选择了 3 个高星 Spring 项目，希望帮你开启 Spring 之门~~&lt;/p&gt;
&lt;h3 id=&quot;31-spring-boot--mybatis的种子项目：spring-boot-api-project-seed&quot;&gt;3.1 Spring Boot &amp;amp; MyBatis的种子项目：spring-boot-api-project-seed&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot API Project Seed 是一个基于Spring Boot &amp;amp; MyBatis的种子项目，用于快速构建中小型API、RESTful API项目，该种子项目已经有过多个真实项目的实践，稳定、简单、快速，使我们摆脱那些重复劳动，专注于业务代码的编写，减少加班。下面是一个简单的使用演示，看如何基于本项目在短短几十秒钟内实现一套简单的API，并运行提供服务。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/lihengming/spring-boot-api-project-seed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;32-spring-boot-专栏：springboot-labs&quot;&gt;3.2 Spring Boot 专栏：SpringBoot-Labs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个涵盖六个专栏：Spring Boot 2.X、Spring Cloud、Spring Cloud Alibaba、Dubbo、分布式消息队列、分布式事务的仓库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/YunaiV/SpringBoot-Labs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;33-分布式敏捷开发：zheng&quot;&gt;3.3 分布式敏捷开发：zheng&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于 Spring+SpringMVC+Mybatis 分布式敏捷开发系统架构，提供整套公共微服务服务模块：内容管理、支付中心、用户管理（包括第三方）、微信平台、存储系统、配置中心、日志分析、任务和通知等，支持服务治理、监控和追踪，努力为中小型企业打造全方位 J2EE 企业级开发解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/shuzheng/zheng&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 16 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200419210420031-154004469.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 20 Apr 2020 00:51:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>摘要：妙趣横生，上周的 GitHub 热点的关键词。无论是让你化身为爱因斯坦开启会议脑暴模式 avatarify，还是和上周人人都是抠图师项目的同门项目 3D 照片修复：3d photo inpain</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12733520.html</dc:identifier>
</item>
<item>
<title>如何有效的读一本书？各位读书人，确定自己真的会读书吗？ - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/12735762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/12735762.html</guid>
<description>&lt;p&gt;不知道大家有没有这样的经历，经常想要看完一本书，却总是半途而废。哪怕最后硬着头皮看完，也感觉收获无几。&lt;/p&gt;
&lt;p&gt;如果你有这种情况，那么，你并未掌握读书的方法和技巧，你只是学会了“看书看文字”而已。如果你不及时调整自己的读书方法，继续这样“看书”，那还不如翻翻新华字典，起码还可以认识几个新字。&lt;/p&gt;
&lt;h2 id=&quot;1看书和读书&quot;&gt;1.看书和读书&lt;/h2&gt;
&lt;p&gt;看书和读书是完全不同的状态，看书很简单，就像看小说，看电视，一遍过去，再过一段时间回忆，基本已经忘光了。&lt;/p&gt;
&lt;p&gt;而读书则不尽相同，读书需细细品味。在阅读的过程中，产生自己的理解和思考，能理解或者记忆大部分的要点内容。这就是看书和读书本质上的区别。&lt;/p&gt;
&lt;h2 id=&quot;2-要怎么读书&quot;&gt;2. 要怎么读书&lt;/h2&gt;
&lt;h3 id=&quot;21-怎么读纸质书&quot;&gt;2.1 怎么读纸质书&lt;/h3&gt;
&lt;p&gt;有朋友问我，要怎么才能算读书呢，读书有什么方法呢？我个人认为：&lt;/p&gt;
&lt;p&gt;首先，读书不应当求快，有些人买书一次性买个七八本，给自己做好规划，这个月读完这本，下月读完那本。我觉得实在是没有必要。事实上也没人和你比赛，但有些人就是想快点把书看完，这样的行为不可取。&lt;/p&gt;
&lt;p&gt;其次，读书应当适当做些笔记，对于书中的概念性的东西，可以划一条直线。一些重点内容，你可以划波浪线，甚至可以用圆圈，五角星标记一些更重要的东西。&lt;/p&gt;
&lt;p&gt;或者，我还是建议你最好备用着便利贴。对于刚开始想要改变自己的人来说，便利贴对阅读质量提升大有好处。当你读到一些好的文字，可以适当的摘抄下来，当你有一些灵感和思考时，可以适当的记录下来。&lt;/p&gt;
&lt;p&gt;最后，我建议你，一本好书，要经常翻阅，温故而知新，经过一段时间的历练，你的眼界和胸怀再来看这本书，定然会有不一样的感受。&lt;/p&gt;
&lt;h3 id=&quot;22-电子书怎么办&quot;&gt;2.2 电子书怎么办&lt;/h3&gt;
&lt;p&gt;现在很多朋友获取知识的地方大多数来源于网络，以及各类读书APP。那么，问题来了，电子版怎么用便利贴呢？&lt;br/&gt;事实上，我们也可以做一些电子笔记。如你可以写一个word文档，记录每一章节大致的内容和自己的思考，下面是我看《 图解HTTP》 的笔记截图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202004/1692986-20200420085046751-1420967849.png&quot; alt=&quot;读图解HTTP&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-做笔记值得吗？&quot;&gt;2.3 做笔记值得吗？&lt;/h3&gt;
&lt;p&gt;很多人会觉得，做笔记是一件很麻烦的事情。事实上，我也很怕麻烦，但有句老话：“好记性不如烂笔头”。正如同登山，坐缆车和徒步，看到的风景，它能是一样的吗？这种亲手写下摘要和读后感的过程也绝不是简单的“流水账式操作”，写完之后就可以扔掉的。&lt;strong&gt;这些宝贵的内容，说不定正是将来某一天你能够派上用场的的知识储备。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把灵感记录在纸上，让思考书面化，让灵感脱离之前的抽象状态，会更容易将其理解消化，也能促使你把灵感用作创意材料，想用的时候就能信手拈来。&lt;/p&gt;
&lt;h2 id=&quot;3-笔记做好就够了吗？&quot;&gt;3. 笔记做好就够了吗？&lt;/h2&gt;
&lt;p&gt;NO,NO,NO! 否认三连！学会做笔记，做好读书笔记，会让你对书中的印象更加深刻，但做好笔记只是你学会读书的第一步。读书笔记并不是写完放好就万事大吉了。如果在读书时发现了感兴趣的内容，就应该扎实地多看几遍，偶尔还需要把读书笔记完完整整地翻一遍，了解自己到目前为止都读了什么书。&lt;/p&gt;
&lt;p&gt;做笔记的真正目的是 &lt;strong&gt;“通过重读笔记提升自我”&lt;/strong&gt;。读书的最终目的就是“活用”，或者称为：“学以致用”。笔记是一种思维工具，帮助你实现从读书到独创的思维飞跃。重读笔记的时候，也要积极输出思想，促进自己的书本知识的内化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202004/1692986-20200420085046909-1732194231.png&quot; alt=&quot;想法加工&quot;/&gt;&lt;br/&gt;没有加工过的想法会消失，而经过加工后的想法，​可以装进袋子里，灵活利用。​&lt;/p&gt;
&lt;p&gt;要知道，大部分的灵感，基本上是来源于信息的重组，当你过一段时间重读笔记后，也许会产生新的灵感火花。美国广告大师詹姆斯·韦伯·扬也在《创意的生成》中提到：所谓创意，只是把原有的元素重新组合而已。&lt;/p&gt;
&lt;p&gt;这样的反复输出，也可以说是在对自己灌输思想。而通过这样的过程，已经消化过的信息又经历了一次精细的咀嚼。&lt;/p&gt;
&lt;h2 id=&quot;4-建议&quot;&gt;4. 建议&lt;/h2&gt;
&lt;p&gt;读书，希望大家都由浅入深。开始不要读太晦涩难懂的，这样不仅浪费时间，而且会让自己失去对读书的兴趣。&lt;br/&gt;笔记，能把重点内容和自己的思考记录下来，或者整理成册，经常翻阅，效果更佳！&lt;br/&gt;重读，选择自己需要或感兴趣的章节，重新阅读和思考。&lt;br/&gt;习惯，养成读书，而不是看书的好习惯，相信你会有所收获！&lt;/p&gt;
&lt;p&gt;以后别再调侃“ 我读书少，你们不要骗我”了。如果你只是看书，那这句话对你来说，真的是“老铁，没毛病啊！”&lt;/p&gt;
&lt;p&gt;文章出自：一个曾经浪费大量时间看书的读书人。&lt;br/&gt;参考: &amp;lt;如何有效阅读一本书&amp;gt;&lt;/p&gt;
&lt;p&gt;公众号： 锅外的大佬 ，欢迎加群~&lt;br/&gt;博客地址： &lt;a href=&quot;http://www.developlee.top&quot;&gt;http://www.developlee.top&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 00:51:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>不知道大家有没有这样的经历，经常想要看完一本书，却总是半途而废。哪怕最后硬着头皮看完，也感觉收获无几。 如果你有这种情况，那么，你并未掌握读书的方法和技巧，你只是学会了“看书看文字”而已。如果你不及时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/12735762.html</dc:identifier>
</item>
<item>
<title> 千亿级平台技术架构：为了支撑高并发，我把身份证存到了JS里 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12735752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12735752.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;br/&gt;接着上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTg4NDQ1Mg==&amp;amp;mid=2247483784&amp;amp;idx=1&amp;amp;sn=e6c29fd3773aebea114d3be1b8af1a83&amp;amp;chksm=e98bfbc3defc72d5f36dc53abe64ca96fd99fefeeb5736a337075a3da25f029e7de9de07719e&amp;amp;token=878089764&amp;amp;lang=zh_CN#rd&quot;&gt;《千亿级互联网平台背后那些事-欲上青天揽明月》&lt;/a&gt;，今天我们来聊一聊关于用户隐私信息的事。
&lt;p&gt;随着时代及互联网的发展，人们对个人隐私越来越重视，但隐私信息泄露及滥用的问题依然屡见不鲜。之前有一份《中国个人信息安全和隐私保护报告》曾抽取100万份调查数据，&lt;strong&gt;80%用户遭遇隐私泄露&lt;/strong&gt;，还比如万豪在18年遭遇3.83亿隐私数据泄露后于2020年3月31日再次爆出520万客户信息泄露。这背后的缘由咱们就不做多讲，除了一些流氓公司的恶意行为，肯定还有很多的商业利益的驱使。今天我们来聊一聊开发人员该如何处理用户隐私，想起半年前在知乎上爆出的某省普通话水平测试查询系统开发人员把身份证直接写在了js里，有网友&lt;strong&gt;笑称这才是真正的前后端分离，支撑亿级并发完全不是事&lt;/strong&gt;。&lt;br/&gt;文章开始之前，先抛出一个&lt;strong&gt;小问题：除了姓名、身份证、银行卡、手机号外，你觉得还有哪些是用户的敏感信息，需要加密存储？&lt;/strong&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419211536904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么叫个人信息，哪些又算敏感信息？个人信息该如何存储，又该如何展示？&lt;strong&gt;游戏中的兑换码是不是敏感信息？住宿信息是不是敏感信息？&lt;/strong&gt;？作为一名优秀的开发人员，我们不能把目光仅仅聚焦在代码上，不能永远是产品经理或者项目经理让我这么做，还应该掌握所在行业的业务知识，包括法律及政策规范等，提升拓宽我们的业务知识面。&lt;/p&gt;

&lt;p&gt;关于信息系统建设这一块，国家及行业其实有很多的标准和规范的，比如国家标准全文公开系统（&lt;a href=&quot;http://openstd.samr.gov.cn/%EF%BC%89%EF%BC%89%E3%80%82%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%9C%80%E6%96%B0%E7%9A%84%E6%98%AF%E4%BB%8A%E5%B9%B4%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8AGB/T&quot;&gt;http://openstd.samr.gov.cn/））。关于个人信息，最新的是今年发布的《GB/T&lt;/a&gt; 35273-2020 信息安全技术-个人信息安全规范 》，将于&lt;strong&gt;2020-10-01正式实施&lt;/strong&gt;，取代老的标准GB/T 35273-2017。 整个规范文档主要体现了&lt;strong&gt;七大原则：权责一致原则、目的明确原则、选择同意原则、最少够用原则、公开透明原则、确保安全原则、主体参与原则&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200418233606112.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11-用户信息、敏感信息定义及判断依据&quot;&gt;1.1 ​用户信息、敏感信息定义及判断依据&lt;/h2&gt;
&lt;h3 id=&quot;111-个人信息&quot;&gt;1.1.1 个人信息&lt;/h3&gt;
&lt;p&gt;个人信息，personal information。指以电子或者其他方式记录的能够单独或者与其他信息结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;识别：即从信息到个人，由信息本身的特殊性识别出特定自然人，个人信息应有助于识别出特定个人。&lt;/li&gt;
&lt;li&gt;关联：即从个人到信息，如已知特定自然人，由该特定自然人在其活动中产生的信息（如个人位置信息、个人通话记录、个人浏览记录等）即为个人信息。&lt;br/&gt;符合上述两种情形之一的信息，均应判定为个人信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;个人信息举例&lt;/strong&gt;：&lt;img src=&quot;https://img-blog.csdnimg.cn/20200418234027651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;个人信息举例&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注&lt;/strong&gt;：个人信息控制者通过个人信息或其他信息加工处理后形成的信息，例如，用户画像或特征标签，能够单独或者与其他信息结合识别特定自然人身份或者反映特定自然人活动情况的，也属于个人信息。&lt;/p&gt;
&lt;h3 id=&quot;112-个人敏感信息&quot;&gt;1.1.2 个人敏感信息&lt;/h3&gt;
&lt;p&gt;个人敏感信息，personal sensitive information。指一旦泄露、非法提供或滥用可能危害人身和财产安全，极易导致个人名誉、身心健康受到损害或歧视性待遇等的个人信息。通常情况下，&lt;strong&gt;14岁以下（含）儿童的个人信息和涉及自然人隐私的信息属于个人敏感信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;泄露：个人信息一旦泄露，将导致个人信息主体及收集、使用个人信息的组织和机构丧失对个人信息的控制能力，造成个人信息扩散范围和用途的不可控。某些个人信息在泄漏后，被以违背个人信息主体意愿的方式直接使用或与其他信息进行关联分析，可能对个人信息主体权益带来重大风险，应判定为个人敏感信息。例如，个人信息主体的身份证复印件被他人用于手机号卡实名登记、银行账户开户办卡等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;非法提供：某些个人信息仅因在个人信息主体授权同意范围外扩散，即可对个人信息主体权益带来重大风险，应判定为个人敏感信息。例如，性取向、存款信息、传染病史等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;滥用：某些个人信息在被超出授权合理界限时使用（如变更处理目的、扩大处理范围等），可能对个人信息主体权益带来重大风险，应判定为个人敏感信息。例如，在未取得个人信息主体授权时，将健康信息用于保险公司营销和确定个体保费高低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;个人敏感信息举例&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200418235049698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;个人敏感信息举例&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注&lt;/strong&gt;：个人信息控制者通过个人信息或其他信息加工处理后形成的信息，如一旦泄露、非法提供或滥GB/T 35273—20206用可能危害人身和财产安全，极易导致个人名誉、身心健康受到损害或歧视性待遇等的，属于个人敏感信息。&lt;/p&gt;
&lt;h2 id=&quot;12-用户信息存储的注意事项&quot;&gt;1.2 ​用户信息存储的注意事项&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;个人信息存储时间最小化，超过个人信息存储期限后，应对个人信息进行删除或匿名化处理。&lt;/li&gt;
&lt;li&gt;传输和存储个人敏感信息时，应采用加密等安全措施；采用密码技术时宜遵循密码管理相关国家标准。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;个人生物识别信息应与个人身份信息分开存储&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;原则上&lt;strong&gt;不应存储原始个人生物识别信息（如样本、图像等）&lt;/strong&gt;，可采取的措施包括但不限于：仅存储个人生物识别信息的摘要信息；在采集终端中直接使用个人生物识别信息实现身份识别、认证等功能； 在使用面部识别特征、指纹、掌纹、虹膜等实现识别身份、认证等功能后删除可提取个人生物识别信息的原始图像。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个规范文件中，还提到了用户信息的使用、展示、第三方接入、安全管理等等，有兴趣的小伙伴可以自定搜索了解一下。&lt;/p&gt;

&lt;h2 id=&quot;21-用户敏感信息自动加解密&quot;&gt;2.1 用户敏感信息自动加解密&lt;/h2&gt;
&lt;p&gt;正如第一章节提到的，用户的真实姓名、手机号、银行卡号、包括住宿等敏感信息需要加密存储到数据库中，业务正常使用的时候再转化为明文数据。从技术实现角度来看，无非就是新增、编辑时进行加密，查询时解密，这样一个个操作起来还是比较low的，而且很可能哪天新增了一个方法又忘记加解密了。所以大部分会通过框架来实现，实现的原理无外乎反射机器+拦截器。接下来以Mybatis为例，原理如下图，具体可参考：&lt;a href=&quot;https://blog.csdn.net/weixin_39494923/article/details/91534658&quot;&gt;https://blog.csdn.net/weixin_39494923/article/details/91534658&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419214139567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;211-通过interceptor实现数据的自动加解密&quot;&gt;2.1.1 通过Interceptor实现数据的自动加解密&lt;/h3&gt;
&lt;p&gt;Mybatis默认提供了一个拦截器接口Interceptor，大部分Mybatis的增强工具都是通过该接口实现的。如果要实现自定义的拦截器，只需要实现 org.apache.ibatis.plugin.Interceptor 接口，该接口有三个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object intercept(Invocation invocation) throws Throwable;

Object plugin(Object target);

void setProperties(Properties properties);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先以自定义一个注解@Crypt，作用在字段上，用于告诉拦截器那个字段需要加解密。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target({ ElementType.FIELD,ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Crypt {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来添加一个自定义拦截器，selelct方法时进行解密，update和add方法时进行加密。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Intercepts({ @Signature(type = Executor.class, method = &quot;update&quot;, args = { MappedStatement.class, Object.class, }),
        @Signature(type = Executor.class, method = &quot;query&quot;, args = { MappedStatement.class, Object.class,
                RowBounds.class, ResultHandler.class }),
        @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = { Statement.class }) })
public class CryptInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object[] args = invocation.getArgs();
        if (args.length &amp;lt;= 0 || invocation.getMethod() == null || args[0] == null) {
            return invocation.proceed();
        }

        String methodName = invocation.getMethod().getName();
        if (&quot;update&quot;.equals(methodName) &amp;amp;&amp;amp; args[1] != null) {
            return this.interceptUpdate(invocation);
        } else if (&quot;query&quot;.equals(methodName) &amp;amp;&amp;amp; args[1] != null) {
            return this.interceptQuery(invocation);
        } else if (&quot;handleResultSets&quot;.equals(methodName)) {
            return this.interceptHandleResultSets(invocation);
        }
        return invocation.proceed();
    }

    private Object interceptHandleResultSets(Invocation invocation) throws Throwable {
        Object resultCollection = invocation.proceed();
        // 略 将resultCollection的对象中有@Crypt注解的Feild进行解密
        return newObject;
    }

    private Object interceptUpdate(Invocation invocation) throws Throwable {
        Object[] args = invocation.getArgs();
        Object args1Obj = args[1];
        // 略 将args1Obj的对象进行加密
        args[1] = newObject;
        return invocation.proceed();
    }
    
    private Object interceptQuery(Invocation invocation) throws Throwable {
        Object[] args = invocation.getArgs();
        Object condition = args[1];
        // 略 将condition对象进行解密
        args[1] = newObject;
        return invocation.proceed();
    }    
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;212-通过basetypehandler实现数据的自动加解密&quot;&gt;2.1.2 通过BaseTypeHandler实现数据的自动加解密&lt;/h3&gt;
&lt;p&gt;一般情况下不会通过Interceptor接口对Mybatis的请求进行拦截，除非类似于“读写分离”这样的一些复杂的需求。参见上面的mybatis的执行过程，我们发现最后一步调用了TypeHander，这个类的作用就是把数据库与实体之间进行类型转换，比如把MySql的varchar转为Java的Long，把Java的Integer转为Mysql的int，所以我们可以借助于BaseTypeHandler类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@Alias(&quot;CryptHandler&quot;)
@MappedTypes(value = {Crypt.class})
public class EncryptHandler extends BaseTypeHandler {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType)
        throws SQLException {
        ps.setString(i, encrypt(parameter.toString()));
    }

    @Override
    public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
        String columnValue = rs.getString(columnName);
        return decrypt(columnValue);
    }

    @Override
    public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        String columnValue = rs.getString(columnIndex);
        return decrypt(columnValue);
    }

    @Override
    public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        String columnValue = cs.getString(columnIndex);
        return decrypt(columnValue);
    }

    private String encrypt(String parameter) {
        // 加密
        return parameter;
    }

    private String decrypt(String columnValue) {
        // 解密
        return columnValue;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整 代码见上面，不做多讲。接下来需要告诉Mybatis哪些字段需要加解密，为了简化书写，定义一个类Crypt重命名为crypt，上面的类EncryptHandler也重命名为EncryptHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Alias(&quot;crypt&quot;)
public final class Crypt {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的两个类都放在cn.itmds.plugin目录下，配置yml文件告诉Mybatis读取重命名的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;mybatis:
  type-aliases-Package: cn.itmds.plugin.dbcrypt
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，假设有一张member表的realname(真实姓名)字段需要加解密，写起来就很简单了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; &amp;lt;sql id=&quot;memberConditionSql&quot;&amp;gt;
        &amp;lt;where&amp;gt;
            &amp;lt;if test=&quot;id != null&quot;&amp;gt;and id = #id}&amp;lt;/if&amp;gt;
            &amp;lt;!--这个地方只需要指定javaType=crypt，如果上面没有重命名，这个地方需要写成javaType= cn.itmds.plugin.dbcrypt.Crypt，写起来比较麻烦 --&amp;gt;
            &amp;lt;if test=realName != null&quot;&amp;gt;and real_name = #{realName,javaType=crypt}&amp;lt;/if&amp;gt;
        &amp;lt;/where&amp;gt;
    &amp;lt;/sql&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;    &amp;lt;resultMap id=&quot;memberDOResultMap&quot; type=&quot;MemberDO&quot;&amp;gt;
        &amp;lt;!--这个地方只需要指定typeHandler=CryptHandler，如果上面没有重命名，这个地方需要写成javaType= cn.itmds.plugin.dbcrypt.CryptHandler，写起来比较麻烦 --&amp;gt;
        &amp;lt;!--另外，只需要将需要解密的字段写到这个resultMap里即可，不需要写全部的字段，其他字段系统会自动映射为MemberDO --&amp;gt;
        &amp;lt;result column=&quot;phone&quot; property=&quot;phone&quot; typeHandler=&quot;CryptHandler&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;213-mybatisplus实现数据的自动加解密&quot;&gt;2.1.3 MybatisPlus实现数据的自动加解密&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyBatis-Plus只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。而且还支持Lambda表达式，通过对象来操作sql等，所以现在使用的人越来越多。那么它如何来实现数据的自动加解密呢，超级简单。实现原理和2.1.2一样，也是通过BaseTypeHandler来实现。&lt;/p&gt;
&lt;p&gt;1、增加&lt;code&gt;@TableField(typeHandler = EncryptHandler.class)&lt;/code&gt;，其中EncryptHandler就是2.1.2定义的&lt;code&gt;EncryptHandler.java&lt;/code&gt;，此时新增、修改时就实现了自动加密。&lt;br/&gt;2、在@TableName上设置&lt;code&gt;autoResultMap = true&lt;/code&gt;，此时就实现了返回值的自动解密。&lt;/p&gt;
&lt;p&gt;Done！示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@TableName(value = &quot;user_info&quot;,autoResultMap = true)
public class UserPO {

    /**  */
    @TableId(type = IdType.AUTO)
    private Long id;

    /** 真实姓名 */
    @TableField(typeHandler = EncryptHandler.class)
    private String realName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22-日志文件自动过滤用户敏感信息&quot;&gt;2.2 日志文件自动过滤用户敏感信息&lt;/h2&gt;
&lt;p&gt;为了便于开发调试及产线问题定位，开发框架基本都会定义日志拦截器，对所有的controller层和service层的方法进行拦截，打印详细等入参、出参。在2.1中我们提到了用户的敏感信息的加解密是在dao底层自动完成的，所以也就导致了日志中还会打印了用户的敏感信息，那么此时该如何处理呢？接下来提供一个完整的案例。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义一个注解@ServiceLog，可以作用在类上或者方法上。提供一个参数：ignore，默认为false。如果为true，表示该方法不需要打印日志。比如某一个类里有很多个方法需要日志，但其中某个方法是用于文件上传的或者定时任务每秒都会执行1次，这些场景下不需要打印日志，则可以设置ignore=true。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ServiceLog {

    boolean ignore() default false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;定义一个全局拦截器，打印入参、出参日志，在这里使用的是FastJson将对象转化为字符串。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Aspect
@Component
public class ServiceLogAspect {

        @Around(&quot;@within(cn.itmds.log.ServiceLog)&quot;)
    protected Object aroundJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature)joinPoint.getSignature();
        Method method = signature.getMethod();
        ServiceLog serviceLog = method.getAnnotation(ServiceLog.class);
        if (null != serviceLog &amp;amp;&amp;amp; serviceLog.ignore()) {
            return joinPoint.proceed();
        }
        long beginTime = System.currentTimeMillis();
        Class clazz = joinPoint.getTarget().getClass();
        String methodName = clazz.getSimpleName() + &quot;.&quot; + method.getName();
        // 打印请求所有的入参
        log.info(&quot;Begin|{}|{}&quot;, methodName, jsonString(joinPoint.getArgs()));

        Object result = null;
        try {
            result = joinPoint.proceed();
        } finally {
                // 打印所有的出参
            log.info(&quot;End|{}|{}ms|{}&quot;, methodName, System.currentTimeMillis(),
                 - beginTime, jsonString(result));
        }
        return result;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;增加一个配置项，定义需要过滤的敏感信息，比如真实姓名、手机号、身份证、密码等&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;logging:
  sensitiveChars: realName,phoneNumber,idCard,mail,password
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;接下来，我们可以利用FastJSON的过滤器特性来实现日志的过滤。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private ValueFilter valueFilter = (object, name, value) -&amp;gt; {
        if (null == value || &quot;&quot;.equals(value)) {
            return value;
        }

        if (value instanceof byte[]) {
            // 如果是byte字节，直接打印长度
            return &quot;byte length:&quot; + ((byte[])value).length;
        } else if (value instanceof String) {
            // 在该方法里检查name，如果name包含我们配置的敏感信息，则将value设置为加*隐藏。
            return stringValueProcess(name, (String)value);
        } else {
            return value;
        }
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第二步拦截器的方法aroundJoinPoint中,对象转化为String时，使用FastJSON的过滤器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    protected String jsonString(Object object) {
        return JSON.toJSONString(object, valueFilter);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;Controller层同样，拦截所有的controller目录下的文件即可。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Around(&quot;execution(public * cn.itmds.controller..*(..) )&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Controller通过该方法实现时要注意，http请求和response请求有些字段是无法序列化的，所以务必要进行过滤。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; streamOf(T[] array) {
        return ArrayUtils.isEmpty(array) ? Stream.empty() : Arrays.asList(array).stream();
    }

//... 拦截器的方法中增加过滤
 List&amp;lt;Object&amp;gt; logArgs = (List)streamOf(args).filter((arg) -&amp;gt; {
                return !(arg instanceof HttpServletRequest) &amp;amp;&amp;amp; !(arg instanceof HttpServletResponse);
            }).collect(Collectors.toList());
// 打印请求所有的入参
log.info(&quot;Begin|{}|{}&quot;, methodName, jsonString(logArgs));

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-密码加密和《密码法》&quot;&gt;2.3 密码加密和《密码法》&lt;/h2&gt;
&lt;p&gt;关于密码，国家也是有一部《密码法》的，最近好像也在推广宣传。当然我们平时常说的用户名“密码”只是“口令”，并不是密码法中的“密码”。《密码法》中的密码使用范围包含二代身份证、电子签名、增值税发票密码区之类的，具体大家可以去看看全文，不做多讲。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419000255264.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;231-密码加密的注意事项&quot;&gt;2.3.1 密码加密的注意事项&lt;/h3&gt;
&lt;p&gt;现在的开发人员基本都具备一定的安全知识，很少有明文存储密码的了，甚至直接md5的也很少，大部分都开始采用sha1，sha256了，也有一些公司开始使用用Argon2&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Argon2 是一种慢哈希函数，在 2015 年获得 Password Hashing Competition 冠军，利用大量内存计算抵御GPU 和其他定制硬件的破解，提高哈希结果的安全性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里主要讲几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每一个密码都要加上不同的盐，确保相同的密码也产生不同的hash。比如两个人的密码都是abcd1234，生成的hash一定要是不同的。&lt;/li&gt;
&lt;li&gt;不要使用普通的随机算法生成盐，一定要使用CSPRNG（Cryptographically Secure Pseudo-Random Number Generator）；对应java就是Java.security.SecureRandom，对应C/C++ CryptGenRandom。&lt;/li&gt;
&lt;li&gt;有些系统使用用户的id、手机号等来作为盐加密密码，这其实不符合盐的生成规则要求。但对于一般性的安全性要求并不是那么高的网站，也基本能用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;232-使用bcrypt实现密码加密&quot;&gt;2.3.2 使用BCrypt实现密码加密&lt;/h3&gt;
&lt;p&gt;Bcrypt是一个跨平台的文件加密工具，SpringSecurity默认使用了该算法。如果项目中没有依然SpringSecurity，也可以单独引入jar包。 bcrypt算法与md5/sha算法有一个很大的区别，就是每次生成的hash值都是不同的，不需要我们自行指定盐。加密后的字符长度比较长，有60位，数据库字段设计时务必要注意。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) {
        BCryptPasswordEncoder bcrypt = new BCryptPasswordEncoder();
        String pwd = &quot;abcd1234&quot;;
        for (int i = 0; i &amp;lt; 5; i++) {
            String encodePwd = bcrypt.encode(pwd);
            boolean result = bcrypt.matches(pwd, encodePwd);
            System.out.println(encodePwd + &quot;|&quot; + result);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419215437708.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;加密后的字符串值组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;$是分割符，无意义；&lt;/li&gt;
&lt;li&gt;2a是bcrypt加密版本号；&lt;/li&gt;
&lt;li&gt;10是cost的值；&lt;/li&gt;
&lt;li&gt;后面的字符串中，前22位是salt值；再然后的字符串就是密码的密文了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有兴趣的可以看下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static String gensalt(int log_rounds, SecureRandom random) {
                if (log_rounds &amp;lt; MIN_LOG_ROUNDS || log_rounds &amp;gt; MAX_LOG_ROUNDS) {
                        throw new IllegalArgumentException(&quot;Bad number of rounds&quot;);
                }
                StringBuilder rs = new StringBuilder();
                byte rnd[] = new byte[BCRYPT_SALT_LEN];

                random.nextBytes(rnd);

                rs.append(&quot;$2a$&quot;);
                if (log_rounds &amp;lt; 10) {
                        rs.append(&quot;0&quot;);
                }
                rs.append(log_rounds);
                rs.append(&quot;$&quot;);
                encode_base64(rnd, rnd.length, rs);
                return rs.toString();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;233-dropbox密码加密存储防范&quot;&gt;2.3.3 Dropbox密码加密存储防范&lt;/h3&gt;
&lt;p&gt;Dropbox是提供文件在线存储的著名厂商，曾在其官方技术博客发表名为《How Dropbox securely stores your passwords》的文章，讲述了他们的用户密码加密存储方案。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419003256697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先使用sha512，将用户密码归一化为64字节hash值。因为两个原因：一个是Bcrypt算对输入敏感，如果用户输入的密码较长，可能导致Bcrypt计算过慢从而影响响应时间；另一个是有些Bcrypt算法的实现会将长输入直接截断为72字节，从信息论的角度讲，这导致用户信息的熵变小；&lt;/li&gt;
&lt;li&gt;然后使用Bcrypt算法。选择Bcrypt的原因，是Dropbox的工程师对这个算法更熟悉调优更有经验，参数选择的标准，是Dropbox的线上API服务器可以在100ms左右的时间可计算出结果。另外，关于Bcrypt和Scrypt哪个算法更优，密码学家也没有定论。同时，Dropbox也在关注密码hash算法新秀Argon2，并表示会在合适的时机引入；&lt;/li&gt;
&lt;li&gt;最后使用AES加密。因为Bcrypt不是完美的算法，所以Dropbox使用AES和全局密钥进一步降低密码被破解的风险，为了防止密钥泄露，Dropbox采用了专用的密钥保存硬件。Dropbox还提到了最后使用AES加密的另一个好处，即密钥可定时更换，以降低用户信息/密钥泄露带来的风险。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用户隐私保护，远不是开发人员加解密这么简单，还需要运营、运维团队各方面的配合，任重而道远！&lt;/p&gt;
&lt;p&gt;【人总要给自己留一些隐私的空间，就像你总是会站在你的影子前挡住了光的视线】&lt;br/&gt;People always want to give yourself some privacy space, just like you will always be standing in front of the shadow of you blocking the line of sight of the light.&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xinzhao/p/6035847.html&quot;&gt;https://www.cnblogs.com/xinzhao/p/6035847.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39494923/article/details/91534658&quot;&gt;https://blog.csdn.net/weixin_39494923/article/details/91534658&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;架构师，十年戎【码】，老【叔】开花。个人微信号：qiaojs，关注架构设计、大数据、微服务、技术管理。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200412182950207.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 00:47:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>这才是真正的前后端分离，支撑亿级并发完全不是事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12735752.html</dc:identifier>
</item>
<item>
<title>Python工业互联网监控项目实战3—websocket to UI - wuch</title>
<link>http://www.cnblogs.com/haozi0804/p/12725449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haozi0804/p/12725449.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　本小节继续演示如何在&lt;/span&gt;Django&lt;span&gt;项目中采用&lt;/span&gt;早期websocket&lt;span&gt;技术&lt;/span&gt;原型&lt;span&gt;来实现把&lt;/span&gt;OPC&lt;span&gt;服务端数据实时推送到&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;端，让监控页面&lt;/span&gt;在另一种技术方式下，实时显示现场设备的工艺数据变化情况。本例我们仍然采用比较轻量级的dwebsocket组件。&lt;/p&gt;
&lt;h4&gt;1. &lt;strong&gt;&lt;span&gt;安装&lt;/span&gt;dwebsocket&lt;span&gt;组件&lt;/span&gt;&lt;/strong&gt; &lt;/h4&gt;
&lt;p&gt;　　安装命令：&lt;strong&gt;pip install dwebsocket  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1. &lt;strong&gt;dwebsocket&lt;span&gt;使用方法&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　如果你想为一个单独的视图处理一个websocket连接可以使用&lt;span&gt;accept_websocket&lt;/span&gt;装饰器，它会将标准的&lt;span&gt;HTTP&lt;/span&gt;请求路由到视图中。使用&lt;span&gt;require_websocke&lt;/span&gt;装饰器只允许使用&lt;span&gt;WebSocket&lt;/span&gt;连接，会拒绝正常的&lt;span&gt;HTTP&lt;/span&gt;请求。  &lt;/p&gt;
&lt;p&gt;　　在设置中添加设置MIDDLEWARE_CLASSES=dwebsocket.middleware.WebSocketMiddleware这样会拒绝单独的视图使用websocket，必须加上&lt;span&gt;accept_websocket&lt;/span&gt; 装饰器。 &lt;/p&gt;
&lt;p&gt; 　　设置WEBSOCKET_ACCEPT_ALL=True可以允许每一个单独的视图实用&lt;span&gt;websockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1.2. &lt;strong&gt;常用方法和属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.request.is_websocket()　　如果是个websocket&lt;span&gt;请求返回&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;，如果是个普通的&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;请求返回&lt;/span&gt;&lt;span&gt;False,&lt;/span&gt;&lt;span&gt;可以用这个方法区分它们。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　2.request.websocket&lt;span&gt;　　在一个&lt;/span&gt;websocket&lt;span&gt;请求建立之后，这个请求将会有一个&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;属性，用来给客户端提供一个简单的&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;通讯，如果&lt;/span&gt;&lt;span&gt;request.is_websocket()&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;，这个属性将是&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　3.WebSocket.wait()&lt;span&gt;　　返回一个客户端发送的信息，在客户端关闭连接之前他不会返回任何值，这种情况下，方法将返回&lt;/span&gt;None &lt;/p&gt;
&lt;p&gt;　　4.WebSocket.read()&lt;span&gt;　　如果没有从客户端接收到新的消息，&lt;/span&gt;read&lt;span&gt;方法会返回一个新的消息，如果没有，就不返回。这是一个替代&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;的非阻塞方法&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; 　　5.WebSocket.count_messages()　　返回消息队列数量 &lt;/p&gt;
&lt;p&gt;　　6.WebSocket.has_messages()&lt;span&gt;　　如果有新消息返回&lt;/span&gt;True&lt;span&gt;，否则返回&lt;/span&gt;&lt;span&gt;False&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　7.WebSocket.send(message)　　向客户端发送消息 &lt;/p&gt;
&lt;p&gt;　　8.WebSocket.__iter__()　　websocket&lt;span&gt;迭代器&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;dwebsocket使用起来比较简单，增加一个简单的服务端url和重构UI代码；UI代码创建一个websocket连接并在onmessage 事件里处理返回的数据即可，不用花费多大的代价就能快速让监控页面升级到一个新的方式下，下面看代码演进吧。&lt;/p&gt;
&lt;h4&gt;2.&lt;strong&gt;&lt;span&gt;重构服务端代码&lt;/span&gt;——&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;增加一个推送的&lt;/span&gt;websocket url&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　使用accept_websocket&lt;span&gt;装饰器在&lt;/span&gt;Collector APP&lt;span&gt;的&lt;/span&gt;views&lt;span&gt;文件中增加一个&lt;/span&gt;pushCollector&lt;span&gt;的方法，实现&lt;/span&gt;UI端连接上服务端后，服务端使用websocket主动向UI界面推送实时设备工艺数据，函数代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; dwebsocket.decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; accept_websocket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; OpenOPC
@accept_websocket   
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pushCollectorData(request):

    tank4C9&lt;/span&gt;=&lt;span&gt;{            
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#反应罐&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备运行状态&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OverheadFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:0 ,&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'顶流量',&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButtomsFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;'低流量'&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功率&lt;/span&gt;
&lt;span&gt;    }
    Collector&lt;/span&gt;=&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#采集器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:[tank4C9],
            } 
    Collector&lt;/span&gt;=&lt;span&gt;{
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#采集器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:[tank4C9],
         }  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; request.is_websocket():
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:   

                opc &lt;/span&gt;=&lt;span&gt; OpenOPC.client()
                opc.connect(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Matrikon.OPC.Simulation&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                tank4C9[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OverheadFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]= opc[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Random.Int1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                tank4C9[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButtomsFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]= opc[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Random.Int2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                tank4C9[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]= opc[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Random.Int4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                opc.close()
                request.websocket.send(\
                    json.dumps( {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[Collector],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;}))
                time.sleep(&lt;/span&gt;2&lt;span&gt;)
 
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            client.disconnect()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　解读：上文代码与原来的主要差别就是从被动刷新（UI请求后）读去opc服务的tag位号值，变成间隔time.sleep(2)秒读取数据后通过request.websocket.send到UI端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. &lt;/span&gt;&lt;strong&gt;重构&lt;/strong&gt;&lt;strong&gt;UI&lt;span&gt;端代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;这里&lt;/span&gt;django&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Flask&lt;/span&gt;&lt;span&gt;的差别就是无须新建一个新的项目，当前项目我们就可以&lt;/span&gt;&lt;span&gt;通过重构&lt;/span&gt;tank4C9.html页面代码来使用websocket实时推送功能。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;重构后&lt;/span&gt;tank4C9.html代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        Status:    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divStatus&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        OverheadFlow:    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divOverheadFlow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        ButtomsFlow:    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divButtomsFlow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        Power:    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divPower&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        pushCount:    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divpushCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JQuery 代码入口&lt;/span&gt;
&lt;span&gt;        $(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebSocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; window) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接server--TagCurValue&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ws &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocket(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws://127.0.0.1:8090/pushCollector/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                ws.onmessage &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (evt) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收数据&lt;/span&gt;
&lt;span&gt;                    d &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(evt.data);
                    collector&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.rows[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; collector.DeviceList.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
                        device &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; collector.DeviceList[i]
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#divStatus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(device.Status);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#divOverheadFlow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(device.OverheadFlow);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#divButtomsFlow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(device.ButtomsFlow);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#divPower&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(device.Power);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#divpushCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(device.Count);

                    }                   

                };
            } 
        });

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;　　&lt;/strong&gt;解读：UI端代码通过ws.onmessage事件更新页面显示，对照上一张的ajax轮询模式的代码，代码的主体结构和功能并没有大的变化，只是采用了一种的新的数据传递方式而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　注意&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　var ws = new WebSocket(&quot;ws://127.0.0.1:8090/pushCollector/&quot;);&lt;/p&gt;
&lt;p&gt;　　pushCollector/ url&lt;span&gt;最后那个“&lt;/span&gt;/”，这个点是&lt;span&gt;django&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;flask&lt;/span&gt;&lt;span&gt;的一个差别，否则我们创建这个&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;时会收到&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;&lt;span&gt;错误提示！&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 发布pushCollectorData url&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　项目的&lt;/span&gt;urls&lt;span&gt;发布这新的&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;接口地址，这例我们保留原来的getCollectorData，代码如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Uncomment next two lines to enable admin:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;from django.contrib import admin&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Collector &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Uncomment the next line to enable the admin:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;path('admin/', admin.site.urls)&lt;/span&gt;
&lt;span&gt;
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tank4C9/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.tank4C9),
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;getCollectorData/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.getCollectorData),
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pushCollectorData/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.pushCollectorData),
    
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 调试&lt;strong&gt;运行&lt;/strong&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202004/67400-20200418130315962-1721865501.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5. &lt;strong&gt;小结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;本小节我们通过websocket的主动推送方式，完成了实时监控画面从后台服务端主动推送到UI端的技术架构迭代，这个过程我们也演示了项目迭代的方式，迭代推进项目功能点的好处非常明显也就是在一个版本满足需求的前提下，可以相对从容的采用新的技术和方案升级产品改进性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例子我们保留了原来的getCollectorData url，实际的项目开发也是通过增加新推送方法的方式来组织进行的，这样新的升级也同时满足原有ajax模式的后台访问方式。从而避免升级过程中，前后台升级版本不一致导致原有页面不能正常访问，避免系统已发布就“崩溃”的“灾难”问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里多说一下敏捷编程下的“小步快跑，快速迭代”模式下，一些团队遇到的问题就是一开始极简设计满足当下要求，然后在不断功能迭代过程中项目产品架构技术快速老化，可是团队还是不断的增加功能点，而没有人员关心技术架构优化和调整。最终，导致问题越积越多，架构越来越难用，产品构建越来越慢，最后等待一次彻底的项目“重构”。一些“好的”项目应该在过程中逐步演化代码结构来满足不断扩张的功能需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　敏捷编程的前提是要有一套体系来做保证的，需求管理、代码重构、单元测试等等，比如：代码重构在敏捷编程项目过程中就非常重要，一开始简单满足需求，一旦发现引入新的需求代码不能很好的满足需求的变化时，引入好的设计模式，采用代码重构的方式来优化代码结构，并通过回归单元测试来保证新的代码结构能够正常通过原来的单元测试。盲目的采用敏捷编程又没有采用它有效管理的一整套机制，最后陷入项目泥潭的，只能说是没有理解好“敏捷”的核心要素罢了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Apr 2020 00:44:00 +0000</pubDate>
<dc:creator>wuch</dc:creator>
<og:description>本小节继续演示如何在Django项目中采用早期websocket技术原型来实现把OPC服务端数据实时推送到UI端，让监控页面在另一种技术方式下，实时显示现场设备的工艺数据变化情况。本例我们仍然采用比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haozi0804/p/12725449.html</dc:identifier>
</item>
<item>
<title>啃不透--线程池 - 2J</title>
<link>http://www.cnblogs.com/jijunjian/p/12724640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jijunjian/p/12724640.html</guid>
<description>&lt;p&gt;最近加入同事文博组织的虚拟PMO团队--Thor，大家在交流分享结构化思维时，方才意识到自己在学习线程池上花了很多时间，还是不能清楚的描述它，更本原因就是没有从宏观上认识，建立初始知识体系，没有这个基础，零散学习只是增加了很多无效时间。这也就是为啥有的人学习快，有些慢；有的人可以举一反三，有的确不能。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;218.6826332444&quot;&gt;

&lt;p&gt;　　上一篇文章《&lt;a href=&quot;https://www.cnblogs.com/jijunjian/p/12637246.html&quot; target=&quot;_blank&quot;&gt;火焰图--记一次cpu降温过程&lt;/a&gt;》提到接手了单车投放的应用，上周已经有大量流量切到新应用，然而心中还是惴惴不安的，投放动作业务逻辑复杂，使用了线程池异步处理。对于线程池认知只是停留在一个模糊的状态。这是一个什么状态呢：感觉什么都懂，就是说不出来（就像考试前啥都懂，考试时咬笔杆）。每次使用线程遇到问题都不能用已经有知识去思考，比如3个核心参数应该如何设置，阻塞队列应该用什么...通过搜索引擎查询后，又感觉自己懂了，实际上只是做了一次无用的循环，这次输入的内容，因为没有体系根基，很快又被新的内容冲刷得毫无痕迹。&lt;/p&gt;
&lt;p&gt;　　最近加入同事文博组织的虚拟PMO团队--Thor，大家在交流分享结构化思维时，方才意识到自己在学习线程池上花了很多时间，还是不能清楚的描述它，更本原因就是没有从宏观上认识，建立初始知识体系，没有这个基础，零散学习只是增加了很多无效时间。这也就是为啥有的人学习快，有些慢；有的人可以举一反三，有的确不能。&lt;/p&gt;
&lt;p&gt;　　一个良好的学习过程应该是：&lt;/p&gt;
&lt;p&gt;　　1，找到初始化知识体系。&lt;/p&gt;
&lt;p&gt;      2，补充丰富知识体系。&lt;/p&gt;
&lt;p&gt;      我们都知道系统学习可以建立初始化知识体系，比如阅读一本相关书籍，写一些文章。那么如何补充丰富呢，一句话：拿到锤子，看到什么都是钉子。那应该如何理解这句话呢：这篇文章就是这个的实践。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200418152242063-982651930.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                        文博分享的关于结构化思维的脑图&lt;/p&gt;


&lt;p&gt;　　随着处理器的核心越来越多，利用多线程技术可以把计算逻辑拆分成多个片段，分配到多个核心上，可以显著减少处理时间，提高效率；复杂的业务逻辑，可以使用多线程并发处理，缩短响应时间，提高用户体验。java的线程机制是抢占式协作多线程， 调用机制会周期性的中断线程，将上下文切换到另一个进程，线程越多，竞争会越多，切换会更频繁。所以增加线程带来的性能增加不是线性的，这就是amdahl定律。&lt;/p&gt;
&lt;p&gt;　　再者，线程的创建与销毁，上下文切换都不是免费的。《并发编程实战》一书中对于线程创建与销毁开销说明：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Thread lifecycle overhead. Thread creation and teardown are not free. The actual overhead varies across platforms, but thread creation takes time, introducing latency into request processing, and requires some processing activity by the JVM and OS. If requests are frequent and lightweight, as in most server applications, creating a new thread for each request can consume significative computing resources.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　大意如下：“线程生命周期开销：创建和销毁都是有代价的。实际开销虽因平台有所不同，但是都要消耗时间，jvm和os 需要执行一些处理程序；在大数请求频繁的服务端应用中，如果为每个请求创建一个线程将消耗非常可观的计算机资源”。以上概念层的开销，那一个java线程的创建实际开销则是这样的：　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-preserver-spaces=&quot;true&quot;&gt;A large block of memory has to be allocated and initialized for the thread stack. 为线程栈分配内存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-preserver-spaces=&quot;true&quot;&gt;System calls need to be made to create / register the native thread with the host OS.  为os 创建和注册本地线程进行系统调用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-preserver-spaces=&quot;true&quot;&gt;Descriptors needs to be created, initialized and added to JVM internal data structures.  创建和初始化描述符，添加到jvm内部的数据结构。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　 上下问切换（context switching）也是有开销的，需要分配内存存储当前状态，克隆系统调用等，具体可以参考文末参考资料[2]&lt;/p&gt;

&lt;p&gt;    正是因为创建线程的代价是如此昂贵的（expensive），所以线程池出现了， 它以“池化”思想来管理资源，按需创建，分配，回收；并重复利用已有的线程资源。既然大家都用线程池，那么它的”真面目“是怎么样的呢-- 从源开开始。&lt;/p&gt;


&lt;p&gt;　　java为多线程编程提供了良好的，考究并且一致的编程模型，让我们只需关注问题本身，而ThreadPoolExecutor类就是java为我们提供的线程池模型，其继承体系如下图，顶层接口定义了统一的行为，并将任务提交与任务执行的策略解藕开来；而AbstractExecutorService 抽象任务执行流程并串连起来；如此，子类只用关注某个具体方法了。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419103201404-2119962936.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 一般而言 ThreadPoolExecutor.execute(Runnable()) 是我们使用线程池的入口&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public void execute(Runnable command) {&lt;br/&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;
    // 三种情况：
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1，线程数 少于 核心线程 直接创建线程&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        c &lt;/span&gt;=&lt;span&gt; ctl.get();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程数数超过 核心线程，但是blockqueue 未满，enqueue.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
            reject(command);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
            addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; queue 已经满，直接创建线程（超过max  reject）&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        reject(command);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　execute方法的三个分支，决定了线程池中线程的创建执行策略（面试中经常碰到的场景就是：添加了多个任务时，创建了多少个线程）：&lt;/p&gt;
&lt;p&gt;　　1，线程数 少于 核心线程 直接创建线程&lt;/p&gt;
&lt;p&gt;　　2，线程数数超过 核心线程，但是blockqueue 未满，enqueue.&lt;/p&gt;
&lt;p&gt;　　3, queue 已经满，直接创建线程（超过max reject）&lt;/p&gt;

&lt;p&gt;　　下图展示了线程的创建过程&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419111530497-1652214821.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　 上面的代码中的判断条件中有两个：workerCountOf(c) -- 获取当前线程数； isRunning(c)  -- 线程池是否是运行状态。这两个方法的参数都是一个int类型，那么一个int是如何能同时表示两个类型呢。一个int 4个字节，32位，这里就是用指定位数（3位）来表示状态，剩下的29位表示线程数，下图展示了这个关系。jdk中还有一些其他类也同步用了这样方法，比如：ReentrantReadWriteLock，高16位表示共享锁的数量，低16位表示互斥锁的数量。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419124944794-824825447.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAPACITY= 00011111111111111111111111111111(29个1)&lt;br/&gt;// 获取当前线程数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池的最大数就是2^29-1&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)  {
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　线程池做为一个对象，有自己的状态机，其状态变化是有内部事件驱动的。下图展示了每个状态以及对应值（状态值是3位二进制），及对应的行为。这里有个插曲：以前面试被问到线程池shutwon和stop的差别。当时认识不清说得特别含糊，其实从这两个状态的英文单词的含义就可以看出7，8分了。 showdown 牛津翻译为：the act of closing a factory or business or stopping a large machine from working, either temporarily or permanently。体现的是进行时，closing，stopping；stop 意思比较多，但都是表示的一个意思：end /  not continue。大师的变量名命名那真是相当精确的，要不怎么都提倡程序员学好英语呢。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419133041823-301633840.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　看完了线程池的调度入口，了解了线程池的状态机，我们继续来看下方法 addWorker(Runnable firstTask, boolean core)，前文说到线程池的把任务的提交和执行解藕，那就是如何串连的呢，addWorker方法就很好的完成的这个串连。这个方法主要分两个部分：&lt;/p&gt;
&lt;p&gt;　　1，根据线程池状态及线程数判断是返回还是继续。其中第一个 if 条件尤为复杂，已经有注释。&lt;/p&gt;
&lt;p&gt;　　2，创建工作进程对象 Worker w ，并执行其持有的线程对象thread 的start 方法。顺利让解藕的执行部分开始工作。&lt;/p&gt;
&lt;p&gt;　　这里的代码逻辑不复杂，有一个标记还是有意思的： retry:(标记，可以写成任意如：abc:) / continue retry ;(跳出当前循环) /break retry; （跳出外层循环）。 以后跳出双重循环是不是也可以这样写？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
        retry:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.&lt;br/&gt;　　　　　　　&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;　　　　　　// 如果 是shutdown 以上， 后在有三个条件 都满足才可以接续执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　1， shutdown 执行原有任务，可能加新任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　2， firstTask 必须为空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　3， queue 不能为空（有任务才能接续执行。）&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                   firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                   !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                    wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
                c &lt;/span&gt;= ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        Worker w &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
                mainLock.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                        (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                        workers.add(w);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                            largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                        workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mainLock.unlock();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                    t.start();
                    workerStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
                addWorkerFailed(w);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　接下来任务的执行就交给了工作线程 Worker w 了，这是一个内部类实现了接口 Runnable，构造函数中对的 属性thread初始化传是this,  如此 addWorker 方法中的 t.start(); 就顺利调用了Worker的run 方法了，而run方法又调用 runWorker。所以真正执行任务的最终方法在这里 -- runWorker。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Worker 
Worker(Runnable firstTask) {
    setState(&lt;/span&gt;-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; inhibit interrupts until runWorker&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.firstTask =&lt;span&gt; firstTask;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：这里，这个线程 传的runnable 是this, 也就是 worker本身， 所以start()后进入runnable状态，等到获取时间片后，就执行 run方法。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
/** Delegates main run loop to outer runWorker  */&lt;br/&gt;public void run() {&lt;br/&gt;runWorker(this);&lt;br/&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们继续来读最关键的方法runWorker，我删除了一些判断以及异常处理的代码，让我们可以清晰看到处理逻辑：获取任务，执行，回收线程。获取任务有两种情况：1，线程数小于核心数和队列满了但线程未到最大线程数时直接传入了任务；2，从阻塞获取任务，getTask()方法完成了这一任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runWorker(Worker w) {
        Thread wt &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        Runnable task &lt;/span&gt;=&lt;span&gt; w.firstTask;
        w.firstTask &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        w.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allow interrupts&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                w.lock();&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Throwable thrown &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        task.run();&lt;/span&gt;&lt;span&gt;
                    }&lt;br/&gt;　　　　　　　　　　　　&lt;/span&gt;afterExecute(task, thrown);&lt;p&gt;&lt;span&gt;                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { task &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　　　// 统计完成任务数
                    w.completedTasks&lt;/span&gt;++&lt;span&gt;;
                    w.unlock();
                }
            }
            completedAbruptly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;//回收工作线程，尝试更新状态。&lt;/span&gt;
            processWorkerExit(w, completedAbruptly);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　ThreadPoolExecutor 中定义了 HashSet&amp;lt;Worker&amp;gt;&lt;span class=&quot;s1&quot;&gt;worker 工作&lt;/span&gt;线程队列，BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span class=&quot;s1&quot;&gt;workQueue &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;任务队列 来实现了工作线程和任务管理与解藕。到里线程的任务添加流程和执行过程就分析完了，当然中间抛弃了大量细节，比如锁的使用，比如状态机的变化等等。还是如前文所说，先建立初始化知识体系，后面再研究细节补充体系，每次的投入都是在强化它，再也不是无效时间了。简版调用时序图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s2&quot;&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419150745534-355412420.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;476&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　 文章开头提到流量增大，心中不安，很大一部分原因，就是因为无法监控到线上线程池的状态，比如阻塞队列中的任务数，活跃线程数，线程池大小等等。当然这也是原于早前的无知，平时我们写代码主要分成两部分：功能性代码，实现业务功能；运维性代码，监控程序状态，分析问题。大师的代码也不例外，只是优雅很多。ThreadPoolExecutor 中有提供了相关运维代码，并在runWorker 中使用模板方法设计模式，为我们获取线程池状态等信息提供接口了，比如：&lt;em&gt;beforeExecute(wt, task);  &lt;/em&gt;afterExecute(task, thrown);   ThreadPoolExecutor中这两个方法都是空实现，我们可以继承，并重写完成状态的获取。获取线程池运维状态提代了如下方法下图。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200419152917277-1380770419.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　参考了一位网友的代码(忘记出处了)，继承ThreadPoolExecutor ，重写afterExecute，打印线程池相关信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d8490d0f-d317-43cd-a468-8ce2e20fdbc2')&quot; readability=&quot;49&quot;&gt;&lt;img id=&quot;code_img_closed_d8490d0f-d317-43cd-a468-8ce2e20fdbc2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d8490d0f-d317-43cd-a468-8ce2e20fdbc2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d8490d0f-d317-43cd-a468-8ce2e20fdbc2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d8490d0f-d317-43cd-a468-8ce2e20fdbc2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadPoolMonitor  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String poolName;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 调用线程池的构造方法，并记录线程池名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; corePoolSize    线程池核心线程数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maximumPoolSize 线程池最大线程数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; keepAliveTime   线程的最大空闲时间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; unit            空闲时间的单位
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; workQueue       保存被提交任务的队列
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; poolName        线程池名称
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolMonitor(&lt;span&gt;int&lt;/span&gt; corePoolSize, &lt;span&gt;int&lt;/span&gt; maximumPoolSize, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                             TimeUnit unit, BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue, String poolName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HamThreadFactory(poolName));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.poolName =&lt;span&gt; poolName;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 任务执行之后，将相关状态记录日志。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterExecute(Runnable r, Throwable t) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统计任务耗时、初始线程数、核心线程数、正在执行的任务数量、
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已完成任务数量、任务总数、队列里缓存的任务数量、池中存在的最大线程数、
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大允许的线程数、线程空闲时间、线程池是否关闭、线程池是否终止&lt;/span&gt;
        log.info(&quot;{}-pool-monitor: &quot; +
                        &quot; PoolSize: {}, CorePoolSize: {}, Active: {}, &quot; +
                        &quot;Completed: {}, Task: {}, Queue: {}, LargestPoolSize: {}, &quot; +
                        &quot;MaximumPoolSize: {},  KeepAliveTime: {}, isShutdown: {}, isTerminated: {}&quot;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.poolName, &lt;span&gt;this&lt;/span&gt;.getPoolSize(), &lt;span&gt;this&lt;/span&gt;.getCorePoolSize(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getActiveCount(),
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getCompletedTaskCount(), &lt;span&gt;this&lt;/span&gt;.getTaskCount(), &lt;span&gt;this&lt;/span&gt;.getQueue().size(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getLargestPoolSize(),
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getMaximumPoolSize(), &lt;span&gt;this&lt;/span&gt;.getKeepAliveTime(TimeUnit.MILLISECONDS), &lt;span&gt;this&lt;/span&gt;.isShutdown(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isTerminated());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　&lt;span&gt;结语&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最近学习一直停留在输入（看）层面，所看内容无法转化成自己的知识体系，因而很多东西都无法深入，我们当然知道原因，但是总是说忙得没时间整理。入职哈啰后看到很多优秀的人都是每天大量记录心得感想。等到文博和我们分享他的读书笔记时，从震撼到忏愧。知识只有经历了 输入-消化-输出 才会最终成为我们拥有的。为此文博还在Thor团队发起对赌打卡 -- 哈哈哈，我们当然要应战。&lt;/p&gt;
&lt;p&gt;　　文章到这里就结束了，因为个人经验还有很多不足，文章中的分析也比较粗浅，甚至有错误的地方，希望大家可以拍砖，狠狠的拍。&lt;/p&gt;

&lt;p&gt;　　 成为一名优秀的程序员！&lt;/p&gt;
&lt;p&gt;　　 参考资料：&lt;/p&gt;
&lt;p&gt;　　[1] &lt;a href=&quot;https://intellipaat.com/community/36170/why-is-creating-a-thread-said-to-be-expensive&quot;&gt;https://intellipaat.com/community/36170/why-is-creating-a-thread-said-to-be-expensive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　[2] &lt;strong&gt;https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　[3] &lt;a href=&quot;https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww&quot;&gt;https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　[4] 《java并发编程》&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 20 Apr 2020 00:37:00 +0000</pubDate>
<dc:creator>2J</dc:creator>
<og:description>最近加入同事文博组织的虚拟PMO团队--Thor，大家在交流分享结构化思维时，方才意识到自己在学习线程池上花了很多时间，还是不能清楚的描述它，更本原因就是没有从宏观上认识，建立初始知识体系，没有这个基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jijunjian/p/12724640.html</dc:identifier>
</item>
<item>
<title>EFCore.Sharding(EFCore开源分表框架) - 寒空飞箭</title>
<link>http://www.cnblogs.com/coldairarrow/p/12733886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coldairarrow/p/12733886.html</guid>
<description>&lt;center&gt;&lt;span&gt;EFCore.Sharding(EFCore开源分表框架)&lt;/span&gt;&lt;/center&gt;

&lt;p&gt;本框架旨在为EF Core提供&lt;strong&gt;Sharding&lt;/strong&gt;(即读写分离分库分表)支持,不仅提供了一套强大的普通数据操作接口,并且降低了分表难度,支持按时间自动分表扩容,提供的操作接口简洁统一.&lt;/p&gt;
&lt;p&gt;源码地址:&lt;a href=&quot;https://github.com/Coldairarrow/EFCore.Sharding&quot;&gt;EFCore.SHarding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读写分离分库分表一直是数据库领域中的重难点,当数据规模达到单库极限的时候,就不得不考虑分表方案。EF Core作为.NET Core中最为主流的ORM,用起来十分方便快捷,但是官方并没有相应的Sharding支持,鄙人不才,经过一番摸索之后终于完成这个框架.&lt;/p&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;首先根据需要安装对应的Nuget包&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;包名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;EFCore.Sharding&lt;/td&gt;
&lt;td&gt;必装包,3.x版本对应EF Core3.x,2.x版本对应EF Core2.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;EFCore.Sharding.MySql&lt;/td&gt;
&lt;td&gt;MySql支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EFCore.Sharding.PostgreSql&lt;/td&gt;
&lt;td&gt;PostgreSql支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;EFCore.Sharding.SQLite&lt;/td&gt;
&lt;td&gt;SQLite支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EFCore.Sharding.SqlServer&lt;/td&gt;
&lt;td&gt;SqlServer支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EFCore.Sharding.Oracle&lt;/td&gt;
&lt;td&gt;Oracle支持(暂不支持3.x)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Base_UnitTestShardingRule : ModShardingRule&amp;lt;Base_UnitTest&amp;gt;
{
    protected override string KeyField =&amp;gt; &quot;Id&quot;;
    protected override int Mod =&amp;gt; 3;
}

ShardingConfig.Init(config =&amp;gt;
{
    config.AddAbsDb(DatabaseType.SQLite)
        .AddPhysicDb(ReadWriteType.Read | ReadWriteType.Write, &quot;DataSource=db.db&quot;)
        .AddPhysicDbGroup()
        .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_0&quot;)
        .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_1&quot;)
        .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_2&quot;)
        .SetShardingRule(new Base_UnitTestShardingRule());
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中完成了Sharding配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AddAbsDb&lt;/strong&gt;是指添加抽象数据库,抽象数据库就是将多个分库看成同一个数据库来进行操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AddPhysicDbGroup&lt;/strong&gt;是指添加物理数据库组,在同一组物理数据库中,它们数据库类型相同,拥有的表相同,每个数据库拥有的数据是一致的(之间通过主主复制或主从复制进行数据同步)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AddPhysicTable&lt;/strong&gt;是指添加物理数据表,传入的Base_UnitTest是抽象数据表(即将Base_UnitTest拆分为Base_UnitTest_0~2)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Base_UnitTestShardingRule&lt;/strong&gt;是采用的分表规则,上述代码中采用的是哈希取模的分表方式&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;配置完成，下面开始使用，使用方式&lt;strong&gt;非常简单&lt;/strong&gt;，与平常使用基本一致&lt;br/&gt;首先获取分片仓储接口IShardingRepository&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;IShardingRepository _db = DbFactory.GetRepository().ToSharding();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后即可进行数据操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Base_UnitTest _newData  = new Base_UnitTest
{
    Id = Guid.NewGuid().ToString(),
    UserId = &quot;Admin&quot;,
    UserName = &quot;超级管理员&quot;,
    Age = 22
};
List&amp;lt;Base_UnitTest&amp;gt; _insertList = new List&amp;lt;Base_UnitTest&amp;gt;
{
    new Base_UnitTest
    {
        Id = Guid.NewGuid().ToString(),
        UserId = &quot;Admin1&quot;,
        UserName = &quot;超级管理员1&quot;,
        Age = 22
    },
    new Base_UnitTest
    {
        Id = Guid.NewGuid().ToString(),
        UserId = &quot;Admin2&quot;,
        UserName = &quot;超级管理员2&quot;,
        Age = 22
    }
};
//添加单条数据
_db.Insert(_newData);
//添加多条数据
_db.Insert(_insertList);
//清空表
_db.DeleteAll&amp;lt;Base_UnitTest&amp;gt;();
//删除单条数据
_db.Delete(_newData);
//删除多条数据
_db.Delete(_insertList);
//删除指定数据
_db.Delete&amp;lt;Base_UnitTest&amp;gt;(x =&amp;gt; x.UserId == &quot;Admin2&quot;);
//更新单条数据
_db.Update(_newData);
//更新多条数据
_db.Update(_insertList);
//更新单条数据指定属性
_db.UpdateAny(_newData, new List&amp;lt;string&amp;gt; { &quot;UserName&quot;, &quot;Age&quot; });
//更新多条数据指定属性
_db.UpdateAny(_insertList, new List&amp;lt;string&amp;gt; { &quot;UserName&quot;, &quot;Age&quot; });
//更新指定条件数据
_db.UpdateWhere&amp;lt;Base_UnitTest&amp;gt;(x =&amp;gt; x.UserId == &quot;Admin&quot;, x =&amp;gt;
{
    x.UserId = &quot;Admin2&quot;;
});
//GetList获取表的所有数据
var list=_db.GetList&amp;lt;Base_UnitTest&amp;gt;();
//GetIQPagination获取分页后的数据
var list=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().GetPagination(pagination);
//Max
var max=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Max(x =&amp;gt; x.Age);
//Min
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Min(x =&amp;gt; x.Age);
//Average
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Average(x =&amp;gt; x.Age);
//Count
var min=_db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Count();
//事务,使用方式与普通事务一致
bool succcess = _db.RunTransaction(() =&amp;gt;
{
    _db.Insert(_newData);
    var newData2 = _newData.DeepClone();
    _db.Insert(newData2);
}).Success;
Assert.AreEqual(succcess, false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述操作中表面上是操作Base_UnitTest表，实际上却在按照一定规则使用Base_UnitTest_0~2三张表，使分片对业务&lt;strong&gt;操作透明&lt;/strong&gt;，极大提高开发效率&lt;br/&gt;具体使用方式请参考单元测试源码：&lt;a href=&quot;https://github.com/Coldairarrow/EFCore.Sharding/tree/master/src/EFCore.Sharding.Tests/Sharding&quot;&gt;连接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;按时间自动分表&quot;&gt;按时间自动分表&lt;/h2&gt;
&lt;p&gt;上面的哈希取模的方式虽然简单,但是却十分不实用,因为当3张分表到达瓶颈时,将会面临扩容的问题，这种方式扩容需要进行大量的数据迁移，这无疑是十分麻烦的。因此需要一种方式能够系统自动建表扩容，并且无需人工干预，这就是按时间自动分表.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;
using Demo.Common;
using EFCore.Sharding;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Demo.AutoExpandByDate
{
    class Base_UnitTestShardingRule : AbsShardingRule&amp;lt;Base_UnitTest&amp;gt;
    {
        public override DateTime BuildDate(Base_UnitTest obj)
        {
            return obj.CreateTime;
        }
    }

    class Program
    {
        /// &amp;lt;summary&amp;gt;
        /// 表都在同一个数据库中
        /// &amp;lt;/summary&amp;gt;
        public static void OneGroup()
        {
            DateTime startTime = DateTime.Now.AddMinutes(-5);
            DateTime endTime = DateTime.MaxValue;

            //配置初始化
            ShardingConfig.Init(config =&amp;gt;
            {
                config.AddAbsDb(DatabaseType.SqlServer)//添加抽象数据库
                    .AddPhysicDbGroup()//添加物理数据库组
                    .AddPhysicDb(ReadWriteType.Read | ReadWriteType.Write, Config.ConString1)//添加物理数据库1
                    .SetShardingRule(new Base_UnitTestShardingRule())//设置分表规则
                    .AutoExpandByDate&amp;lt;Base_UnitTest&amp;gt;(//设置为按时间自动分表
                        ExpandByDateMode.PerMinute,
                        (startTime, endTime, ShardingConfig.DefaultDbGourpName)
                        );
            });
            var db = DbFactory.GetShardingRepository();
            while (true)
            {
                db.Insert(new Base_UnitTest
                {
                    Id = Guid.NewGuid().ToString(),
                    Age = 1,
                    UserName = Guid.NewGuid().ToString(),
                    CreateTime = DateTime.Now
                });

                var count = db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Count();
                Console.WriteLine($&quot;当前数据量:{count}&quot;);

                Thread.Sleep(50);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 表分布在两个数据库测试
        /// &amp;lt;/summary&amp;gt;
        public static void TwoGroup()
        {
            DateTime startTime1 = DateTime.Now.AddMinutes(-5);
            DateTime endTime1 = DateTime.Now.AddMinutes(5);
            DateTime startTime2 = endTime1;
            DateTime endTime2 = DateTime.MaxValue;

            string group1 = &quot;group1&quot;;
            string group2 = &quot;group2&quot;;

            //配置初始化
            ShardingConfig.Init(config =&amp;gt;
            {
                config.AddAbsDb(DatabaseType.SqlServer)//添加抽象数据库
                    .AddPhysicDbGroup(group1)//添加物理数据库组1
                    .AddPhysicDbGroup(group2)//添加物理数据库组2
                    .AddPhysicDb(ReadWriteType.Read | ReadWriteType.Write, Config.ConString1, group1)//添加物理数据库1
                    .AddPhysicDb(ReadWriteType.Read | ReadWriteType.Write, Config.ConString2, group2)//添加物理数据库2
                    .SetShardingRule(new Base_UnitTestShardingRule())//设置分表规则
                    .AutoExpandByDate&amp;lt;Base_UnitTest&amp;gt;(//设置为按时间自动分表
                        ExpandByDateMode.PerMinute,
                        (startTime1, endTime1, group1),
                        (startTime2, endTime2, group2)
                        );
            });

            List&amp;lt;Task&amp;gt; tasks = new List&amp;lt;Task&amp;gt;();
            for (int i = 0; i &amp;lt; 4; i++)
            {
                tasks.Add(Task.Run(() =&amp;gt;
                {
                    var db = DbFactory.GetShardingRepository();
                    while (true)
                    {
                        db.Insert(new Base_UnitTest
                        {
                            Id = Guid.NewGuid().ToString(),
                            Age = 1,
                            UserName = Guid.NewGuid().ToString(),
                            CreateTime = DateTime.Now
                        });

                        var count = db.GetIShardingQueryable&amp;lt;Base_UnitTest&amp;gt;().Count();
                        Console.WriteLine($&quot;当前数据量:{count}&quot;);

                        Thread.Sleep(50);
                    }
                }));
            }

            Console.ReadLine();
        }

        static void Main(string[] args)
        {
            OneGroup();

            Console.ReadLine();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面Demo都在源码中&lt;/p&gt;
&lt;p&gt;上面的代码实现了将Base_UnitTest表按照时间自动分表，每分钟创建一张表，实际使用中根据业务需求设置ExpandByDateMode参数，常用按天、按月分表&lt;/p&gt;
&lt;p&gt;自动分表效果&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/19/JKxE8K.png&quot; alt=&quot;JKxE8K.png&quot;/&gt;&lt;br/&gt;全程无需人工干预，系统会自动定时创建分表，十分简单好用&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;using Demo.Common;
using EFCore.Sharding;
using System;
using System.Diagnostics;
using System.Linq;

namespace Demo.Performance
{
    class Base_UnitTestShardingRule : ModShardingRule&amp;lt;Base_UnitTest&amp;gt;
    {
        protected override string KeyField =&amp;gt; &quot;Id&quot;;
        protected override int Mod =&amp;gt; 3;
    }

    class Program
    {
        static void Main(string[] args)
        {
            ShardingConfig.Init(config =&amp;gt;
            {
                config.AddAbsDb(DatabaseType.SqlServer)
                    .AddPhysicDb(ReadWriteType.Read | ReadWriteType.Write, Config.ConString1)
                    .AddPhysicDbGroup()
                    .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_0&quot;)
                    .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_1&quot;)
                    .AddPhysicTable&amp;lt;Base_UnitTest&amp;gt;(&quot;Base_UnitTest_2&quot;)
                    .SetShardingRule(new Base_UnitTestShardingRule());
            });

            var db = DbFactory.GetRepository(Config.ConString1, DatabaseType.SqlServer);
            Stopwatch watch = new Stopwatch();
            var q = db.GetIQueryable&amp;lt;Base_UnitTest&amp;gt;()
                .Where(x =&amp;gt; x.UserName.Contains(&quot;00001C22-8DD2-4D47-B500-407554B099AB&quot;))
                .OrderByDescending(x =&amp;gt; x.Id)
                .Skip(0)
                .Take(30);

            q.ToList();
            q.ToSharding().ToList();
            watch.Restart();
            var list1 = q.ToList();
            watch.Stop();
            Console.WriteLine($&quot;未分表耗时:{watch.ElapsedMilliseconds}ms&quot;);
            watch.Restart();
            var list2 = q.ToSharding().ToList();
            watch.Stop();
            Console.WriteLine($&quot;分表后耗时:{watch.ElapsedMilliseconds}ms&quot;);

            Console.WriteLine(&quot;完成&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分表Base_UnitTest_0-2各有100万数据,然后将这三张表的数据导入Base_UnitTest中(即Base_UnitTest表的数据与Base_UnitTest_0-2三张表总合数据一致)&lt;/p&gt;
&lt;p&gt;分表与不分表测试结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/19/JMSJBQ.png&quot; alt=&quot;JMSJBQ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里仅仅分了3张表，其效果立杆见影，若分表几十张，那效果想想就很棒&lt;/p&gt;
&lt;h2 id=&quot;其它简单操作非sharing&quot;&gt;其它简单操作(非Sharing)&lt;/h2&gt;
&lt;p&gt;框架不仅支持Sharing,而且封装了常用数据库操作,使用比较简单&lt;br/&gt;详细使用方式参考 &lt;a href=&quot;https://github.com/Coldairarrow/EFCore.Sharding/blob/master/examples/Demo.DI/Program.cs&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个简单实用强大的框架希望能够帮助到大家,力求为.NET生态贡献一份力,大家一起壮大.NET生态&lt;/p&gt;
&lt;p&gt;欢迎使用本框架，若觉得不错，请比心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Coldairarrow/UploadFiles/master/Colder.Fx.Net.AdminLTE/04abaa3d37fa01b4c4058c8163aab6a8.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Github欢迎星星:&lt;a href=&quot;https://github.com/Coldairarrow&quot;&gt;https://github.com/Coldairarrow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园欢迎点赞：&lt;a href=&quot;https://www.cnblogs.com/coldairarrow/&quot;&gt;https://www.cnblogs.com/coldairarrow/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QQ群3:940069478&lt;br/&gt;个人QQ:862520575（&lt;strong&gt;欢迎技术支持及商务合作，提供.NET Core + Linux + Nginx+ jenkins + git整套持续集成快速开发平台&lt;/strong&gt;）&lt;/p&gt;
&lt;center&gt;本人将会对这个快速开发框架不断完善与维护，希望能够帮助到各位
&lt;center&gt;若遇到任何问题或需要技术支持，请联系我
&lt;center&gt;------学习永无止境，技术永无上限，代码就是艺术------&lt;/center&gt;
&lt;/center&gt;
&lt;/center&gt;
</description>
<pubDate>Sun, 19 Apr 2020 23:53:00 +0000</pubDate>
<dc:creator>寒空飞箭</dc:creator>
<og:description>.NET .NET Core EF Core Sharding</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coldairarrow/p/12733886.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（6）——滤镜 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12518907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12518907.html</guid>
<description>&lt;p&gt;　　滤镜（filter）可改造元素的视觉呈现，CSS内置的滤镜有10种，通过SVG文件还能自定义滤镜。&lt;/p&gt;

&lt;p&gt;　　调色滤镜可控制元素的模糊、颜色、亮度等变化，并且多个滤镜可组合在一起使用。这些滤镜大部分既能接收百分数，也能接收数值。当传入的值大于上限值时，会以上限值来处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）模糊&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　blur()滤镜会对元素进行高斯模糊的处理，它能接收一个模糊半径的长度值。注意，不能向其传递负数。在下图中，右侧是调用了blur()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; blur(5px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318174525403-43199769.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）透明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　opacity()滤镜可控制元素的透明度，其默认值为1或100%（表示不透明），最小值为0。opacity()滤镜与opacity属性类似，但两者不是互斥关系，可同时应用于同一个元素，不过opacity属性会在执行完所有的滤镜后再起作用。在下图中，右侧是调用了opacity()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; opacity(.5)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318174627504-160969202.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）阴影&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　drop-shadow()滤镜可为元素的透明部分提供阴影，其取值与text-shadow属性类似，也是X轴与Y轴的偏移、模糊半径以及颜色。下图使用了一张透明的五角星图，右侧调用了drop-shadow()滤镜，阴影会沿着透明轮廓渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; drop-shadow(5px 5px 5px #F60)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318174732449-760560657.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）灰度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　grayscale()滤镜能转换元素的灰度，当值为1或100%时，元素会转换成完全的灰度。在下图中，右侧是调用了grayscale()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; grayscale(100%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318174833936-815747196.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）褐色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　sepia()滤镜能指定元素褐色的比例，即用褐色为元素上色。当值为1或100%时，元素会转换成完全的深褐色。在下图中，右侧是调用了sepia()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; sepia(100%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318174941592-236385932.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）反转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　invert()滤镜能将元素的颜色反转处理，即用255或100%减去颜色的R、G和B通道的值。在下图中，右侧是调用了invert()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; invert(100%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175105481-1559066288.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）色相旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　hue-rotate()滤镜能接收一个角度值，参照标准色轮（如下图）旋转元素的整体色相。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175151887-1256397065.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在下图中，右侧是调用了hue-rotate()滤镜旋转90°后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; hue-rotate(90deg)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175243160-1458662780.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8）亮度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　brightness()滤镜能调整元素的明暗程度，值越小，元素越暗。在下图中，右侧是调用了brightness()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; brightness(50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175340066-1821776329.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9）对比度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　contrast()滤镜能调整元素颜色的对比度，对比度越低，颜色越接近。在下图中，右侧是调用了contrast()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; contrast(30%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175430922-2099239053.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10）饱和度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　saturate()滤镜能调整元素颜色的饱和度，饱和度越低，颜色越暗。在下图中，右侧是调用了saturate()滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; saturate(50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175538846-999409281.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11）组合&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在声明filter属性时，可定义多个滤镜函数，用空格分隔，如下所示。在下图中，右侧是调用了多个滤镜后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; drop-shadow(5px 5px 5px #F60) sepia(100%) saturate(50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175632724-1558683009.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　所有的CSS滤镜都能通过SVG滤镜实现。以blur(5px)为例，首先用一个名为filter.svg的文件描绘模糊的效果，其内容如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;svg &lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;blur&quot;&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;=&quot;-5%&quot;&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;&lt;span&gt;=&quot;-5%&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;110%&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;110%&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;feGaussianBlur &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;=&quot;SourceGraphic&quot;&lt;/span&gt;&lt;span&gt; stdDeviation&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;svg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过url()函数引用SVG文件中的滤镜，注意，井号后面跟着的是filter元素的id属性值，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  filter&lt;/span&gt;:&lt;span&gt; url(./filter.svg#blur)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318175759977-164976264.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过SVG文件的方式就能创造出各种功能的滤镜，以适应更多的复杂场景。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Apr 2020 23:16:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>滤镜（filter）可改造元素的视觉呈现，CSS内置的滤镜有10种，通过SVG文件还能自定义滤镜。 一、调色滤镜 调色滤镜可控制元素的模糊、颜色、亮度等变化，并且多个滤镜可组合在一起使用。这些滤镜大部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12518907.html</dc:identifier>
</item>
<item>
<title>面试 HTTP ，99% 的面试官都爱问这些问题 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/12735623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/12735623.html</guid>
<description>&lt;h2 id=&quot;http-和-https-的区别&quot;&gt;HTTP 和 HTTPS 的区别&lt;/h2&gt;
&lt;p&gt;HTTP 是一种 &lt;code&gt;超文本传输协议(Hypertext Transfer Protocol)&lt;/code&gt;，&lt;strong&gt;HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070234931-1546260397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP 主要内容分为三部分，&lt;strong&gt;超文本（Hypertext）、传输（Transfer）、协议（Protocol）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行&lt;code&gt;超链接&lt;/code&gt;的跳转。&lt;/li&gt;
&lt;li&gt;上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为&lt;code&gt;请求方&lt;/code&gt;，把接到二进制数据包的一方称为&lt;code&gt;应答方&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到 HTTP，不得不提的就是 TCP/IP 网络模型，一般是五层模型。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070245831-867564603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是也可以分为四层，就是&lt;strong&gt;把链路层和物理层都表示为网络接口层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070252826-386757517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种就是 OSI 七层网络模型，它就是在五层协议之上加了&lt;strong&gt;表示层和会话层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070300443-907560535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 HTTPS 的全称是 &lt;code&gt;Hypertext Transfer Protocol Secure&lt;/code&gt;，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;HTTPS 就是身披了一层 SSL 的 HTTP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070308592-242968210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，HTTP 和 HTTPS 的主要区别是什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最简单的，HTTP 在地址栏上的协议是以 &lt;code&gt;http://&lt;/code&gt; 开头，而 HTTPS 在地址栏上的协议是以 &lt;code&gt;https://&lt;/code&gt; 开头&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;http://www.cxuanblog.com/
https://www.cxuanblog.com/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 &lt;strong&gt;密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法&lt;/strong&gt; 能够解决上面这些问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070326006-1741295366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;http-get-和-post-区别&quot;&gt;HTTP Get 和 Post 区别&lt;/h2&gt;
&lt;p&gt;HTTP 中包括许多方法，&lt;strong&gt;Get 和 Post 是 HTTP 中最常用的两个方法&lt;/strong&gt;，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;get 方法一般用于请求，比如你在浏览器地址栏输入 &lt;code&gt;www.cxuanblog.com&lt;/code&gt; 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于 &lt;code&gt;&amp;lt;form&amp;gt; 表单&lt;/code&gt;的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。&lt;/li&gt;
&lt;li&gt;get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;/test/demo_form.asp?name1=value1&amp;amp;name2=value2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;amp;name2=value2
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;get 请求在浏览器反复的 &lt;code&gt;回退/前进&lt;/code&gt; 操作是无害的，而 post 操作会再次提交表单请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是无状态协议，http-是无状态协议吗，怎么解决&quot;&gt;什么是无状态协议，HTTP 是无状态协议吗，怎么解决&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;无状态协议(Stateless Protocol)&lt;/code&gt; 就是指&lt;strong&gt;浏览器对于事务的处理没有记忆能力&lt;/strong&gt;。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。&lt;/p&gt;
&lt;p&gt;HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 &lt;code&gt;小甜饼(Cookie)&lt;/code&gt; 的机制。它能够让浏览器具有&lt;code&gt;记忆&lt;/code&gt;能力。&lt;/p&gt;
&lt;p&gt;如果你的浏览器允许 cookie 的话，查看方式 &lt;strong&gt;chrome://settings/content/cookies&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070342864-2070396598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就说明你的记忆芯片通电了...... 当你想服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID=XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070352977-586746205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070402885-1879965053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JWT 的 Cookie 信息存储在&lt;code&gt;客户端&lt;/code&gt;，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。&lt;/li&gt;
&lt;li&gt;JWT 支持跨域认证，Cookies 只能用在&lt;code&gt;单个节点的域&lt;/code&gt;或者它的&lt;code&gt;子域&lt;/code&gt;中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过&lt;code&gt;多个节点&lt;/code&gt;进行用户认证，也就是我们常说的&lt;code&gt;跨域认证&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;udp-和-tcp-的区别&quot;&gt;UDP 和 TCP 的区别&lt;/h2&gt;
&lt;p&gt;TCP 和 UDP 都位于计算机网络模型中的运输层，它们负责传输应用层产生的数据。下面我们就来聊一聊 TCP 和 UDP 分别的特征和他们的区别&lt;/p&gt;
&lt;h3 id=&quot;udp-是什么&quot;&gt;UDP 是什么&lt;/h3&gt;
&lt;p&gt;UDP 的全称是 &lt;code&gt;User Datagram Protocol&lt;/code&gt;，用户数据报协议。它不需要所谓的&lt;code&gt;握手&lt;/code&gt;操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;数据报是与分组交换网络关联的传输单元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UDP 的特点主要有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UDP 能够支持容忍数据包丢失的带宽密集型应用程序&lt;/li&gt;
&lt;li&gt;UDP 具有低延迟的特点&lt;/li&gt;
&lt;li&gt;UDP 能够发送大量的数据包&lt;/li&gt;
&lt;li&gt;UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tcp-是什么&quot;&gt;TCP 是什么&lt;/h3&gt;
&lt;p&gt;TCP 的全称是&lt;code&gt;Transmission Control Protocol&lt;/code&gt; ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。&lt;/p&gt;
&lt;p&gt;TCP 的主要特点有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TCP 能够确保连接的建立和数据包的发送&lt;/li&gt;
&lt;li&gt;TCP 支持错误重传机制&lt;/li&gt;
&lt;li&gt;TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送&lt;/li&gt;
&lt;li&gt;TCP 能够提供错误校验和，甄别有害的数据包。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tcp-和-udp-的不同&quot;&gt;TCP 和 UDP 的不同&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070414578-759690763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面为你罗列了一些 TCP 和 UDP 的不同点，方便理解，方便记忆。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 是面向连接的协议&lt;/td&gt;
&lt;td&gt;UDP 是无连接的协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 在发送数据前先需要建立连接，然后再发送数据&lt;/td&gt;
&lt;td&gt;UDP 无需建立连接就可以直接发送大量数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 会按照特定顺序重新排列数据包&lt;/td&gt;
&lt;td&gt;UDP 数据包没有固定顺序，所有数据包都相互独立&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TCP 传输的速度比较慢&lt;/td&gt;
&lt;td&gt;UDP 的传输会更快&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 的头部字节有 20 字节&lt;/td&gt;
&lt;td&gt;UDP 的头部字节只需要 8 个字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 是重量级的，在发送任何用户数据之前，TCP需要三次握手建立连接。&lt;/td&gt;
&lt;td&gt;UDP 是轻量级的。没有跟踪连接，消息排序等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 会进行错误校验，并能够进行错误恢复&lt;/td&gt;
&lt;td&gt;UDP 也会错误检查，但会丢弃错误的数据包。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TCP 有发送确认&lt;/td&gt;
&lt;td&gt;UDP 没有发送确认&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TCP 会使用握手协议，例如 SYN，SYN-ACK，ACK&lt;/td&gt;
&lt;td&gt;无握手协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP 是可靠的，因为它可以确保将数据传送到路由器。&lt;/td&gt;
&lt;td&gt;在 UDP 中不能保证将数据传送到目标。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;tcp-三次握手和四次挥手&quot;&gt;TCP 三次握手和四次挥手&lt;/h2&gt;
&lt;p&gt;TCP 三次握手和四次挥手也是面试题的热门考点，它们分别对应 TCP 的连接和释放过程。下面就来简单认识一下这两个过程&lt;/p&gt;
&lt;h3 id=&quot;tcp-三次握手&quot;&gt;TCP 三次握手&lt;/h3&gt;
&lt;p&gt;在了解具体的流程前，我们需要先认识几个概念&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;消息类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;这个消息是用来初始化和建立连接的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ACK&lt;/td&gt;
&lt;td&gt;帮助对方确认收到的 SYN 消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SYN-ACK&lt;/td&gt;
&lt;td&gt;本地的 SYN 消息和较早的 ACK 数据包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;用来断开连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SYN：它的全称是 &lt;code&gt;Synchronize Sequence Numbers&lt;/code&gt;，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ACK：&lt;code&gt;Acknowledge character&lt;/code&gt;, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070424280-1762755163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果用现实生活来举例的话就是&lt;/p&gt;
&lt;p&gt;小明 - 客户端 小红 - 服务端&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小明给小红打电话，接通了后，小明说&lt;strong&gt;喂，能听到吗&lt;/strong&gt;，这就相当于是连接建立。&lt;/li&gt;
&lt;li&gt;小红给小明回应，&lt;strong&gt;能听到，你能听到我说的话吗&lt;/strong&gt;，这就相当于是请求响应。&lt;/li&gt;
&lt;li&gt;小明听到小红的回应后，&lt;strong&gt;好的&lt;/strong&gt;，这相当于是连接确认。在这之后小明和小红就可以通话/交换信息了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tcp-四次挥手&quot;&gt;TCP 四次挥手&lt;/h3&gt;
&lt;p&gt;在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070433284-37040778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。&lt;/li&gt;
&lt;li&gt;然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。&lt;/li&gt;
&lt;li&gt;当客户端收到服务器发送的 ACK 响应后，客户端就进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态，然后等待来自服务器的 &lt;code&gt;FIN&lt;/code&gt; 消息&lt;/li&gt;
&lt;li&gt;服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。&lt;/li&gt;
&lt;li&gt;当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是可以用上面那个通话的例子来进行描述&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小明对小红说，我所有的东西都说完了，我要挂电话了。&lt;/li&gt;
&lt;li&gt;小红说，收到，我这边还有一些东西没说。&lt;/li&gt;
&lt;li&gt;经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了&lt;/li&gt;
&lt;li&gt;小明收到消息后，又等了若干时间后，挂断了电话。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简述-http101120-的区别&quot;&gt;简述 HTTP1.0/1.1/2.0 的区别&lt;/h2&gt;
&lt;h3 id=&quot;http-10&quot;&gt;HTTP 1.0&lt;/h3&gt;
&lt;p&gt;HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。&lt;/li&gt;
&lt;li&gt;HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。&lt;/li&gt;
&lt;li&gt;HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。&lt;/li&gt;
&lt;li&gt;HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。&lt;/li&gt;
&lt;li&gt;HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;http-11&quot;&gt;HTTP 1.1&lt;/h3&gt;
&lt;p&gt;HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP 1.1 使用了摘要算法来进行身份验证&lt;/li&gt;
&lt;li&gt;HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 &lt;code&gt;keep-alive&lt;/code&gt; 来设置&lt;/li&gt;
&lt;li&gt;HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。&lt;/li&gt;
&lt;li&gt;HTTP 1.1 支持断点续传，通过使用请求头中的 &lt;code&gt;Range&lt;/code&gt; 来实现。&lt;/li&gt;
&lt;li&gt;HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;http-20&quot;&gt;HTTP 2.0&lt;/h3&gt;
&lt;p&gt;HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;头部压缩&lt;/code&gt;，由于 HTTP 1.1 经常会出现 &lt;strong&gt;User-Agent、Cookie、Accept、Server、Range&lt;/strong&gt; 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 &lt;code&gt;HPACK&lt;/code&gt; 算法进行压缩。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;二进制格式&lt;/code&gt;，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;强化安全&lt;/code&gt;，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;多路复用&lt;/code&gt;，即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070445646-598174426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;请你说一下-http-常见的请求头&quot;&gt;请你说一下 HTTP 常见的请求头&lt;/h2&gt;
&lt;p&gt;这个问题比较开放，因为 HTTP 请求头有很多，这里只简单举出几个例子，具体的可以参考我的另一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XZZR0945IcI6X4S0g5fZXg&quot;&gt;https://mp.weixin.qq.com/s/XZZR0945IcI6X4S0g5fZXg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP 标头会分为四种，分别是 &lt;code&gt;通用标头&lt;/code&gt;、&lt;code&gt;实体标头&lt;/code&gt;、&lt;code&gt;请求标头&lt;/code&gt;、&lt;code&gt;响应标头&lt;/code&gt;。分别介绍一下&lt;/p&gt;
&lt;h3 id=&quot;通用标头&quot;&gt;通用标头&lt;/h3&gt;
&lt;p&gt;通用标头主要有三个，分别是 &lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;Cache-Control&lt;/code&gt; 和 &lt;code&gt;Connection&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Date: Wed, 21 Oct 2015 07:28:00 GMT 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示的是格林威治标准时间，这个时间要比北京时间慢八个小时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070506989-1008635632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cache-Control 是一个通用标头，他可以出现在&lt;code&gt;请求标头&lt;/code&gt;和&lt;code&gt;响应标头&lt;/code&gt;中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是又一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 &lt;code&gt;可缓存性&lt;/code&gt;、&lt;code&gt;阈值性&lt;/code&gt;、 &lt;code&gt;重新验证并重新加载&lt;/code&gt; 和&lt;code&gt;其他特性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是&lt;code&gt;持久性连接&lt;/code&gt;，即一次事务完成后不关闭网络连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Connection: keep-alive
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种是&lt;code&gt;非持久性连接&lt;/code&gt;，即一次事务完成后关闭网络连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Connection: close
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP1.1 其他通用标头如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070517966-2139009759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实体标头&quot;&gt;实体标头&lt;/h3&gt;
&lt;p&gt;实体标头是描述消息正文内容的 HTTP 标头。实体标头用于 HTTP 请求和响应中。头部&lt;code&gt;Content-Length&lt;/code&gt;、 &lt;code&gt;Content-Language&lt;/code&gt;、 &lt;code&gt;Content-Encoding&lt;/code&gt; 是实体头。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Content-Length 实体报头指示实体主体的大小，以字节为单位，发送到接收方。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Content-Language 实体报头描述了客户端或者服务端能够接受的语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Content-Encoding 这又是一个比较麻烦的属性，这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。&lt;/p&gt;
&lt;p&gt;常见的内容编码有这几种： &lt;strong&gt;gzip、compress、deflate、identity&lt;/strong&gt; ，这个属性可以应用在请求报文和响应报文中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Accept-Encoding: gzip, deflate //请求头
Content-Encoding: gzip  //响应头
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一些实体标头字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070525511-1872030407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;请求标头&quot;&gt;请求标头&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Host 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的 TCP 端口号。如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个 HTTP 的 URL 会自动使用 80 作为端口）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Host: developer.mozilla.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 &lt;code&gt;Accpet&lt;/code&gt;、 &lt;code&gt;Accept-Language&lt;/code&gt;、&lt;code&gt;Accept-Encoding&lt;/code&gt; 都是属于内容协商的请求标头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Referer: https://developer.mozilla.org/testpage.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;If-Modified-Since&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If-Modified-Since 通常会与 If-None-Match 搭配使用，If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 &lt;code&gt;Last-Modified&lt;/code&gt; 来确定。&lt;/p&gt;
&lt;p&gt;大白话说就是如果在 &lt;code&gt;Last-Modified&lt;/code&gt; 之后更新了服务器资源，那么服务器会响应 200，如果在 &lt;code&gt;Last-Modified&lt;/code&gt; 之后没有更新过资源，则返回 304。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;If-None-Match&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If-None-Match HTTP 请求标头使请求成为条件请求。 对于 GET 和 HEAD 方法，仅当服务器没有与给定资源匹配的 &lt;code&gt;ETag&lt;/code&gt; 时，服务器才会以 200 状态发送回请求的资源。 对于其他方法，仅当最终现有资源的&lt;code&gt;ETag&lt;/code&gt;与列出的任何值都不匹配时，才会处理请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;If-None-Match: &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Accept&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Accept-Charset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;accept-charset 属性规定服务器处理表单数据所接受的字符集。&lt;/p&gt;
&lt;p&gt;常用的字符集有： UTF-8 - Unicode 字符编码 ； ISO-8859-1 - 拉丁字母表的字符编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Accept-Language&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。&lt;/p&gt;
&lt;p&gt;请求标头我们大概就介绍这几种，后面会有一篇文章详细深挖所有的响应头的，下面是一个响应头的汇总，基于 HTTP 1.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070537767-846263525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;响应标头&quot;&gt;响应标头&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 指定一个来源，它告诉浏览器允许该来源进行资源访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Keep-Alive 表示的是 Connection 非持续连接的存活时间，可以进行指定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器标头包含有关原始服务器用来处理请求的软件的信息。&lt;/p&gt;
&lt;p&gt;应该避免使用过于冗长和详细的 Server 值，因为它们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面这种写法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Server: Apache/2.4.1 (Unix)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Set-Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Set-Cookie 用于服务器向客户端发送 sessionID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer-Encoding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。&lt;/p&gt;
&lt;p&gt;HTTP /1.1 的传输编码方式仅对分块传输编码有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X-Frame-Options&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。&lt;/p&gt;
&lt;p&gt;首部字段 &lt;code&gt;X-Frame-Options&lt;/code&gt; 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。&lt;/p&gt;
&lt;p&gt;下面是一个响应头的汇总，基于 HTTP 1.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070547364-1951785761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;地址栏输入-url-发生了什么&quot;&gt;地址栏输入 URL 发生了什么&lt;/h2&gt;
&lt;p&gt;这道题也是一道经常会考的面试题。那么下面我们就来探讨一下从你输入 URL 后到响应，都经历了哪些过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，你需要在浏览器中的 URL 地址上，输入你想访问的地址，如下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070603984-33979171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你应该访问不到的，对不对~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;然后，浏览器会根据你输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 &lt;code&gt;hosts&lt;/code&gt; 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先来看一下 DNS 是啥，互联网中识别主机的方式有两种，通过&lt;code&gt;主机名&lt;/code&gt;和 &lt;code&gt;IP 地址&lt;/code&gt;。我们人喜欢用名字的方式进行记忆，但是通信链路中的路由却喜欢定长、有层次结构的 IP 地址。所以就需要一种能够把主机名到 IP 地址的转换服务，这种服务就是由 DNS 提供的。DNS 的全称是 &lt;code&gt;Domain Name System&lt;/code&gt; 域名系统。DNS 是一种由分层的 DNS 服务器实现的分布式数据库。DNS 运行在 UDP 上，使用 53 端口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070613476-618983445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DNS 是一种分层数据库，它的主要层次结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070620978-673308076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是 &lt;code&gt;本地 DNS 服务器(local DNS server)&lt;/code&gt;。严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 &lt;code&gt;ISP(Internet Service Provider)&lt;/code&gt; 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP地址。通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。&lt;/p&gt;
&lt;p&gt;首先，查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;注意：DNS 涉及两种查询方式：一种是&lt;code&gt;递归查询(Recursive query)&lt;/code&gt; ，一种是&lt;code&gt;迭代查询(Iteration query)&lt;/code&gt;。《计算机网络：自顶向下方法》竟然没有给出递归查询和迭代查询的区别，找了一下网上的资料大概明白了下。&lt;/p&gt;
&lt;p&gt;如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询；&lt;/p&gt;
&lt;p&gt;如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在由根域名服务器 -&amp;gt; 顶级域名服务器 -&amp;gt; 权威 DNS 服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，具体的握手过程请参考上面的回答。&lt;/li&gt;
&lt;li&gt;在建立连接后，浏览器会向目标服务器发起 &lt;code&gt;HTTP-GET&lt;/code&gt; 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。&lt;/li&gt;
&lt;li&gt;如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。&lt;/li&gt;
&lt;li&gt;然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;https-的工作原理&quot;&gt;HTTPS 的工作原理&lt;/h2&gt;
&lt;p&gt;我们上面描述了一下 HTTP 的工作原理，下面来讲述一下 HTTPS 的工作原理。因为我们知道 HTTPS 不是一种新出现的协议，而是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070636714-2087758576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。&lt;/p&gt;
&lt;p&gt;TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。&lt;/p&gt;
&lt;p&gt;每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。&lt;/p&gt;
&lt;p&gt;TLS 具体的握手过程会根据所使用的&lt;code&gt;密钥交换算法的类型&lt;/code&gt;和双方支持的&lt;code&gt;密码套件&lt;/code&gt;而不同。 我们以&lt;code&gt;RSA 非对称加密&lt;/code&gt;来讨论这个过程。整个 TLS 通信流程图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070646273-169528725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程&lt;/li&gt;
&lt;li&gt;ClientHello：客户端通过向服务器发送 &lt;code&gt;hello&lt;/code&gt; 消息来发起握手过程。这个消息中会夹带着客户端支持的 &lt;code&gt;TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)&lt;/code&gt; 、客户端支持的密码套件、以及一串 &lt;code&gt;客户端随机数&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。&lt;/li&gt;
&lt;li&gt;认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 &lt;code&gt;Certificate&lt;/code&gt; 报文，报文中包含公开密钥证书。最后服务器发送 &lt;code&gt;ServerHelloDone&lt;/code&gt; 作为 &lt;code&gt;hello&lt;/code&gt; 请求的响应。第一部分握手阶段结束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;加密阶段&lt;/code&gt;：在第一个阶段握手完成后，客户端会发送 &lt;code&gt;ClientKeyExchange&lt;/code&gt; 作为响应，这个响应中包含了一种称为 &lt;code&gt;The premaster secret&lt;/code&gt; 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 &lt;code&gt;ChangeCipherSpec&lt;/code&gt;，告诉服务端使用私钥解密这个 &lt;code&gt;premaster secret&lt;/code&gt; 的字符串，然后客户端发送 &lt;code&gt;Finished&lt;/code&gt; 告诉服务端自己发送完成了。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Session key 其实就是用公钥证书加密的公钥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;实现了安全的非对称加密&lt;/code&gt;：然后，服务器再发送 &lt;code&gt;ChangeCipherSpec&lt;/code&gt; 和 &lt;code&gt;Finished&lt;/code&gt; 告诉客户端解密完成，至此实现了 RSA 的非对称加密。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&quot;&gt;What is a TLS handshake?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.omnisecu.com/tcpip/recursive-and-iterative-dns-queries.php&quot;&gt;Recursive and Iterative DNS Queries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qingdaofu/p/7399670.html&quot;&gt;DNS递归查询与迭代查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Andya/p/7272462.html&quot;&gt;TCP三次握手和四次挥手过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dosarrest.com/ddos-blog/http1-0-and-1-1-what-are-the-differences/&quot;&gt;HTTP/1.0 AND 1.1, WHAT ARE THE DIFFERENCES?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/tcp-connection-termination/&quot;&gt;TCP Connection Termination&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment&quot;&gt;Transmission_Control_Protocol&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/syn&quot;&gt;SYN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.guru99.com/tcp-3-way-handshake.html&quot;&gt;TCP 3-Way Handshake (SYN, SYN-ACK,ACK)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34074946&quot;&gt;HTTP/2 相比 1.0 有哪些重大改进？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.guru99.com/tcp-vs-udp-understanding-the-difference.html&quot;&gt;TCP vs UDP: What's the Difference?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yuqilin520/article/details/82915269&quot;&gt;计算机网络7层模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yicixing7/article/details/79320821&quot;&gt;HTTP常见面试题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202004/1515111-20200420070706562-1307313439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Apr 2020 23:08:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>HTTP 和 HTTPS 的区别 HTTP 是一种 ， HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范 HTTP 主要内容分为三部分， 超文本（Hype</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/12735623.html</dc:identifier>
</item>
<item>
<title>实例讲解Springboot整合MongoDB进行CRUD操作的两种方式 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/12735620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/12735620.html</guid>
<description>&lt;p&gt;&lt;code&gt;Springboot&lt;/code&gt;是最简单的使用&lt;code&gt;Spring&lt;/code&gt;的方式，而&lt;code&gt;MongoDB&lt;/code&gt;是最流行的&lt;code&gt;NoSQL&lt;/code&gt;数据库。两者在分布式、微服务架构中使用率极高，本文将用实例介绍如何在&lt;code&gt;Springboot&lt;/code&gt;中整合&lt;code&gt;MongoDB&lt;/code&gt;的两种方法：&lt;code&gt;MongoRepository&lt;/code&gt;和&lt;code&gt;MongoTemplate&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202004/946674-20200420070100797-1205459233.jpg&quot; alt=&quot;code&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-启动mongodb实例&quot;&gt;2.1 启动MongoDB实例&lt;/h2&gt;
&lt;p&gt;为了方便，使用&lt;code&gt;Docker&lt;/code&gt;来启动&lt;code&gt;MongoDB&lt;/code&gt;，详细指导文档请参考：&lt;a href=&quot;https://www.pkslow.com/archives/start-mongodb-with-docker&quot;&gt;用Docker安装一个MongoDB最新版玩玩&lt;/a&gt; ，这里不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;22-引入相关依赖&quot;&gt;2.2 引入相关依赖&lt;/h2&gt;
&lt;p&gt;主要的依赖为&lt;code&gt;Web&lt;/code&gt;和&lt;code&gt;MongoDB&lt;/code&gt;的&lt;code&gt;starter&lt;/code&gt;，把下面代码加入到&lt;code&gt;pom.xml&lt;/code&gt;中即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-配置数据库连接信息&quot;&gt;2.3 配置数据库连接信息&lt;/h2&gt;
&lt;p&gt;与配置&lt;code&gt;MySQL&lt;/code&gt;或&lt;code&gt;Oracle&lt;/code&gt;一样，&lt;code&gt;MongoDB&lt;/code&gt;也需要配置连接信息，配置在&lt;code&gt;application.properties&lt;/code&gt;中如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;server.port=8080

spring.data.mongodb.authentication-database=admin
spring.data.mongodb.database=testdb
spring.data.mongodb.username=user
spring.data.mongodb.password=123456
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24-创建数据模型实体&quot;&gt;2.4 创建数据模型实体&lt;/h2&gt;
&lt;p&gt;创建&lt;code&gt;User&lt;/code&gt;类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.model;

import org.springframework.data.annotation.Id;
import java.util.Date;

public class User {
    @Id
    private String userId;
    private String name;
    private Integer age;
    private Date createTime = new Date();

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不需要在&lt;code&gt;MongoDB&lt;/code&gt;中创建对应的&lt;code&gt;Collections&lt;/code&gt;（表），当通过Web应用新增时会自动创建。&lt;/p&gt;

&lt;h2 id=&quot;31-定义数据访问层userrepository&quot;&gt;3.1 定义数据访问层UserRepository&lt;/h2&gt;
&lt;p&gt;使用过&lt;code&gt;Spring Jpa&lt;/code&gt;的都清楚，&lt;code&gt;Repository&lt;/code&gt;实际就是用于操作数据库的类。在非关系型数据库&lt;code&gt;MongoDB&lt;/code&gt;的整合中，也是一样的。&lt;code&gt;Spring&lt;/code&gt;会帮我们实现好对应接口的方法，开发人员连&lt;code&gt;SQL&lt;/code&gt;都不用写，非常省心。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.dal;

import com.pkslow.mongo.model.User;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends MongoRepository&amp;lt;User, String&amp;gt; {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;MongoRepository&lt;/code&gt;后面接的泛型&lt;code&gt;&amp;lt;User, String&amp;gt;&lt;/code&gt;第一个为实体类，第二个为主键&lt;code&gt;ID&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;32-实现controller&quot;&gt;3.2 实现Controller&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Controller&lt;/code&gt;比较基础，就不讲解了，常用的注解是必须要掌握的，直接上代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.contrlloer;

import com.pkslow.mongo.dal.UserRepository;
import com.pkslow.mongo.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Autowired
    private final UserRepository userRepository;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping(&quot;&quot;)
    public List&amp;lt;User&amp;gt; getAllUsers() {
        return userRepository.findAll();
    }

    @GetMapping(&quot;/{userId}&quot;)
    public User getByUserId(@PathVariable String userId) {
        return userRepository.findById(userId).orElse(new User());
    }

    @PostMapping(&quot;&quot;)
    public User addNewUser(@RequestBody User user) {
        return userRepository.save(user);
    }

    @DeleteMapping(&quot;/{userId}&quot;)
    public String delete(@PathVariable String userId) {
        User user = new User();
        user.setUserId(userId);
        userRepository.deleteById(userId);
        return &quot;deleted: &quot; + userId;
    }

    @PutMapping(&quot;&quot;)
    public User update(@RequestBody User user) {
        return userRepository.save(user);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意代码没有做异常情况的判断和处理，这里为了快速演示，就先不管了。&lt;/p&gt;
&lt;h2 id=&quot;33-测试&quot;&gt;3.3 测试&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;Postman&lt;/code&gt;测试后，每个接口均调用成功。就不一一截图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202004/946674-20200420070105430-429822646.jpg&quot; alt=&quot;repository.test&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;41-定义数据访问层userdal&quot;&gt;4.1 定义数据访问层UserDAL&lt;/h2&gt;
&lt;p&gt;先定义接口为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.dal;

import com.pkslow.mongo.model.User;
import java.util.List;

public interface UserDAL {
    List&amp;lt;User&amp;gt; findAll();

    User findById(String userId);

    User save(User user);

    void deleteById(String userId);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后实现该接口如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.dal;

import com.pkslow.mongo.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public class UserDALImpl implements UserDAL {

    @Autowired
    private MongoTemplate template;

    @Override
    public List&amp;lt;User&amp;gt; findAll() {
        return template.findAll(User.class);
    }

    @Override
    public User findById(String userId) {
        return template.findById(userId,User.class);
    }

    @Override
    public User save(User user) {
        return template.save(user);
    }

    @Override
    public void deleteById(String userId) {
        Query query = new Query();
        query.addCriteria(Criteria.where(&quot;userId&quot;).is(userId));
        template.remove(query, User.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;42-实现另一个controller&quot;&gt;4.2 实现另一个Controller&lt;/h2&gt;
&lt;p&gt;这个&lt;code&gt;Controller&lt;/code&gt;的代码与之前的基本一样，只是数据访问类不一样，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.mongo.contrlloer;

import com.pkslow.mongo.dal.UserDAL;
import com.pkslow.mongo.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/userTemplate&quot;)
public class UserTemplateController {

    @Autowired
    private final UserDAL userDAL;

    public UserTemplateController(UserDAL userDAL) {
        this.userDAL = userDAL;
    }


    @GetMapping(&quot;&quot;)
    public List&amp;lt;User&amp;gt; getAllUsers() {
        return userDAL.findAll();
    }

    @GetMapping(&quot;/{userId}&quot;)
    public User getByUserId(@PathVariable String userId) {
        return userDAL.findById(userId);
    }

    @PostMapping(&quot;&quot;)
    public User addNewUser(@RequestBody User user) {
        return userDAL.save(user);
    }

    @DeleteMapping(&quot;/{userId}&quot;)
    public String delete(@PathVariable String userId) {
        User user = new User();
        user.setUserId(userId);
        userDAL.deleteById(userId);
        return &quot;deleted: &quot; + userId;
    }

    @PutMapping(&quot;&quot;)
    public User update(@RequestBody User user) {
        return userDAL.save(user);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;43-测试&quot;&gt;4.3 测试&lt;/h2&gt;
&lt;p&gt;测试一样也是全部通过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202004/946674-20200420070105920-1580427006.jpg&quot; alt=&quot;template.test&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文通过实例讲解了如何整合&lt;code&gt;Springboot&lt;/code&gt;和&lt;code&gt;MongoDB&lt;/code&gt;，主要有两种方法：&lt;code&gt;MongoRepository&lt;/code&gt;和&lt;code&gt;MongoTemplate&lt;/code&gt;。代码基本在文章中已经贴出来了，如果还不清楚，可以在&lt;strong&gt;南瓜慢说&lt;/strong&gt;公众号回复&amp;lt;&lt;strong&gt;SpringbootMongoDB&lt;/strong&gt;&amp;gt;获取代码。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt; 获取更多精彩文章！&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202004/946674-20200420070106207-1876552389.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Apr 2020 23:01:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 简介 是最简单的使用 的方式，而 是最流行的 数据库。两者在分布式、微服务架构中使用率极高，本文将用实例介绍如何在 中整合 的两种方法： 和`MongoTemplate`。 代码结构如下： 2 项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/12735620.html</dc:identifier>
</item>
<item>
<title>Camunda 流程引擎的一种 Adapter 层实现 - schaepher</title>
<link>http://www.cnblogs.com/schaepher/p/12735619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/schaepher/p/12735619.html</guid>
<description>&lt;p&gt;上一篇说明了选择 Camunda 的理由。这一篇说明如何实现适配层。&lt;/p&gt;
&lt;blockquote readability=&quot;5.3333333333333&quot;&gt;
&lt;p&gt;当前还没有专门写一篇对 Camunda 各个功能的详细介绍。如果要获得比较直观的感受，可以下载 Modeler 或者使用在线版的 Modeler 。&lt;br/&gt;&lt;a href=&quot;https://demo.bpmn.io/&quot;&gt;https://demo.bpmn.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么要做适配层？&lt;/li&gt;
&lt;li&gt;要对 Camunda 做扩充的部分&lt;/li&gt;
&lt;li&gt;数据表的扩充&lt;/li&gt;
&lt;li&gt;流程实例的操作&lt;/li&gt;
&lt;li&gt;前端动态表单的渲染&lt;/li&gt;
&lt;li&gt;结语&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;现有引擎无法满足业务&lt;br/&gt;如果能满足，加个代理层就够了。&lt;/li&gt;
&lt;li&gt;避免改源码导致升级困难&lt;br/&gt;我们部门有个基于 k8s 源码修改的项目，当年拿过公司的大奖。现在由于没人维护的来，已经凉了。&lt;/li&gt;
&lt;li&gt;可以兼容其他流程引擎&lt;br/&gt;当前选的引擎即使能满足当前业务需要，但未必满足其他业务的需要。更何况要形成一个基础设施给其他组件使用。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;+---------+
|         |
| System  |
|         |
+--+--+---+
   |  ^
   v  |
+--+--+---+
|         |
| Adapter |
|         |
+--+--+---+
   |  ^
   v  |
+--+--+---+
|         |
| Camunda |
|         |
+---------+
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;各业务系统有自己的系统界面，也有各自需要展示的内容，不能直接使用 Camunda 自带的管理界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Camunda 内置的表单支持使得业务系统对其有一定的依赖。要改成在业务层处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Camunda 在一次请求跳转时只能对原任务和目标任务同时应用或者不应用参数检测。但其实应该要在取消原任务的执行时不检测参数，在创建目标任务的执行时检测参数，因此要分两次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;流程和流程实例 ID 是 UUID，但要展示整数 ID 给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;流程实例自动化任务出错时，要转交给运维处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;制定 External Task Client 的规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了适应业务需要，需要另外创建几张数据表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流程定义信息表&lt;/li&gt;
&lt;li&gt;流程实例信息表&lt;/li&gt;
&lt;li&gt;流程节点日志表&lt;/li&gt;
&lt;li&gt;服务定义表&lt;/li&gt;
&lt;li&gt;服务请求客户端管理表&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;流程定义信息表&quot;&gt;流程定义信息表&lt;/h3&gt;
&lt;p&gt;无论是团队内部沟通还是和需求方沟通，最经常用到的用于区别流程的信息是流程的 ID。大家都不太喜欢用流程的名称来沟通，除非是比较少见的流程。而且在各种文档中也是使用流程的 ID。因此这个 ID 信息需要展示给用户。&lt;/p&gt;
&lt;p&gt;由于是从旧系统迁移过来的，所以要保证原先流程的 ID 不变。所以不适用自增 ID 作为流程 ID，而是新增一列专门存储这些 ID。&lt;/p&gt;
&lt;p&gt;以下 pd 表示 process definition，e 表示 engine 。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pd_id&lt;/td&gt;
&lt;td&gt;流程 ID，兼容旧系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pd_key&lt;/td&gt;
&lt;td&gt;底层流程引擎的流程名称，也用于翻译后作为名称展示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pd_version&lt;/td&gt;
&lt;td&gt;当前使用的流程版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pd_version_max&lt;/td&gt;
&lt;td&gt;底层流程引擎的流程最高版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;category&lt;/td&gt;
&lt;td&gt;流程分类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;maintainer&lt;/td&gt;
&lt;td&gt;维护人&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doc_link&lt;/td&gt;
&lt;td&gt;文档地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Camunda 可以通过流程名称和流程版本确定一个特定的流程定义 UUID，所以不需要在这里加上 UUID。&lt;/p&gt;
&lt;p&gt;如果要加入其他引擎，且这些引擎不是用 key 和 version 确定，则可以加入 UUID 字段。并且还需要加入 engine 字段用于标识使用哪个引擎。&lt;/p&gt;
&lt;p&gt;当新版本发布时，e_pd_version_max 加一， e_pd_version 保持不变，只能人为修改。这样便于做测试。&lt;/p&gt;
&lt;p&gt;这一部分没有什么特别的点，实现起来不难。&lt;/p&gt;
&lt;h3 id=&quot;流程实例信息表&quot;&gt;流程实例信息表&lt;/h3&gt;
&lt;p&gt;pi 表示 process instance&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，作为流程实例 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pd_id&lt;/td&gt;
&lt;td&gt;流程 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pi_id&lt;/td&gt;
&lt;td&gt;流程引擎的流程实例 ID，用于与流程引擎的实例保持关联&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pd_key&lt;/td&gt;
&lt;td&gt;底层流程引擎的流程名称，也用于翻译后作为名称展示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pd_version&lt;/td&gt;
&lt;td&gt;当前使用的流程版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e_pi_activity_name&lt;/td&gt;
&lt;td&gt;当前所在的节点名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;流程实例名称，由创建人填写&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;creator&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;创建来源，其他系统可调用 Restful API 创建流程实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;handlers&lt;/td&gt;
&lt;td&gt;处理人，可以有多个&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;当前流程实例状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tags&lt;/td&gt;
&lt;td&gt;标签，作为补充信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;流程实例状态：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;创建&lt;/td&gt;
&lt;td&gt;流程实例刚创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;待提交表单&lt;/td&gt;
&lt;td&gt;需要等待用户提交表单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;等待执行器&lt;/td&gt;
&lt;td&gt;自动化执行步骤，需要等待 External Task Client 获取任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;执行中&lt;/td&gt;
&lt;td&gt;任务执行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;出错&lt;/td&gt;
&lt;td&gt;执行时报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;暂停&lt;/td&gt;
&lt;td&gt;暂停流程实例执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;结束&lt;/td&gt;
&lt;td&gt;正常流程结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;终止&lt;/td&gt;
&lt;td&gt;人工关闭流程或者其他非正常结束关闭&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;自增 ID&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一开始打算直接用 UUID 作为流程实例的 ID，但产品经理说使用跟原系统一样的数字 ID 比较好，用户用起来也比较习惯。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;举个例子，这个有点像 B 站以前用 AV 号而现在用 BV 号给用户带来的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于流程实例本身有权限控制，用自增 ID 也爬不了多少。就算爬了也没有什么影响，所以还是保留了自增 ID，并且初始 ID 设置为比当前流程实例多一个数量级，以保证迁移过程中不会出现 ID 冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前所在的节点名称&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用户在查看列表的时候想直到流程实例的进度，可以用这个名称展示给用户。&lt;/p&gt;
&lt;p&gt;另外还可以作为重启流程实例时跳转的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建来源&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;流程实例有时候碰到问题会回退给创建人，这就要求创建人必须是一个具体的用户。而如果不标注来源，则该具体用户可能无法获取相关信息来解决问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先级&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这个字段用于给 External Task 标注优先级，优先级越高越先执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理人&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;填写表单的人&lt;/li&gt;
&lt;li&gt;自动化步骤出现一些意外的问题，将会转交给相关运维人员处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;流程实例状态&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;对底层引擎流程实例状态的缓存，用于列表查看时减少对底层引擎的查询。&lt;/p&gt;
&lt;p&gt;但是什么时候更新这个状态就成了一个问题。如果没有及时更新，会给用户带来疑惑。比如说流程实例在底层引擎已经结束了，但是这个状态却不是结束状态。后续会对此做详细说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;目前作为一些业务信息的补充，仅用于展示。&lt;/p&gt;
&lt;h3 id=&quot;流程节点日志表&quot;&gt;流程节点日志表&lt;/h3&gt;
&lt;p&gt;这个信息用于展示哪些节点执行过，以及相关时间点和输出信息。&lt;/p&gt;
&lt;p&gt;由于各种数据或者业务问题，或者确实是正常的执行但用户误认为流程实例的流向有问题，这个时候可以参考这些信息。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，没有额外作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;节点标识，用于确定唯一节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;i18n&lt;/td&gt;
&lt;td&gt;翻译标识，用于翻译并展示节点名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pi_id&lt;/td&gt;
&lt;td&gt;流程实例 ID，便于关联和应对底层引擎 ID 的变化&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;执行状态。等待执行、执行中、成功、失败、超时&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;operator&lt;/td&gt;
&lt;td&gt;操作人。可以是用户，也可以是 External Task Client 的 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;结果信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;started_at&lt;/td&gt;
&lt;td&gt;开始执行的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ended_at&lt;/td&gt;
&lt;td&gt;结束执行的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;timeout_at&lt;/td&gt;
&lt;td&gt;超时的时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;节点标识&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用于确定流程中的一个唯一节点，在绘制流程图的时候配置。&lt;/p&gt;
&lt;p&gt;由于同一个功能的节点在流程中可能被使用多次，因此该字段会加上一些无关紧要的信息来相互区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;翻译标识&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;由于同一个功能的节点在流程中可能被使用多次，在不同位置的同一个功能的节点所代表的业务含义不一定是相同的，所以翻译标识要另外指定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程实例 ID&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;由于特殊业务需求，有些流程实例在被强行关闭或者正常结束后，需要重新激活。&lt;/p&gt;
&lt;p&gt;Camunda 提供了这种支持，但它创建了新的流程实例，其流程实例 ID 自然也就和之前的不同。&lt;/p&gt;
&lt;p&gt;这时有两种选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学 Camunda 将流程实例相关信息复制一份，创建新实例&lt;/li&gt;
&lt;li&gt;保持当前实例不变，仅变更实例绑定的底层引擎实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我选择了第二种。因为第一种成本比较高，且在当前业务场景下没有带来价值，用户也不愿意接受。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超时时间&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;设置超时时间是为了避免由于各种不确定性原因导致没有正常结束时，该节点状态没有得到更新，而用户会觉得困惑。&lt;/p&gt;
&lt;h3 id=&quot;服务定义表&quot;&gt;服务定义表&lt;/h3&gt;
&lt;p&gt;该表用于管理节点和 API 的映射关系。&lt;/p&gt;
&lt;p&gt;Camunda 有一种叫做 External Task 的节点类型，表示该任务是外部任务。需要外部系统主动拉取任务并提交结果。外部系统可以将这个拉取并提交结果的功能抽取出来，单独创建一个 External Task Client （以下将其简称为 ETC） 。&lt;/p&gt;
&lt;p&gt;ETC 从 Camunda 拉取特定 Topic 的 External Task，然后执行业务逻辑。&lt;/p&gt;
&lt;p&gt;External Task 的 Topic 在配置流程图的时候指定。ETC 在启动时需要指定 Topic。&lt;/p&gt;
&lt;p&gt;最开始写 ETC 的时候，是参照官方的 JAVA 版本写了一个 PHP 版本。&lt;/p&gt;
&lt;p&gt;整个流程大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+-----------------------------------------+
|                                         |
| Adapter            (5)                  |
|                   Submit                |
|                                         |
|      +--------------------------+       |
|      |                          |       |
|      v             (1)          +       |   (3)
|              Fetch And Lock             | Request
| +----------+               +----------+ |         +--------+
| |          | &amp;lt;-----------+ | External | | +-----&amp;gt; | API    |
| |  Camunda |               | Task     | |         | System |
| |          | +-----------&amp;gt; | Client   | | &amp;lt;-----+ +--------+
| +----------+               +----------+ |
|              External Task              | Response
|                    (2)                  |   (4)
|                                         |
+-----------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式时要解决的一个问题是：如何通过流程图配置的节点信息来判断该节点执行时要请求哪个接口？&lt;/p&gt;
&lt;p&gt;有一个简单的做法是在节点的 Task ID 上应用一些规则。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里使用 “Task ID” 这个表述，是为了和 Camunda 保持一致。这个 Task ID 是一串由英文单词组成的有意义的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如将 Task ID 设置为：&lt;code&gt;Users_Decisions_ShouldDoSomething&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 ETC 获取该节点任务执行时，配置 ETC 将 ID 转化为 &lt;code&gt;POST /users/decisions/should-do-something&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;它的优点在于实现起来简单，缺点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;难以控制请求方式。&lt;br/&gt;只能用 POST。不过如果要用其他的方法，可以将 Task ID 的第一个部分设置为方法，但 Task ID 会变得很长。如 &lt;code&gt;Post_Users_Decisions_ShouldDoSomething&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;难以做到近似的 Restful API 。&lt;br/&gt;比如实现 &lt;code&gt;/users/{uid}&lt;/code&gt; 这种在 URL 上放用户 ID 的功能，需要再对 Task ID 做定制。&lt;/li&gt;
&lt;li&gt;难以控制超时时间。&lt;br/&gt;超时时间是为了在各种问题导致 ETC 无法 complete 一个任务时，只要等待过了超时时间， ETC 就可以重新拉取到该任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;超时时间是在第一步拉取任务的时候设置的，也就是在 ETC 上做配置。但是每个 ETC 只能配置一种超时时间。&lt;/p&gt;
&lt;p&gt;最初的做法是每一种超时时间都设置一个特定 Topic，比如 XXX_3MIN 表示超时时间为 3 分钟。然后启动一些 ETC ，通过启动参数配置对应的超时时间。但是从实践的结果看，这样更新起来不灵活，有时候还需要重启 ETC。&lt;/p&gt;
&lt;p&gt;上面这些问题虽然在 Task ID 上或者 Topic 上多做一些定制化就能完成，但是会使得它们自身变得越来越复杂。并且因为它们都是配置在流程图上的，随着 Task 越来越多，越难以更改。一旦要新加一个规则，会导致所有流程都得改一遍。&lt;/p&gt;
&lt;p&gt;怎么优化呢？&lt;/p&gt;
&lt;p&gt;在 Adapter 层加一个 External Task 定义表。在 ETC 获取到任务后查询这个表，根据查询结果做相应调整。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，没有额外用途&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;task_id&lt;/td&gt;
&lt;td&gt;External Task ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;HTTP 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;url_path&lt;/td&gt;
&lt;td&gt;URL 的 Path 部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;url_query&lt;/td&gt;
&lt;td&gt;URL 的 Query 部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;timeout&lt;/td&gt;
&lt;td&gt;超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;优化后的流程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+-------------------------------------------+
|                                           |
| Adapter              (7)                  |
|                   Complete                |
|                                           |
|        +--------------------------+       |
|        |                          |       |
|        v             (1)          +       |   (5)
|                Fetch And Lock             | Request
|   +----------+               +----------+ |         +--------+
|   |          | &amp;lt;-----------+ | External | | +-----&amp;gt; | API    |
|   |  Camunda |               | Task     | |         | System |
|   |          | +-----------&amp;gt; | Client   | | &amp;lt;-----+ +--------+
|   +----------+               +----------+ |
|                External Task              | Response
|                      (2)        +    ^    |   (6)
|                                 |    |    |
|                      (3)        |    |    |
|                 Fetch API Info  |    |    |
| +------------+                  |    |    |
| | External   | &amp;lt;----------------+    |    |
| | Task       |                       |    |
| | Definition | +---------------------+    |
| +------------+                            |
|                    API Info               |
|                      (4)                  |
|                                           |
+-------------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务请求客户端管理表&quot;&gt;服务请求客户端管理表&lt;/h3&gt;
&lt;p&gt;这个表用于管理 ETC 客户端。&lt;/p&gt;
&lt;p&gt;主要解决两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关闭前等待执行中的任务结束&lt;/li&gt;
&lt;li&gt;ETC 数量动态调整&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;关闭前等待执行中的任务结束&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;有时候要重启 ETC，但是因为 ETC 总是会获取任务执行，所以只能等深夜没有流程在执行的时候重启。&lt;/p&gt;
&lt;p&gt;如果直接关闭的话，会导致任务虽然执行成功了，但由于没有调用 Camunda 的 complete 而超时。超时就会重新执行。&lt;/p&gt;
&lt;p&gt;如果是幂等的接口倒是不会出问题，但有些幂等难度大或者消耗的资源大，二次执行会出问题。&lt;/p&gt;
&lt;p&gt;那么让 Camunda 在 ETC 请求任务的时候不给任务是否可行？因为获取不到新任务后，总是能等到所有 ETC 执行中的任务都结束。&lt;/p&gt;
&lt;p&gt;Camunda 提供了挂起（Suspend）流程实例的功能，虽然能避免流程实例的任务被 Fetch，但同时也使得正在执行的任务无法执行 complete。&lt;/p&gt;
&lt;p&gt;那怎么办？&lt;/p&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ETC 每次执行完一个任务后，就自动重启&lt;/li&gt;
&lt;li&gt;ETC 在向 Camunda 获取任务前，都先查询一下自己能否获取任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里选择第二种，需要额外的表格维护 ETC 的信息。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，没有其他作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etc_id&lt;/td&gt;
&lt;td&gt;客户端 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;topic&lt;/td&gt;
&lt;td&gt;客户端获取的任务的 topic&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;switch&lt;/td&gt;
&lt;td&gt;on/off 控制是否继续获取任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;ETC 数量动态调整&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;调整的依据来自于两方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流程实例的数量&lt;/li&gt;
&lt;li&gt;业务系统 API 的负载情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果流程实例的量大，且业务系统 API 负载比较低，可以添加更多 ETC ，加快整体的速度。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，没有其他作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;topic&lt;/td&gt;
&lt;td&gt;客户端获取的任务的 topic&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;count&lt;/td&gt;
&lt;td&gt;启动客户端的数量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;手动控制的话，这样就够了。如果要通过采集信息自动控制，那么可以再加两个参数：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;count_max&lt;/td&gt;
&lt;td&gt;启动客户端的最大数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;count_min&lt;/td&gt;
&lt;td&gt;启动客户端的最小数量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;动态表单定义表&quot;&gt;动态表单定义表&lt;/h3&gt;
&lt;p&gt;Camunda 自身支持以下几种类型的表单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌入式 HTML 表单&lt;br/&gt;对 Camunda 依赖性强。&lt;/li&gt;
&lt;li&gt;基于 XML 生成表单&lt;br/&gt;在流程图绘制工具里面定义表单，只能做简单的功能。&lt;/li&gt;
&lt;li&gt;JSF 表单&lt;br/&gt;和嵌入式 HTML 表单类似。&lt;/li&gt;
&lt;li&gt;通用表单&lt;br/&gt;功能太少。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于业务上的表单比较复杂，又不能太过于依赖 Camunda，因此表单的定义和渲染需要另外做。&lt;/p&gt;
&lt;p&gt;表单的功能至少需要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择项动态加载&lt;/li&gt;
&lt;li&gt;丰富的支持&lt;br/&gt;如上传文件和图片展示。&lt;/li&gt;
&lt;li&gt;前端页面数据格式校验&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表单有两种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态表单&lt;br/&gt;把表单定义放在前端，前端直接渲染。&lt;/li&gt;
&lt;li&gt;动态表单&lt;br/&gt;把表单定义放在后端，前端提供基本组件。前端获取后端对表单的配置，根据这个配置做渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们选的是动态表单。一是因为原先的系统就是这么做的，同时也比较灵活；二是因为我们团队没有专门的前端。&lt;/p&gt;
&lt;p&gt;动态表单可以放业务层，也可以放流程引擎 Adapter 层。&lt;/p&gt;
&lt;p&gt;如果想要多个接入流程引擎的系统都可以使用，可以放 Adapter 层。就算有的系统不想用这个动态表单，也完全不影响。流程引擎中台的同事倒是对我们动态表单的实现比较感兴趣。&lt;/p&gt;
&lt;p&gt;分为两张表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表单项组件表&lt;/li&gt;
&lt;li&gt;表单定义表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表单项组件表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;组件名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;组件的配置（Json），主要是数据校验&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;前端用的是 Vue，每个表单项直接对应一个 Component 。&lt;/p&gt;
&lt;p&gt;表单定义表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;p_id&lt;/td&gt;
&lt;td&gt;流程定义 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;form_key&lt;/td&gt;
&lt;td&gt;表单名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;表单版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;group&lt;/td&gt;
&lt;td&gt;表单内部分组，支持翻译&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;cpn_id&lt;/td&gt;
&lt;td&gt;Component ID，表单项组件表中的 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;order&lt;/td&gt;
&lt;td&gt;在表单中所处的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;变量名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;label&lt;/td&gt;
&lt;td&gt;渲染表单时，该组件的展示名称，支持翻译&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;组件的配置（Json），主要是数据校验&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;表单暂存表&quot;&gt;表单暂存表&lt;/h3&gt;
&lt;p&gt;用户在编辑完表单时，可能因为各种原因无法全部填写完，又想保存当前已填写的数据。&lt;/p&gt;
&lt;p&gt;可以创建一个数据表用于存储这些暂存数据，当表单提交后删除这些数据。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增 ID，没有其他作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;pi_id&lt;/td&gt;
&lt;td&gt;流程实例 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;form_key&lt;/td&gt;
&lt;td&gt;表单 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;变量名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;变量值，以 json 形式存储&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;提交后的表单数据去哪了？&lt;/p&gt;
&lt;p&gt;Camunda 里的每个流程实例都可以有对应的流程实例变量集合，可以从下面的接口中获取：&lt;/p&gt;
&lt;blockquote readability=&quot;1.0862068965517&quot;&gt;
&lt;p&gt;Get Process Variables&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/variables/get-variables/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/variables/get-variables/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了便于理解，我画了一张图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+-------------------------+
|                         |
| Process Instance        |
|                         |
| +----------+            |
| |          |            |
| | Global   +&amp;lt;-+         |
| | Variable |  |         |
| | Box      |  | Publish |
| |          |  |         |
| +--------+-+  |         |
|    fetch |    |         |
|          |    |         |
| +--------------------+  |
| |        |    |      |  |
| | Nodes  |    |      |  |
| |        |    |      |  |
| | +---------------+  |  |
| | |      |    |   |  |  |
| | | Node |    |   |  |  |
| | |      v    |   |  |  |
| | | +----+----++  |  |  |
| | | |          |  |  |  |
| | | | Local    |  |  |  |
| | | | Variable |  |  |  |
| | | | Box      |  |  |  |
| | | |          |  |  |  |
| | | +----------+  |  |  |
| | |               |  |  |
| | +---------------+  |  |
| |                    |  |
| +--------------------+  |
|                         |
+-------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即流程实例里面会包含一个全局的流程实例变量盒子，所有流程实例级别的变量都会放进去。&lt;/p&gt;
&lt;p&gt;然后每个节点都有自己的本地变量盒子。它可以从全局盒子获取变量映射到本地盒子，也可以把本地变量发布到全局盒子。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;创建&lt;/li&gt;
&lt;li&gt;暂停和恢复&lt;/li&gt;
&lt;li&gt;节点跳转&lt;/li&gt;
&lt;li&gt;表单处理&lt;/li&gt;
&lt;li&gt;关闭流程实例&lt;/li&gt;
&lt;li&gt;重启流程实例&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;p&gt;先在自建流程实例表添加一条记录，然后把流程实例的 ID 、创建人等一些基本信息作为变量，调用流程引擎创建实例的接口时一起传进去。&lt;/p&gt;
&lt;blockquote readability=&quot;1.0731707317073&quot;&gt;
&lt;p&gt;Start Process Instance&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-definition/post-start-process-instance/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-definition/post-start-process-instance/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些流程实例基本信息的变量在存储到 Camunda 里面时，会给变量名加一个 meta 前缀。&lt;/p&gt;
&lt;p&gt;例如 id 加上前缀后变成 &lt;code&gt;meta__id&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;注意，如果变量名使用下划线，在搜索变量的时候不能用 GET 接口，要用 POST 接口。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6774193548387&quot;&gt;
&lt;p&gt;Get Variable Instances&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/variable-instance/get-query/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/variable-instance/get-query/&lt;/a&gt;&lt;br/&gt;Get Variable Instances (POST)&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/variable-instance/post-query/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/variable-instance/post-query/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;表单处理&quot;&gt;表单处理&lt;/h3&gt;
&lt;h4 id=&quot;先创建流程实例再填表单还是反之？&quot;&gt;先创建流程实例再填表单还是反之？&lt;/h4&gt;
&lt;p&gt;两种都可以。&lt;/p&gt;
&lt;p&gt;我选择的是先创建流程实例再填写表单。&lt;/p&gt;
&lt;p&gt;接下来分析两者的优缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先填写表单再创建流程实例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果表单填写一半时发现没有必要走流程或者由于数据不足不能填完整，就不会创建流程实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果流程里有其他表单，则初始表单与其他表单的处理逻辑不统一&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;先创建流程实例再填表单&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有表单处理逻辑统一&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;必须创建流程实例才能填写表单，如果最终不需要该流程实例，则流程实例列表会多出一个无用的实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个缺点可以缓解。&lt;/p&gt;
&lt;p&gt;我见过一种实现：先创建实例，填完第一个表单后才在自己扩展的实例表中添加该实例。这样用户看流程实例列表就不会有无用的实例。&lt;/p&gt;
&lt;p&gt;但是这个实现有个问题。用户很有可能经常创建流程实例后不提交第一个表单，可能直接返回或者刷新页面丢失该信息。经过一段时间会发现底层引擎保留大量流程实例，以至于流程引擎处理速度变慢。&lt;/p&gt;
&lt;h4 id=&quot;获取当前表单&quot;&gt;获取当前表单&lt;/h4&gt;
&lt;p&gt;由于 Camunda 做的是标准的流程引擎，因此界面中每个用户都会有自己要处理的 UserTask（表单） 列表。&lt;/p&gt;
&lt;p&gt;我们的场景是流程实例只会有一个节点执行，并且表单是和流程实例放在一起的。并且用户要求要一次性查看所有已填表单，包括其他人的表单。所以要从流程实例的角度处理。&lt;/p&gt;
&lt;p&gt;我们需要一个 “获取当前表单” 的接口，但由于上面的原因， Camunda 没有现成的接口。只能自己根据 Camunda 已有接口封装了。&lt;/p&gt;
&lt;ol readability=&quot;-0.36882129277567&quot;&gt;&lt;li readability=&quot;0.17808219178082&quot;&gt;
&lt;p&gt;获取流程实例当前节点&lt;/p&gt;
&lt;blockquote readability=&quot;1.095652173913&quot;&gt;
&lt;p&gt;Get Activity Instance&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/get-activity-instances/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/get-activity-instances/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据节点 ID 获取 Form Key&lt;/p&gt;
&lt;blockquote readability=&quot;0.71428571428571&quot;&gt;
&lt;p&gt;Get Form Key&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/task/get-form-key/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/task/get-form-key/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;获取 Form Key 后就可以到动态表单定义表里面获取表单的定义，传给前端渲染。&lt;/p&gt;
&lt;h4 id=&quot;表单的暂存&quot;&gt;表单的暂存&lt;/h4&gt;
&lt;p&gt;前面提到表单提交后要删除暂存的数据，因为如果没有删除这些数据，会碰到一个问题：&lt;/p&gt;
&lt;p&gt;当用户将流程实例驳回到前面的表单节点时，用户修改表单但是不选择提交而是暂存，下次用户进入这个表单界面时数据是以 Camunda 里面为准还是暂存的数据为准？&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;如果选择以暂存的数据为准，那么要考虑一个场景：&lt;/p&gt;
&lt;p&gt;用户初次提交表单后，流程实例后面的步骤修改了表单里的某些数据。接着有用户将流程实例驳回到这个表单，此时如果选择以暂存数据为准，会导致表单展示的是未修改的数据，在业务上会出现问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果选择以 Camunda 的数据为准，那么就会导致用户发现其修改并暂存的数据不见了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以删除暂存数据是一种解决方案，如果暂存表里面有数据，就以暂存表为准，否则以 Camunda 为准。&lt;/p&gt;
&lt;h4 id=&quot;表单数据校验&quot;&gt;表单数据校验&lt;/h4&gt;
&lt;p&gt;数据校验分为两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据类型校验&lt;/li&gt;
&lt;li&gt;业务关系校验&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Camunda 自身支持数据类型校验，但如果有复杂的类型就得在引擎层面自定义校验类。&lt;/p&gt;
&lt;p&gt;并且由于业务关系校验不能放在引擎层面，所以两者一起放在业务系统层面处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                  数据格式
 数据格式          业务关系
 校验             校验

+-------+        +--------+        +---------+
|       | submit |        | submit |         |
| front |        | system |        | engine  |
|  end  | +----&amp;gt; |        | +----&amp;gt; | adapter |
|       |        |        |        |         |
+-------+        +--------+        +---------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;暂存的接口一般只会执行数据格式的校验，并且不对是否必填做校验。&lt;/p&gt;
&lt;h4 id=&quot;提交表单&quot;&gt;提交表单&lt;/h4&gt;
&lt;p&gt;提交表单到 Adapter 层的时候要做以下校验：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前节点是否是表单节点&lt;/li&gt;
&lt;li&gt;当前表单节点的 Form Key 是否与提交的 Form Key 一致&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;流程实例转交&quot;&gt;流程实例转交&lt;/h4&gt;
&lt;p&gt;转交分为两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表单节点转交&lt;/li&gt;
&lt;li&gt;自动化节点转交&lt;br/&gt;指的是将操作权交给其他人，一般自动化节点出现错误的时候，会转交给运维人员处理，运维人员可以转给其他运维同事帮忙处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者都需要修改流程实例信息表中的处理人字段。&lt;/p&gt;
&lt;p&gt;表单节点除此之外还要调用 Camunda 设置操作人的接口：&lt;/p&gt;
&lt;blockquote readability=&quot;0.70588235294118&quot;&gt;
&lt;p&gt;Set Assignee&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/task/post-assignee/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/task/post-assignee/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;暂停和恢复&quot;&gt;暂停和恢复&lt;/h3&gt;
&lt;p&gt;Camunda 提供了一个 suspended 接口，用于挂起整个流程实例。使流程实例处于暂停状态。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/put-activate-suspend-by-id/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/put-activate-suspend-by-id/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方文档有关于挂起流程实例的完整说明。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-concepts/#suspend-process-instances&quot;&gt;https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-concepts/#suspend-process-instances&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一旦挂起流程实例，会产生以下影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户无法提交表单&lt;/li&gt;
&lt;li&gt;External Task Client （以下简称 ETC） 的 complete 无效&lt;/li&gt;
&lt;li&gt;用户无法执行跳转节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然无法变更流程实例的执行节点，但是可以修改流程实例的全局变量。&lt;/p&gt;
&lt;p&gt;最初由于节点跳转的需要，没有把挂起直接作为流程实例的暂停功能，下面会对此做出解释。&lt;/p&gt;
&lt;h3 id=&quot;节点跳转&quot;&gt;节点跳转&lt;/h3&gt;
&lt;p&gt;节点跳转最常用的就是驳回功能。之所以不直接说驳回，是因为除了驳回外，有时还需要跳转到后面的节点。&lt;/p&gt;
&lt;p&gt;这是因为自动化流程中，有一些节点会出现难以预测的问题。有的可以通过优化流程图来解决，有的难以通过优化流程图解决。所以需要人工干涉，跳过当前节点的执行或者返回前面的节点执行。&lt;/p&gt;
&lt;h4 id=&quot;跳转的接口&quot;&gt;跳转的接口&lt;/h4&gt;
&lt;p&gt;Camunda 对节点跳转的支持是在流程实例修改接口。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/post-modification/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/post-modification/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它可以取消一个节点的执行（cancel），也可以开启一个节点的执行（startBeforeActivity）。&lt;/p&gt;
&lt;p&gt;执行修改接口时，有一个参数需要注意： skipIoMappings 。这个参数表示是否跳过节点输入输出映射的校验。为了解释这个参数，得先做个补充说明。&lt;/p&gt;
&lt;p&gt;External Task 有个输入输出变量（Input/Output Variable）配置。用于将全局变量映射到本地变量（Input），或者将本地变量发布到全局变量（Output）。&lt;/p&gt;
&lt;p&gt;当开始执行一个 Task 之前，会对 Input Variable 执行映射。此时如果映射配置中的全局变量不存在，就会报错。因为变量不存在是一个错误的状态，不能强行执行。结束一个 Task 则会对 Output Variable 执行映射。&lt;/p&gt;
&lt;p&gt;如果一个 External Task 没有执行完，就不会生成 Output Variable 所需的本地变量。这个时候如果取消该执行，会默认进入映射变量的逻辑，导致出错。所以用 cancel 的时候需要开启 skipIoMappings 。&lt;/p&gt;
&lt;p&gt;而跳转到目标节点时，又需要校验 Input Variable 映射所需的全局变量是否存在，否则强行执行会有问题。此时应该关闭 skipIoMappings 。&lt;/p&gt;
&lt;p&gt;但 Camunda 这个 modification 接口的 skipIoMappings 放在最外层，表示一次只能设置一种 skipIoMappings 。&lt;/p&gt;
&lt;p&gt;另外 skipCustomListeners 总是开启。&lt;/p&gt;
&lt;p&gt;因此想要实现跳转，就得分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在目标节点 startBeforeActivity ， 请求时关闭 skipIoMappings ，开启 skipCustomListeners&lt;/li&gt;
&lt;li&gt;如果上一步成功，则在当前节点 cancel ， 请求时开启 skipIoMappings ，开启 skipCustomListeners&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意一个问题：&lt;/p&gt;
&lt;p&gt;执行跳转的接口前要保证流程已处于暂停状态。否则如果 cancel 节点时，节点已经完毕并转入下一个节点，就会出现 cancel 失败并且此时流程有两个执行的节点。&lt;/p&gt;
&lt;p&gt;但是如果用流程实例挂起接口使流程实例处于暂停状态，也会受到挂起状态的限制而没办法执行跳转。&lt;/p&gt;
&lt;h4 id=&quot;支持跳转的暂停状态&quot;&gt;支持跳转的暂停状态&lt;/h4&gt;
&lt;p&gt;暂停的实现经历过两个版本。&lt;/p&gt;
&lt;p&gt;最初版本中，节点跳转前要求用户必须先手动暂停流程实例。&lt;/p&gt;
&lt;p&gt;前面提到挂起流程实例后无法跳转节点，所以专门为当时的流程实例设置一个暂停的状态。&lt;/p&gt;
&lt;p&gt;如何实现可跳转节点的暂停？&lt;/p&gt;
&lt;p&gt;这里要处理流程实例节点的两种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;还未被 ETC 获取。此时可以想办法让 ETC 没办法获取到处于暂停状态的流程实例的任务。&lt;/li&gt;
&lt;li&gt;已经被 ETC 获取。此时可以让 ETC 不执行 complete&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来详细说明。&lt;/p&gt;
&lt;p&gt;首先是 &lt;strong&gt;还未被 ETC 获取&lt;/strong&gt; 的场景。&lt;/p&gt;
&lt;p&gt;如何让 ETC 不获取暂停状态的流程实例？&lt;/p&gt;
&lt;p&gt;通过查询文档得知流程实例碰到 &lt;code&gt;failedExternalTask&lt;/code&gt; 这种 Incident 的时候， ETC 不会获取该流程实例的任务。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/user-guide/process-engine/incidents/#incident-types&quot;&gt;https://docs.camunda.org/manual/latest/user-guide/process-engine/incidents/#incident-types&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么如何生成这种 Incident ？&lt;/p&gt;
&lt;p&gt;Incident 没有一个 create 的接口，所以无法直接创建。&lt;/p&gt;
&lt;p&gt;从刚才的文档上可以看到当 retries &amp;lt;= 0 的时候会生成 &lt;code&gt;failedExternalTask&lt;/code&gt; 类型的 Incident 。&lt;/p&gt;
&lt;p&gt;每个 External Task 的 retries 值默认为 1 。当 ETC 报告一个错误的时候，将 retries 减一。&lt;/p&gt;
&lt;p&gt;但是用户如果想要跳转节点，不会想要等到当前节点出错，万一它不出错怎么办？&lt;/p&gt;
&lt;p&gt;通过找文档发现 External Task 有一个设置 retries 的接口。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/external-task/put-retries/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/external-task/put-retries/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尝试直接将 retries 设置为 0 ，发现可以生成 &lt;code&gt;failedExternalTask&lt;/code&gt; 类型的 Incident 。&lt;/p&gt;
&lt;p&gt;这样节点还未被 ETC 获取的场景就得到了处理。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;strong&gt;已经被 ETC 获取&lt;/strong&gt; 的场景。&lt;/p&gt;
&lt;p&gt;在 ETC 获取任务执行后设置 Incident 就没法阻止，并且 Incident 的情况下 ETC 仍然可以 complete ，使得流程继续往下走。所以如果只有上面的处理，点击暂停可能会出现失败的情况。&lt;/p&gt;
&lt;p&gt;这就得在 Adapter 层加一个处理。当 ETC 执行 complete 的时候请求给 Adapter，Adapter 查询流程实例是否有 Incident，如果有就不提交给 Camunda。&lt;/p&gt;
&lt;p&gt;但如果在查询到没 Incident 和提交给 Camunda 之间设置了 Incident 呢？&lt;/p&gt;
&lt;p&gt;这个问题在于没办法通过接口请求对 Camunda 的表直接加锁。&lt;/p&gt;
&lt;p&gt;不过我们可以在自定义的流程实例信息表里的 status 上想办法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在执行暂停的时候，将该流程实例所在行加排他锁，然后更新为暂停状态，更新完释放锁。&lt;/li&gt;
&lt;li&gt;ETC 执行 complete 之前，对流程实例加排他锁，查询到的状态如果是暂停状态，则放弃 complete，否则执行 complete 。之后释放锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;已经被 ETC 获取的场景也处理了。&lt;/p&gt;
&lt;p&gt;上述的暂停只能针对 External Task，其余的就无法暂停了。&lt;/p&gt;
&lt;p&gt;于是我后来重构了这部分代码，把 Incident 和 Suspend 结合在一起，让跳转的时候不需要先手动暂停。&lt;/p&gt;
&lt;p&gt;步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置 Suspend ，防止 ETC 获取任务&lt;/li&gt;
&lt;li&gt;流程实例信息表设置状态为 incident&lt;/li&gt;
&lt;li&gt;设置流程引擎实例 Incident&lt;/li&gt;
&lt;li&gt;取消 Suspend&lt;/li&gt;
&lt;li&gt;设置新节点位置&lt;/li&gt;
&lt;li&gt;取消当前节点，这个动作会连同 Incident 一起删除&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何获取跳转获取目标节点的-task-id&quot;&gt;如何获取跳转获取目标节点的 Task ID&lt;/h4&gt;
&lt;p&gt;有三种做法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以下 “用户” 表示运维人员或者某个用户部门的公共账号，不是所有人都有跳转的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;7.7789360172538&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;通常的做法，即把执行过的节点以下拉菜单的形式列出来，用户选择一个，然后执行。&lt;/p&gt;
&lt;p&gt;要实现这个功能，可以使用节点日志的信息。将节点执行日志中的 Task ID 取出来去重。它的缺点是只能跳转到已经执行过的节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;将流程中所有节点列出来，让用户选择。&lt;/p&gt;
&lt;p&gt;解决了第一种无法跳转到未执行过的节点的问题。但带来新的问题：流程所有节点的信息如何获取？&lt;/p&gt;
&lt;p&gt;Camunda 的接口没有提供这个信息，最多只有流程图的 xml 。解析 xml 是一种方法，不过也比较麻烦。&lt;/p&gt;
&lt;p&gt;如果在发布流程定义的时候将所有节点信息放入一张记录节点信息的表。这不仅需要解析 xml ，还需要添加一张数据表，更麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.0406504065041&quot;&gt;
&lt;p&gt;直接将流程图展示给用户，用户在流程图上选择一个节点，然后点击跳转。&lt;/p&gt;
&lt;p&gt;不仅直观，而且不用自己写解析，直接用 Camunda 的 bpmn-js 。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bpmn-io/bpmn-js&quot;&gt;https://github.com/bpmn-io/bpmn-js&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;bpmn-js 提供了很多示例。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://bpmn.io/toolkit/bpmn-js/examples/&quot;&gt;https://bpmn.io/toolkit/bpmn-js/examples/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/bpmn-io/bpmn-js-examples&quot;&gt;https://github.com/bpmn-io/bpmn-js-examples&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;interaction： 与流程图的交互，点击节点&lt;/li&gt;
&lt;li&gt;overlays： 添加覆盖层。可以在流程节点上加悬浮图标来表示当前所在节点&lt;/li&gt;
&lt;li&gt;colors： 给节点加颜色。比如将所有未执行过的节点设置为灰色，将执行过的节点设置为黑色。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我选择第三种方式。&lt;/p&gt;
&lt;h4 id=&quot;驳回功能&quot;&gt;驳回功能&lt;/h4&gt;
&lt;p&gt;节点跳转的另一个应用是驳回。驳回是流程实例当前具有控制权的用户可以做的动作。&lt;/p&gt;
&lt;p&gt;驳回通常有两种场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户选择驳回到已经执行过的某个节点&lt;br/&gt;前端限制流程图中只能选择已执行过的节点，后端在跳转前查询执行日志判断该节点是否已执行过。&lt;/li&gt;
&lt;li&gt;所有流程实例只会驳回到第一个节点&lt;br/&gt;绘制流程图的时候，为所有流程图的开始节点设置相同的 ID&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;跳过当前节点&quot;&gt;跳过当前节点&lt;/h4&gt;
&lt;p&gt;有的节点只执行一个操作，不生成任何对流程实例流转有影响的数据。这种节点会因为各种奇怪的原因执行出错，运维人员需要介入处理这些问题。处理完后跳过这些节点。&lt;/p&gt;
&lt;p&gt;Camunda 有一个接口可以直接做到这件事：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/signal/post-signal/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/signal/post-signal/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关说明文档：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/bpmn20/events/signal-events/&quot;&gt;https://docs.camunda.org/manual/latest/reference/bpmn20/events/signal-events/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始用过这个接口，不过后来取消了。还是让运维人员选择目标节点比较安全。&lt;/p&gt;
&lt;h3 id=&quot;流程实例迁移（升级）&quot;&gt;流程实例迁移（升级）&lt;/h3&gt;
&lt;p&gt;当流程发布新版本之后，不会对已有的流程实例造成影响。如果想应用最新版本流程，则需要升级旧流程实例。&lt;/p&gt;
&lt;p&gt;流程实例迁移分为三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.504&quot;&gt;生成迁移计划
&lt;blockquote readability=&quot;1.3018867924528&quot;&gt;
&lt;p&gt;Generate Migration Plan&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/migration/generate-migration/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/migration/generate-migration/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.48461538461538&quot;&gt;验证迁移计划
&lt;blockquote readability=&quot;1.2432432432432&quot;&gt;
&lt;p&gt;Validate Migration Plan&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/migration/validate-migration-plan/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/migration/validate-migration-plan/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;执行迁移计划
&lt;blockquote readability=&quot;1.2692307692308&quot;&gt;
&lt;p&gt;Execute Migration Plan&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/migration/execute-migration/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/migration/execute-migration/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成迁移计划和验证迁移计划的时候，不会涉及具体的流程实例 ID。&lt;/p&gt;
&lt;p&gt;执行迁移计划的时候，可以选择要迁移的具体流程实例 ID，也可以用查询的方式指定要迁移的流程实例。&lt;/p&gt;
&lt;h3 id=&quot;关闭流程实例&quot;&gt;关闭流程实例&lt;/h3&gt;
&lt;p&gt;使用 Camunda 的 Delete 接口就行了。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3663366336634&quot;&gt;
&lt;p&gt;Delete Process Instance&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/delete/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/delete/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;重启流程实例&quot;&gt;重启流程实例&lt;/h3&gt;
&lt;p&gt;Camunda 会用旧流程实例的信息来启动一个新的流程实例。&lt;/p&gt;
&lt;blockquote readability=&quot;1.0909090909091&quot;&gt;
&lt;p&gt;Restart Process Instance&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-definition/post-restart-process-instance-sync/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-definition/post-restart-process-instance-sync/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于会创建一个新的流程实例，其 ID 与旧实例的 ID 不一致，因此得将流程实例信息表中的引擎流程实例 ID 替换掉。&lt;/p&gt;
&lt;p&gt;这里会碰到一个问题： Camunda 重启实例的接口不会返回新实例的 ID 。&lt;/p&gt;
&lt;p&gt;还好我们之前在创建流程实例的时候，会往底层 Camunda 的全局变量盒保存自增 ID ： &lt;code&gt;meta__id&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以通过流程实例搜索接口找到有保存 &lt;code&gt;meta__id&lt;/code&gt; 为指定 ID 的流程实例。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1764705882353&quot;&gt;
&lt;p&gt;Get Instances (POST)&lt;br/&gt;&lt;a href=&quot;https://docs.camunda.org/manual/latest/reference/rest/process-instance/post-query/&quot;&gt;https://docs.camunda.org/manual/latest/reference/rest/process-instance/post-query/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后将获取到的流程实例 ID 更新到流程实例信息表里面。&lt;/p&gt;

&lt;p&gt;写一个主 Component，然后在里面写具体的各个组件。&lt;/p&gt;
&lt;p&gt;遍历后端传的各组件名称，创建多个主 Component。然后用组件名称依次匹配里面的各个组件，如果匹配到则展示。这里用到了 Vue 的 &lt;code&gt;v-if&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;目前能想到的基本上都写了。有一些细节的地方没有深入讨论，待后续继续完善。&lt;/p&gt;
&lt;p&gt;这篇没有完全地按照当前项目写的适配层的实践来写，而是在此基础上做了一些优化。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Apr 2020 22:57:00 +0000</pubDate>
<dc:creator>schaepher</dc:creator>
<og:description>上一篇说明了选择 Camunda 的理由。这一篇说明如何实现适配层。 当前还没有专门写一篇对 Camunda 各个功能的详细介绍。如果要获得比较直观的感受，可以下载 Modeler 或者使用在线版的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/schaepher/p/12735619.html</dc:identifier>
</item>
</channel>
</rss>