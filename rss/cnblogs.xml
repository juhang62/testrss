<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习之支持向量机原理和sklearn实践 - Fate0729</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/11107042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/11107042.html</guid>
<description>&lt;p&gt;&lt;strong&gt;问题:&lt;/strong&gt;如何对对下图的线性可分数据集和线性不可分数据集进行分类？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201906/1117865-20190629163957360-1060528923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)对线性可分数据集找到最优分割超平面&lt;/li&gt;
&lt;li&gt;(2)将线性不可分数据集通过某种方法转换为线性可分数据集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面将带着这两个问题对支持向量机相关问题进行总结&lt;/p&gt;

&lt;p&gt;一般地，当训练数据集线性可分时，存在无穷个分离超平面可将两类数据正确分开，比如感知机求得的分离超平面就有无穷多个，为了求得唯一的最优分离超平面，就需要使用间隔最大化的支持向量机&lt;/p&gt;
&lt;h2 id=&quot;分类预测确信度&quot;&gt;2.1 分类预测确信度&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201906/1117865-20190629164012476-680330451.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，有A,B,C三个点，表示三个示例，均在分离超平面的正类一侧，点A距分离超平面较远，若预测点为正类，就比较确信预测是正确的；点C距离超平面较近，若预测该点为正类，就不那么确信；点B介于点A与C之间，预测其为正类的确信度也在A与C之间&lt;/p&gt;
&lt;p&gt;通过上面的描述，当训练集中的所有数据点都距离分隔平面足够远时，确信度就越大。在超平面&lt;span class=&quot;math inline&quot;&gt;\(w^T X + b = 0\)&lt;/span&gt;确定的情况下，可以通过函数间隔和几何间隔来确定数据点离分割超平面的距离&lt;/p&gt;
&lt;h2 id=&quot;函数间隔&quot;&gt;2.2 函数间隔&lt;/h2&gt;
&lt;p&gt;对于给定的训练数据集T和超平面（w,b）,定义超平面（w,b）关于样本&lt;span class=&quot;math inline&quot;&gt;\(（x_i,y_i）\)&lt;/span&gt;的函数间隔为：&lt;span class=&quot;math display&quot;&gt;\[\overline{\gamma{_i}} = y_i(w\bullet{x_i} + b)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义超平面（w,b）关于训练数据集T的函数间隔为超平面（w,b）关于T中所有样本点&lt;span class=&quot;math inline&quot;&gt;\(（x_i,y_i）\)&lt;/span&gt;的函数间隔之最小值：&lt;span class=&quot;math display&quot;&gt;\[\overline{\gamma} = \min\limits_{i=1,...,N}\overline{\gamma{_i}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;函数间隔可以表示分类预测的正确性及确信度，但是选择分离超平面时，只有函数间隔却是不够的&lt;/p&gt;
&lt;h2 id=&quot;几何间隔&quot;&gt;2.3 几何间隔&lt;/h2&gt;
&lt;p&gt;对于给定的训练数据集T和超平面（w,b）,定义超平面（w,b）关于样本点&lt;span class=&quot;math inline&quot;&gt;\(（x_i,y_i）\)&lt;/span&gt;的几何间隔为：&lt;span class=&quot;math display&quot;&gt;\[\gamma{_i} = \frac{y_i(w\bullet{x_i} + b)}{||w||}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义超平面（w,b）关于训练数据集T的几何间隔为超平面（w,b）关于T中所有样本点&lt;span class=&quot;math inline&quot;&gt;\(（x_i,y_i）\)&lt;/span&gt;的几何间隔之最小值：&lt;span class=&quot;math display&quot;&gt;\[\gamma = \min\limits_{i=1,...,N}\gamma_i\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数间隔和几何间隔之间的关系&quot;&gt;2.4 函数间隔和几何间隔之间的关系&lt;/h2&gt;
&lt;p&gt;从上面函数间隔和几何间隔的定义，可以得到函数间隔和几何间隔之间的关系：&lt;span class=&quot;math display&quot;&gt;\[\gamma_i = \frac{\overline{\gamma_i}}{||w||}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\gamma = \frac{\overline{\gamma}}{||w||}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;硬间隔最大化分离超平面&quot;&gt;2.5 硬间隔最大化分离超平面&lt;/h2&gt;
&lt;p&gt;支持向量机学习的基本想法是找到能够正确划分训练数据集并且几何间隔最大的分离超平面，换句话说也就是不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开,硬间隔是与后面说明的软间隔相对应的&lt;/p&gt;
&lt;p&gt;如何求得一个几何间隔最大化的分离超平面，可以表示为下面的约束优化问题：&lt;span class=&quot;math display&quot;&gt;\[\max\limits_{w,b}\quad\gamma\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_.t.\quad\frac{y_i(w\bullet{x_i}+b)}{||w||}\geq\gamma,\quad{i=1,2,...,N}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上面函数间隔和几何间隔之间的关系，转换成下面的同等约束问题：&lt;span class=&quot;math display&quot;&gt;\[\max\limits_{w,b}\quad\frac{\overline{\gamma}}{||w||}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_.t.\quad\ y_i(w\bullet{x_i}+b)\geq\overline{\gamma},\quad{i=1,2,...,N}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于当w,b按比例变换的的时候函数间隔&lt;span class=&quot;math inline&quot;&gt;\(\overline\gamma\)&lt;/span&gt;也会呈比例变化，先取&lt;span class=&quot;math inline&quot;&gt;\(\overline\gamma= 1\)&lt;/span&gt;,再由于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{||w||}\)&lt;/span&gt;最大化和最小化&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}{||w||}^2\)&lt;/span&gt;是等价的，于是得到：&lt;span class=&quot;math display&quot;&gt;\[\min\limits_{w,b}\quad\frac{1}{2}{||w||^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_.t.\quad\ y_i(w\bullet{x_i}+b)\geq 1,\quad{i=1,2,...,N}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由此得到分离超平面：&lt;span class=&quot;math display&quot;&gt;\[w^{*} \bullet x + b^{*} = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分类决策函数：&lt;span class=&quot;math display&quot;&gt;\[f(x) = sign(w^{*} \bullet x + b^{*})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求解拉格朗日对偶函数：&lt;span class=&quot;math display&quot;&gt;\[L(w,b,a) = \frac{1}{2}{||w||}^2 - \sum_{i=1}^na_i[(y_i(x_iw+b)-1)]----(1)\]&lt;/span&gt;&lt;br/&gt;对w求偏导:&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial L}{\partial w} = w - \sum_{i=1}^na_iy_ix_i = 0-----(2)\]&lt;/span&gt;&lt;br/&gt;对b求偏导:&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial L}{\partial b} = \sum_{i=1}^na_iy_i = 0-------(3)\]&lt;/span&gt;&lt;br/&gt;将（2）（3）带入（1）得到：&lt;span class=&quot;math display&quot;&gt;\[maxL(a) = -\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^na_ia_jy_iy_jx_ix_j + \sum_{i=1}^na_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s.t. \quad \sum_{i=1}^na_iy_i = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[a_i &amp;gt;= 0\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;软间隔最大化分离超平面&quot;&gt;2.6 软间隔最大化分离超平面&lt;/h2&gt;
&lt;p&gt;对于线性可分的数据集可以直接使用硬间隔最大化超平面进行划分，但对于线性不可分的某些样本点不能满足函数间隔大于等于1的约束条件，为了解决这个问题，可以对每个样本点&lt;span class=&quot;math inline&quot;&gt;\((x_i,y_i)\)&lt;/span&gt;引进一个松弛变量&lt;span class=&quot;math inline&quot;&gt;\(\xi &amp;gt;= 0\)&lt;/span&gt;,使函数间隔加上松弛变量大于等于1，这样约束条件变为：&lt;span class=&quot;math display&quot;&gt;\[yi(w\bullet x_i + b) &amp;gt;= 1- \xi_{i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时，对每个松弛变量&lt;span class=&quot;math inline&quot;&gt;\(\xi_{i}\)&lt;/span&gt;支付一个代价&lt;span class=&quot;math inline&quot;&gt;\(\xi_{i},目标函数由原来的\)&lt;/span&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}{||w||}^2\)&lt;/span&gt;&lt;span class=&quot;math inline&quot;&gt;\(变为\)&lt;/span&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}{||w||}^2 + C\sum_{i=1}^n{\xi_i}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;C为惩罚系数，一般由应用问题决定，C值大时对误分类的惩罚增大，C值小时对误分类惩罚小&lt;/p&gt;
&lt;p&gt;线性不可分的线性支持向量机的学习问题编程如下凸二次规划问题：&lt;span class=&quot;math display&quot;&gt;\[\min\limits_{w,b,\xi}\quad\frac{1}{2}{||w||^2}+ C\sum_{i=1}^n{\xi_i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_.t.\quad\ y_i(w\bullet{x_i}+b)\geq 1 - \xi_{i},\quad{i=1,2,...,N}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\xi_{i} &amp;gt;= 0,\quad i = 1,2,...,N\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由此得到分离超平面：&lt;span class=&quot;math display&quot;&gt;\[w^{*} \bullet x + b^{*} = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分类决策函数：&lt;span class=&quot;math display&quot;&gt;\[f(x) = sign(w^{*} \bullet x + b^{*})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;拉格朗日对偶函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[maxL(a) = -\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^na_ia_jy_iy_jx_ix_j + \sum_{i=1}^na_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s.t. \quad \sum_{i=1}^na_iy_i = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[a_i &amp;gt;= 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\mu_i &amp;gt;= 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C-a_i-\mu_i = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;支持向量和间隔边界&quot;&gt;2.7 支持向量和间隔边界&lt;/h2&gt;
&lt;p&gt;在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的样本点的示例称为&lt;strong&gt;支持向量&lt;/strong&gt;，支持向量是使约束条件成立的点，即&lt;span class=&quot;math display&quot;&gt;\[\quad\ y_i(w\bullet{x_i}+b) - 1 = 0\]&lt;/span&gt;或&lt;span class=&quot;math display&quot;&gt;\[yi(w\bullet x_i + b) - (1- \xi_{i}) = 0\]&lt;/span&gt;,在&lt;span class=&quot;math inline&quot;&gt;\(y_i = +1\)&lt;/span&gt;的正例点，支持向量在超平面&lt;span class=&quot;math display&quot;&gt;\[H_1:w^Tx + b = 1\]&lt;/span&gt;上，对&lt;span class=&quot;math inline&quot;&gt;\(y_i = -1\)&lt;/span&gt;的负例点，支持向量在超平面&lt;span class=&quot;math display&quot;&gt;\[H_2:w^T x + b = -1\]&lt;/span&gt;上，此时&lt;span class=&quot;math inline&quot;&gt;\(H_1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(H_2\)&lt;/span&gt;平行，并且没有实例点落在它们中间，在&lt;span class=&quot;math inline&quot;&gt;\(H_1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(H_2\)&lt;/span&gt;之间形成一条长带，分离超平面与它们平行且位于它们中间，&lt;span class=&quot;math inline&quot;&gt;\(H_1和H_2\)&lt;/span&gt;之间的距离为间隔，间隔依赖于分割超平面的法向量&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;,等于&lt;span class=&quot;math inline&quot;&gt;\(\frac{2}{|w|}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(H_1和H_2\)&lt;/span&gt;为&lt;strong&gt;间隔边界&lt;/strong&gt;，如下图:&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201906/1117865-20190629164117605-111264489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用&lt;/strong&gt;。如果移动支持向量将改变所求的解；但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会变的，由于支持向量在确定分离超平面中起着决定性的作用，所以将这种分类称为&lt;strong&gt;支持向量机&lt;/strong&gt;。支持向量的个数一般很少，所以支持向量机由很少的‘很重要的’训练样本确定&lt;/p&gt;

&lt;h2 id=&quot;数据线性不可分的原因&quot;&gt;3.1 数据线性不可分的原因&lt;/h2&gt;
&lt;p&gt;(1) 数据集本身就是线性不可分隔的&lt;/p&gt;
&lt;p&gt;(2) 数据集中存在噪声，或者人工对数据赋予分类标签出错等情况的原因导致数据集线性不可分&lt;/p&gt;
&lt;h2 id=&quot;常用方法&quot;&gt;3.2 常用方法&lt;/h2&gt;
&lt;p&gt;将线性不可分数据集转换为线性可分数据集常用方法：&lt;/p&gt;
&lt;p&gt;对于原因(2)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要修正模型，加上惩罚系数C,修正后的模型，可以“容忍”模型错误分类的情况，并且通过惩罚系数的约束，使得模型错误分类的情况尽可能合理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于原因(1)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)通过相似函数添加相似特征&lt;/li&gt;
&lt;li&gt;(2)使用核函数(多项式核、高斯RBF核)，将原本的低维特征空间映射到一个更高维的特征空间，从而使得数据集线性可分&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;核技巧在支持向量机中的应用&quot;&gt;3.3 核技巧在支持向量机中的应用&lt;/h2&gt;
&lt;p&gt;注意到在线性支持向量机的对偶问题中，无论是目标函数还是决策函数都只涉及输入实例与实例之间的内积，在对偶问题的目标函数中的内积&lt;span class=&quot;math inline&quot;&gt;\(x_ix_j\)&lt;/span&gt;可以用核函数&lt;span class=&quot;math display&quot;&gt;\[K(x_i,x_j) = \phi (x_i)\bullet \phi(x_j)\]&lt;/span&gt;代替，此时对偶问题的目标函数成为&lt;span class=&quot;math display&quot;&gt;\[maxL(a) = -\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^na_ia_jy_iy_jK(x_i,x_j) + \sum_{i=1}^na_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样，分类决策函数中的内积也可以用核函数代替&lt;span class=&quot;math display&quot;&gt;\[f(x) = sign(\sum_{i=1}^na_i^*y_iK(x_i,x)+b^*)\]&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;SVM特别适用于小型复杂数据集，samples &amp;lt; 100k&lt;/li&gt;
&lt;li&gt;硬间隔分类有两个主要的问题：
&lt;ul&gt;&lt;li&gt;(1) 必须要线性可分&lt;/li&gt;
&lt;li&gt;(2) 对异常值特别敏感，会导致不能很好的泛化或无法找不出硬间隔&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用软间隔分类可以解决硬间隔分类的两个主要问题，尽可能保存街道宽敞和限制间隔违例(即位于街道之上，甚至在错误一边的实例)之间找到良好的平衡&lt;/li&gt;
&lt;li&gt;在Sklean的SVM类中，可以通过超参数C来控制这个平衡，C值越小，则街道越宽，但是违例会越多，如果SVM模型过度拟合，可以试试通过降低C来进行正则化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线性可分linearsvc类&quot;&gt;4.1 线性可分LinearSVC类&lt;/h2&gt;
&lt;h3 id=&quot;linearsvc类重要参数说明&quot;&gt;4.1.1 LinearSVC类重要参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;penalty&lt;/strong&gt;: string,'l1'or'l2',default='l2'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;loss&lt;/strong&gt;: string 'hing'or'squared_hinge',default='squared_hinge',hinge为标准的SVM损失函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dual&lt;/strong&gt;: bool,defalut=True,wen n_samples &amp;gt; n_features,dual=False，SVM的原始问题和对偶问题二者解相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tol&lt;/strong&gt;: float,deafult=le-4,用于提前停止标准&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: float,defult=1.0,为松弛变量的惩罚系数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;multi_class&lt;/strong&gt;: 默认为ovr，该参数不用修改&lt;/li&gt;
&lt;li&gt;更多说明应查看源码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hinge损失函数&quot;&gt;4.1.2 Hinge损失函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;函数max(0,1-t),当t&amp;gt;=1时，函数等于0，如果t&amp;lt;1，其导数为-1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def hinge(x):
    if x &amp;gt;=1 :
        return 0
    else:
        return 1-x&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-2,4,20)
y = [hinge(i) for i in x ]
ax = plt.subplot(111)
plt.ylim([-1,2])
ax.plot(x,y,'r-')
plt.text(0.5,1.5,r'f(t) = max(0,1-t)',fontsize=20)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Figure size 640x480 with 1 Axes&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;linearsvc实例&quot;&gt;4.1.3 LinearSVC实例&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn import datasets
import pandas as pd&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;iris = datasets.load_iris()
print(iris.keys())
print('labels:',iris['target_names'])
features,labels = iris['data'],iris['target']
print(features.shape,labels.shape)

# 分析数据集
print('-------feature_names:',iris['feature_names'])
iris_df = pd.DataFrame(features)
print('-------info:',iris_df.info())
print('--------descibe:',iris_df.describe())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['data', 'target', 'target_names', 'DESCR', 'feature_names', 'filename'])
labels: ['setosa' 'versicolor' 'virginica']
(150, 4) (150,)
-------feature_names: ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
0    150 non-null float64
1    150 non-null float64
2    150 non-null float64
3    150 non-null float64
dtypes: float64(4)
memory usage: 4.8 KB
-------info: None
--------descibe:                 0           1           2           3
count  150.000000  150.000000  150.000000  150.000000
mean     5.843333    3.057333    3.758000    1.199333
std      0.828066    0.435866    1.765298    0.762238
min      4.300000    2.000000    1.000000    0.100000
25%      5.100000    2.800000    1.600000    0.300000
50%      5.800000    3.000000    4.350000    1.300000
75%      6.400000    3.300000    5.100000    1.800000
max      7.900000    4.400000    6.900000    2.500000&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 数据进行预处理
from sklearn.preprocessing import StandardScaler,LabelEncoder
from sklearn.model_selection import RandomizedSearchCV
from sklearn.svm import LinearSVC
from scipy.stats import uniform

# 对数据进行标准化
scaler = StandardScaler()
X = scaler.fit_transform(features)
print(X.mean(axis=0))
print(X.std(axis=0))
# 对标签进行编码
encoder = LabelEncoder()
Y = encoder.fit_transform(labels)

# 调参
svc = LinearSVC(loss='hinge',dual=True)
param_distributions = {'C':uniform(0,10)}
rscv_clf =RandomizedSearchCV(estimator=svc, param_distributions=param_distributions,cv=3,n_iter=20,verbose=2)
rscv_clf.fit(X,Y)
print(rscv_clf.best_params_)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[-1.69031455e-15 -1.84297022e-15 -1.69864123e-15 -1.40924309e-15]
[1. 1. 1. 1.]
Fitting 3 folds for each of 20 candidates, totalling 60 fits
[CV] C=8.266733168092582 .............................................
[CV] .............................. C=8.266733168092582, total=   0.0s
[CV] C=8.266733168092582 .............................................
[CV] .............................. C=8.266733168092582, total=   0.0s
[CV] C=8.266733168092582 .............................................
[CV] .............................. C=8.266733168092582, total=   0.0s
[CV] C=8.140498369662586 .............................................
[CV] .............................. C=8.140498369662586, total=   0.0s
...
...
...
[CV] .............................. C=9.445168322251103, total=   0.0s
[CV] C=9.445168322251103 .............................................
[CV] .............................. C=9.445168322251103, total=   0.0s
[CV] C=2.100443613273717 .............................................
[CV] .............................. C=2.100443613273717, total=   0.0s
[CV] C=2.100443613273717 .............................................
[CV] .............................. C=2.100443613273717, total=   0.0s
[CV] C=2.100443613273717 .............................................
[CV] .............................. C=2.100443613273717, total=   0.0s
{'C': 3.2357870215300046}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 模型评估
y_prab = rscv_clf.predict(X)
result = np.equal(y_prab,Y).astype(np.float32)
print('accuracy:',np.sum(result)/len(result))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;accuracy: 0.9466666666666667&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import accuracy_score,precision_score,recall_score

print('accracy_score:',accuracy_score(y_prab,Y))
print('precision_score:',precision_score(y_prab,Y,average='micro'))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;accracy_score: 0.9466666666666667
precision_score: 0.9466666666666667&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;非线性svm分类svc&quot;&gt;5.1 非线性SVM分类SVC&lt;/h2&gt;
&lt;p&gt;SVC类通过参数kernel的设置可以实现线性和非线性分类，具体参数说明和属性说明如下&lt;/p&gt;
&lt;h3 id=&quot;svc类参数说明&quot;&gt;5.1.1 SVC类参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: 惩罚系数，float,default=1.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kernel&lt;/strong&gt;: string,default='rbf',核函数选择，必须为('linear','poly','rbf','sigmoid','precomputed' or callable)其中一个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;degree&lt;/strong&gt;: 只有当kernel='poly'时才有意义，表示多项式核的深度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gamma&lt;/strong&gt;: float,default='auto',核系数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;coef0,&lt;/strong&gt;: float, optional (default=0.0),Independent term in kernel function,It is only significant in 'poly' and 'sigmoid',影响模型受高阶多项式还是低阶多项式影响的结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shrinking&lt;/strong&gt;: bool,default=True&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;probability&lt;/strong&gt;: bool,default=False&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tol&lt;/strong&gt;: 提前停止参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cache_size&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;class_weight&lt;/strong&gt;: 类标签权重&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;verbose&lt;/strong&gt;: 日志输出类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_iter&lt;/strong&gt;: 最大迭代次数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;decision_function_shape&lt;/strong&gt;: ‘ovo’,'ovr',defalut='ovr'&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random_state&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;svc类属性说明&quot;&gt;5.1.2 SVC类属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;support_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;support_vectors_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_support_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dual_coef_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;coef_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;intercept_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fit_status_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;probA_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;probB_&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;核函数选择&quot;&gt;5.1.3 核函数选择&lt;/h3&gt;
&lt;p&gt;有这么多核函数，该如何决定使用哪一个呢？有一个经验法则是，永远先从线性核函数开始尝试(LinearSVC比SVC(kernel='linear')快的多)，特别是训练集非常大或特征非常多的时候，如果训练集不太大，可以试试高斯RBF核，大多数情况下它都非常好用。如果有多余时间和精力，可以使用交叉验证核网格搜索来尝试一些其他的核函数，特别是那些专门针对你数据集数据结构的和函数&lt;/p&gt;
&lt;h2 id=&quot;gridsearchcv类说明&quot;&gt;5.2 GridSearchCV类说明&lt;/h2&gt;
&lt;h3 id=&quot;gridsearchcv参数说明&quot;&gt;5.2.1 GridSearchCV参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;estimator&lt;/strong&gt;: 估算器，继承于BaseEstimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;param_grid&lt;/strong&gt;: dict,键为参数名，值为该参数需要测试值选项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scoring&lt;/strong&gt;: default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fit_params&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_jobs&lt;/strong&gt;: 设置要并行运行的作业数，取值为None或1，None表示1 job,1表示all processors,default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cv&lt;/strong&gt;: 交叉验证的策略数，None或integer,None表示默认3-fold, integer指定“(分层)KFold”中的折叠数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;verbose&lt;/strong&gt;: 输出日志类型&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gridsearchcv属性说明&quot;&gt;5.2.2 GridSearchCV属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cv_results_&lt;/strong&gt;: dict of numpy(masked) ndarray&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_estimator_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_score_&lt;/strong&gt;: Mean cross-validated score of the best_estimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_params_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_index_&lt;/strong&gt;: int,The index (of the ``cv_results_`` arrays) which corresponds to the best candidate parameter setting&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scorer_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_splits_&lt;/strong&gt;: The number of cross-validation splits (folds/iterations)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refit_time&lt;/strong&gt;: float&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;randomizedsearchcv类说明&quot;&gt;5.3 RandomizedSearchCV类说明&lt;/h2&gt;
&lt;h3 id=&quot;randomizedsearchcv参数说明&quot;&gt;5.3.1 RandomizedSearchCV参数说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;estimator&lt;/strong&gt;: 估算器，继承于BaseEstimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;param_distributions&lt;/strong&gt;: dict,键为参数名，Dictionary with parameters names (string) as keys and distributions or lists of parameters to try. Distributions must provide a ``rvs`` method for sampling (such as those from scipy.stats.distributions). If a list is given, it is sampled uniformly&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_iter&lt;/strong&gt;: 采样次数，default=10&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scoring&lt;/strong&gt;: default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fit_params&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_jobs&lt;/strong&gt;: 设置要并行运行的作业数，取值为None或1，None表示1 job,1表示all processors,default=None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cv&lt;/strong&gt;: 交叉验证的策略数，None或integer,None表示默认3-fold, integer指定“(分层)KFold”中的折叠数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;verbose&lt;/strong&gt;: 输出日志类型&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;randomizedsearchcv属性说明&quot;&gt;5.3.2 RandomizedSearchCV属性说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cv_results_&lt;/strong&gt;: dict of numpy(masked) ndarray&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_estimators_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_score_&lt;/strong&gt;: Mean cross-validated score of the best_estimator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_params_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;best_index_&lt;/strong&gt;: int,The index (of the ``cv_results_`` arrays) which corresponds to the best candidate parameter setting&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scorer_&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n_splits_&lt;/strong&gt;: The number of cross-validation splits (folds/iterations)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refit_time&lt;/strong&gt;: float&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参考资料:&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 23:50:00 +0000</pubDate>
<dc:creator>Fate0729</dc:creator>
<og:description>1. 场景描述 问题:如何对对下图的线性可分数据集和线性不可分数据集进行分类？ 思路: (1)对线性可分数据集找到最优分割超平面 (2)将线性不可分数据集通过某种方法转换为线性可分数据集 下面将带着这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaobingqianrui/p/11107042.html</dc:identifier>
</item>
<item>
<title>Hadoop 三剑客之 —— 集群资源管理器 YARN - 单人影</title>
<link>http://www.cnblogs.com/danrenying/p/11108562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danrenying/p/11108562.html</guid>
<description>&lt;nav&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#一hadoop-yarn-简介&quot;&gt;一、hadoop yarn 简介&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#二YARN架构&quot;&gt;二、YARN架构&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#1-ResourceManager&quot;&gt;1. ResourceManager&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#2-NodeManager&quot;&gt;2. NodeManager&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#3-ApplicationMaster&quot;&gt;3. ApplicationMaster&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#4-Contain&quot;&gt;4. Contain&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#三YARN工作原理简述&quot;&gt;三、YARN工作原理简述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#四YARN工作原理详述&quot;&gt;四、YARN工作原理详述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11108562.html#五提交作业到YARN上运行&quot;&gt;五、提交作业到YARN上运行&lt;/a&gt;&lt;br/&gt;&lt;/nav&gt;&lt;h2 id=&quot;一hadoop-yarn-简介&quot;&gt;一、hadoop yarn 简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Apache YARN&lt;/strong&gt; (Yet Another Resource Negotiator) 是hadoop 2.0 引入的集群资源管理系统。用户可以将各种服务框架部署在YARN上，由YARN进行统一地管理和资源分配。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/yarn-base.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;二yarn架构&quot;&gt;二、YARN架构&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/Figure3Architecture-of-YARN.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;resourcemanager&quot;&gt;1. ResourceManager&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ResourceManager&lt;/code&gt;通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。&lt;code&gt;ResourceManager&lt;/code&gt;负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。&lt;/p&gt;
&lt;h3 id=&quot;nodemanager&quot;&gt;2. NodeManager&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NodeManager&lt;/code&gt;是YARN集群中的每个具体节点的管理者。主要负责该节点内所有容器的生命周期的管理，监视资源和跟踪节点健康。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动时向&lt;code&gt;ResourceManager&lt;/code&gt;注册并定时发送心跳消息，等待&lt;code&gt;ResourceManager&lt;/code&gt;的指令；&lt;/li&gt;
&lt;li&gt;维护&lt;code&gt;Container&lt;/code&gt;的生命周期，监控&lt;code&gt;Container&lt;/code&gt;的资源使用情况；&lt;/li&gt;
&lt;li&gt;管理任务运行时的相关依赖，根据&lt;code&gt;ApplicationMaster&lt;/code&gt;的需要，在启动&lt;code&gt;Container&lt;/code&gt;之前将需要的程序及其依赖拷贝到本地。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;applicationmaster&quot;&gt;3. ApplicationMaster&lt;/h3&gt;
&lt;p&gt;在用户提交一个应用程序时，YARN会启动一个轻量级的进程&lt;code&gt;ApplicationMaster&lt;/code&gt;。&lt;code&gt;ApplicationMaster&lt;/code&gt;负责协调来自 &lt;code&gt;ResourceManager&lt;/code&gt;的资源，并通过&lt;code&gt;NodeManager&lt;/code&gt; 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据应用的运行状态来决定动态计算资源需求；&lt;/li&gt;
&lt;li&gt;向&lt;code&gt;ResourceManager&lt;/code&gt;申请资源，监控申请的资源的使用情况；&lt;/li&gt;
&lt;li&gt;跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；&lt;/li&gt;
&lt;li&gt;负责任务的容错。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;contain&quot;&gt;4. Contain&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当AM向RM申请资源时，RM为AM返回的资源是用&lt;code&gt;Container&lt;/code&gt;表示的。YARN会为每个任务分配一个&lt;code&gt;Container&lt;/code&gt;，该任务只能使用该&lt;code&gt;Container&lt;/code&gt;中描述的资源。&lt;code&gt;ApplicationMaster&lt;/code&gt;可在&lt;code&gt;Container&lt;/code&gt;内运行任何类型的任务。例如，&lt;code&gt;MapReduce ApplicationMaster&lt;/code&gt;请求一个容器来启动 map 或 reduce 任务，而&lt;code&gt;Giraph ApplicationMaster&lt;/code&gt;请求一个容器来运行 Giraph 任务。&lt;/p&gt;
&lt;h2 id=&quot;三yarn工作原理简述&quot;&gt;三、YARN工作原理简述&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/yarn%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AE%80%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;提交作业到YARN上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Resource Manager&lt;/code&gt;选择一个&lt;code&gt;Node Manager&lt;/code&gt;，启动一个&lt;code&gt;Container&lt;/code&gt;并运行&lt;code&gt;Application Master&lt;/code&gt;实例；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Application Master&lt;/code&gt;根据实际需要向&lt;code&gt;Resource Manager&lt;/code&gt;请求更多的&lt;code&gt;Container&lt;/code&gt;资源（如果作业很小, 应用管理器会选择在其自己的JVM中运行任务）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Application Master&lt;/code&gt;通过获取到的&lt;code&gt;Container&lt;/code&gt;资源执行分布式计算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四yarn工作原理详述&quot;&gt;四、YARN工作原理详述&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/yarn%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&quot;/&gt;&lt;/div&gt;
&lt;h4 id=&quot;作业提交&quot;&gt;1. 作业提交&lt;/h4&gt;
&lt;p&gt;client调用job.waitForCompletion方法，向整个集群提交MapReduce作业 (第1步) 。新的作业ID(应用ID)由资源管理器分配(第2步)。作业的client核实作业的输出, 计算输入的split, 将作业的资源(包括Jar包，配置文件, split信息)拷贝给HDFS(第3步)。 最后, 通过调用资源管理器的submitApplication()来提交作业(第4步)。&lt;/p&gt;
&lt;h4 id=&quot;作业初始化&quot;&gt;2. 作业初始化&lt;/h4&gt;
&lt;p&gt;当资源管理器收到submitApplciation()的请求时, 就将该请求发给调度器(scheduler), 调度器分配container, 然后资源管理器在该container内启动应用管理器进程, 由节点管理器监控(第5步)。&lt;/p&gt;
&lt;p&gt;MapReduce作业的应用管理器是一个主类为MRAppMaster的Java应用，其通过创造一些bookkeeping对象来监控作业的进度, 得到任务的进度和完成报告(第6步)。然后其通过分布式文件系统得到由客户端计算好的输入split(第7步)，然后为每个输入split创建一个map任务, 根据mapreduce.job.reduces创建reduce任务对象。&lt;/p&gt;
&lt;h4 id=&quot;任务分配&quot;&gt;3. 任务分配&lt;/h4&gt;
&lt;p&gt;如果作业很小, 应用管理器会选择在其自己的JVM中运行任务。&lt;/p&gt;
&lt;p&gt;如果不是小作业, 那么应用管理器向资源管理器请求container来运行所有的map和reduce任务(第8步)。这些请求是通过心跳来传输的, 包括每个map任务的数据位置，比如存放输入split的主机名和机架(rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入split的节点相同机架的节点。&lt;/p&gt;
&lt;h4 id=&quot;任务运行&quot;&gt;4. 任务运行&lt;/h4&gt;
&lt;p&gt;当一个任务由资源管理器的调度器分配给一个container后，应用管理器通过联系节点管理器来启动container(第9步)。任务由一个主类为YarnChild的Java应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR文件, 以及分布式缓存的所有文件(第10步。 最后, 运行map或reduce任务(第11步)。&lt;/p&gt;
&lt;p&gt;YarnChild运行在一个专用的JVM中, 但是YARN不支持JVM重用。&lt;/p&gt;
&lt;h4 id=&quot;进度和状态更新&quot;&gt;5. 进度和状态更新&lt;/h4&gt;
&lt;p&gt;YARN中的任务将其进度和状态(包括counter)返回给应用管理器, 客户端每秒(通mapreduce.client.progressmonitor.pollinterval设置)向应用管理器请求进度更新, 展示给用户。&lt;/p&gt;
&lt;h4 id=&quot;作业完成&quot;&gt;6. 作业完成&lt;/h4&gt;
&lt;p&gt;除了向应用管理器请求作业进度外, 客户端每5分钟都会通过调用waitForCompletion()来检查作业是否完成，时间间隔可以通过mapreduce.client.completion.pollinterval来设置。作业完成之后, 应用管理器和container会清理工作状态， OutputCommiter的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。&lt;/p&gt;
&lt;h2 id=&quot;五提交作业到yarn上运行&quot;&gt;五、提交作业到YARN上运行&lt;/h2&gt;
&lt;p&gt;这里以提交Hadoop Examples中计算Pi的MApReduce程序为例，相关Jar包在Hadoop安装目录的&lt;code&gt;share/hadoop/mapreduce&lt;/code&gt;目录下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 提交格式: hadoop jar jar包路径 主类名称 主类参数
# hadoop jar hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar pi 3 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol readability=&quot;-0.013333333333333&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeOfLife/p/5492740.html&quot;&gt;初步掌握Yarn的架构及原理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YARN.html&quot;&gt;Apache Hadoop 2.9.2 &amp;gt; Apache Hadoop YARN&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.8333333333333&quot;&gt;
&lt;p&gt;更多大数据系列文章可以参见个人 GitHub 开源项目： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;大数据入门指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 29 Jun 2019 23:10:00 +0000</pubDate>
<dc:creator>单人影</dc:creator>
<og:description>一、hadoop yarn 简介 二、YARN架构         1. ResourceManager  &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/danrenying/p/11108562.html</dc:identifier>
</item>
<item>
<title>PhpStorm 配置 PHPUnit - Martini</title>
<link>http://www.cnblogs.com/martini-d/p/phpstorm-pei-zhiphpunit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/martini-d/p/phpstorm-pei-zhiphpunit.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;全局安装phpunit代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-terminal&quot;&gt;composer global require phpunit/phpunit
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码会自动保存在 &lt;code&gt;/User/你的用户名/.composer/vendor/phpunit&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;全局安装phpunit命令脚本&lt;/h2&gt;
&lt;p&gt;从上一步安装结果可以得知当前环境PHP版本可兼容的phpunit的版本，我这里的PHP是5.6的，最大可兼容phpunit5.7&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-terminal&quot;&gt;wget https://phar.phpunit.de/phpunit-5.7.phar
chmod +x phpunit-5.7.phar
sudo mv phpunit-5.7.phar /usr/local/bin/phpunit
phpunit --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;创建 phpunit.xml&lt;/h2&gt;
&lt;p&gt;放在你的项目根目录，这个文件是 phpunit 会默认读取的一个配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&quot;service&quot;&amp;gt;
            &amp;lt;directory&amp;gt;tests&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;
&amp;lt;/phpunit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;配置 PhpStorm 的 PHP CLi&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Languages &amp;amp; Frameworks &amp;gt; PHP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;span&gt;+&lt;/span&gt; 新增一个 PHP 解释器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置 php 执行程序&lt;/li&gt;
&lt;li&gt;点击那个 同步的小图标，如果看到 successfully 就说明配置有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225554220-765926904.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;配置 phpunit.phar 路径和 phpunit.xml 路径&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Languages &amp;amp; Frameworks &amp;gt; PHP &amp;gt; Test Frameworks&lt;/strong&gt;&lt;br/&gt;点击 &lt;span&gt;+&lt;/span&gt; 新增一个 &lt;span&gt;PHPUnit Local&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如我的phpunit本地的路径为/usr/local/bin/phpunit&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225554344-2044375565.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;配置单元测试类提示&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Languages &amp;amp; Frameworks &amp;gt; PHP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如我的phpunit包本地的路径为/Users/maritni/.composer/vendor/phpunit&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225552912-1658876496.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;Class为Demo的测试类为DemoTest&lt;/li&gt;
&lt;li&gt;测试类继承于 PHPUnit\Framework\TestCase&lt;/li&gt;
&lt;li&gt;测试方法
&lt;ul&gt;&lt;li&gt;必须为public权限，&lt;/li&gt;
&lt;li&gt;一般以test开头，也可以给其加注释@test来标识&lt;/li&gt;
&lt;li&gt;在测试方法内，类似于 assertEquals() 这样的断言方法用来对实际值与预期值的匹配做出断言。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
/**
 * Description:数组压入和弹出测试用例
 * Created by Martini
 * DateTime: 2019-06-29 16:09
 */

use PHPUnit\Framework\TestCase;

class DemoTest extends TestCase
{
    public function testPushAndPop()
    {
        $stack = [];
        $this-&amp;gt;assertEquals(0, count($stack));

        array_push($stack, 'foo');
        $this-&amp;gt;assertEquals('foo', $stack[count($stack)-1]);
        $this-&amp;gt;assertEquals(1, count($stack));

        $this-&amp;gt;assertEquals('foo', array_pop($stack));
        $this-&amp;gt;assertEquals(0, count($stack));
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;执行单个文件单元测试&lt;/h2&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;方式1: Phpstorm方式，当前测试类右键Run即可&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225554485-713024919.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;方式2：命令行方式，进入项目目录执行&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;phpunit Creational/SimpleFactory/Tests/DemoTest.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225551598-381545118.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;执行全局单元测试&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;全局单元测试，实际上phpunit会根据xml配置文件进行测试。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;phpstorm方式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1275424/201906/1275424-20190629225551686-963352332.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_14&quot;&gt;命令行方式&lt;/h3&gt;
&lt;p&gt;命令行下进入当前项目执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;phpunit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PHPUnit 的目标之一是测试应当可组合：我们希望能将任意数量的测试以任意组合方式运行，例如，整个项目的所有测试，或者项目中的某个组件内的所有类的测试，又或者仅仅某单个类的测试。&lt;/p&gt;
&lt;p&gt;PHPUnit 支持好几种不同的方式来组织测试以及将它们编排组合成测试套件。&lt;/p&gt;
&lt;p&gt;PHPUnit的 XML 配置文件可以用于编排测试套件。Example1, “用 XML 配置来编排测试套件”展示了一个最小化的 phpunit.xml 例子，它将在递归遍历 tests 时添加所有在 *Test.php 文件中找到的 *Test 类。&lt;/p&gt;
&lt;h2 id=&quot;toc_16&quot;&gt;Example1.最小化xml文件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&quot;money&quot;&amp;gt;
            &amp;lt;directory&amp;gt;tests&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;
&amp;lt;/phpunit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果 &lt;span&gt;phpunit.xml&lt;/span&gt; 或 &lt;span&gt;phpunit.xml.dist&lt;/span&gt; （按此顺序）存在于当前工作目录并且未使用 --configuration，将自动从此文件中读取配置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以明确指定测试的执行顺序：&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_17&quot;&gt;Example 2. 用 XML 配置来编排测试套件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;phpunit bootstrap=&quot;vendor/autoload.php&quot;&amp;gt;
  &amp;lt;testsuites&amp;gt;
    &amp;lt;testsuite name=&quot;money&quot;&amp;gt;
      &amp;lt;file&amp;gt;tests/IntlFormatterTest.php&amp;lt;/file&amp;gt;
      &amp;lt;file&amp;gt;tests/MoneyTest.php&amp;lt;/file&amp;gt;
      &amp;lt;file&amp;gt;tests/CurrencyTest.php&amp;lt;/file&amp;gt;
    &amp;lt;/testsuite&amp;gt;
  &amp;lt;/testsuites&amp;gt;
&amp;lt;/phpunit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_18&quot;&gt;xml实例1&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;phpunit bootstrap=&quot;./vendor/autoload.php&quot; colors=&quot;true&quot;&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&quot;Design Patterns&quot;&amp;gt;
            &amp;lt;directory suffix=&quot;Test.php&quot;&amp;gt;Behavioral/*/Tests&amp;lt;/directory&amp;gt;
            &amp;lt;directory suffix=&quot;Test.php&quot;&amp;gt;Creational/*/Tests&amp;lt;/directory&amp;gt;
            &amp;lt;directory suffix=&quot;Test.php&quot;&amp;gt;More/*/Tests&amp;lt;/directory&amp;gt;
            &amp;lt;directory suffix=&quot;Test.php&quot;&amp;gt;Structural/*/Tests&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;blacklist&amp;gt;
            &amp;lt;directory&amp;gt;./vendor&amp;lt;/directory&amp;gt;
        &amp;lt;/blacklist&amp;gt;
    &amp;lt;/filter&amp;gt;
&amp;lt;/phpunit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_19&quot;&gt;xml实例2&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;phpunit bootstrap=&quot;./booten.php&quot;&amp;gt;

    &amp;lt;testsuite name=&quot;actionsuitetest&quot;&amp;gt;
      &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;action&amp;lt;/directory&amp;gt;

      &amp;lt;file&amp;gt;HuiyuanZhanghuOrder.php&amp;lt;/file&amp;gt;

     &amp;lt;exclude&amp;gt;/action/HuiyuanJifenTest.php&amp;lt;/exclude&amp;gt;
    &amp;lt;/testsuite&amp;gt;
    
    &amp;lt;testsuite name=&quot;modelsuitetest&quot;&amp;gt;
      &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;model&amp;lt;/directory&amp;gt;
    &amp;lt;/testsuite&amp;gt;
    
    &amp;lt;testsuite name=&quot;htmlsuitetest&quot;&amp;gt;
      &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;html&amp;lt;/directory&amp;gt;
    &amp;lt;/testsuite&amp;gt;

    &amp;lt;!-- 代码覆盖率 --&amp;gt;
    &amp;lt;!-- 覆盖率的测试文件，blacklist 黑名单(不需要统计覆盖率的文件)，whitelist 白名单(统计覆盖率的测试文件) 当黑名单与白名单文件重复时，白名单起作用 
    
    --&amp;gt;
    &amp;lt;filter&amp;gt;
&amp;lt;blacklist&amp;gt;
    &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;action&amp;lt;/directory&amp;gt;
    &amp;lt;file&amp;gt;ArrayTest.php&amp;lt;/file&amp;gt;
  &amp;lt;/blacklist&amp;gt;
  
  &amp;lt;whitelist addUncoveredFilesFromWhitelist=&quot;true&quot;&amp;gt;
   &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;action&amp;lt;/directory&amp;gt;
   &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;model&amp;lt;/directory&amp;gt;
   &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;html&amp;lt;/directory&amp;gt;
   &amp;lt;file&amp;gt;ArrayTest.php&amp;lt;/file&amp;gt;
   &amp;lt;exclude&amp;gt;
   &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;action/lib&amp;lt;/directory&amp;gt;
   &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;model&amp;lt;/directory&amp;gt;
   &amp;lt;file&amp;gt;action/lib/Loginxxx.php&amp;lt;/file&amp;gt;
   &amp;lt;/exclude&amp;gt;
  &amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
    
    &amp;lt;!--代码覆盖率报告，可以生成很多类型报告，有html(coverage-html),xml(coverage-clover),txt ,json 等等  
    &amp;lt;log type=&quot;coverage-php&quot; target=&quot;/tmp/coverage.serialized&quot;/&amp;gt;
  &amp;lt;log type=&quot;coverage-text&quot; target=&quot;php://stdout&quot; showUncoveredFiles=&quot;false&quot;/&amp;gt;
  &amp;lt;log type=&quot;json&quot; target=&quot;/tmp/logfile.json&quot;/&amp;gt;
  &amp;lt;log type=&quot;tap&quot; target=&quot;/tmp/logfile.tap&quot;/&amp;gt;
  &amp;lt;log type=&quot;junit&quot; target=&quot;/tmp/logfile.xml&quot; logIncompleteSkipped=&quot;false&quot;/&amp;gt;
  &amp;lt;log type=&quot;testdox-html&quot; target=&quot;/tmp/testdox.html&quot;/&amp;gt;
  &amp;lt;log type=&quot;testdox-text&quot; target=&quot;/tmp/testdox.txt&quot;/&amp;gt;
    
    --&amp;gt;
    
        &amp;lt;logging&amp;gt;
         &amp;lt;!-- target(report/html) 生成html 文件的目录--&amp;gt;
  &amp;lt;log type=&quot;coverage-html&quot; target=&quot;report/html&quot; charset=&quot;UTF-8&quot; yui=&quot;true&quot; highlight=&quot;false&quot; lowUpperBound=&quot;35&quot; highLowerBound=&quot;70&quot;/&amp;gt;
  &amp;lt;!-- target(report/coverage/coverage.xml) 生成xml的文件名--&amp;gt;
  &amp;lt;log type=&quot;coverage-clover&quot; target=&quot;report/coverage/coverage.xml&quot;/&amp;gt;
&amp;lt;/logging&amp;gt;
    &amp;lt;!-- 代码覆盖率 --&amp;gt;



    &amp;lt;php&amp;gt;
 &amp;lt;includePath&amp;gt;.&amp;lt;/includePath&amp;gt;
 &amp;lt;ini name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;const name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;var name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;env name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;post name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;get name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;cookie name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;server name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;files name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
 &amp;lt;request name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
&amp;lt;/php&amp;gt;  

&amp;lt;/phpunit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_20&quot;&gt;xml 解释&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;xml 解释

bootstrap=&quot;./vendor/autoload.php&quot;

在测试之前加载的的PHP 文件，一般可以做一个初始化工作


&amp;lt;testsuite name=&quot;actionsuitetest&quot;&amp;gt;
      &amp;lt;directory suffix=&quot;.php&quot;&amp;gt;action&amp;lt;/directory&amp;gt;
      &amp;lt;file&amp;gt;Order.php&amp;lt;/file&amp;gt;
&amp;lt;/testsuite&amp;gt;

测试套件，如果想测试页面，action，model 可以多加几个测试套件

name： 套件名称

directory ：套件测试的目录，目录下一般放测试文件的用例

       suffix :测试文件后缀，如果不填写，则默认后缀为*Test.php,即phpunit 默认会执行*Test.php  的文件

       action:测试目录名

file：可以单独设置测试文件

exclude：排除不需要测试的文件

&amp;lt;filter&amp;gt; 元素及其子元素用于配置代码覆盖率报告所使用的白名单。
blacklist 黑名单(不需要统计覆盖率的文件)，whitelist 白名单(统计覆盖率的测试文件) 当黑名单与白名单文件重复时，白名单起作用

&amp;lt;logging&amp;gt; 元素及其 &amp;lt;log&amp;gt; 子元素用于配置测试执行期间的日志记录。

 &amp;lt;php&amp;gt;
  &amp;lt;includePath&amp;gt;.&amp;lt;/includePath&amp;gt;
  &amp;lt;ini name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;const name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;var name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;env name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;post name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;get name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;cookie name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;server name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;files name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
  &amp;lt;request name=&quot;foo&quot; value=&quot;bar&quot;/&amp;gt;
&amp;lt;/php&amp;gt;  

这段xml 可以对应以下PHP 代码

includePath

ini_set('foo', 'bar');
define('foo', 'bar');
$GLOBALS['foo'] = 'bar';
$_ENV['foo'] = 'bar';
$_POST['foo'] = 'bar';
$_GET['foo'] = 'bar';
$_COOKIE['foo'] = 'bar';
$_SERVER['foo'] = 'bar';
$_FILES['foo'] = 'bar';
$_REQUEST['foo'] = 'bar';
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://phpunit.readthedocs.io/zh_CN/latest/index.html&quot;&gt;PHPUnit 手册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/taotaoxixihaha/p/6386225.html&quot;&gt;在phpstorm中安装、配置和运行phpunit详细教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/chenqionghe/p/8984157.html&quot;&gt;PHP单元测试使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kancloud.cn/manual/phpunit-book/68602&quot;&gt;phpunit5.0中文手册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.yzone.net/blog/130&quot;&gt;phpunit XML 配置文件&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 29 Jun 2019 15:03:00 +0000</pubDate>
<dc:creator>Martini</dc:creator>
<og:description>配置说明 全局安装phpunit代码 该代码会自动保存在 /User/你的用户名/.composer/vendor/phpunit 全局安装phpunit命令脚本 从上一步安装结果可以得知当前环境PH</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/martini-d/p/phpstorm-pei-zhiphpunit.html</dc:identifier>
</item>
<item>
<title>嵌入式应用开发第一阶段 - 陈佳乐</title>
<link>http://www.cnblogs.com/cyyz-le/p/11108198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyyz-le/p/11108198.html</guid>
<description>&lt;p&gt;本文主要讲如何搭建嵌入式开发环境以及文件传输到开发板的两种方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、准备开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件&lt;/p&gt;
&lt;p&gt;SecureCRT  串口工具、tftpd64   tftp文件传输工具、vmware虚拟机+Ubuntu系统&lt;/p&gt;
&lt;p&gt;硬件&lt;/p&gt;
&lt;p&gt;rk3399开发板、7寸lcd屏、rs232串口线、usb转串口线、网线&lt;/p&gt;

&lt;p&gt;1.1虚拟机安装ubuntu系统&lt;/p&gt;
&lt;p&gt;虚拟机和ubuntu系统，微信关注软件安装管家  发送ubuntu即可获取文件和安装教程&lt;/p&gt;

&lt;p&gt;1.2 设置虚拟机的共享文件夹&lt;/p&gt;
&lt;p&gt;======================&lt;/p&gt;
&lt;p&gt;1、虚拟机 --&amp;gt; 设置 --&amp;gt; 选项 --&amp;gt; 添加共享文件夹，&lt;/p&gt;
&lt;p&gt;2、在ubuntu中打开终端(terminal)：按 ctrl + alt + t&lt;/p&gt;
&lt;p&gt;3、在终端中切换到共享文件夹：&lt;/p&gt;
&lt;p&gt;cd  /mnt/hgfs&lt;/p&gt;

&lt;p&gt;1.3 交叉编译环境搭建&lt;/p&gt;
&lt;p&gt;我们知道，我们的开发一般在PC机上,是基于X86架构的,而我们的开发板却是基于ARM架构的。如果在PC主机上编辑编译我们的程序,那编译时按照X86架构来进行的,这样的话编译的二进制代码就无法再ARM开发板上运行,所以我们需要安装交叉编译环境,既方便我们在PC主机上进行编辑, 又能在开发板子上运行起来。&lt;/p&gt;
&lt;p&gt;一般芯片厂商会提供编译好的工具链，这里我选的是机智云esp8266的开发工具链&lt;/p&gt;
&lt;p&gt;链接：https://pan.baidu.com/s/1W2mD0dVeIYNBddqxxcOGow&lt;/p&gt;
&lt;p&gt;提取码：kou8&lt;/p&gt;
&lt;p&gt;1、将xtensa-lx106-elf.tar.bz2 复制到 D:\share 中。（之前创建的共享文件夹）&lt;/p&gt;
&lt;p&gt;2、进入Ubuntu运行Terminal&lt;/p&gt;
&lt;p&gt;首先进入root权限，命令行中输入：sudo su ，输密码后回车。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225208435-348497739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;更新源：&lt;/p&gt;
&lt;p&gt;apt-get update&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225213562-1818767309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安装相关软件库：&lt;/p&gt;
&lt;p&gt;32位虚拟机执行：apt-get install vim git //一路回车确认&lt;/p&gt;
&lt;p&gt;64位虚拟机执行：apt-get install vim git libc6-dev-amd64 //一路回车确认&lt;/p&gt;
&lt;p&gt;进入共享文件夹：&lt;/p&gt;
&lt;p&gt;cd /mnt/hgfs/share&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225219171-2124826964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;命令行顺序执行：&lt;/p&gt;
&lt;p&gt;cp xtensa-lx106-elf.tar.bz2 /opt/&lt;/p&gt;
&lt;p&gt;cd /opt/&lt;/p&gt;
&lt;p&gt;tar -jxvf xtensa-lx106-elf.tar.bz2 //解压后显示如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225225255-446721947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;cd /home/$ username //$username为登录用户名&lt;/p&gt;
&lt;p&gt;vim .profile&lt;/p&gt;
&lt;p&gt;export PATH=”/opt/xtensa-lx106-elf/bin:$PATH” //添加到最后一行 保存退出&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225230514-870649479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;exit //注意在要退出超级用户权限&lt;/p&gt;
&lt;p&gt;source .profile //在用户名权限下执行此脚本&lt;/p&gt;
&lt;p&gt;echo $PATH //显示红框所示表示配置正确&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225235555-621867097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;二、PC机传输文件到开发板--通过串口传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1 安装SecureCRT  串口工具、tftpd64   tftp文件传输工具&lt;/p&gt;
&lt;p&gt;链接：https://pan.baidu.com/s/1sf7uInxn4mFDVptJnHpZKQ&lt;/p&gt;
&lt;p&gt;提取码：fmvm&lt;/p&gt;

&lt;p&gt;2.2开发板已经烧写好默认系统（以后会讲如何自制uboot，内核裁剪和移植）&lt;/p&gt;
&lt;p&gt;开发板连接好电源线，插上rs232串口线、usb转串口线，网线到PC机&lt;/p&gt;
&lt;p&gt;通电&lt;/p&gt;
&lt;p&gt;电脑打开设备管理器，查看端口号（驱动安装失败可以使用驱动精灵自动安装）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225241570-1637419658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;2.3打开SecureCRT &lt;/p&gt;
&lt;p&gt;设置参数（波特率根据自己板子的波特率设置，一般为115200，流控的勾要去掉）&lt;/p&gt;
&lt;p&gt;注意：波特率不对串口终端会乱码，一些不是原厂标配的串口线和usb转串口线也会导致乱码，很多人都倒在了这一步（建议买新板子，二手市场有风险）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225245342-59096541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225249277-1665566994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，输入快捷键  ctrl+c 可以进入串口终端则连接成功&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225254147-264547486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.4 传输文件到开发板上&lt;/p&gt;
&lt;p&gt;ubuntu 在共享文件夹写一个.c文件 打印你的名字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225311311-903787651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;交叉编译：arm-linux-gcc -o  myname myname.c&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225316441-992072319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;PC机的共享文件夹找到myname 文件&lt;/p&gt;

&lt;p&gt;在SecureCRT  中执行rx  myname，然后将myname拖进secureCRT，并选择Xmodem&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225321870-558609051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225330572-727081415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;设置文件权限: chmod 777 myname，执行 :  ./myname&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225341140-608498792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;文件通过串口文件传输到开发板成功&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、PC机传输文件到开发板--通过网线传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开tftpd64  选择共享文件夹&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225351076-89184774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;找到自己的PC机以太网的IP地址&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225356570-376643599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225400536-1194610783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在SecureCRT终端查看开发板的ip地址并修改成和主机IP地址同一网段，最后一位不和主机一致就好，0-255（169.254.64.xxx）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225405425-1604417474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;网线ping通如图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225409656-923849499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意：1、ping不通检查是否和PC机以太网同一网段，不是wlan的网段&lt;/p&gt;
&lt;p&gt;2、开发板和pc机记得插上网线，隔壁小伙ping了半天发现网线没插&lt;/p&gt;
&lt;p&gt;3、关闭主机的所有防火墙、杀毒软件&lt;/p&gt;
&lt;p&gt;在开发板执行tftp 169.254.64.7   -g   -r   myname&lt;/p&gt;
&lt;p&gt;其中，169.254.64.7是你windows主机的IP地址， myname是你要传送到开发板的文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1697502/201906/1697502-20190629225413175-2076703752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;传输成功&lt;/p&gt;
&lt;p&gt;至此，嵌入式应用开发第一阶段完成，掌握了文件传输到开发板的方法后可进行下一阶段的学习&lt;/p&gt;

&lt;p&gt;转载请注明出处&lt;/p&gt;

</description>
<pubDate>Sat, 29 Jun 2019 14:49:00 +0000</pubDate>
<dc:creator>陈佳乐</dc:creator>
<og:description>本文主要讲如何搭建嵌入式开发环境以及文件传输到开发板的两种方式 一、准备开发环境 软件 SecureCRT 串口工具、tftpd64 tftp文件传输工具、vmware虚拟机+Ubuntu系统 硬件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cyyz-le/p/11108198.html</dc:identifier>
</item>
<item>
<title>整合SSM框架必备基础—SpringMVC（上） - 胖达熊丶</title>
<link>http://www.cnblogs.com/panda001/p/11108171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panda001/p/11108171.html</guid>
<description>&lt;h2 id=&quot;mvc概述&quot;&gt;01 MVC概述&lt;/h2&gt;
&lt;p&gt;在Web系统开发中一般按照视图（View）、模型（Model）、控制（Controller）三层设计模式进行构建，视图层负责模型数据的渲染，将数据用一定的形式展现给用户；模型层负责监听实体的变化并对实体进行解析和封装；控制层负责提供前后端交互的请求逻辑处理入口，处理用户请求，并建立适当的模型传递给视图进行渲染。层级关系一般如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190629223446809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05UU0RC,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在Web开发的早期，JSP + Servlet + JavaBean的组合非常流行，那个时候JSP担任着视图层渲染工作，Servlet作为控制器负责用户的请求和响应，而JavaBean则负责一些更加复杂的业务逻辑，例如跟数据库打交道。&lt;/p&gt;
&lt;p&gt;后来出现了一个新的MVC框架Struts2，它将action作为框架的控制器负责用户请求响应，同时为前端页面提供了标签库和有力的渲染工具-OGNL，用户请求action返回数据到JSP后，在JSP中可以采用OGNL表达式对数据进行动态的渲染，它还增加了请求过滤器以及进行请求前后处理的拦截器，方便系统过滤、拦截一些不符合规则的请求并做出及时的响应操作，不得不说它的出现降低了系统的耦合性，让MVC模式的分层更加明显，也大大的简化了开发者的代码量。&lt;/p&gt;
&lt;h2 id=&quot;springmvc简介&quot;&gt;02 SpringMVC简介&lt;/h2&gt;
&lt;p&gt;由于Struts2框架带来的便利，它和Spring在过去很长一段时间被结合在一起用来构建系统，但是随着技术的发展，二者的结合出现了很多问题例如类臃肿、兼容性以及Struts2漏洞等问题，而就在这时候，Spring家族诞生了一个新的MVC框架来与Spring实现无缝结合，它就是SpringMVC。&lt;/p&gt;
&lt;p&gt;SpringMVC是采用Java开发，一种基于Web MVC设计模式，以请求驱动为类型的轻量级Web框架。由于使用了MVC架构模式的思想，将Web层进行了职责解耦，让分层更加的明显。&lt;/p&gt;
&lt;h2 id=&quot;springmvc优势&quot;&gt;03 SpringMVC优势&lt;/h2&gt;
&lt;p&gt;谈到SpringMVC的优势，首先想到的就是它依赖Spring的包才能运行，也就是说它其实是Spring的一个MVC子框架，这样的话就可以跟Spring实现无缝的结合，从而继承它的众多特性，这一点比起Struct2框架就有了很大的先天优势，另外还有其他的几个优点如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、实现方法级别的请求拦截&lt;/strong&gt;&lt;br/&gt;上面提及的Struts2采用的是类级别的请求拦截，即一个类对应一个请求上下文，而SpringMVC采用方法级别的拦截，一个方法对应一个请求URL，也就是一个请求上下文。所以从架构本身上SpringMVC容易实现Restful接口，而Struts2的架构实现起来要麻烦很多，因为Struts2 action的一个方法可以对应一个URL，但是它的类属性却被所有的方法共享，这也就无法用注解或其他方式标识其所属的方法了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、SpringMVC提供强大的注解&lt;/strong&gt;&lt;br/&gt;SpringMVC引入了注解的功能，通过在类、方法上标记相应的注解，可以实现实体的映射、配置的加载等，使用起来非常便利，可以大大简化配置和代码量，比如说同样是接收请求，Servlet作为控制器需要在doPost或者doGet中做一些处理后才能调用业务代码，而SpringMVC通过几个注解就可以实现，例如@requestMapping可以帮助定义当前类为一个Spring管理的bean,同时指定该类是一个控制器,可以用来接受请求，标识当前类是控制层的一个具体的实现；@Controller放在方法上面用来指定某个方法的路径，当它放在类上的时候相当于命名空间需要组合方法上的requestMapping来访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、清晰的角色划分&lt;/strong&gt;&lt;br/&gt;控制器(Controller)、验证器(Validator)、命令对象(Command-obect)、表单对象(form-object)、模型对象(model-object)、Servlet分发器(DispatcherServlet)、处理器映射(handler-mapping)、视图解析器(view-resolver)等等。每一个角色都可以由一个专门的对象来实现。&lt;/p&gt;
&lt;h2 id=&quot;springmvc流程步骤&quot;&gt;04 SpringMVC流程步骤&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190629223623299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05UU0RC,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;SpringMVC的具体执行流程步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.首先用户在前台页面向某一个后台指定的URL发起了请求,SpringMVC收到这个请求后会首先交给中央控制器(DispatcherServlet)&lt;/p&gt;
&lt;p&gt;2.中央控制器请求HandlerMapping查找 Handler处理器 （可以根据xml配置、注解进行查找）&lt;/p&gt;
&lt;p&gt;3.处理器映射器HandlerMapping向中央控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略&lt;/p&gt;
&lt;p&gt;4.中央控制器调用处理器适配器去执行Handler&lt;/p&gt;
&lt;p&gt;5.处理器适配器HandlerAdapter将会根据适配的结果去执行Handler&lt;/p&gt;
&lt;p&gt;6.Handler执行完成给适配器返回ModelAndView&lt;/p&gt;
&lt;p&gt;7.处理器适配器向中央控制器返回ModelAndView （ModelAndView其实是SpringMVC框架的一个底层对象，包括模型Model和视图View）&lt;/p&gt;
&lt;p&gt;8.中央控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)，通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可&lt;/p&gt;
&lt;p&gt;9.视图解析器向中央控制器返回View&lt;/p&gt;
&lt;p&gt;10.中央控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）&lt;/p&gt;
&lt;p&gt;11.前端控制器向用户响应结果&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 14:42:00 +0000</pubDate>
<dc:creator>胖达熊丶</dc:creator>
<og:description>01 MVC概述 在Web系统开发中一般按照视图（View）、模型（Model）、控制（Controller）三层设计模式进行构建，视图层负责模型数据的渲染，将数据用一定的形式展现给用户；模型层负责监</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/panda001/p/11108171.html</dc:identifier>
</item>
<item>
<title>开闭原则——面向对象程序设计原则 - 海向</title>
<link>http://www.cnblogs.com/haixiang/p/11107859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haixiang/p/11107859.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我们将在下面的几节中依次来介绍这 7 条原则，本节首先介绍开闭原则。&lt;/p&gt;
&lt;h2 id=&quot;开闭原则定义&quot;&gt;开闭原则定义&lt;/h2&gt;
&lt;p&gt;开闭原则规定“软件中的对象（类，模块，函数等等）应该&lt;strong&gt;对于扩展是开放的，但是对于修改是封闭的&lt;/strong&gt;”，这意味着一个实体是允许&lt;strong&gt;在不改变它的源代码的前提下变更它的行为&lt;/strong&gt;。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。&lt;/p&gt;
&lt;p&gt;我们通常在程序设计中利用接口、抽象类、继承和实现等方式来体现开闭原则。&lt;/p&gt;
&lt;h2 id=&quot;开闭原则作用&quot;&gt;开闭原则作用&lt;/h2&gt;
&lt;p&gt;开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;对软件测试的影响&lt;/strong&gt;&lt;br/&gt;软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以提高代码的可复用性&lt;/strong&gt;&lt;br/&gt;粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以提高软件的可扩展性和可维护性&lt;/strong&gt;&lt;br/&gt;遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;开闭原则案例&quot;&gt;开闭原则案例&lt;/h2&gt;
&lt;h3 id=&quot;描述&quot;&gt;1. 描述&lt;/h3&gt;
&lt;p&gt;我们设计图书接口、电子书接口、以及SSM电子书类和美食书籍类。电子书接口通过继承图书接口，对其进行了扩展，增加了&lt;code&gt;getSize()&lt;/code&gt;方法，即获取电子书内存大大小。SSM电子书类通过实现电子书接口进一步扩展，增加了&lt;code&gt;SSMComtent&lt;/code&gt;方法。美食书籍类通过实现图书接口，同样实现了扩展的方法。&lt;/p&gt;
&lt;p&gt;以后如果我们有了更多的武侠类、游戏类……等书籍，不需要对原来的图书接口进行修改，只需要继承完成扩展即可。&lt;/p&gt;
&lt;h3 id=&quot;uml-图&quot;&gt;2. uml 图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201906/1543774-20190629205750904-1896949322.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201906/1543774-20190629205759765-973589084.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;具体代码&quot;&gt;3. 具体代码&lt;/h3&gt;
&lt;p&gt;图书接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;

/**
 * 图书接口
 * 价格、书名、出版日期
 */
public interface IBook {
    double getPrince();
    String getName();
    Date publishDate();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电子书接口，扩展了一个方法获取电子书所占大小的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 电子书接口
 */
public interface IComputerBook extends IBook{
    /**
     * 获取电子书大小 16kb
     * */
    String getSize();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现图书接口实现扩展。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;

public class FoodBook implements IBook{

    private String name;
    private double price;
    private Date publishDate;

    public FoodBook(String name, double price, Date publishDate) {
        this.name = name;
        this.price = price;
        this.publishDate = publishDate;
    }

    @Override
    public double getPrince() {
        return price;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Date publishDate() {
        return publishDate;
    }

    public void foodContent() {
        System.out.println(&quot;美食书籍: &quot; + name + &quot;-内容丰富哦!仅需要&quot; + price +&quot;元&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现电子书接口实现扩展。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;
public class SSMBook implements IComputerBook {

    private String name;
    private double price;
    private Date publishDate;
    private String size;
    private String author;

    public SSMBook(String name, double price, Date publishDate, String size, String author) {
        this.name = name;
        this.price = price;
        this.publishDate = publishDate;
        this.size = size;
        this.author = author;
    }

    @Override
    public String getSize() {
        return size;
    }

    @Override
    public double getPrince() {
        return price;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Date publishDate() {
        return publishDate;
    }

    public void SSMComtent() {
        System.out.println(&quot;SSM架构实战书籍:&quot; + name + &quot;-作者:&quot; + author);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;

public class Main {
    public static void main(String[] args) {
        FoodBook foodBook = new FoodBook(&quot;厨房秘籍&quot;, 30.00, new Date());
        showBookConten(foodBook);

        SSMBook ssmBook = new SSMBook(&quot;ssm架构&quot;, 57.20, new Date(), &quot;20MB&quot;, &quot;anben&quot;);
        showBookConten(ssmBook);
    }

    private static void showBookConten(IBook iBook) {
        if (iBook instanceof IComputerBook) {
            SSMBook ssmBook = (SSMBook) iBook;
            ssmBook.SSMComtent();
        } else {
            FoodBook foodBook = (FoodBook) iBook;
            foodBook.foodContent();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;美食书籍: 厨房秘籍-内容丰富哦!仅需要30.0元
SSM架构实战书籍:ssm架构-作者:anben&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 29 Jun 2019 12:58:00 +0000</pubDate>
<dc:creator>海向</dc:creator>
<og:description>[TOC] 前言 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我们将在下面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haixiang/p/11107859.html</dc:identifier>
</item>
<item>
<title>Anaconada安装 - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/11107842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/11107842.html</guid>
<description>&lt;p&gt;Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。&lt;/p&gt;
&lt;p&gt;Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换&lt;/p&gt;
&lt;p&gt;Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等&lt;/p&gt;
&lt;p&gt;Miniconda包括Conda、Python&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;https://www.anaconda.com/download/&quot; class=&quot;uri&quot;&gt;https://www.anaconda.com/download/&lt;/a&gt; （官网）&lt;/p&gt;
&lt;p&gt;镜像版下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot; class=&quot;uri&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;（官网已通知2019年5月16号后无法下载）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirrors-wan.geekpie.club/anaconda/archive/&quot; class=&quot;uri&quot;&gt;https://mirrors-wan.geekpie.club/anaconda/archive/&lt;/a&gt;（这个是最新的,也无法下载了）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.anaconda.com/distribution/&quot; class=&quot;uri&quot;&gt;https://www.anaconda.com/distribution/&lt;/a&gt;（官方版本）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://repo.continuum.io/archive/&quot; class=&quot;uri&quot;&gt;https://repo.continuum.io/archive/&lt;/a&gt;（目前可用）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DamnWidget/anaconda/releases&quot; class=&quot;uri&quot;&gt;https://github.com/DamnWidget/anaconda/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rhinstaller/anaconda/releases&quot; class=&quot;uri&quot;&gt;https://github.com/rhinstaller/anaconda/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-01.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-01.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-02.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-02.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Anaconda 是跨平台的，有 Windows、macOS、Linux 版本，我们这里以 Windows 版本为例，点击那个 Windows 图标。&lt;/p&gt;
&lt;p&gt;我这里选择下载&lt;/p&gt;
&lt;p&gt;Python 2.7 version &lt;em&gt;--Python 2.7 版&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;64-Bit Graphical Installer (564 MB) --64位图形安装程序（564 MB）&lt;/p&gt;
&lt;p&gt;当然，你也可以根据自己的实际情况，选择 Python 3.6版的，或者 32-Bit 版本的。&lt;/p&gt;
&lt;p&gt;安装包有 564MB，因为网速的关系，下载时间可能会比较长，请耐心等待。我这里下载完成 Anaconda2-5.2.0-Windows-x86_64.exe文件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-03.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-03.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;双击下载好的 Anaconda2-5.2.0-Windows-x86_64.exe文件，出现如下界面，点击 Next 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-04.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-04.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-05.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-05.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 I Agree （我同意），不同意，当然就没办法继续安装啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-06.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-06.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Install for: Just me还是All Users，假如你的电脑有好几个 Users ，才需要考虑这个问题.其实我们电脑一般就一个 User，就我们一个人使用，如果你的电脑有多个用户，选择All Users，我这里直接 All User，继续点击 Next 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-07.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-07.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Destination Folder 是“目标文件夹”的意思，可以选择安装到什么地方。默认是安装到 C:\ProgramData\Anaconda2文件夹下。你也可以选择 Browse... ，选择想要安装的文件夹。我这里 C 盘空间充裕，所以我直接就装到默认的地方。&lt;/p&gt;
&lt;p&gt;这里提一下，Anaconda 很强大，占用空间也不小啊，2.6GB，差不多是一部高清电影的体积了。不过，为了学习，这点硬盘空间算什么呢。&lt;/p&gt;
&lt;p&gt;继续点击 Next&amp;gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-08.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-08.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里来到 Advanced Options 了，所谓的“高级选项”。如果你英文好，有一定背景知识的话，肯定明白这界面上的意思。两个默认就好，第一个是加入环境变量，第二个是默认使用 Python 2.7，点击“Install”，终于开始安装额。&lt;/p&gt;
&lt;p&gt;安装时间根据你的电脑配置而异，电脑配置高，硬盘是固态硬盘，速度就更快。安装过程其实就是把 Anaconda2-5.2.0-Windows-x86_64.exe文件里压缩的各种 dll 啊，py 文件啊，全部写到安装目标文件夹里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-09.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-09.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过程还是很漫长的，毕竟 2.6GB 的无数个小文件啊，请耐心等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-10.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-10.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-11.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-11.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过漫长的等待，终于安装完成 Installation Complete （安装完成）了，点击最后一个 Next&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-12.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-12.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Install Microsoft VSCode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-13.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-13.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 Finish，那两个 √ 可以取消。&lt;/p&gt;

&lt;p&gt;如果是windows的话需要去 控制面板\系统和安全\系统\高级系统设置\环境变量\用户变量\PATH 中添加 anaconda的安装目录的Scripts文件夹, 比如我的路径是C:\ProgramData\Anaconda2\Scripts, 看个人安装路径不同需要自己调整.&lt;/p&gt;
&lt;p&gt;之后就可以打开命令行(最好用管理员模式打开) 输入 conda --version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-14.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-14.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输出conda 4.5.4之类的就说明环境变量设置成功了.&lt;/p&gt;
&lt;p&gt;为了避免可能发生的错误, 我们在命令行输入conda upgrade --all 先把所有工具包进行升级b&lt;/p&gt;

&lt;p&gt;接下来我们就可以用anaconda来创建我们一个个独立的python环境了.接下来的例子都是在命令行操作的,请打开你的命令行吧.&lt;/p&gt;
&lt;h2 id=&quot;activate&quot;&gt;activate&lt;/h2&gt;
&lt;p&gt;activate 能将我们引入anaconda设定的虚拟环境中, 如果你后面什么参数都不加那么会进入anaconda自带的base环境,&lt;/p&gt;
&lt;p&gt;你可以输入python试试, 这样会进入base环境的python解释器, 如果你把原来环境中的python环境去除掉会更能体会到, 这个时候在命令行中使用的已经不是你原来的python而是base环境下的python.而命令行前面也会多一个(base) 说明当前我们处于的是base环境下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-15.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-15.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建自己的虚拟环境&lt;/p&gt;
&lt;p&gt;我们当然不满足一个base环境, 我们应该为自己的程序安装单独的虚拟环境.&lt;/p&gt;
&lt;p&gt;创建一个名称为python34的虚拟环境并指定python版本为3.4(这里conda会自动找3.4中最新的版本下载)&lt;/p&gt;
&lt;p&gt;conda create -n python34 python=3.4&lt;/p&gt;
&lt;p&gt;或者conda create --name python34 python=3.4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-16.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-16.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我们就有了一个learn的虚拟环境, 接下来我们切换到这个环境, 一样还是用activae命令 后面加上要切换的环境名称&lt;/p&gt;
&lt;h2 id=&quot;切换环境&quot;&gt;切换环境&lt;/h2&gt;
&lt;p&gt;activate learn&lt;/p&gt;
&lt;p&gt;如果忘记了名称我们可以先用&lt;/p&gt;
&lt;p&gt;conda env list&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-17.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-17.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去查看所有的环境&lt;/p&gt;
&lt;p&gt;现在的learn环境除了python自带的一些官方包之外是没有其他包的, 一个比较干净的环境我们可以试试&lt;/p&gt;
&lt;p&gt;先输入python打开python解释器然后输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import requests&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;会报错找不到requests包, 很正常.接下来我们就要演示如何去安装requests包&lt;/p&gt;
&lt;p&gt;exit()&lt;/p&gt;
&lt;p&gt;退出python解释器&lt;/p&gt;
&lt;h2 id=&quot;卸载环境&quot;&gt;卸载环境&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-18.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-18.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;conda remove --name test --all&lt;/p&gt;
&lt;h2 id=&quot;关于环境总结&quot;&gt;关于环境总结&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）
 
conda create --name python34 python=3.4
 
# 安装好后，使用activate激活某个环境
 
activate python34 # for Windows
 
source activate python34 # for Linux &amp;amp; Mac
 
# 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH
 
# 此时，再次输入
 
python --version
 
# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境
 
# 如果想返回默认的python 2.7环境，运行
 
deactivate python34 # for Windows
source deactivate python34 # for Linux &amp;amp; Mac
# 删除一个已有的环境
 
conda remove --name python34 --all&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;输入&lt;/p&gt;
&lt;p&gt;conda install requests&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;pip install requests&lt;/p&gt;
&lt;p&gt;来安装requests包.&lt;/p&gt;
&lt;p&gt;安装完成之后我们再输入python进入解释器并import requests包, 这次一定就是成功的了.&lt;/p&gt;

&lt;p&gt;那么怎么卸载一个包呢&lt;/p&gt;
&lt;p&gt;conda remove requests&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;pip uninstall requests&lt;/p&gt;
&lt;p&gt;就行啦.&lt;/p&gt;

&lt;p&gt;要查看当前环境中所有安装了的包可以用&lt;/p&gt;
&lt;p&gt;conda list&lt;/p&gt;

&lt;p&gt;如果想要导出当前环境的包信息可以用&lt;/p&gt;
&lt;p&gt;conda env export &amp;gt; environment.yaml&lt;/p&gt;
&lt;p&gt;将包信息存入yaml文件中.&lt;/p&gt;
&lt;p&gt;当需要重新创建一个相同的虚拟环境时可以用&lt;/p&gt;
&lt;p&gt;conda env create -f environment.yaml&lt;/p&gt;
&lt;p&gt;其实命令很简单对不对, 我把一些常用的在下面给出来, 相信自己多打两次就能记住&lt;/p&gt;
&lt;p&gt;activate // 切换到base环境&lt;/p&gt;
&lt;p&gt;activate learn // 切换到learn环境&lt;/p&gt;
&lt;p&gt;conda create -n learn python=3 // 创建一个名为learn的环境并指定python版本为3(的最新版本)&lt;/p&gt;
&lt;p&gt;conda env list // 列出conda管理的所有环境&lt;/p&gt;
&lt;p&gt;conda list // 列出当前环境的所有包&lt;/p&gt;
&lt;p&gt;conda install requests 安装requests包&lt;/p&gt;
&lt;p&gt;conda remove requests 卸载requets包&lt;/p&gt;
&lt;p&gt;conda remove -n learn --all // 删除learn环境及下属所有包&lt;/p&gt;
&lt;p&gt;conda update requests 更新requests包&lt;/p&gt;
&lt;p&gt;conda env export &amp;gt; environment.yaml // 导出当前环境的包信息&lt;/p&gt;
&lt;p&gt;conda env create -f environment.yaml // 用配置文件创建新的虚拟环境&lt;/p&gt;

&lt;p&gt;或许你会觉得奇怪为啥anaconda能做这些事, 他的原理到底是什么, 我们来看看anaconda的安装目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-19.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-19.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只截取了一部分, 但是我们和本文章最开头的python环境目录比较一下, 可以发现其实十分的相似, 其实这里就是base环境. 里面有着一个基本的python解释器, lLib里面也有base环境下的各种包文件.&lt;/p&gt;
&lt;p&gt;那我们自己创建的环境去哪了呢, 我们可以看见一个envs, 这里就是我们自己创建的各种虚拟环境的入口, 点进去看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-20.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-20.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现我们之前创建的learn目录就在下面, 再点进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-21.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-21.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这不就是一个标准的python环境目录吗?&lt;/p&gt;
&lt;p&gt;这么一看, anaconda所谓的创建虚拟环境其实就是安装了一个真实的python环境, 只不过我们可以通过activate,conda等命令去随意的切换我们当前的python环境, 用不同版本的解释器和不同的包环境去运行python脚本.&lt;/p&gt;

&lt;p&gt;在工作环境中我们会集成开发环境去编码, 这里推荐JB公司的PyCharm, 而PyCharm也能很方便的和anaconda的虚拟环境结合&lt;/p&gt;
&lt;p&gt;在Setting =&amp;gt; Project =&amp;gt; Project Interpreter 里面修改 Project Interpreter , 点击齿轮标志再点击Add Local为你某个环境的python.exe解释器就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-22.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-22.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如你要在learn环境中编写程序, 那么就修改为C:\Users\Administrator\AppData\Local\conda\conda\envs\learn, 可以看到这时候下面的依赖包也变成了learn环境中的包了.接下来我们就可以在pycharm中愉快的编码了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-23.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-23.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按下 Windows 徽标键，调出 Windows 开始菜单，可以看到 “最近添加”的：Anaconda2(64-bit)&lt;/p&gt;

&lt;p&gt;打开Anaconda Prompt，这个窗口和doc窗口一样的，输入命令就可以控制和配置python，最常用的是conda命令，这个pip的用法一样，此软件都集成了，你可以直接用，点开的话如下图。用命令“conda list”查看已安装的包，从这些库中我们可以发现NumPy,SciPy,Matplotlib,Pandas，说明已经安装成功了!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-24.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-24.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以使用conda命令进行一些包的安装和更新&lt;/p&gt;
&lt;p&gt;conda list：列出所有的已安装的packages&lt;/p&gt;
&lt;p&gt;conda install name：其中name是需要安装packages的名字，比如，我安装numpy包，输入上面的命令就是“conda install numpy”。单词之间空一格，然后回车，输入y就可以了。&lt;/p&gt;
&lt;p&gt;安装完anaconda，就相当于安装了Python、IPython、集成开发环境Spyder、一些包等等。你可以在Windows下的cmd下查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-25.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-25.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-26.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-26.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-27.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-27.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基于web的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-28.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-28.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-29.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-29.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个使用Python语言、跨平台的、科学运算集成开发环境。&lt;/p&gt;
&lt;p&gt;点击 Anaconda Navigator ，第一次启用，会初始化，耐心等待一段时间，加载完成，界面如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-30.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-30.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spyder编辑器，我们以后就可以用这款编辑器来编写代码，它最大优点就是模仿MATLAB的“工作空间”。spyder.exe放在安装目录下的Scripts里面，如我的是C:\ProgramData\Anaconda2\Scripts\spyder.exe, 直接双击就能运行。我们可以右键发送到桌面快捷方式，以后运行就比较方便了。&lt;/p&gt;
&lt;p&gt;我们简单编写一个程序来测试一下安装是否成功，该程序用来打开一张图片并显示。首先准备一张图片，然后打开spyder，编写如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
 
&quot;&quot;&quot;
Spyder Editor
 
This is a temporary script file.
&quot;&quot;&quot;
 
from skimage import io
 
 
 
img = io.imread('C:/Users/Administrator/Desktop/379283176280170726.jpg?x-oss-process=style/watermark')
 
 
 
io.imshow(img)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将其中的C:/Users/Administrator/Desktop/379283176280170726.jpg?x-oss-process=style/watermark改成你自己要显示图片的位置，然后点击上面工具栏里的绿色三角进行运行，最终显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-31.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-31.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们点击 jupyterlab 下面的 Launch ，会在默认浏览器（我这里是 Chrome）打开 &lt;a href=&quot;http://localhost:8888/lab&quot; class=&quot;uri&quot;&gt;http://localhost:8888/lab&lt;/a&gt; 这样一个东东，这里就可以输入 Python 代码啦，来一句 Hello World 吧。&lt;/p&gt;
&lt;p&gt;我们可以打开 Anaconda Navigator -&amp;gt; Launch jupyterlab ，也可以直接在浏览器输入 &lt;a href=&quot;http://localhost:8888/lab&quot; class=&quot;uri&quot;&gt;http://localhost:8888/lab&lt;/a&gt; （可以保存为书签）。如果是布置在云端，可以输入服务器域名（IP），是不是很爽？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-32.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-32.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-33.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-33.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Visual Studio Code是一个轻量级但功能强大的源代码编辑器，可在桌面上运行，适用于Windows，macOS和Linux。它内置了对JavaScript，TypeScript和Node.js的支持，并为其他语言（如C ++，C＃，Java，Python，PHP，Go）和运行时（如.NET和Unity）提供了丰富的扩展生态系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-34.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-34.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Glue是一个Python库，用于探索相关数据集内部和之间的关系。其主要特点包括：&lt;/p&gt;
&lt;p&gt;链接统计图形。使用Glue，用户可以创建数据的散点图，直方图和图像（2D和3D）。胶水专注于刷牙和链接范例，其中任何图形中的选择传播到所有其他图形。&lt;/p&gt;
&lt;p&gt;灵活地跨数据链接。Glue使用不同数据集之间存在的逻辑链接来覆盖不同数据的可视化，并跨数据集传播选择。这些链接由用户指定，并且是任意灵活的。&lt;/p&gt;
&lt;p&gt;完整的脚本功能。Glue是用Python编写的，并且建立在其标准科学库（即Numpy，Matplotlib，Scipy）之上。用户可以轻松地集成他们自己的python代码进行数据输入，清理和分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-35.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-35.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;交互式数据可视化&lt;/p&gt;
&lt;p&gt;通过巧妙的数据可视化执行简单的数据分析。探索统计分布，箱形图和散点图，或深入了解决策树，层次聚类，热图，MDS和线性投影。即使您的多维数据也可以在2D中变得合理，特别是在智能属性排名和选择方面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-36.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-36.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老师和学生都喜欢它&lt;/p&gt;
&lt;p&gt;在教授数据挖掘时，我们喜欢说明而不是仅仅解释。而橙色很棒。Orange在世界各地的学校，大学和专业培训课程中使用，支持数据科学概念的实践培训和视觉插图。甚至还有专门为教学设计的小部件。&lt;/p&gt;
&lt;p&gt;附加组件扩展功能&lt;/p&gt;
&lt;p&gt;使用Orange中可用的各种附加组件从外部数据源挖掘数据，执行自然语言处理和文本挖掘，进行网络分析，推断频繁项目集并执行关联规则挖掘。此外，生物信息学家和分子生物学家可以使用Orange通过差异表达对基因进行排序并进行富集分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-37.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-37.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;R软件自带的有写脚本的工具，可是我不是很喜欢用（并不是说不好哈），我更喜欢用RStudio（网上还有Tinn-R，RWinEdt等）。因为我觉得其本身比较方便，另外在编程的时候有些功能很方便。下面这个界面是我修改了主题的，下面我将介绍如何修改主题，来方便编程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/010-Anaconada%E5%AE%89%E8%A3%85-38.png?x-oss-process=style/watermark&quot; alt=&quot;010-Anaconada安装-38.png?x-oss-process=style/watermark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在你是不是发现用上anaconda就可以十分优雅简单的解决上面所提及的单个python环境所带来的弊端了呢, 而且也明白了其实这一切的实现并没有那么神奇.&lt;/p&gt;
&lt;p&gt;当然anaconda除了包管理之外还在于其丰富数据分析包, 不过那就是另一个内容了, 我们先学会用anaconda去换一种方法管里自己的开发环境, 这已经是一个很大的进步了。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 12:52:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>[TOC] Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nickchen121/p/11107842.html</dc:identifier>
</item>
<item>
<title>Spring源码解读之BeanFactoryPostProcessor的处理 - 张曾经</title>
<link>http://www.cnblogs.com/zzq6032010/p/11031214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/11031214.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    前段时间旁听了某课堂两节Spring源码解析课，刚好最近自己又在重新学习中，便在这里记录一下学习所得。我之前写过一篇博文，是介绍BeanFactoryPostProcessor跟BeanPostProcessor是如何发挥作用的，当时觉得讲的还行，但是现在看来，太粗劣了，很多地方没涉及到，而且重点都被我忽略了，简直就是蠢得不行。现在就用这篇文章弥补一下前文中对BeanFactoryPostProcessor的讲解，争取把重点讲到，至于BeanPostProcessor，由于涉及到的东西太多，限于本人目前的水平只能作罢，待后面感悟成熟了再来补充。&lt;/p&gt;
&lt;p&gt;我们以AnnotationConfigApplicationContext为例来构建测试类，先附上此次打断点调试的三个简约到极致的测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从这两行代码，实地跟踪考察Spring中的流程&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         AnnotationConfigApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(ScanConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         applicationContext.getBean(Teacher.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).teach();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myPackage;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Teacher () {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;Teacher init&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; teach () {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;teach&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myPackage;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; @ComponentScan(&quot;myPackage&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScanConfig {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、洞悉启动容器时的准备工作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;熟悉一些Spring的道友应该都知道，refresh方法中的invokeBeanFactoryPostProcessors方法实现了对BeanFactoryPostProcessor实现类的处理。大家如果只看invokeBeanFactoryPostProcessors方法的话，不会发现有何异常之处，此方法虽然较长，但是处理逻辑很清晰，先对重写了BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor方法的实现类进行处理，后对重写了BeanFactoryPostProcessor的方法的实现类做了处理。但是如果心细的话，你会发现问题，Spring是如何将@ComponentScan(&quot;myPackage&quot;)注解发挥作用的？这时带着这样的问题，我们再回过头来看容器的构造方法，就会在这平实的表面下发现意想不到的 &quot;杀机&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;&lt;span&gt;... annotatedClasses) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        register(annotatedClasses);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        refresh();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这个构造方法可以知道，在第二行将我们的测试类ScanConfig 注册进了容器中，但这只是注册，注册之后是如何调用如何实现了@ComponentScan(&quot;myPackage&quot;)这个注解的包扫描的呢？这时我们将目光锁定this()方法。点进去后发现是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnnotationConfigApplicationContext() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt; AnnotatedBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.scanner = &lt;span&gt;new&lt;/span&gt; ClassPathBeanDefinitionScanner(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第二行新建reader对象时，调用了这个构造方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Assert.notNull(environment, &quot;Environment must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.registry =&lt;span&gt; registry;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.conditionEvaluator = &lt;span&gt;new&lt;/span&gt; ConditionEvaluator(registry, environment, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         AnnotationConfigUtils.registerAnnotationConfigProcessors(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的第六行，最终调用了AnnotationConfigUtils#registerAnnotationConfigProcessors方法，而就是在这个方法中完成了对多个重要Bean的注册，跟我们关系比较大的有以下几个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder只是存放BD的，里面有三个属性：BD对象、beanName以及别名组成的String[]&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefs = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;BeanDefinitionHolder&amp;gt;(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册最关键的类，对应的类为ConfigurationClassPostProcessor，父类的父类是BeanFactoryPostProcessor&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             RootBeanDefinition def = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(ConfigurationClassPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            def.setSource(source);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将BD注入进容器中，没经过什么处理，只是放入了DefaultListableBeanFactory中的beanDefinitionMap跟存放beanName的list中&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此类实现了BeanPostProcessor，用于处理@Autowired、@Value注解&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             RootBeanDefinition def = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            def.setSource(source);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此类也实现了BeanPostProcessor，用于处理有@Required注解的方法&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             RootBeanDefinition def = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(RequiredAnnotationBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            def.setSource(source);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第一个对应的类就是我们重点关注的对象 ConfigurationClassPostProcessor类，查看此类的组成，发现它实现了BeanDefinitionRegistryPostProcessor接口，而此接口正是BeanFactoryPostProcessor的子接口。此时，萦绕在我们心头的迷雾开始渐渐散开，我们仿佛能抓到一闪而过的逻辑走向，现在让我们带着之前的发现，进入正主invokeBeanFactoryPostProcessors方法中一探究竟。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、invokeBeanFactoryPostProcessors&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该方法位于AbstractApplicationContext的refresh方法中，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 public void refresh() throws&lt;span&gt; BeansException, IllegalStateException {
 2         synchronized (this&lt;span&gt;.startupShutdownMonitor) {
 3             // Prepare this context for refreshing.
 4 &lt;span&gt;            prepareRefresh();
 5 
 6             // Tell the subclass to refresh the internal bean factory.
 7             ConfigurableListableBeanFactory beanFactory =&lt;span&gt; obtainFreshBeanFactory();
 8 
 9             // Prepare the bean factory for use in this context.
10 &lt;span&gt;            prepareBeanFactory(beanFactory);
11 
12             try&lt;span&gt; {
13                 // Allows post-processing of the bean factory in context subclasses.
14 &lt;span&gt;                postProcessBeanFactory(beanFactory);
15 
16                 // Invoke factory processors registered as beans in the context. 
17                 invokeBeanFactoryPostProcessors(beanFactory);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即第17行调用的方法。初学者看到这个方法的内部实现时，会发现此方法无外乎是找到所有实现了BeanDefinitionRegistryPostProcessor跟BeanFactoryPostProcessor接口的类，按照优先级（实现了PriorityOrdered接口的先于实现了Ordered接口，前两者均先于未实现的，且同一类中按照getOrder方法返回值排优先级）顺序执行它们的重写方法，先执行BeanDefinitionRegistryPostProcessor的重写方法，再执行BeanFactoryPostProcessor的重写方法，很容易理解的逻辑。但是现在我们是带着前面准备工作中得到的线索来的，此时再看，就能透过这个方法朴实的外表发现它潜藏的凶险，它如平地一声雷般让人猛地惊出一身冷汗。&lt;/p&gt;
&lt;p&gt;我们打断点进入PostProcessorRegistrationDelegate类中的下面方法中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeBeanFactoryPostProcessors(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先略过开始对手动添加进去的beanFactoryPostProcessors处理逻辑，看后面的部分代码（由于此方法代码较多，此处就不全部粘贴出来了，因为逻辑很好理解，所以只粘贴重点）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             String[] postProcessorNames =
&lt;span&gt; 2&lt;/span&gt;                     beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; priorityOrderedPostProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.2 先处理实现了PriorityOrdered的类&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String ppName : postProcessorNames) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, PriorityOrdered.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处通过getBean来生成ConfigurationClassPostProcessor实例对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                     priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    processedBeans.add(ppName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就一个对象，有啥好排序的&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            registryPostProcessors.addAll(priorityOrderedPostProcessors);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行ConfigurationClassPostProcessor中的重写方法postProcessBeanDefinitionRegistry，会将所有加了注解的类注册到容器中
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处才是整个invokeBeanFactoryPostProcessors方法的核心所在，需要详述 下面进入ConfigurationClassPostProcessor中的postProcessBeanDefinitionRegistry中一探究竟&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;debug到第一行的时候，会发现此处获取到的postProcessorNames 中只有一个值，就是前面准备工作中通过硬编码往容器里注册的ConfigurationClassPostProcessor类。下面的逻辑就是进行各种判断，最后在第19行完成了对ConfigurationClassPostProcessor中postProcessBeanDefinitionRegistry方法的调用。&lt;/p&gt;
&lt;p&gt;就是在这个后置处理方法中，完成了@ComponentScan(&quot;myPackage&quot;)中对包的扫描，完成了所有Bean的注册。执行完这个方法后，你会发现beanDefinitionMap中所有应该容器管理的类全都齐活了，包括其他的后置处理器。这样，后面继续调用beanFactory.getBeanNamesForType方法时，获取到的是所有满足条件的类，后面的工作就会有条不紊的开展下去了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    本文着重追溯了BeanFactoryPostProcessor及其子接口是如何在Spring中发挥作用的。先通过Spring初始化容器时注册进去的ConfigurationClassPostProcessor类触发对其他类的扫描，待全部注册进容器后，再从容器中取对应的BeanFactoryPostProcessor及其子接口的实现类，逐一对重写方法进行调用。&lt;/p&gt;
&lt;p&gt;虽然魔鬼在细节，但这也正是解读源码的快乐之处，不是吗？&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 12:45:00 +0000</pubDate>
<dc:creator>张曾经</dc:creator>
<og:description>前言 前段时间旁听了某课堂两节Spring源码解析课，刚好最近自己又在重新学习中，便在这里记录一下学习所得。我之前写过一篇博文，是介绍BeanFactoryPostProcessor跟BeanPost</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/11031214.html</dc:identifier>
</item>
<item>
<title>设计模式之观察者模式（observer pattern） - alpha_panda</title>
<link>http://www.cnblogs.com/yssjun/p/11107038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yssjun/p/11107038.html</guid>
<description>&lt;p&gt;观察者模式主要用于处理对象间的一对多的关系，是一种对象行为模式。该模式的实际应用场景比较容易确认，当一个对象状态发生变化时，所有该对象的关注者均能收到状态变化通知，以进行相应的处理。&lt;br/&gt;本文希望通过简单的介绍和分析，能让读者对观察者模式有一个简单直观的认识和感知，以便在实际开发中根据需要灵活运用。&lt;/p&gt;
&lt;h3&gt;1. 目的&lt;/h3&gt;
&lt;p&gt;建立对象间一对多的关联关系，并能使一个对象的变化被所有关联对象感知。&lt;/p&gt;
&lt;h3&gt;2. 动机&lt;/h3&gt;
&lt;p&gt;建立一套低耦合的消息触发机制。&lt;/p&gt;
&lt;h3&gt;3. 优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;被观察者和观察者之间是抽象耦合的；&lt;/li&gt;
&lt;li&gt;耦合度较低，两者之间的关联仅仅在于消息的通知；&lt;/li&gt;
&lt;li&gt;被观察者无需关心他的观察者；&lt;/li&gt;
&lt;li&gt;支持广播通信；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;观察者只知道被观察对象发生了变化，但不知变化的过程和缘由；&lt;/li&gt;
&lt;li&gt;观察者同时也可能是被观察者，消息传递的链路可能会过长，完成所有通知花费时间较多；&lt;/li&gt;
&lt;li&gt;如果观察者和被观察者之间产生循环依赖，或者消息传递链路形成闭环，会导致无限循环；&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;4. 应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;需要在系统中建立一个单项广播的触发机制；&lt;/li&gt;
&lt;li&gt;系统中某个对象的行为会影响若干其他对象；&lt;/li&gt;
&lt;li&gt;对象之间的关联关系可以在运行时动态的建立与撤销；&lt;/li&gt;
&lt;li&gt;对象之间的关联关系呈现出一种树状结构；&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.  原理&lt;/h3&gt;
&lt;p&gt;下面是GoF介绍的典型的类观察者模式的UML类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190629173030851-1788921679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Subject:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;抽象被观察者，仅提供注册和删除观察者对象的接口声明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConcreteSubject:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　具体被观察者对象，该对象中收集了所有需要被通知的观察者，并可以动态的增删集合中的观察者。当其状态发生变化时会通知所有观察者对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Observer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　抽象观察者，为所有观察者定义获得通知的统一接口；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConcreteObserver:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　观察者对象，其关注对象为Subject，能接受Subject变化时发出的通知并更新自身状态。&lt;/p&gt;
&lt;h3&gt;6.实现&lt;/h3&gt;
&lt;p&gt;接下来先将上面的UML类图转换为具体的代码，然后在举一个具体的例子来看一下其应用。&lt;/p&gt;
&lt;p&gt;抽象被观察者类：Subject&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Subject {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; state);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getState();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(Observer obs);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detach(Observer obs);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notify(String msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 抽象观察者类：Observer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体被观察者类：ConcreteSubject&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteSubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Subject {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Observer&amp;gt; observerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Observer&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; state) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;        
        notify(&lt;/span&gt;&quot;new state: &quot; +&lt;span&gt; state);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getState() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(Observer obs) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        observerList.add(obs);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detach(Observer obs) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        observerList.remove(obs);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notify(String msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Observer obs: observerList) {
            obs.update(msg);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体观察者类：ConcreteObserver&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteObserver &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Observer {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;ConcreteObserver receive notify msg: &quot; +&lt;span&gt; msg);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConcreteObserver obs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcreteObserver();
        ConcreteSubject sub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcreteSubject();
        sub.attach(obs);
        sub.setState(&lt;/span&gt;666&lt;span&gt;);
        sub.notify(&lt;/span&gt;&quot;just test subject notify function!&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ConcreteObserver receive notify msg: &lt;span&gt;new&lt;/span&gt; state: 666&lt;span&gt;
ConcreteObserver receive notify msg: just test subject notify function&lt;/span&gt;!
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7.实例&lt;/h3&gt;
&lt;p&gt;我们以一个更加实际的例子——商品价格的变动来体会一下观察者模式的用途。&lt;/p&gt;
&lt;p&gt;在网上购物的时候，商品一般都有一个价格变动通知，前提是我们关注了该商品。&lt;/p&gt;
&lt;p&gt;这里我们稍微变通一下，只有当关注的商品价格下降，且低于用户期望购买价格的时候，才会给用户发送一条商品降价的短信通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419489/201906/1419489-20190629201327305-1861325463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面分别定义每个类：&lt;/p&gt;
&lt;p&gt;产品抽象类：Product&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Product {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; price);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPrice();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; follow(User user);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unfollow(User user);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyLowPrice();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户抽象类：User&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isExpectedPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; price);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shortMSG(String msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;商品笔记本电脑：Laptop&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Laptop &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Product {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;User&amp;gt; followList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;User&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; curPrice;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; price) {
        curPrice &lt;/span&gt;=&lt;span&gt; price;
        System.out.println(&lt;/span&gt;&quot;set laptop price: &quot; +&lt;span&gt; price);
        notifyLowPrice();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curPrice;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; follow(User user) {
        followList.add(user);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unfollow(User user) {
        followList.remove(user);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyLowPrice() {
        String msg &lt;/span&gt;= &quot;&quot; +&lt;span&gt; curPrice;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user: followList) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (user.isExpectedPrice(curPrice)) {
                user.shortMSG(msg);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关注笔记本电脑用户类：LaptopBuyer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LaptopBuyer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedPrice;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LaptopBuyer(String userName, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedPrice) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.expectedPrice =&lt;span&gt; expectedPrice;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isExpectedPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; curPrice) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; curPrice &amp;lt;=&lt;span&gt; expectedPrice;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shortMSG(String msg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;Your follow product have a low price: &quot; + msg + &quot; TO:&quot; +&lt;span&gt; userName);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        LaptopBuyer Alice &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LaptopBuyer(&quot;Alice&quot;, 6000&lt;span&gt;);
        LaptopBuyer Jack &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LaptopBuyer(&quot;Jack&quot;, 6500&lt;span&gt;);
        Laptop laptop &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Laptop();
        laptop.follow(Alice);
        laptop.follow(Jack);
        laptop.setPrice(&lt;/span&gt;7000&lt;span&gt;);
        laptop.setPrice(&lt;/span&gt;6500&lt;span&gt;);
        laptop.setPrice(&lt;/span&gt;6000&lt;span&gt;);
        laptop.unfollow(Jack);
        laptop.setPrice(&lt;/span&gt;5999&lt;span&gt;);
        laptop.setPrice(&lt;/span&gt;6099&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
set laptop price: 7000&lt;span&gt;
set laptop price: &lt;/span&gt;6500&lt;span&gt;
Your follow product have a low price: &lt;/span&gt;6500&lt;span&gt; TO:Jack
set laptop price: &lt;/span&gt;6000&lt;span&gt;
Your follow product have a low price: &lt;/span&gt;6000&lt;span&gt; TO:Alice
Your follow product have a low price: &lt;/span&gt;6000&lt;span&gt; TO:Jack
set laptop price: &lt;/span&gt;5999&lt;span&gt;
Your follow product have a low price: &lt;/span&gt;5999&lt;span&gt; TO:Alice
set laptop price: &lt;/span&gt;6099
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个例子是一个能够很好地解释观察者模式的一个实际用途。&lt;/p&gt;
&lt;h3&gt;8. 总结&lt;/h3&gt;
&lt;p&gt;相比较与观察者模式，我们或许有许多获取另外一个对象状态的方式，比如，常见的轮询方式，或者仅仅在需要的时候去查一下对方的状态等，不过观察者模式有其特殊的用途，而且更加灵活。&lt;/p&gt;
&lt;p&gt;该模式原理比较简单直接，但是实际使用过程中需要考虑一些细节问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;何时通知？&lt;/li&gt;
&lt;li&gt;有谁触发通知？&lt;/li&gt;
&lt;li&gt;观察者是关注状态变化的次数还是最终的状态？&lt;/li&gt;
&lt;li&gt;如果消息通知被阻塞，应该怎么办？&lt;/li&gt;
&lt;li&gt;是否可以改为异步消息通知？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这些都是实际使用时应该考虑的。考虑清楚这些细节才能更灵活的应用该模式解决实际问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GoF《Design Patterns: Elements of Reusable Object-Oriented Software》&lt;/p&gt;
&lt;p&gt;https://www.runoob.com/design-pattern/observer-pattern.html&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 12:26:00 +0000</pubDate>
<dc:creator>alpha_panda</dc:creator>
<og:description>观察者模式主要用于处理对象间的一对多的关系，是一种对象行为模式。该模式的实际应用场景比较容易确认，当一个对象状态发生变化时，所有该对象的关注者均能收到状态变化通知，以进行相应的处理。本文希望通过简单的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yssjun/p/11107038.html</dc:identifier>
</item>
<item>
<title>.Net for Spark 实现 WordCount 应用及调试入坑详解 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/11107696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/11107696.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;.Net for Spark 实现WordCount应用及调试入坑详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;1.    概述&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      &lt;a href=&quot;http://www.ineuos.net/&quot;&gt;iNeuOS&lt;/a&gt;云端操作系统现在具备物联网、视图业务建模、机器学习的功能，但是缺少一个计算平台产品。最近在调研使用什么语言进行开发，并且研究实现的技术路线。iNeuOS全系使用C#/JS/CSS/PYTHON开发，所以优先选择C#实现计算平台的开发，当然也不排除使用scala和python等语言。最近微软发布.Net for Spark组件，与 .NET Standard 2.0 兼容，可以在 Linux、macOS 和 Windows 系统上使用，就像 .NET 的其余部分一样。在网上进行了调研，下图展示了 .NET Core 与 Python、Scala 在 TPC-H 查询集上的性能对比。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201906/279374-20190629194459381-1412518135.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        在&lt;a href=&quot;https://github.com/dotnet/spark&quot;&gt;github&lt;/a&gt;上看了源代码，代码质量比较高。最近两天进行了应用及测试，整体流程已经走通，感觉比较清爽。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.系统环境&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;         操作系统：Ubuntu 16.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         开发语言：.Net Core 2.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         计算框架：.Net for Spark&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         开发工具：VSCODE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         测试工具：netcat&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;3.环境部署&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;      3.1安装 .Net Core 2.2&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;          参见安装过程：&lt;a href=&quot;https://dotnet.microsoft.com/download/linux-package-manager/ubuntu16-04/sdk-current&quot;&gt;https://dotnet.microsoft.com/download/linux-package-manager/ubuntu16-04/sdk-current&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;      3.2安装 .Net for Spark及代码实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;         参见安装过程：&lt;a href=&quot;https://github.com/dotnet/spark/blob/master/docs/getting-started/ubuntu-instructions.md&quot;&gt;https://github.com/dotnet/spark/blob/master/docs/getting-started/ubuntu-instructions.md&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201906/279374-20190629194614906-1396009297.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Program.cs实现的代码参见：&lt;a href=&quot;https://github.com/dotnet/spark/blob/master/examples/Microsoft.Spark.CSharp.Examples/Sql/Streaming/StructuredNetworkWordCount.cs&quot;&gt;https://github.com/dotnet/spark/blob/master/examples/Microsoft.Spark.CSharp.Examples/Sql/Streaming/StructuredNetworkWordCount.cs&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;     3.3安装 netcat&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;命令行：apt-get install netcat  &lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;4.开发调试&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;     4.1启动netcat&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    主要用于实时发送字符串，实现字符串统计。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;命令行：nc -lk 9999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;    4.2启动调试模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    在程序集目录：HelloSpark/bin/Debug/netcoreapp2.2下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;命令行：spark-submit --class org.apache.spark.deploy.DotnetRunner --master local microsoft-spark-2.4.x-0.3.0.jar debug&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     &lt;span&gt;不执行这个命令，在vscode调试的时候，会出现异常：&lt;strong&gt;[Exception] [JvmBridge] Connection refused 127.0.0.1:5567&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;    4.3启动vscode调试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    在main函数的第一行增加一行测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;args=new string[]{&quot;localhost&quot;,&quot;9999&quot;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      &lt;span&gt;主要用于连接netcat服务，接收netcat发送过来的字符串，并进行字符串统计。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201906/279374-20190629195105657-392227562.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;     4.4调试过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     打开“&lt;strong&gt;4.1启动netcat&lt;/strong&gt;”和“&lt;strong&gt;4.2启动调试模式&lt;/strong&gt;”窗口，netcat用于发送数据，调试模式窗口可以接收到数据并进行统计。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201906/279374-20190629195201274-46695863.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;5.应用发布&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      把main函数内的测试代码删除掉，在工程目录下执行命令：dotnet build，生成新的程序集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在程序集目录：HelloSpark/bin/Debug/netcoreapp2.2下执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;命令行：spark-submit --class org.apache.spark.deploy.DotnetRunner --master local microsoft-spark-2.4.x-0.3.0.jar dotnet HelloSpark.dll localhost 9999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       &lt;span&gt;同样在netcat窗口发送数据，结果如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/279374/201906/279374-20190629195247885-1508578288.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;6.项目合作&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      承接工业物联网、大数据、工业互联网项目。官方网站（iNeuOS）：&lt;a href=&quot;http://www.ineuos.net&quot;&gt;http://www.ineuos.net&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;      项目代码下载：&lt;a href=&quot;https://files.cnblogs.com/files/lsjwq/HelloSpark-WordCount.rar&quot;&gt;博客园下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 11:55:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>.Net for Spark 实现WordCount应用及调试入坑详解 1. 概述 iNeuOS云端操作系统现在具备物联网、视图业务建模、机器学习的功能，但是缺少一个计算平台产品。最近在调研使用什么语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsjwq/p/11107696.html</dc:identifier>
</item>
</channel>
</rss>