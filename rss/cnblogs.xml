<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaScript 正则表达式全面总结 - wenruo</title>
<link>http://www.cnblogs.com/wenruo/p/10612437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenruo/p/10612437.html</guid>
<description>&lt;p&gt;本文适合有 JavaScript 基础 &amp;amp;&amp;amp; 面向搜索引擎书写正则的人群。&lt;/p&gt;
&lt;p&gt;正则表达式是用于匹配字符串中字符组合的模式。正则表达式的模式规则是由一个字符序列组成的。包括所有字母和数字在内，大多数的字符都是直接按照直接量描述待匹配的字符。除此之外，正则表达式还有其他特殊语义的字符，这些字符不按照特殊含义进行匹配。&lt;/p&gt;

&lt;p&gt;JavaScript 中的正则表达式用 RegExp 对象表示，有两种创建方式。&lt;/p&gt;
&lt;h2 id=&quot;直接量语法创建&quot;&gt;1. 直接量语法创建&lt;/h2&gt;
&lt;p&gt;正则表达式直接量定义为包含在一对斜杠（&lt;code&gt;/&lt;/code&gt;）之间的字符。&lt;/p&gt;
&lt;h2 id=&quot;构造函创建&quot;&gt;2. 构造函创建&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;code&gt;RegExp()&lt;/code&gt; 构造函数可以实现动态创建正则表达式。&lt;code&gt;RegExp&lt;/code&gt; 的第二个参数是可选的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new RegExp(pattern [, flags])
RegExp(pattern [, flags])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;pattern&lt;/code&gt; 可以是字符串或者正则字面量。当 &lt;code&gt;pattern&lt;/code&gt; 是字符串时，需要常规的字符转义规则，必须将 &lt;code&gt;\&lt;/code&gt; 替换成 &lt;code&gt;\\&lt;/code&gt;，比如 &lt;code&gt;/\w+/&lt;/code&gt; 等价于 &lt;code&gt;new RegExp(&quot;\\w+&quot;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;正则表达式中所有字母和数字都是按照字面含义进行匹配的，其他非字母的字符需要通过反斜杠（&lt;code&gt;\&lt;/code&gt;）作为前缀进行转移，如 &lt;code&gt;\n&lt;/code&gt; 匹配换行符。这些字符为&lt;strong&gt;直接量字符（literal characters）&lt;/strong&gt;。这些字符都是精确匹配，每一个字符都只能匹配一个字符。&lt;/p&gt;
&lt;p&gt;在正则表达式中，有一些标点符号具有特殊含义，他们是：&lt;strong&gt;&lt;code&gt;^ $ . * + ? = ! : | \ / ( ) [ ] { }&lt;/code&gt;&lt;/strong&gt; 如果需要在正则表达式中与这些直接量进行匹配，必须使用前缀 &lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不记得哪些标点需要反斜杠转义，可以在每个标点符号前都加上反斜杠。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果不想匹配某一个特定的字符而是想匹配某一类字符，则需要使用字符类。&lt;/p&gt;
&lt;p&gt;通过将直接量字符放入方括号内，可以组成字符类（character class）。一个字符类可以匹配它所包含任意 &lt;strong&gt;一个&lt;/strong&gt; 字符。如 &lt;code&gt;[abc]&lt;/code&gt; 可以匹配 a，b，c 中任意一个字符。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;^&lt;/code&gt; 作为方括号中第一个字符来定义否定字符集，它匹配所有不包含在方框括号内的字符。&lt;strong&gt;&lt;code&gt;[^]&lt;/code&gt; 可以匹配任意字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符类可以使用连字符来表示字符范围。比如匹配小写字母&lt;code&gt;[a-z]&lt;/code&gt;，匹配任何字母和数字可以用&lt;code&gt;[a-zA-Z0-9]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一些常用的字符类，在 JavaScript 中有特殊的转义字符来表达它们。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;[...]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方括号内任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[^...]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不在方括号内任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;除了换行符和其他 Unicode 行终止符之外的任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等价于 &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等价于 &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何 Unicode 空白符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何非 Unicode 空白符的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等价于 &lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等价于 &lt;code&gt;[^0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[\b]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退格直接量，与退格键 &lt;code&gt;\u0008&lt;/code&gt; 匹配，注意不同于 &lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;方括号内也可出现转义字符，如 &lt;code&gt;[\d\s]&lt;/code&gt; 表示匹配任意空白符或数字。&lt;/p&gt;

&lt;p&gt;当一个模式需要被多次匹配的时候，正则表达式提供了表示重复的正则语法。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项至少 n 次，但不能超过 m 次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项至少 n 次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项 n 次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项 0 次或 1 次，等价于 &lt;code&gt;{0,1}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项 1 次或多次，等价于 &lt;code&gt;{1,}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前一项 0 次或多次，等价于 &lt;code&gt;{0,}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;贪婪和非贪婪的重复&quot;&gt;贪婪和非贪婪的重复&lt;/h2&gt;
&lt;p&gt;上面所有的重复都是“贪婪的”匹配，也就是匹配尽可能多的字符。如 &lt;code&gt;/a+/&lt;/code&gt; 匹配 &lt;code&gt;'aaaa'&lt;/code&gt; 时，它会匹配 &lt;code&gt;'aaaa'&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果想要尽可能少的匹配，只需要在重复的标记后加一个问号（&lt;code&gt;?&lt;/code&gt;）即可。如 &lt;code&gt;/a+?/&lt;/code&gt; 匹配 &lt;code&gt;'aaaa'&lt;/code&gt; 时，它会匹配 &lt;code&gt;'a'&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;注意：正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置，这意味这 &lt;code&gt;/a+?b/&lt;/code&gt; 匹配 &lt;code&gt;'aaab'&lt;/code&gt; 时，匹配到的是 &lt;code&gt;'aaab'&lt;/code&gt; 而不是 &lt;code&gt;'ab'&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;选择&quot;&gt;选择&lt;/h2&gt;
&lt;p&gt;字符 &lt;code&gt;|&lt;/code&gt; 用于分隔供选择的模式，匹配时会尝试从左到右匹配每一个分组，直到发现匹配项。如 &lt;code&gt;/ab|bc|cd/&lt;/code&gt; 可以匹配字符串&lt;code&gt;'ab'&lt;/code&gt;、&lt;code&gt;'bc'&lt;/code&gt; 和 &lt;code&gt;'cd'&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;分组&quot;&gt;分组&lt;/h2&gt;
&lt;p&gt;圆括号可以把单独的项组合成子表达式，以便可以像一个独立的单元用 &lt;code&gt;|&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;?&lt;/code&gt; 对单元内的项进行处理。&lt;/p&gt;
&lt;h2 id=&quot;引用&quot;&gt;引用&lt;/h2&gt;
&lt;p&gt;带圆括号的表达式的另一个用途是允许在同一个正则表达式的后面引用前面的子表达式。通过&lt;code&gt;\&lt;/code&gt;后面加数字实现。&lt;code&gt;\n&lt;/code&gt; 表示第 n 个带圆括号的子表达式。表示引用前一个表达式所匹配的文本。&lt;strong&gt;因为子表达式可以嵌套，所以根据子表达式左括号的位置进行计数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例，能匹配 1999-01-01 或 1999/01/01 的正则：&lt;code&gt;/\d{4}([-//])\d{2}\1\d{2}/&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;具名引用&quot;&gt;具名引用&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 的语法来为分组命名，并通过 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 在后面的正则表达式中引用。如上面的正则可以改写为：&lt;code&gt;/\d{4}(?&amp;lt;separator&amp;gt;[-//])\d{2}\k&amp;lt;separator&amp;gt;\d{2}/&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;忽略引用&quot;&gt;忽略引用&lt;/h3&gt;
&lt;p&gt;如果只想用圆括号来表示子表达式，而不希望生成引用，可以使用 &lt;code&gt;(?:)&lt;/code&gt; 来进行分组。例，&lt;code&gt;/(?:a)(?:b)(c)/&lt;/code&gt; 中 &lt;code&gt;\1&lt;/code&gt; 将表示 &lt;code&gt;(c)&lt;/code&gt; 所匹配的文本。&lt;/p&gt;

&lt;p&gt;有一些正则表达式的元素&lt;strong&gt;不用来匹配实际的字符，而是匹配指定的位置&lt;/strong&gt;。我们称这些元素为正则表达式的锚。&lt;/p&gt;
&lt;p&gt;正则表达式中的锚字符包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 用来匹配字符串的开始，多行检索时匹配一行的开头。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 用来匹配字符串的结束，多行检索时匹配一行的结尾。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\b&lt;/code&gt; 用来匹配单词的边界，就是 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\W&lt;/code&gt; 之间的位置，或者 &lt;code&gt;\w&lt;/code&gt; 和字符串的开头或结尾之间的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\B&lt;/code&gt; 匹配非单词边界的位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例： &lt;code&gt;/\bJava\b/&lt;/code&gt; 可以匹配 &lt;code&gt;Java&lt;/code&gt; 却不匹配 &lt;code&gt;JavaScript&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任意正则表达式都可以作为锚点条件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;先行断言&quot;&gt;先行断言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;(?=pattern)&lt;/code&gt; 它表示一个位置，该位置&lt;strong&gt;之后&lt;/strong&gt;的字符能&lt;strong&gt;匹配&lt;/strong&gt; &lt;code&gt;pattern&lt;/code&gt; 。如 &lt;code&gt;/\d+(?=%)/&lt;/code&gt; 匹配字符串 &lt;code&gt;'100%'&lt;/code&gt; 中的 &lt;code&gt;'100'&lt;/code&gt; 但是不匹配 &lt;code&gt;'100。'&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;负向先行断言&quot;&gt;负向先行断言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;(?!pattern)&lt;/code&gt; 它表示一个位置，该位置&lt;strong&gt;之后&lt;/strong&gt;的字符能&lt;strong&gt;不匹配&lt;/strong&gt; &lt;code&gt;pattern&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;后行断言&quot;&gt;后行断言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;(?&amp;lt;=pattern)&lt;/code&gt; 它表示一个位置，该位置&lt;strong&gt;之前&lt;/strong&gt;的字符能&lt;strong&gt;匹配&lt;/strong&gt; &lt;code&gt;pattern&lt;/code&gt; 。例，&lt;code&gt;/(?&amp;lt;=\$)\d+/&lt;/code&gt; 匹配 &lt;code&gt;'$100'&lt;/code&gt; 但是不匹配 &lt;code&gt;'￥100'&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;负向后行断言&quot;&gt;负向后行断言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;(?&amp;lt;!pattern)&lt;/code&gt; 它表示一个位置，该位置&lt;strong&gt;之前&lt;/strong&gt;的字符能&lt;strong&gt;不匹配&lt;/strong&gt; &lt;code&gt;pattern&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在正则表达式的第二条斜线之后，可以指定一个或多个修饰符，&lt;code&gt;/pattern/g&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;常用修饰符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 执行不区分大小写的匹配。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 全局匹配。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 多行匹配模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; “粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 表示点（.）可以表示任意字符，不设置的话，四个字节的 UTF-16 字符和行终止符不能用 . 表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 开启 “Unicode 模式”，用来正确处理大于 &lt;code&gt;\uFFFF&lt;/code&gt; 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过 &lt;code&gt;RegExp.prototype.flags&lt;/code&gt; 可以获得正则修饰符的字符串。&lt;code&gt;/pattern/ig.flags&lt;/code&gt; 返回 &lt;code&gt;&quot;gi&quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;string.prototype.searchregexpsubstr&quot;&gt;String.prototype.search(regexp|substr)&lt;/h2&gt;
&lt;p&gt;返回第一个和参数匹配的子串的起始位置。没有匹配子串返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果参数不是正则表达式，将会通过 &lt;code&gt;RegExp&lt;/code&gt; 构造函数转换成正则表达式。它会忽略正则的修饰符 &lt;code&gt;g&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;string.prototype.replaceregexpsubstr-newsubstrfunction&quot;&gt;String.prototype.replace(regexp|substr, newSubStr|function)&lt;/h2&gt;
&lt;p&gt;第一个参数同&lt;code&gt;search&lt;/code&gt;，查找指定子串。如果第二个表达式是字符串，将把第一个参数匹配的子串替换为 &lt;code&gt;newSubStr&lt;/code&gt;。如果在替换字符串中出现了 &lt;code&gt;$&lt;/code&gt; 加数字，&lt;code&gt;replace&lt;/code&gt; 将用与指定的子表达式相匹配的文本来替换这些字符。&lt;/p&gt;
&lt;p&gt;例，单书名号包裹文本改为书名号。&lt;code&gt;'&amp;lt;JavaScript&amp;gt;和&amp;lt;正则表达式&amp;gt;'.replace(/&amp;lt;([^_]*?)&amp;gt;/g, '《$1》')&lt;/code&gt; 会得到 &lt;code&gt;&quot;《JavaScript》和《正则表达式》&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用字符串作为参数时替换字符串可以插入下面的特殊变量名：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 插入一个 &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;amp;&lt;/code&gt; 插入匹配的子串。&lt;/li&gt;
&lt;li&gt;`$`` 插入当前匹配的子串左边的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$'&lt;/code&gt; 插入当前匹配的子串右边的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$n&lt;/code&gt; 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用函数作为第二个参数&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function replacer(match, p1, p2, p3, offset, string) { }
// match        匹配的子串。
// p1,p2, ...   假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。
// offset       匹配到的子字符串在原字符串中的偏移量。子串首字母下标。
// string       被匹配的原字符串。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例，下划线命名转驼峰命名。&lt;code&gt;'a_simple_name'.replace(/_([a-z])/g, (m, p1) =&amp;gt; p1.toUpperCase())&lt;/code&gt; 将得到 &lt;code&gt;&quot;aSimpleName&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;string.prototype.matchregexp&quot;&gt;String.prototype.match(regexp)&lt;/h2&gt;
&lt;p&gt;参数 &lt;code&gt;regexp&lt;/code&gt; 为一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 &lt;code&gt;new RegExp(obj)&lt;/code&gt; 将其转换为一个 &lt;code&gt;RegExp&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;regexp&lt;/code&gt; 没有设置修饰符 &lt;code&gt;g&lt;/code&gt;，则仅返回第一个完整匹配及其相关的捕获组（Array），返回数组第一个字符是匹配字符串，余下的元素是正则表达式中圆括号括起来的子表达式。在这种情况下，返回的项目将具有如下所述的其他属性（groups: 一个捕获组数组 或 &lt;code&gt;undefined&lt;/code&gt;（如果没有定义命名捕获组）。index: 匹配的结果的开始位置。input: 搜索的字符串。），或者未匹配时返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;g&lt;/code&gt; 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组，或者未匹配时返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;'196.168.0.1'.match(/(\d+)(?=.|$)/) // (?=.|$) 先行匹配 匹配 . 或者字符串结尾
// (2) [&quot;196&quot;, &quot;196&quot;, index: 0, input: &quot;196.168.0.1&quot;, groups: undefined]
'196.168.0.1'.match(/(?&amp;lt;num&amp;gt;\d+)(?=.|$)/) // (?&amp;lt;name&amp;gt;) 具名引用 见上文
// (2) [&quot;196&quot;, &quot;196&quot;, index: 0, input: &quot;196.168.0.1&quot;, groups: {num: &quot;196&quot;}]
'196.168.0.1'.match(/\d+(?=.|$)/g)
// (4) [&quot;196&quot;, &quot;168&quot;, &quot;0&quot;, &quot;1&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string.prototype.splitseparator-limit&quot;&gt;String.prototype.split([separator[, limit]])&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;separator&lt;/code&gt; 指定表示每个拆分应发生的点的字符串，可以是一个字符串或正则表达式。如果空字符串（&lt;code&gt;&quot;&quot;&lt;/code&gt;）被用作分隔符，则字符串会在每个字符之间分割。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;limit&lt;/code&gt; 一个整数，限定返回的分割片段数量。&lt;/p&gt;
&lt;p&gt;例，&lt;code&gt;'张三;李四,王五|赵六'.split(/[;\|,]/) // (4) [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;]&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; 会返回正则表达式的修饰符。&lt;/li&gt;
&lt;li&gt;表示对应修饰符是否存在的只读布尔值，&lt;code&gt;global&lt;/code&gt;(表示是否带有修饰符 &lt;code&gt;g&lt;/code&gt;)，&lt;code&gt;ignoreCase&lt;/code&gt; （&lt;code&gt;i&lt;/code&gt;），&lt;code&gt;multiline&lt;/code&gt;（&lt;code&gt;m&lt;/code&gt;），&lt;code&gt;sticky&lt;/code&gt;（&lt;code&gt;y&lt;/code&gt;），&lt;code&gt;dotAll&lt;/code&gt;（&lt;code&gt;s&lt;/code&gt;），&lt;code&gt;unicode&lt;/code&gt;（&lt;code&gt;u&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source&lt;/code&gt; 只读字符串，包含正则表达式的文本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lastIndex&lt;/code&gt; 可读/写整数。如果带有 &lt;code&gt;g&lt;/code&gt; 修饰符，这个属性存储在整个字符串中下一次检索的开始位置。这个属性会被 &lt;code&gt;exec()&lt;/code&gt; 和 &lt;code&gt;test()&lt;/code&gt; 方法用到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;exec&quot;&gt;exec()&lt;/h2&gt;
&lt;p&gt;如果没有找到任何属性，将返回 &lt;code&gt;null&lt;/code&gt;，如果找到匹配返回一个数组，该数组第一个元素是相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。&lt;/p&gt;
&lt;p&gt;当调用 &lt;code&gt;exec()&lt;/code&gt; 的正则表达式具有修饰符 &lt;code&gt;g&lt;/code&gt; 时，它将把当前正则表达式对象的 &lt;code&gt;lastIndex&lt;/code&gt; 属性设置为紧挨着匹配子串的字符位置。&lt;/p&gt;
&lt;p&gt;注意即使两次匹配的不是同一个字符串，&lt;code&gt;lastIndex&lt;/code&gt; 还是会连续生效的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let reg = /\d+/g;
reg.exec('25*10=250'); // [&quot;25&quot;, index: 0, input: &quot;25*10=250&quot;, groups: undefined]
reg.lastIndex; // 2
reg.exec('666'); // [&quot;6&quot;, index: 2, input: &quot;666&quot;, groups: undefined]
reg.lastIndex; // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;test&quot;&gt;test()&lt;/h2&gt;
&lt;p&gt;调用 &lt;code&gt;test()&lt;/code&gt; 和 &lt;code&gt;exec()&lt;/code&gt; 等价，当 &lt;code&gt;exec()&lt;/code&gt; 返回结果不是 &lt;code&gt;null&lt;/code&gt;，&lt;code&gt;test()&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String 的方法不会用到 &lt;code&gt;lastIndex&lt;/code&gt; 属性。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 27 Mar 2019 23:57:00 +0000</pubDate>
<dc:creator>wenruo</dc:creator>
<og:description>本文适合有 JavaScript 基础 &amp;&amp; 面向搜索引擎书写正则的人群。 正则表达式是用于匹配字符串中字符组合的模式。正则表达式的模式规则是由一个字符序列组成的。包括所有字母和数字在内，大多数的字符</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenruo/p/10612437.html</dc:identifier>
</item>
<item>
<title>css的继承和层叠 - cherry小樱桃</title>
<link>http://www.cnblogs.com/surewing/p/10612512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surewing/p/10612512.html</guid>
<description>&lt;p&gt;标签（空格分隔）： css&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;css称为层叠样式表，CSS有两大特性：继承性和层叠性，本章简单介绍一下继承性：&lt;/p&gt;
&lt;h2 id=&quot;继承性&quot;&gt;继承性：&lt;/h2&gt;
&lt;p&gt;定义：继承就是给父及设置了一些属性，子级继承了父及的该属性，这就是我们的css的继承，有一些属性可以继承，&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;继承性&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .father{
            color:red;

        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;father&quot; id=&quot;egon&quot;&amp;gt;
    &amp;lt;p&amp;gt;wangwang&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/nyk3fo4f8vc6o3y9v29ihuwe/image.png&quot; alt=&quot;image.png-232.5kB&quot;/&gt;&lt;br/&gt;问题：背景色是不是继承？&lt;/p&gt;
&lt;pre class=&quot;pytnon&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;继承性&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .father{
            color:red;
            font-size: 30px;
            background-color: green;

        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;father&quot; id=&quot;egon&quot;&amp;gt;
    &amp;lt;p&amp;gt;wangwang&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/zlspscmzip9usfe01e9ker6z/image.png&quot; alt=&quot;image.png-182.1kB&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;通过上述的例子，背景色不属于继承，P标签的标签是透明的，但是从肉眼看到的是绿色的，他是通过透明提现的，所以background是没有继承的；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;哪些属性可以继承&quot;&gt;哪些属性可以继承&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;color,&lt;br/&gt;font-&lt;em&gt;,&lt;br/&gt;text-&lt;/em&gt;,&lt;br/&gt;line-*&lt;br/&gt;像一些盒子元素，定位元素（浮动，绝对，固定定位）不能继承，大家可以先了解一下；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;层叠性&quot;&gt;层叠性：&lt;/h2&gt;
&lt;p&gt;这里先举个例子，大家猜猜如下的代码，P标签是什么颜色？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;层叠性&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        #box{
            color:red;

        }
        .container{
            color:yellow;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p id=&quot;box&quot; class=&quot;container&quot;&amp;gt;
        猜猜我是什么颜色
    &amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/ibdsvd1za7fylb4ymz4xg3nj/image.png&quot; alt=&quot;image.png-71.7kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题为什么显示为红色呢代码不是从上往下执行的吗&quot;&gt;问题：为什么显示为红色呢？代码不是从上往下执行的吗？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;答案：在css里面我们会讨论这个问题，在CSS里面有个权重的概念，谁的权重大，浏览器就会显示谁的属性；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;例如：如下代码执行：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;层叠性&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        #box{
            color:red;

        }
        .container{
            color:yellow;
        }
        p{
            color:purple;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p id=&quot;box&quot; class=&quot;container&quot;&amp;gt;
        猜猜我是什么颜色
    &amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;执行结果：还是显示红色，为什么呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;那么如何判断谁的权重大？非常简单，就是数数：&lt;br/&gt;1.先数：id的数量；100&lt;br/&gt;2.在数：class数量010&lt;br/&gt;3.标签：数量001&lt;br/&gt;上述的代码：中当仅仅显示id的时候：这时候100我们只看id的时候，对应的ID是1，对应的类是0，对应的标签是0&lt;br/&gt;当显示：类的时候：010，这时候对应的ID是0，对应的类是1，对应的标签是0&lt;br/&gt;当显示：标签的时候：001对应的ID是0，对应的类是0，对应的标签是1；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;比较的方法：&lt;br/&gt;比较id的数量：如上述所述：id第一位是1，就不再进行后续的比较了；&lt;br/&gt;100----010---001；&lt;br/&gt;如上第一位比较大，就不在进行后续的比较了，如果第一位一样我们比较第二位，如果第二位比较大，我们不在进行比较就是显示第二位大的那个，如果第一位和第二位都一样的话，就继续比较；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;层叠性&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        &amp;lt;!--这时候100我们只看id的时候，对应的ID是1，对应的类是0，对应的标签是0--&amp;gt;
        #box{
            color:red;

        }
        /*010，这时候对应的ID是0，对应的类是1，对应的标签是0*/
        .container{
            color:yellow;
        }
        /*001对应的ID是0，对应的类是0，对应的标签是1*/
        p{
            color:purple;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p id=&quot;box&quot; class=&quot;container&quot;&amp;gt;
        猜猜我是什么颜色
    &amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;权重&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        &amp;lt;!-- id 为2个0个类1个标签--&amp;gt;
        #box1 #box2{
            color:yellow;

        }
        /*1 1 1*/
        #box2 .wrap3{
            color:red;
        }
        /*1 0 3*/
        div div #box3 p{
            color:purple;
        }
        /*0 3 4*/
        div.wrap1 div.wrap2 div.wrap3 p{
            color:blue;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;box1&quot; class=&quot;wrap1&quot;&amp;gt;
        &amp;lt;div id=&quot;box2&quot; class=&quot;wrap2&quot;&amp;gt;
            &amp;lt;div id=&quot;box3&quot; class=&quot;wrap3&quot;&amp;gt;
                &amp;lt;p&amp;gt;我是什么颜色&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在比较的时候会先比较id的数量，然后比较类的数量，标签的数量；权重大的就是有限显示权重大的；&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/p7k82sgy18jfa7oc5lx1tzc2/image.png&quot; alt=&quot;image.png-93.1kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权重相同的处理&quot;&gt;权重相同的处理&lt;/h3&gt;
&lt;p&gt;例如：下边的代码，权重一样的时候，应该怎么显示呢？应该显示后边的最新的权重；&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;权重&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        /*1 1 1*/
        #box1 .wrap2 p{
            color:red;
        }
        /*1 1 1*/
         #box2 .wrap3 p{
            color:yellow;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;box1&quot; class=&quot;wrap1&quot;&amp;gt;
        &amp;lt;div id=&quot;box2&quot; class=&quot;wrap2&quot;&amp;gt;
            &amp;lt;div id=&quot;box3&quot; class=&quot;wrap3&quot;&amp;gt;
                &amp;lt;p&amp;gt;我是什么颜色&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;so:所以上述执行的颜色结果是：黄色；&lt;br/&gt;问题：&lt;br/&gt;通过上述的学习大家看看下边的例子的网页应该显示为什么颜色？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;权重&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        /*2 1 0 */
        #box1 #box2 .wrap3{
            color:red;
        }
        /*1 1 1*/
         #box2 .wrap3 p{
            color:yellow;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;box1&quot; class=&quot;wrap1&quot;&amp;gt;
        &amp;lt;div id=&quot;box2&quot; class=&quot;wrap2&quot;&amp;gt;
            &amp;lt;div id=&quot;box3&quot; class=&quot;wrap3&quot;&amp;gt;
                &amp;lt;p&amp;gt;我是什么颜色&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据我们以上的学习大家毫无疑问肯定是：红色；&lt;/p&gt;
&lt;p&gt;颜色结果如下：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/t9hehubkgvd6x7rgxno12qtt/image.png&quot; alt=&quot;image.png-9.3kB&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;so:这里总结：我们会先看一下标签有没有被选中，选中了，就是开始数数(id ,class ,标签的数量，)谁的权重大就显示谁的属性，如果没有被选中，权重为0&lt;br/&gt;如果权重都是被继承下来的权重都是0，“就近原则”这里就近原则就是说谁描述的近；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 Mar 2019 22:00:00 +0000</pubDate>
<dc:creator>cherry小樱桃</dc:creator>
<og:description>标签（空格分隔）： css css称为层叠样式表，CSS有两大特性：继承性和层叠性，本章简单介绍一下继承性： 继承性： 定义：继承就是给父及设置了一些属性，子级继承了父及的该属性，这就是我们的css的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surewing/p/10612512.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 共享第三方依赖库部署的Bug(*.deps.json on 2.2.0 or 4.6.0 版本) - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/10612508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/10612508.html</guid>
<description>&lt;p&gt;I try to put the Microsoft.&lt;em&gt;*.dll and System.*&lt;/em&gt;.dll togather to a new folder.&lt;br/&gt;以便把(第三方或）系统的和应用的dll分开。&lt;br/&gt;之前花了很长的一段时间研究之后，最后：&lt;br/&gt;I find xxx.deps.json can make it work.&lt;/p&gt;
&lt;p&gt;之后我还特意写了篇文章介绍它：&lt;a href=&quot;https://www.cnblogs.com/cyq1162/p/10542832.html&quot; rel=&quot;nofollow&quot;&gt;https://www.cnblogs.com/cyq1162/p/10542832.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;but today,when i update the Microsoft. Aspnetcore to 2.2.0 version.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328041631862-283470328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前框架引用的是全家桶Microsoft.AspNetCore.All，感觉发布的时候，多了太多没用的dll。&lt;/p&gt;
&lt;p&gt;所以为了瘦身，只挑几个必要的，然后升级了一下版本，毕竟听说NetCore新版本性能更强了。&lt;/p&gt;
&lt;p&gt;只是没想到啊。&lt;/p&gt;
&lt;p&gt;it dose not work, and make me crazy.&lt;/p&gt;
&lt;p&gt;because it always show me the msg like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F:\Code\OpenSource\Aries-GitHub\trunk\Aries.DevFramework\Web.UI_NetCore\bin\Rele ase\PublishOutput&amp;gt;dotnet Web.UI.dll Error: **An assembly specified in the application dependencies manifest (Web.UI.deps.js on) was not found**: package: 'Microsoft.AspNetCore.Authentication.Abstractions', version: '2.2.0 ' path: 'lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.d ll'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328041914575-883486476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;and the json like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Microsoft.AspNetCore.Authentication.Abstractions/2.2.0&quot;: {
        &quot;dependencies&quot;: {
          &quot;Microsoft.AspNetCore.Http.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Logging.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Options&quot;: &quot;2.2.0&quot;
        },
        &quot;runtime&quot;: {
          &quot;lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.dll&quot;: {
            &quot;fileVersion&quot;: &quot;2.2.0.18316&quot;
          }
        }
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328042001937-1199529226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我花了N长的时间在检测配置和确定路径的正确性，不管是相对的，还是绝对的；&lt;/p&gt;
&lt;p&gt;在服务器上，在本地上，但结果，却依旧很悲催。&lt;/p&gt;
&lt;p&gt;甚至，我上一篇中指向把源码都下到本地了，搜了半天关键字，也没啥发现。&lt;br/&gt;it take me much time to find out the question what it's.&lt;/p&gt;

&lt;p&gt;when i try to maike it like this:&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions/2.2.xxx&lt;br/&gt;it work.&lt;br/&gt;就是这样，只要版本号不是2.2.0，它就一切正常。&lt;br/&gt;之后又几次测试，发现版本号是4.6.0也同样有问题。&lt;br/&gt;and then i find the version on /4.6.0 ,it does not work also.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是这样，版本号三位数，尾数是0的，就提示找不到dll。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;how ugly this bug it's.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;过点时间再升一下版本，只要尾号不是以0为结尾就好，像之前一直用2.0.3版本，就很好。&lt;/p&gt;
&lt;p&gt;或者，把版本号替换掉。&lt;/p&gt;
&lt;p&gt;Github上也留言了，小小问题，但愿早日修复：&lt;a href=&quot;https://github.com/dotnet/core-setup/issues/5588&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/core-setup/issues/5588&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，祝大伙玩NetCore玩的快乐。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 20:31:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<og:description>之前花了很长的一段时间研究之后，以便把(第三方或）系统的和应用的dll分开，最后还写了一篇文章介绍，木有想到，今天又入坑了，发现了一个bug。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/10612508.html</dc:identifier>
</item>
<item>
<title>架构设计之「 微服务入门 」 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10612478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10612478.html</guid>
<description>&lt;p&gt;微服务这几年不可谓不火，很多技术团队都开始在自己的项目上引入了微服务。一方面这些团队确实很好的推动了微服务的应用和发展，另一方面也可以看到一些盲目追技术热点的行为所带来的危害，比如很多中小团队对微服务的基础知识只是做了很浅显的了解就开始盲目的推动微服务的实施，最后导致了项目的失败。&lt;/p&gt;
&lt;p&gt;微服务要想做好是一个非常复杂的架构，今天就先只聊一聊微服务的一些基础架构，算是入门篇。&lt;/p&gt;
&lt;h4 id=&quot;一什么是-微服务&quot;&gt;一、什么是「 微服务 」？&lt;/h4&gt;
&lt;p&gt;「 微服务 」由 Martin Fowler 提出，它是指一种软件架构风格。一个大型的系统可以由多个微服务组成，每个微服务是被独立部署，独立完成自己的任务单元，微服务之间是通过API方式进行通信调用，是松耦合的。&lt;/p&gt;
&lt;p&gt;这个模式听着是不是很熟悉的感觉？&lt;/p&gt;
&lt;p&gt;因为在提出「 微服务 」概念之前，很多互联网公司的中大型项目早就是按照将业务拆分成独立单元的形式在部署和架构的，这与微服务的思路是一脉相通的，只不过实现方式没有现在这么规范与体系。&lt;/p&gt;
&lt;p&gt;那「 微服务 」到底是怎么演变过来的呢？&lt;/p&gt;
&lt;p&gt;在做一个新项目的时候，一开始项目大多数都很小，都是「 单体应用 」，这是很常见的做法。在项目规模小的时候，这种方式开发效率和运维效率都最高，符合互联网公司快速响应的要求。&lt;/p&gt;
&lt;p&gt;但是随着业务量越来越大，项目也越来越复杂，开发团队人员也越来越多。这个时候还采用单体应用，问题就会很明显了。下面挑选两个最为常见的问题来举例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;协同问题：&lt;/strong&gt;多个人同时开发一份代码，在工作协同上就会经常遇到代码冲突问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性问题：&lt;/strong&gt;因为是单体应用，即使改个最小的功能，也需要整体发布，不仅直接影响了线上可用性，还可能会对正常功能带来风险。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决这些问题，大家就开始考虑将「 单体应用 」进行拆分，进行服务化部署。然后又随着 Martin Fowler对「 微服务 」概念的提出，加上 DevOps 的流行，进一步促进了微服务的火热发展。&lt;/p&gt;
&lt;p&gt;「 微服务 」的理念提倡每个服务都是单一职责，且每一个服务都能实现自治，因此可以带来一些明显好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;部署简单：&lt;/strong&gt;每个微服务都可以独立去部署，方便快捷。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑清晰：&lt;/strong&gt;将一个独立功能逻辑封装在单一微服务里面，实现整体项目的逻辑清晰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展：&lt;/strong&gt;因为可以随时增加和减少微服务，可以很方便的扩展功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性高：&lt;/strong&gt;某一个功能的异常可以隔离在单一微服务里面，可以提高整体可靠性。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二-微服务-的架构是什么样&quot;&gt;二、「 微服务 」的架构是什么样？&lt;/h4&gt;
&lt;p&gt;我们先来看一下「 微服务 」的架构图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/JG/001/001.png&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/JG/001/001.png&quot; alt=&quot;img&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（图片来源网络，粉丝太少就懒得画图了，大家发挥一下想象力将就的看看，哈哈）&lt;/p&gt;
&lt;p&gt;看起来挺复杂对不对，事实上也确实很复杂。&lt;/p&gt;
&lt;p&gt;所以微服务并不是适用于所有项目、所有团队的。在应用之前一定要搞清楚是否适合自己。&lt;/p&gt;
&lt;p&gt;要保证这么一套微服务架构能成功运行起来，我们起码需要以下这些 &lt;strong&gt;微服务的基础组件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署了一个微服务节点，得让调用者知道啊，当微服务节点有增加或减少的时候，也得让调用者及时知晓啊。这些问题都是通过“服务注册”组件来实现的，服务提供者将自己的服务地址等信息登记到“服务注册”组件中，调用者需要的时候，每次都先去查询“服务注册”即可。免去人工维护微服务节点的信息同步问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是指提供给外部系统调用的是统一网关。主要做安全和权限控制等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;配置中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务的配置中心是用来统一管理所有微服务节点的配置信息的。因为同一个程序可能要适用于多个环境，所以在微服务实践中要尽量做到程序与配置分离，将配置进行集中管理。包括微服务节点信息、程序运行时配置、变量配置、数据源配置、日志配置、版本配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是指用来规范各个微服务节点之间通信标准的。服务间通信采用什么协议、数据是如何传输的、数据格式是什么样的。有了这个统一的“服务框架”就能保证各个微服务节点之间高效率的协同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务运行起来之后，为了能够监控节点的健康情况，保障节点的高可行，需要对各个服务节点进行收集数据指标、然后对数据进行实时处理和分析，形成监控报表和预警。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦使用了微服务架构，那么当有请求过来时，就会经过多个微服务节点的处理，形成了一个调用链。为了进行问题追踪和故障的定位，需要对请求的完整调用链进行记录。&lt;/p&gt;
&lt;p&gt;这里的服务追踪与上面的服务监控是不同维度的，一个是全局的，一个是微观的，发挥的作用也不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务治理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是指需要通过准备一些策略和方案，来保障整个微服务架构在生产环境遇到极端情况下也能正常提供服务的措施。比如 熔断、限流、隔离等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，上述只是一个微服务架构最为核心的基础组件，一旦微服务体系过大，例如有几十上百个微服务节点，那么开发、维护、测试的成本就会非常大。因此一般还会引入 自动化部署 和 自动化测试 来提高协同效率。&lt;/p&gt;
&lt;h4 id=&quot;三-微服务-入门如何避免踩坑&quot;&gt;三、「 微服务 」入门如何避免踩坑？&lt;/h4&gt;
&lt;p&gt;你以为微服务架构都是下面这样的吗？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/JG/001/002.png&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/JG/001/002.png&quot; alt=&quot;img&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上，更能是下面这样的，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/450255266/courses/blob/master/JG/001/003.png&quot;&gt;&lt;img src=&quot;https://github.com/450255266/courses/raw/master/JG/001/003.png&quot; alt=&quot;img&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（图片来源网络）&lt;/p&gt;
&lt;p&gt;大家都在宣扬「 微服务 」多么多么的好，例如：易扩展、松耦合、服务简单、独立开发、易维护、轻量级等等。虽然这些优势也是事实，但是「 微服务 」带来的问题也很多，尤其是对于刚入门的团队而言，应用微服务后，趟坑真的可以趟到你崩溃。下面就普及一些常见的问题来给大家打个预防针：&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;不是所有项目都适用微服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些项目规模还比较小，或者项目才刚立项启动，也只有三四个人负责开发维护，这时候是不建议一上来就搞微服务架构的。这种情况下搞微服务，不仅是“杀鸡用牛刀”，而且还无谓的增加了项目的复杂度，本身一个单体结构就可以搞定的事情，非得拆分N多节点，人员又不足以支撑这么多节点的开发维护，这完全是自找苦吃。反而是等项目成熟了、规模大了之后，再开始慢慢将原有结构拆为微服务才是正确的做法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;不要拆分过多过细的服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使项目经过评估后适合拆为微服务架构，但也不要过度拆解。有的团队喜欢将项目拆成很细很细的颗粒，最后把项目搞的特别复杂，整个团队都陷进去了。&lt;/p&gt;
&lt;p&gt;拆分服务的颗粒度应该根据业务发展和团队现状综合去考虑。这里可以参考一个很火的理论&lt;strong&gt;「 康威定律 」&lt;/strong&gt;。什么样的团队，就产生什么样的架构，微服务拆分的颗粒度是需要和团队结构相匹配的。当你着手拆微服务的时候，得先评估一下团队人员和素质，一般在开发期，2-3个人开发一个服务是合理的，在维护期，1个人维护2-3个服务也是合理的。&lt;/p&gt;
&lt;p&gt;如果拆分过细，开发人员跟不上，会严重降低大家的工作效率。并且过细的服务，会导致一个请求的调用链条很长，不仅会影响请求的响应时间，也会对线上问题排查带来增加难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;没有DevOps就不要急于微服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个稳定的微服务架构，是需要 持续集成、自动化部署、自动化测试、健全的监控体系来保障的。如果团队还不具备DevOps，这些基础的建设都没有做好，一上来就搞微服务的话，就会导致实施过程中问题百出，微服务的优势不能发挥。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，就是对架构设计中「 微服务基础 」的一些思考。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 18:25:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>微服务这几年不可谓不火，很多技术团队都开始在自己的项目上引入了微服务。一方面这些团队确实很好的推动了微服务的应用和发展，另一方面也可以看到一些盲目追技术热点的行为所带来的危害，比如很多中小团队对微服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10612478.html</dc:identifier>
</item>
<item>
<title>[蓝牙前沿应用] 照明即平台 —— 通过蓝牙增强服务提高照明投资回报率（蓝牙MESH、定位AoA、AoD） - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/10604840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/10604840.html</guid>
<description>&lt;p&gt; &lt;br/&gt;&lt;strong&gt;1、照明即平台(LAAP)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着照明设施向LED转型，他们也在利用类似于蓝牙MESH的技术，创建一个可连接的照明平台，作为他们建筑的中枢神经系统。这些系统除了提供先进的照明控制，还建立了一个增强版的楼宇服务平台，例如：寻路定位、资产跟踪、兴趣采集、空间应用，这些都显著提高了新照明基础设施的投资回报率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/56/9e263501a31ae319c1f9b170a00bf6.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;智能照明带来的附加服务价值是照明控制和节能本身价值的7到10倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;2、在零售中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在零售领域，传统的灯具仅仅提供照明功能，当切换成具备蓝牙beacon能力的智能灯后，可以帮助客户和员工在商店中导航并更快、更容易地找到产品。全球各地的零售商也在利用蓝牙信标进行个性化促销，以创造更好的购物者体验并增加销售额。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/7a/bf9c580b011ba950ae77f41befb655.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;91%的消费者在购物时对促销信息是OPEN的；&lt;/li&gt;
&lt;li&gt;在TOP20名零售商中，75%已经部署了位置服务；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;蓝牙技术给了我们提供准确室内定位服务所需的稳定性和可靠性。 —— Trevayne O’Brien, Pointr&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;3、在博物馆中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在阿姆斯特丹的梵高博物馆最近用具备蓝牙功能的LED模组和传感器取代他们传统照明系统。结果，博物馆的照明系统可以检测LUX、温度和湿度水平，以帮助保存无价的艺术品，同时减少维护和日常开销。世界各地的博物馆也在使用先进的照明控制来提供兴趣点信息和寻路服务，以增强游客体验。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;100%的手机、笔记本、PC拥有蓝牙&lt;/li&gt;
&lt;li&gt;50%的能源节省，当使用智能照明控制系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/a6/db3f0e9a5c90e1554df95d51bd0424.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;蓝牙的独特优势在于它被消费者大量采用。 —— Jakub Krzych, Estimote, Inc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;4、在办公场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近CBRE（世邦魏理仕）升级了他们阿姆斯特丹办公室的照明系统为：先进蓝牙照明控制平台，包括400个吸顶灯。这个系统收集数据，来帮助CBRE分析楼宇，以降低能源成本、优化员工的工作环境、并充分利用办公空间。这家耗资142亿美元的房地产服务巨头计划在全球范围内为其许多房产提供类似的设施，使CBRE能够为租户提供相同的基础设施、服务和福利。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CBRE总部生产力提高18%&lt;/li&gt;
&lt;li&gt;50%的房地产在普通企业中未得到充分利用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/e4/3c8a4e0a9f017818b61862e7b37831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;5、支撑技术&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;蓝牙MESH技术&lt;/p&gt;
&lt;p&gt;传统一个手机同时只能连接1～8个BLE设备，在面向未来的智能照明场景中，需要蓝牙具备组网能力，bluetooth mesh便应运而生。&lt;/p&gt;
&lt;p&gt;其拓扑结构如下：(包括低功耗节点、Friend节点、中继节点等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/c6/0304eafb2f8219f9456491dc43a5c8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个具体的实例如下：（灯具、开关、风扇构成对等通信MESH网络，低功耗温度传感器节点可通过友谊节点将数据发送到网络，智能手机能够通过MESH中的灯具、风扇、开关等连接来与整个MESH网络通信）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/f7/dcbfaaf29dde51c1d5eaa10f4f46c7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BLUETOOTH MESH网络更有意思的点是可以做&lt;strong&gt;本地联动&lt;/strong&gt;，如下图：（通过&lt;strong&gt;发布与订阅系统&lt;/strong&gt;，可以实现一个开关绑定不同群组的灯具，多个开关绑定同一群组的灯具，可以实现非常丰富的本地自动化联动策略。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/27/5569d3260f053d5ccb68dce3f5d0b8.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;35&quot;&gt;
&lt;p&gt;蓝牙AOA、AOD定位技术&lt;/p&gt;
&lt;p&gt;传统蓝牙位置服务多是&lt;strong&gt;基于RSSI和三点定位&lt;/strong&gt;来实现的：(左图是3个接收器+1个发射器，通过3点定位来追踪tag的位置&amp;lt;实时定位&amp;gt;；右图是3个发射器+1个接收器，通过分析3个发射器信号来计算接收器的位置&amp;lt;室内定位&amp;gt;）&lt;/p&gt;
&lt;p&gt;传统的方法可用来提供米级别的定位方案，精度并不太高、且部署安装复杂，同时如果用来实现低成本蓝牙防丢器，则会出现找不到方向的尴尬。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/0a/c3e16d28318a857901792600520bf8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然蓝牙定位服务在当前功能的基础上取得了巨大的成功，但市场对能够提供更高性能的解决方案的需求仍然很大。例如，在一些RTLS部署中，系统必须提供精确到厘米级别的位置。幸运的是，蓝牙技术最近增加了一项成熟的功能，使定位服务解决方案的开发能够实现这些高级性能。&lt;/p&gt;
&lt;p&gt;在蓝牙核心规范的5.1版本中，蓝牙添加了方向测量功能。使用此新功能，&lt;strong&gt;蓝牙设备可以确定信号从另一台蓝牙设备传输的方向&lt;/strong&gt;。这种看似基本的能力显着增强蓝牙定位服务。如上所述，蓝牙位置服务当前正在使用RSSI来估计距离在两个设备之间，在RTLS和IPS解决方案的情况下，使用这些距离估计和三边测量以确定设备的位置。现在，通过两个固定设备和待测设备的方向夹角即可辅助目标设备的精确位置。&lt;/p&gt;
&lt;p&gt;蓝牙5.1规范中规定，蓝牙测向功能支持两种确定方向的方法蓝牙信号，&lt;strong&gt;两者都基于天线阵列的使用到 到达角（AoA）和出发角（AoD）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/6d/23dd2948484fa8cd26fe224b426b54.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AoA角度测量&lt;/strong&gt;：在RTLS解决方案中的标签，使用单天线发射机（信标）传输特殊的测向信号。接收设备，例如同一RTLS解决方案中的定位器，具有以阵列排列的多个天线（至少双天线）。当传输的信号穿过阵列时，接收由于与天线中的每个天线的距离不同，设备看到信号相位差阵列到发射天线。接收设备在切换时获取信号的IQ样本在阵列中的有源天线之间。基于IQ样本数据，接收设备可以计算相对信号方向。AoA测向方法适用于RTLS，项目查找和PoI信息定位服务解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AoD角度测量&lt;/strong&gt;：在IPS解决方案中的定位信标，使用安排在其中的多个天线发送特殊信号阵列。接收设备，例如同一IPS解决方案中的移动电话，只需要具有单个天线。当来自发送设备的多个信号穿过接收设备中的天线时，接收设备需要IQ样本。基于IQ样本数据，接收设备可以计算相对信号方向。 AoD测向方法适用于IPS解决方案，例如用于寻路，导航。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Profile(带方向查找的蓝牙配置文件)&lt;/strong&gt;：对于许多蓝牙功能，Spec会定义如何开发的profile实现该功能的可互操作的蓝牙产品。例如，蓝牙 耳机配置文件定义了如何使用蓝牙开发可互操作的音频耳机A2DP profile。 对于新的蓝牙测向功能也是如此。蓝牙5.1中新的针对AoA,AoD配置文件profile正处于最后阶段，预计很快就会发布。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt;&lt;strong&gt;6、展望&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到2021年，商业建筑中&lt;strong&gt;40%&lt;/strong&gt;的连接端点将采用智能照明。&lt;/p&gt;
&lt;p&gt;照明无处不在，通过将蓝牙集成进照明中，您可以创建一个蓝牙网络，使您可以超越照明进行思考，例如：室内定位、资产追踪和导航寻路等 ......&lt;/p&gt;
&lt;p&gt;: &lt;span&gt;&lt;strong&gt;前沿蓝牙应用：照明即平台，超越照明去思考照明！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;: &lt;span&gt;&lt;strong&gt;大家觉得不错，可以点推荐给更多人～&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bluetooth.com/~/media/files/marketing/laap_infographic.ashx?la=en&quot;&gt;[1]. 蓝牙官网：Light as a Platform&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.eeworld.com.cn/mp/BLE5CODER/a60561.jspx&quot;&gt;[2]. 蓝牙核心规范v5.1：剑指精确定位市场&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.eeworld.com.cn/mp/Dialog/a62539.jspx&quot;&gt;[3]. Dialog发布最强无线MCU：支持蓝牙5.1寻向功能，可实现厘米级定位！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.eeworld.com.cn/mp/Silicon-Labs/a61491.jspx&quot;&gt;[4]. 综览Bluetooth 5.1全新测向功能&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;file:///home/btfz/Downloads/1901_Enhancing%20Bluetooth%20Location%20Service_FINAL.pdf&quot;&gt;[5]. Enhancing Bluetooth Location Services with Direction Finding&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
以蓝牙技术为基础的的末梢无线网络系统架构及创新型应用探索！
领域：智能硬件、物联网、自动化、前沿软硬件
博客：https://www.cnblogs.com/zjutlitao/
园友交流群|微信交流群：414948975|园友交流群&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Mar 2019 17:39:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>  1、照明即平台(LAAP) 随着照明设施向LED转型，他们也在利用类似于蓝牙MESH的技术，创建一个可连接的照明平台，作为他们建筑的中枢神经系统。这些系统除了提供先进的照明控制，还建立了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/10604840.html</dc:identifier>
</item>
<item>
<title>分享几个实用的Chrome扩展程序 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/10604339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/10604339.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;吐槽一下自己，最近变懒了，博客已经变成月更了。这次分享几个自己工作这几年下来，平常用的比较多的几个谷歌浏览器的扩展程序。&lt;/p&gt;
&lt;h2&gt;AdBlock&lt;/h2&gt;
&lt;p&gt;最受欢迎的 Chrome 扩展，拥有超过 6000 万用户！拦截网页上的广告。&lt;/p&gt;
&lt;p&gt;这个插件在我看来是自己使用谷歌浏览器时必须安装的，能拦截掉网页上的各种乱七八糟的广告，也可以屏蔽掉搜索引擎根据你的喜好展示的推荐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190326220508185-1073793131.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190326221022681-1814988742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;title-for-login&quot;&gt;Restlet&lt;/h2&gt;
&lt;p&gt;一款能在浏览器里测试接口的工具。特别适合在测试一些内部接口时，还必须要在用户登录的情况下才能测试的情况。因为这个工具是完全在浏览器内部的所以可以共享浏览器的cookie等信息。与postman不同的是，postman是属于浏览器里的应用，浏览器应用是可以在关闭浏览器后独立使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190326221842462-1373216619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RestLet支持get、post、put、delete、head、options、patch等方法，支持以表单的形式测试接口，以及测试上传附件的接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190326222859921-2015155346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;FE助手：包括JSON格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown与HTML互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax接口调试、密码生成器、JSON比对工具、网页编码设置、便签笔记。&lt;/p&gt;
&lt;h3&gt;功能介绍：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190328003246082-77147945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190326223802538-820766124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了丰富的功能外，我还比较喜欢这个工具的一点是，只要装了这个工具，在浏览器请求一个get接口时，如果返回的是一个json数据，FeHelper会自动将json数据格式化。&lt;/p&gt;
&lt;h2&gt;MultiLogin&lt;/h2&gt;
&lt;p&gt;这是一款能打开多个独立隐身窗口的工具 ，在现在的互联网环境中，大多系统都是已经实现了单点登录了，即一处登录，处处登录，一处注销，处处注销。当在同一套系统中想要登录多个用户时，通常的情况是打开一个谷歌浏览器的隐身窗口，但是Chrome只支持打开一个独立环境的隐身窗口，如果同时打开多个隐身窗口，cookie等信息是共享的，也可以用360浏览器（360支持打开多个单独的隐身窗口），但是用360浏览器就需要再安装一个浏览器。&lt;/p&gt;
&lt;p&gt;MultiLogin这个插件就支持打开多个独立的隐身标签页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327221707191-586117540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和&lt;strong&gt;MultiLogin&lt;/strong&gt;类似插件还有&lt;strong&gt;SessionBox&lt;/strong&gt;，也是支持打开多个隐身标签页的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327222140501-1199881323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;SessionBox的概述：&lt;/h4&gt;
&lt;p class=&quot;C-b-p-j-Pb&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190328003601077-1762321647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; Clear Cache&lt;/h2&gt;
&lt;p&gt;通常对谷歌浏览器清除缓存，是在菜单栏中选择更多工具，选择清除浏览数据。或是按快捷键ctrl+alt+delete，进入清除浏览数据页面。但是通过clear cache工具设置好了要清除的缓存，点击一下按钮即可清除缓存和浏览数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327222854040-1900769604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327222923032-2101158012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;SimpleUndoClose&lt;/h2&gt;
&lt;p&gt;这个简单的工具可让您轻而易举的撤销关闭的标签！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327224727792-1177612381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327224643570-2102363980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;e-f-w&quot;&gt;Screencastify&lt;/h2&gt;
&lt;p&gt;这是一款可以录屏的Chrome插件，可以录浏览器，可以录桌面等。录制完成后可以上传到goole云盘。录制完成后自动打开一个标签页播放，也可以将录制的文件下载下来。文件后缀为.webm。可以直接将文件拖到Chrome里自动播放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327234813094-197062251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击RECORD开始录制。&lt;/p&gt;
&lt;h2&gt;掘金&lt;/h2&gt;
&lt;p&gt;程序员分享社区，这个插件可以让你在打开新标签页的时候默认看到的是，掘金收集的每天最新，最热的技术文章。以及各大社区的最新最热的文章或项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327232616095-157583891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; Extension Manager&lt;/h2&gt;
&lt;p&gt;一款Chrome插件/APP管理工具 ,装了太多的插件可以使用这个工具来进行管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327234404355-1763675435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Source Shell App&lt;/h2&gt;
&lt;p&gt;这是一款可以将Chrome当成SSH连接工具的浏览器应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327235402085-1254597948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;MyAdmin App&lt;/h2&gt;
&lt;p&gt;这是一款可以将浏览器窗口当成mysql数据库客户端的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201903/772743-20190327235949490-882256771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;最后推荐一下，我一直都装着的一个小工具，Start Today，这个Chrome插件可以让每次打开新的标签页时都是展示一个随机的背景图，图片的来源都是从unsplash上精心挑选出来的，每次打开都是不同风格的背景美图。如果大家不知道怎么下载Chrome插件的话，可以百度一下另一个插件SetupVPN，这个工具具体是干啥的，我就不多说了。&lt;/p&gt;
&lt;p&gt;最后的最后，这些扩展程序都是自己经常用到的，如果大家也有好用的Chrome插件也可以推荐给我。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201902/772743-20190225000117090-1961830280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章会同步到我的公众号上面，欢迎关注。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 16:43:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 吐槽一下自己，最近变懒了，博客已经变成月更了。这次分享几个自己工作这几年下来，平常用的比较多的几个谷歌浏览器的扩展程序。 AdBlock 最受欢迎的 Chrome 扩展，拥有超过 6000 万用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/10604339.html</dc:identifier>
</item>
<item>
<title>Frame Interpolation - TaigaComplex</title>
<link>http://www.cnblogs.com/TaigaCon/p/10612354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TaigaCon/p/10612354.html</guid>
<description>&lt;p&gt;对于视频网站、电视厂商以及进行视频压制的用户来说，改变视频的帧率算是一个比较常见的需求。视频网站改变帧率主要是为了向不同级别的网站用户提供差异化服务；电视厂商则是以提供更好的显示效果作为电视的卖点；对视频压制有所研究的用户会为了更好的显示效果而追求更高的帧率，或者为了更高的压缩率而选择更低的帧率。&lt;/p&gt;
&lt;p&gt;帧率的变化能分为两种：低帧率变为高帧率；高帧率变为低帧率。虽然两者出于不同的需求，但是采取的是同一实现方式。一般来说，视频中相邻的两帧之间有相同的时间间隔，例如帧率为24的视频的相邻两帧之间的间隔为1/24秒，帧率为60的视频的相邻两帧之间的间隔为1/60秒。如果要把帧率为24的视频转换为60的帧率，则需要通过位于0，1/24，2/24，…秒上的帧来构造出位于0，1/60，2/60，…秒的帧；如果要把帧率为24的视频转换为10的帧率，那么则需要构造分别位于0，1/10，2/10，…秒的帧。本质上说，提高帧率以及降低帧率同样都是构造出不存在于源视频上的帧，两者只存在构造的帧的数量上的差别。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190327234259014-1554669671.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190327234259546-506765385.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;321&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构造不存在的帧，我们称之为&lt;strong&gt;插帧&lt;/strong&gt;（Frame Interpolation），插帧有三种实现方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Duplication，复制相近的帧。&lt;/li&gt;
&lt;li&gt;Blend，用相邻的两帧进行混合。&lt;/li&gt;
&lt;li&gt;Motion Interpolation，结合图像运动来构造中间帧。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面对比了这三种不同的实现方式的插帧效果，把每秒15帧的视频插帧成每秒30帧：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001820788-303531483.gif&quot; alt=&quot;normal&quot; width=&quot;455&quot; height=&quot;768&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每秒播放1帧可以明显看出采用不同实现方法的时不同表现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001659296-2114693374.gif&quot;&gt;&lt;img title=&quot;slow&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001700262-376028095.gif&quot; alt=&quot;slow&quot; width=&quot;455&quot; height=&quot;768&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面分析三种不同实现方式的具体实现。&lt;/p&gt;



&lt;p&gt;输出的时间节点上的帧，就是我们需要生成的帧，此处称之为&lt;strong&gt;中间帧&lt;/strong&gt;。在生成当前的中间帧的过程中涉及到两个输入帧，分别为小于输出时间并且最接近该输出时间的输入帧（假设为第n帧），以及大于输出时间并且最接近该输出时间的输入帧（假设为第n+1帧），我们可以称它们为&lt;strong&gt;参考帧&lt;/strong&gt;。从这两个参考帧中选取时间上最接近中间帧输出时间的一帧，对这一帧进行复制，作为当前的中间帧进行输出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001701329-967871262.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001701665-1062034404.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;与前面Dup的讨论相同，中间帧也涉及到左右相邻的两个参考帧，不过blend的实现是把这两个参考帧按照一定方式进行混合。混合方式就是分别为两帧分配一个权重（或者称之为透明度，不透明时权重为1，完全透明时权重为0），两帧的各个像素在乘上各自的权重后进行相加，即可得到中间帧对应位置上的像素值。&lt;/p&gt;
&lt;p&gt;这两个权重应该满足两个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;两个权重应该为[0,1]区间上的数值，并且两者相加等于1。&lt;/li&gt;
&lt;li&gt;距离中间帧远的帧的透明度更高，即权重更小；距离中间帧帧近的帧的透明度更低，即权重更大。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此一来，利用中间帧与其左右相邻的参考帧在时间上的关系就能计算出这两个参考帧的权重。假设中间帧与参考帧之间在时间上有以下关系&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001702245-1543862580.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001702560-1673761291.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;156&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;左边的参考帧的权重应该为(L-α)/L，右边的参考帧的透明度应该为α/L。两个参考帧乘上各自的权重后相加即可得到中间帧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001702813-1870711980.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001703104-1495621544.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;一般来说，视频中相邻两帧的时间间隔很短，因此如果这两帧中的内容的变化较小（在场景切换的时候，或者说两帧中的内容变化较大时，直接复制前一帧进行输出即可），我们可以把两帧中内容的变化看作线性运动。如果能够求出该线性运动的运动轨迹，就能根据该运动轨迹以及输入输出帧的时间关系来进行内容位置的调整，这种实现方法被称为运动内插（Motion Interpolation）。这种利用物体的运动对视频进行插帧的方法会使得插帧后的视频显得更为流畅。&lt;/p&gt;
&lt;p&gt;当然，视频中的内容复杂，并不能单纯地认为一个运动的物体的所有部分都是朝一个方向做线性运动，但是如果把视频分成小块，那么就把运动的物体分解成了一块块运动的色块，对于这些色块，我们则可以认为它们是做线性运动的。（下图为各个16x16大小的块的运动向量）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001703598-1892481486.jpg&quot;&gt;&lt;img title=&quot;mv&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001704048-833275879.jpg&quot; alt=&quot;mv&quot; width=&quot;512&quot; height=&quot;288&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于我们此处认为这些小块是线性运动的，因此可以根据时间关系得到中间帧上的小块与参考帧的对应小块之间的运动关系（运动向量）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001704739-606248424.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001705116-717530164.png&quot; alt=&quot;image&quot; width=&quot;150&quot; height=&quot;111&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过运动向量可以定位到参考帧的两个参考块，以及中间帧上所需要生成的块的位置，然后就采用类似于上述blend的方法对块进行合成。当把帧内的所有块都执行完合成操作后，就能得到所需的运动内插的帧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001705386-1128417356.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001705667-73961591.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;431&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;运动向量搜索&lt;/h4&gt;
&lt;p&gt;按照前面的描述，在构造中间帧之前，必须先求出两个参考帧之间各个块的运动向量，这需要把一个参考帧作为「当前帧」，另一个参考帧作为「参考帧」。参考上图，在求运动向量时，我们把序号为n的帧当作「当前帧」，把序号为n+1的帧当作「参考帧」。&lt;/p&gt;
&lt;p&gt;运动向量搜索就是把「当前帧」分割成小块，并顺次从「参考帧」中搜寻各个小块的最优匹配块，这与视频编码时的运动向量搜索是基本一致的，在搜索时可以选择各种各样的搜索算法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001706118-1543745963.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001706412-1673033222.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此外还有一种运动向量搜索方案，该方案以中间帧为基准，把中间帧分割成小块，顺次地把这些小块当作「当前块」进行运动向量搜索。这种搜索方案要求：对「当前块」求的所有运动向量都需要通过「当前块」，即以「当前块」为中心。具体是把「当前块」作为中心点(0,0)，如果运动向量为(x, y)，那么「当前帧」上的块的相对位置为(-xα/L, -yα/L)，「参考帧」上的块的相对位置为(x(L-α)/L, -y(L-α)/L)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001706654-401031811.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001706975-1500981146.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;173&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种方案在计算运动向量上会增加额外的消耗，为了减少这种消耗，在实际实现的时候可能会假设中间帧位于两个参考帧的正中间，并以此去求运动向量，求得的运动向量会被当作穿过实际中间帧上的「当前块」的运动向量，该运动向量在进行运动补偿时会按照中间帧的实际位置分割运动向量。如下图，可见「当前帧」（n）中的块与「参考帧」（n+1）中的块都存在了一定程度的偏移，即进行运动向量搜索时采用的两个块并非后续进行运动补偿的两个块，这需要我们采取一些补救措施。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001707468-1433159720.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001707763-1071855761.png&quot; alt=&quot;image&quot; width=&quot;200&quot; height=&quot;210&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;运动补偿&lt;/h4&gt;
&lt;p&gt;我们把通过运动向量来得到源块并生成目标块的这一过程称为运动补偿（motion compensation）。根据上方两种不同的运动向量搜索方式，分别有两种不同的运动补偿方案。&lt;/p&gt;
&lt;p&gt;如果采用上述第一种运动向量搜索方案，在运动补偿时时，会以这两个参考帧以及中间帧之间的时间关系来对运动向量进行分割，分割点就是插帧生成的块的位置，如下图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001708169-1808094560.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001708561-1351214852.png&quot; alt=&quot;image&quot; width=&quot;300&quot; height=&quot;165&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果采用上述第二种运动向量搜索方案，在运动补偿时，是中间帧上的各个块就是插帧生成的块的位置，如下图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001708887-1767183858.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001709128-811994717.png&quot; alt=&quot;image&quot; width=&quot;310&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对比两个中不同方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在进行运动向量搜索时，方案一相对于方案二节省了运动向量的计算的消耗。&lt;/li&gt;
&lt;li&gt;在进行运动补偿时方案一无法保证完全填充中间帧，因此总会出现未填充区域，而方案二则可以完全覆盖整个中间帧。&lt;/li&gt;
&lt;li&gt;方案一如果为了节省运动向量搜索时的消耗而采取我们前面所说的优化处理，则会导致执行运动补偿的块并非运动向量搜索时得到的块。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了提高方案二对中间帧的覆盖率，以及提高方案一中运动向量搜索所得的块与运动补偿的块之间的相关性，我们在保持块位置不变的情况下把块的宽高提升为两倍。例如，原本各个块的大小为16x16，原本各个块的位置位于(0, 0), (0, 16), (0, 32),…,(16, 0), (16, 16), (16, 32), … 提升后的各个块的大小为32x32，即在运动向量搜索以及运动补偿的时候块的大小都是32x32，但是各个块的位置不变。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001709543-1454348864.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201903/421096-20190328001709892-825300356.png&quot; alt=&quot;image&quot; width=&quot;630&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此时无论是方案一还是方案二，在执行运动补偿的时候都会出现生成的块之间相互覆盖的情况，但是这并非我们需要的效果，我们可以为一个块中的各个像素分配一个权重，在进行运动补偿的时候就可以按照这个权重对相互覆盖的块的像素进行混合。通常为了更好的显示效果，混合的像素应该平滑地过渡，因此越靠近块的边缘的像素应该权重更小，越靠近块的中心的像素的权重更大。&lt;/p&gt;
&lt;p&gt;最后，对于方案一，即使提高了中间帧的覆盖率，但是还是很有可能出现无法覆盖的区域，对于这种区域，只能用两个参考帧的对应位置上的像素来进行混合。&lt;/p&gt;

&lt;h4&gt;其它优化措施&lt;/h4&gt;
&lt;p&gt;对于方案一，上面的描述只采用了单向运动预测，采用双向运动预测可以有更高的中间帧覆盖率，在实现的时候只需要把序号为n+1帧作为「当前帧」，序号为n的帧作为「参考帧」。&lt;/p&gt;
&lt;p&gt;对于方案二，在运动补偿的时候由于各个块之间的重叠区域是固定的，因此我们可以去比较重叠区域之间的cost来调整重叠区域的权重。&lt;/p&gt;
&lt;p&gt;为了进行更精确的运动补偿，我们可以对运动向量进行分类。我们把相差不大的运动向量的块归为一类，把一类看作一个内容，如果相邻的块的运动向量相差较大，则表明相邻块并非位于同一个内容之中，而是处于两个内容之间的边界，对于这种情况，可以采用更小的块来进行小范围的搜索，以求得更准确的运动向量，从而在运动补偿的时候也能生成更准确的块。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 16:17:00 +0000</pubDate>
<dc:creator>TaigaComplex</dc:creator>
<og:description>对于视频网站、电视厂商以及进行视频压制的用户来说，改变视频的帧率算是一个比较常见的需求。视频网站改变帧率主要是为了向不同级别的网站用户提供差异化服务；电视厂商则是以提供更好的显示效果作为电视的卖点；对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TaigaCon/p/10612354.html</dc:identifier>
</item>
<item>
<title>《用OpenResty搭建高性能服务端》笔记 - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/10589295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/10589295.html</guid>
<description>&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《用OpenResty搭建高性能服务端》是&lt;code&gt;OpenResty&lt;/code&gt;系列课程中的入门课程，主讲人：温铭老师。课程分为10个章节，侧重于&lt;code&gt;OpenResty&lt;/code&gt;的基本概念和主要特点的介绍，包括它的指令、&lt;code&gt;nginx_lua&lt;/code&gt; API、缓存、如何连接数据库、执行阶段等，并通过几个实际的操作和代码片段，告诉大家学习中如何搭建开发、测试环境，如何调试、查找和解决问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;视频播放地址：&lt;a href=&quot;https://study.163.com/course/introduction.htm?courseId=1520005&quot; class=&quot;uri&quot;&gt;https://study.163.com/course/introduction.htm?courseId=1520005&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;课程目录一览：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324174234072-1458046891.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人评价：评分满分。内容由浅入深，思路清晰，内容组织有序，容易上手，为初学者打开了一扇学习的大门。非常不错的分享。学完后需再配合 &lt;a href=&quot;https://github.com/moonbingbing/openresty-best-practices&quot;&gt;《OpenResty最佳实践》&lt;/a&gt; + &lt;a href=&quot;https://github.com/openresty/lua-nginx-module#version&quot;&gt;官方文档&lt;/a&gt; 进行系统学习。&lt;/p&gt;
&lt;p&gt;下面是学习笔记，内容主要是以老师的讲解为主，加上部分自己补充或理解的内容。&lt;/p&gt;
&lt;p&gt;本文环境：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ uname -a
Linux ba2f3eedf7df 4.4.111-boot2docker #1 SMP Thu Jan 11 16:25:31 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux

$ cat /etc/redhat-release 
CentOS release 6.8 (Final)

$ /usr/local/openresty/bin/openresty -v
nginx version: openresty/1.13.6.2

$ /usr/local/openresty/luajit/bin/luajit -v
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2017 Mike Pall. http://luajit.org/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;openresty-简介&quot;&gt;OpenResty 简介&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;OpenResty®&lt;/code&gt; 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenResty 基于&lt;code&gt;Nginx&lt;/code&gt;开发，可以简单认为是 &lt;code&gt;Nginx&lt;/code&gt; + &lt;code&gt;lua-nginx-module&lt;/code&gt;的组合版。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://openresty.org/cn/&quot; class=&quot;uri&quot;&gt;https://openresty.org/cn/&lt;/a&gt;&lt;br/&gt;官方文档：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#version&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module#version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高性能服务端两个重要要素：需要支持缓存，语言层面要支持异步非堵塞。&lt;/p&gt;
&lt;p&gt;缓存速度上，内存 &amp;gt; SSD &amp;gt; 机械磁盘；本机 &amp;gt; 网络 ； 进程内 &amp;gt; 进程间 。异步非阻塞指的是事件驱动方式（事件完成后再通知）。&lt;/p&gt;
&lt;p&gt;OpenResty 包含的技术：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Nginx：不仅仅是负载均衡+反向代理等功能，Nginx c module开发成本高。&lt;/li&gt;
&lt;li&gt;LuaJIT：OpenResty用的是 LuaJIT，LuaJIT 是主打性能的Lua。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;OpenResty&lt;/code&gt; 本质上是将 &lt;code&gt;LuaJIT&lt;/code&gt; 的虚拟机嵌入到 Nginx的worker中，所以效率特别高，在性能上，&lt;code&gt;OpenResty&lt;/code&gt; 接近或超过 Nginx c module：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324163450095-741619710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OpenResty已经颠覆了高性能服务端的开发模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OpenResty&lt;/code&gt;与市面上其他语言对比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;node.js：第一门将异步非阻塞特性放入自己语言中的，前端同学可以快速切入。但是 node.js 用回调(callback)实现异步非阻塞，代码写起来比较麻烦。&lt;/li&gt;
&lt;li&gt;Python：3.4之后加入了异步的支持，比如异步io和aiohttp；3.5引入了协程。缺点是版本跨度大，因为很多人还是使用2.7。&lt;/li&gt;
&lt;li&gt;Golang：最近几年非常火。缺点：代码写法上需要使用go关键字；线上热调试不方便（&lt;code&gt;SystemTap&lt;/code&gt; 提供了有限的支持）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;h3 id=&quot;openresty安装&quot;&gt;OpenResty安装&lt;/h3&gt;
&lt;p&gt;以 CentOS 为例：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir /opt &amp;amp;&amp;amp; cd /opt

# download openresty
wget https://openresty.org/download/openresty-1.13.6.2.tar.gz

tar zxvf openresty-1.13.6.2.tar.gz
cd openresty-1.13.6.2

# configure
./configure --prefix=/usr/local/openresty -j4

make -j4 &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 源码包可以到 &lt;a href=&quot;https://openresty.org/cn/download.html&quot; class=&quot;uri&quot;&gt;https://openresty.org/cn/download.html&lt;/a&gt; 该页面获取。&lt;br/&gt;&lt;code&gt;-j4&lt;/code&gt;表示使用4核。&lt;code&gt;configure&lt;/code&gt;那一步还可以指定各种参数：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;./configure --prefix=/usr/local/openresty \
            --with-luajit \
            --without-http_redis2_module \
            --with-http_iconv_module \
            --with-http_postgres_module&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;./configure --help&lt;/code&gt; 查看更多的选项。&lt;/p&gt;
&lt;p&gt;其它系统环境上安装可以参考 &lt;a href=&quot;https://openresty.org/cn/installation.html&quot; class=&quot;uri&quot;&gt;https://openresty.org/cn/installation.html&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;其实安装 OpenResty 和安装 Nginx 是类似的，因为 OpenResty 是基于 Nginx 开发的。&lt;/p&gt;
&lt;p&gt;如果已经安装了 Nginx，又想使用 OpenResty 的功能，可以参考 《Nginx编译安装Lua》：&lt;a href=&quot;https://www.cnblogs.com/52fhy/p/10164553.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/52fhy/p/10164553.html&lt;/a&gt; 一文安装&lt;code&gt;lua-nginx-module&lt;/code&gt;模块即可。&lt;/p&gt;
&lt;h3 id=&quot;第一个程序&quot;&gt;第一个程序&lt;/h3&gt;
&lt;p&gt;修改 &lt;code&gt;/usr/local/openresty/nginx/conf/nginx.conf&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;worker_processes  1;
error_log logs/error.log;
events {
    worker_connections 1024;
}
http {
    server {
        listen 8080;
        location /hello {
            default_type text/html;
            content_by_lua '
                ngx.say(&quot;&amp;lt;p&amp;gt;hello, world&amp;lt;/p&amp;gt;&quot;)
            ';
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把默认的&lt;code&gt;80&lt;/code&gt;端口改为&lt;code&gt;8080&lt;/code&gt;，新增&lt;code&gt;/hello&lt;/code&gt;部分。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;content_by_lua&lt;/code&gt;便是 OpenResty 提供的指令，在官方文档可以搜索到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324174956312-276962073.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们启动OpenResty：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;/usr/local/openresty/nginx/sbin/nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后，查看效果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://127.0.0.1:8080/hello
&amp;lt;p&amp;gt;hello, world&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明成功运行了。&lt;/p&gt;
&lt;p&gt;知识点：&lt;br/&gt;1、&lt;code&gt;content_by_lua&lt;/code&gt;：返回的内容使用 lua 代码。&lt;br/&gt;2、&lt;code&gt;content_by_lua_file&lt;/code&gt;：读取lua文件里的 lua 代码。&lt;br/&gt;3、默认情况下，修改Lua代码，需要 reload OpenResty服务才会生效。可以修改&lt;code&gt;lua_code_cache&lt;/code&gt;为&lt;code&gt;off&lt;/code&gt;，作用域： http, server, location, location if。请勿在生产环境里开启。&lt;/p&gt;
&lt;p&gt;测试1：使用&lt;code&gt;content_by_lua_file&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd /usr/local/openresty
mkdir nginx/conf/lua
vim nginx/conf/lua/hello.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容为：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;ngx.say(&quot;&amp;lt;p&amp;gt;hello, lua world&amp;lt;/p&amp;gt;&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改 nginx.conf：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /hello {
    default_type text/html;
    content_by_lua_file conf/lua/hello.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启 OpenResty：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./nginx/sbin/nginx -s reload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后，查看效果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ curl http://127.0.0.1:8080/hello
&amp;lt;p&amp;gt;hello, lua world&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试2：关闭&lt;code&gt;lua_code_cache&lt;/code&gt;：&lt;br/&gt;根据&lt;code&gt;lua_code_cache&lt;/code&gt;作用域，我们可以在server块加上：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;lua_code_cache off;
location /hello {
    default_type text/html;
    content_by_lua_file conf/lua/hello.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重启：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./nginx/sbin/nginx -s reload
nginx: [alert] lua_code_cache is off; this will hurt performance in /usr/local/openresty/nginx/conf/nginx.conf:43&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示说&lt;code&gt;lua_code_cache&lt;/code&gt;关闭后影响性能。我们再次修改 &lt;code&gt;nginx/conf/lua/hello.lua&lt;/code&gt;的代码，保存后就会生效，无需 reload server。&lt;/p&gt;
&lt;h2 id=&quot;openresty-入门&quot;&gt;OpenResty 入门&lt;/h2&gt;
&lt;p&gt;这节使用 ngx_lua api完成一个小功能。&lt;/p&gt;
&lt;p&gt;lua代码：&lt;br/&gt;nginx/conf/lua/get_random_string.lua&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- 实现随机字符串

local args = ngx.req.get_uri_args()
local salt = args.salt

if not salt then
        ngx.exit(ngx.HTTP_BAD_REQUEST)
end

local str = ngx.md5(ngx.time() .. salt)
ngx.say(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 nginx.conf ，新增：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /get_random_string {
    content_by_lua_file conf/lua/get_random_string.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于修改了 nginx.conf ，需要reload OpenResty 服务。然后，我们访问服务：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ curl http://127.0.0.1:8080/get_random_string?salt=2
2d8231ff301ab0ce8b95c7e4c2c59574

$ curl http://127.0.0.1:8080/get_random_string?salt=2
c145db4ec45a6bf792ac30ed4246c563&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;br/&gt;1、&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args&quot;&gt;&lt;code&gt;ngx.req.get_uri_args()&lt;/code&gt;&lt;/a&gt;用于获取URI请求参数。&lt;br/&gt;2、&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#http-status-constants&quot;&gt;&lt;code&gt;ngx.HTTP_BAD_REQUEST&lt;/code&gt;&lt;/a&gt;为ngx常量，指的是400。代码里尽量使用常量。&lt;br/&gt;3、&lt;code&gt;ngx.time()&lt;/code&gt;用于获取时间戳，是带有缓存的。与Lua的日期库不同，不涉及系统调用。尽量使用Ngx给出的方法，以免发生性能问题。&lt;br/&gt;4、&lt;code&gt;ngx.md5()&lt;/code&gt;用于生成md5值。&lt;br/&gt;5、如果代码里有语法错误，我们可以通过nginx 的 error.log里看到，默认文件是 &lt;code&gt;nginx/logs/error.log&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7.0027100271003&quot;&gt;
&lt;p&gt;再次提醒大家，做 OpenResty 开发，&lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot;&gt;lua-nginx-module&lt;/a&gt; 的文档是你的首选，Lua 语言的库都是同步阻塞的，用的时候要三思。也就是说，尽量使用 ngx_lua提供的api，而不是使用 Lua 本身的。例如&lt;code&gt;ngx.sleep()&lt;/code&gt;与 lua提供的sleep，前者不会造成阻塞，后者是会阻塞的，详见：&lt;a href=&quot;https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/sleep.html&quot;&gt;sleep · OpenResty最佳实践&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ngx_lua-api介绍&quot;&gt;ngx_lua API介绍&lt;/h2&gt;
&lt;p&gt;本节主要是带着大家简单的过一下常用的ngx_lua API。&lt;/p&gt;
&lt;p&gt;ngx_lua 有60多个&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#directives&quot;&gt;指令&lt;/a&gt;(Directive)，140多个 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module#nginx-api-for-lua&quot;&gt;API&lt;/a&gt;（截止到2019-3-26）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt; 是 ngx_lua 提供给Nginx调用的方法，与 Nginx自带的 &lt;code&gt;location&lt;/code&gt;、&lt;code&gt;rewrite&lt;/code&gt;等是一个级别的。指令有自己的作用域，例如：&lt;code&gt;content_by_lua_file&lt;/code&gt;只能作用于&lt;code&gt;location&lt;/code&gt;和&lt;code&gt;location if&lt;/code&gt;里面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324220148794-827351512.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt; 是指ngx_lua基于lua代码实现的一系列方法或常量，遵循 lua的语法规则。只能在lua代码块或者lua文件里使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;content_by_lua '
    ngx.say(&quot;&amp;lt;p&amp;gt;hello, world&amp;lt;/p&amp;gt;&quot;)
';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;content_by_lua&lt;/code&gt;是指令，作用于&lt;code&gt;location&lt;/code&gt;块；&lt;code&gt;ngx.say()&lt;/code&gt;是 ngx_lua 提供的API。&lt;/p&gt;
&lt;p&gt;在官方文档上可以找到指令及API所在的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324215129886-1346170000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，我们使用 ngx_lua完成另外一个小功能：实现base64的解码并重新json编码输出。代码里会用到一些指令和API。&lt;/p&gt;
&lt;p&gt;lua代码：&lt;br/&gt;nginx/conf/lua/decode_info.lua&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- 实现base64的解码并重新json编码输出

local json = require &quot;cjson&quot;

ngx.req.read_body()
local args = ngx.req.get_post_args()

if not args or not args.info then
        ngx.exit(ngx.HTTP_BAD_REQUEST)
end

local client_ip = ngx.var.remote_var or '127.0.0.1'
local user_agnet = ngx.req.get_headers()['user_agent'] or ''
local info = ngx.decode_base64(args.info)

local res = {}
res.client_ip = client_ip
res.user_agnet = user_agnet
res.info = info

ngx.say(json.encode(res))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 nginx.conf ，新增：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /decode_info {
    content_by_lua_file conf/lua/decode_info.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于修改了 nginx.conf ，需要 reload OpenResty 服务。然后，我们访问服务：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ php -r &quot;echo base64_encode('test');&quot;
dGVzdA==
$ curl -XPOST -d &quot;info=dGVzdA==&quot; http://127.0.0.1:8080/decode_info
{&quot;user_agnet&quot;:&quot;curl\/7.19.7&quot;,&quot;client_ip&quot;:&quot;127.0.0.1&quot;,&quot;info&quot;:&quot;test&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;br/&gt;1、&lt;code&gt;require&lt;/code&gt;是 lua 里面引入其他库的关键字。这里引入的 &lt;a href=&quot;https://www.kyne.com.au/~mark/software/lua-cjson.php&quot;&gt;cjson&lt;/a&gt;。&lt;br/&gt;2、当我们要读取 http里的post数据的时候，就需要使用&lt;code&gt;ngx.req.read_body()&lt;/code&gt;。该API同步读取客户端请求主体而不阻塞Nginx事件循环。&lt;br/&gt;3、&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxreqget_post_args&quot;&gt;&lt;code&gt;ngx.req.get_post_args()&lt;/code&gt;&lt;/a&gt; 用于获取post请求数据。&lt;br/&gt;4、&lt;code&gt;ngx.var.remote_var&lt;/code&gt;实际是获取的nginx里的变量&lt;code&gt;remote_var&lt;/code&gt;。也就是说，&lt;code&gt;ngx.var.xxx&lt;/code&gt;实际是获取的nginx里的变量&lt;code&gt;xxx&lt;/code&gt;。例如：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324223518128-1754668914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nginx变量详见：[Alphabetical index of variables}(&lt;a href=&quot;http://nginx.org/en/docs/varindex.html&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/varindex.html&lt;/a&gt;)。 ngx_lua &lt;code&gt;ngx.var&lt;/code&gt; API详见：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxvarvariable&quot;&gt;ngx.var.VARIABLE&lt;/a&gt;。&lt;br/&gt;5、&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxreqget_headers&quot;&gt;&lt;code&gt;ngx.req.get_headers()&lt;/code&gt;&lt;/a&gt; 用于读取nginx的header参数。返回的是lua table。&lt;br/&gt;6、&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxdecode_base64&quot;&gt;&lt;code&gt;ngx.decode_base64()&lt;/code&gt;&lt;/a&gt;用于 base64字符串解码。对应的编码API是 &lt;code&gt;ngx.encode_base64()&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;防盗版声明&lt;/strong&gt;：本文系原创文章，发布于公众号&lt;code&gt;飞鸿影的博客&lt;/code&gt;(fhyblog)及&lt;a href=&quot;http://52fhy.cnblogs.com&quot;&gt;博客园&lt;/a&gt;，转载需作者同意。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h2&gt;
&lt;p&gt;连接数据库我们需要使用到ngx_lua的第三方库：&lt;/p&gt;
&lt;p&gt;这两个库都是基于cosocket实现的，特点是异步非阻塞。代码风格是同步的写法。更多第三方库详见：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#see-also&quot;&gt;See Also&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;连接-mysql&quot;&gt;连接 MySQL&lt;/h3&gt;
&lt;p&gt;lua代码：&lt;br/&gt;nginx/conf/lua/test_mysql.lua&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local mysql = require &quot;resty.mysql&quot;

local db, err = mysql:new()
if not db then
    ngx.say(&quot;failed to instantiate mysql: &quot;, err)
    return
end

db:set_timeout(1000) -- 1 sec

local ok, err, errcode, sqlstate = db:connect{
    host = &quot;127.0.0.1&quot;,
    port = 3306,
    database = &quot;ngx_test&quot;,
    user = &quot;ngx_test&quot;,
    password = &quot;ngx_test&quot;,
    charset = &quot;utf8&quot;,
    max_packet_size = 1024 * 1024,
}

if not ok then
    ngx.say(&quot;failed to connect: &quot;, err, &quot;: &quot;, errcode, &quot; &quot;, sqlstate)
    return
end

-- insert 
res, err, errcode, sqlstate =
    db:query(&quot;insert into cats (name) &quot;
             .. &quot;values (\'Bob\'),(\'\'),(null)&quot;)
if not res then
    ngx.say(&quot;bad result: &quot;, err, &quot;: &quot;, errcode, &quot;: &quot;, sqlstate, &quot;.&quot;)
    return
end

ngx.say(res.affected_rows, &quot; rows inserted into table cats &quot;,
        &quot;(last insert id: &quot;, res.insert_id, &quot;)&quot;)

-- run a select query, expected about 10 rows in the result set
res, err, errcode, sqlstate =
    db:query(&quot;select * from cats order by id asc&quot;, 10)
if not res then
    ngx.say(&quot;bad result: &quot;, err, &quot;: &quot;, errcode, &quot;: &quot;, sqlstate, &quot;.&quot;)
    return
end

local cjson = require &quot;cjson&quot;
ngx.say(&quot;result: &quot;, cjson.encode(res))

-- close connection
local ok, err = db:close()
if not ok then
     ngx.say(&quot;failed to close: &quot;, err)
     return
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 nginx.conf ，新增：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /test_mysql {
    content_by_lua_file conf/lua/test_mysql.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于修改了 nginx.conf ，需要 reload OpenResty 服务。然后，我们访问服务：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ http://127.0.0.1:8080/test_mysql &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连接-redis&quot;&gt;连接 Redis&lt;/h3&gt;
&lt;p&gt;lua代码：&lt;br/&gt;nginx/conf/lua/test_redis.lua&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local redis = require &quot;resty.redis&quot;

local red = redis:new()
red:set_timeout(1000) -- 1 sec

local ok, err = red:connect(&quot;127.0.0.1&quot;, 6379)
if not ok then
    ngx.say(&quot;failed to connect: &quot;, err)
    return
end

ok, err = red:set(&quot;dog&quot;, &quot;an animal&quot;)
if not ok then
    ngx.say(&quot;failed to set dog: &quot;, err)
    return
end

ngx.say(&quot;set result: &quot;, ok)

local res, err = red:get(&quot;dog&quot;)
if not res then
    ngx.say(&quot;failed to get dog: &quot;, err)
    return
end

if res == ngx.null then
    ngx.say(&quot;dog not found.&quot;)
    return
end

ngx.say(&quot;dog: &quot;, res)

-- close the connection right away
local ok, err = red:close()
if not ok then
     ngx.say(&quot;failed to close: &quot;, err)
     return
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 nginx.conf ，新增：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;location /test_redis {
    content_by_lua_file conf/lua/test_redis.lua;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于修改了 nginx.conf ，需要 reload OpenResty 服务。然后，我们访问服务：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ http://127.0.0.1:8080/test_redis &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多参考：&lt;br/&gt;&lt;a href=&quot;https://moonbingbing.gitbooks.io/openresty-best-practices/content/redis/out_package.html&quot;&gt;redis 接口的二次封装（简化建连、拆连等细节） · OpenResty最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;openresty-缓存&quot;&gt;OpenResty 缓存&lt;/h2&gt;
&lt;h3 id=&quot;使用-lua-shared-dict&quot;&gt;使用 Lua shared dict&lt;/h3&gt;
&lt;p&gt;使用的话首先需要在 nginx.conf 加上一句：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;lua_shared_dict my_cache 128m;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;my_cache&lt;/code&gt;就是申请 Lua shared dict 缓存， 下面示例里会用到。&lt;/p&gt;
&lt;p&gt;这个缓存是 Nginx 所有 worker 之间共享的，内部使用的 LRU 算法（最近最少使用）来判断缓存是否在内存占满时被清除。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function get_from_cache(key)
    local cache_ngx = ngx.shared.my_cache
    local value = cache_ngx:get(key)
    return value
end

function set_to_cache(key, value, exptime)
    if not exptime then
        exptime = 0
    end

    local cache_ngx = ngx.shared.my_cache
    local succ, err, forcible = cache_ngx:set(key, value, exptime)
    return succ
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多支持的命令详见：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxshareddict&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module#ngxshareddict&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;使用-lua-lru-cache&quot;&gt;使用 Lua LRU cache&lt;/h3&gt;
&lt;p&gt;这个 cache 是 worker 级别的，不会在 Nginx wokers 之间共享。并且，它是预先分配好 key 的数量，而 shared dict 需要自己用 key 和 value 的大小和数量，来估算需要把内存设置为多少。&lt;/p&gt;
&lt;p&gt;官方示例：&lt;br/&gt;myapp.lua&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local _M = {}

-- alternatively: local lrucache = require &quot;resty.lrucache.pureffi&quot;
local lrucache = require &quot;resty.lrucache&quot;

-- we need to initialize the cache on the lua module level so that
-- it can be shared by all the requests served by each nginx worker process:
local c, err = lrucache.new(200)  -- allow up to 200 items in the cache
if not c then
    return error(&quot;failed to create the cache: &quot; .. (err or &quot;unknown&quot;))
end

function _M.go()
    c:set(&quot;dog&quot;, 32)
    c:set(&quot;cat&quot;, 56)
    ngx.say(&quot;dog: &quot;, c:get(&quot;dog&quot;))
    ngx.say(&quot;cat: &quot;, c:get(&quot;cat&quot;))

    c:set(&quot;dog&quot;, { age = 10 }, 0.1)  -- expire in 0.1 sec
    c:delete(&quot;dog&quot;)

    c:flush_all()  -- flush all the cached data
end

return _M&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx.conf&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;
http {
    lua_package_path &quot;/path/to/lua-resty-lrucache/lib/?.lua;;&quot;;

    server {
        listen 8080;

        location = /t {
            content_by_lua '
                require(&quot;myapp&quot;).go()
            ';
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多支持的命令详见：&lt;a href=&quot;https://github.com/openresty/lua-resty-lrucache&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-resty-lrucache&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;那么这两个缓存 &lt;a href=&quot;https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/cache.html&quot;&gt;如何选择&lt;/a&gt; ？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;shared.dict&lt;/code&gt; 使用的是共享内存，每次操作都是全局锁，如果高并发环境，不同 worker 之间容易引起竞争。所以单个 &lt;code&gt;shared.dict&lt;/code&gt; 的体积不能过大。&lt;code&gt;lrucache&lt;/code&gt; 是 worker 内使用的，由于 Nginx 是单进程方式存在，所以永远不会触发锁，效率上有优势，并且没有 &lt;code&gt;shared.dict&lt;/code&gt; 的体积限制，内存上也更弹性，但不同 worker 之间数据不同享，同一缓存数据可能被冗余存储。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;你需要考虑的，一个是 &lt;code&gt;Lua lru cache&lt;/code&gt; 提供的 API 比较少，现在只有 get、set 和 delete，而 &lt;code&gt;ngx shared dict&lt;/code&gt; 还可以 &lt;code&gt;add&lt;/code&gt;、&lt;code&gt;replace&lt;/code&gt;、&lt;code&gt;incr&lt;/code&gt;、&lt;code&gt;get_stale&lt;/code&gt;（在 key 过期时也可以返回之前的值）、&lt;code&gt;get_keys&lt;/code&gt;（获取所有 key，虽然不推荐，但说不定你的业务需要呢）；第二个是内存的占用，由于 &lt;code&gt;ngx shared dict&lt;/code&gt; 是 workers 之间共享的，所以在多 worker 的情况下，内存占用比较少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节内容参考来自：&lt;a href=&quot;https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/cache.html&quot; class=&quot;uri&quot;&gt;https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/cache.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ffi和第三方模块&quot;&gt;FFI和第三方模块&lt;/h2&gt;
&lt;h3 id=&quot;ffi&quot;&gt;FFI&lt;/h3&gt;
&lt;p&gt;FFI是 &lt;code&gt;LuaJIT&lt;/code&gt; 中的一个扩展库，它允许我们使用 Lua 代码调用C语言的数据结构和函数。&lt;/p&gt;
&lt;p&gt;FFI库在很大程度上避免了在C中编写繁琐的手动 &lt;code&gt;Lua/C&lt;/code&gt; 绑定的需要。无需学习单独的绑定语言 - 它解析普通的C声明！这些可以从C头文件或参考手册中剪切粘贴。&lt;/p&gt;
&lt;p&gt;如何调用外部C库函数呢？&lt;br/&gt;1、加载FFI库。&lt;br/&gt;2、为函数添加C声明。&lt;br/&gt;3、调用命名的C函数。&lt;/p&gt;
&lt;p&gt;看一个官方提供的简单示例：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- test_ffi.lua

local ffi = require(&quot;ffi&quot;)
ffi.cdef[[
int printf(const char *fmt, ...);
]]
ffi.C.printf(&quot;Hello %s!&quot;, &quot;world&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ luajit test_ffi.lua
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详见：&lt;a href=&quot;http://luajit.org/ext_ffi.html&quot; class=&quot;uri&quot;&gt;http://luajit.org/ext_ffi.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;增加第三方模块&quot;&gt;增加第三方模块&lt;/h3&gt;
&lt;p&gt;默认的 resty 库所在位置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pwd
/usr/local/openresty
$ ls lualib/
cjson.so  ngx/      rds/      redis/    resty/    
$ ls lualib/resty/
aes.lua   limit/         md5.lua        redis.lua   sha384.lua  upload.lua
core/      lock.lua      memcached.lua  sha1.lua    sha512.lua  upstream/
core.lua  lrucache/      mysql.lua      sha224.lua  sha.lua     websocket/
dns/       lrucache.lua  random.lua     sha256.lua  string.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在以安装 &lt;a href=&quot;https://github.com/ledgetech/lua-resty-http&quot;&gt;&lt;code&gt;lua-resty-http&lt;/code&gt;&lt;/a&gt; 为例：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd /opt

# 下载并解压
$  wget https://github.com/ledgetech/lua-resty-http/archive/v0.13.tar.gz &amp;amp;&amp;amp; tar zxvf v0.13.tar.gz 

# 复制到resty目录即可
$ cp -r lua-resty-http-0.13/lib/resty/* /usr/local/openresty/lualib/resty/

# 查看安装的模块
$ cd /usr/local/openresty/lualib/resty/ &amp;amp;&amp;amp; ls http*
http_headers.lua  http.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local http = require &quot;resty.http&quot;
local httpc = http.new()

local res, err = httpc:request_uri(&quot;http://example.com/helloworld&quot;, {
    method = &quot;POST&quot;,
    body = &quot;a=1&amp;amp;b=2&quot;,
    headers = {
      [&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;,
    },
    keepalive_timeout = 60,
    keepalive_pool = 10
})

if not res then
    ngx.say(&quot;failed to request: &quot;, err)
    return
end

ngx.status = res.status

for k,v in pairs(res.headers) do
  --
end

ngx.say(res.body)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;子查询&quot;&gt;子查询&lt;/h2&gt;
&lt;p&gt;子查询只是模拟 HTTP 接口的形式， 没有 额外的 HTTP/TCP 流量，也 没有 IPC (进程间通信) 调用。所有工作在内部高效地在 C 语言级别完成。&lt;/p&gt;
&lt;p&gt;子查询只能在一个 &lt;code&gt;location&lt;/code&gt; 里调用其它 一个或多个 `location。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;res = ngx.location.capture(uri, options?)&lt;/code&gt; 发起子查询&lt;br/&gt;返回一个包含四个元素的 Lua 表 (&lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, 和 &lt;code&gt;res.truncated&lt;/code&gt;)。&lt;br/&gt;作用域：&lt;code&gt;rewrite_by_lua *&lt;/code&gt;，&lt;code&gt;access_by_lua *&lt;/code&gt;，&lt;code&gt;content_by_lua *&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;res = ngx.location.capture(
     '/foo/bar',
     { method = ngx.HTTP_POST, body = 'hello, world' }
 )&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })&lt;/code&gt; 发起多个并发子查询&lt;br/&gt;作用域：&lt;code&gt;rewrite_by_lua *&lt;/code&gt;，&lt;code&gt;access_by_lua *&lt;/code&gt;，&lt;code&gt;content_by_lua *&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;res1, res2, res3 = ngx.location.capture_multi{
     { &quot;/foo&quot;, { args = &quot;a=3&amp;amp;b=4&quot; } },
     { &quot;/bar&quot; },
     { &quot;/baz&quot;, { method = ngx.HTTP_POST, body = &quot;hello&quot; } },
 }

 if res1.status == ngx.HTTP_OK then
     ...
 end

 if res2.body == &quot;BLAH&quot; then
     ...
 end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用：&lt;br/&gt;减少网络请求。&lt;br/&gt;方便配置降级服务。&lt;/p&gt;
&lt;p&gt;子查询文档参考： &lt;a href=&quot;https://github.com/openresty/lua-nginx-module#ngxlocationcapture&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module#ngxlocationcapture&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;执行阶段&quot;&gt;执行阶段&lt;/h2&gt;
&lt;p&gt;下面这个图是 ngx_lua 各个指令的执行顺序。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190324215401299-1498881409.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行阶段说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;set_by_lua*&lt;/code&gt;: 流程分支处理判断变量初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rewrite_by_lua*&lt;/code&gt;: 转发、重定向、缓存等功能(例如特定请求代理到外网)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;access_by_lua*&lt;/code&gt;: IP 准入、接口权限等情况集中处理(例如配合 iptable 完成简单防火墙)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content_by_lua*&lt;/code&gt;: 内容生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header_filter_by_lua*&lt;/code&gt;: 响应头部过滤处理(例如添加头部信息)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;body_filter_by_lua*&lt;/code&gt;: 响应体过滤处理(例如完成应答内容统一成大写)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log_by_lua*&lt;/code&gt;: 会话完成后本地异步完成日志记录(日志可以记录在本地，还可以同步到其他机器)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于 Nginx 把一个请求分成了很多阶段，这样第三方模块就可以根据自己行为，挂载到不同阶段进行处理达到目的。不同的阶段，有不同的处理行为，理解了他，也能更好的理解 Nginx 的设计思维。&lt;/p&gt;
&lt;h2 id=&quot;总结与自学&quot;&gt;总结与自学&lt;/h2&gt;
&lt;p&gt;1、如何自学&lt;br/&gt;《OpenResty最佳实践》&lt;br/&gt;2、遇到问题怎么办&lt;br/&gt;1) 看 nginx 的error.log&lt;br/&gt;2) 疑难问题把可复现信息在官方邮件组里反馈&lt;br/&gt;3) 善用Google&lt;br/&gt;4) QQ交流群&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/663847/201903/663847-20190328001209897-1821458152.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、OpenResty® - 中文官方站&lt;br/&gt;&lt;a href=&quot;https://openresty.org/cn/&quot; class=&quot;uri&quot;&gt;https://openresty.org/cn/&lt;/a&gt;&lt;br/&gt;2、openresty/lua-nginx-module: Embed the Power of Lua into NGINX HTTP servers&lt;br/&gt;&lt;a href=&quot;https://github.com/openresty/lua-nginx-module#version&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module#version&lt;/a&gt;&lt;br/&gt;3、FFI Library&lt;br/&gt;&lt;a href=&quot;http://luajit.org/ext_ffi.html&quot; class=&quot;uri&quot;&gt;http://luajit.org/ext_ffi.html&lt;/a&gt;&lt;br/&gt;4、luajit FFI简单使用(1) - Abel's Blog - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/erlang_hell/article/details/52836467&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/erlang_hell/article/details/52836467&lt;/a&gt;&lt;br/&gt;5、OpenResty最佳实践&lt;br/&gt;&lt;a href=&quot;https://moonbingbing.gitbooks.io/openresty-best-practices/&quot; class=&quot;uri&quot;&gt;https://moonbingbing.gitbooks.io/openresty-best-practices/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 16:16:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<og:description>概要 《用OpenResty搭建高性能服务端》是 系列课程中的入门课程，主讲人：温铭老师。课程分为10个章节，侧重于 的基本概念和主要特点的介绍，包括它的指令、 API、缓存、如何连接数据库、执行阶段</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/10589295.html</dc:identifier>
</item>
<item>
<title>Linux  Mysql数据库安全配置 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10583808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10583808.html</guid>
<description>&lt;p&gt; &lt;span&gt;Linux  Mysql数据库安全配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.修改mysql管理员账号root的密码(2种方法)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;修改mysql管理员账号root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;mysql管理员root账号密码遗忘解决办法(2种方法)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;创建数据库用户(3种方法)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;span&gt;mysql数据库权限管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　本地权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　网络权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       撤销权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       删除用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、修改mysql管理员账号root的密码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;方法一：shell命令&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysqladmin  -u  root  -p  password  &quot;123&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135010649-1986623522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查看密码存放的表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135035723-207788998.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二：mysql数据库命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt;use mysql;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt;update user set password=password('123') where user='root' and host='localhost';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt; FLUSH PRIVILEGES;        #刷新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135125953-834653612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试密码修改是否成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135155352-1342321113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、修改mysql管理员账号root&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;update mysql.user set user=&quot;admin&quot; where user=&quot;root&quot; and host=&quot;localhost&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flush privileges;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135333665-1705948092.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135352974-1148377229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、mysql管理员root账号密码遗忘&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;killall -TERM mysqld&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysqld_safe --skip-grant-tables &amp;amp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql -u admin &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt;update user set password=password('123456') where user='admin' and host='localhost';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt; FLUSH PRIVILEGES;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MySQL&amp;gt; quit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新启动MySQL，使用新密码登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135529947-490382438.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置新的密码，并刷新修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135611324-616967753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试，重启mysqld服务用新的密码登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135632934-1414794608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;修改/etc/my.cnf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在[Mysqld]下添加：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip-grant-tables  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重启MySQL服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql -u root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt;update user set password=password('123') where user='admin' and host='localhost';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql&amp;gt; FLUSH PRIVILEGES;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MySQL&amp;gt; quit &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改/etc/my.cnf  删除skip-grant-tables  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新启动MySQL，使用新密码登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135707767-1830038890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改/etc/my.cnf  删除skip-grant-tables  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新启动MySQL，使用新密码登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135726698-760715764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、创建数据库用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INSERT INTO user(host, user, password, select_priv, insert_priv, update_priv)     VALUES ('localhost', 'yuzly', PASSWORD('yuzly'), 'Y', 'Y', 'Y');&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135833243-1192536162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法二:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CREATE  USER  'user1'@'localhost'  IDENTIFIED  BY 'yuzly';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135854155-662746828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法三：通过新用户授权创建数据库用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323135919828-990483676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、权限管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.创建一个zhang用户,只给select权限,然后查看权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140016374-236617933.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.登录zhang用户，mysql -uzhang -pyuzly测试，创建一个表，下图显示被拒绝，当前账户没有create权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140043714-532985111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.登录管理员账户，给zhangsan账户添加create权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140105351-810601956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.重新登录zhangsan账户,测试是否具有create权限，下图说明具有create权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140136111-1874821610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.插入一条数据，下图提示没有insert权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140201601-1052336229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.登录管理员账户，给zhangsan账户添加insert权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140247517-473512024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.重新登录zhangsan账户,测试是否具有insert权限，下图说明具有insert权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140315895-1749748002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.创建的新用户，默认没有任何权限,下图可以看到创建的用户默认是没有任何权限的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140347099-1259394630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.登录新创建的用户&lt;span lang=&quot;EN-US&quot;&gt;mysql -uabcd -pyuzly,测试，下图可以看到&lt;span lang=&quot;EN-US&quot;&gt;abcd没有&lt;span lang=&quot;EN-US&quot;&gt;select等权限，用&lt;span lang=&quot;EN-US&quot;&gt;show只能查看&lt;span lang=&quot;EN-US&quot;&gt;mysql系统自带的东西，别的用户创建的数据库等看不到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140421517-1458078619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;远程连接权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.创建一个账户，赋予远程登录权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;grant all on userdb.* to 'abc'@'10.10.10.200' identified by 'yuzly';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flush privileges;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140623436-1645089403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;测试，&lt;/span&gt;&lt;span&gt;从另一台Linux的Mysql客户端登录验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140650436-2144380041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.下图可以看到，abc用户对userdb数据库具有任何权限，但对别的数据库没有任何权限，例如mysql.user&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140714274-215825330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.远程连接限制一个网段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140800629-1437277421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140821620-703396234.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;撤销权限&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;revoke all on userdb.* from 'zhangsan'@'localhost';&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140910292-152331624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;测试，撤消zhangsan账户的权限是否生效&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323140931954-1839566357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除账户&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;delete from mysql.user where user=&quot;aaa&quot; and host=&quot;localhost&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190323141005800-1451467003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mysql数据库基础学习笔记：&lt;a href=&quot;https://www.cnblogs.com/yuzly/p/10582295.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yuzly/p/10582295.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Mar 2019 16:16:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>Linux Mysql数据库安全配置 目录： 1.修改mysql管理员账号root的密码(2种方法) 2.修改mysql管理员账号root 3.mysql管理员root账号密码遗忘解决办法(2种方法)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10583808.html</dc:identifier>
</item>
<item>
<title>HTTP浅谈 - BUG提交器_Hugo</title>
<link>http://www.cnblogs.com/BUG-Hugo-qing/p/10612310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BUG-Hugo-qing/p/10612310.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;HTTP浅谈&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;1···什么是HTTP？&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;HTTP协议就是&lt;strong&gt;超文本传输协议&lt;/strong&gt;(HyperText Transfer Protocol),通俗理解是浏览器和web服务器传输数据格式的协议,HTTP协议是一个应用层协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;HTTP协议是基于&lt;strong&gt;TCP&lt;/strong&gt;协议的，发送数据之前需要建立好连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面&amp;lt;网页&amp;gt;的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;HTTP协议的制作者是蒂姆·伯纳斯-李，他供职于CERN(欧洲核子研究组织)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327195827040-10942389.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1991年发布的0.9版，该版本极其简单，只有一个GET请求方法&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1996年5月，HTTP/1.0版本发布&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1997年1月，HTTP/1.1版本发布，目前使用就是HTTP/1.1版本&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;2···网络传输-TCP/IP四层的模型&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;TCP/IP模型又称为TCP/IP协议族，是一系列网络协议的总称。TCP/IP模型一共包括几百种协议，制作协议的目的，就是保证计算机之间可以进行按照一定格式进行数据通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327195938420-861864811.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;3··· HTTP协议#的工作模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HTTP协议的工作模式是一次请求(request)和一次响应(response)的模式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327195854052-2080529511.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;4···Http与Https的区别：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;a-&lt;span class=&quot;cm-variable&quot;&gt;HTTP &lt;span class=&quot;cm-variable&quot;&gt;的URL &lt;span class=&quot;cm-variable&quot;&gt;以 &lt;span class=&quot;cm-variable&quot;&gt;http:&lt;span class=&quot;cm-operator&quot;&gt;// &lt;span class=&quot;cm-variable&quot;&gt;开头，&lt;br/&gt;&lt;span class=&quot;cm-variable cm-error&quot;&gt;而HTTPS &lt;span class=&quot;cm-variable&quot;&gt;的URL &lt;span class=&quot;cm-variable&quot;&gt;以 &lt;span class=&quot;cm-variable&quot;&gt;https:&lt;span class=&quot;cm-operator&quot;&gt;// &lt;span class=&quot;cm-variable&quot;&gt;开头&lt;br/&gt;​&lt;br/&gt;&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;b-&lt;span class=&quot;cm-variable&quot;&gt;HTTP &lt;span class=&quot;cm-variable&quot;&gt;是不安全的，&lt;br/&gt;&lt;span class=&quot;cm-variable&quot;&gt;而 &lt;span class=&quot;cm-variable&quot;&gt;HTTPS &lt;span class=&quot;cm-variable&quot;&gt;是安全的&lt;br/&gt;​&lt;br/&gt;&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;c-&lt;span class=&quot;cm-variable&quot;&gt;HTTP &lt;span class=&quot;cm-variable&quot;&gt;标准端口是80 &lt;span class=&quot;cm-variable&quot;&gt;，&lt;br/&gt;&lt;span class=&quot;cm-variable&quot;&gt;而 &lt;span class=&quot;cm-variable&quot;&gt;HTTPS &lt;span class=&quot;cm-variable&quot;&gt;的标准端口是443&lt;br/&gt;​&lt;br/&gt;&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;d-&lt;span class=&quot;cm-variable&quot;&gt;在OSI &lt;span class=&quot;cm-variable&quot;&gt;网络模型中，HTTP工作于应用层，&lt;br/&gt;&lt;span class=&quot;cm-variable&quot;&gt;而HTTPS &lt;span class=&quot;cm-variable&quot;&gt;的安全传输机制工作在传输层&lt;br/&gt;​&lt;br/&gt;&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;e-&lt;span class=&quot;cm-variable&quot;&gt;HTTP &lt;span class=&quot;cm-variable&quot;&gt;无法加密，&lt;br/&gt;&lt;span class=&quot;cm-variable&quot;&gt;而HTTPS &lt;span class=&quot;cm-variable&quot;&gt;对传输的数据进行加密&lt;br/&gt;​&lt;br/&gt;&lt;span class=&quot;cm-number&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;f-&lt;span class=&quot;cm-variable&quot;&gt;HTTP  &lt;span class=&quot;cm-variable&quot;&gt;无需证书，&lt;br/&gt;&lt;span class=&quot;cm-variable&quot;&gt;而HTTPS &lt;span class=&quot;cm-variable&quot;&gt;需要CA机构的颁发的SSL证书&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;5···什么是Http协议无状态协议?&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息&lt;br/&gt;也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;6···URI和URL的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;URI&lt;/span&gt;&lt;/strong&gt;  (&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的&lt;br/&gt;URI一般由三部组成：&lt;br/&gt;①访问资源的命名机制&lt;br/&gt;②存放资源的主机名&lt;br/&gt;③资源自身的名称，由路径表示，着重强调于资源。&lt;/p&gt;

&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;URL&lt;/span&gt;&lt;/strong&gt;  (&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;URL是Internet上用来描述信息资源的字符串，主要用在各种万维网的客户程序和服务器程序上，特别是著名的Mosaic。&lt;br/&gt;采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：&lt;br/&gt;①协议(或称为服务方式)&lt;br/&gt;②存有该资源的主机IP地址(有时也包括端口号)&lt;br/&gt;③主机资源的具体地址。如目录和文件名等&lt;/p&gt;

&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;URN&lt;/span&gt;&lt;/strong&gt;  （&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:python-net@python.sun.com。）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;上面的 mailto、news 和 isbn URI 都是 URN 的示例。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;7···常用的HTTP方法有哪些？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器&lt;br/&gt;POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。&lt;br/&gt;PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。&lt;br/&gt;DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。&lt;br/&gt;OPTIONS：查询相应URI支持的HTTP方法。（当客户端想要决定其他可用的方法来检索或者处理Web服务端的一个文档时使用。）&lt;/p&gt;
&lt;p&gt;HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。（当客户端向Web服务器请求一个资源的一些信息而不是资源的全部信息的时候使用。）&lt;/p&gt;
&lt;p&gt;TRACE: 当客户端要求可用的代理服务器或者中间服务更改请求来宣布自己的时候使用。&lt;/p&gt;
&lt;p&gt;CONNECT: 当客户端想要确定一个明确的连接到远程主机的时候使用，通常便于通过Http代理服务器进行SSL加密通信（Https）连接使用。&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;8···HTTP请求报文与响应报文格式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;请求报文&lt;/span&gt;主要有两种（POST和GET），包含四部分：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327223804073-1216460758.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;请求报文的请求头常用到的字段&lt;/p&gt;
&lt;p&gt;Host：请求资源所在服务器&lt;/p&gt;
&lt;p&gt;Accept：可处理的媒体类型&lt;/p&gt;
&lt;p&gt;Accept-Charset：可接收的字符集&lt;/p&gt;
&lt;p&gt;Accept-Encoding：可接受的内容编码&lt;/p&gt;
&lt;p&gt;Accept-Language：可接受的自然语言&lt;/p&gt;


&lt;p&gt;&lt;em&gt;&lt;span&gt;响应报文&lt;/span&gt;也是包含了四部分：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327234256272-377674727.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;9···HTTPS工作原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；&lt;/p&gt;
&lt;p&gt;二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；&lt;/p&gt;
&lt;p&gt;三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；&lt;/p&gt;
&lt;p&gt;四、发送给服务端，此时只有服务端（RSA私钥）能解密。&lt;/p&gt;
&lt;p&gt;五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629240/201903/1629240-20190327234745569-1374732525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;具体的参考链接：&lt;span class=&quot;md-expand&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/sean_cd/article/details/6966130&quot;&gt;http://blog.csdn.net/sean_cd/article/details/6966130&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;···&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;一次完整的HTTP请求所经历的7个步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;建立TCP连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。&lt;span&gt;&lt;strong&gt;HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;一旦建立了TCP连接，&lt;span&gt;&lt;strong&gt;Web浏览器就会向Web服务器发送请求命令&lt;/strong&gt;&lt;span&gt;。例如：GET /sample/hello.jsp HTTP/1.1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Web浏览器发送请求头&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Web服务器应答&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Web服务器发送应答头&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Web服务器向浏览器发送数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Web服务器关闭TCP连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;Connection:keep-alive&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;建立TCP连接-&amp;gt;发送请求行-&amp;gt;发送请求头-&amp;gt;（到达服务器）发送状态行-&amp;gt;发送响应头-&amp;gt;发送响应数据-&amp;gt;断TCP连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;最具体的HTTP请求过程：&lt;span&gt;&lt;a href=&quot;http://blog.51cto.com/linux5588/1351007&quot;&gt;http://blog.51cto.com/linux5588/1351007&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;11···&lt;/span&gt;常见的HTTP相应状态码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;13.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;200：服务器已成功处理了请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;201：请求成功并且服务器创建了新的资源&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;204： 服务器成功处理了请求，但没有返回任何内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;206：服务器成功处理了部分 GET 请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;301：请求的网页已永久移动到新位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;303：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;304：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;307：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;400：服务器不理解请求的语法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;401： 请求要求身份验证&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;403：服务器拒绝请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;404：服务器无法找到对应资源&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;500：服务器内部错误&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;503： 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;12···HTTP1.1版本新特性&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;a、&lt;span&gt;&lt;strong&gt;默认持久连接节省通信量&lt;/strong&gt;&lt;span&gt;，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;b、&lt;span&gt;&lt;strong&gt;管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;c、&lt;span&gt;&lt;strong&gt;断点续传&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;13···HTTP优化方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我下面就简要概括一下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;压缩：将文本数据进行压缩，减少带宽&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;详情参考：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以上部分内容参考于：https://www.cnblogs.com/Java3y/p/8444033.html&lt;/p&gt;
&lt;p&gt;均为个人学习总结，若有误之处，还望大牛们评论指出，互相学习共勉&lt;/p&gt;

</description>
<pubDate>Wed, 27 Mar 2019 16:03:00 +0000</pubDate>
<dc:creator>BUG提交器_Hugo</dc:creator>
<og:description>HTTP浅谈 1···什么是HTTP？ HTTP协议就是超文本传输协议(HyperText Transfer Protocol),通俗理解是浏览器和web服务器传输数据格</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BUG-Hugo-qing/p/10612310.html</dc:identifier>
</item>
</channel>
</rss>