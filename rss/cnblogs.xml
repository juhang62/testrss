<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习基础——简单易懂的K邻近算法，根据邻居“找自己” - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12460255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12460255.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章给大家分享机器学习领域非常简单的模型——KNN，也就是K Nearest Neighbours算法，翻译过来很简单，就是K最近邻居算法。这是一个经典的&lt;strong&gt;无监督学习&lt;/strong&gt;的算法，原理非常直观，易于理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;监督与无监督&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单介绍一下监督这个概念，监督是supervised的直译，我个人觉得不太准确，翻译成&lt;strong&gt;有标注和无标注&lt;/strong&gt;可能更加准确。也就是说如果模型在学习的时候，既能够看到样本的特征又可以看到样本的结果，那么就是有监督学习，如果只能看到特征，但是并不能知道这些特征对应的结果，那么就是无监督学习。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们介绍的线性回归和逻辑回归模型就是典型的有监督模型，因为模型在训练的时候知道样本的结果，并且根据我们设计的损失函数朝着贴近样本真实结果的方向“努力”。而今天介绍的KNN算法则是一个经典的无监督学习模型，算法在训练的时候并不知道正确的结果是什么，也因此模型根本没有损失函数这个概念，那么自然整个算法的运行原理也很监督模型大相径庭。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;算法概述&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实KNN算法的原理非常简单，简单到只有一句话，就是&lt;strong&gt;找到样本的K个邻居&lt;/strong&gt;，然后这K个邻居出现次数最多的结果就是答案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们怎么定义邻居，又怎么找到这些邻居呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答这个问题之前，我们先来看一个例子。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在有这么一个问题，我需要知道全城的用户有哪些用户有车，但是我们只知道用户的家庭地址，那么该怎么办呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，我需要在全城做一个调查，也就是对全城市民做一个抽样，抽取一部分做个是否有车的调研。对于剩下的用户呢，我去寻找离他最近的几个邻居，看看他的这几个邻居是否有车。如果离他近的邻居大多数都有车，那么，我可以认为，该用户可能住在富人区，他有车的概率比较大。如果他的邻居都没有车，可能他住在穷人区，他很有可能也没有车。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能会说中国不像美国可以划分成穷人区和富人区，往往在一个区域内穷富是杂居的，用这种方法得出的结果准确率肯定不高。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;的确存在这个问题，所以我们可以在此基础上做一点优化，很简单，我们只知道用户住在哪里是不够的，我们可能还需要了解用户的收入情况。在寻找他最近的邻居的过程当中，除了要考虑距离上的远近之外，还需要保证收入尽可能接近。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能知道和他距离和收入都接近的邻居是否有车，那么大概率可以判断这个用户是否有车。重复这个算法，我就可以通过少量的样本，算出全体样本是否有车的情况。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，想必你应该能明白，在KNN算法的范畴当中，&lt;strong&gt;“邻居”指的不是地理上的邻近关系，而指的是样本空间的接近&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，对于向量A(a1,a2,a3...an)，B(b1,b2,b3...bn)&lt;/p&gt;
&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=dis%20=%20/sqrt{(a_1%20-%20b_1)^2%20+%20(a_2%20-%20b_2)^2%20+%20/cdots%20+%20(a_n%20-%20b_n)^2}&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在机器学习当中，我们通常会把一条样本数据当做向量空间中的一条向量。比如在刚刚的问题当中，用户A，他的样本可能是(120.3213, 30.1312, 10.5)，指的是居住地点的经纬度和年收入。也可能是(城东, 泾河花园, 10.5)，或者是(城东, 沿河西路, 泾河花园, 10.5)等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的一条样本，表示成向量就有多种形式。对于不同的问题而言，不同的表示方法拥有不同的效果。在当前问题当中，我们需要计算向量和向量之间的距离，显然，使用第一种经纬度的表示方式更好。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;算法原理&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面这个例子，其实我们已经把算法的整个运行过程讲解清楚了。所谓的k-邻近算法，其实就是使用距离样本最近的k个样本的结果来代表当前样本的结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个算法的流程如下：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;采集一批有标注结果的样本，设为s&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;遍历每一个未知结果的样本&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=x_i&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;遍历s，计算s中的每一个样本和&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=x_i&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的距离&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;根据距离进行排序，选出距离最小的k个样本&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;选出这k个样本中出现频次最多的类别作为&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=x_i&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;的结果&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法流程不难理解，但是其中有几个注意点：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，每一个样本其实指的是样本空间里的一个向量。既然是向量，并且要计算样本之间的距离，那么&lt;strong&gt;向量的每一个维度都必须是实数&lt;/strong&gt;。一般情况下，字符串是无法作为特征计算距离的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，向量距离的计算方法。常规来说，向量之间的距离可以理解成空间中两个点的距离，关于这个距离常规上有几种计算的公式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种叫做欧式公式，就是我们刚才列的也是最常见的欧几里得距离公式：&lt;/p&gt;
&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=d%20=%20/sqrt{(a_1%20-%20b_1)^2%20+%20(a_2%20-%20b_2)^2%20+%20/cdots%20+%20(a_n%20-%20b_n)^2}&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种叫做曼哈顿距离，曼哈顿是纽约的CBD，既然是街区，从一个路口到另一个路口的距离显然是不能从街区中跨越的。所以两个路口的距离，其实是两点的直角连线距离。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设一个点坐标是(3, 4) ，另一个点的坐标是(5, 1)，这两点的距离d = | 3 - 5| + | 4 - 1| = 5&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公式为：&lt;/p&gt;
&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/displaystyle%20d%20=%20/sum_{i=1}^n|x_{1i}-x_{2i}|&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在距离计算的方法当中，欧氏距离和曼哈顿距离最常用，除了这两种之外还有切比雪夫距离和闵可夫斯基距离等，一般不太常用，我们不多做赘述，感兴趣的可以自行谷歌。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就到了我们紧张刺激的代码实现环节，KNN的原理不算难，只要能理解，稍微思考一下我想大部分同学应该都能写出来。所以之前阿里的校招经常用KNN作为&lt;strong&gt;笔试题&lt;/strong&gt;，考察一下同学的代码能力以及对基础模型的理解情况。所以实现是一方面，将代码写漂亮，实现完美又是另一方面。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细想一下当我们的数据有了之后，KNN主体就只有一个函数，我们先来看一下不使用任何库函数进行实现的代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vector, dataSet, labels, k)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;dis = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(len(dataSet)):&lt;br/&gt;data = dataSet[i]&lt;br/&gt;d = calculate_distance(vector, data)&lt;br/&gt;dis.append(d)&lt;br/&gt;dis_index = sorted(enumerate(dis), key=&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x: x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])&lt;br/&gt;label_map = {}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(k):&lt;br/&gt;label = labels[dis_index[i][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; label &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; label_map:&lt;br/&gt;label_map[label] += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;label_map[label] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;maxi = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;label = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; label_map:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; label_map[i] &amp;gt; maxi:&lt;br/&gt;maxi = label_map[i]&lt;br/&gt;label = i&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; label&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中calculate_distance是计算两个向量距离的函数，实现也很简单，就是套用一下上面刚才提到的距离公式，基本没有难度：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;calculate_distance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vectorA, vectorB)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;d = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(len(vectorA)):&lt;br/&gt;d += (vectorA[i] - vectorB[i]) * (vectorA[i] - vectorB[i])&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; math.sqrt(d)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是显然这是没有必要的，我们多做了很多无用功。灵活地使用库函数，可以将代码缩减到不可思议的地步：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; random&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Counter&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(x, dataset, labels, K)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;x, dataset = np.array(x), np.array(dataset)&lt;br/&gt;dis = np.sqrt(np.sum((x - dataset) ** &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, axis=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;br/&gt;topKIdices = np.argsort(dis)[:K]&lt;br/&gt;labels = np.array(labels)&lt;br/&gt;counter = Counter(labels[topKIdices])&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; counter.most_common(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道大家看到有没有觉得有点不可思议，我们一个for循环都没有用到就实现了KNN算法，只有&lt;strong&gt;短短5行&lt;/strong&gt;。其中Numpy是我们做机器学习非常常用的包，由于Numpy有非常多的API可以非常方便地进行计算，所以我们会在之后单独开一个Numpy专题。关于Counter等库函数的用法，在之前介绍collections的文章当中介绍过，如果有遗忘的同学可以在公众号回复collections获取文章。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们创造一个简单的sample来验证一下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;create_data_set&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;dataset = np.array([[&lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;]])&lt;br/&gt;labels = [&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; dataset, labels&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序得到的结果是A。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优化&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们还没有结束，还有一个问题值得讨论。在我们刚才叙述算法流程的过程当中，有一个关键点被我们忽略了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的样本由特征构成，我们对特征向量计算距离。问题是这些&lt;strong&gt;特征并不是一个维度的&lt;/strong&gt;，还用上面的例子。我们为了判断一个用户是否有车，用到了三个特征，分别是他家的经度、纬度和年收入。注意，经纬度和年收入并不是一个量纲下的变量，从数学上我们当然可以对它们当做是一个量纲来计算，但是这样显然是不准确的。最主要的问题是，不同量纲的特征波动的幅度可能完全不同。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一点应该不难理解，对于经纬度而言，取值范围假设是[0, 360]，但是年收入的浮动范围可能是上千万。显然如果我们直接来计算距离的话，那么主要的权重就落在了年收入上，这个&lt;strong&gt;模型就发生了倾斜&lt;/strong&gt;，这显然是我们不想看到的，因为会影响模型最终的效果。为了解决这个问题，我们需要将这些量纲归一化，消除量纲带来的影响。这也是KNN关键的优化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归一化的方式很多，比较常用的有两种。&lt;strong&gt;一种是Standardization&lt;/strong&gt;，又称为Z-score normalization，归一化之后的数据服从正态分布，它的公式如下：&lt;/p&gt;
&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=z_i%20=%20/frac{x_i-/mu}{/delta}&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/mu&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;和&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/delta&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;分别对应样本的均值和方差，归一化之后的结果在[-1, 1]之间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种归一化的方法叫做&lt;strong&gt;Min-max Scaling&lt;/strong&gt;，它是根据样本的最大最小值进行的缩放。公式如下：&lt;/p&gt;
&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=z_i=/frac{x_i%20-%20min(x_i)}{max(x_i)-min(x_i)}&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样缩放之后的结果在[0, 1]之间，最大值时取1，最小值时取0，这也是最常用的归一化的方法之一。通过归一化之后，我们可以将不同量纲下的变量缩放到同一个取值范围当中，从而将特征拉到平等的维度，这样模型学习的效果更佳均匀，不容易被其中某一个或者某几个特征带偏。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就是这些，KNN是非常基础的机器学习算法，相信对大家而言应该并不难。如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/11/170c70933948a9d3?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Mar 2020 00:43:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天的文章给大家分享机器学习领域非常简单的模型——KNN，也就是K Nearest Neighbours算法，翻译过来很简单，就是K最近</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12460255.html</dc:identifier>
</item>
<item>
<title>开源字体不香吗？五款 GitHub 上的爆红字体任君选 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12455960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12455960.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152512932-547115150.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://chungzh.cn/&quot;&gt;HelloGitHub-ChungZH&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在编程时，用一个你喜欢的字体可以大大提高效率，越看越舒服。这篇文章就推荐 5 个在 GitHub 上优秀的字体供大家选择吧！&lt;/p&gt;
&lt;h2 id=&quot;iosevka&quot;&gt;1. Iosevka&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152525353-1894094226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Iosevka 是一款由 &lt;a href=&quot;https://github.com/be5invis&quot;&gt;be5invis&lt;/a&gt; 大佬开发的开源字体。它支持了 15 种不同的样式（可前往 GitHub 仓库中预览），还支持连字特性（ligatures）。同时，be5invis 还将 Iosevka 和 Source Han Sans（思源黑体）合成为了一个等宽的支持 CJK（中日韩语言）的字体 &lt;a href=&quot;https://github.com/be5invis/Sarasa-Gothic&quot;&gt;Sarasa Gothic 更纱黑体&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;source-code-pro&quot;&gt;2. Source Code Pro&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152535353-1056515846.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Source Code Pro 这款大名鼎鼎的字体相信大家都不陌生，它是由 Adobe 公司开发的一款字体。除了写代码，还可以用在 UI 环境中。不支持连字。&lt;/p&gt;
&lt;h2 id=&quot;cascadia-code&quot;&gt;3. Cascadia Code&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152543461-1929032188.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这款新字体由 Microsoft 开发，被用于 Windows Terminal 中。Cascadia Code 看起来比较粗，同样支持连字（图中 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt; 等符号都是连字的样式）。&lt;/p&gt;
&lt;h2 id=&quot;jetbrains-mono&quot;&gt;4. JetBrains Mono&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152552335-1883445742.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这款字体是 JB 家一个月前发布的字体，支持 145 种语言（没有 CJK）。这款字体比一般的字体要稍微宽一点，提高了易读性。目前 JetBrains 的全部 IDE 都将 JetBrains Mono 作为了默认字体。&lt;/p&gt;
&lt;h2 id=&quot;fira-code&quot;&gt;5. Fira Code&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200310152601311-1085960557.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Fira Code 是 tonsky 基于 Mozilla 开发的 Fira Mono 改进而成的。相比原版，Fira Code 主要增加了连字的特性。它是第一个将连字“发扬光大”的编程字体，十分受程序员的喜爱，它在 GitHub 上的 Stars 数量有 44k！&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;上面推荐的开源字体，不知道有没有你喜欢的？如果有其它优秀的开源字体，欢迎在留言区讨论。一款好的编程字体便于提高开发效率，快去选一款用起来吧～&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200213201956024-782757549.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Mar 2020 00:20:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub ChungZH&amp;quot; 在编程时，用一个你喜欢的字体可以大大提高效率，越看越舒服。这篇文章就推荐 5 个在 GitHub 上优秀的字体供大家选择吧！ 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12455960.html</dc:identifier>
</item>
<item>
<title>SpringCloud第二代实战系列：一文搞定Nacos实现服务注册与发现 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12460197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12460197.html</guid>
<description>&lt;h2 id=&quot;一背景springcloud-生态圈&quot;&gt;一、背景：SpringCloud 生态圈&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;在正式开始本篇文章之前我们先岔开来讲一下SpringCloud的生态圈。&lt;br/&gt;SpringCloud大家都比较熟悉了，它制定了分布式系统的标准规范，做了高度抽象和封装，然后将业界公司比较成熟以及经得起实际考验的框架整合起来。通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。我们之前常用的一些SpringCloud组件大部分来自于Netflix公司，比如我们熟知的Eureka，Hystrix，Ribbon等等，&lt;strong&gt;然而随着Eureka不再维护且闭源，Hystrix不再开发新功能，Zuul的性能一般而2.0又迟迟出不来，Ribbon不支持webFlux的负载均衡等等&lt;/strong&gt; ，这些已经限制了SpringCloud的高速发展，于是大家开始把目光转向第二代组合——SpringCloud Alibaba。&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-alibaba概述&quot;&gt;1.1、Spring Cloud Alibaba概述&lt;/h3&gt;
&lt;p&gt;Spring Cloud Alibaba 于 2018年成为SpringCloud的孵化项目，2018年7月27日 在 Spring Cloud 孵化器仓库提交第一次代码，到 2019年8月1日 在 Alibaba 仓库发布第一个正式版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi00YzYzYjBjMzYyOTkwZGFj?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一代和第二代部分常用组件对比&quot;&gt;1.2、第一代和第二代部分常用组件对比&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;网关&lt;/td&gt;
&lt;td&gt;Zuul（Netflix）&lt;/td&gt;
&lt;td&gt;Gateway（SpringCloud）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;注册中心&lt;/td&gt;
&lt;td&gt;Eureka（Netflix），Consul、ZK&lt;/td&gt;
&lt;td&gt;Nacos（阿里）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;配置中心&lt;/td&gt;
&lt;td&gt;SprigCloudConfig&lt;/td&gt;
&lt;td&gt;Nacos（阿里），Apollo（携程）等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;负载均衡&lt;/td&gt;
&lt;td&gt;Ribbon（Netflix）&lt;/td&gt;
&lt;td&gt;Loadbalancer（SpringCloud）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;熔断器&lt;/td&gt;
&lt;td&gt;Hystrix（Netflix）&lt;/td&gt;
&lt;td&gt;Resilience4J（spring-cloud-r4j），Sentinel （阿里）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;二nacos介绍及与eureka的对比&quot;&gt;二、Nacos介绍及与Eureka的对比&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;微服务项目，我们肯定绕不开服务注册接下来我们正式进入今天的正题，一起来认识一下Nacos。关键特性有：服务发现和服务健康监测，动态配置服务，动态 DNS 服务，服务及其元数据管理等等&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi02M2QyODlkMTdlMjY3NGFi?x-oss-process=image/format,png&quot; width=&quot;500&quot; div=&quot;&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;2.1 介绍&lt;/h3&gt;
&lt;p&gt;官方介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。&lt;br/&gt;Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。Nacos 是构建以“服务”为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi03YmI5NDBjZGI0ZjQxNjhj?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi03MjJhNzdlOTA4ZTU2ZGMyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;nacos对比eureka&quot;&gt;2.2 Nacos对比Eureka&lt;/h3&gt;
&lt;p&gt;既然称之为第二代，那么Nacos对比Eureka，是否具有优势呢？我们来看一下对比&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0wNWM3MTdlMTNiYTE5OTkyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;更多关于Naclos的介绍可参见官网：&lt;a href=&quot;https://nacos.io/&quot; class=&quot;uri&quot;&gt;https://nacos.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三nacos安装与配置&quot;&gt;三、Nacos安装与配置&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;接下来我们来使用Nacos进行服务的注册与发现（Nacos还可以实现分布式配置管理，在后续章节再进行讲解）。开始之前需确保我们的环境符合要求：操作系统是64位，且本地已安装了JDK1.8+，Maven3.2.X。&lt;/p&gt;
&lt;h3 id=&quot;下载nacos&quot;&gt;3.1 下载Nacos&lt;/h3&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/alibaba/nacos/releases&quot; class=&quot;uri&quot;&gt;https://github.com/alibaba/nacos/releases&lt;/a&gt;&lt;br/&gt;由于众所周知的原因，有的时候github访问非常的慢，我们可以访问国内的镜像仓库：&lt;a href=&quot;https://gitee.com/mirrors/Nacos%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%90%8E%E8%87%AA%E5%B7%B1%E6%89%8B%E5%8A%A8%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91%E5%8D%B3%E5%8F%AF&quot; class=&quot;uri&quot;&gt;https://gitee.com/mirrors/Nacos，下载后自己手动镜像编译即可&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;解压启动&quot;&gt;3.2 解压启动&lt;/h4&gt;
&lt;p&gt;编写本篇文字时，Nocos1.2 处于Beta1阶段，所以我下载的是1.1.4Release版本。&lt;br/&gt;我们将下载的安装包直接解压到本地，直接双击bin目录下的startup.cmd即可启动，非常地方便,&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi05ODU4ZmE1YjkxNDVlZTM1?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nacos的默认端口是8848，访问地址：&lt;a href=&quot;http://127.0.0.1:8848/nacos/index.html#/login&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:8848/nacos/index.html#/login&lt;/a&gt; ，界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01YzliNTNiNjcxMDQ2ZmI5?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户名/密码&lt;/strong&gt;： nacos/nacos，登录系统：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01MDliZjlhZTBlY2RhZDFhLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置调整&quot;&gt;3.3 配置调整&lt;/h3&gt;
&lt;p&gt;如果需要修改端口号，或者修改contextPath等，只需要修改conf/application.properties文件即可&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0wZjVjOTYyNWFlMGEzNzM4LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用mysql数据库&quot;&gt;3.4 使用Mysql数据库&lt;/h3&gt;
&lt;p&gt;Nacos默认内置了一个Mysql数据库，为了便于管理，我们可以改为外置的数据库（尤其是在使用Nacos的分布式配置中心功能时，一定要改为外置的数据库，分布式配置中心功能后续会进行讲解），目前只支持Mysql，不支持其他数据库，&lt;/p&gt;
&lt;h4 id=&quot;初始化数据库&quot;&gt;3.4.1 初始化数据库&lt;/h4&gt;
&lt;p&gt;我们找到conf目录下的nacos-mysql.sql，并进行初始化&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1lNjI2MmNmZmFiMjEyYWU4LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加数据库配置&quot;&gt;3.4.2 添加数据库配置&lt;/h4&gt;
&lt;p&gt;修改conf/application.properties文件，追加以下数据库信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_devtest?characterEncoding=utf8&amp;amp;connectTimeout=1000&amp;amp;socketTimeout=3000&amp;amp;autoReconnect=true
db.user=nacos_devtest
db.password=youdontknow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完后，直接启动即可。&lt;/p&gt;
&lt;h4 id=&quot;踩坑记录&quot;&gt;3.4.3 踩坑记录&lt;/h4&gt;
&lt;p&gt;我们在启动过程中，可能会遇到如下的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'opsController' defined in URL [jar:file:/D:/Dev/nacos-server-1.1.4/target/nacos-server.jar!/BOOT-INF/lib/nacos-config-1.1.4.jar!/com/alibaba/nacos/config/server/controller/OpsController.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dumpService': Invocation of init method failed; nested exception is java.lang.RuntimeException: Nacos Server did not start because dumpservice bean construction failure :
No DataSource set
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1308)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考了网上的部分资料，在Linux环境下可能是防火墙的问题，需要关闭防火墙，再进行启动。在我的环境中发现和防火墙没关系，是版本问题：&lt;strong&gt;Mysql当前不支持使用Mysql8&lt;/strong&gt;，只支持Mysql5。如果需要使用Mysql8，稍微修改下代码即可。支持8.0的方法可参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gyli20170901/p/11245270.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/gyli20170901/p/11245270.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四使用nacos作为注册中心&quot;&gt;四、使用Nacos作为注册中心&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;创建工程&quot;&gt;4.1 创建工程&lt;/h3&gt;
&lt;p&gt;我们新建一个member-service的 Gradle工程（Maven工程一样设置），添加jar包依赖，Gradle配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;implementation group: 'com.alibaba.cloud', name: 'spring-cloud-starter-alibaba-nacos-discovery', version: '2.1.1.RELEASE'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加配置&quot;&gt;4.2 添加配置&lt;/h3&gt;
&lt;p&gt;在我们的项目中新建一个application.yml文件，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
    application:
        name: order-service
    cloud:
        nacos:
            discovery:
                server-addr: 127.0.0.1:8848&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：网上有的教程说只支持properties不支持yml，这个说明是错误的，是可以使用yml配置。还有的教程说需要新建一个bootstrap.properties文件，这个说法也是不准确的，在使用Nacos的配置中心功能时才需要。如果仅仅是作为服务注册中心，这个也是没有必要的。关于Nacos配置中心的用法，后续章节会进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;注册成功&quot;&gt;4.3 注册成功&lt;/h3&gt;
&lt;p&gt;项目启动后，我们访问【服务管理】-【服务列表】页面，可以看到我们的服务已经注册上去了，非常地方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1mNjcyZjhhYmUxYzY4MDEy?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五集群配置&quot;&gt;五、集群配置&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;产线实际使用时，为了确保服务的高可能，正常会配置至少3台，所以我们需要进行集群的配置。&lt;/p&gt;
&lt;h3 id=&quot;集群配置&quot;&gt;5.1 集群配置&lt;/h3&gt;
&lt;p&gt;在conf目录下，新建一个cluster.conf，配置集群机器的地址即可。建议至少配置三台&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;172.22.204.10:8848
172.22.204.10:8849
172.22.204.10:8850&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依次启动&quot;&gt;5.2 依次启动&lt;/h3&gt;
&lt;p&gt;依次启动3台机器，访问【集群管理】-【节点列表】，我们发现已经配置成功。并且自动选举出了一台作为Leader。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1kMzIyZDg2ZGU3NDc4N2Yx?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nacos使用的是&lt;strong&gt;Raft算法&lt;/strong&gt;，将Server划分为3种状态或者也可以称作角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Leader&lt;/strong&gt;：负责Client交互和log复制，同一时刻系统中最多存在1个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follower&lt;/strong&gt;：被动响应请求RPC，从不主动发起请求RPC。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Candidate&lt;/strong&gt;：一种临时的角色，只存在于leader的选举阶段，某个节点想要变成leader，那么就发起投票请求，同时自己变成candidate。如果选举成功，则变为candidate，否则退回为follower&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;踩坑记录-1&quot;&gt;5.3 踩坑记录&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;坑1&lt;/strong&gt;： 我们本地测试的时候，如果设置ip为127.0.0.1或者localhost会发现服务无法访问，一定要配置成我们本机的真实的IP。&lt;br/&gt;这个对于我们本机做集群测试时非常地不方便，比如在公司配置了一个地址后，到家ip发生了变化，又得修改cluster配置文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;坑2&lt;/strong&gt;： window环境下默认是单机模式启动，需要修改为集群模式&lt;strong&gt;。&lt;/strong&gt;&lt;br/&gt;查看&lt;strong&gt;bin/startup.cmd&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;set MODE=&quot;standalone&quot;
set FUNCTION_MODE=&quot;all&quot;
set SERVER=nacos-server
set MODE_INDEX=-1
set FUNCTION_MODE_INDEX=-1
set SERVER_INDEX=-1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Mode由standalone改为cluster即可（在startup.sh脚本中，默认是集群的方式）修改后重新启动：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi04ZTQwMDM0ODg3ZWY5NjUz?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六谁在使用&quot;&gt;六、谁在使用&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;按照官方的说法，1.0之后的版本大家完全可以放心大胆地在产线上使用。目前使用nacos的企业已经有很多，包括阿里自身，以及工商银行，平安、爱奇艺、虎牙直播、汽车之家等等。&lt;/p&gt;
&lt;h2 id=&quot;七参考资料&quot;&gt;七、参考资料&lt;/h2&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;SpringCloudAlibaba地址：&lt;a href=&quot;https://github.com/alibaba/spring-cloud-alibaba&quot; class=&quot;uri&quot;&gt;https://github.com/alibaba/spring-cloud-alibaba&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nacos官方网站：&lt;a href=&quot;https://nacos.io/&quot; class=&quot;uri&quot;&gt;https://nacos.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nacos数据持久化 mysql8.0https://www.cnblogs.com/gyli20170901/p/11245270.html&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://springcloud.cn/view/415&quot; class=&quot;uri&quot;&gt;http://springcloud.cn/view/415&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/afd7776a64c6&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/afd7776a64c6&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;微信公众号：码大叔&lt;/strong&gt; 十年戎“码”，老“叔”开花&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iYThiNGRmMDkzMDgyZjdhLnBuZw?x-oss-process=image/format,png&quot; width=&quot;200&quot; height=&quot;200&quot; div=&quot;&quot; align=&quot;left&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Mar 2020 00:14:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>一、背景：SpringCloud 生态圈 在正式开始本篇文章之前我们先岔开来讲一下SpringCloud的生态圈。 SpringCloud大家都比较熟悉了，它制定了分布式系统的标准规范，做了高度抽象和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12460197.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 中IdentityServer4 授权中心之应用实战 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12447081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12447081.html</guid>
<description>&lt;p&gt;查阅了大多数相关资料，搜索到的IdentityServer4 的应用博客大多是比较简单并且多是翻译官网的文档编写的，我这里在 Asp.Net Core 中IdentityServer4 的应用分析中以电商系统架构升级过程中普遍遇到的场景进行实战性讲述分析，同时最后会把我的实战性的代码放到github 上，敬请大家关注！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;256.87165954035&quot;&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;查阅了大多数相关资料，查阅到的IdentityServer4 的相关文章大多是比较简单并且多是翻译官网的文档编写的，我这里在&lt;br/&gt;Asp.Net Core 中IdentityServer4 的应用分析中会以一个电商系统架构升级过程中普遍会遇到的场景进行实战性讲述分析，同时最后会把我的实战性的代码放到github 上，敬请大家关注！&lt;/p&gt;
&lt;p&gt;这里就直接开始撸代码，概念性东西就已经不概述了，想要了解概念推荐大家查看我之前的文章和官方文档：&lt;/p&gt;
&lt;h2 id=&quot;二应用实战&quot;&gt;二、应用实战&lt;/h2&gt;
&lt;h3 id=&quot;模拟场景&quot;&gt;2.1 模拟场景&lt;/h3&gt;
&lt;p&gt;最初小团队的电商系统场景如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310110017008-1660735876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张架构图缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布频繁，发布影响整个电商系统&lt;/li&gt;
&lt;li&gt;很难做到敏捷开发&lt;/li&gt;
&lt;li&gt;维护性可能会存在一定的弊端，主要看内部架构情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大多数小电商团队对于多客户端登录授权来说可能已经实现了Oauth 2.0 的身份授权验证，但是是和电商业务集成在一个网关里面，这样不是很好的方式；由于公司业务横向扩大，产品经理调研了代理商业务，最终让技术开发代理商业务系统。架构师出于后续发展的各方面考虑，把代理商业务单独建立了一个独立的网关，并且把授权服务一并给独立出来，调整后的电商系统架构图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310110050365-906620357.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;身份授权从业务系统中拆分出来后，有了如下的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;授权服务不受业务的影响，如果业务网关宕机了，那至少不会影响代理商网关的业务授权系统的使用&lt;/li&gt;
&lt;li&gt;授权服务一旦建立，一般就很难进行升级，除非特殊情况。&lt;/li&gt;
&lt;li&gt;在敏捷开发中，业务系统可能发布频繁，电商业务系统可能每天都是在频繁升级更新，这样也不至于影响了授权系统服务导致代理商业务受到影响&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代理商业务引入进来后，同时又增加了秒杀活动，发现成交量大大增大，支付订单集中在某一时刻翻了十几倍，这时候整个电商业务API网关已经扛不住了，负载了几台可能也有点吃力；开发人员经过跟架构师一起讨论，得出了扛不住的原因：主要是秒杀活动高并发的支付，以至于整个电商业务系统受到影响，故准备把支付系统从业务系统中拆分出成独立的支付网关，并做了一定的负载，成功解决了以上问题，这时候整个电商系统架构图就演变成如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310111100212-1434441217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支付网关服务抽离后的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支付网关服务更新不会太频繁，可以减少整个系统的因为发布导致的一系列问题，增强稳定性&lt;/li&gt;
&lt;li&gt;支付系统出现宕机不影响整个电商系统的使用，用户还可以浏览商品等等其他操作，技术和运维人员也比较好排查定位问题所在；提升用户体验，同时提升排查问题的效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;授权中心&lt;/code&gt;：单独一个服务网关，访问&lt;code&gt;支付业务网关&lt;/code&gt;、&lt;code&gt;电商业务网关&lt;/code&gt;及&lt;code&gt;代理商业务网关&lt;/code&gt;都需要先通过&lt;code&gt;授权中心&lt;/code&gt;获得授权拿到访问令牌&lt;code&gt;AccessToken&lt;/code&gt; 才能正常的访问这些网关，这样授权模块就不会受任何的业务影响，同时各个业务网关也不需要写同样的授权业务的代码；&lt;code&gt;业务网关&lt;/code&gt;仅仅只需关注本身的业务即可，&lt;code&gt;授权中心&lt;/code&gt;仅仅只需要关注维护授权；经过这样升级改造后整个系统维护性得到很大的提高，相关的业务也可以针对具体情况进行选择性的扩容。&lt;/p&gt;
&lt;p&gt;上面的电商网关演变架构图中我这里没有画出具体的请求流向，偷了个赖，这里还是先把OAuth2.0 的授权大体的流程图单独贴出来：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190708144314592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxeTI0OA==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;授权网关服务&lt;/code&gt;之前单独抽离出来了，这次把支付业务网关拆分出来就也比较顺利，一下子就完成了电商系统的架构升级。今天这篇文章的目的架构升级也就完成了，想要深入后续电商系统架构升级的同学可以关注后续给大家带来的微服务的相关教程，到时继续以这个例子来进行微服务架构上的演变升级，敬请大家关注。好了下面我们来回归该升级的和核心主题&lt;code&gt;授权网关服务&lt;/code&gt; &lt;code&gt;IdentityServer4&lt;/code&gt; 的应用。&lt;/p&gt;
&lt;h3 id=&quot;identityserver4-密码授权模式&quot;&gt;2.2 IdentityServer4 密码授权模式&lt;/h3&gt;
&lt;h4 id=&quot;授权网关服务&quot;&gt;授权网关服务&lt;/h4&gt;
&lt;h5 id=&quot;静态内存配置方式&quot;&gt;静态内存配置方式&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;定义资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分资源分为身份资源(&lt;code&gt;Identity resources&lt;/code&gt;)和API资源(&lt;code&gt;API resources&lt;/code&gt;)。&lt;br/&gt;我们先创建Jlion.NetCore.Identity.Service 网关服务项目,在网关服务中添加受保护的&lt;code&gt;API资源&lt;/code&gt;，创建&lt;code&gt;OAuthMemoryData&lt;/code&gt; 类代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Api资源 静态方式定义
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
{
       return new List&amp;lt;ApiResource&amp;gt;
       {
            new ApiResource(OAuthConfig.UserApi.ApiName,OAuthConfig.UserApi.ApiName),
       };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;定义客户端Client&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来&lt;code&gt;OAuthMemoryData&lt;/code&gt; 类中定义一个客户端应用程序的&lt;code&gt;Client&lt;/code&gt;，我们将使用它来访问我们的API资源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
{
       return new List&amp;lt;Client&amp;gt;
       {
           new Client()
           {
               ClientId =OAuthConfig.UserApi.ClientId,
               AllowedGrantTypes = new List&amp;lt;string&amp;gt;()
               {
                   GrantTypes.ResourceOwnerPassword.FirstOrDefault(),//Resource Owner Password模式
               },
               ClientSecrets = {new Secret(OAuthConfig.UserApi.Secret.Sha256()) },
               AllowedScopes= {OAuthConfig.UserApi.ApiName},
               AccessTokenLifetime = OAuthConfig.ExpireIn,
           },
      };
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AllowedGrantTypes&lt;/code&gt; ：配置授权类型，可以配置多个授权类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ClientSecrets&lt;/code&gt;：客户端加密方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AllowedScopes&lt;/code&gt;：配置授权范围，这里指定哪些API 受此方式保护&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AccessTokenLifetime&lt;/code&gt;：配置Token 失效时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GrantTypes&lt;/code&gt;：授权类型，这里使用的是密码模式&lt;code&gt;ResourceOwnerPassword&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码中可以看到有一个&lt;code&gt;OAuthConfig&lt;/code&gt; 类，这个类是我单独建的，是用于统一管理，方便维护，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class OAuthConfig
 {
        /// &amp;lt;summary&amp;gt;
        /// 过期秒数
        /// &amp;lt;/summary&amp;gt;
        public const int ExpireIn = 36000;

        /// &amp;lt;summary&amp;gt;
        /// 用户Api相关
        /// &amp;lt;/summary&amp;gt;
        public static class UserApi
        {
            public static string ApiName = &quot;user_api&quot;;

            public static string ClientId = &quot;user_clientid&quot;;

            public static string Secret = &quot;user_secret&quot;;
        }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果后续架构升级，添加了其他的网关服务，则只需要在这里添加所需要保护的API 资源，也可以通过读取数据库方式读取受保护的Api资源。&lt;/p&gt;
&lt;p&gt;接下来&lt;code&gt;OAuthMemoryData&lt;/code&gt; 类添加测试用户，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 测试的账号和密码
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static List&amp;lt;TestUser&amp;gt; GetTestUsers()
{
    return new List&amp;lt;TestUser&amp;gt;
    {
        new TestUser()
        {
             SubjectId = &quot;1&quot;,
             Username = &quot;test&quot;,
             Password = &quot;123456&quot;
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面受保护的资源，和客户端以及测试账号都已经建立好了，现在需要把IdentityServer4 注册到DI中：&lt;br/&gt;&lt;code&gt;Startup&lt;/code&gt; 中的&lt;code&gt;ConfigureServices&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();

    #region 内存方式
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
        .AddInMemoryClients(OAuthMemoryData.GetClients())
        .AddTestUsers(OAuthMemoryData.GetTestUsers());
    #endregion

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解读：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AddDeveloperSigningCredential&lt;/code&gt;：添加证书加密方式，执行该方法，会先判断tempkey.rsa证书文件是否存在，如果不存在的话，就创建一个新的tempkey.rsa证书文件，如果存在的话，就使用此证书文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddInMemoryApiResources&lt;/code&gt;：把受保护的Api资源添加到内存中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddInMemoryClients&lt;/code&gt; ：客户端配置添加到内存中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddTestUsers&lt;/code&gt; ：测试的用户添加进来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后通过&lt;code&gt;UseIdentityServer()&lt;/code&gt;需要把IdentityServer4 中间件添加到Http管道中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
     if (env.IsDevelopment())
     {
         app.UseDeveloperExceptionPage();
     }
   
     app.UseIdentityServer();

     app.UseRouting();

     app.UseAuthorization();

     app.UseEndpoints(endpoints =&amp;gt;
     {
        endpoints.MapControllers();
     });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，现在&lt;code&gt;授权网关服务&lt;/code&gt;代码已经完成，现在直接通过命令行方式启动，命令行启动如下，我指定5000端口，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200309145420622-518750766.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;电商用户网关api项目&quot;&gt;电商用户网关Api项目&lt;/h4&gt;
&lt;p&gt;现在我来新建一个WebApi 大的用户网关服务项目，取名为&lt;code&gt;Jlion.NetCore.Identity.UserApiService&lt;/code&gt;，新建后会默认有一个天气预报的api接口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ApiController]
[Route(&quot;[controller]&quot;)]
public class WeatherForecastController : ControllerBase
{
    private static readonly string[] Summaries = new[]
    {
        &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
    };

    private readonly ILogger&amp;lt;WeatherForecastController&amp;gt; _logger;

    public WeatherForecastController(ILogger&amp;lt;WeatherForecastController&amp;gt; logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()
    {
        var rng = new Random();
        return Enumerable.Range(1, 5).Select(index =&amp;gt; new WeatherForecast
        {
            Date = DateTime.Now.AddDays(index),
            TemperatureC = rng.Next(-20, 55),
            Summary = Summaries[rng.Next(Summaries.Length)]
        })
        .ToArray();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在&lt;code&gt;Startup&lt;/code&gt; 类中添加授权网关服务的配置到DI中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void ConfigureServices(IServiceCollection services)
 {
       services.AddControllers();

       services.AddAuthorization();
       services.AddAuthentication(&quot;Bearer&quot;)
           .AddIdentityServerAuthentication(options =&amp;gt;
           {
               options.Authority = &quot;http://localhost:5000&quot;;    //配置Identityserver的授权地址
               options.RequireHttpsMetadata = false;           //不需要https    
               options.ApiName = OAuthConfig.UserApi.ApiName;  //api的name，需要和config的名称相同
           });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;options.ApiName&lt;/code&gt; 需要和网关服务中的Api 资源配置中的ApiName 一致&lt;/p&gt;
&lt;p&gt;接下来需要把授权和认证中间件分别注册到Http 管道中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }


    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllers();
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在授权服务网关启用已经完成，只需要在需要保护的&lt;code&gt;Controller&lt;/code&gt; 中添加 &lt;code&gt;Authorize&lt;/code&gt; 过滤器即可，现在我也通过命令行把需要保护的网关服务启动，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200309171909609-1631064921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我通过postman 工具来单独访问 用户网关服务API，不携带任何信息的情况下,如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200309172307873-328739614.png&quot;/&gt;&lt;br/&gt;从访问结果可以看出返回&lt;code&gt;401 Unauthorized&lt;/code&gt; 未授权。&lt;/p&gt;
&lt;p&gt;我们接下来再来访问授权服务网关，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200309172500470-189757185.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求网关服务中body中携带了用户名及密码等相关信息，这是返回了&lt;code&gt;access_token&lt;/code&gt; 及有效期等相关信息，我们再拿&lt;code&gt;access_token&lt;/code&gt; 来继续上面的操作，访问用户业务网关的接口，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200309172710633-1291755074.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问结果中已经返回了我们所需要的接口数据，大家目前已经对密码模式的使用有了一定的了解，但是这时候可能会有人问我，我生产环境中可能需要通过数据库的方式进行用户信息的判断，以及客户端授权方式需要更加灵活的配置，可通过后台来配置ClientId以及授权方式等，那应该怎么办呢？下面我再来给大家带来生存环境中的实现方式。&lt;/p&gt;
&lt;h5 id=&quot;数据库匹配验证方式&quot;&gt;数据库匹配验证方式&lt;/h5&gt;
&lt;p&gt;我们需要通过用户名和密码到数据库中验证方式则需要实现&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt; 接口，并实现&lt;code&gt;ValidateAsync&lt;/code&gt; 验证方法，简单的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
{
    public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
    {
        try
        {
            var userName = context.UserName;
            var password = context.Password;

            //验证用户,这么可以到数据库里面验证用户名和密码是否正确
            var claimList = await ValidateUserAsync(userName, password);

            // 验证账号
            context.Result = new GrantValidationResult
            (
                subject: userName,
                authenticationMethod: &quot;custom&quot;,
                claims: claimList.ToArray()
             );
       }
       catch (Exception ex)
       {
            //验证异常结果
            context.Result = new GrantValidationResult()
            {
                IsError = true,
                Error = ex.Message
             };
       }
  }

    #region Private Method
    /// &amp;lt;summary&amp;gt;
    /// 验证用户
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;loginName&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;password&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task&amp;lt;List&amp;lt;Claim&amp;gt;&amp;gt; ValidateUserAsync(string loginName, string password)
    {
        //TODO 这里可以通过用户名和密码到数据库中去验证是否存在，
        // 以及角色相关信息，我这里还是使用内存中已经存在的用户和密码
        var user = OAuthMemoryData.GetTestUsers();

        if (user == null)
            throw new Exception(&quot;登录失败，用户名和密码不正确&quot;);

        return new List&amp;lt;Claim&amp;gt;()
        {
            new Claim(ClaimTypes.Name, $&quot;{loginName}&quot;),
        };
    }
    #endregion
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户密码验证器已经实现完成，现在需要把之前的通过&lt;code&gt;AddTestUsers&lt;/code&gt; 方式改成&lt;code&gt;AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;()&lt;/code&gt; 方式，修改后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();

    #region 数据库存储方式
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
        .AddInMemoryClients(OAuthMemoryData.GetClients())
        //.AddTestUsers(OAuthMemoryData.GetTestUsers());
        .AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;();
   #endregion
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前已经实现了用户名和密码数据库验证的方式，但是现在有人会考虑另外一个场景，客户端的授权方式等也需要通过后台可配置的方式，这样比较灵活，不通过代码中静态配置的方式，那应该这么办呢？&lt;br/&gt;官方考虑的很周到，我们可以使用&lt;code&gt;IClientStore&lt;/code&gt; 接口，同时需要实现&lt;code&gt;FindClientByIdAsync&lt;/code&gt; 方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ClientStore : IClientStore
{
    public async Task&amp;lt;Client&amp;gt; FindClientByIdAsync(string clientId)
    {
        #region 用户名密码
        var memoryClients = OAuthMemoryData.GetClients();
        if (memoryClients.Any(oo =&amp;gt; oo.ClientId == clientId))
        {
           return memoryClients.FirstOrDefault(oo =&amp;gt; oo.ClientId == clientId);
        }
        #endregion

        #region 通过数据库查询Client 信息
        return GetClient(clientId);
        #endregion
    }

    private Client GetClient(string client)
    {
        //TODO 根据数据库查询
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup&lt;/code&gt; 中&lt;code&gt;ConfigureServices&lt;/code&gt; 代码&lt;code&gt;AddInMemoryClients&lt;/code&gt; 改成&lt;code&gt;AddClientStore&amp;lt;&amp;gt;&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
     services.AddControllers();

     #region 数据库存储方式
     services.AddIdentityServer()
         .AddDeveloperSigningCredential()
         .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
         //.AddInMemoryClients(OAuthMemoryData.GetClients())
         .AddClientStore&amp;lt;ClientStore&amp;gt;()
         .AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;();
    #endregion
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了数据库查询匹配方式也已经改造完了，业务网关服务不需要改动如何代码，运行结果这里就不在运行演示了。Demo 代码已经上传到github 上了，github 源代码地址：&lt;a href=&quot;https://github.com/a312586670/IdentityServerDemo&quot; class=&quot;uri&quot;&gt;https://github.com/a312586670/IdentityServerDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结语：通过IdentityServer4 实现的简单授权中心的思想也就完成了，后续继续学习，有错误地方还请留言指出！感谢！！！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 11 Mar 2020 00:06:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>查阅了大多数相关资料，搜索到的IdentityServer4 的应用博客大多是比较简单并且多是翻译官网的文档编写的，我这里在 Asp.Net Core 中IdentityServer4 的应用分析中以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12447081.html</dc:identifier>
</item>
<item>
<title>Rust入坑指南：智能指针 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/12459458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/12459458.html</guid>
<description>&lt;p&gt;在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。&lt;/p&gt;
&lt;p&gt;智能指针是Rust中一种特殊的数据结构。它与普通指针的本质区别在于普通指针是对值的借用，而智能指针通常拥有对数据的所有权。在Rust中，如果你想要在堆内存中定义一个对象，并不是像Java中那样直接new一个，也不是像C语言中那样需要手动malloc函数来分配内存空间。Rust中使用的是&lt;code&gt;Box::new&lt;/code&gt;来对数据进行封箱，而&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;就是我们今天要介绍的智能指针之一。除了&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;之外，Rust标准库中提供的智能指针还有&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;等等。在详细介绍之前，我们还是先了解一下智能指针的基本概念。&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;我们说Rust的智能指针是一种特殊的数据结构，那么它特殊在哪呢？它与普通数据结构的区别在于智能指针实现了&lt;code&gt;Deref&lt;/code&gt;和&lt;code&gt;Drop&lt;/code&gt;这两个traits。实现&lt;code&gt;Deref&lt;/code&gt;可以使智能指针能够解引用，而实现&lt;code&gt;Drop&lt;/code&gt;则使智能指针具有自动析构的能力。&lt;/p&gt;
&lt;h4 id=&quot;deref&quot;&gt;Deref&lt;/h4&gt;
&lt;p&gt;Deref有一个特性是强制隐式转换：&lt;strong&gt;如果一个类型T实现了Deref&amp;lt;Target=U&amp;gt;，则该类型T的引用在应用的时候会被自动转换为类型U&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::rc::Rc;
fn main() {
    let x = Rc::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, x.chars());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你查看Rc的源码，会发现它并没有实现chars()方法，但我们上面这段代码却可以直接调用，这是因为Rc实现了Deref。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&amp;lt;T: ?Sized&amp;gt; Deref for Rc&amp;lt;T&amp;gt; {
    type Target = T;

    #[inline(always)]
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;T {
        &amp;amp;self.inner().value
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就使得智能指针在使用时被自动解引用，像是不存在一样。&lt;/p&gt;
&lt;p&gt;Deref的内部实现是这样的：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;#[lang = &quot;deref&quot;]
#[doc(alias = &quot;*&quot;)]
#[doc(alias = &quot;&amp;amp;*&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub trait Deref {
    /// The resulting type after dereferencing.
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    type Target: ?Sized;

    /// Dereferences the value.
    #[must_use]
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;Self::Target;
}

#[lang = &quot;deref_mut&quot;]
#[doc(alias = &quot;*&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub trait DerefMut: Deref {
    /// Mutably dereferences the value.
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn deref_mut(&amp;amp;mut self) -&amp;gt; &amp;amp;mut Self::Target;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DerefMut和Deref类似，只不过它是返回可变引用的。&lt;/p&gt;
&lt;h4 id=&quot;drop&quot;&gt;Drop&lt;/h4&gt;
&lt;p&gt;Drop对于智能指针非常重要，它是在智能指针被丢弃时自动执行一些清理工作，这里所说的清理工作并不仅限于释放堆内存，还包括一些释放文件和网络连接等工作。之前我总是把Drop理解成Java中的GC，随着对它的深入了解后，我发现它比GC要强大许多。&lt;/p&gt;
&lt;p&gt;Drop的内部实现是这样的：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;#[lang = &quot;drop&quot;]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub trait Drop {
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn drop(&amp;amp;mut self);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只有一个drop方法，实现了Drop的结构体，在消亡之前，都会调用drop方法。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::ops::Drop;
#[derive(Debug)]
struct S(i32);

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        println!(&quot;drop {}&quot;, self.0);
    }
}

fn main() {
    let x = S(1);
    println!(&quot;create x: {:?}&quot;, x);
    {
        let y = S(2);
        println!(&quot;create y: {:?}&quot;, y);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码的执行结果为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1583204435/Blog/rust/11/rust11-1.png&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到x和y在生命周期结束时都去执行了drop方法。&lt;/p&gt;
&lt;p&gt;对智能指针的基本概念就先介绍到这里，下面我们进入正题，具体来看看每个智能指针都有什么特点吧。&lt;/p&gt;
&lt;h3 id=&quot;box&quot;&gt;Box&lt;/h3&gt;
&lt;p&gt;前面我们已经提到了Box在Rust中是用来在堆内存中保存数据使用的。它的使用方法非常简单：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn main() {
    let x = Box::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, x.chars())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下&lt;code&gt;Box::new&lt;/code&gt;的源码&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[inline(always)]
pub fn new(x: T) -&amp;gt; Box&amp;lt;T&amp;gt; {
  box x
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里只有一个box关键字，这个关键字是用来进行堆内存分配的，它只能在Rust源码内部使用。box关键字会调用Rust内部的exchange_malloc和box_free方法来管理内存。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;#[cfg(not(test))]
#[lang = &quot;exchange_malloc&quot;]
#[inline]
unsafe fn exchange_malloc(size: usize, align: usize) -&amp;gt; *mut u8 {
    if size == 0 {
        align as *mut u8
    } else {
        let layout = Layout::from_size_align_unchecked(size, align);
        let ptr = alloc(layout);
        if !ptr.is_null() {
            ptr
        } else {
            handle_alloc_error(layout)
        }
    }
}

#[cfg_attr(not(test), lang = &quot;box_free&quot;)]
#[inline]
pub(crate) unsafe fn box_free&amp;lt;T: ?Sized&amp;gt;(ptr: Unique&amp;lt;T&amp;gt;) {
    let ptr = ptr.as_ptr();
    let size = size_of_val(&amp;amp;*ptr);
    let align = min_align_of_val(&amp;amp;*ptr);
    // We do not allocate for Box&amp;lt;T&amp;gt; when T is ZST, so deallocation is also not necessary.
    if size != 0 {
        let layout = Layout::from_size_align_unchecked(size, align);
        dealloc(ptr as *mut u8, layout);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rc&quot;&gt;Rc&lt;/h3&gt;
&lt;p&gt;在前面的学习中，我们知道Rust中一个值在同一时间只能有一个变量拥有其所有权，但有时我们可能会需要多个变量拥有所有权，例如在图结构中，两个图可能对同一条边拥有所有权。&lt;/p&gt;
&lt;p&gt;对于这样的情况，Rust为我们提供了智能指针Rc（reference counting）来解决共享所有权的问题。每当我们通过Rc共享一个所有权时，引用计数就会加一。当引用计数为0时，该值才会被析构。&lt;/p&gt;
&lt;p&gt;Rc是单线程引用计数指针，不是线程安全类型。&lt;/p&gt;
&lt;p&gt;我们还是通过一个简单的例子来看一下Rc的应用吧。（示例来自&lt;a href=&quot;https://doc.rust-lang.org/book/ch15-04-rc.html&quot;&gt;the book&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;如果我们想要造一个“双头”的链表，如下图所示，3和4都指向5。我们先来尝试使用Box实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1583289009/Blog/rust/11/rust11-2.svg&quot; alt=&quot;双头链表&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;enum List {
    Cons(i32, Box&amp;lt;List&amp;gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,
                 Box::new(Cons(10,
                               Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码在编译时就会报错，因为a绑定给了b以后就无法再绑定给c了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1583289016/Blog/rust/11/rust11-3.png&quot; alt=&quot;Box无法共享所有权&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;enum List {
    Cons(i32, Rc&amp;lt;List&amp;gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;amp;a));
    let c = Cons(4, Rc::clone(&amp;amp;a));
    println!(&quot;count a {}&quot;, Rc::strong_count(&amp;amp;a));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们可以看到a的引用计数是3，这是因为这里计算的是节点5的引用计数，而a本身也是对5的一次绑定。这种通过clone方法共享所有权的引用称作&lt;strong&gt;强引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Rust还为我们提供了另一种智能指针Weak，你可以把它当作是Rc的另一个版本。它提供的引用属于&lt;strong&gt;弱引用&lt;/strong&gt;。它共享的指针没有所有权。但他可以帮助我们有效的避免循环引用。&lt;/p&gt;
&lt;h3 id=&quot;refcell&quot;&gt;RefCell&lt;/h3&gt;
&lt;p&gt;前文中我们聊过变量的可变性和不可变性，主要是针对变量的。按照前面所讲的，对于结构体来说，我们也只能控制它的整个实例是否可变。实例的具体某个成员是否可变我们是控制不了的。但在实际开发中，这样的场景也是比较常见的。比如我们有一个User结构体：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;struct User {
    id: i32,
    name: str,
    age: u8,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常情况下，我们只能修改一个人的名称或者年龄，而不能修改用户的id。如果我们把User的实例设置成了可变状态，那就不能保证别人不会去修改id。&lt;/p&gt;
&lt;p&gt;为了应对这种情况，Rust为我们提供了&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;。它们本质上不属于智能指针，而是可以提供内部可变性的容器。内部可变性实际上是一种设计模式，它的内部是通过一些&lt;code&gt;unsafe&lt;/code&gt;代码来实现的。&lt;/p&gt;
&lt;p&gt;我们先来看一下&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;的使用方法吧。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::cell::Cell;
struct Foo {
    x: u32,
    y: Cell&amp;lt;u32&amp;gt;,
}

fn main() {
    let foo = Foo { x: 1, y: Cell::new(3)};
    assert_eq!(1, foo.x);
    assert_eq!(3, foo.y.get());
    foo.y.set(5);
    assert_eq!(5, foo.y.get());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用Cell的set/get方法来设置/获取起内部的值。这有点像我们在Java实体类中的setter/getter方法。这里有一点需要注意：&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;中包裹的T必须要实现Copy才能够使用get方法，如果没有实现Copy，则需要使用Cell提供的get_mut方法来返回可变借用，而set方法在任何情况下都可以使用。由此可见Cell并没有违反借用规则。&lt;/p&gt;
&lt;p&gt;对于没有实现Copy的类型，使用&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;还是比较不方便的，还好Rust还提供了&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;。话不多说，我们直接来看代码。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;use std::cell::RefCell;
fn main() {
    let x = RefCell::new(vec![1, 2, 3]);
    println!(&quot;{:?}&quot;, x.borrow());
    x.borrow_mut().push(5);
    println!(&quot;{:?}&quot;, x.borrow());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面这段代码中我们可以观察到&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;的borrow_mut和borrow方法对应了&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;中的set和get方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;还有一点区别是：&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;没有运行时开销（不过也不要用它包裹大的数据结构），而&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;是有运行时开销的，这是因为使用&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;时需要维护一个借用检查器，如果违反借用规则，则会引起线程恐慌。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;关于智能指针我们就先介绍这么多，现在我们简单总结一下。Rust的智能指针为我们提供了很多有用的功能，智能指针的一个特点就是实现了&lt;code&gt;Drop&lt;/code&gt;和&lt;code&gt;Deref&lt;/code&gt;这两个trait。其中&lt;code&gt;Drop&lt;/code&gt;trait中提供了drop方法，在析构时会去调用。&lt;code&gt;Deref&lt;/code&gt;trait提供了自动解引用的能力，让我们在使用智能指针的时候不需要再手动解引用了。&lt;/p&gt;
&lt;p&gt;接着我们分别介绍了几种常见的智能指针。&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;可以帮助我们在堆内存中分配值，&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;为我们提供了多次借用的能力。&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;使内部可变性成为现实。&lt;/p&gt;
&lt;p&gt;最后再多说一点，其实我们以前见到过的&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Vec&lt;/code&gt;也属于智能指针。&lt;/p&gt;
&lt;p&gt;至于它们为什么属于智能指针，Rust又提供了哪些其他的智能指针呢？这里就留个坑吧，感兴趣的同学可以自己踩一下。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Mar 2020 14:52:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>在了解了Rust中的所有权、所有权借用、生命周期这些概念后，相信各位坑友对Rust已经有了比较深刻的认识了，今天又是一个连环坑，我们一起来把智能指针刨出来，一探究竟。 智能指针是Rust中一种特殊的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/12459458.html</dc:identifier>
</item>
<item>
<title>机器学习 - LSTM应用之sequence generation - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12459428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12459428.html</guid>
<description>&lt;p&gt;LSTM在机器学习上面的应用是非常广泛的，从股票分析，机器翻译 到 语义分析等等各个方面都有它的用武之地，经过前面的对于LSTM结构的分析，这一节主要介绍一些LSTM的一个小应用，那就是sequence generation。其实sequence generation本事也是对一些应用的统称，例如: 让机器学习音乐后然后让机器根据学习的模型自己创造音乐（制作人快要失业啦。。。。），让机器学习某种语言然后让这个学习到的模型自己产生Word来说话，等等。这其实本质是一种one-to-many的LSTM网络结构。这一节内容主要就是讲解这一种网络结构的应用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sequence generation的网络结构分析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在咱们实际实施并且写代码之前，咱们首要的任务是如何搭建一个sequence generation的网络结构。一个sequence generation的网络结构其实也是分为两个部分，第一部分是encoding （modeling），也就是咱们建模的网络，它是一个many-to-many的网络结构；第二部分是decoding的过程，它是一个one-to-many的结构。那么具体这个网络结构是什么样呢？咱们看看下面的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1287224/202003/1287224-20200310153916939-960784669.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的图片展示的就是一个sequence generation从encoding到decoding的全过程和结构。在咱们的这个应用中，咱们的encoding中每一个time step的输入是一个文字，输出则是相应输入的后一个字，这些数据都来自于咱们的training data；等到咱们训练完成后，咱们将训练得来的LSTM cell来构建一个decoding网络，就是咱们只输入一个单词，它根据咱们的之前学习的model，来自动的预测咱们要说什么话，是不是很cool？？当然啦，在encoding阶段，咱们的LSTM具体有多少的time steps,是根据咱们的input data的shape来决定的；在decoding阶段具体有多少的time step则是由咱们自己来决定的, 咱们需要用一个for loop来决定咱们在decoding阶段的time steps。从上图，咱们也可以很明显的看出在decoding的时候，咱们只有一个输入X，后面time step的输入则都是前一个time step的输出。上面就是怎么sequence generation的一个整体的结构。那么就下来，咱们就分析一些它的代码，看看咱们如何用代码来实现上面的网络结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sequence generation 代码分析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;从上面的分析，咱们可以看出sequence generation是由两个部分组成，那么自然咱们代码也肯定得分成两部分来实现上图中的网络结构，那么接下来咱们来看看第一步，就是如何用Python来实现encoding的结构，代码如下所示，咱们看着代码来慢慢分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
#define shared variables&lt;br/&gt;n_a=64&lt;span&gt;
n_values = 78 # dimensions of out single input 
reshapor = keras.layers.Reshape((1, n_values))                  # Used in Step 2.B of djmodel(), below
LSTM_cell = keras.layers.LSTM(n_a, return_state = True)         # Used in Step 2.C, return_state muset be set 
densor = keras.layers.Dense(n_values, activation='softmax')     # Used in Step 2.D
&lt;br/&gt;#multiple inputs (X, a, c), we have to use functional Keras, other than sequential APIs
def&lt;span&gt; create_model(Tx, n_a, n_values):
    &quot;&quot;&quot;
    Implement the model
    
    Arguments:
    Tx -- length of the sequence in a corpus
    n_a -- the number of activations used in our model
    n_values -- number of unique values in the music data 
    
    Returns:
    model -- a keras instance model with n_a activations
    &quot;&quot;&quot;
    
    # Define the input layer and specify the shape
    X = keras.Input(shape=(Tx, n_values))#input omit the batch_size dimension,  X is still 3 dimensiones (with batch_size dimension).
    
    # Define the initial hidden state a0 and initial cell state c0
    a0 = keras.Input(shape=(n_a,), name='a0'&lt;span&gt;)
    c0 = keras.Input(shape=(n_a,), name='c0'&lt;span&gt;)
    a =&lt;span&gt; a0
    c =&lt;span&gt; c0
    

    # Step 1: Create empty list to append the outputs while you iterate 
    outputs =&lt;span&gt; []
    
    # Step 2: Loop
    for t in&lt;span&gt; range(Tx):
        
        # Step 2.A: select the &quot;t&quot;th time step vector from X. 
        x = keras.layers.Lambda(lambda&lt;span&gt; x: X[:,t,:])(X)
        # Step 2.B: Use reshapor to reshape x to be (1, n_values) (≈1 line)
        #因为LSTM layer默认的输入的dimension是 (batch_size, Tx, n_values)，其中batch_size是省略的， 即是（Tx, n_values）。如果是（Tx,n_values）的话，LSTM()会默认循环Tx次，因而，咱们将它reshape成（1，n_values）,它就不会循环了。
        x =&lt;span&gt;  reshapor(x)
        # Step 2.C: Perform one step of the LSTM_cell
        a, _, c = LSTM_cell(x, initial_state=&lt;span&gt;[a,c])
        # Step 2.D: Apply densor to the hidden state output of LSTM_Cell
        out =&lt;span&gt; densor(a) #out's shape is (m,1,n_values)
        # Step 2.E: add the output to &quot;outputs&quot;
&lt;span&gt;        outputs.append(out)
        
    # Step 3: Create model instance
    model = keras.Model(inputs=[X,a0,c0],outputs=&lt;span&gt;outputs)

    return model&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码，咱们可以看出，首先咱们得定义一些shared variable，例如a, c的dimension， LSTM_cell， 等等这些，这些变量在咱们的model中无论是encoding还是decoding都是公用的，并不是说一个LSTM layer就含有很多个LSTM_cell，这是错误的理解（虽然咱们图片上面是这么画的，但这是为了方便大家理解才画了很多个LSTM_cell，实际是同一个LSTM_cell， 希望不要误解）。首先咱们构建这个网络需要的参数有，Tx = time_steps； n_a = a，c的vector的dimension；以及n_values = 咱们每一个输入的vector的dimension。因为咱们的网络有三处输入，分别是X, a, c, 所以咱们要先定义这三处输入，并且设定它们的shape， 注意在设定它们的shape的时候，是不需要有batch_size的；随后咱们来到for loop中，首先提取每一个time step的input value， 即上面代码中Lambda layer所做的事儿，然后因为咱们提取的是每一个time step的值，每一个time step， LSTM只会循环一次，所以咱们还是得把它reshape到（1，n_values）; 随后咱们将处理好的input value传递给LSTM_cell，并且返回hidden state a, 和memory cell c, 最后经过一个dense layer计算咱们的输出，并且将每一步的输出装进outputs这个list中。这就是构建咱们的encoding网络的整个步骤。那么既然咱们分析了上面encoding的阶段，完成了对咱们LSTM的训练过程并且得到了咱们想要的LSTM, 那么接下来咱们看一看咱们的decoding过程，即如何用训练得到的LSTM来generate（predict）咱们的sequence啦，咱们还是看下面的代码，然后慢慢分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
def sequence_inference_model(LSTM_cell, n_values = 78, n_a = 64, Ty = 100&lt;span&gt;):
    &quot;&quot;&quot;
    Uses the trained &quot;LSTM_cell&quot; and &quot;densor&quot; from model() to generate a sequence of values.
    
    Arguments:
    LSTM_cell -- the trained &quot;LSTM_cell&quot; from model(), Keras layer object
    densor -- the trained &quot;densor&quot; from model(), Keras layer object
    n_values -- integer, number of unique values
    n_a -- number of units in the LSTM_cell
    Ty -- integer, number of time steps to generate
    
    Returns:
    inference_model -- Keras model instance
    &quot;&quot;&quot;
    
    # Define the input of your model with a shape (it is a one-to-many structure, the input shape is (1,n_values))
    x0 = keras.Input(shape=(1&lt;span&gt;, n_values))
    
    # Define a0, c0, initial hidden state for the decoder LSTM
    a0 = keras.Input(shape=(n_a,), name='a0'&lt;span&gt;)
    c0 = keras.Input(shape=(n_a,), name='c0'&lt;span&gt;)
    a =&lt;span&gt; a0
    c =&lt;span&gt; c0
    x =&lt;span&gt; x0

    # Step 1: Create an empty list of &quot;outputs&quot; to later store your predicted values (≈1 line)
    outputs =&lt;span&gt; []
    
    # Step 2: Loop over Ty and generate a value at every time step
    for t in&lt;span&gt; range(Ty):
        
        # Step 2.A: Perform one step of LSTM_cell 
        a, _, c = LSTM_cell(x, initial_state=&lt;span&gt;[a, c])
        
        # Step 2.B: Apply Dense layer to the hidden state output of the LSTM_cell
        out =&lt;span&gt; densor(a)

        # Step 2.C: Append the prediction &quot;out&quot; to &quot;outputs&quot;. out.shape = (None, 78) 
&lt;span&gt;        outputs.append(out)
        
        # Step 2.D: Select the next value according to &quot;out&quot;, and set &quot;x&quot; to be the one-hot representation of the
        #           selected value, which will be passed as the input to LSTM_cell on the next step. We have provided 
        #           the line of code you need to do this. 
        x =&lt;span&gt; keras.layers.Lambda(one_hot)(out)
        
    # Step 3: Create model instance with the correct &quot;inputs&quot; and &quot;outputs&quot;
    inference_model = keras.Model(inputs=[x0, a0, c0], outputs=&lt;span&gt;outputs)
   
    return inference_model&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;inference_model = sequence_inference_model(LSTM_cell, densor, n_values = 78, n_a = 64, Ty = 50)&lt;br/&gt;inference_model.summary()&lt;/p&gt;
&lt;p&gt;x_initializer = np.zeros((1, 1, 78))&lt;br/&gt;a_initializer = np.zeros((1, n_a))&lt;br/&gt;c_initializer = np.zeros((1, n_a))&lt;/p&gt;
&lt;p&gt;pred = inference_model.predict([x_initializer, a_initializer, c_initializer])&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个inference model就是根据上面的训练来的LSTM来predict的，它共用了上面训练得来的的LSTM中的参数weights 和bias， 根据输入的一个词x0来预测后面来输出哪些值，具体输出多少个值也是根据用户设定的Ty来决定，当然啦，咱们还可以更加精细化的管理咱们的输出，例如如果遇到EOS，咱们直接停止输出。咱们即使有了前面的LSTM，但是因为结构的不同，咱们还是得先去构建一个新的inference model，即重新要搭建一个decoding的结构。从decoding的结构咱们可以看出来，咱们的输入还是有三个，即x0,a0,c0。这里有比encoding简单的地方就是咱们不需要再去reshape那么的输入了，咱们的输入都是标准的shape，即分别是（batch_size, Tx, n_values）, (batch_size, n_a), (batch_size, n_a)，咱们直接输入进去并且输入到Lstm和densor中就可以，不需要进行一些shape方面的配置了，其次这里有一点个encoding不一样的，就是需要将每一个time step的输出当做下个time step的输入， 即上面代码中的x=tf.keras.Lambda(one_hot)(out)。 因为这是一个inference model，所以咱们也不需要重新fitting啦，可以直接调用它的predict方法就可以predict啦。&lt;/p&gt;
&lt;p&gt;对于sequence generation相关的应用呢，咱们首先要在脑海中找到这个pattern，即它是有2部分组成的，一个encoding，一个decoding；然后用encoding来训练模型，用decoding来predict模型。对于输入的input layer，一定要注意并且理解他们input data的shape，一定要一致性；对于一起share的变量一定要理解，例如LSTM_cell, densor 等，他们都是构成这个LSTM模型的最基本的但愿，都是share的，并不是每一个time step都有独立的entity。如果对于以上的步骤和内容都理解的话，对于sequence generation相关的应用就都可以套用上面的模式进行实现，唯一需要改动的就是一下dimension值。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Mar 2020 14:47:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>概述 LSTM在机器学习上面的应用是非常广泛的，从股票分析，机器翻译 到 语义分析等等各个方面都有它的用武之地，经过前面的对于LSTM结构的分析，这一节主要介绍一些LSTM的一个小应用，那就是sequ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12459428.html</dc:identifier>
</item>
<item>
<title>基于Modelsim的直方图统计算法仿真 - TheSkyIsMine</title>
<link>http://www.cnblogs.com/huangwei0521/p/12459289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangwei0521/p/12459289.html</guid>
<description>&lt;p&gt;　　　　本篇主要针对牟新刚编著《基于FPGA的数字图像处理及应用》第六章第五节中直方图统计相关类容进行总结，包括代码实现及&lt;/p&gt;
&lt;p&gt;基于Modelsim的仿真。书读百遍，其意自现。　2020-03-09 22:16:07&lt;/p&gt;

&lt;p&gt;　　设计难点：&lt;/p&gt;
&lt;p&gt;　　　　（1）统计工作至少要等到当前图像“流过”之后才能完成。&lt;span&gt;此限制决定了我们不可能对统计工作进行流水统计和输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　（2）必须对前期的统计结果进行缓存。&lt;/p&gt;
&lt;p&gt;　　　　（3）在下一次统计前需要将缓存结果清零。&lt;/p&gt;
&lt;p&gt;　　在直方图统计中，我们一般选择片内双口RAM作为缓存存储器。对于8位的深度图来说，统计结果的数据量并不大，因此选择片内&lt;/p&gt;
&lt;p&gt;RAM。此外，一方面统计模块需要与其他时序进行配合，因此需提供双边读写接口；另一方面，统计过程中需要地址信息，因此选择&lt;/p&gt;
&lt;p&gt;RAM形式的存储器。接下来的工作就是确定双口RAM的参数，主要包括数据位宽及地址位宽。假定输入图像宽度为IW，高度为IH，数据&lt;/p&gt;
&lt;p&gt;位宽度为DW。那么待统计的像素总数为Pixel&lt;sub&gt;Total&lt;/sub&gt; = IW * IH，像素灰度值的理论最大值为Pixel&lt;sub&gt;Max&lt;/sub&gt;=2&lt;sup&gt;DW&lt;/sup&gt;-1。&lt;/p&gt;
&lt;p&gt;　　双口RAM的统计地址输入端为输入像素值，很明显，这个数据范围为0~2&lt;sup&gt;DW&lt;/sup&gt;-1，因此RAM的地址位宽最少为DW，即 AW&lt;sub&gt;DPRAM&lt;/sub&gt; ≥ DW。&lt;/p&gt;
&lt;p&gt;　　双口RAM的数据输出端为输入统计值，很明显，这个数据范围为0~Pixel&lt;sub&gt;Total，&lt;/sub&gt;因此RAM的地址位宽最少为log&lt;sub&gt;2&lt;/sub&gt;(Pixel&lt;sub&gt;Total&lt;/sub&gt;)。即DW&lt;sub&gt;DPRAM&lt;/sub&gt; ≥ log&lt;sub&gt;2&lt;/sub&gt;(Pixel&lt;sub&gt;Total&lt;/sub&gt;)。&lt;/p&gt;
&lt;p&gt;　　例如要对图像分辨率为640 x 512位宽为8位的图像进行直方图统计，则有&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　AW&lt;sub&gt;DPRAM&lt;/sub&gt; ≥ 8&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　DW&lt;sub&gt;DPRAM&lt;/sub&gt; ≥ log&lt;sub&gt;2&lt;/sub&gt;(Pixel&lt;sub&gt;Total&lt;/sub&gt;) = log&lt;sub&gt;2&lt;/sub&gt;(640x512) ≈19。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;通常情况下会将两个参数取为2的整次幂，即AW&lt;sub&gt;DPRAM&lt;/sub&gt; = 8&lt;/strong&gt;， &lt;strong&gt;DW&lt;sub&gt;DPRAM&lt;/sub&gt; =32。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　直方图统计步骤如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　（1）将当前统计值读出，加1后重新写入RAM。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　（2）重复以上步骤，直至当前图像统计完毕。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　（3）在下一副图像到来之前将结果读出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　（4）读出之后对RAM内容进行清零。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　因此如下图所示，要完成直方图统计，需要至少设计三个电路：统计电路，读出电路，读出电路和清零电路。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1230100/202003/1230100-20200309225154405-1078073768.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;1.统计电路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在实际的图像中，连续的像素点灰度值为相同值的情况非常常见，如果每来一个像素都对双口RAM进行一次寻址和写操作，&lt;/span&gt;&lt;span&gt;&lt;span&gt;显然降低了统计效率而提高了功耗&lt;/span&gt;。书中给出了一种优化的统计方法：采用一个相同灰度值计数器进行优化，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;　　（1）DPRAM：存放统计结果。分为A口和B口，&lt;span&gt;A口负责统计结果写入，不输出。B口负责统计结果读出和清零，无输入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;（2）CNT: 相同像素计数器。负责对连续相同灰度值的像素进行计数，&lt;span&gt;复位值为1&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（3）ADD(+)：统计值加法器。对当前统计值和新的统计值进行加法运算，重新写入RAM。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（4）B_ADDR MUX： B口地址mux，很明显，B口在统计阶段需要完成读出前一个统计值和清零的分时操作。因此需要一个mux对读出地址和清零地址进行选通。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（5）reg：将输入数据打两拍以确保读出的是当前的统计值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;统计原理如下：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;当前灰度值的统计值由B口读出，与相同灰度值计数器进行相加后重新写入RAM。CNT会不断检测当前像素和前一个像素是否一致，若不一致，则重置为1，实现统计值加1目的；若一致，则计数器加1，直到不一致之后将一致的总数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;写入RAM，&lt;strong&gt;&lt;span&gt;并在每一行图像的最后一个像素统一执行一次写入操作（没明白啥意思）&lt;/span&gt;&lt;/strong&gt;，这样大大减少读写RAM操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　下面几个关键信号的设计电路来说明统计电路的工作原理。首先将输入信号din，输入有效dvalid打两拍，分别为din_r,din_r2及dvalid_r,dvalid_r2。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（1）inc_en&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　此信号负责递增计数器的递增使能。当前待统计数据din_r2有效，且与前一个已经统计完成的数据din_r相同时，将递增计数器加1。否则计数器会复位到1。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（2）rst_cnt&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　此信号为递增计数器的复位信号。除了当前待统计灰度值与上一个统计过的灰度值不同的情况下会复位计数器，第一个有效数据到来时也会复位递增计数器，为新的一轮统计工作做准备。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（3）we_a&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　此信号为DPRAM写入信号，也是分为两种情况：若当前待统计灰度值与之前待统计值不同。则直接写入RAM。否则，就一直累加到数据无效时统一写入RAM。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（4）count_en&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　此信号为统计使能，很明显，在统计阶段此信号需要一直保持有效，统计完成后（也即当前图像遍历完毕），在读出和清零阶段，需要将此信号失能，这是由于B口在此阶段需要读出和清零地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   此信号的产生可以通过对图像进行行计数来实现，当到达一副图像的高度时，失能信号。新的行同步到来时使能信号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2.读出电路设计&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　 &lt;/strong&gt; 首先书中统计读出方法是顺序读出，即灰度值为0的统计值首先读出，其次是灰度值为1的统计值，最后是灰度值为255的统计值输出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　  读出和清零操作并不一定是在统计完成之后立即进行的，可以根据需要由外部时序控制，输入读出请求。当然在统计阶段，模块是不允许读出的，此时读出电路处于复位状态。在读出阶段，需设计&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;读出像素计数器对读出时序进行控制。&lt;/p&gt;
&lt;p&gt;　　  只有当计数完成，并且外部时序申请读出时，输出地址才会进行递增。否则会被钳位到0。当一次读出完成之后此地址发生器复位，也就是count_en会重新使能，直到下一次统计完成。&lt;/p&gt;
&lt;p&gt;　   &lt;strong&gt;3.清零电路设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt; 书中给出反相清零的方法，即在读出时钟的下一个时钟进行清零。因此每个像素的统计数据输出和清零操作均需占用1个时钟，&lt;strong&gt;&lt;span&gt;奇数时钟输出，偶数时钟清零&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　代码的部分参照书中的代码实现，并与前面灰度图像生成代码进行整合编译仿真。&lt;span&gt;唯一需要特别注意的是在实例化DPRAM IP核时，输出端口切记不要缓存（添加寄存器输出）&lt;/span&gt;。相应整理后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
`timescale 1ps/&lt;span&gt;1ps

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============================================================================&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FileName: histogram_2d.v
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Date: 2020-02-29
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============================================================================&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
module histogram_2d(
    rst_n,
    clk,
    din_valid,            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入有效&lt;/span&gt;
    din,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入待统计的数据&lt;/span&gt;
    dout,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计输出&lt;/span&gt;
    vsync,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场同步&lt;/span&gt;
    dout_valid,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出有效&lt;/span&gt;
    int_flag,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断输出&lt;/span&gt;
    rdyOutput,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据读出请求&lt;/span&gt;
    dout_clk            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据输出时钟    &lt;/span&gt;
&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块入口参数&lt;/span&gt;
    parameter DW = &lt;span&gt;14&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据位宽&lt;/span&gt;
    parameter IH = &lt;span&gt;512&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图像高度&lt;/span&gt;
    parameter IW = &lt;span&gt;640&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图像宽度&lt;/span&gt;
    parameter TW = &lt;span&gt;32&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图统计数据位宽&lt;/span&gt;
&lt;span&gt;    
    localparam TOTAL_CNT &lt;/span&gt;= IW * IH;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;像素总数&lt;/span&gt;
    localparam HALF_WIDTH = (TW &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将32位的数据位宽拆分为高低16位
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入输出声明&lt;/span&gt;
&lt;span&gt;    input rst_n;
    input clk;
    input din_valid;
    input [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] din;
    input rdyOutput;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output wire [HALF_WIDTH:0] dout;&lt;/span&gt;
&lt;span&gt;    
    output wire [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] dout;
    
    input vsync;
    output reg dout_valid;
    output reg int_flag;
    output dout_clk;
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量声明&lt;/span&gt;
&lt;span&gt;    reg vsync_r;
    reg dvalid_r;
    reg dvalid_r2;
    reg [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] din_r;
    reg [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] din_r2;
    
    wire hsync_fall;
    wire hsync_rise;
    
    reg [&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] hsync_count;
    reg count_en;
    wire [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] mux_addr_b;
    wire [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] mux_addr_b2;
    
    wire [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] q_a;
    wire [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] q_b;
    reg [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] counter;
    
    wire [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] count_value;
    wire rst_cnt;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计计数器复位信号&lt;/span&gt;
    wire inc_en;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递增使能信号
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DPRAM 信号&lt;/span&gt;
&lt;span&gt;    wire we_a;
    wire we_b;
    wire we_b_l;
    reg  we_b_h;
    
    wire [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] addr_a;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断寄存器&lt;/span&gt;
&lt;span&gt;    reg int_r;
    wire [DW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;] clr_addr;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清零地址&lt;/span&gt;
    reg [DW-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] clr_addr_r;
    reg [DW:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] out_pixel;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出计数&lt;/span&gt;
&lt;span&gt;    
    reg count_all;                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计完成信号
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reg count_en_r;&lt;/span&gt;
&lt;span&gt;    reg count_en_r;
    
    reg [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;] hist_cnt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图统计累加寄存器&lt;/span&gt;
    wire rstOutput;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出电路复位信号&lt;/span&gt;
&lt;span&gt;    
    wire [TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] dataTmp2;
    wire clr_flag;                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局清零
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将输入数据打两拍&lt;/span&gt;
&lt;span&gt;    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((~(rst_n))) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;        begin
            vsync_r     &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
            dvalid_r     &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
            dvalid_r2     &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
            din_r        &amp;lt;= #&lt;span&gt;1&lt;/span&gt; {DW{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};&lt;/span&gt;
            din_r2        &amp;lt;= #&lt;span&gt;1&lt;/span&gt; {DW{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};&lt;/span&gt;
&lt;span&gt;        end
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        begin
            vsync_r        &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; vsync;
            dvalid_r    &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; din_valid;
            dvalid_r2    &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; dvalid_r;
            din_r        &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; din;
            din_r2        &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; din_r;
        end    
    end
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入行同步计数，确定统计的开始和结束时刻&lt;/span&gt;
    assign #&lt;span&gt;1&lt;/span&gt; hsync_fall = dvalid_r &amp;amp; (~&lt;span&gt;(din_valid));
    assign #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; hsync_rise = (~(dvalid_r)) &amp;amp;&lt;span&gt; din_valid;
    
    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((~(rst_n))) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            hsync_count &amp;lt;= #&lt;span&gt;1&lt;/span&gt; {&lt;span&gt;10&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        begin
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vsync_r == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
                hsync_count &amp;lt;= #&lt;span&gt;1&lt;/span&gt; {&lt;span&gt;10&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(hsync_fall == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
                hsync_count &amp;lt;= hsync_count + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
&lt;span&gt;        end
    end
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一帧图像结束后停止统计 下一帧图像到来时开始计数&lt;/span&gt;
&lt;span&gt;    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((~(rst_n))) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            count_en &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
        begin
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(hsync_count &amp;gt;=&lt;span&gt; IH)
                count_en &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(hsync_rise == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
                count_en &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                count_en &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; count_en;
        end
    end
    
    assign mux_addr_b     &lt;/span&gt;= ((count_en == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)) ? din_r : clr_addr;&lt;/span&gt;
    assign mux_addr_b2     = ((count_en == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)) ? din_r : clr_addr_r;&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计递增计数器&lt;/span&gt;
&lt;span&gt;    always@(posedge clk)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rst_cnt == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            counter &amp;lt;= #&lt;span&gt;1&lt;/span&gt; {{TW-&lt;span&gt;1&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}},1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b1}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复位值为1&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(inc_en == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            counter &amp;lt;= #&lt;span&gt;1&lt;/span&gt; counter + {{TW-&lt;span&gt;1&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}},1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1};
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            counter &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; counter;
    end
    
    assign #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; rst_cnt = ((din_r != din_r2) | ((dvalid_r2 == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1) &amp;amp; (dvalid_r == 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b0))) ? &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1 : 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;
    assign #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; inc_en = (((din_r == din_r2) &amp;amp; (dvalid_r2 == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1))) ? 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b1 : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
    assign #&lt;span&gt;1&lt;/span&gt; we_a = ((((din_r != din_r2) &amp;amp; (dvalid_r2 == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)) |((dvalid_r2 == 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b1) &amp;amp; (dvalid_r == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0)))) ? 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b1 : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
    assign #&lt;span&gt;1&lt;/span&gt; count_value = ((count_en == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)) ? counter+q_b : {TW{1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};
    assign #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; addr_a =&lt;span&gt; din_r2;
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图存储器 分高16位和低16位分别存储&lt;/span&gt;
&lt;span&gt;    hist_buffer dpram_bin_l(
        .address_a(addr_a),                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入地址为像素灰度值&lt;/span&gt;
        .address_b(mux_addr_b),                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出和清零地址&lt;/span&gt;
        .clock(clk),                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步时钟&lt;/span&gt;
        .data_a(count_value[HALF_WIDTH-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;]),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前计数值&lt;/span&gt;
        .data_b({HALF_WIDTH{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}}),            //清零数据&lt;/span&gt;
&lt;span&gt;        .wren_a(we_a),
        .wren_b(we_b_l),
        .q_a(q_a[HALF_WIDTH&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]),
        .q_b(q_b[HALF_WIDTH&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])    
    );
    

    hist_buffer dpram_bin_h(
        .address_a(addr_a),
        .address_b(mux_addr_b2),
        .clock(clk),
        .data_a(count_value[TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:HALF_WIDTH]),
        .data_b({HALF_WIDTH{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}}),&lt;/span&gt;
&lt;span&gt;        .wren_a(we_a),
        .wren_b(we_b_h),
        .q_a(q_a[TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:HALF_WIDTH]),
        .q_b(q_b[TW&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:HALF_WIDTH])
    );
    
    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((~(rst_n))) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            count_en_r &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
            count_en_r &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; count_en;
    end
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出电路逻辑，计数时不能输出，读出请求时才输出&lt;/span&gt;
    assign rstOutput = count_en_r | (~&lt;span&gt;(rdyOutput));
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出像素计数&lt;/span&gt;
&lt;span&gt;    always@(posedge clk)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rstOutput == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            out_pixel &amp;lt;= {DW+&lt;span&gt;1&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}};&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; begin
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((~count_all) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;            begin
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(out_pixel == (((&lt;span&gt;2&lt;/span&gt; ** (DW + &lt;span&gt;1&lt;/span&gt;)) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)))
                    out_pixel &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; {DW+&lt;span&gt;1&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0}}; //输出完毕&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    out_pixel &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; out_pixel + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
&lt;span&gt;            end
        end
    end
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计结束信号&lt;/span&gt;
&lt;span&gt;    always@(posedge clk)begin
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;count_all_r &amp;lt;= (~rstOutput);&lt;/span&gt;
        we_b_h &amp;lt;=&lt;span&gt; we_b_l;
        clr_addr_r &lt;/span&gt;&amp;lt;=&lt;span&gt; clr_addr;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(out_pixel == (((&lt;span&gt;2&lt;/span&gt; ** (DW + &lt;span&gt;1&lt;/span&gt;)) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)))
            count_all &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(count_en == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
            count_all &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;    end
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局清零信号&lt;/span&gt;
    assign clr_flag =&lt;span&gt; vsync;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断输出 信号读出操作完成&lt;/span&gt;
&lt;span&gt;    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((~(rst_n)) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;        begin
            int_flag     &lt;/span&gt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
            int_r         &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
&lt;span&gt;        end
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        begin
            int_flag &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; int_r;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(clr_flag == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
                int_r &amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(out_pixel &amp;gt;= (((&lt;span&gt;2&lt;/span&gt; ** (DW + &lt;span&gt;1&lt;/span&gt;)) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)))
                int_r &lt;/span&gt;&amp;lt;= #&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;        end
    end
    
    assign we_b_l &lt;/span&gt;= (((out_pixel[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1) &amp;amp; (count_all == 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;b0))) ? &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1 : 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清零地址，与读出地址反相&lt;/span&gt;
    assign clr_addr = out_pixel[DW:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    
    wire dout_valid_temp;
    
    wire [HALF_WIDTH&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] dout_temp;
    
    always@(posedge clk or negedge rst_n)begin
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((~(rst_n)) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;        begin
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dout &amp;lt;= {HALF_WIDTH{1'b0}};&lt;/span&gt;
            dout_valid &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;        end
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        begin
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dout &amp;lt;= #1 dout_temp;&lt;/span&gt;
            dout_valid &amp;lt;= #&lt;span&gt;1&lt;/span&gt;&lt;span&gt; dout_valid_temp;
        end
    end
    
    assign dout_temp &lt;/span&gt;= (we_b_l == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1) ? q_b[HALF_WIDTH-1:0] : q_b[TW-1:HALF_WIDTH];&lt;/span&gt;
&lt;span&gt;    
    assign dout_valid_temp &lt;/span&gt;= we_b_h | we_b_l; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出使能&lt;/span&gt;
&lt;span&gt;    
    assign dout_clk &lt;/span&gt;= (dout_valid) ? we_b_h : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;    
    assign dout &lt;/span&gt;=&lt;span&gt; q_b;
    
endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　顶层代码设计如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; `timescale 1ps/&lt;span&gt;1ps
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================================================================================&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FileName: histogram.v
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Date: 2020-03-02
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;===========================================================================================&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;module histogram(
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     RSTn,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局复位&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;     CLOCK,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统时钟&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     
&lt;span&gt; 13&lt;/span&gt;     IMG_CLK,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;像素时钟&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;     IMG_DVD,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;像素值&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     IMG_DVSYN,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场信号&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     IMG_DHSYN,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入数据有效信号&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     HIST_DAT,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出直方图统计数据&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     HIST_VALID,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出直方图统计有效&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     HIST_RDY,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据读出请求&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     HIST_INT,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据中断输出&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     HIST_CLK            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据输出时钟&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;image parameter&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;     parameter iw             = &lt;span&gt;640&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image width&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     parameter ih            = &lt;span&gt;512&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image height&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     parameter trig_value    = &lt;span&gt;400&lt;/span&gt;;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     parameter tw            = &lt;span&gt;32&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图统计数据位宽&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     
&lt;span&gt; 31&lt;/span&gt;     localparam half_width    = (tw &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将32位的数据位宽拆分为高低16位&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;data width&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     parameter dvd_dw     = &lt;span&gt;8&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image source data width&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     parameter dvd_chn    = &lt;span&gt;3&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;channel of the dvd data: when 3 it's rgb or 4:4:YCbCr&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     parameter local_dw    = dvd_dw * dvd_chn;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;local algorithem process data width&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;     parameter cmd_dw    = dvd_dw * dvd_chn;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;local algorithem process data width
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Port Declared&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    input RSTn;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    input CLOCK;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    input IMG_CLK;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     input [dvd_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] IMG_DVD;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    input IMG_DVSYN;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    input IMG_DHSYN;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     output [tw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] HIST_DAT;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    output HIST_VALID;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    input HIST_RDY;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    output HIST_INT;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    output HIST_CLK;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Variable Declared&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    wire GRAY_CLK;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    wire GRAY_VSYNC;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    wire GRAY_DVALID;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     wire [dvd_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] Y_DAT;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     wire [dvd_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] Cb_DAT;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     wire [dvd_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] Cr_DAT;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     
&lt;span&gt; 60&lt;/span&gt;     wire [local_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] RGB_DAT;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    wire RGB_DVALID;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    wire RGB_VSYNC;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    video_cap video_cap_inst(
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             .reset_l(RSTn),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步复位信号&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;             .DVD(IMG_DVD),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入视频流&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;             .DVSYN(IMG_DVSYN),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场同步信号&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;             .DHSYN(IMG_DHSYN),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入行同步&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             .DVCLK(IMG_CLK),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入DV时钟&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;             .cap_dat(RGB_DAT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出RGB通道像素流，24位&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;             .cap_dvalid(RGB_DVALID),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数据有效&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;             .cap_vsync(RGB_VSYNC),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出场同步&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;             .cap_clk(CLOCK),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地逻辑时钟&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            .img_en(),                
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             .cmd_rdy(),                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令行准备好，代表可以读取&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;             .cmd_rdat(),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令行数据输出&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;             .cmd_rdreq()                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令行读取请求&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     
&lt;span&gt; 80&lt;/span&gt;     defparam video_cap_inst.DW_DVD         =&lt;span&gt; dvd_dw;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     defparam video_cap_inst.DW_LOCAL     =&lt;span&gt; local_dw;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     defparam video_cap_inst.DW_CMD         =&lt;span&gt; cmd_dw;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     defparam video_cap_inst.DVD_CHN     =&lt;span&gt; dvd_chn;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     defparam video_cap_inst.TRIG_VALUE  =&lt;span&gt; trig_value;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     defparam video_cap_inst.IW             =&lt;span&gt; iw;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     defparam video_cap_inst.IH             =&lt;span&gt; ih;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    RGB2YCrCb RGB2YCrCb_Inst(
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             .RESET(RSTn),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步复位信号&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;             
&lt;span&gt; 91&lt;/span&gt;             .RGB_CLK(CLOCK),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入像素时钟&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;             .RGB_VSYNC(RGB_VSYNC),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场同步信号&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             .RGB_DVALID(RGB_DVALID),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入数据有信号&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             .RGB_DAT(RGB_DAT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入RGB通道像素流，24位&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;             
&lt;span&gt; 96&lt;/span&gt;             .YCbCr_CLK(GRAY_CLK),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出像素时钟&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             .YCbCr_VSYNC(GRAY_VSYNC),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出场同步信号&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             .YCbCr_DVALID(GRAY_DVALID),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数据有效信号&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;             .Y_DAT(Y_DAT),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Y分量&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;             .Cb_DAT(Cb_DAT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Cb分量&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;             .Cr_DAT(Cr_DAT)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Cr分量&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        );    
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;     defparam RGB2YCrCb_Inst.RGB_DW =&lt;span&gt; local_dw;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     defparam RGB2YCrCb_Inst.YCbCr_DW =&lt;span&gt; dvd_dw;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    histogram_2d histogram_2d_inst(
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;        .rst_n(RSTn),
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        .clk(GRAY_CLK),
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         .din_valid(GRAY_DVALID),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入有效&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;         .din(Y_DAT),                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入待统计的数据&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;         .dout(HIST_DAT),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计输出&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;         .vsync(GRAY_VSYNC),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场同步&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;         .dout_valid(HIST_VALID),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出有效&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;         .int_flag(HIST_INT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断输出&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;         .rdyOutput(HIST_RDY),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据读出请求&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        .dout_clk(HIST_CLK)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    );    
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;     defparam histogram_2d_inst.DW =&lt;span&gt; dvd_dw;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     defparam histogram_2d_inst.IH =&lt;span&gt; ih;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     defparam histogram_2d_inst.IW =&lt;span&gt; iw;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     defparam histogram_2d_inst.TW =&lt;span&gt; tw;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     
&lt;span&gt;125&lt;/span&gt; endmodule
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用于测试仿真的文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; `timescale 1ps/&lt;span&gt;1ps
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;module histogram_tb;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;image para&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     parameter iw             = &lt;span&gt;640&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image width&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;     parameter ih            = &lt;span&gt;512&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image height&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;     parameter trig_value    = &lt;span&gt;400&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;video parameter&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     parameter h_total        = &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     parameter v_total        = &lt;span&gt;600&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     parameter sync_b        = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     parameter sync_e        = &lt;span&gt;55&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     parameter vld_b            = &lt;span&gt;65&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;     parameter clk_freq         = &lt;span&gt;72&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;data width&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     parameter dvd_dw     = &lt;span&gt;8&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;image source data width&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;     parameter dvd_chn    = &lt;span&gt;3&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;channel of the dvd data: when 3 it's rgb or 4:4:YCbCr&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     parameter local_dw    = dvd_dw * dvd_chn;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;local algorithem process data width&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     parameter cmd_dw    = dvd_dw * dvd_chn;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;local algorithem process data width&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     parameter hist_dw    = &lt;span&gt;32&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;test module enable&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     parameter cap_en    = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;signal group&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     reg pixel_clk = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    reg reset_l;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     reg [&lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] src_sel;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;input dv group&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    wire dv_clk;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    wire dvsyn;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    wire dhsyn;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     wire [dvd_dw-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] dvd;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     
&lt;span&gt; 44&lt;/span&gt;     wire [&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] HIST_DAT;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    wire HIST_VALID;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    wire HIST_INT;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    wire HIST_CLK;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;dvd source data generated for simulation&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;     image_src &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#(iw*dvd_chn, ih+1, dvd_dw, h_total, v_total, sync_b, sync_e, vld_b)&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    u1(
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        .clk(pixel_clk),
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        .reset_l(reset_l),
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        .src_sel(src_sel),
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        .test_data(dvd),
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        .test_dvalid(dhsyn),
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        .test_vsync(dvsyn),
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        .clk_out(dv_clk)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         
&lt;span&gt; 61&lt;/span&gt;     defparam u1.iw = iw*&lt;span&gt;dvd_chn;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     defparam u1.ih = ih + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     defparam u1.dw =&lt;span&gt; dvd_dw;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     defparam u1.h_total =&lt;span&gt; h_total;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     defparam u1.v_total =&lt;span&gt; v_total;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     defparam u1.sync_b =&lt;span&gt; sync_b;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     defparam u1.sync_e =&lt;span&gt; sync_e;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     defparam u1.vld_b =&lt;span&gt; vld_b;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         
&lt;span&gt; 70&lt;/span&gt;     
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;local clk: also clk of all local modules&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     reg cap_clk = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;video capture: capture image src and transfer it into local timing&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    histogram histogram_inst(
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         .RSTn(reset_l),                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局复位&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         .CLOCK(cap_clk),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统时钟&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         
&lt;span&gt; 79&lt;/span&gt;         .IMG_CLK(pixel_clk),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;像素时钟&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;         .IMG_DVD(dvd),                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;像素值&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         .IMG_DVSYN(dvsyn),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入场信号&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         .IMG_DHSYN(dhsyn),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入数据有效信号&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         .HIST_DAT(HIST_DAT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出直方图统计数据&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;         .HIST_VALID(HIST_VALID),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出直方图统计有效&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         .HIST_RDY(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1),                //数据读出请求&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         .HIST_INT(HIST_INT),            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据中断输出&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         .HIST_CLK(HIST_CLK)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据输出时钟&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    initial
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    begin: init
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         reset_l &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         src_sel &amp;lt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0000;&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         #(&lt;span&gt;100&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;reset the system&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;         reset_l &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;         #(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         reset_l &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1;&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     
&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dv_clk generate&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    always@(reset_l or pixel_clk)begin
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((~(reset_l)) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;             pixel_clk &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;        begin
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(clk_freq == &lt;span&gt;48&lt;/span&gt;)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;48MHz&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;                 pixel_clk &amp;lt;= #&lt;span&gt;10417&lt;/span&gt; (~&lt;span&gt;(pixel_clk));
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             
&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(clk_freq == &lt;span&gt;51.84&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;51.84MHz&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;                 pixel_clk &amp;lt;= #&lt;span&gt;9645&lt;/span&gt; (~&lt;span&gt;(pixel_clk));
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             
&lt;span&gt;112&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(clk_freq == &lt;span&gt;72&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;72MHz&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;                 pixel_clk &amp;lt;= #&lt;span&gt;6944&lt;/span&gt; (~&lt;span&gt;(pixel_clk));
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cap_clk generate: 25MHz&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    always@(reset_l or cap_clk)begin
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((~(reset_l)) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;             cap_clk &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0;&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;             cap_clk &amp;lt;= #&lt;span&gt;20000&lt;/span&gt; (~&lt;span&gt;(cap_clk));    
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    wire clk;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     assign clk = ~&lt;span&gt;cap_clk;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    generate
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(cap_en != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) begin :capture_operation
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         integer fid, cnt_cap=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        always@(posedge clk or negedge reset_l)begin
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(((~(reset_l))) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1)&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;                 cnt_cap = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; &lt;span&gt;                begin
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(HIST_VALID == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1 &amp;amp;&amp;amp; HIST_CLK == 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b0)
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                    begin 
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                         fid = $fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/Modelsim/histogram_2d/sim/hist_result.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                         $fseek(fid,cnt_cap,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                         $fdisplay(fid,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%8x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,HIST_DAT);
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;                        $fclose(fid);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                         cnt_cap&amp;lt;=cnt_cap+&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;        
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;                    end
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;                end
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    endgenerate    
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;endmodule
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　用于modelsim仿真的.do文件如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#切换至工程目录
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; cd E:/Modelsim/histogram_2d/&lt;span&gt;sim
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;#打开工程
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; project open E:/Modelsim/histogram_2d/sim/&lt;span&gt;histogram_2d
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;#添加指定设计文件
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/sim/&lt;span&gt;histogram_tb.v
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;cross_clock_fifo.v
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;hist_buffer.v
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;histogram.v
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;histogram_2d.v
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;image_src.v
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;line_buffer_new.v
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;rgb2gray.v
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;RGB2YCbCr.v
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; project addfile E:/Modelsim/histogram_2d/src/&lt;span&gt;video_cap.v
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;#编译工程内的所有文件
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;project compileall
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;#仿真work库下面的histogram_tb实例，同时调用altera_lib库，不进行任何优化
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; vsim -t 1ps -novopt -&lt;span&gt;L altera_lib work.histogram_tb
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;#添加输入灰度图像信号
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; add wave -&lt;span&gt;divider GRAYImg
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;clk
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;vsync
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;din_valid
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; add wave -radix hex -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;din
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;#输入信号缓存
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; add wave -&lt;span&gt;divider Data_Cache
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;vsync_r
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;dvalid_r
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;dvalid_r2
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; add wave -radix hex -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;din_r
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; add wave -radix hex -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;din_r2
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;#统计开始、结束；统计使能
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; add wave -&lt;span&gt;divider Statistics_Signal
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;hsync_rise
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;hsync_fall
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;hsync_count 
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;hsync_fall
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;#添加双口RAM读写控制时序
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; add wave -&lt;span&gt;divider HIST_BUFFER_WR
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;rst_cnt
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;inc_en
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;we_a
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;count_value
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;addr_a
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;#Buff数据读出控制时序
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; add wave -&lt;span&gt;divider HIST_BUFFER_RD
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;rstOutput
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;out_pixel
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;count_all
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;clr_flag
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;int_flag
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;int_r
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;we_b_l
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;we_b_h
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;mux_addr_b
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;mux_addr_b2
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;#添加统计输出信号
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; add wave -&lt;span&gt;divider Statistics_Out
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;dout_valid
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; add wave -radix binary -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;dout_clk
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; add wave -radix unsigned -position insertpoint sim:/histogram_tb/histogram_inst/histogram_2d_inst/&lt;span&gt;dout
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#复位
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;restart
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;#取消警告
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; StdArithNoWarnings &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;#开始
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; run &lt;span&gt;16&lt;/span&gt;.1ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用于数据处理的Maltab文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;clc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;clear;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; fid1 = fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hist_result.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt;FPGA转换灰度图像
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; data1 = fscanf(fid1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%8x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;fclose(fid1);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; RGBImg = imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lena_512x512.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt;rgb原始图像
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; RGBImg = imresize(RGBImg,[&lt;span&gt;512&lt;/span&gt; &lt;span&gt;640&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; GRAYImg = rgb2gray(RGBImg); %&lt;span&gt;Matlab变换灰度图像
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; fid2 = fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray_image.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt;FPGA转换灰度图像
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; data2 = fscanf(fid2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%2x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; data2 =&lt;span&gt; uint8(data2);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; gray_data = reshape(data2,&lt;span&gt;640&lt;/span&gt;,&lt;span&gt;512&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; gray_data = gray_data&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;fclose(fid2);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; figure(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; subplot(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;imshow(GRAYImg);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Matlab变换灰度图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; subplot(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;imhist(GRAYImg);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Matlab统计直方图&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; subplot(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;imshow(gray_data);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FPGA变换灰度图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; subplot(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;bar(data1);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FPGA统计直方图&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）输入信号缓存时序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1230100/202003/1230100-20200310222442750-258194902.jpg&quot; alt=&quot;&quot;/&gt;　&lt;br/&gt; （2）统计数据写入控制时序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1230100/202003/1230100-20200310222535512-1306094557.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）统计数据读出控制时序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1230100/202003/1230100-20200310222614692-1324386476.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）FPGA直方图统计结果与Maltab直方图统计结果对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1230100/202003/1230100-20200310222708994-427141530.jpg&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;






















</description>
<pubDate>Tue, 10 Mar 2020 14:29:00 +0000</pubDate>
<dc:creator>TheSkyIsMine</dc:creator>
<og:description>一、前言 本篇主要针对牟新刚编著《基于FPGA的数字图像处理及应用》第六章第五节中直方图统计相关类容进行总结，包括代码实现及 基于Modelsim的仿真。书读百遍，其意自现。　2020-03-09&amp;#</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangwei0521/p/12459289.html</dc:identifier>
</item>
<item>
<title>【原创】（四）Linux进程调度-组调度及带宽控制 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/12459000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/12459000.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组调度（&lt;code&gt;task_group&lt;/code&gt;）是使用Linux &lt;code&gt;cgroup(control group)&lt;/code&gt;的cpu子系统来实现的，可以将进程进行分组，按组来分配CPU资源等。&lt;br/&gt;比如，看一个实际的例子：&lt;br/&gt;A和B两个用户使用同一台机器，A用户16个进程，B用户2个进程，如果按照进程的个数来分配CPU资源，显然A用户会占据大量的CPU时间，这对于B用户是不公平的。组调度就可以解决这个问题，分别将A、B用户进程划分成组，并将两组的权重设置成占比50%即可。&lt;/p&gt;
&lt;p&gt;带宽（&lt;code&gt;bandwidth&lt;/code&gt;）控制，是用于控制用户组（&lt;code&gt;task_group&lt;/code&gt;）的CPU带宽，通过设置每个用户组的限额值，可以调整CPU的调度分配。在给定周期内，当用户组消耗CPU的时间超过了限额值，该用户组内的任务将会受到限制。&lt;/p&gt;
&lt;p&gt;由于组调度和带宽控制紧密联系，因此本文将探讨这两个主题，本文的讨论都基于CFS调度器，开始吧。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;组调度，在内核中是通过&lt;code&gt;struct task_group&lt;/code&gt;来组织的，&lt;code&gt;task_group&lt;/code&gt;本身支持&lt;code&gt;cfs组调度&lt;/code&gt;和&lt;code&gt;rt组调度&lt;/code&gt;，本文主要分析&lt;code&gt;cfs组调度&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;CFS调度器管理的是&lt;code&gt;sched_entity&lt;/code&gt;调度实体，&lt;code&gt;task_struct（代表进程）&lt;/code&gt;和&lt;code&gt;task_group（代表进程组）&lt;/code&gt;中分别包含&lt;code&gt;sched_entity&lt;/code&gt;，进而来参与调度；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于组调度的相关数据结构，组织如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310213939298-386758453.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内核维护了一个全局链表&lt;code&gt;task_groups&lt;/code&gt;，创建的&lt;code&gt;task_group&lt;/code&gt;会添加到这个链表中；&lt;/li&gt;
&lt;li&gt;内核定义了&lt;code&gt;root_task_group&lt;/code&gt;全局结构，充当&lt;code&gt;task_group&lt;/code&gt;的根节点，以它为根构建树状结构；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct task_group&lt;/code&gt;的子节点，会加入到父节点的&lt;code&gt;siblings&lt;/code&gt;链表中；&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;struct task_group&lt;/code&gt;会分配运行队列数组和调度实体数组（以CFS为例，RT调度类似），其中数组的个数为系统CPU的个数，也就是为每个CPU都分配了运行队列和调度实体；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应到实际的运行中，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214009477-225815245.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct cfs_rq&lt;/code&gt;包含了红黑树结构，&lt;code&gt;sched_entity&lt;/code&gt;调度实体参与调度时，都会挂入到红黑树中，&lt;code&gt;task_struct&lt;/code&gt;和&lt;code&gt;task_group&lt;/code&gt;都属于被调度对象；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;task_group&lt;/code&gt;会为每个CPU再维护一个&lt;code&gt;cfs_rq&lt;/code&gt;，这个&lt;code&gt;cfs_rq&lt;/code&gt;用于组织挂在这个任务组上的任务以及子任务组，参考图中的&lt;code&gt;Group A&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;调度器在调度的时候，比如调用&lt;code&gt;pick_next_task_fair&lt;/code&gt;时，会从遍历队列，选择&lt;code&gt;sched_entity&lt;/code&gt;，如果发现&lt;code&gt;sched_entity&lt;/code&gt;对应的是&lt;code&gt;task_group&lt;/code&gt;，则会继续往下选择；&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;sched_entity&lt;/code&gt;结构中存在&lt;code&gt;parent&lt;/code&gt;指针，指向它的父结构，因此，系统的运行也能从下而上的进行遍历操作，通常使用函数&lt;code&gt;walk_tg_tree_from&lt;/code&gt;进行遍历；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;task_group权重&quot;&gt;2.2 task_group权重&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;进程或进程组都有权重的概念，调度器会根据权重来分配CPU的时间。&lt;/li&gt;
&lt;li&gt;进程组的权重设置，可以通过&lt;code&gt;/sys&lt;/code&gt;文件系统进行设置，比如操作&lt;code&gt;/sys/fs/cgoup/cpu/A/shares&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214059270-591255805.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sched_group_set_shares&lt;/code&gt;来完成最终的设置；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;task_group&lt;/code&gt;为每个CPU都分配了一个&lt;code&gt;sched_entity&lt;/code&gt;，针对当前&lt;code&gt;sched_entity&lt;/code&gt;设置更新完后，往上对&lt;code&gt;sched_entity-&amp;gt;parent&lt;/code&gt;设置更新，直到根节点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shares&lt;/code&gt;的值计算与&lt;code&gt;load&lt;/code&gt;相关，因此也需要调用&lt;code&gt;update_load_avg&lt;/code&gt;进行更新计算；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看一下实际的效果图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214119139-113782827.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写节点操作可以通过&lt;code&gt;echo XXX &amp;gt; /sys/fs/cgroup/cpu/A/B/cpu.shares&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;橙色的线代表传入参数指向的对象；&lt;/li&gt;
&lt;li&gt;紫色的线代表每次更新涉及到的对象，包括三个部分；&lt;/li&gt;
&lt;li&gt;处理完&lt;code&gt;sched_entity&lt;/code&gt;后，继续按同样的流程处理&lt;code&gt;sched_entity-&amp;gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看一下&lt;code&gt;/sys/fs/cgroup/cpu&lt;/code&gt;下的内容吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214139609-150165770.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有两个关键的字段：&lt;code&gt;cfs_period_us&lt;/code&gt;和&lt;code&gt;cfs_quota_us&lt;/code&gt;，这两个与cfs_bandwidth息息相关；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;period&lt;/code&gt;表示周期，&lt;code&gt;quota&lt;/code&gt;表示限额，也就是在&lt;code&gt;period&lt;/code&gt;期间内，用户组的CPU限额为&lt;code&gt;quota&lt;/code&gt;值，当超过这个值的时候，用户组将会被限制运行（&lt;code&gt;throttle&lt;/code&gt;），等到下一个周期开始被解除限制（&lt;code&gt;unthrottle&lt;/code&gt;）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来一张图直观理解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214212348-1048763810.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在每个周期内限制在&lt;code&gt;quota&lt;/code&gt;的配额下，超过了就&lt;code&gt;throttle&lt;/code&gt;，下一个周期重新开始；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据结构&quot;&gt;3.1 数据结构&lt;/h2&gt;
&lt;p&gt;内核中使用&lt;code&gt;struct cfs_bandwidth&lt;/code&gt;来描述带宽，该结构包含在&lt;code&gt;struct task_group&lt;/code&gt;中。&lt;br/&gt;此外，&lt;code&gt;struct cfs_rq&lt;/code&gt;中也有与带宽控制相关的字段。&lt;br/&gt;还是来看一下代码吧：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct cfs_bandwidth {
#ifdef CONFIG_CFS_BANDWIDTH
    raw_spinlock_t lock;
    ktime_t period;
    u64 quota, runtime;
    s64 hierarchical_quota;
    u64 runtime_expires;

    int idle, period_active;
    struct hrtimer period_timer, slack_timer;
    struct list_head throttled_cfs_rq;

    /* statistics */
    int nr_periods, nr_throttled;
    u64 throttled_time;
#endif
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;period：周期值；&lt;/li&gt;
&lt;li&gt;quota：限额值；&lt;/li&gt;
&lt;li&gt;runtime：记录限额剩余时间，会使用quota值来周期性赋值；&lt;/li&gt;
&lt;li&gt;hierarchical_quota：层级管理任务组的限额比率；&lt;/li&gt;
&lt;li&gt;runtime_expires：每个周期的到期时间；&lt;/li&gt;
&lt;li&gt;idle：空闲状态，不需要运行时分配；&lt;/li&gt;
&lt;li&gt;period_active：周期性计时已经启动；&lt;/li&gt;
&lt;li&gt;period_timer：高精度周期性定时器，用于重新填充运行时间消耗；&lt;/li&gt;
&lt;li&gt;slack_timer：延迟定时器，在任务出列时，将剩余的运行时间返回到全局池里；&lt;/li&gt;
&lt;li&gt;throttled_cfs_rq：限流运行队列列表；&lt;/li&gt;
&lt;li&gt;nr_periods/nr_throttled/throttled_time：统计值；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;struct cfs_rq&lt;/code&gt;结构中相关字段如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct cfs_rq {
...
#ifdef CONFIG_CFS_BANDWIDTH
    int runtime_enabled;
    u64 runtime_expires;
    s64 runtime_remaining;

    u64 throttled_clock, throttled_clock_task;
    u64 throttled_clock_task_time;
    int throttled, throttle_count;
    struct list_head throttled_list;
#endif /* CONFIG_CFS_BANDWIDTH */
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;runtime_enabled：周期计时器使能；&lt;/li&gt;
&lt;li&gt;runtime_expires：周期计时器到期时间；&lt;/li&gt;
&lt;li&gt;runtime_remaining：剩余的运行时间；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;流程分析&quot;&gt;3.2 流程分析&lt;/h2&gt;
&lt;h3 id=&quot;初始化流程&quot;&gt;3.2.1 初始化流程&lt;/h3&gt;
&lt;p&gt;先看一下初始化的操作，初始化函数&lt;code&gt;init_cfs_bandwidth&lt;/code&gt;本身比较简单，完成的工作就是将&lt;code&gt;struct cfs_bandwidth&lt;/code&gt;结构体进程初始化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214259138-947344133.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册两个高精度定时器：&lt;code&gt;period_timer&lt;/code&gt;和&lt;code&gt;slack_timer&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;period_timer&lt;/code&gt;定时器，用于在时间到期时重新填充关联的任务组的限额，并在适当的时候&lt;code&gt;unthrottle&lt;/code&gt;cfs运行队列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slack_timer&lt;/code&gt;定时器，&lt;code&gt;slack_period&lt;/code&gt;周期默认为5ms，在该定时器函数中也会调用&lt;code&gt;distribute_cfs_runtime&lt;/code&gt;从全局运行时间中分配runtime；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_cfs_bandwidth&lt;/code&gt;和&lt;code&gt;start_cfs_slack_bandwidth&lt;/code&gt;分别用于启动定时器运行，其中可以看出在&lt;code&gt;dequeue_entity&lt;/code&gt;的时候会去利用&lt;code&gt;slack_timer&lt;/code&gt;，将运行队列的剩余时间返回给&lt;code&gt;tg-&amp;gt;cfs_b&lt;/code&gt;这个&lt;code&gt;runtime pool&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unthrottle_cfs_rq&lt;/code&gt;函数，会将&lt;code&gt;throttled_list&lt;/code&gt;中的对应&lt;code&gt;cfs_rq&lt;/code&gt;删除，并且从下往上遍历任务组，针对每个任务组调用&lt;code&gt;tg_unthrottle_up&lt;/code&gt;处理，最后也会根据&lt;code&gt;cfs_rq&lt;/code&gt;对应的&lt;code&gt;sched_entity&lt;/code&gt;从下往上遍历处理，如果&lt;code&gt;sched_entity&lt;/code&gt;不在运行队列上，那就重新&lt;code&gt;enqueue_entity&lt;/code&gt;以便参与调度运行，这个也就完成了解除限制的操作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;do_sched_cfs_period_timer&lt;/code&gt;函数与&lt;code&gt;do_sched_cfs_slack_timer()&lt;/code&gt;函数都调用了&lt;code&gt;distrbute_cfs_runtime()&lt;/code&gt;，该函数用于分发&lt;code&gt;tg-&amp;gt;cfs_b&lt;/code&gt;的全局运行时间&lt;code&gt;runtime&lt;/code&gt;，用于在该&lt;code&gt;task_group&lt;/code&gt;中平衡各个CPU上的&lt;code&gt;cfs_rq&lt;/code&gt;的运行时间&lt;code&gt;runtime&lt;/code&gt;，来一张示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214327034-866469658.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统中两个CPU，因此&lt;code&gt;task_group&lt;/code&gt;针对每个cpu都维护了一个&lt;code&gt;cfs_rq&lt;/code&gt;，这些&lt;code&gt;cfs_rq&lt;/code&gt;来共享该&lt;code&gt;task_group&lt;/code&gt;的限额运行时间；&lt;/li&gt;
&lt;li&gt;CPU0上的运行时间，浅黄色模块表示超额了，那么在下一个周期的定时器点上会进行弥补处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用户设置流程&quot;&gt;3.2.2 用户设置流程&lt;/h3&gt;
&lt;p&gt;用户可以通过操作&lt;code&gt;/sys&lt;/code&gt;中的节点来进行设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214408643-1763244978.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作&lt;code&gt;/sys/fs/cgroup/cpu/&lt;/code&gt;下的&lt;code&gt;cfs_quota_us/cfs_period_us&lt;/code&gt;节点，最终会调用到&lt;code&gt;tg_set_cfs_bandwidth&lt;/code&gt;函数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tg_set_cfs_bandwidth&lt;/code&gt;会从&lt;code&gt;root_task_group&lt;/code&gt;根节点开始，遍历组调度树，并逐个设置限额比率 ；&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;cfs_bandwidth&lt;/code&gt;的&lt;code&gt;runtime&lt;/code&gt;信息；&lt;/li&gt;
&lt;li&gt;如果使能了&lt;code&gt;cfs_bandwidth&lt;/code&gt;功能，则启动带宽定时器；&lt;/li&gt;
&lt;li&gt;遍历&lt;code&gt;task_group&lt;/code&gt;中的每个&lt;code&gt;cfs_rq&lt;/code&gt;队列，设置&lt;code&gt;runtime_remaining&lt;/code&gt;值，如果&lt;code&gt;cfs_rq&lt;/code&gt;队列限流了，则需要进行解除限流操作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;throttle限流操作&quot;&gt;3.2.3 &lt;code&gt;throttle&lt;/code&gt;限流操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cfs_rq&lt;/code&gt;运行队列被限制，是在&lt;code&gt;throttle_cfs_rq&lt;/code&gt;函数中实现的，其中调用关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214423221-158953219.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调度实体&lt;code&gt;sched_entity&lt;/code&gt;入列时，进行检测是否运行时间已经达到限额，达到则进行限制处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pick_next_task_fair/put_prev_task_fair&lt;/code&gt;在选择任务调度时，也需要进行检测判断；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;3.2.4 总结&lt;/h3&gt;
&lt;p&gt;总体来说，带宽控制的原理就是通过&lt;code&gt;task_group&lt;/code&gt;中的&lt;code&gt;cfs_bandwidth&lt;/code&gt;来管理一个全局的时间池，分配给属于这个任务组的运行队列，当超过限额的时候则限制队列的调度。同时，&lt;code&gt;cfs_bandwidth&lt;/code&gt;维护两个定时器，一个用于周期性的填充限额并进行时间分发处理，一个用于将未用完的时间再返回到时间池中，大抵如此。&lt;/p&gt;
&lt;p&gt;组调度和带宽控制就先分析到此，下篇文章将分析&lt;code&gt;CFS调度器&lt;/code&gt;了，敬请期待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200310214440102-457715613.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Mar 2020 13:48:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 By 鲁迅 By 高尔基 说明： 1. Kernel版本：4.14 2. ARM64处理器，Contex A53，双核 3. 使用工具：Source Insight 3.5， Visio 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/12459000.html</dc:identifier>
</item>
<item>
<title>Redis面试题集锦（精选） - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/12458686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/12458686.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7326374-3acce3a2228e77a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Redis面试题集锦（精选）&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-redis简述它的优缺点&quot;&gt;1.什么是 Redis？简述它的优缺点？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;的全称是：&lt;code&gt;Remote Dictionary.Server&lt;/code&gt;，本质上是一个&lt;code&gt;Key-Value&lt;/code&gt; 类型的内存数据库，很像&lt;code&gt;memcached&lt;/code&gt;，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据&lt;code&gt;flush&lt;/code&gt;到硬盘上进行保存。因为是纯内存操作，&lt;code&gt;Redis&lt;/code&gt; 的性能非常出色，每秒可以处理超过 &lt;strong&gt;10&lt;/strong&gt; 万次读写操作，是已知性能最快的&lt;strong&gt;Key-Value DB&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;Redis&lt;/strong&gt; 的出色之处不仅仅是性能，&lt;code&gt;Redis&lt;/code&gt; 最大的魅力是支持保存多种数据结构，此外单个 &lt;code&gt;value&lt;/code&gt; 的最大限制是 &lt;code&gt;1GB&lt;/code&gt;，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。&lt;br/&gt;比方说用他的 &lt;code&gt;List&lt;/code&gt; 来做 &lt;code&gt;FIFO&lt;/code&gt; 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 &lt;code&gt;Set&lt;/code&gt;可以做高性能的 &lt;code&gt;tag&lt;/code&gt;系统等等。&lt;br/&gt;另外 &lt;code&gt;Redis&lt;/code&gt; 也可以对存入的 &lt;code&gt;Key-Value&lt;/code&gt; 设置 &lt;code&gt;expire&lt;/code&gt; 时间，因此也可以被当作一个功能加强版的memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。&lt;/p&gt;
&lt;h3 id=&quot;redis-支持的-java-客户端都有哪些官方推荐用哪个&quot;&gt;2.Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？&lt;/h3&gt;
&lt;p&gt;Redisson、Jedis、lettuce 等等，官方推荐使用 &lt;code&gt;Redisson&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;redis-与-memcached-相比有哪些优势&quot;&gt;3.Redis 与 Memcached 相比有哪些优势？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;memcached&lt;/code&gt; 所有的值均是简单的字符串，&lt;code&gt;redis&lt;/code&gt; 作为其替代者，支持更为丰富的数据类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt; 的速度比 &lt;code&gt;memcached&lt;/code&gt; 快很多。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis&lt;/code&gt; 可以持久化其数据。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7326374-2c0a68b348a67eb0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Redis 与 Memcached区别&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;redis-支持哪几种数据类型并简单介绍一下&quot;&gt;4.Redis 支持哪几种数据类型？并简单介绍一下？&lt;/h3&gt;
&lt;p&gt;String(字符串)、Hash(哈希)、List(列表)、Set(集合)、Zset(sorted set：有序集合)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String(字符串)&lt;/strong&gt;&lt;br/&gt;String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。&lt;br/&gt;String类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。&lt;br/&gt;String类型是Redis最基本的数据类型，一个键最大能存储512MB。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个键能存512M，但是取出来的时候就要注意了。如果存的value过大，却用String接收的话，就会抛异常了。我们就出现过线上问题~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hash(哈希)&lt;/strong&gt;&lt;br/&gt;Redis hash是一个键值对集合。&lt;br/&gt;Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。每个 hash 可以存储 2^32 - 1键值对（40多亿）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List(列表)&lt;/strong&gt;&lt;br/&gt;Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。&lt;br/&gt;列表最多可存储 2^32 - 1元素 (4294967295, 每个列表可存储40多亿)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set(集合)&lt;/strong&gt;&lt;br/&gt;Redis的Set是string类型的无序集合。&lt;br/&gt;集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&lt;br/&gt;sadd 命令:添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zset&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Redis&lt;/code&gt; &lt;code&gt;zset&lt;/code&gt; 和&lt;code&gt;set&lt;/code&gt;一样也是&lt;code&gt;string&lt;/code&gt;类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个&lt;code&gt;double&lt;/code&gt;类型的分数。&lt;code&gt;redis&lt;/code&gt;正是通过分数来为集合中的成员进行从小到大的排序。&lt;br/&gt;&lt;code&gt;zset&lt;/code&gt;的成员是唯一的,但分数(&lt;code&gt;score&lt;/code&gt;)却可以重复。&lt;br/&gt;&lt;code&gt;zadd&lt;/code&gt;命令：添加元素到集合，元素在集合中存在则更新对应&lt;code&gt;score&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;怎么理解-redis-事务相关事务命令有哪些并介绍一下&quot;&gt;5.怎么理解 Redis 事务？相关事务命令有哪些？并介绍一下&lt;/h3&gt;
&lt;p&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;MULTI&lt;/code&gt;、&lt;code&gt;EXEC&lt;/code&gt;、&lt;code&gt;DISCARD&lt;/code&gt;、&lt;code&gt;WATCH&lt;/code&gt;、&lt;code&gt;UNWATCH&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DISCARD&lt;br/&gt;取消事务，放弃执行事务块内的所有命令。&lt;/li&gt;
&lt;li&gt;EXEC&lt;br/&gt;执行所有事务块内的命令。&lt;/li&gt;
&lt;li&gt;MULTI&lt;br/&gt;标记一个事务块的开始。&lt;/li&gt;
&lt;li&gt;UNWATCH&lt;br/&gt;取消 WATCH 命令对所有 key 的监视。&lt;/li&gt;
&lt;li&gt;WATCH key [key ...]&lt;br/&gt;监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在传统的关系式数据库中，常常用 &lt;code&gt;ACID&lt;/code&gt; 性质来检验事务功能的可靠性和安全性。在 &lt;code&gt;Redis&lt;/code&gt;中，事务总是具有&lt;strong&gt;原子性&lt;/strong&gt;（Atomicity)、&lt;strong&gt;一致性&lt;/strong&gt;(Consistency)和&lt;strong&gt;隔离性&lt;/strong&gt;（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有&lt;strong&gt;持久性&lt;/strong&gt;（Durability）。&lt;/p&gt;
&lt;h3 id=&quot;为什么要用-redis-而不用-mapguava-做缓存&quot;&gt;6.为什么要用 redis 而不用 map/guava 做缓存?&lt;/h3&gt;
&lt;p&gt;缓存分为本地缓存和分布式缓存。以 &lt;code&gt;Java&lt;/code&gt; 为例，使用自带的&lt;code&gt;map&lt;/code&gt;或者 &lt;code&gt;guava&lt;/code&gt;实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 &lt;code&gt;jvm&lt;/code&gt; 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;redis&lt;/code&gt; 或&lt;code&gt;memcached&lt;/code&gt;之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 &lt;code&gt;redis&lt;/code&gt; 或 &lt;code&gt;memcached&lt;/code&gt;服务的高可用，整个程序架构上较为复杂。&lt;/p&gt;
&lt;h3 id=&quot;redis-设置过期时间&quot;&gt;7. redis 设置过期时间&lt;/h3&gt;
&lt;p&gt;Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。&lt;/p&gt;
&lt;p&gt;我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。&lt;/p&gt;
&lt;p&gt;如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt;+&lt;strong&gt;惰性删除&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过名字大概就能猜出这两个删除方式的意思了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？&lt;/p&gt;
&lt;h3 id=&quot;说一说redis-内存淘汰机制mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据&quot;&gt;8. 说一说Redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 配置文件 &lt;code&gt;redis.conf&lt;/code&gt; 中有相关注释，大家可以自行查阅或者通过这个网址查看：&lt;br/&gt;&lt;a href=&quot;http://download.redis.io/redis-stable/redis.conf&quot; class=&quot;uri&quot;&gt;http://download.redis.io/redis-stable/redis.conf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 提供 6种数据淘汰策略：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;br/&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;br/&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;br/&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.&lt;br/&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;br/&gt;&lt;strong&gt;no-eviction&lt;/strong&gt;：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！&lt;/p&gt;
&lt;h3 id=&quot;如何解决-redis-的并发竞争-key-问题&quot;&gt;9. 如何解决 Redis 的并发竞争 Key 问题？&lt;/h3&gt;
&lt;p&gt;所谓 &lt;code&gt;Redis&lt;/code&gt; 的并发竞争 &lt;code&gt;Key&lt;/code&gt; 的问题也就是多个系统同时对一个 &lt;code&gt;key&lt;/code&gt; 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！&lt;/p&gt;
&lt;p&gt;推荐一种方案：&lt;strong&gt;分布式锁&lt;/strong&gt;（&lt;code&gt;zookeeper&lt;/code&gt; 和 &lt;code&gt;redis&lt;/code&gt; 都可以实现分布式锁）。（如果不存在 &lt;code&gt;Redis&lt;/code&gt; 的并发竞争 &lt;code&gt;Key&lt;/code&gt; 问题，不要使用分布式锁，这样会影响性能）&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;zookeeper&lt;/code&gt;临时有序节点可以实现的分布式锁。&lt;br/&gt;大致思想为：每个客户端对某个方法加锁时，在&lt;code&gt;zookeeper&lt;/code&gt;上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。&lt;/p&gt;
&lt;p&gt;在实践中，当然是从以可靠性为主。所以首推&lt;code&gt;Zookeeper&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;redis-为什么是单线程的&quot;&gt;10.Redis 为什么是单线程的？&lt;/h3&gt;
&lt;p&gt;官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问&lt;br/&gt;1）绝大部分请求是纯粹的内存操作（非常快速）&lt;br/&gt;2）采用单线程,避免了不必要的上下文切换和竞争条件&lt;br/&gt;3）非阻塞IO优点：&lt;br/&gt;1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持丰富数据类型，支持string，list，set，sorted set，hash&lt;br/&gt;3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行&lt;/li&gt;
&lt;li&gt;丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。&lt;br/&gt;(1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可&lt;br/&gt;(2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。&lt;/p&gt;
&lt;p&gt;(3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性&lt;br/&gt;对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。&lt;/p&gt;
&lt;h3 id=&quot;说一说redis-持久化机制&quot;&gt;11.说一说Redis 持久化机制？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当&lt;code&gt;Redis&lt;/code&gt;重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。&lt;br/&gt;实现：单独创建&lt;code&gt;fork()&lt;/code&gt;一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RDB&lt;/strong&gt;是&lt;code&gt;Redis&lt;/code&gt;默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt;：&lt;code&gt;Redis&lt;/code&gt;会将每一个收到的写命令都通过&lt;code&gt;Write&lt;/code&gt;函数追加到文件最后，类似于&lt;code&gt;MySQL&lt;/code&gt;的&lt;code&gt;binlog&lt;/code&gt;。当&lt;code&gt;Redis&lt;/code&gt;重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。&lt;br/&gt;当两种方式同时开启时，数据恢复&lt;code&gt;Redis&lt;/code&gt;会优先选择&lt;code&gt;AOF&lt;/code&gt;恢复。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;热点数据和冷数据是什么&quot;&gt;12.热点数据和冷数据是什么?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;热点数据&lt;/strong&gt;，缓存才有价值&lt;br/&gt;对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。&lt;br/&gt;对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存&lt;br/&gt;对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据更新前至少读取两次&lt;/strong&gt;，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。&lt;br/&gt;那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。&lt;/p&gt;
&lt;h3 id=&quot;简单说一说缓存雪崩以及解决办法&quot;&gt;13. 简单说一说缓存雪崩以及解决办法？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;我们可以简单的理解为：&lt;strong&gt;由于原有缓存失效，新缓存未到期间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：&lt;br/&gt;大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。&lt;/p&gt;
&lt;h3 id=&quot;简单说一说缓存穿透以及解决办法&quot;&gt;14. 简单说一说缓存穿透以及解决办法？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;:&lt;br/&gt;最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。&lt;br/&gt;另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。&lt;br/&gt;5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？&lt;br/&gt;对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。&lt;br/&gt;&lt;strong&gt;Bitmap&lt;/strong&gt;： 典型的就是哈希表&lt;br/&gt;缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;（推荐）&lt;br/&gt;就是引入了k(k&amp;gt;1)k(k&amp;gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。&lt;br/&gt;它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;br/&gt;Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。&lt;br/&gt;Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。&lt;br/&gt;Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。&lt;/p&gt;
&lt;h3 id=&quot;简单说一说缓存预热&quot;&gt;15. 简单说一说缓存预热？&lt;/h3&gt;
&lt;p&gt;除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：&lt;br/&gt;（1）定时去清理过期的缓存；&lt;br/&gt;（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。&lt;br/&gt;两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。&lt;/p&gt;
&lt;h3 id=&quot;简单说一说缓存降级&quot;&gt;16. 简单说一说缓存降级？&lt;/h3&gt;
&lt;p&gt;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。&lt;br/&gt;降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。&lt;br/&gt;以参考日志级别设置预案：&lt;br/&gt;（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；&lt;br/&gt;（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；&lt;br/&gt;（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；&lt;br/&gt;（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。&lt;/p&gt;
&lt;p&gt;服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。&lt;/p&gt;
&lt;h3 id=&quot;redis-常见性能问题和解决方案&quot;&gt;17.Redis 常见性能问题和解决方案？&lt;/h3&gt;
&lt;p&gt;(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件&lt;/p&gt;
&lt;p&gt;(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次&lt;/p&gt;
&lt;p&gt;(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内&lt;/p&gt;
&lt;p&gt;(4) 尽量避免在压力很大的主库上增加从库&lt;/p&gt;
&lt;p&gt;(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &amp;lt;- Slave1 &amp;lt;- Slave2 &amp;lt;- Slave3…&lt;/p&gt;
&lt;h3 id=&quot;redis如何实现分布式锁&quot;&gt;18.Redis如何实现分布式锁？&lt;/h3&gt;
&lt;p&gt;1.根据lockKey区进行setnx（set not exist，如果key值为空，则正常设置，返回1，否则不会进行设置并返回0）操作，如果设置成功，表示已经获得锁，否则并没有获取锁。&lt;/p&gt;
&lt;p&gt;2.如果没有获得锁，去Redis上拿到该key对应的值，在该key上我们存储一个时间戳（用毫秒表示，t1），为了避免死锁以及其他客户端占用该锁超过一定时间（5秒），使用该客户端当前时间戳，与存储的时间戳作比较。&lt;/p&gt;
&lt;p&gt;3.如果没有超过该key的使用时限，返回false，表示其他人正在占用该key，不能强制使用；如果已经超过时限，那我们就可以进行解锁，使用我们的时间戳来代替该字段的值。&lt;/p&gt;
&lt;p&gt;4.但是如果在setnx失败后，get该值却无法拿到该字段时，说明操作之前该锁已经被释放，这个时候，最好的办法就是重新执行一遍setnx方法来获取其值以获得该锁。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7326374-1219d618bce23643.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Redis分布式锁流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细内容可以查看：Redis与Zookeeper实现分布式锁的区别（&lt;a href=&quot;https://www.cnblogs.com/mengchunchen/p/9647756.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/mengchunchen/p/9647756.html&lt;/a&gt;）&lt;/p&gt;
&lt;h3 id=&quot;如何保证缓存与数据库双写时的数据一致性&quot;&gt;19.如何保证缓存与数据库双写时的数据一致性？&lt;/h3&gt;
&lt;p&gt;你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？&lt;/p&gt;
&lt;p&gt;一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况&lt;/p&gt;
&lt;p&gt;串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。&lt;/p&gt;
&lt;p&gt;还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。&lt;/p&gt;
&lt;p&gt;这种情况不存在并发问题么？&lt;/p&gt;
&lt;p&gt;不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生&lt;/p&gt;
&lt;p&gt;（1）缓存刚好失效&lt;br/&gt;（2）请求A查询数据库，得一个旧值&lt;br/&gt;（3）请求B将新值写入数据库&lt;br/&gt;（4）请求B删除缓存&lt;br/&gt;（5）请求A将查到的旧值写入缓存&lt;/p&gt;
&lt;p&gt;ok，如果发生上述情况，确实是会发生脏数据。&lt;/p&gt;
&lt;p&gt;然而，发生这种情况的概率又有多少呢？&lt;/p&gt;
&lt;p&gt;发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。&lt;/p&gt;
&lt;p&gt;如何解决上述并发问题？&lt;/p&gt;
&lt;p&gt;首先，给缓存设有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。&lt;/p&gt;
&lt;h3 id=&quot;是否使用过redis集群集群的原理是什么&quot;&gt;20.是否使用过Redis集群，集群的原理是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Redis Sentinal&lt;/code&gt;着眼于高可用，在&lt;code&gt;master&lt;/code&gt;宕机时会自动将&lt;code&gt;slave&lt;/code&gt;提升为&lt;code&gt;master&lt;/code&gt;，继续提供服务。&lt;br/&gt;&lt;code&gt;Redis Cluster&lt;/code&gt;着眼于扩展性，在单个&lt;code&gt;redis&lt;/code&gt;内存不足时，使用&lt;code&gt;Cluster&lt;/code&gt;进行分片存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slot&lt;/strong&gt;：插槽，可以存储两个数值的一个变量这个变量的取值范围是：0-16383。&lt;br/&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：集群管理者，使集群对外暴漏的是一个整体。&lt;br/&gt;&lt;strong&gt;redis cluster&lt;/strong&gt;：采用虚拟分区的方式，将整个集群看成一个整体，然后分成16384个槽位。&lt;br/&gt;然后再将16484个槽位分别分配给集群的各个节点，然后各个节点各自负责一部分槽位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7326374-f534036d48705138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Redis集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt;&lt;br/&gt;节点1负责 &lt;code&gt;0-5000&lt;/code&gt;之间的槽位，节点2负责&lt;code&gt;5001-10000&lt;/code&gt;之间的槽位，节点3负责&lt;code&gt;10001-16383&lt;/code&gt;之间的槽位。&lt;br/&gt;k-v键值对数据只会和槽位相关，与物理机器无关。通过crc16算法计算出 k对应的整数值（有点类似hash），然后对算出的整数值%16384取模，计算出k-v对应在哪个槽位上，然后再根据槽位与机器节点的映射关系，存储到相应的节点上去。取的时候，也是相应的过 程所以整个集群协同一致对外，给client看到的视图就是完整的数据集。&lt;/p&gt;
&lt;h3 id=&quot;redis事物的了解cascheck-and-set-操作实现乐观锁&quot;&gt;21. redis事物的了解CAS(check-and-set 操作实现乐观锁 )?&lt;/h3&gt;
&lt;p&gt;和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：&lt;br/&gt;　　1). 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。&lt;br/&gt;　　2). 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。&lt;br/&gt;　　3). 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为&quot;BEGIN TRANSACTION&quot;语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。&lt;br/&gt;　　4). 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。&lt;br/&gt;　　5). 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。&lt;br/&gt;　　Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。&lt;/p&gt;
&lt;h3 id=&quot;watch命令和基于cas的乐观锁&quot;&gt;22.WATCH命令和基于CAS的乐观锁？&lt;/h3&gt;
&lt;p&gt;在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务&lt;br/&gt;　执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：&lt;br/&gt;　　val = GET mykey&lt;br/&gt;　　val = val + 1&lt;br/&gt;　　SET mykey $val&lt;br/&gt;　　以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　WATCH mykey
　　val = GET mykey
　　val = val + 1
　　MULTI
　　SET mykey $val
　　EXEC&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。&lt;/p&gt;
&lt;h3 id=&quot;redis-最适合的场景有哪些&quot;&gt;23.redis 最适合的场景有哪些？　　&lt;/h3&gt;
&lt;p&gt;Redis最适合所有数据&lt;code&gt;in-momory&lt;/code&gt;的场景，虽然Redis也提供持久化功能，但实际更多的是一个&lt;code&gt;disk-backed&lt;/code&gt;的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的&lt;code&gt;Memcached&lt;/code&gt;，那么何时使用&lt;code&gt;Memcached&lt;/code&gt;，何时使用Redis呢?&lt;/p&gt;
&lt;p&gt;如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis不仅仅支持简单的k/v类型的数据，同时还提供&lt;code&gt;list&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;，&lt;code&gt;zset&lt;/code&gt;，&lt;code&gt;hash&lt;/code&gt;等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即&lt;code&gt;master-slave&lt;/code&gt;模式的数据备份。&lt;/li&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.会话缓存（Session Cache）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？&lt;/p&gt;
&lt;p&gt;幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.全页缓存（FPC）&lt;/strong&gt;&lt;br/&gt;除基本的会话token之外，Redis还提供很简便的&lt;code&gt;FPC&lt;/code&gt;平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。&lt;/p&gt;
&lt;p&gt;再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。&lt;br/&gt;此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 队列&lt;/strong&gt;&lt;br/&gt;Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。&lt;/p&gt;
&lt;p&gt;如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.排行榜/计数器&lt;/strong&gt;&lt;br/&gt;Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。&lt;br/&gt;所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：&lt;br/&gt;当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZRANGE user_scores 0 10 WITHSCORES&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.发布/订阅&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。&lt;br/&gt;Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。&lt;/p&gt;
&lt;h3 id=&quot;说说redis哈希槽的概念&quot;&gt;24. 说说Redis哈希槽的概念？&lt;/h3&gt;
&lt;p&gt;Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有&lt;strong&gt;16384&lt;/strong&gt;个哈希槽，每个key通过&lt;strong&gt;CRC16&lt;/strong&gt;校验后对&lt;strong&gt;16384&lt;/strong&gt;取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。&lt;/p&gt;
&lt;h3 id=&quot;redis集群方案什么情况下会导致整个集群不可用&quot;&gt;25. Redis集群方案什么情况下会导致整个集群不可用？&lt;/h3&gt;
&lt;p&gt;有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少&lt;code&gt;5501-11000&lt;/code&gt;这个范围的槽而不可用。&lt;/p&gt;
&lt;p&gt;关于Redis集群架构更加详细的内容，可以看看大佬的文章：&lt;br/&gt;那些年用过的Redis集群架构（含面试解析）：(&lt;a href=&quot;https://www.cnblogs.com/rjzheng/p/10360619.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/rjzheng/p/10360619.html&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;推荐&quot;&gt;推荐&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247484099&amp;amp;idx=1&amp;amp;sn=8e7ad8e24c2ced9bc9a5bee16ffea66a&amp;amp;chksm=96e673d0a191fac60672313b7f8031d6b76daa1d5eec4b7c698505877fc2cc3a21c47cf2a922&amp;amp;token=1975823476&amp;amp;lang=zh_CN#rd&quot;&gt;Spring面试题集锦（精选）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247484113&amp;amp;idx=1&amp;amp;sn=e6c5c5942152ee1cd6bacbab571a766c&amp;amp;chksm=96e673c2a191fad42c54a718dbfcfad8f4a32448f63c832e081eea2a130968f5a12bb165c6bb&amp;amp;token=1513909591&amp;amp;lang=zh_CN#rd&quot;&gt;SpringMVC面试题集锦（精选）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247484108&amp;amp;idx=1&amp;amp;sn=ea9de1f2e9e8640002a1ddb85e3c78a8&amp;amp;chksm=96e673dfa191fac9bd60c66dcccc4bb0d4fdec3d9e3db5f4237b0bd638d843a0de18d7095594&amp;amp;token=1975823476&amp;amp;lang=zh_CN#rd&quot;&gt;Spring全家桶注解一览（精选）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21&quot;&gt;ProcessOn是一个在线作图工具的聚合平台~&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;欢迎关注个人微信公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;欢迎关注&lt;strong&gt;Coder编程&lt;/strong&gt;公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.1780821917808&quot;&gt;
&lt;p&gt;文章收录至&lt;br/&gt;Github: &lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot; class=&quot;uri&quot;&gt;https://github.com/CoderMerlin/coder-programming&lt;/a&gt;&lt;br/&gt;Gitee: &lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot; class=&quot;uri&quot;&gt;https://gitee.com/573059382/coder-programming&lt;/a&gt;&lt;br/&gt;欢迎&lt;strong&gt;关注&lt;/strong&gt;并star~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7326374-0c30c361239e4cca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 10 Mar 2020 13:15:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>1.什么是 Redis？简述它的优缺点？ Redis 的全称是： ，本质上是一个 类型的内存数据库，很像 ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 到硬盘上进行保存。因为是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coder-programming/p/12458686.html</dc:identifier>
</item>
<item>
<title>Dubbo进阶 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12458362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12458362.html</guid>
<description>&lt;p&gt;什么是注册中心:&lt;/p&gt;
&lt;p&gt;注册中心就是用来存储服务信息的地方,就像房屋中介一样;&lt;/p&gt;
&lt;p&gt;为什么需要注册中心:&lt;/p&gt;
&lt;p&gt;在前面的例子中我们使用了客户端与服务器直连的方式完成了服务的调用,在实际开发中这回带来一些问题,例如服务器地址变更了,或服务搭建了集群,客户端不知道服务的地址,此时注册中心就派上用场了,服务提供方发布服务后将服务信息放在zookeeper中,然后消费方从zookeeper获取服务器信息,进行调用,这样就使提供方和消费方解开了耦合,也让服务提供方可以更方便的搭建集群;&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;p&gt;1.启动zookeeper,单机和集群都可以&lt;/p&gt;
&lt;p&gt;2.在双方配置文件中指定注册中心的信息(内容相同)&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--注册中心 N/A 表示不使用注册中心 直连客户端  地址可以是一个或多个 多个表示集群--&amp;gt;
    &amp;lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;10.211.55.6:2181,10.211.55.7:2181&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要说明的是,注册中心不是必须使用zookeeper,dubbo还支持其他三种:Simple,Redis,Multicast,因其优秀的可用性,官方推荐使用zookeeper;&lt;/p&gt;

&lt;h2 id=&quot;api配置&quot;&gt;API配置&lt;/h2&gt;
&lt;p&gt;简单的说就是不使用配置文件而是使用使用代码来完成配置,该方式主要用于测试环境或集成其他框架,不推荐用于生产环境;&lt;/p&gt;
&lt;p&gt;服务提供者:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProviderApplication {
    public static void main(String[] args) throws IOException {
//        xmlConfig();
        apiConfig();
        System.in.read();//阻塞主线程保持运行
    }

    private static void apiConfig() {
        //应用配置
        ApplicationConfig applicationConfig = new ApplicationConfig();
        applicationConfig.setName(&quot;my-service&quot;);
        applicationConfig.setQosEnable(true);
        //注册中心
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;10.211.55.6:2181,10.211.55.7:2181&quot;);
        //rpc协议
        ProtocolConfig protocolConfig = new ProtocolConfig();
        protocolConfig.setName(&quot;dubbo&quot;);
        protocolConfig.setPort(20880);
        //发布服务
        ServiceConfig&amp;lt;HelloService&amp;gt; serviceConfig = new ServiceConfig&amp;lt;HelloService&amp;gt;();
        serviceConfig.setApplication(applicationConfig);
        serviceConfig.setProtocol(protocolConfig);
        serviceConfig.setRegistry(registryConfig);
        serviceConfig.setInterface(HelloService.class);
        serviceConfig.setRef(new HelloServiceImpl());
        serviceConfig.export();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConsumerApplication {
    public static void main(String[] args) {
//        xmlConfig();
        apiConfig();
    }

    private static void apiConfig() {
        //应用配置
        ApplicationConfig applicationConfig = new ApplicationConfig();
        applicationConfig.setName(&quot;my-consumer&quot;);
        applicationConfig.setQosEnable(false);
                //注册中心
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;10.211.55.6:2181,10.211.55.7:2181&quot;);
                //调用服务
        ReferenceConfig&amp;lt;HelloService&amp;gt; serviceReferenceConfig = new ReferenceConfig&amp;lt;HelloService&amp;gt;();
        serviceReferenceConfig.setApplication(applicationConfig);
        serviceReferenceConfig.setRegistry(registryConfig);
        serviceReferenceConfig.setInterface(HelloService.class);
        HelloService service = serviceReferenceConfig.get();
        String tom = service.sayHello(&quot;tom&quot;);
        System.out.println(tom);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注解配置&quot;&gt;注解配置&lt;/h2&gt;
&lt;p&gt;注解配置是使用较多的一种方式,可加快开发速度,让我们从繁琐的配置文件中解脱出来;&lt;/p&gt;
&lt;p&gt;Dubbo使用了Spring容器来管理bean,所以配置方式也大同小异,可使用Configuration将一个类作为配置类;在该类中提供必要的几个bean&lt;/p&gt;
&lt;h3 id=&quot;服务提供者&quot;&gt;服务提供者&lt;/h3&gt;
&lt;p&gt;配置类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableDubbo(scanBasePackages = &quot;com.yyh.service&quot;)
public class ProviderConfiguration {
    //无论如何配置我们最终需要的还是那几个bean
    @Bean
    public ApplicationConfig applicationConfig(){
        //应用配置
        ApplicationConfig applicationConfig = new ApplicationConfig();
        applicationConfig.setName(&quot;my-service&quot;);
        applicationConfig.setQosEnable(true);
        return applicationConfig;
    }

    @Bean
    public RegistryConfig registryConfig(){
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;10.211.55.6:2181,10.211.55.7:2181&quot;);
        return registryConfig;
    }

    @Bean
    public ProtocolConfig protocolConfig(){
        //rpc协议
        ProtocolConfig protocolConfig = new ProtocolConfig();
        protocolConfig.setName(&quot;dubbo&quot;);
        protocolConfig.setPort(20880);
        return protocolConfig;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务实现类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//注意该注解是Dubbo提供的 不要用错
@Service
public class HelloServiceImpl implements HelloService {
    public String sayHello(String name) {
        return &quot;hello: &quot;+name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发布服务:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws IOException {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);
    context.start();
    System.in.read();//阻塞主线程保持运行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费者&quot;&gt;消费者&lt;/h3&gt;
&lt;p&gt;配置类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableDubbo
@ComponentScan(&quot;com.yyh.consumer&quot;)
public class ConsumerConfiguration {
    @Bean
    public ApplicationConfig applicationConfig(){
        //应用配置
        ApplicationConfig applicationConfig = new ApplicationConfig();
        applicationConfig.setName(&quot;my-consumer&quot;);
        applicationConfig.setQosEnable(true);
        return applicationConfig;
    }

    @Bean
    public RegistryConfig registryConfig(){
        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setProtocol(&quot;zookeeper&quot;);
        registryConfig.setAddress(&quot;10.211.55.6:2181,10.211.55.7:2181&quot;);
        return registryConfig;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SayHelloConsumer {
  
    @Reference
    private HelloService helloService;

    public void sayHello(){
        String jack = helloService.sayHello(&quot;jack&quot;);
        System.out.println(jack);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行测试:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConsumerApplication {
    public static void main(String[] args) {
                AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class);
        SayHelloConsumer consumer = context.getBean(SayHelloConsumer.class);
        consumer.sayHello();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现消费者不需要指定ProtocolConfig,主要服务端固定端口即可;&lt;/p&gt;
&lt;h2 id=&quot;使用properties配置&quot;&gt;使用properties配置&lt;/h2&gt;
&lt;p&gt;相比xml和api的方式,properties是体量是最轻的,在面对一些简单配置时可以采用properties&lt;/p&gt;
&lt;h3 id=&quot;服务提供者-1&quot;&gt;服务提供者&lt;/h3&gt;
&lt;p&gt;在resource下提供名为&lt;code&gt;dubbo.properties&lt;/code&gt;的文件,内容如下:&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;dubbo.application.name=my-service
dubbo.application.owner=jerry
dubbo.protocol.dubbo.port=1099
dubbo.registry.address=zookeeper://10.211.55.6:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableDubbo(scanBasePackages = &quot;com.yyh.service&quot;)
@PropertySource(&quot;classpath:/dubbo.properties&quot;)
public class AnnotationAndPropperties {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProviderApplication {
    public static void main(String[] args) throws IOException {
        annotationAndPropConfig();
        System.out.println(&quot;服务已启动  按任意键退出&quot;);
        System.in.read();//阻塞   主线程  保持运行
    }
    private static void annotationAndPropConfig() {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AnnotationAndPropperties.class);
        context.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费者-1&quot;&gt;消费者&lt;/h3&gt;
&lt;p&gt;同样提供properties文件,但不需要指定protocol&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;dubbo.application.name=my-service
dubbo.application.qos.enable=false
dubbo.application.owner=jerry
dubbo.registry.address=zookeeper://10.211.55.6:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDubbo
@Configuration
@ComponentScan(&quot;com.yyh.consumer&quot;)
@PropertySource(&quot;classpath:/dubbo.properties&quot;)
public class AnnotationAndPropConfiguration {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SayHelloConsumer {
  
    @Reference
    private HelloService helloService;

    public void sayHello(){
        String jack = helloService.sayHello(&quot;jack&quot;);
        System.out.println(jack);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConsumerApplication {
    public static void main(String[] args) {
                AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class);
        SayHelloConsumer consumer = context.getBean(SayHelloConsumer.class);
        consumer.sayHello();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;强调:注解使用时,扫描服务的实现类使用dubbo提供的EnableDubbo注解,而扫描其他bean用的是spring的ComponentScan注解;&lt;/p&gt;

&lt;h2 id=&quot;启动时检查&quot;&gt;1.启动时检查&lt;/h2&gt;
&lt;p&gt;默认情况下,dubbo在启动时会自动检查依赖(作为消费者)的服务是否可用,若服务不可用则直接抛出异常并阻止容器正常初始化,但在一些情况下我们会希望先启动程序,因为服务可能会在之后的时间里变为可用的;&lt;/p&gt;
&lt;h3 id=&quot;启动检查注册中心&quot;&gt;启动检查注册中心&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--启动程序时是否检查注册中心的可用性--&amp;gt;
&amp;lt;dubbo:registry protocol=&quot;zookeeper&quot; check=&quot;true&quot; address=&quot;10.211.55.8:2181,10.211.55.7:2181,10.211.55.6:2181&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动检查服务提供方对所有提供者&quot;&gt;启动检查服务提供方(对所有提供者)&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--这里的启动指的是从容器中获取一个服务方的代理对象时  即getBean()时是否检查--&amp;gt;
&amp;lt;dubbo:consumer check=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动检查服务提供方对某个提供者&quot;&gt;启动检查服务提供方(对某个提供者)&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--这里的启动指的是从容器中获取一个服务方的代理对象时  即getBean()时是否检查--&amp;gt;
&amp;lt;dubbo:reference interface=&quot;com.yyh.service.HelloService&quot; id=&quot;helloService&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;properties文件写法:&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;java -Ddubbo.reference.com.foo.BarService.check=false
#强制修改所有reference的check
java -Ddubbo.reference.check=false
#当reference的check为空时有效
java -Ddubbo.consumer.check=false
java -Ddubbo.registry.check=false&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集群容错&quot;&gt;2.集群容错&lt;/h2&gt;
&lt;p&gt;在后续的使用中我们可能会对某一个服务部署多个示例形成集群,随着项目的运行时间越来越常,一些服务节点可能会宕机或是由于网络原因暂时不可用,集群容错可指定在调用服务失败时dubbo要采取的行为;&lt;/p&gt;
&lt;p&gt;dubbo提供以下6种容错机制:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;failover(默认)&lt;/td&gt;
&lt;td&gt;对调用者屏蔽调用失败的信息&lt;/td&gt;
&lt;td&gt;额外资源开销，资源浪费&lt;/td&gt;
&lt;td&gt;通讯环境良好,并发不高的场景&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;failfast&lt;/td&gt;
&lt;td&gt;业务快速感知失败状态进行自主决策&lt;/td&gt;
&lt;td&gt;产生较多报错的信息&lt;/td&gt;
&lt;td&gt;非幂等性操作，需要快速感知失败的场景&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;failsafe&lt;/td&gt;
&lt;td&gt;即使失败了也不会影响核心流程&lt;/td&gt;
&lt;td&gt;对于失败的信息不敏感，需要额外的监控&lt;/td&gt;
&lt;td&gt;旁路系统，失败不影响核心流程正确性的场景&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;failback&lt;/td&gt;
&lt;td&gt;失败自动异步重试&lt;/td&gt;
&lt;td&gt;重试任务可能堆积&lt;/td&gt;
&lt;td&gt;对于实时性要求不高，且不需要返回值的一些异步操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;forking&lt;/td&gt;
&lt;td&gt;并行发起多个调用，降低失败概率&lt;/td&gt;
&lt;td&gt;消耗额外的机器资源，需要确保操作幂等性&lt;/td&gt;
&lt;td&gt;资源充足，且对于失败的容忍度较低，实时性要求高的场景&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;broadcast&lt;/td&gt;
&lt;td&gt;支持对所有的服务提供者进行操作&lt;/td&gt;
&lt;td&gt;资源消耗很大&lt;/td&gt;
&lt;td&gt;通知所有提供者更新缓存或日志等本地资源信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;幂等性:指的是每次调用都会产生相同的结果,即不会对数据进行写操作(增删改)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置方式&quot;&gt;配置方式:&lt;/h3&gt;
&lt;p&gt;容错配置分为两个粒度:接口级别,方法级别&lt;/p&gt;
&lt;h4 id=&quot;服务方配置&quot;&gt;服务方配置:&lt;/h4&gt;
&lt;p&gt;服务方配置即将容错配置放在服务提供方,这样一来所有消费方就可以使用统一的容错机制,而不用每个消费方都配一遍;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--接口级别:--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; ref=&quot;helloService&quot; cluster=&quot;failover&quot; retries=&quot;2&quot;/&amp;gt;
&amp;lt;!--方法级别:--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; cluster=&quot;failover&quot; ref=&quot;helloService&quot;&amp;gt;
   &amp;lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;2&quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;消费方配置&quot;&gt;消费方配置:&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--接口级别:--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; ref=&quot;helloService&quot; cluster=&quot;failsafe&quot;/&amp;gt;
&amp;lt;!--方法级别--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; cluster=&quot;failover&quot; ref=&quot;helloService&quot;&amp;gt;
  &amp;lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;2&quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;负载均衡&quot;&gt;3.负载均衡&lt;/h2&gt;
&lt;p&gt;为了提高系统的可用性,能够承受更大的并发量,我们会将压力的服务部署为集群,但是如果每次请求都交给集群中的同一个节点,那这个几点很可能直接就宕了,所以合理的分配任务给集群中的每一台机器也是我们必须考虑的事情,好在dubbo已经提供相应的功能,我们只需简单的配置即可完成负载均衡;&lt;/p&gt;
&lt;p&gt;dubbo支持的任务分配方式:&lt;/p&gt;
&lt;h3 id=&quot;随机random&quot;&gt;随机random&lt;/h3&gt;
&lt;p&gt;顾名思义,从Provider列表中选择随机选择一个,但是我们可以为Provider指定权重,权重越大的被选中的几率越高,因此对于性能更好的机器应设置更大的权重,反之则反,如果不指定负载均衡，默认使用随机负载均衡;&lt;/p&gt;
&lt;h3 id=&quot;轮询roundrobin&quot;&gt;轮询roundrobin&lt;/h3&gt;
&lt;p&gt;即依次调用所有Provider,每个Provider轮流处理请求,当然我们也可以指定权重,Provider收到的请求数量比约等于权重比; 性能差的机器可能会累积一堆请求,最终拖慢整个系统;&lt;/p&gt;
&lt;h3 id=&quot;基于活跃数leastactive&quot;&gt;基于活跃数leastactive&lt;/h3&gt;
&lt;p&gt;每个Provider收到一个请求则将活跃数+1,每处理完成一个请求则活跃数-1,新的请求将会交给活跃数最少的Provider; 简单的说性能越好的机器将收到更多的请求,反之则反;&lt;/p&gt;
&lt;h3 id=&quot;基于hash一致consistenthash&quot;&gt;基于hash一致consistenthash&lt;/h3&gt;
&lt;p&gt;将根据Provider的 ip 或者其他的信息为Provider生成一个 hash，并将这个 hash 投射到 [0, 232 - 1] 的圆环上。当有请求时，则使用请求参数计算得出一个hash值。然后查找第一个大于或等于该 hash 值的缓存Provider，并将请求交予该Provider处理。如果当前Provider挂了，则在下一次请求时，为缓存项查找另一个大于其 hash 值的Provider即可。 具体算法参考:&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html&quot;&gt;去官网看看&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置方法&quot;&gt;配置方法:&lt;/h3&gt;
&lt;p&gt;与容错配置一样,我们可以选择在服务方或是消费方进行设置;&lt;/p&gt;
&lt;p&gt;服务方:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--接口级别--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; loadbalance=&quot;roundrobin&quot; /&amp;gt;
&amp;lt;!--方法级别--&amp;gt;
&amp;lt;dubbo:service interface=&quot;com.yyh.service.HelloService&quot; cluster=&quot;failover&quot; ref=&quot;helloService&quot;&amp;gt;
  &amp;lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;2&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费方:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--接口级别--&amp;gt;
&amp;lt;dubbo:reference interface=&quot;com.yyh.service.HelloService&quot; id=&quot;helloService&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;!--方法级别--&amp;gt;
&amp;lt;dubbo:reference interface=&quot;com.yyh.service.HelloService&quot; id=&quot;helloService&quot;&amp;gt;
    &amp;lt;dubbo:method name=&quot;sayHello&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;直连&quot;&gt;直连&lt;/h2&gt;
&lt;p&gt;即跳过注册中新直接找服务提供方,必须提前明确服务提供方的地址,所以该方式一般仅用于开发调试;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:registry address=&quot;N/A&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;仅订阅&quot;&gt;仅订阅&lt;/h2&gt;
&lt;p&gt;仅订阅指的是,不发布服务到注册中心,只从注册中心订阅依赖的服务;&lt;/p&gt;
&lt;p&gt;使用场景:当我们要开发一个新的Provider,而这个Provider需要依赖其他Provider时,使用,其目的是避免正在开发的服务发布后被消费方调用,因为开发还未完成,可能造成意想不到的结果; 这就用到了仅订阅,再搭配直连即可完成开发调试;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;10.211.55.8:2181&quot; register=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;仅注册&quot;&gt;仅注册&lt;/h2&gt;
&lt;p&gt;仅注册指的是,发布自身服务到注册中心,但不从注册中心订阅依赖的服务;&lt;/p&gt;
&lt;p&gt;使用场景: 自身需要对外提供服务,但是依赖的某个服务还在开发调试总,不能正常提供访问;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;10.211.55.8:2181&quot; subscribe=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多注册中心&quot;&gt;多注册中心&lt;/h2&gt;
&lt;p&gt;对于一些大型系统,为了加快响应速度,可能会在不同地区进行部署,例如阿里云分布在7个不同城市,有的时候可能因为当地系统还未部署完成,但是仍然需要提供访问,这是就需要我们将相同的服务注册到多个不同的注册中心;&lt;/p&gt;
&lt;p&gt;反过来,一些时候当前系统依赖的服务可能部署在不同的注册中心中,这就需要同时向多个不同的注册中心订阅服务;&lt;/p&gt;
&lt;p&gt;配置方式也非常简单,添加额外registry即可;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在Common模块中创建新的接口&lt;code&gt;com.yyh.service.UserService&lt;/code&gt;,同时在Provider中实现该接口,最后发布到注册中心;&lt;/p&gt;
&lt;h3 id=&quot;发布到多个注册中心&quot;&gt;发布到多个注册中心&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--两个注册中心--&amp;gt;
&amp;lt;dubbo:registry id=&quot;reg1&quot; protocol=&quot;zookeeper&quot; address=&quot;10.211.55.8:2181,10.211.55.7:2181,10.211.55.6:2181&quot;/&amp;gt;
&amp;lt;dubbo:registry id=&quot;reg2&quot; protocol=&quot;zookeeper&quot; address=&quot;10.211.55.7:2188&quot;/&amp;gt;

&amp;lt;!--注册到多个注册中心 id用逗号隔开--&amp;gt;
&amp;lt;dubbo:service registry=&quot;reg1,reg2&quot; interface=&quot;com.yyh.service.HelloService&quot; ref=&quot;helloService&quot; cluster=&quot;failsafe&quot; loadbalance=&quot;random&quot;/&amp;gt;
&amp;lt;!--userService仅注册到id为reg2的注册中心--&amp;gt;
&amp;lt;dubbo:service registry=&quot;reg2&quot; interface=&quot;com.kkb.service.UserService&quot; ref=&quot;userService&quot; cluster=&quot;failsafe&quot; loadbalance=&quot;random&quot;/&amp;gt;

&amp;lt;!--实现Bean--&amp;gt;
&amp;lt;bean id=&quot;helloService&quot; class=&quot;com.kkb.service.impl.HelloServiceImpl&quot;/&amp;gt;
&amp;lt;bean id=&quot;userService&quot; class=&quot;com.kkb.service.impl.UserServiceImpl&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从不同注册中心订阅&quot;&gt;从不同注册中心订阅&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--两个注册中心--&amp;gt;
&amp;lt;dubbo:registry id=&quot;reg1&quot; protocol=&quot;zookeeper&quot; address=&quot;10.211.55.8:2181,10.211.55.7:2181,10.211.55.6:2181&quot;/&amp;gt;
&amp;lt;dubbo:registry id=&quot;reg2&quot; protocol=&quot;zookeeper&quot; address=&quot;10.211.55.7:2188&quot;/&amp;gt;
&amp;lt;!--从两个注册中心分别订阅 --&amp;gt;
&amp;lt;dubbo:reference interface=&quot;com.yyh.service.HelloService&quot; id=&quot;helloService&quot; cluster=&quot;failover&quot; retries=&quot;3&quot; registry=&quot;reg1&quot;/&amp;gt;
&amp;lt;dubbo:reference interface=&quot;com.yyh.service.UserService&quot; id=&quot;userService&quot; cluster=&quot;failover&quot; retries=&quot;3&quot; registry=&quot;reg2&quot;/&amp;gt;
&amp;lt;dubbo:consumer check=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 10 Mar 2020 12:28:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>注册中心zookeeper 什么是注册中心: 注册中心就是用来存储服务信息的地方,就像房屋中介一样; 为什么需要注册中心: 在前面的例子中我们使用了客户端与服务器直连的方式完成了服务的调用,在实际开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12458362.html</dc:identifier>
</item>
</channel>
</rss>