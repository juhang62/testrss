<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 9.0 新特性预览 - 顶级语句 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-top-level-statements.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-top-level-statements.html</guid>
<description>&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。 目录&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;128.68875893437&quot;&gt;


&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-target-typed-new.html&quot;&gt;C# 9.0 新特性预览 - 类型推导的 new&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-null-arg-checking.html&quot;&gt;C# 9.0 新特性预览 - 空参数校验&lt;/a&gt;]&lt;br/&gt;[C# 9.0 新特性预览 - 顶级语句]&lt;br/&gt;[C# 9.0 新特性预览 - Record 类型]&lt;br/&gt;[C# 9.0 新特性预览 - 模式匹配的改善]&lt;br/&gt;[C# 9.0 新特性预览 - 源代码生成器]&lt;br/&gt;[C# 9.0 新特性预览 - 其他小的变化]&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;顶级语句-top-level-statements&quot;&gt;顶级语句 (Top-level statements)&lt;/h3&gt;
&lt;p&gt;顶级语句这个名字看起来不是那么直观，或许它的曾用名更好一些：Simple Programs，简单程序。&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;目的&quot;&gt;目的&lt;/h4&gt;
&lt;p&gt;想必大家都知道，即使是最简单的 C# 程序，也会有一定量的繁文缛节，因为最少也需要一个 Main 方法。这似乎妨碍了语言的学习和程序的清晰度。因此，这个特性的最主要目的就是为了初学者和代码的清晰度，让书写 C# 程序可以变得更轻松。&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;p&gt;语法 Spec 如下，允许在命名空间的声明前面，添加一组语句，且只允许有一个编译单元（可以认为是一个源文件）拥有这种语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;compilation_unit
    : extern_alias_directive* using_directive* global_attributes? statement* namespace_member_declaration*
    ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spec 比较难懂，我们直接来看示例：简单来说，就是允许在源文件中直接书写代码语句而不用写 Main 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;System.Console.WriteLine(&quot;Hi!&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码会被翻译为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static class $Program
{
    static void $Main(string[] args)
    {
        System.Console.WriteLine(&quot;Hi!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，WriteLine语句被自动的包在了一个类和 Main 方法里面。&lt;br/&gt;自动生成的 Main 方法的返回值也会根据是否异步以及是否有返回值来变化，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await System.Threading.Tasks.Task.Delay(1000);
System.Console.WriteLine(&quot;Hi!&quot;);
return 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被翻译为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static class $Program
{
    static async Task&amp;lt;int&amp;gt; $Main(string[] args)
    {
        await System.Threading.Tasks.Task.Delay(1000);
        System.Console.WriteLine(&quot;Hi!&quot;);
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;各种场景&quot;&gt;各种场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;支持在 using 语句后面：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

Console.Write(&quot;Hi!&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被翻译为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

static class $Program
{
    static void $Main(string[] args)
    {
        Console.Write(&quot;Hi!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;也可以加上本地函数：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;local();
void local() =&amp;gt; System.Console.WriteLine(2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以与其它代码共存，例如类的声明：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Type.M();
static class Type
{
    public static void M()
    {
        System.Console.WriteLine(&quot;Hi!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍微复杂一点的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;await using (var x = new C())
{
    System.Console.Write(&quot;body &quot;);
}
class C : System.IAsyncDisposable, System.IDisposable
{
    public System.Threading.Tasks.ValueTask DisposeAsync()
    {
        System.Console.Write(&quot;DisposeAsync&quot;);
        return new System.Threading.Tasks.ValueTask(System.Threading.Tasks.Task.CompletedTask);
    }
    public void Dispose()
    {
        System.Console.Write(&quot;IGNORED&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;同时兼容了using alias的语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using alias1 = Test;
string Test() =&amp;gt; &quot;&quot;1&quot;&quot;;
System.Console.WriteLine(Test());
class Test {}
delegate Test D(alias1 x);
namespace N1
{
    using alias2 = Test;
    delegate Test D(alias2 x);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;也可以同时与显示的 Main 方法声明在一起，只不过显示的Main方法会被忽略掉并提示一个警告&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Threading.Tasks;
System.Console.Write(&quot;Hi!&quot;);
class Program
{
    static void Main() // warning CS7022: The entry point of the program is global code; ignoring 'Program.Main()' entry point
    {
        Console.Write(&quot;hello&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;限制&quot;&gt;限制&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;不支持在多个编译单元下拥有顶级语句：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// file1.cs
System.Console.WriteLine(&quot;1&quot;); // error CS9001: Only one compilation unit can have top-level statements.

// file2.cs
System.Console.WriteLine(&quot;2&quot;); // error CS9001: Only one compilation unit can have top-level statements.
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不能放在类的内部&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Test
{
    System.Console.WriteLine(&quot;Hi!&quot;); // ERROR
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不能放在命名空间的内部&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace Test
{
    System.Console.WriteLine(&quot;Hi!&quot;); // ERROR
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;要么所有分支都有返回值，要么都没有&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;System.Console.WriteLine();
if (args.Length == 0)
{
    return 10; // error CS0161: 不是所有代码分支都有返回值
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;虽然可以可以与类声明一起写，但是在类中是无法调用到 Main 方法 args 入参的，因为编译时会编译为两个类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;System.Console.WriteLine(args);
class Test
{
    void M()
    {
        System.Console.WriteLine(args); // ERROR
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;自然，你也不能用 args 来命名本地函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;args(1);
void args(int x) // ERROR
{}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/proposals/null-arg-checking.md&quot;&gt;Proposal: Simplified Null Argument Checking&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://github.com/dotnet/roslyn/blob/features%2Fparam-nullchecking/src/Compilers/CSharp/Test/Semantic/Semantics/NullCheckedParameterTests.cs&quot;&gt;Unit test: NullCheckedParameterTests.cs&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-07-10.md#param&quot;&gt;LDM-2019-07-10.md&lt;/a&gt;]&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 23 Sep 2020 00:41:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。 目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-top-level-statements.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.x启动时运行异步任务（二） - 老王Plus</title>
<link>http://www.cnblogs.com/tiger-wang/p/13714679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-wang/p/13714679.html</guid>
<description>&lt;blockquote readability=&quot;5.5714285714286&quot;&gt;
&lt;p&gt;这一篇是接着前一篇在写的。如果没有看过前一篇文章，建议先去看一下前一篇，这儿是&lt;a href=&quot;https://www.cnblogs.com/tiger-wang/p/13673046.html&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;前一篇文章，我们从应用启动时异步运行任务开始，说到了必要性，也说到了几种解决方法，及各自的优缺点。最后，还提出了一个比较合理的解决方法：通过在&lt;code&gt;Program.cs&lt;/code&gt;里加入代码，来实现&lt;code&gt;IWebHost&lt;/code&gt;启动前运行异步任务。&lt;/p&gt;
&lt;p&gt;实现的代码再贴一下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; async Task &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;IWebHost webHost = CreateWebHostBuilder(args).Build();&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; (var scope = webHost.Services.CreateScope())&lt;br/&gt;{&lt;br/&gt;var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();&lt;/p&gt;&lt;p&gt;await myDbContext.Database.MigrateAsync();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;await webHost.RunAsync();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IWebHostBuilder &lt;span class=&quot;hljs-title&quot;&gt;CreateWebHostBuilder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;=&amp;gt;&lt;br/&gt;WebHost.CreateDefaultBuilder(args)&lt;br/&gt;.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法是有效的。但是，也会有一点不足。&lt;/p&gt;
&lt;p&gt;从.Net Core的最简规则来说，我们不应该在&lt;code&gt;Program.cs&lt;/code&gt;中加入其它代码。当然，我们可以把这部分代码转到一个外部类中，但最后也必须手动加入到&lt;code&gt;Program.cs&lt;/code&gt;中。尤其是在多个应用中，使用相同的模式时，这种方式会很麻烦。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    &lt;span&gt;为防止非授权转发，这儿给出本文的原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/tiger-wang/p/13714679.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tiger-wang/p/13714679.html&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;也许，我们可以采用向DI容器中注入启动任务？&lt;/p&gt;

&lt;p&gt;这种方式，是基于&lt;code&gt;IStartupFilter&lt;/code&gt;和&lt;code&gt;IHostedService&lt;/code&gt;两个接口，通过这两个接口可以向依赖注入容器中注册类。&lt;/p&gt;

&lt;p&gt;首先，我们为启动任务创建一个简单接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; interface IStartupTask&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;Task &lt;span class=&quot;hljs-title&quot;&gt;ExecuteAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再建一个扩展方法，用来向DI容器注册启动任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ServiceCollectionExtensions&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IServiceCollection AddStartupTask&amp;lt;T&amp;gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; IServiceCollection services)&lt;br/&gt;where T : &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;IStartupTask&lt;/span&gt;&lt;br/&gt;=&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;services&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;AddTransient&lt;/span&gt;&amp;lt;IStartupTask, T&amp;gt;();&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，再建一个扩展方法，在应用启动时，查找所有已注册的&lt;code&gt;IStartupTask&lt;/code&gt;，按顺序执行他们，然后启动&lt;code&gt;IWebHost&lt;/code&gt;：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StartupTaskWebHostExtensions&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; async Task &lt;span class=&quot;hljs-title&quot;&gt;RunWithTasksAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; IHost webHost, CancellationToken cancellationToken = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;var startupTasks = webHost.Services.GetServices&amp;lt;IStartupTask&amp;gt;();&lt;p&gt;foreach (var startupTask in startupTasks)&lt;br/&gt;{&lt;br/&gt;await startupTask.ExecuteAsync(cancellationToken);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;await webHost.RunAsync(cancellationToken);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就齐活了。&lt;/p&gt;

&lt;p&gt;还是用一个例子来看看这个方式的具体应用。&lt;/p&gt;

&lt;p&gt;实现&lt;code&gt;IStartupTask&lt;/code&gt;其实和实现&lt;code&gt;IStartupFilter&lt;/code&gt;很相似，可以从DI容器中注入。如果需要考虑作用域，还可以注入&lt;code&gt;IServiceProvider&lt;/code&gt;，并手动创建作用域。&lt;/p&gt;

&lt;p&gt;例子中，数据迁移类可以写成这样：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MigratorStartupFilter&lt;/span&gt;:&lt;/span&gt; IStartupTask&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; readonly IServiceProvider _serviceProvider;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MigratorStartupFilter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceProvider serviceProvider)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_serviceProvider = serviceProvider;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; async Task &lt;span class=&quot;hljs-title&quot;&gt;ExecuteAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt;(var scope = _seviceProvider.CreateScope())&lt;br/&gt;{&lt;br/&gt;var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();&lt;br/&gt;await myDbContext.Database.MigrateAsync();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，把任务注入到&lt;code&gt;ConfigureServices()&lt;/code&gt;中：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);&lt;p&gt;services.AddStartupTask&amp;lt;MigrationStartupTask&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，用上一节中的扩展方法&lt;code&gt;RunWithTasksAsync()&lt;/code&gt;来替代&lt;code&gt;Program.cs&lt;/code&gt;中的&lt;code&gt;Run()&lt;/code&gt;:&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; async Task &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;await &lt;span class=&quot;hljs-title&quot;&gt;CreateWebHostBuilder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args)&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Build&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;RunWithTasksAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IWebHostBuilder &lt;span class=&quot;hljs-title&quot;&gt;CreateWebHostBuilder&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;=&amp;gt;&lt;br/&gt;WebHost.CreateDefaultBuilder(args)&lt;br/&gt;.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;从功能上来说，跟上一篇的代码区别不大，但这样的写法，又多了一些优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任务代码放到了&lt;code&gt;Program.cs&lt;/code&gt;之外。这符合微软的建议，也更容易理解；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任务放到了DI容器中，这样更容易添加额外的任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果没有额外任务，这个代码和标准的&lt;code&gt;Run()&lt;/code&gt;一样，所以这个代码可以独立成一个模板。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单来说，使用&lt;code&gt;RunWithTasksAsync()&lt;/code&gt;后，可以轻松地向DI容器添加额外的任务，而不需要任何其它的更改。&lt;/p&gt;

&lt;p&gt;满意了吗？好像感觉还差一点点…&lt;/p&gt;

&lt;p&gt;如果要照着完美去做，好像还差一点点。&lt;/p&gt;
&lt;p&gt;这个一点点是在于：任务现在运行在&lt;code&gt;IConfiguration&lt;/code&gt;和DI容器配置完成后，&lt;code&gt;IStartupFilters&lt;/code&gt;运行和中间件管道配置完成之前。换句话说，如果任务需要依赖于&lt;code&gt;IStartupFilters&lt;/code&gt;，那这个方案行不通。&lt;/p&gt;
&lt;p&gt;在大多数情况下，这没什么问题。以我自己的经验来看，好像没有什么功能需要依赖于&lt;code&gt;IStartupFilters&lt;/code&gt;。但作为一个框架类的代码，需要考虑这种情况发生的可能性。&lt;/p&gt;
&lt;p&gt;以目前的方案来说，好像还没办法解决。&lt;/p&gt;
&lt;p&gt;应用启动时，当调用&lt;code&gt;WebHost.Run()&lt;/code&gt;时，是内部调用&lt;code&gt;WebHost&lt;/code&gt;。看一下&lt;code&gt;StartAsync()&lt;/code&gt;的简化代码：&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; async Task &lt;span class=&quot;hljs-title&quot;&gt;StartAsync&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CancellationToken cancellationToken = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_logger = _applicationServices.GetRequiredService&amp;lt;ILogger&amp;lt;WebHost&amp;gt;&amp;gt;();&lt;p&gt;var application = BuildApplication();&lt;/p&gt;&lt;p&gt;_applicationLifetime = _applicationServices.GetRequiredService&amp;lt;IApplicationLifetime&amp;gt;() as ApplicationLifetime;&lt;br/&gt;_hostedServiceExecutor = _applicationServices.GetRequiredService&amp;lt;HostedServiceExecutor&amp;gt;();&lt;br/&gt;var diagnosticSource = _applicationServices.GetRequiredService&amp;lt;DiagnosticListener&amp;gt;();&lt;br/&gt;var httpContextFactory = _applicationServices.GetRequiredService&amp;lt;IHttpContextFactory&amp;gt;();&lt;br/&gt;var hostingApp = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HostingApplication(application, _logger, diagnosticSource, httpContextFactory);&lt;/p&gt;&lt;p&gt;await Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;_applicationLifetime?.NotifyStarted();&lt;/p&gt;&lt;p&gt;await _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们希望任务是加在&lt;code&gt;BuildApplication()&lt;/code&gt;调用和&lt;code&gt;Server.StartAsync()&lt;/code&gt;的调用之间，该怎么办？&lt;/p&gt;
&lt;p&gt;这段代码能给出答案：我们需要装饰IServer&lt;code&gt;。 ¨K16K 首先，我们替换&lt;/code&gt;IServer&lt;code&gt;的实现： ¨G8G 在这段代码中，我们拦截&lt;/code&gt;StartAsync()&lt;code&gt;调用并注入任务，然后回到内置处理。 下面是对应的扩展代码： ¨G9G 这个扩展代码做了两件事：在DI容器中注册了&lt;/code&gt;IStartupTask&lt;code&gt;，并装饰了之前注册的&lt;/code&gt;IServer&lt;code&gt;实例。装饰方法&lt;/code&gt;Decorate()&lt;code&gt;我略过了，有兴趣的可以去了解一下 - 装饰模式。&lt;/code&gt; Program.cs&lt;code&gt;的代码和第三节的代码相同，略过。 &amp;amp;emsp; 我们终于做到了在应用程序完全构建完成后去执行我们的任务，包括&lt;/code&gt;IStartupFilters`和中间件管道。&lt;/p&gt;
&lt;p&gt;现在的流程，类似于下面这个微软官方的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/907112/202009/907112-20200922202409863-1029024113.png&quot; alt=&quot;&quot; width=&quot;1040&quot; height=&quot;693&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;


&lt;hr/&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/907112/202005/907112-20200527230728396-985375280.jpg&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;160&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;微信公众号：老王Plus&lt;/p&gt;
&lt;p&gt;扫描二维码，关注个人公众号，可以第一时间得到最新的个人文章和内容推送&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，转载请保留此声明和原文链接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 23 Sep 2020 00:37:00 +0000</pubDate>
<dc:creator>老王Plus</dc:creator>
<og:description>这一篇是接着前一篇在写的。如果没有看过前一篇文章，建议先去看一下前一篇，这儿是传送门 一、前言 前一篇文章，我们从应用启动时异步运行任务开始，说到了必要性，也说到了几种解决方法，及各自的优缺点。最后，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-wang/p/13714679.html</dc:identifier>
</item>
<item>
<title>一个提高N倍系统新能的编程点，却总是被普通开发们遗忘 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13716134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13716134.html</guid>
<description>&lt;p&gt;位运算这个概念并不陌生，大多数程序员在进入这个领域的时候或多或少都接触过位运算，估计当时都写过不少练习题的。&lt;/p&gt;
&lt;p&gt;位运算本身不难，困难的是大家没有学会在系统设计时用上它，提高系统性能，增加你的不可替代性。&lt;/p&gt;
&lt;p&gt;就不做太多铺垫了，直接说下今天讲述的干货内容：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gigtprpcssj30tm0iit9t.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;位运算使用场景&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;面试经常问&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;比如我曾经在面试腾讯的时候&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;O(1) 时间如何检测整数 n 是否是 2 的幂次？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在看一道Google面试题：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有64瓶药，其中63瓶是无毒的，一瓶是有毒的。如果做实验的小白鼠喝了有毒的药，3天后会死掉，当然喝了其它的药，包括同时喝几种就没事。现在只剩下3天时间，请问最少需要多少只小白鼠才能试出那瓶药有毒？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就不用龙su啰嗦了吧，稳稳的都是和位运算有关的。&lt;/p&gt;
&lt;p&gt;类似面试题目还有很多，一个不注意就会被撂倒。&lt;/p&gt;
&lt;p&gt;这部分的题目整体难度不大，本身不是一个很大的知识点，但是&lt;strong&gt;很容易被大家忽略&lt;/strong&gt;，今天龙su就拿出来好好说说，大家可要记住喔，不然…&lt;/p&gt;
&lt;img src=&quot;https://i04piccdn.sogoucdn.com/3264bfa09280616c&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;系统设计经常用&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;喜欢看源码的同学就会注意到，经常在里面看到这样的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lucene源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1giidsgp6juj30ix0m6whh.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;redis源码&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1giidury7cyj30iw0mbwgs.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;龙叔的源码&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1giidvyz2fqj30iv0m0q51.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;有没有发现这些代码惊人的相似，&lt;strong&gt;好的设计总是这样不谋而合&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi988505u1g30710714qp.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;看了这么多，想必大家已经知道这东西还是有些作用的，应该好好搞清楚他的原理。接下来就一起来盘他。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;位运算原理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;位&lt;/strong&gt; 指的是比特位(bit)，不是byte，所以位运算指的就是比特位计算。&lt;/p&gt;
&lt;p&gt;CPU所有计算都是二进制的计算，一个高性能的服务一定是把CPU资源利用到极致，也就是用最少资源换取最大收益。&lt;/p&gt;
&lt;p&gt;当然随着现代CPU的计算速度不断加快，很多人在设计系统的时候完全不会去考虑这些性能点，然而真正的高并发系统都是极致性能的。&lt;/p&gt;
&lt;p&gt;看看我们日常开发都是啥样的，只要不涉及到&lt;strong&gt;高并发&lt;/strong&gt;，开发代码就算是一坨屎，也没关系，大多数人都是在这坨屎上继续CRUD，也就会变成了一大坨。&lt;/p&gt;
&lt;p&gt;没办法，老板只看结果，懒得管你的代码是什么样的。哎呀，好像暴露了龙叔是个CRUD菜鸡选手。&lt;/p&gt;
&lt;p&gt;等到有一天发现加机器加到扛不住了，这时候就是&lt;strong&gt;最幸运&lt;/strong&gt;的一批程序员诞生的时候，必须开始重构系统。为什么最幸运，大家都知道了吧？机会不是天天有的，这就是千载难逢的良机啊。&lt;/p&gt;
&lt;p&gt;哈，好像有点说远了。&lt;/p&gt;
&lt;p&gt;在计算机世界里，万物皆0、1，0、1生万物。万物到0、1的过程叫做编码。&lt;/p&gt;
&lt;p&gt;一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的最高位存放符号, 正数为0, 负数为1。&lt;/p&gt;
&lt;p&gt;计算机中对数字的编码表示有三种方式：&lt;strong&gt;原码&lt;/strong&gt;，&lt;strong&gt;反码&lt;/strong&gt;，&lt;strong&gt;补码&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原码&lt;/strong&gt;：原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1。比如十进制3如果用8个二进制位来表示就是 00000011， -3就是 10000011。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反码&lt;/strong&gt;：反码表示方法：正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余各个位取反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码&lt;/strong&gt;：补码表示方法：正数的补码是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。 (即在反码的基础上+1)&lt;/p&gt;
&lt;p&gt;这三种是编码方式，但是在计算机系统中，数值一律用补码来表示（存储）。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;. &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;原码           反码         补码&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt;  --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt; --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;. -&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;10001111&lt;/span&gt;  --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;11110000&lt;/span&gt; --&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;11110001&lt;/span&gt;  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说完了数据编码，基本已经知道一个数据是怎么存储在计算机中的，接下来就看看数据比特位之间是如何计算的。&lt;/p&gt;
&lt;p&gt;各种编程语言都提供了对补码的二进制位直接进行运算的方法，即&lt;strong&gt;位运算&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;规则&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;相同位的两个数字都为1，则为1；若有一个不为1，则为0。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;相同位只要一个为1即为1。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;td&gt;0和1全部取反。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;亦或&lt;/td&gt;
&lt;td&gt;相同位不同则为1，相同则为0。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;左移&lt;/td&gt;
&lt;td&gt;a &amp;lt;&amp;lt; b就表示把a转为二进制后左移b位（在后面添b个0）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;右移&lt;/td&gt;
&lt;td&gt;a &amp;gt;&amp;gt; b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h-4&quot;&gt;&lt;span&gt;举几个例子&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; &amp;amp; -&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt; &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;11110001&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gijjkzy23rj30ee0620sr.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;按位进行相与，相同为1则为1，否则为0，最终算的结果为00000000 即0&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt; &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;00001111&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gijjmagap1j30du05u0sr.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;按位进行相与，相同为1则为1，否则为0，最终算的结果为00001010 即10&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; | &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;00001010&lt;/span&gt; | &lt;span class=&quot;hljs-number&quot;&gt;00001111&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gijjysgfg3j30rc0d8jtz.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;按位进行或逻辑，相同位只要一个为1即为1 ，00001111即15&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gijk5b0qslj30he0b274c.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;二进制右移2位，左边填符号号位，右边抹掉，得到00000011 即3&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gijk3iucumj30go08amx6.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;二进制左移2位，左边抹掉，符号位不变，右边填0，得到00111100&lt;/p&gt;
&lt;p&gt;原理还是比较简单，主要就是对比特位进行逻辑操作。&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;位运算为什么那么快？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;看到这里其实大多数人已经明白为什么位运算快了，但暖心的龙叔还是在啰嗦下原因，就算是锦上添花（画蛇添足）了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;存储更友好，比特位存储，不用转换后在存储&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CPU更友好，直接比特位操作，减少机器数到比特位的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;寻址次数更少，左移一位就乘2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;说一个搜索里面位运算带来的性能提升&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;比如你在百度搜索 &lt;strong&gt;广东富婆&lt;/strong&gt; ，分词会分为 &lt;strong&gt;广东&lt;/strong&gt; &lt;strong&gt;富婆&lt;/strong&gt; 两个词，分别从两个倒排中召回，假设 &lt;strong&gt;广东&lt;/strong&gt; 这个词召回了100w个doc，&lt;strong&gt;富婆&lt;/strong&gt; 召回了1000W个。&lt;/p&gt;
&lt;p&gt;此时两个doc链会进行一个合并，合并的返回结果是存在广东的同时又要存在富婆的doc。&lt;/p&gt;
&lt;p&gt;这个合并如果是通过比特位的方式操作的话，一个64位的CPU一个&lt;strong&gt;指令周期&lt;/strong&gt;可以处理64个doc，如果采用普通合并的话，一次只能合并一个doc，这个性能提升很明显的吧，是不是感觉高性能有点意思了。&lt;/p&gt;
&lt;p&gt;像这种性能上的提升，是无法通过增&lt;strong&gt;加机器&lt;/strong&gt;解决的。&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这次内容不难，讲出来是希望大家在做系统设计时，性能考虑不是简单的加机器，而是真的把CPU价值最大化。&lt;/p&gt;
&lt;p&gt;小改动、大效果，一些小的改动，会对性能提升产生很多的效果。反正我这次设计时基本把一些计算都改为了位运算。&lt;/p&gt;
&lt;p&gt;我是龙叔，一个在互联网大器晚成的设计师，我们下期见。喜欢我，记得&lt;strong&gt;关注&lt;/strong&gt;我。&lt;/p&gt;
</description>
<pubDate>Wed, 23 Sep 2020 00:27:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>位运算这个概念并不陌生，大多数程序员在进入这个领域的时候或多或少都接触过位运算，估计当时都写过不少练习题的。 位运算本身不难，困难的是大家没有学会在系统设计时用上它，提高系统性能，增加你的不可替代性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13716134.html</dc:identifier>
</item>
<item>
<title>MySQL的共享锁阻塞会话案例浅析 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/13716132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/13716132.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这是问题是一个网友遇到的问题：一个UPDATE语句产生的共享锁阻塞了其他会话的案例，对于这个案例，我进一步分析、总结和衍化了相关问题。下面分析如有不对的地方，敬请指正。下面是初始化环境和数据的脚本&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;36&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-- Table structure for table `tableA`&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DROP TABLE IF EXISTS `tableA`;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `tableA` (
&lt;/pre&gt;
&lt;pre&gt;
  `id` &lt;span&gt;varchar&lt;/span&gt;(10) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
  `name` &lt;span&gt;varchar&lt;/span&gt;(10) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
  &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`id`)
&lt;/pre&gt;
&lt;pre&gt;
) ENGINE=InnoDB;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-- Dumping data for table `tableA`&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;LOCK TABLES `tableA` WRITE;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; `tableA` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'1'&lt;/span&gt;,&lt;span&gt;'11'&lt;/span&gt;),(&lt;span&gt;'2'&lt;/span&gt;,&lt;span&gt;'22'&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
UNLOCK TABLES;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-- Table structure for table `tableB`&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; `tableB`;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `tableB` (
&lt;/pre&gt;
&lt;pre&gt;
  `id` &lt;span&gt;varchar&lt;/span&gt;(10) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
  `bill_id` &lt;span&gt;varchar&lt;/span&gt;(10) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
  `update_time` bigint(12) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
  &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`id`),
&lt;/pre&gt;
&lt;pre&gt;
  &lt;span&gt;KEY&lt;/span&gt; `idx_bill_id` (`bill_id`)
&lt;/pre&gt;
&lt;pre&gt;
) ENGINE=InnoDB;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-- Dumping data for table `tableB`&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
LOCK TABLES `tableB` &lt;span&gt;WRITE&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/*!40000 ALTER TABLE `tableB` DISABLE KEYS */;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; `tableB` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'100'&lt;/span&gt;,&lt;span&gt;'1'&lt;/span&gt;,1586880000000),(&lt;span&gt;'200'&lt;/span&gt;,&lt;span&gt;'2'&lt;/span&gt;,1586793600000),(&lt;span&gt;'300'&lt;/span&gt;,&lt;span&gt;'2'&lt;/span&gt;,1586880000000),(&lt;span&gt;'400'&lt;/span&gt;,&lt;span&gt;'2'&lt;/span&gt;,1586880000000),(&lt;span&gt;'500'&lt;/span&gt;,&lt;span&gt;'3'&lt;/span&gt;,1586990000000),(&lt;span&gt;'600'&lt;/span&gt;,&lt;span&gt;'4'&lt;/span&gt; ,1586990000000);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/*!40000 ALTER TABLE `tableB` ENABLE KEYS */;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
UNLOCK TABLES;
&lt;/pre&gt;
&lt;pre&gt;
```
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面我们先通过实验模拟一下这个阻塞问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;事务的级别为默认的可重复读级别&lt;/span&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;Repeatable Read&lt;/span&gt;），&lt;/span&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实验环境： MySQL 5.6.25&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话1（连接ID=52）在autocommit=0下面，执行一个update语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;13.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              52 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;session&lt;/span&gt; autocommit=0;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Rows&lt;/span&gt; matched: 1  Changed: 1  Warnings: 0
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话2（连接ID=54）执行一个delete语句被阻塞&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              54 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'1'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话3中进行分析、查看这些阻塞、锁等相关信息，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;64.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;124&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; b.trx_mysql_thread_id             &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_thread_id'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;       ,b.trx_query                        &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_sql_text'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;       ,c.trx_mysql_thread_id             &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocker_thread_id'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;       ,c.trx_query                       &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocker_sql_text'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;       ,( Unix_timestamp() - Unix_timestamp(c.trx_started) ) 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;        &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_time'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;FROM&lt;/span&gt;   information_schema.innodb_lock_waits a 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; information_schema.innodb_trx b 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          &lt;span&gt;ON&lt;/span&gt; a.requesting_trx_id = b.trx_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; information_schema.innodb_trx c 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          &lt;span&gt;ON&lt;/span&gt; a.blocking_trx_id = c.trx_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;  ( Unix_timestamp() - Unix_timestamp(c.trx_started) ) &amp;gt; 4; 
&lt;/pre&gt;
&lt;pre&gt;
+-------------------+--------------------------------------+-------------------+------------------+--------------+
&lt;/pre&gt;
&lt;pre&gt;
| blocked_thread_id | blocked_sql_text                     | blocker_thread_id | blocker_sql_text | blocked_time |
&lt;/pre&gt;
&lt;pre&gt;
+-------------------+--------------------------------------+-------------------+------------------+--------------+
&lt;/pre&gt;
&lt;pre&gt;
|                54 | &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'1'&lt;/span&gt; |                52 | &lt;span&gt;NULL&lt;/span&gt;             |           39 |
&lt;/pre&gt;
&lt;pre&gt;
+-------------------+--------------------------------------+-------------------+------------------+--------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.01 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; INFORMATION_SCHEMA.INNODB_TRX\G;
&lt;/pre&gt;
&lt;pre&gt;
*************************** 1. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
                    trx_id: 1261156958
&lt;/pre&gt;
&lt;pre&gt;
                 trx_state: LOCK WAIT
&lt;/pre&gt;
&lt;pre&gt;
               trx_started: 2020-09-21 07:05:36
&lt;/pre&gt;
&lt;pre&gt;
     trx_requested_lock_id: 1261156958:1678:4:2
&lt;/pre&gt;
&lt;pre&gt;
          trx_wait_started: 2020-09-21 07:05:36
&lt;/pre&gt;
&lt;pre&gt;
                trx_weight: 2
&lt;/pre&gt;
&lt;pre&gt;
       trx_mysql_thread_id: 54
&lt;/pre&gt;
&lt;pre&gt;
                 trx_query: &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'1'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
       trx_operation_state: starting &lt;span&gt;index&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_in_use: 1
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_locked: 1
&lt;/pre&gt;
&lt;pre&gt;
          trx_lock_structs: 2
&lt;/pre&gt;
&lt;pre&gt;
     trx_lock_memory_bytes: 360
&lt;/pre&gt;
&lt;pre&gt;
           trx_rows_locked: 1
&lt;/pre&gt;
&lt;pre&gt;
         trx_rows_modified: 0
&lt;/pre&gt;
&lt;pre&gt;
   trx_concurrency_tickets: 0
&lt;/pre&gt;
&lt;pre&gt;
       trx_isolation_level: REPEATABLE &lt;span&gt;READ&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_unique_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
    trx_foreign_key_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
trx_last_foreign_key_error: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_latched: 0
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_timeout: 10000
&lt;/pre&gt;
&lt;pre&gt;
          trx_is_read_only: 0
&lt;/pre&gt;
&lt;pre&gt;
trx_autocommit_non_locking: 0
&lt;/pre&gt;
&lt;pre&gt;
*************************** 2. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
                    trx_id: 1261156943
&lt;/pre&gt;
&lt;pre&gt;
                 trx_state: RUNNING
&lt;/pre&gt;
&lt;pre&gt;
               trx_started: 2020-09-21 07:05:28
&lt;/pre&gt;
&lt;pre&gt;
     trx_requested_lock_id: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
          trx_wait_started: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
                trx_weight: 6
&lt;/pre&gt;
&lt;pre&gt;
       trx_mysql_thread_id: 52
&lt;/pre&gt;
&lt;pre&gt;
                 trx_query: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
       trx_operation_state: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_in_use: 0
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_locked: 0
&lt;/pre&gt;
&lt;pre&gt;
          trx_lock_structs: 5
&lt;/pre&gt;
&lt;pre&gt;
     trx_lock_memory_bytes: 1184
&lt;/pre&gt;
&lt;pre&gt;
           trx_rows_locked: 14
&lt;/pre&gt;
&lt;pre&gt;
         trx_rows_modified: 1
&lt;/pre&gt;
&lt;pre&gt;
   trx_concurrency_tickets: 0
&lt;/pre&gt;
&lt;pre&gt;
       trx_isolation_level: REPEATABLE &lt;span&gt;READ&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_unique_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
    trx_foreign_key_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
trx_last_foreign_key_error: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_latched: 0
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_timeout: 10000
&lt;/pre&gt;
&lt;pre&gt;
          trx_is_read_only: 0
&lt;/pre&gt;
&lt;pre&gt;
trx_autocommit_non_locking: 0
&lt;/pre&gt;
&lt;pre&gt;
2 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
ERROR: 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;No&lt;/span&gt; query specified
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; INFORMATION_SCHEMA.INNODB_LOCKS\G;
&lt;/pre&gt;
&lt;pre&gt;
*************************** 1. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
    lock_id: 1261156958:1678:4:2
&lt;/pre&gt;
&lt;pre&gt;
lock_trx_id: 1261156958
&lt;/pre&gt;
&lt;pre&gt;
  lock_mode: X
&lt;/pre&gt;
&lt;pre&gt;
  lock_type: RECORD
&lt;/pre&gt;
&lt;pre&gt;
 lock_table: `test`.`tableB`
&lt;/pre&gt;
&lt;pre&gt;
 lock_index: idx_bill_id
&lt;/pre&gt;
&lt;pre&gt;
 lock_space: 1678
&lt;/pre&gt;
&lt;pre&gt;
  lock_page: 4
&lt;/pre&gt;
&lt;pre&gt;
   lock_rec: 2
&lt;/pre&gt;
&lt;pre&gt;
  lock_data: &lt;span&gt;'1'&lt;/span&gt;, &lt;span&gt;'100'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
*************************** 2. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
    lock_id: 1261156943:1678:4:2
&lt;/pre&gt;
&lt;pre&gt;
lock_trx_id: 1261156943
&lt;/pre&gt;
&lt;pre&gt;
  lock_mode: S
&lt;/pre&gt;
&lt;pre&gt;
  lock_type: RECORD
&lt;/pre&gt;
&lt;pre&gt;
 lock_table: `test`.`tableB`
&lt;/pre&gt;
&lt;pre&gt;
 lock_index: idx_bill_id
&lt;/pre&gt;
&lt;pre&gt;
 lock_space: 1678
&lt;/pre&gt;
&lt;pre&gt;
  lock_page: 4
&lt;/pre&gt;
&lt;pre&gt;
   lock_rec: 2
&lt;/pre&gt;
&lt;pre&gt;
  lock_data: &lt;span&gt;'1'&lt;/span&gt;, &lt;span&gt;'100'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
2 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
ERROR: 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;No&lt;/span&gt; query specified
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; INFORMATION_SCHEMA.INNODB_LOCK_WAITS\G
&lt;/pre&gt;
&lt;pre&gt;
*************************** 1. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
requesting_trx_id: 1261156958
&lt;/pre&gt;
&lt;pre&gt;
requested_lock_id: 1261156958:1678:4:2
&lt;/pre&gt;
&lt;pre&gt;
  blocking_trx_id: 1261156943
&lt;/pre&gt;
&lt;pre&gt;
 blocking_lock_id: 1261156943:1678:4:2
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082553990-830431268.png&quot;&gt;&lt;img title=&quot;clip_image001[4]&quot; border=&quot;0&quot; alt=&quot;clip_image001[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082554672-438058368.png&quot; width=&quot;654&quot; height=&quot;590&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从上图的信息中，我们可以看出事务（trx_id=1261156958）处于等待状态，TRX_STATE是LOCK WAIT，表示当前事务事务正在等待锁资源的获取，通过lock_id，我们可以知道，事务在表空间ID为1678（即表tableB对应的表空间）,页码值为4，堆号2的记录上加了共享锁，而恰巧事务（trx_id=1261156943）在这些记录上拥有共享锁（S),导致事务事务（trx_id=1261156958）处于等待状态。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们知道共享锁(S)跟排他锁(X)是的兼容关系如下图所示，那么为什么会话1（线程ID=52）在表tableB的的bill_id='1'持有共享锁呢？其实如果你修改一下实验条件，你会发现delete任意记录都会被阻塞（例如delete from tableB where bill_id='4';），网友的问题是为什么这里共享锁锁定了整个tableB表呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082555039-949023806.png&quot;&gt;&lt;img title=&quot;clip_image002[4]&quot; border=&quot;0&quot; alt=&quot;clip_image002[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082555449-116515859.png&quot; width=&quot;601&quot; height=&quot;339&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么现在在有个问题：共享锁的粒度是什么粒度？ 答案是&lt;strong&gt;InnoDB存储引擎中，共享锁的粒度是行级别的&lt;/strong&gt;。如下资料所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Shared and Exclusive Locks&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;InnoDB implements standard row-level locking where there are two types of locks, &lt;u&gt;&lt;span&gt;&lt;span&gt;shared (S) locks&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; and &lt;u&gt;&lt;span&gt;&lt;span&gt;exclusive (X) locks&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;A &lt;u&gt;&lt;span&gt;&lt;span&gt;shared (S) lock&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; permits the transaction that holds the lock to read a row.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;An &lt;u&gt;&lt;span&gt;&lt;span&gt;exclusive (X) lock&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; permits the transaction that holds the lock to update or delete a row.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;If transaction T1 holds a shared (S) lock on row r, then requests from some distinct transaction T2 for a lock on row r are handled as follows:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;A request by T2 for an S lock can be granted immediately. As a result, both T1 and T2 hold an S lock on r.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;A request by T2 for an X lock cannot be granted immediately.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;If a transaction T1 holds an exclusive (X) lock on row r, a request from some distinct transaction T2 for a lock of either type on r cannot be granted immediately. Instead, transaction T2 has to wait for transaction T1 to release its lock on row r.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么也就是说会话1的UPDATE语句对表tableB中的所有行加了共享锁，为什么会这样呢？ 其实共享锁（S）锁一般是锁定读取的行。那么会话1中的SQL执行计划，肯定读取了tableB中所有的行，我们观察执行计划发现，&lt;/span&gt;&lt;span&gt;&lt;span&gt;优化器通过对索引idx_bill_id扫描，读取了此表的6条记录。这个也是业务逻辑使然。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;16&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;27&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
| id | select_type | &lt;span&gt;table&lt;/span&gt;      | type  | possible_keys | &lt;span&gt;key&lt;/span&gt;         | key_len | &lt;span&gt;ref&lt;/span&gt;   | &lt;span&gt;rows&lt;/span&gt; | Extra       |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
|  1 | &lt;span&gt;PRIMARY&lt;/span&gt;     | a          | const | &lt;span&gt;PRIMARY&lt;/span&gt;       | &lt;span&gt;PRIMARY&lt;/span&gt;     | 12      | const |    1 | &lt;span&gt;NULL&lt;/span&gt;        |
&lt;/pre&gt;
&lt;pre&gt;
|  1 | &lt;span&gt;PRIMARY&lt;/span&gt;     | &amp;lt;derived2&amp;gt; | &lt;span&gt;ref&lt;/span&gt;   | &amp;lt;auto_key0&amp;gt;   | &amp;lt;auto_key0&amp;gt; | 13      | const |    0 | &lt;span&gt;Using&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
|  2 | DERIVED     | tableB     | &lt;span&gt;index&lt;/span&gt; | idx_bill_id   | idx_bill_id | 13      | &lt;span&gt;NULL&lt;/span&gt;  |    6 | &lt;span&gt;NULL&lt;/span&gt;        |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
3 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;MySQL 8&lt;/span&gt;&lt;span&gt;下面&lt;/span&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;MySQL 8.0.18&lt;/span&gt;&lt;/span&gt;&lt;span&gt;下的实验结果跟&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;MySQL 5.6.25&lt;/span&gt;&lt;span&gt;下是一致的&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;格式化对应的执行计划&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;你会有更形象、直观的认识。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082555855-1249352357.png&quot;&gt;&lt;img title=&quot;clip_image003[4]&quot; border=&quot;0&quot; alt=&quot;clip_image003[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082556239-606562144.png&quot; width=&quot;654&quot; height=&quot;472&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面我们再改变一下实验中的SQL语句，修改业务逻辑，对比看看一下实验效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;会话1：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
         bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
        tableB
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;WHERE&lt;/span&gt; bill_id &amp;lt;=&lt;span&gt;'2'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;会话&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delete&lt;/span&gt;     &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'4'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;照理来说&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;会话&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;在表&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;tableB&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;应该走索引区间扫描&lt;/span&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;rang&lt;/span&gt;），&lt;/span&gt;&lt;span&gt;不会对&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;bill_id=4&lt;/span&gt;&lt;span&gt;的记录加上共享锁&lt;/span&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;S),&lt;/span&gt;&lt;/span&gt; &lt;span&gt;会话&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;不应该被会话&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;阻塞。然而实际情况：在MySQL 5.6.25中，我们实验测试发现会话1还是会阻塞会话2，因为会话1的执行计划还是走索引扫描，对表tableB中的6行记录加了共享锁，如下截图所示，即使更新统计信息也好，重建索引也罢，MySQL优化器始终走索引扫描。不清楚为什么会这样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082556636-1633558622.png&quot;&gt;&lt;img title=&quot;clip_image004[4]&quot; border=&quot;0&quot; alt=&quot;clip_image004[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082556987-1130315586.png&quot; width=&quot;804&quot; height=&quot;341&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是在MySQL 8.0.18中，就会发现会话1不会阻塞会话2，从执行计划来看，在tableB上对索引idx_bill_id进行索引范围扫描，读取记录有4行（bill_id&amp;lt;=2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。也就是说这4行上加上了共享锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;30.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt; bill_id &amp;lt;=&lt;span&gt;'2'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+------------+-------+---------------+-------------+---------+-------+------+----------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
| id | select_type | &lt;span&gt;table&lt;/span&gt;      | partitions | type  | possible_keys | &lt;span&gt;key&lt;/span&gt;         | key_len | &lt;span&gt;ref&lt;/span&gt;   | &lt;span&gt;rows&lt;/span&gt; | filtered | Extra       |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+------------+-------+---------------+-------------+---------+-------+------+----------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
|  1 | &lt;span&gt;UPDATE&lt;/span&gt;      | a          | &lt;span&gt;NULL&lt;/span&gt;       | const | &lt;span&gt;PRIMARY&lt;/span&gt;       | &lt;span&gt;PRIMARY&lt;/span&gt;     | 12      | const |    1 |   100.00 | &lt;span&gt;NULL&lt;/span&gt;        |
&lt;/pre&gt;
&lt;pre&gt;
|  1 | &lt;span&gt;PRIMARY&lt;/span&gt;     | &amp;lt;derived2&amp;gt; | &lt;span&gt;NULL&lt;/span&gt;       | &lt;span&gt;ref&lt;/span&gt;   | &amp;lt;auto_key0&amp;gt;   | &amp;lt;auto_key0&amp;gt; | 13      | const |    1 |   100.00 | &lt;span&gt;NULL&lt;/span&gt;        |
&lt;/pre&gt;
&lt;pre&gt;
|  2 | DERIVED     | tableB     | &lt;span&gt;NULL&lt;/span&gt;       | range | idx_bill_id   | idx_bill_id | 13      | &lt;span&gt;NULL&lt;/span&gt;  |    4 |   100.00 | &lt;span&gt;Using&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------------+------------+------------+-------+---------------+-------------+---------+-------+------+----------+-------------+
&lt;/pre&gt;
&lt;pre&gt;
3 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, 1 warning (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; explain format=tree
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt; bill_id &amp;lt;=&lt;span&gt;'2'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
| EXPLAIN                                                                                        |
&lt;/pre&gt;
&lt;pre&gt;
+------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
| -&amp;gt; &lt;span&gt;Update&lt;/span&gt; a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; Nested loop &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
        -&amp;gt; &lt;span&gt;Rows&lt;/span&gt; fetched &lt;span&gt;before&lt;/span&gt; execution
&lt;/pre&gt;
&lt;pre&gt;
        -&amp;gt; &lt;span&gt;Index&lt;/span&gt; lookup &lt;span&gt;on&lt;/span&gt; b &lt;span&gt;using&lt;/span&gt; &amp;lt;auto_key0&amp;gt; (bill_id=&lt;span&gt;'2'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
            -&amp;gt; Materialize
&lt;/pre&gt;
&lt;pre&gt;
                -&amp;gt; &lt;span&gt;Group&lt;/span&gt; &lt;span&gt;aggregate&lt;/span&gt;: &lt;span&gt;max&lt;/span&gt;(tableB.update_time)
&lt;/pre&gt;
&lt;pre&gt;
                    -&amp;gt; Filter: (tableB.bill_id &amp;lt;= &lt;span&gt;'2'&lt;/span&gt;)  (cost=2.06 &lt;span&gt;rows&lt;/span&gt;=4)
&lt;/pre&gt;
&lt;pre&gt;
                        -&amp;gt; &lt;span&gt;Index&lt;/span&gt; range scan &lt;span&gt;on&lt;/span&gt; tableB &lt;span&gt;using&lt;/span&gt; idx_bill_id  (cost=2.06 &lt;span&gt;rows&lt;/span&gt;=4)
&lt;/pre&gt;
&lt;pre&gt;
 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082557657-157086076.png&quot;&gt;&lt;img title=&quot;clip_image005[4]&quot; border=&quot;0&quot; alt=&quot;clip_image005[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082558053-1297647937.png&quot; width=&quot;803&quot; height=&quot;623&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其实我们从performance_schema.data_locks中看到，bill_id='3'的记录即使没有被读取，但是也加了共享锁，而bill_id=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;’&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的记录因为没有加上共享锁，所以会话2删除这行记录时，申请X锁时，就不会被阻塞。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082558446-1541431445.png&quot;&gt;&lt;img title=&quot;clip_image006[4]&quot; border=&quot;0&quot; alt=&quot;clip_image006[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082558833-2044686823.png&quot; width=&quot;814&quot; height=&quot;302&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果继续上面的实验，将会话2的SQL修改一下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'3'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后我们按照下面的步骤测试实验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话1：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;13.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id();
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              41 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;session&lt;/span&gt; autocommit=0;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt; bill_id &amp;lt;=&lt;span&gt;'2'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Rows&lt;/span&gt; matched: 1  Changed: 1  Warnings: 0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;17&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;29&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id();
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              42 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; tableB;
&lt;/pre&gt;
&lt;pre&gt;
+-----+---------+---------------+
&lt;/pre&gt;
&lt;pre&gt;
| id  | bill_id | update_time   |
&lt;/pre&gt;
&lt;pre&gt;
+-----+---------+---------------+
&lt;/pre&gt;
&lt;pre&gt;
| 100 | 1       | 1586880000000 |
&lt;/pre&gt;
&lt;pre&gt;
| 200 | 2       | 1586793600000 |
&lt;/pre&gt;
&lt;pre&gt;
| 300 | 2       | 1586880000000 |
&lt;/pre&gt;
&lt;pre&gt;
| 400 | 2       | 1586880000000 |
&lt;/pre&gt;
&lt;pre&gt;
| 500 | 3       | 1586990000000 |
&lt;/pre&gt;
&lt;pre&gt;
+-----+---------+---------------+
&lt;/pre&gt;
&lt;pre&gt;
5 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'3'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此时你会发现会话1阻塞了会话2. 那么我来查看一下事务相关的阻塞和锁相关的信息，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;会话3：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;84.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;164&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; thread_id, processlist_id &lt;span&gt;from&lt;/span&gt; performance_schema.threads &lt;span&gt;where&lt;/span&gt; PROCESSLIST_ID &lt;span&gt;in&lt;/span&gt;(41,42);
&lt;/pre&gt;
&lt;pre&gt;
+-----------+----------------+
&lt;/pre&gt;
&lt;pre&gt;
| THREAD_ID | PROCESSLIST_ID |
&lt;/pre&gt;
&lt;pre&gt;
+-----------+----------------+
&lt;/pre&gt;
&lt;pre&gt;
|        80 |             41 |
&lt;/pre&gt;
&lt;pre&gt;
|        81 |             42 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------+----------------+
&lt;/pre&gt;
&lt;pre&gt;
2 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; INFORMATION_SCHEMA.INNODB_TRX\G;
&lt;/pre&gt;
&lt;pre&gt;
*************************** 1. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
                    trx_id: 7979252
&lt;/pre&gt;
&lt;pre&gt;
                 trx_state: LOCK WAIT
&lt;/pre&gt;
&lt;pre&gt;
               trx_started: 2020-09-22 10:50:00
&lt;/pre&gt;
&lt;pre&gt;
     trx_requested_lock_id: 139958870846928:33:5:6:139958757162504
&lt;/pre&gt;
&lt;pre&gt;
          trx_wait_started: 2020-09-22 10:50:00
&lt;/pre&gt;
&lt;pre&gt;
                trx_weight: 2
&lt;/pre&gt;
&lt;pre&gt;
       trx_mysql_thread_id: 42
&lt;/pre&gt;
&lt;pre&gt;
                 trx_query: &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tableB &lt;span&gt;where&lt;/span&gt; bill_id=&lt;span&gt;'3'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
       trx_operation_state: starting &lt;span&gt;index&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_in_use: 1
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_locked: 1
&lt;/pre&gt;
&lt;pre&gt;
          trx_lock_structs: 2
&lt;/pre&gt;
&lt;pre&gt;
     trx_lock_memory_bytes: 1136
&lt;/pre&gt;
&lt;pre&gt;
           trx_rows_locked: 1
&lt;/pre&gt;
&lt;pre&gt;
         trx_rows_modified: 0
&lt;/pre&gt;
&lt;pre&gt;
   trx_concurrency_tickets: 0
&lt;/pre&gt;
&lt;pre&gt;
       trx_isolation_level: REPEATABLE &lt;span&gt;READ&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_unique_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
    trx_foreign_key_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
trx_last_foreign_key_error: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_latched: 0
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_timeout: 0
&lt;/pre&gt;
&lt;pre&gt;
          trx_is_read_only: 0
&lt;/pre&gt;
&lt;pre&gt;
trx_autocommit_non_locking: 0
&lt;/pre&gt;
&lt;pre&gt;
*************************** 2. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
                    trx_id: 7979251
&lt;/pre&gt;
&lt;pre&gt;
                 trx_state: RUNNING
&lt;/pre&gt;
&lt;pre&gt;
               trx_started: 2020-09-22 10:49:57
&lt;/pre&gt;
&lt;pre&gt;
     trx_requested_lock_id: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
          trx_wait_started: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
                trx_weight: 6
&lt;/pre&gt;
&lt;pre&gt;
       trx_mysql_thread_id: 41
&lt;/pre&gt;
&lt;pre&gt;
                 trx_query: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
       trx_operation_state: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_in_use: 0
&lt;/pre&gt;
&lt;pre&gt;
         trx_tables_locked: 2
&lt;/pre&gt;
&lt;pre&gt;
          trx_lock_structs: 5
&lt;/pre&gt;
&lt;pre&gt;
     trx_lock_memory_bytes: 1136
&lt;/pre&gt;
&lt;pre&gt;
           trx_rows_locked: 11
&lt;/pre&gt;
&lt;pre&gt;
         trx_rows_modified: 1
&lt;/pre&gt;
&lt;pre&gt;
   trx_concurrency_tickets: 0
&lt;/pre&gt;
&lt;pre&gt;
       trx_isolation_level: REPEATABLE &lt;span&gt;READ&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         trx_unique_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
    trx_foreign_key_checks: 1
&lt;/pre&gt;
&lt;pre&gt;
trx_last_foreign_key_error: &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_latched: 0
&lt;/pre&gt;
&lt;pre&gt;
 trx_adaptive_hash_timeout: 0
&lt;/pre&gt;
&lt;pre&gt;
          trx_is_read_only: 0
&lt;/pre&gt;
&lt;pre&gt;
trx_autocommit_non_locking: 0
&lt;/pre&gt;
&lt;pre&gt;
2 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
ERROR: 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;No&lt;/span&gt; query specified
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; ENGINE
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;       ,ENGINE_LOCK_ID
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,ENGINE_TRANSACTION_ID
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,THREAD_ID
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,EVENT_ID
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,OBJECT_NAME
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,INDEX_NAME
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,LOCK_TYPE
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,LOCK_MODE
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,LOCK_STATUS
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;   ,LOCK_DATA
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;FROM&lt;/span&gt; performance_schema.data_locks;
&lt;/pre&gt;
&lt;pre&gt;
+--------+----------------------------------------+-----------------------+-----------+----------+-------------+-------------+-----------+---------------+-------------+------------+
&lt;/pre&gt;
&lt;pre&gt;
| ENGINE | ENGINE_LOCK_ID                         | ENGINE_TRANSACTION_ID | THREAD_ID | EVENT_ID | OBJECT_NAME | INDEX_NAME  | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA  |
&lt;/pre&gt;
&lt;pre&gt;
+--------+----------------------------------------+-----------------------+-----------+----------+-------------+-------------+-----------+---------------+-------------+------------+
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846928:1090:139958757165432   |               7979252 |        81 |       34 | tableB      | &lt;span&gt;NULL&lt;/span&gt;        | &lt;span&gt;TABLE&lt;/span&gt;     | IX            | GRANTED     | &lt;span&gt;NULL&lt;/span&gt;       |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846928:33:5:6:139958757162504 |               7979252 |        81 |       34 | tableB      | idx_bill_id | RECORD    | X             | WAITING     | &lt;span&gt;'3'&lt;/span&gt;, &lt;span&gt;'500'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:1088:139958757159480   |               7979251 |        80 |       42 | tableA      | &lt;span&gt;NULL&lt;/span&gt;        | &lt;span&gt;TABLE&lt;/span&gt;     | IX            | GRANTED     | &lt;span&gt;NULL&lt;/span&gt;       |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:31:4:9:139958757156440 |               7979251 |        80 |       42 | tableA      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | X,REC_NOT_GAP | GRANTED     | &lt;span&gt;'2'&lt;/span&gt;        |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:1090:139958757159568   |               7979251 |        80 |       42 | tableB      | &lt;span&gt;NULL&lt;/span&gt;        | &lt;span&gt;TABLE&lt;/span&gt;     | &lt;span&gt;IS&lt;/span&gt;            | GRANTED     | &lt;span&gt;NULL&lt;/span&gt;       |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:5:2:139958757156784 |               7979251 |        80 |       42 | tableB      | idx_bill_id | RECORD    | S             | GRANTED     | &lt;span&gt;'1'&lt;/span&gt;, &lt;span&gt;'100'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:5:3:139958757156784 |               7979251 |        80 |       42 | tableB      | idx_bill_id | RECORD    | S             | GRANTED     | &lt;span&gt;'2'&lt;/span&gt;, &lt;span&gt;'200'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:5:4:139958757156784 |               7979251 |        80 |       42 | tableB      | idx_bill_id | RECORD    | S             | GRANTED     | &lt;span&gt;'2'&lt;/span&gt;, &lt;span&gt;'300'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:5:5:139958757156784 |               7979251 |        80 |       42 | tableB      | idx_bill_id | RECORD    | S             | GRANTED     | &lt;span&gt;'2'&lt;/span&gt;, &lt;span&gt;'400'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:5:6:139958757156784 |               7979251 |        80 |       42 | tableB      | idx_bill_id | RECORD    | S             | GRANTED     | &lt;span&gt;'3'&lt;/span&gt;, &lt;span&gt;'500'&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:4:2:139958757157128 |               7979251 |        80 |       42 | tableB      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | S,REC_NOT_GAP | GRANTED     | &lt;span&gt;'100'&lt;/span&gt;      |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:4:3:139958757157128 |               7979251 |        80 |       42 | tableB      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | S,REC_NOT_GAP | GRANTED     | &lt;span&gt;'200'&lt;/span&gt;      |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:4:4:139958757157128 |               7979251 |        80 |       42 | tableB      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | S,REC_NOT_GAP | GRANTED     | &lt;span&gt;'300'&lt;/span&gt;      |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:4:5:139958757157128 |               7979251 |        80 |       42 | tableB      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | S,REC_NOT_GAP | GRANTED     | &lt;span&gt;'400'&lt;/span&gt;      |
&lt;/pre&gt;
&lt;pre&gt;
| INNODB | 139958870846056:33:4:6:139958757157128 |               7979251 |        80 |       42 | tableB      | &lt;span&gt;PRIMARY&lt;/span&gt;     | RECORD    | S,REC_NOT_GAP | GRANTED     | &lt;span&gt;'500'&lt;/span&gt;      |
&lt;/pre&gt;
&lt;pre&gt;
+--------+----------------------------------------+-----------------------+-----------+----------+-------------+-------------+-----------+---------------+-------------+------------+
&lt;/pre&gt;
&lt;pre&gt;
15 &lt;span&gt;rows&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; performance_schema.data_lock_waits\G;
&lt;/pre&gt;
&lt;pre&gt;
*************************** 1. &lt;span&gt;row&lt;/span&gt; ***************************
&lt;/pre&gt;
&lt;pre&gt;
                          ENGINE: INNODB
&lt;/pre&gt;
&lt;pre&gt;
       REQUESTING_ENGINE_LOCK_ID: 139958870846928:33:5:6:139958757162504
&lt;/pre&gt;
&lt;pre&gt;
REQUESTING_ENGINE_TRANSACTION_ID: 7979252
&lt;/pre&gt;
&lt;pre&gt;
            REQUESTING_THREAD_ID: 81
&lt;/pre&gt;
&lt;pre&gt;
             REQUESTING_EVENT_ID: 34
&lt;/pre&gt;
&lt;pre&gt;
REQUESTING_OBJECT_INSTANCE_BEGIN: 139958757162504
&lt;/pre&gt;
&lt;pre&gt;
         BLOCKING_ENGINE_LOCK_ID: 139958870846056:33:5:6:139958757156784
&lt;/pre&gt;
&lt;pre&gt;
  BLOCKING_ENGINE_TRANSACTION_ID: 7979251
&lt;/pre&gt;
&lt;pre&gt;
              BLOCKING_THREAD_ID: 80
&lt;/pre&gt;
&lt;pre&gt;
               BLOCKING_EVENT_ID: 42
&lt;/pre&gt;
&lt;pre&gt;
  BLOCKING_OBJECT_INSTANCE_BEGIN: 139958757156784
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
ERROR: 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;No&lt;/span&gt; query specifie
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082559373-1975314929.png&quot;&gt;&lt;img title=&quot;clip_image007[4]&quot; border=&quot;0&quot; alt=&quot;clip_image007[4]&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202009/73542-20200923082559921-251050701.png&quot; width=&quot;1260&quot; height=&quot;341&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么为什么在表tableB的id=500或bill_id='3'的记录上有共享锁呢？ 我们来看看会话1中SQL的执行计划，执行计划会通过表tableB的索引idx_bill_id的区间索引扫描，读取了4行记录，对这4行记录加上共享锁。那么为什么id=500这条记录上也加上了共享锁呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;18&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;31&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain format=tree
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     (&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;          bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;         tableB
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt; bill_id &amp;lt;=&lt;span&gt;'2'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id) b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt;     a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+--------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
| EXPLAIN                                                                                          |
&lt;/pre&gt;
&lt;pre&gt;
+--------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
| -&amp;gt; &lt;span&gt;Update&lt;/span&gt; a
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; Nested loop &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
        -&amp;gt; &lt;span&gt;Rows&lt;/span&gt; fetched &lt;span&gt;before&lt;/span&gt; execution
&lt;/pre&gt;
&lt;pre&gt;
        -&amp;gt; &lt;span&gt;Index&lt;/span&gt; lookup &lt;span&gt;on&lt;/span&gt; b &lt;span&gt;using&lt;/span&gt; &amp;lt;auto_key0&amp;gt; (bill_id=&lt;span&gt;'2'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
            -&amp;gt; Materialize
&lt;/pre&gt;
&lt;pre&gt;
                -&amp;gt; &lt;span&gt;Group&lt;/span&gt; &lt;span&gt;aggregate&lt;/span&gt;: &lt;span&gt;max&lt;/span&gt;(tableB.update_time)
&lt;/pre&gt;
&lt;pre&gt;
                    -&amp;gt; Filter: (tableB.bill_id &amp;lt;= &lt;span&gt;'2'&lt;/span&gt;)  (cost=2.06 &lt;span&gt;rows&lt;/span&gt;=4)
&lt;/pre&gt;
&lt;pre&gt;
                        -&amp;gt; &lt;span&gt;Index&lt;/span&gt; range scan &lt;span&gt;on&lt;/span&gt; tableB &lt;span&gt;using&lt;/span&gt; idx_bill_id  (cost=2.06 &lt;span&gt;rows&lt;/span&gt;=4)
&lt;/pre&gt;
&lt;pre&gt;
 |
&lt;/pre&gt;
&lt;pre&gt;
+---------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;说到这里，就必须先简单介绍一下&lt;span lang=&quot;X-NONE&quot;&gt;Next-Key Lock&lt;/span&gt;，它是结合了&lt;span lang=&quot;X-NONE&quot;&gt;Gap Lock&lt;/span&gt;和&lt;span lang=&quot;X-NONE&quot;&gt;Record Lock&lt;/span&gt;的一种锁定算法，在&lt;span lang=&quot;X-NONE&quot;&gt;Next-Key Lock&lt;/span&gt;算法下，因为&lt;span lang=&quot;X-NONE&quot;&gt;InnoDB&lt;/span&gt;对于行的查询都是采用了&lt;span lang=&quot;X-NONE&quot;&gt;Next-Key Lock&lt;/span&gt;的算法，锁定的不是单个值，而是一个范围（&lt;span lang=&quot;X-NONE&quot;&gt;GAP&lt;/span&gt;）。上面索引值有&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;2&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;3&lt;/span&gt;，其记录的&lt;span lang=&quot;X-NONE&quot;&gt;GAP&lt;/span&gt;的区间如下：是一个左开右闭的空间：（&lt;span lang=&quot;X-NONE&quot;&gt;-&lt;/span&gt;∞&lt;span lang=&quot;X-NONE&quot;&gt;,1]&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;(1,2]&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;(2,3]&lt;/span&gt;，&lt;span lang=&quot;X-NONE&quot;&gt;(3,+&lt;/span&gt;∞），该&lt;span lang=&quot;X-NONE&quot;&gt;SQL&lt;/span&gt;语句锁定的的记录为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;bill_id &amp;lt;= '2'的行记录&lt;/span&gt;&lt;span&gt;&lt;span&gt;，它还会对辅助索引下一个键值（&lt;span lang=&quot;X-NONE&quot;&gt;bill_id='3')&lt;/span&gt;加上&lt;span lang=&quot;X-NONE&quot;&gt;Gap Lock,&lt;/span&gt;以及在在记录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;bill_id='3'上加上共享锁。所以在删除bill_id='3'的记录时，就会遇到阻塞了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Next-Key Locks&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks. A next-key lock on an index record also affects the “gap” before that index record. That is, a next-key lock is an index-record lock plus a gap lock on the gap preceding the index record. If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;Suppose that an index contains the values 10, 11, 13, and 20. The possible next-key locks for this index cover the following intervals, where a round bracket denotes exclusion of the interval endpoint and a square bracket denotes inclusion of the endpoint:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;(negative infinity, 10]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;(10, 11]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;(11, 13]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;(13, 20]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;(20, positive infinity)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;For the last interval, the next-key lock locks the gap above the largest value in the index and the “supremum” pseudo-record having a value higher than any value actually in the index. The supremum is not a real index record, so, in effect, this next-key lock locks only the gap following the largest index value.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;By default, InnoDB operates in &lt;u&gt;&lt;span&gt;&lt;span&gt;REPEATABLE READ&lt;/span&gt;&lt;/span&gt;&lt;/u&gt; transaction isolation level. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see &lt;u&gt;&lt;span&gt;&lt;span&gt;Section 15.7.4, “Phantom Rows”&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;思考部分&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从这个&lt;span lang=&quot;X-NONE&quot;&gt;UPDATE&lt;/span&gt;语句中，我们可以看到其子查询内&lt;span lang=&quot;X-NONE&quot;&gt;tableB&lt;/span&gt;所有的行都会加上共享锁。那么要如何优化这个&lt;span lang=&quot;X-NONE&quot;&gt;SQL&lt;/span&gt;呢？ 下面是一种方案，借助临时表，可以避免&lt;span lang=&quot;X-NONE&quot;&gt;tableB&lt;/span&gt;上的所有记录加上共享锁，影响并发性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TEMPORARY&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; tmp_result
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
         bill_id,&lt;span&gt;MAX&lt;/span&gt;(update_time)
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;FROM&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
        tableB
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; bill_id;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; tableA a
&lt;/pre&gt;
&lt;pre&gt;
        &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    tmp_result b &lt;span&gt;ON&lt;/span&gt; a.id = b.bill_id 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
    a.name = &lt;span&gt;'abcd'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    a.id = &lt;span&gt;'2'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;另外，我们还要特别留意&lt;span lang=&quot;X-NONE&quot;&gt;UPDATE&lt;/span&gt;语句中使用子查询的情况的，例如下面这种情况&lt;span lang=&quot;X-NONE&quot;&gt;(&lt;/span&gt;下面是博客&lt;a href=&quot;https://www.percona.com/blog/2017/09/25/avoid-shared-locks-from-subqueries-when-possible/&quot; target=&quot;_blank&quot;&gt;Avoid Shared Locks from Subqueries When Possible&lt;/a&gt;中例子&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; ibreg &lt;span&gt;set&lt;/span&gt; k=1 &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;from&lt;/span&gt; ibcmp &lt;span&gt;where&lt;/span&gt; id &amp;gt; 90000);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这样的&lt;span lang=&quot;X-NONE&quot;&gt;SQL&lt;/span&gt;会导致子查询中的表，例如&lt;span lang=&quot;X-NONE&quot;&gt;ibcmp&lt;/span&gt;，大范围的加上共享锁，导致&lt;span lang=&quot;X-NONE&quot;&gt;DML&lt;/span&gt;操作被阻塞，严重的时候，可能产生大量的阻塞。所以可以通过下面方式优化：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;方法&lt;span lang=&quot;X-NONE&quot;&gt;1&lt;/span&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;begin&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;select&lt;/span&gt; group_concat(id) &lt;span&gt;into&lt;/span&gt; @ids &lt;span&gt;from&lt;/span&gt; ibcmp &lt;span&gt;where&lt;/span&gt; id &amp;gt; 90000;
&lt;/pre&gt;
&lt;pre&gt;
   &lt;span&gt;update&lt;/span&gt; ibreg &lt;span&gt;set&lt;/span&gt; k=1 &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;in&lt;/span&gt; (@ids);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;方法&lt;span lang=&quot;X-NONE&quot;&gt;2&lt;/span&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span&gt;begin&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; id &lt;span&gt;into&lt;/span&gt; outfile &lt;span&gt;'/tmp/id.csv'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ibcmp &lt;span&gt;where&lt;/span&gt; id &amp;gt; 90000;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;temporary&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t (id &lt;span&gt;int&lt;/span&gt; unsigned &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) engine=innodb;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;load&lt;/span&gt; &lt;span&gt;data&lt;/span&gt; infile &lt;span&gt;'/tmp/id.csv'&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; ibreg &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; t &lt;span&gt;on&lt;/span&gt; ibreg.id = t.id;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://www.percona.com/blog/2017/09/25/avoid-shared-locks-from-subqueries-when-possible/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;原因是这样的，共享锁（S）锁一般是锁定读取的行，但是你这个测试案例里面，为什么出现了阻塞呢？其实还是因为这样写SQL，导致执行计划里面通过索引读取了tableB中所有的行，所以导致会话2被阻塞。你可以看执行计划（MySQL 8也是这种情况），&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Sep 2020 00:26:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>这是问题是一个网友遇到的问题：一个UPDATE语句产生的共享锁阻塞了其他会话的案例，对于这个案例，我进一步分析、总结和衍化了相关问题。下面分析如有不对的地方，敬请指正。下面是初始化环境和数据的脚本。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/13716132.html</dc:identifier>
</item>
<item>
<title>ASP.NET Web API 2系列(四)：基于JWT的token身份认证方案 - 码探长</title>
<link>http://www.cnblogs.com/aizai846/p/13715738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aizai846/p/13715738.html</guid>
<description>&lt;p&gt;没有保护的API接口任何人都可以访问，完全没有安全性可言，这时就需要控制对它的访问，也就是WebAPI的权限验证。本文介绍一种常用的验证方式：基于JWT的token身份认证方案，讲解了它的原理，以及通过代码实现其验证的整个过程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;163.80623045465&quot;&gt;
&lt;h2 id=&quot;1引言&quot;&gt;1.引言&lt;/h2&gt;
&lt;p&gt;通过前边的系列教程，我们可以掌握WebAPI的初步运用，但是此时的API接口任何人都可以访问，这显然不是我们想要的，这时就需要控制对它的访问，也就是WebAPI的权限验证。验证方式非常多，本文就重点介绍一种常用的验证方式：基于JWT的token身份认证方案。&lt;/p&gt;
&lt;h2 id=&quot;2前期回顾&quot;&gt;2.前期回顾&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NTgxODAzNw==&amp;amp;mid=2247483718&amp;amp;idx=1&amp;amp;sn=37f2915d168c9f8b6822907f2dd66a16&amp;amp;chksm=a6f3fe1c9184770a68e3e11049af9bb0314c5e2a96401db72fbd42b3f51555f1f567ba5c5321&amp;amp;sessionid=1598198567&amp;amp;scene=126&amp;amp;subscene=0&amp;amp;clicktime=1598198645&amp;amp;enterid=1598198645&amp;amp;ascene=3&amp;amp;devicetype=android-25&amp;amp;version=2700113f&amp;amp;nettype=cmnet&amp;amp;abtest_cookie=AAACAA%3D%3D&amp;amp;lang=zh_CN&amp;amp;exportkey=AZRAoZV7yfmDruaqJiP%2B2qQ%3D&amp;amp;pass_ticket=gTqwDqmQJMoL5qt7%2FaYDLOjLJq9l%2Bi7hSHIeLQ4EZkeFMmkMXkUpFSMt0MMUczVC&amp;amp;wx_header=1&quot;&gt;Web API系列(一)：初识API及手动搭建基本框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NTgxODAzNw==&amp;amp;mid=2247483776&amp;amp;idx=1&amp;amp;sn=b5c32e4d07e12c82f207793cceef534c&amp;amp;chksm=a6f3feda918477cc436eadea8318166becd7d5fed63f4b8166f9e5b7f19d26c49bc86c16db98&amp;amp;sessionid=1598199049&amp;amp;scene=126&amp;amp;subscene=0&amp;amp;clicktime=1598199060&amp;amp;enterid=1598199060&amp;amp;ascene=3&amp;amp;devicetype=android-25&amp;amp;version=2700113f&amp;amp;nettype=cmnet&amp;amp;abtest_cookie=AAACAA%3D%3D&amp;amp;lang=zh_CN&amp;amp;exportkey=AVamcd22VHq%2BxuIKPJjuhbg%3D&amp;amp;pass_ticket=gTqwDqmQJMoL5qt7%2FaYDLOjLJq9l%2Bi7hSHIeLQ4EZkeFMmkMXkUpFSMt0MMUczVC&amp;amp;wx_header=1&quot;&gt;Web API系列(二)：灵活多样的路由配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NTgxODAzNw==&amp;amp;mid=2247483809&amp;amp;idx=1&amp;amp;sn=22e829777bfd9c9f4b8c871b30bc5b0e&amp;amp;chksm=a6f3fefb918477edef82baa41e3c2901b588465cfdbbd8802ca5b4fd3ddbd49d9dfa2f5b5e0c&amp;amp;scene=0&amp;amp;xtrack=1&amp;amp;key=53e823c17d388498a097f7003d25f77738ad16ba4da34419ddb5d2a2ce6294f6bb7312c71de6ce7f2bb67584a1d055accbadc02a108fe98421af9aef6084cab39e7037338bd99c24e947ae4353ba084422dec28a4928bf2e19c14221a224fbe4b14778a124043ca512b3f48afa28590e416e457d9fd487e80186dcccdf229f47&amp;amp;ascene=1&amp;amp;uin=NzQyNDQxODYx&amp;amp;devicetype=Windows+10+x64&amp;amp;version=62090529&amp;amp;lang=zh_CN&amp;amp;exportkey=AWPey2atIs4ilCccJ5%2BEra0%3D&amp;amp;pass_ticket=iXSPlmN8KuxXXMctGUtuGKeygGgLqDi8YPQ%2BKxyeS1q44eM%2Fok%2BnBto9fchz51z1&amp;amp;wx_header=0&quot;&gt;Web API系列(三)：添加接口详细说明及测试&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3认识jwt&quot;&gt;3.认识JWT&lt;/h2&gt;
&lt;p&gt;JWT是 JSON Web Token 的缩写，是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。&lt;/p&gt;
&lt;h3 id=&quot;31-jwt工作流程&quot;&gt;3.1 JWT工作流程&lt;/h3&gt;
&lt;p&gt;这里我们通过一张图了解它的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003101899-258548922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中我们可以看出它是&lt;strong&gt;基于Token的身份认证&lt;/strong&gt;，具体流程：客户端携带用户名和密码请求访问 - 服务器校验用户凭据 - 应用提供一个token给客户端 - 客户端存储token，并且在随后的每一次请求中都带着它 -服务器校验token并返回数据。&lt;/p&gt;
&lt;h3 id=&quot;32jwt结构&quot;&gt;3.2JWT结构&lt;/h3&gt;
&lt;p&gt;JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Header：头部，它有token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）两部分组成；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Payload&lt;/strong&gt;：荷载，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明；&lt;/li&gt;
&lt;li&gt;Signature：签名，目的是用来验证头部和载荷是否被非法篡改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过下图，我们可以直观的看到JWT的组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003124512-377030663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它本质上是一个独立的身份验证令牌，可以包含用户标识、用户角色和权限等信息，以及您可以存储任何其他信息（自包含）。任何人都可以轻松读取和解析，并使用密钥来验证真实性。&lt;/p&gt;
&lt;h2 id=&quot;4具体实现&quot;&gt;4.具体实现&lt;/h2&gt;
&lt;p&gt;上文介绍了JWT的原理，读者简单了解即可，这里我们通过具体代码来实现。&lt;/p&gt;
&lt;h3 id=&quot;41安装jwt包&quot;&gt;4.1安装JWT包&lt;/h3&gt;
&lt;p&gt;通过NuGget管理工具安装JWT包，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003143702-1375437547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;42添加loginrequest、authinfo和httpresult三个实体类&quot;&gt;4.2添加LoginRequest、AuthInfo和HttpResult三个实体类&lt;/h3&gt;
&lt;p&gt;在MyWebAPI.Entities中添加相应类&lt;/p&gt;
&lt;p&gt;LoginRequest实体&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LoginRequest
{
    public string UserId { get; set; }
    public string Password { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthInfo实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuthInfo
{
    public string UserId { get; set; }
    public DateTime Expires { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HttpResul实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HttpResult
{
    public bool Success { get; set; }
    public dynamic Data { get; set; }
    public string Message { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43添加systemcontroller，并添加login登录方法&quot;&gt;4.3添加SystemController，并添加Login登录方法&lt;/h3&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[RoutePrefix(&quot;api/System&quot;)]
public class SystemController : ApiController
{
    [HttpPost, Route(&quot;Login&quot;)]
    public HttpResult Login([FromBody] LoginRequest loginRequest)
    {
        if (loginRequest == null) return new HttpResult() { Success = false, Message = &quot;登录信息为空！&quot; };

        #region 通过数据库判断登录信息是否正确（这里简化判断）

        if (loginRequest.UserId != &quot;admin&quot; || loginRequest.Password != &quot;admin&quot;)
        {
            return new HttpResult() { Success = false, Message = &quot;用户名和密码不正确！&quot; };
        }
        #endregion
        AuthInfo authInfo = new AuthInfo()
        {
            UserId = loginRequest.UserId,
            Expires = DateTime.Now.AddDays(1)
        };
        const string secretKey = &quot;matanzhang&quot;;//口令加密秘钥（应该写到配置文件中）
        byte[] key = Encoding.UTF8.GetBytes(secretKey);
        IJwtAlgorithm algorithm = new HMACSHA256Algorithm();//加密方式
        IJsonSerializer serializer = new JsonNetSerializer();//序列化Json
        IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//base64加解密
        IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);//JWT编码
        var token = encoder.Encode(authInfo, key);//生成令牌

        return new HttpResult() { Success = true, Data = token,Message = &quot;登录成功！&quot;};
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44添加api过滤器apiauthorizeattribute&quot;&gt;4.4添加API过滤器ApiAuthorizeAttribute&lt;/h3&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ApiAuthorizeAttribute: AuthorizeAttribute
{
    protected override bool IsAuthorized(HttpActionContext actionContext)
    {
        try
        {
            var authHeader = from t in actionContext.Request.Headers where t.Key == &quot;auth&quot; select t.Value.FirstOrDefault();
            var enumerable = authHeader as string[] ?? authHeader.ToArray();
            string token = enumerable.FirstOrDefault();
            if (string.IsNullOrEmpty(enumerable.FirstOrDefault())) return false;
            const string secretKey = &quot;matanzhang&quot;;//口令加密秘钥（应该写到配置文件中）
            byte[] key = Encoding.UTF8.GetBytes(secretKey);
            IJsonSerializer serializer = new JsonNetSerializer();
            IDateTimeProvider provider = new UtcDateTimeProvider();
            IJwtValidator validator = new JwtValidator(serializer, provider);
            IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();
            IJwtAlgorithm algorithm = new HMACSHA256Algorithm();
            IJwtDecoder decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm);
            //解密
            var authInfo = decoder.DecodeToObject&amp;lt;AuthInfo&amp;gt;(token, key, verify: true);
            if (authInfo != null)
            {
                //判断口令过期时间
                if (authInfo.Expires &amp;lt; DateTime.Now)
                {
                    return false;
                }
                actionContext.RequestContext.RouteData.Values.Add(&quot;auth&quot;, authInfo);
                return true;
            }
        }
        catch (Exception e)
        {

        }
        return false;
    }
    /// &amp;lt;summary&amp;gt;
    /// 处理授权失败的请求
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;actionContext&quot;&amp;gt;&amp;lt;/param&amp;gt;
    protected override void HandleUnauthorizedRequest(HttpActionContext actionContext)
    {
        var erModel = new HttpResult()
        {
            Success = false,
            Message = &quot;身份认证不正确！&quot;
        };
        actionContext.Response = actionContext.Request.CreateResponse(HttpStatusCode.OK, erModel, &quot;application/json&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;45在studentcontroller中添加过滤属性apiauthorize&quot;&gt;4.5在StudentController中添加过滤属性ApiAuthorize&lt;/h3&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[RoutePrefix(&quot;api/Student&quot;),ApiAuthorize]
public class StudentController : ApiController
{
    private static readonly List&amp;lt;Student&amp;gt; StudentList = new List&amp;lt;Student&amp;gt;()
    {
        new Student() {Id = &quot;001&quot;, Name = &quot;张三&quot;, Sex = &quot;男&quot;, Age = 19, Dept = &quot;软件学院&quot;},
        new Student() {Id = &quot;002&quot;, Name = &quot;李丽&quot;, Sex = &quot;女&quot;, Age = 19, Dept = &quot;资环学院&quot;}
    };

    [HttpGet]
    public IEnumerable&amp;lt;Student&amp;gt; Get()
    {
        return StudentList;
    }

    [HttpGet, Route(&quot;GetByDept/{dept}&quot;)]
    public IEnumerable&amp;lt;Student&amp;gt; GetByDept(string dept)
    {
        List&amp;lt;Student&amp;gt; tempList = StudentList.Where(p =&amp;gt; p.Dept == dept).ToList();
        return tempList;
    }
    [HttpGet]
    public Student Get(string id)
    {
        List&amp;lt;Student&amp;gt; tempList = StudentList.Where(p =&amp;gt; p.Id == id).ToList();
        return tempList.Count == 1 ? tempList.First() : null;
    }

    [HttpPost]
    public bool Post([FromBody] Student student)
    {
        if (student == null) return false;
        if (StudentList.Where(p =&amp;gt; p.Id == student.Id).ToList().Count &amp;gt; 0) return false;
        StudentList.Add(student);
        return true;
    }

    [HttpPut]
    public bool Put(string id, [FromBody] Student student)
    {
        if (student == null) return false;
        List&amp;lt;Student&amp;gt; tempList = StudentList.Where(p =&amp;gt; p.Id == id).ToList();
        if (tempList.Count == 0) return false;
        Student originStudent = tempList[0];
        originStudent.Name = student.Name;
        originStudent.Sex = student.Sex;
        originStudent.Age = student.Age;
        originStudent.Dept = student.Dept;
        return true;
    }

    [HttpDelete]
    public bool Delete(string id)
    {
        List&amp;lt;Student&amp;gt; tempList = StudentList.Where(p =&amp;gt; p.Id == id).ToList();
        if (tempList.Count == 0) return false;
        StudentList.Remove(tempList[0]);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依照步骤添加相关代码，此时就完成了JWT验证的添加。&lt;/p&gt;
&lt;h2 id=&quot;5通过postman测试程序&quot;&gt;5.通过PostMan测试程序&lt;/h2&gt;
&lt;p&gt;运行VS，查看相关API接口，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003226982-1356016100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录前，测试Get：&lt;code&gt;http://localhost:44321/api/Student&lt;/code&gt;接口，返回结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003246372-649669167.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录，测试Post：&lt;code&gt;http://localhost:44321/api/System/Login&lt;/code&gt;接口，返回结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003305947-840833833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录后，测试Get：&lt;code&gt;http://localhost:44321/api/Student&lt;/code&gt;接口，返回结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202009/1033899-20200923003327315-310357381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在APIController上添加权限验证后，访问相应接口时，需要在header里面添加auth属性（token），这样就完成了身份认证。&lt;/p&gt;
&lt;h2 id=&quot;6总结&quot;&gt;6.总结&lt;/h2&gt;
&lt;p&gt;本文介绍了JWT的原理，然后通过代码完成了相应实例教程，博文中的源代码可以通过笔者GitHUb获取。博文写作不易希望多多支持，后续会更新更多内容，感兴趣的朋友可以加关注，欢迎留言交流！也可以通过微信公众搜索“码探长”，联系笔者！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫描添加下方的微信公众号，获取更多福利和干货！也可通公众号（码探长）联系探长，期待与你相遇！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 23 Sep 2020 00:16:00 +0000</pubDate>
<dc:creator>码探长</dc:creator>
<og:description>没有保护的API接口任何人都可以访问，完全没有安全性可言，这时就需要控制对它的访问，也就是WebAPI的权限验证。本文介绍一种常用的验证方式：基于JWT的token身份认证方案，讲解了它的原理，以及通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aizai846/p/13715738.html</dc:identifier>
</item>
<item>
<title>搞 Java 的年薪 40W 是什么水平？ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/how_to_earn_400_thousand_per_year.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/how_to_earn_400_thousand_per_year.html</guid>
<description>&lt;p&gt;我 2014 年毕业，现在工作 6 年了，目前年薪已经超过了 40W。所以我来回答这个问题，应该算是比较有发言权的，能代表了一部分人的情况。能达到年薪 40W，按我了解到的，有两种可能性：一种是应届毕业生拿到大厂（BAT）的 SP Offer，另一种则是工作年限较长（三年以上）。&lt;/p&gt;
&lt;p&gt;第一种情况，拿到 SP Offer 的人，毕竟是少数，不然怎么能叫 SP Offer 呢。而要拿到 SP Offer 的前提肯定是你非常非常优秀，而且可能毕业学校要不错。我一个中山大学硕士研究生毕业的同学，前几年毕业拿了华为的 SP Offer 也就 18K 的月薪，算上有 5 个月年终 ，那年薪也就 30W 左右吧。所以应届毕业生要拿到 40W 年薪还是蛮难的，而且也需要有不错的运气。&lt;/p&gt;
&lt;p&gt;第二种情况，就是像楼主这样的，工作年限较长，一路升级打怪慢慢涨到 40 万年薪。下面聊聊要达到 40W 应该有什么样的水平。&lt;/p&gt;
&lt;p&gt;我之前写过一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/lMkaBQaHHCHaLsFPz4UQew&quot;&gt;聊聊阿里面试的三个层次&lt;/a&gt;。在这篇文章里，我将阿里对面试者的能力分为了三个层次：基础知识、项目经验、项目深度。&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;能拿到年薪 40W 的人了，Java 基础知识肯定是需要了熟于心的了。&lt;br/&gt;对于 Java 开发岗位上来说，这些知识点包括但不限于：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集合 HashMap 的原理，与 Hashtable、ConcurrentHashMap 的区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java 线程池的核心属性以及处理流程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java 并发包原理、Synchronized 关键字、锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 类加载机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 内存模型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JVM 分代以及垃圾回收机制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Spring Bean 容器生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring AOP 原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Dubbo 请求流程以及原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据库 SQL 优化、数据库索引、索引原理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;……&lt;br/&gt;　　&lt;br/&gt;　　看到这么多的知识点，我一下子就懵逼了，这么多得看到什么时候才看得完啊？但后面我想明白了，其实你不需要全部都懂，但需要了解大部分知识点，并且在这大部分知识点中，还需要有部分是了解得非常深入的。如果达到这个水平，基本上都能通过考核。&lt;br/&gt;　　&lt;br/&gt;　　关于这块知识，其实我们需要将其体系化，形成自己的知识体系。我在去年工作五周年的时候，写了一篇文章，梳理了一下目前我的知识体系：聊聊我的知识体系。这篇文章基本上就概括了年薪 40W 的我掌握了哪些知识点，可能无法做到非常深入，但是绝大多数都使用过并且有一定了解。这块的基础知识，至少需要掌握的是：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集合源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发集合源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发包源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞队列源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程池源码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM 原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基本上这几块东西，我面试的时候必问。如果回答不出来，不要说年薪 40W了，连 30W 都没机会。关于这几块知识点，我梳理了一些系列文章，感兴趣的同学可以翻翻看。&lt;/p&gt;

&lt;h2 id=&quot;项目经验&quot;&gt;项目经验&lt;/h2&gt;
&lt;p&gt;　　如果你知识掌握了上面的基础知识，但是没有不错耐看的项目经验，大概率还是拿不到 40W 年薪的。这里说的不错耐看的项目经验，指的是复杂度较高、有一定并发量的系统开发、设计经验。&lt;/p&gt;
&lt;p&gt;　　复杂度较高，可以简单粗暴地理解为项目中使用到了消息队列、缓存、微服务，这几个是最基础的。稍微复杂些的，可以用到了 netty，用到了 ElasticSearch，用到了 Canal、Otter 等。越复杂越能从某一程度上说明你的技术实力。&lt;/p&gt;
&lt;p&gt;　　除了用到这些复杂些的框架，你还要知道为什么要用这些框架，解决了什么问题，他们的应用在哪些场景，优缺点是什么。如果你只是在项目里打酱油，框架都没用过，也不知道为啥要用，那这个项目对你来说没有任何意义。例如我做过一个「会员信息搜索重构项目」，其中用到了 ElasticSearch + Canal 去实现千万级的实时搜索。&lt;br/&gt;　　&lt;br/&gt;　　&lt;img src=&quot;https://www.cnblogs.com/chanshuyi/p/media/16008194263219/16008196478444.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一个项目是 IM 即时通讯的开发和改造，其中用到了 RocketMQ + Netty 去实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/chanshuyi/p/media/16008194263219/16008196573213.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你有过类似这样的项目经验，并且能把项目中涉及到的框架、技术都了解清楚，那么可以认为你在项目经验这块已经没问题了。&lt;/p&gt;
&lt;h2 id=&quot;项目深度&quot;&gt;项目深度&lt;/h2&gt;
&lt;p&gt;如果你有了上面的项目经验之后，基本上你对整个项目都会有一个全面的认识，应用层面上的问题基本上不会难倒你了。但在「项目思考深度」的考核上，就不仅仅只是考核应用层面上的问题了。&lt;br/&gt;　　&lt;br/&gt;　　还是用我做过的一个搜索项目作为例子，其中 Canal 这个开源框架暂时是没有实现集群这个功能的，那么面试官就问了：&lt;br/&gt;　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你如何去改造这个项目，从而实现 Canal 的集群功能？&lt;br/&gt;　　&lt;br/&gt;　　这个时候，你会发现你懵逼了，因为你从来没有去思考过这个问题。你所有的工作内容都是在想如何使用开源框架，而没有进一步思考这些开源框架好不好，有什么可以改进的地方。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　所以，在这一个层次上考核的是你对开源框架的思考深度，这些框架到底好不好，好在哪里，不好在哪里，有什么可以改进的地方。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;对于「项目思考深度」的考核同样发生在技术面试的三四轮。在这个层次上，你不仅要对项目本身理解足够深刻，还要跳出项目本身，去思考开源框架本身的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在我的理解力，年薪 40W 的人应该能够独立完成一个复杂系统的设计，并且作为核心开发带团队去完成系统的落地、交付。在我所在的公司里，我们有高级工程师（P5）和资深工程师（P6）之分，他们之间一个很重要的区别就是：是否能否独立完成一个复杂的项目。&lt;/p&gt;
&lt;p&gt;如果你能够独立完成一个复杂的项目，那么你才有资格升级为 P6，而我们公司 P6 的薪资才能达到 40 万的年薪。如果只是 P5，那么大概只有25-30万。但是要成为 P6，不仅仅要能独立完成一个复杂的项目，还要求你在沟通能力、表达能力、项目管理达到一定水平。&lt;/p&gt;

&lt;p&gt;原文发表于知乎回答：&lt;a href=&quot;https://www.zhihu.com/question/31437847/answer/1461901722&quot;&gt;搞 Java 的年薪 40W 是什么水平？ - 陈树义的回答 - 知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Sep 2020 00:11:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>文章首发于【陈树义的博客】，点击跳转到原文https://www.cnblogs.com/chanshuyi/p/how_to_earn_400_thousand_per_year.html 我 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanshuyi/p/how_to_earn_400_thousand_per_year.html</dc:identifier>
</item>
<item>
<title>一次代码优化的实践（模板方法+策略+工厂方法模式） - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/13716072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/13716072.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;好久没分享工作总结啦，今天来一份代码优化总结。用模板方法+策略+工厂方法模式优化了代码，耐心点看完，应该对大家有帮助的~&lt;/p&gt;
&lt;p&gt;本文已经收录到github&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/whx123/JavaHome&quot;&gt;https://github.com/whx123/JavaHome&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;公众号：捡田螺的小男孩&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;优化代码前&quot;&gt;优化代码前&lt;/h3&gt;
&lt;p&gt;先来了解一下类似的业务场景，简言之，就是：多个商户接入我们系统，都是走一个类似的流程通过http请求出去的。&lt;br/&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5ad1d5b5f57469894ecc83df77d68d9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优化前，每个公司对应一个句柄服务，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 商户A处理句柄
CompanyAHandler implements RequestHandler {
   Resp hander(req){
   //查询商户信息
   queryMerchantInfo();
   //加签
   signature();
   // http请求（走代理）
   httpRequestbyProxy()
   // 验签
   verify();
   }
}
// 商户B处理句柄
CompanyBHandler implements RequestHandler {
   Resp hander(Rreq){
   //查询商户信息
   queryMerchantInfo();
   //加签
   signature();
   // http请求（不走代理）
   httpRequestbyDirect();
   // 验签
   verify(); 
   }
}
// 商户C处理句柄
CompanyBHandler implements RequestHandler {
   Resp hander(Rreq){
   //查询商户信息
   queryMerchantInfo();
   // webservice 方式调用
   requestByWebservice();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优化代码思路&quot;&gt;优化代码思路&lt;/h3&gt;
&lt;p&gt;我的优化代码思路，是有&lt;strong&gt;重复代码，先把它抽出来，或者公用变量，或者公用方法，伸着公用类&lt;/strong&gt;。所以呢，查询商户信息呀，加签呀，http请求呀先全部各抽成一个公用方法。你细心点会发现，连每个Handler处理过程都很类似的，大概都是查询商户信息+加签+http请求+验签，于是呢，可以直接把它们抽象成一个公用类呀~在这里就要引入模板方法模式咯&lt;/p&gt;
&lt;h4 id=&quot;模板方法模式&quot;&gt;模板方法模式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
这种类型的设计模式属于行为型模式。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然每个Handler处理，都是类似的流程，那&lt;strong&gt;定义一个抽象类，把查询商户信息，加签，http请求，验签什么的，都放到里面去，俨然一个模板一样&lt;/strong&gt;。然后，因为有些商户走http代理，有些又没走代理，怎么办呢? 定义&lt;strong&gt;一个抽象方法，给子类实现&lt;/strong&gt;嘛，因为能共用就放到父类（当前的抽象类），不能共用就放到子类嘛~代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class AbstractCompanyCommonService implements ICompanyCommonService { 
     //模板方法
     Resp handlerTempPlate(req){
            //查询商户信息
           queryMerchantInfo();
           // 加签
           signature();
           //http 请求
           if(isRequestByProxy()){
              httpProxy();
            }else{
              httpDirect();
             }
            // 验签
            verifySinature();
     }
      // Http是否走代理
      abstract boolean isRequestByProxy();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类商户A实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CompanyAServiceImpl extends AbstractCompanyCommonService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //公司A是走代理的
    boolean isRequestByProxy(){
       return true;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类商户B实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CompanyBServiceImpl extends AbstractCompanyCommonService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //公司B是不走代理的
    boolean isRequestByProxy(){
       return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;策略模式&quot;&gt;策略模式&lt;/h4&gt;
&lt;p&gt;心细的读者会发现，甚至提出疑问，&lt;strong&gt;你的商户C的服务实现跟你定义的公用模板，不太一样呢&lt;/strong&gt;，那当然，实际开发中，不跟你定义的模板一样太常见了，需求是产品提的嘛，又不是根据你模板提的，是代码服务于需求的。好了，不多说啦，我使用了策略模式，来优化这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;策略模式理解起来其好抽象对不对？我个人理解，其实策略模式就是定义一个方法（所谓算法），给子类自己去实现。实际上就是&lt;strong&gt;定义个方法/接口，让子类自己去实现&lt;/strong&gt;。看代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义一个方法，把策略交给子类去实现。
interface ICompanyCommonService{
  Resp hander(req);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面商户A和商户B还是不变，使用抽象类AbstractCompanyCommonService的模板，模板不满足商户C，商户C只能自己去实现咯，各个子类自己去实现的行为，就是策略模式的体现呢，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CompanyCServiceImpl extends AbstractCompanyCommonService{
    Res hander(req){
       //查询商户信息
       queryMerchantInfo();
       requestByWebservice();    
    }
    //随意了，你都不走模板了
    boolean isRequestByProxy(){
       return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;工厂方法模式&quot;&gt;工厂方法模式&lt;/h4&gt;
&lt;p&gt;商户A、B、C服务怎么被管理呢，之前分别给A，B，C服务实现handler的，现在好了，都不知道怎么管理了，怎么知道调用哪个呢？别慌，解决方案是&lt;strong&gt;工厂方法模式&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工厂方法模式具体实现就是：接口定义一个枚举，每个服务实现都重新实现枚举，设置唯一标志枚举，再交给spring容器管理。看代码咯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface ICompanyCommonService{
  Resp hander(req);
  CompanyEnum getCompanyEnum();
}

CompanyAServiceImpl extends AbstractCompanyCommonService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //公司A是走代理的
    boolean isRequestByProxy(){
       return true;
    }
    CompanyEnum getCompanyEnum(){
     return CompanyEnum.A;
    } 
    
CompanyBServiceImpl extends AbstractCompanyCommonService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //公司B是不走代理的
    boolean isRequestByProxy(){
       return false;
    }
    CompanyEnum getCompanyEnum(){
     return CompanyEnum.B;
    } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来来来，工厂方法模式出炉咯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class CompanyServiceFactory implements ApplicationContextAware {

    private static Map&amp;lt;CompanyEnum, ICompanyCommonService&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map&amp;lt;String, ICompanyCommonService&amp;gt; tempMap = applicationContext.getBeansOfType(ICompanyCommonService.class);
        tempMap.values().forEach(iCompanyCommonService -&amp;gt;
                map.put(iCompanyCommonService.getCompanyEnum(), iCompanyCommonService));
    }

    public Resp handler(req) {
        return map.get(CompanyEnum.getCompanyEnum(req.getCompanyFlag()).hander(req);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最后建议&quot;&gt;最后建议&lt;/h3&gt;
&lt;p&gt;最后，不要为了使用设计模式生搬硬套，而是优化代码过程中，发现这个设计模式刚好适用，才去用的哈。附上最后的代码咯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class CompanyHandler implements RequestHandler  {
   @Autowire
   private CompanyServiceFactory companyServiceFactory;
   
   Resp hander(req){
    return companyServiceFactory.handler(req);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;个人公众号&quot;&gt;个人公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e531344ab1a417188a4d8ece4148c64~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Sep 2020 23:18:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 好久没分享工作总结啦，今天来一份代码优化总结。用模板方法+策略+工厂方法模式优化了代码，耐心点看完，应该对大家有帮助的~ 本文已经收录到github https://github.com/whx</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/13716072.html</dc:identifier>
</item>
<item>
<title>Redis 发布订阅，小功能大用处，真没那么废材！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13716071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13716071.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071551245-480949487.jpg&quot; alt=&quot;jae-park-7GX5aICb5i4-unsplash&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天小黑哥来跟大家介绍一下 Redis 发布/订阅功能。&lt;/p&gt;
&lt;p&gt;也许有的小伙伴对这个功能比较陌生，不太清楚这个功能是干什么的，没关系小黑哥先来举个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071551671-950298652.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们有这么一个业务场景，在网站下单支付以后，需要通知库存服务进行发货处理。&lt;/p&gt;
&lt;p&gt;上面业务实现不难，我们只要让库存服务提供给相关的给口，下单支付之后只要调用库存服务即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071551810-1889612249.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面如果又有新的业务，比如说积分服务，他需要获取下单支付的结果，然后增加用户的积分。&lt;/p&gt;
&lt;p&gt;这个实现也不难，让积分服务同样提供一个接口，下单支付之后只要调用库存服务即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071551948-1456777281.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果就两个业务需要获取下单支付的结果，那也还好，程序改造也快。可是随着业务不断的发展，越来越多的新业务说是要下单支付的结果。&lt;/p&gt;
&lt;p&gt;这时我们会发现上面这样的系统架构存在很多问题：&lt;/p&gt;
&lt;p&gt;第一，下单支付业务与其他业务重度耦合，每当有个新业务需要支付结果，就需要改动下单支付的业务。&lt;/p&gt;
&lt;p&gt;第二，如果调用业务过多，会导致下单支付接口响应时间变长。另外，如果有任一下游接口响应变慢，就会同步导致下单支付接口响应也变长。&lt;/p&gt;
&lt;p&gt;第三，如果任一下游接口失败，可能导致数据不一致的情况。比如说下图，先调用 A，成功之后再调用 B，最后再调用 C。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552081-326942269.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果在调用 B 接口的发生异常，此时可能就导致下单支付接口返回失败，但是此时 A 接口其实已经调用成功，这就代表它内部已经处理下单支付成功的结果。&lt;/p&gt;
&lt;p&gt;这样就会导致 A，B，C 三个下游接口，A 获取成功获取支付结果，但是 B，C 没有拿到，导致三者系统数据不一致的情况。&lt;/p&gt;
&lt;p&gt;其实我们仔细想一下，对于下单支付业务来讲，它其实不需要关心下游调用结果，只要有某种机制通知能通知到他们就可以了。&lt;/p&gt;
&lt;p&gt;讲到这里，这就需要引入今天需要介绍发布订阅机制。&lt;/p&gt;
&lt;h2 id=&quot;redis-发布与订阅&quot;&gt;Redis 发布与订阅&lt;/h2&gt;
&lt;p&gt;Redis 提供了基于「发布/订阅」模式的消息机制，在这种模式下，消息发布者与订阅者不需要进行直接通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552234-861298090.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，消息发布者只需要想指定的频道发布消息，订阅该频道的每个客户端都可以接受到到这个消息。&lt;/p&gt;
&lt;p&gt;使用 Redis 发布订阅这种机制，对于上面业务，下单支付业务只需要向&lt;strong&gt;支付结果&lt;/strong&gt;这个频道发送消息，其他下游业务订阅&lt;strong&gt;支付结果&lt;/strong&gt;这个频道，就能收相应消息，然后做出业务处理即可。&lt;/p&gt;
&lt;p&gt;这样就可以解耦系统上下游之间调用关系。&lt;/p&gt;
&lt;p&gt;接下来我们来看下，我们来看下如何使用 Redis 发布订阅功能。&lt;/p&gt;
&lt;p&gt;Redis 中提供了一组命令，可以用于发布消息，订阅频道，取消订阅以及按照模式订阅。&lt;/p&gt;
&lt;p&gt;首先我们来看下如何发布一条消息，其实很简单只要使用 &lt;strong&gt;publish&lt;/strong&gt; 指令:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;publish channel message
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552359-110330798.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，我们使用 &lt;strong&gt;publish&lt;/strong&gt; 指令向 &lt;strong&gt;pay_result&lt;/strong&gt; 这个频道发送了一条消息。我们可以看到 redis 向我们返回 0 ，这其实代表当前订阅者个数，由于此时没有订阅，所以返回结果为 0 。&lt;/p&gt;
&lt;p&gt;接下来我们使用 &lt;strong&gt;subscribe&lt;/strong&gt; 订阅一个或多个频道&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;subscribe channel [channel ...]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552527-1553825283.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们订阅 &lt;strong&gt;pay_result&lt;/strong&gt; 这个频道，当有其他客户端往这个频道发送消息，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552708-1128781229.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前订阅者就会收到消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071552825-1554354110.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们子在使用订阅命令，需要主要几点：&lt;/p&gt;
&lt;p&gt;第一，客户端执行订阅指令之后，就会进入订阅状态，之后就只能接收 &lt;strong&gt;subscribe&lt;/strong&gt;、&lt;strong&gt;psubscribe&lt;/strong&gt;、&lt;strong&gt;unsubscribe&lt;/strong&gt;、&lt;strong&gt;punsubscribe&lt;/strong&gt; 这四个命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071553029-877652412.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二，新订阅的客户端，是&lt;strong&gt;无法收到这个频道之前的消息&lt;/strong&gt;，这是因为 Redis 并不会对发布的消息持久化的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;相比于很多专业 MQ，比如 kafka、rocketmq 来说， redis 发布订阅功能就显得有点简陋了。不过 redis 发布订阅功能胜在简单，如果当前场景可以容忍这些缺点，还是可以选择使用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了上面的功能以外的，Redis 还支持模式匹配的订阅方式。简单来说，客户端可以订阅一个带 &lt;code&gt;*&lt;/code&gt; 号的模式，如果某些频道的名字与这个模式匹配，那么当其他客户端发送给消息给这些频道时，订阅这个模式的客户端也将会到收到消息。&lt;/p&gt;
&lt;p&gt;使用 Redis 订阅模式，我们需要使用一个新的指令 &lt;strong&gt;psubscribe&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们执行下面这个指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;psubscribe pay.*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么一旦有其他客户端往 &lt;strong&gt;pay&lt;/strong&gt; 开头的频道，比如 &lt;code&gt;pay_result&lt;/code&gt;、&lt;code&gt;pay_xxx&lt;/code&gt;，我们都可以收到消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071553200-1935642593.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要取消订阅模式，我们需要使用相应&lt;code&gt;punsubscribe&lt;/code&gt; 指令，比如取消上面订阅的模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;punsubscribe pay.*
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;redis-客户端发布订阅使用方式&quot;&gt;Redis 客户端发布订阅使用方式&lt;/h2&gt;
&lt;h3 id=&quot;基于-jedis-开发发布订阅&quot;&gt;基于 Jedis 开发发布/订阅&lt;/h3&gt;
&lt;p&gt;聊完 Redis 发布订阅指令，我们来看下 Java Redis 客户端如何使用发布订阅。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;下面的例子主要基于 Jedis，maven 版本为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他 Redis 客户端大同小异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jedis 发布代码比较简单，只需要调用 &lt;code&gt;Jedis&lt;/code&gt; 类的 &lt;code&gt;publish&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 生产环境千万不要这么使用哦，推荐使用 JedisPool 线程池的方式 
Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
jedis.auth(&quot;xxxxx&quot;);
jedis.publish(&quot;pay_result&quot;, &quot;hello world&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅的代码就相对复杂了，我们需要继承 &lt;code&gt;JedisPubSub&lt;/code&gt; 实现里面的相关方法，一旦有其他客户端往订阅的频道上发送消息，将会调用 &lt;code&gt;JedisPubSub&lt;/code&gt; 相应的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class MyListener extends JedisPubSub {
    @Override
    public void onMessage(String channel, String message) {
        System.out.println(&quot;收到订阅频道：&quot; + channel + &quot; 消息：&quot; + message);

    }

    @Override
    public void onPMessage(String pattern, String channel, String message) {
        System.out.println(&quot;收到具体订阅频道：&quot; + channel + &quot;订阅模式：&quot; + pattern + &quot; 消息：&quot; + message);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次我们需要调用 &lt;code&gt;Jedis&lt;/code&gt; 类的 &lt;code&gt;subscribe&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
jedis.auth(&quot;xxx&quot;);
jedis.subscribe(new MyListener(), &quot;pay_result&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有其他客户端往 &lt;code&gt;pay_result&lt;/code&gt;频道发送消息时，订阅将会收到消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071553346-126324633.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过需要注意的是，&lt;code&gt;jedis#subscribe&lt;/code&gt; 是一个阻塞方法，调用之后将会阻塞主线程的，所以如果需要在正式项目使用需要使用异步线程运行，这里就不演示具体的代码了。&lt;/p&gt;
&lt;h3 id=&quot;基于-spring-data-redis-开发发布订阅&quot;&gt;基于 Spring-Data-Redis 开发发布订阅&lt;/h3&gt;
&lt;p&gt;原生 jedis 发布订阅操作，相对来说还是有点复杂。现在我们很多应用已经基于 SpringBoot 开发，使用 &lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt; ，可以简化发布订阅开发。&lt;/p&gt;
&lt;p&gt;首先我们需要引入相应的 startter 依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;artifactId&amp;gt;lettuce-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;groupId&amp;gt;io.lettuce&amp;lt;/groupId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里我们使用 Jedis 当做底层连接客户端，所以需要排除 lettuce，然后引入 Jedis 依赖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们需要创建一个消息接收类，里面需要有方法消费消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class Receiver {
    private AtomicInteger counter = new AtomicInteger();

    public void receiveMessage(String message) {
        log.info(&quot;Received &amp;lt;&quot; + message + &quot;&amp;gt;&quot;);
        counter.incrementAndGet();
    }

    public int getCount() {
        return counter.get();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们只需要注入 Spring- Redis 相关 Bean，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StringRedisTemplate&lt;/code&gt;，用来操作 Redis 命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MessageListenerAdapter&lt;/code&gt; ，消息监听器，可以在这个类注入我们上面创建消息接受类 &lt;code&gt;Receiver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RedisConnectionFactory&lt;/code&gt;, 创建 Redis 底层连接&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MessageConfiguration {

    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                            MessageListenerAdapter listenerAdapter) {

        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        // 订阅指定频道使用 ChannelTopic
        // 订阅模式使用 PatternTopic
        container.addMessageListener(listenerAdapter, new ChannelTopic(&quot;pay_result&quot;));

        return container;
    }

    @Bean
    MessageListenerAdapter listenerAdapter(Receiver receiver) {
        // 注入 Receiver，指定类中的接受方法
        return new MessageListenerAdapter(receiver, &quot;receiveMessage&quot;);
    }

    @Bean
    Receiver receiver() {
        return new Receiver();
    }

    @Bean
    StringRedisTemplate template(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们使用 &lt;code&gt;StringRedisTemplate#convertAndSend&lt;/code&gt; 发送消息，同时 &lt;code&gt;Receiver&lt;/code&gt; 将会收到一条消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class MessagingRedisApplication {
    public static void main(String[] args) throws InterruptedException {

        ApplicationContext ctx = SpringApplication.run(MessagingRedisApplication.class, args);

        StringRedisTemplate template = ctx.getBean(StringRedisTemplate.class);
        Receiver receiver = ctx.getBean(Receiver.class);

        while (receiver.getCount() == 0) {
            template.convertAndSend(&quot;pay_result&quot;, &quot;Hello from Redis!&quot;);
            Thread.sleep(500L);
        }

        System.exit(0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071553490-360728283.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-发布订阅实际应用&quot;&gt;Redis 发布订阅实际应用&lt;/h2&gt;
&lt;h3 id=&quot;redis-sentinel-节点发现&quot;&gt;Redis Sentinel 节点发现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Redis Sentinel&lt;/strong&gt; 是 Redis 一套高可用方案，可以在主节点故障的时候，自动将从节点提升为主节点，从而转移故障。&lt;/p&gt;
&lt;p&gt;今天这里我们不详细解释 &lt;strong&gt;Redis Sentinel&lt;/strong&gt; 详细原理，主要来看下 &lt;strong&gt;Redis Sentinel&lt;/strong&gt; 如何使用发布订阅机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis Sentinel&lt;/strong&gt; 节点主要使用发布订阅机制，实现新节点的发现，以及交换主节点的之间的状态。&lt;/p&gt;
&lt;p&gt;如下所示，每一个 &lt;strong&gt;Sentinel&lt;/strong&gt; 节点将会定时向 &lt;code&gt;_sentinel_:hello&lt;/code&gt; 频道发送消息，并且每个 &lt;strong&gt;Sentinel&lt;/strong&gt; 都会订阅这个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200923071553656-852449901.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一旦有节点往这个频道发送消息，其他节点就可以立刻收到消息。&lt;/p&gt;
&lt;p&gt;这样一旦有的新节点加入，它往这个频道发送消息，其他节点收到之后，判断本地列表并没有这个节点，于是就可以当做新的节点加入本地节点列表。&lt;/p&gt;
&lt;p&gt;除此之外，每次往这个频道发送消息内容可以包含节点的状态信息，这样可以作为后面 &lt;strong&gt;Sentinel&lt;/strong&gt; 领导者选举的依据。&lt;/p&gt;
&lt;p&gt;以上都是对于 Redis 服务端来讲，对于客户端来讲，我们也可以用到发布订阅机制。&lt;/p&gt;
&lt;p&gt;当 &lt;strong&gt;Redis Sentinel&lt;/strong&gt; 进行主节点故障转移，这个过程各个阶段会通过发布订阅对外提供。&lt;/p&gt;
&lt;p&gt;对于我们客户端来讲，比较关心切换之后的主节点，这样我们及时切换主节点的连接（旧节点此时已故障，不能再接受操作指令），&lt;/p&gt;
&lt;p&gt;客户端可以订阅 &lt;code&gt;+switch-master&lt;/code&gt;频道，一旦 &lt;strong&gt;Redis Sentinel&lt;/strong&gt; 结束了对主节点的故障转移就会发布主节点的的消息。&lt;/p&gt;
&lt;h3 id=&quot;redission-分布式锁&quot;&gt;redission 分布式锁&lt;/h3&gt;
&lt;p&gt;redission 开源框架提供一些便捷操作 Redis 的方法，其中比较出名的 redission 基于 Redis 的实现分布式锁。&lt;/p&gt;
&lt;p&gt;今天我们来看下 Redis 的实现分布式锁中如何使用 Redis 发布订阅机制，提高加锁的性能。&lt;/p&gt;
&lt;blockquote readability=&quot;2.289156626506&quot;&gt;
&lt;p&gt;PS:redission 分布式锁实现原理，可以参考之前写过的文章:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3sJ0TfYG3tXLPwBa2AAJBg&quot;&gt;可重入分布式锁的实现方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HlD46m-OP-HDdKJFxgqFYA&quot;&gt;Redis 分布式锁，看似简单，其实真不简单&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;首先我们来看下 redission 加锁的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Redisson redisson = ....
RLock redissonLock = redisson.getLock(&quot;xxxx&quot;);
redissonLock.lock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RLock&lt;/code&gt; 继承自 Java 标准的 &lt;code&gt;Lock&lt;/code&gt; 接口,调用 &lt;code&gt;lock&lt;/code&gt; 方法,如果当前锁已被其他客户端获取，那么当前加锁的线程将会被阻塞，直到其他客户端释放这把锁。&lt;/p&gt;
&lt;p&gt;这里其实有个问题，当前阻塞的线程如何感知分布式锁已被释放呢？&lt;/p&gt;
&lt;p&gt;这里其实有两种实现方法：&lt;/p&gt;
&lt;p&gt;第一钟，定时查询分布时锁的状态，一旦查到锁已被释放（&lt;em&gt;Redis 中不存在这个键值&lt;/em&gt;），那么就去加锁。&lt;/p&gt;
&lt;p&gt;实现伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while (true) {
  boolean result=lock();
  if (!result) {
    Thread.sleep(N);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式实现起来起来简单，不过缺点也比较多。&lt;/p&gt;
&lt;p&gt;如果定时任务时间过短，将会导致查询次数过多，其实这些都是无效查询。&lt;/p&gt;
&lt;p&gt;如果定时任务休眠时间过长，那又会导致加锁时间过长，导致加锁性能不好。&lt;/p&gt;
&lt;p&gt;那么第二种实现方案，就是采用服务通知的机制，当分布式锁被释放之后，客户端可以收到锁释放的消息，然后第一时间再去加锁。&lt;/p&gt;
&lt;p&gt;这个服务通知的机制我们可以使用 Redis 发布订阅模式。&lt;/p&gt;
&lt;p&gt;当线程加锁失败之后，线程将会订阅 &lt;code&gt;redisson_lock__channel_xxx&lt;/code&gt;（xx 代表锁的名称） 频道，使用异步线程监听消息，然后利用 Java 中 &lt;code&gt;Semaphore&lt;/code&gt; 使当前线程进入阻塞。&lt;/p&gt;
&lt;p&gt;一旦其他客户端进行解锁，redission 就会往这个&lt;code&gt;redisson_lock__channel_xxx&lt;/code&gt; 发送解锁消息。&lt;/p&gt;
&lt;p&gt;等异步线程收到消息，将会调用 &lt;code&gt;Semaphore&lt;/code&gt; 释放信号量，从而让当前被阻塞的线程唤醒去加锁。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ps：这里只是简单描述了 redission 加锁部分原理，出于篇幅，这里就不再消息解析源码。&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可以自己看下 redission 加锁的源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过发布订阅机制，被阻塞的线程可以及时被唤醒，减少无效的空转的查询，有效的提高的加锁的效率。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps: 这种方式，性能确实提高，但是实现起来的复杂度也很高，这部分源码有点东西，快看晕了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天我们主要介绍 Redis 发布订阅功能，主要对应的 Redis 命令为:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;subscribe channel [channel ...]&lt;/strong&gt; 订阅一个或多个频道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsubscribe channel&lt;/strong&gt; 退订指定频道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publish channel message&lt;/strong&gt; 发送消息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;psubscribe pattern&lt;/strong&gt; 订阅指定模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;punsubscribe pattern&lt;/strong&gt; 退订指定模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以利用 Redis 发布订阅功能，实现的简单 MQ 功能，实现上下游的解耦。&lt;/p&gt;
&lt;p&gt;不过需要注意了，由于 Redis 发布的消息不会被持久化，这就会导致新订阅的客户端将不会收到历史消息。&lt;/p&gt;
&lt;p&gt;所以，如果当前的业务场景不能容忍这些缺点，那还是用专业 MQ 吧。&lt;/p&gt;
&lt;p&gt;最后介绍了两个使用 Redis 发布订阅功能使用场景供大家参考。&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 22 Sep 2020 23:16:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>今天小黑哥来跟大家介绍一下 Redis 发布/订阅功能。 也许有的小伙伴对这个功能比较陌生，不太清楚这个功能是干什么的，没关系小黑哥先来举个例子。 假设我们有这么一个业务场景，在网站下单支付以后，需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13716071.html</dc:identifier>
</item>
<item>
<title>@JsonCreator自定义反序列化函数-JSON框架Jackson精解第5篇 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13716062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13716062.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200923070043669-2011179231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jackson是Spring Boot(SpringBoot)默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，没有这种限制。它提供了很多的JSON数据处理方法、注解，也包括&lt;strong&gt;流式API、树模型、数据绑定&lt;/strong&gt;，以及复杂数据类型转换等功能。它虽然简单易用，但绝对不是小玩具，&lt;strong&gt;更多的内容我会写成一个系列，5-10篇文章，请您继续关注我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本节继续为大家介绍在JSON反序列化过程中，如何使用&lt;code&gt;@JsonCreator&lt;/code&gt;注解和&lt;code&gt;@ConstructorProperties&lt;/code&gt;注解自定义反序列化函数。&lt;/p&gt;
&lt;h2 id=&quot;一、jackson反序列化过程做了什么？&quot;&gt;一、Jackson反序列化过程做了什么？&lt;/h2&gt;
&lt;p&gt;对于Jackson的JSON数据格式，反序列化过程就是&lt;strong&gt;将JSON字符串反序列化为java 对象&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ObjectMapper mapper = new ObjectMapper();

//将JSON字符串反序列化为java对象
String jsonInString = &quot;{\&quot;name\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
PlayerStar3 jordan = mapper.readValue(jsonInString, PlayerStar3.class);

System.out.println(jordan);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，Jackson在反序列化过程中调用了哪些函数，给大家介绍一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先调用反序列化的目标类PlayerStar3的&lt;strong&gt;无参构造函数&lt;/strong&gt;，构造一个java对象&lt;/li&gt;
&lt;li&gt;然后调用该类的成员变量的set方法，为该对象的每一个成员变量赋值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以默认情况下，一个Java类使用Jackson做反序列化，必须有public无参构造函数(java中不写也默认有)，必须有成员变量的set方法。&lt;/p&gt;
&lt;h2 id=&quot;二、jsoncreator注解&quot;&gt;二、&lt;code&gt;@JsonCreator&lt;/code&gt;注解&lt;/h2&gt;
&lt;p&gt;默认情况下，Jackson的反序列化过程是上面描述的那样，使用无参构造函数及set方法。除此之外，我们还可以使用&lt;code&gt;@JsonCreator&lt;/code&gt;注解自定义反序列化的过程，在我们自定义的反序列化函数里面，我们有&lt;strong&gt;更强的灵活性，可以完成更多的非规定动作&lt;/strong&gt;。一共有两种自定义反序列化渠道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@JsonCreator&lt;/code&gt;注解加在构造方法上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@JsonCreator&lt;/code&gt;注解加在工厂静态方法上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用了&lt;code&gt;@JsonCreator&lt;/code&gt;注解之后，将使用该注解标注的方法进行反序列化对象的构造，默认的使用无参构造函数及set方法进行反序列化的过程失效。&lt;/p&gt;
&lt;h3 id=&quot;21jsoncreator注解加在构造方法上&quot;&gt;2.1.&lt;code&gt;@JsonCreator&lt;/code&gt;注解加在构造方法上&lt;/h3&gt;
&lt;p&gt;该PlayerStar3对应的JSON字符串是第一小节中的jsonInString。下文的构造函数，你希望将哪些属性值赋值给java 对象的成员变量，你就使用&lt;code&gt;@JsonProperty(&quot;salary&quot;)&lt;/code&gt;去定义它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PlayerStar3 {

  private String name;
  private Integer age;
  private String[] hobbies;    //业余爱好,数组
  private List&amp;lt;String&amp;gt; friends;   //  朋友
  private Map&amp;lt;String, BigDecimal&amp;gt; salary; //年收入 Map

  //这段是我们的核心代码，使用JsonCreator注解说明该方法是反序列化构造方法。
  @JsonCreator
  public PlayerStar3(@JsonProperty(&quot;name&quot;) String name,
                     @JsonProperty(&quot;age&quot;) Integer age,
                     @JsonProperty(&quot;hobbies&quot;) String[] hobbies,
                     @JsonProperty(&quot;friends&quot;) List&amp;lt;String&amp;gt; friends,
                     @JsonProperty(&quot;salary&quot;) Map&amp;lt;String, BigDecimal&amp;gt; salary) {
    this.name = name;
    this.age = age;
    this.hobbies = hobbies;
    this.friends = friends;
    this.salary = salary;
  }

  //这里省略一个toString()方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用第一小节中的反序列化代码，将jsonInString反序列化构造PlayerStar3对象，控制台输出结果如下(对象的toString()方法输出)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PlayerStar3{name='乔丹', age=45, hobbies=[高尔夫球, 棒球], friends=null, salary=null}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;@JsonCreator&lt;/code&gt;标注的构造方法里面下断点，也的确证明在java 对象反序列化构造的过程中使用的是该方法。&lt;/p&gt;
&lt;h3 id=&quot;22jsoncreator注解加在工厂静态方法上&quot;&gt;2.2.&lt;code&gt;@JsonCreator&lt;/code&gt;注解加在工厂静态方法上&lt;/h3&gt;
&lt;p&gt;除了可以将&lt;code&gt;@JsonCreator&lt;/code&gt;加在构造方法上，还可以使用静态工厂函数反序列化构造java对象。使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PlayerStar3 {

  //  省略若干成员变量的定义,和上文一样

  @JsonCreator
  public static PlayerStar3 createPlayer(@JsonProperty(&quot;name&quot;) String name,
                                         @JsonProperty(&quot;age&quot;) Integer age,
                                         @JsonProperty(&quot;hobbies&quot;) String[] hobbies,
                                         @JsonProperty(&quot;friends&quot;) List&amp;lt;String&amp;gt; friends,
                                         @JsonProperty(&quot;salary&quot;) Map&amp;lt;String, BigDecimal&amp;gt; salary) {
    PlayerStar3 player = new PlayerStar3();  //new 一个java对象
    player.name = name;    //赋值
    player.age = age;
    player.hobbies = hobbies;
    player.friends = friends;
    player.salary = salary;
    return player;
  }
    //这里省略一个toString()方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;@JsonCreator&lt;/code&gt;注解加在工厂静态方法上，可以达到一样的反序列化效果。&lt;/p&gt;
&lt;h2 id=&quot;三、constructorproperties注解&quot;&gt;三、&lt;code&gt;@ConstructorProperties&lt;/code&gt;注解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@ConstructorProperties&lt;/code&gt;注解的作用和&lt;code&gt;@JsonCreator&lt;/code&gt;注解起到的作用是一致的，但是它只能加在构造方法上，作为反序列化函数。但是它的语法更简洁，使用起来也更加方便，不用&lt;code&gt;@JsonProperty&lt;/code&gt;注解。又提供了灵活性，我们可以在构造方法反序列化过程中，针对该对象做更多的非规定操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ConstructorProperties({&quot;name&quot;, &quot;age&quot;,&quot;hobbies&quot;, &quot;friends&quot;,&quot;salary&quot;})
public PlayerStar3(String name,
                   Integer age,
                   String[] hobbies,
                   List&amp;lt;String&amp;gt; friends,
                   Map&amp;lt;String, BigDecimal&amp;gt; salary) {
  this.name = name;
  this.age = age;
  this.hobbies = hobbies;
  this.friends = friends;
  this.salary = salary;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;@ConstructorProperties&lt;/code&gt;注解加在构造方法上，可以达到一样的反序列化效果。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Sep 2020 23:01:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>Jackson是Spring Boot(SpringBoot)默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13716062.html</dc:identifier>
</item>
<item>
<title>【计算几何 01】叉积 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13715847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13715847.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这几天闲来无事去学习了一下计算几何，发现其实不（sang）是（xin）太（bing）难（kuang）😛&lt;br/&gt;今天就重点介绍一下简单的叉积及其简单的运用（毕竟作为蒟蒻，难的搞不来啊）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是计算几何？&quot;&gt;什么是计算几何？&lt;/h2&gt;
&lt;h5 id=&quot;对几何外形信息的计算机表示、分析和综合福雷斯特&quot;&gt;“对几何外形信息的计算机表示、分析和综合”——福雷斯特&lt;/h5&gt;
&lt;p&gt;其实所谓计算几何，就是用计算机去解决不同维度上的几何问题，而我们要做的，就是设计一套算法，让计算机去分析和解决一系列的几何问题。&lt;/p&gt;
&lt;h2 id=&quot;一些基本知识&quot;&gt;一些基本知识&lt;/h2&gt;
&lt;h5 id=&quot;坐标的存储&quot;&gt;坐标的存储&lt;/h5&gt;
&lt;p&gt;一般来说，计算几何都涉及到了小数坐标，这时开一个含两个double类型的结构体就比较稳健，我一般的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct node//定义一个点 
{
    double x,y;
}a[11000];
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;线段的存储&quot;&gt;线段的存储&lt;/h5&gt;
&lt;p&gt;聪明绝顶的你肯定已经想到了，线段就是包含两个点的一个结构体，所以我一般的定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct line//定义一条线
{
    node p1,p2;
} list[11000];
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;叉积&quot;&gt;叉积&lt;/h2&gt;
&lt;p&gt;终于到今天的主角—叉积了！😝&lt;br/&gt;那么什么是叉积呢？叉积其实是两个矢量模的乘积再乘夹角正弦，经过推导可以发现两个向量&lt;span class=&quot;math inline&quot;&gt;\(A(x1,y1),B(x2,y2)\)&lt;/span&gt;的叉积为：&lt;/p&gt;
&lt;p&gt;\[x1*y2-x2*y1 \]&lt;/p&gt;
&lt;p&gt;先丢出代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;double multi(node p1,node p2,node p0)//计算叉积，p1，p2，p0都为点
{
    double x1,y1,x2,y2;
    x1=p1.x-p0.x;
    y1=p1.y-p0.y;
    x2=p2.x-p0.x;
    y2=p2.y-p0.y;
    return x1*y2-x2*y1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是传说中的叉积计算了！是不是很短呢，那就让我们来理解一下这个multi函数吧。&lt;/p&gt;
&lt;p&gt;由于叉积是向量间的运算，大家都知道向量可以用末坐标减去首坐标得到，那么其实multi函数计算的就是向量A(x1,y1)与向量B(x2,y2)的叉积。&lt;/p&gt;
&lt;p&gt;对于multi函数的意义，首先multi的正负是有特殊含义的：以p0为参考点，如果multi大于0，则p2在p1的逆时针方向，反正，如果multi小于0，则p2在p1的顺时针方向，特殊的，当multi等于0，p1、p2、p0三点共线。&lt;br/&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次，multi的值也是有含义的！通过后面的学习你就会发现，multi的绝对值就是以p0、p1、p2三点构成的三角形的面积的两倍！利用这个规律，可以完成很多与计算几何有关的题目。&lt;/p&gt;
&lt;h2 id=&quot;一些简单的运用&quot;&gt;一些简单的运用&lt;/h2&gt;
&lt;h4 id=&quot;【caioj-1212-判断线段相交（跨立实验）】&quot;&gt;【caioj 1212 判断线段相交（跨立实验）】&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;题目描述&lt;br/&gt;【题意】&lt;br/&gt;有n条线段（编号为1~n），按1~n的顺序放在二维坐标系上（就是先放1号，再放2号……），&lt;br/&gt;要求输出最上面的那些线段的编号（就是没有其他线段压在它上面的那些线段）&lt;br/&gt;【输入格式】&lt;br/&gt;第一行第一个数n（ 1 &amp;lt;= n &amp;lt;= 10000）表示这组数据有n条线段。&lt;br/&gt;下来n行，每行两个坐标，表示第i条线段的两个端点。&lt;br/&gt;【输出格式】&lt;br/&gt;一行。输出最上面的线段的编号（从小到大）。相邻两个编号用空格隔开，最后一个编号没有空格。&lt;br/&gt;【样例1输入】&lt;br/&gt;5&lt;br/&gt;1 1 4 2&lt;br/&gt;2 3 3 1&lt;br/&gt;1 -2.0 8 4&lt;br/&gt;1 4 8 2&lt;br/&gt;3 3 6 -2.0&lt;br/&gt;【样例1输出】&lt;br/&gt;2 4 5&lt;br/&gt;【样例2输入】&lt;br/&gt;3&lt;br/&gt;0 0 1 1&lt;br/&gt;1 0 2 1&lt;br/&gt;2 0 3 1&lt;br/&gt;【样例2输出】&lt;br/&gt;1 2 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题很明显要让我们判断任意两条线段是否相交，这就要用到刚刚讲到的叉积的第一种用法了!&lt;/p&gt;
&lt;p&gt;很明显，相交有两种情况，相交且穿过和相交但不穿过（如下图）&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022302.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们首先先讨论第一种情况，如何判断两条直线相交且穿过？&lt;br/&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如上图，先假设两条直线为L1和L2，每条直线的两个端点分别为p1和p2，那么如果以&lt;br/&gt;L1.p1为一个参考点，如果L1.p2在L2.p1与L2.p2中间；再以L2.p1为参考点，如果L2.p2在L1.p1与L1.p2中间，那么就可以判断L1与L2相交且穿过（如下图）&lt;br/&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况非常好理解吧，下一种情况就更加简单了，仅需讨论哪三个点在一条“直线”上（毕竟不穿过，所以必有三点共线），然后判断一下&lt;br/&gt;不穿过的那个点是否在一条“线段”上（如下图）&lt;br/&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;具体代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;double check(line l1,line l2)//判断是否相交 
{
    if(multi(l2.p1,l1.p2,l1.p1)*multi(l1.p2,l2.p2,l1.p1)&amp;gt;0)//判断以L1.p1为基准，L1.p2是否在L2.p1与L2.p2中间
    if(multi(l1.p1,l2.p2,l2.p1)*multi(l2.p2,l1.p2,l2.p1)&amp;gt;0)//判断以L2.p1为基准,L2.p2是否在L1.p1与L2.p2中间
    return true;//大部分情况下，能判断两直线相交   
    if(multi(l1.p1,l1.p2,l2.p1)==0)if(mymin(l1.p1.x,l1.p2.x)&amp;lt;=l2.p1.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p1.x)if(mymin(l1.p1.y,l1.p2.y)&amp;lt;=l2.p1.y)if(mymax(l1.p1.y,l1.p2.y)&amp;gt;=l2.p1.y)return true;
    if(multi(l1.p1,l1.p2,l2.p2)==0)if(mymin(l1.p1.x,l1.p2.x)&amp;lt;=l2.p2.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p2.x)if(mymin(l1.p1.y,l1.p2.y)&amp;lt;=l2.p2.y)if(mymax(l1.p1.y,l1.p2.y)&amp;gt;=l2.p2.y)return true;
    if(multi(l2.p1,l2.p2,l1.p1)==0)if(mymin(l2.p1.x,l2.p2.x)&amp;lt;=l1.p1.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p1.x)if(mymin(l2.p1.y,l2.p2.y)&amp;lt;=l1.p1.y)if(mymax(l2.p1.y,l2.p2.y)&amp;gt;=l1.p1.y)return true;
    if(multi(l2.p1,l2.p2,l1.p2)==0)if(mymin(l2.p1.x,l2.p2.x)&amp;lt;=l1.p2.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p2.x)if(mymin(l2.p1.y,l2.p2.y)&amp;lt;=l1.p2.y)if(mymax(l2.p1.y,l2.p2.y)&amp;gt;=l1.p2.y)return true;
    //判断两条直线相交且一条直线端点在另一条直线上 
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在之前的版本里，我在判断两条直线相交且一条直线端点在另一条直线上的情况中忽略了两条直线互相一条与x轴垂直，一条与y轴垂直，且某一条延伸出去恰好交于另一条直线交点的情况，于是在一次比赛中WA了十多发QwQ，下面放上错误代码以作为警示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;double check(line l1,line l2)//判断是否相交 
{
    if(multi(l2.p1,l1.p2,l1.p1)*multi(l1.p2,l2.p2,l1.p1)&amp;gt;0)//判断以L1.p1为基准，L1.p2是否在L2.p1与L2.p2中间
    if(multi(l1.p1,l2.p2,l2.p1)*multi(l2.p2,l1.p2,l2.p1)&amp;gt;0)//判断以L2.p1为基准,L2.p2是否在L1.p1与L2.p2中间
    return true;//大部分情况下，能判断两直线相交   if(multi(l2.p1,l1.p1,l1.p2)==0)if(mymin(l1.p1.x,l1.p2.x&amp;lt;=l2.p1.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p1.x)return true;
    if(multi(l2.p2,l1.p1,l1.p2)==0)if(mymin(l1.p1.x,l1.p2.x&amp;lt;=l2.p2.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p2.x)return true;
    if(multi(l1.p1,l2.p1,l2.p2)==0)if(mymin(l2.p1.x,l2.p2.x&amp;lt;=l1.p1.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p1.x)return true;
    if(multi(l1.p2,l2.p1,l2.p2)==0)if(mymin(l2.p1.x,l2.p2.x&amp;lt;=l1.p2.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p2.x)return true;
    //判断两条直线相交且一条直线端点在另一条直线上 
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主程序就很简单了，一条一条边读入，读入第i条边时判断他与前i-1条边是否相交，若相交，这之前的边j被盖住，判断数组bo【j】=1。最后统计bo【i】==0的边就好啦&lt;br/&gt;附上完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
struct node//定义一个点 
{
        double x,y;
};

struct line//定义一条线 
{
    node p1,p2;
} list[11000];

int a[11000]={0};
bool bo[11000]={0};
int i,j,k,m,n,o,p,js,jl,jk,len;

    //================================
double mymax(double x,double y)//求max 
{
    if(x&amp;gt;y)return x;
    else return y;
}

double mymin(double x,double y)//求min 
{
    if(x&amp;lt;y)return x;
    else return y;
}

    //=================================

double multi(node p1,node p2,node p0)//计算叉积：而且值为三点构成三角形的面积的两倍 
{
    double x1,y1,x2,y2;
    x1=p1.x-p0.x;
    y1=p1.y-p0.y;
    x2=p2.x-p0.x;
    y2=p2.y-p0.y;
    return x1*y2-x2*y1;
}

double check(line l1,line l2)//判断是否相交 
{
    if(multi(l2.p1,l1.p2,l1.p1)*multi(l1.p2,l2.p2,l1.p1)&amp;gt;0)//判断以L1.p1为基准，L1.p2是否在L2.p1与L2.p2中间
    if(multi(l1.p1,l2.p2,l2.p1)*multi(l2.p2,l1.p2,l2.p1)&amp;gt;0)//判断以L2.p1为基准,L2.p2是否在L1.p1与L2.p2中间
    return true;//大部分情况下，能判断两直线相交   
    if(multi(l1.p1,l1.p2,l2.p1)==0)if(mymin(l1.p1.x,l1.p2.x)&amp;lt;=l2.p1.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p1.x)if(mymin(l1.p1.y,l1.p2.y)&amp;lt;=l2.p1.y)if(mymax(l1.p1.y,l1.p2.y)&amp;gt;=l2.p1.y)return true;
    if(multi(l1.p1,l1.p2,l2.p2)==0)if(mymin(l1.p1.x,l1.p2.x)&amp;lt;=l2.p2.x)if(mymax(l1.p1.x,l1.p2.x)&amp;gt;=l2.p2.x)if(mymin(l1.p1.y,l1.p2.y)&amp;lt;=l2.p2.y)if(mymax(l1.p1.y,l1.p2.y)&amp;gt;=l2.p2.y)return true;
    if(multi(l2.p1,l2.p2,l1.p1)==0)if(mymin(l2.p1.x,l2.p2.x)&amp;lt;=l1.p1.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p1.x)if(mymin(l2.p1.y,l2.p2.y)&amp;lt;=l1.p1.y)if(mymax(l2.p1.y,l2.p2.y)&amp;gt;=l1.p1.y)return true;
    if(multi(l2.p1,l2.p2,l1.p2)==0)if(mymin(l2.p1.x,l2.p2.x)&amp;lt;=l1.p2.x)if(mymax(l2.p1.x,l2.p2.x)&amp;gt;=l1.p2.x)if(mymin(l2.p1.y,l2.p2.y)&amp;lt;=l1.p2.y)if(mymax(l2.p1.y,l2.p2.y)&amp;gt;=l1.p2.y)return true;
    //判断两条直线相交且一条直线端点在另一条直线上 
    return false;
}
    //==================================
int main()
{
    scanf(&quot;%d&quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%lf%lf%lf%lf&quot;,&amp;amp;list[i].p1.x,&amp;amp;list[i].p1.y,&amp;amp;list[i].p2.x,&amp;amp;list[i].p2.y);
    for(int i=1;i&amp;lt;n;i++)
    for(int j=i+1;j&amp;lt;=n;j++)
    {
        if(check(list[i],list[j]))//判断相交 
        {
            bo[i]=1;
            break;
        }
    }
    len=0;
    for(int i=1;i&amp;lt;=n;i++)if(bo[i]==0)a[++len]=i;
    for(int i=1;i&amp;lt;len;i++)printf(&quot;%d &quot;,a[i]);
    printf(&quot;%d\n&quot;,a[len]);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;【caioj-1213-面积】&quot;&gt;【caioj 1213 面积】&lt;/h4&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;题目描述&lt;br/&gt;【题意】&lt;br/&gt;在一个平面坐标系上随意画一条有n个点的封闭折线（按画线的顺序给出点的坐标），保证封闭折线的任意两条边都不相交。最后要计算这条路线包围的面积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【输入格式】&lt;br/&gt;第一行整数 n (3 &amp;lt;= n &amp;lt;= 1000),表示有n个点。&lt;br/&gt;下来n行，每行两个整数x（横坐标）和y（纵坐标），表示点坐标（-10000&amp;lt;x,y&amp;lt;=10000）。&lt;br/&gt;【输出格式】&lt;br/&gt;一行一个实数，即封闭折线所包围的面积（保留4位小数）。&lt;br/&gt;【样例1输入】&lt;br/&gt;4&lt;br/&gt;2 1&lt;br/&gt;5 1&lt;br/&gt;5 5&lt;br/&gt;2 5&lt;br/&gt;【样例1输出】&lt;br/&gt;12.0000&lt;br/&gt;【样例2输入】&lt;br/&gt;5&lt;br/&gt;2 1&lt;br/&gt;5 1&lt;br/&gt;3 2&lt;br/&gt;5 3&lt;br/&gt;2 3&lt;br/&gt;【样例2输出】&lt;br/&gt;4.0000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题对比上一道题就简单很多了，这道题要用到叉积的第二种用法——计算面积！对于任意一个多边形，只要以一号点p1为参考点，枚举任意两个相邻的点pi和pi-1（i&amp;gt;=3）,带符号计算p1和pi、pi-1所构成的三角形的面积（multi（pi，pi-1，p1）/2），累加取绝对值就是答案了。&lt;/p&gt;
&lt;p&gt;至于为什么要带符号运算，请看我用下面这幅图演示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022427.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个多边形，首先先加上multi(p3,p2,p1)/2的值（由于p3在p2的逆时针方向，所以为正）即为加上了红色部分&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后再加上multi(p4,p3,p1)/2的值（由于p4在p3的顺时针方向，所以为负）即为减去了绿色部分&lt;br/&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200923022457.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后再加上multi(p5,p4,p1)/2的值（由于p5在p4的逆时针方向，所以为正）即为加上了黄色部分，就是答案了&lt;img src=&quot;https://jvruo.com/usr/uploads/2018/01/2820856144.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后附上代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
struct node
{
    double x,y;
}a[11000];

int i,j,k,m,n,o,p,js,jl;
double ans;

double multi(node p1,node p2, node p0)
{
    double x1=p1.x-p0.x;
    double y1=p1.y-p0.y; 

    double x2=p2.x-p0.x;
    double y2=p2.y-p0.y;

    return(x1*y2-x2*y1); 
}

int main()
{
    scanf(&quot;%d&quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%lf%lf&quot;,&amp;amp;a[i].x,&amp;amp;a[i].y);

    for(int i=2;i&amp;lt;=n;i++)
    {
        ans=ans+multi(a[i],a[i-1],a[1]);
    }
    ans=ans/2.0;
    if(ans&amp;lt;0)ans=-ans;

    printf(&quot;%0.4lf&quot;,ans);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;通过上面的学习和例题，是不是已经初步了解了计算几何的一点点精（皮）髓（毛）呢，希望你能有所收获，在计算几何的路上越走越远吧（蒟蒻的我可能是走不下去了）&lt;br/&gt;最后Orz各位大佬，写的不好请各位神犇提出建议和意见，感谢你的阅读:neckbeard:&lt;/p&gt;
</description>
<pubDate>Tue, 22 Sep 2020 18:28:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>这几天闲来无事去学习了一下计算几何，发现其实不（sang）是（xin）太（bing）难（kuang）:stuck_out_tongue: 今天就重点介绍一下简单的叉积及其简单的运用（毕竟作为蒟蒻，难的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13715847.html</dc:identifier>
</item>
</channel>
</rss>