<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java 从 Map 到 HashMap 的一步步实现 - 山貓先森</title>
<link>http://www.cnblogs.com/king0/p/14176609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/king0/p/14176609.html</guid>
<description>&lt;h2 id=&quot;一、-map&quot;&gt;一、 Map&lt;/h2&gt;
&lt;h3 id=&quot;11--map-接口&quot;&gt;1.1 Map 接口&lt;/h3&gt;
&lt;p&gt;在 Java 中, Map 提供了键——值的映射关系。映射不能包含重复的键,并且每个键只能映射到一个值。&lt;br/&gt;以 Map 键——值映射为基础，java.util 提供了 HashMap（最常用）、 TreeMap、Hashtble、LinkedHashMap 等数据结构。&lt;br/&gt;衍生的几种 Map 的主要特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashMap：最常用的数据结构。键和值之间通过 Hash函数 来实现映射关系。当进行遍历的 key 是无序的&lt;/li&gt;
&lt;li&gt;TreeMap：使用红黑树构建的数据结构，因为红黑树的原理，可以很自然的对 key 进行排序，所以 TreeMap 的 key 遍历时是默认按照自然顺序（升序）排列的。&lt;/li&gt;
&lt;li&gt;LinkedHashMap: 保存了插入的顺序。遍历得到的记录是按照插入顺序的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12--hash-散列函数&quot;&gt;1.2 Hash 散列函数&lt;/h3&gt;
&lt;p&gt;Hash （散列函数）是把任意长度的输入通过散列算法变换成固定长度的输出。Hash 函数的返回值也称为 哈希值 哈希码 摘要或哈希。Hash作用如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202012/1600185-20201223082556974-1719941306.png&quot; alt=&quot;引用自维基百科&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hash 函数可以通过选取适当的函数，可以在时间和空间上取得较好平衡。&lt;br/&gt;解决 Hash 的两种方式：拉链法和线性探测法&lt;/p&gt;
&lt;h3 id=&quot;13-键值关系的实现&quot;&gt;1.3 键值关系的实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; interface Entry&amp;lt;K,V&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 HashMap 中基于链表的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用树的方式实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, val, next);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;14-map-约定的-api&quot;&gt;1.4 Map 约定的 API&lt;/h3&gt;
&lt;h4 id=&quot;141-map-中约定的基础-api&quot;&gt;1.4.1 Map 中约定的基础 API&lt;/h4&gt;
&lt;p&gt;基础的增删改查：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int size();  // 返回大小
boolean isEmpty(); // 是否为空
boolean containsKey(Object key); // 是否包含某个键
boolean containsValue(Object value); // 是否包含某个值
V get(Object key); // 获取某个键对应的值 
V put(K key, V value); // 存入的数据 
V remove(Object key); // 移除某个键
void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m); //将将另一个集插入该集合中
void clear();  // 清除
Set&amp;lt;K&amp;gt; keySet(); //获取 Map的所有的键返回为 Set集合
Collection&amp;lt;V&amp;gt; values(); //将所有的值返回为 Collection 集合
Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet(); // 将键值对映射为 Map.Entry，内部类 Entry 实现了映射关系的实现。并且返回所有键值映射为 Set 集合。 
boolean equals(Object o); 
int hashCode(); // 返回 Hash 值
default boolean replace(K key, V oldValue, V newValue); // 替代操作
default V replace(K key, V value);

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;142-map-约定的较为高级的-api&quot;&gt;1.4.2 Map 约定的较为高级的 API&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
default V getOrDefault(Object key, V defaultValue); //当获取失败时，用 defaultValue 替代。

default void forEach(BiConsumer&amp;lt;? super K, ? super V&amp;gt; action)  // 可用 lambda 表达式进行更快捷的遍历

default void replaceAll(BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; function); 

default V putIfAbsent(K key, V value);

default V computeIfAbsent(K key,
            Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction);

default V computeIfPresent(K key,
            BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction);

default V compute(K key,
            BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction)

default V merge(K key, V value,
            BiFunction&amp;lt;? super V, ? super V, ? extends V&amp;gt; remappingFunction)           
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;143-map--高级-api-的使用&quot;&gt;1.4.3 Map 高级 API 的使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;getOrDefault() 当这个通过 key获取值，对应的 key 或者值不存在时返回默认值，避免在使用过程中 null 出现，避免程序异常。&lt;/li&gt;
&lt;li&gt;ForEach() 传入 BiConsumer 函数式接口，表达的含义其实和 Consumer 一样，都 accept 拥有方法，只是 BiConsumer 多了一个 andThen() 方法，接收一个BiConsumer接口，先执行本接口的，再执行传入的参数的 accept 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;      Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;a&quot;, &quot;1&quot;);
        map.put(&quot;b&quot;, &quot;2&quot;);
        map.put(&quot;c&quot;, &quot;3&quot;);
        map.put(&quot;d&quot;, &quot;4&quot;);
        map.forEach((k, v) -&amp;gt; {
            System.out.println(k+&quot;-&quot;+v);
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的函数用法：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/king0/p/runoob.com/java/java-hashmap.html&quot; target=&quot;_blank&quot;&gt;菜鸟教程-Java HashMap&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;15-从-map-走向-hashmap&quot;&gt;1.5 从 Map 走向 HashMap&lt;/h3&gt;
&lt;p&gt;HashMap 是 Map的一个实现类，也是 Map 最常用的实现类。&lt;/p&gt;
&lt;h4 id=&quot;151-hashmap-的继承关系&quot;&gt;1.5.1 HashMap 的继承关系&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 HashMap 的实现过程中，解决 Hash冲突的方法是拉链法。因此从原理来说 HashMap 的实现就是 数组 + 链表（数组保存链表的入口）。 当链表过长，为了优化查询速率，HashMap 将链表转化为红黑树（数组保存树的根节点），使得查询速率为 log(n)，而不是链表的 O(n)。&lt;/p&gt;
&lt;h2 id=&quot;二、hashmap&quot;&gt;二、HashMap&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/*
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先 HashMap 由 Doug Lea 和 Josh Bloch 两位大师的参与。同时 Java 的 Collections 集合体系，并发框架 Doug Lea 也做出了不少贡献。&lt;/p&gt;
&lt;h3 id=&quot;21-基本原理&quot;&gt;2.1 基本原理&lt;/h3&gt;
&lt;p&gt;对于一个插入操作，首先将键通过 Hash 函数转化为数组的下标。 若该数组为空，直接创建节点放入数组中。若该数组下标存在节点,即 Hash 冲突，使用拉链法，生成一个链表插入。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181102221702492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvc2hpbWF4aWFvMQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.1111111111111&quot;&gt;
&lt;p&gt;引用图片来自 &lt;a href=&quot;https://blog.csdn.net/woshimaxiao1/article/details/83661464&quot; target=&quot;_blank&quot;&gt;Java集合之一—HashMap&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果存在 Hash 冲突，使用拉链法插入，我们可以在这个链表的头部插入，也可以在链表的尾部插入，所以在 JDK 1.7 中使用了头部插入的方法，JDK 1.8 后续的版本中使用尾插法。JDK 1.7 使用头部插入的可能依据是最近插入的数据是最常用的，但是头插法带来的问题之一，在多线程会链表的复制会出现死循环。所以 JDK 1.8 之后采用的尾部插入的方法。&lt;br/&gt;在 HashMap 中，前面说到的 数组+链表 的数组的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链表的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;table 来表示上述的数据。&lt;/p&gt;
&lt;h4 id=&quot;212-提供的构造函数&quot;&gt;2.1.2 提供的构造函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public HashMap() { // 空参
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    public HashMap(int initialCapacity) { //带有初始大小的，一般情况下，我们需要规划好 HashMap 使用的大小，因为对于一次扩容操作，代价是非常的大的
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    public HashMap(int initialCapacity, float loadFactor); // 可以自定义负载因子

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个构造函数，都没有完全的初始化 HashMap，当我们第一次插入数据时，才进行堆内存的分配，这样提高了代码的响应速度。&lt;/p&gt;
&lt;h3 id=&quot;22-hashmap-中的-hash函数定义&quot;&gt;2.2 HashMap 中的 Hash函数定义&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16); // 将 h 高 16 位和低 16 位 进行异或操作。
    }
// 采用 异或的原因：两个进行位运算，在与或异或中只有异或到的 0 和 1 的概率是相同的，而&amp;amp;和|都会使得结果偏向0或者1。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到，Map 的键可以为 null，且 hash 是一个特定的值 0。&lt;br/&gt;Hash 的目的是获取数组 table 的下标。Hash 函数的目标就是将数据均匀的分布在 table 中。&lt;br/&gt;让我们先看看如何通过 hash 值得到对应的数组下标。第一种方法：hash%table.length()。但是除法操作在 CPU 中执行比加法、减法、乘法慢的多，效率低下。第二种方法 table[(table.length - 1) &amp;amp; hash] 一个与操作一个减法，仍然比除法快。 这里的约束条件为 table.length = 2&lt;sup&gt;N&lt;/sup&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;table.length =16
table.length -1 = 15 1111 1111
任何一个数与之与操作，获取到这个数的低 8 位，其他位为 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子可以让我们获取到对应的下标,而 &lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt; 让高 16 也参与运算，让数据充分利用，一般情况下 table 的索引不会超过 2&lt;sup&gt;16&lt;/sup&gt;，所以高位的信息我们就直接抛弃了，&lt;code&gt;^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt; 让我们在数据量较少的情况下，也可以使用高位的信息。如果 table 的索引超过 2&lt;sup&gt;16&lt;sup&gt;， hashCode() 的高 16 为 和 16 个 0 做异或得到的 Hash 也是公平的。&lt;/sup&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-hashmap-的插入操作&quot;&gt;2.3 HashMap 的插入操作&lt;/h3&gt;
&lt;p&gt;上面我们已经知道如果通过 Hash 获取到 对应的 table 下标，因此我们将对应的节点加入到链表就完成了一个 Map 的映射，的确 JDK1.7 中的 HashMap 实现就是这样。让我们看一看 JDK 为实现现实的 put 操作。&lt;br/&gt;定位到 put() 操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 put 操作交给了 putVal 来进行通用的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict);
//onlyIfAbsent  如果当前位置已存在一个值，是否替换，false是替换，true是不替换
evict // 钩子函数的参数，LinkedHashMap 中使用到，HashMap 中无意义。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;231--putval-的流程分析&quot;&gt;2.3.1 putVal 的流程分析&lt;/h4&gt;
&lt;p&gt;其实 putVal() 流程的函数非常的明了。这里挑了几个关键步骤来引导。&lt;/p&gt;
&lt;p&gt;是否第一次插入，true 调用 resizer() 进行调整，其实此时 resizer() 是进行完整的初始化，之后直接赋值给对应索引的位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; if ((tab = table) == null || (n = tab.length) == 0) // 第一次 put 操作， tab 没有分配内存，通过 redize() 方法分配内存，开始工作。
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果链表已经转化为树，则使用树的插入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用遍历的方式遍历每个 Node，如果遇到键相同，或者到达尾节点的next 指针将数据插入，记录节点位置退出循环。若插入后链表长度为 8 则调用 treeifyBin() 是否进行树的转化 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对键重复的操作：更新后返回旧值，同时还取决于onlyIfAbsent，普通操作中一般为 true，可以忽略。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;      if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e); //钩子函数，进行后续其他操作，HashMap中为空，无任何操作。
                return oldValue;
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;     ++modCount;
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后续的数据维护。&lt;/p&gt;
&lt;h4 id=&quot;232--modcount-的含义&quot;&gt;2.3.2 modCount 的含义&lt;/h4&gt;
&lt;p&gt;fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。一种多线程错误检查的方式，减少异常的发生。&lt;br/&gt;一般情况下，多线程环境 我们使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 来代替 HashMap。&lt;/p&gt;
&lt;h3 id=&quot;24-resize-函数&quot;&gt;2.4 resize() 函数&lt;/h3&gt;
&lt;p&gt;HashMap 扩容的特点：默认的table 表的大小事 16，threshold 为 12。负载因子 loadFactor .75，这些都是可以构造是更改。以后扩容都是 2 倍的方式增加。&lt;br/&gt;至于为何是0.75 代码的注释中也写了原因，对 Hash函数构建了泊松分布模型，进行了分析。&lt;/p&gt;
&lt;h4 id=&quot;241--hashmap-预定义的一些参数&quot;&gt;2.4.1 HashMap 预定义的一些参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16  HashMap 的默认大小。 为什么使用 1 &amp;lt;&amp;lt;4
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 最大容量
static final float DEFAULT_LOAD_FACTOR = 0.75f; // 加载因子，扩容使用

static final int UNTREEIFY_THRESHOLD = 6;//  树结构转化为链表的阈值
static final int TREEIFY_THRESHOLD = 8;  //  链表转化为树结构的阈值
static final int MIN_TREEIFY_CAPACITY = 64; // 链表转变成树之前，还会有一次判断，只有数组长度大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。

// 定义的有关变量
int threshold;   // threshold表示当HashMap的size大于threshold时会执行resize操作
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些变量都是和 HashMap 的扩容机制有关，将会在下文中用到。&lt;/p&gt;
&lt;h4 id=&quot;242--resize-方法解析&quot;&gt;2.4.2 resize() 方法解析&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;      Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0; // 定义了 旧表长度、旧表阈值、新表长度、新表阈值
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  if (oldCap &amp;gt; 0) {  // 插入过数据，参数不是初始化的
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {  // 如果旧的表长度大于 1 &amp;lt;&amp;lt; 30;
                threshold = Integer.MAX_VALUE; // threshold 设置 Integer 的最大值。也就是说我们可以插入 Integer.MAX_VALUE 个数据
                return oldTab; // 直接返回旧表的长度，因为表的下标索引无法扩大了。 
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; // 
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)  //新表的长度为旧表的长度的 2 倍。
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold 新表的阈值为同时为旧表的两倍
        }
        else if (oldThr &amp;gt; 0) //   public HashMap(int initialCapacity, float loadFactor)   中的  this.threshold = tableSizeFor(initialCapacity);  给正确的位置   
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults ，如果调用了其他两个构造函数，则下面代码初始化。因为他们都没有对其 threshold 设置，默认为 0，
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) { // 修正 threshold，例如上面的   else if (oldThr &amp;gt; 0)  部分就没有设置。
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
     
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一些参数设置正确后便开始扩容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap]; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当扩容完毕之后，自然就是将原表中的数据搬到新的表中。下面代码完成了该任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  if (oldTab != null) { //
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                .... 
            }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何正确的，快速的扩容调整每个键值节点对应的下标？第一种方法：遍历节点再使用 put() 加入一遍，这种方法实现，但是效率低下。第二种，我们手动组装好链表，加入到相应的位置。显然第二种比第一种高效，因为第一种 put() 还存在其他不属于这种情况的判断，例如重复键的判断等。所以 JDK 1.8 也使用了第二种方法。我们可以继续使用&lt;code&gt;e.hash &amp;amp; (newCap - 1)&lt;/code&gt;找到对应的下标位置,对于旧的链表，执行&lt;code&gt;e.hash &amp;amp; (newCap - 1)&lt;/code&gt; 操作，只能产生两个不同的索引。一个保持原来的索引不变，另一个变为 原来索引 + oldCap(因为 newCap 的加入产生导致索引的位数多了 1 位，即就是最左边的一个，且该位此时结果为 1，所以相当于 原来索引 + oldCap)。所以可以使用 &lt;code&gt;if ((e.hash &amp;amp; oldCap) == 0)&lt;/code&gt; 来确定出索引是否来变化。因此这样我们就可以将原来的链表拆分为两个新的链表，然后加入到对应的位置。为了高效，我们手动的组装好链表再存储到相应的下标位置上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;oldCap  = 16
newCap  = 32
hash       : 0001 1011
oldCap-1   : 0000 1111
结果为     :  0000 1011  对应的索引的 11
-------------------------
e.hash &amp;amp; oldCap 则定于 1,则需要进行调整索引
oldCap  = 16
hash       : 0001 1011 
newCap-1   : 0001 1111
结果为     :  0001 1011
相当于 1011 + 1 0000 原来索引 + newCap
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; for (int j = 0; j &amp;lt; oldCap; ++j)  // 处理每个链表 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特殊条件处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)  // 该 链表只有一个节点，那么直接复制到对应的位置，下标由 e.hash &amp;amp; (newCap - 1) 确定
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode) // 若是 树，该给树的处理程序
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;普通情况处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       else { // preserve order
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;  // 构建原来索引位置 的链表，需要的指针
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null; // 构建 原来索引 + oldCap 位置 的链表需要的指针
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null); // 将原来的链表划分两个链表
                        if (loTail != null) { // 将链表写入到相应的位置
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此 resize() 方法的逻辑完成了。总的来说 resizer() 完成了 HashMap 完整的初始化，分配内存和后续的扩容维护工作。&lt;/p&gt;
&lt;h3 id=&quot;25--remove-解析&quot;&gt;2.5 remove 解析&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public V remove(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 remove 删除工作交给内部函数 removeNode() 来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (p = tab[index = (n - 1) &amp;amp; hash]) != null) {  // 获取索引，
            Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;amp;&amp;amp;  
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) // 判断索引处的值是不是想要的结果
                node = p;  
            else if ((e = p.next) != null) { // 交给树的查找算法
                if (p instanceof TreeNode)
                    node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
                else {
                    do { // 遍历查找
                        if (e.hash == hash &amp;amp;&amp;amp;
                            ((k = e.key) == key ||
                             (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;amp;&amp;amp; value.equals(v)))) {
                if (node instanceof TreeNode)  //树的删除
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p) // 修复链表，链表的删除操作
                    tab[index] = node.next; 
                else
                    p.next = node.next;  
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、-hashmap-从链表到红黑树的转变&quot;&gt;三、 HashMap 从链表到红黑树的转变&lt;/h2&gt;
&lt;p&gt;如果链表的长度（冲突的节点数）已经达到8个，此时会调用 treeifyBin() ，treeifyBin() 首先判断当前hashMap 的 table的长度，如果不足64，只进行resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树。 在源码还有这样的一个字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; static final int UNTREEIFY_THRESHOLD = 6; // 这样表明了从红黑树转化为链表的阈值为 6，为何同样不是 8 那？ 如果插入和删除都在 8 附近，将多二者相互转化将浪费大量的时间，对其性能影响。 如果是的二者转化的操作不平衡，偏向一方，则可以避免此类影响。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;31-红黑树的数据结构&quot;&gt;3.1 红黑树的数据结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // 删除后需要取消链接，指向前一个节点（原链表中的前一个节点）
        boolean red;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 继承了 LinkedHashMap.Entry&amp;lt;K,V&amp;gt; ，所以存储的数据最总最 Entry 中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32--承上启下的-treeifybin&quot;&gt;3.2 承上启下的 treeifyBin()&lt;/h3&gt;
&lt;p&gt;treeifyBin() 决定了一个链表何时转化为一个红黑树。 treeifyBin() 有两种格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash);
 final void treeify(Node&amp;lt;K,V&amp;gt;[] tab);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) { // 简单的 Node 修改为 TreeNode，同时维护了 prev 属性。
        int n, index; Node&amp;lt;K,V&amp;gt; e;
        if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) &amp;amp; hash]) != null) {
            TreeNode&amp;lt;K,V&amp;gt; hd = null, tl = null;
            do {
                TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);  // 真正生成红黑树的
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    TreeNode&amp;lt;K,V&amp;gt; replacementTreeNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt; next) {
        return new TreeNode&amp;lt;&amp;gt;(p.hash, p.key, p.value, next);
    } // 实现 Node 链表节点到 TreeNode 节点的转化。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面函数真正实现了链表的红黑树的转变。首先构建一个标准查询二叉树，然后在标准查询二叉树然后调整为一个红黑树。而 balanceInsertion() 实现了调整。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
        /**
         * Forms tree of the nodes linked from this node.
         */
        final void treeify(Node&amp;lt;K,V&amp;gt;[] tab) {
            TreeNode&amp;lt;K,V&amp;gt; root = null;
            for (TreeNode&amp;lt;K,V&amp;gt; x = this, next; x != null; x = next) {
                next = (TreeNode&amp;lt;K,V&amp;gt;)x.next;
                x.left = x.right = null;
                if (root == null) { // 第一次转化过程，将链表的头节点作为根节点。
                    x.parent = null;
                    x.red = false;  // 红黑树的定义 根节点必须为黑色
                    root = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&amp;lt;?&amp;gt; kc = null;
                    for (TreeNode&amp;lt;K,V&amp;gt; p = root;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &amp;gt; h)  //// 通过 Hash 的大小来确定插入顺序
                            dir = -1; // dir 大小顺序的标识
                        else if (ph &amp;lt; h)
                            dir = 1; 
                        else if ((kc == null &amp;amp;&amp;amp; //当 两个 Hash 的值相同，进行特殊的方法，确定大小。
                                  (kc = comparableClassFor(k)) == null) || // Returns x's Class if it is of the form &quot;class C implements Comparable &quot;, else null. 如果 key类的 源码书写格式为 C implement Comparable&amp;lt;C&amp;gt; 那么返回该类类型 C, 如果间接实现也不行。 如果是 String 类型，直接返回 String.class
                                 (dir = compareComparables(kc, k, pk)) == 0)   //    ((Comparable)k).compareTo(pk)); 强制转换后进行对比，若 dir == 0,则 tieBreakOrder()，继续仲裁 
                            dir = tieBreakOrder(k, pk);  // 首先通过二者的类类型进行比较，如果相等的话，使用 (System.identityHashCode(a) &amp;lt;= System.identityHashCode(b) 使用原始的 hashcode，不是重写的在对比。
 
                        TreeNode&amp;lt;K,V&amp;gt; xp = p; // 遍历的，上一个节点
                        if ((p = (dir &amp;lt;= 0) ? p.left : p.right) == null) { //通过 dir，将 p 向下查找，直到 p 为 null，找到一个插入时机
                            x.parent = xp;
                            if (dir &amp;lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            root = balanceInsertion(root, x); //进行二叉树的调整
                            break;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-将一个二叉树转化为红黑树的操作-balanceinsertion&quot;&gt;3.3 将一个二叉树转化为红黑树的操作-balanceInsertion()&lt;/h3&gt;
&lt;p&gt;当红黑树中新增节点的时候需要调用balanceInsertion方法来保证红黑树的特性。&lt;br/&gt;如果想要了解红黑树的插入过程那么必须对红黑树的性质有一个较为清晰的了解。&lt;/p&gt;
&lt;p&gt;红黑树的性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个结点或是红色的，或是黑色的&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;每个叶结点（NIL）是黑色的&lt;/li&gt;
&lt;li&gt;如果一个节点是红色的，则它的两个儿子都是黑色的。&lt;/li&gt;
&lt;li&gt;对于每个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceInsertion(TreeNode&amp;lt;K,V&amp;gt; root,
                                                    TreeNode&amp;lt;K,V&amp;gt; x) {
            x.red = true;  // 插入的子节点必须为 red
            for (TreeNode&amp;lt;K,V&amp;gt; xp, xpp, xppl, xppr;;) { //// x 当前处理节点 xp父节点 xpp祖父节点 xppl祖父左节点 xppr 祖父右节点
                if ((xp = x.parent) == null) { // 如果 当前处理节点为根节点，满足红黑树的性质，结束循环
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null) 
                    return root;
                if (xp == (xppl = xpp.left)) {
                    if ((xppr = xpp.right) != null &amp;amp;&amp;amp; xppr.red) {
                        xppr.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null &amp;amp;&amp;amp; xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;treenode-红黑树总结&quot;&gt;TreeNode 红黑树总结&lt;/h4&gt;
&lt;p&gt;TreeNode 完整的实现了一套红黑树的增删改查的规则。实现参考了《算法导论》&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;      /* ------------------------------------------------------------ */
        // Red-black tree methods, all adapted from CLR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里推荐一个红黑树动画演示网站 &lt;a href=&quot;https://rbtree.phpisfuture.com/&quot; target=&quot;_blank&quot;&gt;https://rbtree.phpisfuture.com/&lt;/a&gt;&lt;br/&gt;红黑树是一个不严格的平衡二叉查找树，高度近似 log(N)。&lt;/p&gt;
&lt;h2 id=&quot;四、hashmap-的扩展&quot;&gt;四、HashMap 的扩展&lt;/h2&gt;
&lt;p&gt;Map中 key 有一个性质，就是 key 不能重复，而 Java Set 的含义：集合中不能有重复的元素。HashMap 的实现已经足够的优秀。那么我们是否可以用 key 的性质来实现 Set ？ 的确 JDK 中的 HashSet 就是这样做的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HashSet&amp;lt;E&amp;gt;
    extends AbstractSet&amp;lt;E&amp;gt;
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
{
    private transient HashMap&amp;lt;E,Object&amp;gt; map;
      // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PRESENT&lt;/code&gt; 就是存进 Map 中的 value，而 key 正是 Set 语义的实现。而且可以判断出 HashSet 中是允许存入 Null 值的。&lt;/p&gt;
</description>
<pubDate>Wed, 23 Dec 2020 00:29:00 +0000</pubDate>
<dc:creator>山貓先森</dc:creator>
<og:description>Java 从 Map 到 HashMap 的一步步实现 一、 Map 1.1 Map 接口 在 Java 中, Map 提供了键——值的映射关系。映射不能包含重复的键,并且每个键只能映射到一个值。 以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/king0/p/14176609.html</dc:identifier>
</item>
<item>
<title>C#中的深度学习（三）：理解神经网络结构 - 码农译站</title>
<link>http://www.cnblogs.com/hhhnicvscs/p/14176603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhhnicvscs/p/14176603.html</guid>
<description>&lt;p&gt;在这篇文章中，我们将回顾监督机器学习的基础知识，以及训练和验证阶段包括哪些内容。&lt;/p&gt;
&lt;p&gt;在这里，我们将为不了解AI的读者介绍机器学习(ML)的基础知识，并且我们将描述在监督机器学习模型中的训练和验证步骤。&lt;/p&gt;
&lt;p&gt;ML是AI的一个分支，它试图通过归纳一组示例而不是接收显式指令来让机器找出如何执行任务。ML有三种范式:监督学习、非监督学习和强化学习。在监督学习中，一个模型(我们将在下面讨论)通过一个称为训练的过程进行学习，在这个过程中，它会提供示例输入和正确输出。它了解数据集示例中哪些特性映射到特定输出，然后能够在一个称为预测的阶段预测新的输入数据。在无监督学习中，模型通过分析数据之间的关系来学习数据的结构，而不涉及任何其他过程。在强化学习中，我们建立模型，通过试验和错误技术，随着时间的推移学习和改进。&lt;/p&gt;
&lt;p&gt;ML中的模型是什么?模型是一个简单的数学对象或实体，它包含一些关于AI的理论背景，以便能够从数据集学习。在监督学习中流行的模型包括决策树、向量机，当然还有神经网络。&lt;/p&gt;
&lt;p&gt;神经网络是按堆栈的形状分层排列的。除了输入层和输出层之外，每一层的节点都接收来自上一层节点的输入，也可以接收来自下一层节点的输入，同样也可以向上一层和下一层节点发送信号或输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201223082029415-1554092617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一个神经网络中，我们总是存在输入和输出层，可能有一个或多个隐藏层。&lt;/p&gt;
&lt;p&gt;最简单的NN是感知器，它是包含的输入层和输出层单个节点。&lt;/p&gt;
&lt;p&gt;对于神经网络中的每条边都有一个关联的权重值，这是对于每个节点都有关联的值。例如，输入层中每个节点的值可以来自与数据集中的图像相关联的像素值输入数组。为了计算下一层节点的值，我们计算连接到该节点的输入的加权和。这就是传递函数。一旦计算出这个值，它就被传递给另一个称为激活函数的函数，该函数根据阈值确定该节点是否应该触发到下一层。有些激活函数是二进制的，有些则有多个输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201223082045868-2093488065.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常在神经网络的末尾，我们有一个激活函数，它对传递到输入层的数据进行分类(做出决定)。在硬币识别的情况下，它将决定图像中硬币的类别或类型。神经网络中的学习过程可以仅仅看作是对其权重的调整，以便为每个给定的输入获得预期的输出。一旦对模型进行了训练，得到的权重就可以被保存下来。&lt;/p&gt;
&lt;p&gt;当一个神经网络有一个以上的隐藏层时，我们将其称为深度学习(DL)。DL是一套依赖于神经网络且不止一个隐藏层的技术。拥有多个隐藏层的原因是提供比单一隐藏层神经网络更准确的结果。实践证明，深度神经网络比单层神经网络能产生更快更准确的结果。你添加到你的神经网络的每一层都有助于从数据集学习复杂的特征。&lt;/p&gt;
&lt;p&gt;神经网络包含许多需要调整以获得更好性能的参数。为了能够检查参数优化的有效性和神经网络本身的性能,我们留出很大一部分的原始数据集(通常大于70%)作为训练集,使用其他验证(测试)组。验证集也帮助我们防止过度拟合,这发生在一个模型学习太好一组非常相似的对象数据集,使它太适合这个数据和不适合新数据。&lt;/p&gt;
&lt;p&gt;在下一篇文章中，我们将研究用于硬币识别问题的卷积神经网络，并将在Keras.NET中实现一个卷积神经网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注我的公众号，如果你有喜欢的外文技术文章，可以通过公众号留言推荐给我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201223082100116-444019742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://www.codeproject.com/Articles/5284227/Deep-Learning-in-Csharp-Understanding-Neural-Netwo&quot;&gt;&lt;span&gt;https://www.codeproject.com/Articles/5284227/Deep-Learning-in-Csharp-Understanding-Neural-Netwo&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 23 Dec 2020 00:22:00 +0000</pubDate>
<dc:creator>码农译站</dc:creator>
<og:description>在这篇文章中，我们将回顾监督机器学习的基础知识，以及训练和验证阶段包括哪些内容。 在这里，我们将为不了解AI的读者介绍机器学习(ML)的基础知识，并且我们将描述在监督机器学习模型中的训练和验证步骤。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hhhnicvscs/p/14176603.html</dc:identifier>
</item>
<item>
<title>10 个 GitHub 上超火的 CSS 奇技淫巧项目，找到写 CSS 的灵感！ - 天明夜尽</title>
<link>http://www.cnblogs.com/biaochenxuying/p/14167406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/biaochenxuying/p/14167406.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-9dbeb551ffc39333.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是你们的 超级猫，一个不喜欢吃鱼、又不喜欢喵 的超级猫 ~&lt;/p&gt;
&lt;p&gt;如果 CSS 是女孩子，肯定如上图那样吧 🤩 ~&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-61e533eb9988f8b1.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般人没事的时候刷刷朋友圈、微博、电视剧、知乎，而有些人是没事的时候刷刷 GitHub ，看看最近有哪些流行的项目。&lt;/p&gt;
&lt;p&gt;久而久之，这差距就越来越大，因此总会有开源信息的不对称，有哪些优秀的前端开源项目值得学习的也不知道。&lt;/p&gt;
&lt;p&gt;初步前端与高级前端之间，最大的差距可能就是信息差造成的。&lt;/p&gt;
&lt;p&gt;超级猫从 2016 年加入 GitHub，到现在的 2020 年，快整整 5 个年头了。&lt;/p&gt;
&lt;p&gt;从 2018 年开始，我就养成了每天逛 GitHub 的习惯，一般在早上上班前或者中午午休的时候都会逛一下。&lt;/p&gt;
&lt;p&gt;看看每天都开源了哪些好的前端项目，还有用到的主流前端技术栈又是哪些，值得我去学习的。&lt;/p&gt;
&lt;p&gt;因此也收藏了不少好的开源项目，在此推荐给大家，每周会有一到三篇精华文章推送。&lt;/p&gt;
&lt;p&gt;希望你在浏览、学习了超级猫推荐的这些开源项目的过程中，你能学习到更多编程知识、提高编程技巧、找到编程的乐趣。&lt;/p&gt;
&lt;blockquote readability=&quot;6.6199095022624&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/FrontEndGitHub/FrontEndGitHub&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;前端GitHub&lt;/strong&gt;&lt;/a&gt;，专注于挖掘 GitHub 上优秀的前端开源项目，抹平你的前端信息不对称，涵盖 JavaScript、Vue、React、Node、小程序、Flutter、Deno、HTML、CSS、数据结构与算法 等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时如何发现好的开源项目，可以看看这篇文章：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/45&quot; target=&quot;_blank&quot;&gt;GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以下为【前端GitHub】的第 7 期精华内容。&lt;/p&gt;
&lt;p&gt;今天给大家带来的是 &lt;strong&gt;GitHub 上超火的 10 个 CSS 项目&lt;/strong&gt;，希望你在这里面找到写 CSS 的灵感！&lt;/p&gt;
&lt;p&gt;喵~ 喵~ 喵~ 正文开始了，上车坐稳扶好了~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-9bded23edcb522df.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;you-need-to-know-css&quot;&gt;You-need-to-know-css&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-26c4a8a9b2777dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该项目是 CSS 的各种效果实现，尤其是动画效果。&lt;/p&gt;
&lt;p&gt;笔者把自己的收获和工作中常用的一些 CSS 小样式总结成这份文档。&lt;/p&gt;
&lt;p&gt;目前文档一共包含 43 个 CSS 的小样式（持续更新…），所以还是很不错的学习 CSS 的项目来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-c90dbdeb4ac39c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如： 打字效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style&amp;gt;
  main {
    width: 100%; height: 229px;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  span {
    display: inline-block;
    width: 21ch;
    font: bold 200% Consolas, Monaco, monospace;   /*等宽字体*/
    overflow: hidden;
    white-space: nowrap;
    font-weight: 500;
    border-right: 1px solid transparent;
    animation: typing 10s steps(21), caret .5s steps(1) infinite;
  }
  @keyframes typing{
    from {
        width: 0;
    }
  }
  @keyframes caret{
    50% { border-right-color: currentColor}
  }
&amp;lt;/style&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;main class=&quot;main&quot;&amp;gt;
    &amp;lt;span&amp;gt;前端GitHub&amp;lt;/span&amp;gt;
  &amp;lt;/main&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://lhammer.cn/You-need-to-know-css/#/zh-cn/&quot; target=&quot;_blank&quot;&gt;https://lhammer.cn/You-need-to-know-css/#/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;css-inspiration&quot;&gt;CSS-Inspiration&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-62e7b41f9871921d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以让你寻找到使用或者是学习 CSS 的灵感，以分类的形式，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。&lt;/p&gt;
&lt;p&gt;包含了：布局(Layout)、阴影(box-shadow、drop-shadow)、伪类/伪元素、滤镜(fliter)、边框(border)、背景/渐变(linear-gradient/radial-gradient/conic-gradient)、混合模式（mix-blend-mode/background-blend-mode)、3D、动画/过渡(transition/animation)、clip-path、文本类、综合、CSS-Doodle、SVG 等内容。&lt;/p&gt;
&lt;p&gt;比如：&lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/75&quot; target=&quot;_blank&quot;&gt;巧用 CSS 实现酷炫的充电动画&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-246773093bcbe20e.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chokcoco/CSS-Inspiration&quot; target=&quot;_blank&quot;&gt;https://github.com/chokcoco/CSS-Inspiration&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;css_tricks&quot;&gt;css_tricks&lt;/h2&gt;
&lt;p&gt;该项目总结了一些常用的 CSS 样式，记录一些 CSS 的新属性和一点奇技淫巧。&lt;/p&gt;
&lt;p&gt;比如 提示气泡的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;poptip btn&quot; aria-controls=&quot;弹出气泡&quot;&amp;gt;poptip&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$poptipBg: #30363d;
$color: #fff;
$triangle: 8px;
$distance: -12px;
.poptip {
  position: relative;
  z-index: 101;
  &amp;amp;::before,
  &amp;amp;::after {
    visibility: hidden;
    opacity: 0;
    transform: translate3d(0, 0, 0);
    transition: all 0.3s ease 0.2s;
    box-sizing: border-box;
  }
  &amp;amp;::before {
    content: &quot;&quot;;
    position: absolute;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: $triangle $triangle 0 $triangle;
    border-color: $poptipBg transparent transparent transparent;
    left: calc(50% - #{$triangle});
    top: 0px;
    transform: translateX(0%) translateY($distance);
  }

  &amp;amp;::after {
    font-size: 14px;
    color: $color;
    content: attr(aria-controls);
    position: absolute;
    padding: 6px 12px;
    white-space: nowrap;
    z-index: -1;
    left: 50%;
    bottom: 100%;
    transform: translateX(-50%) translateY($distance);
    background: $poptipBg;
    line-height: 1;
    border-radius: 2px;
  }
  &amp;amp;:hover::before,
  &amp;amp;:hover::after {
    visibility: visible;
    opacity: 1;
  }
}

.btn {
  min-width: 100px;
  line-height: 1.5;
  padding: 5px 10px;
  color: #fff;
  background: #00adb5;
  border-radius: 4px;
  text-align: center;
  cursor: pointer;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-35a063a8cd1b5a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/QiShaoXuan/css_tricks&quot; target=&quot;_blank&quot;&gt;https://github.com/QiShaoXuan/css_tricks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;animista&quot;&gt;animista&lt;/h2&gt;
&lt;p&gt;该项目里面有各种 CSS 实现的效果，还有代码演示，方便直接复制代码，还可以复制压缩后的代码，如果你在找某个 CSS 的效果的话，可以到这里找找看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-e54e3eea21945d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-cea61e040153d0c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://animista.net/&quot; target=&quot;_blank&quot;&gt;http://animista.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spinkit&quot;&gt;spinkit&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-56f7e809e64a29ce.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汇集了实现各种加载效果的 CSS 代码片段。&lt;/p&gt;
&lt;p&gt;SpinKit 仅使用（&lt;code&gt;transform&lt;/code&gt; 和 &lt;code&gt;opacity&lt;/code&gt;）CSS 动画来创建平滑且易于自定义的动画。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://tobiasahlin.com/spinkit/&quot; target=&quot;_blank&quot;&gt;https://tobiasahlin.com/spinkit/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;you-dont-need-javascrip&quot;&gt;You-Dont-Need-JavaScrip&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/you-dont-need/You-Dont-Need-JavaScrip&quot; target=&quot;_blank&quot;&gt;https://github.com/you-dont-need/You-Dont-Need-JavaScrip&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;十天精通-css3&quot;&gt;十天精通 CSS3&lt;/h2&gt;
&lt;p&gt;这是前端大佬大漠出的一个免费的 CSS3 教程，对于有一定 CSS2 经验的伙伴，能让您系统的学习 CSS3，快速的理解掌握并应用于工作之中。&lt;/p&gt;
&lt;p&gt;里面的内容有讲解，还有代码演习，学完之后，可以练习所学的 api ，真的很不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-cd8f7b19cf206b88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;超级猫入门前端时，也学习过里面的内容呢，虽然现在忘记的差不多了 😂，但是学过！。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.imooc.com/learn/33&quot; target=&quot;_blank&quot;&gt;https://www.imooc.com/learn/33&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;animate&quot;&gt;Animate&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-e736e99341536f62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是一个有趣的，跨浏览器的 css3 动画库，内置了很多典型的 css3 动画，兼容性好使用方便。&lt;/p&gt;
&lt;p&gt;animate.css 的使用非常简单，因为它是把不同的动画绑定到了不同的类里，所以想要使用哪种动画，只需要把通用类 animated 和相应的类添加到元素上就行了。&lt;/p&gt;
&lt;p&gt;做为一个前端开发，如果不知道这个库就真的很失败了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://animate.style/&quot; target=&quot;_blank&quot;&gt;https://animate.style/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;sass&quot;&gt;sass&lt;/h2&gt;
&lt;p&gt;Sass 是一种 CSS 的预编译语言，Sass 为 CSS 赋予了更强大的功能。&lt;/p&gt;
&lt;p&gt;它提供了 变量（variables）、嵌套（nested rules） [混合（mixins）、函数（functions）等功能，并且完全兼容 CSS 语法。&lt;/p&gt;
&lt;p&gt;Sass 能够帮助复杂的样式表更有条理， 并且易于在项目内部或跨项目共享设计。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://sass.bootcss.com/documentation&quot; target=&quot;_blank&quot;&gt;https://sass.bootcss.com/documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;less&quot;&gt;less&lt;/h2&gt;
&lt;p&gt;Less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量、Mixin、函数等特性。&lt;/p&gt;
&lt;p&gt;Less 可以运行在 Node 或浏览器端。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://less.bootcss.com/&quot; target=&quot;_blank&quot;&gt;https://less.bootcss.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;stylus&quot;&gt;stylus&lt;/h2&gt;
&lt;p&gt;富有表现力、动态、健壮的 CSS。&lt;/p&gt;
&lt;p&gt;它提供了一种高效，动态和表达方式来生成 CSS。同时支持缩进语法和常规 CSS 样式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://stylus-lang.com/&quot; target=&quot;_blank&quot;&gt;https://stylus-lang.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;CSS 预处理器技术已经非常的成熟了，而且也涌现出了越来越多的 CSS 的预处理器框架。&lt;/p&gt;
&lt;p&gt;对于 sass 、less 和 stylus，都是在现在的 vue 和 react 项目中经常用到的，用法也很简单，只要学会一种，其他两种都很容易上手，项目中用哪一种就要看自己的喜欢了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-6fd605f528682683.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-6b3b3bd777ba069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近加班有点严重，所有文章更新慢了很多，同是打工猫，生活不易啊！&lt;/p&gt;
&lt;p&gt;好了啦，【前端GitHub】的第 7 期内容已经讲完了啦。&lt;/p&gt;
&lt;p&gt;更多精彩内容请关注下方仓库：&lt;/p&gt;
&lt;blockquote readability=&quot;1.1904761904762&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://github.com/FrontEndGitHub/FrontEndGitHub&quot; target=&quot;_blank&quot;&gt;https://github.com/FrontEndGitHub/FrontEndGitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时如何发现好的开源项目，可以看看这两篇文章：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/45&quot; target=&quot;_blank&quot;&gt;GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/FrontEndGitHub/FrontEndGitHub/issues/4&quot; target=&quot;_blank&quot;&gt;恕我直言，你可能连 GitHub 搜索都不会用 - 如何精准搜索的神仙技巧&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以加超级猫的 wx：CB834301747 ，一起闲聊 前端GitHub。&lt;/p&gt;
&lt;p&gt;觉得有用 ？喜欢就收藏，顺便点个赞吧，你的支持是我最大的鼓励！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;往期精文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你最想对超级猫说点啥？&lt;/p&gt;
</description>
<pubDate>Wed, 23 Dec 2020 00:20:00 +0000</pubDate>
<dc:creator>天明夜尽</dc:creator>
<og:description>大家好，我是你们的 超级猫，一个不喜欢吃鱼、又不喜欢喵 的超级猫 ~ 如果 CSS 是女孩子，肯定如上图那样吧 &amp;amp;#129321; ~ 简介 一般人没事的时候刷刷朋友圈、微博、电视剧、知乎，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/biaochenxuying/p/14167406.html</dc:identifier>
</item>
<item>
<title>我是如何提高自己的「编程能力」的？ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/14176574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/14176574.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上周的投票，大家最关心的还是提高技术，那我们今天就来聊聊这个话题。&lt;/p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1glwfpyqb3yj31390n9wfm.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前主要分享的多是算法和数据结构方面（年后继续），因为我认为算法和数据结构是程序员最最最重要的内功，但是并不是唯一。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己作为一个非科班的程序员，并且在工作中观察了“这两类”工程师的表现，我认为科班和非科班最大的区别在于：科班的同学知道去学什么，问题出现了他知道自己是哪里有知识漏洞；而非科班的，可能&lt;strong&gt;压根不知道自己不知道什么&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（解决方式：建立系统的知识体系、寻求老板、tech lead 的指点，快速补充基础并反复学习。）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这篇文章我想粗浅的聊聊成为一个工程师需要掌握的大致学习路线，更多的偏入门一些，不涉及具体的工作方向。欢迎大家在文末分享你的学习心得，正如柏拉图所说：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;人只有通过和别人讨论，才能知道我们的经验是不是真实的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文章略长，如果一次没时间看完，建议先拉到文末参与抽奖送书活动～&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把学习比作练功的话，我把我的学习内容分为：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;修炼“外功”：偏应用&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;修炼“内功”：偏基础&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者配合，才能仗剑走天涯！&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一、外功&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. Linux 操作系统&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于想做开发的同学，如果还是个小白，问我第一件事情该做什么，我会强烈推荐先学习 Linux 操作系统，因为互联网公司基本上大部分业务框架部署都是在 Linux 操作系统上进行的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为学习 Linux 操作系统的重点就在于学习各种强大&lt;strong&gt;命令&lt;/strong&gt;如何组合运用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一是因为工作中我们经常需要用到，比如对各种日志文件进行分析，写脚本驱动机器帮助我们工作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二是面试时经常会给出一个需求场景让你编写相关的组合命令，比如统计一段日志中各种 IP 地址出现的次数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给大家推荐一本 Linux 界的“圣经”。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxztfj74j30jz08174u.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《鸟哥的 Linux 私房菜》蝉联最受欢迎华语 Linux 书籍第一的位置，无人能撼动。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于想走开发路线，或者互联网技术路线的同学，学习 Linux 绝对是必须的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一本既能帮助你入门，又能随时备查的工具书。更特别的是鸟哥的写作风格，非常口语化，读起来感觉像是有人在跟你实时互动聊天。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议想要学习的同学可以收藏一本电子版随时备查。第一次阅读的同学估计会被它的厚度吓到，但其实没有必要去一字一字的全部读完，快速的看完前面十章，你就会对 Linux 有一个初步的认识。以后需要用到哪些命令和知识随时再查就可以了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 学习一门语言和框架&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 Linux 操作系统有了一定的了解之后，大家就可选择一门编程语言及其通用框架进行学习开发。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语言的学习和框架可以借助的资料就很多了，每个人的习惯都不一样。喜欢跟着视频学习的可以去慕课网、极客时间，上面有很多性价比很高的课程。另外推荐大家可以加入一些交流群，嗯，比如我的读者交流群，另外一些框架或者语言的官网里面都会有自己社区和交流群的联系方式，里面会有很多精华帖子和大牛进行分享。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说回我自己，当时入门语言是 C++，研究生课程要用，没基础也只能硬着头皮上了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实很多 C++ 的课程或者书籍都是先讲 C 语言，比如《C++ Primer》前面几章都是讲的 C 语言，所以也还好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来刷题的时候觉得 C++ 刷题有些麻烦，听了朋友建议选择了 Java，真心感谢他的建议，在这里我也建议如果你不知道应该选什么语言，自己也没有特殊偏爱的话，那就无脑选 Java 吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Java 市面上学习资料非常的多，无论是国内还是国外大厂 Java 的就业面都非常广，对于新人来说目前是个很稳妥的选择。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你不放心，可以在任何一个招聘网站上面查一查各种语言给岗位需求，只要不是那种很窄门的语言，我觉得学习都是没有问题的。像 Go、Python、C++ 等等就业面还是广泛的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在看来，我认为这三门语言都是需要学习的：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java 是综合能力很强的语言，很多互联网公司大型的框架或者开源项目都是基于 Java 的，因为它有非常完成的一套轮子，能够快速帮助企业解决业务问题；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;C 语言偏底层，很多软件都是用 C 来写的或者和它有间接的关系，学习 C 能够帮你更好的理解计算机；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;C++ 虽然有些复杂，但它在某些应用场景中有很强的不可替代性，很多公司还在用 C++ 开发核心架构，比如腾讯、百度、谷歌等。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何学习呢？这里拿 Java 举例来说。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;A. 基础部分&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐书籍：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzl5un4j30jy09i3zc.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时推荐 B 站尚学堂的这套免费课程，可以说包含了 Java 的全部内容了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://space.bilibili.com/392179313&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己总结的关于 Java 集合的文章：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 &lt;a href=&quot;https://mp.weixin.qq.com/s/7WA1k31xmatsYTEfyMdLEQ&quot;&gt;Java 集合框架看这一篇就够了&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外如何写出高效的 Java 代码，再次拿出我喜欢的这本 &lt;em&gt;Effective Java&lt;/em&gt;了，其实我觉得 &lt;em&gt;Effective C++&lt;/em&gt; 会更好些，不过 Java 这本有针对 Java 的内容，具体的介绍可以看我这个视频：&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;B. 实战部分&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习一门语言和框架我认为最好的方式就是做项目，做项目除了锻炼我们开发能力外，在找实习和找工作时候也是和面试官很好的切入点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 的 Spring 框架是必须要用的，推荐《Spring 实战》这本书。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzg9tu9j30jm07kt9c.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IoC 和 AOP 是核心，如何理解，看我这篇文章：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 &lt;a href=&quot;https://mp.weixin.qq.com/s/F_ISmJwNuH1I3l6IXua2SQ&quot;&gt;一分钟带你玩转 Spring IoC&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以去 Github 上找一些感兴趣的项目入手，或者是跟着一些课程视频做项目。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们习以为常的博客系统，你可以亲自动手实现感受一下做一个博客的全过程。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试时候面试官常常会问：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;你做这个项目有什么亮点？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;你解决的最难问题是什么？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题都是想考察你知识深度，所以做项目时候要思考一些有趣的点，或者就是别人的东西自己内化一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，我使用了几种不同的缓存技术极大的降低了响应耗时，接下来再跟面试官去讲自己的实现思路和对缓存技术的深入理解，做到“年轻人有备而来”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做开发的同学经常戏称自己的工作就是“增删查改”，那么增删查改自然离不开对数据库的使用，做项目的时候就要学习数据库的使用。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 数据库&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我是全栈程序员，但是工作中多数处理的还是后端问题，数据库真的非常非常常用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我转行成为“专业”的程序员之前，在金融公司里也常用数据库，毕竟交易系统的下游肯定是数据库，数据也是一切模型的前提。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初学者建议由浅入深，先学习怎么用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐这本书《MySQL 必知必会》，是一本稍厚的小册子，书中没有讲太多数据库的底层原理，但是条理清晰、简明扼要的介绍了初学者应该掌握的基础知识。&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzh6qtlj30kb084js2.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个晚上的时间坐下来静静的看，你会发现你对 SQL 语句如何编写会有一个很系统性认识。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试时候面试官常常问一个需求场景，让你编写相关的 SQL 语句。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我面试时遇到的一个问题：写一个 SQL: table(Sno, Sname, classId, grade)查出每个班成绩前三名的同学？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但仅仅是掌握基本的 SQL 语句编写是远远不够的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“增删查改”里面也有大学问，同样是增删查改，有些人就能把数据库性能玩转到极致。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想玩到极致自然离不开我们对&lt;strong&gt;底层原理&lt;/strong&gt;的把握，这也是面试时候面试官最喜欢考察的内容，下面介绍两本和数据库底层原理相关的书籍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzpuzksj30kk07bq3f.jpg&quot; alt=&quot;&quot;/&gt; 《MySQL 技术内幕：InnoDB 存储引擎》由国内资深 MySQL 专家亲自执笔。本书的内容不是着眼于基本的语法教学，而是通过对数据库底层数据结构、工作机制的分析，告诉我们如何编写 SQL 语句才是高效的，告诉我们索引如何利用才能发挥最佳效果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举几个面试常见的问题，联合索引为什么要最左匹配？数据库的隔离级别是怎么实现的？都可以在里面找到答案，数据库绝对是开发适合面试考察的重点。这本书是通过大量的例子和插图进行知识讲解，会给人留下很直观印象。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一本书和 Redis 相关的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzqq2cjj30kq081jru.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是世界上最受欢迎的非关系型数据库之一，常常用来当作缓存和 MySQL 配套使用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 本身的语法并不复杂，同学们可以找到很多这方面的语法教学资料。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试时候常常会被问到，Redis 为什么会这么快？如果只是回答因为它是基于内存的数据库，那么面试就凉凉啦。真正的关键秘诀是在于 Redis 的设计与实现，阅读这本书你会发现，Redis 是通过一系列底层设计来保证它快速存取的性能。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二、内功&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. 算法和数据结构&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为算法和数据结构是计算机最重要的东西，没有之一。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序 = 数据结构 + 算法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习算法究竟有什么用呢？为什么大厂喜欢考察算法？可以看我这篇文章：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 &lt;a href=&quot;https://mp.weixin.qq.com/s/afgfp3FQAauywAEElibD9w&quot;&gt;刷题到底有什么用？你这么刷题还真没用&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作中需要分析复杂度，很多性能上的问题都依赖算法和数据结构来解决，并且带给你思维方式上的改变。有没有学过算法，决定了你能否想到最优的解决方案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时算法也是计算机的基础，任何一个你使用的软件或者框架中都一定有算法和数据结构。比如数据库索引使用了 B+ 树。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此先推荐这本书：&lt;em&gt;Algorithms + Data Structures = Programs&lt;/em&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzm97uxj30wm0ehwgp.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而功利一点来说，算法题的考察是进大厂必备的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国外的不管大中小公司、国内呢像字节跳动，基本上每一轮面试官都会让你“手撕“代码，因为这是对我们写代码能力最直接的考察。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;国外面试&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于国外面试的准备，大家可以看我之前写的自己的备考经历：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 &lt;a href=&quot;https://mp.weixin.qq.com/s/B9ttml8KX7kn7K1mvbRbng&quot;&gt;从小白到 6 个 offer，我究竟是怎么刷题的？&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时推荐普利斯顿老爷爷的算法课，B 站也有搬运版：&lt;code&gt;https://www.bilibili.com/video/av50599771/&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喏，就是这本书的作者，斯坦福的 PhD。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxznvqh5j30ka08xwf8.jpg&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;国内面试&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对国内的面试，我建议从《剑指 offer》这本书开始学习，然后陆续到牛客网或者 Leetcode 开始你的刷题之旅。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzk3n6vj30k907qjrx.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这本书的作者通过 50 多道算法题作为案例，像我们讲解了面试官考察的思路和一些基本数据结构算法的运用，读这本书我们会感觉是一个资深面试官在对我循循善诱，指出我们常见的错误和学习的方向。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷完这本书之后，就可以在 Leetcode 上继续找各类型的题目进行学习，我个人感觉一般对于面试来说，如果能把两百道中等题目刷的比较熟练是足以找到一份不错的工作了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;各种算法和数据结构我也写过不少了，在我的 Github 上都有分类汇总，大家可以自行取用：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的 Github：&lt;code&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/code&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. 设计模式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计模式可以说是写出高质量代码的关键。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在入职前快速学习了设计模式，入职后看代码就顺畅很多，很多设计如果你不知道这种模式就不能理解为什么要这样做。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得学习设计模式的是一个培养自己“审美”能力的过程，和画作、音乐不同，计算机的世界审美标准比较统一，那么我们首先需要知道游戏规则，然后才能打怪升级。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐书籍《设计模式》：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzsm8bhj30jk0azwfk.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一遍是不够的，也不需要一遍追求完全看懂。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一年里，我反复读这本书，遇到不同的问题时去看，随着代码量的积累，对设计模式的理解也会不同。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时因为 code review 时会有同事给出意见，这样更能促进我的进步。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以对于还没有工作的同学，我不建议花大量时间在这上面，因为没有人给你反馈，可能效果有限，而且这项内功是需要我们终身修炼的，不必急于一时。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 操作系统&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，我们已经学习了 Linux 操作系统，学习了一门语言和通用框架并且做了一个小项目，学习了一种常见的关系型数据库和非关系型数据库，算法和数据结构也过关了，拿 offer 应该没问题了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么后端开发还需要我们学习计算机哪些知识呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐大名鼎鼎的 CSAPP：&lt;em&gt;Computer Systems: A Programmer's Perspective&lt;/em&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzn1jzgj30k608vt9l.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这本书我在很久之前的视频里就推荐过了，它把计算机底层原理讲解的非常透彻，同时 CMU 也有配套的课程：&lt;code&gt;http://csapp.cs.cmu.edu/3e/courses.html&lt;/code&gt; ，重要性不言而喻。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，书很厚，很难啃，小齐给你划重点章节：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;1，2，3，6，7，8，9 章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读不下来？加入自习室，我们一起打卡！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那理解了计算机系统有什么用呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很难说具体有什么运用，但其实却是无处不在，比如工作中的性能优化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把开发当作修炼一门功夫这些方面的内容就像是内功，只有内功修炼扎实了，最后开发才能更加稳固，做出来的项目才是可靠的。于我们个人而言，才能走得更远。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 计算机网络&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试还喜欢考察什么内容呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如面试常常会问一道经典面试题：**从输入一个 URL 到出现页面的过程发生了什么？**如果你学过计算机网络就会对这个问题起码有一个大概的认识。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个问题有什么用呢？比如当你的访问 web 页面出现了“白页“（web 页面一片空白）这种故障，你会怎么排查？如果你只是着眼于自己的代码和服务端，不清楚整个请求链路发生了什么，遇到一些稍微复杂的故障你就束手无策了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是不是计算机科班学生，我都强烈建议把计算机网络学好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果更加“功利“一点，我觉得直接去搜相关的”面经“来看，看看什么问题是最常问的，把相关板块的知识弄懂熟透，形成自己的回答条理，看看自己能不能清晰的回答。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;TCP 三次握手说一下？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为什么要三次握手呢？两次、四次不行吗？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;HTTP 协议哪一层？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;说一下 URL 到出现页面的整个过程？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐书籍：《计算机网络：自顶向下》&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzp1tyuj30k8095gmi.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐课程：斯坦福大学 CS 144 计算机网络&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B 站链接：&lt;code&gt;https://www.bilibili.com/video/av96841516/&lt;/code&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. 计算机发展史&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一点呢，是我自己感兴趣的，顺便推荐给大家。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机是一门非常非常有意思的学科，很好玩的学科，从最早的图灵机、到如今的台式机、笔记本电脑，以及我最近玩的树莓派，都是非常非常有意思的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些东西是为了激发我的学习热情，保持自己的好奇心的一种方式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐视频：Crash Course Computer Science - 翻译叫“计算机速成课”，但并非那种“速成”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B 站中英文版本：&lt;code&gt;https://www.bilibili.com/video/av21376839/&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字幕组的 Github: &lt;code&gt;https://github.com/1c7/Crash-Course-Computer-Science-Chinese&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这门课我真是相见恨晚，每一集只有 10-12 分钟，一共 40 集，主讲人非常激情澎湃，你能够隔着屏幕感受到她对计算机科学的热情，对我影响很大。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gldxzj5xxij313x0e00wl.jpg&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;三、踏入江湖&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能做一个相对不错的项目，对各类面经知识能回答的七八分，算法题做了 200 道，我建议可以开始面试了，那么就真正踏入了江湖。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;踏入江湖之后，我们仍需不断反复修炼自己的“外功”和“内功”，不断提高自己的功力，哪怕是同一本书，在工作的不同阶段读，一定会有不同的体会。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，以上这些还只是职场硬实力，而能在江湖混的风生水起，一定也离不开过人的软实力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是软实力一定是建立在硬实力之上的，没有雪中送炭的作用，只可以锦上添花。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，如果硬实力强到一定程度，是不需要软实力的，但不适合 99% 的人。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文中提到的所有书籍，我都整理好放在后台了～&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取方式：&lt;strong&gt;先在右下角点个在看&lt;/strong&gt;，然后回复【05】。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路上阳光正好，愿每一位踏入江湖的少年都能潇潇洒洒，仗剑走天涯！&lt;/p&gt;
</description>
<pubDate>Wed, 23 Dec 2020 00:07:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>上周的投票，大家最关心的还是提高技术，那我们今天就来聊聊这个话题。 之前主要分享的多是算法和数据结构方面（年后继续），因为我认为算法和数据结构是程序员最最最重要的内功，但是并不是唯一。 我自己作为一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/14176574.html</dc:identifier>
</item>
<item>
<title>如何从零开发一个NuGet软件包？ - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/14175019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/14175019.html</guid>
<description>&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;首发地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/14175019.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yilezhu/p/14175019.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想目前每个.net开发人员都应该知道&lt;a href=&quot;https://nuget.org/&quot; target=&quot;_blank&quot;&gt;nuget.org&lt;/a&gt;和NuGet软件包吧。但是，您是否曾经尝试并创建过一个nuget包呢？Nuget软件包比较容易引入到类库中。因此，可以使用NuGet软件包管理器将nuget软件包添加到任何项目中。&lt;/p&gt;
&lt;h3 id=&quot;nuget包的剖析&quot;&gt;Nuget包的剖析&lt;/h3&gt;
&lt;p&gt;Nuget软件包不仅是&lt;strong&gt;dll&lt;/strong&gt;文件。NuGet包是可移植的，它包含您要放入.Net项目中的所有内容。您可以在其中放置txt文件或png文件。这就是为什么我们称它们为“包裹”。您可以打包一些开发文件，并将它们以.nupkg格式在项目之间移动。&lt;br/&gt;我刚刚解压缩了InputKit的nuget包，您可以在下图中看到nupkg文件的树状视图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202012/1377250-20201222201312736-1272312599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，只需查看其中的文件夹和文件。&lt;br/&gt;&lt;strong&gt;icon.png：&lt;/strong&gt;&lt;br/&gt;这是您的NuGet包的图标文件。现在已将其嵌入.nupkg中，但在早期版本的NuGet中只能定义为url。&lt;br/&gt;&lt;strong&gt;.nuspec&lt;/strong&gt;&lt;br/&gt;nuspec是关于nuget包的元数据文件。在早期版本中，它曾经用于打包nuget包。但是在新的dotnet CLI中，此文件是由roslyn编译器从您的.csproj文件生成的。它包括软件包的目标框架，名称，许可证，图标，标签，与其他包的依赖关系以及其中描述的要放置到添加的项目中的静态文件。&lt;br/&gt;&lt;strong&gt;[Content_Types] .xml：&lt;/strong&gt;&lt;br/&gt;这是一个元数据文件，提供了程序包中包含的每个文件扩展名。&lt;br/&gt;&lt;strong&gt;lib：&lt;/strong&gt;&lt;br/&gt;软件包的主文件夹。此文件夹包括您的构建输出。换句话说，它在构建之后包含了bin文件夹。所以您可以看到不同目标框架的文件夹与项目输出相同。例如，如果您的.csproj文件是多目标的，您可以像我一样看到每个目标框架的文件夹。&lt;br/&gt;&lt;strong&gt;package：&lt;/strong&gt;&lt;br/&gt;此文件夹包含有关您的包的更多元数据文件。此数据与您在nuget软件包列表中看到的数据相同：“创建者”，“描述”，“标识符”，“版本”和“关键字”。&lt;br/&gt;&lt;strong&gt;_rels / .rels：&lt;/strong&gt;&lt;br/&gt;这是xml格式的文件扩展名，由Microsoft创建和使用。您可以从&lt;a href=&quot;https://fileinfo.com/extension/rels&quot; target=&quot;_blank&quot;&gt;此处&lt;/a&gt;查看有关.rels格式的更多信息。它主要用于Microsoft Office。&lt;/p&gt;
&lt;h3 id=&quot;创建你的第一个库&quot;&gt;创建你的第一个库&lt;/h3&gt;
&lt;p&gt;每一个开发者都应该知道类库。它们很难移动或用于不同的项目。因为它们的输出是&lt;strong&gt;dll&lt;/strong&gt;文件。在本文中，我不会谈论如何构建库。我将展示如何将它们转换为可移植的nuget包。因此，让我们从第一步开始。&lt;br/&gt;&lt;strong&gt;1-选择目标框架&lt;/strong&gt;&lt;br/&gt;选择目标框架是非常重要！只需计划你的项目并定义依赖项即可。如果您的依赖项需要.net core（如实体框架）或以.Net core为目标的对象，只需将目标框架选为“.Net core”。但如果不是，请始终尝试在“.Net Standard”上构建库。顺便说一句，你可以建立一个多目标项目。您可以&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/create-packages/multiple-target-frameworks-project-file&quot; target=&quot;_blank&quot;&gt;从此处&lt;/a&gt;阅读有关&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/create-packages/multiple-target-frameworks-project-file&quot; target=&quot;_blank&quot;&gt;多目标项目的&lt;/a&gt;更多信息。&lt;br/&gt;&lt;strong&gt;2-填充元数据&lt;/strong&gt;&lt;br/&gt;在我们所处的时代，MetaData是最重要的事情。MetaData可以更轻松地找到您的包裹并最好地描述其作用。因此，请正确填写您的元数据。在Visual Studio中创建类库后，只需&lt;strong&gt;右键单击&lt;/strong&gt;并转到&lt;strong&gt;属性&lt;/strong&gt;。您可以在“&lt;strong&gt;打包”&lt;/strong&gt;标签下看到所有可以填写的字段。&lt;br/&gt;如果您的环境不是Visual Studio，则可以直接修改.csproj文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PackageId&amp;gt;My.Package&amp;lt;/PackageId&amp;gt;
    &amp;lt;Version&amp;gt;1.0.1&amp;lt;/Version&amp;gt;
    &amp;lt;Authors&amp;gt;enisn&amp;lt;/Authors&amp;gt;
    &amp;lt;Company&amp;gt;enisn&amp;lt;/Company&amp;gt;
    &amp;lt;Product&amp;gt;My Package&amp;lt;/Product&amp;gt;
    &amp;lt;Description&amp;gt;This is my packages description.&amp;lt;/Description&amp;gt;
    &amp;lt;Copyright&amp;gt;All rights reserved&amp;lt;/Copyright&amp;gt;
    &amp;lt;PackageLicenseExpression&amp;gt;MIT&amp;lt;/PackageLicenseExpression&amp;gt;
    &amp;lt;PackageProjectUrl&amp;gt;https://github.com/enisn/MyPackage&amp;lt;/PackageProjectUrl&amp;gt;
    &amp;lt;RepositoryUrl&amp;gt;https://github.com/enisn/MyPackage&amp;lt;/RepositoryUrl&amp;gt;
    &amp;lt;PackageTags&amp;gt;my,awesome,package&amp;lt;/PackageTags&amp;gt;
    &amp;lt;PackageReleaseNotes&amp;gt;Hot fixes&amp;lt;/PackageReleaseNotes&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3-打包！&lt;/strong&gt;&lt;br/&gt;这就是奇迹发生的地方！准备好你的代码，&lt;strong&gt;右键单击&lt;/strong&gt;您的项目，然后单击“&lt;strong&gt;打包”&lt;/strong&gt;按钮。您的nupkg文件将在您项目的&lt;strong&gt;bin&lt;/strong&gt;文件夹中等待着您。&lt;br/&gt;如果您的开发环境不是Visual Studio，则可以使用命令提示符来执行此操作，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;dotnet pack My.Package.csproj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4-与全世界分享！&lt;/strong&gt;&lt;br/&gt;转到&lt;a href=&quot;https://nuget.org/&quot; target=&quot;_blank&quot;&gt;nuget.org&lt;/a&gt;并登录到你的帐户。然后导航到“&lt;strong&gt;发布”&lt;/strong&gt;选项卡，并将您的.nupkg文件拖放到该页面中。填写有关包裹的信息字段并提交。仅此而已！这是在nuget.org上发布软件包的最简单方法。&lt;br/&gt;&lt;strong&gt;使用命令行工具&lt;/strong&gt;&lt;br/&gt;但是您也可以在命令行下执行此操作。让我们来看看这种方式。&lt;br/&gt;首先，您需要一个Api-Key与nuget API通信。转到nuget.org上的个人资料，然后找到“ &lt;strong&gt;API密钥”&lt;/strong&gt;部分，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1377250/202012/1377250-20201222201349109-85448723.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个API密钥并保存它。您将无法再次看到它。因此，您需要保存它。&lt;br/&gt;现在，从打包开始，然后您可以通过CLI进行推送。&lt;br/&gt;&lt;code&gt;dotnet pack --configuration Release -o .packages/&lt;/code&gt;&lt;br/&gt;这意味着在发布模式下构建项目，并将输出文件放置到“ .packages”文件夹中。因此，我们可以轻松地从.pacakges文件夹中找到输出。因此，您的nupkg文件已准备好推送。使用以下命令将软件包推送到nuget.org或您自定义的源：&lt;br/&gt;&lt;code&gt;dotnet nuget push .\.packages\My.Pacakge.1.0.1.nupkg --source [https://api.nuget.org/v3/index.json](https://api.nuget.org/v3/index.json) --api-key YOUR_API_KEY --skip-duplicate&lt;/code&gt;&lt;br/&gt;我使用了 &lt;code&gt;skip-duplicate&lt;/code&gt; 参数，因为如果要配置 &lt;code&gt;CI&lt;/code&gt; ，则可以多次推送相同版本的软件包，而如果要推送已经存在的版本，则会出现错误，并且 &lt;code&gt;CI-CD&lt;/code&gt; 进程将失败。因此，使用 &lt;code&gt;skip-duplicate&lt;/code&gt; 参数忽略已存在的版本推送，并成功完成操作。&lt;br/&gt;感谢您的阅读，我们下篇文章见！&lt;br/&gt;翻译自：&lt;a href=&quot;https://enisn.medium.com/how-to-develop-a-nuget-package-d37400d9e1d3&quot; target=&quot;_blank&quot;&gt;https://enisn.medium.com/how-to-develop-a-nuget-package-d37400d9e1d3&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Dec 2020 23:37:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 首发地址：https://www.cnblogs.com/yilezhu/p/14175019.html 我想目前每个.net开发人员都应该知道nuget.org和NuGet软件包吧。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/14175019.html</dc:identifier>
</item>
<item>
<title>跨域配置与两种解决方法 - 菜鸟全栈</title>
<link>http://www.cnblogs.com/dtyy/p/14176560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dtyy/p/14176560.html</guid>
<description>&lt;p&gt;跨域问题出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;strong&gt;同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。&lt;/p&gt;
&lt;h2 id=&quot;1-两种跨域解决方法&quot;&gt;1 两种跨域解决方法&lt;/h2&gt;
&lt;p&gt;当web项目仅部署在Tomcat等服务器时，我们可以添加Java跨域配置；假设项目采用了Nginx，跨域任务可以交给Nginx。&lt;/p&gt;
&lt;h3 id=&quot;11-nginx跨域配置&quot;&gt;1.1 Nginx跨域配置&lt;/h3&gt;
&lt;p&gt;完整的Nginx跨域配置示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;server {
    listen 3002;
    server_name localhost;

    location /hello {
    
        # 指定允许跨域的方法，*代表所有，也可设置具体方法。
        add_header Access-Control-Allow-Methods $http_access_control_request_method;
    
        # 预检命令的缓存，如果不缓存每次会发送两次请求
        add_header Access-Control-Max-Age 3600;
    
        # 带cookie请求需要加上这个字段，并设置为true
        add_header Access-Control-Allow-Credentials true;
    
        # 表示允许这个域跨域调用（客户端发送请求的域名和端口） 
        # $http_origin动态获取请求客户端请求的域 不用*的原因是带cookie的请求不支持*号
        add_header Access-Control-Allow-Origin $http_origin;
    
        # 表示请求头的字段 动态获取
        add_header Access-Control-Allow-Headers $http_access_control_request_headers;
    
        # OPTIONS预检命令，预检命令通过时才发送请求
        # 检查请求的类型是不是预检命令
        if ($request_method = OPTIONS){
            return 200;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-springboot-跨域配置注册&quot;&gt;1.2 SpringBoot 跨域配置注册&lt;/h3&gt;
&lt;p&gt;原理与nignx相同，修改请求信息。 本类作为一个bean装载到spring容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        // Cors配置
        CorsConfiguration config = new CorsConfiguration();
        // 1. 设置请求域名
        config.addAllowedOrigin(&quot;http://localhost:8080&quot;); // 本地ip
        config.addAllowedOrigin(&quot;http://192.168.233.130:8080&quot;); // 虚拟机
        config.addAllowedOrigin(&quot;http://49.232.170.99&quot;); // 外网ip
        config.addAllowedOrigin(&quot;*&quot;); // 任意

        // 2. 设置允许的header
        config.addAllowedHeader(&quot;*&quot;);

        // 3. 设置允许请求的方法
        config.addAllowedMethod(&quot;*&quot;);

        // 4. 设置是否发送cookie
        config.setAllowCredentials(true);

        // 为URL添加路由
        UrlBasedCorsConfigurationSource corsSource = new UrlBasedCorsConfigurationSource();
        corsSource.registerCorsConfiguration(&quot;/**&quot;, config);

        return new CorsFilter(corsSource);
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 22 Dec 2020 23:33:00 +0000</pubDate>
<dc:creator>菜鸟全栈</dc:creator>
<og:description>跨域问题出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dtyy/p/14176560.html</dc:identifier>
</item>
<item>
<title>52条SQL语句性能优化策略汇总 - Brian_Huang</title>
<link>http://www.cnblogs.com/hlkawa/p/14176545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hlkawa/p/14176545.html</guid>
<description>&lt;h3&gt;1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。&lt;/h3&gt;

&lt;h3&gt;2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。&lt;/h3&gt;

&lt;h3&gt;3、应尽量避免在where子句中使*用!=或&amp;lt;&amp;gt;操作符，MySQL只有对以下操作符才使用索引：&amp;lt;，&amp;lt;=，=，&amp;gt;，&amp;gt;=，BETWEEN，IN，以及某些时候的LIKE。&lt;/h3&gt;

&lt;h3&gt;4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。&lt;/h3&gt;

&lt;h3&gt;5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。&lt;/h3&gt;

&lt;h3&gt;6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。&lt;/h3&gt;

&lt;h3&gt;7、如果在where子句中使用参数，也会导致全表扫描。&lt;/h3&gt;

&lt;h3&gt;8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。&lt;/h3&gt;

&lt;h3&gt;9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。&lt;/h3&gt;

&lt;h3&gt;10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。&lt;/h3&gt;

&lt;h3&gt;11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。&lt;/h3&gt;

&lt;h3&gt;12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。&lt;/h3&gt;

&lt;h3&gt;13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/h3&gt;

&lt;h3&gt;14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。&lt;/h3&gt;

&lt;h3&gt;15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。&lt;/h3&gt;

&lt;h3&gt;16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。&lt;/h3&gt;

&lt;h3&gt;17、使用“临时表”暂存中间结果 ：简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。&lt;/h3&gt;

&lt;h3&gt;18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。&lt;/h3&gt;
&lt;p&gt;使用nolock有3条原则：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1.&lt;span&gt;查询的结果用于“插、删、改”的不能加nolock；

&lt;/span&gt;2&lt;span&gt;.查询的表属于频繁发生页分裂的，慎用nolock ；

&lt;/span&gt;3.使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;19、常见的简化规则如下：&lt;/h3&gt;
&lt;p&gt;不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。 &lt;/p&gt;
&lt;h3&gt;20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。&lt;/h3&gt;

&lt;h3&gt;21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。&lt;/h3&gt;

&lt;h3&gt;22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。&lt;/h3&gt;

&lt;h3&gt;23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。&lt;/h3&gt;
&lt;p&gt;存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。&lt;/p&gt;
&lt;h3&gt;24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&amp;lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。&lt;/h3&gt;

&lt;h3&gt;25、查询的关联同写的顺序 ： &lt;/h3&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） &lt;/p&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） &lt;/p&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）&lt;/p&gt;
&lt;h3&gt;26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。&lt;/h3&gt;

&lt;h3&gt;27、尽量使用“&amp;gt;=”，不要使用“&amp;gt;”。&lt;/h3&gt;

&lt;h3&gt;28、索引的使用规范：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；

&lt;/span&gt;2&lt;span&gt;.尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；

&lt;/span&gt;3&lt;span&gt;.避免对大表查询时进行table scan，必要时考虑新建索引；

&lt;/span&gt;4&lt;span&gt;.在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；

&lt;/span&gt;5.要注意索引的维护，周期性重建索引，重新编译存储过程。　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： &lt;/h3&gt;
&lt;p&gt;SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒)  &lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE amount/30&amp;lt; 1000 （11秒）  &lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） &lt;/p&gt;
&lt;p&gt;分析：  &lt;/p&gt;
&lt;p&gt;WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。 &lt;/p&gt;
&lt;p&gt;如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： &lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE card_no like ‘5378%’ （&amp;lt; 1秒） &lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE amount&amp;lt; 1000*30 （&amp;lt; 1秒） &lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE date= ‘1999/12/01’ （&amp;lt; 1秒）&lt;/p&gt;
&lt;h3&gt;30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。&lt;/h3&gt;

&lt;h3&gt;31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。&lt;/h3&gt;
&lt;p&gt;例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。&lt;/p&gt;
&lt;h3&gt;32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： &lt;/h3&gt;
&lt;p&gt;Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。&lt;/p&gt;
&lt;p&gt;如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。&lt;/p&gt;
&lt;h3&gt;33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 &lt;/h3&gt;
&lt;p&gt;低效：&lt;/p&gt;
&lt;p&gt;SELECT JOB , AVG(SAL) &lt;/p&gt;
&lt;p&gt;FROM EMP &lt;/p&gt;
&lt;p&gt;GROUP BY JOB &lt;/p&gt;
&lt;p&gt;HAVING JOB =’PRESIDENT’ &lt;/p&gt;
&lt;p&gt;OR JOB =’MANAGER’ &lt;/p&gt;
&lt;p&gt;高效: &lt;/p&gt;
&lt;p&gt;SELECT JOB , AVG(SAL) &lt;/p&gt;
&lt;p&gt;FROM EMP &lt;/p&gt;
&lt;p&gt;WHERE JOB =’PRESIDENT’ &lt;/p&gt;
&lt;p&gt;OR JOB =’MANAGER’ &lt;/p&gt;
&lt;p&gt;GROUP BY JOB&lt;/p&gt;
&lt;h3&gt;34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。&lt;/h3&gt;

&lt;h3&gt;35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。&lt;/h3&gt;

&lt;h3&gt;36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。&lt;/h3&gt;

&lt;h3&gt;37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。&lt;/h3&gt;

&lt;h3&gt;38、最好不要使用触发器：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；

&lt;/span&gt;2&lt;span&gt;.如果能够使用约束实现的，尽量不要使用触发器；

&lt;/span&gt;3&lt;span&gt;.不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；

&lt;/span&gt;4.不要在触发器中使用事务型代码。 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;39、索引创建规则： &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.表的主键、外键必须有索引； 

&lt;/span&gt;2&lt;span&gt;.数据量超过300的表应该有索引； 

&lt;/span&gt;3&lt;span&gt;.经常与其他表进行连接的表，在连接字段上应该建立索引； 

&lt;/span&gt;4&lt;span&gt;.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； 

&lt;/span&gt;5&lt;span&gt;.索引应该建在选择性高的字段上； 

&lt;/span&gt;6&lt;span&gt;.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 

&lt;/span&gt;7&lt;span&gt;.复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； 

&lt;/span&gt;8&lt;span&gt;.正确选择复合索引中的主列字段，一般是选择性较好的字段； 

&lt;/span&gt;9&lt;span&gt;.复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； 

&lt;/span&gt;10&lt;span&gt;.如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； 

&lt;/span&gt;11&lt;span&gt;.如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； 

&lt;/span&gt;12&lt;span&gt;.如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； 

&lt;/span&gt;13&lt;span&gt;.频繁进行数据操作的表，不要建立太多的索引； 

&lt;/span&gt;14&lt;span&gt;.删除无用的索引，避免对执行计划造成负面影响； 

&lt;/span&gt;15&lt;span&gt;.表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 

&lt;/span&gt;16.尽量不要对数据库中某个含有大量重复的值的字段建立索引。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;40、MySQL查询优化总结：&lt;/h3&gt;
&lt;p&gt;使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。&lt;/p&gt;
&lt;p&gt;久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。&lt;/p&gt;
&lt;p&gt;有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 &lt;/p&gt;
&lt;p&gt;为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。&lt;/p&gt;
&lt;p&gt;基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。&lt;/p&gt;
&lt;h3&gt;41、MySQL备份过程：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.从二级复制服务器上进行备份；

&lt;/span&gt;2&lt;span&gt;.在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；

&lt;/span&gt;3&lt;span&gt;.彻底停止MySQL，从数据库文件进行备份；

&lt;/span&gt;4&lt;span&gt;.如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；

&lt;/span&gt;5&lt;span&gt;.不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；

&lt;/span&gt;6&lt;span&gt;.为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 

&lt;/span&gt;7&lt;span&gt;.当使用mysqldump时请使用–opt；

&lt;/span&gt;8&lt;span&gt;.在备份之前检查和优化表；

&lt;/span&gt;9&lt;span&gt;.为了更快的进行导入，在导入时临时禁用外键约束。；

&lt;/span&gt;10&lt;span&gt;.为了更快的进行导入，在导入时临时禁用唯一性检测；

&lt;/span&gt;11&lt;span&gt;.在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；

&lt;/span&gt;12&lt;span&gt;.通过自动调度脚本监控复制实例的错误和延迟；

&lt;/span&gt;13.定期执行备份。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。&lt;/h3&gt;

&lt;h3&gt;43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。&lt;/h3&gt;

&lt;h3&gt;而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。&lt;/h3&gt;

&lt;h3&gt;44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。&lt;/h3&gt;

&lt;h3&gt;45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。&lt;/h3&gt;

&lt;h3&gt;46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。&lt;/h3&gt;

&lt;h3&gt;47、EXPLAIN SELECT查询用来跟踪查看效果： &lt;/h3&gt;
&lt;p&gt;使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。 &lt;/p&gt;
&lt;h3&gt;48、当只要一行数据时使用LIMIT 1 ： &lt;/h3&gt;
&lt;p&gt;当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。&lt;/p&gt;
&lt;p&gt;在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。 &lt;/p&gt;
&lt;h3&gt;49、选择表合适存储引擎： &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 

InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。

对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，&lt;br/&gt;导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;50、优化表的数据类型，选择合适的数据类型：  &lt;/h3&gt;
&lt;p&gt;原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 &lt;/p&gt;
&lt;p&gt;例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) &lt;/p&gt;
&lt;p&gt;比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 &lt;/p&gt;
&lt;p&gt;MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 &lt;/p&gt;
&lt;p&gt;因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。&lt;/p&gt;
&lt;p&gt;例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。 &lt;/p&gt;
&lt;p&gt;同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 &lt;/p&gt;
&lt;p&gt;对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。&lt;/p&gt;
&lt;h3&gt;51、字符串数据类型：char，varchar，text选择区别。&lt;/h3&gt;

&lt;h3&gt;52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 &lt;/h3&gt;
</description>
<pubDate>Tue, 22 Dec 2020 22:47:00 +0000</pubDate>
<dc:creator>Brian_Huang</dc:creator>
<og:description>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。 2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hlkawa/p/14176545.html</dc:identifier>
</item>
<item>
<title>Erlang那些事儿第2回之我是模块(module),一文件一模块 - snowcicada</title>
<link>http://www.cnblogs.com/snowcicada/p/14166014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowcicada/p/14166014.html</guid>
<description>&lt;p&gt;　　前几篇文章会写得比较基础，但是既然要写一系列的文章，还是得从基础开始写。我刚学Erlang碰到最大的问题是，想网上搜索下语法，结果却是寥寥无几，而且介绍得不是很系统，对我了解一些细节是有影响的，正好我身边有好多Erlang大神，遇到问题可以随时找他们请教，经过自己消化后，分享到这里，希望可以帮助到一些人。这几天偶尔逛一逛博客园，发现这里真是程序员的知识海洋，随便翻两页，就有很多大佬在编写Java并发、Docker镜像、K8S等技术文章，文章的质量我觉得都可以出书了。虽然我之前经常在CSDN，但是没看过这么专业的，看来程序大佬都在博客园。&lt;/p&gt;&lt;p&gt;　　开始聊正题吧，今天聊到是模块（Module），模块就是存放代码的地方。&lt;/p&gt;&lt;p&gt;　　C语言有.h头文件和.c源文件，同理，Erlang代码也有这2个玩意儿，只不过后缀有点区别，Erlang的头文件后缀为.hrl，源文件的后缀为.erl。每个Erlang源文件都是一个模块，模块名就是文件名称，每个.erl模块编译后会产生一个.beam文件，就好比.java类编译后会产生一个.class文件。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;147.10638461538&quot;&gt;
&lt;p&gt;　　创建一个文件hello_world.erl，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(hello_world).&lt;br/&gt;&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([hello/0&lt;span&gt;]).

hello() &lt;/span&gt;-&amp;gt;
  &quot;Hello Erlang&quot;&lt;span&gt;.

world() &lt;/span&gt;-&amp;gt;
  &quot;Hello World&quot;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个模块非常简单，只有2个函数，分别是hello和world。这里有几个概念，module（模块）、export（函数导出列表）、函数。&lt;/p&gt;
&lt;p&gt;　　export里面只有hello，说明其它模块只能访问到hello函数，无法访问到world函数。hello类似于Java声明为public公有函数，world类似于private私有函数。&lt;/p&gt;
&lt;p&gt;　　现在来编译下hello_world模块，并分别执行下2个函数看下返回信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Erlang/OTP 23 [erts-11.1.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1&lt;span&gt;] [hipe] [dtrace]

Eshell V11.&lt;/span&gt;1.3  (abort with ^&lt;span&gt;G)
&lt;/span&gt;1&amp;gt;&lt;span&gt; ls(). %% ls()函数在终端显示当前目录下的所有文件，输入help().可查看所有命令
hello_world.erl
ok
&lt;/span&gt;2&amp;gt;&lt;span&gt; c(hello_world). %% c()函数在终端编译hello_world模块，注意不能加.erl后缀
hello_world.erl:&lt;/span&gt;18: Warning: function world/0&lt;span&gt; is unused  %% 这里是个警告，提醒world函数没有导出
{ok,hello_world}
&lt;/span&gt;3&amp;gt;&lt;span&gt; m(hello_world). %% m()函数在终端显示hello_world模块信息，可以查看该模块的基本信息和导出函数列表
Module: hello_world
MD5: f7866776c11b9cfc904dc569bafe7995
Compiled: No compile time info available
Object file: &lt;/span&gt;/Users/snowcicada/code/erlang-story/story002/&lt;span&gt;hello_world.beam
Compiler options:  []
Exports:
         hello&lt;/span&gt;/0&lt;span&gt;
         module_info&lt;/span&gt;/0&lt;span&gt;
         module_info&lt;/span&gt;/1&lt;span&gt;
ok
&lt;/span&gt;4&amp;gt;&lt;span&gt; hello_world:hello(). %% M:F()是Erlang的基本调用方式，M表示模块名，F表示函数名
&lt;/span&gt;&quot;Hello Erlang&quot; %% 这里就是hello函数的返回结果
5&amp;gt;&lt;span&gt; hello_world:world(). %% 由于world函数没有导出，没有加入export导出列表，所以调用没导出的函数，会得到一个错误
&lt;/span&gt;** exception error: undefined function hello_world:world/0
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;知识点2：编写一个有头文件的Hello World模块&lt;/h2&gt;
&lt;p&gt;　　创建一个文件hello_world.hrl，就一行代码，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-define(TEXT, &quot;Hello World&quot;).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用define声明了一个宏TEXT，这里的宏跟C语言的宏类似，语法差不多。&lt;/p&gt;
&lt;p&gt;　　修改hello_world.erl，引用下头文件，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(hello_world).&lt;/span&gt;-include(&quot;hello_world.hrl&quot;&lt;span&gt;).

&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([hello/0, world/0&lt;span&gt;]).

hello() &lt;/span&gt;-&amp;gt;
  &quot;Hello Erlang&quot;&lt;span&gt;.

world() &lt;/span&gt;-&amp;gt;
  ?TEXT. %% 注意这行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Erlang要使用宏，需要在宏的前面加一个问号？，不加编译不过。&lt;/p&gt;
&lt;p&gt;　　重新编译下hello_world模块，执行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Erlang/OTP 23 [erts-11.1.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1&lt;span&gt;] [hipe] [dtrace]

Eshell V11.&lt;/span&gt;1.3  (abort with ^&lt;span&gt;G)
&lt;/span&gt;1&amp;gt;&lt;span&gt; ls().
hello_world.beam     hello_world.erl      hello_world.hrl

ok
&lt;/span&gt;2&amp;gt;&lt;span&gt; c(hello_world).
{ok,hello_world}
&lt;/span&gt;3&amp;gt;&lt;span&gt; m(hello_world).
Module: hello_world
MD5: ceb4d19017c728b4f338ba92ea7bc0cb
Compiled: No compile time info available
Object file: &lt;/span&gt;/Users/guozs/code/erlang-story/story002/&lt;span&gt;hello_world.beam
Compiler options:  []
Exports:
         hello&lt;/span&gt;/0&lt;span&gt;
         module_info&lt;/span&gt;/0&lt;span&gt;
         module_info&lt;/span&gt;/1&lt;span&gt;
         world&lt;/span&gt;/0&lt;span&gt;
ok
&lt;/span&gt;4&amp;gt;&lt;span&gt; hello_world:world().
&lt;/span&gt;&quot;Hello World&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;知识点3：模块之间可以相互调用，但是不能有循环调用&lt;/h2&gt;
&lt;p&gt;　　Erlang的模块可以相互调用，比如在其他语言经常会出现A包含B，B包含A的问题，但是在Erlang这里，只要避免2个模块的函数不互相循环调用，就不会有问题。什么意思呢？假设A模块有一个函数a，B模块有一个函数b，A:a调用了B:b，B:b调用了A:a，那么这样就已经循环调用了，这是不允许出现的。&lt;/p&gt;
&lt;p&gt;　　创建一个文件a.erl，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(a).

&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([a/0&lt;span&gt;]).

a() &lt;/span&gt;-&amp;gt;&lt;span&gt;
  b:b().&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建一个文件b.erl，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(b).&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([b/0&lt;span&gt;]).

b() &lt;/span&gt;-&amp;gt;&lt;span&gt;
  a:a().&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Erlang/OTP 23 [erts-11.1.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1&lt;span&gt;] [hipe] [dtrace]

Eshell V11.&lt;/span&gt;1.3  (abort with ^&lt;span&gt;G)
&lt;/span&gt;1&amp;gt;&lt;span&gt; c(a).
{ok,a}
&lt;/span&gt;2&amp;gt;&lt;span&gt; c(b).
{ok,b}
&lt;/span&gt;3&amp;gt;&lt;span&gt; a:a(). %% 这里卡死了，只能执行Ctrl+C强制退出

BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo
       (l)oaded (v)ersion (k)ill (D)b&lt;/span&gt;-tables (d)istribution
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　程序卡死了，只能强制退出，所以模块虽然可以互相引用对方的函数，但是要注意避免循环调用问题。&lt;/p&gt;
&lt;h2&gt;知识点4：引入模块函数&lt;/h2&gt;
&lt;p&gt;　　创建一个文件calc.erl，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(calc).

&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([add/2&lt;span&gt;]).

add(A, B) &lt;/span&gt;-&amp;gt;&lt;span&gt;
  A &lt;/span&gt;+ B.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改hello_world.erl，引入calc模块的函数，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(hello_world).

&lt;/span&gt;-include(&quot;hello_world.hrl&quot;&lt;span&gt;).

&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;
-&lt;span&gt;export&lt;/span&gt;([hello/0, world/0, mod_add/2&lt;span&gt;]).

&lt;/span&gt;-import(calc, [add/2&lt;span&gt;]). %% 这里引入calc模块

hello() &lt;/span&gt;-&amp;gt;
  &quot;Hello Erlang&quot;&lt;span&gt;.

world() &lt;/span&gt;-&amp;gt;
  ?&lt;span&gt;TEXT.

mod_add(A, B) &lt;/span&gt;-&amp;gt;&lt;span&gt;
  add(A, B).&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一行import只能引入一个模块，至于要引入多少函数，可以灵活选择。&lt;/p&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Erlang/OTP 23 [erts-11.1.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1&lt;span&gt;] [hipe] [dtrace]

Eshell V11.&lt;/span&gt;1.3  (abort with ^&lt;span&gt;G)
&lt;/span&gt;1&amp;gt;&lt;span&gt; c(calc).
{ok,calc}
&lt;/span&gt;2&amp;gt;&lt;span&gt; c(hello_world).
{ok,hello_world}
&lt;/span&gt;3&amp;gt;&lt;span&gt; hello_world:mod %% 按Tab键可以智能提示
mod_add&lt;/span&gt;/2      module_info/0  module_info/1
3&amp;gt; hello_world:mod_add(1, 2&lt;span&gt;).
&lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;知识点5：导出所有函数(export_all)&lt;/h2&gt;
&lt;p&gt;　　首先声明，export_all要避免使用，因为会将所有的函数对外导出，会存在一些设计理念的问题。不使用export_all的好处有几个，&lt;/p&gt;
&lt;p&gt;　　1、安全性：比如当您重构模块时，您可以知道哪些功能可以安全地重命名，而不需要到外部查找依赖，万一修改了，导致其他模块调用失败也是有可能的；&lt;/p&gt;
&lt;p&gt;　　2、代码气味：编译时不会收到警告；&lt;/p&gt;
&lt;p&gt;　　3、清晰度：更容易看出在模块之外使用哪些功能。&lt;/p&gt;
&lt;p&gt;　　在函数顶部加入一行：-compile(export_all).，即可导出所有函数，但是编译时会收到一个警告。&lt;/p&gt;
&lt;p&gt;　　修改calc.erl，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;module&lt;/span&gt;&lt;span&gt;(calc).

&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;&lt;span&gt;
%%&lt;/span&gt;&lt;span&gt;-export([add/2]).&lt;/span&gt;
-&lt;span&gt;compile(export_all).

add(A, B) &lt;/span&gt;-&amp;gt;&lt;span&gt;
  A &lt;/span&gt;+ B.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Erlang/OTP 23 [erts-11.1.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1&lt;span&gt;] [hipe] [dtrace]

Eshell V11.&lt;/span&gt;1.3  (abort with ^&lt;span&gt;G)
&lt;/span&gt;1&amp;gt;&lt;span&gt; c(calc).
calc.erl:&lt;/span&gt;14: Warning: export_all flag enabled -&lt;span&gt; all functions will be exported %% 这里会有警告
{ok,calc}
2&lt;/span&gt;&amp;gt;&lt;span&gt; c(hello_world).
{ok,hello_world}
3&lt;/span&gt;&amp;gt; hello_world:mod_add(1,2&lt;span&gt;).
&lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模块的内容就先讲到这了，这一回只介绍模块本身，以后会经常编写代码，使用模块就是家常便饭了。&lt;/p&gt;
&lt;p&gt;　　本文使用的代码已上传Github：&lt;a href=&quot;https://github.com/snowcicada/erlang-story/tree/main/story002&quot; target=&quot;_blank&quot;&gt;https://github.com/snowcicada/erlang-story/tree/main/story002&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下一回将介绍函数（Function）的使用，且听下回分解。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1134020/202012/1134020-20201220221505023-39194680.png&quot; width=&quot;60&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Tue, 22 Dec 2020 16:51:00 +0000</pubDate>
<dc:creator>snowcicada</dc:creator>
<og:description>前几篇文章会写得比较基础，但是既然要写一系列的文章，还是得从基础开始写。我刚学Erlang碰到最大的问题是，想网上搜索下语法，结果却是寥寥无几，而且介绍得不是很系统，对我了解一些细节是有影响的，正好我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snowcicada/p/14166014.html</dc:identifier>
</item>
<item>
<title>Angular实战之使用NG-ZORRO创建一个企业级中后台框架（新手入门篇） - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/14170872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/14170872.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在之前的一篇文章已经介绍过了，公司正在使用NG-ZORRO组件库开发后台应用，并且详细的介绍了Angular开发环境的搭建和项目的创建。这篇文章就是为了让大家熟悉了解我们该如何在Angular项目中使用到NG-ZORRO UI组件库搭建后台管理框架。&lt;/p&gt;
&lt;h2&gt;NG-ZORRO介绍：&lt;/h2&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://ng.ant.design/docs/introduce/zh&quot; target=&quot;_blank&quot;&gt;https://ng.ant.design/docs/introduce/zh&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;ng-zorro-antd&lt;/code&gt; 是遵循 Ant Design 设计规范的 Angular UI 组件库，主要用于研发企业级中后台产品。全部代码开源并遵循 MIT 协议，任何企业、组织及个人均可免费使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;NG-ZORRO特性：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;提炼自企业级中后台产品的交互语言和视觉风格。&lt;/li&gt;
&lt;li&gt;开箱即用的高质量 Angular 组件库，与 Angular 保持同步升级。&lt;/li&gt;
&lt;li&gt;使用 TypeScript 构建，提供完整的类型定义文件。&lt;/li&gt;
&lt;li&gt;支持 OnPush 模式，性能卓越。&lt;/li&gt;
&lt;li&gt;数十个国际化语言支持。&lt;/li&gt;
&lt;li&gt;深入每个细节的主题定制能力。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;创建一个Angular项目：&lt;/h2&gt;
&lt;p&gt;angular环境配置参考：&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/14166192.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/14166192.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在创建项目之前，请确保 &lt;code&gt;@angular/cli&lt;/code&gt; 已被成功安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行以下命令，&lt;code&gt;@angular/cli&lt;/code&gt; 会在当前目录下新建一个名称为 YyFlight-NG-ZORRO的文件夹，并自动安装好相应依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
ng new YyFlight-NG-ZORRO
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202012/1336199-20201221235934319-1657963958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;自动完成 &lt;code&gt;ng-zorro-antd&lt;/code&gt; 的初始化配置（推荐，简单快速）：&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;进入新建的Angular项目目录(YyFlight-NG-ZORRO)中:&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
cd YyFlight-NG-ZORRO
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;初始化ng-zorro-antd配置：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;注意：执行以下命令后将自动完成 &lt;code&gt;ng-zorro-antd&lt;/code&gt; 的初始化配置，包括引入国际化文件，导入模块，引入样式文件等工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
ng add ng-zorro-antd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【重要】设置项目的相关配置，并选择模板创建项目：　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Skipping installation: Package already installed? Enable icon dynamic loading（正在跳过安装：包已安装？启用图标动态加载）：y&lt;/p&gt;
&lt;p&gt;set up custom theme file（设置自定义主题文件）：y&lt;/p&gt;
&lt;p&gt;choose your locale code（选择区域设置代码）：ZH-CN&lt;/p&gt;
&lt;p&gt;choose template to create project（选择模板创建项目）:sidemenu (页面菜单)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202012/1336199-20201222011238611-2095461058.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;启动调试查看页面效果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
ng serve --port 0 --open
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202012/1336199-20201222013227599-1879345132.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;手动安装ng-zorro-antd：&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;安装组件：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot; readability=&quot;7&quot;&gt;
npm install ng-zorro-antd --save&lt;p&gt;如果上面命令安装失败，可以试试下面的cnpm安装：&lt;/p&gt;&lt;p&gt;cnpm install ng-zorro-antd --save
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202012/1336199-20201222002115760-178343999.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;引入样式：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 &lt;code&gt;angular.json&lt;/code&gt; 中引入：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
{
  &quot;styles&quot;: [
    &quot;node_modules/ng-zorro-antd/ng-zorro-antd.min.css&quot;
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在 &lt;code&gt;style.css&lt;/code&gt; 中引入css样式文件：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
@import &quot;~ng-zorro-antd/ng-zorro-antd.min.css&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在 &lt;code&gt;style.less&lt;/code&gt; 中引入 less 样式文件：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
@import &quot;~ng-zorro-antd/ng-zorro-antd.less&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;引入组件模块&quot;&gt;引入组件模块：&lt;/h3&gt;
&lt;p&gt;以下面的 &lt;code&gt;NzButtonModule&lt;/code&gt; 模块为例，先引入组件模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
import { NgModule } from '@angular/core';
import { NzButtonModule } from 'ng-zorro-antd/button';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    NzButtonModule
  ]
})
export class AppModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在模板中使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;button nz-button nzType=&quot;primary&quot;&amp;gt;Primary&amp;lt;/button&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 22 Dec 2020 16:03:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 在之前的一篇文章已经介绍过了，公司正在使用NG-ZORRO组件库开发后台应用，并且详细的介绍了Angular开发环境的搭建和项目的创建。这篇文章就是为了让大家熟悉了解我们该如何在Angular</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/14170872.html</dc:identifier>
</item>
<item>
<title>ThreadX——IPC应用之消息队列 - zzssdd2</title>
<link>http://www.cnblogs.com/zzssdd2/p/14176251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzssdd2/p/14176251.html</guid>
<description>&lt;blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;消息队列&lt;/code&gt;是RTOS中常用的一种数据通信方式，常用于任务与任务之间或是中断与任务之间的数据传递。在裸机系统中我们通常会使用全局变量的方式进行数据传递，比如在事件发生后在中断中改变数据和设置标志，然后在主循环中轮询不同的标志是否生效来对全局数据执行不同的操作，执行完毕后清除相关标志。但是这种方式需要不断地轮询标志状态，使得CPU的利用率并不高。而使用RTOS的消息队列则具有任务阻塞机制，当没有需要处理的消息时任务挂起等待消息，此时其他任务占用CPU执行其他操作，当有消息放入队列时任务恢复运行进行消息接收和处理。这种消息处理机制相比裸机而言大大地提高了CPU利用率。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ThreadX&lt;/strong&gt;的消息队列支持“消息置顶通知”功能，也就是可以将消息放在队列的最前面，使得任务可以及时处理某些紧急消息（RT-Thread的消息队列也有该功能）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ThreadX&lt;/strong&gt;的消息队列可以传递任意长度的数据，因为它是采用传递数据指针的方式（uCOS也是采用这种引用传递的方式，而FreeRTOS和RT-Thread则支持传递整体数据内容。这两种方式各有优劣吧，指针传递方式优点是执行效率高，缺点是存数据的内存区域如果数据还未及时处理就被覆写了那么就会引发问题；整体数据传递方式优点是安全不需担心数据覆写致错，缺点是数据量大的话传递数据过程执行时间长导致效率低）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面介绍使用&lt;strong&gt;ThreadX&lt;/strong&gt;的消息队列时常用的几个API函数。&lt;/p&gt;
&lt;h2 id=&quot;1、创建消息队列&quot;&gt;1、创建消息队列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;该服务用于创建消息队列。 消息总数是根据指定的消息大小和队列中的字节总数来计算的&lt;/li&gt;
&lt;li&gt;如果在队列的内存区域中指定的字节总数不能被指定的消息大小均分，则不会使用该内存区域中的其余字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向消息队列控制块的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name_ptr&lt;/strong&gt; 指向消息队列名称的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;message_size&lt;/strong&gt; 指定队列中每条消息的大小。 消息大小选项为1个32位字到16个32位字之间（包含）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;queue_start&lt;/strong&gt; 消息队列的起始地址。 起始地址必须与ULONG数据类型的大小对齐&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;queue_size&lt;/strong&gt; 消息队列可用的字节总数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 创建成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的消息队列指针，指针为NULL或队列已创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt; (0x03) 消息队列的起始地址无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_SIZE_ERROR&lt;/strong&gt; (0x05) 消息队列大小无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt; (0x13) 该服务的调用者无效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_create(
    TX_QUEUE *queue_ptr, 
    CHAR *name_ptr,
    UINT message_size,
    VOID *queue_start, 
    ULONG queue_size);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、删除消息队列&quot;&gt;2、删除消息队列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;此服务删除指定的消息队列。所有挂起等待此队列消息的线程都将恢复，并给出TX_DELETED返回状态&lt;/li&gt;
&lt;li&gt;在删除队列之前，应用程序必须确保已完成（或禁用）此队列的所有send_notify回调。 此外，应用程序必须防止将来使用已删除的队列&lt;/li&gt;
&lt;li&gt;应用程序还负责管理与队列相关联的内存区域，该内存区域在此服务完成后可用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的消息队列的指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 删除成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 消息队列指针无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt; (0x13) 该服务的调用者无效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_delete(TX_QUEUE *queue_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、清空消息队列&quot;&gt;3、清空消息队列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;此服务删除存储在指定消息队列中的所有消息&lt;/li&gt;
&lt;li&gt;如果队列已满，将丢弃所有挂起线程的消息，然后恢复每个挂起的线程，并返回一个指示消息发送成功的返回状态。如果队列为空，则此服务不执行任何操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的消息队列的指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 消息队列指针无效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_flush(TX_QUEUE *queue_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、消息置顶&quot;&gt;4、消息置顶&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;该服务将消息发送到指定消息队列的最前面。 消息从源指针指定的存储区域复制到队列的最前面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向消息队列控制块的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;source_ptr&lt;/strong&gt; 指向存放消息的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wait_option&lt;/strong&gt; 定义消息队列已满时服务的行为
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_NO_WAIT&lt;/strong&gt; (0x00000000) - 无论是否成功都立即返回（用于非线程调用，例如中断里面）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_FOREVER&lt;/strong&gt; (0xFFFFFFFF) - 一直等待直到消息队列有空闲为止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_DELETED&lt;/strong&gt; (0x01) 线程挂起时，消息队列被删除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_FULL&lt;/strong&gt; (0x0B) 服务无法发送消息，因为在指定的等待时间内队列已满&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ABORTED&lt;/strong&gt; (0x1A) 被另一个线程、计时器或ISR中断给中止&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的消息队列指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt; (0x03) 消息的源指针无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ERROR&lt;/strong&gt; (0x04) 在非线程调用中指定了TX_NO_WAIT以外的等待选项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_front_send(
    TX_QUEUE *queue_ptr,
    VOID *source_ptr, 
    ULONG wait_option);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5、获取消息队列信息&quot;&gt;5、获取消息队列信息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;该服务检索有关指定消息队列的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;（TX_NULL表示不需要获取该参数代表的信息）
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的消息队列的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; 指向目标的指针，用于指向队列名称&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enqueued&lt;/strong&gt; 指向目标的指针，表示当前队列中的消息数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;available_storage&lt;/strong&gt; 指向目标的指针，表示队列当前有空间容纳的消息数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;first_suspended&lt;/strong&gt; 指向目标的指针，该指针指向该队列的挂起列表中第一个线程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;suspended_count&lt;/strong&gt; 指向目标的指针，用于指示当前在此队列上挂起的线程数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;next_queue&lt;/strong&gt; 指向下一个创建队列的指针的目标的指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的消息队列指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_info_get(
    TX_QUEUE *queue_ptr, 
    CHAR **name,
    ULONG *enqueued, 
    ULONG *available_storage
    TX_THREAD **first_suspended, 
    ULONG *suspended_count,
    TX_QUEUE **next_queue);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6、从队列获取消息&quot;&gt;6、从队列获取消息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;该服务从指定的消息队列中检索消息。 检索到的消息从队列复制到目标指针指定的存储区域。 然后将该消息从队列中删除&lt;/li&gt;
&lt;li&gt;指定的目标存储区必须足够大以容纳消息。 也就是说，由&lt;em&gt;&lt;strong&gt;destination_ptr&lt;/strong&gt;&lt;/em&gt; 指向的消息目标必须至少与此队列的消息大小一样大。 否则，如果目标不够大，则会在存储区域中发生内存地址非法错误&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的消息队列的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;destination_ptr&lt;/strong&gt; 指向储存消息的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wait_option&lt;/strong&gt; 定义消息队列为空时服务的行为
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_NO_WAIT&lt;/strong&gt; (0x00000000) - 无论是否成功都立即返回（用于非线程调用，例如中断里面）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_FOREVER&lt;/strong&gt; (0xFFFFFFFF) - 一直等待直到有消息可以获取&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x00000001 ~ 0xFFFFFFFE&lt;/strong&gt;- 指定具体等待心跳节拍数（如果心跳频率1KHZ，那么单位就是ms ）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_DELETED&lt;/strong&gt; (0x01) 线程挂起时删除了消息队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_EMPTY&lt;/strong&gt; (0x0A) 服务无法检索消息，因为队列在指定的等待时间段内为空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ABORTED&lt;/strong&gt; (0x1A) 被另一个线程、计时器或ISR中断给中止&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的消息队列指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt; (0x03) 消息的目标指针无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ERROR&lt;/strong&gt; (0x04) 在非线程调用中指定了TX_NO_WAIT以外的等待选项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_receive(
    TX_QUEUE *queue_ptr,
    VOID *destination_ptr, 
    ULONG wait_option);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7、向队列发送消息&quot;&gt;7、向队列发送消息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;此服务将消息发送到指定的消息队列。发送的消息将从源指针指定的内存区域复制到队列中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的消息队列的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;source_ptr&lt;/strong&gt; 指向消息的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wait_option&lt;/strong&gt; 定义消息队列已满时服务的行为
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_NO_WAIT&lt;/strong&gt; (0x00000000) - 无论是否成功都立即返回（用于非线程调用，例如中断里面）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_FOREVER&lt;/strong&gt; (0xFFFFFFFF) - 一直等待直到队列有空位可以放置消息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0x00000001 ~ 0xFFFFFFFE&lt;/strong&gt; - 指定具体等待心跳节拍数（如果心跳频率1KHZ，那么单位就是ms ）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_DELETED&lt;/strong&gt; (0x01) 线程挂起时删除了消息队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_FULL&lt;/strong&gt; (0x0B) 服务无法发送消息，因为队列在指定的等待时间内已满&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ABORTED&lt;/strong&gt; (0x1A) 被另一个线程、计时器或ISR中断给中止&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的消息队列指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt; (0x03) 消息的目标指针无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ERROR&lt;/strong&gt; (0x04) 在非线程调用中指定了TX_NO_WAIT以外的等待选项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_send(
    TX_QUEUE *queue_ptr,
    VOID *source_ptr, 
    ULONG wait_option);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8、注册发送通知回调函数&quot;&gt;8、注册发送通知回调函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;此服务注册一个通知回调函数，每当一条消息发送到指定的队列时就会调用该函数。 通知回调的处理由应用程序定义&lt;/li&gt;
&lt;li&gt;不允许在应用程序的队列发送通知回调函数中调用具有暂停选项的ThreadX API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;queue_ptr&lt;/strong&gt; 指向先前创建的队列的指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;queue_send_notify&lt;/strong&gt; 指向应用程序队列发送通知功能的指针。 如果此值为TX_NULL，则禁用通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt; (0x00) 操作成功&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_QUEUE_ERROR&lt;/strong&gt; (0x09) 无效的队列指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_FEATURE_NOT_ENABLED&lt;/strong&gt; (0xFF) 禁用了通知功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_queue_send_notify(
    TX_QUEUE *queue_ptr,
    VOID (*queue_send_notify)(TX_QUEUE *));
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;该应用实例创建三个任务和一个队列消息发送通知回调&lt;/li&gt;
&lt;li&gt;任务1：按键1按一次向消息队列1发送一条消息（单个变量消息）&lt;/li&gt;
&lt;li&gt;任务2：按键2按一次向消息队列2发送一条消息（结构体指针消息）&lt;/li&gt;
&lt;li&gt;任务3：向消息队列3发送消息；接收任务1和任务2的消息并打印输出消息内容&lt;/li&gt;
&lt;li&gt;回调功能：输出消息队列3的相关信息&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define DEMO_STACK_SIZE         (2 * 1024)
#define DEMO_BYTE_POOL_SIZE     (32 * 1024)

TX_THREAD       thread_0;
TX_THREAD       thread_1;
TX_THREAD       thread_2;

TX_BYTE_POOL    byte_pool_0;
UCHAR           memory_area[DEMO_BYTE_POOL_SIZE];

/* 消息队列 */
TX_QUEUE        tx_queue1;
TX_QUEUE        tx_queue2;
TX_QUEUE        tx_queue3;

ULONG           msg_queue1[32];
ULONG           msg_queue2[16];
ULONG           msg_queue3[8];

struct S_DATA{
    uint32_t id;
    uint16_t flag;
    uint8_t msg[2];
};
struct S_DATA data_package;

void thread_0_entry(ULONG thread_input);
void thread_1_entry(ULONG thread_input);
void thread_2_entry(ULONG thread_input);
void queue3_send_notify(TX_QUEUE *input);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void tx_application_define(void *first_unused_memory)
{
    CHAR    *pointer = TX_NULL;

    /* Create a byte memory pool from which to allocate the thread stacks. */
    tx_byte_pool_create(&amp;amp;byte_pool_0, &quot;byte pool 0&quot;, memory_area, DEMO_BYTE_POOL_SIZE);

    /* Allocate the stack for thread 0. */
    tx_byte_allocate(&amp;amp;byte_pool_0, (VOID **) &amp;amp;pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
    /* Create the main thread. */
    tx_thread_create(&amp;amp;thread_0, &quot;thread 0&quot;, thread_0_entry, 0,  
                    pointer, DEMO_STACK_SIZE, 
                    1, 1, TX_NO_TIME_SLICE, TX_AUTO_START);

    /* Allocate the stack for thread 1. */
    tx_byte_allocate(&amp;amp;byte_pool_0, (VOID **) &amp;amp;pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
    /* Create threads 1 */
    tx_thread_create(&amp;amp;thread_1, &quot;thread 1&quot;, thread_1_entry, 0,  
                    pointer, DEMO_STACK_SIZE, 
                    2, 2, TX_NO_TIME_SLICE, TX_AUTO_START);

    /* Allocate the stack for thread 2. */
    tx_byte_allocate(&amp;amp;byte_pool_0, (VOID **) &amp;amp;pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
    /* Create threads 1 */
    tx_thread_create(&amp;amp;thread_2, &quot;thread 2&quot;, thread_2_entry, 0,  
                    pointer, DEMO_STACK_SIZE, 
                    3, 3, TX_NO_TIME_SLICE, TX_AUTO_START);

    /* 创建消息队列 */
    tx_queue_create(&amp;amp;tx_queue1, &quot;tx_queue1&quot;, 1, msg_queue1, sizeof(msg_queue1));
    tx_queue_create(&amp;amp;tx_queue2, &quot;tx_queue2&quot;, 1, msg_queue2, sizeof(msg_queue2));
    tx_queue_create(&amp;amp;tx_queue3, &quot;tx_queue2&quot;, 1, msg_queue3, sizeof(msg_queue3));
    
    /* 注册发送消息回调 */
    tx_queue_send_notify(&amp;amp;tx_queue3, queue3_send_notify);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;任务1&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void    thread_0_entry(ULONG thread_input)
{
    uint8_t i =0, key_flag = 0;
    uint8_t data_single = 0;

    while(1)
    {
        if (0 == key_flag)
        {
            if (GPIO_PIN_SET == HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin))
            {
                key_flag = 1;
            }
        }
        else
        {
            if (GPIO_PIN_RESET == HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin))
            {
                key_flag = 0;
                /*按键1触发，向队列1发送消息*/
                data_single++;
                tx_queue_send(&amp;amp;tx_queue1, &amp;amp;data_single, TX_NO_WAIT);
            }
        }
        tx_thread_sleep(20);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;任务2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void    thread_1_entry(ULONG thread_input)
{
    uint8_t key_flag = 0;
    struct S_DATA *pData;

    pData = &amp;amp;data_package;
    pData-&amp;gt;id       = 1;
    pData-&amp;gt;flag     = 2;
    pData-&amp;gt;msg[0]   = 3;
    pData-&amp;gt;msg[1]   = 4;

    while(1)
    {
        if (0 == key_flag)
        {
            if (GPIO_PIN_SET == HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin))
            {
                key_flag = 1;
            }
        }
        else
        {
            if (GPIO_PIN_RESET == HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin))
            {
                key_flag = 0;
                /*按键2触发，向队列2发送消息*/
                pData-&amp;gt;id       += 8;
                pData-&amp;gt;flag     += 4;
                pData-&amp;gt;msg[0]   += 2;
                pData-&amp;gt;msg[1]   += 1;
                tx_queue_send(&amp;amp;tx_queue2, &amp;amp;pData, TX_NO_WAIT);
            }
        }
        tx_thread_sleep(20);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;任务3&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void    thread_2_entry(ULONG thread_input)
{
    UINT status;
    uint8_t char_data;
    ULONG long_data = 0;
    struct S_DATA *buf_data;

    while(1)
    {
        /* 向队列3发送消息 */
        long_data++;
        tx_queue_send(&amp;amp;tx_queue3, &amp;amp;long_data, TX_NO_WAIT);
        if (0 == (long_data &amp;amp; 7))
        {
            tx_queue_flush(&amp;amp;tx_queue3);
        }

        /* 接收队列1消息 */
        status = tx_queue_receive(&amp;amp;tx_queue1, &amp;amp;char_data, 1000);
        if (TX_SUCCESS == status)
        {
            SEGGER_RTT_SetTerminal(0);
            SEGGER_RTT_printf(0, RTT_CTRL_TEXT_BRIGHT_GREEN&quot;message queue1 receive data is %d\r\n&quot;, char_data);
        }

        /* 接收队列2消息 */
        status = tx_queue_receive(&amp;amp;tx_queue2, &amp;amp;buf_data, 1000);
        if (TX_SUCCESS == status)
        {
            SEGGER_RTT_SetTerminal(1);
            SEGGER_RTT_printf(0, RTT_CTRL_TEXT_BRIGHT_YELLOW&quot;message queue2 receive data is %d\t%d\t%d\t%d \r\n&quot;, \
                                buf_data-&amp;gt;id, \
                                buf_data-&amp;gt;flag, \
                                buf_data-&amp;gt;msg[0], \
                                buf_data-&amp;gt;msg[1]);
        }
    }   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发送队列消息回调功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void    queue3_send_notify(TX_QUEUE *input)
{
    ULONG enqueued;             // 队列中的消息数
    ULONG available_storage;    // 队列剩余空间
    
    tx_queue_info_get(&amp;amp;tx_queue3, TX_NULL, &amp;amp;enqueued, &amp;amp;available_storage, TX_NULL, TX_NULL, TX_NULL);
    
    SEGGER_RTT_SetTerminal(2);
    SEGGER_RTT_printf(0, &quot;the number of messages in the queue3 %d\r\n&quot;, enqueued);
    SEGGER_RTT_printf(0, &quot;the queue3 remaining size %d\r\n&quot;, available_storage);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;任务1演示结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201222234948580-1103793613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务2演示结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201222234954382-293860159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务3演示结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201222235004724-95607872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：关于使用SEGGER_RTT打印功能可以参考这篇笔记：&lt;a href=&quot;https://www.cnblogs.com/zzssdd2/p/14162382.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zzssdd2/p/14162382.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Dec 2020 15:52:00 +0000</pubDate>
<dc:creator>zzssdd2</dc:creator>
<og:description>作者：zzssdd2 E-mail：zzssdd2@foxmail.com 一、应用简介 消息队列是RTOS中常用的一种数据通信方式，常用于任务与任务之间或是中断与任务之间的数据传递。在裸机系统中我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzssdd2/p/14176251.html</dc:identifier>
</item>
</channel>
</rss>