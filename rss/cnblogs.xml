<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【实验课选题详解】用C语言实现万年历 - 喵乖乖喵</title>
<link>http://www.cnblogs.com/Qing-LKY/p/permanent-calendar.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Qing-LKY/p/permanent-calendar.html</guid>
<description>&lt;p&gt;编程实现万年历，要求：&lt;br/&gt;可根据用户输入或系统日期进行初始化，如果用户无输入则显示系统日期所在月份的月历，并突出显示当前日期；&lt;br/&gt;可根据用户输入的日期查询，并显示查询结果所在月份的月历，突出显示当前日期，并提示是否闰年&lt;br/&gt;对任何不合法输入数据，拒绝查询并进行提示。&lt;/p&gt;

&lt;p&gt;可将思考、编程划分为以下几个模块：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何通过已有日期和星期推算要求的日期的星期？&lt;/li&gt;
&lt;li&gt;如何整齐地输出月历？&lt;/li&gt;
&lt;li&gt;如何获取系统时间？&lt;/li&gt;
&lt;li&gt;在有余力的前提下，如何美化界面？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面对上面的几个问题给出粗略的概述。&lt;br/&gt;具体实现和技巧性地东西参考后文代码。&lt;/p&gt;
&lt;h2 id=&quot;问题1-日期推算&quot;&gt;问题1 日期推算&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;众所周知，需要推算日期的模拟题都是毒瘤题&lt;/s&gt;&lt;br/&gt;日期推算的算法有很多，这里只给出我的思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;推出差了多少天。&lt;/li&gt;
&lt;li&gt;用数学公式推出星期。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这条公式是 &lt;span class=&quot;math inline&quot;&gt;\((w+d) \mod 7\)&lt;/span&gt;，d 表示差的天数，w 表示原本是星期几。&lt;br/&gt;我采用的是标准的 &lt;strong&gt;0 表示 Sun.&lt;/strong&gt; 而 6 表示 Sat. 的方法。&lt;br/&gt;time.h 自带的 tm_wday 就是用这种方式表示的。&lt;br/&gt;需要注意的是 &lt;strong&gt;C 与 C++ 对负数取模的特(sha)殊(bi)性&lt;/strong&gt;，所以为了求出正确的结果，我们要采用一点小技巧。&lt;br/&gt;&lt;code&gt;if(w1+d&amp;lt;0) w2=(w1+d)+(-w1-d)/7*7+7;&lt;/code&gt;&lt;br/&gt;似乎也可以在推出天数后乘上86400减一下然后扔给 localtime() 去推星期。&lt;br/&gt;&lt;s&gt;但是你连天数都推出来了，直接算不香吗。而且既然是万年历，秒数太大爆了怎么办&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;接下来让我们考虑如何推算差了多少天。&lt;/p&gt;
&lt;p&gt;我为了方便计算，所有的推算都以2020年1月1日星期三为基准。&lt;br/&gt;由一个基准来推的化可以省去很多麻烦。&lt;/p&gt;
&lt;p&gt;首先，第一种方法是暴力模拟。一年一年地推、一月一月地推、一天一天地推。&lt;br/&gt;我在代码中注释掉的就是暴力模拟法。&lt;br/&gt;这个没什么好讲的，闰年就差 366 天，否则差 365 天。&lt;br/&gt;年推到了就推月，实现把每个月份的天数打个表，别忘了特判二月就行。&lt;br/&gt;你也可以不像我那样偷懒一个一个月推，使用&lt;strong&gt;前缀和数组+闰年特判&lt;/strong&gt;也行。但是每次查询最多就推 12 个月，一个月一个月推也差不了多少。&lt;br/&gt;这点时间肉眼是看不出来的。所以随便吧。&lt;br/&gt;天数就没什么好说的，自己随便想两个同年同月的日期看看差几天，很快就能看出是直接拿日期相减了。&lt;/p&gt;
&lt;p&gt;其实，我们不难发现，年份可以不用一年一年模拟，可以用数学公式算。&lt;br/&gt;现在我们要算 &lt;strong&gt;A年1月1日 到 B年1月1日&lt;/strong&gt; 经过了几个闰年。&lt;br/&gt;以 A &amp;lt; B 为例&lt;br/&gt;直接拿 (B-A)/4 来算闰年个数这种玄学的事情我是不会干的。我希望求出的闰年个数是绝对准确的。&lt;br/&gt;因此可以这样来：&lt;br/&gt;我们知道 x/4 可以表示小于等于 x 的正整数中 4 的倍数的个数。&lt;br/&gt;我们需要求经过的闰年的个数，只需要知道区间 [A,B-1] 中 4、100、400 的倍数的个数就行了。&lt;br/&gt;（ 因为我考虑的是 1月1日 ，如果考虑 12月31日 的话，应该变为 [A+1,B] ）&lt;br/&gt;根据容斥原理，记 4、100、400 的倍数的个数分别为 &lt;span class=&quot;math inline&quot;&gt;\(c_1,c_2,c_3\)&lt;/span&gt;&lt;br/&gt;我们有：&lt;span class=&quot;math inline&quot;&gt;\(n = c_1 - c_2 + c_3\)&lt;/span&gt;&lt;br/&gt;根据&lt;strong&gt;前缀和&lt;/strong&gt;的思想，我们有：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(c_1 = (B-1)/4 - (A-1)/4\)&lt;/span&gt;&lt;br/&gt;应该不会有人看不懂前缀和吧，不过我还是解释一下吧。&lt;br/&gt;因为 A 是包含在区间里面的，我们要求 [A,B-1] 的区间权值，自然不能把 A 删出去，所以要用 A-1 。&lt;br/&gt;其它几项同理。&lt;br/&gt;于是我们求出了闰年的个数，于是 &lt;span class=&quot;math inline&quot;&gt;\(d = (B-A) + n \times 1\)&lt;/span&gt;&lt;br/&gt;至于 A &amp;gt; B 的情形，同理，只需要把区间改为 [B,A-1] 。&lt;br/&gt;然后根据前缀和，你会发现&lt;strong&gt;式子是一样的，只是正负号变了而已，所以没有分类讨论的必要&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样就解决了最关键的问题，剩下的只需要动用知识和&lt;strong&gt;耐心&lt;/strong&gt;去模拟就好了。&lt;/p&gt;
&lt;h2 id=&quot;问题2-月历的格式&quot;&gt;问题2 月历的格式&lt;/h2&gt;
&lt;p&gt;这个随便百度一下万年历或者点一下右下角的时间模仿一下它的格式就行了。这里介绍几个技巧。&lt;/p&gt;
&lt;h3 id=&quot;分行-printf-（这个好像谁都会）&quot;&gt;分行 printf （这个好像谁都会）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;char s[]=&quot;you bao da me.&quot;;
printf(
        &quot;I too vegetable le.\nI do not have %d pens.\n&quot;
        &quot;You too strong le.\n%s\n&quot;
        &quot;I also want as strong as No.%d.\n&quot;,5,s
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对齐&quot;&gt;对齐&lt;/h3&gt;
&lt;p&gt;利用 &lt;code&gt;%-*d&lt;/code&gt; 可以靠左对齐，&lt;code&gt;%*d&lt;/code&gt; 则是靠右对齐。&lt;br/&gt;总之计算好需要的字符长度然后分配即可。看着不行多试几次。&lt;/p&gt;
&lt;h3 id=&quot;利用字符数组减少工作量&quot;&gt;利用字符数组减少工作量&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;char wday_[7][7]={&quot;Sun. |&quot;,&quot;Mon. |&quot;,&quot;Tues.|&quot;,&quot;Wed. |&quot;,&quot;Thur.|&quot;,&quot;Fri. |&quot;,&quot;Sat.  &quot;};
char div_line[]=&quot;============================================================&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，二维数组的字符串长度必须声明。因为只有知道了长度才可以分配内存。二维数组不止要分配第一个字符串的内存，还要同时按间隔分配余下的内存，不规定长度的话它不知道要在哪里放第二个。&lt;/p&gt;
&lt;p&gt;（下面这个是我的个人理解，因为我一开始出了这个问题）&lt;br/&gt;还有，不建议把字符数组的长度设得刚刚好。&lt;code&gt;printf(&quot;%s&quot;,wday_[1])&lt;/code&gt; 读入的只是 &lt;code&gt;wday_[1]&lt;/code&gt; 的指针，而不知道 &lt;code&gt;wday_[1]&lt;/code&gt; 到底有多长（因为二维数组的内存分配是连续的），确实我只用了六个字符 &lt;code&gt;&quot;Sun. |&quot;&lt;/code&gt; 但是连在一起的话计算机眼中是这样的 &lt;code&gt;&quot;Sun. |Mon. |&quot;&lt;/code&gt; 也就是说，因为连在一起，中间没有字符串终止的标记，%s 就会把你整个二维数组全输出来。&lt;strong&gt;多预留出至少一位&lt;/strong&gt;就能解决这个问题。&lt;/p&gt;
&lt;p&gt;另外，我发现 &lt;code&gt;div_line[]&lt;/code&gt; 默认分配到是恰好的 61 个 char 的长度。也就是说这玩意后面也没有预留一位。那假如我在之后的某次操作中恰好用接在它后面空间声明了一个字符串 ss ，那我 &lt;code&gt;printf(&quot;%s&quot;,div_line)&lt;/code&gt; 的时候是不是也会把 ss 输出来？&lt;/p&gt;
&lt;p&gt;有点意思，这个问题先留个影，以后再研究吧。&lt;/p&gt;
&lt;h2 id=&quot;问题3-timeh的简单用法&quot;&gt;问题3 &amp;lt;time.h&amp;gt;的简单用法&lt;/h2&gt;
&lt;p&gt;这个百度一堆，不做赘述。个人比较喜欢&lt;a href=&quot;https://blog.csdn.net/xbaer/article/details/6422326&quot;&gt;这篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在这里&lt;strong&gt;转载&lt;/strong&gt;一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct tm {  
int tm_sec; /* 秒 – 取值区间为[0,59] */  
int tm_min; /* 分 - 取值区间为[0,59] */  
int tm_hour; /* 时 - 取值区间为[0,23] */  
int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */  
int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */  
int tm_year; /* 年份，其值等于实际年份减去1900 */  
int tm_wday; /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */ 
int tm_yday; /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */  
int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/  
};  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;strong&gt;tm_year 返回的是差值，且 tm_mon 是从 0 开始的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接放代码和注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
int main(){
    struct tm *t; /*因为下面用上的两个函数返回值都是指针*/
    /*time_t 其实是整数，具体是 long 还是 int 之类的可能不太一样*/
    time_t x;
    /*使用 time 函数获取基准时间到现在时间经过的秒数 这有两种方法*/
    time(&amp;amp;x);/*可以利用 time 改动指针 &amp;amp;x 对应的值*/
    x=time(NULL); /*time 返回值也是秒数，所以这样写也行*/ 
    /*NULL 也可以改成随便一个指针，但是这样一来那个指针对应的数会被修改，这需要注意*/
    t=localtime(&amp;amp;x);/*获取x秒对应的本地时间（UTC+8）*/
    t=gmtime(&amp;amp;x);/*也可以用这个函数，获取UTC标准时间*/
    /*之后便可以用上面的结构体里的东西了*/
    printf(&quot;Now is %d\n&quot;,t-&amp;gt;tm_year+1900);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;问题4-美化&quot;&gt;问题4 美化&lt;/h2&gt;
&lt;p&gt;基于我对 cmd 界面的认识，我认为改动颜色可以使他更好看（雾&lt;/p&gt;
&lt;p&gt;其实 lxy 大佬有向我介绍用 printf 改变字符串颜色的做法，&lt;s&gt;但是看起来太麻烦了，我懒得弄，&lt;/s&gt;感兴趣的可以自己百度去试一试。&lt;/p&gt;
&lt;p&gt;关于常见的 cmd 命令，可以在 cmd 窗口输入 help 去查，也可以用 &quot;/?&quot; 如 color /? 这样的命令去查询细节&lt;/p&gt;
&lt;p&gt;使用 &amp;lt;stdlib.h&amp;gt; 中的 system 函数可以运行 cmd 命令。（大概吧）&lt;/p&gt;
&lt;p&gt;分割线也挺好看的。嗯。挺好看的。（确信&lt;/p&gt;
&lt;p&gt;&lt;s&gt;当然你要卷 GUI 那当我没说过（逃&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;效果图：事实证明，每行留几个空格在前面会好看一点，不过我不太想改了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160110/202010/2160110-20201031211319782-698476968.png&quot; alt=&quot;图1&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160110/202010/2160110-20201031211331916-750840027.png&quot; alt=&quot;图2&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160110/202010/2160110-20201031211437974-121122794.png&quot; alt=&quot;图3&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160110/202010/2160110-20201031211502205-859371224.png&quot; alt=&quot;图4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;这是一个方便快速跳过图片的标记-&quot;&gt;这是一个方便快速跳过图片的标记 ~&lt;/h2&gt;
&lt;p&gt;顺便，无奖求 hack ，也许哪个日期的星期是错的。至少我现在没查出有错误。&lt;/p&gt;
&lt;p&gt;哦对了，我担心有人的基准年不是 1900年 所以加了一个 Fix Mode&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define PAUSE() system(&quot;pause&quot;)
#define CLEAR() system(&quot;cls&quot;)
#define rep(i,a,b) for(int i=a;i&amp;lt;=b;i++)
char wday_[7][7]={&quot;Sun. |&quot;,&quot;Mon. |&quot;,&quot;Tues.|&quot;,&quot;Wed. |&quot;,&quot;Thur.|&quot;,&quot;Fri. |&quot;,&quot;Sat.  &quot;};
char div_line[]=&quot;============================================================&quot;;
char _16bas[]=&quot;0123456789abcdef&quot;;
void color_change(){
    /*change the color of cmd in random*/
    static char cmd_[] = &quot;color f0&quot;;
    cmd_[7]=_16bas[rand()%7];
    system(cmd_);
}
void _statement(){
    color_change();
    printf(
        &quot;\n&quot;
        &quot;============================================================\n&quot;
        &quot;Welcome to use Permanent Calendar by Qing_!\n&quot;
        &quot;Here, you can see the monthly calendar now.\n&quot;
        &quot;Here, you can query the calendar for anyday.\n&quot;
        &quot;Come on, study-human! Now, enjoy your time!\n&quot;
        &quot;Notice: I will use Chinese English to talk with you.\n&quot;
        &quot;============================================================\n&quot;
        &quot;\n&quot;
    );
    PAUSE(); CLEAR();
}
void put_space(int x){ while(x) x--,putchar(' '); }
void i_am_doing(){
    /*To tell user that I'm calucating.*/
    static int cc=0,p=0;
    cc=(cc+1)%25; if(cc&amp;gt;0) return;
    p=(p+1)%27;

    CLEAR();
    printf(&quot;\n%s\nNow calucating\n&quot;,div_line);
    rep(i,1,p) putchar('.'); putchar('\n');
    printf(&quot;%s\n&quot;,div_line);
}

/*----------------------------------------------------------------------------*/

struct DATE{ int year,mon,day,wday; };
int c_day[]={0,31,0,31,30,31,30,31,31,30,31,30,31};
int bas_Y=1900;

void Fix_Mode(){
    /* May be your bas_Y is not 1900. */
    color_change(); CLEAR();
    printf(
        &quot;%s\nHere is Fix-Mode.\n&quot;
        &quot;This is an important step.\nPlease input a correct year.\n&quot;
        &quot;Before use, input the year today like this:\n2020\n&quot;
        &quot;To fix the base year of different system.\n%s\n&quot;,div_line,div_line
    );
    printf(&quot;The year today is:&quot;),scanf(&quot;%d&quot;,&amp;amp;bas_Y);
    time_t now; time(&amp;amp;now);
    struct tm *t=localtime(&amp;amp;now);
    bas_Y-=t-&amp;gt;tm_year;
    printf(&quot;Done. Press any key to see the change.\n&quot;);
    PAUSE();
}
void input_date(struct DATE *A,int y,int m,int d,int w){
    /* Maybe i havenot use this */
    A-&amp;gt;day=d; A-&amp;gt;mon=m; A-&amp;gt;year=y; A-&amp;gt;wday=w;
}
void get_date(struct DATE *A,struct tm *t){
    /* Notice: tm_year is a delta with 1900, tm_mon is [0,11] */
    A-&amp;gt;day=t-&amp;gt;tm_mday; A-&amp;gt;mon=t-&amp;gt;tm_mon+1; 
    A-&amp;gt;wday=t-&amp;gt;tm_wday; A-&amp;gt;year=t-&amp;gt;tm_year+bas_Y;
}
int is_leap_year(int year){
    return year%100==0 ? year%400==0 : year%4==0;
}
int legal_judge(struct DATE *Q){
    if(Q-&amp;gt;day&amp;lt;=0||Q-&amp;gt;mon&amp;lt;=0) return 0;
    if(Q-&amp;gt;mon&amp;gt;12||Q-&amp;gt;day&amp;gt;31) return 0;
    if(Q-&amp;gt;mon==2) return is_leap_year(Q-&amp;gt;year)?Q-&amp;gt;day&amp;lt;=29:Q-&amp;gt;day&amp;lt;=28;
    return Q-&amp;gt;day&amp;lt;=c_day[Q-&amp;gt;mon];
}
int get_wday(int wday,int delta){
    wday+=delta;
    return wday&amp;lt;0?wday-wday/7*7+7:wday%7;
}
int get_day(struct DATE *Q){
    if(Q-&amp;gt;mon==2) return is_leap_year(Q-&amp;gt;year)?29:28;
    return c_day[Q-&amp;gt;mon];
}
void _display(struct DATE *Q){
    /* To display the date. */
    /* The head */
    if(is_leap_year(Q-&amp;gt;year)) printf(&quot;Do you know? %d is a leap year ~\n&quot;,Q-&amp;gt;year);
    else printf(&quot;Wuhu, i want to fly ~\n&quot;);
    printf(&quot;Here: %d-%d\n&quot;,Q-&amp;gt;year,Q-&amp;gt;mon);
    rep(i,0,6) printf(&quot;%s&quot;,wday_[i]); putchar('\n');
    /* what day is it? */
    int _wday=get_wday(Q-&amp;gt;wday,-Q-&amp;gt;day+1),mDAY=get_day(Q);
    rep(i,0,_wday-1) put_space(2),putchar('/'),put_space(2),putchar('|');
    rep(i,1,mDAY){
        printf(i!=Q-&amp;gt;day?&quot; %2d  &quot;:&quot;[%2d] &quot;,i);
        putchar(_wday==6?'\n':'|');
        _wday=(_wday+1)%7;
    }
    if(_wday!=0){
        rep(i,_wday,5) put_space(2),putchar('/'),put_space(2),putchar('|');
        put_space(2),putchar('/');
    }
    putchar('\n');
}
void calc_wday(struct DATE *Q){
    /* Base on 2020-1-1 Wed. */
    int delta=0,by=2020,bm=1,bd=1;
    /*
    while(by&amp;lt;Q-&amp;gt;year){
        delta+=is_leap_year(by)?366:365; 
        by++; i_am_doing();
    }
    while(by&amp;gt;Q-&amp;gt;year){
        delta-=is_leap_year(by-1)?366:365; 
        by--; i_am_doing();
    }
    */
    delta+=(Q-&amp;gt;year-by)*365;
    delta+=((Q-&amp;gt;year-1)/4-(by-1)/4); 
    delta-=((Q-&amp;gt;year-1)/100-(by-1)/100);
    delta+=((Q-&amp;gt;year-1)/400-(by-1)/400);
    by=Q-&amp;gt;year;

    while(bm&amp;lt;Q-&amp;gt;mon){
        if(bm==2) delta+=is_leap_year(by)?29:28;
        else delta+=c_day[bm];
        bm++; i_am_doing();
    }
    delta+=Q-&amp;gt;day-bd;
    Q-&amp;gt;wday=get_wday(3,delta);
}
void Query_Mode(){
    color_change(); CLEAR();
    printf(
        &quot;\n%s\nWelcome to Query-Mode!\n&quot;
        &quot;In this mode, you can input a date like this:\n&quot;
        &quot;1969 11 9\n&quot;
        &quot;And I will show you the monthly calendar of the date.\n&quot;
        &quot;Notice not to input an illegal date.\n&quot;
        &quot;If, you do that, I may point it out.\n&quot;
        &quot;When you want to exit this mode, input three \'0\':\n&quot;
        &quot;0 0 0\n&quot;
        &quot;Enjoy your time!\n%s\n\n&quot;,div_line,div_line
    );
    PAUSE();
    struct DATE Q; 
    while(1){
        color_change(); CLEAR();
        printf(&quot;Now tell me what date you want to query:\n&quot;);
        scanf(&quot;%d%d%d&quot;,&amp;amp;Q.year,&amp;amp;Q.mon,&amp;amp;Q.day);
        if(Q.day==0&amp;amp;&amp;amp;Q.mon==0&amp;amp;&amp;amp;Q.year==0){
            color_change(); CLEAR();
            printf(&quot;\n%s\nThanks for your use!\n&quot;,div_line);
            printf(&quot;Now press any key to exit Query_Mode.\n%s\n\n&quot;,div_line);
            PAUSE(); return;
        }
        if(legal_judge(&amp;amp;Q)==0){
            printf(&quot;You input an illegal date! Try again!\n&quot;);
            PAUSE();
            continue;
        }else{
            calc_wday(&amp;amp;Q); CLEAR();
            /* display */
            printf(&quot;%s\n&quot;,div_line);
            _display(&amp;amp;Q);
            printf(&quot;%s\n&quot;,div_line);
            /* ask for another */
            printf(
                &quot;I have show you the calendar.\n&quot;
                &quot;Now press any key to come back.\n&quot;
                &quot;If you want to exit this mode, input \'0 0 0\' next time.\n&quot;
            );
            PAUSE();
        }
    }
    
}

/*----------------------------------------------------------------------------*/

int main(){
    srand(time(NULL));
    _statement();
    while(1){
        time_t sec_; time(&amp;amp;sec_);
        struct tm *p; p=localtime(&amp;amp;sec_);
        struct DATE now; get_date(&amp;amp;now,p);
        /* Display the date today. */
        color_change(); CLEAR();
        printf(&quot;Today is a good day!\n&quot;);
        printf(&quot;%s\n&quot;,div_line);
        _display(&amp;amp;now);
        printf(&quot;%s\n&quot;,div_line);
        /* Ask for next option. */
        printf(
            &quot;What do you want to do now?\n&quot;
            &quot;Input an opt as follow to tell me.\n&quot;
            &quot;1 - to query some date.\n&quot;
            &quot;2 - to fix year.\n&quot;
            &quot;3 - to exit.\n&quot;
            &quot;If you input something else, \n&quot;
            &quot;I will change the color for you.\n&quot;
        );
        int opt;
        printf(&quot;%s\nInput option:\n&quot;,div_line),scanf(&quot;%d&quot;,&amp;amp;opt);
        if(opt==1) Query_Mode();
        if(opt==2) Fix_Mode();
        if(opt==3){
            color_change(); CLEAR();
            printf(&quot;%s\nSee you next time!\n%s\n&quot;,div_line,div_line);
            PAUSE(); break;
        }
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 01 Nov 2020 00:13:00 +0000</pubDate>
<dc:creator>喵乖乖喵</dc:creator>
<og:description>模拟 万年历 星期推算 思路理清</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Qing-LKY/p/permanent-calendar.html</dc:identifier>
</item>
<item>
<title>vue-cli @4安装 - 荨筱</title>
<link>http://www.cnblogs.com/wjt-tz/p/13908529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wjt-tz/p/13908529.html</guid>
<description>&lt;p&gt;10月16日，官方发布消息称Vue-cli 4.0正式版发布，安装和vue-cli3.0的是一模一样的，与3.0的脚手架，除了目录发生变化一些，其他的都一样，由于近期才推出，企业中还在使用3.0，但是4.0使用方式与3.0相同。&lt;br/&gt;vue-cli @4安装&lt;br/&gt;1、npm install -g @vue/cli&lt;br/&gt;2、vue --version查看版本&lt;br/&gt;4、vue create 项目名&lt;br/&gt;5、cd项目名&lt;br/&gt;vue-cli配置端口 自动开启 热更新&lt;br/&gt;在项目的根路径下创建一个文件名为vue.config.js&lt;br/&gt;module.exports={&lt;br/&gt;devServer:{&lt;br/&gt;open:true,//自动开启&lt;br/&gt;port:3333,//修改端口&lt;br/&gt;host:&quot;127.0.0.1&quot;,&lt;br/&gt;hotOnly:true,//热更新&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 00:04:00 +0000</pubDate>
<dc:creator>荨筱</dc:creator>
<og:description>10月16日，官方发布消息称Vue-cli 4.0正式版发布，安装和vue-cli3.0的是一模一样的，与3.0的脚手架，除了目录发生变化一些，其他的都一样，由于近期才推出，企业中还在使用3.0，但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wjt-tz/p/13908529.html</dc:identifier>
</item>
<item>
<title>新版本 swagger 组件中 Servers 的 坑 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/servers-in-swagger.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/servers-in-swagger.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;上周做了公司的项目升级，从 2.2 更新到 3.1， swagger 直接更新到了最新，swagger 用的组件是 &lt;code&gt;Swashbuckle.AspNetCore&lt;/code&gt;，然后遇到一个 swagger 的问题，&lt;br/&gt;在本地测试是没问题的，但是部署在测试环境之后就会有问题，主要是 swagger 界面会多一个 servers 的选项，可能会导致 swagger 不能正常使用，下面详细介绍一下&lt;/p&gt;
&lt;h2 id=&quot;swagger-bug-reproduce&quot;&gt;Swagger &quot;bug&quot; reproduce&lt;/h2&gt;
&lt;p&gt;大概的问题是这样的，在本地环境是好的，在测试环境部署是有问题，测试环境部署之后的 swagger 界面大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202010/489462-20201031191424921-1405123249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显这个 servers 是有问题的，我们实际访问的地址是 &lt;code&gt;https://testserver/swagger&lt;/code&gt; 这样的地址，但是 swagger 内部拼出来的 server 地址和实际访问的地址是不符的，swagger 生成的 open api 文档里也会有一个 servers 的属性，示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202010/489462-20201031193726749-1357282092.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这会导致我们使用 swagger 调试 API 的时候会走一个错误的 server 地址，实际请求的地址是 sever 地址加上 api path，可以看一个示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202010/489462-20201031192158370-1107183618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dig-the-source&quot;&gt;Dig the Source&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Swashbuckle.AspNetCore&lt;/code&gt; 是开源的，我们就是扒一扒它的实现源码吧，我们用的是 5.6.3 版本，直接看 5.6.3 tag 对应的代码，可以找到 swagger 的中间件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/v5.6.3/src/Swashbuckle.AspNetCore.Swagger/SwaggerMiddleware.cs&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/v5.6.3/src/Swashbuckle.AspNetCore.Swagger/SwaggerMiddleware.cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里我们可以看到，再返回给客户端之前 open api 文档响应之前我们是可以看到，是会经过 &lt;code&gt;PreSerializeFilters&lt;/code&gt; 处理的，我们再详细看一下 &lt;code&gt;swaggerProvider.GetSwagger&lt;/code&gt; 的实现&lt;/p&gt;
&lt;p&gt;实现代码在这里（可以通过服务注册找到对应的实现，也可以直接找对应接口的实现）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/v5.6.3/src/Swashbuckle.AspNetCore.SwaggerGen/SwaggerGenerator/SwaggerGenerator.cs#L31&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/v5.6.3/src/Swashbuckle.AspNetCore.SwaggerGen/SwaggerGenerator/SwaggerGenerator.cs#L31&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二者结合来看，servers 会根据用户请求来获取一个 server 地址，而当有 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 请求头的时候如果没有按照 swagger 指定的规则这样进行请求头的转发就会导致有问题，而我们的测试环境也正是因为如此，测试环境有一层 LB，经过 LB 转发了 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 和 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 请求头，但是没有转发 &lt;code&gt;X-Forwarded-Port&lt;/code&gt; 所以经过 swagger 的处理之后，就从 &lt;code&gt;https://testserver&lt;/code&gt; 变成了 &lt;code&gt;https://testserver:80&lt;/code&gt; 这样&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private string GetHostOrNullFromRequest(HttpRequest request)
{
    if (!request.Headers.TryGetValue(&quot;X-Forwarded-Host&quot;, out StringValues forwardedHost))
        return null;

    var hostBuilder = new UriBuilder($&quot;http://{forwardedHost[0]}&quot;);

    if (request.Headers.TryGetValue(&quot;X-Forwarded-Proto&quot;, out StringValues forwardedProto))
        hostBuilder.Scheme = forwardedProto[0];

    if (request.Headers.TryGetValue(&quot;X-Forwarded-Port&quot;, out StringValues forwardedPort))
        hostBuilder.Port = int.Parse(forwardedPort[0]);

    return hostBuilder.Uri.ToString().Trim('/');
}

private string GetBasePathOrNullFromRequest(HttpRequest request)
{
    var pathBuilder = new StringBuilder();

    if (request.Headers.TryGetValue(&quot;X-Forwarded-Prefix&quot;, out StringValues forwardedPrefix))
        pathBuilder.Append(forwardedPrefix[0].TrimEnd('/'));

    if (request.PathBase.HasValue)
        pathBuilder.Append(request.PathBase.Value.TrimEnd('/'));

    return (pathBuilder.Length &amp;gt; 0)
        ? pathBuilder.ToString()
        : null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;从上面的源码中基本就可以分析出问题的原因来，解决的办法我觉得有下面几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LB 转发的时候带上 &lt;code&gt;X-Forwarded-Port&lt;/code&gt; 请求头，转发原始请求的端口号（需要 LB 转发自己能够控制，我们如果要配置还需要让 DevOps 的童鞋帮忙弄，如果完全是自己控制的就比较方便【推荐】）&lt;/li&gt;
&lt;li&gt;在使用 Swagger 中间件之前把 &lt;code&gt;X-Forwarded-Port&lt;/code&gt; 请求头设置为 &lt;code&gt;443&lt;/code&gt;（不够灵活，如果访问 LB 是 http 或者有特别的端口号就会有问题）&lt;/li&gt;
&lt;li&gt;在使用 swagger 中间件之前把 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 请求头移除掉，这样就不会有 servers 这个属性了(感觉不够优雅)&lt;/li&gt;
&lt;li&gt;注册一个 &lt;code&gt;PreSerializeFilter&lt;/code&gt; 把 Servers 清空，实现代码如下（【推荐】，没有 servers 属性的时候完全按请求 swagger 的 baseUrl 来作为 api 的前缀，示例代码如下）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;app.UseSwagger(c =&amp;gt;
{
    c.PreSerializeFilters.Add((doc, _) =&amp;gt;
    {
        doc.Servers?.Clear();
    });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新之后就没有 servers 属性了，和之前的版本保持一致了&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;我们使用的是 5.6.3 版本，应该从 5.6.0 开始都有这个问题，如果遇到了这个问题不要慌哈，参考上面的解决方案即可&lt;/p&gt;
&lt;p&gt;我觉得 swagger 这样的实现方式不太友好，更好的实现应该结合微软的 &lt;code&gt;ForwardHeaders&lt;/code&gt; 中间件来实现，Swagger 组件作者表示已经有计划，打算在 6.0 的时候更新结合微软的中间件来实现，详细可以参考 Github 上的 Issue &lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/issues/1814&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/issues/1814&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sat, 31 Oct 2020 15:27:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>swagger servers 的坑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/servers-in-swagger.html</dc:identifier>
</item>
<item>
<title>Git系列:常用命令 - IT技术派</title>
<link>http://www.cnblogs.com/vic-tory/p/13908272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vic-tory/p/13908272.html</guid>
<description>&lt;p&gt;一.背景&lt;/p&gt;
&lt;p&gt;作为一名程序员，怎么能不懂Git那些常用命令呢？于是花费一点时间来总结Git命令。关于安装的话，就不讲了。&lt;/p&gt;
&lt;p&gt;二.初始化和帮助&lt;/p&gt;
&lt;p&gt;1.配置全局的用户名称和用户邮箱&lt;/p&gt;
&lt;p&gt;git config --global user.name &quot;用户名&quot; &amp;amp;&amp;amp; git config --global user.email &quot;邮箱账号&quot;&lt;/p&gt;
&lt;p&gt;git config --&lt;span&gt;list&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;git config user.name&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@centos-master ~]# git config --global user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;robin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; git config --global user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code9342@gmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[root@centos&lt;/span&gt;-master ~]# git config --&lt;span&gt;list
user.name&lt;/span&gt;=&lt;span&gt;robin
user.email&lt;/span&gt;=&lt;span&gt;code9342@gmail.com
[root@centos&lt;/span&gt;-master ~&lt;span&gt;]# git config user.name  
robin
[root@centos&lt;/span&gt;-master ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.查看帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;git help -a &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;git help &amp;lt;command&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@centos-master ~]# git help -&lt;span&gt;a
usage: git [&lt;/span&gt;--version] [--help] [-c name=&lt;span&gt;value]
           [&lt;/span&gt;--exec-path[=&amp;lt;path&amp;gt;]] [--html-path] [--&lt;span&gt;man&lt;/span&gt;-path] [--&lt;span&gt;info&lt;/span&gt;-&lt;span&gt;path]
           [&lt;/span&gt;-p|--paginate|--no-pager] [--no-replace-objects] [--&lt;span&gt;bare]
           [&lt;/span&gt;--git-&lt;span&gt;dir&lt;/span&gt;=&amp;lt;path&amp;gt;] [--work-tree=&amp;lt;path&amp;gt;] [--namespace=&amp;lt;name&amp;gt;&lt;span&gt;]
           &lt;/span&gt;&amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;&lt;span&gt;]

available git commands &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/libexec/git-core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

  add                       clean                     fast&lt;/span&gt;-import               init                      merge-tree                receive-pack              revert                    &lt;span&gt;tar&lt;/span&gt;-&lt;span&gt;tree
  add&lt;/span&gt;--interactive          clone                     fetch                     init-db                   mergetool                 reflog                    &lt;span&gt;rm&lt;/span&gt;                        unpack-&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
  am                        column                    fetch&lt;/span&gt;-pack                log                       mktag                     relink                    send-pack                 unpack-&lt;span&gt;objects
  annotate                  commit                    filter&lt;/span&gt;-branch             lost-found                mktree                    remote                    &lt;span&gt;sh&lt;/span&gt;-i18n--envsubst         update-&lt;span&gt;index
  apply                     commit&lt;/span&gt;-tree               &lt;span&gt;fmt&lt;/span&gt;-merge-msg             &lt;span&gt;ls&lt;/span&gt;-files                  &lt;span&gt;mv&lt;/span&gt;                        remote-ext                shell                     update-&lt;span&gt;ref
  archive                   config                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;-each-ref              &lt;span&gt;ls&lt;/span&gt;-remote                 name-rev                  remote-fd                 shortlog                  update-server-&lt;span&gt;info&lt;/span&gt;&lt;span&gt;
  bisect                    count&lt;/span&gt;-objects             format-&lt;span&gt;patch&lt;/span&gt;              &lt;span&gt;ls&lt;/span&gt;-tree                   notes                     remote-&lt;span&gt;ftp&lt;/span&gt;                show                      upload-&lt;span&gt;archive
  bisect&lt;/span&gt;--helper            credential                fsck                      mailinfo                  pack-objects              remote-ftps               show-branch               upload-&lt;span&gt;pack
  blame                     credential&lt;/span&gt;-cache          fsck-objects              mailsplit                 pack-redundant            remote-http               show-&lt;span&gt;index                var
  branch                    credential&lt;/span&gt;-cache--daemon  gc                        merge                     pack-refs                 remote-https              show-ref                  verify-&lt;span&gt;pack
  bundle                    credential&lt;/span&gt;-store          get-&lt;span&gt;tar&lt;/span&gt;-commit-&lt;span&gt;id&lt;/span&gt;         merge-base                &lt;span&gt;patch&lt;/span&gt;-&lt;span&gt;id&lt;/span&gt;                  remote-testpy             stage                     verify-&lt;span&gt;tag
  &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;-&lt;span&gt;file&lt;/span&gt;                  describe                  &lt;span&gt;grep&lt;/span&gt;                      merge-&lt;span&gt;file&lt;/span&gt;                peek-remote               repack                    stash                     web--&lt;span&gt;browse
  check&lt;/span&gt;-attr                &lt;span&gt;diff&lt;/span&gt;                      hash-&lt;span&gt;object&lt;/span&gt;               merge-&lt;span&gt;index               prune                     replace                   status                    whatchanged
  check&lt;/span&gt;-ignore              &lt;span&gt;diff&lt;/span&gt;-files                help                      merge-octopus             prune-packed              repo-config               stripspace                &lt;span&gt;write&lt;/span&gt;-&lt;span&gt;tree
  check&lt;/span&gt;-ref-format          &lt;span&gt;diff&lt;/span&gt;-index                http-backend              merge-one-&lt;span&gt;file&lt;/span&gt;            pull                      request-&lt;span&gt;pull              submodule
  checkout                  &lt;/span&gt;&lt;span&gt;diff&lt;/span&gt;-tree                 http-fetch                merge-ours                push                      rerere                    submodule--&lt;span&gt;helper
  checkout&lt;/span&gt;-index            difftool                  http-push                 merge-&lt;span&gt;recursive           quiltimport               reset                     subtree
  cherry                    difftool&lt;/span&gt;--helper          imap-send                 merge-resolve             read-tree                 rev-list                  symbolic-&lt;span&gt;ref
  cherry&lt;/span&gt;-pick               fast-export               index-pack                merge-subtree             rebase                    rev-&lt;span&gt;parse                 tag

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;git help -a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; and &lt;span&gt;'&lt;/span&gt;&lt;span&gt;git help -g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; lists available subcommands and some
concept guides. See &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;git help &amp;lt;command&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; or &lt;span&gt;'&lt;/span&gt;&lt;span&gt;git help &amp;lt;concept&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
to read about a specific subcommand or concept.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三.站在构建者的角度上需要掌握的命令&lt;/p&gt;
&lt;p&gt;1.创建一个仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699002/202010/1699002-20201031235557225-1683009571.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1699002/202010/1699002-20201031235647098-14293014.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2.基本命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[root@centos-master git]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
[root@centos&lt;/span&gt;-master git]# &lt;span&gt;mkdir&lt;/span&gt; my-&lt;span&gt;project
[root@centos&lt;/span&gt;-master git]# cd my-project/&lt;span&gt;
[root@centos&lt;/span&gt;-master my-&lt;span&gt;project]# git init
Initialized empty Git repository &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /opt/git/my-project/.git/&lt;span&gt;
[root@centos&lt;/span&gt;-master my-project]# &lt;span&gt;touch&lt;/span&gt;&lt;span&gt; index.html
[root@centos&lt;/span&gt;-master my-&lt;span&gt;project]# git add .
[root@centos&lt;/span&gt;-master my-&lt;span&gt;project]# git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git rm --cached &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; to unstage)
#
#       new &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;:   index.html
#
[root@centos&lt;/span&gt;-master my-project]# git commit -&lt;span&gt;m 注释
[master (root&lt;/span&gt;-&lt;span&gt;commit) ce8369e] 注释
 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; changed, &lt;span&gt;0&lt;/span&gt; insertions(+), &lt;span&gt;0&lt;/span&gt; deletions(-&lt;span&gt;)
 create mode &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt;&lt;span&gt; index.html
[root@centos&lt;/span&gt;-master my-&lt;span&gt;project]# git status
# On branch master
nothing to commit, working directory clean
[root@centos&lt;/span&gt;-master my-project]# git remote add origin https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/CodeInterface/my-project.git&lt;/span&gt;
[root@centos-master my-project]# git push -&lt;span&gt;u origin  master
Username &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: CodeInterface
Password &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://CodeInterface@github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
Counting objects: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;done&lt;/span&gt;&lt;span&gt;.
Writing objects: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;% (&lt;span&gt;3&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;), &lt;span&gt;219&lt;/span&gt; bytes | &lt;span&gt;0&lt;/span&gt; bytes/s, &lt;span&gt;done&lt;/span&gt;&lt;span&gt;.
Total &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; (delta &lt;span&gt;0&lt;/span&gt;), reused &lt;span&gt;0&lt;/span&gt; (delta &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
remote:
remote: Create a pull request &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; on GitHub by visiting:
remote:      https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/CodeInterface/my-project/pull/new/master&lt;/span&gt;
&lt;span&gt;remote:
To https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/CodeInterface/my-project.git&lt;/span&gt;
 * [new branch]      master -&amp;gt;&lt;span&gt; master
Branch master set up to track remote branch master from origin.
[root@centos&lt;/span&gt;-master my-project]#
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 31 Oct 2020 15:26:00 +0000</pubDate>
<dc:creator>IT技术派</dc:creator>
<og:description>一.背景 作为一名程序员，怎么能不懂Git那些常用命令呢？于是花费一点时间来总结Git命令。关于安装的话，就不讲了。 二.初始化和帮助 1.配置全局的用户名称和用户邮箱 git config --gl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vic-tory/p/13908272.html</dc:identifier>
</item>
<item>
<title>【算法】HashMap相关要点记录 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/13908259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/13908259.html</guid>
<description>&lt;p&gt;在刷leetcode的算法题时，HashMap需要大量使用，而且也是面试的高频问题。这里记录了HashMap一些增、删、改、查的实现细节和时间复杂度，罗列了一些比较有用的方法，以及其它的一些细节。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;155&quot;&gt;
&lt;p&gt;        在刷leetcode的算法题时，HashMap需要大量使用，而且也是面试的高频问题。这里记录了HashMap一些增、删、改、查的实现细节和时间复杂度，罗列了一些比较有用的方法，以及其它的一些细节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、底层数据结构&lt;/strong&gt;&lt;br/&gt;       HashMap在jdk1.7及之前的版本中，由数组+链表的结构实现，从jdk1.8开始，由数组+链表+红黑树的结构实现，这里在jdk1.8的基础上探讨HashMap。&lt;br/&gt;源码中维护了一个数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] table;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    V value;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这个数组存储的Node，就包含了我们put时的K与V，K的hash值，以及指向下一个节点的指针next。数组中查询节点的时间复杂度是O(1)，但是插入、删除的时间复杂度是O(n)，所以执行插入和删除操作比较耗时。HashMap中加入链表结构来解决这个问题。我们知道，解决hash冲突的一般方法有：开发地址法、二次hash法、拉链法等，这里采用的就是拉链法，也就是这里的数组+链表结构了。查找元素时，最好的情况是就在数组中，时间复杂度为O(1)，最坏的情况是在链表的末尾，时间复杂度是O(n)(当然，由于HashMap的扩容机制和良好的hash算法，hash冲突发生得比较少)；插入和删除的时间复杂度就变成了O(1)了。&lt;/p&gt;
&lt;p&gt;        jdk1.8加入了红黑树，当链表的长度达到8的时候就会由链表升维为红黑树，当红黑树减少到6时又由红黑树降到链表。这里需要补充一点的是，红黑树的节点占用的空间比链表要大，维护红黑树的空间成本比较大，但操作方便；而链表正好相反，所以这里的8和6是一个平衡的值。在链表转为红黑树时，还会判断当前的Entry的数量是否小于64，小于64时会扩容，减少hash冲突，生成红黑树的可能性就小了很多。可见，只有当数量比较多时，维护红黑树的效率才比较明显。&lt;/p&gt;
&lt;p&gt;       红黑树的节点如下，实际上也Node的子类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; LinkedHashMap.LinkedHashMapEntry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      TreeNode&amp;lt;K,V&amp;gt; parent; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; red-black tree links&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      TreeNode&amp;lt;K,V&amp;gt; prev; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; needed to unlink next upon deletion&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; red;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、构造函数的选择&lt;/strong&gt;&lt;br/&gt;      HashMap提供了4个构造函数，实际工作中可能会用到下面3个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashMap() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.loadFactor = DEFAULT_LOAD_FACTOR; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; all other fields defaulted&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; HashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; DEFAULT_LOAD_FACTOR;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      putMapEntries(m, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三个构造函数都使用了默认的扩容因子，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其值为0.75，当HashMap当前使用率达到整个容量(capacity)的75%时就会扩容。第一个构造函数使用得最频繁，会分配默认大小的容量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       第二个构造函数会指定初始容量，指定容量后通过计算，会分配比该初始值大的最近的2的n次方大小的容量，比如传入的initialCapacity为12，实际上会分配16的容量，最大能分配的容量为；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       第三个可以用于复制指定的HashMap。由于扩容需要执行不少操作，所以肯定是会占用一些资源的，如果平时开发比较明确需要使用多少容量，最好使用第二个，可以避免频繁扩容影响性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、元素的插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      插入元素的方法是put(K,V),其基本步骤是：&lt;/p&gt;
&lt;p&gt;  （1）根据Key算出hash值，(n-1)&amp;amp;hash来确定其在数组中的index(这里的n表示数组的长度)&lt;/p&gt;
&lt;p&gt;  （2）如果数组的这个index位置为空，则直接插入，时间复杂度是O(1)，如果达到扩容条件还会扩容。&lt;/p&gt;
&lt;p&gt;  （3）如果数组的这个index已经有值了，那就依次遍历，比价Key来判断是否已经存在，存在就修改该节点的Value，不存在就新建节点并插在链尾。&lt;br/&gt;如果链表长度达到了8，此时会升维形成红黑树。如果还在链表阶段，时间复杂度是O(1)+O(k)，这里O(1)是插入，O(k)是遍历，由于不会超过8，所以也可以认为是O(1)。在形成红黑树时，还会判断容量是否小于64，如果是，会扩容。&lt;/p&gt;
&lt;p&gt;  （4）在第3步中，可能插入前已经是红黑树了，那就在红黑树中先查找是否存在，存在则修改，不存在则新建并插入。这样，时间复杂度是O(l)+O(logK)。所以综合来看，可以理解为插入一个元素时时间复杂度最好是O(1),最坏是O(logn)&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt; &lt;strong&gt;4、获取元素&lt;/strong&gt;&lt;br/&gt;     获取元素的方法是get(K),基本步骤是：&lt;br/&gt;  （1）根据Key的hash值确定其在数组中的index。&lt;br/&gt;  （2）先判断数组的这个地方是否有节点，没有则返回null。&lt;br/&gt;  （3）如果有，则根据hash和Key判断第一个节点是否为目标节点，是则返回其Value。否则继续判断，根据第一个节点是TreeNode实例来判断当前是链表还是红黑树。 同样根据hash值和Key来确定是否存在，存在则返回Value，否则返回null。所以时间复杂度也和插入时类似，最好时是O(1),最坏时是O(logn)。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt; &lt;strong&gt;5、删除元素&lt;/strong&gt;&lt;br/&gt;       删除元素的方法是remove(K),先和获取元素一样查找该节点，删除，然后调整结构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Key为null时的处理&lt;/strong&gt;&lt;br/&gt;      HashMap的K和V均可以为null，当Key为null时有，其hash值定为0；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;7、做算法题时常用的方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Map&amp;lt;Object, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; map.put(K,V); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存取KV对&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; map.get(K); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不存在，则返回null&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; map.getOrDefault(K,defaultValue); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相比get方法，会得到设定的默认值defaultValue。该方法很有用&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; map.entrySet(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有KV对的实体Set，其元素类型为Map.Entry&amp;lt;K, V&amp;gt;。HashMap中的Node，TreeNode都是其子类。&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; map.keySet(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Key的集合Set&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; map.values(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取value的集合Collection,区别于Set&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; map.containsKey(K); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否包含指定Key的Entry&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; map.containsValue(V); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否包含指定Value的Entry&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; map.remove(K); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定Key的Entry&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; map.putAll(otherMap); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制给定的map&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; map.size(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Entry的数量&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; map.clear(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除所有Entry&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; map.isEmpty(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相关阅读&lt;/p&gt;
&lt;p&gt;https://tech.meituan.com/2016/06/24/java-hashmap.html&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 31 Oct 2020 15:19:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>在刷leetcode的算法题时，HashMap需要大量使用，而且也是面试的高频问题。这里记录了HashMap一些增、删、改、查的实现细节和时间复杂度，罗列了一些比较有用的方法，以及其它的一些细节。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/13908259.html</dc:identifier>
</item>
<item>
<title>drf 认证校验及源码分析 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13908204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13908204.html</guid>
<description>&lt;p&gt;　　 认证校验是十分重要的，如用户如果不登陆就不能访问某些接口。&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;drf&lt;/code&gt;中认证的写法流程如下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;　　 1.写一个类，继承BaseAuthentication，并且覆写其authenticate方法&lt;/p&gt;
&lt;p&gt;　　 2.当认证通过后应该返回两个值，并且第一个值会传递给request.user这个属性中，第二个值将会传递给request.auth这个属性中&lt;/p&gt;
&lt;p&gt;　　 3.如果认证失败，则抛出异常APIException或者AuthenticationFailed，它会自动捕获并返回&lt;/p&gt;
&lt;p&gt;　　 4.当前认证类设置是全局使用还是局部使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　 我们有一个登录功能，并且还有一个查询商品的接口，只有当用户登录后才能进行查询，否则就不可以。&lt;/p&gt;
&lt;h2&gt;模型表&lt;/h2&gt;
&lt;p&gt;　　 两张表如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models


class User(models.Model):
    # 用户
    user_id = models.AutoField(primary_key=True)
    user_name = models.CharField(max_length=32)
    user_password = models.CharField(max_length=32)
    user_token = models.CharField(max_length=64,unique=True,null=True)  # token，唯一

    def __str__(self):
        return self.user_name

    class Meta:
        db_table = &quot;&quot;
        managed = True
        verbose_name = &quot;User&quot;
        verbose_name_plural = &quot;Users&quot;

class Merchandise(models.Model):
    # 商品
    merchandise_id = models.AutoField(primary_key=True)
    merchandise_name = models.CharField(max_length=32)
    merchandise_price = models.IntegerField()

    def __str__(self):
        return self.merchandise_name

    class Meta:
        db_table = &quot;&quot;
        managed = True
        verbose_name = &quot;Merchandise&quot;
        verbose_name_plural = &quot;Merchandises&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 用户表的数据如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201031170412050.png&quot; alt=&quot;image-20201031170412050&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 商品表的数据如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201031171236819.png&quot; alt=&quot;image-20201031171236819&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 现在，只有当用户登录后，才能够访问商品的接口。&lt;/p&gt;
&lt;p&gt;　　 也就是说，用户的&lt;code&gt;token&lt;/code&gt;自动如果为空，将会被认为没有登陆。&lt;/p&gt;
&lt;h2&gt;序列类&lt;/h2&gt;
&lt;p&gt;　　 下面是序列类，我们只展示商品，用户列表将不会展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from rest_framework.serializers import ModelSerializer
from . import models

class MerchandiseModelSerializer(ModelSerializer):
    class Meta:
        model = models.Merchandise
        fields = &quot;__all__&quot;
        
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;视图&lt;/h2&gt;
&lt;p&gt;　　 视图，我们只写了关于用户登录与商品的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from uuid import uuid4
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.viewsets import ModelViewSet

from . import models
from . import ser
from . import authLogin  # 导入认证的文件

class MerchandiseAPI(ModelViewSet):
    queryset = models.Merchandise.objects.all()
    serializer_class = ser.MerchandiseModelSerializer

class Login(APIView):
    def post(self,request):
        # 代表用户登录
        login_msg = {
            &quot;user_name&quot;: request.data.get(&quot;user_name&quot;),
            &quot;user_password&quot;: request.data.get(&quot;user_password&quot;),
        }
        user_obj = models.User.objects.filter(**login_msg).first()
        if user_obj:
            token = uuid4()  # 生成随机字符串
            user_obj.user_token = token
            user_obj.save()
            return Response(data=&quot;登录成功&quot;,headers={&quot;token&quot;:token})  # 返回随机字符串
        else:
            return Response(data=&quot;登录失败，用户名或密码错误&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;url&lt;/h2&gt;
&lt;p&gt;　　 使用自动生成路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib import admin
from django.urls import path, re_path
from rest_framework.routers import SimpleRouter

from app01 import views

router = SimpleRouter()
router.register(&quot;merchandises&quot;,views.MerchandiseAPI)

urlpatterns = [
    path('admin/', admin.site.urls),
    path('login/',views.Login.as_view()),
]
urlpatterns.extend(router.urls)


&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;认证类&lt;/h2&gt;
&lt;p&gt;　　 接下来我们要书写一个认证类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from rest_framework.authentication import BaseAuthentication  # 继承的基类
from rest_framework.exceptions import AuthenticationFailed  # 异常
from . import models
from django.http import request

class LoginVerify(BaseAuthentication):
    def authenticate(self, request):
        token = request.META.get(&quot;HTTP_TOKEN&quot;)
        # 如果在请求头中设置的是token的key名，获取时一定要全大写并加上HTTP
        if not token:
            raise AuthenticationFailed(&quot;请求失败，请求头中缺少token&quot;)
        else:
            user_obj = models.User.objects.filter(user_token=token).first()  # 获取用户对象
            if user_obj:
                return user_obj,user_obj.user_token  # 返回用户本身和token。这样request.user里面就能拿到该用户了
            else:
                raise AuthenticationFailed(&quot;token不存在，用户不存在，请不要伪造登录&quot;)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;局部使用&lt;/h2&gt;
&lt;p&gt;　　 只需要在商品接口中设置一个类属性，该接口便会进行认证。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MerchandiseAPI(ModelViewSet):
    authentication_classes = [authLogin.LoginVerify]  # 使用认证
    queryset = models.Merchandise.objects.all()
    serializer_class = ser.MerchandiseModelSerializer 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;全局使用&lt;/h2&gt;
&lt;p&gt;　　 只需要在&lt;code&gt;settings.py&lt;/code&gt;中进行配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;REST_FRAMEWORK={
    &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;:[&quot;app01.authLogin.LoginVerify&quot;,]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果想取消某个接口的认证，则在其中设置类属性&lt;code&gt;authentication_classes&lt;/code&gt;是一个空列表。&lt;/p&gt;
&lt;p&gt;　　 如下所示，登录功能不需要验证，我们对他取消掉即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Login(APIView):
        authentication_classes = []
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;流程分析&lt;/h2&gt;
&lt;p&gt;　　 由于&lt;code&gt;modelViewSet&lt;/code&gt;继承自&lt;code&gt;APIView&lt;/code&gt;，所以我们直接看&lt;code&gt;as_view()&lt;/code&gt;，在下面这一句代码中，将会对&lt;code&gt;request&lt;/code&gt;进行二次封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def dispatch(self, request, *args, **kwargs):

        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)  # 这里
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 在二次封装中，实例化出了一个&lt;code&gt;Request&lt;/code&gt;对象并返回了，在实例化时，会调用&lt;code&gt;self.get_authenticators()&lt;/code&gt;方法，此时的&lt;code&gt;self&lt;/code&gt;是我们自定义的视图类，切记这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def initialize_request(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        Returns the initial request object.
        &quot;&quot;&quot;
        parser_context = self.get_parser_context(request)

        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),  # 看这里，获取认方式
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 下面是&lt;code&gt;get_authenticators()&lt;/code&gt;的代码，可以看见它会循环&lt;code&gt;self.authentication_classes&lt;/code&gt;这个可迭代对象，如果你没有传递这个可迭代对象，那么该对象是一个默认的设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def get_authenticators(self):
        return [auth() for auth in self.authentication_classes] # ( authLogin.LoginVerify调用，实例化 )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果没有传递，将会找到&lt;code&gt;APIView&lt;/code&gt;中的默认设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     class APIView(View):
        renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
        parser_classes = api_settings.DEFAULT_PARSER_CLASSES
        authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES  # 默认的设置，默认的认证类，可以自己看一下
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果有进行传递，可以发现它是使用了一个括号，这就代表会调用，由于传入的是一个类，所以它会进行实例化。&lt;/p&gt;
&lt;p&gt;　　 所以我们可以认为&lt;code&gt;request.authenticators&lt;/code&gt;这个参数是一个&lt;code&gt;tuple&lt;/code&gt;，里面包含了认证类的实例化对象。&lt;/p&gt;
&lt;p&gt;　　 然后，&lt;code&gt;request&lt;/code&gt;就被二次包装完毕了。接下来执行 &lt;code&gt;self.initial()&lt;/code&gt;，现在的&lt;code&gt;self&lt;/code&gt;依然是我们自定义的视图类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def dispatch(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        `.dispatch()` is pretty much the same as Django's regular dispatch,
        but with extra hooks for startup, finalize, and exception handling.
        &quot;&quot;&quot;
        self.args = args
        self.kwargs = kwargs
        request = self.initialize_request(request, *args, **kwargs)
        self.request = request
        self.headers = self.default_response_headers  # deprecate?

        try:
            self.initial(request, *args, **kwargs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 下面是&lt;code&gt;self.inital()&lt;/code&gt;的代码，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def initial(self, request, *args, **kwargs):

        self.format_kwarg = self.get_format_suffix(**kwargs)

        self.perform_authentication(request)  # 只看这个，认证相关的
        self.check_permissions(request)
        self.check_throttles(request)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 到了&lt;code&gt;self.perform_authentication()&lt;/code&gt;时，它传递进了个&lt;code&gt;request&lt;/code&gt;，并且会去找&lt;code&gt;user&lt;/code&gt;这个属性抑或是被&lt;code&gt;property&lt;/code&gt;装饰的方法，所以我们需要到&lt;code&gt;Request&lt;/code&gt;这个类中去找，需要注意的是如果&lt;code&gt;user&lt;/code&gt;是一个方法，这代表会自动传递进&lt;code&gt;self&lt;/code&gt;，此时的&lt;code&gt;self&lt;/code&gt;则是我们经过二次封装的&lt;code&gt;request&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;　　 可以发现它是一个被装饰的方法。很显然我们没有&lt;code&gt;_user&lt;/code&gt;这个方法或属性，会执行&lt;code&gt;with&lt;/code&gt;语句，其实直接看&lt;code&gt;self._authenticate()&lt;/code&gt;即可。再次强调，此次的&lt;code&gt;self&lt;/code&gt;是二次封装的&lt;code&gt;request&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @property
    def user(self):
        if not hasattr(self, '_user'):
            with wrap_attributeerrors():
                self._authenticate()
        return self._user
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 下面是整个代码的核心。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def _authenticate(self):
 
        for authenticator in self.authenticators:  # 循环认证类对象 ( authLogin.LoginVerify的实例化 )
            try:
                user_auth_tuple = authenticator.authenticate(self) # 这里会找authenticate方法并将request对象进行传递，我们的认证类继承了BaseAuthentication这个类，它会实现一个接口方法， 但会抛出异常。
            except exceptions.APIException:   # 如果没有实现接口方法，或在验证时抛出异常都会被这里捕获
                self._not_authenticated()  # 执行这里 self.user将会是匿名用户AnonymousUser，而self.auth则是None
                raise

            if user_auth_tuple is not None:  # 如果返回的值不是空
                self._authenticator = authenticator  
                self.user, self.auth = user_auth_tuple  # 分别赋值给self.user，以及self.auth中
                return  # 返回

        self._not_authenticated()  # 上面有认证对象就会return，没有还是设置匿名用户和None
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;最后总结&lt;/h2&gt;
&lt;p&gt;　　 其实看了源码后，你可以发现我们的认证类可以不继承&lt;code&gt;BaseAuthentication&lt;/code&gt;，但是推荐继承会更规范，因为这个基类实现了抽象接口。&lt;/p&gt;
&lt;p&gt;　　 其次，它将返回的两个值分别赋值给了&lt;code&gt;request.user&lt;/code&gt;以及&lt;code&gt;request.auth&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 如果你没有返回值，那么对应的，&lt;code&gt;request.user&lt;/code&gt;就是匿名用户，&lt;code&gt;request.auth&lt;/code&gt;就是&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 如果你没有配置认证类，其实它会走默认的认证类。&lt;/p&gt;
&lt;p&gt;　　 老规矩，关于配置认证类时依旧是先用局部的，再用全局的，最后是用默认的，如果你的上面的源码确实有感觉了的话，应该能够看懂。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Oct 2020 14:58:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>认证校验 认证校验是十分重要的，如用户如果不登陆就不能访问某些接口。 drf中认证的写法流程如下： 1.写一个类，继承BaseAuthentication，并且覆写其authenticate方法 2.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13908204.html</dc:identifier>
</item>
<item>
<title>Linux下如何使用X86 CPU的GPIO - 木多</title>
<link>http://www.cnblogs.com/wsg1100/p/13908049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wsg1100/p/13908049.html</guid>
<description>&lt;h2 id=&quot;1前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;在arm嵌入式开发中，各个外设具有固定的物理地址，我们可以直接通过芯片手册来编写驱动配置后使用。但是在x86中有所不同，所有外设控制器集成在PCH（曾经的南桥）中，每个外设都是作为一个PCI设备挂在PCH的PCI总线上，PCH再通过DMI与CPU相联。对于标压处理器H/K系列（也就是我们台式机），南桥还在主板上，对于x86移动处理器(Y/U结尾系列)，已将PCH和CPU集成到同一封装中，与如今各类SOC类似，如下（详见&lt;a href=&quot;https://www.intel.com/content/www/us/en/design/products-and-solutions/processors-and-chipsets/kaby-lake-u-y/technical-library.html?grouping=EMT_Content%20Type&amp;amp;sort=title:asc&quot;&gt;datasheet&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wsg-blogs-pic.oss-cn-beijing.aliyuncs.com/xenomai/image-20201031102153079.png&quot; alt=&quot;image-20201031102153079&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于x86中每个外设是一个PCI设备，所以我们要使用某个外设就需要为其分配内存空间映射、IRQ和I/O基址，x86中这些资源配置是由BIOS（UEFI）完成的，因为每块主板设计和外设使用不一样，就需要不一样的配置，所以不同的主板厂商需要定制自己主板的BIOS 。&lt;/p&gt;
&lt;p&gt;BIOS配置好主板使用的外设后，一些BIOS（UEFI）通过ACPI(高级配置和电源接口）的DSDT来传递设备信息（类似arm设备树，但功能更强）给操作系统，操作系统解析获取到这些设备信息后我们才能在驱动配置和使用这个外设，但ACPI对各个操作系统有兼容性问题，这就会出现在Windows设备管理器能看到该设备，到linux下什么就也没有的现象，因为桌面CPU大多都是用的Windows系统，所以大部分X86硬件厂商的BIOS主要兼容Windows为主。BIOS又是我们普通开发者无法接触修改的东西，不兼容怎么办。&lt;/p&gt;
&lt;p&gt;本文说的GPIO就是这么个问题，linux下无法使用，由于涉及的东西有点多，所以简单介绍在如何将x86工控机引出的GPIO使用起来的(注意：是CPU的GPIO引脚，不是Super IO的GPIO）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CPU :英特尔7代低压处理器( Kaby Lake) i5-7200U/赛扬3865U&lt;/p&gt;
&lt;p&gt;linux:linux 4.0以上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2linux-pinctrl子系统&quot;&gt;2.linux pinctrl子系统&lt;/h2&gt;
&lt;p&gt;要使用gpio需要先看一下linux系统PINCTRL子系统，层级如下所示（图片来源蜗窝科技）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wsg-blogs-pic.oss-cn-beijing.aliyuncs.com/xenomai/pinctrl.png&quot; alt=&quot;pinctrl&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最底层是硬件控制器，其上是操作这些硬件的相关驱动（pin controller driver），不同的控制器有不同底层驱动，一般由芯片厂商BSP完成；pin controller driver初始化的时候会向pin control core模块注册pin control设备（通过pinctrl_register这个bootom level interface）。pin control core模块是一个硬件无关模块，它抽象了所有pin controller的硬件特性，仅仅从用户（各个driver就是pin control subsystem的用户）角度给出了top level的接口函数，这样，&lt;strong&gt;各个driver不需要关注pin controller的底层硬件相关的内容，使用时直接向pinctrl子系统申请IO资源即可。&lt;/strong&gt;关于linux GPIO与pinctrl子系统信息，详见&lt;a href=&quot;http://www.wowotech.net/sort/gpio_subsystem&quot;&gt;蜗窝科技-GPIO子系统&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;pin controller driver成功注册到pin control core后，我们通过pin control core导出到sysfs的文件就可以直接操作一个GPIO，使其输入输出，而不需要专门去写一个驱动模块。&lt;/p&gt;
&lt;h2 id=&quot;3-pin-controller-driver&quot;&gt;3. pin controller driver&lt;/h2&gt;
&lt;p&gt;搞嵌入式的一定对platform bus非常熟悉，pin controller driver的注册同样离不开platform bus，driver与device必须经过某种匹配后，才能进一步执行probe注册到系统中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wsg-blogs-pic.oss-cn-beijing.aliyuncs.com/xenomai/pinctrl-bus.png&quot; alt=&quot;pinctrl-bus&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合前言中对x86设备的描述，platform bus可通过以下两种方式来判断driver和device是否匹配。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方式一，由BIOS通过ACPI 中DSDT传递控制器设备节点描述给linux（可类比设备树），linux内核启动过程中解析处理DSDT信息，自动构造device设备并添加到Platform bus，添加过程中匹配ACPI_ID,触发执行pin controller driver 的&lt;code&gt;probe()&lt;/code&gt;函数。&lt;/li&gt;
&lt;li&gt;方式二，linux扫描PCI总线设备创建设备并添加，PCI驱动匹配vendor、device、class后触发执行pin controller driver 的&lt;code&gt;probe()&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;别忘了前提，启动时BIOS必须为使用的PCI设备分配好设备中断号(中断vector)、映射空间地址等我们才能用。那对于我们的GPIO设备linux系统使用的是哪种方式呢，这需要到源码中来看，首先七代系列CPU linux pinctrl driver源码文件为&lt;code&gt;\drivers\pinctrl\intel\pinctrl-sunrisepoint.c&lt;/code&gt;，看如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;static const struct acpi_device_id spt_pinctrl_acpi_match[] = {
        { &quot;INT344B&quot;, (kernel_ulong_t)&amp;amp;sptlp_soc_data },
        { &quot;INT345D&quot;, (kernel_ulong_t)&amp;amp;spth_soc_data },
        { }
};
MODULE_DEVICE_TABLE(acpi, spt_pinctrl_acpi_match);
.....
static struct platform_driver spt_pinctrl_driver = {
        .probe = spt_pinctrl_probe,
        .driver = {
                .name = &quot;sunrisepoint-pinctrl&quot;,
                .acpi_match_table = spt_pinctrl_acpi_match,
                .pm = &amp;amp;spt_pinctrl_pm_ops,
        },
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用的是ACPI模式，那么驱动的注册逻辑应该如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wsg-blogs-pic.oss-cn-beijing.aliyuncs.com/xenomai/PINCTRL.png&quot; alt=&quot;PINCTRL&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中driver把系统中所有的pin描述出来，并将driver注册到platform bus。driver需要对应的device才能工作，&lt;strong&gt;但是linux因为ACPI的兼容性问题，linux并没有解析DSDT并创建出GPIO 相关的device，所以没有触发执行probe来将pin controller driver注册到pin control core中，pinctrl子系统没有工作当然无法使用&lt;/strong&gt;。到这里我们去解决内核对ACPI的解析（或者说兼容性问题）显然是不太现实的(自己太菜(╯﹏╰))，有没有其他办法呢？&lt;/p&gt;
&lt;p&gt;先阅读源码看看，probe()执行过程中需要用到device的哪些resource，只要我们能获取到这些resource，自己手动构造一个device注册到platform bus不就行了，O(∩_∩)O哈哈~。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int intel_pinctrl_probe(struct platform_device *pdev,
                        const struct intel_pinctrl_soc_data *soc_data)
{
    ......
    for (i = 0; i &amp;lt; pctrl-&amp;gt;ncommunities; i++) {
        ......
                res = platform_get_resource(pdev, IORESOURCE_MEM,
                                            community-&amp;gt;barno);//0
                regs = devm_ioremap_resource(&amp;amp;pdev-&amp;gt;dev, res);
                ......
        }
        ......
        irq = platform_get_irq(pdev, 0);
    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到pin controller driver需要pincontrler 的地址空间和使用的中断号两部分资源，其中地址空间是三个，因为所有GPIO由三个GPIO控制器组成，三个GPIO控制器共享相同的中断线，三个GPIO控制器作为一个PCI设备。如何获取这两个信息呢？&lt;/p&gt;
&lt;h2 id=&quot;4手动构造device&quot;&gt;4.手动构造device&lt;/h2&gt;
&lt;p&gt;上面通过阅读源代码得知，&lt;strong&gt;intel-pinctrl&lt;/strong&gt;需要&lt;strong&gt;pincontrler&lt;/strong&gt; 地址空间、和使用的中断号两部分资源。&lt;/p&gt;
&lt;p&gt;地址空间起始地址可通过PCI 设备&lt;strong&gt;P2SB Bridge (D31:F1)&lt;/strong&gt;获得。中断&lt;strong&gt;vector&lt;/strong&gt;由&lt;strong&gt;BIOS&lt;/strong&gt;配置，反编译&lt;strong&gt;BIOS&lt;/strong&gt;给linux传递的&lt;strong&gt;ACPI&lt;/strong&gt;信息，看是否有中断vector相关信息：&lt;/p&gt;
&lt;p&gt;在板子上进入&lt;code&gt;/sys/firmware/acpi/tables&lt;/code&gt;，将目录下所有文件考出，使用acpi工具&lt;code&gt;iasl&lt;/code&gt;对DSDT文件进行反编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;iasl -d DSDT.dat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到&lt;code&gt;AML&lt;/code&gt;文件 &lt;code&gt;DSDT.dsl&lt;/code&gt;,里面包含&lt;strong&gt;BIOS&lt;/strong&gt;开发的各设备节点信息。&lt;/p&gt;
&lt;p&gt;打开 &lt;code&gt;DSDT.dsl&lt;/code&gt;并找到pin controler设备节点描述，只需要搜索驱动里的&quot;INT344B&quot;或&quot;INT345D&quot;就能定位到。到这里我们也明白了，为什么驱动里的&lt;code&gt;spt_pinctrl_acpi_match[]&lt;/code&gt;有两像，原来是一个代表标压处理器（H）,一个代表低压处理器（U）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Device (GPI0)
        {
            Method (_HID, 0, NotSerialized)  // _HID: Hardware ID
            {
                If ((PCHV () == SPTH))
              {
                    If ((PCHG == 0x02))
                  {
                        Return (&quot;INT3451&quot;)
                    }
                    Return (&quot;INT345D&quot;)    //表示7代标压处理器
                }
                Return (&quot;INT344B&quot;)              //表示7代低压处理器
            Name (LINK, &quot;\\_SB.PCI0.GPI0&quot;)
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Name (RBUF, ResourceTemplate ()
                {
                    Memory32Fixed (ReadWrite,
                        0x00000000,         // Address Base
                        0x00010000,         // Address Length  地址空间大小
                        _Y2E)
                    Memory32Fixed (ReadWrite,
                        0x00000000,         // Address Base
                        0x00010000,         // Address Length   地址空间大小
                        _Y2F)
                    Memory32Fixed (ReadWrite,
                        0x00000000,         // Address Base
                        0x00010000,         // Address Length   地址空间大小
                        _Y31)
                    Interrupt (ResourceConsumer, Level, ActiveLow, Shared, ,, _Y30)
                    {
                        0x0000000E,             //中断号
                    }
                })
                                CreateDWordField (RBUF, \_SB.PCI0.GPI0._CRS._Y2E._BAS, COM0)  // _BAS: Base Address
              CreateDWordField (RBUF, \_SB.PCI0.GPI0._CRS._Y2F._BAS, COM1)  // _BAS: Base Address
              CreateDWordField (RBUF, \_SB.PCI0.GPI0._CRS._Y30._INT, IRQN)  // _INT: Interrupts
              COM0 = (SBRG + 0x00AF0000)
              COM1 = (SBRG + 0x00AE0000)
              CreateDWordField (RBUF, \_SB.PCI0.GPI0._CRS._Y31._BAS, COM3)  // _BAS: Base Address
              COM3 = (SBRG + 0x00AC0000)
              IRQN = SGIR /* \SGIR */
              Return (RBUF) /* \_SB_.PCI0.GPI0._CRS.RBUF */
                
       }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能看不懂上面面的信息，到底哪个是标压哪个是低压？没关系，我们去pin controller driver中，里面有注释，反推一下就知道&lt;code&gt;INT345D&lt;/code&gt;代表的是标压，&lt;code&gt;INT344B&lt;/code&gt;代表的是低压。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Sunrisepoint-LP */
static const struct pinctrl_pin_desc sptlp_pins[] = {
    ....
}
static const struct intel_pinctrl_soc_data sptlp_soc_data = {
        .pins = sptlp_pins,
    ...
}
.....
/* Sunrisepoint-H */
static const struct pinctrl_pin_desc spth_pins[] = {
    ....
}
static const struct intel_pinctrl_soc_data spth_soc_data = {
        .pins = spth_pins,
    ...
}
static const struct acpi_device_id spt_pinctrl_acpi_match[] = {
        { &quot;INT344B&quot;, (kernel_ulong_t)&amp;amp;sptlp_soc_data },
        { &quot;INT345D&quot;, (kernel_ulong_t)&amp;amp;spth_soc_data },
        { }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到正题，我们从 &lt;code&gt;DSDT.dsl&lt;/code&gt;获取得到中断号: 0xE，三个地址空间起始地址及大小。构建一个platform_device 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;linux/debugfs.h&amp;gt;
#include &amp;lt;linux/ioport.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/platform_device.h&amp;gt;

#define P2SB_PORTID_SHIFT 16
#define P2SB_PORT_GPIO3 0xAC
#define P2SB_PORT_GPIO2 0xAD    /*未使用*/
#define P2SB_PORT_GPIO1 0xAE
#define P2SB_PORT_GPIO0 0xAF

#define sbreg_addr 0xfd000000 /*Address Base*/

/*Community 0*/
#define SPT_PINCTRL_COMMUNITY0_OFFSET           sbreg_addr + (P2SB_PORT_GPIO0 &amp;lt;&amp;lt; P2SB_PORTID_SHIFT)
#define SPT_PINCTRL_COMMUNITY0_SIZE             0x00010000
/*Community 1*/
#define SPT_PINCTRL_COMMUNITY1_OFFSET           sbreg_addr + (P2SB_PORT_GPIO1 &amp;lt;&amp;lt; P2SB_PORTID_SHIFT)
#define SPT_PINCTRL_COMMUNITY1_SIZE             0x00010000 
/*Community 2*/
#define SPT_PINCTRL_COMMUNITY2_OFFSET           sbreg_addr + (P2SB_PORT_GPIO2 &amp;lt;&amp;lt; P2SB_PORTID_SHIFT)
#define SPT_PINCTRL_COMMUNITY2_SIZE             0x00010000
/*Community 3*/
#define SPT_PINCTRL_COMMUNITY3_OFFSET           sbreg_addr + (P2SB_PORT_GPIO3 &amp;lt;&amp;lt; P2SB_PORTID_SHIFT)
#define SPT_PINCTRL_COMMUNITY3_SIZE             0x00010000


static struct resource intel_pinctrl_dev_resources[] = {
        /* iomem resource */
        DEFINE_RES_MEM_NAMED(SPT_PINCTRL_COMMUNITY0_OFFSET, SPT_PINCTRL_COMMUNITY0_SIZE, NULL),
        DEFINE_RES_MEM_NAMED(SPT_PINCTRL_COMMUNITY1_OFFSET, SPT_PINCTRL_COMMUNITY1_SIZE, NULL),
//      DEFINE_RES_MEM_NAMED(SPT_PINCTRL_COMMUNITY2_OFFSET, SPT_PINCTRL_COMMUNITY2_SIZE, NULL),/*未使用*/
        DEFINE_RES_MEM_NAMED(SPT_PINCTRL_COMMUNITY3_OFFSET, SPT_PINCTRL_COMMUNITY3_SIZE, NULL),
        /* irq resource */
        DEFINE_RES_IRQ(0x0E), /*反编译BIOS DSDT获取*/
};

static struct platform_device intel_pinctrl_device = {
        .name           = &quot;sunrisepoint-pinctrl&quot;,
        .id             = -1,
        .resource       = intel_pinctrl_dev_resources,
        .num_resources  = ARRAY_SIZE(intel_pinctrl_dev_resources),
};

static int __init intel_spt_device_init(void)
{
        return platform_device_register(&amp;amp;intel_pinctrl_device);
}
module_init(intel_spt_device_init);

static void __exit intel_spt_device_exit(void)
{
        platform_device_unregister(&amp;amp;intel_pinctrl_device);
}
module_exit(intel_spt_device_exit);

MODULE_AUTHOR(&quot;wsg1100&quot;);
MODULE_DESCRIPTION(&quot;Intel  sunrisepoint pinctrl device&quot;);
MODULE_LICENSE(&quot;GPL v2&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随内核编译后，加载模块，intel pinctrl子系统正常工作，(^o^)/。&lt;br/&gt;&lt;strong&gt;注意，相同平台，不同BIOS PCI信息可能不同！文中提供的只是一种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;版权声明：本文为本文为博主原创文章，转载请注明出处，博客地址：&lt;a href=&quot;https://www.cnblogs.com/wsg1100/%E3%80%82%E5%A6%82%E6%9C%89%E9%94%99%E8%AF%AF%EF%BC%8C%E6%AC%A2%E8%BF%8E%E6%8C%87%E6%AD%A3%E3%80%82&quot;&gt;https://www.cnblogs.com/wsg1100/。如有错误，欢迎指正。&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Oct 2020 14:25:00 +0000</pubDate>
<dc:creator>木多</dc:creator>
<og:description>如何在linux上使用X86 CPU的gpio？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wsg1100/p/13908049.html</dc:identifier>
</item>
<item>
<title>JVM的艺术—类加载器篇（二） - 雕爷的架构之路</title>
<link>http://www.cnblogs.com/tomakemyself/p/13907994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tomakemyself/p/13907994.html</guid>
<description>&lt;p&gt;分享是价值的传递，喜欢就点个赞&lt;/p&gt;
&lt;h4 id=&quot;引言&quot;&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;今天我们继续来深入的剖析类加载器的内容。上节课我们讲了类加载器的基本内容，没看过的小伙伴请加关注。今天我们继续。&lt;/p&gt;
&lt;h2 id=&quot;什么是定义类加载器和初始化类加载器？&quot;&gt;什么是定义类加载器和初始化类加载器？&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义类加载器：假设我们的某一个类是由ExtClassLoader加载的，那么ExtClassLoader称为该类的定义类加载器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;初始化加载器：能够返回Class对象引用的都叫做该类的初始类加载器，比如类A是由我们的ExtClassLoader加载，那么&lt;/p&gt;
&lt;p&gt;ExtClassLoader是该类的定义类加载器，也是该类的初始类加载器，而我们的AppClassLoader也能返回我们A类的引用&lt;/p&gt;
&lt;p&gt;那么AppClassLoader也是该类的初始类加载器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是类加载器的双亲委派模型？&quot;&gt;什么是类加载器的双亲委派模型？&lt;/h2&gt;
&lt;p&gt;上篇文章我们提到了类加载器的双亲委派模型，也可以称为双亲委托模型。今天这篇文章我们就来把这个概念给讲明白。&lt;/p&gt;
&lt;p&gt;概念：用一种简单的方式去描述双亲委托的概念。可以分为两个部分去理解&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;h5 id=&quot;1委托&quot;&gt;1委托:&lt;/h5&gt;
&lt;p&gt;jvm加载类的时候是通过双亲委派的方式去加载，自下而上的去委托。&lt;/p&gt;
&lt;p&gt;自定义类加载器需要加载类时，先委托应用类加载器去加载，然后应用类加载器又向扩展类加载器去委托，扩展类加载器在向启动类加载器去委托。&lt;/p&gt;
&lt;p&gt;如果启动类加载器不能加载该类。那么就向下加载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;h5 id=&quot;2加载&quot;&gt;2加载:&lt;/h5&gt;
&lt;p&gt;jvm加载类的时候是通过双亲委派的方式去加载委托，但是加载的时候是由上向下去加载的，当委托到最顶层启动类加载器的时候，无法在向上委托，那么&lt;/p&gt;
&lt;p&gt;启动类加载器就开始尝试去加载这个类，启动类加载器加载不了就向下交给扩展类加载器去加载，扩展类加载器加载不了就继续向下委托交给应用类加载器&lt;/p&gt;
&lt;p&gt;去加载，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果文字描述你还不清楚什么是双亲委托机制，那么我画了一幅图可以更清楚类加载的过程。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220833166-850903438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图，我们知道更能清楚的知道，双亲委托模型的工作机制，用一句简单的话说，就是需要加载一个类的时候，向上委托，向下加载。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：在双亲委派机制中，各个加载器按照父子关系形成树型结构,除了根加载器以外,每一个加载器有且只有一个父加载器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，我也从jdk底层源码的角度给大家画了一张类加载的主要过程，图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220834231-667359566.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是类加载器加载一个类的重要过程步骤。希望各位小伙儿可以结合源码的方式，仔细再研究一下。其实还挺好理解的。&lt;/p&gt;
&lt;p&gt;下面咱们再说说，java采用双亲委托的方式去加载类，这样做的好处是什么呢？&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;h3 id=&quot;双亲委派模型的好处&quot;&gt;双亲委派模型的好处&lt;/h3&gt;
&lt;p&gt;总所周知:java.lang.object类是所有类的父类，所以我们程序在运行期间会把java.lang.object类加载到内存中，假如java.lang.object类&lt;/p&gt;
&lt;p&gt;能够被我们自定义类加载器去加载的话，那么jvm中就会存在多份Object的Class对象，而且这些Class对象是不兼容的。&lt;/p&gt;
&lt;p&gt;所以双亲委派模型可以保证java核心类库下的类型的安全。&lt;/p&gt;
&lt;p&gt;借助双亲委派模型，我们java核心类库的类必须是由我们的启动类加载器加载的，这样可以确保我们核心类库只会在jvm中存在一份&lt;/p&gt;
&lt;p&gt;这就不会给自定义类加载器去加载我们核心类库的类。&lt;/p&gt;
&lt;p&gt;根据我们的演示案例，一个class可以由多个类加载器去加载，同时可以在jvm内存中存在多个不同版本的Class对象，这些对象是不兼容的。&lt;/p&gt;
&lt;p&gt;并且是不能相互转换的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是全盘委托加载？&quot;&gt;什么是全盘委托加载？&lt;/h3&gt;
&lt;p&gt;解释:假如我们的Person类是由我们的系统类APP类加载器加载的，而person类所依赖的Dog类也会委托给App系统类进 行加载，这个委托过程也遵循双亲委派模型。代码如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;person类代码中创建Dog实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;public class Person {&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public Person(){
  
      new Dog();
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class Dog {

    public Dog(){
        System.out.println(&quot;Dog 的构造函数&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MainClass02 {

    public static void main(String[] args) throws Exception {
        //创建自定义类加载器的一个实例，并且通过构造器指定名称
        Test01ClassLoader myClassLoader = new Test01ClassLoader(&quot;loader1&quot;);
        myClassLoader.setPath(&quot;I:\\test\\&quot;);
        Class&amp;lt;?&amp;gt; classz = myClassLoader.loadClass(&quot;com.test.Person&quot;);
        System.out.println(classz.getClassLoader());
        System.out.println(Dog.class.getClassLoader());
    }
}


运行结果：

sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$AppClassLoader@18b4aac2

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的运行结果，我们可以看出，当我们用自定义类加载器去加载我们的Person的时候，根据双亲委托模型，我们的Person并没有被自定义类加载（Test01ClassLoader）加载，而是被AppClassloader加载成功，同时根据全盘委托规则，我们的Dog类也被AppClassLoader加载了。所以大家一定要记住这个至关重要的结论。为我们后面的学习打下坚实的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们在看一个例子。我们把类路径下的Person.class文件删除掉，然后再运行一下上面的main函数，看看结果。代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220834638-787124842.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过那行结果我们看出，Person类是由我们的自定义类加载器加载的。那为什么Dog类没有进行全盘委托的，这是因为双亲委托模型的缘故，我们的类路径下并没有Person类，故此AppClassLoader是无法加载我们的路径I：\\test\\下的com.test.Person.class文件的。所以Person类是由我们自定的类加载器加载的。再看Dog类，由于它的加载要遵循双亲委托模型，因为类路径下有Dog.class文件，所以AppClassLoader就可以加载Dog类。故此加载Dog类的ClassLoader是AppClassLoader。写到这里，大家对类加载已经有了一个非常深刻的理解。那么java为什么使用双亲委托模型的好处我相信已经不言而喻了。那么下面来说说双亲委托模型，有没有他的弊端呢，或者说有什么不好的地方嘛？我们可以打破这种双亲委托的方式去加载类嘛？下面我们来看一个例子。&lt;/p&gt;
&lt;h3 id=&quot;类加载器的命名空间&quot;&gt;&lt;strong&gt;类加载器的命名空间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;说到双亲委托模型的弊端，那我就离不开命名空间的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类加载器的命名空间&lt;/strong&gt; &lt;strong&gt;是由类加载器本身以及所有父加载器所加载出来的binary name(full class name)组成.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①:在同一个命名空间里，不允许出现二个完全一样的binary name。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②:在不同的命名空间种，可以出现二个相同的binary name。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：同一个Person.class文件 被我们的不同的类加载器去加载，那么我们的jvm内存中会生成二个对应的Person的Class对象，而且这二个对应的Class对象是相互不可见的(通过Class对象反射创建的实例对象相互是不能够兼容的不能相互转型**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③:子加载器的命名空间中的binary name对应的类中可以访问 父加载器命名空间中binary name对应的类，反之不行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面准备了一张图，以便于大家的理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220834850-1772156537.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图就很好的解释了命名空间的概念。大家可以再好好的体会一下。&lt;/p&gt;
&lt;p&gt;我们光画图，光用嘴说并不是一种很有力的证据，就如同我写在这篇博文的时候所提，我们在学习和掌握某个概念的时候，就必须要拿出有力的证据，来证明自己的猜想或者是观点，那我们就举一个例子。来验证一下我们上面的理论是否正确。代码如下：&lt;/p&gt;
&lt;p&gt;这是Person类的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

public class Person {

    public Person() {
        new Dog();
        System.out.println(&quot;Dog的classLoader:--&amp;gt;&quot;+ Dog.class.getClassLoader());
    }

    static{
        System.out.println(&quot;person类被初始化了&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是Dog类的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

public class Dog {

    public Dog(){
        System.out.println(&quot;Dog 的构造函数&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的验证思路是这样的，首先我们把Person类的Class文件放到启动类加载器的加载目录下（C:\Program Files\Java\jdk1.8.0_144\jre\classes 这是启动类加载器的加载目录）来达到Person类交给启动类加载器加载的目的。&lt;/p&gt;
&lt;p&gt;然后呢，我们让Dog类去被AppClassLoader（系统类加载器去加载）。然后我们在Person类中去访问Dog类。看看能否访问成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试环境:把我们的Person.class放置在C:\Program Files\Java\jdk1.8.0_131\jre\classes这个目录下，那么我们的Person.class就会被我们的启动类加载器加载,而我们的Dog类是被AppClassLoader进行加载，我们的Person类 中引用我们的Dog类会抛出异常.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建main方法进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import java.lang.reflect.Method;

/**
 * jvm 类加载器 第一章
 * @author 奇客时间-时光
 * 自定义类加载器——命名空间
 * 测试父加载所加载的类，不能访问子加载器所加载的类。
 */
public class MainClass02 {

    public static void main(String[] args) throws Exception {

        System.out.println(&quot;Person的类加载器:&quot;+Person.class.getClassLoader());

        System.out.println(&quot;Dog的类加载器:&quot;+Dog.class.getClassLoader());

        Class&amp;lt;?&amp;gt; clazz = Person.class;
        clazz.newInstance();


    }
}

运行结果：
    
&quot;C:\Program Files\Java\jdk1.8.0_144\bin\java.exe&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2\lib\idea_rt.jar=59226:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_144\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\rt.jar;I:\jvm\out\production\jvm-classloader&quot; com.test.MainClass02
Person的类加载器:null
Dog的类加载器:sun.misc.Launcher$AppClassLoader@18b4aac2
person类被初始化了
Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/test/Dog
        at com.test.Person.&amp;lt;init&amp;gt;(Person.java:7)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at java.lang.Class.newInstance(Class.java:442)
        at com.test.MainClass02.main(MainClass02.java:20)

Process finished with exit code 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220835298-1774542000.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;总结:通过上面的代码我们就可以看出来，我们在Person中去new一个Dog的实例的时候，并没有创建成功，而是抛出了Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/test/Dog这样的异常，这也就证明了，我们上面所说的结论（父加载器所加载的类，不能访问子加载所加载的类。）&lt;/p&gt;
&lt;p&gt;即启动类加载器所加载的类，不能访问系统类加载器所加载的类（AppClassLoader）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么肯定会有人问，我们的子加载器所加载的类，可以访问父加载器所加载的类嘛？我们不妨来证实一下，我们只需要改动一下MainClass02这个类的代码即可，让AppClassLoader去加载Dog类，让我们的自定义类加载器去加载我们的Person类。并在Person类中去访问Dog类。然后将之前C:\Program Files\Java\jdk1.8.0_131\jre\classes目录下的Person中的Class文件删除掉，另外还有把我们类路径下的Person文件删除掉，并且在I:\test\目录下添加com.test.Person.class文件。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import java.lang.reflect.Method;

/**
 * jvm 类加载器 第一章
 * @author 奇客时间-时光
 * 自定义类加载器
 * 测试子类加载器所加载的类，能否访问父加载器所加载的类。
 */
public class MainClass02 {

    public static void main(String[] args) throws Exception {
        //创建自定义类加载器的一个实例，并且通过构造器指定名称
        Test01ClassLoader myClassLoader = new Test01ClassLoader(&quot;loader1&quot;);
        myClassLoader.setPath(&quot;I:\\test\\&quot;);
        Class&amp;lt;?&amp;gt; classz = myClassLoader.loadClass(&quot;com.test.Person&quot;);
        System.out.println(classz.getClassLoader());

        System.out.println(&quot;Dog的类加载器:&quot;+Dog.class.getClassLoader());

        classz.newInstance();


    }
}

运行结果：
&quot;C:\Program Files\Java\jdk1.8.0_144\bin\java.exe&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2\lib\idea_rt.jar=60588:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_144\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_144\jre\lib\rt.jar;I:\jvm\out\production\jvm-classloader&quot; com.test.MainClass02
自己的类加载器被加载了
com.test.Test01ClassLoader@677327b6
Dog的类加载器:sun.misc.Launcher$AppClassLoader@18b4aac2
Dog 的构造函数

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果可以看出，Person是由我们的Test01ClassLoader自定义类加载器所加载的，那么它的父亲加载器是AppClassLoader，显然Dog类是由我们的AppClassLoader所加载的。故此代码正常运行，没有抛出异常，从而得出结论：&lt;/p&gt;
&lt;h4 id=&quot;1：父加载器所加载的类，不能访问子加载器所加载的类。&quot;&gt;1：父加载器所加载的类，不能访问子加载器所加载的类。&lt;/h4&gt;
&lt;h4 id=&quot;2：子加载器所加载的类，可以访问父加载器所加载的类。&quot;&gt;2：子加载器所加载的类，可以访问父加载器所加载的类。&lt;/h4&gt;
&lt;h3 id=&quot;双亲委托模型的弊端&quot;&gt;双亲委托模型的弊端&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;我们先看一段我们非常熟悉的数据库连接相关的代码片段。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/RUNOOB&quot;,&quot;root&quot;,&quot;123456&quot;);
Statement stmt = conn.createStatement();
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220836109-1206437826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;案例分析&quot;&gt;案例分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在上述图中的第五步为什么会用线程上下文加载器进行加载呢？&lt;/li&gt;
&lt;li&gt;在双亲委托模型的机制下，类的加载是由下而上的。即下层的加载器会委托上层进行加载。有些接口是Java核心库（rt.jar）提供的例如上面的createStatement接口，而Java核心库是由启动类加载器进行加载的。而这些接口的具体实现是来自不同的厂商(Mysql)。而具体的实现都是通过依赖jar包放到我们项目中的classPath下的。Java的启动类加载器/根类加载器是不会加载这些其他来源的jar包。&lt;/li&gt;
&lt;li&gt;我们都知道classPath下的jar包是由我们系统类加载器/应用加载器进行加载，根据我们双亲委托的机制父类加载器是看不到子类（系统类加载器）所加载的具体实现。createStatement 这个接口是由根类加载器进行加载的 而具体的实现又加载不了。在双亲委托的机制下，createStatement这个接口就无具体的实现。&lt;/li&gt;
&lt;li&gt;我们Java的开发者就通过给当前线程池设置上下文加载器的机制，就可以由设置的上下文加载器来实现对于接口实现类的加载。换句话说父类加载器可以使用当前线程上下文加载器加载父类加载器加载不了的一些接口的实现。完美了解决了由于SPI模型（接口定义在核心库中,而实现由各自的厂商以jar的形式依赖到我们项目中）的接口调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我提供了一张SPI的流程图。不知道什么是SPI的小伙伴儿，可以看一下这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1187061/202010/1187061-20201031220836524-188516808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的例子，我们可以看出，双亲委托模型的弊端。然后我们的jdk给我们提供了一种通过修改线程上下文类加载的方式来打破这种双亲委托的规则。关于修改上下文类加载的话题，我们下个章节再具体的讲解。接下来呢，我们再看看，获取类加载器的几个方法。并且奉上翻译好的java doc文档。方便我们后续学习线程类加载器。&lt;/p&gt;
&lt;h4 id=&quot;获取类加载器的几个方法&quot;&gt;&lt;strong&gt;获取类加载器的几个方法&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Class.getClassLoader()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* Returns the class loader for the class(返回加载该类的类加载器). Some implementations may use
* null to represent the bootstrap class loader(有一些jvm的实现可能用null来表示我们的启动类加载器比如 hotspot).
* This method will return null in such implementations if this class was loaded by the bootstrap class loader.
* 若这个方法返回null的话,那么这个类是由我们的启动类加载器加载
*
* If this object represents a primitive type or void, null is returned.
(原始类型 比如int,long等等的类或者 void类型 那么他们的类加载器是null)
*
*
*/
public ClassLoader getClassLoader() {
ClassLoader cl = getClassLoader0();
if (cl == null)
return null;
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
}
return cl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1:返回代表加载该class的类加载器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2:有一些虚拟机(比如hotspot) 的启动类加载器是null来表示&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3:原始类型 比如int ,long 或者是void类型 ，他们的类加载器是null&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ClassLoader.getSystemClassLoader()方法解读&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* Returns the system class loader for delegation(该方法返回系统类加载器). This is the default
* delegation parent for new ClassLoader instances(也是我们自己定义的类加载器的委托父类), and is
* typically the class loader used to start the application(通常系统类加载器是用来启动我们的应用的)
*
* This method is first invoked early in the runtime's startup
* sequence(程序在运行早起就会调用该方法), at which point it creates the system class loader and sets it
* as the context class loader of the invoking &amp;lt;tt&amp;gt;Thread&amp;lt;/tt&amp;gt;.(在那个时间,调用线程创建我们的系统类加载器同时把系统类加载器设置到我们线程上下文中)
*
* &amp;lt;p&amp;gt; The default system class loader is an implementation-dependent
* instance of this class.(这句话没有很好的理解)
*
* &amp;lt;p&amp;gt; If the system property &quot;&amp;lt;tt&amp;gt;java.system.class.loader&amp;lt;/tt&amp;gt;&quot; is defined
* when this method is first invoked then the value of that property is
* taken to be the name of a class that will be returned as the system
* class loader. The class is loaded using the default system class loader
* and must define a public constructor that takes a single parameter of
* type &amp;lt;tt&amp;gt;ClassLoader&amp;lt;/tt&amp;gt; which is used as the delegation parent. An
* instance is then created using this constructor with the default system
* class loader as the parameter. The resulting class loader is defined
* to be the system class loader.
我们可以通过java.system.class.loader 系统属性来指定一个自定义的类加载的二进制名称作为新的系统类加载器，
在我们自定的加载中我们需要定义个带参数的构造函数，参数为classLoader,那么我们这个自定义的类加载器就会看做系统类加载器

*
* @return The system &amp;lt;tt&amp;gt;ClassLoader&amp;lt;/tt&amp;gt; for delegation, or
* &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if none
*
* @throws SecurityException
* If a security manager exists and its &amp;lt;tt&amp;gt;checkPermission&amp;lt;/tt&amp;gt;
* method doesn't allow access to the system class loader.
*
* @throws IllegalStateException
* If invoked recursively during the construction of the class
* loader specified by the &quot;&amp;lt;tt&amp;gt;java.system.class.loader&amp;lt;/tt&amp;gt;&quot;
* property.
*
* @throws Error
* If the system property &quot;&amp;lt;tt&amp;gt;java.system.class.loader&amp;lt;/tt&amp;gt;&quot;
* is defined but the named class could not be loaded, the
* provider class does not define the required constructor, or an
* exception is thrown by that constructor when it is invoked. The
* underlying cause of the error can be retrieved via the
* {@link Throwable#getCause()} method.
*
* @revised 1.4
*/
@CallerSensitive
public static ClassLoader getSystemClassLoader() {
//初始化系统类加载器
initSystemClassLoader();
if (scl == null) {
return null;
}
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
checkClassLoaderPermission(scl, Reflection.getCallerClass());
}
return scl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1:该方法的作用是返回系统类加载器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2:也是我们自定义加载器的直接父类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3:系统类加载器是用来启动我们的应用的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4:在系统早期，调用线程会创建出我们的系统类加载器，并且把我们的系统类加载器设置到当前线程的上下文中.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5：我们可以通过系统属性:java.system.class.loader来指定一个我们自定义类加载器来充当我们系统类加载器，不过我们的我们自定的加载器需要提供一个带参数(classloader)的构造器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这篇文章就写到这里，jvm的艺术会继续连载，有兴趣的读者可以关注我：&lt;/p&gt;
&lt;p&gt;JVM的艺术—类加载器篇（一）已完结&lt;/p&gt;
&lt;p&gt;JVM的艺术—类加载器篇（二）已完结&lt;/p&gt;
&lt;p&gt;JVM的艺术—类加载器篇（三）创作中&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;笔者公众号：奇客时间&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 31 Oct 2020 14:09:00 +0000</pubDate>
<dc:creator>雕爷的架构之路</dc:creator>
<og:description>分享是价值的传递，喜欢就点个赞 引言 今天我们继续来深入的剖析类加载器的内容。上节课我们讲了类加载器的基本内容，没看过的小伙伴请加关注。今天我们继续。 什么是定义类加载器和初始化类加载器？ 定义类加载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tomakemyself/p/13907994.html</dc:identifier>
</item>
<item>
<title>## 【分布式事务】面试官问我：MySQL中的XA事务崩溃了如何恢复？？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13907976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13907976.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前段时间搭建了一套MySQL分布式数据库集群，数据库节点有12个，用来测试各种分布式事务方案的性能和优缺点。测试MySQL XA事务时，正当测试脚本向数据库中批量插入数据时，强制服务器断电！注意：是直接拔电源，使其瞬间断电，再次重启服务器后，MySQL数据库报错了。特此记录MySQL XA事务的恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mysql-xa事务问题&quot;&gt;MySQL XA事务问题&lt;/h2&gt;
&lt;p&gt;服务器强制断电后重启，此时MySQL报错，查看MySQL启动日志时，发现如下所示的错误信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;InnoDB: The log sequence number in ibdata files does not match
InnoDB: the log sequence number in the ib_logfiles!
100224 23:24:20 InnoDB: Database was not shut down normally!
InnoDB: Starting crash recovery.
InnoDB: Reading tablespace information from the .ibd files...
InnoDB: Restoring possible half-written data pages from the doublewrite
InnoDB: buffer...
InnoDB: Transaction 0 4497755 was in the XA prepared state.
InnoDB: Transaction 0 4468551 was in the XA prepared state.
InnoDB: Transaction 0 4468140 was in the XA prepared state.
InnoDB: 3 transaction(s) which must be rolled back or cleaned up
InnoDB: in total 0 row operations to undo
InnoDB: Trx id counter is 0 5312768
InnoDB: Starting in background the rollback of uncommitted transactions
100224 23:24:20 InnoDB: Rollback of non-prepared transactions completed
100224 23:24:20 InnoDB: Started; log sequence number 0 3805002509
100224 23:24:20 InnoDB: Starting recovery for XA transactions...
100224 23:24:20 InnoDB: Transaction 0 4497755 in prepared state after recovery
100224 23:24:20 InnoDB: Transaction contains changes to 8 rows
100224 23:24:20 InnoDB: Transaction 0 4468551 in prepared state after recovery
100224 23:24:20 InnoDB: Transaction contains changes to 1 rows
100224 23:24:20 InnoDB: Transaction 0 4468140 in prepared state after recovery
100224 23:24:20 InnoDB: Transaction contains changes to 1 rows
100224 23:24:20 InnoDB: 3 transactions in prepared state after recovery
100224 23:24:20 [Note] Found 3 prepared transaction(s) in InnoDB
100224 23:24:20 [Warning] Found 3 prepared XA transactions
100224 23:24:20 [Note] Event Scheduler: Loaded 0 events
100224 23:24:20 [Note] /opt/mysql/bin/mysqld: ready for connections.
Version: '8.0.18' socket: '/tmp/mysql.sock' port: 3306 MySQL Community Server (GPL) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的日志信息中，可以看出有三个XA的事务没有提交或回滚。那该如何恢复MySQL的XA事务呢？&lt;/p&gt;
&lt;h2 id=&quot;恢复mysql-xa事务&quot;&gt;恢复MySQL XA事务&lt;/h2&gt;
&lt;p&gt;首先，登录到MySQL，执行如下命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; xa recover;
+----------+--------------+--------------+------------------------------------------------------------+
| formatID | gtrid_length | bqual_length | data |
+----------+--------------+--------------+------------------------------------------------------------+
| 131075 | 30 | 28 | 1-7f000001:bae5:4b6928eb:f06397f000001:bae5:4b6928eb:f0650 |
| 131075 | 30 | 28 | 1-7f000001:bae5:4b6928eb:fb5c37f000001:bae5:4b6928eb:fb5cd |
| 131075 | 30 | 28 | 1-7f000001:bae5:4b6928eb:f03ea7f000001:bae5:4b6928eb:f0400 |
+----------+--------------+--------------+------------------------------------------------------------+ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据表示信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;formatIDis the formatIDpart of the transaction xid
gtrid_lengthis the length in bytes of the gtridpart of the xid
bqual_lengthis the length in bytes of the bqualpart of the xid
datais the concatenation of the gtridand bqualparts of the xid 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是三个XA事务的信息，准备直接回滚。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; xa rollback '1-7f000001:bae5:4b6928eb:fb5c3','7f000001:bae5:4b6928eb:fb5cd',131075;
Query OK, 0 rows affected (0.41 sec) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mysql-xa事务补充&quot;&gt;MySQL XA事务补充&lt;/h2&gt;
&lt;p&gt;XA事务支持限于InnoDB存储引擎。&lt;/p&gt;
&lt;p&gt;MySQL XA实施是针对外部XA的，其中，MySQL服务器作为资源管理器，而客户端程序作为事务管理器。未实施“内部XA”。这样，就允许MySQL服务器内的单独存储引擎作为RM（资源管理器），而服务器本身作为TM（事务管理器）。处理包含1个以上存储引擎的XA事务时，需要内部XA。内部XA的实施是不完整的，这是因为，它要求存储引擎在表处理程序层面上支持两阶段提交，目前仅对InnoDB实现了该特性。&lt;/p&gt;
&lt;p&gt;对于XA START，不支持JOIN和RESUME子句。&lt;/p&gt;
&lt;p&gt;对于XA END，不支持SUSPEND [FOR MIGRATE]子句。&lt;/p&gt;
&lt;p&gt;在全局事务内，对于每个XA事务，xid值的bqual部分应是不同的，该要求是对当前MySQL XA实施的限制。它不是XA规范的组成部分。&lt;/p&gt;
&lt;p&gt;如果XA事务达到PREPARED状态而且MySQL服务器宕机，当服务器重启后，能够继续处理事务。就像原本应当的那样。但是，如果客户端连接中止而服务器继续运行，服务器将回滚任何未完成的XA事务，即使该事务已达到PREPARED状态也同样。它应能提交或回滚PREPARED XA事务，但在不更改二进制日志机制的情况下不能这样。&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Sat, 31 Oct 2020 14:05:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 前段时间搭建了一套MySQL分布式数据库集群，数据库节点有12个，用来测试各种分布式事务方案的性能和优缺点。测试MySQL XA事务时，正当测试脚本向数据库中批量插入数据时，强制服务器断电！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13907976.html</dc:identifier>
</item>
<item>
<title>java log4j  的一个bug  - dint</title>
<link>http://www.cnblogs.com/dint/p/13907951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dint/p/13907951.html</guid>
<description>&lt;p&gt;java项目中使用log4j记录日志几乎成了标配，&lt;/p&gt;
&lt;p&gt;最近一个项目中出了个问题  现象是这样的：  不连vpn程序一切正常，连上VPN启动程序 直接异常退出，&lt;/p&gt;
&lt;p&gt;错误日志直接指向了 log4j 库&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
org.apache.logging.log4j.core.util.UuidUtil.clinit    &lt;p&gt;就是说在 UuidUtil 这个类初始化时出了问题
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;最终错误在此处&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/617210/202010/617210-20201031213706744-1899031856.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 数组index超界    &lt;/p&gt;

&lt;p&gt;原因是在我的机器上不连vpn  mac是一个长度为6的数组   连vpn后长度为8 了&lt;/p&gt;

&lt;p&gt;mac长度为8   则 length=6  index=2 &lt;/p&gt;
&lt;p&gt;则等价于: &lt;/p&gt;
&lt;p&gt;mac=new byte[8];&lt;/p&gt;
&lt;p&gt;node=new byte[8];&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.arraycopy(mac, 2, node, 2+ 2, 6);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是java.lang.ArrayIndexOutOfBoundsException&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;作者的意图我想是：&lt;/p&gt;
&lt;p&gt;如果mac长度小于等6 则将其复制到node从2开始的后面几位&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果mac长度大于 6 则复制最后六位到node从2开始的后6位 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则应该写成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; System.arraycopy(mac,index, node,2,length); &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坑！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;最后附上异常信息和原类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError&lt;br/&gt;at org.apache.logging.log4j.core.util.WatchManager.&amp;lt;init&amp;gt;(WatchManager.java:53)&lt;br/&gt;at org.apache.logging.log4j.core.config.AbstractConfiguration.&amp;lt;init&amp;gt;(AbstractConfiguration.java:135)&lt;br/&gt;at org.apache.logging.log4j.core.config.NullConfiguration.&amp;lt;init&amp;gt;(NullConfiguration.java:32)&lt;br/&gt;at org.apache.logging.log4j.core.LoggerContext.&amp;lt;clinit&amp;gt;(LoggerContext.java:85)&lt;br/&gt;at org.apache.logging.log4j.core.selector.ClassLoaderContextSelector.createContext(ClassLoaderContextSelector.java:179)&lt;br/&gt;at org.apache.logging.log4j.core.selector.ClassLoaderContextSelector.locateContext(ClassLoaderContextSelector.java:153)&lt;br/&gt;at org.apache.logging.log4j.core.selector.ClassLoaderContextSelector.getContext(ClassLoaderContextSelector.java:78)&lt;br/&gt;at org.apache.logging.log4j.core.selector.ClassLoaderContextSelector.getContext(ClassLoaderContextSelector.java:65)&lt;br/&gt;at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:148)&lt;br/&gt;at org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:45)&lt;br/&gt;at org.apache.logging.log4j.LogManager.getContext(LogManager.java:194)&lt;br/&gt;at org.apache.commons.logging.LogAdapter$Log4jLog.&amp;lt;clinit&amp;gt;(LogAdapter.java:155)&lt;br/&gt;at org.apache.commons.logging.LogAdapter$Log4jAdapter.createLog(LogAdapter.java:122)&lt;br/&gt;at org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:89)&lt;br/&gt;at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67)&lt;br/&gt;at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Caused by: java.lang.ArrayIndexOutOfBoundsException&lt;br/&gt;at java.lang.System.arraycopy(Native Method)&lt;br/&gt;at org.apache.logging.log4j.core.util.UuidUtil.&amp;lt;clinit&amp;gt;(UuidUtil.java:81)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.util;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.security.SecureRandom;
import java.util.Enumeration;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.PropertiesUtil;

/**
 * Generates a unique ID. The generated UUID will be unique for approximately 8,925 years so long as
 * less than 10,000 IDs are generated per millisecond on the same device (as identified by its MAC address).
 */
public final class UuidUtil {
    /**
     * System property that may be used to seed the UUID generation with an integer value.
     */
    public static final String UUID_SEQUENCE = &quot;org.apache.logging.log4j.uuidSequence&quot;;

    private static final Logger LOGGER = StatusLogger.getLogger();

    private static final String ASSIGNED_SEQUENCES = &quot;org.apache.logging.log4j.assignedSequences&quot;;

    private static final AtomicInteger COUNT = new AtomicInteger(0);
    private static final long TYPE1 = 0x1000L;
    private static final byte VARIANT = (byte) 0x80;
    private static final int SEQUENCE_MASK = 0x3FFF;
    private static final long NUM_100NS_INTERVALS_SINCE_UUID_EPOCH = 0x01b21dd213814000L;
    private static final long INITIAL_UUID_SEQNO = PropertiesUtil.getProperties().getLongProperty(UUID_SEQUENCE, 0);

    private static final long LEAST;

    private static final long LOW_MASK = 0xffffffffL;
    private static final long MID_MASK = 0xffff00000000L;
    private static final long HIGH_MASK = 0xfff000000000000L;
    private static final int NODE_SIZE = 8;
    private static final int SHIFT_2 = 16;
    private static final int SHIFT_4 = 32;
    private static final int SHIFT_6 = 48;
    private static final int HUNDRED_NANOS_PER_MILLI = 10000;

    static {
        byte[] mac = NetUtils.getMacAddress();
        final Random randomGenerator = new SecureRandom();
        if (mac == null || mac.length == 0) {
            mac = new byte[6];
            randomGenerator.nextBytes(mac);
        }
        final int length = mac.length &amp;gt;= 6 ? 6 : mac.length;
        final int index = mac.length &amp;gt;= 6 ? mac.length - 6 : 0;
        final byte[] node = new byte[NODE_SIZE];
        node[0] = VARIANT;
        node[1] = 0;
        for (int i = 2; i &amp;lt; NODE_SIZE; ++i) {
            node[i] = 0;
        }
        System.arraycopy(mac, index, node, index + 2, length);
        final ByteBuffer buf = ByteBuffer.wrap(node);
        long rand = INITIAL_UUID_SEQNO;
        String assigned = PropertiesUtil.getProperties().getStringProperty(ASSIGNED_SEQUENCES);
        long[] sequences;
        if (assigned == null) {
            sequences = new long[0];
        } else {
            final String[] array = assigned.split(Patterns.COMMA_SEPARATOR);
            sequences = new long[array.length];
            int i = 0;
            for (final String value : array) {
                sequences[i] = Long.parseLong(value);
                ++i;
            }
        }
        if (rand == 0) {
            rand = randomGenerator.nextLong();
        }
        rand &amp;amp;= SEQUENCE_MASK;
        boolean duplicate;
        do {
            duplicate = false;
            for (final long sequence : sequences) {
                if (sequence == rand) {
                    duplicate = true;
                    break;
                }
            }
            if (duplicate) {
                rand = (rand + 1) &amp;amp; SEQUENCE_MASK;
            }
        } while (duplicate);
        assigned = assigned == null ? Long.toString(rand) : assigned + ',' + Long.toString(rand);
        System.setProperty(ASSIGNED_SEQUENCES, assigned);

        LEAST = buf.getLong() | rand &amp;lt;&amp;lt; SHIFT_6;
    }


    /* This class cannot be instantiated */
    private UuidUtil() {
    }

    /**
     * Generates Type 1 UUID. The time contains the number of 100NS intervals that have occurred
     * since 00:00:00.00 UTC, 10 October 1582. Each UUID on a particular machine is unique to the 100NS interval
     * until they rollover around 3400 A.D.
     * &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;Digits 1-12 are the lower 48 bits of the number of 100 ns increments since the start of the UUID
     * epoch.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Digit 13 is the version (with a value of 1).&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Digits 14-16 are a sequence number that is incremented each time a UUID is generated.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Digit 17 is the variant (with a value of binary 10) and 10 bits of the sequence number&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Digit 18 is final 16 bits of the sequence number.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Digits 19-32 represent the system the application is running on.&amp;lt;/li&amp;gt;
     * &amp;lt;/ol&amp;gt;
     *
     * @return universally unique identifiers (UUID)
     */
    public static UUID getTimeBasedUuid() {

        final long time = ((System.currentTimeMillis() * HUNDRED_NANOS_PER_MILLI) +
            NUM_100NS_INTERVALS_SINCE_UUID_EPOCH) + (COUNT.incrementAndGet() % HUNDRED_NANOS_PER_MILLI);
        final long timeLow = (time &amp;amp; LOW_MASK) &amp;lt;&amp;lt; SHIFT_4;
        final long timeMid = (time &amp;amp; MID_MASK) &amp;gt;&amp;gt; SHIFT_2;
        final long timeHi = (time &amp;amp; HIGH_MASK) &amp;gt;&amp;gt; SHIFT_6;
        final long most = timeLow | timeMid | TYPE1 | timeHi;
        return new UUID(most, LEAST);
    }
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 31 Oct 2020 13:59:00 +0000</pubDate>
<dc:creator>dint</dc:creator>
<og:description>java项目中使用log4j记录日志几乎成了标配， 最近一个项目中出了个问题 现象是这样的： 不连vpn程序一切正常，连上VPN启动程序 直接异常退出， 错误日志直接指向了 log4j 库 org.a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dint/p/13907951.html</dc:identifier>
</item>
</channel>
</rss>