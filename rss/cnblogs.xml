<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>恕我直言你可能真的不会java第8篇-函数式接口 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13206001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13206001.html</guid>
<description>&lt;h2 id=&quot;一、函数式接口是什么？&quot;&gt;一、函数式接口是什么？&lt;/h2&gt;
&lt;p&gt;所谓的函数式接口，实际上就是接口里面&lt;strong&gt;只能有一个抽象方法的接口&lt;/strong&gt;。我们上一节用到的Comparator接口就是一个典型的函数式接口，它只有一个抽象方法compare。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200629082609445-908234819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;只有一个抽象方法？那上图中的equals方法不是也没有函数体么？不急，和我一起往下看！&lt;/p&gt;
&lt;h2 id=&quot;二、函数式接口的特点&quot;&gt;二、函数式接口的特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;接口有且仅有一个抽象方法，如上图的抽象方法compare&lt;/li&gt;
&lt;li&gt;允许定义静态非抽象方法&lt;/li&gt;
&lt;li&gt;允许定义默认defalut非抽象方法（default方法也是java8才有的，见下文）&lt;/li&gt;
&lt;li&gt;允许java.lang.Object中的public方法，如上图的方法equals。&lt;/li&gt;
&lt;li&gt;FunctionInterface注解不是必须的，如果一个接口符合&quot;函数式接口&quot;定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;甚至可以说：函数式接口是专门为lambda表达式准备的，&lt;strong&gt;lambda表达式是只实现接口中唯一的抽象方法的匿名实现类&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;三、default关键字&quot;&gt;三、default关键字&lt;/h2&gt;
&lt;p&gt;顺便讲一下default关键字，在java8之前&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接口是不能有方法的实现，所有方法全都是抽象方法&lt;/li&gt;
&lt;li&gt;实现接口就必须实现接口里面的所有方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就导致一个问题：&lt;strong&gt;当一个接口有很多的实现类的时候,修改这个接口就变成了一个非常麻烦的事,需要修改这个接口的所有实现类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个问题困扰了java工程师许久，不过在java8中这个问题得到了解决,没错就是default方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;default方法可以有自己的默认实现，即有方法体。&lt;/li&gt;
&lt;li&gt;接口实现类可以不去实现default方法，并且可以使用default方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、jdk中的函数式接口举例&quot;&gt;四、JDK中的函数式接口举例&lt;/h2&gt;
&lt;p&gt;java.lang.Runnable,&lt;/p&gt;
&lt;p&gt;java.util.Comparator,&lt;/p&gt;
&lt;p&gt;java.util.concurrent.Callable&lt;/p&gt;
&lt;p&gt;java.util.function包下的接口，如Consumer、Predicate、Supplier等&lt;/p&gt;
&lt;h2 id=&quot;五、自定义comparator排序&quot;&gt;五、自定义Comparator排序&lt;/h2&gt;
&lt;p&gt;我们自定义一个排序器，实现compare函数（函数式接口Comparator唯一的抽象方法）。返回0表示元素相等，-1表示前一个元素小于后一个元素，1表示前一个元素大于后一个元素。这个规则和java 8之前没什么区别。&lt;/p&gt;
&lt;p&gt;下面代码用自定义接口实现类的的方式实现：按照年龄的倒序排序！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;employees.sort(new Comparator&amp;lt;Employee&amp;gt;() {
    @Override
    public int compare(Employee em1, Employee em2) {
        if(em1.getAge() == em2.getAge()){
            return 0;
        }
        return em1.getAge() - em2.getAge() &amp;gt; 0 ? -1:1;
    }
});
employees.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的打印结果如下，按照年龄的自定义规则进行排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin)
Employee(id=7, age=68, gender=F, firstName=Melissa, lastName=Roy)
Employee(id=10, age=45, gender=M, firstName=Naveen, lastName=Jain)
Employee(id=3, age=43, gender=M, firstName=Ricky, lastName=Martin)
Employee(id=4, age=26, gender=M, firstName=Jon, lastName=Lowman)
Employee(id=1, age=23, gender=M, firstName=Rick, lastName=Beethovan)
Employee(id=5, age=19, gender=F, firstName=Cristine, lastName=Maria)
Employee(id=9, age=15, gender=F, firstName=Neetu, lastName=Singh)
Employee(id=6, age=15, gender=M, firstName=David, lastName=Feezor)
Employee(id=2, age=13, gender=F, firstName=Martina, lastName=Hengis)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码如果以lambda表达式简写。箭头左侧是参数，右侧是函数体，参数类型和返回值根据上下文自动判断。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;employees.sort((em1,em2) -&amp;gt; {
    if(em1.getAge() == em2.getAge()){
        return 0;
    }
    return em1.getAge() - em2.getAge() &amp;gt; 0 ? -1:1;
});
employees.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 00:26:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、函数式接口是什么？ 所谓的函数式接口，实际上就是接口里面只能有一个抽象方法的接口。我们上一节用到的Comparator接口就是一个典型的函数式接口，它只有一个抽象方法compare。 只有一个抽象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13206001.html</dc:identifier>
</item>
<item>
<title>谈反应式编程在服务端中的应用，数据库操作优化，提速 Upsert - Newbe36524</title>
<link>http://www.cnblogs.com/newbe36524/p/13205608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newbe36524/p/13205608.html</guid>
<description>&lt;p&gt;反应式编程在客户端编程当中的应用相当广泛，而当前在服务端中的应用相对被提及较少。本篇将介绍如何在服务端编程中应用响应时编程来改进数据库操作的性能。&lt;/p&gt;
&lt;h2 id=&quot;开篇就是结论&quot;&gt;开篇就是结论&lt;/h2&gt;
&lt;p&gt;接续上一篇《&lt;a title=&quot;谈反应式编程在服务端中的应用，数据库操作优化，从20秒到0.5秒&quot; href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-1/&quot;&gt;谈反应式编程在服务端中的应用，数据库操作优化，从 20 秒到 0.5 秒&lt;/a&gt;》之后，这次，我们带来了关于利用反应式编程进行 upsert 优化的案例说明。建议读者可以先阅读一下前一篇，这样更容易理解本篇介绍的方法。&lt;/p&gt;
&lt;p&gt;同样还是利用批量化的思路，将单个 upsert 操作批量进行合并。已达到减少数据库链接消耗从而大幅提升性能的目的。&lt;/p&gt;
&lt;h2 id=&quot;业务场景&quot;&gt;业务场景&lt;/h2&gt;
&lt;p&gt;在最近的一篇文章《&lt;a title=&quot;十万同时在线用户，需要多少内存？——Newbe.Claptrap框架水平扩展实验&quot; href=&quot;https://www.newbe.pro/Newbe.Claptrap/How-Many-RAMs-In-Used-While-There-Are-One-Hundred-Thousand-Users-Online/&quot;&gt;十万同时在线用户，需要多少内存？——Newbe.Claptrap 框架水平扩展实验&lt;/a&gt;》中。我们通过激活多个常驻于内存当中的 Claptrap 来实现快速验证 JWT 正确性的目的。&lt;/p&gt;
&lt;p&gt;但，当时有一个技术问题没有得到解决：&lt;/p&gt;
&lt;p&gt;Newbe.Claptrap 框架设计了一个特性：当 Claptrap Deactive 时，可以选择将快照立即保存到数据库。因此，当尝试从集群中关闭一个节点时，如果节点上存在大量的 Claptrap ，那么将产生大量的数据库 upsert 操作。瞬间推高数据库消耗，甚至导致部分错误而保存失败。&lt;/p&gt;
&lt;h2 id=&quot;一点点代码&quot;&gt;一点点代码&lt;/h2&gt;
&lt;p&gt;有了前篇的 &lt;code&gt;IBatchOperator&lt;/code&gt;，那么留给这篇的代码内容就非常少了。&lt;/p&gt;
&lt;p&gt;首先，按照使用上一篇的 IBatchOperator 编写一个支持操作的 Repository，形如以下代码：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;25.5&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;29.5&quot;&gt;
&lt;pre readability=&quot;22&quot;&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BatchUpsert&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;IUpsertRepository&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt; IDatabase _database;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt; IBatchOperator&amp;lt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; _batchOperator;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BatchUpsert&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;IDatabase database&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        _database = database;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; options = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchOperatorOptions&amp;lt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            BufferCount = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            BufferTime = TimeSpan.FromMilliseconds(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            DoManyFunc = DoManyFunc&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        };&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        _batchOperator = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BatchOperator&amp;lt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(options);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Task&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;DoManyFunc&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;IEnumerable&amp;lt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;)&amp;gt; arg)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _database.UpsertMany(arg.ToDictionary(x =&amp;gt; x.Item1, x =&amp;gt; x.Item2));&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Task &lt;span class=&quot;title&quot;&gt;UpsertAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _batchOperator.CreateTask((key, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;然后，只要实现对应数据库的 UpsertMany 方法，便可以很好地完成这项优化。&lt;/p&gt;
&lt;h2 id=&quot;各种数据库的操作&quot;&gt;各种数据库的操作&lt;/h2&gt;
&lt;p&gt;结合 Newbe.Claptrap 现在项目的实际。目前，被支持的数据库分别有 SQLite、PostgreSQL、MySql 和 MongoDB。以下，分别对不同类型的数据库的批量 Upsert 操作进行说明。&lt;/p&gt;
&lt;p&gt;由于在 Newbe.Claptrap 项目中的 Upsert 需求都是以主键作为对比键，因此以下也只讨论这种情况。&lt;/p&gt;
&lt;h3 id=&quot;SQLite&quot;&gt;SQLite&lt;/h3&gt;
&lt;p&gt;根据官方文档，使用 &lt;code&gt;INSERT OR REPLACE INTO&lt;/code&gt; 便可以实现主键冲突时替换数据的需求。&lt;/p&gt;
&lt;p&gt;具体的语句格式形如以下：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; TestTable (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(@id0,@value0),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(@idn,@valuen);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;因此只要直接拼接语句和参数调用即可。需要注意的是，SQLite 的可传入参数默认为 999，因此拼接的变量也不应大于该数量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sqlite.org/lang_insert.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档：INSERT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;PostgreSQL&quot;&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;众所周知，PostgreSQL 在进行批量写入时，可以使用高效的 &lt;code&gt;COPY&lt;/code&gt; 语句来完成数据的高速导入，这远远快于 &lt;code&gt;INSERT&lt;/code&gt; 语句。但可惜的是 &lt;code&gt;COPY&lt;/code&gt; 并不能支持 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句。因此，无法使用 &lt;code&gt;COPY&lt;/code&gt; 来完成 upsert 需求。&lt;/p&gt;
&lt;p&gt;因此，我们还是回归使用 &lt;code&gt;INSERT&lt;/code&gt; 配合 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 子句，以及 &lt;code&gt;unnest&lt;/code&gt; 函数来完成批量 upsert 的需求。&lt;/p&gt;
&lt;p&gt;具体的语句格式形如以下：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; TestTable (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unnest&lt;/span&gt;(@ids), &lt;span class=&quot;keyword&quot;&gt;unnest&lt;/span&gt;(@&lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; CONFLICT &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CONSTRAINT&lt;/span&gt; TestTable_pkey&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;DO&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;=excluded.value;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;其中的 ids 和 values 分别为两个等长的数组对象，unnest 函数可以将数组对象转换为行数据的形式。&lt;/p&gt;
&lt;p&gt;注意，可能会出现 ON CONFLICT DO UPDATE command cannot affect row a second time 错误。&lt;/p&gt;
&lt;p&gt;因此如果尝试使用上述方案，需要在传入数据库之前，先在程序中去重一遍。而且，通常来说，在程序中进行一次去重可以减少向数据库中传入的数据，这本身也很有意义。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.postgresql.org/docs/9.2/functions-array.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档：unnest 函数&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.postgresql.org/docs/9.5/sql-insert.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档：Insert 语句&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;MySql&quot;&gt;MySql&lt;/h3&gt;
&lt;p&gt;MySql 与 SQLite 类似，支持 &lt;code&gt;REPLACE&lt;/code&gt; 语法。具体语句形式如下：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; TestTable (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(@id0,@value0),&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;(@idn,@valuen);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/replace.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档：REPLACE 语句&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;MongoDB&quot;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;MongoDB 原生支持 bulkWrite 的批量传输模式，也支持 replace 的 upsert 语法。因此操作非常简单。&lt;/p&gt;
&lt;p&gt;那么这里展示一下 C# 操作方法：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;19.5&quot;&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; Task &lt;span class=&quot;title&quot;&gt;SaveManyCoreMany&lt;/span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    IDbFactory dbFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    IEnumerable&amp;lt;StateEntity&amp;gt; entities&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; array = entities &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; StateEntity[] ?? entities.ToArray();&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; items = array&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        .Select(x =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MongoStateEntity&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            claptrap_id = x.ClaptrapId,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            claptrap_type_code = x.ClaptrapTypeCode,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            version = x.Version,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            state_data = x.StateData,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            updated_time = x.UpdatedTime,&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        .ToArray();&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; client = dbFactory.GetConnection(_connectionName);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; db = client.GetDatabase(_databaseName);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; collection = db.GetCollection&amp;lt;MongoStateEntity&amp;gt;(_stateCollectionName);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; upsertModels = items.Select(x =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; filter = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExpressionFilterDefinition&amp;lt;MongoStateEntity&amp;gt;(entity =&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            entity.claptrap_id == x.claptrap_id &amp;amp;&amp;amp; entity.claptrap_type_code == x.claptrap_type_code);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReplaceOneModel&amp;lt;MongoStateEntity&amp;gt;(filter, x)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            IsUpsert = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        };&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    });&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; collection.BulkWriteAsync(upsertModels);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;这是从 Newbe.Claptrap 项目业务场景中给出的代码，读者可以结合自身需求进行修改。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档：db.collection.bulkWrite ()&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;通用型解法&quot;&gt;通用型解法&lt;/h3&gt;
&lt;p&gt;优化的本质是减少数据库链接的使用，尽可能在一个链接内完成更多的工作。因此如果特定的数据库不支持以上数据库类似的操作。那么还是存在一种通用型的解法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以尽可能快地方式将数据写入一临时表&lt;/li&gt;
&lt;li&gt;将临时表的数据已连表 update 的方式更新的目标表&lt;/li&gt;
&lt;li&gt;删除临时表&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sql-workbench.eu/dbms_comparison.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;UPDATE with a join&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;以 SQLite 为例，尝试对 12345 条数据进行 2 次 upsert 操作。&lt;/p&gt;
&lt;p&gt;单条并发：1 分 6 秒&lt;/p&gt;
&lt;p&gt;批量处理：2.9 秒&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/newbe36524/Newbe.Demo/blob/master/src/BlogDemos/Newbe.Rx/Newbe.RxWorld/Newbe.RxWorld/UpsertTest.cs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;可以在该链接找到测试的代码。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;样例中不包含有 MySql、PostgreSQL 和 MongoDB 的样例，因为没有优化之前，在不提高连接池的情况下，一并发基本就爆炸了。所有优化的结果是直接解决了可用性的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7272727272727&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/newbe36524/Newbe.Demo&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;所有的示例代码均可以在代码库中找到&lt;/a&gt;。如果 Github Clone 存在困难，&lt;a href=&quot;https://gitee.com/yks/Newbe.Demo&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;也可以点击此处从 Gitee 进行 Clone&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常见问题解答&quot;&gt;常见问题解答&lt;/h2&gt;
&lt;p&gt;此处对一些常见的问题进行解答。&lt;/p&gt;
&lt;h3 id=&quot;客户端是等待批量操作的结果吗？&quot;&gt;客户端是等待批量操作的结果吗？&lt;/h3&gt;
&lt;p&gt;这是一个很多网友提出的问题。答案是：是的。&lt;/p&gt;
&lt;p&gt;假设我们公开了一个 WebApi 作为接口，由浏览器调用。如果同时有 100 个浏览器同时发出请求。&lt;/p&gt;
&lt;p&gt;那么这 100 个请求会被合并，然后写入数据库。而在写入数据库之前，这些客户端都不会得到服务端的响应，会一直等待。&lt;/p&gt;
&lt;p&gt;这也是该合并方案区别于普通的 “写队列，后写库” 方案的地方。&lt;/p&gt;
&lt;h3 id=&quot;原理上讲，这种和bulkcopy有啥不一样？&quot;&gt;原理上讲，这种和 bulkcopy 有啥不一样？&lt;/h3&gt;
&lt;p&gt;两者是不相关，必须同时才有作用的功能。&lt;br/&gt;首先，代码中的 database.InsertMany 就是你提到的 bulkcopy。&lt;/p&gt;
&lt;p&gt;这个代码的关键不是 InsertMany ，而是如何将单次的插入请求合并。&lt;br/&gt;试想一下，你可以在 webapi 上公开一个 bulkcopy 的 API。&lt;br/&gt;但是，你无法将来自不同客户端的请求合并在同一个 API 里面来调用 bulkcopy。&lt;br/&gt;例如，有一万个客户端都在调用你的 API，那怎么合并这些 API 请求呢？&lt;/p&gt;
&lt;p&gt;如果如果通过上面这种方式，虽然你只是对外公开了一个单次插入的 API。你却实现了来自不同客户端请求的合并，变得可以使用 bulkcopy 了。这在高并发下很有意义。&lt;/p&gt;
&lt;p&gt;另外，这符合开闭的原理，因为你没有修改 Repository 的 InsertOne 接口，却实现了 bulkcopy&lt;br/&gt;的效果。&lt;/p&gt;
&lt;h3 id=&quot;如果批量操作中一个操作异常失败是否会导致被合并的其他操作全部失败？&quot;&gt;如果批量操作中一个操作异常失败是否会导致被合并的其他操作全部失败？&lt;/h3&gt;
&lt;p&gt;如果业务场景是合并会有影响，那当然不应该合并。&lt;/p&gt;
&lt;p&gt;批量操作一个失败，当然是一起失败，因为底层的数据库事务肯定也是一起失败。&lt;/p&gt;
&lt;p&gt;除非批量接口也支持对每个传入的 ID 做区别对待。典型的，比如 mongodb 的 bulkcopy 可以返回哪些成功哪些失败，那么我们就有能力设置不同的 Tcs 状态。&lt;/p&gt;
&lt;p&gt;哪些该合并，哪些不该合并，完全取决于业务。样例给出的是如果要合并，应该怎么合并。不会要求所有都要合并。&lt;/p&gt;
&lt;h3 id=&quot;Insert-和-Upsert-都说了，那-Delete-和-Select-呢？&quot;&gt;Insert 和 Upsert 都说了，那 Delete 和 Select 呢？&lt;/h3&gt;
&lt;p&gt;笔者笼统地将该模式称为 “反应式批量处理”。要确认业务场景是否应用该模式，需要具备以下这两个基本的要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务下游的批量处理是否会比累积的单条处理要快，如果会，那可以用&lt;/li&gt;
&lt;li&gt;业务上游是否会出现短时间的突增频率的请求，如果会，那可以用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，还需要考量，比如：下游的批量操作能否却分每个请求的结果等等问题。但以上两点是一定需要考量的。&lt;/p&gt;
&lt;p&gt;那么以 Delete 为例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Delete Where In 的速度会比 Delete = 的速度快吗？试一下&lt;/li&gt;
&lt;li&gt;会有突增的 Delete 需求吗？想一下&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小小工具-Zeal&quot;&gt;小小工具 Zeal&lt;/h2&gt;
&lt;p&gt;笔者是一个完整存储过程都写不出来的人。能够查阅到这些数据库的文档，全靠一款名为 Zeal 的离线文档查看免费软件。推荐给您，您也值得拥有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.newbe.pro/images/20200627-010.png&quot; alt=&quot;Zeal&quot; class=&quot;medium-zoom-image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Zeal 官网地址：&lt;a href=&quot;https://zealdocs.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://zealdocs.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后但是最重要！&quot;&gt;最后但是最重要！&lt;/h2&gt;
&lt;p&gt;最近作者正在构建以&lt;code&gt;反应式&lt;/code&gt;、&lt;code&gt;Actor模式&lt;/code&gt;和&lt;code&gt;事件溯源&lt;/code&gt;为理论基础的一套服务端开发框架。希望为开发者提供能够便于开发出 “分布式”、“可水平扩展”、“可测试性高” 的应用系统 ——Newbe.Claptrap&lt;/p&gt;
&lt;p&gt;本篇文章是该框架的一篇技术选文，属于技术构成的一部分。如果读者对该内容感兴趣，欢迎转发、评论、收藏文章以及项目。您的支持是促进项目成功的关键。&lt;/p&gt;
&lt;p&gt;如果你对该项目感兴趣，你可以通过 github issues 提交您的看法。&lt;/p&gt;
&lt;p&gt;如果您无法正常访问 github issue，您也可以发送邮件到 &lt;a href=&quot;mailto:newbe-claptrap@googlegroups.com&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;newbe-claptrap@googlegroups.com&lt;/a&gt; 来参与我们的讨论。&lt;/p&gt;
&lt;p&gt;点击链接 QQ 交流【Newbe.Claptrap】：&lt;a href=&quot;https://jq.qq.com/?_wv=1027&amp;amp;k=5uJGXf5&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://jq.qq.com/?_wv=1027&amp;amp;k=5uJGXf5&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您还可以查阅本系列的其他选文：&lt;/p&gt;
&lt;p&gt;GitHub 项目地址：&lt;a href=&quot;https://github.com/newbe36524/Newbe.Claptrap&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/newbe36524/Newbe.Claptrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee 项目地址：&lt;a href=&quot;https://gitee.com/yks/Newbe.Claptrap&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://gitee.com/yks/Newbe.Claptrap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.newbe.pro/images/main_banner.png&quot; alt=&quot;Newbe.Claptrap&quot; class=&quot;medium-zoom-image&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot;post-copyright&quot;&gt;&lt;li class=&quot;post-copyright-author&quot;&gt;&lt;span&gt;本文作者： &lt;/span&gt;newbe36524&lt;/li&gt;
&lt;li class=&quot;post-copyright-link&quot;&gt;&lt;span&gt;本文链接：&lt;/span&gt; &lt;a title=&quot;谈反应式编程在服务端中的应用，数据库操作优化，提速 Upsert&quot; href=&quot;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-2/&quot;&gt;https://www.newbe.pro/Newbe.Claptrap/Reactive-In-Server-2/&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;post-copyright-license&quot;&gt;&lt;span&gt;版权声明： &lt;/span&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;BY-NC-SA&lt;/a&gt; 许可协议。转载请注明出处！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 29 Jun 2020 00:23:00 +0000</pubDate>
<dc:creator>Newbe36524</dc:creator>
<og:description>反应式编程在客户端编程当中的应用相当广泛，而当前在服务端中的应用相对被提及较少。本篇将介绍如何在服务端编程中应用响应时编程来改进数据库操作的性能。 开篇就是结论 接续上一篇《谈反应式编程在服务端中的应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newbe36524/p/13205608.html</dc:identifier>
</item>
<item>
<title>用户画像产品化——从零开始搭建实时用户画像(六) - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13205991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13205991.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081230506-653449321.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在开发好用户标签以后，如何将标签应用到实际其实是一个很重要的问题。只有做好产品的设计才能让标签发挥真正的价值，本文将介绍用户画像的产品化过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081240814-788298361.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先是标签展示功能，这个主要供业务人员和研发人员使用，是为了更直观的看见整个的用户标签体系。&lt;/p&gt;
&lt;p&gt;不同的标签体系会有不同的层级，那么这个页面的设计就需要我们展示成树状的结构，方便以后的扩展。&lt;/p&gt;
&lt;p&gt;在最后一个层级，比如自然性别，可以设计一个统计页面，在进入页面后，可以展示相应的数据统计情况，&lt;/p&gt;
&lt;p&gt;可以更直观看见标签中值得比例，也可以为业务提供好的建议，另外可以对标签的具体描述进行展示，起到一个说明的作用，还可以展示标签按天的波动情况，观察标签的变化情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081248453-1899554261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一部分的数据来源呢？之前也提到过，这些标签的元数据信息都存在mysql中，方便我们查询。&lt;/p&gt;
&lt;p&gt;所以树状图和标签描述信息需要去mysql中获取，而比例等图表数据则是从Hbase，Hive中查询获取的，当然也有直接通过ES获取的。但是每天的标签历史波动情况，还是要通过每天跑完标签后存在mysql中作为历史记录进行展示。&lt;/p&gt;

&lt;p&gt;这一功能可以提供给研发人员和业务人员使用。&lt;/p&gt;
&lt;p&gt;标签查询功能其实就是对用户进行全局画像的过程，对于一个用户的全量标签信息，我们是需要对其进行展示的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081255175-577467334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入用户id后，可以查看该用户的属性信息、行为信息、风控属性等信息。从多方位了解一个具体的用户特征。&lt;/p&gt;
&lt;p&gt;这些已经是标签的具体信息了，由于是对单一id的查找，从hive中获取会造成查询速度的问题，所以我们更建议从Hbase或者ES中查询获取，这样查询效率和实时性都能获得极大的提升。&lt;/p&gt;

&lt;p&gt;这一功能是提供给研发人员使用的。&lt;/p&gt;
&lt;p&gt;对于标签，不能每一次新增一个标签都进行非常大改动，这样是非常耗费人力的，所以必须要有可以对标签进行管理的功能。&lt;/p&gt;
&lt;p&gt;这里定义了标签的基本信息，开发方式，开发人员等等，在完成标签的开发以后，直接在此页面对标签进行录入，就可以完成标签的上线工作，让业务人员可以对标签进行使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081304079-2021547476.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新增和编辑标签的页面，可以提供下拉框或者输入框提供信息录入的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081309773-2024539555.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前已经提到过，这些标签的元数据信息都保存在了Mysql中，只要完成对其的新增和修改就可以了。&lt;/p&gt;

&lt;p&gt;作为用户画像最核心的功能，用户分群功能。是用户画像与业务系统建立联系的桥梁，也是用户画像的价值所在。&lt;/p&gt;
&lt;p&gt;这项功能主要供业务人员使用。&lt;/p&gt;
&lt;p&gt;此功能允许用户自定义的圈定一部分人员，圈定的规则就是对于标签的条件约束。&lt;/p&gt;
&lt;p&gt;在圈定好人群以后，可以对这部分人群提供与业务系统的外呼系统，客服系统，广告系统，Push系统的交互，达到真正的精细化运营的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081315773-1853271525.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于标签规则的判断，需要将记录好的规则存储于Mysql中，在进行人群计算时又需要将规则解析成可计算的逻辑。不管是解析成Sql或者其他的查询语言都难度巨大，这对于研发是一个非常大的挑战。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081321434-1324788238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此功能中，还可以增加人群对比的功能，对不同人群的不同标签进行圈定，对比。这对于查询性能也是一个巨大的考验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200629081327950-1539067645.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，用户分群功能作为用户画像的核心是我们必须要实现的。对于技术架构，Hbase更擅长与KV形式的查询，对于多维度查询性能较差，所以可以采取ES索引，在ES查询出Hbase的Rowkey，再去查询Hbase的方式。也有很多公司选择整体迁移到ES中完成此项工作。那么ES可以胜任这项工作吗？&lt;/p&gt;
&lt;p&gt;下一章，我们来聊一聊如何用ES来实现用户分群，未完待续~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《用户画像：方法论与工程化解决方案》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多实时数据分析相关博文与科技资讯，欢迎关注 “实时流式计算” 获取用户画像相关资料 请关注 “实时流式计算” 回复 “用户画像”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 00:18:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>在开发好用户标签以后，如何将标签应用到实际其实是一个很重要的问题。只有做好产品的设计才能让标签发挥真正的价值，本文将介绍用户画像的产品化过程。 一、标签展示 首先是标签展示功能，这个主要供业务人员和研</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13205991.html</dc:identifier>
</item>
<item>
<title>读懂操作系统之虚拟内存页表（五）  - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13167467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13167467.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在一个拥有32位的地址空间，4KB的页面（2&lt;sup&gt;12&lt;/sup&gt;），并且每个PTE为4个字节，那么页表大小为4MB（4 * 2&lt;sup&gt;32 &lt;/sup&gt;/ 2&lt;sup&gt;12&lt;/sup&gt;），但若为64位地址空间，4KB的页面（2&lt;sup&gt;12&lt;/sup&gt;）且每个PTE为4字节，那么页表大小为16TB（4 * 2&lt;sup&gt;64 &lt;/sup&gt;/ 2&lt;sup&gt;12&lt;/sup&gt;），由于页表常驻内存，占用内存会很大，所以必须对页表存储结构进行优化，这就是我们本文所要讲解的内容，常见的页表数据结构为多级页表（两级、三级等）、倒置页表、哈希页表，我们来一一进行分析。&lt;/p&gt;
&lt;h2&gt;多级页表&lt;/h2&gt;
&lt;p&gt;首先我们讲讲2级页表，然后通过2级页表延伸到多级页表，现假设有16KB（2&lt;sup&gt;14&lt;/sup&gt;）的地址空间，并且每页大小为64（2&lt;sup&gt;6&lt;/sup&gt;）字节，每个PTE为4字节，那么说明页表为1KB（4 * 2&lt;sup&gt;14 &lt;/sup&gt;/ 2&lt;sup&gt;6&lt;/sup&gt;），若我们有64字节的页，那么将1KB可划分为16个64字节的页面，每个页面可容纳16个PTE，前面我们讲解到虚拟地址划分为虚拟页号（VPN）和虚拟页偏移量（VPO），但虚拟页偏移量已经固定，那么我们只能从VPN下手将其作为索引用于索引页表目录，那么我们该如何利用VPN来构建各个部分的索引呢？我们首先需要构建页表目录，根据上述假设，总共有256个PTE分布在16页上，页目录在页表的每页上需要一个条目，因此它具有16个条目， 最终我们需要VPN中的4位索引到目录中，这也就意味着我们需要使用VPN的前4位，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200622225139771-1828880375.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从VPN提取出了页表目录索引（PDI），那么我们就可以计算出每个PDE（Page Directory Entry）的地址值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PDEAddress = PageDirectoryBase + (PDIndex * &lt;span&gt;sizeof&lt;/span&gt;(PDE))。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了页目录索引后我们还需进行进一步翻译，如果页目录索引为空，很显然第2级页表根本就不会存在，如此一来则达到了减少内存的要求，因为只有第一级页表才会存在于主存中，虚拟内存系统会根据需要调入或调出第2级页表，这就减少了主存的压力，只有经常使用的2级页表才需要缓存在主存中。如果第1级页表即页目录索引有值，那么还需根据页目录指向的页表页面去获取PTE，要找到此PTE，我们还需要使用VPN的其余索引映射到页表的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200622230218310-905813599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过使用如上页表索引来索引页表本身，从而找到PTE地址，也就找到了PFN（物理页帧号）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PTEAddress = (PDE.PFN &amp;lt;&amp;lt; SHIFT) + (PTIndex * &lt;span&gt;sizeof&lt;/span&gt;(PTE))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从页面目录获得的页面帧号（PFN）必须先左移到适当位置，然后再与页表索引组合以形成PTE的地址。假设如下为二级页表扁平化的片段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200623221134554-1852765420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上第1片段为页表目录，在其中存在索引到第2级页表的索引，还包括有效位，第2和第3片段分别为第1级页表目录索引对应的页表（其中包含保护位，可读？可写？等等），假设CPU产生虚拟地址（0xFE&lt;sub&gt;16&lt;/sub&gt; = 254&lt;sub&gt;10&lt;/sub&gt; = 11111110&lt;sub&gt;2&lt;/sub&gt;），由于我们假设虚拟地址空间为14位，所以将转换后的2进制不足用0填充即11111110000000，同时我们将地址空间进行虚拟页号（VPN）和虚拟页偏移量（VPO）划分，然后对VPN划分为页表目录和页表索引，我们通过红色、绿色、蓝色由左至右分别代表页表目录索引、页表索引、虚拟页偏移量即&lt;span&gt;1111&lt;/span&gt; &lt;span&gt;1110 &lt;/span&gt; &lt;span&gt;000000，&lt;span&gt;经过如此划分后，此时前4位（1111&lt;sub&gt;2&lt;/sub&gt; = 15&lt;sub&gt;10&lt;/sub&gt;）为页表目录索引，对应上述页表目录最后一行，此时页表目录帧号为101对应第2个页表片段，然后根据接下来的4位（1110&lt;sub&gt;2&lt;/sub&gt; = 14&lt;sub&gt;10&lt;/sub&gt;），最终得到索引为倒数第2行，即最终物理页帧号为55。最后我们通过如下物理地址计算公式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 PhysAddress = (PTE.PFN &amp;lt;&amp;lt; SHIFT) + offset
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 即最终物理地址为：55 * 2&lt;sup&gt;6 &lt;/sup&gt;+ 000000 = 3520&lt;sub&gt;10 &lt;/sub&gt;= 0XDC0&lt;sub&gt;16&lt;/sub&gt;。假设为32位地址空间，那么页目录索引、页表索引、虚拟页偏移量分别对应为10、10、12位，那么对应的2级页表将是如下形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200623223559139-822132628.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简而言之，对于32位地址空间，会将VPN中的前10位（位22..31）用于索引页表目录，紧接下来的10位（12 ..21）用于索引所选的页表。换言之，&lt;span&gt;对于2级页表结构其本质是：VPN的前m位为页表目录索引，而接下来的n位为页表索引，同时需要注意的是2级页表其地址是从上往下增加。&lt;span&gt;根据上述将32位地址空间中的页表以2级结构划分，此时第1级页表大小为（1024 * 4） = 4KB，而第2级页表为（1024 * 1024 * 4） = 4MB，所以页表大小将为4KB + 4MB，这么算来比直接使用单级页表结构为4MB情况更糟糕了不是吗，其实情况并不是这样，如上算出的4KB + 4MB为最极限的情况，上述已经讲解过只有经常需要用到的2级页表才缓存在主存中，所以实际情况下页表大小会小于4MB。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;早期操作系统采用的是2级页表结构，但是现如今大多数操作系统采用多级页表结构，就像树一样，不过是深度或层次更深了而已。假设我们有一个30位虚拟地址空间和一个较小的页面（512字节），因此，我们的虚拟地址具有21位的虚拟页号和9位的偏移量，&lt;span&gt;使页表的每个部分都适合单个页面是构建多级页表的目标&lt;/span&gt;，但到目前为止，我们仅考虑了页表本身，如果页表目录很大，那该怎么办？为了确定一个多级页表中需要多少级才能使页表的所有部分用一个页面容纳，我们首先确定一个页面中可以容纳多少个PTE。我们假设给定的页面大小为512字节，并假设PTE大小为4字节，我们知道在单个页面上可容纳128个PTE。当我们索引到页表的页面时，可以得出结论，我们需要使用VPN的最低有效7位（log&lt;sub&gt;2&lt;/sub&gt;128）作为索引&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200623232024966-672910050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过确定单页面需要容纳128个PTE，那么将占据地址空间7位，那么还剩下14位地址空间，如果将剩下的2&lt;sup&gt;14&lt;/sup&gt;作为页表目录， 那么将横跨128页而不再是1页，那么对于构建多级页表的目标将无法实现，为了解决这个问题，我们需要将14位进行再次划分，将页表目录进行设置为多页，页表目录位于上方从而指向另一页表目录，因此我们可以进行如下划分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200623233308446-59500105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，在索引上层页表目录时，我们使用虚拟地址的最高位（图中PD Index：0），该索引可用于从顶级页表目录中获取页表目录的条目，如果有效，则对来自自顶层PDE和VPN的下一部分（PD Index：1）的物理帧号组合来查询页表目录的第二层，最后，如果有效，则为PTE地址通过将页表索引与第二级PDE中的地址结合使用，可以形成一个地址。 当然这个过程需要做很多工作，所有这些都是为了在多级表中查找物理页帧号。最终多级页表结构如下这般&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200623234220511-605850906.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述我们讲过若为64位地址空间，4KB的页面（2&lt;sup&gt;12&lt;/sup&gt;）且每个PTE为4字节，在单级页表情况下，那么页表大小为16TB（4 * 2&lt;sup&gt;64 &lt;/sup&gt;/ 2&lt;sup&gt;12&lt;/sup&gt;）= 16TB，若我们划分为3级，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200628225829552-1286552744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么对于上述外部页即页目录索引将需要占内存4 * 2&lt;sup&gt;32&lt;/sup&gt; = 16GB，所以我们仍需继续划分层级，但是每个层级都有一个额外的间接方式，因此会产生额外的开销。比如64位地址空间在4KB页面上将使用大地址空间，所以多级页表成为具有小页的大地址空间的内存消耗。 &lt;/p&gt;
&lt;h2&gt;哈希页表&lt;/h2&gt;
&lt;p&gt;处理大于32位地址空间常用的方法是使用哈希页表（使用稀疏的地址空间），采用虚拟页码作为哈希值，对于每一个PTE使用链表结构存储从而解决冲突或碰撞，每个元素由三个字段组成：虚拟页码、映射的页帧、指向链表内下一个元素的指针。通过哈希算法将虚拟页码映射到哈希页表，然后将虚拟页码与链表第一个元素的第一个字段进行比较，若匹配则将第二个字段用来形成物理地址，否则遍历链表查找对应匹配项。哈希页表如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200628223530649-1647121281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然通过哈希页表查找很快，同时采用如上划重点标记的链表数据结构解决冲突问题，虽说消除了条目在内存中连续的需求，但是仍然以更高的内存开销进行存储即消耗更多内存，特别是如果页表是完整的，并且具有有效/无效位以使未使用的条目无效，那么哈希页表不再那么适用，此时我们采用其他方案，如下倒置页表。&lt;/p&gt;
&lt;h2&gt;倒置页表&lt;/h2&gt;
&lt;p&gt;通过前面内容学习我们知道对于每个进程都有一个关联的页表，该进程中的每一个虚拟页都在页表中对应一项，不管是否有效，进程通过虚拟地址引用页，操作系统通过计算虚拟地址在页表中的位置即PTE，但这种方式有明显的缺点，如上我们也叙述过，每个页表可能包含数以百万计的条目，如此一来，页表将占用大量的物理内存以跟踪其他物理内存是如何使用的，为解决这个问题，我们可以使用倒置页表（inverted page table），对于每个真正的内存页，倒置页表才有一个条目，每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息，因此，整个系统中所有进程将只有一个页表，并且每个物理内存的页只有一个相应的条目，换言之，与知道每个进程的虚拟页在哪里相反，现在我们知道拥有哪个物理页的进程与它对应的虚拟页。IBM是最早采用倒置页表的公司，从IBM System 38、RS/6000、到现代的IBM Power CPU。对于IBM  RT，系统的虚拟地址包含三部分：进程Id、页码、页偏移量，每个倒置页表条目包含两部分：进程Id、页码，这里的进程Id作为地址空间的标识符，当发生内存引用时，由进程Id和页码组成的虚拟地址被提交到内存子系统，然后搜索倒置页表来寻址匹配，如果找到匹配条目，则生成物理地址，如果未找到匹配条目则为非法地址访问。 倒置页表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200628222451566-1058375409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然倒置页表减少了存储每个页表所需的内存空间，但是它增加了由于引用页而查找页表所需要的时间，由于倒置页表是按照物理地址排序，而查找则是根据虚拟地址，因此查找匹配可能需要搜索整个表，这种搜索需要耗费很长时间，为解决这个问题，可以使用一个哈希表结构，从而将搜索限制在一个或最多数个页表条目，当然，每访问哈希表就增加了一次内存引用，因此每次虚拟地址的引用至少需要两个内存读，一个用于哈希表条目，另一个用于页表条目即PTE，同时结合前面所学，在搜索哈希表之前，肯定先搜索TLB，这样可大大提高性能。对于倒置页表还会带来一个问题，那就是实现共享内存，共享内存需要将多个虚拟地址映射到同一物理地址，很显然，这种标准的方式无法应用于倒置页表，因为每一个物理页只有一个虚拟页条目，一个物理页不可能有两个或多个共享的虚拟地址，所以为解决这个问题，只能允许页表包含一个虚拟地址到共享物理地址的映射，这也就意味着，对于未映射的虚拟地址的引用势必会导致页错误。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们非常详细的讨论了多级页表结构、对于哈希页表和倒置页表数据结构通过看图理解起来非常简单，从本节内容我们可总结出：对应页表结构可以拥有良好的时间复杂度或空间复杂度，但不能同时兼得。到此关于虚拟内存重要内容基本上都已囊括，若有遗漏，后续我会继续进行补充。接下来我们将进入内存管理分页和分段的学习，讲完之后，会陆续进入到程序的执行、进程、死锁、并发等，相信大家会比较感兴趣，感谢您的阅读，我们下节再见。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 00:09:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 在一个拥有32位的地址空间，4KB的页面（212），并且每个PTE为4个字节，那么页表大小为4MB（4 * 232&amp;#160;/ 212），但若为64位地址空间，4KB的页面（212）且每个PT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13167467.html</dc:identifier>
</item>
<item>
<title>小师妹学JVM之:JIT中的PrintAssembly - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-jit-printassembly.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-jit-printassembly.html</guid>
<description>&lt;p&gt;想不想了解JVM最最底层的运行机制？想不想从本质上理解java代码的执行过程？想不想对你的代码进行进一步的优化和性能提升？&lt;/p&gt;
&lt;p&gt;如果你的回答是yes。那么这篇文章非常适合你，因为本文将会站在离机器码最近的地方来观看JVM的运行原理：Assembly。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，上次你给我介绍了java中的字节码，还有JIT中的LogCompilation和PrintCompilation的用法。虽然都非常有用，但是能不能更进一步，让我能以机器的眼光来看待JVM的执行？&lt;/p&gt;
&lt;p&gt;小师妹，如果要探究JVM的运行本质，那就应该是机器码了。难道你要去读懂机器码？虽然我不是机器码的专家，但我猜那应该是个非常复杂的过程。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，当然不是机器码，有没有比机器码更高级一点点的，我记得上大学的时候学过汇编语言，好像就是离机器码最近的语言了，JVM有没有相应的汇编语言呢？&lt;/p&gt;
&lt;p&gt;必须有的，我们可以使用-XX:+PrintAssembly来将assembly打印出来。&lt;/p&gt;
&lt;p&gt;但是打印assembly是有条件的，它就像一个高傲的姑娘，不是你想追求就能追求得上的。&lt;/p&gt;
&lt;p&gt;我们使用下面的命令来查看系统对PrintAssembly的支持程度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version

Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output
Could not load hsdis-amd64.dylib; library not loadable; PrintAssembly is disabled
java version &quot;1.8.0_171&quot;
Java(TM) SE Runtime Environment (build 1.8.0_171-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据大家的运行环境的不同，得到的结果可能也是不同的，我是mac的系统，从上面的结果可以看到，在我的JDK8的环境中，显示缺少hsdis-amd64.dylib，所以PrintAssembly其实是禁用的。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，那现在咋办呀？没有hsdis-amd64.dylib就用不了PrintAssembly了。&lt;/p&gt;
&lt;p&gt;巴甫洛夫说过：问号是开启任何一门科学的钥匙。没有问题我们就创造问题，没有困难我们就制造困难，没有hsdis-amd64.dylib当然是安装咯。&lt;/p&gt;
&lt;p&gt;具体怎么安装，大家自行探索吧，网上有很多安装的教程，这里就不一一介绍了。&lt;/p&gt;
&lt;p&gt;这里想讨论一个很奇怪的事情，虽然在JDK8环境中，我们不能使用PrintAssembly，因为没有hsdis-amd64.dylib。但是当我切到最新的JDK14环境中，一切都很美好，PrintAssembly可以正常运行了。&lt;/p&gt;
&lt;p&gt;如果我们在JDK14中同样运行上面的命令，我们会得到下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200530193157627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图说明JDK14中虽然可以正常运行但是结果却不是assembly code，说明在JDK14中还是需要安装hsdis-amd64.dylib才能够得到正确的assembly结果。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，JDK14也需要安装hsdis-amd64.dylib才能正确使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;默认情况下，PrintAssembly输出的是所有的信息，但是JDK内部的代码我们不可能进行修改，一般来说并不关心他们的assembly输出，如果要指定我们自己编写的方法，可以使用CompileCommand：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;CompileCommand=print,*MyClass.myMethod prints assembly for just one method
CompileCommand=option,*MyClass.myMethod,PrintOptoAssembly (debug build only) produces the old print command output
CompileCommand=option,*MyClass.myMethod,PrintNMethods produces method dumps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:CompileCommand=print,com.flydean.PrintAssemblyUsage::testPrintAssembly
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们可以得到，只属于testPrintAssembly方法的输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200530194133803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文讲解了怎么使用PrintAssembly来输出JVM的汇编日志。我们会在后面继续讲解这些Assembly code到底有什么用。&lt;/p&gt;
&lt;p&gt;本文的例子&lt;a href=&quot;https://github.com/ddean2009/learn-java-base-9-to-20&quot;&gt;https://github.com/ddean2009/learn-java-base-9-to-20&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.5373134328358&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-jit-printassembly/&quot;&gt;http://www.flydean.com/jvm-jit-printassembly/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 28 Jun 2020 23:35:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 想不想了解JVM最最底层的运行机制？想不想从本质上理解java代码的执行过程？想不想对你的代码进行进一步的优化和性能提升？ 如果你的回答是yes。那么这篇文章非常适合你，因为本文将会站在离机器码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-jit-printassembly.html</dc:identifier>
</item>
<item>
<title>没想到，这么简单的线程池用法，深藏这么多坑！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13205944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13205944.html</guid>
<description>&lt;h2 id=&quot;又又又踩坑了&quot;&gt;又又又踩坑了&lt;/h2&gt;
&lt;p&gt;生产有个对账系统，每天需要从渠道端下载对账文件，然后开始日终对账。这个系统已经运行了很久，前两天突然收到短信预警，没有获取渠道端对账文件。&lt;/p&gt;
&lt;blockquote readability=&quot;2.8571428571429&quot;&gt;
&lt;p&gt;ps:对账系统详细实现方式：&lt;a href=&quot;https://studyidea.cn/articles/2019/08/26/1566790305561.html&quot;&gt;对账系统设计与实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本以为又是渠道端搞事情，上去一排查才发现，所有下载任务都被阻塞了。再进一步排查源码，才发现自己一直用错了线程池某个方法。&lt;/p&gt;
&lt;p&gt;由于线程创建比较昂贵，正式项目中我们都会使用线程池执行异步任务。线程池，使用池化技术保存线程对象，使用的时候直接取出来，用完归还以便使用。&lt;/p&gt;
&lt;p&gt;虽然线程池的使用非常方法非常简单，但是越简单，越容易踩坑。细数一下，这些年来因为线程池导致生产事故也有好几起。&lt;/p&gt;
&lt;p&gt;所以今天，小黑哥就针对线程池的话题，给大家演示一下怎么使用线程池才会踩坑。&lt;/p&gt;
&lt;p&gt;希望大家看完，可以完美避开这些坑~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看，养成习惯。微信搜索「&lt;strong&gt;程序通事&lt;/strong&gt;」，关注就完事了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;慎用-executors-组件&quot;&gt;慎用 Executors 组件&lt;/h2&gt;
&lt;p&gt;Java 从 JDK1.5 开始提供线程池的实现类，我们只需要在构造函数内传入相关参数，就可以创建一个线程池。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072838218-525629317.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过线程池的构造函数可以说非常复杂，就算最简单的那个构造函数，也需要传入 5 个参数。这对于新手来说，非常不方便哇。&lt;/p&gt;
&lt;p&gt;也许 JDK 开发者也考虑到这个问题，所以&lt;em&gt;非常贴心&lt;/em&gt;给我们提供一个工具类 &lt;code&gt;Executors&lt;/code&gt;，用来快捷创建创建线程池。&lt;/p&gt;
&lt;p&gt;虽然这个工具类使用真的非常方便，可以少写很多代码，但是小黑哥还是建议生产系统还是老老实实手动创建线程池，慎用&lt;code&gt;Executors&lt;/code&gt;，尤其是工具类中两个方法 &lt;code&gt;Executors#newFixedThreadPool&lt;/code&gt;与 &lt;code&gt;Executors#newCachedThreadPool&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你图了方便使用上述方法创建了线程池，那就是一颗定时炸弹，说不准那一天生产系统就会💥。&lt;/p&gt;
&lt;p&gt;我们来看两个🌰，看下这个这两个方法会有什么问题。&lt;/p&gt;
&lt;p&gt;假设我们有个应用有个批量接口，每次请求将会下载 100w 个文件，这里我们使用 &lt;code&gt;Executors#newFixedThreadPool&lt;/code&gt;批量下载。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;下面方法中，我们随机休眠，模拟真实下载耗时。&lt;/p&gt;
&lt;p&gt;为了快速复现问题，调整 JVM 参数为 &lt;code&gt;-Xmx128m -Xms128m&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private ExecutorService threadPool = Executors.newFixedThreadPool(10);

/**
 * 批量下载对账文件
 *
 * @return
 */
@RequestMapping(&quot;/batchDownload&quot;)
public String batchDownload() {
    
    // 模拟下载 100w 个文件
    for (int i = 0; i &amp;lt; 1000000; i++) {
        threadPool.execute(() -&amp;gt; {
            // 随机休眠，模拟下载耗时
            Random random = new Random();
            try {
                TimeUnit.SECONDS.sleep(random.nextInt(100));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    return &quot;process&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行之后，多请求几次这个批量下载方法，程序很快就会 &lt;strong&gt;OOM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072838550-249991873.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;Executors#newFixedThreadPool&lt;/code&gt;源码，我们可以看到这个方法创建了一个默认的 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 当做任务队列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个问题槽点就在于 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt;，这个队列的默认构造方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Creates a {@code LinkedBlockingQueue} with a capacity of
 * {@link Integer#MAX_VALUE}.
 */
public LinkedBlockingQueue() {
    this(Integer.MAX_VALUE);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 队列时，如果我们不指定队列数量，默认数量上限为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;。这么大的数量，我们简直可以当做无界队列了。&lt;/p&gt;
&lt;p&gt;上面我们使用 &lt;code&gt;newFixedThreadPool&lt;/code&gt;，我们仅使用了固定数量的线程下载。如果线程都在执行任务，线程池将会任务加入任务队列中。&lt;/p&gt;
&lt;p&gt;如果线程池执行任务过慢，任务将会一直堆积在队列中。由于我们队列可以认为是无界的，可以无限制添加任务，这就导致内存占用越来越高，直到 &lt;strong&gt;OOM&lt;/strong&gt; 爆仓。&lt;/p&gt;
&lt;blockquote readability=&quot;0.78125&quot;&gt;
&lt;p&gt;ps：&lt;a href=&quot;https://studyidea.cn/articles/2019/12/01/1575187296406.html&quot;&gt;线程池基本工作原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们将上面的例子稍微修改一下，使用 &lt;code&gt;newCachedThreadPool&lt;/code&gt; 创建线程池。&lt;/p&gt;
&lt;p&gt;程序运行之后，多请求几次这个批量下载方法，程序很快就会 &lt;strong&gt;OOM&lt;/strong&gt; ，不过这次报错信息与之前信息与之前不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072838726-1488942318.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从报错信息来看，这次 &lt;strong&gt;OOM&lt;/strong&gt; 的主要原因是因为无法再创建新的线程。&lt;/p&gt;
&lt;p&gt;这次看下一下 &lt;code&gt;newCachedThreadPool&lt;/code&gt; 方法的源码，可以看到这个方法将会创建最大线程数为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的的线程池。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072838929-2071169763.jpg&quot; alt=&quot;image-20200627180428310&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这个线程池使用 &lt;code&gt;SynchronousQueue&lt;/code&gt; 队列，这个队列比较特殊，没办法存储任务。所以默认情况下，线程池只要接到一个任务，就会创建一个线程。&lt;/p&gt;
&lt;p&gt;一旦线程池收到大量任务，就会创建大量线程。Java 中的线程是会占用一定的内存空间 ，所以创建大量的线程是必然会导致 &lt;strong&gt;OOM&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看，养成习惯。微信搜索「&lt;strong&gt;程序通事&lt;/strong&gt;」，关注就完事了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;复用线程池&quot;&gt;复用线程池&lt;/h2&gt;
&lt;p&gt;由于线程池的构造方法比较复杂，而 &lt;code&gt;Executors&lt;/code&gt; 创建的线程池比较坑，所以我们有个项目中自己封装了一个线程池工具类。&lt;/p&gt;
&lt;p&gt;工具类代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ThreadPoolExecutor getThreadPool() {
    // 为了快速复现问题，故将线程池 核心线程数与最大线程数设置为 100
    return new ThreadPoolExecutor(100, 100, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&amp;lt;&amp;gt;(200));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目代码中这样使用这个工具类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(&quot;/batchDownload&quot;)
public String batchDownload() {
    ExecutorService threadPool = ThreadPoolUtils.getThreadPool();

    // 模拟下载 100w 个文件
    for (int i = 0; i &amp;lt; 100; i++) {
        threadPool.execute(() -&amp;gt; {
            // 随机休眠，模拟下载耗时
            Random random = new Random();
            try {
                TimeUnit.SECONDS.sleep(random.nextInt(100));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    return &quot;process&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;strong&gt;WRK&lt;/strong&gt; 工具对这个接口同时发起多个请求，很快应用就会抛出 &lt;strong&gt;OOM&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072839051-912204887.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次请求都会创建一个新的线程池执行任务，如果短时间内有大量的请求，就会创建很多的线程池，间接导致创建很多线程。从而导致内存占尽，发生 &lt;strong&gt;OOM&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;p&gt;这个问题修复办法很简单，要么工具类生成一个单例线程池，要么项目代码中复用创建出来的线程池。&lt;/p&gt;
&lt;h2 id=&quot;spring-异步任务&quot;&gt;Spring 异步任务&lt;/h2&gt;
&lt;p&gt;上面代码中我们都是自己创建一个线程池执行异步任务，这样还是比较麻烦。在 Spring 中， 我们可以在方法上使用 Spring 注解 &lt;strong&gt;@Async&lt;/strong&gt;，然后执行异步任务。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Async
public void async() throws InterruptedException {
    log.info(&quot;async process&quot;);
    Random random = new Random();
    TimeUnit.SECONDS.sleep(random.nextInt(100));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过使用 Spring 异步任务，我们需要自定义线程池，不然大量请求下，还是有可能发生 &lt;strong&gt;OOM&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;p&gt;这是原因主要是 Spring 异步任务默认使用 Spring 内部线程池 &lt;code&gt;SimpleAsyncTaskExecutor&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072839226-621408308.jpg&quot; alt=&quot;image-20200627191850022&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个线程池比较坑爹，不会&lt;strong&gt;复用线程&lt;/strong&gt;。也就是说来一个请求，将会新建一个线程。&lt;/p&gt;
&lt;p&gt;所以如果需要使用异步任务，一定要使用自定义线程池替换默认线程池。&lt;/p&gt;
&lt;p&gt;如果使用 XML 配置，我们可以增加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;task:executor id=&quot;myexecutor&quot; pool-size=&quot;5&quot;  /&amp;gt;
&amp;lt;task:annotation-driven executor=&quot;myexecutor&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用注解配置，我们需要设置一个 Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(name = &quot;threadPoolTaskExecutor&quot;)
public Executor threadPoolTaskExecutor() {
    ThreadPoolTaskExecutor executor=new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);
    executor.setMaxPoolSize(10);
    executor.setThreadNamePrefix(&quot;test-%d&quot;);
    // 其他设置
    return new ThreadPoolTaskExecutor();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用注解时指定线程池名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Async(&quot;threadPoolTaskExecutor&quot;)
public void xx() {
    // 业务逻辑
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是 SpringBoot 项目，从本人测试情况来看，默认将会创建核心线程数为 8，最大线程数为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，队列数也为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;线程池。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps:以下代码基于 Spring-Boot 2.1.6-RELEASE，暂不确定 Spring-Boot 1.x 版本是否也是这种策略，熟悉的同学的，也可以留言指出一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072839469-60177754.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然上面的线程池不用担心创建过多线程的问题，不是还是有可能队列任务过多，导致 &lt;strong&gt;OOM&lt;/strong&gt; 的问题。所以还是建议使用自定义线程池吗，或者在配置文件修改默认配置，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JAVA&quot;&gt;spring.task.execution.pool.core-size=10
spring.task.execution.pool.max-size=20
spring.task.execution.pool.queue-capacity=200
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.3015873015873&quot;&gt;
&lt;p&gt;Spring 相关踩坑案例： &lt;a href=&quot;https://studyidea.cn/spring-scheduler&quot;&gt;Spring 定时任务突然不执行&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程池方法使用不当&quot;&gt;线程池方法使用不当&lt;/h2&gt;
&lt;p&gt;最后再来说下文章开头的我踩到的这个坑，这个问题主要是因为理解错这个方法。&lt;/p&gt;
&lt;p&gt;错误代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建线程池
ExecutorService threadPool = ...
List&amp;lt;Callable&amp;lt;String&amp;gt;&amp;gt; tasks = new ArrayList&amp;lt;&amp;gt;();
// 批量创建任务
for (int i = 0; i &amp;lt; 100; i++) {
    tasks.add(() -&amp;gt; {
        Random random = new Random();
        try {
            TimeUnit.SECONDS.sleep(random.nextInt(100));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;success&quot;;
    });
}
// 执行所有任务
List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = threadPool.invokeAll(tasks);
// 获取结果
for (Future&amp;lt;String&amp;gt; future : futures) {
    try {
        future.get();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，使用 &lt;code&gt;invokeAll&lt;/code&gt;执行所有任务。由于这个方法返回值为 &lt;code&gt;List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;，我误以为这个方法如 &lt;code&gt;submit&lt;/code&gt;一样，异步执行，不会阻塞主线程。&lt;/p&gt;
&lt;p&gt;实际上从源码上，这个方法实际上逐个调用 &lt;code&gt;Future#get&lt;/code&gt;获取任务结果，而这个方法会同步阻塞主线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072839735-1946140307.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦某个任务被永久阻塞，比如 &lt;strong&gt;Socket&lt;/strong&gt; 网络连接位置超时时间，导致任务一直阻塞在网络连接，间接导致这个方法一直被阻塞，从而影响后续方法执行。&lt;/p&gt;
&lt;p&gt;如果需要使用 &lt;code&gt;invokeAll&lt;/code&gt; 方法，最好使用其另外一个重载方法，设置超时时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200629072839976-1449802694.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天文章通过几个例子，给大家展示了一下线程池使用过程一些坑。为了快速复现问题，上面的示例代码还是比较极端，实际中可能并不会这么用。&lt;/p&gt;
&lt;p&gt;不过即使这样，我们千万不要抱着侥幸的心理，认为这些任务很快就会执行结束。我们在生产上碰到好几次事故，正常的情况执行都很快。但是偶尔外部程序抽疯，返回时间变长，就可能导致系统中存在大量任务，导致 &lt;strong&gt;OOM&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后总结一下几个线程池几个最佳实践：&lt;/p&gt;
&lt;p&gt;第一，生产系统慎用 &lt;code&gt;Executors&lt;/code&gt; 类提供的便捷方法，我们需要自己根据自己的业务场景，配置合理的线程数，任务队列，拒绝策略，线程回收策略等等，并且一定记得自定义线程池的命名方式，以便于后期排查问题。&lt;/p&gt;
&lt;p&gt;第二，线程池不要重复创建，每次都创建一个线程池可能比不用线程池还要糟糕。如果使用其他同学创建的线程池工具类，最好还是看一下实现方式，防止自己误用。&lt;/p&gt;
&lt;p&gt;第三，一定不要按照自己的&lt;strong&gt;片面理解&lt;/strong&gt;去使用 API 方法，如果把握不准，一定要去看下方法上注释以及相关源码。&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 28 Jun 2020 23:29:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>又又又踩坑了 生产有个对账系统，每天需要从渠道端下载对账文件，然后开始日终对账。这个系统已经运行了很久，前两天突然收到短信预警，没有获取渠道端对账文件。 ps:对账系统详细实现方式：对账系统设计与实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13205944.html</dc:identifier>
</item>
<item>
<title>【Flutter实战】自定义滚动条 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13205929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13205929.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064618730-1472621111.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.9203539823009&quot;&gt;
&lt;p&gt;老孟导读：【Flutter实战】系列文章地址：&lt;a href=&quot;http://laomengit.com/guide/introduction/mobile_system.html&quot;&gt;http://laomengit.com/guide/introduction/mobile_system.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下，Flutter 的滚动组件（比如 ListView）没有显示滚动条，使用 &lt;strong&gt;Scrollbar&lt;/strong&gt; 显示滚动条：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Scrollbar(
  child: ListView.builder(
    reverse: false,
    itemBuilder: (BuildContext context, int index) {
      return Card(
        child: Container(
          height: 45,
          alignment: Alignment.center,
          child: Text('$index'),
        ),
      );
    },
    itemCount: 30,
    itemExtent: 50,
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064619235-126407669.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在滑动的过程中，右侧显示滚动条，然而 Scrollbar 无法实现自定义滚动条的样式，比如实现如下滚动条样式，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064620166-517280562.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时需要自定义一个滚动条组件。&lt;/p&gt;
&lt;p&gt;实现自定义滚动条组件首先需要监听滚动组件 &lt;strong&gt;滚动的位置&lt;/strong&gt;，使用 &lt;strong&gt;NotificationListener&lt;/strong&gt; 监听滚动的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;bool _handleScrollNotification(ScrollNotification notification) {
    final ScrollMetrics metrics = notification.metrics;
    print('滚动组件最大滚动距离:${metrics.maxScrollExtent}');
    print('当前滚动位置:${metrics.pixels}');
    return true;
  }

  @override
  Widget build(BuildContext context) {
    return NotificationListener&amp;lt;ScrollNotification&amp;gt;(
      onNotification: _handleScrollNotification,
      child: ListView.builder(
        reverse: false,
        itemBuilder: (BuildContext context, int index) {
          return Card(
            child: Container(
              height: 45,
              alignment: Alignment.center,
              child: Text('$index'),
            ),
          );
        },
        itemCount: 30,
        itemExtent: 50,
      ),
    );
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;strong&gt;ScrollNotification&lt;/strong&gt; 获取当前滚动组件最大滚动距离和当前滚动位置，其中 &lt;strong&gt;metrics.maxScrollExtent&lt;/strong&gt; 表示当前滚动组件最大滚动距离，&lt;strong&gt;metrics.pixels&lt;/strong&gt; 表示当前滚动位置。&lt;/p&gt;
&lt;p&gt;通过这两个值计算滚动条在当前屏幕的位置，通过 Stack 组件 将 ListView 和 自定义的滚动条进行叠加显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;NotificationListener&amp;lt;ScrollNotification&amp;gt;(
  onNotification: _handleScrollNotification,
  child: Stack(
    alignment: Alignment.topRight,
    children: &amp;lt;Widget&amp;gt;[
      ListView.builder(
        reverse: false,
        itemBuilder: (BuildContext context, int index) {
          return Card(
            child: Container(
              height: 45,
              alignment: Alignment.center,
              child: Text('$index'),
            ),
          );
        },
        itemCount: 30,
        itemExtent: 50,
      ),
      //滚动条
      Container(
        height: 100,
        width: 20,
        color: Colors.red,
      )
    ],
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064620547-578132195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将此滚动条和 NotificationListener 监听到的滚动事件联动，通过 Container 的 alignment 属性控制滚动条的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  alignment: Alignment(1, _alignmentY),
  padding: EdgeInsets.only(right: 5),
  child: Container(
    height: 100,
    width: 20,
    color: Colors.red,
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;_alignmentY&lt;/strong&gt; 就是计算出的偏移位置，计算方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_alignmentY = -1 + (metrics.pixels / metrics.maxScrollExtent) * 2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意 alignment 的坐标系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064620782-1071224977.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064621087-489547514.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后只需修改滚动条的样式即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _ScrollBar extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 18,
      height: 60,
      decoration: BoxDecoration(
          shape: BoxShape.rectangle,
          borderRadius: BorderRadius.all(Radius.circular(20)),
          color: Colors.blue),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: &amp;lt;Widget&amp;gt;[
          Icon(
            Icons.arrow_drop_up,
            size: 18,
          ),
          Icon(
            Icons.arrow_drop_down,
            size: 18,
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064621636-296245207.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后将代码封装，就可以给所有的滚动组件添加自定义的滚动条，而不仅仅是 ListView。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064622227-1024203612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200629064622525-380382954.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sun, 28 Jun 2020 22:46:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：【Flutter实战】系列文章地址：http://laomengit.com/guide/introduction/mobile_system.html 默认情况下，Flutter 的滚动组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13205929.html</dc:identifier>
</item>
<item>
<title>socketserver模块使用与源码分析 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13205917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13205917.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在前面的学习中我们其实已经可以通过&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块来建立我们的服务端，并且还介绍了关于TCP协议的粘包问题。但是还有一个非常大的问题就是我们所编写的Server端是不支持并发性服务的，在我们之前的代码中只能加入一个通信循环来进行排队式的单窗口一对一服务。那么这一篇文章将主要介绍如何使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块来建立具有并发性的Server端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;基于TCP协议的socketserver服务端&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们先看它的一段代码，对照代码来看功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; _*_ coding:utf-8 _*_&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ==== 使用socketserver创建支持多并发性的服务器 TCP协议 ====&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socketserver

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyServer(socketserver.BaseRequestHandler):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;自定义类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;handle处理请求&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;双向链接通道建立完成:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, self.request)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对于TCP协议来说，self.request相当于双向链接通道conn，即accept()的第一部分&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端的信息是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, self.client_address)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对于TCP协议来说，相当于accept()的第二部分，即客户端的ip+port&lt;/span&gt;

        &lt;span&gt;while&lt;/span&gt; 1:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始内层通信循环&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # bug修复：针对windows环境&lt;/span&gt;
                data = self.request.recv(1024&lt;span&gt;)

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; bug修复：针对类UNIX环境&lt;/span&gt;

                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到客户机[{0}]的消息:[{1}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.client_address, data))
                self.request.sendall(data.upper())  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; #sendall是重复调用send.&lt;/span&gt;

            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

        self.request.close()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当出现异常情况下一定要关闭链接&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    s1 &lt;/span&gt;= socketserver.ThreadingTCPServer((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6666), MyServer) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 公网服务器绑定 0.0.0.0 私网测试为 127.0.0.1&lt;/span&gt;
    s1.serve_forever()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动服务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;30&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;1.导入&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;2.创建一个新的类，并继承&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver.BaseRequestHandler&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;3.覆写&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法，对于TCP协议来说，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.request&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;相当于双向链接通道&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;conn&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.client_address&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;相当于被服务方的ip和port信息，也就是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;addr&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，而整个&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法相当于链接循环。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;4.写入收发逻辑规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;5.防止客户端发送空的消息已致双方卡死&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;6.防止客户端突然断开已致服务端崩溃&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;7.粘包优化（可选）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;8.实例化 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver.ThreadingTCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类，并传入IP+port，以及刚写好的类名&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;9.使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver.ThreadingTCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;实例化对象中的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;server_forever( )&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法启动服务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;它其实是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　　　&lt;span class=&quot;md-plain&quot;&gt;我们不用管链接循环，因为在执行&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法之前内部已经帮我们做好了。当我们使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;serve_forever()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法的时候便开始监听链接描述符对象，一旦有链接请求就创建一个子线程来处理该链接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基于UDP协议的socketserver服务端&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;基于UDP协议的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;服务端与基于TCP协议的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;服务端大相径庭，但是还是有几点不太一样的地方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;对TCP来说：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.request = 双向链接通道（conn）&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;对UDP来说：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.request = (client_data_byte,udp的套接字对象)&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; _*_ coding:utf-8 _*_&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ==== 使用socketserver创建支持多并发性的服务器 UDP协议 ====&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socketserver

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyServer(socketserver.BaseRequestHandler):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;自定义类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;handle处理请求&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于UDP是基于消息的协议，故根本不用通信循环&lt;/span&gt;
&lt;span&gt;
        data &lt;/span&gt;= self.request[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对于UDP协议来说，self.request其实是个元组。第一个元素是消息内容主题（Bytes类型),相当于recvfrom()的第一部分&lt;/span&gt;
        server = self.request[1]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二个元素是服务端本身，即自己&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端的信息是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, self.client_address)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对于UDP协议来说，相当于recvfrom()的第二部分，即客户端的ip+port&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到客户机[{0}]的消息:[{1}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.client_address, data))
        server.sendto(data.upper(),self.client_address)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    s1 &lt;/span&gt;= socketserver.ThreadingUDPServer((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6666), MyServer)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 公网服务器绑定 0.0.0.0 私网测试为 127.0.0.1&lt;/span&gt;
    s1.serve_forever()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动服务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;扩展：socketserver源码分析&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;探索socketserver中的继承关系&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;好了，接下来我们开始剖析&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块中的源码部分。在Pycharm下使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;CTRL+鼠标左键&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，可以进入源码进行查看。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们在查看源码前一定要首先要明白两点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类分为两部分，其一是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;server&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类主要是负责处理链接方面，另一类是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类主要负责处理通信方面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;好了，请在脑子里记住这个概念。我们来看一些&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块的实现用了哪些其他的基础模块。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;注意，接下来的源码注释部分我并没有在源代码中修改，也请读者不要修改源代码的任何内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f08cd373-95e3-4936-8053-ecd8fb95803f')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_f08cd373-95e3-4936-8053-ecd8fb95803f&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_f08cd373-95e3-4936-8053-ecd8fb95803f&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f08cd373-95e3-4936-8053-ecd8fb95803f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; socket  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这模块挺熟悉吧&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; selectors  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个是一个多线程模块，主要支持I/O多路复用。&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; os &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 老朋友了&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; sys  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 老朋友&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; threading  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多线程模块&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; io &lt;span&gt;import&lt;/span&gt; BufferedIOBase  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读写相关的模块&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt; monotonic as time  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 老朋友time模块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;socketserver中用到的基础模块&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;好了，让我们接着往下走。可以看到一个变量&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__all__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，是不是觉得很熟悉？就是我们使用 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;from xxx import xxx&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;能导入进的东西全是被&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__all__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;控制的，我们看一下它包含了哪些内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('84c01e25-d906-469c-8784-b403fd900932')&quot; readability=&quot;41.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_84c01e25-d906-469c-8784-b403fd900932&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_84c01e25-d906-469c-8784-b403fd900932&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_84c01e25-d906-469c-8784-b403fd900932&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__all__&lt;/span&gt; = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TCPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UDPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadingUDPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadingTCPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BaseRequestHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StreamRequestHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DatagramRequestHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadingMixIn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
           
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个是我们原本的 __all__ 中的值。&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(os, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;.extend([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForkingUDPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForkingTCPServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForkingMixIn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(socket, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AF_UNIX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;.extend([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnixStreamServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnixDatagramServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadingUnixStreamServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadingUnixDatagramServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
                    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上面两个if判断是给__all__添加内容的，os.fork()这个方法是创建一个新的进程，并且只在类UNIX平台下才有效，Windows平台下是无效的，所以这里对于Windows平台来说就from socketserver import xxx 肯定少了三个类，这三个类的作用我们接下来会聊到。而关于socket中的AF_UNIX来说我们其实已经学习过了，是基于文件的socket家族。这在Windows上也是不支持的，只有在类UNIX平台下才有效。所以Windows平台下的导入又少了4个类。&lt;/span&gt;
&lt;span&gt;​
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; poll/select have the advantage of not requiring any extra file descriptor,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; contrarily to epoll/kqueue (also, they require a single syscall).&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; hasattr(selectors, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PollSelector&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    _ServerSelector &lt;/span&gt;=&lt;span&gt; selectors.PollSelector
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    _ServerSelector &lt;/span&gt;=&lt;span&gt; selectors.SelectSelector
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这两个if还是做I/O多路复用使用的，Windows平台下的结果是False，而类Unix平台下的该if结果为True，这关乎I/O多路复用的性能选择。到底是select还是poll或者epoll。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;socketserver模块对于from xxx import * 导入的处理&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们接着向下看源码，会看到许许多多的类。先关掉它来假设自己是解释器一行一行往下走会去执行那个部分。首先是一条&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;判断&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e17ebda5-3ab8-4908-a6b4-ab324499eba6')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e17ebda5-3ab8-4908-a6b4-ab324499eba6&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e17ebda5-3ab8-4908-a6b4-ab324499eba6&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e17ebda5-3ab8-4908-a6b4-ab324499eba6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; hasattr(os, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ForkingMixIn:
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里我自己省略了&lt;/span&gt;
 
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 我们可以看见这条代码是接下来执行的，它意思还是如果在类Unix环境下，则会去创建该类。如果在Windows平台下则不会创建该类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;处理点一&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;继续走，其实这种&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;判断再创建类的地方还有两处。我这里全部列出来：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('07ecce26-ae5f-42e3-87ce-7c7428bef01a')&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_07ecce26-ae5f-42e3-87ce-7c7428bef01a&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_07ecce26-ae5f-42e3-87ce-7c7428bef01a&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_07ecce26-ae5f-42e3-87ce-7c7428bef01a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; hasattr(os, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ForkingUDPServer(ForkingMixIn, UDPServer): &lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt; ForkingTCPServer(ForkingMixIn, TCPServer): &lt;span&gt;pass&lt;/span&gt;
 

&lt;span&gt;if&lt;/span&gt; hasattr(socket, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AF_UNIX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
​
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnixStreamServer(TCPServer):
        address_family &lt;/span&gt;=&lt;span&gt; socket.AF_UNIX
​
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnixDatagramServer(UDPServer):
        address_family &lt;/span&gt;=&lt;span&gt; socket.AF_UNIX
​
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): &lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
​
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;处理点二 and 三&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;好了，说完了大体粗略的一个流程，我们该来研究这里面的类都有什么作用，这里可以查看每个类的文档信息。大致如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;前面已经说过，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块中主要分为两大类，我们就依照这个来进行划分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th colspan=&quot;2&quot;&gt;&lt;span&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;socketserver模块源码内部class功能一览&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;处理链接相关&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;BaseServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基础链接类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;TCPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;TCP协议类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;UDPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;UDP协议类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;UnixStreamServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;文件形式字节流类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;UnixDatagramServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;文件形式数据报类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;处理通信相关&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;BaseRequestHandler&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基础请求处理类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;StreamRequestHandler&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;字节流请求处理类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;DatagramRequestHandler&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数据报请求处理类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;多线程相关&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ThreadingMixIn&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;线程方式&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ThreadingUDPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多线程UDP协议服务类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ThreadingTCPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多线程TCP协议服务类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;多进程相关&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ForkingMixIn&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;进程方式&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ForkingUDPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多进程UDP协议服务类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ForkingTCPServer&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多进程TCP协议服务类&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;他们的继承关系如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ForkingUDPServer(ForkingMixIn, UDPServer)
​
ForkingTCPServer(ForkingMixIn, TCPServer)
​
ThreadingUDPServer(ThreadingMixIn, UDPServer)
​
ThreadingTCPServer(ThreadingMixIn, TCPServer)
​
StreamRequestHandler(BaseRequestHandler)
​
DatagramRequestHandler(BaseRequestHandler)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;处理链接相关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144653156-498089880.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144653156-498089880.png&quot; alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;处理通信相关&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144717893-2050885624.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144717893-2050885624.png&quot; alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多线程相关&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144905036-1823156711.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144905036-1823156711.png&quot; alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总继承关系（处理通信相关的不在其中，并且不包含多进程）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144803375-1766688942.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1050792/201811/1050792-20181114144803375-1766688942.png&quot; alt=&quot;img&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;最后补上一个多进程的继承关系，就不放在总继承关系中了，容易图形造成混乱。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多进程相关&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055545985-907415389.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055545985-907415389.png&quot; alt=&quot;image-20200629020157389&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;实例化过程分析&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;有了继承关系我们可以来模拟实例化的过程，我们以TCP协议为准：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
socketserver.ThreadingTCPServer((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6666), MyServer)
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们点进（选中上面代码的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThradingTCPServe&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;r部分，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;CTRL+鼠标左键&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;）源码部分，查找其 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; ThreadingTCPServer(ThreadingMixIn, TCPServer): &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;看来没有，那么就找第一父类有没有，我们点进去可以看到第一父类&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;也没有&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法，看上面的继承关系图可以看出是普通多继承，那么就是广度优先的查找顺序。我们来看第二父类&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中有没有，看来第二父类中是有&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法的，我们详细来看。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('10b0e097-0700-4776-ab16-f5423a9e32ba')&quot; readability=&quot;36&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_10b0e097-0700-4776-ab16-f5423a9e32ba&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_10b0e097-0700-4776-ab16-f5423a9e32ba&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_10b0e097-0700-4776-ab16-f5423a9e32ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TCPServer(BaseServer):

   &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释全被我删了，影响视线&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    address_family &lt;/span&gt;= socket.AF_INET  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  基于网络的套接字家族&lt;/span&gt;
&lt;span&gt;
    socket_type &lt;/span&gt;= socket.SOCK_STREAM  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TCP（字节流）协议&lt;/span&gt;
&lt;span&gt;
    request_queue_size &lt;/span&gt;= 5  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 消息队列最大为5，可以理解为backlog，即半链接池的大小&lt;/span&gt;
&lt;span&gt;
    allow_reuse_address &lt;/span&gt;= False  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口重用默认关闭&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, server_address, RequestHandlerClass, bind_and_activate=&lt;span&gt;True):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Constructor.  May be extended, do not override.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        BaseServer.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, server_address, RequestHandlerClass)
        self.socket &lt;/span&gt;=&lt;span&gt; socket.socket(self.address_family,
                                    self.socket_type)
                                    
       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看见，上面先是调用了父类的__init__方法，然后又实例化出了一个socket对象！所以我们先不着急往下看，先看其父类中的__init__方法。&lt;/span&gt;
       
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; bind_and_activate:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.server_bind()
                self.server_activate()
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
                self.server_close()
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TCPServer中的__init__()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;来看一下，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类中的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('109baff3-fc59-4a40-8b74-a90940b6b4c0')&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_109baff3-fc59-4a40-8b74-a90940b6b4c0&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_109baff3-fc59-4a40-8b74-a90940b6b4c0&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_109baff3-fc59-4a40-8b74-a90940b6b4c0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseServer:

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释依旧全被我删了&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    timeout &lt;/span&gt;= None  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个变量可以理解为超时时间，先不着急说他。先看 __init__ 方法&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, server_address, RequestHandlerClass):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Constructor.  May be extended, do not override.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.server_address &lt;/span&gt;= server_address  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即我们传入的 ip+port (&quot;0.0.0.0&quot;, 6666)&lt;/span&gt;
        self.RequestHandlerClass = RequestHandlerClass  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即我们传入的自定义类 MyServer&lt;/span&gt;
        self.&lt;span&gt;__is_shut_down&lt;/span&gt; = threading.Event()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里可以看到执行了该方法，这里先不详解，因为它是一个事件锁，所以不用管&lt;/span&gt;
        self.&lt;span&gt;__shutdown_request&lt;/span&gt; = False 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseServer中的__init__()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中执行了&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;thrading&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块下的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Event()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法。我这里还是提一嘴这个方法是干嘛用的，&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;它会去控制线程的启动顺序&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，这里实例化出的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.__is_shut_down&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;其实就是一把锁，没什么深究的，接下来的文章中我也会写到。我们继续往下看，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;现在是该回到&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法中来了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f6d201ba-1f70-4521-84a1-4350554abdda')&quot; readability=&quot;36&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_f6d201ba-1f70-4521-84a1-4350554abdda&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_f6d201ba-1f70-4521-84a1-4350554abdda&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6d201ba-1f70-4521-84a1-4350554abdda&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TCPServer(BaseServer):

   &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释全被我删了，影响视线&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
   
    address_family &lt;/span&gt;= socket.AF_INET  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  基于网络的套接字家族&lt;/span&gt;
&lt;span&gt;
    socket_type &lt;/span&gt;= socket.SOCK_STREAM  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TCP（字节流）协议&lt;/span&gt;
&lt;span&gt;
    request_queue_size &lt;/span&gt;= 5  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 消息队列最大为5，可以理解为backlog，即半链接池的大小&lt;/span&gt;
&lt;span&gt;    
    allow_reuse_address &lt;/span&gt;= False  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口重用默认关闭&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, server_address, RequestHandlerClass, bind_and_activate=True): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 看这里！！！！&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Constructor.  May be extended, do not override.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        BaseServer.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, server_address, RequestHandlerClass)
        self.socket &lt;/span&gt;=&lt;span&gt; socket.socket(self.address_family,
                                self.socket_type)                        
   
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bind_and_activate:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在创建完socket对象后就会进行该判断。默认参数bind_and_activate就是为True&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.server_bind() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 现在进入该方法查看细节&lt;/span&gt;
&lt;span&gt;                self.server_activate()
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
                self.server_close()
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TCPServer中的__init__()&lt;/span&gt;&lt;/div&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;好了，需要找这个&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.bind()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法，还是从头开始找。实例本身没有，第一父类&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;也没有，所以现在我们看的是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;server_bind()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb12f98a-fe55-45fc-8e0c-ad188289deae')&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_bb12f98a-fe55-45fc-8e0c-ad188289deae&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_bb12f98a-fe55-45fc-8e0c-ad188289deae&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb12f98a-fe55-45fc-8e0c-ad188289deae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; server_bind(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Called by constructor to bind the socket.

    May be overridden.

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; self.allow_reuse_address:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的变量对应 TCPServer.__init__ 上面定义的类方法，端口重用这个。由于是False，所以我们直接往下执行。&lt;/span&gt;
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1&lt;span&gt;)
    self.socket.bind(self.server_address)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定 ip+port 即 (&quot;0.0.0.0&quot;, 6666)&lt;/span&gt;
    self.server_address = self.socket.getsockname() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取socket的名字 其实还是 (&quot;0.0.0.0&quot;, 6666)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TCPServer中的server_bind()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;现在我们该看&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;下的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;server_activate()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('41870e47-7b7b-4563-ad9f-e91de1765201')&quot; readability=&quot;31.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_41870e47-7b7b-4563-ad9f-e91de1765201&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_41870e47-7b7b-4563-ad9f-e91de1765201&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_41870e47-7b7b-4563-ad9f-e91de1765201&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; server_activate(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Called by constructor to activate the server.

    May be overridden.

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.socket.listen(self.request_queue_size)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其实就是监听半链接池，backlog为5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TCPServer中的server_activate()&lt;/span&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;这个时候没有任何异常会抛出的，所以我们已经跑完了整个实例化的流程。并将其赋值给&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;s1&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;现在我们看一下&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;s1&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;字典，再接着进行源码分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e4ddf712-7137-47fe-aa7b-9dc14b68a038')&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e4ddf712-7137-47fe-aa7b-9dc14b68a038&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e4ddf712-7137-47fe-aa7b-9dc14b68a038&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e4ddf712-7137-47fe-aa7b-9dc14b68a038&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6666), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;RequestHandlerClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyServer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_BaseServer__is_shut_down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;threading.Event object at 0x000002A96A0208E0&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_BaseServer__shutdown_request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;socket.socket fd=716, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6666)&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;s1的__dict__&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;server_forever()启动服务分析&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们接着来看下一条代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
s1.serve_forever()
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;还是老规矩，由于&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;s1&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThreadingTCPServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类的实例对象，所以我们去一层层的找&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;serve_forever()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，最后在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类中找到了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('85bd16ea-b1f8-4654-aa6d-4e0289e65a58')&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_85bd16ea-b1f8-4654-aa6d-4e0289e65a58&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_85bd16ea-b1f8-4654-aa6d-4e0289e65a58&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_85bd16ea-b1f8-4654-aa6d-4e0289e65a58&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; serve_forever(self, poll_interval=0.5&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释被我删了&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.&lt;/span&gt;&lt;span&gt;__is_shut_down&lt;/span&gt;.clear()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上面说过了那个Event锁，控制子线程的启动顺序。这里的clear()代表清除，这个不是重点，往下看。&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; XXX: Consider using another file descriptor or connecting to the&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; socket to wake this up instead of polling. Polling reduces our&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; responsiveness to a shutdown request and wastes cpu at all other&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; times.&lt;/span&gt;
&lt;span&gt;        with _ServerSelector() as selector:  
            selector.register(self, selectors.EVENT_READ)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里是设置了一个监听类型为读取事件。也就是说当有请求来的时候当前socket对象就会发生反应。&lt;/span&gt;

            &lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.&lt;span&gt;__shutdown_request&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为False，会执行，注意！下面都是死循环了！！！&lt;/span&gt;
                ready = selector.select(poll_interval)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置最大监听时间为0.5s&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; bpo-35017: shutdown() called during select(), exit immediately.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; self.&lt;span&gt;__shutdown_request&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; BaseServer类中的类方法，为False，所以不执行这个。&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ready: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 代表有链接请求会执行下面的方法&lt;/span&gt;
                    self._handle_request_noblock()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这儿是比较重要的一个点。我们先来看。&lt;/span&gt;
&lt;span&gt;
                self.service_actions() 
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        self.&lt;/span&gt;&lt;span&gt;__shutdown_request&lt;/span&gt; =&lt;span&gt; False
        self.&lt;/span&gt;&lt;span&gt;__is_shut_down&lt;/span&gt;.set() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里是一个释放锁的行为&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseServer中的serve_forever()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;如果有链接请求，则会执行&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self._handle_request_noblock()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法，它在哪里呢？刚好这个方法就在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;serve_forever()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法的正下方第4个方法的位置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9ed026b3-b59a-4438-b45f-d3f8e78f0ddd')&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_9ed026b3-b59a-4438-b45f-d3f8e78f0ddd&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_9ed026b3-b59a-4438-b45f-d3f8e78f0ddd&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9ed026b3-b59a-4438-b45f-d3f8e78f0ddd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _handle_request_noblock(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释被我删了&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        request, client_address &lt;/span&gt;= self.get_request()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的这个方法在TCPServer中，它的return值是 self.socket.accept(),就是就是返回了元组然后被解压赋值了。其实到这一步三次握手监听已经开启了。&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; self.verify_request(request, client_address): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个是验证ip和port，返回的始终是True&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.process_request(request, client_address) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; request 双向链接通道，client_address客户端ip+port。现在我们来找这个方法。&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
            self.handle_error(request, client_address)
            self.shutdown_request(request)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            self.shutdown_request(request)
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        self.shutdown_request(request)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseServer中的_handle_request_noblock()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;现在开始查找&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.process_request(request, client_address)&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;该方法，还是先从实例对象本身找，找不到去第一父类找。他位于第一父类&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de155239-39d8-4b13-8ad4-b381928be47a')&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_de155239-39d8-4b13-8ad4-b381928be47a&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_de155239-39d8-4b13-8ad4-b381928be47a&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de155239-39d8-4b13-8ad4-b381928be47a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, client_address):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Start a new thread to process the request.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    t &lt;/span&gt;= threading.Thread(target =&lt;span&gt; self.process_request_thread,
                         args &lt;/span&gt;= (request, client_address))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建子线程！！看这里！&lt;/span&gt;
    t.daemon = self.daemon_threads &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ThreadingMixIn的类属性，为False&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; t.daemon &lt;span&gt;and&lt;/span&gt; self.block_on_close:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一个值为False，第二个值为True。他们都是ThreadingMixIn的类属性&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self._threads &lt;span&gt;is&lt;/span&gt; None:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 会执行&lt;/span&gt;
            self._threads = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建了空列表&lt;/span&gt;
        self._threads.append(t) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将当前的子线程添加至空列表中&lt;/span&gt;
    t.start()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始当前子线程的运行，即运行self.process_request_thread方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ThreadingMixIn中的process_request()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们可以看到，这里的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;target&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;参数中指定了一个方法&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.process_request_thread&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，其实意思就是说当这个线程&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;t&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;的时候会去执行该方法。我们看一下它都做了什么，这个方法还是在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('66b9868b-a187-4e23-9c6a-60eadb17bd84')&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_66b9868b-a187-4e23-9c6a-60eadb17bd84&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_66b9868b-a187-4e23-9c6a-60eadb17bd84&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_66b9868b-a187-4e23-9c6a-60eadb17bd84&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request_thread(self, request, client_address):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Same as in BaseServer but as a thread.

    In addition, exception handling is done here.

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        self.finish_request(request, client_address) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到又执行该方法了，这里我再标注一下，别弄头晕了。request 双向链接通道，client_address客户端ip+port。&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
        self.handle_error(request, client_address)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        self.shutdown_request(request)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 它不会关闭这个线程，而是将其设置为wait()状态。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ThreadingMixIn中的 process_request_thread()&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;看&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.finish_request()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法，它在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e2af3438-5d36-4090-969f-ec49c07d881e')&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e2af3438-5d36-4090-969f-ec49c07d881e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e2af3438-5d36-4090-969f-ec49c07d881e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2af3438-5d36-4090-969f-ec49c07d881e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; finish_request(self, request, client_address):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Finish one request by instantiating RequestHandlerClass.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.RequestHandlerClass(request, client_address, self)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里是干嘛？其实就是在进行实例化！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseServer中的finish_request&lt;/span&gt;&lt;/div&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self.RequestHandlerClass(request, client_address, self)&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，我们找到&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;self&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;字典，看看这个到底是什么东西&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8672ee81-b8d3-4823-875e-b8c43ced8082')&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8672ee81-b8d3-4823-875e-b8c43ced8082&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8672ee81-b8d3-4823-875e-b8c43ced8082&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8672ee81-b8d3-4823-875e-b8c43ced8082&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6666), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;RequestHandlerClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyServer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_BaseServer__is_shut_down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;threading.Event object at 0x000002A96A0208E0&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_BaseServer__shutdown_request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;socket.socket fd=716, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 6666)&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;s1的__dict__&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;可以看到，它就是我们传入的那个类，即自定义的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;MyServer&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类。我们把request,client_address,以及整个是实例self传给了MyServer的&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法。但是我们的MyServer类没有&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，怎么办呢？去它父类&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;BaseRequestHandler&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;里面找呗。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('264e6fbe-66c4-49e6-adc0-8df43e42fde6')&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_264e6fbe-66c4-49e6-adc0-8df43e42fde6&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_264e6fbe-66c4-49e6-adc0-8df43e42fde6&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_264e6fbe-66c4-49e6-adc0-8df43e42fde6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseRequestHandler:

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;注释被我删了&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, request, client_address, server):
        self.request &lt;/span&gt;= request  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; request 双向链接通道&lt;/span&gt;
        self.client_address = client_address  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 客户端ip+port&lt;/span&gt;
        self.server = server &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即 实例对象本身。上面的__dict__就是它的__dict__&lt;/span&gt;
        self.setup() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 钩子函数，我们可以自己写一个类然后继承`BaseRequestHandler`并覆写其setup方法即可。&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.handle()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 看，自动执行handle&lt;/span&gt;
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            self.finish()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 钩子函数&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setup(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; finish(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseRequestHandler中的__init__&lt;/span&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;现在我们知道了，为什么一定要覆写&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法了吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;socketserver内部调用顺序流程图(基于TCP协议)&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;实例化过程图解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055545543-251457037.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055545543-251457037.png&quot; alt=&quot;image-20200629051129570&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;server_forever()启动服务图解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055544816-426140323.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202006/1881426-20200629055544816-426140323.png&quot; alt=&quot;image-20200629053610118&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;扩展：验证链接合法性&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在很多时候，我们的TCP服务端为了防止网络泛洪可以设置一个三次握手验证机制。那么这个验证机制的实现其实也是非常简单的，我们的思路在于进入通信循环之前，客户端和服务端先走一次链接认证，只有通过认证的客户端才能够继续和服务端进行链接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　下面就来看一下具体的实现步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('88d07a3b-cd80-4761-aaca-901c32686d77')&quot; readability=&quot;39.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_88d07a3b-cd80-4761-aaca-901c32686d77&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_88d07a3b-cd80-4761-aaca-901c32686d77&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_88d07a3b-cd80-4761-aaca-901c32686d77&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;_*_coding:utf-8_*_&lt;/span&gt;
&lt;span&gt;__author__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linhaifeng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hmac,os

secret_key&lt;/span&gt;=b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linhaifeng bang bang bang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; conn_auth(conn):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    认证客户端链接
    :param conn:
    :return:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始验证新链接的合法性&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    msg&lt;/span&gt;=os.urandom(32)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新方法，生成32位随机Bytes类型的值&lt;/span&gt;
&lt;span&gt;    conn.sendall(msg)
    h&lt;/span&gt;=&lt;span&gt;hmac.new(secret_key,msg)
    digest&lt;/span&gt;=&lt;span&gt;h.digest()
    respone&lt;/span&gt;=&lt;span&gt;conn.recv(len(digest))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hmac.compare_digest(respone,digest) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对比结果为True或者为False&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; data_handler(conn,bufsize=1024&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; conn_auth(conn):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;该链接不合法,关闭&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        conn.close()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;链接合法,开始通信&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data&lt;/span&gt;=&lt;span&gt;conn.recv(bufsize)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; data:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        conn.sendall(data.upper())

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; server_handler(ip_port,bufsize,backlog=5&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    只处理链接
    :param ip_port:
    :return:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    tcp_socket_server&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_STREAM)
    tcp_socket_server.bind(ip_port)
    tcp_socket_server.listen(backlog)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        conn,addr&lt;/span&gt;=&lt;span&gt;tcp_socket_server.accept()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;新连接[%s:%s]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(addr[0],addr[1&lt;span&gt;]))
        data_handler(conn,bufsize)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9999&lt;span&gt;)
    bufsize&lt;/span&gt;=1024&lt;span&gt;
    server_handler(ip_port,bufsize)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Server端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e79ee42f-56b1-49e9-b853-bbce67234fdf')&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_e79ee42f-56b1-49e9-b853-bbce67234fdf&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_e79ee42f-56b1-49e9-b853-bbce67234fdf&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e79ee42f-56b1-49e9-b853-bbce67234fdf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;_*_coding:utf-8_*_&lt;/span&gt;
&lt;span&gt;__author__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linhaifeng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hmac,os

secret_key&lt;/span&gt;=b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linhaifeng bang bang bang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; conn_auth(conn):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    验证客户端到服务器的链接
    :param conn:
    :return:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    msg&lt;/span&gt;=conn.recv(32) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拿到随机位数&lt;/span&gt;
    h=hmac.new(secret_key,msg) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 掺盐&lt;/span&gt;
    digest=&lt;span&gt;h.digest()
    conn.sendall(digest)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; client_handler(ip_port,bufsize=1024&lt;span&gt;):
    tcp_socket_client&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_STREAM)
    tcp_socket_client.connect(ip_port)

    conn_auth(tcp_socket_client)

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; data:&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; data == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

        tcp_socket_client.sendall(data.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        respone&lt;/span&gt;=&lt;span&gt;tcp_socket_client.recv(bufsize)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(respone.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    tcp_socket_client.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9999&lt;span&gt;)
    bufsize&lt;/span&gt;=1024&lt;span&gt;
    client_handler(ip_port,bufsize)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Client端&lt;/span&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;到这里已经很简单了，服务器将随机数给客户机发过去，客户机收到后也用自家的盐与随机数加料，再使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;将它转化为字节，直接发送了回来然后客户端通过&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;hmac.compare_digest()&lt;/code&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;方法验证两个的值是否相等，如果不等就说明盐不对。客户机不合法服务端将会关闭与该客户机的双向链接通道。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 22:14:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>socketserver模块使用与源码分析 前言 在前面的学习中我们其实已经可以通过socket模块来建立我们的服务端，并且还介绍了关于TCP协议的粘包问题。但是还有一个非常大的问题就是我们所编写的S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13205917.html</dc:identifier>
</item>
<item>
<title>如何在项目开发中应用好“Deadline 是第一生产力”？ - 宝玉</title>
<link>http://www.cnblogs.com/dotey/p/13205902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotey/p/13205902.html</guid>
<description>&lt;p&gt;我想也许你早就听说过“Deadline是第一生产力”这句话，哪怕以前没听说过，我相信看完本文后，再也不会忘记这句话，甚至时不时还要感慨一句：“Deadline是第一生产力！”。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202006/564-20200629043836678-561572996.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在日常生活中，Deadline倒逼生产力的例子比比皆是，比如说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上学时，临近到要交作业的Deadline了，游戏都顾不上玩了，急急忙忙赶作业。&lt;/li&gt;
&lt;li&gt;工作中，项目发布的Deadline临近了，大家加班加点，热火朝天赶着开发功能和修复bug。&lt;/li&gt;
&lt;li&gt;生活中，快到了要报税的Deadline了，每个人都急急忙忙赶在Deadline前把税给报了。&lt;br/&gt;不管多拖延的人，快到了Deadline的时候，总能爆发出惊人的生产力。这就是为什么我们总是说：Deadline 是第一生产力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与之相反的例子也很多，一些没有Deadline的事情，总会能拖则拖，直到不能拖为止，或者干脆不了了之。比如说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序员常有一些绝妙的想法，比如写一个开源项目，做一个App或者网站，结果因为没有Deadline，结果总是开了个头，就再没结果了。&lt;/li&gt;
&lt;li&gt;工作中很多项目，虽然有计划，但是没有强Deadline，结果需求一改再改，计划总是在跟着调整延迟，一直不能上线。&lt;/li&gt;
&lt;li&gt;比如说我这篇文章，打算写很久了，但因为没有Deadline一直拖着，最近终于给自己定了一个Deadline是这周末要写出来，这才开始动笔。&lt;br/&gt;这些失败的例子，归根结底，一个很重要的原因就是没有Deadline，导致不能发挥出生产力，或者生产力没有用在正确的地方。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;deadline为什么能创造出巨大的生产力？&quot;&gt;Deadline为什么能创造出巨大的生产力？&lt;/h2&gt;
&lt;p&gt;为什么Deadline这么神奇，能创造出巨大的生产力？&lt;/p&gt;
&lt;p&gt;无论是个人的事情还是项目，生产力低下，不能按时完成的原因，总结下来不外乎三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;想太多&lt;/li&gt;
&lt;li&gt;过于追求完美、关注细节&lt;/li&gt;
&lt;li&gt;不够专注&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;想太多&quot;&gt;想太多&lt;/h3&gt;
&lt;p&gt;回想一下你做过的事或者项目，是不是会有“想太多”的情况。这并不是说在动手做之前先思考不好，而是有时候，因为停留在想的时间太长，迟迟没有动手，导致想的太多对于做成一件事反而会成为一种阻碍。&lt;/p&gt;
&lt;p&gt;比如说想写一篇文章，打腹稿打的太久，最后都模糊了当初要写的观点，真下笔的时候，很多思考完全用不上；想写一个程序，设计了太久，不仅花了太多的时间在不必要的设计上，最后留给写程序的时间就不多了；做一个项目，在需求上想太多，迟迟不能确定，最后留给后面设计和开发的时间很短。&lt;/p&gt;
&lt;p&gt;当有了明确的Deadline，想太多的问题就会有明显的改善，该写的文章就动手写起来了，程序差不多时间也就动手编码起来了，需求也能早点明确下来。&lt;/p&gt;
&lt;h3 id=&quot;过于追求完美、关注细节&quot;&gt;过于追求完美、关注细节&lt;/h3&gt;
&lt;p&gt;追求完美、关注细节不是坏事，像乔布斯就以关注细节而闻名，但对一个项目来说，有时候过于追求完美、关注细节反而会导致项目失败。&lt;/p&gt;
&lt;p&gt;比如说想打造“完美”的产品，导致产品一改再改，迟迟无法上线；程序设计时考虑各种未来可能的需求，导致设计非常复杂，很难实现。&lt;/p&gt;
&lt;p&gt;想象一下，如果你本来想做一个完美的产品、设计一个完美的架构设计，但是有个很严格的Deadline，必须要保证在Deadline前交付，那么你是不是就不会那么追求完美和细节，而是抓住最核心最主要的功能和设计，先保证能交付。&lt;/p&gt;
&lt;h3 id=&quot;不够专注&quot;&gt;不够专注&lt;/h3&gt;
&lt;p&gt;当一件事没有明确的deadline时，就很容易被其他事情分心，比如说上上网、玩玩游戏，只有在deadline临近时，才能专注在要做的事情上，不再被那些无关紧要的事所分心。&lt;/p&gt;
&lt;p&gt;借用&lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%9B%E8%B1%A1%E9%99%90%E6%B3%95&quot;&gt;时间四象限&lt;/a&gt;的理论，有了Deadline，你要做的事情就变成了“重要并且紧急”，否则就会变成“重要不紧急”甚至是“不重要不紧急”，以至于一拖再拖。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202006/564-20200629043916552-773637307.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;结合项目管理金三角来分析&quot;&gt;结合项目管理金三角来分析&lt;/h3&gt;
&lt;p&gt;我曾经在《&lt;a href=&quot;https://time.geekbang.org/column/article/85302&quot;&gt;怎样平衡软件质量与时间成本范围的关系？&lt;/a&gt;》一文中提到了项目管理金三角的理论，也就是软件质量和时间成本范围三者之间是相互制约的关系。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202006/564-20200629043933943-428700082.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合前面的分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“想太多”的问题本质上是在压缩了你的有效时间和扩大了范围，导致失控；&lt;/li&gt;
&lt;li&gt;“过于追求完美、关注细节”的问题本质上是扩大了范围，导致失控；&lt;/li&gt;
&lt;li&gt;“不够专注”则是一些不重要的事情挤压了你的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而当你的项目有强Deadline的时候，说明金三角的三条边中，时间这条边是固定住的，只能少不能多，那你就只能去调整范围和成本另两条边。而成本很多时候也是不能动的，最终结果就是缩小范围和有效利用时间。&lt;/p&gt;
&lt;p&gt;所以说，&lt;strong&gt;Deadline之所以能提升生产力，归根结底，是由于利用Deadline，倒逼着你缩小“范围”，做当前最重要最有价值的事情；利用Deadline，让你专注，不浪费时间在不重要的事情上。从而可以把Deadline，变成第一生产力。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何在项目中应用好deadline-是第一生产力？&quot;&gt;如何在项目中应用好“Deadline 是第一生产力”？&lt;/h2&gt;
&lt;p&gt;既然Deadline是第一生产力，那是不是只要凡事设置一个Deadline，就万事大吉，自然就可以把事情做好？把项目完成好？&lt;/p&gt;
&lt;p&gt;显然也不是那么简单的事情！并不是随便把一个时间点设成Deadline，就可以马上激发生产力。&lt;/p&gt;
&lt;h3 id=&quot;首先你的deadline是否有一定的强制性？&quot;&gt;首先你的Deadline是否有一定的强制性？&lt;/h3&gt;
&lt;p&gt;Deadline之所以能成为Deadline，就是因为它具有一定的强制性，Deadline到了之后没能完成会有一定后果。比如说你作业没能按时交，那么分数就会受影响；项目没能按时交付，绩效就会受影响。&lt;/p&gt;
&lt;p&gt;很多优秀的程序员，在公司的项目中能高效的完成任务，相反自己在做Side Project的时候却各种拖延，难以交付，就是因为无法给自己定一个Deadline，就算定了时间点，到时间没能完成也不用承担什么后果，自然就难以将Deadline变成生产力。&lt;/p&gt;
&lt;p&gt;有时候如果自己真的难以执行，可以让家人朋友帮助监督，或者可以学学亚马逊的逆向工作法（Working backwards），在打造一个新产品前，不是按传统的需求、设计、开发、测试和发布流程，而是先写新闻稿，然后开新闻发布会告诉大众要打造一个什么样的产品，以及什么时间发布，再去设计开发。这样在写新闻稿的时候就想清楚你的产品要交付的最核心的功能是什么，以及你的Deadline是什么。&lt;/p&gt;
&lt;p&gt;当你把要做的事情和Deadline当作牛逼吹出去了，要想不被人笑话，就要考虑为你吹过的牛逼奋斗，保证在Deadline之前有所交付了。&lt;/p&gt;
&lt;h3 id=&quot;然后你的deadline是否具有可操作性？&quot;&gt;然后你的Deadline是否具有可操作性？&lt;/h3&gt;
&lt;p&gt;成功的Deadline一定都是以科学的计划为基础的，否则不切实际的Deadline就会闹出像“两个女人5个月生孩子”这样的笑话。&lt;/p&gt;
&lt;p&gt;怎么样的Deadline才算具有可操作性呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先Deadline的时间点不宜太遥远。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你的Deadline定的太过遥远，只有在Deadline临近的时候，才能发挥出作用，但可能已经太迟了。&lt;/p&gt;
&lt;p&gt;传统的瀑布模型开发软件就是典型的例子。使用瀑布模型开发软件项目，也会有一个项目发布的Deadline，但是这个Deadline通常在几个月甚至一年之后，结果通常就是开发过程前松后紧，刚开始不忙，临到上线时加班加点。&lt;/p&gt;
&lt;p&gt;后来针对这种情况，一个改善的方案就是设置里程碑，里程碑本质上就是把一个长的Deadline拆分成几个短的Deadline，比如说需求分析完成是一个里程碑、开发完成是一个里程碑。这样的借助一个个里程碑，让Deadline贯穿项目始终，持续的激发生产力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后Deadline到了必须要有交付。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人有追求完美的情结，即使Deadline到了，因为觉得产品不完美而不愿意交付，所以宁可将Deadline不断调整，一直延期，最终导致Deadline形同虚设。&lt;/p&gt;
&lt;p&gt;完美是没有止境的，在你眼里不完美的东西也许在其他人而言，已经可以满足需求了。Deadline的一个意义也在于通过Deadline，让你在有限的时间内必须要有交付，倒逼着你放弃完美清洁，想清楚什么是你应该交付的最重要的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交付，也不意味之交付一个漏洞百出半成品给大众，而是通过缩小范围，交付一个完成的最小可用的版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外软件的交付也分两种，一种是内部的可供测试的版本，一种是外部的正式发布的版本。比如像Chrome (&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/process/release_cycle.md#:~:text=More%20Info-,Overview,to%20stabilize%20the%20beta%20branch.&quot;&gt;Chrome Release Cycle&lt;/a&gt;) 的开发，会交付不同的版本给不同的用户，比如每天交付的开发版本，但是只是内部人员使用。还有Beta版本，只是给一部分测试用户，最终交付给用户的，已经是一个经过反复测试完善的稳定版本了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202006/564-20200629043958974-471290143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再有就是Deadline到了必须要有完整的交付。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面说的里程碑的方案可以很好的解决Deadline太长的问题，但也有问题，那就是在里程碑的Deadline到了的时候，虽然有交付，但交付的产物并不是十分清晰。比如说需求设计里程碑到了，只是一些模糊不清的需求文档。结果就只能是基于这种模糊不清的需求文档，边开发边修改，导致后续因为需求修改而产生很多不必要的浪费。&lt;/p&gt;
&lt;p&gt;所以Deadline到了的时候，不能交付一个半成品或者模棱两可的结果，而必须是一个完整的结果，否则这样的Deadline，生产力是大打折扣的。&lt;/p&gt;
&lt;p&gt;最后再给你看一个在软件项目中，应用好“Deadline 是第一生产力”的经典例子。&lt;/p&gt;
&lt;h2 id=&quot;敏捷开发的时间盒子&quot;&gt;敏捷开发的时间盒子&lt;/h2&gt;
&lt;p&gt;可能你已经知道敏捷开发，每天都在用敏捷开发管理软件项目，也许你还不知道&lt;a href=&quot;https://time.geekbang.org/column/article/84351&quot;&gt;什么是敏捷开发&lt;/a&gt;，在这里我并展开多讲，只讲其中的时间盒子（Time Boxing）概念。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202006/564-20200629044015277-983234423.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在敏捷开发中，一个软件项目的开发，是采用的迭代开发的模式，并不是一次交付完整的产品，而是通过一个个的迭代，每次交付一部分可以运行的产品，最终交付完整的交付。&lt;/p&gt;
&lt;p&gt;每一个迭代都是一个固定时长的时间盒子，时间通常不会太长，1-4周左右，但每个迭代结束，都要求要交付可执行的产品。&lt;/p&gt;
&lt;p&gt;这个时间盒子本质上就是一个个的Deadline，每次时间盒子的结束点就是一个Deadline。那这样做有什么意义呢？&lt;/p&gt;
&lt;h3 id=&quot;首先，每次迭代前，你要计划好：当前迭代要做哪些事情？deadline到了的时候能交付什么？&quot;&gt;首先，每次迭代前，你要计划好：当前迭代要做哪些事情？deadline到了的时候能交付什么？&lt;/h3&gt;
&lt;p&gt;因为有Deadline的压力，每次迭代时间是有限的，而你又必须要交付，那么就会倒逼着&lt;strong&gt;你在计划的时候，会优先选择当前优先级最高的任务，专注在重要的事情上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;然后，在迭代的过程中，你要尽可能的提升效率，保证在deadline之前能交付。&quot;&gt;然后，在迭代的过程中，你要尽可能的提升效率，保证在Deadline之前能交付。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果你想要在Deadline之前尽可能的交付更多的东西，那就会倒逼着你去提升效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以你在设计的时候，只会做刚刚好的设计；所以你会写自动化测试，从而提升测试的效率；所以你会采用像CI/CD这样的工具，帮助你将很多工作自动化，提升效率。&lt;/p&gt;
&lt;h3 id=&quot;最后，在迭代完成的时候，deadline到了，你一定要有完整的交付。&quot;&gt;最后，在迭代完成的时候，Deadline到了，你一定要有完整的交付。&lt;/h3&gt;
&lt;p&gt;前面说到了：在Deadline到了后，有交付、有完整的交付非常重要。这也会&lt;strong&gt;倒逼着你去思考如果提升发布版本的质量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要保证你有一个稳定的可交付的版本，在敏捷开发中有很多很好的实践：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是要有充分的测试，完全人工测试显然是跟不上快速迭代的节奏的，所以要有大量自动化测试来辅助，保证可以同自动化的方式覆盖各种测试用例；&lt;/li&gt;
&lt;li&gt;然后需求不能频繁变更，这就意味着在一个迭代中，通常不会接受需求的变更；&lt;/li&gt;
&lt;li&gt;还有就是采用分支的方式来开发新功能或开发bug，只有代码审查和测试通过才能合并，这样你就有一个稳定的随时可以发布的分支。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;敏捷开发的时间盒子，就是一个借助Deadline来提升生产力的经典应用。&lt;strong&gt;借助Deadline，倒逼着你专注于重要的事，倒逼着你提升效率，倒逼着你按时交付可执行的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使你不是采用的敏捷开发的时间盒子来开发项目，其中很多借助Deadline激发生产力的思想和方法，都可以借鉴到你的项目开发甚至是日常生活中。&lt;/p&gt;
&lt;p&gt;Deadline就是第一生产力，希望你能理解和应用好Deadline，帮助你提升生产力。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 20:43:00 +0000</pubDate>
<dc:creator>宝玉</dc:creator>
<og:description>我想也许你早就听说过“Deadline是第一生产力”这句话，哪怕以前没听说过，我相信看完本文后，再也不会忘记这句话，甚至时不时还要感慨一句：“Deadline是第一生产力！”。 在日常生活中，Dead</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotey/p/13205902.html</dc:identifier>
</item>
<item>
<title>Mariadb之日志相关配置 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13205870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13205870.html</guid>
<description>&lt;p&gt;　　前面我们聊到了mariadb的事务，以及事务隔离级别，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13198186.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13198186.html&lt;/a&gt;；今天我们来聊一聊mariadb的日志相关话题；mariadb日志有6种，分别是查询日志（general_log）,慢查询日志（log_slow_queries）,错误日志（log_error,log_warnings）,二进制日志（binlog）,中继日志（relay_log）和事务日志（innodb_log）;&lt;/p&gt;
&lt;p&gt;　　1、查询日志，主要记录查询语句，日志存储位置可放在表中，也可以放在文件中，这个要根据自己的配置，当然也可以同时放在表和文件中；一般情况服务器IO压力不大的情况下是可以开启查询日志的，如果服务器IO压力大，建议不要开启查询日志；具体配置方法如下&lt;/p&gt;
&lt;p&gt;　　把查询日志放在mysql库的general_log 表中的配置方法：&lt;/p&gt;
&lt;p&gt;　　在/etc/my.cnf.d/server.cnf中的server配置段下添加如下配置，并重启mariadb服务即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628211556516-1584020636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启查询日志，日志输出到表；默认会把查询日志存放在mysql库中的general_log表中；&lt;/p&gt;
&lt;p&gt;　　重启服务，然后查看general_log表是否有数据？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [mysql]&amp;gt; select * from mysql.general_log ;
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
| event_time                 | user_host                 | thread_id | server_id | command_type | argument                         |
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
| 2020-06-28 09:14:33.402211 | [root] @ localhost []     |         3 |         3 | Connect      | root@localhost on  using Socket  |
| 2020-06-28 09:14:33.409731 | root[root] @ localhost [] |         3 |         3 | Query        | select @@version_comment limit 1 |
| 2020-06-28 09:14:38.087307 | root[root] @ localhost [] |         3 |         3 | Query        | SELECT DATABASE()                |
| 2020-06-28 09:14:38.087952 | root[root] @ localhost [] |         3 |         3 | Init DB      | mysql                            |
| 2020-06-28 09:14:38.091356 | root[root] @ localhost [] |         3 |         3 | Query        | show databases                   |
| 2020-06-28 09:14:38.092713 | root[root] @ localhost [] |         3 |         3 | Query        | show tables                      |
| 2020-06-28 09:14:38.094222 | root[root] @ localhost [] |         3 |         3 | Field List   | column_stats                     |
| 2020-06-28 09:14:38.095628 | root[root] @ localhost [] |         3 |         3 | Field List   | columns_priv                     |
| 2020-06-28 09:14:38.096401 | root[root] @ localhost [] |         3 |         3 | Field List   | db                               |
| 2020-06-28 09:14:38.097869 | root[root] @ localhost [] |         3 |         3 | Field List   | event                            |
| 2020-06-28 09:14:38.099603 | root[root] @ localhost [] |         3 |         3 | Field List   | func                             |
| 2020-06-28 09:14:38.100382 | root[root] @ localhost [] |         3 |         3 | Field List   | general_log                      |
| 2020-06-28 09:14:38.101266 | root[root] @ localhost [] |         3 |         3 | Field List   | global_priv                      |
| 2020-06-28 09:14:38.101867 | root[root] @ localhost [] |         3 |         3 | Field List   | gtid_slave_pos                   |
| 2020-06-28 09:14:38.102563 | root[root] @ localhost [] |         3 |         3 | Field List   | help_category                    |
| 2020-06-28 09:14:38.103556 | root[root] @ localhost [] |         3 |         3 | Field List   | help_keyword                     |
| 2020-06-28 09:14:38.104430 | root[root] @ localhost [] |         3 |         3 | Field List   | help_relation                    |
| 2020-06-28 09:14:38.105328 | root[root] @ localhost [] |         3 |         3 | Field List   | help_topic                       |
| 2020-06-28 09:14:38.106362 | root[root] @ localhost [] |         3 |         3 | Field List   | index_stats                      |
| 2020-06-28 09:14:38.107459 | root[root] @ localhost [] |         3 |         3 | Field List   | innodb_index_stats               |
| 2020-06-28 09:14:38.109085 | root[root] @ localhost [] |         3 |         3 | Field List   | innodb_table_stats               |
| 2020-06-28 09:14:38.110367 | root[root] @ localhost [] |         3 |         3 | Field List   | plugin                           |
| 2020-06-28 09:14:38.111098 | root[root] @ localhost [] |         3 |         3 | Field List   | proc                             |
| 2020-06-28 09:14:38.112958 | root[root] @ localhost [] |         3 |         3 | Field List   | procs_priv                       |
| 2020-06-28 09:14:38.113798 | root[root] @ localhost [] |         3 |         3 | Field List   | proxies_priv                     |
| 2020-06-28 09:14:38.114734 | root[root] @ localhost [] |         3 |         3 | Field List   | roles_mapping                    |
| 2020-06-28 09:14:38.115476 | root[root] @ localhost [] |         3 |         3 | Field List   | servers                          |
| 2020-06-28 09:14:38.116419 | root[root] @ localhost [] |         3 |         3 | Field List   | slow_log                         |
| 2020-06-28 09:14:38.118138 | root[root] @ localhost [] |         3 |         3 | Field List   | table_stats                      |
| 2020-06-28 09:14:38.119065 | root[root] @ localhost [] |         3 |         3 | Field List   | tables_priv                      |
| 2020-06-28 09:14:38.120027 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone                        |
| 2020-06-28 09:14:38.120907 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_leap_second            |
| 2020-06-28 09:14:38.121914 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_name                   |
| 2020-06-28 09:14:38.122718 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_transition             |
| 2020-06-28 09:14:38.123713 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_transition_type        |
| 2020-06-28 09:14:38.124958 | root[root] @ localhost [] |         3 |         3 | Field List   | transaction_registry             |
| 2020-06-28 09:14:38.126722 | root[root] @ localhost [] |         3 |         3 | Field List   | user                             |
| 2020-06-28 09:14:48.615477 | root[root] @ localhost [] |         3 |         3 | Query        | select * from mysql.general_log  |
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
38 rows in set (0.002 sec)

MariaDB [mysql]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到重启服务后，general_log表中就有数据了，此时查询日志记录到表中就配置好了；通常不建议开启查询日志，这个很消耗服务器性能；&lt;/p&gt;
&lt;p&gt;　　配置查询日志记录到文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628212314988-2075786660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示明确开启查询日志，并把日志记录到/var/lib/mysql/general_log中；&lt;/p&gt;
&lt;p&gt;　　重启服务，看看对应目录下是否生成日志文件，连接到数据，执行查询操作，看看是否把日志记录到相应文件中哦？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb
[root@lxc my.cnf.d]# ll /var/lib/mysql/general_log 
-rw-rw---- 1 mysql mysql 143 Jun 28 09:22 /var/lib/mysql/general_log
[root@lxc my.cnf.d]# cat /var/lib/mysql/general_log
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| first_db           |
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.001 sec)

MariaDB [(none)]&amp;gt; \q
Bye
[root@lxc my.cnf.d]# cat /var/lib/mysql/general_log
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
200628  9:22:32      3 Connect  root@localhost on  using Socket
                     3 Query    select @@version_comment limit 1
200628  9:22:37      3 Query    show databases
200628  9:22:38      3 Quit
[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们在数据库中执行了一个show databases; 在对应日志文件中是能够记录对应语句的；&lt;/p&gt;
&lt;p&gt;　　配置查询日志记录同时记录到表和文件中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628212656290-1550645653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启查询日志功能，并把日志同时记录到表和文件中，文件路径为/var/lib/mysq/general_log；&lt;/p&gt;
&lt;p&gt;　　重启mariadb，执行查询操作，看看对应表和文件中是否有记录？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb     
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; select * from mysql.general_log;
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
| event_time                 | user_host                 | thread_id | server_id | command_type | argument                         |
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
| 2020-06-28 09:14:33.402211 | [root] @ localhost []     |         3 |         3 | Connect      | root@localhost on  using Socket  |
| 2020-06-28 09:14:33.409731 | root[root] @ localhost [] |         3 |         3 | Query        | select @@version_comment limit 1 |
| 2020-06-28 09:14:38.087307 | root[root] @ localhost [] |         3 |         3 | Query        | SELECT DATABASE()                |
| 2020-06-28 09:14:38.087952 | root[root] @ localhost [] |         3 |         3 | Init DB      | mysql                            |
| 2020-06-28 09:14:38.091356 | root[root] @ localhost [] |         3 |         3 | Query        | show databases                   |
| 2020-06-28 09:14:38.092713 | root[root] @ localhost [] |         3 |         3 | Query        | show tables                      |
| 2020-06-28 09:14:38.094222 | root[root] @ localhost [] |         3 |         3 | Field List   | column_stats                     |
| 2020-06-28 09:14:38.095628 | root[root] @ localhost [] |         3 |         3 | Field List   | columns_priv                     |
| 2020-06-28 09:14:38.096401 | root[root] @ localhost [] |         3 |         3 | Field List   | db                               |
| 2020-06-28 09:14:38.097869 | root[root] @ localhost [] |         3 |         3 | Field List   | event                            |
| 2020-06-28 09:14:38.099603 | root[root] @ localhost [] |         3 |         3 | Field List   | func                             |
| 2020-06-28 09:14:38.100382 | root[root] @ localhost [] |         3 |         3 | Field List   | general_log                      |
| 2020-06-28 09:14:38.101266 | root[root] @ localhost [] |         3 |         3 | Field List   | global_priv                      |
| 2020-06-28 09:14:38.101867 | root[root] @ localhost [] |         3 |         3 | Field List   | gtid_slave_pos                   |
| 2020-06-28 09:14:38.102563 | root[root] @ localhost [] |         3 |         3 | Field List   | help_category                    |
| 2020-06-28 09:14:38.103556 | root[root] @ localhost [] |         3 |         3 | Field List   | help_keyword                     |
| 2020-06-28 09:14:38.104430 | root[root] @ localhost [] |         3 |         3 | Field List   | help_relation                    |
| 2020-06-28 09:14:38.105328 | root[root] @ localhost [] |         3 |         3 | Field List   | help_topic                       |
| 2020-06-28 09:14:38.106362 | root[root] @ localhost [] |         3 |         3 | Field List   | index_stats                      |
| 2020-06-28 09:14:38.107459 | root[root] @ localhost [] |         3 |         3 | Field List   | innodb_index_stats               |
| 2020-06-28 09:14:38.109085 | root[root] @ localhost [] |         3 |         3 | Field List   | innodb_table_stats               |
| 2020-06-28 09:14:38.110367 | root[root] @ localhost [] |         3 |         3 | Field List   | plugin                           |
| 2020-06-28 09:14:38.111098 | root[root] @ localhost [] |         3 |         3 | Field List   | proc                             |
| 2020-06-28 09:14:38.112958 | root[root] @ localhost [] |         3 |         3 | Field List   | procs_priv                       |
| 2020-06-28 09:14:38.113798 | root[root] @ localhost [] |         3 |         3 | Field List   | proxies_priv                     |
| 2020-06-28 09:14:38.114734 | root[root] @ localhost [] |         3 |         3 | Field List   | roles_mapping                    |
| 2020-06-28 09:14:38.115476 | root[root] @ localhost [] |         3 |         3 | Field List   | servers                          |
| 2020-06-28 09:14:38.116419 | root[root] @ localhost [] |         3 |         3 | Field List   | slow_log                         |
| 2020-06-28 09:14:38.118138 | root[root] @ localhost [] |         3 |         3 | Field List   | table_stats                      |
| 2020-06-28 09:14:38.119065 | root[root] @ localhost [] |         3 |         3 | Field List   | tables_priv                      |
| 2020-06-28 09:14:38.120027 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone                        |
| 2020-06-28 09:14:38.120907 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_leap_second            |
| 2020-06-28 09:14:38.121914 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_name                   |
| 2020-06-28 09:14:38.122718 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_transition             |
| 2020-06-28 09:14:38.123713 | root[root] @ localhost [] |         3 |         3 | Field List   | time_zone_transition_type        |
| 2020-06-28 09:14:38.124958 | root[root] @ localhost [] |         3 |         3 | Field List   | transaction_registry             |
| 2020-06-28 09:14:38.126722 | root[root] @ localhost [] |         3 |         3 | Field List   | user                             |
| 2020-06-28 09:14:48.615477 | root[root] @ localhost [] |         3 |         3 | Query        | select * from mysql.general_log  |
| 2020-06-28 09:19:46.865108 | root[root] @ localhost [] |         3 |         3 | Quit         |                                  |
| 2020-06-28 09:28:29.542343 | [root] @ localhost []     |         3 |         3 | Connect      | root@localhost on  using Socket  |
| 2020-06-28 09:28:29.549997 | root[root] @ localhost [] |         3 |         3 | Query        | select @@version_comment limit 1 |
| 2020-06-28 09:28:44.924061 | root[root] @ localhost [] |         3 |         3 | Query        | select * from mysql.general_log  |
+----------------------------+---------------------------+-----------+-----------+--------------+----------------------------------+
42 rows in set (0.002 sec)

MariaDB [(none)]&amp;gt; \q
Bye
[root@lxc my.cnf.d]# cat /var/lib/mysql/general_log 
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
200628  9:22:32      3 Connect  root@localhost on  using Socket
                     3 Query    select @@version_comment limit 1
200628  9:22:37      3 Query    show databases
200628  9:22:38      3 Quit
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
200628  9:28:29      3 Connect  root@localhost on  using Socket
                     3 Query    select @@version_comment limit 1
200628  9:28:44      3 Query    select * from mysql.general_log
200628  9:28:47      3 Quit
[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到mysql.general_log表中和/var/lib/mysql/general_log文件中是可以记录我们执行的查询语句；&lt;/p&gt;
&lt;p&gt;　　2、慢查询日志，这个日志对于运维来讲是比较重要的，通常我们可以利用慢查询日志来判断哪些语句执行时间超出指定时间；慢查询日志主要记录运行时间超出指定时长度查询语句；这个日志同查询日志类似，它也是可以存储在表和文件中的；具体配置方式如下&lt;/p&gt;
&lt;p&gt;　　配置慢查询日志存放在表中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628221541339-2143327176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启慢查询日志，并把日志记录到表中，默认是mysql.slow_log表中；log_slow_filter用来定义过滤哪些语句不记录的；log_slow_rate_limit表示开启慢查询日志记录速率；log_slow_verbosity开启慢查询日志详细记录；long_query_time定义时长，超出我们指定的时长就会视为慢查询；配置好以上配置以后重启服务，我们就可以在mariadb中看到对应变量的值；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb;
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show global variables like 'slow%';
+---------------------+--------------+
| Variable_name       | Value        |
+---------------------+--------------+
| slow_launch_time    | 2            |
| slow_query_log      | ON           |
| slow_query_log_file | lxc-slow.log |
+---------------------+--------------+
3 rows in set (0.003 sec)

MariaDB [(none)]&amp;gt; show global variables like 'log_slow%';
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Variable_name                | Value                                                                                                                                |
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| log_slow_admin_statements    | ON                                                                                                                                   |
| log_slow_disabled_statements | sp                                                                                                                                   |
| log_slow_filter              | admin,filesort,filesort_on_disk,filesort_priority_queue,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk |
| log_slow_rate_limit          | 1                                                                                                                                    |
| log_slow_slave_statements    | ON                                                                                                                                   |
| log_slow_verbosity           | innodb                                                                                                                               |
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
6 rows in set (0.002 sec)

MariaDB [(none)]&amp;gt; show global variables like 'long%';    
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 3.000000 |
+-----------------+----------+
1 row in set (0.003 sec)

MariaDB [(none)]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的信息可以看到我们配置的相关参数已经生效；&lt;/p&gt;
&lt;p&gt;　　测试：执行select sleep(5);看看mysql.slow_log表中是否有记录？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; select sleep(5) ;               
+----------+
| sleep(5) |
+----------+
|        0 |
+----------+
1 row in set (5.001 sec)

MariaDB [(none)]&amp;gt; select * from mysql.slow_log\G
*************************** 1. row ***************************
    start_time: 2020-06-28 10:32:19.643885
     user_host: root[root] @ localhost []
    query_time: 00:00:05.000700
     lock_time: 00:00:00.000000
     rows_sent: 1
 rows_examined: 0
            db: 
last_insert_id: 0
     insert_id: 0
     server_id: 3
      sql_text: select sleep(5)
     thread_id: 3
 rows_affected: 0
1 row in set (0.001 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到slow_log表中已经记录了我们执行的select sleep(5)语句，执行时长为5.007秒；&lt;/p&gt;
&lt;p&gt;　　配置慢查询日志记录到文件；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628223537783-1553414887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示把慢查询日志保存在/var/lib/mysql/slow_query_log文件中；&lt;/p&gt;
&lt;p&gt;　　测试：重启mariadb，执行select sleep(5)语句，看看对应文件是否记录？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb
[root@lxc my.cnf.d]# ll /var/lib/mysql/slow_query_log
-rw-rw---- 1 mysql mysql 143 Jun 28 10:39 /var/lib/mysql/slow_query_log
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show global variables like 'slow%';
+---------------------+-------------------------------+
| Variable_name       | Value                         |
+---------------------+-------------------------------+
| slow_launch_time    | 2                             |
| slow_query_log      | ON                            |
| slow_query_log_file | /var/lib/mysql/slow_query_log |
+---------------------+-------------------------------+
3 rows in set (0.003 sec)

MariaDB [(none)]&amp;gt; show global variables like 'log_slow%';
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Variable_name                | Value                                                                                                                                |
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| log_slow_admin_statements    | ON                                                                                                                                   |
| log_slow_disabled_statements | sp                                                                                                                                   |
| log_slow_filter              | admin,filesort,filesort_on_disk,filesort_priority_queue,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk |
| log_slow_rate_limit          | 1                                                                                                                                    |
| log_slow_slave_statements    | ON                                                                                                                                   |
| log_slow_verbosity           | innodb                                                                                                                               |
+------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
6 rows in set (0.003 sec)

MariaDB [(none)]&amp;gt; show global variables like 'long%';    
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 3.000000 |
+-----------------+----------+
1 row in set (0.002 sec)

MariaDB [(none)]&amp;gt; select sleep(5);
+----------+
| sleep(5) |
+----------+
|        0 |
+----------+
1 row in set (5.001 sec)

MariaDB [(none)]&amp;gt; \q
Bye
[root@lxc my.cnf.d]# cat /var/lib/mysql/slow_query_log
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
# Time: 200628 10:40:50
# User@Host: root[root] @ localhost []
# Thread_id: 3  Schema:   QC_hit: No
# Query_time: 5.000553  Lock_time: 0.000000  Rows_sent: 1  Rows_examined: 0
# Rows_affected: 0  Bytes_sent: 64
SET timestamp=1593355250;
select sleep(5);
[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们配置的参数在mariadb中已经可正常查询到，对应的文件中已经记录我们执行select sleep(5)这条语句执行了5.000553秒；&lt;/p&gt;
&lt;p&gt;　　配置慢查询日志记录到表和文件中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628224400595-581087981.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：红框中的内容表示把慢查询日志同时记录到文件和表中；&lt;/p&gt;
&lt;p&gt;　　测试：重启mariadb服务，执行select sleep（5）语句看看是否在表和文件中都记录了？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb       
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; select sleep(5);                   
+----------+
| sleep(5) |
+----------+
|        0 |
+----------+
1 row in set (5.002 sec)

MariaDB [(none)]&amp;gt; select * from mysql.slow_log\G
*************************** 1. row ***************************
    start_time: 2020-06-28 10:32:19.643885
     user_host: root[root] @ localhost []
    query_time: 00:00:05.000700
     lock_time: 00:00:00.000000
     rows_sent: 1
 rows_examined: 0
            db: 
last_insert_id: 0
     insert_id: 0
     server_id: 3
      sql_text: select sleep(5)
     thread_id: 3
 rows_affected: 0
*************************** 2. row ***************************
    start_time: 2020-06-28 10:45:37.720365
     user_host: root[root] @ localhost []
    query_time: 00:00:05.000784
     lock_time: 00:00:00.000000
     rows_sent: 1
 rows_examined: 0
            db: 
last_insert_id: 0
     insert_id: 0
     server_id: 3
      sql_text: select sleep(5)
     thread_id: 3
 rows_affected: 0
2 rows in set (0.001 sec)

MariaDB [(none)]&amp;gt; \q
Bye
[root@lxc my.cnf.d]# cat /var/lib/mysql/slow_query_log
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
# Time: 200628 10:40:50
# User@Host: root[root] @ localhost []
# Thread_id: 3  Schema:   QC_hit: No
# Query_time: 5.000553  Lock_time: 0.000000  Rows_sent: 1  Rows_examined: 0
# Rows_affected: 0  Bytes_sent: 64
SET timestamp=1593355250;
select sleep(5);
/usr/sbin/mariadbd, Version: 10.5.4-MariaDB-log (MariaDB Server). started with:
Tcp port: 0  Unix socket: (null)
Time                Id Command  Argument
# Time: 200628 10:45:37
# User@Host: root[root] @ localhost []
# Thread_id: 3  Schema:   QC_hit: No
# Query_time: 5.000784  Lock_time: 0.000000  Rows_sent: 1  Rows_examined: 0
# Rows_affected: 0  Bytes_sent: 64
SET timestamp=1593355537;
select sleep(5);
[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到slow_log表和我们指定文件中都记录；&lt;/p&gt;
&lt;p&gt;　　用mysqldumpslow来统计慢查询日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# mysqldumpslow 
Can't determine datadir from 'my_print_defaults instances' output: --slow_query_log=on
--log_output=file,table
--slow_query_log_file=/var/lib/mysql/slow_query_log
--log_slow_filter=admin,filesort,filesort_on_disk,filesort_priority_queue,full_join,full_scan,query_cache,query_cache_miss,tmp_table,tmp_table_on_disk
--log_slow_rate_limit=1
--log_slow_verbosity=1
--long_query_time=3
--server_id=3
--read_only
--relay_log_purge=0
--skip_name_resolve=1
[root@lxc my.cnf.d]# mysqldumpslow /var/lib/mysql/slow_query_log

Reading mysql slow query log from /var/lib/mysql/slow_query_log
Count: 2  Time=5.00s (10s)  Lock=0.00s (0s)  Rows_sent=1.0 (2), Rows_examined=0.0 (0), Rows_affected=0.0 (0), root[root]@localhost
  select sleep(N)

Count: 1  Time=4.02s (4s)  Lock=0.00s (0s)  Rows_sent=1.0 (1), Rows_examined=2.0 (2), Rows_affected=0.0 (0), root[root]@localhost
  select sleep(N),count(id) from first_db.test_tb

Count: 3  Time=4.00s (12s)  Lock=0.00s (0s)  Rows_sent=1.0 (3), Rows_examined=5.0 (15), Rows_affected=0.0 (0), root[root]@localhost
  select sleep(N),count(start_time) from mysql.slow_log

Count: 1  Time=4.00s (4s)  Lock=0.00s (0s)  Rows_sent=1.0 (1), Rows_examined=0.0 (0), Rows_affected=0.0 (0), root[root]@localhost
  select sleep(N)as a, N as b

[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认mysqldumpslow 不加任何选项和参数 它会打印配置文件内容，mysqldumpslow 后面给指定的slow日志 它会统计出那些命令执行了几次，总时长是多少等等；&lt;/p&gt;
&lt;p&gt;　　使用日志分析工具mysqlsla工具分析慢查询日志&lt;/p&gt;
&lt;p&gt;　　安装mysqlsla&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# yum install perl-DBI perl-DBD-MySQL perl-devel -y
Loaded plugins: fastestmirror
base                                                                                                                                                | 3.6 kB  00:00:00     
docker-ce-stable                                                                                                                                    | 3.5 kB  00:00:00     
epel                                                                                                                                                | 4.7 kB  00:00:00     
extras                                                                                                                                              | 2.9 kB  00:00:00     
mariadb-main                                                                                                                                        | 2.9 kB  00:00:00     
mariadb-maxscale                                                                                                                                    | 2.4 kB  00:00:00     
mariadb-tools                                                                                                                                       | 2.9 kB  00:00:00     
updates                                                                                                                                             | 2.9 kB  00:00:00     
(1/3): updates/7/x86_64/primary_db                                                                                                                  | 2.9 MB  00:00:00     
(2/3): epel/x86_64/updateinfo                                                                                                                       | 1.0 MB  00:00:00     
(3/3): epel/x86_64/primary_db                                                                                                                       | 6.8 MB  00:00:01     
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Package perl-DBI-1.627-4.el7.x86_64 already installed and latest version
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package perl-DBD-MySQL.x86_64 0:4.023-5.el7 will be updated
---&amp;gt; Package perl-DBD-MySQL.x86_64 0:4.023-6.el7 will be an update
---&amp;gt; Package perl-devel.x86_64 4:5.16.3-295.el7 will be installed
……省略部分内容
Installed:
  perl-devel.x86_64 4:5.16.3-295.el7                                                                                                                                       

Dependency Installed:
  gdbm-devel.x86_64 0:1.10-8.el7                           glibc-devel.x86_64 0:2.17-307.el7.1                      glibc-headers.x86_64 0:2.17-307.el7.1                  
  kernel-headers.x86_64 0:3.10.0-1127.13.1.el7             libdb-devel.x86_64 0:5.3.21-25.el7                       perl-ExtUtils-Install.noarch 0:1.58-295.el7            
  perl-ExtUtils-MakeMaker.noarch 0:6.68-3.el7              perl-ExtUtils-Manifest.noarch 0:1.61-244.el7             perl-ExtUtils-ParseXS.noarch 1:3.18-3.el7              
  perl-Test-Harness.noarch 0:3.28-3.el7                    pyparsing.noarch 0:1.5.6-9.el7                           systemtap-sdt-devel.x86_64 0:4.0-11.el7                

Updated:
  perl-DBD-MySQL.x86_64 0:4.023-6.el7                                                                                                                                      

Dependency Updated:
  glibc.x86_64 0:2.17-307.el7.1          glibc-common.x86_64 0:2.17-307.el7.1          libdb.x86_64 0:5.3.21-25.el7          libdb-utils.x86_64 0:5.3.21-25.el7         

Complete!
[root@lxc my.cnf.d]#cd
[root@lxc ~]#wget  ftp://ftp.tw.freebsd.org/pub/distfiles/mysqlsla-2.03.tar.gz
--2020-06-28 11:07:02--  ftp://ftp.tw.freebsd.org/pub/distfiles/mysqlsla-2.03.tar.gz
           =&amp;gt; ‘mysqlsla-2.03.tar.gz’
Resolving ftp.tw.freebsd.org (ftp.tw.freebsd.org)... 140.113.17.209
Connecting to ftp.tw.freebsd.org (ftp.tw.freebsd.org)|140.113.17.209|:21... connected.
Logging in as anonymous ... Logged in!
==&amp;gt; SYST ... done.    ==&amp;gt; PWD ... done.
==&amp;gt; TYPE I ... done.  ==&amp;gt; CWD (1) /pub/distfiles ... done.
==&amp;gt; SIZE mysqlsla-2.03.tar.gz ... 33674
==&amp;gt; PASV ... done.    ==&amp;gt; RETR mysqlsla-2.03.tar.gz ... done.
Length: 33674 (33K) (unauthoritative)

100%[=================================================================================================================================&amp;gt;] 33,674      --.-K/s   in 0s      

2020-06-28 11:07:10 (195 MB/s) - ‘mysqlsla-2.03.tar.gz’ saved [33674]
[root@lxc ~]# ls
192.168.0.22  lxc_br_set.sh  LXC-Web-Panel  mysqlsla-2.03.tar.gz
[root@lxc ~]# tar xf mysqlsla-2.03.tar.gz 
[root@lxc ~]# cd mysqlsla-2.03/
[root@lxc mysqlsla-2.03]# perl Makefile.PL
Checking if your kit is complete...
Looks good
Writing Makefile for mysqlsla
[root@lxc mysqlsla-2.03]# make
cp lib/mysqlsla.pm blib/lib/mysqlsla.pm
cp bin/mysqlsla blib/script/mysqlsla
/usr/bin/perl -MExtUtils::MY -e 'MY-&amp;gt;fixin(shift)' -- blib/script/mysqlsla
Manifying blib/man3/mysqlsla.3pm
[root@lxc mysqlsla-2.03]# make install
Installing /usr/local/share/perl5/mysqlsla.pm
Installing /usr/local/share/man/man3/mysqlsla.3pm
Installing /usr/local/bin/mysqlsla
Appending installation info to /usr/lib64/perl5/perllocal.pod
[root@lxc mysqlsla-2.03]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用mysqlsla分析慢查询日志/var/lib/mysql/slow_query_log&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;73&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc mysqlsla-2.03]# mysqlsla -lt slow /var/lib/mysql/slow_query_log  
Report for msl logs: /var/lib/mysql/slow_query_log
7 queries total, 4 unique
Sorted by 't_sum'
Grand Totals: Time 30 s, Lock 0 s, Rows sent 7, Rows Examined 17


______________________________________________________________________ 001 ___
Count         : 3  (42.86%)
Time          : 12.003227 s total, 4.001076 s avg, 4.000803 s to 4.001615 s max  (39.97%)
Lock Time (s) : 595 otal, 198 vg, 151 o 257 ax  (26.81%)
Rows sent     : 1 avg, 1 to 1 max  (42.86%)
Rows examined : 5 avg, 4 to 6 max  (88.24%)
Database      :   QC_hit: No
Users         : 
        root@localhost  : 100.00% (3) of query, 100.00% (7) of all users

Query abstract:
SELECT sleep(N),COUNT(start_time) FROM mysql.slow_log;

Query sample:
select sleep(4),count(start_time) from mysql.slow_log;

______________________________________________________________________ 002 ___
Count         : 2  (28.57%)
Time          : 10.001337 s total, 5.000668 s avg, 5.000553 s to 5.000784 s max  (33.31%)
Lock Time (s) : 0 total, 0 avg, 0 to 0 max  (0.00%)
Rows sent     : 1 avg, 1 to 1 max  (28.57%)
Rows examined : 0 avg, 0 to 0 max  (0.00%)
Database      :   QC_hit: No
Users         : 
        root@localhost  : 100.00% (2) of query, 100.00% (7) of all users

Query abstract:
SELECT sleep(N);

Query sample:
select sleep(5);

______________________________________________________________________ 003 ___
Count         : 1  (14.29%)
Time          : 4.023146 s total, 4.023146 s avg, 4.023146 s to 4.023146 s max  (13.40%)
Lock Time (s) : 1.624 ms total, 1.624 ms avg, 1.624 ms to 1.624 ms max  (73.19%)
Rows sent     : 1 avg, 1 to 1 max  (14.29%)
Rows examined : 2 avg, 2 to 2 max  (11.76%)
Database      :   QC_hit: No
Users         : 
        root@localhost  : 100.00% (1) of query, 100.00% (7) of all users

Query abstract:
SELECT sleep(N),COUNT(id) FROM first_db.test_tb;

Query sample:
select sleep(4),count(id) from first_db.test_tb;

______________________________________________________________________ 004 ___
Count         : 1  (14.29%)
Time          : 4.000851 s total, 4.000851 s avg, 4.000851 s to 4.000851 s max  (13.32%)
Lock Time (s) : 0 total, 0 avg, 0 to 0 max  (0.00%)
Rows sent     : 1 avg, 1 to 1 max  (14.29%)
Rows examined : 0 avg, 0 to 0 max  (0.00%)
Database      :   QC_hit: No
Users         : 
        root@localhost  : 100.00% (1) of query, 100.00% (7) of all users

Query abstract:
SELECT sleep(N)AS a, N AS b;

Query sample:
select sleep(4)as a, 1 as b;
[root@lxc mysqlsla-2.03]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到msyqlsla把慢查询日志更具体的分析了一次，每个语句执行了多少次，总时间，平均时间等等信息；&lt;/p&gt;
&lt;p&gt;　　3、错误日志，该日志记录了mairadbd启动关闭过程中的输出信息，mariadbd运行中产生的错误信息，事件调度产生的信息，和主从复制架构中，从服务器复制线程启动时产生的信息；配置错误日志如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628233449844-90897915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上红框中的内容表示启动错误日志功能，并保持到/var/log/mariadb/mariadb_error.log;并开启记录警告信息到错误日志中；&lt;/p&gt;
&lt;p&gt;　　重启服务看看对应文件中是否会记录mariadb启动信息？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# systemctl restart mariadb
[root@lxc my.cnf.d]# ll /var/log/mariadb/mariadb_error.log
-rw-rw---- 1 mysql mysql 2411 Jun 28 11:35 /var/log/mariadb/mariadb_error.log
[root@lxc my.cnf.d]# cat /var/log/mariadb/mariadb_error.log
2020-06-28 11:35:44 0 [Note] /usr/sbin/mariadbd (initiated by: unknown): Normal shutdown
2020-06-28 11:35:44 0 [Note] Event Scheduler: Purging the queue. 0 events
2020-06-28 11:35:44 0 [Note] InnoDB: FTS optimize thread exiting.
2020-06-28 11:35:44 0 [Note] InnoDB: Starting shutdown...
2020-06-28 11:35:44 0 [Note] InnoDB: Dumping buffer pool(s) to /var/lib/mysql/ib_buffer_pool
2020-06-28 11:35:44 0 [Note] InnoDB: Buffer pool(s) dump completed at 200628 11:35:44
2020-06-28 11:35:45 0 [Note] InnoDB: Shutdown completed; log sequence number 91510; transaction id 181
2020-06-28 11:35:45 0 [Note] InnoDB: Removed temporary tablespace data file: &quot;ibtmp1&quot;
2020-06-28 11:35:45 0 [Note] /usr/sbin/mariadbd: Shutdown complete

2020-06-28 11:35:45 0 [Note] InnoDB: Using Linux native AIO
2020-06-28 11:35:45 0 [Note] InnoDB: Uses event mutexes
2020-06-28 11:35:45 0 [Note] InnoDB: Compressed tables use zlib 1.2.7
2020-06-28 11:35:45 0 [Note] InnoDB: Number of pools: 1
2020-06-28 11:35:45 0 [Note] InnoDB: Using SSE4.2 crc32 instructions
2020-06-28 11:35:45 0 [Note] InnoDB: Initializing buffer pool, total size = 134217728, chunk size = 134217728
2020-06-28 11:35:45 0 [Note] InnoDB: Completed initialization of buffer pool
2020-06-28 11:35:45 0 [Note] InnoDB: If the mysqld execution user is authorized, page cleaner thread priority can be changed. See the man page of setpriority().
2020-06-28 11:35:45 0 [Note] InnoDB: 128 rollback segments are active.
2020-06-28 11:35:45 0 [Note] InnoDB: Creating shared tablespace for temporary tables
2020-06-28 11:35:45 0 [Note] InnoDB: Setting file './ibtmp1' size to 12 MB. Physically writing the file full; Please wait ...
2020-06-28 11:35:45 0 [Note] InnoDB: File './ibtmp1' size is now 12 MB.
2020-06-28 11:35:45 0 [Note] InnoDB: 10.5.4 started; log sequence number 91510; transaction id 180
2020-06-28 11:35:45 0 [Note] InnoDB: Loading buffer pool(s) from /var/lib/mysql/ib_buffer_pool
2020-06-28 11:35:45 0 [Note] Plugin 'FEEDBACK' is disabled.
2020-06-28 11:35:45 0 [Note] InnoDB: Buffer pool(s) load completed at 200628 11:35:45
2020-06-28 11:35:45 0 [Note] Server socket created on IP: '::'.
2020-06-28 11:35:45 0 [Warning] 'proxies_priv' entry '@% root@lxc' ignored in --skip-name-resolve mode.
2020-06-28 11:35:45 0 [Note] /usr/sbin/mariadbd: ready for connections.
Version: '10.5.4-MariaDB-log'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MariaDB Server
[root@lxc my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们手动指定的文件是可以正常记录mariadb启动过程中产生的日志信息和警告信息；&lt;/p&gt;
&lt;p&gt;　　测试：故意把配置文件配置错误，重启服务，看看是否反映到错误日志中？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628233947771-1850550796.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：红框中内容是我故意多写了一个i ，接下来我们重启服务，看看错误日中是否会反馈出来；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628234157903-915792530.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在错误日志文件中，它告诉我们未知的变量；&lt;/p&gt;
&lt;p&gt;　　4、二进制日志：用于记录引起数据改变或存在引起数据改变的潜在可能性的语句（STATEMENT）或改变后的结果（ROW），也可能是二者混合；这个日志在主从复制架构中非常重要，主要功能就是记录增删改语句，用于“重放”实现从节点和主节点数据相同的目的；配置如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628235409271-945947899.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上红框中的配置表示开启二进制日志，并保持到/var/lib/mysql/下，以mysql-bin开头命名；二进制文件的最大容量是1G；sync_binlog=1表示只要有二进制文件产生就立刻同步到磁盘；&lt;/p&gt;
&lt;p&gt;　　测试：重启服务，看看对应文件是否产生？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200628235906936-1939972897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到/var/lib/mysql/目录下有一个mysql-bin.000001的文件产生了；&lt;/p&gt;
&lt;p&gt;　　连接数据库，查看二进制文件列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc my.cnf.d]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 4
Server version: 10.5.4-MariaDB-log MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show master logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |       513 |
+------------------+-----------+
1 row in set (0.001 sec)

MariaDB [(none)]&amp;gt; show binary logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |       513 |
+------------------+-----------+
1 row in set (0.000 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上语句都表示查看二进制日志文件列表；&lt;/p&gt;
&lt;p&gt;　　查看当前正在使用的二进制日志文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 |      513 |              |                  |
+------------------+----------+--------------+------------------+
1 row in set (0.000 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当前正在使用mysql-bin.000001这个文件，当前位置是328&lt;/p&gt;
&lt;p&gt;　　查看二进制日志文件中的事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [first_db]&amp;gt; show binlog events;
+------------------+-----+-------------------+-----------+-------------+-----------------------------------------------------------+
| Log_name         | Pos | Event_type        | Server_id | End_log_pos | Info                                                      |
+------------------+-----+-------------------+-----------+-------------+-----------------------------------------------------------+
| mysql-bin.000001 |   4 | Format_desc       |         3 |         256 | Server ver: 10.5.4-MariaDB-log, Binlog ver: 4             |
| mysql-bin.000001 | 256 | Gtid_list         |         3 |         285 | []                                                        |
| mysql-bin.000001 | 285 | Binlog_checkpoint |         3 |         328 | mysql-bin.000001                                          |
| mysql-bin.000001 | 328 | Gtid              |         3 |         370 | BEGIN GTID 0-3-1                                          |
| mysql-bin.000001 | 370 | Query             |         3 |         482 | use `first_db`; insert into test_tb values(3,&quot;wangwu&quot;,22) |
| mysql-bin.000001 | 482 | Xid               |         3 |         513 | COMMIT /* xid=17 */                                       |
+------------------+-----+-------------------+-----------+-------------+-----------------------------------------------------------+
6 rows in set (0.001 sec)

MariaDB [first_db]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上是在数据库上用语句查看二进制日志事件；我们也可以在shell中使用mysqlbinlog命令来查看二进制文件内容；&lt;/p&gt;
&lt;p&gt;　　使用msyqlbinlog命令查看二进制日志内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog /var/lib/mysql/mysql-bin.000001 
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#200628 11:58:31 server id 3  end_log_pos 256 CRC32 0x9afc2aa7  Start: binlog v 4, server v 10.5.4-MariaDB-log created 200628 11:58:31 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
J774Xg8DAAAA/AAAAAABAAABAAQAMTAuNS40LU1hcmlhREItbG9nAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAnvvheEzgNAAgAEgAEBAQEEgAA5AAEGggAAAAICAgCAAAACgoKAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEEwQADQgICAoKCgGnKvya
'/*!*/;
# at 256
#200628 11:58:31 server id 3  end_log_pos 285 CRC32 0x516669db  Gtid list []
# at 285
#200628 11:58:31 server id 3  end_log_pos 328 CRC32 0x8395a8cd  Binlog checkpoint mysql-bin.000001
# at 328
#200628 12:13:13 server id 3  end_log_pos 370 CRC32 0xd9b2a8a4  GTID 0-3-1 trans
/*!100101 SET @@session.skip_parallel_replication=0*//*!*/;
/*!100001 SET @@session.gtid_domain_id=0*//*!*/;
/*!100001 SET @@session.server_id=3*//*!*/;
/*!100001 SET @@session.gtid_seq_no=1*//*!*/;
BEGIN
/*!*/;
# at 370
#200628 12:13:13 server id 3  end_log_pos 482 CRC32 0x5737f424  Query   thread_id=5     exec_time=0     error_code=0
use `first_db`/*!*/;
SET TIMESTAMP=1593360793/*!*/;
SET @@session.pseudo_thread_id=5/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1, @@session.check_constraint_checks=1, @@session.sql_if_exists=0/*!*/;
SET @@session.sql_mode=1411383296/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
insert into test_tb values(3,&quot;wangwu&quot;,22)
/*!*/;
# at 482
#200628 12:13:13 server id 3  end_log_pos 513 CRC32 0x43126028  Xid = 17
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们往test_tb表中插入的数据，在二进制文件中有记录，但是没有查询语句；二进制日志文件是不会记录查询语句，它只会记录对数据有变动的语句；&lt;/p&gt;
&lt;p&gt;　　用mysqlbinlog工具查看指定位置后端日志内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog -j 370 /var/lib/mysql/mysql-bin.000001 
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#200628 11:58:31 server id 3  end_log_pos 256 CRC32 0x9afc2aa7  Start: binlog v 4, server v 10.5.4-MariaDB-log created 200628 11:58:31 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
J774Xg8DAAAA/AAAAAABAAABAAQAMTAuNS40LU1hcmlhREItbG9nAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAnvvheEzgNAAgAEgAEBAQEEgAA5AAEGggAAAAICAgCAAAACgoKAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEEwQADQgICAoKCgGnKvya
'/*!*/;
# at 370
#200628 12:13:13 server id 3  end_log_pos 482 CRC32 0x5737f424  Query   thread_id=5     exec_time=0     error_code=0
use `first_db`/*!*/;
SET TIMESTAMP=1593360793/*!*/;
SET @@session.pseudo_thread_id=5/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1, @@session.check_constraint_checks=1, @@session.sql_if_exists=0/*!*/;
SET @@session.sql_mode=1411383296/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
insert into test_tb values(3,&quot;wangwu&quot;,22)
/*!*/;
# at 482
#200628 12:13:13 server id 3  end_log_pos 513 CRC32 0x43126028  Xid = 17
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用mysqlbinlog查看指定起始位置的日志信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog --start-position=370 --stop-position=482 /var/lib/mysql/mysql-bin.000001      
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#200628 11:58:31 server id 3  end_log_pos 256 CRC32 0x9afc2aa7  Start: binlog v 4, server v 10.5.4-MariaDB-log created 200628 11:58:31 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
J774Xg8DAAAA/AAAAAABAAABAAQAMTAuNS40LU1hcmlhREItbG9nAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAnvvheEzgNAAgAEgAEBAQEEgAA5AAEGggAAAAICAgCAAAACgoKAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEEwQADQgICAoKCgGnKvya
'/*!*/;
# at 370
#200628 12:13:13 server id 3  end_log_pos 482 CRC32 0x5737f424  Query   thread_id=5     exec_time=0     error_code=0
use `first_db`/*!*/;
SET TIMESTAMP=1593360793/*!*/;
SET @@session.pseudo_thread_id=5/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1, @@session.check_constraint_checks=1, @@session.sql_if_exists=0/*!*/;
SET @@session.sql_mode=1411383296/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
insert into test_tb values(3,&quot;wangwu&quot;,22)
/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用mysqlbinlog查看指定开始时间以后的日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog --start-datetime=&quot;2020-06-28 12:39:05&quot; /var/lib/mysql/mysql-bin.000001
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#200628 11:58:31 server id 3  end_log_pos 256 CRC32 0x9afc2aa7  Start: binlog v 4, server v 10.5.4-MariaDB-log created 200628 11:58:31 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
J774Xg8DAAAA/AAAAAABAAABAAQAMTAuNS40LU1hcmlhREItbG9nAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAnvvheEzgNAAgAEgAEBAQEEgAA5AAEGggAAAAICAgCAAAACgoKAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEEwQADQgICAoKCgGnKvya
'/*!*/;
# at 513
#200628 12:39:05 server id 3  end_log_pos 555 CRC32 0xf924553d  GTID 0-3-2 trans
/*!100101 SET @@session.skip_parallel_replication=0*//*!*/;
/*!100001 SET @@session.gtid_domain_id=0*//*!*/;
/*!100001 SET @@session.server_id=3*//*!*/;
/*!100001 SET @@session.gtid_seq_no=2*//*!*/;
BEGIN
/*!*/;
# at 555
#200628 12:39:05 server id 3  end_log_pos 668 CRC32 0x496c0f4f  Query   thread_id=6     exec_time=0     error_code=0
use `first_db`/*!*/;
SET TIMESTAMP=1593362345/*!*/;
SET @@session.pseudo_thread_id=6/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1, @@session.check_constraint_checks=1, @@session.sql_if_exists=0/*!*/;
SET @@session.sql_mode=1411383296/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
insert into test_tb values (4,&quot;wukong&quot;,99)
/*!*/;
# at 668
#200628 12:39:05 server id 3  end_log_pos 699 CRC32 0xf5032d63  Xid = 27
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用mysqlbinlog查看指定时间段的日志信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog --start-datetime=&quot;2020-06-28 12:13:13&quot; --stop-datetime=&quot;2020-06-28 12:43:42&quot; /var/lib/mysql/mysql-bin.000001        
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#200628 11:58:31 server id 3  end_log_pos 256 CRC32 0x9afc2aa7  Start: binlog v 4, server v 10.5.4-MariaDB-log created 200628 11:58:31 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
J774Xg8DAAAA/AAAAAABAAABAAQAMTAuNS40LU1hcmlhREItbG9nAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAnvvheEzgNAAgAEgAEBAQEEgAA5AAEGggAAAAICAgCAAAACgoKAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAEEwQADQgICAoKCgGnKvya
'/*!*/;
# at 328
#200628 12:13:13 server id 3  end_log_pos 370 CRC32 0xd9b2a8a4  GTID 0-3-1 trans
/*!100101 SET @@session.skip_parallel_replication=0*//*!*/;
/*!100001 SET @@session.gtid_domain_id=0*//*!*/;
/*!100001 SET @@session.server_id=3*//*!*/;
/*!100001 SET @@session.gtid_seq_no=1*//*!*/;
BEGIN
/*!*/;
# at 370
#200628 12:13:13 server id 3  end_log_pos 482 CRC32 0x5737f424  Query   thread_id=5     exec_time=0     error_code=0
use `first_db`/*!*/;
SET TIMESTAMP=1593360793/*!*/;
SET @@session.pseudo_thread_id=5/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1, @@session.check_constraint_checks=1, @@session.sql_if_exists=0/*!*/;
SET @@session.sql_mode=1411383296/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=8/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
insert into test_tb values(3,&quot;wangwu&quot;,22)
/*!*/;
# at 482
#200628 12:13:13 server id 3  end_log_pos 513 CRC32 0x43126028  Xid = 17
COMMIT/*!*/;
# at 513
#200628 12:39:05 server id 3  end_log_pos 555 CRC32 0xf924553d  GTID 0-3-2 trans
/*!100001 SET @@session.gtid_seq_no=2*//*!*/;
BEGIN
/*!*/;
# at 555
#200628 12:39:05 server id 3  end_log_pos 668 CRC32 0x496c0f4f  Query   thread_id=6     exec_time=0     error_code=0
SET TIMESTAMP=1593362345/*!*/;
insert into test_tb values (4,&quot;wukong&quot;,99)
/*!*/;
# at 668
#200628 12:39:05 server id 3  end_log_pos 699 CRC32 0xf5032d63  Xid = 27
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：根据上面时间或者位置指定范围后，我们就可以过滤我们需要的信息来做处理；如下，过滤insert语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@lxc ~]# mysqlbinlog --start-datetime=&quot;2020-06-28 12:13:13&quot; --stop-datetime=&quot;2020-06-28 12:43:42&quot; /var/lib/mysql/mysql-bin.000001|grep insert
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
insert into test_tb values(3,&quot;wangwu&quot;,22)
insert into test_tb values (4,&quot;wukong&quot;,99)
[root@lxc ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到通过过滤关键字就可以很快定位到我们日志中记录了那些语句，一眼就能清楚知道之前执行过什么语句；&lt;/p&gt;
&lt;p&gt;　　5、中继日志，该日志主要是在主从复制架构中记录从主服务器的二进制日志文件同步过来的事件信息；开启中继日志配置如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200629005616851-1180612711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启中继日志并保持到/var/lib/mysql/relay_log中；&lt;/p&gt;
&lt;p&gt;　　确定配置中继日志是否开启成功，方法一，搭建主从复制，开启主从复制线程，在对应目录看是否有对应文件生成，方法二，直接在数据库里查看reay_log变量的值，如果是我们配置的路基，表示开启成功，否则失败&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200629010008384-181350317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的截图可以看到关于中继日志参数的配置有以上几种，max_relay_log_size表示中继日志的最大容量；relay_log表示中继日志存放路径和中继日志以那个名称开头，这个和二进制日志的配置逻辑差不多；relay_log_basename表示已那个名字作为中继日志的基名；relay_log_index表示relay_log.index文件存放地；relay_log_info_file表示relay_log.info 文件名；relay_log_purge表示是否开启修剪中继日志；relay_log_recovery表示是否开启中继日志恢复功能（是否随mariadb服务启动而创建一个新的relay_log,将sql线程的位置初始化到新的relay log，并将i/o线程初始化到sql线程位置。）relay_log_space_limit表示是否开启中继日志空间限制；sync_relay_log表示多少次事务同步一次中继日志到磁盘；sync_relay_log_info表示多少次事务同步一次relay-log.info；&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jun 2020 17:49:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前面我们聊到了mariadb的事务，以及事务隔离级别，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13198186.html；今天我们来聊一聊mariadb的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13205870.html</dc:identifier>
</item>
</channel>
</rss>