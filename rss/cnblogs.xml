<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud Alibaba | Sentinel：分布式系统的流量防卫兵进阶实战 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11516011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11516011.html</guid>
<description>&lt;p&gt;在阅读本文前，建议先阅读&lt;a href=&quot;https://www.geekdigging.com/2019/09/10/543536903/&quot;&gt;《Spring Cloud Alibaba | Sentinel：分布式系统的流量防卫兵基础实战》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;sentinel整合feign和resttemplate&quot;&gt;1. Sentinel整合Feign和RestTemplate&lt;/h2&gt;
&lt;p&gt;Sentinel目前已经同时支持Feign和RestTemplate，需要我们引入对应的依赖，在使用Feign的时候需要在配置文件中打开Sentinel对Feign的支持：&lt;code&gt;feign.sentinel.enabled=true&lt;/code&gt;，同时需要加入&lt;code&gt;openfeign starter&lt;/code&gt;依赖使&lt;code&gt;sentinel starter&lt;/code&gt;中的自动化配置类生效。在使用RestTemplate的时候需要在构造RestTemplate的Bean的时候加上&lt;code&gt;@SentinelRestTemplate&lt;/code&gt;注解，开启Sentinel对RestTemplate的支持。&lt;/p&gt;
&lt;h3 id=&quot;创建父工程sentinel-springcloud-high&quot;&gt;1.1 创建父工程sentinel-springcloud-high：&lt;/h3&gt;
&lt;p&gt;父工程pom.xml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-sentinel&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公共组件中引入Sentinel做流量控制，引入Nacos做服务中心。&lt;/p&gt;
&lt;h3 id=&quot;创建子工程provider_server&quot;&gt;1.2 创建子工程provider_server：&lt;/h3&gt;
&lt;p&gt;配置文件application.yml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/provider_server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8000
spring:
  application:
    name: spring-cloud-provider-server
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.44.129:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8720
management:
  endpoints:
    web:
      cors:
        allowed-methods: '*'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口测试类HelloController.java如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/provider_server/src/main/java/com/springcloud/provider_server/controller/HelloController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public String hello(HttpServletRequest request) {
        return &quot;Hello, port is: &quot; + request.getLocalPort();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建子工程consumer_server&quot;&gt;1.3 创建子工程consumer_server：&lt;/h3&gt;
&lt;p&gt;子工程依赖pom.xml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件application.yml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_server/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 9000
spring:
  application:
    name: spring-cloud-consumer-server
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.44.129:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8719
management:
  endpoints:
    web:
      cors:
        allowed-methods: '*'
feign:
  sentinel:
    enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用&lt;code&gt;feign.sentinel.enabled=true&lt;/code&gt;开启Sentinel对Feign的支持。&lt;/p&gt;
&lt;p&gt;接口测试类HelloController.java&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_server/src/main/java/com/springcloud/consumer_server/controller/HelloController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class HelloController {
    @Autowired
    HelloRemote helloRemote;

    @Autowired
    RestTemplate restTemplate;

    @GetMapping(&quot;/helloByFeign&quot;)
    public String helloByFeign() {
        return helloRemote.hello();
    }

    @GetMapping(&quot;/helloByRestTemplate&quot;)
    public String helloByRestTemplate() {
        return restTemplate.getForObject(&quot;http://spring-cloud-provider-server/hello/&quot;, String.class);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sentinel已经对做了整合，我们使用Feign的地方无需额外的注解。同时，&lt;code&gt;@FeignClient&lt;/code&gt;注解中的所有属性，Sentinel都做了兼容。&lt;/p&gt;
&lt;p&gt;启动主类Ch122ConsumerServerApplication.java如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_server/src/main/java/com/springcloud/consumer_server/ConsumerServerApplication.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class Ch122ConsumerServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(Ch122ConsumerServerApplication.class, args);
    }

    @Bean
    @LoadBalanced
    @SentinelRestTemplate
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用RestTemplate的时候需要增加&lt;code&gt;@SentinelRestTemplate&lt;/code&gt;来开启Sentinel对RestTemplate的支持。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;1.4 测试&lt;/h3&gt;
&lt;p&gt;启动工程provider_server和consumer_server，provider_server修改启动配置，启动两个实例，打开浏览器访问：http://localhost:9000/helloByFeign 和 http://localhost:9000/helloByRestTemplate ，刷新几次，可以看到页面交替显示&lt;code&gt;Hello, port is: 8000&lt;/code&gt;和&lt;code&gt;Hello, port is: 8001&lt;/code&gt;，说明目前负载均衡正常，现在查看Sentinel控制台，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084217808-483432541.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;流量控制测试&quot;&gt;1.5 流量控制测试&lt;/h3&gt;
&lt;p&gt;这时选择左侧的簇点流控，点击流控，如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084218786-1251824834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们配置一个最简单的规则，配置QPS限制为1，点击新增，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084218970-385682914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里解释一下什么是QPS，简单来说QPS是一个每秒访问数，这里我们测试时需要重复快速刷新http://localhost:9000/helloByFeign 和 http://localhost:9000/helloByRestTemplate ，在刷新的过程中，我们可以看到页面会显示错误信息，如：&lt;code&gt;Blocked by Sentinel (flow limiting)&lt;/code&gt;，说明我们配置Sentinel已经限流成功，这时我们再看一下Sentinel的控制台，可以看到我们刚才访问的成功和限流的数量，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084219371-555741618.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务降级&quot;&gt;2. 服务降级&lt;/h2&gt;
&lt;p&gt;在上一小结，我们介绍了Feign和RestTemplate整合Sentinel使用，并且在Sentinel控制台上做了QPS限流，并且限流成功，限流成功后，默认情况下，Sentinel对控制资源的限流处理是直接抛出异常。在没有合理的业务承接或者前端对接情况下可以这样，但是正常情况为了更好的用户业务，都会实现一些被限流之后的特殊处理，我们不希望展示一个生硬的报错。这一小节，我们介绍一下服务降级处理。&lt;/p&gt;
&lt;h3 id=&quot;创建子工程consumer_fallback&quot;&gt;2.1 创建子工程consumer_fallback&lt;/h3&gt;
&lt;p&gt;Feign服务降级类HelloRemoteFallBack.java如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_fallback/src/main/java/com/springcloud/consumer_fallback/fallback/HelloRemoteFallBack.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class HelloRemoteFallBack implements HelloRemote {
    @Override
    public String hello() {
        return &quot;Feign FallBack Msg&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相对应的，这里需要在HelloRemote.java上做一部分配置，使得限流后，触发服务降级执行我们的服务降级类，代码如下：&lt;/p&gt;
&lt;p&gt;代码清单：ch12_2/ch12_2_consumer_fallback/src/main/java/com/springcloud/book/ch12_2_consumer_fallback/remote/HelloRemote.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;spring-cloud-provider-server&quot;, fallback = HelloRemoteFallBack.class)
public interface HelloRemote {
    @GetMapping(&quot;/hello&quot;)
    String hello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fallback = HelloRemoteFallBack.class&lt;/code&gt;指定服务降级的处理类为&lt;code&gt;HelloRemoteFallBack.class&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;RestTemplate服务降级工具类ExceptionUtil.java如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_fallback/src/main/java/com/springcloud/consumer_fallback/remote/HelloRemote.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ExceptionUtil {

    private final static Logger logger = LoggerFactory.getLogger(ExceptionUtil.class);

    public static SentinelClientHttpResponse handleException(HttpRequest request, byte[] body, ClientHttpRequestExecution execution, BlockException ex) {
        logger.error(ex.getMessage(), ex);
        return new SentinelClientHttpResponse(&quot;RestTemplate FallBack Msg&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里同样需要修改RestTemplate注册成为Bean的地方，使得RestTemplate触发服务降级以后代码执行我们为它写的处理类，Ch122ConsumerFallbackApplication.java代码如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/consumer_fallback/src/main/java/com/springcloud/consumer_fallback/ConsumerFallbackApplication.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Bean
@LoadBalanced
@SentinelRestTemplate(blockHandler = &quot;handleException&quot;, blockHandlerClass = ExceptionUtil.class)
public RestTemplate restTemplate() {
    return new RestTemplate();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意，&lt;code&gt;@SentinelRestTemplate&lt;/code&gt;注解的属性支持限流(&lt;code&gt;blockHandler&lt;/code&gt;, &lt;code&gt;blockHandlerClass&lt;/code&gt;)和降级(&lt;code&gt;fallback&lt;/code&gt;, &lt;code&gt;fallbackClass&lt;/code&gt;)的处理。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;blockHandler&lt;/code&gt;或&lt;code&gt;fallback&lt;/code&gt;属性对应的方法必须是对应&lt;code&gt;blockHandlerClass&lt;/code&gt;或&lt;code&gt;fallbackClass&lt;/code&gt;属性中的静态方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@SentinelRestTemplate&lt;/code&gt;注解的限流(&lt;code&gt;blockHandler&lt;/code&gt;, &lt;code&gt;blockHandlerClass&lt;/code&gt;)和降级(&lt;code&gt;fallback&lt;/code&gt;, &lt;code&gt;fallbackClass&lt;/code&gt;)属性不强制填写。&lt;/p&gt;
&lt;p&gt;当使用RestTemplate调用被Sentinel熔断后，会返回&lt;code&gt;RestTemplate request block by sentinel&lt;/code&gt;信息，或者也可以编写对应的方法自行处理返回信息。这里提供了 &lt;code&gt;SentinelClientHttpResponse&lt;/code&gt;用于构造返回信息。&lt;/p&gt;
&lt;h3 id=&quot;测试-1&quot;&gt;2.2 测试&lt;/h3&gt;
&lt;p&gt;顺次启动provider_server和consumer_fallback两个子工程。先在浏览器中交替访问http://localhost:9090/helloByFeign 和 http://localhost:9090/helloByRestTemplate ，而后打开Sentinel控制台，在这两个接口上增加限流信息，注意，这里要将限流信息加在资源上，具体如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084220820-308787331.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器中刷新两个链接，两个限流信息都可以正常浏览器中显示，测试成功，再次查看Sentinel控制台，也可以看到被拒接的流量统计，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084221275-914787021.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sentinel整合服务网关限流&quot;&gt;3. Sentinel整合服务网关限流&lt;/h2&gt;
&lt;p&gt;Sentinel目前支持Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。看一下官方的结构图，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084222536-136282818.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这张官方的图中，可以看到，Sentinel对Zuul的限流主要是通过3个Filter来完成的，对Spring Cloud Gateway则是通过一个&lt;code&gt;SentinleGatewayFilter&lt;/code&gt;和一个&lt;code&gt;BlockRequestHandler&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;p&gt;Sentinel 1.6.0 引入了 Sentinel API Gateway Adapter Common 模块，此模块中包含网关限流的规则和自定义 API 的实体和管理逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GatewayFlowRule：网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同 route 或自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。&lt;/li&gt;
&lt;li&gt;ApiDefinition：用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。比如我们可以定义一个 API 叫 my_api，请求 path 模式为 /foo/** 和 /baz/** 的都归到 my_api 这个 API 分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;zuul-1.x&quot;&gt;3.1 Zuul 1.x&lt;/h3&gt;
&lt;p&gt;Sentinel 提供了 Zuul 1.x 的适配模块，可以为 Zuul Gateway 提供两种资源维度的限流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 route ID（对应 RequestContext 中的 proxy 字段）&lt;/li&gt;
&lt;li&gt;自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建子工程zuul_server&quot;&gt;3.1.1 创建子工程zuul_server&lt;/h4&gt;
&lt;p&gt;工程依赖pom.xml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/zuul_server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sentinel-zuul-adapter&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里因为&lt;code&gt;sentinel-zuul-adapter&lt;/code&gt;未包含在&lt;code&gt;spring-cloud-starter-alibaba-sentinel&lt;/code&gt;，需要手动单独引入。&lt;/p&gt;
&lt;h4 id=&quot;配置文件application.yml如下&quot;&gt;3.1.2 配置文件application.yml如下：&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/zuul_server/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 18080
spring:
  application:
    name: spring-cloud-zuul-server
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.44.129:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8720
zuul:
  routes:
    consumer-route:
      path: /consumer/**
      serviceId: spring-cloud-consumer-fallback&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义降级处理类zuulfallbackprovider.java如下&quot;&gt;3.1.3 定义降级处理类ZuulFallbackProvider.java如下：&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/zuul_server/src/main/java/com/springcloud/zuul_server/fallback/ZuulFallbackProvider.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ZuulFallbackProvider implements ZuulBlockFallbackProvider {
    @Override
    public String getRoute() {
        return &quot;*&quot;;
    }

    @Override
    public BlockResponse fallbackResponse(String route, Throwable cause) {
        RecordLog.info(String.format(&quot;[Sentinel DefaultBlockFallbackProvider] Run fallback route: %s&quot;, route));
        if (cause instanceof BlockException) {
            return new BlockResponse(429, &quot;Sentinel block exception&quot;, route);
        } else {
            return new BlockResponse(500, &quot;System Error&quot;, route);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同时我们需要将3个sentinel的filter注入spring配置类如下&quot;&gt;3.1.4 同时，我们需要将3个Sentinel的Filter注入Spring，配置类如下：&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/zuul_server/src/main/java/com/springcloud/zuul_server/config/ZuulConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class ZuulConfig {
    @Bean
    public ZuulFilter sentinelZuulPreFilter() {
        // We can also provider the filter order in the constructor.
        return new SentinelZuulPreFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulPostFilter() {
        return new SentinelZuulPostFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulErrorFilter() {
        return new SentinelZuulErrorFilter();
    }

    /**
     * 注册 ZuulFallbackProvider
     */
    @PostConstruct
    public void doInit() {
        ZuulBlockFallbackManager.registerProvider(new ZuulFallbackProvider());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终，启动前需要配置JVM启动参数，增加&lt;code&gt;-Dcsp.sentinel.app.type=1&lt;/code&gt;，来告诉Sentinel控制台我们启动的服务是为 API Gateway 类型。&lt;/p&gt;
&lt;h4 id=&quot;测试-2&quot;&gt;3.1.5 测试&lt;/h4&gt;
&lt;p&gt;顺次启动子工程provider_server、consumer_fallback、zuul_server，打开浏览器访问：http://localhost:18080/consumer/helloByFeign ，然后我们打开Sentinel控制台，查看zuul_server服务，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084223499-459012548.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们定制限流策略，依旧是QPS为1，我们再次刷新http://localhost:18080/consumer/helloByFeign 页面，这时，页面上已经可以正产限流了，限流后显示的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;code&quot;:429, &quot;message&quot;:&quot;Sentinel block exception&quot;, &quot;route&quot;:&quot;consumer-route&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意，定义限流的是资源，千万不要定义错地方，限流定义如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084223703-1239398.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-gateway&quot;&gt;3.2 Spring Cloud Gateway&lt;/h3&gt;
&lt;p&gt;从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId&lt;/li&gt;
&lt;li&gt;自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建子工程gateway_server&quot;&gt;3.2.1 创建子工程gateway_server&lt;/h4&gt;
&lt;p&gt;工程依赖pom.xml如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/gateway_server/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sentinel-spring-cloud-gateway-adapter&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置文件application.yml如下-1&quot;&gt;3.2.2 配置文件application.yml如下：&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/gateway_server/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 28080
spring:
  application:
    name: spring-cloud-gateway-server
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.44.129:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8720
    gateway:
      enabled: true
      discovery:
        locator:
          lower-case-service-id: true
      routes:
        - id: consumer_server
          uri: lb://spring-cloud-consumer-fallback
          predicates:
            - Method=GET&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;全局配置类gatewayconfig.java如下&quot;&gt;3.2.3 全局配置类GatewayConfig.java如下：&lt;/h4&gt;
&lt;p&gt;同上一小节介绍的Zuul，这里我们同样需要将两个Sentinel有关Spring Cloud Gateway的Filter注入Spring：&lt;code&gt;SentinelGatewayFilter&lt;/code&gt;和&lt;code&gt;SentinelGatewayBlockExceptionHandler&lt;/code&gt;，这里因为在Sentinel v1.6.0版本才加入Spring Cloud Gateway的支持，很多地方还不是很完善，异常处理&lt;code&gt;SentinelGatewayBlockExceptionHandler&lt;/code&gt;目前只能返回一个异常信息，在我们的系统中无法和上下游很好的结合，这里笔者自己重新实现了&lt;code&gt;SentinelGatewayBlockExceptionHandler&lt;/code&gt;，并命名为&lt;code&gt;JsonSentinelGatewayBlockExceptionHandler&lt;/code&gt;，返回参数定义成为JSON，这里不再注入Sentinel提供的&lt;code&gt;SentinelGatewayBlockExceptionHandler&lt;/code&gt;，而是改为笔者自己实现的&lt;code&gt;JsonSentinelGatewayBlockExceptionHandler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/gateway_server/src/main/java/com/springcloud/gateway_server/config/GatewayConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class GatewayConfig {
    private final List&amp;lt;ViewResolver&amp;gt; viewResolvers;
    private final ServerCodecConfigurer serverCodecConfigurer;

    public GatewayConfig(ObjectProvider&amp;lt;List&amp;lt;ViewResolver&amp;gt;&amp;gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer) {
        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);
        this.serverCodecConfigurer = serverCodecConfigurer;
    }

    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public JsonSentinelGatewayBlockExceptionHandler jsonSentinelGatewayBlockExceptionHandler() {
        // Register the block exception handler for Spring Cloud Gateway.
        return new JsonSentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);
    }

    @Bean
    @Order(-1)
    public GlobalFilter sentinelGatewayFilter() {
        return new SentinelGatewayFilter();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;降级处理类jsonsentinelgatewayblockexceptionhandler.java如下&quot;&gt;3.2.4 降级处理类JsonSentinelGatewayBlockExceptionHandler.java如下：&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/sentinel-springcloud-high/gateway_server/src/main/java/com/springcloud/gateway_server/exception/JsonSentinelGatewayBlockExceptionHandler.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JsonSentinelGatewayBlockExceptionHandler implements WebExceptionHandler {
    private List&amp;lt;ViewResolver&amp;gt; viewResolvers;
    private List&amp;lt;HttpMessageWriter&amp;lt;?&amp;gt;&amp;gt; messageWriters;

    public JsonSentinelGatewayBlockExceptionHandler(List&amp;lt;ViewResolver&amp;gt; viewResolvers, ServerCodecConfigurer serverCodecConfigurer) {
        this.viewResolvers = viewResolvers;
        this.messageWriters = serverCodecConfigurer.getWriters();
    }

    private Mono&amp;lt;Void&amp;gt; writeResponse(ServerResponse response, ServerWebExchange exchange) {
        ServerHttpResponse serverHttpResponse = exchange.getResponse();
        serverHttpResponse.getHeaders().add(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);
        byte[] datas = &quot;{\&quot;code\&quot;:403,\&quot;msg\&quot;:\&quot;Sentinel block exception\&quot;}&quot;.getBytes(StandardCharsets.UTF_8);
        DataBuffer buffer = serverHttpResponse.bufferFactory().wrap(datas);
        return serverHttpResponse.writeWith(Mono.just(buffer));
    }

    @Override
    public Mono&amp;lt;Void&amp;gt; handle(ServerWebExchange exchange, Throwable ex) {
        if (exchange.getResponse().isCommitted()) {
            return Mono.error(ex);
        }
        // This exception handler only handles rejection by Sentinel.
        if (!BlockException.isBlockException(ex)) {
            return Mono.error(ex);
        }
        return handleBlockedRequest(exchange, ex)
                .flatMap(response -&amp;gt; writeResponse(response, exchange));
    }

    private Mono&amp;lt;ServerResponse&amp;gt; handleBlockedRequest(ServerWebExchange exchange, Throwable throwable) {
        return GatewayCallbackManager.getBlockHandler().handleRequest(exchange, throwable);
    }

    private final Supplier&amp;lt;ServerResponse.Context&amp;gt; contextSupplier = () -&amp;gt; new ServerResponse.Context() {
        @Override
        public List&amp;lt;HttpMessageWriter&amp;lt;?&amp;gt;&amp;gt; messageWriters() {
            return JsonSentinelGatewayBlockExceptionHandler.this.messageWriters;
        }

        @Override
        public List&amp;lt;ViewResolver&amp;gt; viewResolvers() {
            return JsonSentinelGatewayBlockExceptionHandler.this.viewResolvers;
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者这里仅重写了&lt;code&gt;writeResponse()&lt;/code&gt;方法，讲返回信息简单的更改成了json格式，各位读者有需要可以根据自己的需求进行修改。&lt;/p&gt;
&lt;h4 id=&quot;测试-3&quot;&gt;3.2.5 测试&lt;/h4&gt;
&lt;p&gt;顺次启动provider_server、consumer_server和gateway_server，配置gateway_server jvm启动参数&lt;code&gt;-Dcsp.sentinel.app.type=1&lt;/code&gt;，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190913084224109-249353509.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器访问：http://localhost:28080/helloByFeign ，刷新几次，页面正常返回&lt;code&gt;Hello, port is: 8000&lt;/code&gt;，打开Sentinel控制台，配置限流策略，QPS限制为1，再刷新浏览器页面，这时，我们可以看到浏览器返回限流信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;code&quot;:403,&quot;msg&quot;:&quot;Sentinel block exception&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试成功。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 00:42:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>Spring Cloud Alibaba | Sentinel：分布式系统的流量防卫兵进阶实战 在阅读本文前，建议先阅读 '《Spring Cloud Alibaba | Sentinel：分布式系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11516011.html</dc:identifier>
</item>
<item>
<title>第 15 篇：优化博客功能的细节，提升使用体验—— HelloDjango 系列教程 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11514283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11514283.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190828185611060-1211614569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;作者：HelloGitHub-&lt;strong&gt;追梦人物&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4027777777778&quot;&gt;
&lt;p&gt;文中涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在之前的系列教程中，我们已经实现了：文章的发布、展示、评论等功能，可能认真的小伙伴已经发现这些功能有一些地方设计的不是很好，今天我们就来优化一些体验和操作上的细节。让我们的博客更加完美，使用起来更加顺手～&lt;/p&gt;
&lt;h2 id=&quot;在模型中指定排序&quot;&gt;在模型中指定排序&lt;/h2&gt;
&lt;p&gt;为了让文章（Post）按发布时间逆序排列，让最新发表的文章排在文章列表的最前面，我们对返回的文章列表进行了排序，即各个视图函数中都有类似于 &lt;code&gt;Post.objects.all().order_by('-created_time')&lt;/code&gt; 这样的代码，导致了很多重复。因为只要是返回的文章列表，基本都是逆序排列的，所以可以在 Post 模型中指定 Post 的自然排序方式。&lt;/p&gt;
&lt;p&gt;django 允许我们在 &lt;code&gt;models.Model&lt;/code&gt; 的子类里定义一个名为 &lt;code&gt;Meta&lt;/code&gt; 的内部类，通过这个内部类指定一些属性的值来规定这个模型类该有的一些特性，例如在这里我们要指定 Post 的排序方式。首先看到 Post 的代码，在 &lt;code&gt;Post&lt;/code&gt; 模型的内部定义的 &lt;code&gt;Meta&lt;/code&gt; 类中，指定排序属性 &lt;code&gt;ordering&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;blog/models.py

class Post(models.Model):
    ...
    created_time = models.DateTimeField()
    ...

    class Meta:
        verbose_name = '文章'
        verbose_name_plural = verbose_name
        ordering = ['-created_time']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ordering&lt;/code&gt; 属性用来指定文章排序方式，&lt;code&gt;['-created_time']&lt;/code&gt; 指定了依据哪个属性的值进行排序，这里指定为按照文章发布时间排序，且负号表示逆序排列。列表中可以有多个项，比如 &lt;code&gt;ordering = ['-created_time', 'title']&lt;/code&gt; 表示首先依据 &lt;code&gt;created_time&lt;/code&gt; 排序，如果 &lt;code&gt;created_time&lt;/code&gt; 相同，则再依据 &lt;code&gt;title&lt;/code&gt; 排序。这样指定以后所有返回的文章列表都会自动按照 &lt;code&gt;Meta&lt;/code&gt; 中指定的顺序排序，因此可以删掉视图函数中对文章列表中返回结果进行排序的代码了。&lt;/p&gt;
&lt;p&gt;评论的模型类（Comment）也可以添加这个属性。&lt;/p&gt;
&lt;h2 id=&quot;完善跳转链接&quot;&gt;完善跳转链接&lt;/h2&gt;
&lt;p&gt;导航栏有一个 Black &amp;amp; White 的 Logo，我们希望点击它就能回到首页面，只需修改一下超链接即可。打开 base.html，修改 Logo 处的超链接：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;header id=&quot;site-header&quot;&amp;gt;
  &amp;lt;div class=&quot;row&quot;&amp;gt;
      &amp;lt;div class=&quot;logo&quot;&amp;gt;
        &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;{% url 'blog:index' %}&quot;&amp;gt;&amp;lt;b&amp;gt;Black&amp;lt;/b&amp;gt; &amp;amp;amp; White&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
  ...
  &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外导航栏还有一个首页导航按钮，也希望点击它就能回到首页面，修改的任务作为练习交给你了（有两处，一处是桌面端导航，另一处是移动端导航）。&lt;/p&gt;
&lt;p&gt;当然还有一些跳转可以完善，比如文章标题下有分类、发布时间、作者、评论量、阅读量等信息，可以设置点击分类跳转到分类页面；点击阅读量就跳转到文章详情页等，这些细节部分不涉及新知识，就当做练习交给你自己完成了。&lt;/p&gt;
&lt;h2 id=&quot;显示正确的评论量&quot;&gt;显示正确的评论量&lt;/h2&gt;
&lt;p&gt;有两处地方显示的评论量（首页文章列表和文章详情页），显示评论量的方法很简单。回顾一下我们是如何获取某篇文章下的评论列表的？我们使用的是 &lt;code&gt;post.comment_set.all()&lt;/code&gt;。&lt;code&gt;all&lt;/code&gt; 方法返回该 &lt;code&gt;post&lt;/code&gt; 关联的评论列表。此外模型管理器（&lt;code&gt;comment_set&lt;/code&gt; 是一个特殊的模型管理器）还有一个 &lt;code&gt;count&lt;/code&gt; 方法，返回的是数量，即 &lt;code&gt;post&lt;/code&gt; 下有多少条评论，我们可以直接在模板中调用这个方法：&lt;code&gt;{{ post.comment_set.count }}&lt;/code&gt;。将评论量替换成该模板变量就可以正确显示文章的评论数了。&lt;/p&gt;
&lt;h2 id=&quot;跳转评论区域&quot;&gt;跳转评论区域&lt;/h2&gt;
&lt;p&gt;有时候文章内容长了，评论列表的内容就需要滚动很长的页面才能看到。我们可以在评论区域增加一个锚点，2 处显示评论量的地方超链接都指向这个锚点处，这样点击这两个地方将直接跳转到评论列表区域，方便用户快速查看评论内容。&lt;/p&gt;
&lt;p&gt;看到显示评论的模板代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;section class=&quot;comment-area&quot; id=&quot;comment-area&quot;&amp;gt;
    &amp;lt;hr&amp;gt;
    &amp;lt;h3&amp;gt;发表评论&amp;lt;/h3&amp;gt;
    ...
&amp;lt;/section&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们已经给评论区域的标签设置了 id，只需要在评论的链接后加上这个 id 的锚点即可：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;blog/index.html

&amp;lt;div class=&quot;entry-meta&quot;&amp;gt;
    ...
    &amp;lt;span class=&quot;comments-link&quot;&amp;gt;&amp;lt;a href=&quot;{{ post.get_absolute_url }}#comment-area&quot;&amp;gt;{{ post.comment_set.count }} 评论&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;views-count&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;588 阅读&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;blog/detail.html

&amp;lt;header class=&quot;entry-header&quot;&amp;gt;
    &amp;lt;h1 class=&quot;entry-title&quot;&amp;gt;{{ post.title }}&amp;lt;/h1&amp;gt;
        ...
        &amp;lt;span class=&quot;comments-link&quot;&amp;gt;&amp;lt;a href=&quot;#comment-area&quot;&amp;gt;{{ post.comment_set.count }} 评论&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;views-count&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;588 阅读&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里从 index.html 到评论区域需要跳转页面，因此 href 超链接指定为绝对 URL，而文章详情和评论区域在一个页面，因此仅需指定锚点即可。&lt;/p&gt;
&lt;h2 id=&quot;结束了么&quot;&gt;结束了么&lt;/h2&gt;
&lt;p&gt;我们通过一个博客实战项目，了解了 django 基本的开发技术。包括如何编写模型（Model）、如何编写视图函数（View）、如何使用 django 内置的模板系统（Template）以及如何配置路由（URL），这四大模块是 django 开发的核心所在，现在我们已经能够基本掌握这些模块的使用方法了。&lt;/p&gt;
&lt;p&gt;但是，还没完...&lt;/p&gt;
&lt;p&gt;Django 提供的不仅仅是这些，我们的博客也不仅仅只有这些功能。如何对博客文章进行分页？如何给博客提供 RSS 订阅服务？如果实现文章搜索？如果网站需要提供用户系统，如何实现用户的注册登录？如何部署到服务器上让他人通过公网访问？这些需求都可以利用 django 内置的模块或者丰富的第三方应用来实现。&lt;/p&gt;
&lt;p&gt;另外，django 还有海量的第三方应用来提供更加丰富的功能。比如当他人评论了我的文章时，如何收到通知提醒？网站需要提供新浪微博、微信等社交账号的登录等等，这些都可以借助 django 第三方应用快速完成，而我们自己只需要写很少量的代码就可以了。&lt;/p&gt;
&lt;p&gt;所以，让我们再接再厉，进入到进阶篇，继续学习更多的 django 开发技巧，为博客提供更多的功能吧！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Fri, 13 Sep 2019 00:37:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 追梦人物 文中涉及的示例代码，已同步更新到 'HelloGitHub Team 仓库' 在之前的系列教程中，我们已经实现了：文章的发布、展示、评论等功能，可能认真的小伙伴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11514283.html</dc:identifier>
</item>
<item>
<title>从“最简真分数的个数”谈起 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/11515994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/11515994.html</guid>
<description>&lt;p&gt;      所谓最简真分数是一个分数的分子小于分母，且分子分母无公因数。&lt;br/&gt;      2010年湖北省小学奥林匹克数学竞赛（小学六年级组）有这样一道试题：以2010为分母的最简真分数有多少个？&lt;br/&gt;      这道小学奥数试题考察的是学生对集合包含和容斥知识的掌握情况。&lt;br/&gt;      由于2010=2*3*5*67（分解质因数），因此以2010为分母的最简真分数的分子必须小于2010且不能被2、3、5或67整除。&lt;br/&gt;      小朋友解决这个问题的计算过程如下：&lt;br/&gt;      在1~2010共2010个数中，&lt;br/&gt;      能被2整除的数有 2010÷2=1005&lt;br/&gt;      能被3整除的数有 2010÷3=670&lt;br/&gt;      能被5整除的数有 2010÷5=402&lt;br/&gt;      能被67整除的数有 2010÷67=30&lt;br/&gt;      能同时被2和3整除的数有 2010÷（2×3）=335&lt;br/&gt;      能同时被2和5整除的数有 2010÷（2×5）=201&lt;br/&gt;      能同时被2和67整除的数有 2010÷（2×67）=15&lt;br/&gt;      能同时被3和5整除的数有 2010÷（3×5）=134&lt;br/&gt;      能同时被3和67整除的数有 2010÷（3×67）=10&lt;br/&gt;      能同时被5和67整除的数有 2010÷（5×67）=6&lt;br/&gt;      能同时被2、3和5整除的数有 2010÷（2×3×5）=67&lt;br/&gt;      能同时被2、3和67整除的数有 2010÷（2×3×67）=5&lt;br/&gt;      能同时被2、5和67整除的数有 2010÷（2×5×67）=3&lt;br/&gt;      能同时被3、5和67整除的数有 2010÷（3×5×67）=2&lt;br/&gt;      能同时被2、3、5和67整除的数有 2010÷（2×3×5×67）=1&lt;br/&gt;      这样，1~2010中能被2或3或5或67整除的数有&lt;br/&gt;        （1005+670+402+30）-（335+201+15+134+10+6）+（67+5+3+2）-1&lt;br/&gt;       =2107-701+77-1   =1482&lt;br/&gt;      因此，1~2010中既不能被2整除，也不能被3整除，也不能被5整除，也不能被67整除的数有 2010-1482=528 个。&lt;br/&gt;      即以2010为分母的最简真分数有528个。&lt;/p&gt;
&lt;p&gt;      我们可以看出，上面的计算过程是比较繁琐的，需要认真仔细。&lt;br/&gt;      学习过程序设计后，可以编写了一个简单的循环程序解决这个问题。&lt;br/&gt;      用一个变量cnt来保存最简真分数的个数，初始值为0。&lt;br/&gt;      对1~2010中的每一个数num，进行判断，这是一个循环，写成&lt;br/&gt;             for(num=1; num&amp;lt;=2010;num++)&lt;br/&gt;      循环体中的判断方法为：如果num既不能被2整除，也不能被3整除，也不能被5整除，也不能被67整除，则计数。写成&lt;br/&gt;       if(num%2!=0 &amp;amp;&amp;amp; num%3!=0 &amp;amp;&amp;amp; num%5!=0 &amp;amp;&amp;amp; num %67!=0)&lt;br/&gt;              cnt++;&lt;br/&gt;      最后，输出结果cnt。   一个简单的程序，就得到问题的答案。&lt;br/&gt;   编写的源程序如下：&lt;br/&gt;       #include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;       int main()&lt;br/&gt;       {&lt;br/&gt;             int cnt,num;&lt;br/&gt;             cnt=0;&lt;br/&gt;             for (num=1; num&amp;lt;=2010;num++)&lt;br/&gt;                  if (num%2!=0 &amp;amp;&amp;amp; num%3!=0 &amp;amp;&amp;amp; num%5!=0 &amp;amp;&amp;amp; num %67!=0)&lt;br/&gt;                       cnt++;&lt;br/&gt;             printf(&quot;%d\n&quot;,cnt);&lt;br/&gt;             return 0;&lt;br/&gt;       }&lt;/p&gt;
&lt;p&gt;      需要说明的是，当时竞赛的真题是：所有以2010为分母的最简真分数的和为多少？&lt;/p&gt;
&lt;p&gt;      瞧瞧，作为大学生的你还能像小朋友一样做出来吗？&lt;/p&gt;
&lt;p&gt;      当然，你学过程序设计，将上面的程序简单改写一下，可以很快得到答案的。何须像小朋友一样苦苦思考和运算呢。&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;int main()&lt;br/&gt;{&lt;br/&gt;     int num;&lt;br/&gt;     double sum;&lt;br/&gt;     sum=0;&lt;br/&gt;     for (num=1; num&amp;lt;=2010;num++)&lt;br/&gt;         if (num%2!=0 &amp;amp;&amp;amp; num%3!=0 &amp;amp;&amp;amp; num%5!=0 &amp;amp;&amp;amp; num %67!=0)&lt;br/&gt;               sum+=1.0*num/2010;&lt;br/&gt;     printf(&quot;%lf\n&quot;,sum);&lt;br/&gt;     return 0;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;      程序运行后，输出 264.000000。即所有以2010为分母的最简真分数的和是264。&lt;/p&gt;
&lt;p&gt;      小朋友是没法像程序一样硬算的。1/2010+7/2010+11/2010+…+2099/2010=264。&lt;/p&gt;
&lt;p&gt;      小朋友有小朋友的聪明，1/2010是最简真分数，那么2099/2010 也一定是最简真分数。&lt;/p&gt;
&lt;p&gt;      i/2010 是最简真分数，那么 （2010-i）/2010 也一定是最简真分数。&lt;/p&gt;
&lt;p&gt;      1/2010 + 2099/2010=1         i/2010 +（2010-i）/2010=1。&lt;/p&gt;
&lt;p&gt;      小朋友知道了以2010为分母的最简真分数有528个，因此它们的和为 528/2 = 264。&lt;/p&gt;
&lt;p&gt;      因为2010分解质因数后，因数有2、3、5和67四个，用于考察集合的包含与容斥计算量略大但又可以完成，可以算是一道很好的竞赛试题。&lt;/p&gt;
&lt;p&gt;     在这道试题的基础上，我们看这样一个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【例1】最简真分数。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      任意输入一个正整数n，求以n为分母的最简真分数有多少个？&lt;/p&gt;
&lt;p&gt;     （1）编程思路1。&lt;/p&gt;
&lt;p&gt;      将输入的n作为分母，穷举分子i （1≤i≤n-1）。因此，程序可先写成如下的循环：&lt;/p&gt;
&lt;p&gt;         for (i=1; i&amp;lt;=n-1; i++)&lt;br/&gt;        {&lt;br/&gt;               对每一分数i/n，进行是否存在公因数的检测。根据检测的结果决定是否计数；&lt;br/&gt;        }&lt;br/&gt;      在上面的循环体中需要对每一分数i/n，进行是否存在公因数的检测。如果分子i与分母n存在大于1的公因数k，说明i/n不是最简真分数，不予计数。怎样进行检测呢？&lt;br/&gt;      因为公因数k的取值范围为[2，i]，因而设置u循环在[2，i]中穷举k，若满足条件&lt;br/&gt;            i%k==0 &amp;amp;&amp;amp; n%k==0&lt;br/&gt;      说明分子分母存在公因数k，标记t=1后退出。&lt;br/&gt;      在对因子k进行循环穷举前，可设置标志t=0。退出因子穷举循环后，若t=1，说明分子和分母存在公因子；若保持原t=0，说明分子分母无公因数，统计个数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;     （2）源程序1。&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;int main()&lt;br/&gt;{&lt;br/&gt;      int n,i,k,t,cnt;&lt;br/&gt;      while (scanf(&quot;%d&quot;,&amp;amp;n) &amp;amp;&amp;amp; n!=0)&lt;br/&gt;      {&lt;br/&gt;           cnt=0;&lt;br/&gt;           for (i=1;i&amp;lt;=n-1;i++)       // 穷举分子&lt;br/&gt;           {&lt;br/&gt;                t=0;&lt;br/&gt;                for (k=2;k&amp;lt;=i;k++)  // 穷举因数&lt;br/&gt;                    if (i%k==0 &amp;amp;&amp;amp; n%k==0)&lt;br/&gt;                    {&lt;br/&gt;                         t=1;&lt;br/&gt;                         break;          // 分子分母有公因数舍去&lt;br/&gt;                    }&lt;br/&gt;               if (t==0)&lt;br/&gt;                     cnt++;           // 统计最简真分数个数&lt;br/&gt;          }&lt;br/&gt;          printf(&quot;%d\n&quot;,cnt);&lt;br/&gt;      }&lt;br/&gt;      return 0;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;      将上面的源程序提交给 &lt;a href=&quot;http://poj.org/problem?id=2407&quot; target=&quot;_blank&quot;&gt;POJ 2407 “Relatives”&lt;/a&gt;，判定为Time Limit Exceeded。  POJ 2407的题意是： 输入正整数N，求小于或等于N ([1,N])，且与N互质的正整数（包括1）的个数。这与求最简真分数的意思完全一致。&lt;/p&gt;
&lt;p&gt;      上面源程序1的方法简单直接，但对于N值较大的话，会超时的。因此，我们应找到快速的求法。在数论中，欧拉函数就很好地解决了这样的问题。&lt;/p&gt;
&lt;p&gt;      在数论，对于正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，一般简记为φ函数。 例如，φ(8)=4，因为1,3,5,7均和8互质。&lt;/p&gt;
&lt;p&gt;      一般来说，设正整数N分解质因数后，N=P1^q1*P2^q2*...*Pn^qn.&lt;/p&gt;
&lt;p&gt;      则   φ(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn)。&lt;/p&gt;
&lt;p&gt;      例如， 10= 2*5     φ(10)=10×(1-1/2)×(1-1/5)=4;     这4个数是1, 3, 7, 9 。&lt;/p&gt;
&lt;p&gt;         30=2*3*5   φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;  这8个数是1,7,11,13, 17, 19, 23, 29。&lt;/p&gt;

</description>
<pubDate>Fri, 13 Sep 2019 00:08:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>所谓最简真分数是一个分数的分子小于分母，且分子分母无公因数。 2010年湖北省小学奥林匹克数学竞赛（小学六年级组）有这样一道试题：以2010为分母的最简真分数有多少个？ 这道小学奥数试题考察的是学生对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/11515994.html</dc:identifier>
</item>
<item>
<title>小白的消费为何被迫升级？-java数据类型的转换 - 一天不进步，就是退步</title>
<link>http://www.cnblogs.com/davidwang456/p/11515979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davidwang456/p/11515979.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小白最近有点烦恼，原因也很简单，不知道为何？小白的消费不知不觉被迫升级了，请看费用清单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt; b = Byte.MIN_VALUE; b &amp;lt; Byte.MAX_VALUE; b++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == 0x90&lt;span&gt;)
                System.out.print(&lt;/span&gt;&quot;life is Happy!&quot;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本来小白预期输出结果：&lt;/p&gt;
&lt;p&gt;life is Happy!&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/07d84d85a35a41eea82178678db18c9c&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;但是什么都没有输出，这是怎么回事呢？是不是以后的幸福小日子就没了？&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/b6271115a62e451ca87071b105b03904&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;于是小白向柯南请教：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/36ac92950bc84529bb75afac2d7f9bdb&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;破案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了比较byte 数值(byte)0x90 和int 数值0x90，Java 通过拓宽原始类型转换&lt;/p&gt;
&lt;p&gt;将byte 提升为一个int[JLS 5.1.2]，然后比较这两个int 数值。0x90为144，但byte指的范围为-128~127&lt;/p&gt;
&lt;p&gt;故没有打印出预期的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;究根到底&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原来java language Specification中有自动Promotion机制，让我们了解一下数字提升的问题吧&lt;/p&gt;
&lt;p&gt;数字提升总体的规则是向上提升，又分为一元数字提升和二元数字提升&lt;/p&gt;
&lt;p&gt;一元数字提升&lt;/p&gt;
&lt;p&gt;某些运算符将一元数值提升用在了单操作数运算中，其必定能得到一个数字类型的值，&lt;/p&gt;
&lt;p&gt;规则如下：&lt;/p&gt;
&lt;p&gt;if 操作数是编译时包装类型Byte、Short、Character或Integer，那么它会先拆箱为对应的原始类型，然后拓宽为int类型。&lt;/p&gt;
&lt;p&gt;else if 操作数为编译时包装类型Long、Float或Double，那么就直接拆箱为对应的原始类型。&lt;/p&gt;
&lt;p&gt;else if 操作数是编译时拆箱类型byte、short、char或int，那么就拓宽为int类型。&lt;/p&gt;
&lt;p&gt;else 保持原样。&lt;/p&gt;
&lt;p&gt;一元数值提升还用在以下情境的表达式中：&lt;/p&gt;
&lt;p&gt;数组创建表达式的维度&lt;/p&gt;
&lt;p&gt;数组索引表达式的索引&lt;/p&gt;
&lt;p&gt;正号运算符（+）的操作数&lt;/p&gt;
&lt;p&gt;负号运算符（-）的操作数&lt;/p&gt;
&lt;p&gt;按位补运算符（~）的操作数&lt;/p&gt;
&lt;p&gt;移位运算符（&amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt;, &amp;lt;&amp;lt; ）的每一个操作数。注意移位运算并不会使两边的操作数提升到相同类型，如 A &amp;lt;&amp;lt; B 中若B为long类型，A并不会被提升到long。&lt;/p&gt;
&lt;p&gt;是不是很难理解？&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/b6f2d1c6186f475fa5515b61d9b38a53&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那就举个例子吧&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/ba890ddccb0d41528244f047a0b4ae8e&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b = 2&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[b]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dimension expression promotion&lt;/span&gt;
 &lt;span&gt;char&lt;/span&gt; c = '\\u0001'&lt;span&gt;;
 a[c] &lt;/span&gt;= 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index expression promotion&lt;/span&gt;
 a[0] = -c; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unary - promotion&lt;/span&gt;
 System.out.println(&quot;a: &quot; + a[0] + &quot;,&quot; + a[1&lt;span&gt;]);
 b &lt;/span&gt;= -1&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = ~b; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bitwise complement promotion&lt;/span&gt;
 System.out.println(&quot;~0x&quot; +&lt;span&gt; Integer.toHexString(b)
 &lt;/span&gt;+ &quot;==0x&quot; +&lt;span&gt; Integer.toHexString(i));
 i &lt;/span&gt;= b &amp;lt;&amp;lt; 4L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; shift promotion (left operand)&lt;/span&gt;
 System.out.println(&quot;0x&quot; +&lt;span&gt; Integer.toHexString(b)
 &lt;/span&gt;+ &quot;&amp;lt;&amp;lt;4L==0x&quot; +&lt;span&gt; Integer.toHexString(i));
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
a: -1,1&lt;br/&gt;~0xffffffff==0x0&lt;br/&gt;0xffffffff&amp;lt;&amp;lt;4L==0xfffffff0
&lt;/pre&gt;
&lt;p&gt;二元数字提升&lt;/p&gt;
&lt;p&gt;当二元运算符的操作数皆可转化为数字类型时，那么将采用如下二元数值提升规则：&lt;/p&gt;
&lt;p&gt;如果任一操作数为引用类型，那么对其进行自动拆箱。&lt;/p&gt;
&lt;p&gt;拓宽类型转换被应用于以下情况：&lt;/p&gt;
&lt;p&gt;if 某一操作数为double类型，那么另一个也转为double&lt;/p&gt;
&lt;p&gt;else if 某一操作数为float类型，那么另一个也转为float&lt;/p&gt;
&lt;p&gt;else if 某一操作数为long类型，那么另一个也转为long&lt;/p&gt;
&lt;p&gt;else 两个操作数都转为int&lt;/p&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;乘除法运算符： * 、 / 、%&lt;/li&gt;
&lt;li&gt;针对数字类型的加减运算符： + 、 -&lt;/li&gt;
&lt;li&gt;数值比较运算符：&amp;lt; 、&amp;lt;= 、&amp;gt; 、&amp;gt;=&lt;/li&gt;
&lt;li&gt;数值相等比较运算符： == 、 !=&lt;/li&gt;
&lt;li&gt;整数按位运算符： &amp;amp; 、^ 、|&lt;/li&gt;
&lt;li&gt;某些情况下的条件运算符 ? : 中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来个例子吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f = 1.0f&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d = 2.0&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First int*float is promoted to float*float, then
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; float==double is promoted to double==double:&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; (i * f == d) System.out.println(&quot;oops&quot;&lt;span&gt;);
        
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A char&amp;amp;byte is promoted to int&amp;amp;int:&lt;/span&gt;
 &lt;span&gt;byte&lt;/span&gt; b = 0x1f&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c = 'G'&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; control = c &amp;amp;&lt;span&gt; b;
 System.out.println(Integer.toHexString(control));
        
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Here int:float is promoted to float:float:&lt;/span&gt;
 f = (b==0) ? i : 4.0f&lt;span&gt;;
 System.out.println(&lt;/span&gt;1.0/&lt;span&gt;f);
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实上面的都是冰山一角罢了&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/54d7196af48c4b57be85af8c77c29613&quot; alt=&quot;小白的消费为何被迫升级-java数据类型的Promotion&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;更多信息可以查看jls Chapter 5. Conversions and Contexts&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;【1】https://docs.oracle.com/javase/specs/jls/se12/html/jls-5.html#jls-5.1.2&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 23:03:00 +0000</pubDate>
<dc:creator>一天不进步，就是退步</dc:creator>
<og:description>背景 小白最近有点烦恼，原因也很简单，不知道为何？小白的消费不知不觉被迫升级了，请看费用清单： 本来小白预期输出结果： life is Happy! 但是什么都没有输出，这是怎么回事呢？是不是以后的幸</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/davidwang456/p/11515979.html</dc:identifier>
</item>
<item>
<title>ReentrantLock分析 - pinezhang</title>
<link>http://www.cnblogs.com/ilovena/p/11515953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilovena/p/11515953.html</guid>
<description>&lt;p&gt;主要分析下ReentrantLock锁的占用和释放过程。&lt;/p&gt;
&lt;h2 id=&quot;一.几个核心变量&quot;&gt;一.几个核心变量&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AbstractOwnableSynchronizer{
     /**
     * 表示当前占有独占锁的线程，为null时说明锁未被占用
     */
    private transient Thread exclusiveOwnerThread;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AbstractQueuedSynchronizer extend AbstractOwnableSynchronizer{
    private transient volatile Node head;//队列首节点
    private transient volatile Node tail;//队列尾节点
    private volatile int state;//同步状态，表示锁是否被占用。可重入锁，占用锁时继续获取锁，state=2
}

/**
 * waitStatus:
 *1:线程取消等待
 *-1：后继节点的线程处于等待状态，需要当前结点唤醒
 *-2：等待condition,condition.signale()唤醒，该线程会加入到队列中等待获取锁
 *-3：下一次共享式同步状态获取将会被无条件地传播下去？？没看懂
 */
static final class Node {
    volatile int waitStatus;//当前线程的等待状态。状态被一个线程修改后，立即对其他线程可见
    volatile Node prev;//前置节点
    volatile Node next;//后置节点
    volatile Thread thread;//节点所属线程
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractQueuedSynchronizer同步控制核心类，核心变量为state，state=0表示当前锁被占用，state!=0表示锁被占用，exclusiveOwnerThread变量表示当前占用锁的线程，若为null，表示锁未被占用。&lt;/p&gt;
&lt;h2 id=&quot;二.线程获取锁的流程&quot;&gt;二.线程获取锁的流程&lt;/h2&gt;
&lt;p&gt;1.尝试获取锁，若获取失败，则添加到待占用锁队列，中断当前线程等待占有锁后继续运行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.获取失败的锁加入等待队列，第一个节点Node0为头节点，第二个节点Node1才是链表第一个个数据节点，存储有效数据信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756124/201909/756124-20190913030529409-1339760961.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        Node pred = tail;
        //尾节点存在，即队列不为空。新节点作为新的尾节点
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

    //死循环添加节点，返回node的前置节点
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            //尾节点不存在，初始化。设置一个前置节点node0，即为头节点也是尾节点
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                //尾节点存在，即链表有效，将新node添加到尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.死循环获取锁。死循环，只有前置节点为头节点的链表节点，即链表的第一个数据节点尝试获取锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756124/201909/756124-20190913030614142-635955477.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            //前置结点为头结点，即node为第一个，设置当前节点为头节点
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                //将当前节点设置为头结点，移除之前的头节点
                setHead(node);
                p.next = null; // help GC。。p节点断开和链表的连接
                failed = false;
                return interrupted;
            }
            //前置节点非首节点，则当前线程中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())//阻塞线程并判断线程是否中断
                interrupted = true;
        }
    } finally {
        if (failed)
        cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.获取锁的具体流程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        //当前锁未被占用，且当前线程是队列中头元素Node1,如果是的话，则获取该锁，设置锁的状态，并设置锁的拥有者为当前线程
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        //若当前线程占有锁，锁可重入，state+1.
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &amp;lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.释放锁的流程&quot;&gt;三.释放锁的流程&lt;/h2&gt;
&lt;p&gt;1.尝试释放锁，锁释放成功，则唤醒下一个节点&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        //若锁释放成功，则唤醒当前结点的后继结点
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.如何释放锁&lt;/p&gt;
&lt;p&gt;每次释放state-1，并更新线程state值，直到state减到0，该线程释放锁成功。并将exclusiveOwnerThread字段置为null，表示当前未有线程占有锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final boolean tryRelease(int releases) {
    //获取当前的state值，state-1
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.如何唤醒下一个结点&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void unparkSuccessor(Node node) {
    //当前结点的等待状态为置为0,Node1
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    //从尾结点向前查找第一个waitStatus小于0的Node，Node2
    Node s = node.next;
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    //唤醒结点
    if (s != null)
        LockSupport.unpark(s.thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四.公平锁和非公平锁&quot;&gt;四.公平锁和非公平锁&lt;/h2&gt;
&lt;p&gt;ReentrantLock有可以作为公平锁和非公平锁。默认非公平锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公平ReentrantLock锁获取锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void lock() {
    acquire(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非公平ReentrantLock锁获取锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二者的区别就是非公平锁获取锁的时候首先判断锁是否被占用，若没有被占用，直接占有锁，否则加入等待队列。&lt;/p&gt;
&lt;p&gt;公平锁获取锁的时候的直接加入等待队列。等待队列的线程满足FIFO的条件，即先进入队列的线程会先获取锁。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 19:03:00 +0000</pubDate>
<dc:creator>pinezhang</dc:creator>
<og:description>主要分析下ReentrantLock锁的占用和释放过程。 一.几个核心变量 AbstractQueuedSynchronizer同步控制核心类，核心变量为state，state=0表示当前锁被占用，s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ilovena/p/11515953.html</dc:identifier>
</item>
<item>
<title>又一家数据公司被查，爬虫到底做错了什么？ - zkqiang</title>
<link>http://www.cnblogs.com/zkqiang/p/11515941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkqiang/p/11515941.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;9 月 6 日下午，多位业内人士称，杭州知名大数据服务公司杭州魔蝎数据科技有限公司，疑似被相关执法人员控制，其中一位周姓核心高管人员被警方带走。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是前几天技术圈传播的一则新闻，又一家数据公司被调查，很多数据从业者、爬虫开发者发出了“感叹” —— 「爬虫用得好，XX进得早；数据玩得溜，XX吃个够」。&lt;/p&gt;
&lt;p&gt;魔蝎科技作为一家数据服务公司，曾在 2017 年一篇『爬虫凶猛：爬支付宝、爬微信、窃取现金贷放贷数据』的文章中，被指出存在开发使用恶意爬虫的行为。&lt;/p&gt;
&lt;p&gt;当然关于魔蝎科技为什么被查，这个等待执法部门的调查结果即可，咱们不在这里无端猜测。&lt;/p&gt;
&lt;p&gt;我今天要说的是关于爬虫的合法性，我希望通过一些案例来探讨：怎样做一个不触碰红线的爬虫开发者。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://static.zkqiang.cn/images/20190907184257.jpg-slim&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫作为一种计算机技术，具有技术中立性，爬虫技术在法律上从来没有被禁止。爬虫的发展历史可以追溯到 20 年前，搜索引擎、聚合导航、数据分析、人工智能等业务，都需要基于爬虫技术。&lt;/p&gt;
&lt;p&gt;但是爬虫作为获取数据的技术手段之一，由于部分数据存在敏感性，如果不能甄别哪些数据是可以爬取，哪些会触及红线，可能下一位上新闻的主角就是你。&lt;/p&gt;
&lt;p&gt;如何界定爬虫的合法性，目前没有明文规定，但我通过翻阅大量文章、事件、分享、司法案例，我总结出界定的三个关键点：&lt;strong&gt;采集途径&lt;/strong&gt;、&lt;strong&gt;采集行为&lt;/strong&gt;、&lt;strong&gt;使用目的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;数据的采集途径&quot;&gt;数据的采集途径&lt;/h2&gt;
&lt;p&gt;通过什么途径爬取数据，这个是最需要重视的一点。总体来说，&lt;strong&gt;未公开、未经许可、且带有敏感信息&lt;/strong&gt;的数据，不管是通过什么渠道获得，都是一种不合法的行为。&lt;/p&gt;
&lt;p&gt;所以在采集这类比较敏感的数据时，最好先查询下相关法律法规，特别是用户个人信息、其他商业平台的信息 等这类信息，寻找一条合适的途径。&lt;/p&gt;
&lt;h3 id=&quot;个人数据&quot;&gt;个人数据&lt;/h3&gt;
&lt;p&gt;采集和分析个人信息数据，应该是当下所有互联网都会做的一件事，但是大部分个人数据都是非公开的，想获得必须通过合法途径，可参见『网络安全法』第四十一条：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是必须在&lt;strong&gt;提前告知收集的方式、范围、目的，并经过用户授权或同意后&lt;/strong&gt;，才能采集使用，也就是我们常见的各种网站与 App 的用户协议中关于信息收集的部分。&lt;/p&gt;
&lt;p&gt;相关反面案例：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;8月20日，澎湃新闻从绍兴市越城区公安分局获悉，该局日前侦破一起特大流量劫持案，涉案的新三板挂牌公司北京瑞智华胜科技股份有限公司，涉嫌非法窃取用户个人信息30亿条，涉及百度、腾讯、阿里、京东等全国96家互联网公司产品，目前警方已从该公司及其关联公司抓获6名犯罪嫌疑人。&lt;br/&gt;......&lt;br/&gt;北京瑞智华胜公司及其关联公司在与正规运营商合作中，会加入一些非法软件用于清洗流量、获取用户的 cookie。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;节选自 &lt;a href=&quot;https://www.thepaper.cn/newsDetail_forward_2362227&quot; title=&quot;新三板挂牌公司涉窃取30亿条个人信息&quot;&gt;澎湃新闻：『新三板挂牌公司涉窃取30亿条个人信息，非法牟利超千万元』&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;公开数据&quot;&gt;公开数据&lt;/h3&gt;
&lt;p&gt;从合法公开渠道，并且不明显违背个人信息主体意愿，都没有什么问题。但如果通过&lt;strong&gt;破解&lt;/strong&gt;、&lt;strong&gt;侵入&lt;/strong&gt;等“黑客”手段来获取数据，那有相关法律等着你。&lt;/p&gt;
&lt;p&gt;『刑法』第二百八十五条第二款：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;违反-robots-协议&quot;&gt;违反 Robots 协议&lt;/h3&gt;
&lt;p&gt;虽然 Robots 协议没有法规强制遵守，但 Robots 协议作为行业约定，在遵循之下会给你带来合法支持。&lt;/p&gt;
&lt;p&gt;因为 Robots 协议具有指导意义，如果注明 Disallow 就说明是平台明显要保护的页面数据，想爬取之前应该仔细考虑一下。&lt;/p&gt;
&lt;h2 id=&quot;数据的采集行为&quot;&gt;数据的采集行为&lt;/h2&gt;
&lt;p&gt;使用技术手段应该懂得克制，一些容易对服务器和业务造成干扰甚至破坏的行为，应当充分衡量其承受能力，毕竟不是每家都是 BAT 级。&lt;/p&gt;
&lt;h3 id=&quot;高并发压力&quot;&gt;高并发压力&lt;/h3&gt;
&lt;p&gt;做技术经常专注于优化，爬虫开发也是如此，想尽各种办法增加并发数、请求效率，但高并发带来的近乎 DDOS 的请求，如果对对方服务器造成压力，影响了对方正常业务，那就应该警惕了。&lt;/p&gt;
&lt;p&gt;如果一旦导致严重后果，后果参见『刑法』第二百八十六条：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，构成犯罪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以请爬取的时候，即使没有反爬限制，也不要肆无忌惮地开启高并发，掂量一下对方服务器的实力。&lt;/p&gt;
&lt;h3 id=&quot;影响正常业务&quot;&gt;影响正常业务&lt;/h3&gt;
&lt;p&gt;除了高并发请求，还有一些影响业务的情况，常见的比如抢单，会影响正常用户的体验。&lt;/p&gt;
&lt;h2 id=&quot;数据的使用目的&quot;&gt;数据的使用目的&lt;/h2&gt;
&lt;p&gt;数据使用目的同样是一大关键，就算你通过合法途径采集的数据，如果对数据没有正确的使用，同样会存在不合法的行为。&lt;/p&gt;
&lt;h3 id=&quot;超出约定的使用&quot;&gt;超出约定的使用&lt;/h3&gt;
&lt;p&gt;一种情况是公开收集的数据，但没有遵循之前告知的使用目的，比如用户协议上说只是分析用户行为，帮助提高产品体验，结果变成了出售用户画像数据。&lt;/p&gt;
&lt;p&gt;还有一种情况，是有知识产权、著作权的作品，可能会允许你下载或引用，但明显标注了使用范围，比如不能转载、不能用于商业行为等，更不能去盗用，这些都是有法律明文保护，所以要注意使用。&lt;/p&gt;
&lt;p&gt;其他情况就不列举了。&lt;/p&gt;
&lt;h3 id=&quot;出售个人信息&quot;&gt;出售个人信息&lt;/h3&gt;
&lt;p&gt;关于出售个人信息，千万不要做，是法律特别指出禁止的，参见：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;根据《最高人民法院 最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》第五条规定，对“情节严重”的解释：&lt;br/&gt;（1）非法获取、出售或者提供行踪轨迹信息、通信内容、征信信息、财产信息五十条以上的；&lt;br/&gt;（2）非法获取、出售或者提供住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息五百条以上的；&lt;br/&gt;（3）非法获取、出售或者提供第三项、第四项规定以外的公民个人信息五千条以上的便构成“侵犯公民个人信息罪”所要求的“情节严重”。&lt;br/&gt;此外，未经被收集者同意，即使是将合法收集的公民个人信息向他人提供的，也属于刑法第二百五十三条之一规定的“提供公民个人信息”，可能构成犯罪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;不正当商业行为&quot;&gt;不正当商业行为&lt;/h3&gt;
&lt;p&gt;如果将竞品公司的数据，作为自己公司的商业目的，这就可能存在构成不正当商业竞争，或者是违反知识产权保护。&lt;/p&gt;
&lt;p&gt;这种情况在目前涉及爬虫的商业诉讼案中比较常见，两年前比较知名的案件，“车来了” App 抓取其竞品 “酷米客” 的公交车数据，并展示在自己的产品上：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;虽然公交车作为公共交通工具，其实时运行路线、运行时间等信息仅系客观事实，但当此类信息经过人工收集、分析、编辑、整合并配合GPS精确定位，作为公交信息查询软件的后台数据后，此类信息便具有了实用性并能够为权利人带来现实或潜在、当下或将来的经济利益，已经具备无形财产的属性。元光公司利用网络爬虫技术大量获取并且无偿使用谷米公司“酷米客”软件的实时公交信息数据的行为，实为一种“不劳而获”、“食人而肥”的行为，构成不正当竞争。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;节选自『深圳市中级人民法院（2017）粤03民初822号民事判决书』&lt;/p&gt;
&lt;h2 id=&quot;爬虫法即将出台&quot;&gt;「爬虫法」即将出台&lt;/h2&gt;
&lt;p&gt;好消息是，相关办法已经在路上了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;5 月 28 日零点，国家互联网信息办公室发布了《数据安全管理办法》征求意见稿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我也查阅了这份意见稿，里面对数据的获取、存储、传输、使用等都做了一些规定，包括关于爬虫行为的若干规定（还在征求阶段，因此后续可能会有变化）。&lt;/p&gt;
&lt;p&gt;比如，第二章第十六条：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;网络运营者采取自动化手段访问收集网站数据，不得妨碍网站正常运行；此类行为严重影响网站运行，如自动化访问收集流量超过网站日均流量三分之一，网站要求停止自动化访问收集时，应当停止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第三章第二十七条：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;网络运营者向他人提供个人信息前，应当评估可能带来的安全风险，并征得个人信息主体同意。下列情况除外：&lt;br/&gt;（一）从合法公开渠道收集且不明显违背个人信息主体意愿；&lt;br/&gt;（二）个人信息主体主动公开；&lt;br/&gt;（三）经过匿名化处理；&lt;br/&gt;（四）执法机关依法履行职责所必需；&lt;br/&gt;（五）维护国家安全、社会公共利益、个人信息主体生命安全所必需。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;节选自&lt;a href=&quot;http://www.moj.gov.cn/news/content/2019-05/28/zlk_235861.html&quot; title=&quot;数据安全管理办法（征求意见稿）&quot;&gt;『数据安全管理办法（征求意见稿）』&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;关于爬虫合法性的研究就到这，有很多案例和角度由于篇幅没有提到，也有一些观点结论可能存在错误。&lt;/p&gt;
&lt;p&gt;但希望能给各位爬虫开发者，也包括其他开发者一些启示：技术虽中立，使用有善恶，一定要合理合规、严格谨慎地使用技术。&lt;/p&gt;
&lt;p&gt;本文属于原创内容，首发于微信公众号「&lt;strong&gt;面向人生编程&lt;/strong&gt;」，如需转载请在公众号后台留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627229/201909/1627229-20190905233933463-849327926.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注后回复以下信息获取更多资源&lt;br/&gt;回复【资料】获取 Python / Java 等学习资源&lt;br/&gt;回复【插件】获取爬虫常用的 Chrome 插件&lt;br/&gt;回复【知乎】获取最新知乎模拟登录&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 18:07:00 +0000</pubDate>
<dc:creator>zkqiang</dc:creator>
<og:description>如何界定爬虫的合法性，我通过翻阅大量文章、事件、分享、司法案例，总结出界定的三个关键点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zkqiang/p/11515941.html</dc:identifier>
</item>
<item>
<title>Python连载37-多进程、进程子类、进程父子id - 心悦君兮君不知-睿</title>
<link>http://www.cnblogs.com/ruigege0000/p/11515703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruigege0000/p/11515703.html</guid>
<description>&lt;p&gt;一、线程替代方案&lt;/p&gt;
&lt;p&gt;1.subprocess&lt;/p&gt;
&lt;p&gt;（1）完全跳过线程，使用进程&lt;/p&gt;
&lt;p&gt;（2）是派生进程的主要替代方案&lt;/p&gt;
&lt;p&gt;（3）python2.4后引入&lt;/p&gt;
&lt;p&gt;2.multiprocessing&lt;/p&gt;
&lt;p&gt;（1）使用threading接口派生，使用子进程&lt;/p&gt;
&lt;p&gt;（2）允许为多核或者多CPU派生进程，接口很threading非常相似&lt;/p&gt;
&lt;p&gt;（3）python2.6&lt;/p&gt;
&lt;p&gt;3.concurrent.futures&lt;/p&gt;
&lt;p&gt;（1）新的异步执行模块&lt;/p&gt;
&lt;p&gt;（2）人物级别的操作&lt;/p&gt;
&lt;p&gt;（3）python3.2之后引入&lt;/p&gt;
&lt;p&gt;4.多进程&lt;/p&gt;
&lt;p&gt;（1）进程间通讯（InterprocessCommunication,IPC）&lt;/p&gt;
&lt;p&gt;（2）进程之间无任何共享状态&lt;/p&gt;
&lt;p&gt;（3）进程的创建&lt;/p&gt;
&lt;p&gt;i.直接生成Process实例对象，举例&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; multiprocessing

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep,ctime

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; clock(interval):

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The time is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; ctime())

        sleep(interval)

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:

    p &lt;/span&gt;= multiprocessing.Process(target= clock,args=(2&lt;span&gt;,))

    p.start()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从运行就可以看出来主进程已经结束了，但是子线程仍然在运行着&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;和我们之前讲的线程，有一个最大区别就是线程在主进程里面，主进程结束了，子线程就结束了&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;子线程从属于进程，子进程与进程之间是并列关系&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里的程序停止，是我手动停止的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201909/1707435-20190913002723881-1462768011.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ii.派生子类&lt;/p&gt;

&lt;p&gt;举例：重写子类，和我们之前讲的线程的差不多，这里民重写了最重要的两个函数，一个是初始化子类，继承父类的初始化，第二个就是运行函数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClockProcess(multiprocessing.Process):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,interval):

        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()

        self.interval &lt;/span&gt;=&lt;span&gt; interval

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:

            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The time is {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(ctime()))

            sleep(self.interval)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:

    p2 &lt;/span&gt;= ClockProcess(2&lt;span&gt;)

    p2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201909/1707435-20190913002803140-553598335.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iii.在os中查看pid,ppid以及他们的关系&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; info(title):

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(title)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;module name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到父进程的id&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent process:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,os.getppid())

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到本身进程的id&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;process id:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,os.getpid())

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(name):

    info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:

    info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;==================================&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    p &lt;/span&gt;= multiprocessing.Process(target=f,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))

    p.start()

    p.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释：先调用了一个函数，然后又调用了一个嵌套函数的函数  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201909/1707435-20190913002823855-1537501605.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、源码&lt;/p&gt;
&lt;p&gt;d26_1_multiprocess_exercise.py&lt;/p&gt;
&lt;p&gt;https://github.com/ruigege66/Python_learning/blob/master/d26_1_multiprocess_exercise.py&lt;/p&gt;
&lt;p&gt;2.CSDN：https://blog.csdn.net/weixin_44630050（心悦君兮君不知-睿）&lt;/p&gt;
&lt;p&gt;3.博客园：https://www.cnblogs.com/ruigege0000/&lt;/p&gt;
&lt;p&gt;4.欢迎关注微信公众号：傅里叶变换，个人公众号，仅用于学习交流，后台回复”礼包“，获取大数据学习资料&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201909/1707435-20190913002901403-1752292708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 16:29:00 +0000</pubDate>
<dc:creator>心悦君兮君不知-睿</dc:creator>
<og:description>一、线程替代方案 1.subprocess （1）完全跳过线程，使用进程 （2）是派生进程的主要替代方案 （3）python2.4后引入 2.multiprocessing （1）使用threadin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruigege0000/p/11515703.html</dc:identifier>
</item>
<item>
<title>纯JS实现在一个字符串b中查找另一个字符串a出现的所有位置，并且不使用字符串的方法（递归） - TZ张无忌</title>
<link>http://www.cnblogs.com/zhaohongcheng/p/11515659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaohongcheng/p/11515659.html</guid>
<description>
&lt;p&gt;　　&lt;span&gt;有小伙伴在面试遇到了这个问题，乍一看如果使用使用字符串方法indexof，substring，很简单容易实现，但如果不使用这些方法，怎么样才能实现这个需求呢&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;　&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;// 思路: 如果不能使用字符串的相应方法，我们可以把字符串转换成数组，使用递归函数不断去比对相应的数组索引，然后把满足条件的索引打印出来，其实很多现在前后端交互处理数据的方法，用的都是递归偏多，千万别小瞧递归！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;话不多说，我们先上解决问题的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实很多现在前后端交互处理数据的方法，用的都是递归变多，千万别小瞧递归&lt;/span&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思路: 不能使用字符串的相应方法，我们可以把字符串转换成数组，首先使用递归不断去比对相应的数组索引&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机的字符&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str1 = 'adfacddtgjacbasaclsaacdctacw'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件筛选的字符&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str2 = 'basaclsa'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把相应的字符串转换为数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; arr1 = str1.split(''&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr2 = str2.split(''&lt;span&gt;);
     
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test (arr) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写一个for循环，先把需要筛选的数组arr2第一个索引拿来比对&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; arr1.length; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果符合，执行下一层&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(arr[0] ===&lt;span&gt; arr1[i]){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进入到这里说明了: arr2的第一份索引的字符，和arr1的索引的字符相同相同&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 既然第一个索引相同，我们这里就声明一个变量num，让变量num依据arr2的长度去递增&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; num = 0
                &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ccc (arr) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个索引相同，让他们索引分别加上变量num，去比对他们索引后面的位置是否相同，如果满足条件继续让num递增&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直到递增变量num的值等于arr1的长度为止，这时候说明这段索引和arr1完全相同&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (arr[num] === arr1[i+&lt;span&gt;num]) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num === arr.length-1&lt;span&gt;) {
                            console.log( &lt;/span&gt;'符合条件的索引是'&lt;span&gt;, i)
                        }
                        num&lt;/span&gt;++
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(num)&lt;/span&gt;
&lt;span&gt;                        ccc (arr)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不能满足条件，就让该递归跳出&lt;/span&gt;
                    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
                    }
                }
                ccc(arr2)
            }
        }
    }
    test(str2)
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　其实一说起递归，我想每个人都不陌生。举个从小就听过的例子：从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山，山里有座庙，庙里有个和尚，和尚在讲故事，从前有座山...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实递归，就是在运行的过程中调用自己。程序调用自身的编程技巧称为递归（ recursion）。递归做为一种&lt;a href=&quot;https://baike.baidu.com/item/%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;在&lt;a href=&quot;https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80&quot; target=&quot;_blank&quot;&gt;程序设计语言&lt;/a&gt;中广泛应用。 一个过程或&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%BD%E6%95%B0&quot; target=&quot;_blank&quot;&gt;函数&lt;/a&gt;在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/12/5b6fac208b0ad.jpg&quot; alt=&quot;&quot; width=&quot;232&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实际上这张图就很形象地表达出了递归。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;好了，递归的知识差不多介绍完了。对了!简单来说，循环是有去无回，而递归则是有去有回(因为存在终止条件)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 16:00:00 +0000</pubDate>
<dc:creator>TZ张无忌</dc:creator>
<og:description>问题：判断字符串A在中所有出现字符串B中（长度大于1）的索引。不得使用字符串方法indexof，substring等 有小伙伴在面试遇到了这个问题，乍一看如果使用使用字符串方法indexof，subs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaohongcheng/p/11515659.html</dc:identifier>
</item>
<item>
<title>使用图灵机器人api搭建微信聊天机器人php实现 - 指间人生</title>
<link>http://www.cnblogs.com/gracexu/p/11515622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gracexu/p/11515622.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;之前通过hook技术实现了微信pc端发送消息功能，如果在结合图灵机器人就能实现微信聊天机器人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码下载：http://blog.yshizi.cn/131.html&lt;/p&gt;
&lt;p&gt;逻辑如下：&lt;br/&gt;&lt;img src=&quot;http://image.yshizi.cn/blog/typecho/%E6%8D%95%E8%8E%B7.jpg&quot; alt=&quot;捕获.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我简单介绍一下步骤。&lt;/p&gt;
&lt;ol readability=&quot;21.728740936058&quot;&gt;&lt;li&gt;首先，你需要下载我的微信助手，下载地址请参考我的博客文章：&lt;br/&gt;&lt;a href=&quot;http://blog.yshizi.cn/104.html&quot;&gt;通过对微信pc hook实现微信助手&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;申请图灵机器人，并认证。&lt;a href=&quot;http://www.turingapi.com/&quot;&gt;申请地址&lt;/a&gt;，使用api接入并获取apikey（详细请参考图灵机器人官网） 。&lt;/li&gt;
&lt;li readability=&quot;48&quot;&gt;
&lt;p&gt;使用php实现访问图灵机器人api。&lt;br/&gt;php实现代码如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br/&gt;class Tuling123&lt;br/&gt;{&lt;br/&gt;private $apiKey;&lt;br/&gt;private $secret;&lt;br/&gt;private $text;&lt;br/&gt;private $userId = 1;&lt;br/&gt;private $selfInfo = '';&lt;/p&gt;
&lt;p&gt;public function __construct($apiKey, $userId, $selfInfo){&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$this-&amp;gt;apikey = $apiKey;
$this-&amp;gt;secret = $secret;
$this-&amp;gt;userId = $userId;
$this-&amp;gt;selfInfo = $selfInfo;        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public function tuling($text, $raw = false){&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$this-&amp;gt;text = $text;    

$param = [
    'perception' =&amp;gt; [
        'inputText' =&amp;gt; [
            'text' =&amp;gt; $this-&amp;gt;text,
        ],
        'selfInfo' =&amp;gt; $this-&amp;gt;selfInfo
    ],
    'userInfo' =&amp;gt; [
        'apiKey' =&amp;gt; $this-&amp;gt;apikey,
        'userId' =&amp;gt; $this-&amp;gt;userId,
    ]
];


$result = json_decode('['.$this-&amp;gt;post('http://openapi.tuling123.com/openapi/api/v2',json_encode($param)).']',true);

return $raw ? $result : $result[0]['results'][0]['values']['text'];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;private function post($url,$data){&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$curl = curl_init();
curl_setopt($curl, CURLOPT_POST, 1);
curl_setopt($curl, CURLOPT_HEADER, 0);
curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_TIMEOUT, 500);
curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);
curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2);
curl_setopt($curl, CURLOPT_URL, $url);
$result = curl_exec($curl);
curl_close($curl);

return $result;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;?&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;TuLing.php&lt;br/&gt;这段代码主要是封装图灵机器人api&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php 

require __DIR__.'/TuLing.php';

/**
 * 获取 post 参数; 在 content_type 为 application/json 时，自动解析 json
 * @return array
 */
function initPostData()
{
    if (empty($_POST)) {
        $content = file_get_contents('php://input');
        $post    = (array)json_decode($content, true);
    } else {
        $post = $_POST;
    }
    return $post;
}

$selfInfo = [
    'location' =&amp;gt; [
    'city' =&amp;gt; '广州'
    ]
];

header('Content-Type:application/json'); 

$post = initPostData();

$userid=$post['wxid'];

$content=$post['content'];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;//str_replace(&quot;&lt;em&gt;&quot;,&quot;&quot;,&quot;$userid&quot;) 将去除&quot;&lt;/em&gt;&quot;的微信id作为图灵机器人的用户id,因为图灵机器人用户id不能含&quot;&lt;em&gt;&quot;&lt;br/&gt;$data = new Tuling123('您的图灵机器人apikey',str_replace(&quot;&lt;/em&gt;&quot;,&quot;&quot;,&quot;$userid&quot;),$selfInfo);&lt;br/&gt;$result = $data-&amp;gt;tuling($content);&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$json['wxid'] = $userid;    

$json['content'] = $result;    

echo json_encode($json,JSON_UNESCAPED_UNICODE);

?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wechatrobot.php&lt;/p&gt;
&lt;p&gt;之前将这两个文件发布服务器。发布之后的wechatrobot.php文件访问地址即使微信助手接口地址。&lt;br/&gt;如我的发布后地址是：http://blog.yshizi.cn/wechatrobot.php&lt;br/&gt;微信助手配置如下：&lt;br/&gt;&lt;img src=&quot;http://image.yshizi.cn/blog/typecho/122.JPG&quot; alt=&quot;122.JPG&quot;/&gt;&lt;br/&gt;然后就可撩机器人。&lt;br/&gt;&lt;img src=&quot;http://image.yshizi.cn/blog/typecho/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190912173652.jpg&quot; alt=&quot;微信图片_20190912173652.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 15:41:00 +0000</pubDate>
<dc:creator>指间人生</dc:creator>
<og:description>之前通过hook技术实现了微信pc端发送消息功能，如果在结合图灵机器人就能实现微信聊天机器人。 代码下载：http://blog.yshizi.cn/131.html 逻辑如下： ![捕获.jpg][</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gracexu/p/11515622.html</dc:identifier>
</item>
<item>
<title>vim 高级功能 - pzqu</title>
<link>http://www.cnblogs.com/pzqu/p/11515625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pzqu/p/11515625.html</guid>
<description>&lt;p&gt;本文章原创首发于公众号：编程三分钟 ，文末二维码。&lt;/p&gt;
&lt;p&gt;文本编辑、跳转、删除、复制、替换这些操作用vim确实是快；但是好像仅仅是这样根本不能说服我&lt;code&gt;vim&lt;/code&gt;超过鼠标的地方。&lt;/p&gt;
&lt;p&gt;花点时间弄熟这些，除了炫技意外，主要为了防止深夜被拉起来救火，机房还不能远程，连夜打车到了地方，却发现服务器没有图形化界面，这个时候要是脚本写的熟，&lt;code&gt;vim&lt;/code&gt;操作&lt;code&gt;6&lt;/code&gt;几下修复完了，能尽量降低损失，也能睡个好觉了。&lt;/p&gt;

&lt;p&gt;常用操作在之间的文章我们已经已经掌握了，接下来就要搞一点高级操作，基本谁看见都要感叹一声“你&lt;code&gt;vim&lt;/code&gt;怎么这么6！。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同时修改多个文件、快速在文件之间切换&lt;/li&gt;
&lt;li&gt;编辑多个文档时分屏操作&lt;/li&gt;
&lt;li&gt;批量注释多行代码、修改配置、区域复制删除&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;多文件的编辑&quot;&gt;多文件的编辑&lt;/h2&gt;
&lt;p&gt;同时编辑两个文件&lt;code&gt;1.txt&lt;/code&gt;,&lt;code&gt;2.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim 1.txt 2.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看同时打开了哪些文件 &lt;code&gt;:ls&lt;/code&gt;,其中&lt;code&gt;%a&lt;/code&gt;表示正在编辑的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233756498-1245263497.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在文件之间切换 &lt;code&gt;:n&lt;/code&gt; , &lt;code&gt;:N&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233756617-500875553.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接切换到想要编辑的文件 &lt;code&gt;:b 1.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233756738-412981284.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然了我们为什么跳来跳去，因为这可以完成多个文件之间复制粘贴等组合操作。&lt;/p&gt;
&lt;h2 id=&quot;分屏&quot;&gt;分屏&lt;/h2&gt;
&lt;h3 id=&quot;创建分屏&quot;&gt;创建分屏&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;:sp 2.txt&lt;/code&gt; 打开新的水平分屏(上下)视窗来编辑&lt;code&gt;2.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:vsp 2.txt&lt;/code&gt;打开新的垂直分屏(左右)视窗来编辑&lt;code&gt;2.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233756885-2132220708.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;分屏跳转与移动分屏&quot;&gt;分屏跳转与移动分屏&lt;/h3&gt;
&lt;p&gt;我先打开了三个文件，&lt;code&gt;1.txt&lt;/code&gt; &lt;code&gt;2.txt&lt;/code&gt; &lt;code&gt;3.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233757067-35259837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我分别跳转到各个文件中，删除文件内容。&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w j&lt;/code&gt;移至下面视窗&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w k&lt;/code&gt; 移至上面视窗&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w h&lt;/code&gt; 移至左边视窗&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w l&lt;/code&gt; 移至右边视窗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233757229-883243031.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我垂直打开了三个文件，使用以下命令移动视窗,先把&lt;code&gt;文件3&lt;/code&gt;从最左边移动到最右边，再移动下最下边&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w J&lt;/code&gt;将当前视窗移至下面&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w K&lt;/code&gt; 将当前视窗移至上面&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w H&lt;/code&gt; 将当前视窗移至左边&lt;/p&gt;
&lt;p&gt;普通模式下&lt;code&gt;Ctrl+w L&lt;/code&gt; 将当前视窗移至右边&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233757374-544847218.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要位于相应视窗，&lt;code&gt;:q&lt;/code&gt; &lt;code&gt;:wq&lt;/code&gt; &lt;code&gt;q!&lt;/code&gt;退出就可以；&lt;code&gt;wqa&lt;/code&gt;或&lt;code&gt;qa!&lt;/code&gt;全部退出&lt;/p&gt;
&lt;h2 id=&quot;可视模式&quot;&gt;可视模式&lt;/h2&gt;
&lt;p&gt;可视模式分为三种，也是&lt;code&gt;vim&lt;/code&gt;的精髓。分别是行，矩形区域选择，字符段落选择。&lt;/p&gt;
&lt;p&gt;和鼠标选择类似，进入可视模式加定位符号就可以快速跳转到想选择的范围，选中以后再进行复制，删除等操作。&lt;/p&gt;
&lt;h3 id=&quot;行选择&quot;&gt;行选择&lt;/h3&gt;
&lt;p&gt;行选择 &lt;code&gt;Shift+v（小写）&lt;/code&gt; , 整行选取，可以上下移动光标选更多的行，再按一次 &lt;code&gt;Shift+v&lt;/code&gt; 就可以取消选取。&lt;/p&gt;
&lt;p&gt;如下，进入行选择模式，输入&lt;code&gt;4G&lt;/code&gt;，跳转到第四行，&lt;code&gt;d&lt;/code&gt;删除所选区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233757520-533261727.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;矩形区域选择&quot;&gt;矩形区域选择&lt;/h3&gt;
&lt;p&gt;矩形区域选择&lt;code&gt;Ctrl+v（小写）&lt;/code&gt;，按区域选取，可以上下左右移动光标选更多的区域，再按一次 &lt;code&gt;Ctrl+v&lt;/code&gt;就可以取消选取。&lt;/p&gt;
&lt;p&gt;如下:选择所有的行和第一列所在在区域，&lt;code&gt;shift+i&lt;/code&gt;进入插入模式，插入&lt;code&gt;#&lt;/code&gt;，双击两次&lt;code&gt;esc&lt;/code&gt;，批量注释。然后重复选择动作，输入&lt;code&gt;x&lt;/code&gt;删除所选区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233757902-2348692.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符选择段落选择&quot;&gt;字符选择(段落选择)&lt;/h3&gt;
&lt;p&gt;字符选择 &lt;code&gt;v（小写）&lt;/code&gt;，可以移动光标，光标走过的地方就会选取。再次按下&lt;code&gt;v&lt;/code&gt;后就会取消选取。&lt;/p&gt;
&lt;p&gt;如下：&lt;code&gt;v$&lt;/code&gt;选中&lt;code&gt;192.168.1.2&lt;/code&gt;退一格为了不选中换行符，到第一行粘贴&lt;code&gt;ip&lt;/code&gt;再选中不需要的ip删除掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233758040-558030391.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可视化模式和定位符结合使用效果最佳！&lt;/p&gt;

&lt;p&gt;同时编辑多个文件： &lt;code&gt;vim 1.txt 2.txt&lt;/code&gt;, 切换文件 &lt;code&gt;:n&lt;/code&gt; 、&lt;code&gt;:N&lt;/code&gt;、&lt;code&gt;:b 1.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分屏 &lt;code&gt;:sp 2.txt&lt;/code&gt;  &lt;code&gt;:vsp 2.txt&lt;/code&gt;，跳转&lt;code&gt;Ctrl+w h|j|k|l&lt;/code&gt; 移动分屏位&lt;/p&gt;
&lt;p&gt;置&lt;code&gt;Ctrl+w H|J|K|L&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可视模式 &lt;code&gt;Shift+v&lt;/code&gt;、&lt;code&gt;Ctrl+v&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;命令比较多，这里只列举最有用的，足以应对全部的场景了，记的越多速度越快！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1116902/201909/1116902-20190912233758474-46760621.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Sep 2019 15:38:00 +0000</pubDate>
<dc:creator>pzqu</dc:creator>
<og:description>本文章原创首发于公众号：编程三分钟 ，文末二维码。 文本编辑、跳转、删除、复制、替换这些操作用vim确实是快；但是好像仅仅是这样根本不能说服我 超过鼠标的地方。 花点时间弄熟这些，除了炫技意外，主要为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pzqu/p/11515625.html</dc:identifier>
</item>
</channel>
</rss>