<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>思维发散的双刃剑 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/10499043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/10499043.html</guid>
<description>&lt;p&gt;从17年开始写博客以来，反思一下自己的成长和改变。静儿一直以来都不算特别成功的一个重要原因就是思维太过发散。&lt;/p&gt;
&lt;p&gt;究其原因，还是和自己的人生观、价值观关系很大。静儿从小对物质的追求比较少，所以做事情的时候没有很强的动机和目的性。通常做一件事情的思维是：我想做这件事情。而不是说为了达到一个目的，我要做一件事情。&lt;/p&gt;
&lt;p&gt;这是一把双刃剑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;利 - 舒服的环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在觉得日子过得很舒服、很踏实。家庭和睦，工作都自己想做的。能够达到目前的状态也和自己的思维习惯有关系。&lt;/p&gt;
&lt;p&gt;周围的女孩子都很优秀。有些女孩子自己优秀同时对男朋友也有很高的要求，希望他们很有上进心。&lt;/p&gt;
&lt;p&gt;静儿自己算是比较有上进心，但是对其他人并没有要求。因为静儿做什么学什么，是因为自己喜欢。老公有没有上进心和我有什么关系。虽然实际上他确实很上进。但不是外部压力大而是自驱的，这就让我们两个都很舒服。&lt;/p&gt;
&lt;p&gt;静儿在最最艰难的时候也没有放弃工作。家里两人都可以独立养活一家人。所以两个人外部的压力都是不大的。更有机会做自己喜欢的事情。世上最好的缘分无非是：我刚好坚强，你刚好善良。再要求别的就太贪心了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;利 - 以成长为快乐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静儿每天下班都很晚。人家问我，我就说：年轻嘛。心里明白的很，大我好几级的领导年纪都比我小。但是对静儿来说，好好做技术就可以啦。不是为了什么而做，做本身就是目的。&lt;/p&gt;
&lt;p&gt;正因为如此，写了十二年代码，并没有写够。人生是一场马拉松，静儿的基础不太好。拼的是耐力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弊 - 没有掌握方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思维发散，无目的性最大的弊端就是形成不了方法体系。所有的方法体系：What、Why、How。PDCA（Plan、Do、Check、Action）等等最大的公共特点就是先有一个目的。无目的，所以无方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弊 - 没有连续性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想做什么就做什么。做了一件事，再去做另一件不相关的事。长远来看是没有什么收益的。 静儿曾经花过大力气去学习世界文学史、研究生上的心理学。更不用提当年是东软的学霸，几千人一起日语考试，总是毫无悬念的第一名。&lt;/p&gt;
&lt;p&gt;什么日本东京工作经验啦、美团硅谷工作经验啦。这些对自己的本职工作一点帮助都没有的。静儿基本没有花过特别连续的时间兢兢业业的研究一件事情。所以也谈不上有什么成就。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弊 - 思维不成体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静儿写博客两年来，思维体系化和结构化上稍有些提高。这得益于在美团获得的熏陶。但是想成长再快些，还需要持续很长的打基础阶段。骨子里的东西，没有那么容易变。&lt;/p&gt;
&lt;p&gt;静儿因为不做管理，经常处于一种既感恩又愧疚的矛盾中。每当我在做方案时，表述结构有问题，是会被人指出来的。但是我的leader们就没有这么幸运。自己是拿着工资来学习的，一想到这里，非常惭愧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总是持续的成长，就会少很多外部的压力。一个很上进的人不太会为明天能否找到一个工作而焦虑。成长的各个阶段要有明确的目的和连续性。心态要发散，方法要收敛。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;     本次公众号文章共三篇&lt;a href=&quot;https://mp.weixin.qq.com/s/NDaLFWnBr359xm6djzRfRQ&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《一个请求过来都经过了什么?(Thrift版)》&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/RRFPoZgYil5xmZkjeRfNfA&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《一个请求过来都经过了什么？(2017年http版)》&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/RRFPoZgYil5xmZkjeRfNfA&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《思维发散的双刃剑》&lt;/a&gt;。首篇是最近写的，第二篇是17年写的。最后一篇是一些总结思考。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 17:35:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>从17年开始写博客以来，反思一下自己的成长和改变。静儿一直以来都不算特别成功的一个重要原因就是思维太过发散。 究其原因，还是和自己的人生观、价值观关系很大。静儿从小对物质的追求比较少，所以做事情的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/10499043.html</dc:identifier>
</item>
<item>
<title>深入理解Mybatis插件开发 - 风一样的码农</title>
<link>http://www.cnblogs.com/chenpi/p/10498921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpi/p/10498921.html</guid>
<description>&lt;p&gt;关于Mybatis插件，大部分人都知道，也都使用过，但很多时候，我们仅仅是停留在表面上，知道Mybatis插件可以在DAO层进行拦截，如打印执行的SQL语句日志，做一些权限控制，分页等功能；但对其内部实现机制，涉及的软件设计模式，编程思想往往没有深入的理解。&lt;/p&gt;
&lt;p&gt;本篇案例将帮助读者对Mybatis插件的使用场景，实现机制，以及其中涉及的编程思想进行一个小结，希望对以后的编程开发工作有所帮助。&lt;/p&gt;
&lt;p&gt;注：本案例以mybatis 3.4.7-SNAPSHOT版本为例。&lt;/p&gt;
&lt;p&gt;PS：文章是挺久之前写的，当时花了一些心思，存到电脑的word里，今天正好看到，就是里面的源码都是图片，哈哈哈，凑合着看吧。&lt;/p&gt;

&lt;h2&gt;分页功能&lt;/h2&gt;
&lt;p&gt;mybatis的分页默认是基于内存分页的（查出所有，再截取），数据量大的情况下效率较低，不过使用mybatis插件可以改变该行为，只需要拦截StatementHandler类的prepare方法，改变要执行的SQL语句为分页语句即可；&lt;/p&gt;
&lt;h2&gt;公共字段统一赋值&lt;/h2&gt;
&lt;p&gt;一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO层统一拦截处理，可以用mybatis插件拦截Executor类的update方法，对相关参数进行统一赋值即可；&lt;/p&gt;
&lt;h2&gt;性能监控&lt;/h2&gt;
&lt;p&gt;对于SQL语句执行的性能监控，可以通过拦截Executor类的update, query等方法，用日志记录每个方法执行的时间；&lt;/p&gt;
&lt;h2&gt;其它&lt;/h2&gt;
&lt;p&gt;其实mybatis扩展性还是很强的，基于插件机制，基本上可以控制SQL执行的各个阶段，如执行阶段，参数处理阶段，语法构建阶段，结果集处理阶段，具体可以根据项目业务来实现对应业务逻辑。&lt;/p&gt;

&lt;h2&gt;什么是Mybatis插件&lt;/h2&gt;
&lt;p&gt;与其称为Mybatis插件，不如叫Mybatis拦截器，更加符合其功能定位，实际上它就是一个拦截器，应用代理模式，在方法级别上进行拦截。&lt;/p&gt;
&lt;h2&gt;支持拦截的方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;执行器Executor（update、query、commit、rollback等方法）；&lt;/li&gt;
&lt;li&gt;参数处理器ParameterHandler（getParameterObject、setParameters方法）；&lt;/li&gt;
&lt;li&gt;结果集处理器ResultSetHandler（handleResultSets、handleOutputParameters等方法）；&lt;/li&gt;
&lt;li&gt;SQL语法构建器StatementHandler（prepare、parameterize、batch、update、query等方法）；&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;拦截阶段&lt;/h2&gt;
&lt;p&gt;那么这些类上的方法都是在什么阶段被拦截的呢？为理解这个问题，我们先看段简单的代码（摘自mybatis源码中的单元测试SqlSessionTest类），来了解下典型的mybatis执行流程，如下代码所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308234402360-1460039631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上代码主要完成以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取mybatis的xml配置文件信息&lt;/li&gt;
&lt;li&gt;通过SqlSessionFactoryBuilder创建SqlSessionFactory对象&lt;/li&gt;
&lt;li&gt;通过SqlSessionFactory获取SqlSession对象&lt;/li&gt;
&lt;li&gt;执行SqlSession对象的selectList方法，查询结果&lt;/li&gt;
&lt;li&gt;关闭SqlSession&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下是时序图，在整个时序图中，涉及到mybatis插件部分已标红，基本上就是体现在上文中提到的四个类上，对这些类上的方法进行拦截。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308234940881-593104961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;插件配置信息的加载&lt;/h2&gt;
&lt;p&gt;先来看下mybatis是如何加载插件配置的，对应的xml配置信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235043485-782225664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的解析代码如下，主要做以下工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据解析到的类信息创建Interceptor对象；&lt;/li&gt;
&lt;li&gt;调用setProperties方法设置属性变量；&lt;/li&gt;
&lt;li&gt;添加到Configuration的interceptorChain拦截器链中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235111153-718552251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上逻辑对应的时序图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235141828-523412616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代理对象的生成&lt;/h2&gt;
&lt;p&gt;Mybatis插件的实现机制主要是基于动态代理实现的，其中最为关键的就是代理对象的生成，所以有必要来了解下这些代理对象是如何生成的。&lt;/p&gt;
&lt;p&gt;Executor代理对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235210943-795884380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ParameterHandler代理对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235226463-1174065078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ResultSetHandler代理对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235241968-354202043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StatementHandler代理对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235254637-866824268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察源码，发现这些可拦截的类对应的对象生成都是通过InterceptorChain的pluginAll方法来创建的，进一步观察pluginAll方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235307405-545699124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历所有拦截器，调用拦截器的plugin方法生成代理对象，注意生成代理对象重新赋值给target，所以如果有多个拦截器的话，生成的代理对象会被另一个代理对象代理，从而形成一个代理链条，执行的时候，依次执行所有拦截器的拦截逻辑代码；&lt;/p&gt;
&lt;p&gt;接下来看一下我们在编写拦截器的时候，一个典型的plugin方法实现方式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235323243-1917567311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再进一步查看wrap方法，如下：&lt;/p&gt;
&lt;p&gt;典型的动态代理实现，调用的是Proxy.newProxyInstance方法来生成代理对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235358022-1651879085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上逻辑对应的时序图如下，这里我们假设声明了两个拦截器，那么在创建target代理对象的时候，最终返回的代理对象proxy2，实际上代理了proxy1，而proxy1又代理了target，：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235423753-281632051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 拦截逻辑的执行&lt;/h2&gt;
&lt;p&gt;由于真正去执行Executor、ParameterHandler、ResultSetHandler和StatementHandler类中的方法的对象是代理对象（建议将代理对象转为class文件，反编译查看其结构，帮助理解），所以在执行方法时，首先调用的是Plugin类（实现了InvocationHandler接口）的invoke方法，如下：&lt;/p&gt;
&lt;p&gt;首先根据执行方法所属类获取拦截器中声明需要拦截的方法集合；&lt;/p&gt;
&lt;p&gt;判断当前方法需不需要执行拦截逻辑，需要的话，执行拦截逻辑方法（即Interceptor接口的intercept方法实现），不需要则直接执行原方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235624434-1518384019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以关注下Interceptor接口的intercept方法实现，一般需要用户自定义实现逻辑，其中有一个重要参数，即Invocation类，通过改参数我们可以获取执行对象，执行方法，以及执行方法上的参数，从而进行各种业务逻辑实现，一般在该方法的最后一句代码都是invocation.proceed()（内部执行method.invoke方法），否则将无法执行下一个拦截器的intercept方法。&lt;/p&gt;
&lt;p&gt;以上逻辑对应的时序图如下，这里我们以执行executor对象的query方法为例，且假设有两个拦截器存在：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235725522-1032688001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里以分页插件为例，来了解下一般mybatis插件的编写规则，如下所示：&lt;/p&gt;
&lt;p&gt;主要需要实现三个方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;intercept:在此实现自己的拦截逻辑，可从Invocation参数中拿到执行方法的对象，方法，方法参数，从而实现各种业务逻辑, 如下代码所示，从invocation中获取的statementHandler对象即为被代理对象，基于该对象，我们获取到了执行的原始SQL语句，以及prepare方法上的分页参数，并更改SQL语句为新的分页语句，最后调用invocation.proceed()返回结果。&lt;/li&gt;
&lt;li&gt;plugin：生成代理对象；&lt;/li&gt;
&lt;li&gt;setProperties：设置一些属性变量；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/879896/201903/879896-20190308235810050-214786778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单的说，mybatis插件就是对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，先去执行代理对象的方法，从而执行自己编写的拦截逻辑，所以真正要用好mybatis插件，主要还是要熟悉这四个接口的方法以及这些方法上的参数的含义；&lt;/p&gt;
&lt;p&gt;另外，如果配置了多个拦截器的话，会出现层层代理的情况，即代理对象代理了另外一个代理对象，形成一个代理链条，执行的时候，也是层层执行；&lt;/p&gt;
&lt;p&gt;关于mybatis插件涉及到的设计模式和软件思想如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设计模式：代理模式、责任链模式；&lt;/li&gt;
&lt;li&gt;软件思想：AOP编程思想，降低模块间的耦合度，使业务模块更加独立；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一些注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要定义过多的插件，代理嵌套过多，执行方法的时候，比较耗性能；&lt;/li&gt;
&lt;li&gt;拦截器实现类的intercept方法里最后不要忘了执行invocation.proceed()方法，否则多个拦截器情况下，执行链条会断掉；&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 08 Mar 2019 16:02:00 +0000</pubDate>
<dc:creator>风一样的码农</dc:creator>
<og:description>背景 关于Mybatis插件，大部分人都知道，也都使用过，但很多时候，我们仅仅是停留在表面上，知道Mybatis插件可以在DAO层进行拦截，如打印执行的SQL语句日志，做一些权限控制，分页等功能；但对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenpi/p/10498921.html</dc:identifier>
</item>
<item>
<title>使用3D Slicer对图像进行配准 - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/10498919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/10498919.html</guid>
<description>&lt;p&gt;在进行深度学习之前，我们需要图像进行一些预处理操作，其中配准是很重要的一环，以下将介绍使用软件3D Slicer来进行图像配准&lt;/p&gt;
&lt;p&gt;3D Slicer是（1）一个软件平台，用以图像分析（包括配准和实时编辑），图像可视化以及图像引导治疗；（2）是一个免费、开源软件，并适用于Linux、MacOSX和windows操作系统；（3）拥有强大的可扩展性，可以通过模块嵌入方式来增加新的功能和应用。3D slicer的主要特征有：（1）适用于从头到脚的各个组织器官；（2）兼容MRI、CT、US（超声）、核医学以及显微镜下的影像；（3）拥有双向可交互性&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 3D Slicer下载&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://download.slicer.org/&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装过程不予累述，&lt;span&gt;注意&lt;/span&gt;如果有独显的话，打开该软件的时候，右击鼠标，选择用图形处理器运行，不然会使用CPU运行，会比较卡&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.fanshouji.com/html/a/1050865/49922891.html&quot;&gt;安装及加载文件教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 获取两组dicom文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 获取module -- Elastix&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;点击view，选择Extension Manager。搜索Elastix，安装SlicerElastix&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配准&quot;&gt;配准&lt;/h2&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将两组需要配准的dicom文件拉入软甲所在位置，根据提示框将两组文件都进行加载&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击搜索框，选择Elastix&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190309000015153-794165130.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在Inputs框，依次选择配准的文件，其中Fixed volume表示配准的基准，Moving volums表示待配准的文件&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190309000025195-294681164.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择配准之后输出的名字&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190309000031958-1638747416.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击Apply等待即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击data，可看见左侧中间部分显示原文件和配准结果文件，点击即可查看&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190309000042291-479623013.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保存文件，点击save即可保存，同时可以保存多种格式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190309000047706-1869976015.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 08 Mar 2019 16:01:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>使用3D Slicer对图像进行配准</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/10498919.html</dc:identifier>
</item>
<item>
<title>[译]Golang中的优雅重启 - MnCu</title>
<link>http://www.cnblogs.com/MnCu8261/p/10498849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MnCu8261/p/10498849.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文 &lt;a href=&quot;https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/&quot;&gt;Graceful Restart in Golang&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者 &lt;a href=&quot;https://grisha.org/&quot;&gt;grisha&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明：本文目的仅仅作为个人mark，所以在翻译的过程中参杂了自己的思想甚至改变了部分内容，其中有下划线的文字为译者添加。但由于译者水平有限，所写文字或者代码可能会误导读者，如发现文章有问题，请尽快告知，不胜感激。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Update (Apr 2015): &lt;a href=&quot;https://github.com/fvbock&quot;&gt;Florian von Bock&lt;/a&gt;已经根据本文实现了一个叫做&lt;a href=&quot;https://github.com/fvbock/endless&quot;&gt;endless&lt;/a&gt;的Go package&lt;/p&gt;
&lt;p&gt;大家知道，当我们用Go写的web服务器需要修改配置或者需要升级代码的时候我们需要重启服务器，如果你（像我一样）已经将优雅的重启视为理所当然，因为使用Golang你需要自己动手来做这些操作，所以你可能会发现这个方式非常方便。&lt;/p&gt;
&lt;h3 id=&quot;什么是优雅重启&quot;&gt;什么是优雅重启&lt;/h3&gt;
&lt;p&gt;本文中的优雅重启表现为两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程在不关闭其所监听的端口的情况下重启&lt;/li&gt;
&lt;li&gt;重启过程中保证所有请求能被正确的处理&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;进程在不关闭其所监听的端口的情况下重启&quot;&gt;1.进程在不关闭其所监听的端口的情况下重启&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;fork一个子进程，该子进程继承了父进程所监听的socket&lt;/li&gt;
&lt;li&gt;子进程执行初始化等操作，并最终开始接收该socket的请求&lt;/li&gt;
&lt;li&gt;父进程停止接收请求并等待当前处理的请求终止&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;fork一个子进程&quot;&gt;fork一个子进程&lt;/h5&gt;
&lt;p&gt;有不止一种方法fork一个子进程，但在这种情况下推荐&lt;a href=&quot;https://golang.org/pkg/os/exec/#Command&quot;&gt;exec.Command&lt;/a&gt;，因为&lt;a href=&quot;https://golang.org/pkg/os/exec/#Cmd&quot;&gt;Cmd&lt;/a&gt;结构提供了一个字段&lt;code&gt;ExtraFiles&lt;/code&gt;，该字段(注意不支持windows)为子进程额外地指定了需要继承的额外的文件描述符，不包含&lt;code&gt;std_in, std_out, std_err&lt;/code&gt;。&lt;br/&gt;需要注意的是，&lt;code&gt;ExtraFiles&lt;/code&gt;描述中有这样一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;If non-nil, entry i becomes file descriptor 3+i&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句是说，索引位置为i的文件描述符传过去，最终会变为值为i+3的文件描述符。ie: 索引为0的文件描述符565, 最终变为文件描述符3&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;file := netListener.File() // this returns a Dup()
path := &quot;/path/to/executable&quot;
args := []string{
    &quot;-graceful&quot;}

cmd := exec.Command(path, args...)
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
cmd.ExtraFiles = []*os.File{file}

err := cmd.Start()
if err != nil {
    log.Fatalf(&quot;gracefulRestart: Failed to launch, error: %v&quot;, err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，&lt;code&gt;netListener&lt;/code&gt;是一个&lt;a href=&quot;https://golang.org/pkg/net/#Listener&quot;&gt;net.Listener&lt;/a&gt;类型的指针，path变量则是我们要更新的新的可执行文件的路径。&lt;/p&gt;
&lt;p&gt;需要注意的是：上面&lt;code&gt;netListener.File()&lt;/code&gt;与&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/dup.html&quot;&gt;dup&lt;/a&gt;函数类似，返回的是一个拷贝的文件描述符。另外，该文件描述符不应该设置&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/fcntl.html&quot;&gt;FD_CLOEXEC&lt;/a&gt;标识，这将会导致出现我们不想要的结果：子进程的该文件描述符被关闭。&lt;/p&gt;
&lt;p&gt;你可能会想到可以使用命令行参数把该文件描述符的值传递给子进程，但相对来说，我使用的这种方式更为简单&lt;/p&gt;
&lt;p&gt;最终，&lt;code&gt;args&lt;/code&gt;数组包含了一个&lt;code&gt;-graceful&lt;/code&gt;选项，你的进程需要以某种方式通知子进程要复用父进程的描述符而不是新打开一个。&lt;/p&gt;
&lt;h5 id=&quot;子进程初始化&quot;&gt;子进程初始化&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;server := &amp;amp;http.Server{Addr: &quot;0.0.0.0:8888&quot;}

var gracefulChild bool
var l net.Listever
var err error

flag.BoolVar(&amp;amp;gracefulChild, &quot;graceful&quot;, false, &quot;listen on fd open 3 (internal use only)&quot;)

if gracefulChild {
    log.Print(&quot;main: Listening to existing file descriptor 3.&quot;)
    f := os.NewFile(3, &quot;&quot;)
    l, err = net.FileListener(f)
} else {
    log.Print(&quot;main: Listening on a new file descriptor.&quot;)
    l, err = net.Listen(&quot;tcp&quot;, server.Addr)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通知父进程停止&quot;&gt;通知父进程停止&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;if gracefulChild {
    parent := syscall.Getppid()
    log.Printf(&quot;main: Killing parent pid: %v&quot;, parent)
    syscall.Kill(parent, syscall.SIGTERM)
}

server.Serve(l)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;父进程停止接收请求并等待当前所处理的所有请求结束&quot;&gt;父进程停止接收请求并等待当前所处理的所有请求结束&lt;/h5&gt;
&lt;p&gt;为了做到这一点我们需要使用&lt;a href=&quot;https://golang.org/pkg/sync/#WaitGroup&quot;&gt;sync.WaitGroup&lt;/a&gt;来保证对当前打开的连接的追踪，基本上就是：每当接收一个新的请求时，给wait group做原子性加法，当请求结束时给wait group做原子性减法。也就是说wait group存储了当前正在处理的请求的数量&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var httpWg sync.WaitGroup&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匆匆一瞥，我发现go中的http标准库并没有为Accept()和Close()提供钩子函数，但这就到了&lt;code&gt;interface&lt;/code&gt;展现其魔力的时候了(非常感谢&lt;a href=&quot;http://nella.org/jra/&quot;&gt;Jeff R. Allen&lt;/a&gt;的这篇&lt;a href=&quot;http://blog.nella.org/zero-downtime-upgrades-of-tcp-servers-in-go/&quot;&gt;文章&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;下面是一个例子，该例子实现了每当执行Accept()的时候会原子性增加wait group。首先我们先继承&lt;code&gt;net.Listener&lt;/code&gt;实现一个结构体&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type gracefulListener struct {
    net.Listener
    stop    chan error
    stopped bool
}

func (gl *gracefulListener) File() *os.File {
    tl := gl.Listener.(*net.TCPListener)
    fl, _ := tl.File()
    return fl
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们覆盖Accept方法(暂时先忽略&lt;code&gt;gracefulConn&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (gl *gracefulListener) Accept() (c net.Conn, err error) {
    c, err = gl.Listener.Accept()
    if err != nil {
        return
    }

    c = gracefulConn{Conn: c}

    httpWg.Add(1)
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要一个构造函数以及一个Close方法，构造函数中另起一个goroutine关闭，为什么要另起一个goroutine关闭，请看&lt;code&gt;refer^{[1]}&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func newGracefulListener(l net.Listener) (gl *gracefulListener) {
    gl = &amp;amp;gracefulListener{Listener: l, stop: make(chan error)}
    // 这里为什么使用go 另起一个goroutine关闭请看文章末尾
    go func() {
        _ = &amp;lt;-gl.stop
        gl.stopped = true
        gl.stop &amp;lt;- gl.Listener.Close()
    }()
    return
}

func (gl *gracefulListener) Close() error {
    if gl.stopped {
        return syscall.EINVAL
    }
    gl.stop &amp;lt;- nil
    return &amp;lt;-gl.stop
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的&lt;code&gt;Close&lt;/code&gt;方法简单的向stop chan中发送了一个nil，让构造函数中的goroutine解除阻塞状态并执行Close操作。最终，goroutine执行的函数释放了&lt;code&gt;net.TCPListener&lt;/code&gt;文件描述符。&lt;/p&gt;
&lt;p&gt;接下来，我们还需要一个&lt;code&gt;net.Conn&lt;/code&gt;的变种来原子性的对wait group做减法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type gracefulConn struct {
    net.Conn
}

func (w gracefulConn) Close() error {
    httpWg.Done()
    return w.Conn.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让我们上面所写的优雅启动方案生效，我们需要替换&lt;code&gt;server.Serve(l)&lt;/code&gt;行为:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;netListener = newGracefulListener(l)
server.Serve(netListener)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后补充：我们还需要避免客户端长时间不关闭连接的情况，所以我们创建server的时候可以指定超时时间：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;server := &amp;amp;http.Server{
        Addr:           &quot;0.0.0.0:8888&quot;,
        ReadTimeout:    10 * time.Second,
        WriteTimeout:   10 * time.Second,
        MaxHeaderBytes: 1 &amp;lt;&amp;lt; 16}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;译者总结&quot;&gt;译者总结&lt;/h4&gt;
&lt;h4 id=&quot;译者注&quot;&gt;译者注:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;refer^{[1]}&lt;/code&gt;&lt;br/&gt;&lt;span&gt;在上面的代码中使用goroutine的原因作者写了一部分，但我并没有读懂，但幸好在评论中，&lt;a href=&quot;https://disqus.com/by/disqus_uypMWCNAEC/&quot;&gt;jokingus&lt;/a&gt;问道：如果用下面的方式，是否就不需要在&lt;code&gt;newGracefulListener&lt;/code&gt;中使用那个goroutine函数了&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (gl *gracefulListener) Close() error { 
    // some code
    gl.Listener.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;作者回复道：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Honestly, I cannot fathom why there would need to be a goroutine for this, and simply doing gl.Listener.Close() like you suggest wouldn't work.... May be there is some reason that is escaping me presently, or perhaps I just didn't know what I was doing? If you get to the bottom of it, would you post here, so I can correct the post if this goroutine business is wrong?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;作者自己也较为疑惑，但表示像&lt;a href=&quot;https://disqus.com/by/disqus_uypMWCNAEC/&quot;&gt;jokingus&lt;/a&gt;所提到的这种方式是行不通的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者的个人理解：在绝大多数情况下，需要一个goroutine(可以称之为主goroutine)来创建socket，监听该socket，并accept直到有请求到达，当请求到来之后再另起goroutine进行处理。首先因为accept一般处于主goroutine中，且其是一个阻塞操作，如果我们想在accept执行后关闭socket一般来说有两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为accept设置一个超时时间，到达超时时间后，检测是否需要close socket，如果需要就关闭。但这样的话我们的超时时间可定不能设置太大，这样结束就不够灵敏，但设置的太小，就会对性能影响很大，总之来说不够优雅。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;accept方法可以一直阻塞，当我们需要close socket的时候，在另一个goroutine执行流中关闭socket，这样相对来说就比较优雅了，作者所使用的方法就是这种&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;另外，也可以参考：&lt;a href=&quot;http://blog.fatedier.com/2016/02/19/how-to-shutdown-go-net-dot-listeners-gracefully/&quot;&gt;Go中如何优雅地关闭net.Listener&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:43:00 +0000</pubDate>
<dc:creator>MnCu</dc:creator>
<og:description>原文 'Graceful Restart in Golang' 作者 'grisha' 声明：本文目的仅仅作为个人mark，所以在翻译的过程中参杂了自己的思想甚至改变了部分内容，其中有下划线的文字为译</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MnCu8261/p/10498849.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：18. 我对 Docker 的使用的学习心得 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于 Docker 的介绍，我这里就不废话了。Docker 是什么？Docker 和虚拟机有什么区别？Docker 适用的场景是什么？这些介绍早就烂大街了。大家可以去 Docker 的官网首页看介绍，也可以在博客园的首页随便搜一下，入门级的文章到处都是。如果想了解更深一点的技术细节，可以看 &lt;a href=&quot;https://www.cnblogs.com/sparkdev&quot;&gt;sparkdev&lt;/a&gt; 的博客，我这里先对 &lt;a href=&quot;https://www.cnblogs.com/sparkdev&quot;&gt;sparkdev&lt;/a&gt; 表示感谢，我这篇随笔中，引用了他的部分内容。而且，我这篇的标题是“我对 Docker 的使用的学习心得”，重点是学习它的使用，而不是它的原理。&lt;/p&gt;
&lt;h2 id=&quot;安装-docker&quot;&gt;安装 Docker&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 中安装 Docker 真的是太方便了。完全不用访问 Docker 的官网，不需要自己去下载，&lt;code&gt;apt&lt;/code&gt;超级牛力瞬间搞定。稍微需要注意的是，不是安装&lt;code&gt;docker&lt;/code&gt;软件包，而是安装&lt;code&gt;docker.io&lt;/code&gt;软件包。首先，我先用&lt;code&gt;sudo aptitude search docker&lt;/code&gt;命令查看 Ubuntu 的软件源中有哪些和 Docker 有关的包，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308220307802-1364471466.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;docker&lt;/code&gt;被明确标记为 transitional package，所以我们安装下面的&lt;code&gt;docker.io&lt;/code&gt;包，使用&lt;code&gt;sudo aptitude install docker.io&lt;/code&gt;命令。安装完成后，使用&lt;code&gt;sudo docker --version&lt;/code&gt;查看一下，发现是最新的版本，而且是社区版，不是企业版，所以其版本号为 18.06.1-ce。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308220609285-2127873492.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;拉两个镜像测试一下&quot;&gt;拉两个镜像测试一下&lt;/h2&gt;
&lt;p&gt;只要稍微了解一点 Docker 的人都知道有一个 dockerhub，和我们常用的 github 一样，可以获得别人精心制作并分享的资源。在 github 中，我们可以找到我们感兴趣的项目，并把它 clone 到本地。而在 dockerhub 中，这些资源叫 Image，我们可以把我们感兴趣的 Image 拉到本地，并以该 Image 为基础，运行一些 Container。&lt;/p&gt;
&lt;p&gt;关于 Image 和 Container 的概念，我这里不再废话。我选择了一个 ubuntu，还有一个 spacevim。使用的命令分别为&lt;code&gt;sudo docker pull ubuntu&lt;/code&gt;和&lt;code&gt;sudo docker pull spacevim&lt;/code&gt;。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308221230807-622237421.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-docker-使用中国的-image-仓库&quot;&gt;配置 Docker 使用中国的 Image 仓库&lt;/h2&gt;
&lt;p&gt;上面拉取 Image 的操作看似简单，其实经历过失败，主要原因就是国外的仓库被墙挡住了。解决这个问题的方法，就是设置 Docker 使用中国的 Image 仓库。其设置方法为修改&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;配置文件，如果没有该文件，就新建一个。将其内容修改为：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;{
    &quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，使用如下命令重启 Docker 服务：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;systemctl daemon-reload
systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行一个容器&quot;&gt;运行一个容器&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo docker image ls&lt;/code&gt;命令可以查看我们的机器上有哪些 Image，使用&lt;code&gt;sudo docker container ps -a&lt;/code&gt;命令，可以查看我们的机器上有哪些 Container。在上图中，在我们拉取镜像之前，它们的显示结果都是空的。&lt;code&gt;sudo docker container ps -a&lt;/code&gt;命令之所以要加上&lt;code&gt;-a&lt;/code&gt;参数，就是为了显示所有的 Container，包括运行的和停止的。&lt;/p&gt;
&lt;p&gt;拉取完了以后，再使用&lt;code&gt;sudo docker image ls&lt;/code&gt;命令，显示的就不再是空的了。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308222651050-1422478420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，使用&lt;code&gt;sudo docker run -it spacevim/spacevim nvim&lt;/code&gt;命令运行一个容器，启动 SpaceVim，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308222800465-1801142486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我分别写了一个 C 语言的文件和一个 Python 语言的文件，同时修改了一下 SpaceVim 自己的配置文件。&lt;/p&gt;
&lt;h2 id=&quot;介绍一下-spacevim&quot;&gt;介绍一下 SpaceVim&lt;/h2&gt;
&lt;p&gt;SpaceVim 是一个非常优秀的 Vim 整合项目，简单点说，就是通过各种插件把 Vim 打造成一个万能的 IDE，而且它对 NeoVim 支持非常好。确实很漂亮，功能也确实很强大。但是，我系统上用的 Vim 是我自己配的一个非常简洁的 Vim（请看我前面的随笔），如果再在系统上安装 SpaceVim 就不太方便。所以，使用 SpaceVim 官方提供的 Docker Image 就是一个非常方便的选择了。&lt;/p&gt;
&lt;h2 id=&quot;docker-的最常用命令和参数&quot;&gt;Docker 的最常用命令和参数&lt;/h2&gt;
&lt;p&gt;从上面的截图可以看出，我们最常用的命令就是&lt;code&gt;sudo docker run&lt;/code&gt;命令，它就是以某个 Image 为基础运行一个新的 Container，注意，是新的 Container 哦。也就是说，每执行一次&lt;code&gt;sudo docker run&lt;/code&gt;，就建立一个新的 Container，哪怕它们用的是同一个 Image。如果要启动一个已经存在的 Container 怎么办呢？别担心，有&lt;code&gt;sudo docker container start&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;最常用的参数是&lt;code&gt;-i&lt;/code&gt;和&lt;code&gt;-t&lt;/code&gt;，只有这样，我们才能够和 Container 中的程序进行交互。其次，就是&lt;code&gt;-p&lt;/code&gt;参数，可以把 Container 中的某个端口映射到主机的某个端口，这对网络服务非常重要。还有&lt;code&gt;-v&lt;/code&gt;参数，可以把主机的某个目录映射到 Container 中的某个目录，这样，共享文件就很方便了。&lt;/p&gt;
&lt;h2 id=&quot;使用-spacevim-时遇到的问题在一个-container-中可以运行多个程序吗&quot;&gt;使用 SpaceVim 时遇到的问题：在一个 Container 中可以运行多个程序吗？&lt;/h2&gt;
&lt;p&gt;使用 SpaceVim 的 Image 启动一个 Container 后，问题来了。每次启动这个 Container，就自动运行 nvim，进入 SpaceVim 的界面，编辑文件是不成问题，可是这个编辑器界面毕竟不是 Shell 不是吗？我们其它的管理工作怎么做？&lt;/p&gt;
&lt;p&gt;而我们使用 ubuntu 的 Image 启动 Container 后就很方便了，直接进入 Bash。所以问题来了，在一个 Container 中可以执行多个程序吗？&lt;/p&gt;
&lt;p&gt;答案是肯定的，那就是&lt;code&gt;sudo docker container exec&lt;/code&gt;命令，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308225416786-221819767.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，我们进入 Ubuntu 时，直接和 Shell 进行交互，所以可以非常方便地使用&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;pwd&lt;/code&gt;等命令，甚至可以使用&lt;code&gt;cat /etc/os-release&lt;/code&gt;命令查看系统的版本信息。当然，还可以使用&lt;code&gt;apt&lt;/code&gt;安装软件。而要想进入 SpaceVim 所在的容器，就需要使用&lt;code&gt;sudo docker container exec -i spacevim-1.0 bash&lt;/code&gt;命令再启动一个 Shell，这样就可以使用&lt;code&gt;ls&lt;/code&gt;命令看到我们刚才编辑的&lt;code&gt;test.c&lt;/code&gt;和&lt;code&gt;test.py&lt;/code&gt;了。甚至可以使用&lt;code&gt;ps&lt;/code&gt;命令查看该容器中运行的进程。&lt;/p&gt;
&lt;h2 id=&quot;docker-的学习资源&quot;&gt;Docker 的学习资源&lt;/h2&gt;
&lt;p&gt;Docker 的官网就别看了，难受。买书呢？费钱！还不一定能找到优秀的。最好的办法就是查看 Docker 的手册页啦。使用&lt;code&gt;sudo dpkg -L docker.io&lt;/code&gt;命令，可以看到系统中安装了好多手册页，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230336762-1050665506.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输入&lt;code&gt;man docker&lt;/code&gt;，就是下面这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230410062-641847169.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输入&lt;code&gt;man docker run&lt;/code&gt;，就是下面这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308230445002-92823188.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想自己写 Dockfile，就输入&lt;code&gt;man Dockfile&lt;/code&gt;。我就不继续截图了。每一个手册页都可以从头读到尾，这种流畅的感觉是在 Docker 的官网上查看文档体会不到的。&lt;/p&gt;
&lt;h2 id=&quot;下一个问题我们可以把我们的-container-再打包带走吗&quot;&gt;下一个问题：我们可以把我们的 Container 再打包带走吗？&lt;/h2&gt;
&lt;p&gt;运行一个 Container 后，我们可以在上面编辑文件、更改配置，还可以按需安装软件。做了很多工作后，我们可以把这个 Container 打包带走吗？当然可以了，使用&lt;code&gt;sudo docker container commit&lt;/code&gt;命令可以基于一个 Container 再创建一个镜像。然后使用&lt;code&gt;sudo docker push&lt;/code&gt;命令就可以把这个镜像再上传到 dockerhub 上了。当然，这只是理想状态，毕竟有墙的存在，而且 dockerhub 要注册后才能上传镜像。所以上传这个事就不是那么好做啊。&lt;/p&gt;
&lt;p&gt;不过没关系，我们可以打包用 U 盘带走。&lt;code&gt;sudo docker image save&lt;/code&gt;命令可以把 Image 导出为本地文件。使用 U 盘带走后，使用&lt;code&gt;sudo docker image load&lt;/code&gt;命令可以从这个文件再导入镜像。&lt;/p&gt;
&lt;h2 id=&quot;下一个问题docker-中的程序可以访问我们主机上的所有硬件资源吗&quot;&gt;下一个问题：Docker 中的程序可以访问我们主机上的所有硬件资源吗？&lt;/h2&gt;
&lt;p&gt;其实我关心的是显卡。在我的上上篇随笔中，我写到了使用 CUDA 加速计算，而 CUDA 需要 Nvidia 的显卡支持。如果我要用 Docker 构建一个 CUDA 的开发环境，那就需要我 Docker 中的程序能够访问主机的显卡资源。从理论上讲，这是可以的。毕竟 Docker 不同于虚拟机，Docker 是和主机共享内核的，而 Nvidia 的驱动，只是一个内核模块。于是，我在使用 Ubuntu 镜像的 Container 中测试了一下。使用&lt;code&gt;lsmod&lt;/code&gt;命令查看内核模块，发现它确实是使用的 Nvidia 的驱动，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201903/16576-20190308232004015-351660252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，使用&lt;code&gt;sudo aptitude install nvidia-cuda-toolkit&lt;/code&gt;安装 cuda-toolkit，也是可以安装的。因此，证明 Docker 中的程序可以访问主机上的所有硬件资源。使用 Docker 构建我们自己的开发环境不是梦。&lt;/p&gt;
&lt;h2 id=&quot;最后一个问题docker-中能运行-gui-程序吗&quot;&gt;最后一个问题：Docker 中能运行 GUI 程序吗？&lt;/h2&gt;
&lt;p&gt;答案是可以。&lt;/p&gt;
&lt;p&gt;先来分析一下思路。在 Docker 中运行控制台程序时，我们需要给程序一个标准输入输出，就可以和程序交互了。在 Docker 中运行 Web 服务时，我们需要给程序一个 IP 和端口，就可以和服务交互了。GUI 程序需要什么呢？它们需要一个 X Server 的 Display。我们给它就行了。&lt;/p&gt;
&lt;p&gt;DISPLAY的格式是&lt;code&gt;unix:端口&lt;/code&gt;或&lt;code&gt;主机名:端口&lt;/code&gt;，前一种格式表示使用本地的 unix 套接字，后一种表示使用 tcp 套接字。默认情况下，X11的服务端会监听本地的&lt;code&gt;unix:0&lt;/code&gt;端口，而 DISPLAY 的默认值为&lt;code&gt;:0&lt;/code&gt;，这实际上是&lt;code&gt;unit:0&lt;/code&gt;的简写。因此如果在 Linux 的控制台启动一个图形程序，它就会出现在当前主机的显示屏幕中。&lt;/p&gt;
&lt;p&gt;而 unix 套接字就是一个文件，所以，可以使用&lt;code&gt;-v&lt;/code&gt;参数，将主机的 unix 套接字共享到 Container 中，然后，运行在 Container 中的 GUI 程序，就会出现在主机的屏幕上。&lt;/p&gt;
&lt;p&gt;其实早在2015年的“Docker全球开发者大会”上，Docker 自家的美女程序员“杰西·弗莱泽尔（Jessie Frazelle）”就展示了一系列黑魔法一样的镜像。这些镜像中的大多数都使用了图形界面。比如，她使用这样的命令&lt;code&gt;docker run -d -v /tmp/.X11-unix:/tmp/.X11-unix jess/libreoffice&lt;/code&gt;在 Docker 中运行了 LibreOffice（这只是举例，真要运行成功还有很多细节需要完善），其中最重要的参数就是&lt;code&gt;-v /tmp/.X11-unix:/tmp/.X11-unix&lt;/code&gt;，也就是把主机的 unix 套接字映射到 Container 中。&lt;/p&gt;
&lt;p&gt;OK，关于 Docker，今天就写这么多。我感觉我又找到了新世界的大门。&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2019年03月08日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:38:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop018.html</dc:identifier>
</item>
<item>
<title>没有基础也能写个小程序 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/10498779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/10498779.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文章记录了小程序的设计思路，介绍了使用的技术，描述了提交审核的故事，还提供了最终的完整源码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微信小程序自从发布以来就占据着超高的话题热度，一直以来都想开发一款自己的小程序，但苦于不懂前端迟迟没有开始。偶然发现了ColorUI这个开源的小程序组件库，界面好看且提供Demo，心中狂喜马上动手&lt;/p&gt;
&lt;p&gt;做个什么小程序呢？想了一圈这半年多一直坚持在写技术文章，为此开通了微信公众号，因为公众号查看文章列表不友好，且不方便在微信以外的渠道传播，我又利用Github Pages搭建了&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;网站主页，就想做个类似于网站主页的小程序吧，可以在微信体系内优化公众号文章列表页读取以及方便分类检索&lt;/p&gt;

&lt;p&gt;计划参考&lt;a href=&quot;https://ops-coffee.cn&quot;&gt;运维咖啡吧&lt;/a&gt;网站主页写个小程序页面来展示微信公众号内的所有文章，后边加上搜索、标签等方便检索，用户点击列表后跳转到微信公众号具体的文章查看，形成闭环&lt;/p&gt;
&lt;p&gt;首先写了个“列表”页，用来展示公众号内的所有文章，但写完列表后发现小程序并不支持跳转到公众号的文章，不能查看文章这个小程序的意义就失去了大半&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d461bb2b?w=637&amp;amp;h=1324&amp;amp;f=jpeg&amp;amp;s=134087&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后添加了一个“关于”页面，页面内介绍小程序是干嘛的顺便给个公众号入口，方便对文章感兴趣的朋友继续阅读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d468936b?w=638&amp;amp;h=1325&amp;amp;f=jpeg&amp;amp;s=108188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码完成后提交给小程序审核，约半天时间反馈审核失败，原因是“实际运营内容与名称简介不符”，想着可能审核的伙伴不知道运维是干嘛的，看到名称里包含咖啡吧，以为是跟咖啡相关的，反馈解释了一下什么是运维，以及小程序跟公众号的关系，再次提交审核，又等了半天功夫，还是反馈审核失败，这次原因是“小程序进入点击页面内容无反应”，我就写了个列表页，列表内容并不能点，这不是BUG，又反馈了一次但很遗憾跟上次一样的原因依然审核失败，看来必须得能点&lt;/p&gt;
&lt;p&gt;决定添加一个“详情”页面，并不准备在详情内放文章的详细内容，因为这涉及到以往文章数据整理以及需要提供后端接口等问题，只想着能够审核通过，所以简单展示了文章的基本内容，给了个跳转到公众号的按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d447c5d9?w=638&amp;amp;h=1325&amp;amp;f=jpeg&amp;amp;s=60773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编码完成再次提交审核，顺利通过&lt;/p&gt;

&lt;p&gt;下边介绍一下这个小程序中用到一些技术点&lt;/p&gt;
&lt;h2 id=&quot;for循环展示&quot;&gt;for循环展示&lt;/h2&gt;
&lt;p&gt;列表页面的展示采用了for循环读取JS数据&lt;/p&gt;
&lt;p&gt;JS里边用一个Blogs变量来记录文章列表页的数据，JS里边定义的变量可以直接在模板渲染时引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page({
  data: {
    StatusBar: app.globalData.StatusBar,
    CustomBar: app.globalData.CustomBar,
    Blogs: [
        {
            &quot;title&quot;: &quot;Django内置权限扩展案例&quot;,
            &quot;image&quot;: &quot;https://ws1.sinaimg.cn/large/7164c73agy1g0vl4k4veej20zk0f841d.jpg&quot;,
            &quot;description&quot;: &quot;当Django的内置权限无法满足需求的时候&quot;,
            &quot;url&quot;: &quot;https://mp.weixin.qq.com/s/BZsJnWLtv8ZwwlBYbWSbZQ&quot;,
            &quot;tag&quot;: &quot;Django&quot;
        },
        {
            &quot;title&quot;: &quot;我们自研的那些Devops工具&quot;,
            &quot;image&quot;: &quot;https://ws1.sinaimg.cn/large/7164c73agy1g0vl4wtqdfj20zk0k00ve.jpg&quot;,
            &quot;description&quot;: &quot;随着云技术以及容器技术的崛起，人肉运维的时代结束了&quot;,
            &quot;url&quot;: &quot;https://mp.weixin.qq.com/s/HwOi-ARTvvNjGTWrDmZIkQ&quot;,
            &quot;tag&quot;: &quot;DevOps&quot;
        }
    ]
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模板渲染时用到了循环标签&lt;code&gt;wx:for&lt;/code&gt;，可以读取JS变量的列表值，然后通过&lt;code&gt;{{item}}&lt;/code&gt;拿到列表中的每个对象，再通过&lt;code&gt;{{item.key}}&lt;/code&gt;拿到对象的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view bindtap=&quot;toChild&quot; data-blog=&quot;{{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blogs}}&quot; wx:key&amp;gt;
&amp;lt;view class=&quot;title&quot;&amp;gt;{{item.title}}&amp;lt;/view&amp;gt;
&amp;lt;view class=&quot;content&quot;&amp;gt;
  &amp;lt;image src=&quot;{{item.image}}&quot; mode=&quot;aspectFill&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;view class=&quot;desc&quot;&amp;gt;
    &amp;lt;view class=&quot;text-content&quot;&amp;gt; {{item.description}}&amp;lt;/view&amp;gt;
    &amp;lt;view class=&quot;flex justify-between&quot;&amp;gt;
      &amp;lt;text class=&quot;text-xs text-gray&quot;&amp;gt;原创：37丫37&amp;lt;/text&amp;gt;
      &amp;lt;view class=&quot;bg-right cu-tag bg-green light sm round&quot;&amp;gt;{{item.tag}}&amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后端取数据&quot;&gt;后端取数据&lt;/h2&gt;
&lt;p&gt;考虑到文章可能会随时增加，将数据直接写在JS里边并不友好，每次变更还要重新发布审核，所以从后端接口读取数据才是最好的方式，但考虑到成本问题没必要专门写个后端程序来处理，直接将内容存json，提供https访问即可&lt;/p&gt;
&lt;p&gt;在页面加载的时候去后台请求数据，然后给设置成变量Blogs，页面渲染参考上边介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onLoad: function () {
    var that = this;
    wx.request({
      url: 'https://ops-coffee.cn/blog.json',
      header: {
        'content-type': 'application/json'
      },
      //请求后台数据成功
      success: function (res) {
        that.setData({
          Blogs: res.data.data
        })
      }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;页面跳转&quot;&gt;页面跳转&lt;/h2&gt;
&lt;p&gt;点击列表内容跳转到详情页该怎么实现呢？&lt;/p&gt;
&lt;p&gt;我们先来看看跳转，跳转可以直接通过&lt;code&gt;navigator&lt;/code&gt;标签实现，&lt;code&gt;open-type&lt;/code&gt;指定跳转方式，&lt;code&gt;url&lt;/code&gt;指定跳转的页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;navigator open-type=&quot;navigate&quot; url=&quot;/pages/index/detail/detail?data={{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blog}}&quot; wx:key&amp;gt;
    &amp;lt;view class=&quot;title&quot;&amp;gt;{{item.title}}&amp;lt;/view&amp;gt;
    ...
&amp;lt;/navigator&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过&lt;code&gt;bindtap&lt;/code&gt;事件触发&lt;code&gt;wx.navigateTo&lt;/code&gt;实现跳转，&lt;code&gt;data-blog&lt;/code&gt;可以指定bindtap事件参数，从而在JS中获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view bindtap=&quot;toChild&quot; data-blog=&quot;{{item}}&quot; class=&quot;cu-item shadow&quot; wx:for=&quot;{{Blogs}}&quot; wx:key&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;toChild(event) {
    var blog = event.currentTarget.dataset.blog;
    
    wx.navigateTo({
      url: '/pages/index/blog/blog'
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;本地存储&quot;&gt;本地存储&lt;/h2&gt;
&lt;p&gt;当点击列表内容跳转到详情页，正常的做法应该是去后台请求文章的详情以渲染详情页面，但这里我需要展示的内容列表页已经存在了，无需再次请求就找了个偷懒的做法，在用户点击列表内容时，把这篇文章的详细信息利用&lt;code&gt;wx.setStorageSync&lt;/code&gt;存储在本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;toChild(event) {
    var blog = event.currentTarget.dataset.blog;
    
    wx.setStorageSync(
      'blog',blog
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在详情页加载时利用&lt;code&gt;wx.getStorageSync&lt;/code&gt;取出来渲染到页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onLoad: function (option) {
    var blog = wx.getStorageSync('blog');
    
    this.setData({
      blog:blog
    })
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关联公众号&quot;&gt;关联公众号&lt;/h2&gt;
&lt;p&gt;小程序提供关联公众号的功能，需要先在小程序后台：设置-&amp;gt;关注公众号中开启公众号关注组件，然后在页面的相应地方添加上如下代码就可以像文章详情页最下边一样出来个关联公众号的组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;official-account&amp;gt;&amp;lt;/official-account&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但访问时可能会发现打开详情页并没有出现关联公众号的组件，这个主要是因为并非所有的情况下都会展示，只有用对了姿势才能看到，官方文档有更多介绍，目前还没有办法彻底解决看不到的问题&lt;/p&gt;
&lt;h2 id=&quot;页面分享&quot;&gt;页面分享&lt;/h2&gt;
&lt;p&gt;小程序上线后我想分享给朋友装逼，确发现没有方便的方式，查官方文档发现可以用&lt;code&gt;onShareAppMessage&lt;/code&gt;方法，只需简单的添加到想分享页面的JS中即可，然后在右上角的功能按钮中就会出现转发功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onShareAppMessage() {
    return {
      title: '运维咖啡吧',
      path: '/pages/index/list/list'
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;长按文末二维码关注微信公众号【运维咖啡吧】回复&quot;03&quot;可获取源码地址，期待你的到来&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;感谢ColorUI，如此优秀的项目才能让我没有基础的情况下快速开发一款小程序&lt;/li&gt;
&lt;li&gt;此项目从开发到完成大概只花了1天的时间，比较简陋，学习小程序的实验项目，各位轻喷&lt;/li&gt;
&lt;li&gt;对于框架的学习我的做法是先看一遍官方文档的介绍，了解基本的内容，能看得懂项目结构，然后再开始编码&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/8/1695dd77d456157d?w=430&amp;amp;h=475&amp;amp;f=jpeg&amp;amp;s=67696&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章不错，请点右下角【好看】。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 15:11:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>文章记录了小程序的设计思路，介绍了使用的技术，描述了提交审核的故事，还提供了最终的完整源码 背景说明 微信小程序自从发布以来就占据着超高的话题热度，一直以来都想开发一款自己的小程序，但苦于不懂前端迟迟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/10498779.html</dc:identifier>
</item>
<item>
<title>CUBA 7 新特性（上篇） - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-newversion.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-newversion.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;  &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182113978-1294519029.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三年前，我们宣布了&lt;/span&gt; CUBA 框架的第二个公开的主版本。&lt;a href=&quot;https://www.cuba-platform.com/blog/whats-new-in-cuba-platform-6-0-and-studio-2-0&quot;&gt;&lt;span&gt;CUBA 6&lt;/span&gt;&lt;/a&gt; &lt;span&gt;是改变游戏规则的版本&lt;/span&gt; - 框架的许可从私有化变成了公开的 Apache2.0。那些日子里，我们甚至猜不到这个变化会最终将框架带向何方。随之而来的是，CUBA社区开始呈指数级增长，从中我们学习到许多开发人员可能使用框架的方法（有时甚至是不可能的方法）。现在我们很高兴的宣布 &lt;a href=&quot;https://www.cuba-platform.com/blog/cuba-7-the-new-chapter&quot;&gt;&lt;span&gt;CUBA 7&lt;/span&gt;&lt;/a&gt; &lt;span&gt;的发布，通过这个版本，我们希望那些刚刚开始&lt;/span&gt;CUBA和Java之旅的社区成员能更加顺利和快乐的成长为熟练的企业级开发人员或者Java专家。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182148912-1311792502.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　显然，&lt;/span&gt;CUBA 的成功很大一部分要依赖于 &lt;a href=&quot;https://www.cuba-platform.com/development-tools&quot;&gt;&lt;span&gt;CUBA Studio&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。它极大的简化了繁琐的&lt;/span&gt; Java 企业级开发任务，很多地方被简化成只需要在可视化编辑器进行简单的配置即可，不需要了解Persistence API 或者 Gradle，甚至不需要了解 Spring 就能开发出来完整的、功能丰富的CRUD 应用程序。这一切，Studio就能帮你完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182223277-1112118201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以前，&lt;/span&gt;Studio 是一个单独的 web 应用程序，这样会有一些明显的局限：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;首先，&lt;/span&gt;Studio 并不是功能完备的 IDE，所以开发者需要经常在 Studio 和 IntelliJ IDEA 或者Eclipse 之间切换，以便在 IDE 中开发业务逻辑，也能更好的利用 IDE 方便的导航、代码完成功能和其他必要的功能。来回地切换有时候很烦人。&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;其次，&lt;/span&gt;Studio 的简单性是建立在大量的源码解析和生成的基础上。所以，要提高代码生成的能力也就意味着要朝着开发功能完备的IDE方向努力 - 这个想法太过雄心勃勃了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后我们决定依靠另一位巨人的肩膀来解决这些局限。现在&lt;/span&gt; Studio 跟 JetBrains 开发的IntelliJ IDEA 合并了。现在可以将 Studio 作为 IntelliJ IDEA 的插件安装或者下载单独打包的版本。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182312522-1585450293.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　这个方法为我们开辟了新的视野：&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;能支持其它&lt;/span&gt;JVM的开发语言（首先就是Kotlin）&lt;/p&gt;
&lt;p&gt;　　l 提升了热部署的能力&lt;/p&gt;
&lt;p&gt;　　l 整个项目中能更直观的导航&lt;/p&gt;
&lt;p&gt;　　l 更聪明的代码生成和提醒&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在新的&lt;/span&gt;Studio正在积极的开发中：我们正在移植旧版本的功能。短期计划还包括使用原生IntelliJ UI重新实现基于 Web 的设计器，并改善项目导航体验。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;技术栈升级&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　跟以前主版本升级一样，这次底层的技术栈也做了升级，比如&lt;/span&gt; Java 8/11，Vaadin 8，Spring 5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182342189-1458114780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认情况下新项目会使用&lt;/span&gt;Java 8，但是也可以通过在build.gradle中添加下面的内容来指定需要的Java版本：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182402750-1540875340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　升级到&lt;/span&gt;Vaadin 8是个不小的挑战，因为Vaadin的数据绑定API发生了很大的破坏性变化。但使用CUBA的开发者很幸运，因为CUBA为开发者提供了统一封装的自有API层，屏蔽了底层Vaadin的内部结构。CUBA开发团队做了大量的工作，重新实现了很多内部逻辑以保持CUBA自有的API不变化。也就是说，这很好的保持了CUBA框架的兼容性，不需要做任何重构就可以直接移植到CUBA 7并享受Vaadin 8带来的好处。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　依赖库的完整升级列表可以在官方的&lt;/span&gt; &lt;a href=&quot;http://files.cuba-platform.com/cuba/release-notes/7.0/#upd_dep&quot;&gt;&lt;span&gt;release notes&lt;/span&gt;&lt;/a&gt; &lt;span&gt;中找到。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;新的界面&lt;/span&gt;API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一小节也可以称为&lt;/span&gt; “第一版界面API”，因为CUBA之前没有任何官方的声明在web客户端层有API存在。界面API基于框架的历史，也基于我们最初的一些假设：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以声明为中心的方法&lt;/span&gt; - 所有可以以声明式描述的，都应该在界面描述文件中声明，而不是在其控制器中编码。&lt;/p&gt;
&lt;p&gt;　　标准界面（浏览和编辑界面）提供具体的通用功能，一般不需要修改。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从最初的一千个成员加入了社区开始，我们就认识到对于&lt;/span&gt;“标准” CRUD 界面的需求是有多么广泛，已经超出了最开始我们设计的一组功能了。然而，很长一段时间，即使没有 API 层，我们也能够处理自定义行为的需求，这是因为有另一个第一阶段假设 - 开放继承。有效地进行开放继承意味着可以覆盖基础类的任何公共或保护方法，再根据需要定制其行为。这听起来似乎是所有顽疾的解药，但事实上可能短期都不一定能见效：如果被覆盖的方法被重命名、删除了或者将来版本的框架根本不同这个方法了，该怎么办？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182429358-1461271772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，为了响应社区日益增长的需求，我们决定引入新的界面&lt;/span&gt;API。API提供了清晰的长期的扩展点，而没有隐藏的声明式暗喻，灵活并且易于使用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;界面声明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt; CUBA 7 里，界面声明异常简单：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182454961-1573939596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上面的例子我们可以看到，界面的标识符在控制器类上显式的进行定义。也就是说，现在界面&lt;/span&gt;id和控制器类能相互唯一的对应。由此带来的好消息就是，现在界面可以直接通过其控制类来安全访问了（注意下面例子用控制器类来创建确认窗口）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182503854-1192734549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至此，界面描述文件不再是必须的，而成为了一个补充的部分。界面布局可以通过编程的方式创建或者通过&lt;/span&gt; XML 界面描述声明式创建，界面描述通过控制器类的 @UiDescriptor 注解定义。这样能使得控制器和布局更加容易读懂。这个方式跟Android开发中使用的模式非常类似。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前，需要在&lt;/span&gt;web-screens.xml中注册一个界面描述并为其设置一个标识符。在 CUBA 7 中，这个文件只是因为兼容性的考虑被保留下来，用新方法创建界面不需要这种注册了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;界面生命周期&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　新的&lt;/span&gt;API带来了清晰的自描述的界面生命周期事件：&lt;/p&gt;
&lt;p&gt;　　l Init&lt;/p&gt;
&lt;p&gt;　　l AfterInit&lt;/p&gt;
&lt;p&gt;　　l BeforeShow&lt;/p&gt;
&lt;p&gt;　　l AfterShow&lt;/p&gt;
&lt;p&gt;　　l BeforeClose&lt;/p&gt;
&lt;p&gt;　　l AfterClose&lt;/p&gt;
&lt;p&gt;　　CUBA 7 中所有的界面相关的事件都可以用下面的方式订阅：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182527423-563418869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将新&lt;/span&gt;API与旧方法进行比较，可以看到我们没有重写钩子方法，之前这些钩子方法在父类的层次结构中被模糊地调用。现在我们在界面生命周期的明确预定义的点中定义业务逻辑。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;事件处理和功能代理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前一小节我们介绍了如何订阅生命周期事件，那么，其他组件呢？我们是否应该像在&lt;/span&gt;6.x版本中那样在界面初始化时分散所有必需的监听器？新API非常统一，因此订阅其他事件与生命周期事件完全相似。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们举一个带有两个&lt;/span&gt;UI元素的简单例子，一个按钮和一个货币字段控件，因此它的XML描述符如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182546718-1859839437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过单击按钮我们调用中间件服务返回一个数字，该数字将被写到货币控件中。货币控件需要根据价格的值更改其样式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182648391-1628367278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上面的例子中，我们看到有两个事件处理器：一个是按钮按下时调用的，另一个是当货币控件的值发生变化时执行的。就是这么简单。&lt;/p&gt;
&lt;p&gt;　　现在，我们设想一下，如果需要验证价格的值并确保其为一个正数。最直接的方法就是在界面初始化的时候为其添加一个验证器：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182705539-1711560311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在真实的应用程序中，界面的入口点经常会被这种界面元素的初始化方法填满。为了避免这个问题，&lt;/span&gt;CUBA提供了一个非常有用的注解 @Install。看看使用这个注解怎么避免这个情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182731147-1591504663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　事实上，这里是将货币控件验证的逻辑代理给了界面的&lt;/span&gt; currencyFieldValidator 方法来执行。虽然看上去稍微复杂一点，但是开发人员使用起这个功能来惊人的快速。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;界面&lt;/span&gt;Builders/通知消息/对话框&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182817877-1188204209.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA 7 还引入了一些新的非常有用的带有流式 API 的组件：&lt;/p&gt;
&lt;p&gt;　　l ScreenBuilders 结合了流式工厂来生成标准的查找、编辑和自定义界面。下面的例子展示了如何从一个界面打开另一个界面。注意，build() 方法能返回正确类型的界面实例，不需要不安全的类型转换。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182837428-999038243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　l Screens 组件相对于 ScreenBuilders 来说提供了更底层的抽象，用来显示和创建界面。并且提供了访问 CUBA 应用程序中所有已打开界面信息的方法（Screens#getOpenedScreens），如果需要遍历这些界面，这个方法很有用。&lt;/p&gt;
&lt;p&gt;　　l Notifications和Dialogs 组件均提供了自描述的方便接口。这里有个例子创建对话框和消息通知：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201903/1438872-20190308182851908-2145613901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;数据绑定&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　CUBA 之所以可以做到后台UI的快速开发，不仅仅是因为提供了可以生成大部分代码的可视化工具，还因为提供了大量开箱即用的具有数据感知能力的组件。 这些组件只需要知道要使用哪些数据，其余事情会自动管理。例如， 查找列表、选择器字段、具有 CRUD 操作的各种网格等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在版本&lt;/span&gt; 7 之前，数据绑定是通过称为数据源的对象实现的，数据源包装单个实体或实体集合、与数据感知组件绑定，然后响应数据感知组件的数据变化。 这种方法非常有效，但是是以一个整块的方式实现的。 整块石头似的架构通常在可定制性方面会有问题。因此在 CUBA 7 中，这块坚固的巨石被分成 3 个数据组件：&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data Loader (数据加载器）&lt;/strong&gt; &lt;span&gt;是&lt;/span&gt;&lt;span&gt;数据容器的数据提供者。&lt;/span&gt; &lt;span&gt;数据加载器不保存数据，它们只是将所有必需的查询参数传递给数据存储，并将结果数据集提供给数据容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data container (数据容器)  &lt;/strong&gt;&lt;span&gt;保留加载的数据（单个实体或多个实体）并以响应式的方式将数据提供给数据感知组件：被包装实体的所有更改都会暴露给相应的&lt;/span&gt;UI组件，反之亦然，UI组件内的所有更改都会引起数据容器作出相应更改。&lt;/p&gt;
&lt;p&gt;　　l &lt;strong&gt;Data context&lt;/strong&gt;  &lt;span&gt;（数据上下文）&lt;/span&gt;是一个强大的数据更改管理器，可跟踪更改并提交所有已修改的&lt;span&gt;实体。&lt;/span&gt; &lt;span&gt;一个实体可以合并到一个数据上下文中，合并后会得到一个原始实体的副本，这个副本与原始实体有一个唯一但非常重要的区别：对副本实体及其引用的所有实体（包括集合）的所有修改都将被跟踪、存储和提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据组件可以在界面描述符中声明，也可以使用专门的工厂类&lt;/span&gt; - DataComponents 以编程的方式创建。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;其它&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　上面介绍了新的界面&lt;/span&gt;API中最重要的部分，所以剩下的部分我简要列出 Web客户端层中的其他重要功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　URL 历史记录和导航&lt;/strong&gt;&lt;span&gt;。此功能解决了在&lt;/span&gt; WEB 浏览器中具带有“后退”按钮的 SPA 应用程序存在的一个普遍问题，提供了一种简单地为应用程序界面分配路径的方法，同时使 API 能够在URL中反映界面的当前状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　使用&lt;/span&gt; Form 代替 FieldGroup&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt; FieldGroup 是一个数据感知组件，用于显示和修改单个实体的字段。它在运行时推断出用于显示字段的实际UI组件。也就是说，如果你的实体中有一个日期类型的字段，它将使用 DateField 组件来显示 。但是，如果你希望以编程方式使用此组件，则需要将此组件注入到界面控制器并手动将其转换为正确的类型（在我们的示例中为DateField）。过了一段时间，可能会字段类型更改为其他类型，这时应用程序就是崩溃。表单通过显式声明组件类型解决此问题。关于 Form 的更多信息请参阅&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/gui_Form.html?_ga=2.116833092.339458145.1551663632-952816468.1486173136&quot;&gt;&lt;span&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　显著地简化了第三方&lt;/span&gt; JavaScript 组件的集成&lt;/strong&gt;，可参考这个&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/jsComponent.html?_ga=2.141916144.339458145.1551663632-952816468.1486173136&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;将自定义&lt;/span&gt; JavaScript 组件嵌入到CUBA 应用程序中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　现在可以在&lt;/span&gt; XML 界面描述中轻松定义 HTML/CSS属性&lt;/strong&gt;，也可以通过编程方式设置。详细信息请参阅&lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/gui_attributes.html?_ga=2.182882532.339458145.1551663632-952816468.1486173136#gui_attr_css&quot;&gt;&lt;span&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　好了，以上只是关于&lt;/span&gt; Studio 和偏前端的新功能介绍，下篇会介绍偏后端的新功能。&lt;/p&gt;

</description>
<pubDate>Fri, 08 Mar 2019 14:17:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>三年前，我们宣布了 CUBA 框架的第二个公开的主版本。CUBA 6 是改变游戏规则的版本 - 框架的许可从私有化变成了公开的 Apache2.0。那些日子里，我们甚至猜不到这个变化会最终将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-newversion.html</dc:identifier>
</item>
<item>
<title>python垃圾回收机制 - 吃饭睡觉打逗逗</title>
<link>http://www.cnblogs.com/lurenjia1994/p/10498593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurenjia1994/p/10498593.html</guid>
<description>&lt;p&gt;python中有自动内存回收机制，一般情况不需要程序员来处理，面试时被大佬问到了，记录一下。没有画图，推荐读参考的第一篇博文&lt;/p&gt;

&lt;h2&gt;gc方式1：引用计数&lt;/h2&gt;
&lt;p&gt;若此对象无其他对象引用，则立马回收掉&lt;/p&gt;
&lt;h4&gt;优点：简单、实时（将处理垃圾时间分摊到运行代码时，而不是等到一次回收）&lt;/h4&gt;
&lt;h4&gt;缺点：&lt;/h4&gt;
&lt;p&gt;1.保存对象引用数会占用一点点内存空间&lt;/p&gt;
&lt;p&gt;2.每次执行语句都可能更新引用数，不再使用大的数据结构时，会引起大量对象被回收&lt;/p&gt;
&lt;p&gt;3.不能处理循环引用的情况&lt;/p&gt;

&lt;h2&gt;gc方式2：标记-清除（Mark—Sweep）&lt;/h2&gt;
&lt;p&gt;此方式主要用来处理循环引用的情况，只有容器对象（list、dict、tuple，instance）才会出现循环引用的情况&lt;/p&gt;
&lt;h4&gt;循环引用示例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308212848414-1797660854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 处理过程&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.将所有容器对象放到一个双向链表中（链表为了方便插入删除），这些对象为0代

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.循环遍历链表，如果被本链表内的对象引入，自身的被引用数-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，如果被引用数为0，则触发引用计数回收条件，被回收掉

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;.未被回收的对象，升级为1代
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;触发条件：&lt;/h4&gt;
&lt;p&gt;因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代链表。&lt;/p&gt;
&lt;p&gt;随着时间的推移，一代链表越来越多，多到触发gc阈值，同样会对一代链表进行标记清除操作，然后将剩下活跃对象升为二代&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308211852069-678917010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1046062/201903/1046062-20190308213942672-108078035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;何时触发&lt;/h2&gt;
&lt;p&gt;1.被引用为0时，立即回收当前对象&lt;/p&gt;
&lt;p&gt;2.达到了垃圾回收的阈值，触发标记-清除&lt;/p&gt;
&lt;p&gt;3.手动调用gc.collect()&lt;/p&gt;
&lt;p&gt;4.Python虚拟机退出的时候&lt;/p&gt;







&lt;h2&gt;参考：&lt;/h2&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinganzi/p/6646742.html&quot;&gt;Python垃圾回收机制--完美讲解!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://foofish.net/python-gc.html&quot; target=&quot;_blank&quot;&gt;Python 中的垃圾回收机制&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/xiongchengluo1129/article/details/80462651&quot; target=&quot;_blank&quot;&gt;python垃圾回收&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 14:13:00 +0000</pubDate>
<dc:creator>吃饭睡觉打逗逗</dc:creator>
<og:description>python中有自动内存回收机制，一般情况不需要程序员来处理，面试时被大佬问到了，记录一下。没有画图，推荐读参考的第一篇博文 gc方式1：引用计数 若此对象无其他对象引用，则立马回收掉 优点：简单、实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurenjia1994/p/10498593.html</dc:identifier>
</item>
<item>
<title>SpringBoot 2 要不要升级 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10498344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10498344.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在谈SpringBoot 2.x 之前，先来聊点别的：&lt;/p&gt;
&lt;p&gt;首先是Java 语言，这门长期占据编程语言排行榜首位的语言到底有什么魔力？&lt;br/&gt;大家的看法是多种多样的，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向对象设计，使用简单，可以很快速的入门；&lt;/li&gt;
&lt;li&gt;开源生态做得好，很多可重用的组件，拿来即用；&lt;/li&gt;
&lt;li&gt;跨平台，高性能，是做后台开发的首选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一种观点很有意思：这是命好，每当人们觉得 Java 不行了的时候，总会有英雄横刀救美..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211908029-1186505908.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，主要说的是：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&quot;:最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。&lt;br/&gt;后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。&lt;br/&gt;等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java。&lt;br/&gt;于是 Java 再次焕发勃勃生机。 目前在大数据领域，Java 同样是当仁不让的好手。&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文&lt;a href=&quot;http://www.10tiao.com/html/193/201802/2650713979/1.html&quot;&gt;出自这里&lt;/a&gt;，感兴趣的朋友可以去读一读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&quot;命好&quot;&lt;/strong&gt;的确没错，但这里想说的是开放性(开源)是非常关键的。&lt;br/&gt;由于Java的开放性，其开源生态衍生出了非常多的优秀框架，其中最有代表性的就是SpringFramework。&lt;br/&gt;随着框架的受众越来越多，该项目也在持续演进以满足日益增长的能力需求，最终大家便越来越离不开它。&lt;br/&gt;到如今 SpringFramework 已经形成了一个庞大的生态圈，同时 Spring Web也已经成为Java开发的一种&quot;事实标准&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211924462-1179083631.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果希望了解Spring 框架的一些历史，推荐读一读 &lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/10213304.html&quot;&gt;是时候给大家介绍 Spring Boot/Cloud 背后豪华的研发团队了&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;一springboot-简史&quot;&gt;一、SpringBoot 简史&lt;/h2&gt;
&lt;p&gt;SpringBoot 的诞生不是没有道理的，可能大家都清楚，Spring Framework定义了一个核心的概念叫&lt;strong&gt;IoC&lt;/strong&gt;，即控制反转。 这是什么意思？&lt;br/&gt;控制反转，即对象的关系不再由对象本身决定，由容器来控制其依赖。简单说，就是由容器来帮你初始化对象，并完成自动化的关联。&lt;br/&gt;这样，又有了依赖注入(Dependency Injection)的概念...总之，IoC 和 DI是 理解Spring框架的关键，后面所有出现的东西，都是从这两个概念开始的。&lt;/p&gt;
&lt;p&gt;然后，因为要做自动化的对象初始化、关系装配，需要有个东西来描述这些关系，一般是用xml文件来描述，比如applicationContext.xml 会描述一个ApplicationContext上下文里面所拥有的对象实例，以及这些实例之间的关系。 于是乎，所有的 Spring 应用程序都使用了这样的配置方式。&lt;/p&gt;
&lt;p&gt;在 Web 开发方面，Spring Framework诞生了 Spring MVC，用来简化 Servlet的开发。 通过AOP实现的路由转换能力，可以快速的把URL映射到一个Bean方法去处理；通过内置常用的编解码转换器，可以避免每次都要写格式转换的代码.. 这些能力，也让 Spring MVC 称为了Java Web开发框架的不二之选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308211951324-767429296.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是发展到了后来，随着 Web开发技术的逐步完善，一个框架集成的模块越来越多，而单一Web应用的功能特性也越来越多了。 此时大家逐渐发现，基于 xml的方式去定义Bean加载，工作量其实很大，而且配置文件逐渐变得臃肿、不好维护，有时候配置出现错误，经常是要排查个半天。 于是乎都用了@Bean、@Autowired注解，还有@ComponentScan 来实现自动化扫描，这些特性大大简化了开发工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308212004905-1460578456.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot 是基于&lt;strong&gt;免配置&lt;/strong&gt;的思路来设计的，也就是说让你不用在配置上花太多时间，所有的东西尽可能都用内置的、现成的。&lt;br/&gt;于是乎，就有了各种各样的 &lt;strong&gt;starter&lt;/strong&gt; 子项目，严格说，这些 starter 只能算是胶水项目(几乎没有代码)，但是它们能让你获得许多开发上的愉悦体验！&lt;br/&gt;下面的这些starter都具备不同的用途：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-starter&lt;br/&gt;　核心启动器，包含了自动配置、日志和YAML。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-web&lt;br/&gt;　引入全栈式Web开发组件，包括Tomcat和spring-webmvc&lt;/li&gt;
&lt;li&gt;spring-boot-starter-thymeleaf&lt;br/&gt;　引入Thymeleaf模板引擎，包括与Spring的集成。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-test&lt;br/&gt;　引入常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-websocket&lt;br/&gt;　引入WebSocket模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-redis&lt;br/&gt;　引入Redis模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-security&lt;br/&gt;　引入 spring-security安全模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-jpa&lt;br/&gt;　引入数据存储层JPA(Java Persistence API)&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-mongodb&lt;br/&gt;　引入MongoDB数据库模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-amqp&lt;br/&gt;　引入spring-rabbitmq客户端来支持AMQP协议&lt;/li&gt;
&lt;li&gt;spring-boot-starter-aop&lt;br/&gt;　引入AOP的编程模块，包括spring-aop和AspectJ&lt;/li&gt;
&lt;li&gt;spring-boot-starter-mail&lt;br/&gt;　引入javax.mail模块&lt;/li&gt;
&lt;li&gt;spring-boot-starter-log4j&lt;br/&gt;　引入Log4J日志框架&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，这些模块化项目是随着SpringBoot版本一起演进的。&lt;br/&gt;2014年4月份，Spring Boot 刚发布了 1.0版本 便 &lt;strong&gt;迅速圈粉&lt;/strong&gt;，接下来1.x 版本经历了4年的演进；&lt;br/&gt;直到2018年3月份，Spring Boot 2.0版本发布，&lt;/p&gt;
&lt;p&gt;下面，是SpringBoot经历过的一些版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring boot 1.1（2014 年 6 月）&lt;/strong&gt;&lt;br/&gt;改进的模板支持，gemfire 支持，elasticsearch 和 apache solr 的自动配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.2（2015 年 3 月）&lt;/strong&gt;&lt;br/&gt;升级到 servlet 3.1 / tomcat 8 / jetty 9，spring 4.1 升级，&lt;br/&gt;支持 banner / jms / SpringBootApplication 注解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.3（2016 年 12 月）&lt;/strong&gt;&lt;br/&gt;升级到 Spring 4.2 ，新的 spring-boot-devtools，&lt;br/&gt;缓存模块实现自动化配置（ehcache，hazelcast，redis 和 infinispan）&lt;br/&gt;支持完全可执行的 jar 支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.4（2017年1月）&lt;/strong&gt;&lt;br/&gt;spring 4.3 升级，支持 couchbase/neo4j，分析启动失败和RestTemplateBuilder。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 1.5（2017年2月）&lt;/strong&gt;&lt;br/&gt;支持 kafka / ldap，第三方库升级，弃用 crash 支持和执行器记录器端点以动态修改应用程序日志级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 2.0（2018 年 03 月）&lt;/strong&gt;&lt;br/&gt;基于 Java 8，支持 Java 9，支持 Quartz ，调度程序大大简化了安全自动配置，支持嵌入式 Netty。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 2.1（2018 年 10 月）&lt;/strong&gt;&lt;br/&gt;支持 Java 11，升级Spring 5.1，应用性能提升，度量模块做了改进。&lt;/p&gt;
&lt;p&gt;其中 Spring Boot 2.0跨度较大，酝酿期也达到1年之多，整个 底层的SpringCore 核心都做了较大的升级(基于Spring 5.0)。&lt;br/&gt;随着 SpringBoot 2.1的发布，2.2即将面世，整个2.0 版本也会趋于稳定。&lt;/p&gt;
&lt;p&gt;其中，对于大多数人比较关心的，是Spring Boot 2都有哪些更新，要不要做升级？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190308212023023-234978169.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;图-Spring之父 Rod Johnson&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二springboot-2-的变化&quot;&gt;二、SpringBoot 2 的变化&lt;/h2&gt;
&lt;p&gt;下面列举了Spring Boot 2.0这个重要版本的一些更新：&lt;/p&gt;
&lt;h4 id=&quot;配置的变更&quot;&gt;1.配置的变更&lt;/h4&gt;
&lt;p&gt;在 2.x 中废除了一些 1.x 中的配置，并增加了许多新配置，详细请查看以下链接中的变更表格。&lt;br/&gt;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog&lt;/p&gt;
&lt;p&gt;此外，关于配置的绑定方式也有些变化：&lt;/p&gt;
&lt;p&gt;在 1.x 中，配置绑定是通过注解 @ConfigurationProperties 来注入到 Spring 环境变量中的。&lt;br/&gt;在 2.x 中，配置绑定功能有了些的改造，在调整了 1.x 中许多不一致地方之外，还提供了独立于注解之外的 API 来装配配置属性。&lt;br/&gt;并增加了属性来源，这样你就能知道这些属性是从哪个配置文件中加载进来的。&lt;/p&gt;
&lt;h4 id=&quot;jdk-版本升级&quot;&gt;2.JDK 版本升级&lt;/h4&gt;
&lt;p&gt;2.x 至少需要 JDK 8 的支持，2.x 里面的许多方法应用了 JDK 8 的许多高级新特性，所以升级到 2.0 版本必须先确认你的应用必须兼容 JDK 8。&lt;br/&gt;另外是 2.x 开始了对 JDK 9 的支持。&lt;/p&gt;
&lt;h4 id=&quot;第三方类库升级&quot;&gt;3.第三方类库升级&lt;/h4&gt;
&lt;p&gt;2.x 对第三方类库升级了所有能升级的稳定版本，一些值得关注的类库：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) Spring Framework 5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2) Tomcat 8.5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3) Flyway 5+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4) Hibernate 5.2+&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;5) Thymeleaf 3+&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;响应式编程支持&quot;&gt;4.响应式编程支持&lt;/h4&gt;
&lt;p&gt;2.x 通过启动器和自动配置全面支持 Spring 的响应式编程，响应式编程是完全异步和非阻塞的，它是基于事件驱动模型，而不是传统的线程模型。&lt;br/&gt;就连 Spring Boot 内部也对一些功能点进行了有必要的响应式升级，最值得注意的是对内嵌式容器的支持。&lt;/p&gt;
&lt;p&gt;对响应式编程支持又包括以下几个技术模块。&lt;/p&gt;
&lt;p&gt;1) Spring WebFlux &amp;amp; WebFlux.fn 支持&lt;br/&gt;2) 响应式 Spring Data 支持&lt;br/&gt;3) 响应式 Spring Security 支持&lt;br/&gt;4) 内嵌式的 Netty 服务器支持&lt;/p&gt;
&lt;h4 id=&quot;data-支持&quot;&gt;5.Data 支持&lt;/h4&gt;
&lt;p&gt;上面有说到对响应式 Spring Data 的支持，除此之外，其他 Data 模块也做了许多更新和提升，具体体现在以下几个地方。&lt;/p&gt;
&lt;p&gt;1) 2.x 默认使用 HikariCP 连接池；&lt;br/&gt;2) 更加合理化的优化了数据库初始化逻辑；&lt;br/&gt;3) spring.jdbc.template 自动配置现在可以通过 spring.jdbc.template 属性定制；&lt;br/&gt;4) 提供了新配置 spring.jdbc.template 方便分页和排序；&lt;br/&gt;5) 对数据库 spring.jdbc.template 自动化配置支持；&lt;br/&gt;6) 可以高级定制 MongoDB 客户端；&lt;br/&gt;7) 可以通过 spring.cache.redis.* 来配置 Redis 缓存默认值。&lt;/p&gt;
&lt;h4 id=&quot;web加强&quot;&gt;6.Web加强&lt;/h4&gt;
&lt;p&gt;除了上面说了 2.x 对响应式框架的支持，还包括以下几个 web 开发改进。&lt;/p&gt;
&lt;p&gt;1) 使用内嵌式容器时，context path 会和端口一起记录并打印出来；&lt;br/&gt;2) 所有支持的容器都支持过滤器的初始化；&lt;br/&gt;3) Thymeleaf 开始支持 javax.time 类型；&lt;br/&gt;4) 提供了一个 spring-boot-starter-json 启动器对 JSON 读写的支持。&lt;/p&gt;
&lt;h4 id=&quot;http2-支持&quot;&gt;7.HTTP/2 支持&lt;/h4&gt;
&lt;p&gt;提供对HTTP/2 的支持，如：Tomcat, Undertow, Jetty，这个得依赖具体选择的应用服务器和应用环境。&lt;/p&gt;
&lt;h4 id=&quot;其他增强&quot;&gt;8.其他增强&lt;/h4&gt;
&lt;p&gt;出了前面的一些变化，还包括以下的一些增强：&lt;br/&gt;&lt;strong&gt;Actuator加强&lt;/strong&gt;&lt;br/&gt;在 2.x 中，对执行器端点进行了许多改进，所有的 HTTP 执行端点现在都暴露在 /actuator路径下，并对 JSON 结果集也做了改善。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gradle 插件&lt;/strong&gt;&lt;br/&gt;Spring Boot的 Gradle 插件全面重写了，并且最小支持 Gradle 4+ 以便提供一些重要的特性提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kotlin&lt;/strong&gt;&lt;br/&gt;2.x 开始提供对 Kotlin 1.2 的支持，并且提供了一个 runApplication 函数来运行 Spring Boot 应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quartz支持&lt;/strong&gt;&lt;br/&gt;2.x 提供了一个 spring-boot-starter-quartz 启动器对定时任务框架 Quartz 的支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试支持&lt;/strong&gt;&lt;br/&gt;在 2.x 中，对测试模块有了一些调整，如自动化的配置增强。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes&quot;&gt;在这里&lt;/a&gt;，可以看到更详细的的版本特性。&lt;/p&gt;
&lt;h2 id=&quot;三要不要升级&quot;&gt;三、要不要升级&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.0 发布至今已经将近一年了，目前来看应该是比较稳定的，而市面上也出现不少基于 SpringBoot 2.0的教程书籍，在这个时间点开始使用是没有问题的。&lt;/p&gt;
&lt;p&gt;A. 如果所在的团队较小，或是对于新的项目，建议可以直接上手；&lt;br/&gt;B. 对于规模较大，或是已经上线一段时间的项目，则需要考虑如下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前的Spring Boot版本是否存在重大的缺陷？&lt;/li&gt;
&lt;li&gt;切换过程产生的人力成本是否可以接受？&lt;/li&gt;
&lt;li&gt;团队中对于新版本的掌握程度如何？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于后者，我更多建议持保守态度，Spring Boot 1.x 尽管目前已经停止更新，但其经历了4年多的迭代完善，目前是使用面最广且最为稳定的。&lt;/p&gt;
&lt;p&gt;如果确实想进行升级，也建议先做好的分析及测试，也可以看看&lt;a href=&quot;https://www.oschina.net/translate/spring-boot-2-0-migration-guide&quot;&gt;SpringBoot 2.0迁移指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为初学者来看，使用 Spring Boot 1.x 还是 2.x 的区别并不大，相比较之下，当下在使用 1.x过程中遇到的一些问题会更容易找到答案。&lt;br/&gt;或许，你可以从下面这篇文章开始学习 Spring Boot。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/9278686.html&quot;&gt;springboot项目基础搭建课&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Fri, 08 Mar 2019 13:21:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 前言 在谈SpringBoot 2.x 之前，先来聊点别的： 首先是Java 语言，这门长期占据编程语言排行榜首位的语言到底有什么魔力？ 大家的看法是多种多样的，比如： 面向对象设计，使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10498344.html</dc:identifier>
</item>
<item>
<title>读《构建之法》——感想 - Brad-Pitt</title>
<link>http://www.cnblogs.com/pittma/p/10467372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pittma/p/10467372.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Fri, 08 Mar 2019 12:51:00 +0000</pubDate>
<dc:creator>Brad-Pitt</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fpittma%2Fp%2F10467372.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
</channel>
</rss>