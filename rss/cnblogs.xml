<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从零开始的PHP生活Day1 - 986244073</title>
<link>http://www.cnblogs.com/yancy9862/p/10153073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yancy9862/p/10153073.html</guid>
<description>&lt;h2 id=&quot;什么是php&quot;&gt;什么是PHP？&lt;/h2&gt;
&lt;p&gt;PHP（Hypertext Preprocessor，超文本预处理器）是一种&lt;strong&gt;服务器端的、跨平台的、HTML嵌入式的弱类型开源脚本语言。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、服务器端：PHP需要使用服务器软件进行编译。&lt;/p&gt;
&lt;p&gt;2、跨平台：PHP支持多种操作系统平台，并且能够被多种服务器软件编译。&lt;/p&gt;
&lt;p&gt;3、HTML嵌入式：PHP代码是编写在HTML代码中的。&lt;/p&gt;
&lt;p&gt;4、弱类型：PHP定义变量时不需要指明数据类型。&lt;/p&gt;
&lt;p&gt;5、开源：即开发源代码，PHP的源代码是向所有人公开的。&lt;/p&gt;
&lt;p&gt;6、脚本语言：PHP是以脚本的方式进行编译的，即只在被调用时进行编译。&lt;/p&gt;
&lt;h2 id=&quot;安装环境&quot;&gt;安装环境&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://phpstudy.php.cn/&quot;&gt;下载phpstudy&lt;/a&gt; &lt;strong&gt;安装路径不要有空格和汉字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;下载vscode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装插件汉化包&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Beautify 用来格式化html js css代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Bracket Pair Colorrizer 用来区分括号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Chinese(Simplified) Language 汉化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Code Runner 用于运行代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Code Spell Checker 用于检测代码语法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Open in browser 用于在浏览器中打开html文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PHP Debug 用于在程序中打断点检测&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;VS Color Picker 用于采集信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;vscode-fileheader 用于生成自定义文件头信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5862031-2b2e63e358c42d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1545316474232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hello.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  echo 'Hello World'; 
 ?&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5862031-6adb873443d7cca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1545316531689.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放在网站根目录 然后浏览器访问&lt;a href=&quot;http://localhost:8080/hello.php&quot; class=&quot;uri&quot;&gt;http://localhost:8080/hello.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果出现Hello World 那么恭喜你!!&lt;/p&gt;
&lt;h2 id=&quot;php标记&quot;&gt;php标记&lt;/h2&gt;
&lt;h3 id=&quot;xml风格的标记-默认&quot;&gt;XML风格的标记 &lt;strong&gt;默认&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;&amp;lt;?php?&amp;gt;```&quot;&gt;
&lt;code&gt;
### 脚本风格的标记&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h3 id=&quot;简短风格标记&quot;&gt;简短风格标记&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;asp风格的标记&quot;&gt;ASP风格的标记&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;php注释&quot;&gt;php注释&lt;/h2&gt;
&lt;h3 id=&quot;单行注释&quot;&gt;单行注释&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
      echo '这是单行注释';    //显示信息。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多行注释&quot;&gt;多行注释&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      /*这是
  ​
      多行
  ​
      注释。*/
  ​
      echo '这是多行注释';
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shell注释&quot;&gt;Shell注释&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      echo '这是Shell注释';    #显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;php输出&quot;&gt;php输出&lt;/h2&gt;
&lt;h3 id=&quot;echo&quot;&gt;echo&lt;/h3&gt;
&lt;p&gt;echo 来输出一个或多个字符串&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;void echo(string $arg1[, string $…]);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;echo没有返回值，其中“$arg1”和“$…”为一系列要输出的字符串对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      echo '使用echo输出字符串';    //使用echo输出字符串。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;print&quot;&gt;print&lt;/h3&gt;
&lt;p&gt;print”来输出一个字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int print(string $arg);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;print的返回值总为“1”，其中“$arg”为要输出的字符串对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;&amp;lt;?php&quot;&gt;
&lt;code&gt;      print '使用print输出字符串';    //使用print输出字符串。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;print和echo的作用基本一样，两者之间的区别在于echo没有返回值而print总是返回“1”，因此echo的执行速度相对来说稍快一些。&lt;/p&gt;
&lt;h3 id=&quot;printf&quot;&gt;printf()&lt;/h3&gt;
&lt;p&gt;printf()”函数来输出格式化的字符串，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;int printf(string $format[, mixed $arg1[, mixed $…]]);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;printf()函数的返回值为字符串长度，其中“$format”为需要输出的字符串，其中需要使用类型指示符来指明输出的格式；“$arg1”和“$…”为可选参数，用于指定一系列要输出的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常用的类型指示符&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%b&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为二进制数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%c&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为对应的ASCII字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%d&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为有符号的十进制数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%f&lt;/td&gt;
&lt;td&gt;将参数当作浮点数，并显示为浮点数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%o&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为八进制数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%s&lt;/td&gt;
&lt;td&gt;将参数当作字符串，并显示为字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%u&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为无符号的进制数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%x&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为小写的十六进制数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%X&lt;/td&gt;
&lt;td&gt;将参数当作整数，并显示为大写的十六进制数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      $num1 = 1;    //定义一个整型变量。
  ​
      $num2 = 2;    //定义一个整型变量。
  ​
      //计算“$num1”与“$num2”之和。
  ​
      $sum = $num1 + $num2;
  ​
      //使用printf()函数输出格式化的字符串。
  ​
      printf('%d + %d = %d', $num1, $num2,$sum);
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;print_r&quot;&gt;print_r()&lt;/h3&gt;
&lt;p&gt;print_r()函数来输出数组结构&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;bool print_r(mixed $expression[, bool $return]);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其中“$expression”为需要输出的数组对象；“$return”为可选参数，用于指定函数的返回值，默认值为“false”表示返回“1”，并直接输出数据结构，若设置为“true”则表示返回一个由数据结构组成的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      $arr = array('this', 'is', 'an', 'array');    //定义一个数组变量。
  ​
      print_r($arr);    //使用print_r()函数输出数组结构。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果“$expression”为整型或字符串等类型的变量，则输出该变量本身；如果“$expression”为数组，则按键值和元素的顺序输出该数组中的所有元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;标量数据类型&quot;&gt;标量数据类型&lt;/h2&gt;
&lt;h3 id=&quot;boolean&quot;&gt;boolean&lt;/h3&gt;
&lt;p&gt;布尔型（boolean）数据类型用于存放一个真（true）或假（false）值，其中“true”和“false”为PHP的内部关键字。&lt;/p&gt;
&lt;p&gt;布尔数据类型&lt;strong&gt;主要用于应用程序的逻辑运算&lt;/strong&gt;，大多使用在条件控制语句或循环控制语句的条件表达式中。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在PHP中不仅仅只有boolean值“false”为假，在一些特殊情况下某些非boolean也会被认为是假，例如：“0”、“0.0”、“'0'”、空白字符串（''）和只有声明却没有赋值的数组等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      $boo = true;    //定义一个布尔型变量，并赋值为“true”。
  ​
      //判断$boo的值是否为“true”。
  ​
     if ($boo == true)
  ​
          echo '变量$boo为真';    //显示信息。
  ​
     else
  ​
          echo '变量$boo为假';    //显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string&quot;&gt;string&lt;/h3&gt;
&lt;p&gt;字符串型（string）数据类型用于存放一个连续的字符序列，即由一连串字符组成的字符串，而这些字符可以是&lt;strong&gt;数字&lt;/strong&gt;、&lt;strong&gt;字母&lt;/strong&gt;、&lt;strong&gt;汉字&lt;/strong&gt;或&lt;strong&gt;符号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在PHP中定义字符串的方法有单引号（'）、双引号（&quot;）和界定符（&amp;lt;&amp;lt;&amp;lt;）三种。&lt;/p&gt;
&lt;h4 id=&quot;单引号&quot;&gt;单引号&lt;/h4&gt;
&lt;p&gt;使用单引号定义字符串，即使用一对 ' 将字符串的字符包含在内。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //定义一个字符串型变量，并赋值为“this is a string”。
  ​
      $str = 'this is a string';
  ​
      echo $str;    //显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;双引号&quot;&gt;&lt;strong&gt;双引号&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用双引号定义字符串，即使用一对 &quot; 将字符串的字符包含在内。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      //定义一个字符串型变量，并赋值为“this is a string”。
  ​
      $str = &quot;this is a string&quot;;
  ​
      echo $str;    //显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;在于：&lt;/p&gt;
&lt;p&gt;1、需要转义的字符不同：在&lt;strong&gt;单引号定义的字符串&lt;/strong&gt;中，&lt;strong&gt;只需要对单引号 ' 进行转义&lt;/strong&gt;；而在&lt;strong&gt;双引号定义的字符串&lt;/strong&gt;中，&lt;strong&gt;还需要对双引号 &quot; 、美元符号 $ 等关键字符进行转义&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2、变量的输出方式不同：使用&lt;strong&gt;单引号定义的字符串&lt;/strong&gt;中所包含的&lt;strong&gt;变量会按照普通字符串输出&lt;/strong&gt;；而使用&lt;strong&gt;双引号定义的字符串&lt;/strong&gt;中所包含的&lt;strong&gt;变量会被自动替换为变量的值&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //定义一个字符串型变量，并赋值为“this is a string”。
  ​
      $str = 'this is a string';
  ​
      echo '使用单引号输出：$str';    //显示信息。
  ​
      echo '&amp;lt;br/&amp;gt;';    //换行。
  ​
      echo &quot;使用双引号输出：$str&quot;;   //显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5862031-cf2605dc5096a3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1545314316426.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;界定符&quot;&gt;&lt;strong&gt;界定符&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;使用界定符定义字符串，即使用一对 &amp;lt;&amp;lt;&amp;lt;str str; 将字符串的字符包含在内，其中 str 为指定的标识符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
      //定义一个字符串型变量，并赋值为“this is a string”。
  ​
      $str = &amp;lt;&amp;lt;&amp;lt;std
  ​
      this is a string
  ​
  std;
  ​
      echo $str;    //显示信息。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;标识符前如果出现其他符号或字符时会发生错误，因此结束标识符必须单独另起一行，且不允许有空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;integer&quot;&gt;integer&lt;/h3&gt;
&lt;p&gt;整型（integer）数据类型用于存放整数，且只能存放整数，存放的整数可以为&lt;strong&gt;正数&lt;/strong&gt;或&lt;strong&gt;负数&lt;/strong&gt;，也可以用&lt;strong&gt;十进制&lt;/strong&gt;、&lt;strong&gt;八进制&lt;/strong&gt;或&lt;strong&gt;十六进制&lt;/strong&gt;来表示。&lt;/p&gt;
&lt;p&gt;如果需要用&lt;strong&gt;八进制&lt;/strong&gt;来表示整型，那么&lt;strong&gt;数字的前面必须加上“0”&lt;/strong&gt;；而如果需要用&lt;strong&gt;十六进制&lt;/strong&gt;来表示整型，那么&lt;strong&gt;数字的前面必须加上“0x”&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在八进制中出现了非法数字（8和9），那么非法数字及其后的所有数字都会被忽略掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果数值超过整型所能表示的最大范围（32位操作系统中最大的整型数值为2147483647，64位操作系统中最大的整型数值为9223372036854775807），就会被当作浮点型处理，而这种情况被称为整数溢出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      //定义一个用十进制表示的整型变量。
  ​
      $num1 = 1234567890;
  ​
      //定义一个用八进制表示的整型变量。
  ​
      $num2 = 01234567890;
  ​
      //定义一个用八进制表示的整型变量。
  ​
      $num3 = 01234567;
  ​
      //定义一个用十六进制表示的整型变量。
  ​
      $num4 = 0x1234567890;
  ​
       //显示信息。
  ​
      echo '数值1234567890不同进制的输出结果：&amp;lt;br/&amp;gt;';
  ​
      echo '十进制的输出结果：'.$num1.'&amp;lt;br/&amp;gt;';
  ​
      echo '第一个八进制的输出结果：'.$num2.'&amp;lt;br/&amp;gt;';
  ​
      echo '第二个八进制的输出结果：'.$num3.'&amp;lt;br/&amp;gt;';
  ​
      echo '十六进制的输出结果：'.$num4;
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;float&quot;&gt;float&lt;/h3&gt;
&lt;p&gt;浮点型（float）数据类型用于存放数值，这个数值可以是&lt;strong&gt;超过整型范围的整数&lt;/strong&gt;，也可以是&lt;strong&gt;小数&lt;/strong&gt;。而浮点型数值的书写格式有两种：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;标准格式&lt;/strong&gt;：如3.1415、-34.56。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;科学计数格式&lt;/strong&gt;：如3.456E1、987.65E-3。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在PHP中浮点型数值只是一个近似值，要尽量避免在浮点型数值之间进行大小比较，因为比较的结果往往是不准确的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //用标准格式定义一个浮点型变量。
  ​
      $num1 = 3.14159265359;
  ​
      //用科学计数格式定义一个浮点型变量。
  ​
      $num2 = 314159265359E-11;
  ​
      //显示信息。
  ​
      echo '圆周率的两种书写格式：&amp;lt;br/&amp;gt;';
  ​
      echo '标准格式：'.$num1.'&amp;lt;br/&amp;gt;';
  ​
      echo '科学计数格式：'.$num2;
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复合数据类型&quot;&gt;复合数据类型&lt;/h2&gt;
&lt;p&gt;复合数据类型&lt;strong&gt;存储的是按照一定规则组成的元素类型的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在PHP中，可以使用array和object两种复合数据类型。&lt;/p&gt;
&lt;h3 id=&quot;数组array&quot;&gt;数组（array）&lt;/h3&gt;
&lt;p&gt;数组（array）是一组数据的集合，即将一系列数据组织起来，形成一个可操作的整体，这些数据可以是&lt;strong&gt;标量数据&lt;/strong&gt;、&lt;strong&gt;数组&lt;/strong&gt;、&lt;strong&gt;对象&lt;/strong&gt;和&lt;strong&gt;资源&lt;/strong&gt;等。&lt;/p&gt;
&lt;p&gt;数组中的&lt;strong&gt;每个数据都被称为一个“元素”&lt;/strong&gt;，元素&lt;strong&gt;包括“索引（键名）”和“值”两个部分&lt;/strong&gt;，而在PHP中&lt;strong&gt;索引可以由数值（数字索引）或字符串（关联索引）组成&lt;/strong&gt;，而&lt;strong&gt;值则可以是多种数据类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在PHP中，定义数组的语法格式有三种：&lt;/p&gt;
&lt;p&gt;1、$array = array('value1', 'value2',……);&lt;/p&gt;
&lt;p&gt;2、$array[key] = 'value';&lt;/p&gt;
&lt;p&gt;3、$array = array(key1 =&amp;gt; 'value1',key2 =&amp;gt; 'value2', ……);&lt;/p&gt;
&lt;p&gt;其中，“key”为数组元素的索引，“value”为数组元素的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      $arr1 = array('this', 'is', 'an','array');    //定义一个数组。
  ​
      print_r($arr1);    //输出数组结构。
  ​
      echo '&amp;lt;br/&amp;gt;';    //换行。
  ​
      //定义一个数组。
  ​
      $arr2[0] = 'this';
  ​
      $arr2[1] = 'is';
  ​
      $arr2[2] = 'an';
  ​
      $arr2[3] = 'array';
  ​
      print_r($arr2);    //输出数组结构。
  ​
      echo '&amp;lt;br/&amp;gt;';    //换行。
  ​
      //定义一个数组。
  ​
      $arr3 = array(0 =&amp;gt; 'this', 1=&amp;gt; 'is', 2 =&amp;gt; 'an', 3 =&amp;gt; 'array');
  ​
      print_r($arr3);    //输出数组结构。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象object&quot;&gt;对象（object）&lt;/h3&gt;
&lt;p&gt;对象（object）就是一组数据和与这组数据相关的操作封装在一起而形成的一个实体。&lt;/p&gt;
&lt;h2 id=&quot;特殊数据类型&quot;&gt;特殊数据类型&lt;/h2&gt;
&lt;p&gt;在PHP中，可以使用resource和null两种特殊数据类型。&lt;/p&gt;
&lt;h3 id=&quot;资源resource&quot;&gt;资源（resource）&lt;/h3&gt;
&lt;p&gt;资源（resource）是一种特殊变量，又称为“句柄”，是对外部资源的一个引用，即需要通过专门的函数来建立和使用，主要用于文件操作、连接数据库或创建图形画布区域等。&lt;/p&gt;
&lt;p&gt;在PHP中，系统会自动启动垃圾回收机制，即自动释放不再使用的资源，避免内存被消耗殆尽，提高应用程序的运行速度。因此，PHP很少需要手工释放资源。&lt;/p&gt;
&lt;h3 id=&quot;空值null&quot;&gt;空值（null）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;空值（null）&lt;/strong&gt;表示没有为&lt;strong&gt;变量设置任何值&lt;/strong&gt;。在PHP中，变量为空值的情况有三种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、在定义变量时，没有为变量赋任何值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、变量被赋值为空值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、被“unset()”函数处理过的变量。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在PHP中，空值不区分大小写，即“null”和“NULL”的效果是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      $null1;    //定义一个变量，但不为其赋值。
  ​
      if (is_null($null1))    //判断变量是否为空值。
  ​
          echo '$null1为空值。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $null2 = null;    //定义一个变量，并为其赋空值。
  ​
      if (is_null($null2))    //判断变量是否为空值。
  ​
          echo '$null2为空值。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $null3 = '空值';    //定义一个变量，并为其赋为“空值”。
  ​
      unset($null3);    //释放变量$null3。
  ​
      if (is_null($null3))    //判断变量是否为空值。
  ​
          echo '$null3为空值。';    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;检测数据类型&quot;&gt;检测数据类型&lt;/h2&gt;
&lt;p&gt;有时根据功能要求，需要&lt;strong&gt;检测某个数据属于哪种类型&lt;/strong&gt;，这时可以通过检测数据类型函数分别针对不同数据类型的数据进行检测，从而&lt;strong&gt;判断数据是否属于某个数据类型&lt;/strong&gt;，即&lt;strong&gt;如果符合返回true，否则返回false&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;针对上述八种数据类型，PHP分别提供了九种基本的检测数据类型的函数：&lt;/p&gt;
&lt;p&gt;1、“is_bool()”函数：检测变量是否属于布尔型。&lt;/p&gt;
&lt;p&gt;2、“is_string()”函数：检测变量是否属于字符串型。&lt;/p&gt;
&lt;p&gt;3、“is_numeric()”函数：检测变量是否是由数字组成的字符串。&lt;/p&gt;
&lt;p&gt;4、“is_integer()”函数：检测变量是否属于整型。&lt;/p&gt;
&lt;p&gt;5、“is_float()”函数：检测变量是否属于浮点型。&lt;/p&gt;
&lt;p&gt;6、“is_null()”函数：检测变量是否为空值。&lt;/p&gt;
&lt;p&gt;7、“is_array()”函数：检测变量是否属于数组类型。&lt;/p&gt;
&lt;p&gt;8、“is_object()”函数：检测变量是否属于对象类型。&lt;/p&gt;
&lt;p&gt;9、“is_resource()”函数：检测变量是否属于资源类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
      $boo = true;    //定义一个布尔型变量。
  ​
      if (is_bool($boo))    //判断变量是否属于布尔型。
  ​
          echo '$boo为布尔型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $str = '123';    //定义一个字符串型变量。
  ​
      if (is_string($str))    //判断变量是否属于字符串型。
  ​
          echo '$str为字符串型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      //判断变量是否是由数字组成的字符串。
  ​
      if (is_numeric($str))
  ​
          //显示结果。
  ​
          echo '$str是由数字组成的字符串。&amp;lt;br/&amp;gt;';
  ​
      $num1 = 123;    //定义一个整型变量。
  ​
      if (is_integer($str))    //判断变量是否属于整型。
  ​
          echo '$num1为整型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $num2 = 1.23;    //定义一个浮点型变量。
  ​
      if (is_float($num2))    //判断变量是否属于浮点型。
  ​
          echo '$float为浮点型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $null;    //定义一个变量，但不为其赋值。
  ​
      if (is_null($null))    //判断变量是否为空值。
  ​
          echo '$null为空值。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      $arr = array('this', 'is', 'an', 'array');    //定义一个数组。
  ​
      if (is_array($arr))    //判断变量是否属于数组类型。
  ​
          echo '$arr为数组。';    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换数据类型&quot;&gt;转换数据类型&lt;/h2&gt;
&lt;p&gt;虽然PHP是一种弱类型的语言，但在实际应用中有时仍需要转换数据类型。在PHP中，转换数据类型的方法有两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、在变量前加上括号，并在括号中写入类型名称。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、使用“&lt;strong&gt;settype()&lt;/strong&gt;”函数转换数据类型，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;bool settype(mixed $var, string $type);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;settype()函数的返回值为布尔值，即转换成功返回“true”，否则返回“false”。其中“$var”为需要改变数据类型的变量；“$type”为需要变成的数据类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      $str = '123.456';    //定义一个字符串型变量。
  ​
      $num = (float)$str;    //将字符串型变量转换为浮点型。
  ​
      if (is_float($num))    //判断变量是否属于浮点型。
  ​
          echo '$num为浮点型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      echo '$num = '.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      //将浮点型变量转换为整型。
  ​
      $boo = settype($num, 'integer');
  ​
      if ($boo)    //判断是否转换成功。
  ​
          echo '转换成功！&amp;lt;br/&amp;gt;';   //显示结果。
  ​
     else
  ​
          echo '转换失败！&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      if (is_integer($num))    //判断变量是否属于整型。
  ​
          echo '$num为整型。&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      echo '$num = '.$num;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;转换数据类型时，是从最左边的一个字符开始进行转换，并只转换符合说要转换类型要求的部分，即如果出现非法字符，非法字符及其后的字符都会被忽略掉，比如：浮点型变量转换为整型时，小数部分会被舍去；字符串型变量转换为整型或浮点型时，如果以数字开头就截取到非数字位，否则为“0”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将变量转换成布尔型时，“null”和“0”会被转换为“false”，其他则转换为“true”；而布尔型变量转换为整型时，“false”转换为“0”，“true”转换为“1”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常量重点&quot;&gt;常量（重点）&lt;/h2&gt;
&lt;p&gt;常量存放的是&lt;strong&gt;值不变化的、固定的数据&lt;/strong&gt;，即在脚本的其他任何位置都&lt;strong&gt;不能修改常量的值&lt;/strong&gt;，比如：圆周率、自然对数底和牛顿引力等。&lt;/p&gt;
&lt;h3 id=&quot;声明常量&quot;&gt;&lt;strong&gt;声明常量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在PHP中，需要使用“define()”函数来&lt;strong&gt;声明常量&lt;/strong&gt;，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;bool define(string $name, mixed $value[, bool $case_insensitive]);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“define()”函数，如果声明成功则返回“true”，否则返回“false”。其中“$name”为常量名；“$value”为常量值；“$case_insensitive”为可选参数，用于指定常量名是否大小写敏感。&lt;/p&gt;
&lt;h3 id=&quot;使用常量&quot;&gt;&lt;strong&gt;使用常量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在PHP中，获取常量的值有两种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用常量名直接获取常量值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）使用&lt;strong&gt;“constant()”&lt;/strong&gt;函数获取&lt;strong&gt;常量值&lt;/strong&gt;，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mixed constant(string $name);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;constant()函数的返回值为常量值。其中“$name”为常量名或存储常量名的变量。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果常量未定义，使用constant()函数获取常量值时，系统会报出错误提示，因此通常使用constant()函数之前需要判断常量是否已经定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;constant()函数和直接使用常量名输出的效果是一样的，但是使用constant()函数可以通过变量动态地输出不同的常量值，在使用上要灵活很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;判断常量是否被定义&quot;&gt;&lt;strong&gt;判断常量是否被定义&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在PHP中，使用“&lt;strong&gt;defined()&lt;/strong&gt;”函数判断&lt;strong&gt;常量是否被定义&lt;/strong&gt;，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;bool defined(string $name);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“defined()”函数，如果常量已经被定义则返回“true”，否则返回“false”。其中“$name”为常量名或存储常量名的变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      define(CONSTANT, '常量');    //定义一个常量。
  ​
      //定一个字符串型变量，存放常量名。
  ​
      $name = 'CONSTANT';
  ​
      echo CONSTANT. '&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      //判断常量是否被定义。
  ​
     $boo = defined($name);
  ​
     if ($boo)
  ​
      {
  ​
          echo '常量已被定义！&amp;lt;br/&amp;gt;';   //显示结果。
  ​
          echo constant($name);    //显示结果。
  ​
      }
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预定义常量&quot;&gt;&lt;strong&gt;预定义常量&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在PHP中，除了可以声明自定义常量外，还可以使用预定义常量来获取PHP中的信息，常用的预定义常量如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;FILE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;默认常量，PHP程序文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;LINE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;默认常量，PHP程序行数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PHP_VERSION&lt;/td&gt;
&lt;td&gt;内建常量，PHP程序的版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PHP_OS&lt;/td&gt;
&lt;td&gt;内建常量，执行PHP解析器的操作系统名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;真值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;假值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;空值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;E_ERROR&lt;/td&gt;
&lt;td&gt;指到最近的错误处&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;E_WARNING&lt;/td&gt;
&lt;td&gt;指到最近的警告处&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E_PARSE&lt;/td&gt;
&lt;td&gt;指到解析语法有潜在问题处&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E_NOTICE&lt;/td&gt;
&lt;td&gt;发生不寻常处的提示，但不一定是错误处&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“&lt;strong&gt;FILE&lt;/strong&gt;”和“&lt;strong&gt;LINE&lt;/strong&gt;”中的“__”是两条下划线，而不是一条下划线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;表中以“E_”开头的预定义常量是PHP的错误调试部分。如需详细了解，请参考“error_reporting()函数”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用预定义常量的方法与使用自定义常量的方法相同，没有什么差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;变量重点&quot;&gt;变量（重点）&lt;/h2&gt;
&lt;p&gt;变量与常量正好相反，它用于存放的是&lt;strong&gt;可变的数据&lt;/strong&gt;，即在程序执行过程中变量的值&lt;strong&gt;可以发生变化&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;声明和使用变量&quot;&gt;声明和使用变量&lt;/h3&gt;
&lt;p&gt;在声明变量时，系统会为程序中的每一个变量分配一个存储单元，这些变量都是使用“变量名”来标识，即变量名实质上就是计算机内存单元的名称，因此通过变量名即可访问内存中的数据。&lt;/p&gt;
&lt;p&gt;在PHP中，使用变量之前并不需要进行声明，即只需要为变量赋值，而PHP的&lt;strong&gt;变量名&lt;/strong&gt;用“&lt;strong&gt;$&lt;/strong&gt;”和&lt;strong&gt;标识符&lt;/strong&gt;表示，且区分大小写。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;变量名的标识符不能以数字字符开头，也不能以字母和下划线以外的其他字符开头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量赋值就是给变量一个具体的数据值，通常是通过赋值运算符来实现的，在PHP中为变量赋值的方法有三种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、直接赋值：直接将数据值赋值给变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、变量间赋值：将一个变量的数据值赋值给另一个变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、引用赋值：使用“&amp;amp;”符号将一个变量的内存地址传给另一个变量&lt;/strong&gt;，即再为该内存中的数据起一个“别名”。当改变其中一个变量的值时，另一个变量也会跟着发生变化。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;变量间赋值和引用赋值之间的区别在于，变量间赋值是开辟一个新的内存空间，并复制原变量内容；引用赋值这是给原变量内容另起一个变量名，二者使用的是同一内存空间。‍‍&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
  ​
      $str1 = 'str1';    //直接赋值。
  ​
     echo '$str1的值：'.$str1.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      $str2 = $str1;    //变量间赋值。
  ​
     echo '$str2的值：'.$str2.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      $str3 = &amp;amp; $str1;    //引用赋值。
  ​
     echo '$str3的值：'.$str3.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      $str1 = 'str2';    //修改变量的值。
  ​
     echo '$str1的值：'.$str1.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     echo '$str2的值：'.$str2.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     echo '$str3的值：'.$str3;    //显示结果。
  //定义一个值为“str1”变量“$str1”，然后将该变量的值赋值给另一个变量“str2”，再将该变量引用给另一个变量“$str3”，最后输出结果。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;变量的作用域&quot;&gt;变量的作用域&lt;/h3&gt;
&lt;p&gt;变量的作用域是指能够使用&lt;strong&gt;变量的有效范围&lt;/strong&gt;，&lt;strong&gt;变量必须在其有效范围内使用，否则就会失去其意义&lt;/strong&gt;。在PHP中，变量的作用域有三种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、局部变量：变量定义在函数内部，其作用域为所在函数。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：局部变量在函数调用结束以后，其存储的数据就会被立即清除，内存空间也会被释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、全局变量：变量定义在所有函数以外，其作用域为整个PHP文件。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果需要在自定义函数内部使用全局变量，那么则要使用关键字“global”在调用全局变量时进行声明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3、静态变量：能够在函数调用结束之后保留变量值，当再次回到其作用域时，可以继续使用保留的变量值。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：静态变量需要使用关键字“static”来进行声明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //定义一个全局变量。
  ​
      $str = '全局变量：在函数以外输出。';
  ​
      //定义一个自定义函数。
  ​
     function example()
  ​
      {
  ​
          //定义一个局部变量。
  ​
          $str = '局部变量：调用函数时输出。';
  ​
          echo $str.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      }
  ​
      example();    //调用函数。
  ​
     echo $str;    //显示结果。
  //在函数内外定义并输出变量名相同的局部变量“局部变量：调用函数时输出”和全局变量“全局变量：在函数以外输出”。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
  ​
      $str = '全局变量';    //定义一个全局变量。
  ​
      //定义一个自定义函数。
  ​
     function example()
  ​
      {
  ​
          echo '直接使用全局变量：'.$str.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
          global $str;    //使用关键字“global”调用全局变量。
  ​
          echo '通过global使用全局变量：'.$str;    //显示结果。
  ​
      }
  ​
      example();    //调用函数。
  //在自定义函数内使用并输出值为“全局变量”的全局变量。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个自定义函数。
  ​
     function example1()
  ​
      {
  ​
          $num = 0;    //定义一个普通变量。
  ​
          $num++;    //递增。
  ​
          echo $num.' ';    //显示结果。
  ​
      }
  ​
      //定义一个自定义函数。
  ​
     function example2()
  ​
      {
  ​
          static $num = 0;    //定义一个静态变量。
  ​
          $num++;    //递增。
  ​
          echo $num.' ';    //显示结果。
  ​
      }
  ​
      echo '普通变量输出：';    //显示结果。
  ​
      //循环10次。
  ​
      for ($i = 0; $i &amp;lt; 10; $i++)
  ​
      {
  ​
          example1();    //调用函数。
  ​
      }
  ​
      echo '&amp;lt;br/&amp;gt;静态变量输出：';    //显示结果。
  ​
      //循环10次。
  ​
      for ($i = 0; $i &amp;lt; 10; $i++)
  ​
      {
  ​
          example2();    //调用函数。
  ​
      }
  //分别使用普通变量和静态变量在自定义函数中输出递增数字。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可变变量&quot;&gt;可变变量&lt;/h3&gt;
&lt;p&gt;可变变量是一种非常特殊的变量，它允许动态地改变一个变量的名称，即可变变量的名称由另一个变量的值来确定。&lt;/p&gt;
&lt;p&gt;在PHP中，在变量的前面再加上一个“$”即可实现可变变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      $str1 = 'str2';    //定义一个字符串型变量。
  ​
      $str2 = '可变变量';    //定义一个字符串型变量。
  ​
      echo '$str1的值：'.$str1.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      echo '$str2的值：'.$str1.'&amp;lt;br/&amp;gt;';    //显示结果。
  //定义并输出一个值为“可变变量”的可变变量。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;‍‍说明：“$$str1”为可变变量，在执行时，首先将“$str1”解析为值“str2”，然后再解析“$str2”，最后将值输出。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;预定义变量&quot;&gt;预定义变量&lt;/h3&gt;
&lt;p&gt;在PHP中，除了可以使用自定义变量外，还可以使用预定义变量来获取用户会话、用户操作系统环境和本地操作系统环境等信息，常用的预定义变量如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['SERVER_ADDR']&lt;/td&gt;
&lt;td&gt;当前运行脚本所在服务器的IP地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['SERVER_NAME']&lt;/td&gt;
&lt;td&gt;当前运行脚本所在服务器的主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['SERVER_POST']&lt;/td&gt;
&lt;td&gt;服务器所使用的端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;$_SERVER['SERVER_SIGNATURE']&lt;/td&gt;
&lt;td&gt;包含服务器版本和虚拟主机名的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;$_SERVER['REQUEST_METHOD']&lt;/td&gt;
&lt;td&gt;访问页面时的请求方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['REMOTE_ADDR']&lt;/td&gt;
&lt;td&gt;正在浏览当前页面用户的IP地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['REMOTE_HOST']&lt;/td&gt;
&lt;td&gt;正在浏览当前页面用户的主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SERVER['REMOTE_PORT']&lt;/td&gt;
&lt;td&gt;用户连接到服务器时所使用的端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;$_SERVER['SCRIPT_FILENAME']&lt;/td&gt;
&lt;td&gt;当前执行脚本的绝对路径名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;$_SERVER['DOCUMENT_ROOT']&lt;/td&gt;
&lt;td&gt;指当前运行脚本所在的文档根目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_COOKIE&lt;/td&gt;
&lt;td&gt;通过HTTPCookie传递到脚本的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_SESSION&lt;/td&gt;
&lt;td&gt;包含与所有会话变量有关的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_POST&lt;/td&gt;
&lt;td&gt;包含通过POST方法传递的参数的相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$_GET&lt;/td&gt;
&lt;td&gt;包含通过GET方法传递的参数的相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$GLOBALS&lt;/td&gt;
&lt;td&gt;由所有已定义全局变量组成的数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;运算符重点&quot;&gt;运算符（重点）&lt;/h2&gt;
&lt;h3 id=&quot;算数运算符&quot;&gt;算数运算符&lt;/h3&gt;
&lt;p&gt;算术运算符就是处理算术运算的符号，即对数字数据进行&lt;strong&gt;加&lt;/strong&gt;、&lt;strong&gt;减&lt;/strong&gt;、&lt;strong&gt;乘&lt;/strong&gt;、&lt;strong&gt;除&lt;/strong&gt;和&lt;strong&gt;取余&lt;/strong&gt;等运算。算术运算符是数字处理中应用最多的、最常用的运算符，PHP中的算术运算符如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加法运算符&lt;/td&gt;
&lt;td&gt;$a + $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减法运算符&lt;/td&gt;
&lt;td&gt;$a - $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘法运算符&lt;/td&gt;
&lt;td&gt;$a * $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除法运算符&lt;/td&gt;
&lt;td&gt;$a / $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取余运算符&lt;/td&gt;
&lt;td&gt;$a % $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;递增运算符&lt;/td&gt;
&lt;td&gt;$a++、++$a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;递减运算符&lt;/td&gt;
&lt;td&gt;$a--、--$a&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;‍‍说明：使用“%”取余时，如果被除数（$a）是负数，那么得到的结果也是负数。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;‍‍说明：递增/递减运算符有两种使用方法，一种是将运算符放在变量后面，即先返回变量的当前值，再见变量的当前值增加/减少1；另一种是将运算符放在变量前面，即先将变量增加或减少1，再赋值给原变量。‍‍&lt;/p&gt;
&lt;p&gt;``` &amp;lt;?php&lt;br/&gt;​&lt;br/&gt;  //设置编码格式，正确显示中文。&lt;br/&gt;​&lt;br/&gt;  header(&quot;content-Type:text/html; charset=gb2312&quot;);&lt;br/&gt;​&lt;br/&gt;  $num1 = 10;   //定义一个整型变量。&lt;br/&gt;​&lt;br/&gt;  $num2 = 5;   //定义一个整型变量。&lt;br/&gt;​&lt;br/&gt;  $num3 = 3;   //定义一个整型变量。&lt;br/&gt;​&lt;br/&gt;  $num4 = 2;   //定义一个整型变量。&lt;br/&gt;​&lt;br/&gt;  //显示结果。&lt;br/&gt;​&lt;br/&gt;  echo '$num1 = '.$num1.', $num2 = '.$num2. ', $num3 = '.$num3. ', $num4 ='.$num4.'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num1 + $num2 = '.($num1 + $num2).'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num1 - $num2 = '.($num1 - $num2).'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num3 * $num4 = '.($num3 * $num4).'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num1 / $num4 = '.($num1 / $num4).'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num1 % $num3 = '.($num1 % $num3).'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num1++ = '.$num1++.'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '$num2-- = '.$num2--.'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '++$num3 = '.++$num3.'&lt;br/&gt;';&lt;br/&gt;​&lt;br/&gt;  echo '--$num4 = '.--$num3;&lt;br/&gt;//使用算术运算符对四个值分别为“10”、“5”、“3”和“2”的变量进行算术运算。&lt;br/&gt;?&amp;gt;&lt;/p&gt;
&lt;p&gt;​```&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;字符串运算符&quot;&gt;字符串运算符&lt;/h3&gt;
&lt;p&gt;字符串运算符的作用是将两个字符串连接起来，并结合成一个新的字符串。在PHP中，字符串运算符只有一个，即英文句号“.”。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：与C语言和Java语言不同，PHP中的“+”只能作为算术运算符使用，而不能作为字符串运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;&amp;lt;?php&quot;&gt;
&lt;code&gt;  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
     $str1 = '字符串';    //定义一个字符串型变量。
  ​
     $str2 = '运算符';    //定义一个字符串型变量。
  ​
      //显示结果。
  ​
     echo '$str1 = '.$str1.', $str2 = '.$str2.'&amp;lt;br/&amp;gt;';
  ​
     echo '$str1.$str2 = '.($str1.$str2);
  //使用字符串运算符连接值为“字符串”和“运算符”两个字符串变量，并输出组合成的新字符串。
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;赋值运算符&quot;&gt;赋值运算符&lt;/h3&gt;
&lt;p&gt;赋值运算符的作用是将右边的值赋值给左边的变量。PHP中的赋值运算符如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;$a = $b&lt;/td&gt;
&lt;td&gt;$a = $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;+=&lt;/td&gt;
&lt;td&gt;加赋值&lt;/td&gt;
&lt;td&gt;$a += $b&lt;/td&gt;
&lt;td&gt;$a = $a + $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-=&lt;/td&gt;
&lt;td&gt;减赋值&lt;/td&gt;
&lt;td&gt;$a -= $b&lt;/td&gt;
&lt;td&gt;$a = $a - $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;*=&lt;/td&gt;
&lt;td&gt;乘赋值&lt;/td&gt;
&lt;td&gt;$a *= $b&lt;/td&gt;
&lt;td&gt;$a = $a * $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;/=&lt;/td&gt;
&lt;td&gt;除赋值&lt;/td&gt;
&lt;td&gt;$a /= $b&lt;/td&gt;
&lt;td&gt;$a = $a / $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;%=&lt;/td&gt;
&lt;td&gt;取余赋值&lt;/td&gt;
&lt;td&gt;$a %= $b&lt;/td&gt;
&lt;td&gt;$a = $a % $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;.=&lt;/td&gt;
&lt;td&gt;连接赋值&lt;/td&gt;
&lt;td&gt;$a .= $b&lt;/td&gt;
&lt;td&gt;$a = $a.$b&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
     $num = 1;    //将“1”赋值给变量“$num”。
  ​
     echo '$num = '.$num.'&amp;lt;br/&amp;gt;';   //显示结果。
  ​
     $num += 1;    //将“$num”加“1”后赋值给“$num”。
  ​
     echo '$num += 1的结果：'.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     $num -= 1;    //将“$num”减“1”后赋值给“$num”。
  ​
     echo '$num -= 1的结果：'.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     $num *= 2;    //将“$num”乘“2”后赋值给“$num”。
  ​
     echo '$num *= 2的结果：'.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     $num /= 2;    //将“$num”除“2”后赋值给“$num”。
  ​
     echo '$num /= 2的结果：'.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      //将“$num”除“2”取余后赋值给“$num”。
  ​
     $num %= 2;
  ​
     echo '$num %= 2的结果：'.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     $str = '赋值';    //定义一个字符串型变量。
  ​
     echo '$str = '.$str.'&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      //将“$str”连接“运算符”后赋值给“$str”。
  ​
     $str .= '运算符';
  ​
     echo '$str .= \'运算符\'的结果：'.$str;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;逻辑运算符&quot;&gt;逻辑运算符&lt;/h3&gt;
&lt;p&gt;逻辑运算符的作用是将多个逻辑命题连接成更复杂的逻辑命题，从而进行实现逻辑判断，&lt;strong&gt;主要用在条件控制语句的判断表达式中&lt;/strong&gt;。PHP中的逻辑运算符如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;amp;&amp;amp;或and&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;$a &amp;amp;&amp;amp; $b或$a and $b&lt;/td&gt;
&lt;td&gt;$a和$b都为真&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;||或or&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;$a || $b或$a or $b&lt;/td&gt;
&lt;td&gt;$a为真或$b为真&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;xor&lt;/td&gt;
&lt;td&gt;异或&lt;/td&gt;
&lt;td&gt;$a xor $b&lt;/td&gt;
&lt;td&gt;$a、$b一真一假&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;td&gt;!$a&lt;/td&gt;
&lt;td&gt;$a为假&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：“&amp;amp;&amp;amp;”与“and”、“||”与“or”虽然能够进行同样的逻辑运算，但是它们之间的优先级是不同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
     $boo1 = true;    //定义一个布尔型变量。
  ​
     $boo2 = false;    //定义一个布尔型变量。
  ​
      //显示结果。
  ​
     echo '$boo1 = '.var_export($boo1, true).', $boo2 = '.var_export($boo2,tru
  ​
  e).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 &amp;amp;&amp;amp; $boo2 = '.var_export($boo1 &amp;amp;&amp;amp; $boo2,true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 &amp;amp;&amp;amp; $boo1 = '.var_export($boo1 &amp;amp;&amp;amp; $boo1,true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo2 &amp;amp;&amp;amp; $boo2 = '.var_export($boo2 &amp;amp;&amp;amp; $boo2,true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 || $boo2 = '.var_export($boo1 || $boo2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 || $boo1 = '.var_export($boo1 || $boo1, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo2 || $boo2 = '.var_export($boo2 || $boo2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 xor $boo2 = '.var_export($boo1 xor $boo2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo1 xor $boo1 = '.var_export($boo1 xor $boo1, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$boo2 xor $boo2 = '.var_export($boo2 xor $boo2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '!$boo1 = '.var_export(!$boo1, true);
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较运算符重点&quot;&gt;比较运算符（重点）&lt;/h3&gt;
&lt;p&gt;比较运算符的作用是对变量或表达式的结果进行大小、真假等的比较，&lt;strong&gt;如果比较结果为真，则返回“true”，如果比较结果为假，则返回“false”&lt;/strong&gt;。PHP中的比较运算符如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;td&gt;$a &amp;lt; $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;td&gt;$a &amp;gt; $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;td&gt;$a &amp;lt;= $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;td&gt;$a &amp;gt;= $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;相等&lt;/td&gt;
&lt;td&gt;$a == $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等&lt;/td&gt;
&lt;td&gt;$a != $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;===&lt;/td&gt;
&lt;td&gt;恒等&lt;/td&gt;
&lt;td&gt;$a === $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;!==&lt;/td&gt;
&lt;td&gt;非恒等&lt;/td&gt;
&lt;td&gt;$a !== $b&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：恒等“===”表示变量不仅在数值上相等，而且数据类型也是一致的；非恒等“!==”表示变量数值或数据类型不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
     $num = 3;    //定义一个整型变量。
  ​
      //显示结果。
  ​
     echo '$num = '.$num.'&amp;lt;br/&amp;gt;';
  ​
     echo '$num &amp;lt; 4的结果：'.var_export($num &amp;lt; 4, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num &amp;gt; 2的结果：'.var_export($num &amp;gt; 2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num &amp;lt;= 4的结果：'.var_export($num &amp;lt;= 2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num &amp;gt;= 2的结果：'.var_export($num &amp;gt;= 2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num == 3的结果：'.var_export($num == 3, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num != 2的结果：'.var_export($num == 2, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num === 3的结果：'.var_export($num == 3, true).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num !== \'3\'的结果：'.var_export($num !== '3', true);
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;错误控制运算符重点&quot;&gt;错误控制运算符（重点）&lt;/h3&gt;
&lt;p&gt;错误控制运算符是PHP中独特的一种运算符，其作用是对程序中出现错误的表达式进行操作，即对错误信息进行屏蔽。在PHP中，在错误的表达式前面加上错误控制运算符“@”即可屏蔽错误信息。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：错误控制运算符只能屏蔽错误信息，而不能真正地解决错误。因此错误控制运算符通常用来屏蔽一些不影响程序运行的非必要错误信息，而影响程序运行的重要错误信息不推荐使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;&amp;lt;?php&quot;&gt;
&lt;code&gt;  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
     $num1 = (5 / 0);    //定义一个整型变量。
  ​
     $num2 = @ (5 / 0);    //定义一个整型变量。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5862031-5dd3f2017e440c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1545315660799.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三元运算符&quot;&gt;三元运算符&lt;/h3&gt;
&lt;p&gt;三元运算符，也成为三目运算符，其作用是根据一个表达式在另外两个表达式中选择一个来执行，语法格式如下：&lt;/p&gt;
&lt;p&gt;表达式1?表达式2:表达式3;&lt;/p&gt;
&lt;p&gt;如果表达式1的结果为真，执行表达式2，如果表达式1的结果为假，则执行表达式3。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;‍‍说明：三元运算符最好放在括号中使用。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //显示结果。
  ​
     echo (true?'表达式1为真':'表达式1为假');
  ​
      echo '&amp;lt;br/&amp;gt;';
  ​
     echo (false?'表达式1为真':'表达式1为假');
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;位运算符&quot;&gt;位运算符&lt;/h3&gt;
&lt;p&gt;位运算符的作用将二进制位从低位到高位对齐后进行运算。PHP中的位运算符如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;td&gt;$a &amp;amp; $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;按位或&lt;/td&gt;
&lt;td&gt;$a | $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;td&gt;$a ^ $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;按位取反&lt;/td&gt;
&lt;td&gt;~$a&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;向左移位&lt;/td&gt;
&lt;td&gt;$a &amp;lt;&amp;lt; $b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;向右移位&lt;/td&gt;
&lt;td&gt;$a &amp;gt;&amp;gt; $b&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt; &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      $num1 = 13;    //定义一个整型变量。
  ​
      $num2 = 11;    //定义一个整型变量。
  ​
      //显示结果。
  ​
     echo '$num1 = '.$num1.', $num2 = '.$num2.'&amp;lt;br/&amp;gt;';
  ​
     echo '$num1 &amp;amp; $num2 = '.($num1 &amp;amp; $num2).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num1 | $num2 = '.($num1 | $num2).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num1 ^ $num2 = '.($num1 ^ $num2).'&amp;lt;br/&amp;gt;';
  ​
     echo '~$num1 = '.(~$num1).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num1 &amp;lt;&amp;lt; 1 = '.($num1 &amp;lt;&amp;lt; 1).'&amp;lt;br/&amp;gt;';
  ​
     echo '$num1 &amp;gt;&amp;gt; 1 = '.($num1 &amp;gt;&amp;gt; 1);
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：“13”的二进制原码为“0000 1101”，“11”的二进制原码为“0000 1011”，“9”的二进制原码为“0000 1001”，“15”的二进制原码为“0000 1111”，“6”的二进制原码为“0000 0110”，“-14”的二进制补码为“1111 0010”，“26”的二进制原码为“0001 1010”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;运算符的优先级&quot;&gt;运算符的优先级&lt;/h3&gt;
&lt;p&gt;表达式可能是由多个不同的运算符连接起来的，不同的运算符顺序可能得出不同结果，甚至出现错误运算错误，因此必须按一定顺序进行结合，才能保证运算的合理性和结果的正确性、唯一性。&lt;/p&gt;
&lt;p&gt;运算符优先级就是在表达式中哪一个运算符先计算、哪一个后计算，其遵循的规则是：&lt;/p&gt;
&lt;p&gt;1、优先级高的操作先执行，优先级低的操作后执行。&lt;/p&gt;
&lt;p&gt;2、同一优先级的操作按照从左到右的顺序执行。&lt;/p&gt;
&lt;p&gt;3、括号内的操作最先执行。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;‍‍说明：由于括号的优先级最高，因此在运算符较多的表达式中，不妨多使用括号。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运算符的优先级&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;++、--、~、@&lt;/td&gt;
&lt;td&gt;右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;*、/、%&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;+、-&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&amp;lt;&amp;lt;、&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;==、!=、===、!==&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;?:&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;=、+=、-=、*=、/=、.=、%=&lt;/td&gt;
&lt;td&gt;右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;xor&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;左&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;‍‍说明：优先级别的数值越小，运算符的优先级越高。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;表达式和函数&quot;&gt;表达式和函数&lt;/h2&gt;
&lt;h3 id=&quot;表达式&quot;&gt;表达式&lt;/h3&gt;
&lt;p&gt;表达式是通过具体的代码来实现的，即由多个符号集合起来组成的代码，是构成PHP程序语言的基本元素，也是PHP最重要的组成元素。&lt;/p&gt;
&lt;p&gt;组成表达式的符号是对PHP解释程序有具体含义的最小单元，可以是变量名、函数名、运算符和数值等。&lt;/p&gt;
&lt;p&gt;表达式和语句之间的区别在于分号“;”，即&lt;strong&gt;一个表达式之后加上一个分号之后就是一条语句&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：在编写程序时，必须注意不要漏写语句的分号“;”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;
&lt;p&gt;函数就是&lt;strong&gt;将一些需要重复使用的功能代码写在一个独立的代码块中&lt;/strong&gt;，并&lt;strong&gt;在需要时单独调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在PHP中，使用关键字“function”定义函数，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;functionfun_name([mixed $arg1[, mixed $…]])&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;fun_body;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中“fun_name”为函数名；“$arg1”和“$…”为函数的参数；“fun_body”为函数的主体，即功能实现代码。&lt;/p&gt;
&lt;p&gt;在函数定义好之后，只需要&lt;strong&gt;使用函数名并赋予正确的参数&lt;/strong&gt;，即可调用函数，语法格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;fun_name([mixed $arg1[, mixed $…]]);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中“fun_name”为函数名；“$arg1”和“$…”为赋予函数的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function example($str)
  ​
      {
  ​
          echo $str;    //显示结果。
  ​
      }
  ​
      example('定义和调用函数');    //调用函数。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义函数时，还有一种参数的设置方式，即可选参数，也就是可以指定某个参数为可选参数。在PHP中，将参数放在参数列表末位，并指定其默认值，即可指定可选参数。&lt;/p&gt;
&lt;p&gt;调用函数时，如果设置了可选参数值，那么可选参数的值为调用时的设定值；如果没有设置可选参数值，那么可选参数的值为定义时的默认值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function example($num1, $num2 =2)
  ​
      {
  ​
          //显示结果。
  ​
          echo '$num1 = '.$num1.',$num2 = '.$num2.'&amp;lt;br/&amp;gt;';
  ​
          echo '$num1 * $num2 * 2 ='.($num1 * $num2 * 2);
  ​
      }
  ​
      echo 'exmaple(1,3)&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      example(1, 3);    //调用函数。
  ​
      echo '&amp;lt;br/&amp;gt;';    //换行。
  ​
      echo'exmaple(1)&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      example(1);    //调用函数。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据是如何在函数间传递的&quot;&gt;数据是如何在函数间传递的?&lt;/h4&gt;
&lt;p&gt;在定义和调用函数时存在着两种参数：形参和实参。形参是定义函数时定义的参数；实参是调用函数时传入的参数。也就是说，&lt;strong&gt;调用函数时，需要将实参的值传递给形参&lt;/strong&gt;。在PHP中，实参与形参之间数据传递的方式有两种：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;按值传递&lt;/strong&gt;：按值传递就是将实参的值赋值给对应的形参，在函数主体的操作都是针对形参进行，操作的结果不会影响到实参，即&lt;strong&gt;函数返回之后，实参的值不会改变&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function example($num)
  ​
      {
  ​
          $num *= 2;    //进行算术运算。
  ​
          echo '形参：$num = '.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      }
  ​
      $num = 1;    //定义一个整形变量。
  ​
     echo '实参：$num = '.$num.'&amp;lt;br/&amp;gt;';   //显示结果。
  ​
      example($num);    //调用函数。
  ​
     echo '函数调用之后的实参：$num = '.$num;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、&lt;strong&gt;按引用传递&lt;/strong&gt;：按引用传递就是将实参的内存地址传递给对应的形参，在函数主体针对形参进行的操作都会影响到实参，即&lt;strong&gt;函数返回之后，实参的值会发生改变&lt;/strong&gt;。引用传递参数的方式需要在定义函数时在形参前面加上“&amp;amp;”符号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function example(&amp;amp;$num)
  ​
      {
  ​
          $num *= 2;    //进行算术运算。
  ​
          echo '形参：$num = '.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      }
  ​
      $num = 1;    //定义一个整形变量。
  ​
     echo '实参：$num = '.$num.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
      example($num);    //调用函数。
  ​
     echo '函数调用之后的实参：$num = '.$num;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;返回函数的操作结果&quot;&gt;返回函数的操作结果&lt;/h4&gt;
&lt;p&gt;在实际开发中，经常需要将函数的操作结果返回给调用者。在PHP中，通常使用关键字“return”来&lt;strong&gt;返回函数的操作结果&lt;/strong&gt;，语法格式如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;return mixed $value;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“return”会将程序控制权返回到调用者的作用域，并将函数的操作结果“$value”返回给调用者。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：关键字“return”只能返回一个值，如果需要函数返回多个值，可以使用数组来返回值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：如果在全局作用域中使用关键字“return”，那么会终止脚本的执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;变量函数&quot;&gt;变量函数&lt;/h4&gt;
&lt;p&gt;变量函数和可变变量非常相似，可以通过变量来调用，即根据变量的值来调用相应的函数。&lt;/p&gt;
&lt;p&gt;在PHP中，在变量名后面加上一对小括号，并在其中赋予正确的参数，即可实现变量函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function example()
  ​
      {
  ​
          echo '变量函数';    //显示结果。
  ​
     }
  ​
      $str = 'example';    //定义一个字符串型变量。
  ​
     $str();    //调用变量函数。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;‍‍说明：“$str()”为变量函数，在执行时，首先将“$str”解析为值“example”，然后再调用函数“example()”。‍‍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;引用函数&quot;&gt;引用函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function &amp;amp;example()
  ​
      {
  ​
          return '引用函数';    //返回结果。
  ​
      }
  ​
      $str = &amp;amp;example();    //对函数进行引用。
  ​
     echo $str;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当不需要对函数继续引用时，可以使用“unset()”函数取消对函数的引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;?php
  ​
      //设置编码格式，正确显示中文。
  ​
      header(&quot;content-Type:text/html; charset=gb2312&quot;);
  ​
      //定义一个函数。
  ​
      function &amp;amp;example()
  ​
      {
  ​
          return '引用函数';    //返回结果。
  ​
      }
  ​
      $str = &amp;amp;example();    //对函数进行引用。
  ​
     echo $str.'&amp;lt;br/&amp;gt;';    //显示结果。
  ​
     unset($str);    //取消引用。
  ​
     echo $str;    //显示结果。
  ​
  ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Dec 2018 15:12:00 +0000</pubDate>
<dc:creator>986244073</dc:creator>
<og:description>PHP 什么是PHP？ PHP（Hypertext Preprocessor，超文本预处理器）是一种 服务器端的、跨平台的、HTML嵌入式的弱类型开源脚本语言。 1、服务器端：PHP需要使用服务器软件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yancy9862/p/10153073.html</dc:identifier>
</item>
<item>
<title>新建项目加入到生成流水线中 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10152992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10152992.html</guid>
<description>&lt;p&gt; 　　&lt;strong&gt;整个生成流水线已经搭建完毕了，这一次来从零开始融入到生成流水线中，从仓库建立到镜像生成整个过程，对于之前几篇文章的一次应用过程，注意，本次建立过程是保证在前期基础搭建完毕后的应用阶段，本次搭建过程较为简单，只作为参考示例，并无技术含量。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、码云中新建项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1、在码云中新建一个项目，取名为Standard，作为一个示例项目名，仓库地址：&lt;a href=&quot;https://gitee.com/530521314/Standard.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/Standard.git&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220214746090-2119640084.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;620&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2、将仓库拉取到本地，开始在本地构建项目，我直接使用VS的Git工具&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220215056485-1922946612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、新建解决方案+项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1、新建空白解决方案，指定方案名和路径地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220215325259-1351666350.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;532&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2、添加src文件夹到解决方案下(用于项目结构上区分)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220215728705-701332722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、添加应用程序，选择Asp.Net Core Web应用程序&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220221254006-20773118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;此处直接新建项目的位置为src文件夹下，主要是为了标准化搭建，前期文章也提及了。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;三、配置需要的脚本文件&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1、增加docker compose，选中项目右键添加-&amp;gt;容器业务流程协助程序支持，弹框内选择目标平台，此处我选择为Linux，将dockerfile和docker-compose文件都一并加入到项目中了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220220023061-1218241152.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　加入进来后的项目结构&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220220424569-327910811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、对于docker compose脚本，没有必要在项目结构中展现，选中后右键将其卸载并移除。同时处理一下文件夹中的docker-compose，修改一下项目结构，增加docker文件夹，并将obj文件夹、docker相关的4个文件移入到docker文件夹中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220220739453-237938902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、最终项目结构：gitIgnore文件(手动配置或使用模板)，docker文件夹主要负责docker-compose脚本，src主要为应用程序及其相关，如有更多其它项目，如单元测试、集成测试，则还可以加入test文件夹，如还有文档资料，则还可以加入Document文件夹&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220222538669-950581095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、修改docker-compose.yml中dockerfile位置(主要修改content)，修改image地址为镜像仓库地址，镜像版本前期使用latest，后期稳定部署时改为数字值&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220223749304-392415852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、全部整理完毕后，执行代码提交并推送到仓库中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220222757631-1793769540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;四、Jenkins中新建项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　具体的在Jenkins中新建项目可以参见该文章：&lt;a href=&quot;https://www.cnblogs.com/CKExp/p/9940479.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9940479.html&lt;/a&gt;，在此只处理执行脚本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1、镜像生产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;#!/bin/bash&lt;br/&gt;# 获取短版本号&lt;/p&gt;
&lt;p&gt;GITHASH=`git rev-parse --short HEAD`&lt;/p&gt;
&lt;p&gt;docker-compose -f ./docker/docker-compose.yml -f ./docker/docker-compose.override.yml -p standard down --rmi local --remove-orphans&lt;br/&gt;# 生成容器及镜像等并对外提供服务&lt;br/&gt;# docker-compose -f ./docker/docker-compose.yml -f ./docker/docker-compose.override.yml -p standard up -d --build&lt;br/&gt;# 只生产镜像&lt;br/&gt;docker-compose -f ./docker/docker-compose.yml -f ./docker/docker-compose.override.yml -p standard build&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;&lt;span&gt;　　2、镜像推送到镜像仓库中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker &lt;/span&gt;&lt;span&gt;login&lt;/span&gt; -u=xxx用户名xxx -p=&lt;span&gt;xxx密码xxx ccr.ccs.tencentyun.com
docker&lt;/span&gt;-compose -f ./docker/docker-compose.yml -f ./docker/docker-compose.override.yml push
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　3、保存并构建，查看控制台输出，构建成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220224834688-866992368.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;五、查看镜像仓库&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　1、查看本地主机上的镜像，通过docker image命令或是UI管理工具&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220225010406-423841786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、查看腾讯云镜像仓库，镜像构建完毕，当代码持续更改，镜像持续进行构建&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220225056253-1119257458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;至此，从新建项目到镜像构建并推送到镜像仓库整个过程完成，主要是应用阶段，因此技术含量不多。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 新建项目加入到生成流水线中&quot; href=&quot;https://www.cnblogs.com/CKExp/p/10152992.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/10152992.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181220225431438-926750882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-12-20,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Dec 2018 14:57:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>整个生成流水线已经搭建完毕了，这一次来从零开始融入到生成流水线中，从仓库建立到镜像生成整个过程，对于之前几篇文章的一次应用过程，注意，本次建立过程是保证在前期基础搭建完毕后的应用阶段，本次搭建过程较为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10152992.html</dc:identifier>
</item>
<item>
<title>一个适合.NET Core的代码安全分析工具 - Security Code Scan - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/edc_security_code_scan_simple_introduction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/edc_security_code_scan_simple_introduction.html</guid>
<description>&lt;p&gt;　　本文主要翻译自Security Code Scan的官方Github文档，结合自己的初步使用简单介绍一下这款工具，大家可以结合自己团队的情况参考使用。此外，对.NET Core开发团队来说，可以参考张队的《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/9952663.html&quot; target=&quot;_blank&quot;&gt;.NET Core 必备安全措施&lt;/a&gt;》看看可以使用哪些方法提高我们.NET Core应用程序的安全性，此文也算是对张队的那篇文章的一个补充。此外，本文不会介绍常见的Web攻击及其场景，有兴趣的园友可以读读参考书《白帽子讲Web安全》一书。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220202805808-1014423574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最近公司官网被Google拉入了安全黑名单，我们被迫把安全性的优先级提高了，先是启用HTTPS，然后是安全扫描，最后漏洞修复。以前做内部系统时往往不会很在意安全问题，现在经历了这么一波后印象深刻了。我们希望找寻一款工具，能够在代码开发阶段就能够分析出我们得代码存在的风险（至少是常见的风险，比如XSS、CSRF等），让开发人员第一时间能够知道并选择性地进行改正。&lt;/p&gt;
&lt;p&gt;　　在Visual Studio Marketplace上，我们发现了一款工具：&lt;strong&gt;&lt;em&gt;Security Code Scan&lt;/em&gt;&lt;/strong&gt;，以下简称SCS，它是一款开源的代码安全分析工具，其Github地址为：&lt;a href=&quot;https://github.com/security-code-scan/security-code-scan&quot; target=&quot;_blank&quot;&gt;https://github.com/security-code-scan/security-code-scan&lt;/a&gt;，目前Star数量只有150+，但作者一直在维护，我们可以选择性使用。当然，有机会我们也可以为其提Issue甚至PR。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;SCS能够检测的安全问题有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（1）SQL注入&lt;/p&gt;
&lt;p&gt;　　（2）XSS跨站点攻击&lt;/p&gt;
&lt;p&gt;　　（3）CSRF跨站点请求伪造攻击&lt;/p&gt;
&lt;p&gt;　　（4）XXE（XML External Entity Injection）XML外部实体注入攻击&lt;/p&gt;
&lt;p&gt;　　（5）......&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;SCS能够支持哪些项目类型？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当然是我们喜欢的.NET 和 .NET Core项目啦！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;SCS能够支持CI吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可以，通过MSBuild完美实现，后续会有介绍。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;SCS支持哪些Visual Studio版本？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Visual Studio 2015及以上版本均支持，包括社区版、专业版和企业版。&lt;/p&gt;

&lt;h2&gt;2.1 SCS的安装&lt;/h2&gt;
&lt;p&gt;　　目前，SCS支持两种方式的安装：&lt;/p&gt;
&lt;p&gt;　　（1）&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=JaroslavLobacevski.SecurityCodeScan&quot; target=&quot;_blank&quot;&gt;VS扩展插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　（2）&lt;a href=&quot;https://www.nuget.org/packages/SecurityCodeScan/&quot; target=&quot;_blank&quot;&gt;Nuget包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　目前最新版本为3.0.0，2018年12月4日更新。&lt;/p&gt;
&lt;p&gt;　　推荐使用Nuget包方式使用，因为CI也会依赖该Nuget包。&lt;/p&gt;
&lt;h2&gt;2.2 SCS的使用&lt;/h2&gt;
&lt;p&gt;　　为了演示SCS的使用，这里我们使用一个SCS在官方文档中准备好的一个故意留有安全问题的ASP.NET 项目（不是ASP.NET Core）叫做&lt;a href=&quot;https://codeload.github.com/OWASP/WebGoat.NET/legacy.zip/master&quot; target=&quot;_blank&quot;&gt;WebGoat.NET&lt;/a&gt;来初步使用一下。下载完成后，发现该示例项目是一个VS2010的项目，于是将其升级到.NET Framework 4.6.1并使用VS2017打开，最后效果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220203110130-587367431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WebGoal.NET项目结构&lt;/p&gt;
&lt;p&gt;　　第一步，当然是通过Nuget管理器引入SCS的包啦：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220203552570-1147004948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;VS2017的话选择SecurityCodeScan.VS2017版本，VS2015的话直接选择SecurityCodeScan。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　第二步，确保错误列表窗口的选项是生成+IntelliSense：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220203447453-1303237736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第三步，编译该项目，查看错误列表Tab的警告信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220204010635-1380121563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，我们也可以将安全警告信息筛选出来，它们都是以SCS开头的规则：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220204032230-1921278107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第四步，点开其中一个安全问题，比如SCS0008，看看是什么提示信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220204229866-1581615454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　原来是说Cookie缺少了Secure标记，推荐我们在设置新Cookie时都加上Secure标记。至于为什么要加上Secure标记，这个是OWASP推荐的一个最佳实践，你可以通过这篇《&lt;a href=&quot;https://www.owasp.org/index.php/SecureFlag&quot; target=&quot;_blank&quot;&gt;SecureFlag&lt;/a&gt;》来了解了解。大概意思就是：如果一个cookie被设置了Secure=true，那么这个cookie只能用https协议发送给服务器，用http协议是不发送的。换句话说，cookie是在https的情况下创建的，而且他的Secure=true，那么之后你一直用https访问其他的页面（比如登录之后点击其他子页面），cookie会被发送到服务器，你无需重新登录就可以跳转到其他页面。但是如果这是你把url改成http协议访问其他页面，你就需要重新登录了，因为这个cookie不能在http协议中发送。从另一个侧面来看，整站HTTPS的必要性也得以体现。&lt;/p&gt;
&lt;p&gt;　　一个设置了Secure属性的C#代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    HttpCookie cookie = &lt;span&gt;new&lt;/span&gt; HttpCookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    cookie.Path &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cookie.Value &lt;/span&gt;=&lt;span&gt; loginId.ToLower();
    cookie.Expires &lt;/span&gt;= DateTime.Now.AddDays(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    cookie.Secure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    Response.Cookies.Add(cookie);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因此，这里我们可以定位到有漏洞问题的代码行，为其添加Secure=true，再次编译后，这一条SCS0008的警告就已经不再了。当然，你为此得付出的工作却没有结束，你还需要为系统配置Https证书和端口等等。&lt;/p&gt;
&lt;p&gt;　　下一步？继续查看SCS给出的安全警告，选择性地进行修复，迭代反复。&lt;/p&gt;

&lt;p&gt;　　和StyleCop.Analyzers之类的代码风格分析器一样，SCS也可以设置其规则集，对我们来说最有用的就是可以统一设置其严重性级别（比如：警告、信息还是错误）。怎么做呢？看下面的介绍。&lt;/p&gt;
&lt;p&gt;　　在分析器上选择“打开活动规则集”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220222433262-47969343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在分析器规则集列表中定位到“SecurityCodeScan”中，可以看到SCS开头的一系列规则集，这里假设我们为SCS0008这条规则的严重性设置为错误：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220222710354-565663207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　保存后再次进行编译，可以看到，SCS0008已经是一个错误信息，编译不通过了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220222840432-456180993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过改变安全规则的严重性，我们可以在开发阶段确保团队注意安全性，前提是要筛选出来哪些规则你要设置为错误，哪些规则你要设置为警告或信息等不影响编译的级别。&lt;/p&gt;
&lt;p&gt;　　更多的规则想要了解？点击&lt;a href=&quot;https://security-code-scan.github.io/#Rules&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，你想要了解的都在这里：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181220224326641-1881520869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　前面提到可以修改规则严重性来影响编译，那么在CI的继承中，我们如果使用MSBuild，那么作为Nuget包的SCS可以直接影响CI过程中的编译。&lt;/p&gt;

&lt;p&gt;　　这里参考张队的《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/9952663.html&quot; target=&quot;_blank&quot;&gt;.NET Core 必备安全措施&lt;/a&gt;》一文中的部分内容：&lt;/p&gt;
&lt;p&gt;　　在ASP.NET Core 2.1中，默认会让你启用HTTPS，而在2.0中，默认是不启用的。&lt;/p&gt;
&lt;p&gt;　　对于CSRF攻击，ASP.NET Core使用 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/introduction&quot;&gt;ASP.NET Core data protection stack&lt;/a&gt; 来实现防请求伪造。默认情况下处于启用状态，CSRF令牌将自动添加为隐藏输入字段。&lt;/p&gt;
&lt;p&gt;　　对于XSS攻击，可以使用内容安全策略（CSP），它是一个增加的安全层，可帮助缓解XSS（跨站点脚本）和数据注入攻击。实现上主要是在header里加了Content-Security-Policy的安全策略，ASP.NET Core中的代码参考如柳随风的这篇《&lt;a href=&quot;http://www.cnblogs.com/wang2650/p/7785106.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core2中使用CSP内容安全策略&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;　　对于微服务应用架构，我们默认会借助IdentityServer4实现标准的OIDC进行身份验证，则无需担心如何存储用户、密码或对用户进行身份验证。&lt;/p&gt;
&lt;p&gt;　　.......&lt;/p&gt;

&lt;p&gt;　　（1）Security Code Scan，&lt;a href=&quot;https://security-code-scan.github.io&quot; target=&quot;_blank&quot;&gt;GitHub文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　（2）张善友，《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/9952663.html&quot; target=&quot;_blank&quot;&gt;.NET Core 必备安全措施&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　（3）Forwill，《&lt;a href=&quot;https://www.cnblogs.com/forwill/p/6181984.html&quot; target=&quot;_blank&quot;&gt;Cookie的Secure属性&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　（4）如柳随风，《&lt;a href=&quot;http://www.cnblogs.com/wang2650/p/7785106.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core2中使用CSP内容安全策略&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201812/381412-20181213233810881-1159026008.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　吴翰清，《白帽子讲Web安全》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 20 Dec 2018 14:45:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>本文主要翻译自Security Code Scan的官方Github文档，结合自己的初步使用简单介绍一下这款工具，大家可以结合自己团队的情况参考使用。此外，对.NET Core开发团队来说，可以参考张</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/edc_security_code_scan_simple_introduction.html</dc:identifier>
</item>
<item>
<title>基于IdentityServer4 实现.NET Core的认证授权 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/10150814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/10150814.html</guid>
<description>&lt;h2&gt;IdentityServer4是什么？&lt;/h2&gt;
&lt;p&gt; IdentityServer4是基于ASP.NET Core实现的认证和授权框架，是对OpenID Connect和OAuth 2.0协议的实现。&lt;/p&gt;
&lt;h2&gt;OpenID Connect 和 OAuth2.0是什么&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OpenID Connect:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OpenID Connect由OpenID基金会于2014年发布的一个开放标准, 是建立在OAuth 2.0协议上的一个简单的身份标识层, OpenID Connect 兼容 OAuth 2.0. 实现身份认证（Authentication）&lt;br/&gt;参考资料：&lt;a href=&quot;https://openid.net/connect/&quot; rel=&quot;nofollow&quot;&gt;https://openid.net/connect/&lt;/a&gt;&lt;br/&gt;OpenID Connect文档：&lt;a href=&quot;https://openid.net/specs/openid-connect-discovery-1_0.html&quot; rel=&quot;nofollow&quot;&gt;https://openid.net/specs/openid-connect-discovery-1_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OAuth2.0:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OAuth2.0是一个开放的工业标准的授权协议（Authorization），它允许用户授权让第三方应用直接访问用户在某一个服务中的特定资源，但不提供给第三方账号及密码信息&lt;br/&gt;参考资料：&lt;a href=&quot;https://www.cnblogs.com/xiandnc/p/9763121.html&quot; rel=&quot;nofollow&quot;&gt;https://www.cnblogs.com/xiandnc/p/9763121.html&lt;/a&gt;&lt;br/&gt;OAuth2.0 文档：&lt;a href=&quot;https://tools.ietf.org/html/rfc6749#page-73&quot; rel=&quot;nofollow&quot;&gt;https://tools.ietf.org/html/rfc6749#page-73&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Authentication 和 Authorization的区别&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;authentication: n. 证明；鉴定；证实
authorization: n. 授权，认可；批准，委任
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前者是身份识别，鉴别你是谁；后者是授权许可，告诉你可以做什么。&lt;br/&gt;举个例子：你吭哧吭哧写了一天的代码，急于回家吃上一口媳妇做的热饭。当你走到小区门口的时候你需要刷小区的门禁卡才能进入到小区里面，然后再找到你家在哪一栋楼，几单元几号，然后掏出钥匙开门才能回到家。在这个过程中刷小区的门禁就是认证你是这个小区的人，拿你家的钥匙开门就是授权的过程，如果你的认证不通过，那就不存在授权。&lt;/p&gt;
&lt;h2&gt;OAuth2.0的原理&lt;/h2&gt;
&lt;p&gt;我们先来了解一下OAuth2.0中的几个关键概念：&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;资源所有者（Resource Owner）：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　一个能够访问受保护资源的实体。当资源所有者是一个人时，它被称为终端用户&lt;/p&gt;
&lt;h4&gt;资源服务器（Resource Server）：&lt;/h4&gt;
&lt;p&gt;　　托管受保护资源的服务器，能够使用访问令牌接受和响应受保护的资源请求&lt;/p&gt;
&lt;h4&gt;客户端（Client）：&lt;/h4&gt;
&lt;p&gt;　　代表资源所有者和其授权的应用程序来保护资源请求。术语客户端并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）&lt;/p&gt;
&lt;h4&gt;授权服务器（Authorization Server）：&lt;/h4&gt;
&lt;p&gt;　　在成功验证资源所有者并获得授权之后，服务器向客户端发出访问令牌。（授权服务器是用来管理Resource Owner，Resource Server，Client的中间人）&lt;/p&gt;
&lt;p&gt;场景：小李想要打印（美图快印）自己三年来发布在新浪微博相册中和女朋友的照片，有没有什么方法他既不告诉工作人员自己的新浪微博用账号和密码又能够方便快捷的把照片给到美图快印呢？（排除存U盘这种手工操作）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220174914535-1979738252.png&quot; alt=&quot;&quot; width=&quot;1259&quot; height=&quot;957&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Authorization Server和Resource Server可以使独立的服务提供商，也可以是在一起的，比如例子中新浪微博既作授权服务器也用来存储用户的图片资源。我们可以看到OAuth2解决的问题是：通过Authorization Server可以提供一个访问的凭据（token）给client（美图快印的工作人员），使得client可以在不知道Resource Owner以及Resource Server的用户名和密码的情况下访问到Resource Owner受保护的资源，它是一个完美的中间人。　　&lt;/p&gt;
&lt;p&gt;OAuth2.0详细内容请参考：&lt;a href=&quot;https://www.cnblogs.com/xiandnc/p/9763121.html&quot; rel=&quot;nofollow&quot;&gt;https://www.cnblogs.com/xiandnc/p/9763121.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;IdentityServer4能做什么&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220175002815-985346258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;用户认证服务&lt;/h4&gt;
&lt;p&gt;　　基于OpenID Connect实现的独立的认证服务实现对多平台（web, native, mobile, services）的集中认证&lt;/p&gt;
&lt;h4&gt;API访问授权&lt;/h4&gt;
&lt;p&gt;　　为各种类型的客户机颁发api访问令牌，例如服务器到服务器、web应用程序、spa和native/mobile程序&lt;/p&gt;
&lt;h4&gt;联合身份认证&lt;/h4&gt;
&lt;p&gt;　　支持外部身份提供者，如Azure Active Directory、Google、Facebook等&lt;/p&gt;
&lt;h4&gt;定制化的实现&lt;/h4&gt;
&lt;p&gt;　　IdentityServer4的许多方面可以定制以满足您的需要,因为它是一个框架，而不是SaaS服务，所以可以通过编写代码来调整实现，以适应不同的场景&lt;/p&gt;
&lt;h4&gt;成熟的开原方案&lt;/h4&gt;
&lt;p&gt;　　使用许可的Apache2开源协议，允许在其之上构建商业产品，也作为.NET基金会支持的项目 （&lt;a href=&quot;https://dotnetfoundation.org/projects?type=project&amp;amp;ps=10&amp;amp;pn=6&quot; target=&quot;_blank&quot;&gt;https://dotnetfoundation.org/projects?type=project&amp;amp;ps=10&amp;amp;pn=6&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;提供免费的商业支持&lt;/h4&gt;
&lt;p&gt;　　官方可以对使用者提供部分的免费商业支持&lt;/p&gt;
&lt;h2&gt;IdentityServer4定义的基本术语&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220175659045-425144838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IdentityServer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　身份认证服务器是一个实现了OpenID Connect和OAuth 2.0协议的身份提供者，它负责向客户端发布安全令牌&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;User&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用注册客户端访问资源的用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Client&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        客户端从标识服务器请求令牌，要么用于认证用户（请求身份令牌），要么用于访问资源（请求访问令牌）&lt;br/&gt;        客户端必须首先在身份服务器上注册，然后才能请求令牌&lt;br/&gt;       这里的客户端可以是web应用程序、native mobile， desktop applications, SPA 等程序&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Resource&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　资源是你想要用身份认证服务器保护的东西，如：用户的身份数据或api&lt;br/&gt;　　每个资源都有一个惟一的名称，客户端使用这个名称来指定他们想要访问的资源&lt;br/&gt;　　关于用户的身份数据标识（也称为claim），例如姓名或电子邮件地址&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Identity Token&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　身份令牌代表身份验证过程的结果&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Access Token&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　访问令牌授权客户端以允许访问哪些API资源，访问令牌包含客户端和用户的信息&lt;/p&gt;

&lt;h2&gt;IdentityServer4的简单示例&lt;/h2&gt;
&lt;p&gt; 我们先来看一个简单的例子，我们有三个API ，Order, Product, Inventory，我们利用IdentityServer4来实现对着三个API的认证和授权。首先我们需要一个实现认证和授权的服务，然后外部要想访问我们的API就必须通过统一的认证和授权服务的任何才可以，否则就是返回401: UnAuthorized ,未经授权的访问。我们既可以将身份信息存储到内存中，也可以将其持久化到数据库中，此处我们使用内存模式快速的演示实现（示例代码中也支持存储到DB中，使用SqlLite + EF Core）&lt;/p&gt;
&lt;p&gt;首先我们需要安装IdentityServer4的Nuget包，然后在ConfigureServices方法中添加如下代码来初始化需要保护的API资源信息，代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public void ConfigureServices(IServiceCollection services)
        {
            // config data in memory
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddInMemoryApiResources(InitMemoryData.GetApiResources())
                .AddInMemoryClients(InitMemoryData.GetClients())
                .AddTestUsers(InitMemoryData.GetUsers());

            // config in DB
            //services.AddDbContext&amp;lt;IdentityServerDbContext&amp;gt;(options =&amp;gt;
            //                            options.UseSqlite(sqliteConnection));
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　InitMemoryData 中的配置信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 // scopes define the API resources in your system
        public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
        {
            return new List&amp;lt;ApiResource&amp;gt;
            {
                new ApiResource(&quot;inventoryapi&quot;, &quot;this is inventory api&quot;),
                new ApiResource(&quot;orderapi&quot;, &quot;this is order api&quot;),
                new ApiResource(&quot;productapi&quot;, &quot;this is product api&quot;)
            };
        }

        // clients want to access resources (aka scopes)
        public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
        {
            // client credentials client
            return new List&amp;lt;Client&amp;gt;
            {
                new Client
                {
                    ClientId = &quot;inventory&quot;,
                    AllowedGrantTypes = GrantTypes.ClientCredentials,

                    ClientSecrets =
                    {
                        new Secret(&quot;inventorysecret&quot;.Sha256())
                    },

                    AllowedScopes = { &quot;inventoryapi&quot; }
                },
                 new Client
                {
                    ClientId = &quot;order&quot;,
                    AllowedGrantTypes = GrantTypes.ClientCredentials,

                    ClientSecrets =
                    {
                        new Secret(&quot;ordersecret&quot;.Sha256())
                    },

                    AllowedScopes = { &quot;orderapi&quot; }
                },
                 new Client
                {
                    ClientId = &quot;product&quot;,
                    AllowedGrantTypes = GrantTypes.ClientCredentials,

                    ClientSecrets =
                    {
                        new Secret(&quot;productsecret&quot;.Sha256())
                    },

                    AllowedScopes = { &quot;productapi&quot; }
                }
            };
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们给IdentityServer4设置启动端口5000，认证服务的地址就是：&lt;a href=&quot;http://localhost:5000&quot; target=&quot;_blank&quot;&gt;http://localhost:5000&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;然后认证Server端的代码就好了，接下来我们需要在API添加授权服务的配置，配置都很类似，我们以OrderAPI为例：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvcCore()
                .AddAuthorization()
                .AddJsonFormatters();

            services.AddAuthentication(&quot;Bearer&quot;)
                .AddIdentityServerAuthentication(options =&amp;gt;
                {
                    options.Authority = &quot;http://localhost:5000&quot;;
                    options.RequireHttpsMetadata = false;
                    options.ApiName = &quot;orderapi&quot;;
                });
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.UseAuthentication();
            app.UseMvc();
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们配置的Authority地址就是认证授权的地址，AddAuthentication中的Bearer是Jwt Token的一种，具体可参考文章：&lt;a href=&quot;https://www.cnblogs.com/Leo_wl/p/7792046.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Leo_wl/p/7792046.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在controller中添加简单代码来返回API的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [Authorize]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/order&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Get()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userIdentitys = &lt;span&gt;from&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; User.Claims
                                &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserIdentity
                                {
                                    Type &lt;/span&gt;=&lt;span&gt; c.Type,
                                    Value &lt;/span&gt;=&lt;span&gt; c.Value
                                };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserIdentityModel()
            {
                Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Access user order api successfully&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserIdentitys &lt;/span&gt;=&lt;span&gt; userIdentitys.ToList()
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResult(result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置当前API的端口为：5002&lt;/p&gt;
&lt;p&gt;Product和Inventory中的配置和这个类似，端口信息以此设置为5001，5003，一切就绪，让我们来测试一下结果：&lt;/p&gt;
&lt;p&gt;启动IdentotyServer，以及三个API，我们使用Postman来请求api，下面站点就是IdentityServer的页面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220211121320-1702545889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们来直接访问OrderAPI就会发现返回 401 ，这说明目前我们的API已经受保护了，没有认证服务颁发的token，是直接访问不了的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220211225188-628980686.png&quot; alt=&quot;&quot; width=&quot;1648&quot; height=&quot;534&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们输入地址：&lt;a href=&quot;http://localhost:5000/.well-known/openid-configuration&quot; target=&quot;_blank&quot;&gt;http://localhost:5000/.well-known/openid-configuration &lt;/a&gt; 可以查看我们当前认证授权服务的配置信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220211532214-386229146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在还差一步就可以访问我们的OrderAPI了，那就是：&lt;span&gt;&lt;strong&gt;客户端传入必要的信息给认证服务，生成一定格式的token，然后携带着这个token来访问我们的服务 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220211815372-1749249925.png&quot; alt=&quot;&quot; width=&quot;1748&quot; height=&quot;613&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传入的三个参数分别是grant_type , client_sercret, client_id这几个参数分别代表了我们申请token时的授权方式是客户端授权，密匙，clientid信息。我们在前面介绍过IdentityServer4是对OAuth2.0的实现，所以具体参数的含义请参考之前OAuth2.0文章中的详细介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiandnc/p/9763121.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xiandnc/p/9763121.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以看到认证服务给我们返回了有效token，指定过去时间3600s ，token的类型是Bearer，然后我们再携带这这个token去访问服务试试看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201812/1413706-20181220223311617-1506048585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到此时API 返回了我们期待的正确结果，如果在1小时后再携带着这个token去访问API就会提示token已过期，需要重新生成才能够继续访问。看完这个例子是不是很简单，很清爽呢&lt;/p&gt;
&lt;p&gt;例子参考代码：&lt;a href=&quot;https://github.com/KenWang007/IdentityServer4Demo&quot; target=&quot;_blank&quot;&gt;https://github.com/KenWang007/IdentityServer4Demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Thu, 20 Dec 2018 14:35:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>IdentityServer4是什么？ IdentityServer4是基于ASP.NET Core实现的认证和授权框架，是对OpenID Connect和OAuth 2.0协议的实现。 OpenID</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/10150814.html</dc:identifier>
</item>
<item>
<title>【3分钟就会系列】使用Ocelot+Consul搭建微服务吧! - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10152879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10152879.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;API网关是一个服务器，是系统的唯一入口。API 网关一般放到微服务的最前端，并且要让API 网关变成由应用所发起的每个请求的入口。这样就可以明显的简化客户端实现和微服务应用程序之间的沟通方式。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。&lt;/p&gt;
&lt;p&gt;Ocelot 是一个使用在 .NET Core 平台上的一个 API Gateway，这个项目的目标是在 .NET 上面运行微服务架构。Ocelot 框架内部集成了 IdentityServer（身份验证）和 Consul（服务注册发现），还引入了 Polly 来处理进行故障处理。目前，腾讯和微软Ocelot 在官网贴出来的客户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220174031760-1954624501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在此之前你应该去学一学如何搭建服务集群，那么这将有效与你学习API网关服务，&lt;a href=&quot;https://www.cnblogs.com/ZaraNet/p/10123291.html&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;，再此基础上再添加一个名为  MicroService.APIGetway 的ASP.NET WebApi项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220215345487-1285277889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该项目中，我们通过Nuget安装Ocelot，或者通过m命令行进行安装。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：最新版的不建议使用，会出现一些内部错误，建议使用10.0.1以下的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;创建相关文件夹&lt;/h2&gt;
&lt;p&gt; 在其中应该创建服务注册以及网关文件夹，那么效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220174715569-425940074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;添加网关配置文件&lt;/h2&gt;
&lt;p&gt;在项目中，添加一个配置文件 ocelot.json ,并将文件属性中 “赋值到输出目录” 的值修改为 “如果较新则复制”。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220174743863-1348484596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ocelot.json文件夹中，加入以下内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;ReRoutes&quot;&lt;span&gt;: [
    {
      &quot;UseServiceDiscovery&quot;: true&lt;span&gt;,
      &quot;DownstreamPathTemplate&quot;: &quot;/api/values&quot;&lt;span&gt;,
      &quot;DownstreamScheme&quot;: &quot;http&quot;&lt;span&gt;,
      &quot;ServiceName&quot;: &quot;T169.OcelotConsul.Service&quot;&lt;span&gt;,
      &quot;LoadBalancerOptions&quot;&lt;span&gt;: {
        &quot;Type&quot;: &quot;RoundRobin&quot;&lt;span&gt;
      },
      &quot;UpstreamPathTemplate&quot;: &quot;/ss&quot;&lt;span&gt;,
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot;&lt;span&gt; ],
      &quot;ReRoutesCaseSensitive&quot;: false // non case sensitive
&lt;span&gt;    }
  ],
  &quot;GlobalConfiguration&quot;&lt;span&gt;: {
    &quot;ServiceDiscoveryProvider&quot;&lt;span&gt;: {
      &quot;Host&quot;: &quot;localhost&quot;, // Consul Service IP
      &quot;Port&quot;: 8500 // Consul Service Port
&lt;span&gt;    }
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是 Ocelot 官方给出的配置文件的节点说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  //官⽅方⽂文档ReRoutes全节点示例例
  &quot;ReRoutes&quot;&lt;span&gt;: [
    {
      //Upstream表示上游请求，即客户端请求到API Gateway的请求
      &quot;UpstreamPathTemplate&quot;: &quot;/&quot;, //请求路路径模板
      &quot;UpstreamHttpMethod&quot;: [ //请求⽅方法数组
        &quot;Get&quot;&lt;span&gt;,
        &quot;POST&quot;&lt;span&gt;,
        &quot;PUT&quot;&lt;span&gt;,
        &quot;DELETE&quot;&lt;span&gt;,
        &quot;OPTIONS&quot;&lt;span&gt;
      ],
      //Downstreamb表示下游请求，即API Gateway转发的⽬目标服务地址
      &quot;DownstreamScheme&quot;: &quot;http&quot;, //请求协议，⽬目前应该是⽀支持http和https
      &quot;DownstreamHostAndPorts&quot;&lt;span&gt;: [
        {
          &quot;Host&quot;: &quot;localhost&quot;, //请求服务地址，应该是可以是IP及域名
          &quot;Port&quot;: 8081 //端⼝口号
&lt;span&gt;        }
      ],
      &quot;DownstreamPathTemplate&quot;: &quot;/&quot;, //下游请求地址模板
      // 以下节点可选
      &quot;RouteClaimsRequirement&quot;: { //标记该路路由是否需要认证
        &quot;UserType&quot;: &quot;registered&quot; //示例例,K/V形式，授权声明，授权token中
&lt;span&gt;        会包含⼀一些claim，如填写则会判断是否和token中的⼀一致，不不⼀一致则不不准访问
      },
      //以下三个是将access claims转为⽤用户的Header Claims,QueryString，该
&lt;span&gt;      功能只有认证后可⽤用
      &quot;AddHeadersToRequest&quot;: { //
        &quot;UserType&quot;: &quot;Claims[sub] &amp;gt; value[0] &amp;gt; |&quot;, //示例例
        &quot;UserId&quot;: &quot;Claims[sub] &amp;gt; value[1] &amp;gt; |&quot; //示例例
&lt;span&gt;      },
      &quot;AddClaimsToRequest&quot;&lt;span&gt;: {},
      &quot;AddQueriesToRequest&quot;&lt;span&gt;: {},
      &quot;RequestIdKey&quot;: &quot;&quot;, //设置客户端的请求标识key，此key在请求header中
&lt;span&gt;      ，会转发到下游请求中
      &quot;FileCacheOptions&quot;: { //缓存设置
        &quot;TtlSeconds&quot;: 15, //ttl秒被设置为15，这意味着缓存将在15秒后过期
&lt;span&gt;        。
        &quot;Region&quot;: &quot;&quot; //缓存region，可以使⽤用administrator API清除
&lt;span&gt;      },
      &quot;ReRouteIsCaseSensitive&quot;: false, //路路由是否匹配⼤大⼩小写
      &quot;ServiceName&quot;: &quot;&quot;, //服务名称，服务发现时必填
      &quot;QoSOptions&quot;: { //断路路器器配置,⽬目前Ocelot使⽤用的Polly
        &quot;ExceptionsAllowedBeforeBreaking&quot;: 0, //打开断路路器器之前允许的例例
&lt;span&gt;        外数量量。
        &quot;DurationOfBreak&quot;: 0, //断路路器器复位之前，打开的时间(毫秒)
        &quot;TimeoutValue&quot;: 0 //请求超时时间(毫秒)
&lt;span&gt;      },
      &quot;LoadBalancer&quot;: &quot;&quot;, //负载均衡 RoundRobin(轮询)/LeastConnection(
&lt;span&gt;      最少连接数)
      &quot;RateLimitOptions&quot;: { //官⽅方⽂文档未说明
        &quot;ClientWhitelist&quot;: [], // 客户端⽩白明代 ？
        &quot;EnableRateLimiting&quot;: false, // 是否限流 ？
        &quot;Period&quot;: &quot;&quot;&lt;span&gt;,
        &quot;PeriodTimespan&quot;: 0&lt;span&gt;,
        &quot;Limit&quot;: 0&lt;span&gt;
      },
      &quot;AuthenticationOptions&quot;: { //认证配置
        &quot;AuthenticationProviderKey&quot;: &quot;&quot;, //这个key对应的是代码中.AddJW
&lt;span&gt;        TBreark中的Key
        &quot;AllowedScopes&quot;: [] //使⽤用范围
&lt;span&gt;      },
      &quot;HttpHandlerOptions&quot;&lt;span&gt;: {
        &quot;AllowAutoRedirect&quot;: true, //指示请求是否应该遵循重定向响应。
&lt;span&gt;        如果请求应该⾃自动遵循来⾃自Downstream资源的重定向响应，则将其设置为true; 否则为假。
        默认值是true。
        &quot;UseCookieContainer&quot;: true //该值指示处理理程序是否使⽤用CookieCon
&lt;span&gt;        tainer属性来存储服务器器Cookie，并在发送请求时使⽤用这些Cookie。 默认值是true。
      },
      &quot;UseServiceDiscovery&quot;: false //使⽤用服务发现，⽬目前Ocelot只⽀支持Consu
&lt;span&gt;      l的服务发现
    }
  ],
  &quot;GlobalConfiguration&quot;&lt;span&gt;: {}
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，我们需要了解一下微服务的上游服务器和下游服务器,以下是我个人的总结,下游服务器是提供Api接口，那么上游提供访问的规则，下游服务器配置就是我们刚才创建的json里面的，我们指定Host，port，以及PathTemplate。&lt;/p&gt;
&lt;p&gt;通过配置文件，我们可以可以知道Ocelot是通过我们的json配置规则映射成了它自己可以识别的对象，转发给了后台的httpservice，从后端返回结果。&lt;/p&gt;
&lt;p&gt;通过配置文件可以完成对 Ocelot 的功能配置： 路由、服务聚合、服务发现、认证、鉴权、限流、熔断、缓存、 Header 头传递 等。我们上面的配置说明都已经写好了,比较重要的就是如下，下面你可以多留意。&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;DownstreamPathTemplate：下游戏&lt;/li&gt;
&lt;li&gt;DownstreamScheme：下游服务http schema&lt;/li&gt;
&lt;li&gt;DownstreamHostAndPorts：下游服务的地址，如果使用LoadBalancer的话这里可以填多项&lt;/li&gt;
&lt;li&gt;UpstreamPathTemplate: 上游也就是用户输入的请求Url模板&lt;/li&gt;
&lt;li&gt;UpstreamHttpMethod: 上游请求http方法，可使用数组&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;修改启动文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; Program
    {
        public static void Main(string&lt;span&gt;[] args)
        {

            IWebHostBuilder builder = new&lt;span&gt; WebHostBuilder();

            builder.ConfigureServices(s =&amp;gt;&lt;span&gt; {
                s.AddSingleton(builder);
            });

            builder.UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .ConfigureAppConfiguration((hostingContext, cfg) =&amp;gt;&lt;span&gt; {
                    cfg.AddJsonFile(&quot;ocelot.json&quot;, false, true&lt;span&gt;);
                })
                .UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;();

            var host =&lt;span&gt; builder.Build();

            host.Run();
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要引用一下包：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;using Microsoft.AspNetCore.Hosting;&lt;br/&gt;using Microsoft.Extensions.Configuration;&lt;br/&gt;using Microsoft.Extensions.DependencyInjection;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;加载中间件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
// This method gets called by the runtime. Use this method to add services to the container.
        public void&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddOcelot(Configuration);
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();
            app.UseOcelot().Wait();
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修改项目加载配置文件(launchsettings.json)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;profiles&quot;&lt;span&gt;: {
    &quot;WebApplication1&quot;&lt;span&gt;: {
      &quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &quot;launchBrowser&quot;: false&lt;span&gt;,
      &quot;launchUrl&quot;: &quot;api/values&quot;&lt;span&gt;,
      &quot;environmentVariables&quot;&lt;span&gt;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &quot;applicationUrl&quot;: &quot;http://localhost:5000/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置启动多个项目&lt;/h2&gt;
&lt;p&gt;因为我们需要启动服务，还有网关，我们就需要设置启动多个项目了。右击项目属性。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220215426683-334467104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然我们，还是要回顾以下服务器集群的服务发现是如何进行的。&lt;/p&gt;
&lt;p&gt;这是一个很基本的json，如下图，节点与项目之间的关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;services&quot;&lt;span&gt;: [
    {
      &quot;ID&quot;: &quot;OcelotConsul1_service&quot;&lt;span&gt;,
      &quot;name&quot;: &quot;T169.OcelotConsul.Service&quot;&lt;span&gt;,
      &quot;tags&quot;&lt;span&gt;: [
        &quot;urlprefix-/T169.Studeent.Service&quot;&lt;span&gt;
      ],
      &quot;address&quot;: &quot;localhost&quot;&lt;span&gt;,
      &quot;port&quot;: 8081&lt;span&gt;,
      &quot;checks&quot;&lt;span&gt;: [
        {
          &quot;name&quot;: &quot;Student Service check&quot;&lt;span&gt;,
          &quot;http&quot;: &quot;http://localhost:8081/api/health&quot;&lt;span&gt;,
          &quot;interval&quot;: &quot;10s&quot;&lt;span&gt;,
          &quot;timeout&quot;: &quot;5s&quot;&lt;span&gt;
        }
      ]
    },{
      &quot;ID&quot;: &quot;OcelotConsul2_service&quot;&lt;span&gt;,
      &quot;name&quot;: &quot;T169.OcelotConsul.Service&quot;&lt;span&gt;,
      &quot;tags&quot;&lt;span&gt;: [
        &quot;urlprefix-/T169.Studeent.Service&quot;&lt;span&gt;
      ],
      &quot;address&quot;: &quot;localhost&quot;&lt;span&gt;,
      &quot;port&quot;: 8080&lt;span&gt;,
      &quot;checks&quot;&lt;span&gt;: [
        {
          &quot;name&quot;: &quot;Student Service check&quot;&lt;span&gt;,
          &quot;http&quot;: &quot;http://localhost:8080/api/health&quot;&lt;span&gt;,
          &quot;interval&quot;: &quot;10s&quot;&lt;span&gt;,
          &quot;timeout&quot;: &quot;5s&quot;&lt;span&gt;
        }
      ]
    }
  ]
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家都知道我们在我们的服务中写好了启动端口和和ip地址，如以下定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;profiles&quot;&lt;span&gt;: {
    &quot;ConsulGoForProject&quot;&lt;span&gt;: {
      &quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &quot;applicationUrl&quot;: &quot;http://localhost:8081&quot;&lt;span&gt;,
      &quot;environmentVariables&quot;&lt;span&gt;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们的配置文件就是通过address和port进行寻找的，寻找到之后，如果启动集群，那么就会将这些节点转换成对象，通过httpclient向集群进行映射，达到了一个这么一个功能，其中的ID应该是一个唯一的。那么name可以是相同的，可以让网关进行一个发现，那么网关是根据什么进行分发的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220220246925-848120705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们的网关是如何找到我们的服务的呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220220512238-2034952870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的DownstreamPathTemplate是向下的模板路径，DownstreamScheme是访问的方式，有http和https，ServiceName是服务发现的路径，在此其中，你的配置文件中，如果和这个名字相同，那么就会根据对应的address和port  去访问DownStreamPathTemplate，那么UpstreamPathTemplate是你要写的别名，也就是说我们的台服务器无法达到匹配的时候，我们可以使用这个属性（类似我们访问www.baidu.com 第一次访问和这个ServiceName相同的服务，第二次找第二个，当然这和Type:&quot;RoundRobin&quot; 这个属性有极大的关联，这个就叫做轮询，这个属性是Ocelot的精髓）。我们分别通过网关地址和服务的真实地址来访问服务，看一看效果如何。&lt;/p&gt;
&lt;p&gt;再此其中，我们使用开发模式进行启动服务器集群。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
consul agent -dev -config-dir=/tmp/consul/config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们逐一将其中的api/values的控制器返回值改以下，这里就不贴代码了，我们启动项目，看一个细节。如下是刚启动项目，还没有启动集群的时候是这个样子的，这是大家都经常看到的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220221347265-602968735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们开始部署集群，回车!,发现诸多的代码在执行，如下图所示，这是我们通过consul的命令去扫描了tmp/consul/config/ 这里面的json，当然它只认识json，读取其中的节点，通过Consul的自动代理HttpClient注册我们的服务，那么这就是一个通俗易懂的解释了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220221703641-856815020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下网关的效果如何，我们发现这是非常榜的，这也就是轮询机制，通过网关代理给我们带来了极大的好处。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181220222109469-849760103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么大家都知道WebApi限流机制，限流这个名词我就不再解释了，对请求进行限流可以防止下游服务器因为访问过载而崩溃，这个功能就是我们的张善友张队进添加进去的。非常优雅的实现，我们只需要在路由下加一些简单的配置即可以完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&quot;RateLimitOptions&quot;&lt;span&gt;: {
    &quot;ClientWhitelist&quot;&lt;span&gt;: [],
    &quot;EnableRateLimiting&quot;: true&lt;span&gt;,
    &quot;Period&quot;: &quot;1s&quot;&lt;span&gt;,
    &quot;PeriodTimespan&quot;: 1&lt;span&gt;,
    &quot;Limit&quot;: 1&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;ClientWihteList 白名单&lt;/li&gt;
&lt;li&gt;EnableRateLimiting 是否启用限流&lt;/li&gt;
&lt;li&gt;Period 统计时间段：1s, 5m, 1h, 1d&lt;/li&gt;
&lt;li&gt;PeroidTimeSpan 多少秒之后客户端可以重试&lt;/li&gt;
&lt;li&gt;Limit 在统计时间段内允许的最大请求数量&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;4.601226993865&quot;&gt;
&lt;p&gt; 希望大家看完这篇可以有所收获吧，Ocelot开源地址：&lt;a href=&quot;https://github.com/TomPallister/Ocelot&quot; rel=&quot;nofollow&quot;&gt;https://github.com/TomPallister/Ocelot&lt;/a&gt;，如果有问题的话在下方留言。谢谢。！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 20 Dec 2018 14:32:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>一.什么Ocelot？ API网关是一个服务器，是系统的唯一入口。API 网关一般放到微服务的最前端，并且要让API 网关变成由应用所发起的每个请求的入口。这样就可以明显的简化客户端实现和微服务应用程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10152879.html</dc:identifier>
</item>
<item>
<title>C#实现完整的防盗自制监控系统 - 九天飞翼</title>
<link>http://www.cnblogs.com/langda/p/10152871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/langda/p/10152871.html</guid>
<description>&lt;p&gt;在您的手机中通知您家中的入侵者，并拍摄他们的照片&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;在本文中，我将展示一些DIY东西​​，用于安装监控系统，检测家中的入侵者，拍摄照片并通过手机通知您，必要时可以打电话给警察并提供照片以便快速识别劫匪，并提高你恢复所有被盗事物的机会。&lt;/p&gt;
&lt;p&gt;当然，除了这个软件，你必须提供一些硬件，但我已经在我家使用相对便宜的材料建造了这个系统，如果我们除了相机，这是安装中最昂贵的部分。但你可以用相机做很多事情，所以它可以是一个好的和有趣的投资。&lt;/p&gt;
&lt;p&gt;基本上，这是系统架构，包含所有参与元素：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223045107-2033319510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然在模式中我已经代表了一些具体的子系统，但实际上我已经设计了解决方案，以便通过实现公共接口并使用依赖注入将它们与应用程序链接，可以独立开发所有这些元素。不同的子系统或协议如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;摄像机协议：定义与摄像机的通信。&lt;/li&gt;
&lt;li&gt;存储协议：定义文件传输，图像和控制命令/响应。&lt;/li&gt;
&lt;li&gt;触发协议：启动监控系统。&lt;/li&gt;
&lt;li&gt;警报协议：将事件远程传达给用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该解决方案使用Visual Studio 2015和4.5版的.Net Framework实现。&lt;/p&gt;
&lt;p&gt;你可以在我的博客中找到这篇文章的更长版本&lt;span&gt;&lt;a href=&quot;http://www.codesocang.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;网站源码&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，这里有西班牙文版本。由于此站点的文件大小限制为10MB，我不得不删除源代码中的大量文件，所有NuGet包，obj目录和所有二进制文件。虽然您可以从Visual Studio还原包，但您可能无法重新编译代码。在这种情况下，您可以从我的网站，在上一个链接中下载项目的完整文件集。&lt;/p&gt;
&lt;h2&gt;硬件&lt;/h2&gt;
&lt;p&gt;让我们回顾一下我用来构建系统的硬件。由于应用程序可以通过多种方式进行扩展，因此您可以使用自己的不同硬件选择来安装它。&lt;/p&gt;
&lt;p&gt;首先是相机。我有两个IP摄像头，每个都有不同的协议。更便宜的是一个概念性的wifi摄像头，价格约50€和协议NetWave cgi。另一种是专业的，具有高性能，但也是非常高的价格。这是一款采用VAPIX cgi协议的Axis相机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223055037-1609263861.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了拨打移动电话，我买了一个简单的USB AT调制解调器，价格约为17欧元：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223104213-1654520281.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，作为触发器，我使用的是Arduino板（约20欧元），存在探测器开关（约10欧元）和继电器。由于存在开关适用于220V，因此将其直接连接到Arduino板是一个坏主意。因此，我已将探测器连接到12V电源，并将继电器的电源连接到另一个开关，该电源关闭5V Arduino电源和输入引脚之间的电路。这完全隔离了220V主电源的Arduino板（以及计算机）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223113201-1594686456.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223120285-1943289145.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以轻松地建立一个继电器电路。只需将12个电源连接到继电器卷轴，将二极管从地线连接到12V电线，然后从Arduino侧使用输入引脚（PI）作为触发引脚，输出引脚（PO）用力电路开路时输入引脚为0V，5V电源信号激活输入引脚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223128221-1403813077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是Arduino代码，我使用引脚28作为输入，24使用输出，因为在Arduino Mega板中它们靠近5V引脚，但是你可以使用你想要的，当然。&lt;/p&gt;
&lt;pre&gt;
int pin1 = 28;
int pin0 = 24;
void setup() {
// Initialize pins
    pinMode(pin0, OUTPUT); 
    digitalWrite(pin0, LOW);
    pinMode(pin1, INPUT);
    digitalWrite(pin1, LOW);
    Serial.begin(9600);
}
void loop() {
    int val = digitalRead(pin1);
    if (val == HIGH) {
        Serial.write(1);
    }
    delay(1000);
}
&lt;/pre&gt;
&lt;p&gt;最后，虽然这不是真正的硬件，但我会提到我使用过的存储协议。我选择Dropbox作为将照片上传到云端的最简单，最便宜的方式，我还使用此媒体将移动客户端与控制中心进行通信，使用带有&lt;span&gt;&lt;a href=&quot;http://www.codesocang.com/plus/search.php?typeid=0&amp;amp;q=json&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JSON格式数据&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;的文本文件。&lt;/p&gt;
&lt;h2&gt;控制中心&lt;/h2&gt;
&lt;p&gt;在ThiefWatcher项目中，实现了中央控制应用程序。它是一个桌面MDI Windows应用程序，基本上有两种不同的窗口类型。其中一个是控制面板，您可以在其中设置所有协议，而不是摄像机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223136373-1861180782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顶部窗格用于触发器协议。在这里，您可以选择要使用的协议，提供具有相应设置的连接字符串（可以从协议到另一个不同），系统必须启动监视模式的开始日期/时间（如果您不提供，系统启动（中间），停止监视的结束日期/时间，您可以配置检测到入侵者时拍摄的照片数量和照片之间的秒数（整数）。&lt;/p&gt;
&lt;p&gt;此窗格下方是通知（警报）协议。在下拉列表右侧选择协议，您有一个测试按钮，允许您测试此协议，而无需进行任何模拟。您还必须提供带参数设置的字符串连接，并在协议允许数据传输的情况下提供可选消息。&lt;/p&gt;
&lt;p&gt;底部窗格用于存储协议。您有一个连接字符串来设置参数（如果有）和一个用于存储数据的容器名称，可以是本地文件夹，FTP文件夹，Azure blob容器名称等。&lt;/p&gt;
&lt;p&gt;命令按钮从左到右依次为Start Simulacrum，它启动或停止系统，就像检测到入侵者一样，因此您可以测试摄像机和存储协议以及与客户端的通信。在此模式下，不考虑开始和结束日期。接下来，“ 开始”按钮启动或停止实际监控模式。相机形式中没有显示图像（假设没有人在场）。最后，“ 保存”按钮会在配置文件中写入更改。&lt;/p&gt;
&lt;p&gt;在代码使用部分，我将评论我已实现的所有协议的连接字符串的参数。&lt;/p&gt;
&lt;p&gt;关于摄像机协议，每个摄像机的配置都在摄像机窗口中执行，您可以使用File / New Camera ...菜单选项显示摄像机窗口。首先，您必须为要添加的摄像机选择正确的摄像机协议，然后，您必须提供连接数据，摄像机URL，用户名和密码。然后，你可以看到这样一个窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223143876-1748342116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工具栏左侧的第一个按钮用于更改访问设置，第二个按钮用于显示相机设置对话框，该对话框在相应的协议中实现。然后，您有一个启动按钮和其他停止相机的按钮，因此您可以在配置相机时观看图像。摄像机ID必须是唯一的并且是必需的，因为您将使用此ID从客户端选择摄像机。最后两个按钮用于将摄像机保存在配置文件中或将其删除。&lt;/p&gt;
&lt;p&gt;所有这些设置都存储在应用程序  App.config文件中。connectionStrings部分中的连接字符串，appSettings部分中的其他协议设置。还有两个自定义部分用于存储协议列表以及不同的摄像机及其设置。&lt;/p&gt;
&lt;p&gt;该cameraSection islike这样的：&lt;/p&gt;
&lt;pre&gt;
&amp;lt;camerasSection&amp;gt;
    &amp;lt;cameras&amp;gt;
        &amp;lt;cameraData id=&quot;CAMNW&quot;
            protocolName=&quot;NetWave IP camera&quot;
            connectionStringName=&quot;CAMNW&quot; /&amp;gt;
        &amp;lt;cameraData id=&quot;VAPIX&quot;
            protocolName=&quot;VAPIX IP Camera&quot;
            connectionStringName=&quot;VAPIX&quot; /&amp;gt;
    &amp;lt;/cameras&amp;gt;
&amp;lt;/camerasSection&amp;gt;
&lt;/pre&gt;
&lt;p&gt;每个照相机是一个cameraData元件，具有一个ID属性，protocolName与相应协议的名称属性，和一个的connectionStringName用于连接数据属性：URL，userName的和密码，存储在一个连接字符串中的ConnectionStrings部分。&lt;/p&gt;
&lt;p&gt;还有一个protocolsSection，包含已安装协议的列表：&lt;/p&gt;
&lt;pre&gt;
&amp;lt;protocolsSection&amp;gt;
    &amp;lt;protocols&amp;gt;
        &amp;lt;protocolData name=&quot;Arduino Simple Trigger&quot;
            class=&quot;trigger&quot;
            type=&quot;ArduinoSimpleTriggerProtocol.ArduinoTrigger, ArduinoSimpleTriggerProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;Lync Notifications&quot;
            class=&quot;alarm&quot;
            type=&quot;LyncProtocol.LyncAlarmChannel, LyncProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;AT Modem Notifications&quot;
            class=&quot;alarm&quot;
            type=&quot;ATModemProtocol.ATModemAlarmChannel, ATModemProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;Azure Blob Storage&quot;
            class=&quot;storage&quot;
            type=&quot;AzureBlobProtocol.AzureBlobManager, AzureBlobProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;NetWave IP camera&quot;
            class=&quot;camera&quot;
            type=&quot;NetWaveProtocol.NetWaveCamera, NetWaveProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;VAPIX IP Camera&quot;
            class=&quot;camera&quot;
            type=&quot;VAPIXProtocol.VAPIXCamera, VAPIXProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
        &amp;lt;protocolData name=&quot;DropBox Storage&quot;
            class=&quot;storage&quot;
            type=&quot;DropBoxProtocol.DropBoxStorage, DropBoxProtocol, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; /&amp;gt;
    &amp;lt;/protocols&amp;gt;
&amp;lt;/protocolsSection&amp;gt;
&lt;/pre&gt;
&lt;p&gt;每个协议有一个名字，一类，以确定它们的用法（触发，报警，存储或相机）和类型与所述完整的类型，其实现协议的类。&lt;/p&gt;
&lt;p&gt;您可以使用File / Install Protocol / s ...菜单选项向此部分添加新协议，选择具有协议或协议实现的类库。&lt;/p&gt;
&lt;h2&gt;客户&lt;/h2&gt;
&lt;p&gt;无论您身在何处，应用程序都必须通知您可能的入侵，因此我将客户端实现为移动应用程序。几乎所有平台快速拥有应用程序版本的最简单方法是使用Xamarin来执行此操作，因此这是我选择的方法。&lt;/p&gt;
&lt;p&gt;该TWClientApp PCL（便携式类库）项目包含在客户端几乎所有的代码。在不同平台的具体项目中，只有代码保存文件，将摄像头拍摄的照片保存在手机内存中，以便您尽快将其提供给警方。&lt;/p&gt;
&lt;p&gt;这是我的第一个移动App项目，所以它不是很复杂。这里我没有使用依赖注入。相反，我只实现了Dropbox存储协议，因此，如果要使用另一个协议，则必须更改PCL库中的代码。此协议的优点是您可以使用Dropbox实际客户端获取照片，而无需使用ThiefWatcher客户端（尽管您失去了应用程序控制功能）。&lt;/p&gt;
&lt;p&gt;启动客户端应用程序时，必须按“ 连接”按钮才能向主应用程序发送标识消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223151176-2134941561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，将相机列表发送到客户端。您可以按相应的按钮选择其中一个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223159160-293112867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您可以观看相机的当前图像。通常，您不能等待真正的视频流，因为上传每个图像可能会非常慢。中央控制实时获取帧，但Dropbox每上传花费最多两秒钟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223206067-578582020.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您可以使用按钮启动/停止相机，拍照或结束闹钟模式（在结束闹钟模式之前无需停止相机）。&lt;/p&gt;
&lt;p&gt;照片显示在底部的列表中，您可以将其保存到手机或删除它们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1270661/201812/1270661-20181220223212569-876638384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我无法测试iOS版本，因为我没有MAC，但Windows Phone和Android Apps工作正常。&lt;/p&gt;
&lt;h2&gt;使用代码&lt;/h2&gt;
&lt;p&gt;不同的协议接口在WatcherCommons项目的Interfaces名称空间中定义。摄像机协议是IWatcherCamera，定义如下：&lt;/p&gt;
&lt;pre&gt;
public class FrameEventArgs : EventArgs
{
    public FrameEventArgs(Bitmap bmp)
    {
        Image = bmp;
    }
    public Bitmap Image { get; private set; }
}
public delegate void NewFrameEventHandler(object sender, FrameEventArgs e);
public interface IWatcherCamera
{
    event NewFrameEventHandler OnNewFrame;
    Size FrameSize { get; }
    string ConnectionString { get; set; }
    string UserName { get; set; }
    string Password { get; set; }
    string Uri { get; set; }
    int MaxFPS { get; set; }
    bool Status { get; }
    ICameraSetupManager SetupManager { get; }
    void Initialize();
    void ShowCameraConfiguration(Form parent);
    void Start();
    void Close();
}
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;OnNewFrame：当图像准备好发送到应用程序时触发事件处理程序。图像在FrameEventArgs参数的Image属性中作为Bitmap传递。&lt;/li&gt;
&lt;li&gt;FrameSize：摄像机图像的当前宽度和高度。&lt;/li&gt;
&lt;li&gt;ConnectionString：用分号分隔的字符串，用于定义摄像机访问参数。在我实现的协议中，参数是url，userName和password，如下所示：url = http：//192.168.1.20; userName = root; password = root。&lt;/li&gt;
&lt;li&gt;UserName，Password和Uri：与连接字符串中的相同。&lt;/li&gt;
&lt;li&gt;MaxFps：设置捕获率。&lt;/li&gt;
&lt;li&gt;状态：如果摄像机正在运行，则为true。&lt;/li&gt;
&lt;li&gt;SetupManager：与摄像机设置对话框的界面。用于在用户更改摄像机图像大小时在应用程序中触发事件，以便可以正确调整摄像机表单的大小。&lt;/li&gt;
&lt;li&gt;初始化：根据需要重置内部状态。&lt;/li&gt;
&lt;li&gt;ShowCameraConfiguration：显示摄像机配置对话框。它必须不是模态的，因此如果相机正在显示图像，您可以观察更改。&lt;/li&gt;
&lt;li&gt;开始：开始图像捕获。这是在一个单独的线程中执行的，您必须在新帧事件中与相机交互时将其考虑在内。&lt;/li&gt;
&lt;li&gt;停止：停止捕获。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该NetWave协议在实施NetWaveProtocol项目和VAPIX在协议VAPIXProtocol项目。&lt;/p&gt;
&lt;p&gt;触发器协议ITrigger如下：&lt;/p&gt;
&lt;pre&gt;
 public interface ITrigger
{
    event EventHandler OnTriggerFired;
    string ConnectionString { get; set; }
    void Initialize();
    void Start();
    void Stop();
}
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;OnTriggerFired：在检测到触发条件时触发。&lt;/li&gt;
&lt;li&gt;ConnectionString：带有配置参数的字符串。在我已经实现的协议中，在ArduinoSimpleTriggerProtocol项目中，它们是端口和波特率，如下所示：port = COM4; baudrate = 9600。请记住在Arduino代码中设置相同的波特率。&lt;/li&gt;
&lt;li&gt;初始化：根据需要重置intarnal状态。&lt;/li&gt;
&lt;li&gt;开始：开始侦听触发条件。这是在一个单独的线程中完成的。&lt;/li&gt;
&lt;li&gt;停止：停止听。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通知协议IAlarmChannel也很简单：&lt;/p&gt;
&lt;pre&gt;
public interface IAlarmChannel
{
    string ConnectionString { get; set; }
    string MessageText { get; set; }
    void Initialice();
    void SendAlarm();
} 
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ConnectionString：带有配置参数的字符串。&lt;/li&gt;
&lt;li&gt;MessageText：如果协议允许，则发送消息。&lt;/li&gt;
&lt;li&gt;初始化：重置内部状态。&lt;/li&gt;
&lt;li&gt;SendAlarm：向客户端发送通知。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我实现的协议是ATModemProtocol项目，它使用AT调制解调器拨打一个或多个电话号码，并具有以下配置参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;port：连接调制解调器的COM端口。&lt;/li&gt;
&lt;li&gt;波特率：设置端口波特率。&lt;/li&gt;
&lt;li&gt;initdelay：拨号前等待的延迟时间（以毫秒为单位）。&lt;/li&gt;
&lt;li&gt;number：逗号分隔的电话号码列表。&lt;/li&gt;
&lt;li&gt;ringduration：挂机前的时间，以毫秒为单位。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一个协议使用Skype或Lync通知用户。它在LyncProtocol项目中实现。连接字符串是以分号分隔的Skype或Lync用户地址列表。您必须在主计算机和客户端上安装Lync客户端。&lt;/p&gt;
&lt;p&gt;后者是存储协议，此协议使用的数据在WatcherCommons类库的Data命名空间中定义。有两个不同的类，ControlCommand用于摄像头命令：&lt;/p&gt;
&lt;pre&gt;
[DataContract]
public class ControlCommand
{
    public const int cmdGetCameraList = 1;
    public const int cmdStopAlarm = 2;
    public ControlCommand()
    {
    }
    public static ControlCommand FromJSON(Stream s)
    {
        s.Position = 0;
        StreamReader rdr = new StreamReader(s);
        string str = rdr.ReadToEnd();
        return JsonConvert.DeserializeObject&amp;lt;ControlCommand&amp;gt;(str);
    }
    public static void ToJSON(Stream s, ControlCommand cc)
    {
        s.Position = 0;
        string js = JsonConvert.SerializeObject(cc);
        StreamWriter wr = new StreamWriter(s);
        wr.Write(js);
        wr.Flush();
    }
    [DataMember]
    public int Command { get; set; }
    [DataMember]
    public string ClientID { get; set; }
}
&lt;/pre&gt;
&lt;p&gt;命令以JSON格式发送和接收。在Command成员中传递了两个不同的commnand，一个用于向应用程序注册并获取摄像机列表，另一个用于停止警报并将应用程序重置为监视模式。&lt;/p&gt;
&lt;p&gt;该客户端ID构件唯一地标识每个客户端。&lt;/p&gt;
&lt;p&gt;CameraInfo也是以JSON格式交换有关摄像机的请求和响应：&lt;/p&gt;
&lt;pre&gt;
[DataContract]
public class CameraInfo
{
    public CameraInfo()
    {
    }
    public static List&amp;lt;CameraInfo&amp;gt; FromJSON(Stream s)
    {
        s.Position = 0;
        StreamReader rdr = new StreamReader(s);
        return JsonConvert.DeserializeObject&amp;lt;List&amp;lt;CameraInfo&amp;gt;&amp;gt;(rdr.ReadToEnd());
    }
    public static void ToJSON(Stream s, List&amp;lt;CameraInfo&amp;gt; ci)
    {
        s.Position = 0;
        string js = JsonConvert.SerializeObject(ci);
        StreamWriter wr = new StreamWriter(s);
        wr.Write(js);
        wr.Flush();
    }
    [DataMember]
    public string ID { get; set; }
    [DataMember]
    public bool Active { get; set; }
    [DataMember]
    public bool Photo { get; set; }
    [DataMember]
    public int Width { get; set; }
    [DataMember]
    public int Height { get; set; }
    [DataMember]
    public string ClientID { get; set; }
} 
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ID：摄像机标识符。&lt;/li&gt;
&lt;li&gt;活动：相机状态。&lt;/li&gt;
&lt;li&gt;照片：用于要求相机拍照。&lt;/li&gt;
&lt;li&gt;宽度和高度：相机图像尺寸。&lt;/li&gt;
&lt;li&gt;ClientID：客户端唯一标识符。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当您请求摄像机列表时，您会收到一个带有一系列CameraInfo对象的响应，每个摄像机对应一个。&lt;/p&gt;
&lt;p&gt;实现协议的接口是IStorageManager：&lt;/p&gt;
&lt;pre&gt;
public interface IStorageManager
{
    string ConnsecionString { get; set; }
    string ContainerPath { get; set; }
    void UploadFile(string filename, Stream s);
    void DownloadFile(string filename, Stream s);
    void DeleteFile(string filename);
    bool ExistsFile(string filename);
    IEnumerable&amp;lt;string&amp;gt; ListFiles(string model);
    IEnumerable&amp;lt;ControlCommand&amp;gt; GetCommands();
    IEnumerable&amp;lt;List&amp;lt;CameraInfo&amp;gt;&amp;gt; GetRequests();
    void SendResponse(List&amp;lt;CameraInfo&amp;gt; resp);
} 
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ConnectionString：带有配置参数的字符串。&lt;/li&gt;
&lt;li&gt;ContainerPath：标识文件夹，blob容器名称等。&lt;/li&gt;
&lt;li&gt;UploadFile：发送Stream对象中提供的文件。&lt;/li&gt;
&lt;li&gt;DownloadFile：在提供的Stream对象中获取文件。&lt;/li&gt;
&lt;li&gt;DeleteFile：删除文件。&lt;/li&gt;
&lt;li&gt;ExistsFile：测试文件是否存在。&lt;/li&gt;
&lt;li&gt;ListFiles：枚举文件夹中的文件，其名称的开头必须与模型参数匹配  。&lt;/li&gt;
&lt;li&gt;GetCommands：枚举客户端发送的命令。&lt;/li&gt;
&lt;li&gt;GetRequests：枚举客户端发送的摄像头请求。&lt;/li&gt;
&lt;li&gt;SendResponse：发送命令或摄像机请求的响应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我已经实现了两个存储协议。该DropBoxProtocol项目实施与使用的协议的Dropbox。在服务器端，这只是读取和写入Dropbox文件夹的文件。不需要连接字符串，因为文件夹是单独配置的。&lt;/p&gt;
&lt;p&gt;在客户端中，这是实现的协议。它略有不同，界面在TWClientApp项目中定义：&lt;/p&gt;
&lt;pre&gt;
public interface IStorageManager
{
    Task DownloadFile(string filename, Stream s);
    Task DeleteFile(string filename);
    Task&amp;lt;bool&amp;gt; ExistsFile(string filename);
    Task&amp;lt;List&amp;lt;string&amp;gt;&amp;gt; ListFiles(string model);
    Task SendCommand(ControlCommand cmd);
    Task SendRequest(List&amp;lt;CameraInfo&amp;gt; req);
    Task&amp;lt;List&amp;lt;CameraInfo&amp;gt;&amp;gt; GetResponse(string id);
} 
&lt;/pre&gt;
&lt;p&gt;它是一个异步接口，成员数少于服务器端。实现并不像服务器那么容易; 我们必须使用Dropbox API与之交互。实现在DropBoxStorage类中，并且在_accessKey常量中，您必须将安全密钥设置为成功建立连接（在第一次编译代码之前不要忘记这样做，因为没有默认值）。&lt;/p&gt;
&lt;pre&gt;
private const string _accessKey = &quot;&quot;; 
&lt;/pre&gt;
&lt;p&gt;客户端App的几乎所有代码都在TWClientApp项目中，在CameraPage类中。数据的交换协议是通过文件，每个文件都有一个特殊的名称来识别它。这些是不同的文件名模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;摄像机只写一个帧文件，当客户端读取帧时，它删除文件，服务器可以写另一个。该文件是jpg图片，名称为&amp;lt;CAMERA ID&amp;gt; _FRAME_ &amp;lt;CLIENT ID&amp;gt; .jpg。&lt;/li&gt;
&lt;li&gt;照片的名称相似，可能有多张照片。名称模式为：&amp;lt;CAMERA ID&amp;gt; _PHOTO_yyyyMMddHHmmss.jpg。&lt;/li&gt;
&lt;li&gt;客户端可以以JSON文本格式和名称cmd_ &amp;lt;CLIENT ID&amp;gt; .json将命令一次发送到服务器。&lt;/li&gt;
&lt;li&gt;当服务器获取命令文件时，它会删除该文件，因此客户端可以发送另一个命令，并执行该命令。然后，它编写一个名为resp_ &amp;lt;CLIENT ID&amp;gt; .json的响应文件。&lt;/li&gt;
&lt;li&gt;最后，客户端可以发送相机请求，例如拍摄照片，或以JSON格式在名为req_ &amp;lt;CLIENT ID&amp;gt; .json的文件中启动或停止相机。服务器读取文件，删除它，并将请求传递给摄像机进行处理，然后，服务器写入响应文件，就像命令一样，具有摄像机状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该NetWave相机协议配置对话框非常简单，你可以阅读更多关于此协议中我的博客。&lt;/p&gt;
&lt;p&gt;至于VAPIX协议，它更复杂，因为它是专业相机的协议。我没有使用包含大量控件的复杂对话框，而是实现了一个包含所有配置参数的树视图（它们是很多配置参数），您可以在其中选择每个参数并更改值。您也可以在我的博客中阅读更多相关信息。&lt;/p&gt;
&lt;p&gt;这就是全部，享受解决方案，并感谢阅读！&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 14:30:00 +0000</pubDate>
<dc:creator>九天飞翼</dc:creator>
<og:description>在您的手机中通知您家中的入侵者，并拍摄他们的照片 介绍 在本文中，我将展示一些DIY东西​​，用于安装监控系统，检测家中的入侵者，拍摄照片并通过手机通知您，必要时可以打电话给警察并提供照片以便快速识别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/langda/p/10152871.html</dc:identifier>
</item>
<item>
<title>什么是多模态机器学习？ - 计算机视觉life</title>
<link>http://www.cnblogs.com/CV-life/p/10152745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CV-life/p/10152745.html</guid>
<description>&lt;p&gt;首先，什么叫做模态（Modality）呢？&lt;/p&gt;
&lt;p&gt;每一种信息的来源或者形式，都可以称为一种模态。例如，人有触觉，听觉，视觉，嗅觉；信息的媒介，有语音、视频、文字等；多种多样的传感器，如雷达、红外、加速度计等。以上的每一种都可以称为一种模态。&lt;/p&gt;
&lt;p&gt;同时，模态也可以有非常广泛的定义，比如我们可以把两种不同的语言当做是两种模态，甚至在两种不同情况下采集到的数据集，亦可认为是两种模态。&lt;/p&gt;
&lt;p&gt;因此，多模态机器学习，英文全称 MultiModal Machine Learning (MMML)，旨在通过机器学习的方法实现处理和理解多源模态信息的能力。目前比较热门的研究方向是图像、视频、音频、语义之间的多模态学习。&lt;/p&gt;
&lt;p&gt;多模态学习从1970年代起步，经历了几个发展阶段，在2010后全面步入Deep Learning阶段。&lt;/p&gt;
&lt;p&gt;人其实是一个多模态学习的总和，所以也有”砖家“说了，多模态学习才是真正的人工智能发展方向。&lt;/p&gt;
&lt;p&gt;本文将针对多模态学习在深度学习发面的研究方向和应用做相关介绍，主要参考了来自ACL 2017的《&lt;a href=&quot;https://www.cs.cmu.edu/~morency/MMML-Tutorial-ACL2017.pdf&quot;&gt;Tutorial on Multimodal Machine Learning&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;多模态学习可以划分为以下五个研究方向：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;多模态表示学习 Multimodal Representation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模态转化 Translation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对齐 Alignment&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多模态融合 Multimodal Fusion&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协同学习 Co-learning&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面将针对这五大研究方向，逐一进行介绍。&lt;/p&gt;

&lt;p&gt;单模态的表示学习负责将信息表示为计算机可以处理的数值向量或者进一步抽象为更高层的特征向量，而多模态表示学习是指通过利用多模态之间的互补性，剔除模态间的冗余性，从而学习到更好的特征表示。主要包括两大研究方向：&lt;strong&gt;联合表示（Joint Representations）&lt;/strong&gt;和&lt;strong&gt;协同表示（Coordinated Representations）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;联合表示将多个模态的信息一起映射到一个统一的多模态向量空间；&lt;/li&gt;
&lt;li&gt;协同表示负责将多模态中的每个模态分别映射到各自的表示空间，但映射后的向量之间满足一定的相关性约束（例如线性相关）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18db70a2588.png&quot; alt=&quot;联合表示和协同表示对比图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用多模态表示学习到的特征可以用来做信息检索，也可以用于的分类/回归任务。下面列举几个经典的应用。&lt;/p&gt;
&lt;p&gt;在来自 NIPS 2012 的 《Multimodal learning with deep boltzmann machines》一文中提出将 deep boltzmann machines（DBM） 结构扩充到多模态领域，通过 Multimodal DBM，可以学习到多模态的联合概率分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18db71b685b.png&quot; alt=&quot;单模态和多模态DBM对比图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;论文中的实验通过 Bimodal DBM，学习图片和文本的联合概率分布 P(图片，文本)。在应用阶段，输入图片，利用条件概率 P(文本|图片)，生成文本特征，可以得到图片相应的文本描述；而输入文本，利用条件概率 P(图片|文本)，可以生成图片特征，通过检索出最靠近该特征向量的两个图片实例，可以得到符合文本描述的图片。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18db739e366.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;协同表示学习一个比较经典且有趣的应用是来自于《Unifying Visual-Semantic Embeddings with Multimodal Neural Language Models 》这篇文章。利用协同学习到的特征向量之间满足加减算数运算这一特性，可以搜索出与给定图片满足“指定的转换语义”的图片。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;狗的图片特征向量 - 狗的文本特征向量 + 猫的文本特征向量 = 猫的图片特征向量 -&amp;gt; 在特征向量空间，根据最近邻距离，检索得到猫的图片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc860b902.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转化也称为映射，负责将一个模态的信息转换为另一个模态的信息。常见的应用包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器翻译（Machine Translation）：&lt;/strong&gt;将输入的语言A（即时）翻译为另一种语言B。类似的还有&lt;strong&gt;唇读（Lip Reading）&lt;/strong&gt;和&lt;strong&gt;语音翻译 （Speech Translation）&lt;/strong&gt;，分别将唇部视觉和语音信息转换为文本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc7e129c2.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片描述（Image captioning) 或者视频描述（Video captioning)：&lt;/strong&gt; 对给定的图片/视频形成一段文字描述，以表达图片/视频的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dd1c663f0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语音合成（Speech Synthesis）：&lt;/strong&gt;根据输入的文本信息，自动合成一段语音信号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dd15ca6f8.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模态间的转换主要有两个难点，一个是open-ended，即未知结束位，例如实时翻译中，在还未得到句尾的情况下，必须实时的对句子进行翻译；另一个是subjective，即主观评判性，是指很多模态转换问题的效果没有一个比较客观的评判标准，也就是说目标函数的确定是非常主观的。例如，在图片描述中，形成怎样的一段话才算是对图片好的诠释？也许一千个人心中有一千个哈姆雷特吧。&lt;/p&gt;

&lt;p&gt;多模态的对齐负责对来自同一个实例的不同模态信息的子分支/元素寻找对应关系。这个对应关系可以是时间维度的，比如下图所示的 &lt;strong&gt;Temporal sequence alignment&lt;/strong&gt;，将一组动作对应的视频流同骨骼图片对齐。类似的还有电影画面-语音-字幕的自动对齐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc8196584.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对齐又可以是空间维度的，比如&lt;strong&gt;图片语义分割 （Image Semantic Segmentation）：&lt;/strong&gt;尝试将图片的每个像素对应到某一种类型标签，实现视觉-词汇对齐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc863ccd7.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;多模态融合（Multimodal Fusion ）负责联合多个模态的信息，进行目标预测（分类或者回归），属于 MMML 最早的研究方向之一，也是目前应用最广的方向，它还存在其他常见的别名，例如多源信息融合（Multi-source Information Fusion）、多传感器融合（Multi-sensor Fusion)。&lt;/p&gt;
&lt;p&gt;按照融合的层次，可以将多模态融合分为 pixel level，feature level 和 decision level 三类，分别对应对原始数据进行融合、对抽象的特征进行融合和对决策结果进行融合。而 feature level 又可以分为 early 和 late 两个大类，代表了融合发生在特征抽取的早期和晚期。当然还有将多种融合层次混合的 hybrid 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc7cc6c10.png&quot; alt=&quot;融合层次示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常见的机器学习方法都可以应用于多模态融合，下面列举几个比较热门的研究方向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视觉-音频识别（Visual-Audio Recognition）：&lt;/strong&gt; 综合源自同一个实例的视频信息和音频信息，进行识别工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc7cf1879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多模态情感分析（Multimodal sentiment analysis）：&lt;/strong&gt; 综合利用多个模态的数据（例如下图中的文字、面部表情、声音），通过互补，消除歧义和不确定性，得到更加准确的情感类型判断结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc7f586de.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手机身份认证（Mobile Identity Authentication）：&lt;/strong&gt; 综合利用手机的多传感器信息，认证手机使用者是否是注册用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc81d90df.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多模态融合研究的难点主要包括如何判断每个模态的置信水平、如何判断模态间的相关性、如何对多模态的特征信息进行降维以及如何对非同步采集的多模态数据进行配准等。&lt;/p&gt;
&lt;p&gt;若想了解传统的机器学习方法在此领域的应用，推荐学习清华大学出版的《多源信息融合》（韩崇昭等著）一书。&lt;/p&gt;

&lt;p&gt;协同学习是指使用一个资源丰富的模态信息来辅助另一个资源相对贫瘠的模态进行学习。&lt;/p&gt;
&lt;p&gt;比如&lt;strong&gt;迁移学习（Transfer Learning）&lt;/strong&gt;就是属于这个范畴，绝大多数迈入深度学习的初学者尝试做的一项工作就是将 ImageNet 数据集上学习到的权重，在自己的目标数据集上进行微调。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc86b81d8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迁移学习比较常探讨的方面目前集中在&lt;strong&gt;领域适应性（Domain Adaptation）&lt;/strong&gt;问题上，即如何将train domain上学习到的模型应用到 application domain。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dc82a8849.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迁移学习领域著名的还有&lt;strong&gt;零样本学习（Zero-Shot Learning）&lt;/strong&gt;和&lt;strong&gt;一样本学习（One-Shot Learning）&lt;/strong&gt;，很多相关的方法也会用到领域适应性的相关知识。&lt;/p&gt;
&lt;p&gt;Co-learning 中还有一类工作叫做&lt;strong&gt;协同训练（Co-training ）&lt;/strong&gt;，它负责研究如何在多模态数据中将少量的标注进行扩充，得到更多的标注信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/18/5c18dd160e01b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过以上应用我们可以发现，协同学习是与需要解决的任务无关的，因此它可以用于辅助多模态映射、融合及对齐等问题的研究。&lt;/p&gt;

&lt;p&gt;到此为止，我们对多模态机器学习领域的研究方向和应用进行了一个大致的梳理，受限于篇幅，还有许多未涉及的研究问题。&lt;/p&gt;
&lt;p&gt;有什么读后感吗？&lt;/p&gt;
&lt;p&gt;也许你以前没有听过多模态学习（MMML）这个概念，读了此文发现原来自己做的正是 MMML 一个分支；&lt;/p&gt;
&lt;p&gt;也许你以前觉得 CV / NLP / SSP 才是人工智能的正统，读了此文发现多学科交叉的 MMML 一样可以玩 DL 溜得飞起；&lt;/p&gt;
&lt;p&gt;也许你目前正苦于找不到研究的方向，读了此文发现 MMML 打开了新的大门，原来有这么多的事情可以做。&lt;/p&gt;
&lt;p&gt;多模态学习是一个目前热度逐年递增的研究领域，如果大家感兴趣，欢迎留言反馈，后续我们会考虑推出几个热门 MMML 方向的经典or前沿论文、模型解析。&lt;/p&gt;

&lt;p&gt;如果想入门 MMML 或者希望对该领域有初步了解，可以从以下几篇综述入手&lt;/p&gt;
&lt;p&gt;【1】Atrey P K, Hossain M A, El Saddik A, et al. Multimodal fusion for multimedia analysis: a survey[J]. Multimedia systems, 2010, 16(6): 345-379.&lt;/p&gt;
&lt;p&gt;【2】Ramachandram D, Taylor G W. Deep multimodal learning: A survey on recent advances and trends[J]. IEEE Signal Processing Magazine, 2017, 34(6): 96-108.&lt;/p&gt;
&lt;p&gt;【3】Baltrušaitis T, Ahuja C, Morency L P. Multimodal machine learning: A survey and taxonomy[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2018.&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 14:05:00 +0000</pubDate>
<dc:creator>计算机视觉life</dc:creator>
<og:description>什么是多模态机器学习？ 首先，什么叫做模态（Modality）呢？ 每一种信息的来源或者形式，都可以称为一种模态。例如，人有触觉，听觉，视觉，嗅觉；信息的媒介，有语音、视频、文字等；多种多样的传感器，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CV-life/p/10152745.html</dc:identifier>
</item>
<item>
<title>Elasticsearch 通关教程（三）： 索引别名Aliases问题 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/10152681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/10152681.html</guid>
<description>&lt;p&gt;业务需求是不断变化迭代的，也许我们之前写的某个业务逻辑在下个版本就变化了，我们可能需要修改原来的设计，例如数据库可能需要添加一个字段或删减一个字段，而在搜索中也会发生这件事，即使你认为现在的索引设计已经很完美了，在生产环境中，还是有可能需要做一些修改的，需要添加映射字段或者需要修改字段类型等等。&lt;/p&gt;
&lt;p&gt;数据库中我们可以直接修改原来的表设计语句，前提是需要做好数据迁移。但是在 Elasticsearch 中就没那么简单了。尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是不能添加新的分析器或者对现有的字段做改动。如果你那么做的话，结果就是那些已经被索引的数据就不正确，搜索也不能正常工作。针对这个问题必须重新建立索引。&lt;/p&gt;

&lt;p&gt;重新建立索引的问题是必须更新应用中的索引名称，索引别名就是用来解决这个问题的！&lt;/p&gt;
&lt;p&gt;假设我们有个学生的原始索引 student_index_v1，我们给它起个别名 student_index，程序中也是用别名 student_index 进行搜索，当我们的业务需求发生改变需要修改索引的时候，我们重新创建个索引 student_index_v2，同时将别名 student_index 指向新的索引 student_index_v2，同时将 student_index_v1 的数据迁移到新的 student_index_v2，这样我们就可以做到在零停机下从旧索引切换到新索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引别名&lt;/strong&gt;就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用，而且别名不能与索引同名。&lt;/p&gt;
&lt;p&gt;别名带给我们极大的灵活性，允许我们做下面这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行的集群中可以无缝的从一个索引切换到另一个索引。&lt;/li&gt;
&lt;li&gt;给多个索引分组。&lt;/li&gt;
&lt;li&gt;给索引的一个子集创建视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;别名还可以映射到某个索引也可以映射到多个索引。别名还可以与筛选器关联，筛选器将在搜索和路由值时自动应用，别名不能与索引同名。&lt;/p&gt;
&lt;p&gt;Elasticsearch 中有两种方式管理别名： &lt;code&gt;_alias&lt;/code&gt; 用于单个操作， &lt;code&gt;_aliases&lt;/code&gt; 用于执行多个原子级操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个索引别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重命名别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } },
        { &quot;add&quot; : { &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重命名别名是一个简单的删除然后指向新的索引。这个操作是原子性的，因此不需要担心短时间内的别名不指向一个索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将别名与多个索引关联&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } },
        { &quot;add&quot; : { &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;亦可以通过索引数组的方式来实现&lt;/p&gt;
&lt;pre class=&quot;josn&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;add&quot; : { &quot;indices&quot; : [&quot;test1&quot;, &quot;test2&quot;], &quot;alias&quot; : &quot;alias1&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面的示例，还可以使 &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob pattern&lt;/a&gt; 将别名关联到拥有公共名称的多个索引:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        { &quot;add&quot; : { &quot;index&quot; : &quot;test*&quot;, &quot;alias&quot; : &quot;all_test_indices&quot; } }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Filtered Aliases&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过滤器别名提供了一个简单的方法对同一个索引来创建不同的“视图”。过滤器能够使用Query DSL来定义并且被应用到所有的搜索，统计，通过查询删除和其它类似的行为。&lt;/p&gt;
&lt;p&gt;为了创建一个带过滤器的别名，首先需要确保映射的字段已经存在于mapping中。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /test1
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: {
      &quot;properties&quot;: {
        &quot;user&quot; : {
          &quot;type&quot;: &quot;keyword&quot;
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以创建一个在user字段上带过滤器的别名。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        {
            &quot;add&quot; : {
                 &quot;index&quot; : &quot;test1&quot;,
                 &quot;alias&quot; : &quot;alias2&quot;,
                 &quot;filter&quot; : { &quot;term&quot; : { &quot;user&quot; : &quot;kimchy&quot; } }
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功则返回&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{&quot;acknowledged&quot;:true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样设置之后，我们通过 test1 这个 index 直接进行搜索可以看到索引的全部文档，但是通过 alias2 这个别名就只能看到符合过滤器过滤后的结果了，即只有一个 user 为 &quot;kimchy&quot; 的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Routing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以将路由值与别名关联。这个特性可以与过滤别名一起使用，以避免不必要的碎片操作。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;何为路由？&lt;/strong&gt;&lt;br/&gt;所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档---例如所有属于同一个用户的文档都被存储到同一个分片中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下命令创建一个指向索引 test 的新别名 alias1。创建 alias1 后，所有具有此别名的操作将自动修改为使用值 1 进行路由:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        {
            &quot;add&quot; : {
                 &quot;index&quot; : &quot;test&quot;,
                 &quot;alias&quot; : &quot;alias1&quot;,
                 &quot;routing&quot; : &quot;1&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以为搜索和索引操作指定不同的路由值&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot; : [
        {
            &quot;add&quot; : {
                 &quot;index&quot; : &quot;test&quot;,
                 &quot;alias&quot; : &quot;alias2&quot;,
                 &quot;search_routing&quot; : &quot;1,2&quot;,
                 &quot;index_routing&quot; : &quot;2&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上例所示，&lt;span&gt;搜索路由(search_routing)可能包含几个用逗号分隔的多个值&lt;/span&gt;，但是 &lt;span&gt;索引路由(index_routing)就只能包含一个值&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果使用路由别名的搜索操作也有路由参数，则使用搜索别名路由和参数中指定的路由的交集。例如，下面的命令将使用“2”作为路由值。因为搜索操作中有路由参数2,3，而搜索路由设置的是1,2，所以取交集即为2。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /alias2/_search?q=user:kimchy&amp;amp;routing=2,3&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;仍然以上面学生的例子， student_index 是一个指向当前真实索引的别名。真实索引包含一个版本号： student_index_v1 ， student_index_v2 等等。&lt;/p&gt;
&lt;p&gt;首先，创建索引 student_index_v1 ，然后将别名 student_index 指向它：&lt;/p&gt;
&lt;pre class=&quot;http&quot;&gt;
&lt;code&gt;PUT /student_index_v1  // 创建索引 student_index_v1 。
PUT /student_index_v1/_alias/student_index  //设置别名 student_index 指向 student_index_v1 。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以检测这个别名指向哪一个索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /*/_alias/student_index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或哪些别名指向这个索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /student_index_v1/_alias/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两者都会返回下面的结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;student_index_v1&quot; : {
        &quot;aliases&quot; : {
            &quot;student_index&quot; : { }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们决定修改索引中一个字段的映射。当然，我们不能修改现存的映射，所以我们必须重新索引数据。 首先, 我们用新映射创建索引 student_index_v2 ：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /student_index_v2
{
    &quot;mappings&quot;: {
        &quot;my_type&quot;: {
            &quot;properties&quot;: {
                &quot;tags&quot;: {
                    &quot;type&quot;:   &quot;string&quot;,
                    &quot;index&quot;:  &quot;not_analyzed&quot;
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们将数据从 student_index_v1 索引到 student_index_v2 ，下面的过程在重新索引你的数据 中已经描述过。一旦我们确定文档已经被正确地重索引了，我们就将别名指向新的索引。&lt;/p&gt;
&lt;p&gt;一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 _aliases 操作：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST /_aliases
{
    &quot;actions&quot;: [
        { &quot;remove&quot;: { &quot;index&quot;: &quot;student_index_v1&quot;, &quot;alias&quot;: &quot;student_index&quot; }},
        { &quot;add&quot;:    { &quot;index&quot;: &quot;student_index_v2&quot;, &quot;alias&quot;: &quot;student_index&quot; }}
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过以上几步操作，你的应用就成功在零停机的情况下从旧索引迁移到新索引了。其实别名还有更多管理的语法。&lt;/p&gt;

&lt;p&gt;对于新旧索引的文档数据迁移，字段 _source 的一个优点是在Elasticsearch中已经有整个文档。你不必从源数据中重建索引，而且那样通常比较慢。&lt;/p&gt;
&lt;p&gt;为了有效的重新索引所有在旧的索引中的文档，用 scroll 从旧的索引检索批量文档 ， 然后用 bulk API 把文档推送到新的索引中。&lt;/p&gt;
&lt;p&gt;对现有数据的这类改变最简单的办法就是重新索引：用新的setting创建新的索引并把文档从旧的索引复制到新的索引。&lt;/p&gt;

&lt;p&gt;在你的应用中最好的方式是使用别名而不是索引名。这样你就可以在任何时候重建索引。别名的开销很小，应该广泛使用。本文主要整理自官方文档。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 13:47:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>业务问题 业务需求是不断变化迭代的，也许我们之前写的某个业务逻辑在下个版本就变化了，我们可能需要修改原来的设计，例如数据库可能需要添加一个字段或删减一个字段，而在搜索中也会发生这件事，即使你认为现在的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/10152681.html</dc:identifier>
</item>
<item>
<title>Stream 源码分析（串行流） - 竺旭东</title>
<link>http://www.cnblogs.com/zhuxudong/p/10152663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuxudong/p/10152663.html</guid>
<description>&lt;h4 id=&quot;stream&quot;&gt;Stream&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;支持顺序和并行聚合操作的一组元素序列。
    1）operations：支持在单个元素上执行的操作，流操作分为中间操作和终止操作
    1-1）中间操作：
        1-1-1）无状态：unordered()、filter()、map()、mapToInt()、mapToLong()、mapToDouble、
                      flatMap()、flatMapToInt()、flatMapToLong()、flatMapToDouble()、
                      peek()
        1-1-2）有状态：distinct()、sorted()、limit()、skip()
    1-2）终止操作：
        1-2-1）非短路操作：forEach()、forEachOrdered()、toArray()、min()、max()、count()、
                      collect()、reduce()
        1-2-2）短路操作： findFirst()、findAny()、anyMatch()、noneMatch()、allMatch()
    2）stream pipeline：将多个流操作串联的流管道
流是延迟处理的，直到遇到一个终止操作时，才会触发流管道计算。
已经执行终止操作的流不能再次触发计算。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;流管道&quot;&gt;流管道&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;流管道的创建【以 ArrayList 为数据源】：.stream()、parallelStream()&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collection#
    /**
     *  返回一个顺序流，集合中的元素就是数据源 
     */
    default Stream&amp;lt;E&amp;gt; stream() {
        return StreamSupport.stream(spliterator(), false);
    }

    /**
     *  返回一个并行流，集合中的元素就是数据源 
     */
    default Stream&amp;lt;E&amp;gt; parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }

ArrayList#
    /**
     * 创建一个延时绑定和快速失败的分割迭代器
     */
    @Override
    public Spliterator&amp;lt;E&amp;gt; spliterator() {
        return new ArrayListSpliterator(0, -1, 0);
    }

    /** 基于索引实现二分、延迟初始化的 Spliterator */
    final class ArrayListSpliterator implements Spliterator&amp;lt;E&amp;gt; {
        /**
         * 当前索引，在调用 advance/split 时修改
         */
        private int index;
        /**
         * 初始状态是 -1，使用之后是索引的上界
         */
        private int fence;
        /**
         * 快速失败计数器
         */
        private int expectedModCount;

        /** 创建一个覆盖给定索引范围的新  ArrayListSpliterator*/
        ArrayListSpliterator(int origin, int fence, int expectedModCount) {
            this.index = origin;
            this.fence = fence;
            this.expectedModCount = expectedModCount;
        }

        private int getFence() {
            int hi;
            // 第一次使用时初始化为元素个数
            if ((hi = fence) &amp;lt; 0) {
                expectedModCount = modCount;
                hi = fence = size;
            }
            return hi;
        }

        /**
         *  对此 Spliterator 进行拆分，一分为二
         */
        @Override
        public ArrayListSpliterator trySplit() {
            /**
             * hi：high 索引上界，不包括
             * lo：low 索引下界，包括
             * mid：middle 二分索引
             */
            final int hi = getFence(), lo = index, mid = lo + hi &amp;gt;&amp;gt;&amp;gt; 1;
        // 将范围分成两半，直到无法分割为止【高低索引相邻】
        return lo &amp;gt;= mid ? null : // divide range in half unless too small
            new ArrayListSpliterator(lo, index = mid, expectedModCount);
        }

        /**
         * 如果此 Spliterator 中还有元素可用，则将低索引位的元素传递给 action 进行消费
         * 同时递增 index【一次消费一个元素】
         */
        @Override
        public boolean tryAdvance(Consumer&amp;lt;? super E&amp;gt; action) {
            if (action == null) {
                throw new NullPointerException();
            }
            final int hi = getFence(), i = index;
            if (i &amp;lt; hi) {
                index = i + 1;
                @SuppressWarnings(&quot;unchecked&quot;)
                // 读取元素
                final E e = (E)elementData[i];
                // 执行消费过程
                action.accept(e);
                if (modCount != expectedModCount) {
                    throw new ConcurrentModificationException();
                }
                return true;
            }
            return false;
        }

        /**
         *  一次性消费此 Spliterator 中的所有元素
         */
        @Override
        public void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action) {
            int i, hi, mc; // hoist accesses and checks from loop
            Object[] a;
            if (action == null) {
                throw new NullPointerException();
            }
            if ((a = elementData) != null) {
                if ((hi = fence) &amp;lt; 0) {
                    mc = modCount;
                    hi = size;
                } else {
                    mc = expectedModCount;
                }
                // 读取并更新 index
                if ((i = index) &amp;gt;= 0 &amp;amp;&amp;amp; (index = hi) &amp;lt;= a.length) {
                    // 顺序消费 Spliterator 中的所有元素
                    for (; i &amp;lt; hi; ++i) {
                        @SuppressWarnings(&quot;unchecked&quot;)
                        final E e = (E) a[i];
                        action.accept(e);
                    }
                    if (modCount == mc) {
                        return;
                    }
                }
            }
            throw new ConcurrentModificationException();
        }

        /**
         * 获取此分割迭代器的估计可用元素数【ArrayListSpliterator 是精确的】
         */
        @Override
        public long estimateSize() {
            return getFence() - index;
        }

        /**
         *  此分割迭代器的特性
         */
        @Override
        public int characteristics() {
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        }
    }

StreamSupport#
    /**
     *  基于一个 Spliterator【分割迭代器】创建一个顺序或并行的流
     */
    public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(Spliterator&amp;lt;T&amp;gt; spliterator, boolean parallel) {
        Objects.requireNonNull(spliterator);
        return new ReferencePipeline.Head&amp;lt;&amp;gt;(spliterator,
                                            StreamOpFlag.fromCharacteristics(spliterator),
                                            parallel);
    }

StreamOpFlag#
    /**
     *  将 Spliterator 的特征值转换为流的标志位
     */
    static int fromCharacteristics(Spliterator&amp;lt;?&amp;gt; spliterator) {
        // 读取特征值
        final int characteristics = spliterator.characteristics();
        if ((characteristics &amp;amp; Spliterator.SORTED) != 0 &amp;amp;&amp;amp; spliterator.getComparator() != null) {
            // Do not propagate the SORTED characteristic if it does not correspond to a natural sort order
            return characteristics &amp;amp; SPLITERATOR_CHARACTERISTICS_MASK &amp;amp; ~Spliterator.SORTED;
        }
        else {
            // 转换为流标识
            return characteristics &amp;amp; SPLITERATOR_CHARACTERISTICS_MASK;
        }
    }


ReferencePipeline#Head
    static class Head&amp;lt;E_IN, E_OUT&amp;gt; extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
        /**
         * 创建流水线的管道头
         */
        Head(Spliterator&amp;lt;?&amp;gt; source,
                int sourceFlags, boolean parallel) {
            super(source, sourceFlags, parallel);
        }
    }

ReferencePipeline#
    /**
     *  创建流水线的管道头
     */
    ReferencePipeline(Spliterator&amp;lt;?&amp;gt; source,
            int sourceFlags, boolean parallel) {
        super(source, sourceFlags, parallel);
    }

AbstractPipeline#
abstract class AbstractPipeline&amp;lt;E_IN, E_OUT, S extends BaseStream&amp;lt;E_OUT, S&amp;gt;&amp;gt;
extends PipelineHelper&amp;lt;E_OUT&amp;gt; implements BaseStream&amp;lt;E_OUT, S&amp;gt; {
    private static final String MSG_STREAM_LINKED = &quot;stream has already been operated upon or closed&quot;;
    private static final String MSG_CONSUMED = &quot;source already consumed or closed&quot;;

    /**
     *  流水线的源阶段【即第一个流管道】
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private final AbstractPipeline sourceStage;

    /**
     *  当前流管道的上一阶段，如果是源流，则为 null
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private final AbstractPipeline previousStage;

    /**
     *  此阶段操作的操作标识
     */
    protected final int sourceOrOpFlags;

    /**
     *  此流管道的下一阶段
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private AbstractPipeline nextStage;

    /**
     *  顺序流：当前阶段和源流之间存在的中间阶段的个数
     *  并行流：上一阶段的状态
     */
    private int depth;

    /**
     *  组合了源流和所有中间阶段的流标识和操作标识
     */
    private int combinedFlags;

    /**
     *  源流的分割迭代器，用于产生元素
     */
    private Spliterator&amp;lt;?&amp;gt; sourceSpliterator;

    /**
     *  源流的分割迭代器生成器，如果 sourceSpliterator == null
     */
    private Supplier&amp;lt;? extends Spliterator&amp;lt;?&amp;gt;&amp;gt; sourceSupplier;

    /**
     *  此流管道已经被链接或消费
     */
    private boolean linkedOrConsumed;

    /**
     *  流水线中存在有状态的流管道
     */
    private boolean sourceAnyStateful;

    /**
     *  此流管道关闭时的后置操作
     */
    private Runnable sourceCloseAction;

    /**
     *  此流管道是否是并行的
     */
    private boolean parallel;

    /**
     *  流水线头部管道的构造函数
     */
    AbstractPipeline(Spliterator&amp;lt;?&amp;gt; source,
            int sourceFlags, boolean parallel) {
        this.previousStage = null;
        this.sourceSpliterator = source;
        this.sourceStage = this;
        this.sourceOrOpFlags = sourceFlags &amp;amp; StreamOpFlag.STREAM_MASK;
        // The following is an optimization of:
        // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);
        this.combinedFlags = ~(sourceOrOpFlags &amp;lt;&amp;lt; 1) &amp;amp; StreamOpFlag.INITIAL_OPS_VALUE;
        // 源阶段的 depth=0
        this.depth = 0;
        this.parallel = parallel;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;无状态流管道的链接【以 map 为例】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReferencePipeline#
    /**
     *  基于 mapper 创建一个无状态的流管道，并将其链接到此流管道之后
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super P_OUT, ? extends R&amp;gt; mapper) {
        Objects.requireNonNull(mapper);
        /**
         * 新流管道的操作为 mapper
         * 新流管道的操作标识为 NOT_SORTED、NOT_DISTINCT
         * 下一阶段的操作为 sink【反向链接】
         */
        return new StatelessOp&amp;lt;&amp;gt;(this, StreamShape.REFERENCE,
                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        /**
                         * 接收上游阶段发送的数据 u，并进行当前阶段的处理，
                         * 并将结果发送给下游阶段处理
                         */
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        };
    }

    /**
     *  一个无状态的流管道
     */
    abstract static class StatelessOp&amp;lt;E_IN, E_OUT&amp;gt;
    extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
        
        /**
         * 将此流管道追加到上游管道  upstream 之后
         */
        StatelessOp(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; upstream,
                StreamShape inputShape,
                int opFlags) {
            super(upstream, opFlags);
            assert upstream.getOutputShape() == inputShape;
        }

        /**
         *  此管道的操作是无状态的
         */
        @Override
        final boolean opIsStateful() {
            return false;
        }
    }

    /**
     * 将此流管道追加到上游管道 upstream 之后
     */
    ReferencePipeline(AbstractPipeline&amp;lt;?, P_IN, ?&amp;gt; upstream, int opFlags) {
        super(upstream, opFlags);
    }

    /**
     *  将此流管道追加到 previousStage 之后
     */
    AbstractPipeline(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; previousStage, int opFlags) {
        // 前一阶段已经被链接或消费，则不允许重复消费
        if (previousStage.linkedOrConsumed) {
            throw new IllegalStateException(MSG_STREAM_LINKED);
        }
        // 前一阶段已经被链接
        previousStage.linkedOrConsumed = true;
        // 设置前一阶段的后置阶段为当前阶段
        previousStage.nextStage = this;

        // 写入前置阶段
        this.previousStage = previousStage;
        // 写入此阶段的操作标识
        this.sourceOrOpFlags = opFlags &amp;amp; StreamOpFlag.OP_MASK;
        // 合并前一阶段和此阶段的流操作标识
        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
        // 写入管道头
        this.sourceStage = previousStage.sourceStage;
        // 此阶段是否是有状态操作
        if (opIsStateful()) {
            sourceStage.sourceAnyStateful = true;
        }
        // 写入中间操作计数值（上一阶段 + 1）
        this.depth = previousStage.depth + 1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有状态流管道的链接【sorted()】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReferencePipeline#
    /**
     *  将一个排序的流管道追加到此流管道之后
     */
    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; sorted() {
        return SortedOps.makeRef(this);
    }

SortedOps#
    /**
     *  将一个排序管道追加到 upstream 之后
     */
    static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
        return new OfRef&amp;lt;&amp;gt;(upstream);
    }

ReferencePipeline#
    /**
     *  有状态的流管道
     */
    abstract static class StatefulOp&amp;lt;E_IN, E_OUT&amp;gt;
    extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
        /**
         * 将一个有状态的流管道追加到 upstream 之后
         */
        StatefulOp(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; upstream,
                StreamShape inputShape,
                int opFlags) {
            super(upstream, opFlags);
            assert upstream.getOutputShape() == inputShape;
        }

        /**
         *  此流管道是有状态的
         */
        @Override
        final boolean opIsStateful() {
            return true;
        }

        @Override
        abstract &amp;lt;P_IN&amp;gt; Node&amp;lt;E_OUT&amp;gt; opEvaluateParallel(PipelineHelper&amp;lt;E_OUT&amp;gt; helper,
                Spliterator&amp;lt;P_IN&amp;gt; spliterator,
                IntFunction&amp;lt;E_OUT[]&amp;gt; generator);
    }

    /**
     *  用于对引用流进行排序的管道
     */
    private static final class OfRef&amp;lt;T&amp;gt; extends ReferencePipeline.StatefulOp&amp;lt;T, T&amp;gt; {
        /**
         * 是否是自然顺序
         */
        private final boolean isNaturalSort;
        /**
         * 排序使用的比较器
         */
        private final Comparator&amp;lt;? super T&amp;gt; comparator;

        /**
         * 使用自然顺序排序
         */
        OfRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
            super(upstream, StreamShape.REFERENCE, StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
            this.isNaturalSort = true;
            final Comparator&amp;lt;? super T&amp;gt; comp = (Comparator&amp;lt;? super T&amp;gt;) Comparator.naturalOrder();
            this.comparator = comp;
        }

        /**
         * 使用指定的比较器排序
         */
        OfRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream, Comparator&amp;lt;? super T&amp;gt; comparator) {
            super(upstream, StreamShape.REFERENCE, StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);
            this.isNaturalSort = false;
            this.comparator = Objects.requireNonNull(comparator);
        }

        @Override
        public Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {
            Objects.requireNonNull(sink);

            // 1）如果上游管道是已排序的，并且是按照自然顺序排序的，则此流管道可以忽略
            if (StreamOpFlag.SORTED.isKnown(flags) &amp;amp;&amp;amp; isNaturalSort) {
                return sink;
            // 2）如果上游管道是已知大小的
            } else if (StreamOpFlag.SIZED.isKnown(flags)) {
                return new SizedRefSortingSink&amp;lt;&amp;gt;(sink, comparator);
            // 3）如果上游管道是未知大小的    
            } else {
                return new RefSortingSink&amp;lt;&amp;gt;(sink, comparator);
            }
        }
    }

SortedOps#
    private abstract static class AbstractRefSortingSink&amp;lt;T&amp;gt; extends Sink.ChainedReference&amp;lt;T, T&amp;gt; {
        /**
         * 排序元素的比较器
         */
        protected final Comparator&amp;lt;? super T&amp;gt; comparator;
        // 是否取消接收上游的元素
        protected boolean cancellationRequestedCalled;

        AbstractRefSortingSink(Sink&amp;lt;? super T&amp;gt; downstream, Comparator&amp;lt;? super T&amp;gt; comparator) {
            super(downstream);
            this.comparator = comparator;
        }

        /**
         *  在排序元素被发送到下游时，能够保存短路行为【流水线中存在短路操作】
         */
        @Override
        public final boolean cancellationRequested() {
            cancellationRequestedCalled = true;
            return false;
        }
    }

    private static final class SizedRefSortingSink&amp;lt;T&amp;gt; extends AbstractRefSortingSink&amp;lt;T&amp;gt; {
        // 暂存元素的数组
        private T[] array;
        // 当前元素偏移
        private int offset;

        SizedRefSortingSink(Sink&amp;lt;? super T&amp;gt; sink, Comparator&amp;lt;? super T&amp;gt; comparator) {
            super(sink, comparator);
        }

        @Override
        public void begin(long size) {
            if (size &amp;gt;= Nodes.MAX_ARRAY_SIZE) {
                throw new IllegalArgumentException(Nodes.BAD_SIZE);
            }
            // 创建固定大小的对象数组，用于接收上游发送的元素
            array = (T[]) new Object[(int) size];
        }

        /**
         * 上游元素发送完毕，开始执行排序操作，并将排序后的元素发送到下游
         */
        @Override
        public void end() {
            // 执行元素排序
            Arrays.sort(array, 0, offset, comparator);
            // 发送通知给下游管道，准备接收数据
            downstream.begin(offset);
            // 1）当前管道的下游不存在短路操作
            if (!cancellationRequestedCalled) {
                // 顺序发送所有元素
                for (int i = 0; i &amp;lt; offset; i++) {
                    downstream.accept(array[i]);
                }
            // 2）当前管道的下游存在短路操作
            } else {
                // 先发送一个元素，之后每次发送前都询问下游是否继续接收，下游拒绝接收元素则退出循环
                for (int i = 0; i &amp;lt; offset &amp;amp;&amp;amp; !downstream.cancellationRequested(); i++) {
                    downstream.accept(array[i]);
                }
            }
            // 通知下游管道，数据发送完毕
            downstream.end();
            // 回收数组
            array = null;
        }

        /**
         * 接收上游发送的单个元素
         */
        @Override
        public void accept(T t) {
            array[offset++] = t;
        }
    }

/**
 *  能够消费上游管道发送的元素，同时存储状态的 Sink
 */
interface Sink&amp;lt;T&amp;gt; extends Consumer&amp;lt;T&amp;gt; {
    /**
     *  通知下游管道，重置状态以接收新的数据集
     */
    default void begin(long size) {}

    /**
     *  通知下游管道，数据已经推送完毕，可以执行聚合处理
     */
    default void end() {}

    /**
     *  询问下游管道是否还需要继续推送数据，适用于短路操作
     */
    default boolean cancellationRequested() {
        return false;
    }
}

Sink#ChainedReference
    /**
     *  链式引用 sink
     */
    abstract static class ChainedReference&amp;lt;T, E_OUT&amp;gt; implements Sink&amp;lt;T&amp;gt; {
        // 下游 sink
        protected final Sink&amp;lt;? super E_OUT&amp;gt; downstream;

        public ChainedReference(Sink&amp;lt;? super E_OUT&amp;gt; downstream) {
            this.downstream = Objects.requireNonNull(downstream);
        }

        @Override
        public void begin(long size) {
            downstream.begin(size);
        }

        @Override
        public void end() {
            downstream.end();
        }

        @Override
        public boolean cancellationRequested() {
            return downstream.cancellationRequested();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;链接终端操作执行计算【forEach()】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReferencePipeline#
    @Override
    public void forEach(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
        evaluate(ForEachOps.makeRef(action, false));
    }

ForEachOps#
    /**
     *  创建一个 TerminalOp，遍历并处理流中的每个引用对象
     */
    public static &amp;lt;T&amp;gt; TerminalOp&amp;lt;T, Void&amp;gt; makeRef(Consumer&amp;lt;? super T&amp;gt; action,
            boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfRef&amp;lt;&amp;gt;(action, ordered);
    }

    abstract static class ForEachOp&amp;lt;T&amp;gt;
    implements TerminalOp&amp;lt;T, Void&amp;gt;, TerminalSink&amp;lt;T, Void&amp;gt; {
        // 遍历是否是有序的
        private final boolean ordered;

        protected ForEachOp(boolean ordered) {
            this.ordered = ordered;
        }

        // 获取此操作的操作标识
        @Override
        public int getOpFlags() {
            return ordered ? 0 : StreamOpFlag.NOT_ORDERED;
        }

        /**
         *  将此终端操作链接到流管道尾部，并将 spliterator 中的每个元素都发送到 sink 中
         */
        @Override
        public &amp;lt;S&amp;gt; Void evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,
                Spliterator&amp;lt;S&amp;gt; spliterator) {
            return helper.wrapAndCopyInto(this, spliterator).get();
        }

        /**
         *  并行评估 spliterator 中的元素
         */
        @Override
        public &amp;lt;S&amp;gt; Void evaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,
                Spliterator&amp;lt;S&amp;gt; spliterator) {
            if (ordered) {
                new ForEachOrderedTask&amp;lt;&amp;gt;(helper, spliterator, this).invoke();
            } else {
                new ForEachTask&amp;lt;&amp;gt;(helper, spliterator, helper.wrapSink(this)).invoke();
            }
            return null;
        }

        static final class OfRef&amp;lt;T&amp;gt; extends ForEachOp&amp;lt;T&amp;gt; {
            /**
             * 实际消费者
             */
            final Consumer&amp;lt;? super T&amp;gt; consumer;

            OfRef(Consumer&amp;lt;? super T&amp;gt; consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            /**
             *  处理上游发送的单个元素
             */
            @Override
            public void accept(T t) {
                consumer.accept(t);
            }
        }
    }

AbstractPipeline#
    /**
     *  使用终端操作 terminalOp 对此流管道进行处理，处理过程中会从后往前链接形成流水线
     */
    final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
        // 此阶段的输出类型==终端操作的输入类型
        assert getOutputShape() == terminalOp.inputShape();
        // 不允许重复消费
        if (linkedOrConsumed) {
            throw new IllegalStateException(MSG_STREAM_LINKED);
        }
        // 设置已消费标识
        linkedOrConsumed = true;

        // 使用终端操作并行或串行处理此流管道
        return isParallel()
                ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
                        : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }

    /**
     *  获取此阶段的源分割迭代器【数据源】
     *  
     * created by ZXD at 19 Dec 2018 T 22:32:09
     * @param terminalFlags 终端操作标识
     * @return
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Spliterator&amp;lt;?&amp;gt; sourceSpliterator(int terminalFlags) {
        Spliterator&amp;lt;?&amp;gt; spliterator = null;
        // 1）源分割迭代器不为 null
        if (sourceStage.sourceSpliterator != null) {
            // 读取
            spliterator = sourceStage.sourceSpliterator;
            // 使用后置空
            sourceStage.sourceSpliterator = null;
        }
        // 2）分割迭代器通过 sourceSupplier 进行生成
        else if (sourceStage.sourceSupplier != null) {
            spliterator = (Spliterator&amp;lt;?&amp;gt;) sourceStage.sourceSupplier.get();
            sourceStage.sourceSupplier = null;
        }
        else {
            throw new IllegalStateException(MSG_CONSUMED);
        }

        // 此流是并行的 &amp;amp;&amp;amp; 流管道中存在有状态操作
        if (isParallel() &amp;amp;&amp;amp; sourceStage.sourceAnyStateful) {
            // Adapt the source spliterator, evaluating each stateful op in the pipeline up to and including this pipeline stage.
            // The depth and flags of each pipeline stage are adjusted accordingly.
            int depth = 1;
            /**
             * 从源阶段开始处理，一直处理到当前阶段为止
             */
            for (@SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline u = sourceStage, p = sourceStage.nextStage, e = this;
                    u != e;
                    u = p, p = p.nextStage) {

                int thisOpFlags = p.sourceOrOpFlags;
                // 当前处理阶段是有状态操作
                if (p.opIsStateful()) {
                    depth = 0;
                    // 当前操作是短路操作
                    if (StreamOpFlag.SHORT_CIRCUIT.isKnown(thisOpFlags)) {
                        thisOpFlags = thisOpFlags &amp;amp; ~StreamOpFlag.IS_SHORT_CIRCUIT;
                    }

                    spliterator = p.opEvaluateParallelLazy(u, spliterator);

                    // Inject or clear SIZED on the source pipeline stage based on the stage's spliterator
                    thisOpFlags = spliterator.hasCharacteristics(Spliterator.SIZED)
                            ? thisOpFlags &amp;amp; ~StreamOpFlag.NOT_SIZED | StreamOpFlag.IS_SIZED
                                    : thisOpFlags &amp;amp; ~StreamOpFlag.IS_SIZED | StreamOpFlag.NOT_SIZED;
                }
                p.depth = depth++;
                p.combinedFlags = StreamOpFlag.combineOpFlags(thisOpFlags, u.combinedFlags);
            }
        }

        // 终端操作带有标识位
        if (terminalFlags != 0)  {
            // 将终端操作的标志位合并到最后一阶段中
            combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);
        }

        return spliterator;
    }

    /**
     * @param sink  下游管道操作，中间操作或终端操作
     * @param spliterator   分割迭代器
     * @return
     */
    @Override
    final &amp;lt;P_IN, S extends Sink&amp;lt;E_OUT&amp;gt;&amp;gt; S wrapAndCopyInto(S sink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        return sink;
    }

    /**
     * 从当前流管道开始，向前构建流水线直到第一个流管道为止，流水线后置操作为 sink
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {
        Objects.requireNonNull(sink);
        /**
         * AbstractPipeline.this：当前流管道
         * p.depth：当前流管道距离管道头的距离
         * p.previousStage：前置流管道
         */
        for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        // 返回链接后的 sink
        return (Sink&amp;lt;P_IN&amp;gt;) sink;
    }

    /**
     * 将分割迭代器中的元素顺序发送到流水线中处理
     *
     * @param wrappedSink   链接后的流水线
     * @param spliterator   数据源
     */
    @Override
    final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        Objects.requireNonNull(wrappedSink);
        // 1）流水线中不存在短路操作
        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            // 通知 wrappedSink 处理元素的个数
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            // 使用 wrappedSink 依次处理 spliterator 中的所有元素
            spliterator.forEachRemaining(wrappedSink);
            // 通知 wrappedSink 元素发送完毕，可以执行后置操作
            wrappedSink.end();
        }
        // 2）流水线中存在短路操作
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Spliterator 及其特征值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 *  用于划分和遍历数据源的对象，数据源可以是 array、Collection、IO channel、生成器等。
 */
public interface Spliterator&amp;lt;T&amp;gt; {
    /**
     *  尝试使用 action 处理 Spliterator 中的一个元素
     */
    boolean tryAdvance(Consumer&amp;lt;? super T&amp;gt; action);

    /**
     *  尝试使用 action 一次性处理 Spliterator 中的所有元素
     */
    default void forEachRemaining(Consumer&amp;lt;? super T&amp;gt; action) {
        do { } while (tryAdvance(action));
    }

    /**
     *  对此 Spliterator 进行拆分
     */
    Spliterator&amp;lt;T&amp;gt; trySplit();

    /**
     *  获取此 Spliterator 的估计元素数，如果数据源是无限的，则返回 -1
     */
    long estimateSize();

    /**
     *  尝试获取此 Spliterator 的精确元素个数
     */
    default long getExactSizeIfKnown() {
        return (characteristics() &amp;amp; SIZED) == 0 ? -1L : estimateSize();
    }

    /**
     *  读取此 Spliterator 的特征值
     */
    int characteristics();

    /**
     *  Spliterator 中的元素是顺序处理的
     */
    public static final int ORDERED    = 0x00000010;

    /**
     *  Spliterator 中的元素是唯一的
     */
    public static final int DISTINCT   = 0x00000001;

    /**
     *  Spliterator 中的元素根据自然顺序或比较器进行过排序
     */
    public static final int SORTED     = 0x00000004;

    /**
     *  Spliterator 中的元素个数是有限的
     */
    public static final int SIZED      = 0x00000040;

    /**
     *  Spliterator 中的元素是非 null 的
     */
    public static final int NONNULL    = 0x00000100;

    /**
     *  Spliterator 关联的数据源是不可变的，不支持增加、替换、删除等
     */
    public static final int IMMUTABLE  = 0x00000400;

    /**
     * Spliterator 关联的数据源支持并发修改
     */
    public static final int CONCURRENT = 0x00001000;

    /**
     *  此 Spliterator 通过 trySplit() 方法生成的子 Spliterator 是有限大小的
     */
    public static final int SUBSIZED = 0x00004000;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;流管道和操作标识&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StreamOpFlag#
    /**
     * 流管道中的元素是唯一的
     */
    // 0, 0x00000001
    // Matches Spliterator.DISTINCT
    DISTINCT(0,
            set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),

    /**
     *  流管道中的元素是排过序的【有状态操作】
     */
    // 1, 0x00000004
    // Matches Spliterator.SORTED
    SORTED(1,
            set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),

    /**
     *  流管道中的元素是顺序处理的
     */
    // 2, 0x00000010
    // Matches Spliterator.ORDERED
    ORDERED(2,
            set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP).clear(Type.TERMINAL_OP)
            .clear(Type.UPSTREAM_TERMINAL_OP)),

    /**
     *  流管道的大小是有限的【非无限流】
     */
    // 3, 0x00000040
    // Matches Spliterator.SIZED
    SIZED(3,
            set(Type.SPLITERATOR).set(Type.STREAM).clear(Type.OP)),

    /**
     *  中间操作或终端操作是短路的
     */
    // 12, 0x01000000
    SHORT_CIRCUIT(12,
            set(Type.OP).set(Type.TERMINAL_OP));
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;流管道中的元素类型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;enum StreamShape {
    /**
     *  流元素是对象引用
     */
    REFERENCE,
    /**
     *  流元素是 int 值
     */
    INT_VALUE,
    /**
     *  流元素是 long 值
     */
    LONG_VALUE,
    /**
     *  流元素是 double 值
     */
    DOUBLE_VALUE
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;无状态中间操作&quot;&gt;无状态中间操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;filter：使用指定的函数式断言过滤流中的元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; filter(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
        Objects.requireNonNull(predicate);
        return new StatelessOp&amp;lt;&amp;gt;(this, StreamShape.REFERENCE,
                StreamOpFlag.NOT_SIZED) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;P_OUT&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    @Override
                    public void begin(long size) {
                        downstream.begin(-1);
                    }

                    @Override
                    public void accept(P_OUT u) {
                        /**
                         * 根据目标 predicate 对上游管道发送的数据进行过滤，
                         * 只将满足断言的对象发送到下游
                         */
                        if (predicate.test(u)) {
                            downstream.accept(u);
                        }
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;map：将上游管道发送的数据进行映射处理后，再发送到下游&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  基于 mapper 创建一个无状态的流管道，并将其链接到此流管道之后
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super P_OUT, ? extends R&amp;gt; mapper) {
        Objects.requireNonNull(mapper);
        /**
         * 新流管道的操作为 mapper
         * 新流管道的操作标识为 NOT_SORTED、NOT_DISTINCT
         * 下一阶段的操作为 sink【反向链接】
         */
        return new StatelessOp&amp;lt;&amp;gt;(this, StreamShape.REFERENCE,
                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        /**
                         * 接收上游阶段发送的数据 u，并进行当前阶段的处理，
                         * 并将结果发送给下游阶段处理
                         */
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;flatMap：流的扁平化&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super P_OUT, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper) {
        Objects.requireNonNull(mapper);
        return new StatelessOp&amp;lt;&amp;gt;(this, StreamShape.REFERENCE,
                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    // true if cancellationRequested() has been called
                    boolean cancellationRequestedCalled;

                    @Override
                    public void begin(long size) {
                        downstream.begin(-1);
                    }

                    @Override
                    public void accept(P_OUT u) {
                        /**
                         * 通过 mapper 函数将上游元素映射成一个新的流，并将流中的元素顺序发送到下游
                         */
                        try (Stream&amp;lt;? extends R&amp;gt; result = mapper.apply(u)) {
                            // 映射结果不为 null 时，将新流中的元素发送到下游
                            if (result != null) {
                                // 1）下游操作是非短路的
                                if (!cancellationRequestedCalled) {
                                    result.sequential().forEach(downstream);
                                }
                                // 2）下游操作是短路操作，则每次发送元素前都先询问下游是否需要继续接收
                                else {
                                    final var s = result.sequential().spliterator();
                                    do { } while (!downstream.cancellationRequested() &amp;amp;&amp;amp; s.tryAdvance(downstream));
                                }
                            }
                        }
                    }

                    @Override
                    public boolean cancellationRequested() {
                        // If this method is called then an operation within the stream pipeline is short-circuiting (see AbstractPipeline.copyInto).
                        // Note that we cannot differentiate between an upstream or downstream operation
                        cancellationRequestedCalled = true;
                        return downstream.cancellationRequested();
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;peek：查看上游发送的元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; peek(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
        Objects.requireNonNull(action);
        return new StatelessOp&amp;lt;&amp;gt;(this, StreamShape.REFERENCE,
                0) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;P_OUT&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        /**
                         * 先调用目标接口进行消费，之后再将该元素发送到下游，
                         * 可以查看流的具体处理过程，主要用于调试
                         */
                        action.accept(u);
                        downstream.accept(u);
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;有状态的中间操作&quot;&gt;有状态的中间操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;distinct：将流中的元素去重&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; distinct() {
        return DistinctOps.makeRef(this);
    }

DistinctOps#
    static &amp;lt;T&amp;gt; ReferencePipeline&amp;lt;T, T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
        // StreamOpFlag.IS_DISTINCT 新管道产生的元素是唯一的
        return new ReferencePipeline.StatefulOp&amp;lt;T, T&amp;gt;(upstream, StreamShape.REFERENCE,
                                                      StreamOpFlag.IS_DISTINCT | StreamOpFlag.NOT_SIZED) {

            @Override
            Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {
                Objects.requireNonNull(sink);
                
                // 1）如果上游管道已经是 distinct 则此阶段无序任何处理。
                if (StreamOpFlag.DISTINCT.isKnown(flags)) {
                    return sink;
                // 2）上游管道是已排序的    
                } else if (StreamOpFlag.SORTED.isKnown(flags)) {
                    return new Sink.ChainedReference&amp;lt;T, T&amp;gt;(sink) {
                        boolean seenNull;
                        // 最近发送的元素
                        T lastSeen;

                        @Override
                        public void begin(long size) {
                            seenNull = false;
                            lastSeen = null;
                            downstream.begin(-1);
                        }

                        @Override
                        public void end() {
                            seenNull = false;
                            lastSeen = null;
                            downstream.end();
                        }

                        @Override
                        public void accept(T t) {
                            // 1）上游发送的元素为 null
                            if (t == null) {
                                if (!seenNull) {
                                    seenNull = true;
                                    downstream.accept(lastSeen = null);
                                }
                            /**
                             * 2）上游发送的元素不为 null
                             * lastSeen == null，当前元素是第一个元素
                             * !t.equals(lastSeen)，上次发送的元素和当前元素不一致
                             */
                            } else if (lastSeen == null || !t.equals(lastSeen)) {
                                downstream.accept(lastSeen = t);
                            }
                        }
                    };
                // 3）上游管道是未排序的    
                } else {
                    return new Sink.ChainedReference&amp;lt;T, T&amp;gt;(sink) {
                        // 存放上游发送的唯一元素
                        Set&amp;lt;T&amp;gt; seen;

                        @Override
                        public void begin(long size) {
                            seen = new HashSet&amp;lt;&amp;gt;();
                            downstream.begin(-1);
                        }

                        @Override
                        public void end() {
                            seen = null;
                            downstream.end();
                        }

                        @Override
                        public void accept(T t) {
                            // 已接受元素中不存在此元素 t
                            if (!seen.contains(t)) {
                                // 将其加入已发送唯一元素集合
                                seen.add(t);
                                // 将此元素发送到下游
                                downstream.accept(t);
                            }
                        }
                    };
                }
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;sorted：新管道产生的元素是已排序的&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  将一个排序的流管道追加到此流管道之后
     */
    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; sorted() {
        return SortedOps.makeRef(this);
    }

SortedOps#
    /**
     *  将一个排序管道追加到 upstream 之后
     */
    static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
        return new OfRef&amp;lt;&amp;gt;(upstream);
    }

    /**
     *  用于对引用流进行排序的管道
     */
    private static final class OfRef&amp;lt;T&amp;gt; extends ReferencePipeline.StatefulOp&amp;lt;T, T&amp;gt; {
        /**
         * 是否是自然顺序
         */
        private final boolean isNaturalSort;
        /**
         * 排序使用的比较器
         */
        private final Comparator&amp;lt;? super T&amp;gt; comparator;

        /**
         * 使用自然顺序排序
         */
        OfRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
            super(upstream, StreamShape.REFERENCE, StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
            this.isNaturalSort = true;
            final Comparator&amp;lt;? super T&amp;gt; comp = (Comparator&amp;lt;? super T&amp;gt;) Comparator.naturalOrder();
            this.comparator = comp;
        }

        /**
         * 使用指定的比较器排序
         */
        OfRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream, Comparator&amp;lt;? super T&amp;gt; comparator) {
            super(upstream, StreamShape.REFERENCE, StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);
            this.isNaturalSort = false;
            this.comparator = Objects.requireNonNull(comparator);
        }

        @Override
        public Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {
            Objects.requireNonNull(sink);

            // 1）如果上游管道是已排序的，并且是按照自然顺序排序的，则此流管道可以忽略
            if (StreamOpFlag.SORTED.isKnown(flags) &amp;amp;&amp;amp; isNaturalSort) {
                return sink;
                // 2）如果上游管道是已知大小的
            } else if (StreamOpFlag.SIZED.isKnown(flags)) {
                return new SizedRefSortingSink&amp;lt;&amp;gt;(sink, comparator);
                // 3）如果上游管道是未知大小的
            } else {
                return new RefSortingSink&amp;lt;&amp;gt;(sink, comparator);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;skip：忽略上游管道发送的前 n 个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; skip(long n) {
        if (n &amp;lt; 0) {
            throw new IllegalArgumentException(Long.toString(n));
        }
        if (n == 0) {
            return this;
        } else {
            return SliceOps.makeRef(this, n, -1);
        }
    }

SliceOps#
    /**
     * @param upstream 上游管道
     * @param skip 需要跳过的元素个数
     * @param limit 限制接受的元素个数
     */
    public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream,
            long skip, long limit) {
        if (skip &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;Skip must be non-negative: &quot; + skip);
        }

        return new ReferencePipeline.StatefulOp&amp;lt;&amp;gt;(upstream, StreamShape.REFERENCE,
                flags(limit)) {

            @Override
            Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;&amp;gt;(sink) {
                    // 需要跳过的前 n 个元素
                    long n = skip;
                    // 只需要获取 m 个元素
                    long m = limit &amp;gt;= 0 ? limit : Long.MAX_VALUE;

                    @Override
                    public void begin(long size) {
                        downstream.begin(calcSize(size, skip, m));
                    }

                    @Override
                    public void accept(T t) {
                        // 已经不需要跳过元素
                        if (n == 0) {
                            // 下游需要接受的元素个数 &amp;gt; 0
                            if (m &amp;gt; 0) {
                                // 递减接收个数
                                m--;
                                // 将当前元素发送给下游管道
                                downstream.accept(t);
                            }
                        }
                        // 跳过当前元素，并递减跳过数
                        else {
                            n--;
                        }
                    }

                    @Override
                    public boolean cancellationRequested() {
                        // m == 0 表示此管道将不会发送元素到下游 || 下游拒绝接收元素
                        return m == 0 || downstream.cancellationRequested();
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;limit：只接受上游管道发送的前 maxSize 个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Stream&amp;lt;P_OUT&amp;gt; limit(long maxSize) {
        if (maxSize &amp;lt; 0) {
            throw new IllegalArgumentException(Long.toString(maxSize));
        }
        return SliceOps.makeRef(this, 0, maxSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;非短路的终端操作&quot;&gt;非短路的终端操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;forEach：使用函数式接口 action 消费流水线生产的所有元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void forEach(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
        evaluate(ForEachOps.makeRef(action, false));
    }

ForEachOps#
    /**
     *  创建一个 TerminalOp，遍历并处理流中的每个引用对象
     */
    public static &amp;lt;T&amp;gt; TerminalOp&amp;lt;T, Void&amp;gt; makeRef(Consumer&amp;lt;? super T&amp;gt; action,
            boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfRef&amp;lt;&amp;gt;(action, ordered);
    }

    abstract static class ForEachOp&amp;lt;T&amp;gt;
    implements TerminalOp&amp;lt;T, Void&amp;gt;, TerminalSink&amp;lt;T, Void&amp;gt; {
        // 遍历是否是有序的
        private final boolean ordered;

        protected ForEachOp(boolean ordered) {
            this.ordered = ordered;
        }

        // 获取此操作的操作标识
        @Override
        public int getOpFlags() {
            return ordered ? 0 : StreamOpFlag.NOT_ORDERED;
        }

        /**
         *  将此终端操作链接到流管道尾部，并将 spliterator 中的每个元素都发送到 sink 中
         */
        @Override
        public &amp;lt;S&amp;gt; Void evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,
                Spliterator&amp;lt;S&amp;gt; spliterator) {
            return helper.wrapAndCopyInto(this, spliterator).get();
        }

        static final class OfRef&amp;lt;T&amp;gt; extends ForEachOp&amp;lt;T&amp;gt; {
            /**
             * 实际消费者
             */
            final Consumer&amp;lt;? super T&amp;gt; consumer;

            OfRef(Consumer&amp;lt;? super T&amp;gt; consumer, boolean ordered) {
                super(ordered);
                this.consumer = consumer;
            }

            /**
             *  处理上游发送的单个元素
             */
            @Override
            public void accept(T t) {
                consumer.accept(t);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;forEachOrdered：使用函数式接口 action 顺序消费流水线生产的所有元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void forEachOrdered(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
        evaluate(ForEachOps.makeRef(action, true));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;短路的终端操作&quot;&gt;短路的终端操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;anyMatch：上游管道发送的元素中至少有一个满足函数式断言 predicate 时返回 true&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final boolean anyMatch(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
    }

MatchOps#
    enum MatchKind {
        /** 是否所有的元素都满足指定的断言 */
        ANY(true, true),

        /** 是否至少有一个元素满足指定的断言 */
        ALL(false, false),

        /** 是否所有的元素都不满足指定的断言 */
        NONE(true, false);

        /**
         * 是否需要在满足断言时停止接收上游元素
         */
        private final boolean stopOnPredicateMatches;
        /**
         * 操作被短路时的返回结果
         */
        private final boolean shortCircuitResult;

        private MatchKind(boolean stopOnPredicateMatches,
                          boolean shortCircuitResult) {
            this.stopOnPredicateMatches = stopOnPredicateMatches;
            this.shortCircuitResult = shortCircuitResult;
        }
    }

    public static &amp;lt;T&amp;gt; TerminalOp&amp;lt;T, Boolean&amp;gt; makeRef(Predicate&amp;lt;? super T&amp;gt; predicate,
            MatchKind matchKind) {
        Objects.requireNonNull(predicate);
        Objects.requireNonNull(matchKind);
        class MatchSink extends BooleanTerminalSink&amp;lt;T&amp;gt; {
            MatchSink() {
                super(matchKind);
            }

            @Override
            public void accept(T t) {
                /**
                 * 当前管道还能继续接收元素 &amp;amp;&amp;amp; 当前元素匹配停止条件
                 */
                if (!stop &amp;amp;&amp;amp; predicate.test(t) == matchKind.stopOnPredicateMatches) {
                    // 停止接收元素
                    stop = true;
                    // 写入结果值
                    value = matchKind.shortCircuitResult;
                }
            }
        }

        return new MatchOp&amp;lt;&amp;gt;(StreamShape.REFERENCE, matchKind, MatchSink::new);
    }

    private static final class MatchOp&amp;lt;T&amp;gt; implements TerminalOp&amp;lt;T, Boolean&amp;gt; {
        /**
         * 上游发送的元素类型
         */
        private final StreamShape inputShape;
        /**
         * 匹配类型
         */
        final MatchKind matchKind;
        /**
         * sink 生成器
         */
        final Supplier&amp;lt;BooleanTerminalSink&amp;lt;T&amp;gt;&amp;gt; sinkSupplier;

        MatchOp(StreamShape shape,
                MatchKind matchKind,
                Supplier&amp;lt;BooleanTerminalSink&amp;lt;T&amp;gt;&amp;gt; sinkSupplier) {
            this.inputShape = shape;
            this.matchKind = matchKind;
            this.sinkSupplier = sinkSupplier;
        }

        @Override
        public int getOpFlags() {
            // 当前管道是短路的 &amp;amp;&amp;amp; 未排序的
            return StreamOpFlag.IS_SHORT_CIRCUIT | StreamOpFlag.NOT_ORDERED;
        }

        @Override
        public StreamShape inputShape() {
            return inputShape;
        }

        @Override
        public &amp;lt;S&amp;gt; Boolean evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,
                                              Spliterator&amp;lt;S&amp;gt; spliterator) {
            return helper.wrapAndCopyInto(sinkSupplier.get(), spliterator).getAndClearState();
        }
    }

    /**
     * 避免返回值的装箱而定义的 BooleanTerminalSink
     */
    private abstract static class BooleanTerminalSink&amp;lt;T&amp;gt; implements Sink&amp;lt;T&amp;gt; {
        /**
         * 是否停止接收
         */
        boolean stop;
        /**
         * 返回结果值
         */
        boolean value;

        BooleanTerminalSink(MatchKind matchKind) {
            value = !matchKind.shortCircuitResult;
        }

        /**
         * 情况状态并返回结果值
         */
        public boolean getAndClearState() {
            return value;
        }

        /**
         * 是否停止接收上游元素
         */
        @Override
        public boolean cancellationRequested() {
            return stop;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;allMatch：上游管道发送的所有元素都满足函数式断言 predicate 时返回 true&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final boolean allMatch(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ALL));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;noneMatch：上游管道发送的元素没有一个满足函数式断言 predicate 时返回 true&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final boolean noneMatch(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.NONE));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;findFirst：获取上游管道发送的第一个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Optional&amp;lt;P_OUT&amp;gt; findFirst() {
        return evaluate(FindOps.makeRef(true));
    }

FindOps#
    /**
     * @param mustFindFirst 是否必须是第一个元素
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &amp;lt;T&amp;gt; TerminalOp&amp;lt;T, Optional&amp;lt;T&amp;gt;&amp;gt; makeRef(boolean mustFindFirst) {
        return (TerminalOp&amp;lt;T, Optional&amp;lt;T&amp;gt;&amp;gt;)
                (mustFindFirst ? FindSink.OfRef.OP_FIND_FIRST : FindSink.OfRef.OP_FIND_ANY);
    }

   private abstract static class FindSink&amp;lt;T, O&amp;gt; implements TerminalSink&amp;lt;T, O&amp;gt; {
        /**
         * 是否已经找到值了
         */
        boolean hasValue;
        /**
         * 结果值
         */
        T value;

        FindSink() {} // Avoid creation of special accessor

        @Override
        public void accept(T value) {
            // 当前元素是第一个元素
            if (!hasValue) {
                // 已经找到值
                hasValue = true;
                // 写入目标值
                this.value = value;
            }
        }

        /**
         * 一旦找到值，就拒绝接收上游元素
         */
        @Override
        public boolean cancellationRequested() {
            return hasValue;
        }

        static final class OfRef&amp;lt;T&amp;gt; extends FindSink&amp;lt;T, Optional&amp;lt;T&amp;gt;&amp;gt; {
            /**
             * 获取结果值
             */
            @Override
            public Optional&amp;lt;T&amp;gt; get() {
                return hasValue ? Optional.of(value) : null;
            }

            static final TerminalOp&amp;lt;?, ?&amp;gt; OP_FIND_FIRST = new FindOp&amp;lt;&amp;gt;(true,
                    StreamShape.REFERENCE, Optional.empty(),
                    Optional::isPresent, FindSink.OfRef::new);

            static final TerminalOp&amp;lt;?, ?&amp;gt; OP_FIND_ANY = new FindOp&amp;lt;&amp;gt;(false,
                    StreamShape.REFERENCE, Optional.empty(),
                    Optional::isPresent, FindSink.OfRef::new);
        }
    }

    private static final class FindOp&amp;lt;T, O&amp;gt; implements TerminalOp&amp;lt;T, O&amp;gt; {
        /**
         * 上游发送的元素类型
         */
        private final StreamShape shape;
        /**
         * 此操作的标识
         */
        final int opFlags;
        /**
         * 未找到值时的返回值
         */
        final O emptyValue;
        /**
         * 查找断言
         */
        final Predicate&amp;lt;O&amp;gt; presentPredicate;
        /**
         * sink 生成器
         */
        final Supplier&amp;lt;TerminalSink&amp;lt;T, O&amp;gt;&amp;gt; sinkSupplier;

        FindOp(boolean mustFindFirst,
                StreamShape shape,
                O emptyValue,
                Predicate&amp;lt;O&amp;gt; presentPredicate,
                Supplier&amp;lt;TerminalSink&amp;lt;T, O&amp;gt;&amp;gt; sinkSupplier) {
            this.opFlags = StreamOpFlag.IS_SHORT_CIRCUIT | (mustFindFirst ? 0 : StreamOpFlag.NOT_ORDERED);
            this.shape = shape;
            this.emptyValue = emptyValue;
            this.presentPredicate = presentPredicate;
            this.sinkSupplier = sinkSupplier;
        }

        @Override
        public int getOpFlags() {
            return opFlags;
        }

        @Override
        public StreamShape inputShape() {
            return shape;
        }

        @Override
        public &amp;lt;S&amp;gt; O evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,
                Spliterator&amp;lt;S&amp;gt; spliterator) {
            // 使用 sink 顺序评估流水线产生的元素，并返回查找结果
            final O result = helper.wrapAndCopyInto(sinkSupplier.get(), spliterator).get();
            // 找到目标值，则返回它；否则返回 emptyValue
            return result != null ? result : emptyValue;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;findAny：获取上游管道发送的任意一个元素【串行流取的是第一个元素】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public final Optional&amp;lt;P_OUT&amp;gt; findAny() {
        return evaluate(FindOps.makeRef(false));
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Dec 2018 13:45:00 +0000</pubDate>
<dc:creator>竺旭东</dc:creator>
<og:description>Stream 流管道 流管道的创建【以 ArrayList 为数据源】：.stream()、parallelStream() 有状态流管道的链接【sorted()】 链接终端操作执行计算【forEac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuxudong/p/10152663.html</dc:identifier>
</item>
<item>
<title>Integer和int及String的总结 - 128度</title>
<link>http://www.cnblogs.com/littleorange7/p/10152286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleorange7/p/10152286.html</guid>
<description>&lt;p&gt;&lt;br/&gt;秉承着总结发表是最好的记忆，我把之前遇到的问题在这里总结和大家分享一下，希望大家共同进步：&lt;/p&gt;
&lt;p&gt;一.Integer和int&lt;br/&gt;首先说下自动拆装箱，基本数据类型转换为包装类型的过程叫装箱，反之则是拆箱，其中最特殊也是面试经常遇到的是Integer,下面总结说明，话不多说，show the code，先猜一下下面这6个题的答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         Integer a1=&lt;span&gt;new&lt;/span&gt; Integer(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Integer b1=&lt;span&gt;new&lt;/span&gt; Integer(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;1:&quot;+(a1==b1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1    &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         Integer a2=128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Integer b2=128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;2:&quot;+(a2==b2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         Integer a3=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Integer b3=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;3:&quot;+(a3==b3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a4=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Integer b4=&lt;span&gt;new&lt;/span&gt; Integer(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;4:&quot;+(a4==b4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         Integer a5=&lt;span&gt;new&lt;/span&gt; Integer(40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Integer b5=&lt;span&gt;new&lt;/span&gt; Integer(40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Integer c5=&lt;span&gt;new&lt;/span&gt; Integer(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;5.1:&quot;+(a5==b5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;5.2:&quot;+(a5==b5+c5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.2&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         Integer a6=30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Integer b6=&lt;span&gt;new&lt;/span&gt; Integer(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;6:&quot;+(a6==b6));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;让我们看下对应的答案，要养成良好的习惯，先猜完在看答案 &amp;gt;O&amp;lt;&lt;/p&gt;
&lt;p&gt;---------------我------是-----答-----案-----分----割-----线------------------&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1:&lt;span&gt;false&lt;/span&gt;
2:&lt;span&gt;false&lt;/span&gt;
3:&lt;span&gt;true&lt;/span&gt;
4:&lt;span&gt;true&lt;/span&gt;
5.1:&lt;span&gt;false&lt;/span&gt;
5.2:&lt;span&gt;true&lt;/span&gt;
6:&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;看了答案之后是不是有点意外，如果你答错了，请继续往下看，下面的具体分析可能会对你有所帮助，但是如果你都答对了并且已经很清楚原因了，那么请你也继续往下看，因为有可能我的分析有不对的地方，还要请你指正出来，不废话了，开始分析：&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Integer a1=&lt;span&gt;new&lt;/span&gt; Integer(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b1=&lt;span&gt;new&lt;/span&gt; Integer(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;1:&quot;+(a1==b1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个答案为false可能你猜到了，因为包装类属于引用类型，使用new是在堆中创建了一个对象，而且此处用的比较方法时“==”，比较的是内存地址，所以两个对象的内存不一样很正常，如果改为equels比较，结果就为true;&lt;br/&gt;2.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Integer a2=128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b2=128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;2:&quot;+(a2==b2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是自动转换，jvm会自动转换,实际就等同与Integer a=new Integer(128)，然后就和上道题一样的解释了，明白了吧。&lt;br/&gt;3.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Integer a3=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b3=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;3:&quot;+(a3==b3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3 true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到答案是不是感觉懵X了，上面不是说的好好的，按照上面的解释，答案就是false啊，但实际却为true，别着急，我来解释，这个就比较特殊了，涉及到jvm的包装类型的缓存机制了，如果Integer要装箱，会先判断值，如果是在-128到127之间，则不会new Integer(X),而是直接从缓存中（常量池）获取的，所以上述的两个值都是取至缓存中的同一个值，所以引用地址是一样的，答案为true，网上关于这一块将的比较详细，如果有想更细致的研究，可以搜索网上的文档，还有源码参考，我就不在Ctrl C V了。&lt;br/&gt;4.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a4=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b4=&lt;span&gt;new&lt;/span&gt; Integer(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;4:&quot;+(a4==b4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4 true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说到这个，还有点故事，有一次电话面试，面试官问了我一个这样的问题，当时的我真的是靠懵，但是不知道是我没听清，还是面试官没说明白，说把上述的3换成128，答案就是false，为此，我自己亲自验证，然后又网上搜索，最后确定这个说法是错误的，不管把值换成多少，答案都是true；当Integer和int做“==”比较时，会自动的拆箱，把Integer转换为int类型，然后在值比较。&lt;br/&gt;5.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Integer a5=&lt;span&gt;new&lt;/span&gt; Integer(40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b5=&lt;span&gt;new&lt;/span&gt; Integer(40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Integer c5=&lt;span&gt;new&lt;/span&gt; Integer(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;5.1:&quot;+(a5==b5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.1 false&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;5.2:&quot;+(a5==b5+c5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.2 true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果前面的都看了，这个5.1的答案你可能猜对了，但是这个5.2的答案看着是不是又懵X了，别着急，我再来解释下5.2，当Integer类型做运算时，会自动拆箱，把Integer类型转换为int类型，如果是用“==”做比较，则比较的是值，所以答案是true。&lt;br/&gt;6.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Integer a6=30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b6=&lt;span&gt;new&lt;/span&gt; Integer(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;6:&quot;+(a6==b6));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6 false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看完前面的种种情况之后，相信你会猜对这个题的答案了，不仅是猜，而且也能解释个一二了，我就再解释下吧（解释的有点多........），Integer b6=30;会直接从常量池中取，而不会在堆中new Integer(30),所以两个引用的地址不一样，用“==”比较时答案就为false。&lt;/p&gt;
&lt;p&gt;看完这些相信大家已经很明白了，然后最后在给大家留个小作业，考验下大家，请看题：&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a7=30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Integer b7=30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;7:&quot;+(a7==b7));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;----------答--------案--------在--------此---------&lt;/p&gt;
&lt;p&gt;不用怀疑自己，这个相信你已经会很自信的用自己的知识解释答案了，是的，答案为true，我没有给各位看官下套套。。。。。。只是让大家更坚信自己了~&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;二.String的常量池&lt;br/&gt;刚才上面说到Integer的常量池了，大家肯定不禁想到String的常量池了，是不是正好可以建立关联记忆了，是的，我也忍不住想总结一下了，那就啰唆几句吧。&lt;br/&gt;先抛个砖......&lt;br/&gt;问：这个会创建几个“abc”？&lt;br/&gt;答：不知道。&lt;br/&gt;这个答案实在是高啊，我也不知道会创建几个，扯淡吧；其实正确的答案是一个或者是两个，因为这个得看常量池，如果常量池中已经存在“abc”这个字符串了，则会在堆中创建一次，&lt;br/&gt;如果常量池中没有“abc”，则会在堆中new一个“abc”，然后在常量池中再创建一个“abc”，&lt;br/&gt;这个就是标准的解释。&lt;br/&gt;以后如果碰到这种类似的题都可以按照这种解释，不管是 还是上面new的方式，jvm都会先检查常量池中是否有该字符串，如果有，则 这种方式就不会再创建新的字符串了，如果是 这种方式，则也会先判断常量池，如果常量池中已经存在，则会只在堆中创建一次；所有的这类题目都可以按照这种思路解释，如果出题的话，可以挖出很多大坑，希望大家以后要小心，下面出个题趁热打铁给大家练练手吧,请看题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String m=&quot;abc&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String n=&lt;span&gt;new&lt;/span&gt; String(&quot;abc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;1:&quot;+(m==n));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         String s=&quot;abc&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;2:&quot;+(m==s));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答案在图中的注释，如果有跳不出坑的童鞋，可以给我留言，我会一一的给你们啰唆的明明白白的。&lt;/p&gt;
&lt;p&gt;然后由于联想记忆法，我又想到了String、StringBuffer和StringBuilder的知识了，啊......好烦躁，真想忍不住的在给大家啰唆几句，想想还是算了吧，真的是没完没了T.T&lt;/p&gt;
&lt;p&gt;上述的总结中，如果有不一样的观点，或错误，欢迎大神给予指正哦~&lt;/p&gt;

</description>
<pubDate>Thu, 20 Dec 2018 12:59:00 +0000</pubDate>
<dc:creator>128度</dc:creator>
<og:description>秉承着总结发表是最好的记忆，我把之前遇到的问题在这里总结和大家分享一下，希望大家共同进步： 一.Integer和int首先说下自动拆装箱，基本数据类型转换为包装类型的过程叫装箱，反之则是拆箱，其中最特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleorange7/p/10152286.html</dc:identifier>
</item>
</channel>
</rss>