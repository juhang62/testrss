<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>全网最硬核解读计算机启动原理 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/13972241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/13972241.html</guid>
<description>&lt;p&gt;本讲只为讲明白下面一个问题：我们按下开机键后究竟发生了什么？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;280.5&quot;&gt;
&lt;p&gt;本讲只为讲明白下面一个问题：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们按下开机键后究竟发生了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的，这似乎是好多人都特别想搞明白的一个问题，有时候非常纳闷，为什么一个看似这么简单的问题，就是搜不到一个直面问题的答案呢？&lt;/p&gt;
&lt;p&gt;好问题，我也不知道为什么会这样，但我猜是因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;其一&lt;/strong&gt;，似懂非懂的人太多，他们其实也不知道究竟发生了什么，所以只能模糊大概地说一些教科书上的话。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其二&lt;/strong&gt;，知道这个答案的人一定是大牛，大牛要么不回答这个问题，要么就不会简单地回答这个问题。而我呢，自认为刚好处于两者之间，现在又特别想把自己知道的分享出来，所以你在这里找到了答案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我想当你探寻这个问题的答案是，搜到的大多数是这样的描述：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;BIOS 按照“启动顺序”，把控制权转交给排在第一位的存储设备：硬盘。然后在硬盘里寻找主引导记录的分区，这个分区告诉电脑操作系统在哪里，并把操作系统被加载到内存中，然后你就能看到经典的启动界面了，这个开机过程也就完成了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种描述简直太魔幻了，为什么是 &lt;strong&gt;BIOS&lt;/strong&gt; 主导这一切？怎么叫按照&lt;strong&gt;启动顺序&lt;/strong&gt;？这个分区咋就被&lt;strong&gt;加载&lt;/strong&gt;到内存了，有咋&lt;strong&gt;告诉&lt;/strong&gt;电脑操作系统在哪里了？我无法忍受这样的魔幻描述，我非要把它说得清清楚楚。&lt;/p&gt;
&lt;p&gt;首先学一个东西，一定要有一个&lt;strong&gt;前置&lt;/strong&gt;的知识，我们把它当做已知的，我不可能从原子组成分子开始讲原理。那学习计算机启动过程的前置知识是什么呢？我要求你已知以下几点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。&lt;/li&gt;
&lt;li&gt;CPU 的工作方式就是不断从内存中取出指令，并执行。&lt;/li&gt;
&lt;li&gt;CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;好了，只需要知道这三点&lt;strong&gt;前置&lt;/strong&gt;知识，你就能专业地解释计算机的启动过程了。&lt;/p&gt;
&lt;h2 id=&quot;一、为什么是-bios-主导？&quot;&gt;一、为什么是 BIOS 主导？&lt;/h2&gt;
&lt;p&gt;都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。我就不服了，为什么开机后是执行 BIOS 里的程序？为啥不是内存里的？为啥不是硬盘里的？&lt;/p&gt;
&lt;p&gt;好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说&lt;strong&gt;内存映射&lt;/strong&gt;了。&lt;/p&gt;
&lt;h2 id=&quot;二、内存映射&quot;&gt;二、内存映射&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CPU 地址总线的宽度决定了可访问的内存空间的大小&lt;/strong&gt;。比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。&lt;/p&gt;
&lt;p&gt;可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。&lt;/p&gt;
&lt;p&gt;这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被&lt;strong&gt;映射&lt;/strong&gt;到了内存中的某一片区域一样。这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。这就是所谓的&lt;strong&gt;内存映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;太好了，现在又用简单的前置知识就能解释得通了，我们继续往下推。&lt;/p&gt;
&lt;h2 id=&quot;三、实模式下的内存分布&quot;&gt;三、实模式下的内存分布&lt;/h2&gt;
&lt;p&gt;刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.gitbook.cn/630208c0-ffd7-11e9-86a5-e3fc3c0832e4&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哎哟我真是个小天使，把比例都表现出来了，网上能再找出比我这个更直观的请给我留言。实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。&lt;/p&gt;
&lt;p&gt;我们看到，内存被各种外设瓜分了，即映射在了内存中。BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。&lt;/p&gt;
&lt;h2 id=&quot;四、怎么就从-bios-里的程序开始执行了&quot;&gt;四、怎么就从 BIOS 里的程序开始执行了&lt;/h2&gt;
&lt;p&gt;好了，现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。假如我现在说，CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，你肯定要喷我了，为什么就执行到这了呢，那咋不从头开始执行？&lt;/p&gt;
&lt;p&gt;这就自然有了一种猜想，我们要用到另一个前置知识了，就是 CPU 从内存的哪个位置取出执行并执行呢？&lt;strong&gt;是 PC 寄存器中的地址值&lt;/strong&gt;。BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。没错，接下来这句话，可能就是你找了很久的答案，请做好准备：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0&lt;/strong&gt;。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。&lt;/p&gt;
&lt;p&gt;当我在学习这段知识时，看到这句话才让将我心里积压了很久的疑惑解开，多么简单粗暴的道理啊。写到这里我也是长舒了一口气，因为剩下的过程，就几乎只是流水账一样的正推了。&lt;/p&gt;
&lt;p&gt;至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。&lt;/p&gt;
&lt;h2 id=&quot;五、bios-里到底写了什么程序&quot;&gt;五、BIOS 里到底写了什么程序&lt;/h2&gt;
&lt;p&gt;好了，我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？&lt;/p&gt;
&lt;p&gt;把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jmp far f000:e05b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。&lt;/p&gt;
&lt;p&gt;地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：&lt;strong&gt;加载启动区&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;六、0x7c00-是啥&quot;&gt;六、0x7c00 是啥&lt;/h2&gt;
&lt;p&gt;该较真的地方就是要较真，我绝对不会让&lt;strong&gt;加载&lt;/strong&gt;这种魔幻的词出现在这里，我们现在就来把它拆解成人话。&lt;/p&gt;
&lt;p&gt;其实这个词也并不魔幻，加载在计算机领域就是指，&lt;strong&gt;把某设备上（比如硬盘）的程序复制到内存中的过程&lt;/strong&gt;。那加载启动区这个过程，翻译过来就是，&lt;strong&gt;BIOS 程序把启动区的内容复制到了内存中的某个区域&lt;/strong&gt;。好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。&lt;/p&gt;
&lt;p&gt;什么是启动区呢？即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等，&lt;strong&gt;BIOS 会按照顺序，读取这些启动盘中位于 0 盘 0 道 1 扇区的内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。&lt;/p&gt;
&lt;p&gt;接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，&lt;strong&gt;如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区&lt;/strong&gt;。如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。&lt;/p&gt;
&lt;p&gt;BIOS 找到了这个启动区之后干嘛呢？哦，前面说过了是加载，&lt;strong&gt;就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置&lt;/strong&gt;。怎么复制的？当然是指令啦。哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。&lt;/p&gt;
&lt;p&gt;启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。&lt;/p&gt;
&lt;p&gt;咦？不知道你有没有发现，我们似乎不知不觉又把之前的一句魔法语言翻译成人话了，开头我们说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;BIOS 把控制权转交给排在第一位的存储设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这句话是什么意思呢？&lt;strong&gt;就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00&lt;/strong&gt;。你看，这不是也没多几个字嘛，就把这个问题说得明明白白，简简单单。&lt;/p&gt;
&lt;p&gt;哦，对了，现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？我们看一个简单的启动区 512 字节的代码。（代码摘抄自《30 天自制操作系统》）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; hello-os
; TAB=4

                ORG             0x7c00                  ;程序加载到内存的 0x7c00 这个位置

;程序主体

entry:
                MOV             AX,0                    ;初始化寄存器
                MOV             SS,AX
                MOV             SP,0x7c00
                MOV             DS,AX                   ;段寄存器初始化为 0
                MOV             ES,AX
                MOV             SI,msg
putloop:
                MOV             AL,[SI]
                ADD             SI,1
                CMP             AL,0                    ;如果遇到 0 结尾的，就跳出循环不再打印新字符
                JE              fin
                MOV             AH,0x0e                 ;指定文字
                MOV             BX,15                   ;指定颜色
                INT             0x10                    ;调用 BIOS 显示字符函数
                JMP             putloop
fin:
                HLT
                JMP             fin
msg:
                DB              0x0a,0x0a               ;换行、换行
                DB              &quot;hello-os&quot;
                DB              0x0a                    ;换行
                DB              0                               ;0 结尾

                RESB 0x7dfe-$                   ;填充0到512字节
                DB      0x55, 0xaa                      ;可启动设备标识
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看第一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ORG          0x7c00
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。&lt;/p&gt;
&lt;p&gt;然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。&lt;/p&gt;
&lt;p&gt;再看最后一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DB   0x55, 0xaa
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。&lt;/p&gt;
&lt;p&gt;回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。&lt;/p&gt;
&lt;p&gt;第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。&lt;/p&gt;
&lt;h2 id=&quot;七、启动区里的代码写了啥&quot;&gt;七、启动区里的代码写了啥&lt;/h2&gt;
&lt;p&gt;其实写到这，我这篇文章就应该戛然而止了，因为最初的那个问题已经解决了，CPU 已经开始马不停蹄地从我们预期的位置跑起来了，万事开头难，剩下的内容，就是操作系统想怎么玩就怎么玩了。&lt;/p&gt;
&lt;p&gt;但我觉得还不够味，似乎还有些问题萦绕在你脑海里。比如说这个问题：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？&lt;/p&gt;
&lt;p&gt;其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？&lt;/p&gt;
&lt;p&gt;没错，就是这个套路。&lt;strong&gt;所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核&lt;/strong&gt;，这配合默契吧？&lt;/p&gt;
&lt;p&gt;由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。&lt;/p&gt;
&lt;h2 id=&quot;八、操作系统内核写了啥&quot;&gt;八、操作系统内核写了啥&lt;/h2&gt;
&lt;p&gt;好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）&lt;/li&gt;
&lt;li&gt;该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）&lt;/li&gt;
&lt;li&gt;执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）&lt;/li&gt;
&lt;li&gt;启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;经过这连续的四次跳跃，终于来到了操作系统的世界了，剩下的内容，可以说是整个操作系统课程所讲述的原理，分段、分页、建立中断、设备驱动、内存管理、进程管理、文件系统、用户态接口等等。&lt;/p&gt;
&lt;p&gt;这些名次在操作系统的课程中你可能都或多或少听过，如果你好好学了的话也一定知道大概的原理，不过像笔者这样从头到尾研读过 linux 内核源码的硬核狗来说，这些概念不只是书本上枯燥无味的概念，而是活灵活现在操作系统的每一行代码上，有的展现了作者无比的智慧，有的让我看到了作者由于硬件设定不得已做出的屈服，建议你也找时间读一读，与我交流一下感悟哈哈。&lt;/p&gt;
&lt;h2 id=&quot;九、参考资料&quot;&gt;九、参考资料&lt;/h2&gt;
&lt;p&gt;好了，这回我真的要结束了，相信如果你真的看完了全文，计算机的启动过程，可以说有了比较具象的了解。如果你想深入细节，也就是了解整个过程的每一点，那可要下功夫了。&lt;/p&gt;
&lt;p&gt;初学者推荐两本书籍，可以顺序阅读，祝你入坑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《30 天自制操作系统》&lt;/li&gt;
&lt;li&gt;《操作系统真象还原》&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Sat, 14 Nov 2020 00:48:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>本讲只为讲明白下面一个问题：我们按下开机键后究竟发生了什么？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/13972241.html</dc:identifier>
</item>
<item>
<title>3.3 Spring5源码---循环依赖过程中spring读取不完整bean的最终解决方案 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/13972220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/13972220.html</guid>
<description>&lt;h3&gt;根据之前解析的循环依赖的源码, 分析了一级缓存,二级缓存,三级缓存的作用以及如何解决循环依赖的. 然而在多线程的情况下, Spring在创建bean的过程中, 可能会读取到不完整的bean. 下面, 我们就来研究两点:&lt;/h3&gt;
&lt;h3&gt;1. 为什么会读取到不完整的bean.&lt;/h3&gt;
&lt;h3&gt;2. 如何解决读取到不完整bean的问题.&lt;/h3&gt;

&lt;p&gt;和本文相关的spring循环依赖的前两篇博文如下: &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/ITPower/p/13941844.html&quot;&gt;3.1 spring5源码系列--循环依赖 之 手写代码模拟spring循环依赖&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/ITPower/p/13956880.html&quot;&gt;3.2spring源码系列----循环依赖源码分析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们知道, 如果spring容器已经加载完了, 那么肯定所有bean都是完整的了, 但如果, spring没有加载完, 在加载的过程中, 构建bean就有可能出现不完整bean的情况&lt;/p&gt;
&lt;p&gt;如下所示: &lt;/p&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201113100420567-1075604066.png&quot; width=&quot;1200&quot; loading=&quot;lazy&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;首先, 有一个线程要去创建A类, 调用getBean(A),他会怎么做呢?&lt;/p&gt;
&lt;p&gt;第一步: 调用getSingleton()方法, 去缓存中取数据, 我们发现缓存中啥都没有, 肯定返回null. &lt;/p&gt;
&lt;p&gt;第二步: 将其放入到正在创建集合中,标记当前bean A正在创建&lt;/p&gt;
&lt;p&gt;第三步: 实例化bean&lt;/p&gt;
&lt;p&gt;第四步: 将bean放到三级缓存中. 定义一个函数接口, 方便后面调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四步: 属性赋值. 在属性赋值的时候, 返现要加载类B,就在这个时候, 另一个线程也进来了, 要创建Bean A.&lt;/p&gt;
&lt;p&gt;第五步: 线程2 创建bean ,也是先去调用getSinglton()从缓存中取, 一二级换粗中都没有,但是三级缓存中却是有的. 于是就调用动态代理, 去创建bean, 很显然这时候创建的bean是不完整的. 然后将其放入到二级缓存中, 二级缓存里的bean也是不完整的. 这就导致了后面是用的bean可能都是不完整的. 详细的分析上图&lt;/p&gt;


&lt;p&gt;其实, 之所以出现这样的问题, 原因就在于, 第一个bean还没有被创建完, 第二个bean就开始了. 这是典型的并发问题. &lt;/p&gt;
&lt;p&gt;针对这个问题, 其实,我们加锁就可以了.  &lt;/p&gt;
&lt;p&gt; 用自己手写的代码为例&lt;/p&gt;
&lt;p&gt;第一: 将整个创建过程加一把锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 获取bean, 根据beanName获取
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBean(String beanName) throws Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加一个出口. 判断实体类是否已经被加载过了&lt;/span&gt;
        Object singleton =&lt;span&gt; getSingleton(beanName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
        }
        Object instanceBean;
        &lt;span&gt;&lt;strong&gt;synchronized (singletonObjects) {

            &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记bean正在创建&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;singletonsCurrectlyInCreation.contains(beanName)) {
                singletonsCurrectlyInCreation.add(beanName);
            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             * 第一步: 实例化
             * 我们这里是模拟, 采用反射的方式进行实例化. 调用的也是最简单的无参构造函数
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            RootBeanDefinition beanDefinition &lt;/span&gt;= (RootBeanDefinition) beanDefinitionMap.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
            Class&lt;/span&gt;&amp;lt;?&amp;gt; beanClass =&lt;span&gt; beanDefinition.getBeanClass();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用无参的构造函数进行实例化&lt;/span&gt;
            instanceBean =&lt;span&gt; beanClass.newInstance();


            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             * 第二步: 放入到三级缓存
             * 每一次createBean都会将其放入到三级缓存中. getObject是一个钩子方法. 在这里不会被调用.
             * 什么时候被调用呢?
             * 在getSingleton()从三级缓存中取数据, 调用创建动态代理的时候
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            singletonFactories.put(beanName, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectFactory() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getObject() throws BeansException {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JdkProxyBeanPostProcessor().getEarlyBeanReference(earlySingletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName), beanName);
                }
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;earlySingletonObjects.put(beanName, instanceBean);&lt;/span&gt;

            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             *  第三步: 属性赋值
             *  instanceA这类类里面有一个属性, InstanceB. 所以, 先拿到 instanceB, 然后在判断属性头上有没有Autowired注解.
             *  注意: 这里我们只是判断有没有Autowired注解. spring中还会判断有没有@Resource注解. @Resource注解还有两种方式, 一种是name, 一种是type
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Field[] declaredFields &lt;/span&gt;=&lt;span&gt; beanClass.getDeclaredFields();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field declaredField : declaredFields) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断每一个属性是否有@Autowired注解&lt;/span&gt;
                Autowired annotation = declaredField.getAnnotation(Autowired.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (annotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置这个属性是可访问的&lt;/span&gt;
                    declaredField.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么这个时候还要构建这个属性的bean.&lt;/span&gt;
                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                     * 获取属性的名字
                     * 真实情况, spring这里会判断, 是根据名字, 还是类型, 还是构造函数来获取类.
                     * 我们这里模拟, 所以简单一些, 直接根据名字获取.
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    String name &lt;/span&gt;=&lt;span&gt; declaredField.getName();

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
                     * 这样, 在这里我们就拿到了 instanceB 的 bean
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    Object fileObject &lt;/span&gt;=&lt;span&gt; getBean(name);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为属性设置类型&lt;/span&gt;
                    declaredField.&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(instanceBean, fileObject);
                }
            }


            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             * 第四步: 初始化
             * 初始化就是设置类的init-method.这个可以设置也可以不设置. 我们这里就不设置了
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;


            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             * 第五步: 放入到一级缓存
             *
             * 在这里二级缓存存的是动态代理, 那么一级缓存肯定也要存动态代理的实例.
             * 从二级缓存中取出实例, 放入到一级缓存中
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (earlySingletonObjects.containsKey(beanName)) {
                instanceBean &lt;/span&gt;= earlySingletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
            }
            singletonObjects.put(beanName, instanceBean);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除二级缓存

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除三级缓存&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;        }
        &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instanceBean;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在从缓存取数据的getSingleton()上也加一把锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getSingleton(String beanName) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先去一级缓存里拿,&lt;/span&gt;
        Object bean = singletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一级缓存中没有, 但是正在创建的bean标识中有, 说明是循环依赖&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (bean == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; singletonsCurrectlyInCreation.contains(beanName)) {
           &lt;span&gt;&lt;strong&gt; synchronized (singletonObjects) {&lt;/strong&gt;&lt;/span&gt;
                bean &lt;/span&gt;= earlySingletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果二级缓存中没有, 就从三级缓存中拿&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (bean == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从三级缓存中取&lt;/span&gt;
                    ObjectFactory objectFactory = singletonFactories.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (objectFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是真正创建动态代理的地方.&lt;/span&gt;
                        bean =&lt;span&gt; objectFactory.getObject();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后将其放入到二级缓存中. 因为如果有多次依赖, 就去二级缓存中判断. 已经有了就不在再次创建了&lt;/span&gt;
&lt;span&gt;                        earlySingletonObjects.put(beanName, bean);
                    }
                }
            }
        &lt;span&gt;&lt;strong&gt;}
        &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加了两把锁.&lt;/p&gt;

&lt;p&gt;这样, 在分析一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201114080805566-1685126495.png&quot; width=&quot;1000&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图,线程B执行到getSingleton()的时候, 从一级缓存中取没有, 到二级缓存的时候就加锁了,他要等待直到线程A完成执行完才能进入. 这样就避免出现不完整bean的情况. &lt;/p&gt;


&lt;p&gt;在创建实例bean的时候, 加了一把锁, 锁是一级缓存.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Assert.notNull(beanName, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bean name must not be null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&lt;strong&gt;synchronized (this.singletonObjects) {
 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步: 从一级缓存中获取单例对象&lt;/span&gt;
 &lt;span&gt;5&lt;/span&gt;             Object singletonObject = &lt;span&gt;this&lt;/span&gt;.singletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonsCurrentlyInDestruction) {
 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCreationNotAllowedException(beanName,
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;                             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singleton bean creation not allowed while singletons of this factory are in destruction &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
&lt;span&gt;10&lt;/span&gt;                             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(Do not request a bean from a BeanFactory in a destroy method implementation!)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     logger.debug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Creating shared instance of singleton bean '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + beanName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步: 将bean添加到singletonsCurrentlyInCreation中, 表示bean正在创建&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;&lt;span&gt;                 beforeSingletonCreation(beanName);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 boolean newSingleton = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 boolean recordSuppressedExceptions = (&lt;span&gt;this&lt;/span&gt;.suppressedExceptions == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (recordSuppressedExceptions) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.suppressedExceptions = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步: 这里调用getObject()钩子方法, 就会回调匿名函数, 调用singletonFactory的createBean()&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                     singletonObject =&lt;span&gt; singletonFactory.getObject();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     newSingleton = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalStateException ex) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Has the singleton object implicitly appeared in the meantime -&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if yes, proceed with it since the exception indicates that state.&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                     singletonObject = &lt;span&gt;this&lt;/span&gt;.singletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (recordSuppressedExceptions) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (Exception suppressedException : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.suppressedExceptions) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;                             ex.addRelatedCause(suppressedException);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;&lt;span&gt;                         }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (recordSuppressedExceptions) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.suppressedExceptions = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;&lt;span&gt;                     afterSingletonCreation(beanName);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (newSingleton) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;                     addSingleton(beanName, singletonObject);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;&lt;span&gt;&lt;strong&gt;         }
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再从缓存中取数据的时候, 也加了一把锁, 和我们的demo逻辑是一样的. 锁也是一级缓存.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object getSingleton(String beanName, boolean allowEarlyReference) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从一级缓存中获取bean实例对象&lt;/span&gt;
        Object singletonObject = &lt;span&gt;this&lt;/span&gt;.singletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 如果在第一级的缓存中没有获取到对象, 并且singletonsCurrentlyIncreation为true,也就是这个类正在创建.
         * 标明当前是一个循环依赖.
         *
         * 这里有处理循环依赖的问题.-- 我们使用三级缓存解决循环依赖
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isSingletonCurrentlyInCreation(beanName)) {
            &lt;span&gt;&lt;strong&gt;synchronized (&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;this.singletonObjects) {
                &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
                 * 从二级缓存中拿bean, 二级缓存中的对象是一个早期对象
                 * 什么是早期对象?就是bean刚刚调用了构造方法, 还没有给bean的属性进行赋值, 和初始化, 这就是早期对象
                  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                singletonObject &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.earlySingletonObjects.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; allowEarlyReference) {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
                     * 从三级缓存拿bean, singletonFactories是用来解决循环依赖的关键所在.
                     * 在ios后期的过程中, 当bean调用了构造方法的时候, 把早期对象包装成一个ObjectFactory对象,暴露在三级缓存中
                      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    ObjectFactory&lt;/span&gt;&amp;lt;?&amp;gt; singletonFactory = &lt;span&gt;this&lt;/span&gt;.singletonFactories.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(beanName);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singletonFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
                         * 在这里通过暴露的ObjectFactory包装对象. 通过调用他的getObject()方法来获取对象
                         * 在这个环节中会调用getEarlyBeanReference()来进行后置处理
                         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                        singletonObject &lt;/span&gt;=&lt;span&gt; singletonFactory.getObject();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把早期对象放置在二级缓存中&lt;/span&gt;
                        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlySingletonObjects.put(beanName, singletonObject);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除三级缓存&lt;/span&gt;
                        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singletonFactories.remove(beanName);
                    }
                }
            }
        &lt;span&gt;&lt;strong&gt;}
        &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singletonObject;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 14 Nov 2020 00:23:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>根据之前解析的循环依赖的源码, 分析了一级缓存,二级缓存,三级缓存的作用以及如何解决循环依赖的. 然而在多线程的情况下, Spring在创建bean的过程中, 可能会读取到不完整的bean. 下面,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/13972220.html</dc:identifier>
</item>
<item>
<title>LOJ #6029. 「雅礼集训 2017 Day1」市场 线段树维护区间除法 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13972196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13972196.html</guid>
<description>&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;从前有一个贸易市场，在一位执政官到来之前都是非常繁荣的，自从他来了之后，发布了一系列奇怪的政令，导致贸易市场的衰落。&lt;/p&gt;
&lt;p&gt;有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个商贩，从&lt;span class=&quot;math inline&quot;&gt;\(0 \sim n - 1\)&lt;/span&gt; 编号，每个商贩的商品有一个价格&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;，有两种政令：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(l, r, c\)&lt;/span&gt;，对于&lt;span class=&quot;math inline&quot;&gt;\(i \in [l, r], a_i \leftarrow a_i + c\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(l, r, d\)&lt;/span&gt;，对于&lt;span class=&quot;math inline&quot;&gt;\(i \in [l, r], a_i \leftarrow \lfloor {a_i}/{d} \rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在有一个外乡的旅客想要了解贸易市场的信息，有两种询问方式：&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(l, r\)&lt;/span&gt;，求&lt;span class=&quot;math inline&quot;&gt;\(\min_{i \in [l, r]} a_i\)&lt;/span&gt;&lt;br/&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(l, r\)&lt;/span&gt;，求&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i\in [l, r]} a_i\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;输入格式&lt;/h2&gt;
&lt;p&gt;第一行为两个空格隔开的整数 &lt;span class=&quot;math inline&quot;&gt;\(n, q\)&lt;/span&gt; 分别表示商贩个数和政令 &lt;span class=&quot;math inline&quot;&gt;\(+\)&lt;/span&gt; 询问个数。&lt;br/&gt;第二行包含 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个由空格隔开的整数&lt;span class=&quot;math inline&quot;&gt;\(a_0 \sim a_{n - 1}\)&lt;/span&gt;&lt;br/&gt;接下来 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 行，每行表示一个操作，第一个数表示操作编号&lt;span class=&quot;math inline&quot;&gt;\(1 \sim 4\)&lt;/span&gt;，接下来的输入和问题描述一致。&lt;/p&gt;
&lt;h2 id=&quot;输出格式&quot;&gt;输出格式&lt;/h2&gt;
&lt;p&gt;对于每个 &lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(4\)&lt;/span&gt; 操作，输出询问答案。&lt;/p&gt;
&lt;h2 id=&quot;样例&quot;&gt;样例&lt;/h2&gt;
&lt;h3 id=&quot;样例输入&quot;&gt;样例输入&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10 10&lt;br/&gt;-5 -4 -3 -2 -1 0 1 2 3 4&lt;br/&gt;1 0 4 1&lt;br/&gt;1 5 9 1&lt;br/&gt;2 0 9 3&lt;br/&gt;3 0 9&lt;br/&gt;4 0 9&lt;br/&gt;3 0 1&lt;br/&gt;4 2 3&lt;br/&gt;3 4 5&lt;br/&gt;4 6 7&lt;br/&gt;3 8 9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;样例输出&quot;&gt;样例输出&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;-2&lt;br/&gt;-2&lt;br/&gt;-2&lt;br/&gt;-2&lt;br/&gt;0&lt;br/&gt;1&lt;br/&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据范围与提示&quot;&gt;数据范围与提示&lt;/h2&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(30\%\)&lt;/span&gt; 的数据，$n, q \leq 10 ^ 3 $；&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(60\%\)&lt;/span&gt; 的数据，保证数据随机；&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(100\%\)&lt;/span&gt; 的数据，&lt;span class=&quot;math inline&quot;&gt;\(1 \leq n, q \leq 10 ^ 5, 0 \leq l \leq r \leq n - 1, c \in [-10 ^ {4}, 10 ^ 4], d \in [2, 10 ^ 9]\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;对于区间加、区间求和、区间求最小值的操作，像正常的线段树那样维护即可&lt;/p&gt;
&lt;p&gt;对于区间除的操作，因为题目中要求向下取整，所以不能直接给整体除一个数&lt;/p&gt;
&lt;p&gt;但是我们可以把除法转化为减法，把除以一个数变成减去一个数&lt;/p&gt;
&lt;p&gt;这样，当一个区间内减去的数相同时，我们就可以给整体打一个标记&lt;/p&gt;
&lt;p&gt;判断区间减去的数是否相同只需要判断区间最大值和区间最小值减去的值是否相同&lt;/p&gt;
&lt;p&gt;如果不相同就一直下放，直到相同为止&lt;/p&gt;
&lt;p&gt;这样的话我们再记录一个最大值就可以解决了&lt;/p&gt;
&lt;p&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(可过)\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#define rg register
inline int read() {
    rg int x = 0, fh = 1;
    rg char ch = getchar();
    while (ch &amp;lt; '0' || ch &amp;gt; '9') {
        if (ch == '-')
            fh = -1;
        ch = getchar();
    }
    while (ch &amp;gt;= '0' &amp;amp;&amp;amp; ch &amp;lt;= '9') {
        x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * fh;
}
const int maxn = 1e5 + 5;
int a[maxn], n, q;
struct trr {
    int l, r, laz, mmin, mmax, siz;
    long long sum;
} tr[maxn &amp;lt;&amp;lt; 2];
void push_up(int da) {
    tr[da].mmax = std::max(tr[da &amp;lt;&amp;lt; 1].mmax, tr[da &amp;lt;&amp;lt; 1 | 1].mmax);
    tr[da].mmin = std::min(tr[da &amp;lt;&amp;lt; 1].mmin, tr[da &amp;lt;&amp;lt; 1 | 1].mmin);
    tr[da].sum = tr[da &amp;lt;&amp;lt; 1].sum + tr[da &amp;lt;&amp;lt; 1 | 1].sum;
}
void push_down(int da) {
    if (tr[da].laz) {
        tr[da &amp;lt;&amp;lt; 1].laz += tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1 | 1].laz += tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1].sum += 1LL * tr[da &amp;lt;&amp;lt; 1].siz * tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1 | 1].sum += 1LL * tr[da &amp;lt;&amp;lt; 1 | 1].siz * tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1].mmax += tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1 | 1].mmax += tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1].mmin += tr[da].laz;
        tr[da &amp;lt;&amp;lt; 1 | 1].mmin += tr[da].laz;
        tr[da].laz = 0;
    }
}
void build(int da, int l, int r) {
    tr[da].l = l, tr[da].r = r, tr[da].siz = r - l + 1;
    if (tr[da].l == tr[da].r) {
        tr[da].mmin = tr[da].mmax = a[l];
        tr[da].sum = a[l];
        return;
    }
    rg int mids = (tr[da].l + tr[da].r) &amp;gt;&amp;gt; 1;
    build(da &amp;lt;&amp;lt; 1, l, mids);
    build(da &amp;lt;&amp;lt; 1 | 1, mids + 1, r);
    push_up(da);
}
void ad(int da, int l, int r, int val) {
    if (tr[da].l &amp;gt;= l &amp;amp;&amp;amp; tr[da].r &amp;lt;= r) {
        tr[da].laz += val;
        tr[da].sum += 1LL * val * tr[da].siz;
        tr[da].mmin += val;
        tr[da].mmax += val;
        return;
    }
    push_down(da);
    rg int mids = (tr[da].l + tr[da].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mids)
        ad(da &amp;lt;&amp;lt; 1, l, r, val);
    if (r &amp;gt; mids)
        ad(da &amp;lt;&amp;lt; 1 | 1, l, r, val);
    push_up(da);
}
int cxmin(int da, int l, int r) {
    if (tr[da].l &amp;gt;= l &amp;amp;&amp;amp; tr[da].r &amp;lt;= r) {
        return tr[da].mmin;
    }
    push_down(da);
    rg int mids = (tr[da].l + tr[da].r) &amp;gt;&amp;gt; 1, nans = 2147483647;
    if (l &amp;lt;= mids)
        nans = std::min(nans, cxmin(da &amp;lt;&amp;lt; 1, l, r));
    if (r &amp;gt; mids)
        nans = std::min(nans, cxmin(da &amp;lt;&amp;lt; 1 | 1, l, r));
    return nans;
}
long long cxsum(int da, int l, int r) {
    if (tr[da].l &amp;gt;= l &amp;amp;&amp;amp; tr[da].r &amp;lt;= r) {
        return tr[da].sum;
    }
    push_down(da);
    rg int mids = (tr[da].l + tr[da].r) &amp;gt;&amp;gt; 1;
    rg long long nans = 0;
    if (l &amp;lt;= mids)
        nans += cxsum(da &amp;lt;&amp;lt; 1, l, r);
    if (r &amp;gt; mids)
        nans += cxsum(da &amp;lt;&amp;lt; 1 | 1, l, r);
    return nans;
}
void cf(int da, int l, int r, int val) {
    if (tr[da].l &amp;gt;= l &amp;amp;&amp;amp; tr[da].r &amp;lt;= r) {
        rg int now1 = floor((double)tr[da].mmin / val) - tr[da].mmin;
        rg int now2 = floor((double)tr[da].mmax / val) - tr[da].mmax;
        if (tr[da].l == tr[da].r) {
            tr[da].mmin = floor((double)tr[da].mmin / val);
            tr[da].sum = tr[da].mmax = tr[da].mmin;
        } else if (now1 == now2) {
            tr[da].mmin += now1;
            tr[da].mmax += now1;
            tr[da].laz += now1;
            tr[da].sum += 1LL * tr[da].siz * now1;
        } else {
            push_down(da);
            cf(da &amp;lt;&amp;lt; 1, l, r, val);
            cf(da &amp;lt;&amp;lt; 1 | 1, l, r, val);
            push_up(da);
        }
        return;
    }
    push_down(da);
    rg int mids = (tr[da].l + tr[da].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mids)
        cf(da &amp;lt;&amp;lt; 1, l, r, val);
    if (r &amp;gt; mids)
        cf(da &amp;lt;&amp;lt; 1 | 1, l, r, val);
    push_up(da);
}
int main() {
    n = read(), q = read();
    for (rg int i = 1; i &amp;lt;= n; i++) {
        a[i] = read();
    }
    build(1, 1, n);
    rg int aa, bb, cc, dd;
    for (rg int i = 1; i &amp;lt;= q; i++) {
        aa = read(), bb = read(), cc = read();
        bb++, cc++;
        if (aa == 1) {
            dd = read();
            ad(1, bb, cc, dd);
        } else if (aa == 2) {
            dd = read();
            cf(1, bb, cc, dd);
        } else if (aa == 3) {
            printf(&quot;%d\n&quot;, cxmin(1, bb, cc));
        } else {
            printf(&quot;%lld\n&quot;, cxsum(1, bb, cc));
        }
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 13 Nov 2020 23:31:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>题目描述 从前有一个贸易市场，在一位执政官到来之前都是非常繁荣的，自从他来了之后，发布了一系列奇怪的政令，导致贸易市场的衰落。 有 \(n\) 个商贩，从$0 \sim n - 1$ 编号，每个商贩的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13972196.html</dc:identifier>
</item>
<item>
<title>一种简易的表达式求值算法 - yuanyb</title>
<link>http://www.cnblogs.com/yuanyb/p/13972051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanyb/p/13972051.html</guid>
<description>&lt;p&gt;在算法书上看到了Dijkstra的表达式求值算法，不断地将括号包围的子表达式替换为一个数值，最终就可以求得结果。相比于转换成后缀表达式的算法，该算法很简洁，但限制却十分地大：必须将所有 &lt;span&gt;expr op expr&lt;/span&gt; 用括号括起来，如：&lt;span&gt;( 1 + ( ( 2 + 3 ) + ( 4 * 5 ) ) )&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Dijkstra算法（PS：下面的实现中，每次读到的字符串s是一个一个的元素数字or运算符）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Evaluate {
    public static void main(String[] args) {
        Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;String&amp;gt;();
        Stack&amp;lt;Double&amp;gt; vals = new Stack&amp;lt;Double&amp;gt;();
        while (!StdIn.isEmpty()) { // 读取字符，如果是运算符则压入栈
            String s = StdIn.readString();
            if (s.equals(&quot;(&quot;)) ;
            else if (s.equals(&quot;+&quot;)) ops.push(s);
            else if (s.equals(&quot;-&quot;)) ops.push(s);
            else if (s.equals(&quot;*&quot;)) ops.push(s);
            else if (s.equals(&quot;/&quot;)) ops.push(s);
            else if (s.equals(&quot;sqrt&quot;)) ops.push(s);
            else if (s.equals(&quot;)&quot;)) { // 如果字符为 &quot;)&quot;，弹出运算符和操作数，计算结果并压入栈
                String op = ops.pop();
                double v = vals.pop();
                if (op.equals(&quot;+&quot;)) v = vals.pop() + v;
                else if (op.equals(&quot;-&quot;)) v = vals.pop() - v;
                else if (op.equals(&quot;*&quot;)) v = vals.pop() * v;
                else if (op.equals(&quot;/&quot;)) v = vals.pop() / v;
                else if (op.equals(&quot;sqrt&quot;)) v = Math.sqrt(v);
                vals.push(v);
            } // 如果字符既非运算符也不是括号，将它作为 double 值压入栈
            else vals.push(Double.parseDouble(s));
        }
        StdOut.println(vals.pop());
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;然后我就尝试改进算法，去除必须添加括号限制，思路也是将括号围起来的子表达式求值然后替换，相对来看，改进后的算法代码行数增加了25行左右（去除栈定义、数字识别的代码），但依然要比转换成后缀表达式要简单、容易很多&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如：&lt;span&gt;-1 + 2 * (3 * 3 - 10)&lt;span&gt;    =&amp;gt;   &lt;/span&gt; -1 + 2 * (-1)&lt;span&gt;   =&amp;gt; &lt;/span&gt; -3&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
/////// stack begin /////////
type stack []interface{}

func (s stack) empty() bool {
    return len(s) == 0
}

func (s *stack) push(e interface{}) {
    *s = append(*s, e)
}

func (s *stack) pop() interface{} {
    lastIdx := len(*s) - 1
    e := (*s)[lastIdx]
    *s = (*s)[:lastIdx]
    return e
}
/////// stack end /////////

func Calculate(expr string) int {
    numStack, opStack, curSubexprNumCount := stack{}, stack{}, stack{}
    expr = &quot;(&quot; + expr + &quot;)&quot;
    for i := 0; i &amp;lt; len(expr); i++ {
        ch := expr[i]
        switch ch {
        case '(':
            if !curSubexprNumCount.empty() { // 遇到下一个子表达式，则当前表达式数字个数加一
                curSubexprNumCount.push(curSubexprNumCount.pop().(int) + 1)
            }
            curSubexprNumCount.push(0)
            opStack.push(ch)
        case '+', '-', '*', '/':
            opStack.push(ch)
        case ')':
            numStk, opStk := stack{}, stack{} // 正序化
            numCount := curSubexprNumCount.pop().(int)
            for j := 0; j &amp;lt; numCount; j++ {
                numStk.push(numStack.pop())
            }
            for op := opStack.pop().(byte); op != '('; op = opStack.pop().(byte) {
                opStk.push(op)
            }
            if len(numStk) == len(opStk) { // + 或 - 开头的子表达式：-1+2...
                if op := opStk.pop().(byte); op == '-' {
                    numStk.push(-numStk.pop().(int))
                }
            }
            var tmp stack
            tmp.push(numStk.pop().(int))
            for !opStk.empty() {
                x := numStk.pop().(int)
                switch opStk.pop().(byte) {
                case '+': tmp.push(x)
                case '-': tmp.push(-x)
                case '*': tmp.push(tmp.pop().(int) * x)
                case '/': tmp.push(tmp.pop().(int) / x)
                }
            }
            result := 0
            for !tmp.empty() {
                result += tmp.pop().(int)
            }
            numStack.push(result) // 将求得的子表达式值放入栈中
        default:
            if !unicode.IsDigit(rune(ch)) {
                continue
            }
            num := 0
            for ; i &amp;lt; len(expr) &amp;amp;&amp;amp; unicode.IsDigit(rune(expr[i])); i++ {
                num = 10 * num + int(expr[i]) - '0'
            }
            i-- // 退一步
            numStack.push(num)
            curSubexprNumCount.push(curSubexprNumCount.pop().(int) + 1)
        }
    }
    result := 0
    for !numStack.empty() {
        result += numStack.pop().(int)
    }
    return result
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 13 Nov 2020 17:09:00 +0000</pubDate>
<dc:creator>yuanyb</dc:creator>
<og:description>在算法书上看到了Dijkstra的表达式求值算法，不断地将括号包围的子表达式替换为一个数值，最终就可以求得结果。相比于转换成后缀表达式的算法，该算法很简洁，但限制却十分地大：必须将所有 expr op</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanyb/p/13972051.html</dc:identifier>
</item>
<item>
<title>Java内存泄漏 - Luckyp1ng</title>
<link>http://www.cnblogs.com/p1ng/p/13971962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/13971962.html</guid>
<description>&lt;p&gt;要了解Java中的内存泄漏，首先就得知道Java中的内存是如何管理的。&lt;/p&gt;
&lt;p&gt;在Java程序中，我们通常使用 new 为对象分配内存，而这些内存空间都在堆上。&lt;/p&gt;
&lt;p&gt;Java判断对象是否可以回收使用的而是可达性分析算法。&lt;/p&gt;
&lt;p&gt;这个算法的基本思路就是通过一系列名为 &quot;GC Roots&quot; 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202011/1898410-20201113234930041-1269375582.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Java 语言中，可作为 GC Roots 对象的包括如下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈(Native方法)中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java 中的内存泄漏，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄漏。&lt;/p&gt;
&lt;p&gt;Java 中的内存泄漏与 C++ 中的表现有所不同。&lt;/p&gt;
&lt;p&gt;在 C++ 中，所有被分配了内存的对象，不再使用之后，都必须程序员手动的去释放他们。但是在 Java 中，我们不用自己释放内存，无用的内存由 GC 自动清理，这也极大的简化了我们的编程工作。但实际有时候一些不再会被使用的对象在 GC 看来不能被释放就会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;对象都是有生命周期的，有的长，有的短。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄漏。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
        Object object;
        public void method() {
                object = new Object();
                // ...
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 object 实例，其实我们期望它只作用于 method() 方法中，且其他地方也不会再用到它，但是当 method() 方法执行完之后，object对象所分配的内存不会马上被认为是可以被释放的对象。只有在 Test 类创建的对象被释放后才会被释放。严格地说，这就是一种内存泄漏。解决办法就是将 object 作为 method() 方法中的局部变量。当然也可以在使用完 object 之后 将其置为 null。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
        Object object;
        public void method() {
                object = new Object();
                // ...
                object = null;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，之前 new Object() 分配的内存就可以被 GC 回收。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;strong&gt;静态集合类&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static Vector v = new Vector(); 
for (int i = 1; i&amp;lt;100; i++) 
{ 
    Object o = new Object(); 
    v.add(o); 
    o = null; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，代码栈中存在 Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;各种连接，如数据库连接、网络连接和IO连接等&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;strong&gt;变量不合理的作用域&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UsingRandom {
        private String msg;
        public void receiveMsg(){       
                readFromNet();// 从网络中接受数据保存到msg中
                saveDB();// 把msg保存到数据库中
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如上面这个伪代码&lt;/strong&gt;，通过 readFromNet() 方法把接受的消息保存在变量 msg 中，然后调用 saveDB() 方法把 msg 的内容保存到数据库中，此时 msg 已经就没用了，由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能回收，因此造成了内存泄漏。&lt;/p&gt;
&lt;p&gt;实际上这个 msg 变量可以放在 receiveMsg() 方法内部，当方法使用完，那么 msg 的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;strong&gt;内部类持有外部类&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;&lt;strong&gt;改变哈希值&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) 
{ 
    Set&amp;lt;Person&amp;gt; set = new HashSet&amp;lt;Person&amp;gt;(); 
    Person p1 = new Person(&quot;唐僧&quot;,&quot;pwd1&quot;,25); 
    Person p2 = new Person(&quot;孙悟空&quot;,&quot;pwd2&quot;,26); 
    Person p3 = new Person(&quot;猪八戒&quot;,&quot;pwd3&quot;,27); 
    set.add(p1); 
    set.add(p2); 
    set.add(p3); 
    System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素! 
    p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 
    set.remove(p3); //此时remove不掉，造成内存泄漏
    set.add(p3); //重新添加，居然添加成功 
    System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素! 
    for (Person person : set) 
    { 
        System.out.println(person); 
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;strong&gt;单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用 WeakHashMap 代表缓存，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;&lt;strong&gt;监听器和回调&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的弱引用，例如将他们保存成为 WeakHashMap 中的键。&lt;/p&gt;

&lt;p&gt;1.尽量减少使用静态变量，类的静态变量的生命周期和类同步的。&lt;/p&gt;
&lt;p&gt;2.声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员变量改写为方法内的局部变量；&lt;/p&gt;
&lt;p&gt;3.减少长生命周期的对象持有短生命周期的引用；&lt;/p&gt;
&lt;p&gt;4.使用StringBuilder和StringBuffer进行字符串连接，Sting和StringBuilder以及StringBuffer等都可以代表字符串，其中String字符串代表的是不可变的字符串，后两者表示可变的字符串。如果使用多个String对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。&lt;/p&gt;
&lt;p&gt;5.对于不需要使用的对象手动设置null值，不管GC何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；&lt;/p&gt;
&lt;p&gt;6.各种连接（数据库连接，网络连接，IO连接）操作，务必显示调用close关闭。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 15:50:00 +0000</pubDate>
<dc:creator>Luckyp1ng</dc:creator>
<og:description>Java中的内存管理 要了解Java中的内存泄漏，首先就得知道Java中的内存是如何管理的。 在Java程序中，我们通常使用 new 为对象分配内存，而这些内存空间都在堆上。 Java判断对象是否可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/13971962.html</dc:identifier>
</item>
<item>
<title>Electron入门指北 - 沉迷代码的萌新</title>
<link>http://www.cnblogs.com/NCoreCoder/p/13971956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NCoreCoder/p/13971956.html</guid>
<description>&lt;p&gt;最近几年最火的桌面化技术，无疑是&lt;strong&gt;Qt+&lt;/strong&gt;和&lt;strong&gt;Electron&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;两者都有跨平台桌面化技术，并不局限于Windows系统&lt;/strong&gt;。前者因嵌入式而诞生，在演变过程中，逐步&lt;strong&gt;完善了生态以及工具链&lt;/strong&gt;。后者则是依托于&lt;strong&gt;Node.Js&lt;/strong&gt;和&lt;strong&gt;CCM（Chromium Content Module）&lt;/strong&gt;,支持&lt;strong&gt;Node.js&lt;/strong&gt;和&lt;strong&gt;Node.js原生&lt;/strong&gt;以及自主封装的&lt;strong&gt;Electron API&lt;/strong&gt;。&lt;br/&gt;因为项目考虑跨平台的技术选型，研究过长达一年的Electron，并且做了很多尝试，所以想与诸君分享Electron的技术心得。&lt;/p&gt;

&lt;p&gt;Electron依赖于Node.js，只要会用Node.js开发程序的，都可以用Electron开发桌面应用，只需要前端结合Electron API，就可以快速完成桌面应用，&lt;strong&gt;一处代码，多处编译&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;electron的优势&quot;&gt;Electron的优势&lt;/h2&gt;
&lt;p&gt;可以编译在Windows、Mac、Linux的X64/x86环境，因为是系统&lt;strong&gt;独立打包，不依赖运行时&lt;/strong&gt;。&lt;br/&gt;页面开发依赖于Node.js加前端，可以很便捷的采用前端开发页面，再通过Electron API结合的形式，Electron API可以理解为一套Node原生库，实际上安装也就是一句 &lt;strong&gt;npm install electron&lt;/strong&gt;&lt;br/&gt;Electron内核采用Chromium，可以兼容主流浏览器，并不需要额外适配，而且采用Chromium LST（长期支持版本），并不会过于激进的选择最新版本，减少了前端为了兼容适配带来的风险性。&lt;br/&gt;另一方面，采用前端做UI层，可以减少UI对于系统的适配情况。&lt;/p&gt;
&lt;h2 id=&quot;electron的应用场景&quot;&gt;Electron的应用场景&lt;/h2&gt;
&lt;p&gt;由于采用了Node.js和前端的开发模式，本身是一个嵌套了浏览器的本地化前端应用，适合一些没有底层操作的应用场景，甚至前端页面可以是远程地址，这样子完全可以完成桌面应用的无缝&lt;strong&gt;热更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Electron采用的核心架构是Node.js，所以一旦涉及非页面展示层的功能，比如要与com交互，要操作底层库，比如各种硬件交互的SDK XX.dll，这里就需要参考Node原生来编写原生扩展了。&lt;/p&gt;
&lt;h2 id=&quot;node原生编写&quot;&gt;Node原生编写&lt;/h2&gt;
&lt;p&gt;参照Node.js官网的原生扩展，编写一个简单的例子&lt;/p&gt;
&lt;p&gt;执行npm init&lt;br/&gt;创建一个默认的package.json&lt;/p&gt;
&lt;p&gt;以下代码保存为 hello.cc&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;node.h&amp;gt;

namespace demo {

using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

void Method(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(String::NewFromUtf8(
      isolate, &quot;world&quot;));
}

void Initialize(Local&amp;lt;Object&amp;gt; exports) {
  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下代码保存为 binding.gyp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;hello&quot;,
      &quot;cflags!&quot;: [ &quot;-fno-exceptions&quot; ],
      &quot;cflags_cc!&quot;: [ &quot;-fno-exceptions&quot; ],
      &quot;sources&quot;: [ &quot;hello.cc&quot; ],
      'defines': [ 'NAPI_DISABLE_CPP_EXCEPTIONS' ],
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行两个命令 &lt;strong&gt;node-gyp configure&lt;/strong&gt; &lt;strong&gt;node-gyp build&lt;/strong&gt;&lt;br/&gt;如果提示命令不存在，则 &lt;strong&gt;npm install node-gyp&lt;/strong&gt;&lt;br/&gt;命令很简单 前者是生成项目文件，后者则是编译文件，生成 &lt;strong&gt;hello.node&lt;/strong&gt; ，至于为什么叫hello.node，可以参考 binding.gyp/targets/target_name&lt;/p&gt;
&lt;p&gt;以下代码保存为 index.js&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var addon = require('./build/Release/hello');
console.log(addon.hello()); // 'world'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 &lt;strong&gt;node .&lt;/strong&gt; ，显示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1403991/202011/1403991-20201113211205737-1057384309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;遭遇滑铁卢&quot;&gt;遭遇滑铁卢&lt;/h2&gt;
&lt;p&gt;好像一切都挺顺利的&lt;/p&gt;
&lt;p&gt;按照Electon的例子，编写index.js&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const { app, BrowserWindow } = require('electron')

function createWindow () {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      nodeIntegration: true
    }
  })

  win.loadURL('https://electronjs.org')

  var addon = require('./hello');
  console.log(addon.hello()); // 'world'
}

console.log(process.versions.node);
app.whenReady().then(createWindow);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码本身可以运行起来，但是加入了调用Node原生之后就提示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1403991/202011/1403991-20201113215604792-599371000.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这明显不能用啊，而且很认真的保持了Electron内部Node.js和外部编译插件的Node.js的一致性&lt;/p&gt;
&lt;h2 id=&quot;柳暗花明&quot;&gt;柳暗花明&lt;/h2&gt;
&lt;p&gt;参考了electron官方例子未果后，反复搜索资料，一一验证，最后发现，要在node-gyp编译的时候，标注版本&lt;br/&gt;&lt;strong&gt;node-gyp configure --target=版本号 --dist-url=https://atom.io/download/atom-shell&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;node-gyp build --target=版本&lt;/strong&gt;&lt;br/&gt;看见了node-gyp，你以为是编译的node对应版本的插件？no，这里编译的是electron对应的版本&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1403991/202011/1403991-20201113230124873-508651120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行成功的那一刻，我差点口吐芬芳，不带这么坑人的&lt;/p&gt;
&lt;h2 id=&quot;社会的险恶&quot;&gt;社会的险恶&lt;/h2&gt;
&lt;p&gt;程序也跑起来了，是不是 “天晴了雨停了，感觉自己又行了”&lt;br/&gt;这才第一步呢，实际上node.js原生的写法是专属写法，带有大量的侵入式的插件设计，这块不亚于重写学一门C语言的亚种 （比如Object-C和C的差别）&lt;br/&gt;这还只是自己撰写原生扩展，如果是海量API组合的呢？这个扩展要写成什么样？所幸社区开发了一种神器，叫FFI&lt;br/&gt;&lt;strong&gt;此时应有掌声&lt;/strong&gt;&lt;br/&gt;你以为这里是为你鼓掌的？不，这只是开启了探索星辰大海的第一步，告诉你，不要哭，未来哭的日子还长呢。&lt;br/&gt;FFI的编译文章千千万，编译不成功的文章更是数不胜数，&lt;strong&gt;没有一篇资料阐述了FFI与Node之间晦涩不明的版本关系&lt;/strong&gt; ，也没有一篇文章告诉你，如何成功安装。&lt;br/&gt;成功的都是侥幸，失败，那才是人生。&lt;br/&gt;小伙计，你已经上了黑车，车门焊死了。&lt;/p&gt;

&lt;p&gt;Electron的浏览器内核叫 CCM（Chromium Content Modult），是不是有CEF小伙伴已经嗷嗷叫了？这个自带了mp4支持，不用再编译了，是不是更兴奋了，幸福来的太突然？&lt;br/&gt;先别忙，瞅一眼Electron API，你品，你细品。&lt;br/&gt;是不是没有CEF常见的各种扩展Handler？没错，CEF重度产品，至少在默认的Electron框架上，是很多做不了的，比如截取浏览器区域的webgl renderer/render的产品，比如各种音乐播放器，基于音频的Handler二次混合叠加的产品，在默认实现上，做不了。&lt;/p&gt;
&lt;h2 id=&quot;对于前端框架的改动&quot;&gt;对于前端框架的改动&lt;/h2&gt;
&lt;p&gt;常见的一些前端小组件被移除，常见的比如localstroge、sessionstroge不可用，需要搜索一些三方的组件替代性使用，比如electron-localstroge。&lt;br/&gt;常见的Window.Open被修改，实现指向了Electron.BrowserWindow。&lt;/p&gt;
&lt;h2 id=&quot;发布&quot;&gt;发布&lt;/h2&gt;
&lt;p&gt;Electron本身的发布其实没有什么问题的，一旦引入了原生扩展，发布的时候，就需要小心的重新编译Electron再发布，不然会出现某知名在线教育机构的Electron桌面应用，发布到客户电脑上，报错。&lt;br/&gt;咳咳咳，具体是哪家，就不提了，咱也不知道，咱也不敢说。&lt;/p&gt;

&lt;p&gt;写到这里，只是想给对Electron感兴趣的小伙伴，一个冷静的分析，自己所在的团队，是否能撑得起这套框架的成本，看得见的便利性是存在的，看不见的隐藏成本，是否可以为此买单。&lt;br/&gt;肯定会有很多微软狂热粉 VS Code也用的Electron啊！&lt;br/&gt;实际上对于那种技术研发的大型公司，用什么技术，已经不再是难题了，选择了Electron，也只是为了拥抱社区做的妥协，并不代表这个技术的选型是最佳方案。&lt;br/&gt;技术的选择依旧是 自己的团队是否可以承担简单功能外的Node原生的编写和实现。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 15:47:00 +0000</pubDate>
<dc:creator>沉迷代码的萌新</dc:creator>
<og:description>最近几年最火的桌面化技术，无疑是Qt+和Electron。 两者都有跨平台桌面化技术，并不局限于Windows系统。前者因嵌入式而诞生，在演变过程中，逐步完善了生态以及工具链。后者则是依托于Node.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NCoreCoder/p/13971956.html</dc:identifier>
</item>
<item>
<title> 一直不受领导的重视？程序员怎样管理自己的人设 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/13971926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/13971926.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a1dfc1234d607a8bbab8ef962e2a6028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;成长&amp;amp;认知&lt;/strong&gt; 丨 作者 / 袁吴范&lt;br/&gt;这是&lt;strong&gt;pointers公众号&lt;/strong&gt;分享的第&lt;strong&gt;19&lt;/strong&gt;篇原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2008年北京奥运会，110米跨栏比赛，万众瞩目的刘翔在赛场上，整个体育场人山人海，之后发生的事情，大家都知道了，刘翔退赛了。&lt;/p&gt;
&lt;p&gt;之后的2014年比赛，他再次退赛，和全场运动员给与鼓励相反，国内舆论对他是一篇口诛笔伐。&lt;/p&gt;
&lt;p&gt;运动员由于伤病退赛的例子数不胜数，非常的正常。可为什么大家对他的退赛有这么多的不满？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实这里就存在的“人设”的隐形力量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为他不仅仅是一位运动员，他更是我们国人的骄傲，承载着国人的自尊和荣耀。所有的人都寄希望于他，希望能够再次为国争光。他就是国人心中的“number one”，这就是他的人设。&lt;/p&gt;
&lt;p&gt;一旦偏离了这个人设，就会受到抵触，甚至恶语相向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实我们每个人在别人眼中的成像不是人，而是你的人设。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们工作中，总是会这样称呼别人，例如：“大牛“，”话痨“，”八卦精“等等。&lt;/p&gt;
&lt;p&gt;这是我们大脑给其他人自动打上了标签，这个标签的集合就是人设。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而这个标签，往往产生就来自于第一印象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么面试这么重要。因为这可能是你和主管第一次见面，对你的标签建立非常重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么第一印象非常重要呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;心理学上有一个概念叫做&lt;strong&gt;沉锚效应&lt;/strong&gt;，是指人们在对未知的人和事物做出判断时，极易受第一印象或第一信息支配，它们就像沉入海底的锚一样把人们的思想固定在某处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以第一印象很重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦你被人贴上了某种标签，这个标签在别人心中就扎根了，很难被修改。而且标签的对人的判断产生的影响力比你想象的更大、更深远。&lt;/p&gt;
&lt;p&gt;在工作中，非常常见。&lt;/p&gt;
&lt;p&gt;例如你是业务骨干，领导交给你一个艰巨的任务，你最后搞砸了。大家可能会觉得你是因为最近家里有事情耽搁了，或者是身体不舒服导致的。&lt;/p&gt;
&lt;p&gt;而你的同事，能力不强，做事拖拖拉拉，这个艰巨的任务最终他完美的完成了。大家会怎么看？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;肯定认为他是哪里抄袭的，或者是谁的鼎力支持才搞定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家有没有发现？&lt;/p&gt;
&lt;p&gt;如果你有一个正向的标签对你的发展有多重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有好的标签，“职场发展”对你来说就是在仰攻，反之你会觉得像是在俯冲。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我前面讲了这么多人设的重要性，那么&lt;strong&gt;如何利用人设给自己加分呢？&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;因为人设的存在，在别人的眼中，没有人可以真正的做自己。总是通过你的学历、外表、职业情况给你打上标签，而这个标签的集合就是人设。&lt;/p&gt;
&lt;p&gt;你的影响力越是大，越是无法逃脱人设的掌控，总是需要尽力维护你的人设。这样好像成为了“做自己”的障碍，但是如果合理利用，就能为你自己加分。&lt;/p&gt;
&lt;p&gt;那下面怎样管理人设呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步就是要争取正面标签。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举一个我自己的例子。&lt;/p&gt;
&lt;p&gt;2015年的时候，我离开老东家，来到海康。&lt;/p&gt;
&lt;p&gt;刚来第一个月里，一般情况下就是熟悉团队氛围和公司制度、文化的阶段，而我发现代码中的兼容性、扩展性都比较差，而且耦合特别大。就强制要求自己每天早上非常早的就来公司，晚上几乎11、12点下班，在一个月时间内就输出了一份软件架构方案，递到了领导的手上。&lt;/p&gt;
&lt;p&gt;最后虽然方案还是有漏洞，但是大的问题没有，在第二年就慢慢切换使用我设计的架构。&lt;/p&gt;
&lt;p&gt;通过这件事情，我获得了什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“能力强”，“有拼劲”，“执行力强”的标签，就一直伴随着我。直到今年3月份，成功晋升为技术总监。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以一句话：&lt;strong&gt;争取好标签要趁早！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那如何为自己争取好的印象呢？请看下面的公式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好印象=好的第一印象＋持续增加曝光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是以我的为例，当时作为新员工进来，一直非常的拼，在别人的印象中就是有拼劲，同时能力非常强，而且这种状态一直保持了5年，这就是持续地曝光。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凡是都是有因果的，没有无缘无故的成功，只是很多的“因”由于自身的认知局限而被忽视了。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;勇争第一，你想过为什么吗？这个答案先搁着，往下看会有答案。&lt;/p&gt;
&lt;p&gt;如果我问你，你们同事当中谁的技术能力最强，你可能一下子就会得出答案。然后我再问你，第二个能力强的是谁？你这个时候可能就会忧郁了，答案可能就不止一个，你得好好权衡一番了。&lt;/p&gt;
&lt;p&gt;你的领导现在有一个重大的技术方案要落地，这个时候作为领导会将这个任务交给谁？&lt;/p&gt;
&lt;p&gt;答案想而易见，这个任务肯定落在了那个总是帮助别人解决疑难问题，大家公认的大牛身上了。因为第二个人选需要领导去选择了，领导讨厌这种选择，他需要最信任的人去完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种被称之为&lt;/strong&gt;&lt;strong&gt;头部标签&lt;/strong&gt;，一般来说在某一个特定的认知群体之内确认之后，它便具有明显的排他性。&lt;/p&gt;
&lt;p&gt;标签在人们的认知中长期占有举足轻重的地位，不但难以被擦除，也难以被替代。&lt;/p&gt;
&lt;p&gt;所以，一个好的“标签”最大的价值就是可以帮你稳定地争取到部门内相应的机会，并最大限度保证大家对你工作成果的认可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就回答了前面的问题了，你知道为啥要勇争第一了吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们想要让大家记住并认可我们的“人设”，刻意营销自己身上的亮点将是我们的不二选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为它是我们最拿得出手的“头部”技能，是最能让我们鹤立鸡群、取得第一的竞争优势。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;如果你的技术能力很强，那你就需要继续深入技术、广泛获取知识，积极帮助同事解决问题，为自己打造技术能力强的标签。&lt;/p&gt;
&lt;p&gt;如果你的沟通能力强，那你就需要深挖自己的沟通方法，积极组织解决问题，协调资源，推动项目落地，为自己打造“协调能力，组织能力强”的标签。&lt;/p&gt;
&lt;p&gt;所以，寻&lt;strong&gt;找自己的亮点，打出自己最大的牌，甚至做出一个典型案例，这才能获得你领导、同事的认可&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;程序员的人设管理，争取正面标签，打出自己最大的牌，最后打造出符合自己的人设。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如****果我们真的是金子，就应该主动抓住一切机会为自己赢得大家的认可，自己发光发热，而不是一边大喊“怀才不遇”，一边只是坐等机会自己来敲门。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谨此献上，共勉！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;em&gt;&lt;strong&gt;程序员成为高级管理者的三次跃升&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484039&amp;amp;idx=1&amp;amp;sn=64ff331bd87889216754aa60311a493e&amp;amp;chksm=cf209795f8571e83b586a3211a4bea0343b053ba347ccb5c6b89b4c410a396ce90ee23049de5&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;em&gt;&lt;strong&gt;面试过200人的经验，都在这里了&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483962&amp;amp;idx=1&amp;amp;sn=cc73b3d2124fc23d89ccc4c5c612d18c&amp;amp;chksm=cf209728f8571e3e4345d4737029960d1e5c3f7b005fd4c8545a1ac283c086a73e4ca914ede0&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;em&gt;&lt;strong&gt;程序员如何打造个人品牌？&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=7629654c4acf6bd1c5f53639707a9c61&amp;amp;chksm=cf209738f8571e2e66764576dfa494bec92059058c9f2609391ede8c40bc010c167b2d535820&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;em&gt;&lt;strong&gt;聊一聊 软件系统中的“热力学第二定律”&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=a170a555f571d4cbd2c4136b8ed57eff&amp;amp;chksm=cf209711f8571e07d674b4582488fe61e4e64d7179be7cb5ca5574edeee36f207d0cf7b0ea52&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;em&gt;&lt;strong&gt;谈一谈程序员的职业发展路线&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员进阶技术专家必备能力——深度思考&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我是袁吴范，专注&lt;/strong&gt;&lt;strong&gt;技术人的认知提升和职业成长&lt;/strong&gt;，分享个人多年经验和心得。&lt;br/&gt;希望你有所收获！私人微信号：&lt;strong&gt;&lt;strong&gt;pointersss&lt;/strong&gt;&lt;/strong&gt;，有任何问题都可以找我交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你有技术成长的瓶颈、对未来迷茫、关注我，帮你答疑解惑！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/425da483c978ace9c0672045e177b1d1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 15:34:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>成长&amp;amp;amp;认知 丨 作者 / 袁吴范 这是pointers公众号分享的第19篇原创文章 2008年北京奥运会，110米跨栏比赛，万众瞩目的刘翔在赛场上，整个体育场人山人海，之后发生的事情，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/13971926.html</dc:identifier>
</item>
<item>
<title>面向对象的基本理论1：类和对象 - 寻找猫的薛定谔</title>
<link>http://www.cnblogs.com/hanyu-2020/p/13971842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanyu-2020/p/13971842.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们先介绍基本的面向对象概念，具体的使用语法也就是定义的关键字后面会介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们简单介绍了面向对象和面向过程的思维方式不同，简单理解就是面向过程方式主要关心的是流程化，而面向对象方式主要是找参与者，也就是找类，类是面向对象中最基本的概念，是面向对象分析OOA和面向对象设计OOD的基石，另一个基石是对象。&lt;/p&gt;
&lt;p&gt;类和对象其实分不开的关系，就像鸡和蛋的关系，无法具体知道哪个先产生。只是我们设计类的时候先定义类，所以我们先介绍类的概念。&lt;/p&gt;
&lt;h3 id=&quot;一、类&quot;&gt;一、类&lt;/h3&gt;
&lt;p&gt;类是对象的模板，但是什么对象呢？这个我们留个花絮，在介绍对象之前我们先给类一个通俗的定义吧！&lt;/p&gt;
&lt;p&gt;那就是多个相似事物的通称，是不是还有点难理解，那我就一个词一个词的解释一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hanyu-2020/p/13971842.html&quot;&gt;多个&lt;/a&gt;这个词容易理解，就是有很多事物；单个事物不能形成类；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hanyu-2020/p/13971842.html&quot;&gt;相似&lt;/a&gt;代表有相同的特征，但是也有不同的地方，比如： 张继科和林丹，他俩必定有相同的特征，都有鼻子眼睛嘴等等。但是也有不同的地方，比如他俩的身高体重等不一定完全相同， 他俩还有各自的功能，张继科打乒乓球的，林丹打羽毛球的。&lt;/p&gt;
&lt;p&gt;这就是我们说相似而不是相同；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hanyu-2020/p/13971842.html&quot;&gt;通称&lt;/a&gt;也比较好理解，还拿张继科和林丹举例子，他俩都可以统称为人类，但是不能说统称为张继科，张继科那就是具体的人了。按照上面的理解知道什么是类了吧。奥迪和宝马是不是一类呢，他俩都属于车，所以就是一个车类。&lt;/p&gt;
&lt;p&gt;再比如波音和空机都统称为飞机，所以就是一个飞机类。我们再想一个问题，飞机和车是不是一个类呢，它俩都有发动机，可以统称为交通工具。说到这就有答案了，飞机和车是一个交通工具类。&lt;/p&gt;
&lt;p&gt;说到这你可能就想到了所有的事物最终都可以有大的统称。那为啥还分那么多类呢，就设计一个大类呗。这就失去了面向对象思想的一个好处，可扩展性，举一个例子，如果只设计一个交通工具类，原先的需求就有飞机和汽车。&lt;/p&gt;
&lt;p&gt;某天需要添加个轮船类呢，就要修改类的结构。反之只需要添加轮船类就好。通过上面的介绍，都知道类到底是个啥，设计类的时候按照具体的需求就好，需求和观察角度不同，设计出来的类可能都不同。&lt;/p&gt;
&lt;p&gt;比如：设计一个交通工具类和设计一个汽车类都不一样。&lt;/p&gt;
&lt;p&gt;我们上面是拿文字大概介绍的，拿张继科和林丹举例子他俩都有静态特性，是一个名词，比如年龄、性别等等。也还有动态的功能，是一个动词，比如都能打球、训练等等。&lt;/p&gt;
&lt;p&gt;张继科和林丹不是类，是具体的个体，所以就需要抽取共同的部分抽取成人类。&lt;/p&gt;
&lt;p&gt;可是对应到面向对象中咋设计一个类呢，分别用&lt;strong&gt;属性和方法&lt;/strong&gt;表示，&lt;a href=&quot;https://www.cnblogs.com/hanyu-2020/p/13971842.html&quot;&gt;属性&lt;/a&gt;就是指静态特性，&lt;a href=&quot;https://www.cnblogs.com/hanyu-2020/p/13971842.html&quot;&gt;方法&lt;/a&gt;就是指动态的功能；简单判断标准就是&lt;em&gt;名词是属性&lt;/em&gt;，&lt;em&gt;动词是方法&lt;/em&gt;。我们用一个程序看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 人类
 */
public class Person {
    //属性，人具有的特征
    String name;    //名字
    int age;        //年龄
    float height;   //身高
    float weight;   //体重
    String gender;  //性别

    //方法，人具有的功能
    //方法可以访问属性
    public String getName() {
        return name;
    }
    
    public void playBall(){
        System.out.println(&quot;打球！&quot;);
    }

    public void train(){
        System.out.println(&quot;训练！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;   上面的代码写出来我们并不能运行，一个类不能做事情，就比如一个人类能打球吗，显然不能，都是某个人能打球，所以我们需要一个类的实体来做事情。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二、对象&quot;&gt;二、对象&lt;/h3&gt;
&lt;p&gt;接下来我们该介绍什么是对象了，上面我们说过类是对象的模板，类都知道是什么了。对应的模板都知道是什么吧，一个使物体成固定型状的模具；&lt;/p&gt;
&lt;p&gt;比如做蛋糕，你可以拿一个模具，然后把做好的面糊倒在里面放入入微波炉制作，制作完成之后模具中就有了一个具体的蛋糕。这个蛋糕和模具的形状基本就是相同的。&lt;/p&gt;
&lt;p&gt;对应到面向对象思想中，这个做出来的每个蛋糕就是一个个对象，这每个蛋糕放在一起就是一个统称蛋糕，这其实就是一个蛋糕类。&lt;/p&gt;
&lt;p&gt;蛋糕类是抽象的，也就是没有具体的实体，只是通过这个蛋糕模板可以知道大概的形状而已，通过微波炉制作的过程对应程序中就是实例化。&lt;/p&gt;
&lt;p&gt;另外对象和类其实是相对的概念，上面谈过观察角度不同，类的设计不同，这样的话对应的对象也不同。比如以车作为参照标准来说，车是一个类，具体的奥迪就是一个车的对象，它是一个车的具体品牌。&lt;/p&gt;
&lt;p&gt;ok说到这我们要说一下类和对象的联系：现实对象(归纳概括)---&amp;gt;现实类(抽象模拟)---&amp;gt;软件类(实例化)---&amp;gt;软件对象---&amp;gt;程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1913298/202011/1913298-20201113225810223-2073690871.png&quot; alt=&quot;类和对象的联系&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现实类和对象就是我们现实世界能看到的东西吗，软件类和软件对象就是软件设计和运行中产生的&lt;/p&gt;
&lt;p&gt;我们对上面的类进行一下实例化，创建具体的对象，先用图展示一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1913298/202011/1913298-20201113224609620-1538262933.png&quot; alt=&quot;类和对象&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 创建一个张继科的对象
 */
public class TestPerson {
    public static void main(String[] args) {
        //先创建一个具体的空人，也就是空对象
        Person person=new Person();
        person.name=&quot;张继科&quot;;  //设置名字为张继科
        person.play();//调用人类的方法，这个名字为张继科在打球
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的介绍也就可以理解说：类是对象的抽象，对象是类的实例化了。那抽象是什么呢？抽象其实就是把像的部分抽取出来 ，而抽象的作用就是：隔离关注点，降低复杂度。就比如设计交通工具类，不划分类别的话，都集中在一起的话，那么我们的程序得多复杂凌乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1913298/202011/1913298-20201113230446684-810020899.png&quot; alt=&quot;抽象&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 15:12:00 +0000</pubDate>
<dc:creator>寻找猫的薛定谔</dc:creator>
<og:description>我们先介绍基本的面向对象概念，具体的使用语法也就是定义的关键字后面会介绍 前面我们简单介绍了面向对象和面向过程的思维方式不同，简单理解就是面向过程方式主要关心的是流程化，而面向对象方式主要是找参与者，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanyu-2020/p/13971842.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：超级下载算法(RT-UFL)开发笔记（2） - 识别当前i.MXRT型号 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13971756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13971756.html</guid>
<description>&lt;p&gt;本篇是开发笔记第二篇，咱们就重点聊聊如何让超级下载算法知道当前跑在哪个i.MXRT型号下。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;138.32679738562&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;超级下载算法开发笔记(2)之识别当前i.MXRT型号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　文接上篇 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13966562.html&quot;&gt;《超级下载算法(RT-UFL)开发笔记（1） - 执行在不同CM内核下》&lt;/a&gt;，我们已经解决了超级下载算法能够在i.MXRT全系列下执行的问题，现在我们往前继续推进项目。因为这个超级下载算法将来要跑在很多个芯片型号上，有时候因为型号间差异，我们不得不针对性地弄出不同代码处理分支，而这一切的前提是我们能动态地获取当前芯片型号。&lt;/p&gt;
&lt;p&gt;　　本篇是开发笔记第二篇，咱们就重点聊聊如何让超级下载算法知道当前跑在哪个i.MXRT型号下。&lt;/p&gt;
&lt;h3 id=&quot;一、寻找imxrt家族的id信息&quot;&gt;一、寻找i.MXRT家族的ID信息&lt;/h3&gt;
&lt;p&gt;　　恩智浦当前MCU产品线众多，i.MXRT是2018年才开始推出的新系列，在这之前恩智浦主推的MCU是经典的Kinetis和LPC系列，痞子衡对这两个系列产品也非常熟，型号信息在Kinetis和LPC上都有展现。&lt;/p&gt;
&lt;h4 id=&quot;11-回顾kinetis和lpc&quot;&gt;1.1 回顾Kinetis和LPC&lt;/h4&gt;
&lt;p&gt;　　Kinetis系列有一个专门存放型号信息的寄存器即SIM-&amp;gt;SDID，这个寄存器设计得非常经典，其FAMILYID + SUBFAMID + SERIESID区域组合将Kinetis系列的家族分类特性展示得淋漓尽致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote2_Kinetis-id.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LPC系列存放型号信息的寄存器是SYSCON-&amp;gt;DEVICE_ID0，这个寄存器是另外一种设计风格，低20bit直接就是LPC系列号的值，比如LPC54114xxx型号其SYSCON-&amp;gt;DEVICE_ID0[19:0] = 0x54114，是不是简单粗暴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote2_LPC-id.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;12-查找imxrt的id寄存器&quot;&gt;1.2 查找i.MXRT的ID寄存器&lt;/h4&gt;
&lt;p&gt;　　我们知道i.MXRT从架构上分为四位数和三位数两大阵营，四位数源自i.MX应用处理器，三位数源自LPC系列，我们分别来看。&lt;/p&gt;
&lt;p&gt;　　翻看i.MXRT四位数典型型号i.MXRT1060的参考手册，并没有找到任何有关型号信息的寄存器，仅有UID寄存器，但UID跟芯片型号无关。四位数上找不到型号信息寄存器，也跟其源于i.MX有关，毕竟MPU不像MCU那样会细分特别多的型号。&lt;/p&gt;
&lt;p&gt;　　再看i.MXRT三位数典型型号i.MXRT600的参考手册，我们找到了型号信息，在SYSCTL0-&amp;gt;PRODUCT_ID寄存器中，细看其寄存器设计，还是能看出LPC的影子的，SYSCTL0-&amp;gt;PRODUCT_ID[15:4]直接就是系列号的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote2_RT600-id.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、确认imxrt型号的替代方法&quot;&gt;二、确认i.MXRT型号的替代方法&lt;/h3&gt;
&lt;p&gt;　　根据上一节的分析，我们几乎不能用传统Kinetis或LPC上型号信息寄存器那一套方式来统一获取i.MXRT型号，那有没有替代方法呢？答案当然是有。灵感来自于痞子衡之前研究i.MXRT的ROM API时写过的一篇文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13449256.html&quot;&gt;《了解i.MXRTxxx系列ROM API及其与i.MXRT1xxx系列的差异》&lt;/a&gt;，i.MXRT系列全部都有BootROM，每个型号的ROM区域内容并不尽然相同，我们可以通过读几个ROM区域不同位置的值来定位型号。&lt;/p&gt;
&lt;h4 id=&quot;21-读scb-cpuid得到内核版本&quot;&gt;2.1 读SCB-&amp;gt;CPUID得到内核版本&lt;/h4&gt;
&lt;p&gt;　　i.MXRT四位数（都是CM7内核）的ROM基址是0x200000，而i.MXRT三位数（都是CM33内核）的ROM基址是0x3000000，基址是有差异的，所以我们首先需要先找出一种方法来区分基址，这里可以借助ARM Cortex-M内核模块SCB里的CPUID寄存器。&lt;/p&gt;
&lt;p&gt;　　翻看ARM Cortex-M内核的Generic User Guide，可以找到如下CPUID寄存器的定义，其中CPUID[PartNo]中记录了内核版本，CM7的值是0xC27，CM33的值是0xD21。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote2_SCB-CPUID.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以很容易写出如下ufl_get_core_type()函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;/* See Part number of core in Cortex-Mx Generic UG */
#define CORE_ID_CM33 (0xD21)
#define CORE_ID_CM7  (0xC27)

typedef enum _core_type
{
    kCoreType_Invalid = 0U,
    kCoreType_CM33    = 1U,
    kCoreType_CM7     = 2U,
} core_type_t;

static core_type_t ufl_get_core_type(void)
{
    core_type_t coreType = kCoreType_Invalid;
    uint32_t coreid = (SCB-&amp;gt;CPUID &amp;amp; SCB_CPUID_PARTNO_Msk) &amp;gt;&amp;gt; SCB_CPUID_PARTNO_Pos;

    switch (coreid)
    {
        case CORE_ID_CM33:
            coreType = kCoreType_CM33;
            break;

        case CORE_ID_CM7:
            coreType = kCoreType_CM7;
            break;

        default:
            break;
    }

    return coreType;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;22-通过rom内容定位imxrt型号&quot;&gt;2.2 通过ROM内容定位i.MXRT型号&lt;/h4&gt;
&lt;p&gt;　　有了ufl_get_core_type()函数，我们便可以进一步写出如下ufl_get_imxrt_chip_id()函数，s_romFingerprint[]结构体数组预先存放全部i.MXRT型号的ROM定位信息（此处仅示例了RT600和RT1060），我们选了ROM偏移0x8000、0xa000、0xc000处的四字节数据来定位，如后期随着型号的增多，出现定位位置处数据全部雷同的巧合的话，可以更改定位位置保证定位数据一定不相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;typedef enum _rt_chip_id
{
    kChipId_Invalid = 0xFFU,
    kChipId_RT6xx   = 1U,
    kChipId_RT106x  = 2U,
} rt_chip_id_t;

#define RT_ROM_BASE_CM33 (0x03000000u)
#define RT_ROM_BASE_CM7  (0x00200000u)

#define ROM_FP_OFFSET1 (0x8000)
#define ROM_FP_OFFSET2 (0xa000)
#define ROM_FP_OFFSET3 (0xc000)

typedef struct _rom_fingerprint
{
    uint32_t chipId;
    uint32_t content[3];
} rom_fingerprint_t;

static const rom_fingerprint_t s_romFingerprint[] = {
    {kChipId_RT6xx,  {0xb108f82a, 0x0200f2c5, 0x0070f104} },        // From ROM 2.0rc5.1
    {kChipId_RT106x, {0xb0893000, 0x80dbf000, 0xf2c44100} },        // From ROM 1.0rc3
};

rt_chip_id_t ufl_get_imxrt_chip_id(void)
{
    rt_chip_id_t chipId = kChipId_Invalid;
    core_type_t coreType;
    uint32_t rtRomBase = 0;

    coreType = ufl_get_core_type();
    if (kCoreType_CM33 == coreType)
    {
        rtRomBase = RT_ROM_BASE_CM33;
    }
    else if (kCoreType_CM7 == coreType)
    {
        rtRomBase = RT_ROM_BASE_CM7;
    }
    else
    {}

    do
    {
        uint32_t content[3];
        content[0] = *(uint32_t *)(rtRomBase + ROM_FP_OFFSET1);
        content[1] = *(uint32_t *)(rtRomBase + ROM_FP_OFFSET2);
        content[2] = *(uint32_t *)(rtRomBase + ROM_FP_OFFSET3);

        uint32_t idx = sizeof(s_romFingerprint) / sizeof(rom_fingerprint_t);
        while (idx--)
        {
            if (!memcmp(s_romFingerprint[idx].content, content, sizeof(content)))
            {
                chipId = (rt_chip_id_t)s_romFingerprint[idx].chipId;
                break;
            }
        }
    } while (0);

    return chipId;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　至此，超级下载算法开发笔记(2)之识别当前i.MXRT型号痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 13 Nov 2020 14:48:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>本篇是开发笔记第二篇，咱们就重点聊聊如何让超级下载算法知道当前跑在哪个i.MXRT型号下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13971756.html</dc:identifier>
</item>
<item>
<title>spark内存管理这一篇就够了 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/13971576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/13971576.html</guid>
<description>&lt;h2 id=&quot;11堆内和堆外内存规划outline&quot;&gt;1. 堆内和堆外内存规划&lt;/h2&gt;
&lt;h3 id=&quot;1111堆内内存outline&quot;&gt;1.1 堆内内存&lt;/h3&gt;
&lt;p&gt;堆内内存的大小，由 Spark 应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为&lt;span&gt;存储（Storage）内存&lt;/span&gt;，而这些任务在执行 Shuffle 时占用的内存被规划为&lt;span&gt;执行（Execution）内存&lt;/span&gt;，剩余的部分不做特殊规划，那些 Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。不同的管理模式下，这三部分占用的空间大小各不相同。&lt;/p&gt;
&lt;h3 id=&quot;1212堆外内存outline&quot;&gt;1.2 堆外内存&lt;/h3&gt;
&lt;p&gt;在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。&lt;/p&gt;
&lt;h2 id=&quot;22内存空间分配outline&quot;&gt;2 . 内存空间分配&lt;/h2&gt;
&lt;h3 id=&quot;2222统一内存管理outline&quot;&gt;2.1 统一内存管理&lt;/h3&gt;
&lt;p&gt;Spark 1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，如图 4 和图 5 所示&lt;/p&gt;
&lt;p&gt;图 4 . 统一内存管理图示——堆内&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-apache-spark-memory-management/image004.png&quot; alt=&quot;&quot; width=&quot;791&quot; height=&quot;443&quot; class=&quot;has&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spark.memory.fraction       堆内的存储内存和执行内存总共所占的比例，默认0.6&lt;/p&gt;
&lt;p&gt;spark.storage.storageFraction     用于缓存数据的内存比例，默认0.5&lt;/p&gt;
&lt;p&gt;图 5 . 统一内存管理图示——堆外&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-apache-spark-memory-management/image005.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;366&quot; class=&quot;has&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spark.memory.storageFraction         Storage内存所占堆外内存的比例，默认为0.5&lt;/p&gt;
&lt;p&gt;其中最重要的优化在于动态占用机制，其规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设定基本的存储内存和执行内存区域（spark.storage.storageFraction 参数），该设定确定了双方各自拥有的空间的范围&lt;/li&gt;
&lt;li&gt;双方的空间都不足时，则存储到硬盘；若己方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的 Block）&lt;/li&gt;
&lt;li&gt;执行内存的空间被对方占用后，可让对方将占用的部分转存到硬盘，然后&quot;归还&quot;借用的空间(执行内存的强势)&lt;/li&gt;
&lt;li&gt;存储内存的空间被对方占用后，无法让对方&quot;归还&quot;，因为需要考虑 Shuffle 过程中的很多因素，实现起来较为复杂&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 6 . 动态占用机制图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-apache-spark-memory-management/image006.png&quot; alt=&quot;&quot; width=&quot;793&quot; height=&quot;323&quot; class=&quot;has&quot;/&gt;&lt;/p&gt;
&lt;p&gt;凭借统一内存管理机制，Spark 在一定程度上提高了堆内和堆外内存资源的利用率，降低了开发者维护 Spark 内存的难度，但并不意味着开发者可以高枕无忧。譬如，所以如果存储内存的空间太大或者说缓存的数据过多，反而会导致频繁的全量垃圾回收，降低任务执行时的性能，因为缓存的 RDD 数据通常都是长期驻留内存的 。所以要想充分发挥 Spark 的性能，需要开发者进一步了解存储内存和执行内存各自的管理方式和实现原理。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 14:04:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>1. 堆内和堆外内存规划 1.1 堆内内存 堆内内存的大小，由 Spark 应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/skaarl/p/13971576.html</dc:identifier>
</item>
</channel>
</rss>