<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>将Swagger2文档导出为HTML或markdown等格式离线阅读 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11933051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11933051.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075741269-61932376.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上有很多《使用swagger2构建API文档》的文章，该文档是一个在线文档，需要使用HTTP访问。但是在我们日常使用swagger接口文档的时候，有的时候需要接口文档离线访问，如将文档导出为html、markdown格式。又或者我们不希望应用系统与swagger接口文档使用同一个服务，而是导出HTML之后单独部署，这样做保证了对接口文档的访问不影响业务系统，也一定程度提高了接口文档的安全性。核心的实现过程就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在swagger2接口文档所在的应用内，利用swagger2markup将接口文档导出为adoc文件，也可以导出markdown文件。&lt;/li&gt;
&lt;li&gt;然后将adoc文件转换为静态的html格式，可以将html发布到nginx或者其他的web应用容器，提供访问（本文不会讲html静态部署，只讲HTML导出)。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：adoc是一种文件格式，不是我的笔误。不是doc文件也不是docx文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一maven依赖类库&quot;&gt;一、maven依赖类库&lt;/h2&gt;
&lt;p&gt;在已经集成了swagger2的应用内，通过maven坐标引入相关依赖类库,pom.xml代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.github.swagger2markup&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;swagger2markup&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.swagger&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;swagger-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.16&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.swagger&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;swagger-models&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.16&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;swagger2markup用于将swagger2在线接口文档导出为html,markdown,adoc等格式文档，用于静态部署或离线阅读。其中第一个maven坐标是必须的。后两个maven坐标，当你在执行后面的代码过程中报下图中的ERROR，或者有的类无法import的时候使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075741575-1911298129.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;产生异常的原因已经有人在github的issues上给出解释了：当你使用swagger-core版本大于等于1.5.11,并且swagger-models版本小于1.5.11就会有异常发生。所以我们显式的引入这两个jar，替换掉swagger2默认引入的这两个jar。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075741796-664376473.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二生成adoc格式文件&quot;&gt;二、生成adoc格式文件&lt;/h2&gt;
&lt;p&gt;下面的代码是通过编码方式实现的生成adoc格式文件的方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
public class DemoApplicationTests {
    @Test
    public void generateAsciiDocs() throws Exception {
        //    输出Ascii格式
        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()
                .withMarkupLanguage(MarkupLanguage.ASCIIDOC) //设置生成格式
                .withOutputLanguage(Language.ZH)  //设置语言中文还是其他语言
                .withPathsGroupedBy(GroupBy.TAGS)
                .withGeneratedExamples()
                .withoutInlineSchema()
                .build();

        Swagger2MarkupConverter.from(new URL(&quot;http://localhost:8888/v2/api-docs&quot;))
                .withConfig(config)
                .build()
                .toFile(Paths.get(&quot;src/main/resources/docs/asciidoc&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用RunWith注解和SpringBootTest注解，启动应用服务容器。 SpringBootTest.WebEnvironment.DEFINED_PORT表示使用application.yml定义的端口，而不是随机使用一个端口进行测试，这很重要。&lt;/li&gt;
&lt;li&gt;Swagger2MarkupConfig 是输出文件的配置，如文件的格式和文件中的自然语言等&lt;/li&gt;
&lt;li&gt;Swagger2MarkupConverter的from表示哪一个HTTP服务作为资源导出的源头(JSON格式)，可以自己访问试一下这个链接。8888是我的服务端口，需要根据你自己的应用配置修改。&lt;/li&gt;
&lt;li&gt;toFile表示将导出文件存放的位置，不用加后缀名。也可以使用toFolder表示文件导出存放的路径。二者区别在于使用toFolder导出为文件目录下按标签TAGS分类的多个文件，使用toFile是导出一个文件（toFolder多个文件的合集）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void generateMarkdownDocsToFile() throws Exception {
    //    输出Markdown到单文件
    Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()
            .withMarkupLanguage(MarkupLanguage.MARKDOWN)
            .withOutputLanguage(Language.ZH)
            .withPathsGroupedBy(GroupBy.TAGS)
            .withGeneratedExamples()
            .withoutInlineSchema()
            .build();

    Swagger2MarkupConverter.from(new URL(&quot;http://localhost:8888/v2/api-docs&quot;))
            .withConfig(config)
            .build()
            .toFile(Paths.get(&quot;src/main/resources/docs/markdown&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的这一段代码是生成markdown格式接口文件的代码。执行上面的2段单元测试代码，就可以生产对应格式的接口文件。&lt;/p&gt;
&lt;p&gt;还有一种方式是通过maven插件的方式，生成adoc和markdown格式的接口文件。笔者不常使用这种方式，没有使用代码生成的方式配置灵活，很多配置都放到pom.xml感觉很臃肿。但还是介绍一下,首先配置maven插件swagger2markup-maven-plugin。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;io.github.swagger2markup&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;swagger2markup-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;swaggerInput&amp;gt;http://localhost:8888/v2/api-docs&amp;lt;/swaggerInput&amp;gt;&amp;lt;!---swagger-api-json路径--&amp;gt;
        &amp;lt;outputDir&amp;gt;src/main/resources/docs/asciidoc&amp;lt;/outputDir&amp;gt;&amp;lt;!---生成路径--&amp;gt;
        &amp;lt;config&amp;gt;
            &amp;lt;swagger2markup.markupLanguage&amp;gt;ASCIIDOC&amp;lt;/swagger2markup.markupLanguage&amp;gt;&amp;lt;!--生成格式--&amp;gt;
        &amp;lt;/config&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行插件就可以了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075742016-924141844.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三通过maven插件生成html文档&quot;&gt;三、通过maven插件生成HTML文档&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;asciidoctor-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.6&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
         &amp;lt;!--asciidoc文件目录--&amp;gt;
        &amp;lt;sourceDirectory&amp;gt;src/main/resources/docs&amp;lt;/sourceDirectory&amp;gt;
        &amp;lt;!---生成html的路径--&amp;gt;
        &amp;lt;outputDirectory&amp;gt;src/main/resources/html&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;backend&amp;gt;html&amp;lt;/backend&amp;gt;
        &amp;lt;sourceHighlighter&amp;gt;coderay&amp;lt;/sourceHighlighter&amp;gt;
        &amp;lt;attributes&amp;gt;
            &amp;lt;!--导航栏在左--&amp;gt;
            &amp;lt;toc&amp;gt;left&amp;lt;/toc&amp;gt;
            &amp;lt;!--显示层级数--&amp;gt;
            &amp;lt;!--&amp;lt;toclevels&amp;gt;3&amp;lt;/toclevels&amp;gt;--&amp;gt;
            &amp;lt;!--自动打数字序号--&amp;gt;
            &amp;lt;sectnums&amp;gt;true&amp;lt;/sectnums&amp;gt;
        &amp;lt;/attributes&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;adoc的sourceDirectory路径必须和第三小节中生成的adoc文件路径一致。然后按照下图方式运行插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075742243-1119979017.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTMl接口文档显示的效果如下，有了HTML接口文档你想转成其他各种格式的文档就太方便了，有很多工具可以使用。这里就不一一介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191126075742469-867736696.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Mon, 25 Nov 2019 23:58:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>网上有很多《使用swagger2构建API文档》的文章，该文档是一个在线文档，需要使用HTTP访问。但是在我们日常使用swagger接口文档的时候，有的时候需要接口文档离线访问，如将文档导出为html</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11933051.html</dc:identifier>
</item>
<item>
<title>Java描述设计模式(23)：访问者模式 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/11933050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/11933050.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/model-arithmetic-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/model-arithmetic-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;场景描述&quot;&gt;1、场景描述&lt;/h2&gt;
&lt;p&gt;电竞是游戏比赛达到“竞技”层面的体育项目。利用电子设备作为运动器械进行的、人与人之间的智力对抗运动。通过电竞，可以提高人的反应能力、协调能力、团队精神等。但是不同人群的对电竞的持有的观念不一样，有的人认为电竞就是沉迷网络，持反对态度，而有的人就比较赞同。下面基于访问者模式来描述该场景。&lt;/p&gt;
&lt;h2 id=&quot;场景图解&quot;&gt;2、场景图解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191126074952196-1977686468.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;3、代码实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C01_InScene {
    public static void main(String[] args) {
        DataSet dataSet = new DataSet() ;
        dataSet.addCrowd(new Youth());
        dataSet.addCrowd(new MiddleAge());
        CrowdView crowdView = new Against() ;
        dataSet.display(crowdView);
        crowdView = new Approve() ;
        dataSet.display(crowdView);
    }
}
/**
 * 双分派,不同人群管理
 */
abstract class Crowd {
    abstract void accept(CrowdView action);
}
class Youth extends Crowd {
    @Override
    public void accept(CrowdView view) {
        view.getYouthView(this);
    }
}
class MiddleAge extends Crowd {
    @Override
    public void accept(CrowdView view) {
        view.getMiddleAgeView (this);
    }
}
/**
 * 不同人群观念的管理
 */
abstract class CrowdView {
    // 青年人观念
    abstract void getYouthView (Youth youth);
    // 中年人观念
    abstract void getMiddleAgeView (MiddleAge middleAge);
}
class Approve extends CrowdView {
    @Override
    public void getYouthView(Youth youth) {
        System.out.println(&quot;青年人赞同电竞&quot;);
    }
    @Override
    public void getMiddleAgeView(MiddleAge middleAge) {
        System.out.println(&quot;中年人赞同电竞&quot;);
    }
}
class Against extends CrowdView {
    @Override
    public void getYouthView(Youth youth) {
        System.out.println(&quot;青年人反对电竞&quot;);
    }
    @Override
    public void getMiddleAgeView(MiddleAge middleAge) {
        System.out.println(&quot;中年人反对电竞&quot;);
    }
}
/**
 * 提供一个数据集合
 */
class DataSet {
    private List&amp;lt;Crowd&amp;gt; crowdList = new ArrayList&amp;lt;&amp;gt;();
    public void addCrowd (Crowd crowd) {
        crowdList.add(crowd);
    }
    public void display(CrowdView crowdView) {
        for(Crowd crowd : crowdList) {
            crowd.accept(crowdView);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;基础概念&quot;&gt;1、基础概念&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;访问者模式是对象的行为模式，把作用于数据结构的各元素的操作封装，操作之间没有关联。可以在不改变数据结构的前提下定义作用于这些元素的不同的操作。主要将数据结构与数据操作分离，解决数据结构和操作耦合问题核心原理：被访问的类里面加对外提供接待访问者的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模式图解&quot;&gt;2、模式图解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201911/1691717-20191126074936925-1695250050.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心角色&quot;&gt;3、核心角色&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;抽象访问者角色&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;声明多个方法操作，具体访问者角色需要实现的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;具体访问者角色&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现抽象访问者所声明的接口，就是各个访问操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;抽象节点角色&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;声明接受操作，接受访问者对象作为参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;具体节点角色&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现抽象节点所规定的具体操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;结构对象角色&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;能枚举结构中的所有元素，可以提供一个高层的接口，用来允许访问者对象访问每一个元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;源码实现&quot;&gt;4、源码实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C02_Visitor {
    public static void main(String[] args) {
        ObjectStructure obs = new ObjectStructure();
        obs.add(new NodeA());
        obs.add(new NodeB());
        Visitor visitor = new VisitorA();
        obs.doAccept(visitor);
    }
}
/**
 * 抽象访问者角色
 */
interface Visitor {
    /**
     * NodeA的访问操作
     */
    void visit(NodeA node);
    /**
     * NodeB的访问操作
     */
    void visit(NodeB node);
}
/**
 * 具体访问者角色
 */
class VisitorA implements Visitor {
    @Override
    public void visit(NodeA node) {
        node.operationA() ;
    }
    @Override
    public void visit(NodeB node) {
        node.operationB() ;
    }
}
class VisitorB implements Visitor {
    @Override
    public void visit(NodeA node) {
        node.operationA() ;
    }
    @Override
    public void visit(NodeB node) {
        node.operationB() ;
    }
}
/**
 * 抽象节点角色
 */
abstract class Node {
    /**
     * 接收访问者
     */
    abstract void accept(Visitor visitor);
}
/**
 * 具体节点角色
 */
class NodeA extends Node{
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    public void operationA(){
        System.out.println(&quot;NodeA.operationA&quot;);
    }
}
class NodeB extends Node{
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    public void operationB(){
        System.out.println(&quot;NodeB.operationB&quot;);
    }
}
/**
 * 结构对象角色类
 */
class ObjectStructure {
    private List&amp;lt;Node&amp;gt; nodes = new ArrayList&amp;lt;&amp;gt;();
    public void detach(Node node) {
        nodes.remove(node);
    }
    public void add(Node node){
        nodes.add(node);
    }
    public void doAccept(Visitor visitor){
        for(Node node : nodes) {
            node.accept(visitor);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;bean结构的访问&quot;&gt;1、Bean结构的访问&lt;/h2&gt;
&lt;p&gt;BeanDefinitionVisitor类，遍历bean的各个属性；接口 BeanDefinition，定义Bean的各样信息，比如属性值、构造方法、参数等等。这里封装操作bean结构的相关方法，但却没有改变bean的结构。&lt;/p&gt;
&lt;h2 id=&quot;核心代码块&quot;&gt;2、核心代码块&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BeanDefinitionVisitor {
    public void visitBeanDefinition(BeanDefinition beanDefinition) {
        this.visitParentName(beanDefinition);
        this.visitBeanClassName(beanDefinition);
        this.visitFactoryBeanName(beanDefinition);
        this.visitFactoryMethodName(beanDefinition);
        this.visitScope(beanDefinition);
        if (beanDefinition.hasPropertyValues()) {
            this.visitPropertyValues(beanDefinition.getPropertyValues());
        }
        if (beanDefinition.hasConstructorArgumentValues()) {
            ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues();
            this.visitIndexedArgumentValues(cas.getIndexedArgumentValues());
            this.visitGenericArgumentValues(cas.getGenericArgumentValues());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;1、优点描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(1) 访问者模式符合单一职责原则、使程序具有良好的扩展性、灵活性；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(2) 访问者模式适用与拦截器与过滤器等常见功能，数据结构相对稳定的场景；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、缺点描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(1) 访问者关注其他类的内部细节，依赖性强，违反迪米特法则,这样导致具体元素更新麻烦；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(2) 访问者依赖具体元素，不是抽象元素，面向细节编程，违背依赖倒转原则；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/model-arithmetic-parent
GitEE·地址
https://gitee.com/cicadasmile/model-arithmetic-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 23:51:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' 一、生活场景 1、场景描述 电竞是游戏比赛达到“竞技”层面的体育项目。利用电子设备作为运动器械进行的、人与人之间的智力对抗运动。通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/11933050.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（10）：感知机模型 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11933048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11933048.html</guid>
<description>&lt;p&gt;上一节中，我们介绍了感知机模型损失函数$L(w,b)$的由来，接下来就要说说怎么通过优化损失函数来获得最终的超平面。在感知机模型中，有两种优化方式：原始形式和对偶形式。&lt;/p&gt;
&lt;h2 id=&quot;3.1-原始形式&quot;&gt;3.1 原始形式&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/11933048.html#3.1-原始形式&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;原始形式采用的是梯度下降法进行求解，如果对梯度下降法不了解，可以参看前面写过的一篇&lt;a href=&quot;https://www.cnblogs.com/chenhuabin/p/11166726.html&quot;&gt;博客&lt;/a&gt;。这里需要注意的是，在上一小节中说过，感知机是基于误分类驱动的一种模型，所以不能使用整个数据集进行梯度下降优化，只能对误分类样本集合$M$采用随机梯度下降法或者小批量梯度下降法进行优化。 对损失函数$L(w,b)$求偏导： $$\frac{{\partial L(w,b)}}{{\partial w}} = - \sum\limits_{{x_i} \in M} {{y_i} \cdot {x_i}} $$ $$\frac{{\partial L(w,b)}}{{\partial b}} = - \sum\limits_{{x_i} \in M} {{y_i}} $$ 那么，$w$的梯度下降迭代公式为： $$w = w + \alpha \cdot \sum\limits_{{x_i} \in M} {{y_i} \cdot {x_i}} $$ 偏置$b$的梯度下降迭代公式为： $$b = b + \alpha \cdot \sum\limits_{{x_i} \in M} {{y_i}} $$ 式中，$\alpha $是学习率。 感知机模型中，一般采用随机梯度下降法进行优化，每次使用一个误分类样本点进行梯度更新。假设$(x_i,y_i)$是$M$中的一个误分类点，进行梯度更新： $$w = w + \alpha \cdot {y_i}{x_i} \tag{3}$$ $$b = b + \alpha \cdot {y_i} \tag{4}$$ 总结一下原始形式优化步骤。 输入：训练样本数据集$D = \{ ({x_i},{y_i})\} _{i = 1}^m$,${x_i} \in X \subseteq {R^n}$,${y_i} \in Y = \{ + 1, - 1\} $，学习率% $\alpha \in (0,1)$&lt;br/&gt;输出：$w$,$b$；感知机模型$f(x) = sign(w \cdot x + b) $&lt;br/&gt;（1）初始化$w_0$，$b_0$；&lt;br/&gt;（2）在$D$中选取任意点$(x_i,y_i)$；&lt;br/&gt;（3）通过${y_i} \cdot (w \cdot {x_i} + b)$的值判断是否是误分类点，如果是，使用式（3）、（4）更新参数；&lt;br/&gt;（4）回到步骤（2）直到准确率满足条件。&lt;/p&gt;
&lt;h2 id=&quot;3.2-对偶形式&quot;&gt;3.2 对偶形式&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/11933048.html#3.2-对偶形式&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对偶形式时原始形式在执行效率上的优化。通过3.1小节中，我们知道，每当一个样本点$x_i$被错误分类一次时，都会使用式（3）（4）更新一次参数，那么，如果样本点$x_i$在迭代过程中被错误分类多次（假设$n_i$次），那么就回有$n_i$次参与到参数更新中，我们假设参数$w$和$b$的初始值都为0向量，那么，最终获得的参数$w$和$b$为： $$w = \sum\limits_{i = 1}^N {{\beta _i} {y_i}{x_i}} \tag{5}$$ $$b = \sum\limits_{i = 1}^N {{\beta _i} {y_i}} \tag{6}$$ 这是在对偶形式中的参数更新方式，式中，${\beta _i} ={n_i}\alpha$。另外，在原始形式中，我们使用${y_i}(w \cdot {x_i} + b) \leqslant 0$来判断样本点$x_i$是否被错误分类，将式（5）（6）代入这一判别式中，得： $${y_i}(\sum\limits_{i = 1}^N {{\beta _i} {y_i}{x_i}} \cdot {x_j} + \sum\limits_{i = 1}^N {{\beta _i} {y_i}}) \leqslant 0 \tag{7}$$ 在对偶形式中，采用式（7）判断样本点是否正确分类，观察后可以发现，式（7）中有两个样本点$x_i$和$x_j$内积计算，这个内积计算的结果在下面的迭代过程中需要多次被重复使用，如果我们事先用矩阵运算计算出所有的样本之间的内积，那么在算法迭代过程中， 仅仅一次的矩阵内积运算比原始形式中每遍历一个样本点都要计算$w$与$x_i$的内积要省时得多，这也是对偶形式的感知机模型比原始形式优的原因。&lt;br/&gt;在感知机模型中，样本的内积矩阵称为Gram矩阵，它是一个对称矩阵，记为$G = {[{x_i},{x_j}]_{m \times m}}$。&lt;br/&gt;总结一下对偶形式的步骤。&lt;br/&gt;输入：训练样本数据集$D = \{ ({x_i},{y_i})\} _{i = 1}^m$,${x_i} \in X \subseteq {R^n}$,${y_i} \in Y = \{ + 1, - 1\} $，学习率% $\alpha \in (0,1)$&lt;br/&gt;输出：$w$,$b$；感知机模型$f(x) = sign(w \cdot x + b) $&lt;br/&gt;（1）初始化所有$n_i$值为0；&lt;br/&gt;（2）计算Gram矩阵；&lt;br/&gt;（3）在$D$中选取任意点$(x_i,y_i)$；&lt;br/&gt;（4）如果${y_i}(\sum\limits_{i = 1}^N {{\beta _i} {y_i}{x_i}} \cdot {x_j} + \sum\limits_{i = 1}^N {{\beta _i} {y_i}}) \leqslant 0 $，令${\beta _i} = {\beta _i} + \alpha $；&lt;br/&gt;（5）检查是否还有误分类样本点，如果有，回到步骤（2）；如果没有，（5）（6）计算$w$、$b$最终值。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 23:48:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>感知机是一种简单且易于实现的二分类判别模型，主要思想是通过误分类驱动的损失函数结合梯度下降发求解一个超平面将线性可分的数据集划分为两个不同的类别（+1类和-1类）。  在神经网络、支持向量机等算法盛</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11933048.html</dc:identifier>
</item>
<item>
<title>EF Core For MySql查询中使用DateTime.Now作为查询条件的一个小问题 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11933042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11933042.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201911/65831-20191126072536952-633719675.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近一直忙于手上澳洲线上项目的整体迁移和升级的准备工作，导致博客和公众号停更。本周终于艰难的完成了任务，借此机会，总结一下项目中遇到的一些问题。&lt;/p&gt;
&lt;p&gt;EF Core一直是我们团队中中小型项目常用的ORM框架，在使用SQL Server作为持久化仓储的场景一下，一直表现还中规中矩。但是在本次项目中，项目使用了MySql作为持久化仓储。为了与EF Core集成，团队使用了&lt;code&gt;Pomelo.EntityFrameworkCore.MySql&lt;/code&gt;作为EF Core For MySql的扩展。在开发过程中，团队遇到了各种各样在SQL Server场景下没有遇到过的问题，其中最奇怪的，也是隐藏最深的问题，就是将&lt;code&gt;DateTime.Now&lt;/code&gt;作为查询条件，产生了非预期的结果。&lt;/p&gt;

&lt;p&gt;本周在项目升级的过程中，客户反馈了一个问题。&lt;/p&gt;
&lt;p&gt;在当前系统的Dashboard页面，有一个消息提醒功能，客户可以自定义一些消息，并且指定提醒的日期。客户遇到的问题是通常添加的消息提醒，在指定日期的上午时间段是不会显示，只有在下午时间段才能看到，比如说客户指定2019年10月26号看到一个的消息提醒，但是在10月26日这天早上8:00-12:00这个时间段，系统总是看不到提醒，只有到了下午的时间段才能看到提醒。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;PS：这里客户表达的只是个笼统的问题，但问题确实是上午的大部分时间是看不到消息提醒的，但并不是精确到中午12：00点这个时间, 所以此处不必过于纠结于具体的时间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到这个问题的时候，我自己也很奇怪，难道代码或者数据库使用了时区，导致查询出现了偏差？&lt;/p&gt;
&lt;p&gt;于是我就Review了一下此处的查询， 代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var query = DbContext.CRM_Note_Reminders
    .Include(x =&amp;gt; x.CRM_Note)
    .Where(x =&amp;gt; !x.CRM_Note.Is_Deleted 
             &amp;amp;&amp;amp; !x.Is_Deleted
             &amp;amp;&amp;amp; x.Reminder_Date.Date &amp;lt;= DateTime.Now.Date)
     .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS: 这里可能有同学会有疑问，为啥不用&lt;code&gt;DbFunctions.DiffDays&lt;/code&gt;? 原因是&lt;code&gt;DbFunctions.DiffDays&lt;/code&gt;是 EF Core for SQLServer的扩展方法，针对MySql还没有官方的实现方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从这个查询中，我没有看出任何问题，于是我直接借助一些日志工具，将EF Core生成的查询语句的输出了出来。&lt;/p&gt;
&lt;p&gt;其中WHERE条件部分如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;WHERE (((`x.CRM_Note`.`Is_Deleted` = FALSE) 
AND (`x`.`Is_Deleted` = FALSE))
AND (CONVERT(`x`.`Reminder_Date`, date) 
  &amp;lt;= CONVERT(CURRENT_TIMESTAMP(), date)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;是MySql的内置函数，与SQLServer的内置函数&lt;code&gt;GETDATE()&lt;/code&gt;不同，&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;默认返回的是UTC时间。因此我们大概能知道，为什么澳洲客户会遇到上面的场景了。&lt;/p&gt;
&lt;p&gt;由于澳洲处于东10区，与UTC时间有+10个小时的时差，所以当澳洲上午的10点之前，UTC时间都是在当前澳洲日期的前一天，所以系统中出现了当天的消息提醒在上午时间段不能正常显示的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS： 由于澳洲是分冬令时和夏令时的，夏令时时间要加一个小时，所以实际上客户在每天的11点之前都无法看到正确的消息提醒。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你这可能会非常奇怪，为什么&lt;code&gt;DateTime.Now&lt;/code&gt;会被转化成内置函数&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;，而没有使用我们传入的值&lt;code&gt;DateTime.Now.Date&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;其实EF/EF Core在查询是时候是分2个阶段的，一个是组合查询表达式树的阶段，一个是真正的查询阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201911/65831-20191126072550105-1238181240.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在组合查询表达式树的阶段，EF/EF Core只会去组合表达式，而不会去尝试计算表达式的值，所以这个阶段&lt;code&gt;DateTime.Now.Date&lt;/code&gt;的值并没有被计算出来， 在进入正常查询阶段的时候， EF/EF Core会尝试将查询表达式树翻译成SQL脚本，这时候由于我们的&lt;code&gt;EF Provider&lt;/code&gt;是&lt;code&gt;MySql Provider&lt;/code&gt;， 恰巧&lt;code&gt;DateTime.Now&lt;/code&gt;可以翻译成Mysql的内置函数&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;， 所以这里EF/EF Core就跳过了表达式值的计算，直接将其翻译成了对应的内置函数，所以导致生成的SQL查询和我们的预期有偏差。&lt;/p&gt;
&lt;p&gt;那么我们该如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;经过了以上的思考，其实解决这个问题也就很简单了，我们可以将&lt;code&gt;DateTime.Now.Date&lt;/code&gt;先计算出来，保存在一个变量中，然后将这个变量传入查询中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var today = DateTime.Now.Date;

var query = DbContext.CRM_Note_Reminders
     .Include(x =&amp;gt; x.CRM_Note)
     .Where(x =&amp;gt; !x.CRM_Note.Is_Deleted 
             &amp;amp;&amp;amp; !x.Is_Deleted
             &amp;amp;&amp;amp; x.Reminder_Date.Date &amp;lt;= today)
     .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此生成的MySQL脚本如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;WHERE (((`x.CRM_Note`.`Is_Deleted` = FALSE) 
AND (`x`.`Is_Deleted` = FALSE)) 
AND (CONVERT(`x`.`Reminder_Date`, date) &amp;lt;= @__date_0)) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就得到了一个正确的结果，澳洲客户也就收到了正确的消息。&lt;/p&gt;
&lt;p&gt;是不是有种&lt;em&gt;差之毫厘，谬以千里&lt;/em&gt;的感觉呢？&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 23:28:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>背景 最近一直忙于手上澳洲线上项目的整体迁移和升级的准备工作，导致博客和公众号停更。本周终于艰难的完成了任务，借此机会，总结一下项目中遇到的一些问题。 EF Core一直是我们团队中中小型项目常用的O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11933042.html</dc:identifier>
</item>
<item>
<title>Java并发之volatile关键字 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/11932915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/11932915.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;说到多线程,我觉得我们最重要的是要理解一个临界区概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/24/MXFVy9.png&quot; alt=&quot;黑人问号.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，一个班上1个女孩子（临界区），49个男孩子（线程），男孩子的目标就是这一个女孩子，就是会有竞争关系（线程安全问题）。推广到实际场景，例如对一个数相加或者相减等等情形，因为操作对象就只有一个，在多线程环境下，就会产生线程安全问题。理解临界区概念，我们对多线程问题可以有一个好意识。&lt;/p&gt;
&lt;h3 id=&quot;jav内存模型jmm&quot;&gt;Jav内存模型（JMM)&lt;/h3&gt;
&lt;p&gt;谈到多线程就应该了解一下Java内存模型（JMM）的抽象示意图.下图：&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/24/MXVauQ.png&quot; alt=&quot;JMM.png&quot;/&gt;&lt;br/&gt;线程A和线程B执行的是时候，会去读取共享变量（临界区），然后各自拷贝一份回到自己的本地内存，执行后续操作。&lt;br/&gt;JMM模型是一种规范，就像Java的接口一样。JMM会涉及到三个问题：原子性，可见性，有序性。&lt;br/&gt;所谓原子性。就是说一个线程的执行会不会被其他线程影响的。他是不可中断的。举个例子:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int i=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语句在Jmm中就是原子性的。无论是一个线程执行还是多个线程执行这个语句，读出来的i就是等于1。那什么是非原子性呢，按道理如果Java的代码都是原子性，应该就不会有线程问题了啊。其实JMM这是规定某些语句是原子性罢了。举个非原子性例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;i ++;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个操作就不是原子性的了。因为他就是包含了三个操作:第一读取i的值，第二将i加上1，第三将结果赋值回来给i，更新i的值。&lt;br/&gt;所谓可见性。可见性表示如果一个值在线程A修改了，线程B就会马上知道这个结果。&lt;br/&gt;所谓有序性。所谓有序性值的是语意的有序性。就是说代码顺序可能会发生变化。因为有一个指令重排机制。所谓指令重排，他会改变代码执行顺序，为了让cpu执行效率更高。为了防止重排序出错，JMM有个happen-before规则，这个规则限制了那些语句执行在前，那些语句执行在后。&lt;br/&gt;Happen-before：&lt;br/&gt;程序顺序原则：一个线程内保证语义的串行性&lt;br/&gt;volatile原则：volatile变量的写发生在读之前&lt;br/&gt;锁规则：先加锁再解锁&lt;br/&gt;传递性：a先于b，b先于c，则a必定先于c&lt;br/&gt;线程的start方法先于他的每一个操作&lt;br/&gt;线程所有的操作先于线程的终结&lt;br/&gt;对象的构造函数执行、结束先于finalize()方法。&lt;/p&gt;
&lt;h3 id=&quot;volatile&quot;&gt;volatile&lt;/h3&gt;
&lt;p&gt;进入正题，volatile可以保证变量（临界区）的可见性以及有序性，但是不能保证原子性。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class VolatileTest implements Runnable{
    private static VolatileTest volatileTest = new VolatileTest();
    private  static volatile int i= 0;
    public static void main(String[] args) throws InterruptedException {
        for (int j = 0; j &amp;lt; 20; j++) {
            Thread a = new Thread(new VolatileTest());
            Thread b = new Thread(new VolatileTest());
            a.start();b.start();
            a.join();b.join();
            System.out.print(i+&quot;&amp;amp;&amp;amp;&quot;);
        }

    }
    
    @Override
    public void run() {
        for (int j = 0; j &amp;lt; 1000; j++) {
            i++;
        }
    }

}

// 输出结果
// 2000&amp;amp;&amp;amp;4000&amp;amp;&amp;amp;5852&amp;amp;&amp;amp;7852&amp;amp;&amp;amp;9852&amp;amp;&amp;amp;11852&amp;amp;&amp;amp;13655&amp;amp;&amp;amp;15655&amp;amp;&amp;amp;17655&amp;amp;&amp;amp;19655&amp;amp;&amp;amp;21306     
//&amp;amp;&amp;amp;22566&amp;amp;&amp;amp;24566&amp;amp;&amp;amp;26189&amp;amp;&amp;amp;28189&amp;amp;&amp;amp;30189&amp;amp;&amp;amp;32189&amp;amp;&amp;amp;34189&amp;amp;&amp;amp;36189&amp;amp;&amp;amp;38089&amp;amp;&amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有结果看到有问题，虽然i已经添加了volatile关键字，说明volatile关键字不能保证i++的原子性。&lt;/p&gt;
&lt;p&gt;那什么场景适合使用volatile关键字&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;轻量级的“读-写锁”策略&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile int value;
public int getValue(){ return value;}
public synchronized void doubleValue(){ value = value*value; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.单例模式（双检查锁机制&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile static Singleton instace;   
public static Singleton getInstance(){  // 没有使用同步方法，而是同步方法块
    //第一次null检查 ，利用volatile的线程间可见性，不需要加锁，性能提高    
    if(instance == null){            
        synchronized(Singleton.class) {    //锁住类对象，阻塞其他线程
            //第二次null检查，以保证不会创建重复的实例       
            if(instance == null){       
                instance = new Singleton(); // 禁止重排序
            }  
        }           
    }  
    return instance;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;《现代操作系统（第三版）中文版》&lt;br/&gt;《实战Java高并发程序设计》&lt;br/&gt;《Java并发编程的艺术》&lt;/p&gt;
&lt;h4 id=&quot;如果我的文章帮助到您可以关注我的微信公众号第一时间分享文章给您&quot;&gt;如果我的文章帮助到您，可以关注我的微信公众号，第一时间分享文章给您&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/24/MOMlcV.gif&quot; alt=&quot;MOMlcV.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 16:46:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>引言 说到多线程,我觉得我们最重要的是要理解一个临界区概念。 举个例子，一个班上1个女孩子（临界区），49个男孩子（线程），男孩子的目标就是这一个女孩子，就是会有竞争关系（线程安全问题）。推广到实际场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/11932915.html</dc:identifier>
</item>
<item>
<title>设计模式之代理模式 - 二营长的笔记</title>
<link>http://www.cnblogs.com/happyone/p/11932874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happyone/p/11932874.html</guid>
<description>&lt;h3 id=&quot;什么是代理模式&quot;&gt;什么是代理模式&lt;/h3&gt;
&lt;p&gt;代理模式就是为一个对象提供一个代理对象，由这个代理对象控制对该对象的访问。&lt;/p&gt;
&lt;p&gt;理解代理模式，可以对照生活中的一些具体例子，比如房产中介、二手车交易市场、经纪人等。&lt;/p&gt;
&lt;h3 id=&quot;为什么要用代理模式&quot;&gt;为什么要用代理模式&lt;/h3&gt;
&lt;p&gt;通过使用代理模式，我们避免了直接访问目标对象时可能带来的一些问题，比如：远程调用，需要使用远程代理来帮我们处理一些网络传输相关的细节逻辑；可能需要基于某种权限控制对目标资源的访问，可以使用保护代理等。&lt;/p&gt;
&lt;p&gt;总的来说，通过是用代理模式，我们可以控制对目标对象的访问，可以在真实方法被调用前或调用后，通过代理对象加入额外的处理逻辑。&lt;/p&gt;
&lt;h3 id=&quot;代理模式分类&quot;&gt;代理模式分类&lt;/h3&gt;
&lt;p&gt;代理模式分为静态代理和动态代理。动态代理根据实现不同又可细分为JDK动态代理和cglib动态代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态代理&lt;/strong&gt;是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态代理&lt;/strong&gt;是在实现阶段不用关心代理类，而在运行时动态生成代理类的。&lt;/p&gt;
&lt;h3 id=&quot;静态代理&quot;&gt;静态代理&lt;/h3&gt;
&lt;p&gt;以房哥买房子为例，用代码实现静态代理。&lt;/p&gt;
&lt;p&gt;1、首先建立一个Seller接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Seller {
    void sell();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、创建实现类，房哥，有一个方法，就是买房子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FangGe implements Seller{
    @Override
    public void sell() {
        System.out.println(&quot;房哥要出手一套四合院&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、买房子需要找到买家，达成交易后还要办理过户等其他手续，房哥只想卖房收钱就完了。因此，需要找一个代理来帮房哥处理这些杂事。&lt;/p&gt;
&lt;p&gt;我们创建一个代理类FangGeProxy，代理类也需要实现Seller接口，行为上要保持和FangGe一样，都是要卖房子。同时该代理类还需要持有房哥的引用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FangGeProxy implements Seller{
    private FangGe fangGe;

    public FangGeProxy(FangGe fangGe){
        this.fangGe = fangGe;
    }
    @Override
    public void sell() {
        findBuyer();
        fangGe.sell();
        afterSell();
    }
    
    public void findBuyer(){
        System.out.println(&quot;代理帮助寻找买主&quot;);
    }
    
    public void afterSell(){
        System.out.println(&quot;达成交易后，办理相关手续&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，房哥的代理类通过findBuyer()和afterSell()两个方法帮助房哥完成了其他一些杂事。&lt;/p&gt;
&lt;p&gt;4、测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StaticProxyTest {
    public static void main(String[] args) {
        Seller seller = new FangGeProxy(new FangGe());
        seller.sell();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;代理帮助寻找买主
房哥要出手一套四合院
达成交易后，办理相关手续&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，看下类图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191125214537361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTY1MDE4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态代理的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、由于静态代理类在编译前已经确定了代理的对象，因此静态代理只能代理一种类型的类，如果要给大量的类做代理，就需要编写大量的代理类；&lt;/p&gt;
&lt;p&gt;2、如果我们要给Seller，也就是目标对象要增加一些方法，则需要同步修改代理类，不符合开闭原则。&lt;/p&gt;
&lt;h3 id=&quot;jdk动态代理&quot;&gt;JDK动态代理&lt;/h3&gt;
&lt;p&gt;JDK的动态代理依赖于jdk给我们提供的类库实现，是一种基于接口实现的动态代理，在编译时并不知道要代理哪个类，而是在运行时动态生成代理类。同时也解决了静态代理中存在的问题。&lt;/p&gt;
&lt;p&gt;我们接上上面静态代理的例子，继续实现JDK的动态代理。&lt;/p&gt;
&lt;p&gt;1、我们建一个方法转发的处理器类，该类需要实现InvocationHandler接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SellerInvocationHandler implements InvocationHandler {

    // 要代理的真实对象
    private Object target;

    /**
     * 使用Proxy类静态方法获取代理类实例
     */
    public Object getProxyInstance(Object target){
        this.target = target;
        Class&amp;lt;?&amp;gt; clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object obj = method.invoke(this.target, args);
        after();
        return obj;
    }

    private void before() {
        System.out.println(&quot;执行方法前&quot;);
    }
    
    private void after() {
        System.out.println(&quot;执行方法后&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、新建JDK动态代理测试类，首先代理房哥卖房子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JDKDynamicProxyTest {
    public static void main(String[] args) {

        // new一个房哥，下面帮房哥找个代理
        FangGe fangGe = new FangGe();
        SellerInvocationHandler sellerInvocationHandler = new SellerInvocationHandler();
        
        // 房哥的代理对象
        Seller seller = (Seller) sellerInvocationHandler.getProxyInstance(fangGe);
        seller.sell();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;执行方法前
房哥要出手一套四合院
执行方法后&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，完成了代理。&lt;/p&gt;
&lt;p&gt;3、接下来我们新建另外一个类，User类，并使用JDK动态代理完成代理User类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IUser {
    void sayHello();

    void work();
}

public class UserImpl implements IUser{
    @Override
    public void sayHello() {
        System.out.println(&quot;hello,我是小明&quot;);
    }

    @Override
    public void work() {
        System.out.println(&quot;我正在写代码&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改测试类，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JDKDynamicProxyTest {
    public static void main(String[] args) {

/*        // new一个房哥，下面帮房哥找个代理
        FangGe fangGe = new FangGe();
        SellerInvocationHandler sellerInvocationHandler = new SellerInvocationHandler();

        // 房哥的代理对象
        Seller seller = (Seller) sellerInvocationHandler.getProxyInstance(fangGe);
        seller.sell();*/

        // 代理user类
        IUser user = new UserImpl();
        SellerInvocationHandler sellerInvocationHandler = new SellerInvocationHandler();
        IUser userProxy = (IUser) sellerInvocationHandler.getProxyInstance(user);
        userProxy.sayHello();
        userProxy.work();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;执行方法前
hello,我是小明
执行方法后
执行方法前
我正在写代码
执行方法后
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们SellerInvocationHandler 并未做任何改动，它便能为UserImpl类生成代理，并在执行方法的前后增加额外的执行逻辑。&lt;/p&gt;
&lt;h3 id=&quot;cglib动态代理&quot;&gt;cglib动态代理&lt;/h3&gt;
&lt;p&gt;JDK动态代理有一个局限就是，被代理的类必须要实现接口。如果被代理的类没有实现接口，则JDK动态代理就无能为力了。这个时候该cglib动态代理上场了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、新建一个MyCglibInterceptor，实现MethodInterceptor接口。该类类似于JDK动态代理中的InvocationHandler实例，是实现cglib动态代理的主要类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyCglibInterceptor implements MethodInterceptor {

    public Object getCglibProxyInstance(Object object){
        // 相当于Proxy，创建代理的工具类
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(object.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object obj = methodProxy.invokeSuper(o, objects);
        after();
        return obj;
    }

    private void before() {
        System.out.println(&quot;执行方法之前&quot;);
    }

    private void after() {
        System.out.println(&quot;执行方法之后&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、新建cglib动态代理的测试类，先代理上面例子中的User类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CglibDynamicProxyTest {
    public static void main(String[] args) {
        MyCglibInterceptor myCglibInterceptor = new MyCglibInterceptor();
        IUser userCglibProxy = (IUser) myCglibInterceptor.getCglibProxyInstance(new UserImpl());
        userCglibProxy.sayHello();
        userCglibProxy.work();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;执行方法之前
hello,我是小明
执行方法之后
执行方法之前
我正在写代码
执行方法之后&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、新建一个类HelloWorld，不实现任何接口，为该类实现动态代理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HelloWorld {
    public void hello(){
        System.out.println(&quot;世界这么大，我想去看看&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代理类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CglibDynamicProxyTest {
    public static void main(String[] args) {
/*        MyCglibInterceptor myCglibInterceptor = new MyCglibInterceptor();
        IUser userCglibProxy = (IUser) myCglibInterceptor.getCglibProxyInstance(new UserImpl());
        userCglibProxy.sayHello();
        userCglibProxy.work();*/

        // 代理未实现任何接口的类
        MyCglibInterceptor myCglibInterceptor = new MyCglibInterceptor();
        HelloWorld helloWorldProxy = (HelloWorld) myCglibInterceptor.getCglibProxyInstance(new HelloWorld());
        helloWorldProxy.hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;执行方法之前
世界这么大，我想去看看
执行方法之后&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用cglib动态代理，我们实现了对普通类的代理。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;设计模式系列文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_37965018/article/details/93791567&quot;&gt;单例模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/m0_37965018/article/details/103152585&quot;&gt;工厂模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/m0_37965018/article/details/103192446&quot;&gt;原型模式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 16:28:00 +0000</pubDate>
<dc:creator>二营长的笔记</dc:creator>
<og:description>什么是代理模式 代理模式就是为一个对象提供一个代理对象，由这个代理对象控制对该对象的访问。 理解代理模式，可以对照生活中的一些具体例子，比如房产中介、二手车交易市场、经纪人等。 为什么要用代理模式 通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/happyone/p/11932874.html</dc:identifier>
</item>
<item>
<title>Elasticsearch从入门到放弃：文档CRUD要牢记 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/11932163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/11932163.html</guid>
<description>&lt;p&gt;在Elasticsearch中，文档（document）是所有可搜索数据的最小单位。它被序列化成JSON存储在Elasticsearch中。每个文档都会有一个唯一ID，这个ID你可以自己指定或者交给Elasticsearch自动生成。&lt;/p&gt;
&lt;p&gt;如果延续我们之前不恰当的对比RDMS的话，我认为文档可以类比成关系型数据库中的表。&lt;/p&gt;
&lt;h3 id=&quot;元数据&quot;&gt;元数据&lt;/h3&gt;
&lt;p&gt;前面我们提到，每个文档都有一个唯一ID来标识，获取文档时，“_id”字段记录的就是文档的唯一ID，它是元数据之一。当然，文档还有一些其他的元数据，下面我们来一一介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;_index：文档所属的索引名&lt;/li&gt;
&lt;li&gt;_type：文档所属的type&lt;/li&gt;
&lt;li&gt;_id：文档的唯一ID&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了这三个，我们就可以唯一确定一个document了，当然，7.0版本以后我们已经不需要_type了。接下来我们再来看看其他的一些元数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;_source：文档的原始JSON数据&lt;/li&gt;
&lt;li&gt;_field_names：该字段用于索引文档中值不为null的字段名，主要用于exists请求查找指定字段是否为空&lt;/li&gt;
&lt;li&gt;_ignore：这个字段用于索引和存储文档中每个由于异常（开启了ignore_malformed）而被忽略的字段的名称&lt;/li&gt;
&lt;li&gt;_meta：该字段用于存储一些自定义的元数据信息&lt;/li&gt;
&lt;li&gt;_routing：用来指定数据落在哪个分片上，默认值是Id&lt;/li&gt;
&lt;li&gt;_version：文档的版本信息&lt;/li&gt;
&lt;li&gt;_score：相关性打分&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建文档&quot;&gt;创建文档&lt;/h3&gt;
&lt;p&gt;创建文档有以下4种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PUT /&amp;lt;index&amp;gt;/_doc/&amp;lt;_id&amp;gt;&lt;/li&gt;
&lt;li&gt;POST /&amp;lt;index&amp;gt;/_doc/&lt;/li&gt;
&lt;li&gt;PUT /&amp;lt;index&amp;gt;/_create/&amp;lt;_id&amp;gt;&lt;/li&gt;
&lt;li&gt;POST /&amp;lt;index&amp;gt;/_create/&amp;lt;_id&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这四种方法的区别是，如果不指定id，则Elasticsearch会自动生成一个id。如果使用_create的方法，则必须保证文档不存在，而使用_doc方法的话，既可以创建新的文档，也可以更新已存在的文档。&lt;/p&gt;
&lt;p&gt;在创建文档时，还可以选择一些参数。&lt;/p&gt;
&lt;h4 id=&quot;请求参数&quot;&gt;请求参数&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;if_seq_no&lt;/strong&gt;：当文档的序列号是指定值时才更新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if_primary_term&lt;/strong&gt;：当文档的primary term是指定值时才更新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;op_type&lt;/strong&gt;：如果设置为create则指定id的文档必须不存在，否则操作失败。有效值为index或create，默认为index&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;op_type&lt;/strong&gt;：指定预处理的管道id&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refresh&lt;/strong&gt;：如果设置为true，则立即刷新受影响的分片。如果是wait_for，则会等到刷新分片后，此次操作才对搜索可见。如果是false，则不会刷新分片。默认值为false&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;routing&lt;/strong&gt;：指定路由到的主分片&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;timeout&lt;/strong&gt;：指定响应时间，默认是30秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;master_timeout&lt;/strong&gt;：连接主节点的响应时长，默认是30秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;：显式的指定版本号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version_type&lt;/strong&gt;：指定版本号类型：internal、 external、external_gte、force&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wait_for_active_shards&lt;/strong&gt;：处理操作之前，必须保持活跃的分片副本数量，可以设置为all或者任意正整数。默认是1，即只需要主分片活跃。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;响应包体&quot;&gt;响应包体&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;**_shards**：提供分片的信息&lt;/li&gt;
&lt;li&gt;**_shards.total**：创建了文档的总分片数量&lt;/li&gt;
&lt;li&gt;**_shards.successful**：成功创建文档分片的数量&lt;/li&gt;
&lt;li&gt;**_shards.failed**：创建文档失败的分片数量&lt;/li&gt;
&lt;li&gt;**_index**：文档所属索引&lt;/li&gt;
&lt;li&gt;**_type**：文档所属type，目前只支持_doc&lt;/li&gt;
&lt;li&gt;**_id**：文档的id&lt;/li&gt;
&lt;li&gt;**_version**：文档的版本号&lt;/li&gt;
&lt;li&gt;**_seq_no**：文档的序列号&lt;/li&gt;
&lt;li&gt;**_primary_term**：文档的主要术语&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;result&lt;/strong&gt;：索引的结果，created或者updated&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在创建文档时，如果指定的索引不存在，则ES会自动为我们创建索引。这一操作是可以通过设置中的action.auto_create_index字段来控制的，默认是true。你可以修改这个字段，实现指定某些索引可以自动创建或者所有索引都不能自动创建的目的。&lt;/p&gt;
&lt;h3 id=&quot;更新文档&quot;&gt;更新文档&lt;/h3&gt;
&lt;p&gt;了解了如何创建文档之后，我们再来看看应该如何更新一个已经存在的文档。其实在创建文档时我们就提到过，使用PUT /&amp;lt;index&amp;gt;/_doc/&amp;lt;id&amp;gt;的方法就可以更新一个已存在的文档。除此之外，我们还有另一种更新文档的方法：&lt;/p&gt;
&lt;p&gt;POST /&amp;lt;index&amp;gt;/_update/&amp;lt;_id&amp;gt;&lt;/p&gt;
&lt;p&gt;这两种更新有所不同。_doc方法是先删除原有的文档，再创建新的。而_update方法则是增量更新，它的更新过程是先检索到文档，然后运行指定脚本，最后重新索引。&lt;/p&gt;
&lt;p&gt;还有一个区别就是_update方法支持使用脚本更新，默认的语言是painless，你可以通过参数lang来进行设置。在请求参数方面，_update相较于_doc多了以下几个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;lang&lt;/strong&gt;：指定脚本语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;retry_on_conflict&lt;/strong&gt;：发生冲突时重试次数，默认是0&lt;/li&gt;
&lt;li&gt;**_source**：设置为false，则不返回任何检索字段&lt;/li&gt;
&lt;li&gt;**_source_excludes**：指定要从检索结果排除的source字段&lt;/li&gt;
&lt;li&gt;**_source_includes**：指定要返回的检索source字段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的一个例子是用脚本来更新文档&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST &quot;localhost:9200/test/_update/1?pretty&quot; -H 'Content-Type: application/json' -d'
{
    &quot;script&quot; : {
        &quot;source&quot;: &quot;ctx._source.counter += params.count&quot;,
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;params&quot; : {
            &quot;count&quot; : 4
        }
    }
}
'&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;upsert&quot;&gt;Upsert&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST &quot;localhost:9200/test/_update/1?pretty&quot; -H 'Content-Type: application/json' -d'
{
    &quot;script&quot; : {
        &quot;source&quot;: &quot;ctx._source.counter += params.count&quot;,
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;params&quot; : {
            &quot;count&quot; : 4
        }
    },
    &quot;upsert&quot; : {
        &quot;counter&quot; : 1
    }
}
'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当指定的文档不存在时，可以使用upsert参数，创建一个新的文档，而当指定的文档存在时，该请求会执行script中的脚本。如果不想使用脚本，而只想新增/更新文档的话，可以使用doc_as_upsert。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST &quot;localhost:9200/test/_update/1?pretty&quot; -H 'Content-Type: application/json' -d'
{
    &quot;doc&quot; : {
        &quot;name&quot; : &quot;new_name&quot;
    },
    &quot;doc_as_upsert&quot; : true
}
'&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;update-by-query&quot;&gt;update by query&lt;/h4&gt;
&lt;p&gt;这个API是用于批量更新检索出的文档的，具体可以通过一个例子来了解。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST &quot;localhost:9200/twitter/_update_by_query?pretty&quot; -H 'Content-Type: application/json' -d'
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.likes++&quot;,
    &quot;lang&quot;: &quot;painless&quot;
  },
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;user&quot;: &quot;kimchy&quot;
    }
  }
}
'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取文档&quot;&gt;获取文档&lt;/h3&gt;
&lt;p&gt;ES获取文档用的是GET API，请求的格式是：&lt;/p&gt;
&lt;p&gt;GET /&amp;lt;index&amp;gt;/_doc/&amp;lt;_id&amp;gt;&lt;/p&gt;
&lt;p&gt;它会返回文档的数据和一些元数据，如果你只想要文档的内容而不需要元数据时，可以使用&lt;/p&gt;
&lt;p&gt;GET /&amp;lt;index&amp;gt;/_source/&amp;lt;_id&amp;gt;&lt;/p&gt;
&lt;h4 id=&quot;请求参数-1&quot;&gt;请求参数&lt;/h4&gt;
&lt;p&gt;获取文档的有几个请求参数之前已经提到过，这里不再赘述，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;refresh&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;routing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**_source**&lt;/li&gt;
&lt;li&gt;**_source_excludes**&lt;/li&gt;
&lt;li&gt;**_source_includes**&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version_type&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而还有一些之前没提到过的参数，我们来具体看一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;preference&lt;/strong&gt;：用来 指定执行请求的node或shard，如果设置为_local，则会优先在本地的分片执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;realtime&lt;/strong&gt;：如果设置为true，则请求是实时的而不是近实时。默认是true&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stored_fields&lt;/strong&gt;：返回指定的字段中，store为true的字段&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mget&quot;&gt;mget&lt;/h4&gt;
&lt;p&gt;mget是批量获取的方法之一，请求的格式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET /_mget&lt;/li&gt;
&lt;li&gt;GET /&amp;lt;index&amp;gt;/_mget&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种是在请求体中写index。第二种是把index放到url中，不过这种方式可能会触发ES的安全检查。&lt;/p&gt;
&lt;p&gt;mget的请求参数和get相同，只是需要在请求体中指定doc的相关检索条件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;request&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;GET /_mget
{
    &quot;docs&quot; : [
        {
            &quot;_index&quot; : &quot;jackey&quot;,
            &quot;_id&quot; : &quot;1&quot;
        },
        {
            &quot;_index&quot; : &quot;jackey&quot;,
            &quot;_id&quot; : &quot;2&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;response&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;{
  &quot;docs&quot; : [
    {
      &quot;_index&quot; : &quot;jackey&quot;,
      &quot;_type&quot; : &quot;_doc&quot;,
      &quot;_id&quot; : &quot;1&quot;,
      &quot;_version&quot; : 5,
      &quot;_seq_no&quot; : 6,
      &quot;_primary_term&quot; : 1,
      &quot;found&quot; : true,
      &quot;_source&quot; : {
        &quot;user&quot; : &quot;ja&quot;,
        &quot;tool&quot; : &quot;ES&quot;,
        &quot;message&quot; : &quot;qwer&quot;
      }
    },
    {
      &quot;_index&quot; : &quot;jackey&quot;,
      &quot;_type&quot; : &quot;_doc&quot;,
      &quot;_id&quot; : &quot;2&quot;,
      &quot;_version&quot; : 1,
      &quot;_seq_no&quot; : 2,
      &quot;_primary_term&quot; : 1,
      &quot;found&quot; : true,
      &quot;_source&quot; : {
        &quot;user&quot; : &quot;zhe&quot;,
        &quot;post_date&quot; : &quot;2019-11-15T14:12:12&quot;,
        &quot;message&quot; : &quot;learning Elasticsearch&quot;
      }
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除文档&quot;&gt;删除文档&lt;/h3&gt;
&lt;p&gt;CURD操作只剩下最后一个D了，下面我们就一起来看看ES中如何删除一个文档。&lt;/p&gt;
&lt;p&gt;删除指定id使用的请求是&lt;/p&gt;
&lt;p&gt;DELETE /&amp;lt;index&amp;gt;/_doc/&amp;lt;_id&amp;gt;&lt;/p&gt;
&lt;p&gt;在并发量比较大的情况下，我们在删除时通常会指定版本，以确定删除的文档是我们真正想要删除的文档。删除请求的参数我们在之前也都介绍过，想要具体了解的同学可以直接查看&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.4/docs-delete.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;delete-by-query&quot;&gt;delete by query&lt;/h4&gt;
&lt;p&gt;类似于update，delete也有一个delete by query的API。&lt;/p&gt;
&lt;p&gt;POST /&amp;lt;index&amp;gt;/_delete_by_query&lt;/p&gt;
&lt;p&gt;它也是要先按照条件来查询匹配的文档，然后删除这些文档。在执行查询之前，Elasticsearch会先为指定索引做一个快照，如果在执行删除过程中，要索引发生改变，则会导致操作冲突，同时返回删除失败。&lt;/p&gt;
&lt;p&gt;如果删除的文档比较多，也可以使这个请求异步执行，只需要设置wait_for_completion=false即可。&lt;/p&gt;
&lt;p&gt;这个API的refresh与delete API的refresh参数有所不同，delete中的refresh参数是设置操作是否立即可见，即只刷新一个分片，而这个API中的refresh参数则是需要刷新受影响的所有分片。&lt;/p&gt;
&lt;h3 id=&quot;bulk-api&quot;&gt;Bulk API&lt;/h3&gt;
&lt;p&gt;最后，我们再来介绍一种特殊的API，批量操作的API。它支持两种写法，可以将索引名写到url中，也可以写到请求体中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;POST /_bulk&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST /&amp;lt;index&amp;gt;/_bulk&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个请求中，你可以任意使用之前的CRUD请求的组合。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST &quot;localhost:9200/_bulk?pretty&quot; -H 'Content-Type: application/json' -d'
{ &quot;index&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;1&quot; } }
{ &quot;field1&quot; : &quot;value1&quot; }
{ &quot;delete&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;2&quot; } }
{ &quot;create&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;3&quot; } }
{ &quot;field1&quot; : &quot;value3&quot; }
{ &quot;update&quot; : {&quot;_id&quot; : &quot;1&quot;, &quot;_index&quot; : &quot;test&quot;} }
{ &quot;doc&quot; : {&quot;field2&quot; : &quot;value2&quot;} }
'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求体中使用的语法是newline delimited JSON（NDJSON）。具体怎么用呢？其实我们在上面的例子中已经有所展现了，对于index或create这样的请求，如果请求本身是有包体的，那么用换行符来表示下面的内容与子请求分隔，即为包体的开始。&lt;/p&gt;
&lt;p&gt;例如上面例子中的index请求，它的包体就是{ &quot;field1&quot; : &quot;value1&quot; }，所以它会在index请求的下一行出现。&lt;/p&gt;
&lt;p&gt;对于批量执行操作来说，单条操作失败并不会影响其他操作，而最终每条操作的结果也都会返回。&lt;/p&gt;
&lt;p&gt;上面的例子执行完之后，我们得到的结果应该是&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;{
   &quot;took&quot;: 30,
   &quot;errors&quot;: false,
   &quot;items&quot;: [
      {
         &quot;index&quot;: {
            &quot;_index&quot;: &quot;test&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;1&quot;,
            &quot;_version&quot;: 1,
            &quot;result&quot;: &quot;created&quot;,
            &quot;_shards&quot;: {
               &quot;total&quot;: 2,
               &quot;successful&quot;: 1,
               &quot;failed&quot;: 0
            },
            &quot;status&quot;: 201,
            &quot;_seq_no&quot; : 0,
            &quot;_primary_term&quot;: 1
         }
      },
      {
         &quot;delete&quot;: {
            &quot;_index&quot;: &quot;test&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;2&quot;,
            &quot;_version&quot;: 1,
            &quot;result&quot;: &quot;not_found&quot;,
            &quot;_shards&quot;: {
               &quot;total&quot;: 2,
               &quot;successful&quot;: 1,
               &quot;failed&quot;: 0
            },
            &quot;status&quot;: 404,
            &quot;_seq_no&quot; : 1,
            &quot;_primary_term&quot; : 2
         }
      },
      {
         &quot;create&quot;: {
            &quot;_index&quot;: &quot;test&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;3&quot;,
            &quot;_version&quot;: 1,
            &quot;result&quot;: &quot;created&quot;,
            &quot;_shards&quot;: {
               &quot;total&quot;: 2,
               &quot;successful&quot;: 1,
               &quot;failed&quot;: 0
            },
            &quot;status&quot;: 201,
            &quot;_seq_no&quot; : 2,
            &quot;_primary_term&quot; : 3
         }
      },
      {
         &quot;update&quot;: {
            &quot;_index&quot;: &quot;test&quot;,
            &quot;_type&quot;: &quot;_doc&quot;,
            &quot;_id&quot;: &quot;1&quot;,
            &quot;_version&quot;: 2,
            &quot;result&quot;: &quot;updated&quot;,
            &quot;_shards&quot;: {
                &quot;total&quot;: 2,
                &quot;successful&quot;: 1,
                &quot;failed&quot;: 0
            },
            &quot;status&quot;: 200,
            &quot;_seq_no&quot; : 3,
            &quot;_primary_term&quot; : 4
         }
      }
   ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;批量操作的执行过程相比多次单个操作而言，在性能上会有一定的提升。但同时也会有一定的风险，所以我们在使用的时候要非常的谨慎。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文我们先介绍了文档的基本概念和文档的元数据。接着又介绍了文档的CRUD操作和Bulk API。相信看完文章你对Elasticsearch的文档也会有一定的了解。那最后就请你启动你的Elasticsearch，然后亲自动手试一试这些操作，看看各种请求的参数究竟有什么作用。相信亲手实验过一遍之后你会对这些API有更深的印象。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 15:30:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>在Elasticsearch中，文档（document）是所有可搜索数据的最小单位。它被序列化成JSON存储在Elasticsearch中。每个文档都会有一个唯一ID，这个ID你可以自己指定或者交给E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/11932163.html</dc:identifier>
</item>
<item>
<title>Maven 无法下载依赖包的解决方法---三步dao！！！ - WuHepeng</title>
<link>http://www.cnblogs.com/WLCYSYS/p/11932157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WLCYSYS/p/11932157.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i1.10306940cZR1RA&quot;&gt;版权声明：本文为博主原创文章，转载请附上原文出处链接和本声明。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i1.10306940cZR1RA&quot;&gt;本文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/WLCYSYS/p/11932157.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/WLCYSYS/p/11932157.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i1.10306940cZR1RA&quot;&gt;maven 自动下载依赖包出现错误，那我把错误原因说一下吧。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.0.i1.10306940cZR1RA&quot;&gt;先来个错误示范：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-resources-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来个正确地：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-resources-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用你的两只双眼皮大眼瞅瞅，这两个什么不同吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1312170/201911/1312170-20191125231418786-39416103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 出现依赖包无法下载时可能是下面的原因：&lt;/p&gt;
&lt;p&gt;1：版本错误&lt;/p&gt;
&lt;p&gt;2：依赖包版权问题&lt;/p&gt;
&lt;p&gt;3：或者是中央仓库的镜像（mirror）没配置好&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;1&quot;&gt;步骤一，检查镜像版本。&lt;/h4&gt;
&lt;p&gt;查看项目中依赖包的版本是否存在，可以用 mvnrepository，地址如下：&lt;/p&gt;
&lt;pre&gt;
&lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;hljs cpp&quot;&gt;https:&lt;/code&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2&quot;&gt;步骤二，检查镜像仓库。&lt;/h4&gt;
&lt;p&gt;阿里云仓库改了版本，但是依赖支持以前的仓库地址。&lt;br/&gt;阿里云仓库配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;alimaven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aliyun maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;https://maven.aliyun.com/repository/public&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;central&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果不会配置，请你进入我好友的博客看下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jimc/p/10152621.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Jimc/p/10152621.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;3&quot;&gt;步骤三，下载依赖包安装到本地仓库，然后再引入依赖。&lt;/h4&gt;
&lt;p&gt;以下用 oracle 12.1.0.1 的依赖包为例进行说明。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载依赖包：oracle 12.1.0.1 依赖包下载地址如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;txt hljs ruby&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;&lt;a href=&quot;https://www.oracle.com/database/technologies/jdbc-drivers-12c-downloads.html&quot; target=&quot;_blank&quot;&gt;https:/&lt;/a&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;&lt;a href=&quot;https://www.oracle.com/database/technologies/jdbc-drivers-12c-downloads.html&quot; target=&quot;_blank&quot;&gt;/www.oracle.com/database&lt;/a&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;&lt;a href=&quot;https://www.oracle.com/database/technologies/jdbc-drivers-12c-downloads.html&quot; target=&quot;_blank&quot;&gt;/technologies/jdbc-drivers-&lt;/a&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;a href=&quot;https://www.oracle.com/database/technologies/jdbc-drivers-12c-downloads.html&quot; target=&quot;_blank&quot;&gt;12c-downloads.html&lt;br/&gt;&lt;/a&gt;由于原网址需要注册登录oracle,比较麻烦；用我的也可以；&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/WLCYSYS/ojdbc7.7z&quot;&gt;https://files.cnblogs.com/files/WLCYSYS/ojdbc7.7z&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1312170/201911/1312170-20191125232146071-389642275.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;code class=&quot;txt hljs ruby&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;依赖包安装到本地仓库：命令如下，&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mvn  &lt;span&gt;install&lt;/span&gt;:&lt;span&gt;install&lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; -DgroupId=com.oracle -DartifactId=ojdbc7 -Dversion=&lt;span&gt;12.1&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -Dpackaging=jar -Dfile=E:\chromedownload\ojdbc7.jar&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得一定要在下载依赖包的文件下打开CMD.exe，记清自己下载后放的位置；例如我的：E:\chromedownload\ojdbc7.jar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1312170/201911/1312170-20191126001334316-268107020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引入依赖：依赖配置如下，&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.oracle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ojdbc7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;12.1.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;--------------------------------------------------&lt;span&gt;已经变成大三老学长了鹅鹅鹅！！！点赞再走啊！！！&lt;/span&gt;------------------------------------------------------------------------------&lt;/p&gt;


</description>
<pubDate>Mon, 25 Nov 2019 15:29:00 +0000</pubDate>
<dc:creator>WuHepeng</dc:creator>
<og:description>版权声明：本文为博主原创文章，转载请附上原文出处链接和本声明。 本文链接：https://www.cnblogs.com/WLCYSYS/p/11932157.html maven 自动下载依赖包出现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WLCYSYS/p/11932157.html</dc:identifier>
</item>
<item>
<title>&amp;#128584;羞，Spring Bean 初始化/销毁竟然有这么多姿势 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/11931557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/11931557.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201911/1419561-20191125230444733-583061884.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.1428571428571&quot;&gt;
&lt;p&gt;文章来源：&lt;a href=&quot;http://1t.click/bfHN&quot; class=&quot;uri&quot;&gt;http://1t.click/bfHN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;日常开发过程有时需要在应用启动之后加载某些资源，或者在应用关闭之前释放资源。Spring 框架提供相关功能，围绕 &lt;code&gt;Spring Bean&lt;/code&gt; 生命周期，可以在 &lt;code&gt;Bean&lt;/code&gt; 创建过程初始化资源，以及销毁 &lt;code&gt;Bean&lt;/code&gt; 过程释放资源。Spring 提供多种不同的方式初始化/销毁 &lt;code&gt;Bean&lt;/code&gt;，如果同时使用这几种方式，Spring 如何处理这几者之间的顺序？&lt;/p&gt;
&lt;blockquote readability=&quot;3.8102189781022&quot;&gt;
&lt;p&gt;有没有觉得标题很熟悉，没错标题模仿二哥 「&lt;strong&gt;@沉默王二&lt;/strong&gt;」 文章&lt;a href=&quot;https://juejin.im/post/5dcc76bde51d45109d6df4b4?utm_source=gold_browser_extension&quot;&gt;羞，Java 字符串拼接竟然有这么多姿势&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二姿势剖析&quot;&gt;二、姿势剖析&lt;/h2&gt;
&lt;p&gt;首先我们先来回顾一下 Spring 初始化/销毁 &lt;code&gt;Bean&lt;/code&gt; 几种方式，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init-method/destroy-method&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InitializingBean/DisposableBean&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostConstruct/@PreDestroy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContextStartedEvent/ContextClosedEvent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS: 其实还有一种方式，就是继承 Spring &lt;code&gt;Lifecycle&lt;/code&gt; 接口。不过这种方式比较繁琐，这里就不再分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;init-methoddestroy-method&quot;&gt;2.1、init-method/destroy-method&lt;/h3&gt;
&lt;p&gt;这种方式在配置文件文件指定初始化/销毁方法。XML 配置如下&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;demoService&quot; class=&quot;com.dubbo.example.provider.DemoServiceImpl&quot;  destroy-method=&quot;close&quot;  init-method=&quot;initMethod&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者也可以使用注解方式配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configurable
public class AppConfig {

    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
    public HelloService hello() {
        return new HelloService();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得刚开始接触学习 Spring 框架，使用就是这种方式。&lt;/p&gt;
&lt;h3 id=&quot;initializingbeandisposablebean&quot;&gt;2.2、InitializingBean/DisposableBean&lt;/h3&gt;
&lt;p&gt;这种方式需要继承 Spring 接口 &lt;code&gt;InitializingBean/DisposableBean&lt;/code&gt;，其中 &lt;code&gt;InitializingBean&lt;/code&gt; 用于初始化动作，而 &lt;code&gt;DisposableBean&lt;/code&gt; 用于销毁之前清理动作。使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class HelloService implements InitializingBean, DisposableBean {
    
    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;hello destroy...&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;hello init....&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;postconstructpredestroy&quot;&gt;2.3、@PostConstruct/@PreDestroy&lt;/h3&gt;
&lt;p&gt;这种方式相对于上面两种方式来说，使用方式最简单，只需要在相应的方法上使用注解即可。使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class HelloService {


    @PostConstruct
    public void init() {
        System.out.println(&quot;hello @PostConstruct&quot;);
    }

    @PreDestroy
    public void PreDestroy() {
        System.out.println(&quot;hello @PreDestroy&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里踩过一个坑，如果使用 JDK9 之后版本 ，&lt;code&gt;@PostConstruct/@PreDestroy&lt;/code&gt; 需要使用 maven 单独引入 &lt;code&gt;javax.annotation-api&lt;/code&gt;，否者注解不会生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;contextstartedeventcontextclosedevent&quot;&gt;2.4、ContextStartedEvent/ContextClosedEvent&lt;/h3&gt;
&lt;p&gt;这种方式使用 Spring 事件机制，日常业务开发比较少见，常用与框架集成中。Spring 启动之后将会发送 &lt;code&gt;ContextStartedEvent&lt;/code&gt; 事件，而关闭之前将会发送 &lt;code&gt;ContextClosedEvent&lt;/code&gt; 事件。我们需要继承 Spring &lt;code&gt;ApplicationListener&lt;/code&gt; 才能监听以上两种事件。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class HelloListener implements ApplicationListener {

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if(event instanceof ContextClosedEvent){
            System.out.println(&quot;hello ContextClosedEvent&quot;);
        }else if(event instanceof ContextStartedEvent){
            System.out.println(&quot;hello ContextStartedEvent&quot;);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;code&gt;@EventListener&lt;/code&gt;注解，使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HelloListenerV2 {
    
    @EventListener(value = {ContextClosedEvent.class, ContextStartedEvent.class})
    public void receiveEvents(ApplicationEvent event) {
        if (event instanceof ContextClosedEvent) {
            System.out.println(&quot;hello ContextClosedEvent&quot;);
        } else if (event instanceof ContextStartedEvent) {
            System.out.println(&quot;hello ContextStartedEvent&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS:只有调用 &lt;code&gt;ApplicationContext#start&lt;/code&gt; 才会发送 &lt;code&gt;ContextStartedEvent&lt;/code&gt;。若不想这么麻烦，可以监听 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt; 事件代替。一旦 Spring 容器初始化完成，就会发送 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三综合使用&quot;&gt;三、综合使用&lt;/h2&gt;
&lt;p&gt;回顾完上面几种方式，这里我们综合使用上面的四种方式，来看下 Spring 内部的处理顺序。在看结果之前，各位读者大人可以猜测下这几种方式的执行顺序。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HelloService implements InitializingBean, DisposableBean {


    @PostConstruct
    public void init() {
        System.out.println(&quot;hello @PostConstruct&quot;);
    }

    @PreDestroy
    public void PreDestroy() {
        System.out.println(&quot;hello @PreDestroy&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;bye DisposableBean...&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;hello InitializingBean....&quot;);
    }

    public void xmlinit(){
        System.out.println(&quot;hello xml-init...&quot;);
    }

    public void xmlDestory(){
        System.out.println(&quot;bye xmlDestory...&quot;);
    }

    @EventListener(value = {ContextClosedEvent.class, ContextStartedEvent.class})
    public void receiveEvents(ApplicationEvent event) {
        if (event instanceof ContextClosedEvent) {
            System.out.println(&quot;bye ContextClosedEvent&quot;);
        } else if (event instanceof ContextStartedEvent) {
            System.out.println(&quot;hello ContextStartedEvent&quot;);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xml 配置方式如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;context:annotation-config /&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.dubbo.example.demo&quot;/&amp;gt;
    
    &amp;lt;bean class=&quot;com.dubbo.example.demo.HelloService&quot; init-method=&quot;xmlinit&quot; destroy-method=&quot;xmlDestory&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用启动方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring/dubbo-provider.xml&quot;);
context.start();
context.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201911/1419561-20191125230446068-99783114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后采用图示说明总结以上结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201911/1419561-20191125230447245-208042925.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四源码解析&quot;&gt;四、源码解析&lt;/h2&gt;
&lt;p&gt;不知道各位读者有没有猜对这几种方式的执行顺序，下面我们就从源码角度解析 Spring 内部处理的顺序。&lt;/p&gt;
&lt;h3 id=&quot;初始化过程&quot;&gt;4.1、初始化过程&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 启动 Spring 容器，将会调用 &lt;code&gt;refresh&lt;/code&gt; 方法初始化容器。初始化过程将会创建 &lt;code&gt;Bean&lt;/code&gt; 。最后当一切准备完毕，将会发送 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;。当容器初始化完毕，调用 &lt;code&gt;context.start()&lt;/code&gt; 就发送 &lt;code&gt;ContextStartedEvent&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;refresh&lt;/code&gt; 方法源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
            //... 忽略无关代码

            // 初始化所有非延迟初始化的 Bean
            finishBeanFactoryInitialization(beanFactory);

            // 发送 ContextRefreshedEvent
            finishRefresh();

            //... 忽略无关代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一路跟踪 &lt;code&gt;finishBeanFactoryInitialization&lt;/code&gt; 源码，直到 &lt;code&gt;AbstractAutowireCapableBeanFactory#initializeBean&lt;/code&gt;，源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 调用 BeanPostProcessor#postProcessBeforeInitialization 方法
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    try {
        // 初始化 Bean
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                (mbd != null ? mbd.getResourceDescription() : null),
                beanName, &quot;Invocation of init method failed&quot;, ex);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 将会起着拦截器的作用，一旦 Bean 符合条件，将会执行一些处理。这里带有 &lt;code&gt;@PostConstruct&lt;/code&gt; 注解的 &lt;code&gt;Bean&lt;/code&gt; 都将会被 &lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt; 类拦截，内部将会触发 &lt;code&gt;@PostConstruct&lt;/code&gt; 标注的方法。&lt;/p&gt;
&lt;p&gt;接着执行 &lt;code&gt;invokeInitMethods&lt;/code&gt; ，方法如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
        throws Throwable {

    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean &amp;amp;&amp;amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {
        // 省略无关代码
        // 如果是 Bean 继承 InitializingBean，将会执行  afterPropertiesSet 方法
        ((InitializingBean) bean).afterPropertiesSet();
    }

    if (mbd != null) {
        String initMethodName = mbd.getInitMethodName();
        if (initMethodName != null &amp;amp;&amp;amp; !(isInitializingBean &amp;amp;&amp;amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;amp;&amp;amp;
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            // 执行 XML 定义 init-method
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;Bean&lt;/code&gt; 继承 &lt;code&gt;InitializingBean&lt;/code&gt; 接口，将会执行 &lt;code&gt;afterPropertiesSet&lt;/code&gt; 方法，另外如果在 XML 中指定了 &lt;code&gt;init-method&lt;/code&gt; ，也将会触发。&lt;/p&gt;
&lt;p&gt;上面源码其实都是围绕着 &lt;code&gt;Bean&lt;/code&gt; 创建的过程，当所有 &lt;code&gt;Bean&lt;/code&gt; 创建完成之后，调用 &lt;code&gt;context#start&lt;/code&gt; 将会发送 &lt;code&gt;ContextStartedEvent&lt;/code&gt; 。这里源码比较简单，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void start() {
    getLifecycleProcessor().start();
    publishEvent(new ContextStartedEvent(this));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;销毁过程&quot;&gt;4.2、销毁过程&lt;/h3&gt;
&lt;p&gt;调用 &lt;code&gt;ClassPathXmlApplicationContext#close&lt;/code&gt; 方法将会关闭容器，具体逻辑将会在 &lt;code&gt;doClose&lt;/code&gt; 方法执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doClose&lt;/code&gt; 这个方法首先发送 &lt;code&gt;ContextClosedEvent&lt;/code&gt;，然再后开始销毁 &lt;code&gt;Bean&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;灵魂拷问:如果我们颠倒上面两者顺序，结果会一样吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;doClose&lt;/code&gt; 源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void doClose() {
    if (this.active.get() &amp;amp;&amp;amp; this.closed.compareAndSet(false, true)) {
        // 省略无关代码

        try {
            // Publish shutdown event.
            publishEvent(new ContextClosedEvent(this));
        }
        catch (Throwable ex) {
            logger.warn(&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;, ex);
        }


        // 销毁 Bean
        destroyBeans();

        // 省略无关代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;destroyBeans&lt;/code&gt; 最终将会执行 &lt;code&gt;DisposableBeanAdapter#destroy&lt;/code&gt;，&lt;code&gt;@PreDestroy&lt;/code&gt;、&lt;code&gt;DisposableBean&lt;/code&gt;、&lt;code&gt;destroy-method&lt;/code&gt; 三者定义的方法都将会在内部被执行。&lt;/p&gt;
&lt;p&gt;首先执行 &lt;code&gt;DestructionAwareBeanPostProcessor#postProcessBeforeDestruction&lt;/code&gt;，这里方法类似与上面 &lt;code&gt;BeanPostProcessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@PreDestroy&lt;/code&gt; 注解将会被 &lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt; 拦截，这里类同时也继承了 &lt;code&gt;DestructionAwareBeanPostProcessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后如果 &lt;code&gt;Bean&lt;/code&gt; 为 &lt;code&gt;DisposableBean&lt;/code&gt; 的子类，将会执行 &lt;code&gt;destroy&lt;/code&gt; 方法，如果在 xml 定义了 &lt;code&gt;destroy-method&lt;/code&gt; 方法，该方法也会被执行。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void destroy() {
    if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
        for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
            processor.postProcessBeforeDestruction(this.bean, this.beanName);
        }
    }

    if (this.invokeDisposableBean) {
        // 省略无关代码
        // 如果 Bean 继承 DisposableBean，执行 destroy 方法
        ((DisposableBean) bean).destroy();
        
    }

    if (this.destroyMethod != null) {
        // 执行 xml 指定的  destroy-method 方法
        invokeCustomDestroyMethod(this.destroyMethod);
    }
    else if (this.destroyMethodName != null) {
        Method methodToCall = determineDestroyMethod();
        if (methodToCall != null) {
            invokeCustomDestroyMethod(methodToCall);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;init-method/destroy-method&lt;/code&gt; 这种方式需要使用 XML 配置文件或单独注解配置类，相对来说比较繁琐。而&lt;code&gt;InitializingBean/DisposableBean&lt;/code&gt; 这种方式需要单独继承 Spring 的接口实现相关方法。&lt;code&gt;@PostConstruct/@PreDestroy&lt;/code&gt; 这种注解方式使用方式简单，代码清晰，比较推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;另外 &lt;code&gt;ContextStartedEvent/ContextClosedEvent&lt;/code&gt; 这种方式比较适合在一些集成框架使用，比如 Dubbo 2.6.X 优雅停机就是用改机制。&lt;/p&gt;
&lt;p&gt;六、Spring 历史文章推荐&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/07/10/1562768280760.html&quot;&gt;1、Spring 注解编程之注解属性别名与覆盖&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/07/05/1562314284729.html&quot;&gt;2、Spring 注解编程之 AnnotationMetadata&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://studyidea.cn/spring-stereotype-annotations&quot;&gt;3、Spring 注解编程之模式注解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/06/15/1560598141405.html&quot;&gt;4、缘起 Dubbo ，讲讲 Spring XML Schema 扩展机制&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/201911/1419561-20191125230448935-1581960441.png&quot; alt=&quot;其他平台.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 15:05:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>这么多种姿势初始化 Spring Bean，你知道吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/11931557.html</dc:identifier>
</item>
<item>
<title>08 决策树与随机森林 - hp_lake</title>
<link>http://www.cnblogs.com/hp-lake/p/11931462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hp-lake/p/11931462.html</guid>
<description>&lt;h2 id=&quot;决策树之信息论基础&quot;&gt;决策树之信息论基础&lt;/h2&gt;
&lt;h3 id=&quot;认识决策树&quot;&gt;认识决策树&lt;/h3&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;来源： 决策树的思想来源非常朴素，程序设计中的条件分支结构就是if - then 结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;举例：是否见相亲对象&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224307978-1378813736.png&quot; alt=&quot;举例&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;信息的度量和作用&quot;&gt;信息的度量和作用&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;克劳德 .艾尔伍德 .香农：信息论创始人，密西根大学学士，麻省理工学院博士。 1948年发表了划时代论文 - 通信的数学原理，奠定了现代信息论的基础。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;信息的单位： 比特 （bit)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224337501-1014023852.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;举例： 以32支球队争夺世界杯冠军&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果不知道任何球队的信息，每支球队得冠概率相等。&lt;br/&gt;以二分法预测，最少需要使用5次才能预测到准确结果。 5 = log32 (以2为底）&lt;br/&gt;5 = -（1/32log1/32 + 1/32log1/32 + ......)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;开放一些信息，则小于5bit, 如1/6 德国，1/6 巴西， 1/10 中国&lt;br/&gt;5 &amp;gt; -(1/6log1/4 + 1/6log1/4 + ....)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;信息熵：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;“谁是世界杯冠军”的信息量应该比5 bit少， 它的准确信息量应该是：&lt;/li&gt;
&lt;li&gt;H = -(p1logp1 + p2logp2 + p3logp3 +......p32logp32 ) Pi 为第i支球队获胜的概率&lt;/li&gt;
&lt;li&gt;H 的专业术语就是信息熵，单位为比特&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224400933-1252834920.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;决策树的划分以及案例&quot;&gt;决策树的划分以及案例&lt;/h2&gt;
&lt;h3 id=&quot;信息增益&quot;&gt;信息增益&lt;/h3&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义： 特征A对训练数据集D的信息增益g(D,A), 定义为集合D的信息熵H(D)与特征A给定条件下D的信息条件熵H(D|A) 之差，即：&lt;br/&gt;g(D,A) = H（D) - H(D | A)&lt;br/&gt;注： 信息增益表示得知特征 X 的信息而使得类 Y的信息的不确定性减少的程度。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224420161-1875173752.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以不同特征下的信贷成功率为例&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224434728-1170674683.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;H(D) = -(9/15log(9/15) + 6/15log(6/15)) = 0.971 # 以类别进行判断，只有是否两种类别&lt;/li&gt;
&lt;li&gt;gD,年纪） = H(D) - H(D'|年纪） = 0.971 - [1/3H(青年）+ 1/3H(中年）+ 1/3H(老年）] # 三种年纪对应的目标值均占1/3&lt;br/&gt;- H(青年) = -（2/5log(2/5) + 3/5log(3/5)) # 青年类型中，类别的目标值特征为（2/5, 3/5)&lt;br/&gt;- H(中年) = -（2/5log(2/5) + 3/5log(3/5))&lt;br/&gt;- H(老年) = -（4/5log(2/5) + 1/5log(3/5))&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;令A1, A2, A3, A4 分别表示年龄，有工作，有房子和信贷情况4个特征，则对应的信息增益为：&lt;br/&gt;g(D,A1) = H(D) - H(D|A1)&lt;br/&gt;其中，g(D,A2) = 0.324 , g(D,A3) = 0.420 , g(D,A4) = 0.363&lt;br/&gt;相比而言，A3特征（有房子）的信息增益最大，为最有用特征。&lt;br/&gt;所以决策树的实际划分为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1851919/201911/1851919-20191125224449281-1227528460.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;常见决策树使用的算法&quot;&gt;常见决策树使用的算法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ID3&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;信息增益，最大原则&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;C4.5&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;信息增益比最大原则 （信息增益占原始信息量的比值）&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;CART&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;回归树： 平方误差最小&lt;/li&gt;
&lt;li&gt;分类树： &lt;strong&gt;基尼系数&lt;/strong&gt;最小原则 （划分的细致），sklearn默认的划分原则&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sklearn决策树api&quot;&gt;Sklearn决策树API&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;sklearn.tree.DecisionTreeClassifier(criterion='gini', max_depth=None, random_state=None)&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;criterion （标准）: 默认基尼系数，也可以选用信息增益的熵‘entropy’&lt;/li&gt;
&lt;li&gt;max_depth: 树的深度大小&lt;/li&gt;
&lt;li&gt;random_state: 随机数种子&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;决策树结构&lt;br/&gt;sklearn.tree.export_graphviz() 导出DOT文件格式&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;estimator: 估算器&lt;/li&gt;
&lt;li&gt;out_file = &quot;tree.dot&quot; 导出路径&lt;/li&gt;
&lt;li&gt;feature_name = [,] 决策树特征名&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;决策树预测泰坦尼克号案例&quot;&gt;决策树预测泰坦尼克号案例&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
from sklearn.feature_extraction import DictVectorizer
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, export_graphviz

&quot;&quot;&quot;
泰坦尼克数据描述事故后乘客的生存状态，该数据集包括了很多自建旅客名单，提取的数据集中的特征包括：
票的类别，存货，等级，年龄，登录，目的地，房间，票，船，性别。
乘坐等级（1,2,3）是社会经济阶层的代表，其中age数据存在缺失。
&quot;&quot;&quot;


def decision():
    &quot;&quot;&quot;
    决策树对泰坦尼克号进行预测生死
    :return: None
    &quot;&quot;&quot;
    # 1.获取数据
    titan = pd.read_csv('./titanic_train.csv')

    # 2.处理数据，找出特征值和目标值
    x = titan[['Pclass', 'Age', 'Sex']]
    y = titan[['Survived']]
    # print(x)

    # 缺失值处理 （使用平均值填充）
    x['Age'].fillna(x['Age'].mean(), inplace=True)
    print(x)
    # 3.分割数据集到训练集和测试集
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)

    # 4. 进行处理（特征工程) 特征，类别 --&amp;gt; one_hot编码
    dict = DictVectorizer(sparse=False)
    x_train = dict.fit_transform(x_train.to_dict(orient='records'))
    print(dict.get_feature_names())
    x_test = dict.transform(x_test.to_dict(orient='records'))  # 默认一行一行转换成字典
    print(x_train)

    # 5. 用决策树进行预测
    dec = DecisionTreeClassifier()
    dec.fit(x_train, y_train)

    # 预测准确率
    print(&quot;预测的准确率：&quot;, dec.score(x_test, y_test))

    # 导出决策树
    export_graphviz(dec, out_file='./tree.dot', feature_names=['Pclass', 'Age', 'Sex'])
    return None


if __name__ == '__main__':
    decision()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 25 Nov 2019 14:47:00 +0000</pubDate>
<dc:creator>hp_lake</dc:creator>
<og:description>08 决策树与随机森林 决策树之信息论基础 认识决策树 1. 来源： 决策树的思想来源非常朴素，程序设计中的条件分支结构就是if then 结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hp-lake/p/11931462.html</dc:identifier>
</item>
</channel>
</rss>