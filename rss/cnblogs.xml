<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>容器编排系统K8s之ConfigMap、Secret资源 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14194944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14194944.html</guid>
<description>&lt;p&gt;　　前文我们了解了k8s上的pv/pvc/sc资源的使用和相关说明，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14188621.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14188621.html&lt;/a&gt;；今天我们主要来聊一下k8s上配置应用相关话题；&lt;/p&gt;
&lt;p&gt;　　在说configmap和secret资源之前，我们先来回顾下在docker环境下怎么给容器提供配置信息；在docker容器里我们要给容器里的应用提供配置的方式有两种，一种是通过环境变量的方式，把对应容器里跑的程序的某些属性通过一个环境变量传递给容器运行时的环境中去，这样容器启动时，读取对应的环境变量，对应容器里的应用程序就会根据我们传递的环境变量来启动对应的程序，从而实现配置容器里应用程序的目的；这种能够通过环境变量向容器里的应用传递配置的前提是对应应用程序支持；第二种方式就是通过存储卷的方式，把外部的配置文件直接通过存储卷的方式挂载到容器里的应用程序对应位置，对应程序在启动时，通过读取挂载的配置文件，从而实现配置容器里的应用程序的目的；这两种方式都有一个特点，只能在初始化容器时做，一旦一个容器初始化完成以后，修改对应的配置，必须要重新初始化容器，对应配置才能生效；对于k8s上的pod来说，也是类似的逻辑；第一通过环境变量的方式，第二通过存储卷的方式；不同于docker容器，在k8s上一切皆对象，我们需要把对应的配置信息通过对应资源初始化为一个对象，然后通过pod调用对应的对象，从而实现向pod里的容器提供配置，这种能够把配置信息初始化为一个对象并被pod所调用的资源有两个，分别是configmap和secret；configmap和secret资源都是用来向pod提供配置信息的资源，两者用法都很相似，唯一不同的是configmap主要用于提供非敏感配置的资源，secret主要用来提供敏感配置的资源；简单讲就是configmap不加密，secret要对敏感配置做加密处理（严格上不叫加密，它是把对应敏感数据做base64编码处理）；&lt;/p&gt;
&lt;p&gt;　　configmap资源对象的创建和使用&lt;/p&gt;
&lt;p&gt;　　configmap是k8s上的一个标准资源，我们可以通过命令的方式来创建，也可以通过定义资源清单的方式来创建；&lt;/p&gt;
&lt;p&gt;　　configmap通过create命令来创建的语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1]
[--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：configmap对象的创建主要指定对应configmap对象的名称，以及把对应配置信息传递给对应对象；configmap对象支持从命令行直接获取用户给定的kv配置信息，也支持通过读取一个配置文件的内容来获取对应配置；--from-file选项表示，对应配置信息从文件获取，默认我们直接指定一个配置文件的文件名称，它会把文件的基名（不包含路径名称）当作对应配置信息的key，把文件内容当作对应key的值；--from-literal选项表示，对应配置信息从用户在命令给定的key和value获取；&lt;/p&gt;
&lt;p&gt;　　示例：通过命令的方式创建configmap资源对象，并在命令行向其传递kv配置；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create cm configmap-demo --from-literal=key1=value1 --from-literal=key2=value2
configmap/configmap-demo created
[root@master01 ~]# kubectl get cm
NAME               DATA   AGE
configmap-demo     2      8s
kube-root-ca.crt   1      4d2h
[root@master01 ~]# kubectl describe cm configmap-demo
Name:         configmap-demo
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Data
====
key1:
----
value1
key2:
----
value2
Events:  &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：configmap可以简写为cm；--from-literal选项可以多次使用，每次指定一个配置项；从上面的显示看，对应configmap-demo这个对象保存了两个配置，分别是key1=value1、key2=value2；&lt;/p&gt;
&lt;p&gt;　　定义pod应用configmap对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat nginx-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-demo
  namespace: default
  labels:
    app: nginx
    rel: stable
spec:
  containers: 
  - name: nginx-demo
    image: nginx:1.14-alpine
    env:
    - name: FIRST_KEY
      valueFrom:
        configMapKeyRef:
          name: configmap-demo
          key: key1
    - name: SECOND_KEY
      valueFrom: 
        configMapKeyRef:
          name: configmap-demo
          key: key2
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置清单主要在nginx-demo容器里通过configmap向对应容器的运行环境传递两个环境变量；FIRST_KEY这个环境变量的值对应configmap对象里保存的key1这个键的值；SECOND_KEY这个环境变量的值对应configmap对象里的key2这个键的值；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f nginx-demo.yaml
pod/nginx-demo created
[root@master01 ~]# kubectl get pods
NAME         READY   STATUS              RESTARTS   AGE
nginx-demo   0/1     ContainerCreating   0          8s
[root@master01 ~]# kubectl get pods -w
NAME         READY   STATUS              RESTARTS   AGE
nginx-demo   0/1     ContainerCreating   0          17s
nginx-demo   1/1     Running             0          17s
^C[root@master01 ~]# kubectl describe pod nginx-demo
Name:         nginx-demo
Namespace:    default
Priority:     0
Node:         node03.k8s.org/172.16.11.6
Start Time:   Sat, 26 Dec 2020 22:28:10 +0800
Labels:       app=nginx
              rel=stable
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           10.244.3.8
IPs:
  IP:  10.244.3.8
Containers:
  nginx-demo:
    Container ID:   docker://63cf5421b597f9dcd1169193c248091c62183ba18ec565122e242a53045d3112
    Image:          nginx:1.14-alpine
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sat, 26 Dec 2020 22:28:26 +0800
    Ready:          True
    Restart Count:  0
    Environment:
      FIRST_KEY:   &amp;lt;set to the key 'key1' of config map 'configmap-demo'&amp;gt;  Optional: false
      SECOND_KEY:  &amp;lt;set to the key 'key2' of config map 'configmap-demo'&amp;gt;  Optional: false
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-8qs4l (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-8qs4l:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-8qs4l
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  35s   default-scheduler  Successfully assigned default/nginx-demo to node03.k8s.org
  Normal  Pulling    32s   kubelet            Pulling image &quot;nginx:1.14-alpine&quot;
  Normal  Pulled     20s   kubelet            Successfully pulled image &quot;nginx:1.14-alpine&quot; in 12.059556374s
  Normal  Created    20s   kubelet            Created container nginx-demo
  Normal  Started    19s   kubelet            Started container nginx-demo
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面pod的详细信息可以看到在对应Environment字段下多了两个环境变量，分别是FIRST_KEY和SECOND_KEY；&lt;/p&gt;
&lt;p&gt;　　验证：进入对应pod，看看环境变量是否有FIRST_KEY和SECOND_KEY，对应值是否是configmap对象中的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201226223355529-426395747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在对应pod的环境变量中有我们传递的两个环境变量，对应的值也是我们在configmap对象中定义的值；&lt;/p&gt;
&lt;p&gt;　　示例：通过命令的方式创建configmap资源对象，并通过配置文件向其传递配置信息；&lt;/p&gt;
&lt;p&gt;　　准备配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat www-k8s-org.conf
server {
        server_name www.k8s.org;
        listen 80;
        location / {
            root &quot;/www/html&quot;;
        }
}
[root@master01 ~]# cat bbs-k8s-org.conf
server {
        server_name bbs.k8s.org;
        listen 80;
        location / {
            root &quot;/bbs/html&quot;;
        }
}
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建configmap对象，并把上面两个配置文件信息传递给configmap对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create cm nginx-conf --from-file=./www-k8s-org.conf --from-file=bbs-conf=./bbs-k8s-org.conf
configmap/nginx-conf created
[root@master01 ~]# kubectl get cm
NAME               DATA   AGE
configmap-demo     2      47m
kube-root-ca.crt   1      4d2h
nginx-conf         2      11s
[root@master01 ~]# kubectl describe cm nginx-conf
Name:         nginx-conf
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Data
====
bbs-conf:
----
server {
  server_name bbs.k8s.org;
        listen 80;
        location / {
          root &quot;/bbs/html&quot;;
      }
}

www-k8s-org.conf:
----
server {
  server_name www.k8s.org;
        listen 80;
        location / {
          root &quot;/www/html&quot;;
      }
}

Events:  &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到cm对象创建成功，并且成功把对应的配置文件内容当作对应key传递给cm对象了；在创建cm对象时，要使用--from-file选项来指定从文件加载配置信息，如果只指定了文件名，则以文件基名作为对应key，其文件内容作为对应key的值；&lt;/p&gt;
&lt;p&gt;　　定义pod挂载configmap对象中的配置文件信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat nginx-demo2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-demo2
  namespace: default
  labels:
    app: nginx
    rel: stable
spec:
  containers: 
  - name: nginx-demo
    image: nginx:1.14-alpine
    volumeMounts:
    - name: website-conf
      mountPath: /etc/nginx/conf.d/
  volumes:
  - name: website-conf
    configMap:
      name: nginx-conf
      items:
      - key: www-k8s-org.conf
        path: www-k8s-org.conf
        mode: 0644 
      - key: bbs-conf
        path: bbs-k8s-org.conf
        mode: 0644
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置信息表示把configmap对象中的两个配置信息，都以文件的方式挂载到/etc/nginx/conf.d/目录下；configmap类型存储卷它会把configmap中的对象以文件的形式挂载到对应pod；其中spec.volumes.configMap.items.key字段用于指定configmap对象中的key；path用于指定把对应的key映射的文件名称；mode是用于指定对应文件的权限信息；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f nginx-demo2.yaml
pod/nginx-demo2 created
[root@master01 ~]# kubectl get pods -w
NAME          READY   STATUS    RESTARTS   AGE
nginx-demo    1/1     Running   0          47m
nginx-demo2   1/1     Running   0          8s
^C[root@master01 ~]# kubectl describe pod nginx-demo2
Name:         nginx-demo2
Namespace:    default
Priority:     0
Node:         node02.k8s.org/172.16.11.5
Start Time:   Sat, 26 Dec 2020 23:15:29 +0800
Labels:       app=nginx
              rel=stable
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           10.244.2.8
IPs:
  IP:  10.244.2.8
Containers:
  nginx-demo:
    Container ID:   docker://38781957cabf78616c7d826664009c215d3ef7105955e722e5e0104eca636ab0
    Image:          nginx:1.14-alpine
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sat, 26 Dec 2020 23:15:34 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /etc/nginx/conf.d/ from website-conf (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-8qs4l (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  website-conf:
    Type:      ConfigMap (a volume populated by a ConfigMap)
    Name:      nginx-conf
    Optional:  false
  default-token-8qs4l:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-8qs4l
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  21s   default-scheduler  Successfully assigned default/nginx-demo2 to node02.k8s.org
  Normal  Pulled     18s   kubelet            Container image &quot;nginx:1.14-alpine&quot; already present on machine
  Normal  Created    18s   kubelet            Created container nginx-demo
  Normal  Started    17s   kubelet            Started container nginx-demo
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入nginx-demo2容器，看看对应/etc/nginx/conf.d/目录下是否有两个我们指定的配置文件？对应文件内容是否是cm对象中对应key的内容？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl exec -it nginx-demo2 -- /bin/sh
/ # cd /etc/nginx/conf.d/
/etc/nginx/conf.d # ls 
bbs-k8s-org.conf  www-k8s-org.conf
/etc/nginx/conf.d # cat www-k8s-org.conf 
server {
        server_name www.k8s.org;
        listen 80;
        location / {
            root &quot;/www/html&quot;;
        }
}
/etc/nginx/conf.d # cat bbs-k8s-org.conf 
server {
        server_name bbs.k8s.org;
        listen 80;
        location / {
            root &quot;/bbs/html&quot;;
        }
}
/etc/nginx/conf.d # 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在对应pod容器里，在/etc/nginx/conf.d/目录下有两个配置文件，这两个配置文件就是我们定义pod时挂载configmap存储卷定义的文件名称；对应文件内容也是cm对象中保存的文件内容；&lt;/p&gt;
&lt;p&gt;　　测试：修改对应cm资源的配置信息，看看对应引用了该cm资源对象的pod是否会更新配置信息？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201226233901458-1509907376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在线修改cm对象配置信息，可以使用edit命令来修改指定cm对象即可；修改完成后保存退出对应配置就会立即更新到cm对象；以上主要修改了bbs-conf键中的listen 80修改为8080；&lt;/p&gt;
&lt;p&gt;　　验证：查看对应cm对象，看看配置信息是否更新？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201226234015768-1236230512.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应cm对象中的配置信息已经被更新；&lt;/p&gt;
&lt;p&gt;　　验证：看看对应引用该cm对象中的配置信息的pod是否更新了配置？是否重载了对应配置？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201226234243267-741884277.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对应pod配置文件信息已经更新，但是并没有应用新配置；像这种情况我们还得自己手动进入到对应的容器里重载配置；&lt;/p&gt;
&lt;p&gt;　　示例：使用配置清单创建cm对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat configmap-demo.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-cm-demo
  namespace: default
data:
  website-conf: |
    server {
        server_name bbs.k8s.org;
        listen 80;
        location / {
            root &quot;/bbs/html&quot;;
        }
    }
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：cm对象在没有spec字段，却而代之的是data字段，该字段主要用来定义对应kv配置信息；key可以是任意合法名称，对应的值可以是一个文件内容；如果对应内容需要多行来书写，需要在对应的key后面加上 “|”；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f configmap-demo.yaml
configmap/test-cm-demo created
[root@master01 ~]# kubectl get cm
NAME               DATA   AGE
configmap-demo     2      82m
kube-root-ca.crt   1      4d3h
nginx-conf         2      35m
test-cm-demo       1      5s
[root@master01 ~]# kubectl describe cm test-cm-demo
Name:         test-cm-demo
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Data
====
website-conf:
----
server {
    server_name bbs.k8s.org;
    listen 80;
    location / {
        root &quot;/bbs/html&quot;;
    }
}

Events:  &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应的cm对象已经成功被创建，并且里面保存了我们在定义cm时的配置信息；&lt;/p&gt;
&lt;p&gt;　　Secret资源的创建和使用&lt;/p&gt;
&lt;p&gt;　　secret资源和configmap资源的用法都很类似，可以在命令行中通过create命令来创建，也可以通过定义资源清单来创建，其使用方式和configmap也很类似；&lt;/p&gt;
&lt;p&gt;　　secret资源通过create命令来创建的语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create secret
Create a secret using specified subcommand.

Available Commands:
  docker-registry Create a secret for use with a Docker registry
  generic         Create a secret from a local file, directory or literal value
  tls             Create a TLS secret

Usage:
  kubectl create secret [flags] [options]

Use &quot;kubectl &amp;lt;command&amp;gt; --help&quot; for more information about a given command.
Use &quot;kubectl options&quot; for a list of global command-line options (applies to all commands).
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：secret资源有三种类型，分别是docker-registry、generis、tls；其中docker-registry类型主要用来创建保存私有镜像仓库中需要用到的认证信息，比如用户名称，用户密码，仓库地址，用户邮件信息等等；generis类型是比较通用的一种类型，它可以从一个文件中加载信息，也可以从命令行中获取对应的kv配置信息；tls类型主要用来保存证书相关的证书，私钥；在前边我们使用ingress资源时，在应用对应的证书和私钥时，就是通过tls类型的secret资源对象来向其ingress资源对象传递证书和私钥文件信息；&lt;/p&gt;
&lt;p&gt;　　创建docker-registry类型的secret资源的语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create secret docker-registry NAME --docker-username=user --docker-password=password --docker-email=email
[--docker-server=string] [--from-literal=key1=value1] [--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用create命令来创建一个docker-registry类型的secret资源对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create secret docker-registry docker-registry.io --docker-username=qiuhom --docker-password=Admin123.com --docker-server=docker-registry.io
secret/docker-registry.io created
[root@master01 ~]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      18d
docker-registry.io             kubernetes.io/dockerconfigjson        1      15s
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      4d22h
[root@master01 ~]# kubectl describe secret docker-registry.io
Name:         docker-registry.io
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Type:  kubernetes.io/dockerconfigjson

Data
====
.dockerconfigjson:  118 bytes
[root@master01 ~]# kubectl get secret docker-registry.io -o yaml
apiVersion: v1
data:
  .dockerconfigjson: eyJhdXRocyI6eyJkb2NrZXItcmVnaXN0cnkuaW8iOnsidXNlcm5hbWUiOiJxaXVob20iLCJwYXNzd29yZCI6IkFkbWluMTIzLmNvbSIsImF1dGgiOiJjV2wxYUc5dE9rRmtiV2x1TVRJekxtTnZiUT09In19fQ==
kind: Secret
metadata:
  creationTimestamp: &quot;2020-12-26T16:40:56Z&quot;
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:.dockerconfigjson: {}
      f:type: {}
    manager: kubectl-create
    operation: Update
    time: &quot;2020-12-26T16:40:56Z&quot;
  name: docker-registry.io
  namespace: default
  resourceVersion: &quot;392306&quot;
  uid: ac9e425f-95e7-4c34-b161-c621ad2b0a8a
type: kubernetes.io/dockerconfigjson
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面对应secret资源对象中输出为yaml格式的配置中可以看到，对应data字段输出的是一个base64编码后的字符串；其实里面的内容就是我们创建secret资源对象时指定的内容；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]#  echo  eyJhdXRocyI6eyJkb2NrZXItcmVnaXN0cnkuaW8iOnsidXNlcm5hbWUiOiJxaXVob20iLCJwYXNzd29yZCI6IkFkbWluMTIzLmNvbSIsImF1dGgiOiJjV2wxYUc5dE9rRmtiV2x1TVRJekxtTnZiUT09In19fQ== |base64 -d
{&quot;auths&quot;:{&quot;docker-registry.io&quot;:{&quot;username&quot;:&quot;qiuhom&quot;,&quot;password&quot;:&quot;Admin123.com&quot;,&quot;auth&quot;:&quot;cWl1aG9tOkFkbWluMTIzLmNvbQ==&quot;}}}[root@master01 ~]# 
[root@master01 ~]# echo cWl1aG9tOkFkbWluMTIzLmNvbQ== |base64 -d
qiuhom:Admin123.com[root@master01 ~]# 
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到所有把对应字符串交给base64解密后，拿到的就是我们在创建docker-registry类型的secret资源对象传递的选项；&lt;/p&gt;
&lt;p&gt;　　定义pod资源引用docker-registry类型的secret资源对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat test-pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-nginx
  namespace: default
  labels:
    app: nginx
spec:
  imagePullSecrets:
  - name: docker-registry.io
  containers:
  - name: nginx
    image: docker-registry.io/test/nginx:latest
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在定义pod时，如果要从对应私有镜像仓库中拉去镜像，需要用到认证信息，可以使用imagePullSecrets字段来应用对应的secret资源对象来传递仓库的认证信息；在应用配置清单之前，需要将所有节点的/etc/hosts文件和/etc/docker/daemon.json文件更新下；如果是私钥镜像仓库默认docker会认为不安全，需要我们手动指定出来；如果对应域名在互联网上无法正常解析，还需要借助对应的hosts文件将其解析到对应仓库服务器的地址上；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.0.99 time.test.org time-node
192.168.0.41  master01 master01.k8s.org
192.168.0.42  master02 master02.k8s.org
192.168.0.43  master03 master03.k8s.org
192.168.0.44  node01 node01.k8s.org
192.168.0.45  node02 node02.k8s.org
192.168.0.46  node03 node03.k8s.org
192.168.0.47  node04 node04.k8s.org
199.232.28.133 raw.githubusercontent.com
192.168.0.99 docker-registry.io registry
[root@master01 ~]# cat /etc/docker/daemon.json 
{
&quot;registry-mirrors&quot;: [&quot;https://cyr1uljt.mirror.aliyuncs.com&quot;],
&quot;insecure-registries&quot;: [&quot;docker-registry.io&quot;]
}
[root@master01 ~]# scp /etc/docker/daemon.json node01:/etc/docker/
daemon.json                                                                                                100%  112    39.4KB/s   00:00    
[root@master01 ~]# scp /etc/docker/daemon.json node02:/etc/docker/
daemon.json                                                                                                100%  112    67.3KB/s   00:00    
[root@master01 ~]# scp /etc/docker/daemon.json node03:/etc/docker/
daemon.json                                                                                                100%  112     8.9KB/s   00:00    
[root@master01 ~]# scp /etc/docker/daemon.json node04:/etc/docker/
daemon.json                                                                                                100%  112    69.8KB/s   00:00    
[root@master01 ~]# scp /etc/hosts node01:/etc/
hosts                                                                                                      100%  541   477.4KB/s   00:00    
[root@master01 ~]# scp /etc/hosts node02:/etc/
hosts                                                                                                      100%  541   225.7KB/s   00:00    
[root@master01 ~]# scp /etc/hosts node03:/etc/
hosts                                                                                                      100%  541   217.3KB/s   00:00    
[root@master01 ~]# scp /etc/hosts node04:/etc/
hosts                                                                                                      100%  541   149.4KB/s   00:00    
[root@master01 ~]# ssh node01 'systemctl restart docker'
[root@master01 ~]# ssh node02 'systemctl restart docker' 
[root@master01 ~]# ssh node03 'systemctl restart docker' 
[root@master01 ~]# ssh node04 'systemctl restart docker' 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：有关docker私有镜像仓库harbor的搭建过程可以参考本人博客：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13061984.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13061984.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　应用配置清单，看看对应的pod是否能够启动成功？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f test-pod-demo.yaml
pod/test-nginx created
[root@master01 ~]# kubectl get pods -w
NAME         READY   STATUS    RESTARTS   AGE
test-nginx   1/1     Running   0          6s
^C[root@master01 ~]# kubectl describe pod test-nginx
Name:         test-nginx
Namespace:    default
Priority:     0
Node:         node02.k8s.org/192.168.0.45
Start Time:   Sun, 27 Dec 2020 01:04:18 +0800
Labels:       app=nginx
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           10.244.2.107
IPs:
  IP:  10.244.2.107
Containers:
  nginx:
    Container ID:   docker://9062506afc2fc002102754ee8b2205732ddb740f7f86b870131cb582fc3b9f52
    Image:          docker-registry.io/test/nginx:latest
    Image ID:       docker-pullable://docker-registry.io/test/nginx@sha256:0efad4d09a419dc6d574c3c3baacb804a530acd61d5eba72cb1f14e1f5ac0c8f
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 27 Dec 2020 01:04:24 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xvd4c (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-xvd4c:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xvd4c
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  27s   default-scheduler  Successfully assigned default/test-nginx to node02.k8s.org
  Normal  Pulling    26s   kubelet            Pulling image &quot;docker-registry.io/test/nginx:latest&quot;
  Normal  Pulled     21s   kubelet            Successfully pulled image &quot;docker-registry.io/test/nginx:latest&quot; in 4.835022509s
  Normal  Created    21s   kubelet            Created container nginx
  Normal  Started    21s   kubelet            Started container nginx
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod能够正常到指定的私钥仓库中把镜像托下来，并启动成功；&lt;/p&gt;
&lt;p&gt;　　使用create命令创建generic类型的secret资源对象语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create secret generic NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1]
[--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用create命令创建generic类型的secret资源对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create secret generic mysql-auth --from-literal=username=root --from-literal=passwd=admin
secret/mysql-auth created
[root@master01 ~]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      18d
docker-registry.io             kubernetes.io/dockerconfigjson        1      37m
mysql-auth                     Opaque                                2      13s
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      4d23h
[root@master01 ~]# kubectl describe secret mysql-auth
Name:         mysql-auth
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Type:  Opaque

Data
====
passwd:    5 bytes
username:  4 bytes
[root@master01 ~]# kubectl get secret mysql-auth -o yaml
apiVersion: v1
data:
  passwd: YWRtaW4=
  username: cm9vdA==
kind: Secret
metadata:
  creationTimestamp: &quot;2020-12-26T17:18:08Z&quot;
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:passwd: {}
        f:username: {}
      f:type: {}
    manager: kubectl-create
    operation: Update
    time: &quot;2020-12-26T17:18:08Z&quot;
  name: mysql-auth
  namespace: default
  resourceVersion: &quot;396175&quot;
  uid: a22e27a8-b9f7-405a-b503-ac546da0b4cd
type: Opaque
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：generic类型的secret资源的创建和configmap很类似，它可以接受从命令行中用户手动传递对应的配置信息，也支持从配置文件中获取对应的配置信息；&lt;/p&gt;
&lt;p&gt;　　创建pod资源，引用generic类型的secret类型的资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat mysql-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mysql-demo
  namespace: default
  labels:
    app: mysql
spec:
  containers:
  - name: mysql-demo
    image: mysql:5.6
    env:
    - name: MYSQL_ROOT_PASSWORD
      valueFrom:
        secretKeyRef:
          name: mysql-auth
          key: passwd
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述清单定义了运行一个pod，其内部跑一个mysql:5.6的容器；对应使用环境变量的方式向mysql-demo容器传递了一个MYSQL_ROOT_PASSWORD的环境变量，对应环境变量的值为generic类型的secret资源对象中的passwd这个键的值；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f mysql-demo.yaml
pod/mysql-demo created
[root@master01 ~]# kubectl get pods -w
NAME         READY   STATUS              RESTARTS   AGE
mysql-demo   0/1     ContainerCreating   0          7s
test-nginx   1/1     Running             0          29m
mysql-demo   1/1     Running             0          32s
^C[root@master01 ~]# kubectl describe pod mysql-demo
Name:         mysql-demo
Namespace:    default
Priority:     0
Node:         node03.k8s.org/192.168.0.46
Start Time:   Sun, 27 Dec 2020 01:34:10 +0800
Labels:       app=mysql
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           10.244.3.106
IPs:
  IP:  10.244.3.106
Containers:
  mysql-demo:
    Container ID:   docker://97d88917cbc8e304af120e83a859814248cd915da7d2056643b3f29f61c2cb7b
    Image:          mysql:5.6
    Image ID:       docker-pullable://mysql@sha256:51d59639d9a864ec302008c81d6909c532eff8b946993ef6448c086ba7917e82
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 27 Dec 2020 01:34:42 +0800
    Ready:          True
    Restart Count:  0
    Environment:
      MYSQL_ROOT_PASSWORD:  &amp;lt;set to the key 'passwd' in secret 'mysql-auth'&amp;gt;  Optional: false
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xvd4c (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-xvd4c:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xvd4c
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  50s   default-scheduler  Successfully assigned default/mysql-demo to node03.k8s.org
  Normal  Pulling    49s   kubelet            Pulling image &quot;mysql:5.6&quot;
  Normal  Pulled     18s   kubelet            Successfully pulled image &quot;mysql:5.6&quot; in 30.561208525s
  Normal  Created    18s   kubelet            Created container mysql-demo
  Normal  Started    18s   kubelet            Started container mysql-demo
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应容器已经正常处于running状态，并在其详细信息中看到对应环境变量MYSQL_ROOT_PASSWORD引用secret中的passwd键；&lt;/p&gt;
&lt;p&gt;　　测试：进入mysql-demo的交互式接口，看看使用创建secret时使用的passwd键传递的密码是否可以正常登录到mysql系统？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl exec -it mysql-demo -- /bin/sh
# mysql
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
# mysql -padmin
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.6.50 MySQL Community Server (GPL)

Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

mysql&amp;gt; exit
Bye
# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到直接在容器交互式接口直接不使用密码是不能正常登录到mysql数据库；使用正确的密码后能够正常进入mysql；其实我们在交互式接口上查看环境变量也能查看到对应的环境变量的信息；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201227014111534-1955915718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用create命令创建tls类型的secret资源对象语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create secret tls NAME --cert=path/to/cert/file --key=path/to/key/file
[--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用create命令创建tls类型的secret资源对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl create secret tls test-tls --cert=./tls.crt --key=./tls.key
secret/test-tls created
[root@master01 manifests]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      18d
docker-registry.io             kubernetes.io/dockerconfigjson        1      65m
mysql-auth                     Opaque                                2      28m
test-tls                       kubernetes.io/tls                     2      10s
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      4d23h
[root@master01 manifests]# kubectl describe secret test-tls
Name:         test-tls
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Type:  kubernetes.io/tls

Data
====
tls.crt:  1285 bytes
tls.key:  1679 bytes
[root@master01 manifests]# kubectl get secret test-tls -o yaml
apiVersion: v1
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURoekNDQW0rZ0F3SUJBZ0lKQU4wS2RzTWpIMlNYTUEwR0NTcUdTSWIzRFFFQkN3VUFNRm94Q3pBSkJnTlYKQkFZVEFrTk9NUkF3RGdZRFZRUUlEQWRUYVVOb2RXRnVNUkl3RUFZRFZRUUhEQWxIZFdGdVoxbDFZVzR4RFRBTApCZ05WQkFvTUJGUmxjM1F4RmpBVUJnTlZCQU1NRFhkM2R5NXRlV0Z3Y0M1amIyMHdIaGNOTWpBeE1qSXhNVGMxCk5ETTNXaGNOTXpBeE1qRTVNVGMxTkRNM1dqQmFNUXN3Q1FZRFZRUUdFd0pEVGpFUU1BNEdBMVVFQ0F3SFUybEQKYUhWaGJqRVNNQkFHQTFVRUJ3d0pSM1ZoYm1kWmRXRnVNUTB3Q3dZRFZRUUtEQVJVWlhOME1SWXdGQVlEVlFRRApEQTEzZDNjdWJYbGhjSEF1WTI5dE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBCnV0ek51djNFd0JRRjAvaHY4T2M3eGZzVUZIRG80cm5nYlV5Ym1UTVd6WkVONER3QTlCeVhvUk8rMUFOR0h0cXMKTTk4MUpJM3N5R21uMTV1Q1N5YTRlMjNIOEZrRVcveFh4VzNVMXZoRmxpRlB3NFgxM0ZRTno5TGJqUDdmbHBOTwpRRzZKVm1nYUNyZFp1TlFnbzFJSG1ocmFFWHV6VStTVkYzVXh1MHd3OUNRZmsxcG82N0NiN0FNRlRMa25QbUhJCndpbHpEK1dYeUtyV3NjRDBQZ2gzTTV1QnBENTJuNURsOHpWZDJiSFlSZGdIUm90dTJTTnBwcmtlVjlzSGxlamUKazVlMDRHZHNhV2pkaGJwMDcrWnBYMmhLVkhBMWJYUnplWG03TjE4ZTQ2elNPaEdydW0xYUtEZUNGd1BPbFZhUAovdEhrbmxleVM0NGNqTFk5Q21CSS93SURBUUFCbzFBd1RqQWRCZ05WSFE0RUZnUVVzU1N0OVJSZ083OFRCclBPCjR3UndVMGJlWlBJd0h3WURWUjBqQkJnd0ZvQVVzU1N0OVJSZ083OFRCclBPNHdSd1UwYmVaUEl3REFZRFZSMFQKQkFVd0F3RUIvekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBWEJQNUx1ZzVlNGJUbVl3Q2w0ckIyK2k4VWx5dQpZbmZrdmRKQjgvWlFKWXNEdGgwQ0xGWEdHeWdId1ZoWWRYT01jSnB3MkNVbUNsakVwUk9Cb09kNGpvd0pBTHBJClhxUHMvQmJ2aDNCd3B6OFd3S3c1cUd6NmRDTGNmU2ZMV0Q3dkRBVVd2c3UvV1VGQjVpVVlKcmcrRlpwNnBQVTcKeFdpMUtic3piM3BmNkorWFJ0MlpZeDVYMlpHdTQyb2FmcDd3Z1hzS0l0UG9nNmdjQ0d6Z1JXQUFzcHhPOFFRYwpKY1dOZXYwSFAzdVViWG9SbUV2S1NXY3dTcnlhZTVuUGlaRjVkaCtHRys2TktpdnJBR0RkMTVzZzlGZHkzVDl6CkRkWVVmTkhGYlU5TUh6djE1NEtxNFVVZ1ZSbTk2Y2krdFhuYUdtMzJNcVFkZVUvcVVReEtnZ2VMMmc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
  tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBdXR6TnV2M0V3QlFGMC9odjhPYzd4ZnNVRkhEbzRybmdiVXlibVRNV3paRU40RHdBCjlCeVhvUk8rMUFOR0h0cXNNOTgxSkkzc3lHbW4xNXVDU3lhNGUyM0g4RmtFVy94WHhXM1UxdmhGbGlGUHc0WDEKM0ZRTno5TGJqUDdmbHBOT1FHNkpWbWdhQ3JkWnVOUWdvMUlIbWhyYUVYdXpVK1NWRjNVeHUwd3c5Q1FmazFwbwo2N0NiN0FNRlRMa25QbUhJd2lsekQrV1h5S3JXc2NEMFBnaDNNNXVCcEQ1Mm41RGw4elZkMmJIWVJkZ0hSb3R1CjJTTnBwcmtlVjlzSGxlamVrNWUwNEdkc2FXamRoYnAwNytacFgyaEtWSEExYlhSemVYbTdOMThlNDZ6U09oR3IKdW0xYUtEZUNGd1BPbFZhUC90SGtubGV5UzQ0Y2pMWTlDbUJJL3dJREFRQUJBb0lCQVFDSmxsRUpFUmRRa3Eyago0UGFUZTc4Z1RIb0JmdzJLKzNBTEtuQWJRbW5VM0t4SjRnU1Z1WVBQLzVqdnhLVlp6SXNrK29ISHM1U1lFR3VjCkxvMm1SaEZxR0hBeVFXa2JUZGRXc0VNYU1kNFM1OTR5U2kyNG1FOC9LYk9zd25IaERmOTlJNmFONzhMVkJ5SFMKSEtjWGVpdk14VjZ4cHRKb3dCTWpIWkNMcDFNWVAwbW94ZGNxOFljQlhxYjJIL1plWUUyM0Z2U1pZclRIWHpUQQpIRjhUSUY3QTA4cVpiTHRJVXVHUUkyZ3JobS95TzRmN005NHJpWDI5Z29zUkZadVpRTUY2enRTUWxRRCs4QU8xCnduNGJ2MWdnNHZXaFcycElIcnE1MG5xZkdIR0tRSHBSeU5SbWV4aEliUzJNbzB5UmkzRFNhN2ZSdGhQU0VuWFMKTGdXTFkyaXhBb0dCQU8yd280MjZhVmlDWmUrY3RmNk9YaklQSC9zMGJyNUpjSk92WEgzZHRxeldHdVVlSlRyUwpiWVg4V0oyWXA5c3VPSTk4dUFSRkY4RWNvc25CdzNjSER4NEZ4Skp4blMrUm1ZcGlnNmtNUFVqbmh1MENxcE9HCktPYTV6MVgvUnR0SVRhMlJHeHkxdjdHMHlQTHA3NVhhQTUrYjMvM1RKMDY0ZzQzMThadjZNMEEzQW9HQkFNbEIKMG9YY1BRcGpWdVZWRVFvMmhjUVZOSWw4Qno2SjErQ0o3WUVKZGhLekxYdVdteithMVhtQ0xQcW9wKzVaM0VqMwpiMTFSanRKSHdzQUJ4eGV4QjZDUTlyZ3ZNYk53bitqQkxINmFSRTJaRkZsK0k0T243NGNKbE1la2UrUTB2bEhpCmtNNE94dGZDYkZDNWoyYVowOFJ2SDJob0p5MG9ubEpuWjQvM3d3bDVBb0dBU0FSNk9jb2VleXZmV08rQmtTUnYKMC9rVE5walhhUjUxVnJvT2F6Q1BWZVQxZHpCZ0ZXZUd1YzhReG9kbmJKaWZtSkl3YTFMSDlNSUpiTm9oc0dIYQpLYjJUcHM5MzBkN3F4Nnc3dWkrMExlL0F5UFZDMjdvTmtJTUNHRXRsbTdGWG45eFVlNmx4OEpVWFFjcXh4aFN0CmZtSExSMnYvLy9FV0l5QSsyWVRBbkpjQ2dZQVFnTU5Ba3NTMm0xcSt4M0QwUTNCSW1leUs4WTZ1aENNZG1ISFAKU1BWVHB6bXRqcllBU3pRQ0dMaVRmVXozOElwdHVVeDZmSHVYcHFiRGsrRzlnWmk4ZythWFI5ZHRmV2kvYjBlMAp3ZldqMzArWjN3d09lYkRjZzk2ZFdGR0lid0xFT0Mzamw3YWFicWp2SGFneW81Nkgxd3plUk53aGlka2hyTFVEClN5L0ZFUUtCZ1FDU2dSaCtzaFJYdFBzV2VPVi92c1pVVEY0YTRSejBaMmhoNFpVNnpLU1M2bzRPZlZiSHJjNTQKQ3FIZVpHTEc5ampLQm15WEZ2cE5rdk9qZnhvOUVZSklrODAwRlZybzFWbU4xcFVNUmphK25LSWpveFlBU2ZQdApVWjBVcGJyTFk4MVdsYUZPWStPQmFFdzhpVXZwb2E1S2VLSXVZOVVDU3lLOUR4YTRIZXI0dFE9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
kind: Secret
metadata:
  creationTimestamp: &quot;2020-12-26T17:46:00Z&quot;
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:tls.crt: {}
        f:tls.key: {}
      f:type: {}
    manager: kubectl-create
    operation: Update
    time: &quot;2020-12-26T17:46:00Z&quot;
  name: test-tls
  namespace: default
  resourceVersion: &quot;399079&quot;
  uid: 67fb9062-56b4-4900-bab6-45ea35b75a09
type: kubernetes.io/tls
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：创建tls类型的secret资源对象时，只需要指定其名称和对应的证书和私钥文件即可；这里需要注意一点，不管外部证书和私钥是什么名字，在tls类型的secret资源对象中都叫tls.crt和tls.key；它会自动映射为这两个名字；&lt;/p&gt;
&lt;p&gt;　　示例：定义pod挂载secret存储卷&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat mount-secretvolume.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: default
spec:
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    volumeMounts:
    - name: test-tls-secret
      mountPath: /etc/nginx/cert/
  volumes:
  - name: test-tls-secret
    secret:
      secretName: test-tls
      items:
      - key: tls.crt
        path: test.crt
        mode: 0400
      - key: tls.key
        path: test.key
        mode: 0400
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f mount-secretvolume.yaml
pod/test-pod created
[root@master01 ~]# kubectl get pods -w
NAME         READY   STATUS    RESTARTS   AGE
mysql-demo   1/1     Running   0          23m
test-nginx   1/1     Running   0          53m
test-pod     1/1     Running   0          6s
^C[root@master01 ~]# kubectl describe pod test-pod
Name:         test-pod
Namespace:    default
Priority:     0
Node:         node04.k8s.org/192.168.0.47
Start Time:   Sun, 27 Dec 2020 01:57:54 +0800
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Status:       Running
IP:           10.244.4.25
IPs:
  IP:  10.244.4.25
Containers:
  nginx:
    Container ID:   docker://4ec25999d3813cebe9c7a78c3ffa6b5d282f730c56c88454b08c08b1e7f7a3a7
    Image:          nginx:1.14-alpine
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 27 Dec 2020 01:57:55 +0800
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /etc/nginx/cert/ from test-tls-secret (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-xvd4c (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  test-tls-secret:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  test-tls
    Optional:    false
  default-token-xvd4c:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-xvd4c
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  20s   default-scheduler  Successfully assigned default/test-pod to node04.k8s.org
  Normal  Pulled     19s   kubelet            Container image &quot;nginx:1.14-alpine&quot; already present on machine
  Normal  Created    19s   kubelet            Created container nginx
  Normal  Started    19s   kubelet            Started container nginx
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应容器已经将对应secret存储卷以读写方式挂载至/etc/nginx/cert/目录；&lt;/p&gt;
&lt;p&gt;　　验证：进入test-pod交互式接口，看看对应目录下是否有对应的文件呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl exec -it test-pod -- /bin/sh
/ # cd /etc/nginx/
/etc/nginx # ls
cert                    fastcgi_params.default  modules                 uwsgi_params
conf.d                  koi-utf                 nginx.conf              uwsgi_params.default
fastcgi.conf            koi-win                 nginx.conf.default      win-utf
fastcgi.conf.default    mime.types              scgi_params
fastcgi_params          mime.types.default      scgi_params.default
/etc/nginx # ls cert
test.crt  test.key
/etc/nginx # cat cert/test.crt 
-----BEGIN CERTIFICATE-----
MIIDhzCCAm+gAwIBAgIJAN0KdsMjH2SXMA0GCSqGSIb3DQEBCwUAMFoxCzAJBgNV
BAYTAkNOMRAwDgYDVQQIDAdTaUNodWFuMRIwEAYDVQQHDAlHdWFuZ1l1YW4xDTAL
BgNVBAoMBFRlc3QxFjAUBgNVBAMMDXd3dy5teWFwcC5jb20wHhcNMjAxMjIxMTc1
NDM3WhcNMzAxMjE5MTc1NDM3WjBaMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHU2lD
aHVhbjESMBAGA1UEBwwJR3VhbmdZdWFuMQ0wCwYDVQQKDARUZXN0MRYwFAYDVQQD
DA13d3cubXlhcHAuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
utzNuv3EwBQF0/hv8Oc7xfsUFHDo4rngbUybmTMWzZEN4DwA9ByXoRO+1ANGHtqs
M981JI3syGmn15uCSya4e23H8FkEW/xXxW3U1vhFliFPw4X13FQNz9LbjP7flpNO
QG6JVmgaCrdZuNQgo1IHmhraEXuzU+SVF3Uxu0ww9CQfk1po67Cb7AMFTLknPmHI
wilzD+WXyKrWscD0Pgh3M5uBpD52n5Dl8zVd2bHYRdgHRotu2SNpprkeV9sHleje
k5e04GdsaWjdhbp07+ZpX2hKVHA1bXRzeXm7N18e46zSOhGrum1aKDeCFwPOlVaP
/tHknleyS44cjLY9CmBI/wIDAQABo1AwTjAdBgNVHQ4EFgQUsSSt9RRgO78TBrPO
4wRwU0beZPIwHwYDVR0jBBgwFoAUsSSt9RRgO78TBrPO4wRwU0beZPIwDAYDVR0T
BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAXBP5Lug5e4bTmYwCl4rB2+i8Ulyu
YnfkvdJB8/ZQJYsDth0CLFXGGygHwVhYdXOMcJpw2CUmCljEpROBoOd4jowJALpI
XqPs/Bbvh3Bwpz8WwKw5qGz6dCLcfSfLWD7vDAUWvsu/WUFB5iUYJrg+FZp6pPU7
xWi1Kbszb3pf6J+XRt2ZYx5X2ZGu42oafp7wgXsKItPog6gcCGzgRWAAspxO8QQc
JcWNev0HP3uUbXoRmEvKSWcwSryae5nPiZF5dh+GG+6NKivrAGDd15sg9Fdy3T9z
DdYUfNHFbU9MHzv154Kq4UUgVRm96ci+tXnaGm32MqQdeU/qUQxKggeL2g==
-----END CERTIFICATE-----
/etc/nginx # cat cert/test.key 
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAutzNuv3EwBQF0/hv8Oc7xfsUFHDo4rngbUybmTMWzZEN4DwA
9ByXoRO+1ANGHtqsM981JI3syGmn15uCSya4e23H8FkEW/xXxW3U1vhFliFPw4X1
3FQNz9LbjP7flpNOQG6JVmgaCrdZuNQgo1IHmhraEXuzU+SVF3Uxu0ww9CQfk1po
67Cb7AMFTLknPmHIwilzD+WXyKrWscD0Pgh3M5uBpD52n5Dl8zVd2bHYRdgHRotu
2SNpprkeV9sHlejek5e04GdsaWjdhbp07+ZpX2hKVHA1bXRzeXm7N18e46zSOhGr
um1aKDeCFwPOlVaP/tHknleyS44cjLY9CmBI/wIDAQABAoIBAQCJllEJERdQkq2j
4PaTe78gTHoBfw2K+3ALKnAbQmnU3KxJ4gSVuYPP/5jvxKVZzIsk+oHHs5SYEGuc
Lo2mRhFqGHAyQWkbTddWsEMaMd4S594ySi24mE8/KbOswnHhDf99I6aN78LVByHS
HKcXeivMxV6xptJowBMjHZCLp1MYP0moxdcq8YcBXqb2H/ZeYE23FvSZYrTHXzTA
HF8TIF7A08qZbLtIUuGQI2grhm/yO4f7M94riX29gosRFZuZQMF6ztSQlQD+8AO1
wn4bv1gg4vWhW2pIHrq50nqfGHGKQHpRyNRmexhIbS2Mo0yRi3DSa7fRthPSEnXS
LgWLY2ixAoGBAO2wo426aViCZe+ctf6OXjIPH/s0br5JcJOvXH3dtqzWGuUeJTrS
bYX8WJ2Yp9suOI98uARFF8EcosnBw3cHDx4FxJJxnS+RmYpig6kMPUjnhu0CqpOG
KOa5z1X/RttITa2RGxy1v7G0yPLp75XaA5+b3/3TJ064g4318Zv6M0A3AoGBAMlB
0oXcPQpjVuVVEQo2hcQVNIl8Bz6J1+CJ7YEJdhKzLXuWmz+a1XmCLPqop+5Z3Ej3
b11RjtJHwsABxxexB6CQ9rgvMbNwn+jBLH6aRE2ZFFl+I4On74cJlMeke+Q0vlHi
kM4OxtfCbFC5j2aZ08RvH2hoJy0onlJnZ4/3wwl5AoGASAR6OcoeeyvfWO+BkSRv
0/kTNpjXaR51VroOazCPVeT1dzBgFWeGuc8QxodnbJifmJIwa1LH9MIJbNohsGHa
Kb2Tps930d7qx6w7ui+0Le/AyPVC27oNkIMCGEtlm7FXn9xUe6lx8JUXQcqxxhSt
fmHLR2v///EWIyA+2YTAnJcCgYAQgMNAksS2m1q+x3D0Q3BImeyK8Y6uhCMdmHHP
SPVTpzmtjrYASzQCGLiTfUz38IptuUx6fHuXpqbDk+G9gZi8g+aXR9dtfWi/b0e0
wfWj30+Z3wwOebDcg96dWFGIbwLEOC3jl7aabqjvHagyo56H1wzeRNwhidkhrLUD
Sy/FEQKBgQCSgRh+shRXtPsWeOV/vsZUTF4a4Rz0Z2hh4ZU6zKSS6o4OfVbHrc54
CqHeZGLG9jjKBmyXFvpNkvOjfxo9EYJIk800FVro1VmN1pUMRja+nKIjoxYASfPt
UZ0UpbrLY81WlaFOY+OBaEw8iUvpoa5KeKIuY9UCSyK9Dxa4Her4tQ==
-----END RSA PRIVATE KEY-----
/etc/nginx # 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在test-pod容器对应的/etc/nginx/目录下自动创建了一个cert目录，并在其目录下看到有两个证书文件，一个名为test.crt，一个名为test.key；这两个名字都是我们在pod资源清单中指定的名称；&lt;/p&gt;
&lt;p&gt;　　示例：使用资源清单创建secret资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat test-secret.yaml
apiVersion: v1
kind: Secret
metadata: 
  name: test-secret-demo
  namespace: default
data:
  name: cWl1aG9tCg==
  passwd: YWRtaW4xMjMuY29tCg==
type: Opaque 
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用资源清单方式创建secret时，data字段是定义对应的kv配置信息，需要事先将其对应的值转换为base64编码；type是用来指定对应secret的类型，这个字段有四个值，分别是Opaque 、kubernetes.io/dockerconfigjson、kubernetes.io/tls、kubernetes.io/service-account-token；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f test-secret.yaml 
secret/test-secret-demo created
[root@master01 ~]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      18d
docker-registry.io             kubernetes.io/dockerconfigjson        1      107m
mysql-auth                     Opaque                                2      70m
test-secret-demo               Opaque                                2      19s
test-tls                       kubernetes.io/tls                     2      42m
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      5d
[root@master01 ~]# kubectl describe secret test-secret-demo
Name:         test-secret-demo
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Type:  Opaque

Data
====
name:    7 bytes
passwd:  13 bytes
[root@master01 ~]#kubectl get secret test-secret-demo -o yaml           
apiVersion: v1
data:
  name: cWl1aG9tCg==
  passwd: YWRtaW4xMjMuY29tCg==
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:{&quot;name&quot;:&quot;cWl1aG9tCg==&quot;,&quot;passwd&quot;:&quot;YWRtaW4xMjMuY29tCg==&quot;},&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;test-secret-demo&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;type&quot;:&quot;Opaque&quot;}
  creationTimestamp: &quot;2020-12-26T18:28:19Z&quot;
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:name: {}
        f:passwd: {}
      f:metadata:
        f:annotations:
          .: {}
          f:kubectl.kubernetes.io/last-applied-configuration: {}
      f:type: {}
    manager: kubectl-client-side-apply
    operation: Update
    time: &quot;2020-12-26T18:28:19Z&quot;
  name: test-secret-demo
  namespace: default
  resourceVersion: &quot;403480&quot;
  uid: 95aecff5-7f78-4f16-908f-61deb56f8c53
type: Opaque
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用stringData字段来指定数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat test1-secret.yaml
apiVersion: v1
kind: Secret
metadata: 
  name: test-secret-demo1
  namespace: default
stringData:
  name: qiuhom
  passwd: admin123.com
type: Opaque 
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用stringData字段来指定kv配置信息，可以不用将对应数据编码为base64格式；它会在创建secret时，自动将其转化为base64编码格式，存放在data字段中；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f test1-secret.yaml
secret/test-secret-demo1 created
[root@master01 ~]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      18d
docker-registry.io             kubernetes.io/dockerconfigjson        1      117m
mysql-auth                     Opaque                                2      79m
test-secret-demo               Opaque                                2      9m40s
test-secret-demo1              Opaque                                2      11s
test-tls                       kubernetes.io/tls                     2      51m
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      5d
[root@master01 ~]# kubectl get secret test-secret-demo1 -o yaml
apiVersion: v1
data:
  name: cWl1aG9t
  passwd: YWRtaW4xMjMuY29t
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;name&quot;:&quot;test-secret-demo1&quot;,&quot;namespace&quot;:&quot;default&quot;},&quot;stringData&quot;:{&quot;name&quot;:&quot;qiuhom&quot;,&quot;passwd&quot;:&quot;admin123.com&quot;},&quot;type&quot;:&quot;Opaque&quot;}
  creationTimestamp: &quot;2020-12-26T18:37:48Z&quot;
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:name: {}
        f:passwd: {}
      f:metadata:
        f:annotations:
          .: {}
          f:kubectl.kubernetes.io/last-applied-configuration: {}
      f:type: {}
    manager: kubectl-client-side-apply
    operation: Update
    time: &quot;2020-12-26T18:37:48Z&quot;
  name: test-secret-demo1
  namespace: default
  resourceVersion: &quot;404463&quot;
  uid: 718d1306-43af-40cb-9a56-6177205be5c4
type: Opaque
[root@master01 ~]# kubectl describe secret test-secret-demo1    
Name:         test-secret-demo1
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;

Type:  Opaque

Data
====
name:    6 bytes
passwd:  12 bytes
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：stringData字段不会被apiserver输出，它将stringData字段信息以base64编码格式存储在data字段中给予显示；但是将对应secret输出为yaml格式时，在对应的注解信息中能够看到对应stringData的信息；&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 19:04:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了k8s上的pv/pvc/sc资源的使用和相关说明，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/14188621.html；今天我们主要来聊一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14194944.html</dc:identifier>
</item>
<item>
<title>Android基础工具移植说明 - OnlyTime_唯有时光</title>
<link>http://www.cnblogs.com/Dreaming-in-Gottingen/p/14195135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreaming-in-Gottingen/p/14195135.html</guid>
<description>&lt;p&gt;&lt;span&gt;早前开展的&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/Dreaming-in-Gottingen/p/12052291.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;计划&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;因各种杂事而泡汤，而当遇到了具体任务后，在压力下花了两个多周的业余时间把这件事完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我的引以为傲的&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Dreaming-in-Gottingen/Mercury-Project&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Mercury-Project&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，它的核心目标是移植一些Android底层轮子到Linux平台上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 为什么要做这件事？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Android的SDK是一个大而全的东西，有很多工具可供移植和使用，例如，安卓的MPEG4Writer，MPEG2TSWriter，OpenMAX、MediaCodec等，实现的很优美和完善。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我常常想学习这些子模块是如何实现的，那么就需要有一套SDK环境，修改代码编译后，再将so库放到手机中跑，但是这种调试方式有些缺陷：依赖手机硬件、编译时间漫长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此，产生了这种想法：如何将这些基础工具进行跨平台化，移植到通用的Linux平台上？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 移植基础库的先后顺序性是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果想做一个Linux平台的记录仪方案，那么就需要用到封装模块（muxer），怎么搞这个呢？手撸一个稳定、兼容性较强的ts_muxer，没有十天时间肯定搞不定，那么一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;捷径是移植现有成熟的方案，&lt;/span&gt;&lt;span&gt;例如从FFmpeg的libavformat中抄过来，或者移植Android的MPEG2TSWriter（这个模块其实是muxer+writer），抄FFmpeg的较容易，但是抄Android&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的不是那么容易，因为依赖Andorid的底层基础库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，MPEG2TSWriter模块，用到了管理类对象的sp/RefBase，用到了消息/反射机制ALooper/AMessage/AHander。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前者是安卓大厦的根基之一（实现路径：system/core/libutils），任何native层开发几乎都离不开它；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后者是native层中多媒体系统子模块开发的基础工具（路径为&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Dreaming-in-Gottingen/p/frameworks/av/media/libstagefright/foundation/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这个&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;：frameworks/av/media/libstagefright/foundation/），从名字foundation中也可以看到端倪，这里要补充一点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个foundation其实又是依赖libutils的，&lt;/span&gt;&lt;span&gt;它是对libutils的更上一层的封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此，可以初步总结出，其依赖链：MPEG2TSWriter -&amp;gt; foundation -&amp;gt; libutils。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　libutils又依赖什么？Bionic！这个是什么呢？是Android版的标准C库，等价于通用Linux平台的glibc库。二者都是C标准库的不同实现方式，其提供的接口、功能行为在不同平台上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;都是一致的，&lt;/span&gt;&lt;span&gt;因此移植工作可以在libutils这一层次上结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因袭，结论是：移植的先后顺序，先libutils，再foundation，最后MPEG2TSWriter。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. Android为什么搞这么复杂？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　确实是比较复杂，但层次性非常好！一个东西流行必有其内部脊髓所在！这也是安卓生态圈繁荣的根源吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　软件开发，一个非常重要的概念，就是分层，这个跟其他行业类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，我D目前收割群众的主要方式——房地产行业。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;盖房子，其实也分很多层次，最底层是最廉价，也是最容易被人忽略的，也是最重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　盖房子最底层是什么呢？做砖头这一古老行业！再往上一层是批发经销砖头的，再往上是施工工程队。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　施工工程队可以对比于软件开发的上层，它不可能什么事情都要亲力亲为，例如从开砖窑厂、挖泥巴、烧制砖头开始搞？那岂不又回到了原始社会！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现代社会的主要特点是精细的社会分工，每个人都干自己擅长的事情，大家的劳动成果整合起来，形成一件完美的艺术品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. Mercury-Project名字的由来&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     Mercury中文名称为“水星”，是太阳系中最内层的行星。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     起名字也是一门哲学，每个人都有一个名字，大家有谁想过人为什么要起名字？哈哈。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     起这个名字，绝不是意味着我要或者我想移民水星！！！水星朝向太阳一面温度400多度，背向的将近零下200度，那谁受得了？！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     NASA发射的水星探测器也几乎受不了，呵呵。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     起这个名字寓意Android就是那个太阳，水星要吸收太阳散发出来的光和热！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 项目目前进展&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    libutils大部分工具已移植完毕，foundation中常用的工具移植完毕，并且针对这两个库中提供的工具，编写了诸多测试用例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    下一步的任务，是把libutils中全部工具都移植完毕，&lt;/span&gt;&lt;span&gt;再有就是，对移植的工具，编写齐全的demo case进行验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     时间允许的话，我尽可能针对每一种工具的内部实现原理的进行介绍。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 17:24:00 +0000</pubDate>
<dc:creator>OnlyTime_唯有时光</dc:creator>
<og:description>早前开展的计划因各种杂事而泡汤，而当遇到了具体任务后，在压力下花了两个多周的业余时间把这件事完成了。 这就是我的引以为傲的Mercury-Project，它的核心目标是移植一些Android底层轮子到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dreaming-in-Gottingen/p/14195135.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合任务调度框架Quartz及持久化配置 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14193968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14193968.html</guid>
<description>&lt;blockquote readability=&quot;4.5095541401274&quot;&gt;
&lt;p&gt;本文侧重SpringBoot与Quartz的整合，Quartz的基本入门概念不清楚的小伙伴可以看看这篇文章：&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/14192845.html&quot; target=&quot;_blank&quot;&gt;任务调度框架Quartz快速入门！&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本篇要点&quot;&gt;本篇要点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;介绍SpringBoot与Quartz单机版整合。&lt;/li&gt;
&lt;li&gt;介绍Quartz持久化存储。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;springboot与quartz单机版快速整合&quot;&gt;SpringBoot与Quartz单机版快速整合&lt;/h2&gt;
&lt;p&gt;学习完非Spring环境下Quartz的使用，再来看SpringBoot你会感到更加自如，因为SpringBoot无非是利用它自动配置的特性，将一些重要的Bean自动配置到环境中，我们直接开箱即用，关于Quartz的自动配置定义在QuartzAutoConfiguration中。&lt;/p&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;p&gt;主要是&lt;code&gt;spring-boot-starter-quartz&lt;/code&gt;这个依赖，是SpringBoot与Quartz的整合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!-- 实现对 Spring MVC 的自动化配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 实现对 Quartz 的自动化配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建job&quot;&gt;创建Job&lt;/h3&gt;
&lt;p&gt;为了演示两种Trigger及两种配置方式，我们创建两个不同的Job。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class FirstJob extends QuartzJobBean {

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        String now = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());
        log.info(&quot;当前的时间: &quot; + now);
    }
}

@Slf4j
public class SecondJob extends QuartzJobBean {

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        String now = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());
        log.info(&quot;SecondJob执行, 当前的时间: &quot; + now);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在创建Job的时候，可以实现Job接口，也可以继承QuartzJobBean。&lt;/p&gt;
&lt;p&gt;QuartzJobBean实现了Job，并且定义了公用的execute方法，子类可以继承QuartzJobBean并实现executeInternal方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class QuartzJobBean implements Job {

        /**
         * This implementation applies the passed-in job data map as bean property
         * values, and delegates to {@code executeInternal} afterwards.
         * @see #executeInternal
         */
        @Override
        public final void execute(JobExecutionContext context) throws JobExecutionException {
                try {
             // 将当前对象包装为BeanWrapper
                        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
            // 设置属性
                        MutablePropertyValues pvs = new MutablePropertyValues();
                        pvs.addPropertyValues(context.getScheduler().getContext());
                        pvs.addPropertyValues(context.getMergedJobDataMap());
                        bw.setPropertyValues(pvs, true);
                }
                catch (SchedulerException ex) {
                        throw new JobExecutionException(ex);
                }
        // 子类实现该方法
                executeInternal(context);
        }

        /**
         * Execute the actual job. The job data map will already have been
         * applied as bean property values by execute. The contract is
         * exactly the same as for the standard Quartz execute method.
         * @see #execute
         */
        protected abstract void executeInternal(JobExecutionContext context) throws JobExecutionException;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调度器scheduler绑定&quot;&gt;调度器Scheduler绑定&lt;/h3&gt;
&lt;p&gt;Scheduler绑定有两种方式，一种是使用bena的自动配置，一种是Scheduler手动配置。&lt;/p&gt;
&lt;h4 id=&quot;自动配置，这里演示simpleschedulebuilder&quot;&gt;自动配置，这里演示SimpleScheduleBuilder&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class QuartzConfig {

    private static final String ID = &quot;SUMMERDAY&quot;;

    @Bean
    public JobDetail jobDetail1() {
        return JobBuilder.newJob(FirstJob.class)
                .withIdentity(ID + &quot; 01&quot;)
                .storeDurably()
                .build();
    }

    @Bean
    public Trigger trigger1() {
        // 简单的调度计划的构造器
        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(5) // 频率
                .repeatForever(); // 次数

        return TriggerBuilder.newTrigger()
                .forJob(jobDetail1())
                .withIdentity(ID + &quot; 01Trigger&quot;)
                .withSchedule(scheduleBuilder)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;手动配置，这里演示cronschedulebuilder&quot;&gt;手动配置，这里演示CronScheduleBuilder&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class JobInit implements ApplicationRunner {

    private static final String ID = &quot;SUMMERDAY&quot;;

    @Autowired
    private Scheduler scheduler;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        JobDetail jobDetail = JobBuilder.newJob(FirstJob.class)
                .withIdentity(ID + &quot; 01&quot;)
                .storeDurably()
                .build();
        CronScheduleBuilder scheduleBuilder =
                CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ? *&quot;);
        // 创建任务触发器
        Trigger trigger = TriggerBuilder.newTrigger()
                .forJob(jobDetail)
                .withIdentity(ID + &quot; 01Trigger&quot;)
                .withSchedule(scheduleBuilder)
                .startNow() //立即執行一次任務
                .build();
        // 手动将触发器与任务绑定到调度器内
        scheduler.scheduleJob(jobDetail, trigger);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yml配置&quot;&gt;yml配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  # Quartz 的配置，对应 QuartzProperties 配置类
  quartz:
    job-store-type: memory # Job 存储器类型。默认为 memory 表示内存，可选 jdbc 使用数据库。
    auto-startup: true # Quartz 是否自动启动
    startup-delay: 0 # 延迟 N 秒启动
    wait-for-jobs-to-complete-on-shutdown: true # 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true
    overwrite-existing-jobs: false # 是否覆盖已有 Job 的配置
    properties: # 添加 Quartz Scheduler 附加属性
      org:
        quartz:
          threadPool:
            threadCount: 25 # 线程池大小。默认为 10 。
            threadPriority: 5 # 线程优先级
            class: org.quartz.simpl.SimpleThreadPool # 线程池类型
#    jdbc: # 这里暂时不说明，使用 JDBC 的 JobStore 的时候，才需要配置
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringBoot自动配置中：&lt;code&gt;spring.quartz&lt;/code&gt;对应的配置项定义在&lt;code&gt;QuartzProperties&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&quot;主启动类&quot;&gt;主启动类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class DemoSpringBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoSpringBootApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;启动程序，FirstJob每5s执行一次，SecondJob每10s执行一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; [eduler_Worker-1] com.hyhwky.standalone.FirstJob           : FirstJob执行, 当前的时间: 2020-12-26 16:54:00
 [eduler_Worker-2] com.hyhwky.standalone.SecondJob          : SecondJob执行, 当前的时间: 2020-12-26 16:54:00
 [eduler_Worker-3] com.hyhwky.standalone.FirstJob           : FirstJob执行, 当前的时间: 2020-12-26 16:54:05
 [eduler_Worker-4] com.hyhwky.standalone.SecondJob          : SecondJob执行, 当前的时间: 2020-12-26 16:54:10
 [eduler_Worker-5] com.hyhwky.standalone.FirstJob           : FirstJob执行, 当前的时间: 2020-12-26 16:54:10
 [eduler_Worker-6] com.hyhwky.standalone.FirstJob           : FirstJob执行, 当前的时间: 2020-12-26 16:54:15
 [eduler_Worker-7] com.hyhwky.standalone.SecondJob          : SecondJob执行, 当前的时间: 2020-12-26 16:54:20
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;quartz持久化配置&quot;&gt;Quartz持久化配置&lt;/h2&gt;
&lt;p&gt;Quartz持久化配置提供了两种存储器：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;RAMJobStore&lt;/td&gt;
&lt;td&gt;不要外部数据库，配置容易，运行速度快&lt;/td&gt;
&lt;td&gt;因为调度程序信息是存储在被分配给 JVM 的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个 Job 和 Trigger 将会受到限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;JDBC 作业存储&lt;/td&gt;
&lt;td&gt;支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务&lt;/td&gt;
&lt;td&gt;运行速度的快慢取决与连接数据库的快慢&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;创建数据库表&quot;&gt;创建数据库表&lt;/h3&gt;
&lt;p&gt;为了测试Quartz的持久化配置，我们事先在mysql中创建一个数据库quartz，并执行脚本，脚本藏在&lt;code&gt;org\quartz-scheduler\quartz\2.3.2\quartz-2.3.2.jar!\org\quartz\impl\jdbcjobstore\tables_mysql_innodb.sql&lt;/code&gt;，jdbcjobstore中有支持许多种数据库的脚本，可以按需执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; use quartz;
Database changed
mysql&amp;gt; show tables;
+--------------------------+
| Tables_in_quartz         |
+--------------------------+
| qrtz_blob_triggers       |## blog类型存储triggers
| qrtz_calendars           |## 以blog类型存储Calendar信息
| qrtz_cron_triggers       |## 存储cron trigger信息
| qrtz_fired_triggers      |## 存储已触发的trigger相关信息
| qrtz_job_details         |## 存储每一个已配置的job details
| qrtz_locks               |## 存储悲观锁的信息
| qrtz_paused_trigger_grps |## 存储已暂停的trigger组信息
| qrtz_scheduler_state     |## 存储Scheduler状态信息
| qrtz_simple_triggers     |## 存储simple trigger信息
| qrtz_simprop_triggers    |## 存储其他几种trigger信息
| qrtz_triggers            |## 存储已配置的trigger信息
+--------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的表中都含有一个&lt;code&gt;SCHED_NAME&lt;/code&gt;字段，对应我们配置的&lt;code&gt;scheduler-name&lt;/code&gt;，相同 Scheduler-name的节点，形成一个 Quartz 集群。&lt;/p&gt;
&lt;h3 id=&quot;引入mysql相关依赖&quot;&gt;引入mysql相关依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- 实现对 Spring MVC 的自动化配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 实现对 Quartz 的自动化配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置yml&quot;&gt;配置yml&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  datasource:
    quartz:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/quartz?serverTimezone=GMT%2B8
      username: root
      password: 123456
  quartz:
    job-store-type: jdbc # 使用数据库存储
    scheduler-name: hyhScheduler # 相同 Scheduler 名字的节点，形成一个 Quartz 集群
    wait-for-jobs-to-complete-on-shutdown: true # 应用关闭时，是否等待定时任务执行完成。默认为 false ，建议设置为 true
    jdbc:
      initialize-schema: never # 是否自动使用 SQL 初始化 Quartz 表结构。这里设置成 never ，我们手动创建表结构。
    properties:
      org:
        quartz:
          # JobStore 相关配置
          jobStore:
            dataSource: quartzDataSource # 使用的数据源
            class: org.quartz.impl.jdbcjobstore.JobStoreTX # JobStore 实现类
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_ # Quartz 表前缀
            isClustered: true # 是集群模式
            clusterCheckinInterval: 1000
            useProperties: false
          # 线程池相关配置
          threadPool:
            threadCount: 25 # 线程池大小。默认为 10 。
            threadPriority: 5 # 线程优先级
            class: org.quartz.simpl.SimpleThreadPool # 线程池类型

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置数据源&quot;&gt;配置数据源&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class DataSourceConfiguration {

    private static HikariDataSource createHikariDataSource(DataSourceProperties properties) {
        // 创建 HikariDataSource 对象
        HikariDataSource dataSource = properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
        // 设置线程池名
        if (StringUtils.hasText(properties.getName())) {
            dataSource.setPoolName(properties.getName());
        }
        return dataSource;
    }

    /**
     * 创建 quartz 数据源的配置对象
     */
    @Primary
    @Bean(name = &quot;quartzDataSourceProperties&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.quartz&quot;)
    // 读取 spring.datasource.quartz 配置到 DataSourceProperties 对象
    public DataSourceProperties quartzDataSourceProperties() {
        return new DataSourceProperties();
    }

    /**
     * 创建 quartz 数据源
     */
    @Bean(name = &quot;quartzDataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.quartz.hikari&quot;)
    @QuartzDataSource
    public DataSource quartzDataSource() {
        // 获得 DataSourceProperties 对象
        DataSourceProperties properties = this.quartzDataSourceProperties();
        // 创建 HikariDataSource 对象
        return createHikariDataSource(properties);
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建任务&quot;&gt;创建任务&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class JobInit implements ApplicationRunner {

    private static final String ID = &quot;SUMMERDAY&quot;;

    @Autowired
    private Scheduler scheduler;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        JobDetail jobDetail = JobBuilder.newJob(SecondJob.class)
                .withIdentity(ID + &quot; 02&quot;)
                .storeDurably()
                .build();
        CronScheduleBuilder scheduleBuilder =
                CronScheduleBuilder.cronSchedule(&quot;0/10 * * * * ? *&quot;);
        // 创建任务触发器
        Trigger trigger = TriggerBuilder.newTrigger()
                .forJob(jobDetail)
                .withIdentity(ID + &quot; 02Trigger&quot;)
                .withSchedule(scheduleBuilder)
                .startNow() //立即執行一次任務
                .build();
        Set&amp;lt;Trigger&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        set.add(trigger);
        // boolean replace 表示启动时对数据库中的quartz的任务进行覆盖。
        scheduler.scheduleJob(jobDetail, set, true);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动测试&quot;&gt;启动测试&lt;/h3&gt;
&lt;p&gt;启动测试之后，我们的quartz任务相关信息就已经成功存储到mysql中了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; select * from qrtz_simple_triggers;
+--------------+---------------------+---------------+--------------+-----------------+-----------------+
| SCHED_NAME   | TRIGGER_NAME        | TRIGGER_GROUP | REPEAT_COUNT | REPEAT_INTERVAL | TIMES_TRIGGERED |
+--------------+---------------------+---------------+--------------+-----------------+-----------------+
| hyhScheduler | SUMMERDAY 01Trigger | DEFAULT       |           -1 |            5000 |             812 |
+--------------+---------------------+---------------+--------------+-----------------+-----------------+
1 row in set (0.00 sec)

mysql&amp;gt; select * from qrtz_cron_triggers;
+--------------+---------------------+---------------+------------------+---------------+
| SCHED_NAME   | TRIGGER_NAME        | TRIGGER_GROUP | CRON_EXPRESSION  | TIME_ZONE_ID  |
+--------------+---------------------+---------------+------------------+---------------+
| hyhScheduler | SUMMERDAY 02Trigger | DEFAULT       | 0/10 * * * * ? * | Asia/Shanghai |
+--------------+---------------------+---------------+------------------+---------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;源码下载&lt;/h2&gt;
&lt;p&gt;本文内容均为对优秀博客及官方文档总结而得，原文地址均已在文中参考阅读处标注。最后，文中的代码样例已经全部上传至Gitee：&lt;a href=&quot;https://gitee.com/tqbx/springboot-samples-learn&quot; target=&quot;_blank&quot;&gt;https://gitee.com/tqbx/springboot-samples-learn&lt;/a&gt;，另有其他SpringBoot的整合哦。&lt;/p&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Sat, 26 Dec 2020 16:36:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>本文侧重SpringBoot与Quartz的整合，Quartz的基本入门概念不清楚的小伙伴可以看看这篇文章：任务调度框架Quartz快速入门！ 本篇要点 介绍SpringBoot与Quartz单机版整</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14193968.html</dc:identifier>
</item>
<item>
<title>在 xunit 测试项目中使用依赖注入 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14152452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14152452.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;之前写过几篇 xunit 依赖注入的文章，今天这篇文章将结合我在 .NET Conf 上的分享，更加系统的分享一下在测试中的应用案例。&lt;/p&gt;
&lt;p&gt;之所以想分享这个话题是因为我觉得在我们开发过程中测试是非常重要的一部分，高质量项目的一个重要指标就是测试覆盖率，同时依赖注入已经是一个现代化应用中不可缺少的一部分，我们的 .NET Core 也是从一开始就集成了依赖注入，依赖注入对于测试项目也是不能缺席的。&lt;/p&gt;
&lt;p&gt;xunit 是 .net 里目前使用的最多的测试组件，&lt;code&gt;Xunit.DependencyInjection&lt;/code&gt; 是大师写的一个 xunit 依赖注入的扩展，它是基于微软的 &lt;code&gt;GenericHost&lt;/code&gt;（通用主机） 来实现的，使用它我们可以很轻松的实现依赖注入，很好的和 .NET Core 做集成。&lt;/p&gt;
&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;
&lt;p&gt;那它是如何工作的呢？我们一起来看一下它的执行流程，它的执行流程分为四步&lt;/p&gt;
&lt;p&gt;首先需要构建一个 Host，然后启动这个 Host，启动完成后执行测试用例，最后终止这个 Host&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226174736685-232454613.png&quot; alt=&quot;执行流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Host 又是如何构建的呢？我们一起看一下，Host 的构建也是分为四步&lt;/p&gt;
&lt;p&gt;第一步，创建一个 &lt;code&gt;HostBuilder&lt;/code&gt;，大多数情况下我们不需要用这个方法，使用默认的实现就好&lt;/p&gt;
&lt;p&gt;第二步，Host 配置，对 Host 做一些自定义配置&lt;/p&gt;
&lt;p&gt;第三步，服务配置，注册需要的服务&lt;/p&gt;
&lt;p&gt;第四步，&lt;code&gt;Configure&lt;/code&gt;，可以做一些初始化的配置，比如配置初始化以及测试数据的初始化等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226174850455-1969870223.png&quot; alt=&quot;Host构建流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在测试项目里创建一个 &lt;code&gt;Startup&lt;/code&gt; 类来控制 &lt;code&gt;Host&lt;/code&gt; 的构建过程&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;接着我们来看一些实际的测试示例，示例分为三部分，首先是一些基本用法，然后是和其他组件的集成，最后是一些扩展用法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226174934683-796917960.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;get-started&quot;&gt;Get Started&lt;/h3&gt;
&lt;p&gt;首先来看一下 &lt;code&gt;Startup&lt;/code&gt; 的用法，这个 &lt;code&gt;Startup&lt;/code&gt; 和 asp.net core 里的 &lt;code&gt;Startup&lt;/code&gt; 是很像的，无论是使用方式上还是实现上都是类似的，有兴趣的可以看一下源码对比一下，我们来看一下使用方式，通过下面的示例来感受一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175035842-328182987.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你只需要注册服务，直接在 &lt;code&gt;Startup&lt;/code&gt; 中添加一个 &lt;code&gt;ConfigureServices&lt;/code&gt; 方法，在这个方法中注册自己需要的服务即可，和 asp.net core 并无太多不同&lt;/p&gt;
&lt;p&gt;如果你需要做一些初始化的工作，可以加一个 &lt;code&gt;Configure&lt;/code&gt; 方法，在这个方法中实现自己的初始化逻辑就可以了，如果初始化的时候需要获取注入的服务实例，直接作为方法参数就可以，类似于 asp.net core 中 &lt;code&gt;Configure&lt;/code&gt; 方法，只是不需要配置 Http 请求管道&lt;/p&gt;
&lt;p&gt;如果你需要使用的配置，需要使用 Configuration，可以在 &lt;code&gt;ConfigureHost&lt;/code&gt; 方法中通过 &lt;code&gt;ConfigureHostConfiguration&lt;/code&gt; 扩展方法注册自己的配置&lt;/p&gt;
&lt;p&gt;如果需要在注册服务的时候用到配置，可以在 &lt;code&gt;ConfigureServices&lt;/code&gt; 方法中添加一个 &lt;code&gt;HostBuildContext&lt;/code&gt; 的参数，&lt;code&gt;HostBuilderContext&lt;/code&gt; 中的 &lt;code&gt;Configuration&lt;/code&gt; 对象就是在 &lt;code&gt;ConfigureHost&lt;/code&gt; 中注册的配置&lt;/p&gt;
&lt;p&gt;如果需要在 &lt;code&gt;Configure&lt;/code&gt; 方法中使用配置，直接添加一个 &lt;code&gt;IConfiguration&lt;/code&gt; 的方法参数就可以了&lt;/p&gt;
&lt;p&gt;我们再来看一下，如何在测试用例中使用注入的服务，一般情况下我们会直接通过构造器注入，在构造方法中添加需要注入的服务即可，除此之外我们还可以通过方法参数注入，结合 &lt;code&gt;InlineData&lt;/code&gt; 和 &lt;code&gt;MemeberData&lt;/code&gt; 使用，来看一下这个示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175122323-250152192.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;iocaop-integration&quot;&gt;IoC/AOP Integration&lt;/h3&gt;
&lt;p&gt;接着我们来看一下和其他组件的集成，&lt;code&gt;AutoFac&lt;/code&gt; 是一个很流行的 IOC 组件，&lt;code&gt;AspectCore&lt;/code&gt; 是柠檬大佬写的一个 AOP 框架，我们以这两个为例子来看一下如何集成第三方的依赖注入和 AOP 组件，前面我们已经提到它是基于微软的 &lt;code&gt;GenericHost&lt;/code&gt; 实现的，而 asp.net core 从 3.0 开始也是基于 &lt;code&gt;GenericHost&lt;/code&gt; 实现的，所以在 asp.net core 里怎么集成，在这里也是一样的，来看一下示例，只需要使用对应的 &lt;code&gt;ServiceProviderFactory&lt;/code&gt; 就可以了，是不是很简单呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175239689-585675884.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175248964-1294477549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;test-server-integration&quot;&gt;Test Server Integration&lt;/h3&gt;
&lt;p&gt;然后我们来看一下如何和 &lt;code&gt;TestServer&lt;/code&gt; 做集成，&lt;code&gt;TestServer&lt;/code&gt; 主要用于集成测试，使用 &lt;code&gt;TestServer&lt;/code&gt; 的好处在于它是基于内存进行交互的没有真正的 HTTP 请求和 TCP 链接，会非常的高效，而且也不会监听某一个端口，所以不会有端口权限的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TestServer&lt;/code&gt; 的使用主要有两步，首先是服务的注册，可以使用 &lt;code&gt;IHostBuilder&lt;/code&gt; 或 &lt;code&gt;IWebHostBuilder&lt;/code&gt; 的 &lt;code&gt;UseTestServer&lt;/code&gt; 扩展方法注册 &lt;code&gt;TestServer&lt;/code&gt;，可以使用 &lt;code&gt;IHost&lt;/code&gt; 的 &lt;code&gt;GetTestClient&lt;/code&gt; 扩展方法来注册和 &lt;code&gt;TestServer&lt;/code&gt; 进行交互的 &lt;code&gt;HttpClient&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务注册好之后就可以在测试用例里通过注入的 &lt;code&gt;HttpClient&lt;/code&gt; 请求 API 或页面了，可以参考这个例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175352070-590239071.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;extensions&quot;&gt;Extensions&lt;/h2&gt;
&lt;h3 id=&quot;hosted-service&quot;&gt;Hosted Service&lt;/h3&gt;
&lt;p&gt;然后我们来看一些扩展用法，&lt;code&gt;IHostedService&lt;/code&gt; 可以用来实现一些初始化的操作或者后台服务，我们可以使用 &lt;code&gt;IHostedService&lt;/code&gt; 来实现对应用的 Ready 检查，应用 Ready 之后再开始执行测试用例，这在有些场景下是很有用的&lt;/p&gt;
&lt;p&gt;我们在 k8s 中部署的应用一般都会有一个 &lt;code&gt;HealthCheck&lt;/code&gt;/&lt;code&gt;ReadinessCheck&lt;/code&gt; 的接口来供 k8s 的 liveness/readiness 探针来探测应用的状态，只有应用 Ready 之后才会对外部提供服务&lt;/p&gt;
&lt;p&gt;这个示例就是一个使用 &lt;code&gt;IHostedService&lt;/code&gt; 来实现等待应用 Ready 后再开始执行测试用例的一个 demo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175453709-2043321536.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：这里的等待不能在 &lt;code&gt;Startup&lt;/code&gt; 的 &lt;code&gt;Configure&lt;/code&gt; 方法中执行，因为 &lt;code&gt;Configure&lt;/code&gt; 的执行是在调用 Host 的 &lt;code&gt;StartAsync&lt;/code&gt; 方法之前执行的，而此时 webServer 还没有启动，所以是不能获取到 &lt;code&gt;TestClient&lt;/code&gt; 的，而我们通过 &lt;code&gt;HostedService&lt;/code&gt; 就可以在 Web Server 启动之后再执行我们的等待 Ready 逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;itestoutputhelperaccessor&quot;&gt;ITestOutputHelperAccessor&lt;/h3&gt;
&lt;p&gt;在测试中如果想要输出一个日志的话只能借助于 &lt;code&gt;ITestOutputHelper&lt;/code&gt; 来输出，直接使用 &lt;code&gt;Console.Write[Line]&lt;/code&gt; 是看不到任何输出的，&lt;code&gt;ITestOutputHelper&lt;/code&gt; 只能在测试用例中使用，在测试服务中是不能使用的，&lt;code&gt;Xunit.DependencyInjection&lt;/code&gt; 提供了一个 &lt;code&gt;ITestOutputHelperAccessor&lt;/code&gt; 的服务，类似于 &lt;code&gt;IHttpContextAccessor&lt;/code&gt;，我们可以借助它来在自定义的服务中获取 &lt;code&gt;ITestOutputHelper&lt;/code&gt; 来输出日志&lt;/p&gt;
&lt;p&gt;这里是一个简单的示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175559391-991295986.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;logging&quot;&gt;Logging&lt;/h3&gt;
&lt;p&gt;再来看一个 &lt;code&gt;OutputHelperAccessor&lt;/code&gt; 的实际应用，&lt;code&gt;Xunit.DependencyInjection&lt;/code&gt; 提供了一个 Logging 的扩展，使得我们可以把测试过程中的日志输出出来，更好的帮助我们调试&lt;/p&gt;
&lt;p&gt;集成方式也比较简单，可以参考这个示例，引用 &lt;code&gt;Xunit.DependencyInjection.Logging&lt;/code&gt; 之后，在 &lt;code&gt;LoggerFactory&lt;/code&gt; 中注册 &lt;code&gt;XunitTestOutputLoggerProvider&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;可以看到我们的日志直接输出出来了，默认的日志级别是 &lt;code&gt;Information&lt;/code&gt; ，所以 &lt;code&gt;Debug&lt;/code&gt; 级别的日志没有输出出来，有需要的话可以在注册的时候提供一个委托来控制是否要输出日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175632045-1929802990.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;project-template&quot;&gt;Project Template&lt;/h2&gt;
&lt;p&gt;为了方便大家使用，我们提供了一个项目模板，可以通过一个命令就可以直接创建好一个测试项目，会包含一个默认的 &lt;code&gt;Startup&lt;/code&gt; 不再需要自己去写方法了，使用的时候只需要根据需要做删减就可以了&lt;/p&gt;
&lt;p&gt;默认的 &lt;code&gt;TargetFramework&lt;/code&gt; 使用的是 &lt;code&gt;netcoreapp3.1&lt;/code&gt;，可以通过 &lt;code&gt;-f&lt;/code&gt;/&lt;code&gt;--franework&lt;/code&gt; 指定自己想要使用的目标框架，比如说想要生成 net 5.0 的项目只需要指定 &lt;code&gt;-f net5.0&lt;/code&gt; 就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226175825704-27417913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的内容如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201226181243993-571863347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;最后列出来了一些可能会有帮助的链接，第一个是项目的源代码，第二个是 PPT 中所有示例的源代码，后面的是使用到的 Nuget 包。&lt;/p&gt;
&lt;p&gt;这个 xunit 扩展的代码实现是非常值得学习的，有很多和 asp.net core 的实现是很像的，有需要的可以去看看源码学习一下。&lt;/p&gt;
&lt;p&gt;希望我的分享对大家有所帮助，大家在使用过程中有遇到任何问题都可以随时联系我或者直接在 Github 上建 issue。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sat, 26 Dec 2020 16:06:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>在 xunit 测试项目中使用依赖注入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14152452.html</dc:identifier>
</item>
<item>
<title>编程方式实现MySQL批量导入sql文件 - freephp</title>
<link>http://www.cnblogs.com/freephp/p/14195036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freephp/p/14195036.html</guid>
<description>&lt;p&gt;有时候需要在本地导入一些stage环境的数据到本地mysql，面对1000+的sql文件（包含表结构和数据，放在同一个文件夹下），使用navicat一个一个导入sql文件显然有点太慢了，于是考虑使用source命令批量来实现。网上看了很多人遇到这个高频的数据库sql导入问题，但是没有特别具体的解决方案，只有个大概的思路，我就抛砖引玉，作为一个详细的记录，渡人渡己。&lt;/p&gt;
&lt;p&gt;先复习一下source的使用方法，首先要用命令行方式连接到MySQL数据库，然后使用下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;use database_name1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换到需要被使用的数据库，然后再使用如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source path/to/file/table_name1.sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质上就是要使用这行命令来将sql文件的内容导入database_name1库里。使用source对上G大小的sql文件非常高效和丝滑，不会出现图形化界面导入的时候的卡顿或者崩溃。&lt;br/&gt;但是多个sql文件（比如上千个）那么就需要source很多次，还是回到最初的问题，如何能一次性批量source进去呢？&lt;/p&gt;
&lt;p&gt;这个时候可以想着创建一个完成批量导入的sql文件，假设命名为batch.sql，里面的内容大概如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;source /path/to/file/table_name1.sql
source /path/to/file/table_name2.sql
source /path/to/file/table_name3.sql
...
省略900多行
source /path/to/file/table_name1000.sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;人工的去编写这个batch文件显然费力，但是我们现在目标明确了，就是要想办法实现生成这样的batch.sql文件。&lt;br/&gt;可以考虑使用脚本程序来实现，把这个问题转换成一个简单的脚本任务：&lt;br/&gt;对指定路径的文件夹下所有文件名进行收集，并且是每个文件的全路径+文件名写入一个新的sql文件里面。当然别忘了每行开头要添加一个source命令，一个文件单独一行。&lt;br/&gt;用Python实现最简单，os.walk可以用于遍历文件夹下的文件夹和文件，get_source_batch_file.py实现如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
import sys
import os
'''
To get all the full path of files under a given path, not to search for sub folder's files.
'''
def get_current_dir_filename_with_full_path(path: str) -&amp;gt; list:
    filename_list = []
    for i,j,filename in os.walk(path):
        for item in filename:
            filename_list.append(path + item)
        return filename_list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只处理当前目录下的文件，不会收集子目录下的文件，所以最外层的循环第一次完成后就return结果了。&lt;br/&gt;然后调用部分也很简单，脚本传入第一个参数就是文件夹的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# usage
# the second params from terminater is the folder path.
try:
    mypath = sys.argv[1]
except IndexError:
    mypath = '/Users/tony/pythonwork/test/leetCode/testsqlFiles/'

if mypath[len(mypath) - 1] != '/':
    mypath += '/'
filename_list = get_current_dir_filename_with_full_path(mypath)

for filename in filename_list:
    print(&quot;source &quot; + filename)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出接收参数也做了入参的路径补全的处理，同样也可以不传参数，默认值就是我们需要处理的文件夹的全路径，之所以接收入参是为了日后使用更加灵活。&lt;/p&gt;
&lt;p&gt;最后在终端使用命令如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.7 get_source_batch_file /Users/tony/pythonwork/test/leetCode &amp;gt; ./batch.sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后在当前目录下就会生成需要的batch.sql。注意，我这里是使用的python3.7命令，这是因为我本机MacOS系统自带了一个python2.7，所以我单独安装了一个python3.7，由于get_source_batch_file.py用了python3特有的type hint写法，所以必须使用3.x的python命令才能正常执行。&lt;br/&gt;所以方法总比困难多，没有现成的工具，我们自己写一个就OK了。&lt;br/&gt;最后source /path/to/batch.sql，大功告成!&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 15:52:00 +0000</pubDate>
<dc:creator>freephp</dc:creator>
<og:description>有时候需要在本地导入一些stage环境的数据到本地mysql，面对1000+的sql文件（包含表结构和数据，放在同一个文件夹下），使用navicat一个一个导入sql文件显然有点太慢了，于是考虑使用s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freephp/p/14195036.html</dc:identifier>
</item>
<item>
<title>vue3.0自定义指令（drectives) - 阡陌夕殇</title>
<link>http://www.cnblogs.com/mengxudong/p/14194914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxudong/p/14194914.html</guid>
<description>&lt;p&gt;在大多数情况下，你都可以操作数据来修改视图，或者反之。但是还是避免不了偶尔要操作原生 DOM，这时候，你就能用到自定义指令。&lt;/p&gt;
&lt;p&gt;举个例子，你想让页面的文本框自动聚焦，在没有学习自定义指令的时候，我们可能会这么做。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = Vue.createApp({
  mounted(){
    this.$refs.input.focus();
  },  
  template: `&amp;lt;input type=&quot;text&quot; ref=&quot;input&quot; /&amp;gt;`,
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在mounted钩子函数里，通过 $refs 获取需要聚焦的 DOM 元素，然后调用 focus 方法完成自动聚焦的功能。&lt;/p&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;基本使用&lt;/h2&gt;
&lt;p&gt;上面做法已经实现了我们需要的功能，但是假如说我们有多个组件都需要这个功能，那我们只能把这段代码复制过去，重新实现逻辑。我们下面看下如果使用自定义指令，应该怎么做。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = Vue.createApp({
  // 通过 v-[自定义指令名称] 绑定自定义指令
  template: `&amp;lt;input type=&quot;text&quot; v-focus/&amp;gt;`,
});
// 注册一个全局自定义指令
app.directive('focus',{
  // 当被绑定的元素插入到DOM的时候执行..
  mounted(el){
    el.focus();
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们定义了一个全局自定义指令 &lt;code&gt;focus&lt;/code&gt;，并通过 &lt;code&gt;v-focus&lt;/code&gt; 绑定到需要聚焦的 input 元素上。如果，其他组件或模块也需要聚焦功能，只要简单的绑定此指令即可。&lt;/p&gt;
&lt;h2 id=&quot;自定义指令的钩子函数&quot;&gt;自定义指令的钩子函数&lt;/h2&gt;
&lt;p&gt;我们在上面定义指令的时候，会发现其中包含了 &lt;code&gt;mounted&lt;/code&gt; 钩子函数，指令还提供了如下钩子函数，我们用代码的形式来给大家列出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;app.directive('directiveName', {
  // 指令绑定元素挂载前
  beforeMount(el) {},
  // 指令绑定元素挂载后
  mounted(el, binding) {},
  // 指令绑定元素因为数据修改触发修改前
  beforeUpdate(el) {},
  // 指令绑定元素因为数据修改触发修改后
  updated(el) {},
  // 指令绑定元素销毁前
  beforeUnmount(el) {},
  // 指令绑定元素销毁后
  unmounted(el) {},
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果就不一一列举了，有兴趣大家可以尝试下分别触发这些钩子函数。指令钩子函数大部分与组件很类似，大家可以对比着来看。&lt;/p&gt;
&lt;h2 id=&quot;动态指令参数&quot;&gt;动态指令参数&lt;/h2&gt;
&lt;p&gt;下面，我们再来看一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = Vue.createApp({
  template: `&amp;lt;div class=&quot;box&quot; v-abs-top=&quot;num&quot; style=&quot;position:absolute;&quot; &amp;gt;&amp;lt;/div&amp;gt;`,
});
// 在很多时候，你可能想在 mounted 和 updated 时触发相同行为，而不关心其它的钩子，就这样写
app.directive('absTop', (el) =&amp;gt; {
  el.style[binding.arg] = '100px';
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在 div 元素上绑定 &lt;code&gt;absTop&lt;/code&gt; 指令，div 元素本身定位是 absolute，指令执行让绑定元素的 top 为 100px。这时候，我想在绑定指令的时候能够传一个参数，使得元素的 top 值可以根据参数来改变。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = Vue.createApp({
  data() { return { num: 100 } },
  template: `&amp;lt;div class=&quot;box&quot; v-abs-top=&quot;num&quot;&amp;gt;&amp;lt;/div&amp;gt;`,
});
app.directive('absTop', (el, binding) =&amp;gt; {
  el.style.top = binding.value + 'px';
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;元素可以通过 &lt;code&gt;v-directive=&quot;value&quot;&lt;/code&gt; 传入动态参数，指令通过钩子函数的第二个参数 binding.value 来接收参数。&lt;/p&gt;
&lt;p&gt;如果其他元素可能不是修改 top 的值，有可能是 left、right 或者 bottom，那么指令可以动态指定吗？其实也是可以做到的。首先，我们修改模板为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;box&quot; v-abs:left=&quot;num&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改指令本身&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;app.directive('absTop', (el, binding) =&amp;gt; {
  el.style[binding.arg] = binding.value + 'px';
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;v-mydirective:[argument]=&quot;value&quot;&lt;/code&gt; ，arguments 也是可以动态改变的，这样，就可以完美的实现上述要求了。&lt;/p&gt;
&lt;h2 id=&quot;组件的使用&quot;&gt;组件的使用&lt;/h2&gt;
&lt;p&gt;组件中绑定指令与 DOM元素绑定指令并没有什么不同，指令会获取组件的原生 &lt;code&gt;根DOM&lt;/code&gt; 来操作。但是要注意的是，在 vue3.0 中，组件可能有多个根节点，指令绑定在多根节点组件是有问题的。&lt;/p&gt;
&lt;h2 id=&quot;局部自定义指令&quot;&gt;局部自定义指令&lt;/h2&gt;
&lt;p&gt;最后，再来简单说下局部自定义指令是怎么定义的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const app = Vue.createApp({
directives: {
    focus: {
      // 指令的定义
      mounted(el) {
        el.focus()
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;局部指令定义和全局指令基本一致，如上所示，在组件中定义 directives 就可以了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;自定义指令可以提取出原生DOM操作的逻辑。所以指令的应用范围主要表现在，当一些操作涉及到 DOM 底层时，而且操作逻辑可能用于多处地方，就适合用指令来封装这些逻辑。&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 15:24:00 +0000</pubDate>
<dc:creator>阡陌夕殇</dc:creator>
<og:description>在大多数情况下，你都可以操作数据来修改视图，或者反之。但是还是避免不了偶尔要操作原生 DOM，这时候，你就能用到自定义指令。 举个例子，你想让页面的文本框自动聚焦，在没有学习自定义指令的时候，我们可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxudong/p/14194914.html</dc:identifier>
</item>
<item>
<title>传统文化研究团队------软件工程团队项目 - 于政文</title>
<link>http://www.cnblogs.com/Sakura-hero/p/14194954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sakura-hero/p/14194954.html</guid>
<description>&lt;h3&gt;一、团队成员&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;180402于政文（组长）&lt;/li&gt;
&lt;li&gt;180402张怀志&lt;/li&gt;
&lt;li&gt;180402巩阳昌&lt;/li&gt;
&lt;li&gt;180402李硕&lt;/li&gt;
&lt;li&gt;180402韩秋实&lt;/li&gt;
&lt;li&gt;180402刘利群&lt;/li&gt;
&lt;li&gt;180402栗永春&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;二、项目总结&lt;/h3&gt;
&lt;p&gt;　　本次项目我们的选题为：中华传统文化传播网站，我们在开发过程中，经过所有成员不断的努力，运用了HTML，CSS，JavaScript技术，运用VUE框架进行开发，考虑到我么那项目的受众人群，我们还制作出了几个独特的页面来进行展示，旨在为年轻人能更好的接受我们的网站。&lt;/p&gt;
&lt;p&gt;　　整体来说，我们本次开发较为成功，无论是需求文档还是最后的技术文档，都做了相应的规范，并经过组内成员不断讨论，不断改进。希望可以取得好成绩。&lt;/p&gt;
&lt;h3&gt;三、心得体会&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;180402于政文（组长）心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本次团队项目为宣传传统文化，起初我选择这个题目的初衷是因为觉得传统文化的缺失已经在当前社会中显现出来，大众从老人口中得知的传统文化似乎已经归于平淡，老人们无法展示出传统文化的绚烂多姿，因此我选了这个题目作为本次开发的核心。 　　&lt;/p&gt;
&lt;p&gt;　　随着对软件工程的深入理解，我发现这是一门非常需要探索的学科，无论是常用的UML系列的图，还是常规的数据字典，需求分析程序流程图，数据流图等等，还是各种团队开发模型亦或者是团队模式，都彰显了软件工程的魅力所在，更让我明白的是团队合作的重要性，在经历过单人项目，双人项目开发后，我发现团队项目的开发与这两者是截然不同的方式。首先，你所开发的代码要保证别人可以看懂，可以很快的理解并去运用，还要考虑到后期维护问题，这就对每一位开发者的素质要求都非常高，也让我看到了目前主流公司的软件开发模式。 　　&lt;/p&gt;
&lt;p&gt;　　在本次团队项目中，每一位队员都尽了自己的一份力，无论是从项目开发前期的需求分析，还是项目开发中对代码的前端实现，亦或是项目后期的上线推广，大家各司其职，这才使得项目能有条不紊的开发下去，感谢我的组员对我的一贯支持与包容，虽然我们开发时也会出现意见分歧，出现不和，但我们都一一克服了这些难题，希望团队项目可以交一个完美的答卷，最后感谢老师一学期的辛苦授课，老师您幸苦了。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;180402张怀志心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　软件工程以邹欣的《构建之法》为主本，跟随课本的做中学思想，在对基础知识的学习时，通过对一个项目的创建到完成，学会思想的灵活应用。在书中讲述了如何成为一个软件工程师，及软件工程师的绩效评估，通过讲述，了解到软件公司内部人员的分配及软件由需求到开发的总过程，了解到效能分析工具及个人开发流程，软件工程师的成长，个人能力的衡量与发展，明白了自己在努力的方向，我也学到了与人合作、共同开发的技术。从中，我学到了沟通和表达交流的技术，在分派任务时结合组员的个人实际进行分配，并尽量清楚地传达组内所期望的任务效果，时刻保持与组员的沟通。我学到了不同分组间合作开发的技术。我们组内分为前端组和后端组，前端组负责“画页面”“做特效”等，后端组负责“数据库”“搭载页面”等。经过这段经历，我学到了概况代码功能、抽象代码特点、凸显API等对接技术，在分工的项目开发中，我认为这些技术至关重要。以上便是我在这团队项目开发中学到的，希望在以后的项目开发中我能活用这些宝贵经验、学有所长。在后期两人合作中，学会了代码设计规范的重要性及结对编程每一个人的作用与角色，及如何高效的反馈信息给合作成员团队。&lt;br/&gt;　　在合作中，学会了团队合作，团队中，了解到团队合作中每一个人的作用，感受到了敏捷流程的基本过程，经历了一个软件由需求分析到最终发布的整个流程，增强了自我责任感，学会了各司其职，对项目负责，对小组负责，在对于项目制作过程的一些变化，要保持敏捷，实时更新团队计划。也知道了一个网页的维持有多么不容易，需要后备的资金。总之，通过学习，对自己的专业又加深了一层理解，增强了自信心。在今后的学习中要注意多读书、多思考、多练习、多讨论，不断熟悉书本的基础，并以此为基础将其扩散开来，应用于今后的实践。不断锻炼自己，向一名合格的程序设计师迈进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;180402巩阳昌心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过长达十周的软件工程的学习,让我对软件工程有了新的认知,软件工程，顾名思义，是一门用工程化的思想去开发软件的学科。它实际上是一个工程，并不是大多数人所以为的，软件工程就是开发软件这么简单，写写语言代码这么幼稚。&lt;/p&gt;
&lt;p&gt;　　我们首先通过老师留的单人项目,过渡到双人项目,最后到团队项目,一步一步循序渐进的过程,通过这三次小实验发现自己还有很多不足的地方，对java语言的运用程度还不够，对测试领域接触不够深。&lt;br/&gt;通过这几周的团队项目,虽然时间不算太长,但是收获还是很大,团队项目不仅让我们对java编程有了很大进步的提升,还让我们知道团队精神的重要性,这个java编程和团队精神不是一下子就能有的,但是有了这个团队项目,让我们在做项目的过程中有了很好的培养,我们团队的每个人也都在进步着。&lt;/p&gt;
&lt;p&gt;　　团体项目给我的感悟是: 一、集体的协作精神非常重要,一个人的力量是有限的,大家齐心协力才能共渡难关。二、任何一个团队都不能忽视领导的作用,大家都应该围绕着这个领导核心,一起出谋划策共同开展工作。三、在做任何事情之前,要有个详细的策划,再加上领导最后的决定,并且在做的过程中要按照原定的计划行事。四、团队中成员的相互交流,相互鼓励,相互信任也非常的重要,这样会激发出每个成员的集体荣誉感和增强每个员工的自信心。五、每个成员都要有奉献精神,要尽最大努力来共同完成项目。我相信参与这次拓展培训的每一个人,都会从拓展培训中得到了或多或少的启发。我们是否能真正把拓展中的精神运用到实际工作中和日常生活中去,还需要一个很长的磨练时间。我们要用拓展了的心灵,激情和意志重新面对崭新的每一天,面对学校的每一项工作任务,我们将勇往直前!&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;180402李硕心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这一学期的软件工程课结束了，在上软件工程之前还以为软工就是编写JAVA代码，但经过了本次课程的学习，我了解到软件工程并不仅仅是写代码他是独立的复杂的。我学会了画UML各种图，又学习了单元测试，知道了单元测试的重要性。然后我做的单人项目的题目是：&quot;最大子数组&quot;问题。   虽然很代码简单，但是要严格按照工作做项目的标准对我这个初学者来说是十分的复杂和困难，除了JAVA写代码，还要画出各种图，还要进行单元测试，虽然困难但是好在我也完美完成了单人项目。我也才真正的知道原来我们不仅仅要熟练精通敲代码，对一个大的软件来说，如果只是随便的信马由缰，会很乱也会出很多的问题，所以就要严格按照我们所学的软件工程去操作。&lt;/p&gt;
&lt;p&gt;　　我们还做了双人项目，这是我第一次和其他人一起完成一个软件，我们也有各自想法，两个人的代码风格也不尽相同，造成了很多问题，最终我们统一规定了我们组的代码规范，使我们在解决问题和编码时更加迅速，在经过最后的复审，我们也找到了互相身上的漏洞，也学习到了彼此的好的方法，最终完成了双人项目。我也知道了，在以后工作的时候还是要靠合作才能做的更好，还是需要团队的合作才能走的更远。&lt;/p&gt;
&lt;p&gt;　　最后终极任务完成团队项目。在我们组队后，我们团队投票选择了，优秀中华传统文华传播这个题目，一开始我们是毫无头绪的，毕竟我们以前一直都是需求方，没有真正的去完成客户需要的东西，如何将我们的传统文化传播网站做的更好，更能吸引人们的眼光，能够盈利。经过我们团队成员的激烈的讨论，大体有了一个模糊的方向。我们便进行了需求分析，我们做问卷，做调查，找到了大众心中一个传播文华的网站应该是什么样子，我们最终定下了使用生鱼片模型来去开发，我们团队的模式为：功能团队模式，每名组员都分配到了自己的任务。在我们的认真努力下，我们最终做出了自己感觉满意的文化传播网站。虽然还有很多的漏洞，我希望有朝一日我们能够做出真正能够拿去使用的好的网站&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;以上就是我通过自身经历对我所掌握的软件工程的看法。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;180402韩秋实心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过这学期对软件工程的学习与实践，在老师内容充实的多元化授课下，我对这门课程的了解从一开始只有模糊的理解到逐渐感受到软件工程所涉及到知识面远远大于我所能想象的深度。经过这十周的课程，我学到了很多东西，曾经以为程序就是软件，软件就是程序。学习这门课程第一个收获是，知道了二者的不同之处。以前做过的一些小型的软件比如加密软件，我也只是在程序旁边附上一个软件的说明，看来已经很接近作坊了。不过大的项目没有接触过，用软件工程的方法还是第一次。我想也是程序的不断复杂化导致了软件危机的发生，使得人们不得不探索新的解决方法&lt;/p&gt;
&lt;p&gt;　　经过老师的讲解，理解了软件工程，就是一套用于软件的团队开发，以提高软件质量和程序员工作效率为目的的规范。其核心就是，对于软件开发的5个重要组成部分:需求分析，设计，编码，调试，维护，如何组织这5个部分的工作，以及如何完成每-一个工作。吾生也有涯，而知也无涯，学习永无止境。&lt;/p&gt;
&lt;p&gt;　　起初，对软件工程处于一知半解的状态，分工比较混乱。在划分模块后明确了各自分工，渐渐形成良性循环。软件工程这门课，老师想要交给我们的不仅仅是一个简单的课程或者如何敲代码，而是要给我们传授一种思想：是一个如何去分析和处理问题的过程，应该说其范畴已经远远不止局限于该门课程，成为了一个综合的一个能够解决问题的思想集合。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　在学习过程中，知道了团队合作十分重要，争议固然存在，但通过讨论、协商，群策群力,在不断磨合中能够达成一致与默契。团队成员中能力各有高下，互相尊重,各取所长，不宜妄自菲薄。组长多加协调，组员积极配合，才能合作愉快。&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 26 Dec 2020 15:24:00 +0000</pubDate>
<dc:creator>于政文</dc:creator>
<og:description>一、团队成员 180402于政文（组长） 180402张怀志 180402巩阳昌 180402李硕 180402韩秋实 180402刘利群 180402栗永春 二、项目总结 本次项目我们的选题为：中华</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Sakura-hero/p/14194954.html</dc:identifier>
</item>
<item>
<title>Kibana查询语言（KQL） - 寻觅beyond</title>
<link>http://www.cnblogs.com/-beyond/p/14159002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-beyond/p/14159002.html</guid>
<description>&lt;h2&gt;一.前言&lt;/h2&gt;
&lt;p&gt;　　现在大多数的公司都会使用ELK组合来对日志数据的收集、存储和提供查询服务，这里就不介绍什么是ELK了，只介绍一些EKL中的查询，也就是K（kibana）。&lt;/p&gt;
&lt;p&gt;　　查询数据库，如果是MySQL，那么就需要使用MySQL的语法；同样的，在Kibana上查询数据，也需要使用Kibana的语法，而Kibana的查询语法叫做Kibana Query Language，简称KQL。&lt;/p&gt;
&lt;p&gt;　　本文的内容主要来自ES的官网，简单翻译了一下，https://www.elastic.co/guide/en/kibana/7.7/kuery-query.html&lt;/p&gt;
&lt;p&gt;　　原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/-beyond/p/14159002.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/-beyond/p/14159002.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;二.KQL简单介绍&lt;/h2&gt;
&lt;p&gt;　　KQL（Kibana Query Language），也就是在Kibana上面进行查询时使用的语法。&lt;/p&gt;
&lt;p&gt;　　Kibana中也可以使用Lucene的查询语法，但是这里就不介绍了，可以参考https://www.elastic.co/guide/en/kibana/7.7/lucene-query.html&lt;/p&gt;

&lt;h2&gt;三.使用索引匹配查询&lt;/h2&gt;
&lt;p&gt;　　在Kibana中进行查询的时候，建议使用指定索引查询，这样的效率更高，而不建议使用全局查找的方式。&lt;/p&gt;
&lt;p&gt;　　比如查找response为200的日志，那么就写为response:200，这样去查找中response值为200的文档对象；&lt;/p&gt;
&lt;p&gt;　　如果没有指定response为200，那么只是单纯的查找200，那么可能会返回金额为200的文档对象（假设有金额字段），查询的效率不高，同时也会返回一些不需要的数据；　&lt;/p&gt;

&lt;h2&gt;四.Kibana查询语法&lt;/h2&gt;
&lt;h3&gt;实例1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
response:200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个表达式，会查询出response字段中&lt;strong&gt;包含&lt;/strong&gt;200的文档对象，注意是包含，包含的是200这一个词，比如下面几种情况都会被查询出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
200
hello world 200
hello 200 world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的是1200或者2001，是不能被查出来的。&lt;/p&gt;

&lt;h3&gt;实例2&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
message:&quot;hello world yes&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个表达式，是针对message字段进行搜索，在搜索的时候不会区分大小写，也就是说，Hello world YES也是会被搜索出来的；&lt;/p&gt;
&lt;p&gt;　　需要注意，上面的&quot;hello world yes&quot;使用了引号，这样的话，这3个单词会被作为一个词进行查询，不会再进行分词，也就是说匹配的时候只会匹配hello world yes这样的顺序匹配，而不会匹配出helllo yes world；&lt;/p&gt;

&lt;h3&gt;实例3&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
message:hello world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个表达式，针对message字段进行搜索，搜索message中&lt;strong&gt;包含&lt;/strong&gt;hello，或者&lt;strong&gt;包含&lt;/strong&gt;world，或者两者都&lt;strong&gt;包含&lt;/strong&gt;的情况；&lt;/p&gt;
&lt;p&gt;　　需要注意的是，&lt;strong&gt;不区分大小写，也不会保证顺序&lt;/strong&gt;，也就是说，下面几种情况都会被匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
hello
world
Hello
World
hello world
Hello world
hello yes World
yes world
world yes
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实例4&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
name:jane or addr:beijing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会查询name字段包含jane，或者addr字段包含beijing的记录，或者两者都匹配；&lt;/p&gt;
&lt;p&gt;　　需要注意的是，or表示“或”，不区分大小写；&lt;/p&gt;

&lt;h3&gt;实例5&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
name:jane and addr:beijing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个条件，会查询name字段包含jane，且addr字段包含beijing的记录。&lt;/p&gt;

&lt;h3&gt;实例6&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
name:jane and addr:beijing or job:teacher
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件中，出现了and和or，需要记住的是，KQL中，and的优先级高于or；&lt;/p&gt;
&lt;p&gt;　　所以上面的查询条件，会查询name包含jane，且addr包含beijing的记录，或者job包含teacher的记录，可以使用括号来让上面的查询条件更好理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
(name:jane and addr:beijing) or job:teacher
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;实例7&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
name:jane and (addr:beijing or job:teacher)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个表达式，主要是想表明，可以使用括号来控制匹配的优先级。&lt;/p&gt;

&lt;h3&gt;实例8&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
response:(200 or 404)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个表达式，会查询response包含200，或者response包含404，或者包含200和404的记录（不保证顺序、不区分大小写）；&lt;/p&gt;
&lt;p&gt;　　同时可以使用and来表示“且”的关系。&lt;/p&gt;

&lt;h3&gt;实例9&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
not response:200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会查询出response字段中不包含200的记录。&lt;/p&gt;

&lt;h3&gt;实例10&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
response:200 and not yes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会查询response包含200，并且整条记录不包含yes的数据记录；&lt;/p&gt;

&lt;h3&gt;实例11&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
response:(200 and not yes)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会查询response包含200，且response不包含yes的记录。&lt;/p&gt;

&lt;h3&gt;实例12&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
response:*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会返回所有包含response字段的文档对象。&lt;/p&gt;

&lt;h3&gt;实例13&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
machine*:hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个查询条件，会查询machine1字段，machine2字段...machinexyzabc字段包含hello的数据记录，这里只是想表达，对于搜索的字段列，也是可以使用通配符的。&lt;/p&gt;

&lt;h2&gt;五.总结&lt;/h2&gt;
&lt;p&gt;　　KQL还是比较简单地，主要记住KQL匹配时是不区分大小写的，可以使用括号改变匹配优先级；&lt;/p&gt;
&lt;p&gt;　　另外一个要点就是，匹配是“包含”，某个字段“包含”某个词，而不是某个字段的值为某个词。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/-beyond/p/14159002.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/-beyond/p/14159002.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;　　https://www.elastic.co/guide/en/kibana/7.7/search.html&lt;/p&gt;
&lt;p&gt;　　https://www.elastic.co/guide/en/kibana/7.7/kuery-query.html&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 15:13:00 +0000</pubDate>
<dc:creator>寻觅beyond</dc:creator>
<og:description>一.前言 现在大多数的公司都会使用ELK组合来对日志数据的收集、存储和提供查询服务，这里就不介绍什么是ELK了，只介绍一些EKL中的查询，也就是K（kibana）。 查询数据库，如果是MySQL，那么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/-beyond/p/14159002.html</dc:identifier>
</item>
<item>
<title>多图详解Go的sync.Pool源码 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/14194872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/14194872.html</guid>
<description>&lt;blockquote readability=&quot;5.6434108527132&quot;&gt;
&lt;p&gt;转载请声明出处哦~，本篇文章发布于luozhiyun的博客：&lt;a href=&quot;https://www.luozhiyun.com&quot; target=&quot;_blank&quot;&gt;https://www.luozhiyun.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文使用的go的源码时14.4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;pool介绍&quot;&gt;Pool介绍&lt;/h3&gt;
&lt;p&gt;总所周知Go 是一个自动垃圾回收的编程语言，采用三色并发标记算法标记对象并回收。如果你想使用 Go 开发一个高性能的应用程序的话，就必须考虑垃圾回收给性能带来的影响。因为Go 在垃圾回收的时候会有一个STW（stop-the-world，程序暂停）的时间，并且如果对象太多，做标记也需要时间。&lt;/p&gt;
&lt;p&gt;所以如果采用对象池来创建对象，增加对象的重复利用率，使用的时候就不必在堆上重新创建对象可以节省开销。&lt;/p&gt;
&lt;p&gt;在Go中，sync.Pool提供了对象池的功能。它对外提供了三个方法：New、Get 和 Put。下面用一个简短的例子来说明一下Pool使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var pool *sync.Pool
type Person struct {
        Name string
}

func init() {
        pool = &amp;amp;sync.Pool{
                New: func() interface{}{
                        fmt.Println(&quot;creating a new person&quot;)
                        return new(Person)
                },
        }
}

func main() {

        person := pool.Get().(*Person)
        fmt.Println(&quot;Get Pool Object：&quot;, person)

        person.Name = &quot;first&quot;
        pool.Put(person)

        fmt.Println(&quot;Get Pool Object：&quot;,pool.Get().(*Person))
        fmt.Println(&quot;Get Pool Object：&quot;,pool.Get().(*Person))

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;creating a new person
Get Pool Object： &amp;amp;{}
Get Pool Object： &amp;amp;{first}
creating a new person
Get Pool Object： &amp;amp;{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我用了init方法初始化了一个pool，然后get了三次，put了一次到pool中，如果pool中没有对象，那么会调用New函数创建一个新的对象，否则会重put进去的对象中获取。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type Pool struct {
        noCopy noCopy 
        local     unsafe.Pointer  
        localSize uintptr 
        victim     unsafe.Pointer 
        victimSize uintptr 
        New func() interface{}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pool结构体里面noCopy代表这个结构体是禁止拷贝的，它可以在我们使用 &lt;code&gt;go vet&lt;/code&gt; 工具的时候生效；&lt;/p&gt;
&lt;p&gt;local是一个poolLocal数组的指针，localSize代表这个数组的大小；同样victim也是一个poolLocal数组的指针，每次垃圾回收的时候，Pool 会把 victim 中的对象移除，然后把 local 的数据给 victim；local和victim的逻辑我们下面会详细介绍到。&lt;/p&gt;
&lt;p&gt;New函数是在创建pool的时候设置的，当pool没有缓存对象的时候，会调用New方法生成一个新的对象。&lt;/p&gt;
&lt;p&gt;下面我们对照着pool的结构图往下讲，避免找不到北：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201226184341.png&quot; alt=&quot;Group 25&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type poolLocal struct {
        poolLocalInternal 
        pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;local字段存储的是一个poolLocal数组的指针，poolLocal数组大小是goroutine中P的数量，访问时，P的id对应poolLocal数组下标索引，所以Pool的最大个数runtime.GOMAXPROCS(0)。&lt;/p&gt;
&lt;p&gt;通过这样的设计，每个P都有了自己的本地空间，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。如果对goroutine的P、G、M有疑惑的同学不妨看看这篇文章：&lt;a href=&quot;https://morsmachine.dk/go-scheduler&quot; target=&quot;_blank&quot;&gt;The Go scheduler&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;poolLocal里面有一个pad数组用来占位用，防止在 cache line 上分配多个 poolLocalInternal从而造成false sharing，有关于false sharing可以看看这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10&quot; target=&quot;_blank&quot;&gt;What’s false sharing and how to solve it&lt;/a&gt; ，文中对于false sharing的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;That’s what false sharing is: one core update a variable would force other cores to update cache either.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type poolLocalInternal struct {
        private interface{} // Can be used only by the respective P.
        shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poolLocalInternal包含两个字段private和shared。&lt;/p&gt;
&lt;p&gt;private代表缓存的一个元素，只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题；&lt;/p&gt;
&lt;p&gt;shared则可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type poolChain struct { 
        head *poolChainElt 
        tail *poolChainElt
}

type poolChainElt struct {
        poolDequeue 
        next, prev *poolChainElt
}

type poolDequeue struct { 
        headTail uint64 
        vals []eface
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poolChain是一个双端队列，里面的head和tail分别指向队列头尾；poolDequeue里面存放真正的数据，是一个单生产者、多消费者的固定大小的无锁的环状队列，headTail是环状队列的首位位置的指针，可以通过位运算解析出首尾的位置，生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。&lt;/p&gt;
&lt;p&gt;这个双端队列的模型大概是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201226184348.png&quot; alt=&quot;Group 26&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;poolDequeue里面的环状队列大小是固定的，后面分析源码我们会看到，当环状队列满了的时候会创建一个size是原来两倍大小的环状队列。大家这张图好好体会一下，会反复用到。&lt;/p&gt;
&lt;h3 id=&quot;get方法&quot;&gt;Get方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) Get() interface{} {
        ...
    //1.把当前goroutine绑定在当前的P上
        l, pid := p.pin()
    //2.优先从local的private中获取
        x := l.private
        l.private = nil
        if x == nil { 
        //3，private没有，那么从shared的头部获取
                x, _ = l.shared.popHead()
        //4. 如果都没有，那么去别的local上去偷一个
                if x == nil {
                        x = p.getSlow(pid)
                }
        }
    //解除抢占
        runtime_procUnpin()
        ...
    //5. 如果没有获取到，尝试使用New函数生成一个新的
        if x == nil &amp;amp;&amp;amp; p.New != nil {
                x = p.New()
        }
        return x
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这一段代码首先会将当前goroutine绑定在当前的P上返回对应的local，然后尝试从local的private中获取，然后需要把private字段置空，因为已经拿到了想要的对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;private中获取不到，那么就去shared的头部获取；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;shared也没有，那么尝试遍历所有的 local，尝试从它们的 shared 弹出一个元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后如果还是没有，那么就直接调用预先设置好的 New 函数，创建一个出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;pin&quot;&gt;pin&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) pin() (*poolLocal, int) {
        pid := runtime_procPin() 
        s := atomic.LoadUintptr(&amp;amp;p.localSize) // load-acquire
        l := p.local                          // load-consume
        if uintptr(pid) &amp;lt; s {
                return indexLocal(l, pid), pid
        }
        return p.pinSlow()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pin方法里面首先会调用runtime_procPin方法会先获取当前goroutine，然后绑定到对应的M上，然后返回M目前绑定的P的id，因为这个pid后面会用到，防止在使用途中P被抢占，具体的细节可以看这篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/99710992%E3%80%82&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/99710992。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来会使用原子操作取出localSize，如果当前pid大于localSize，那么就表示Pool还没创建对应的poolLocal，那么调用pinSlow进行创建工作，否则调用indexLocal取出pid对应的poolLocal返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func indexLocal(l unsafe.Pointer, i int) *poolLocal {
        lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{}))
        return (*poolLocal)(lp)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;indexLocal里面是使用了地址操作，传入的i是数组的index值，所以需要获取poolLocal{}的size做一下地址的位移操作，然后再转成转成poolLocal地址返回。&lt;/p&gt;
&lt;h4 id=&quot;pinslow&quot;&gt;pinSlow&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) pinSlow() (*poolLocal, int) { 
        // 解除pin
        runtime_procUnpin()
        // 加上全局锁
        allPoolsMu.Lock()
        defer allPoolsMu.Unlock()
        // pin住
        pid := runtime_procPin() 
        s := p.localSize
        l := p.local
        // 重新对pid进行检查
        if uintptr(pid) &amp;lt; s {
                return indexLocal(l, pid), pid
        }
        // 初始化local前会将pool放入到allPools数组中
        if p.local == nil {
                allPools = append(allPools, p)
        } 
        // 当前P的数量
        size := runtime.GOMAXPROCS(0)
        local := make([]poolLocal, size)
        atomic.StorePointer(&amp;amp;p.local, unsafe.Pointer(&amp;amp;local[0]))  
        atomic.StoreUintptr(&amp;amp;p.localSize, uintptr(size))         
        return &amp;amp;local[pid], pid
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为allPoolsMu是一个全局Mutex锁，因此上锁会比较慢可能被阻塞，所以上锁前调用runtime_procUnpin方法解除pin的操作；&lt;/p&gt;
&lt;p&gt;在解除绑定后，pinSlow 可能被其他的线程调用过了，p.local 可能会发生变化。因此这时候需要再次对 pid 进行检查。&lt;/p&gt;
&lt;p&gt;最后初始化local，并使用原子操作对local和localSize设值，返回当前P对应的local。&lt;/p&gt;
&lt;p&gt;到这里pin方法终于讲完了。画一个简单的图描述一下这整个流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201226184352.png&quot; alt=&quot;Group 22&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们再回到Get方法中往下走，代码我再贴一遍，以便阅读：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) Get() interface{} {
        ...
    //2.优先从local的private中获取
        x := l.private
        l.private = nil
        if x == nil { 
        //3，private没有，那么从shared的头部获取
                x, _ = l.shared.popHead()
        //4. 如果都没有，那么去别的local上去偷一个
                if x == nil {
                        x = p.getSlow(pid)
                }
        }
    ...
        return x
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果private中没有值，那么会调用shared的popHead方法获取值。&lt;/p&gt;
&lt;h4 id=&quot;pophead&quot;&gt;popHead&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (c *poolChain) popHead() (interface{}, bool) {
        // 这里头部是一个poolChainElt
        d := c.head
        // 遍历poolChain链表
        for d != nil {
                // 从poolChainElt的环状列表中获取值
                if val, ok := d.popHead(); ok {
                        return val, ok
                } 
                // load poolChain下一个对象
                d = loadPoolChainElt(&amp;amp;d.prev)
        }
        return nil, false
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;popHead方法里面会获取到poolChain的头结点，不记得poolChain数据结构的同学建议往上面翻一下再回来。&lt;/p&gt;
&lt;p&gt;接着有个for循环会挨个从poolChain的头结点往下遍历，直到获取对象返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (d *poolDequeue) popHead() (interface{}, bool) {
        var slot *eface
        for {
                ptrs := atomic.LoadUint64(&amp;amp;d.headTail)
                // headTail的高32位为head，低32位为tail
                head, tail := d.unpack(ptrs)
                // 首尾相等，那么这个队列就是空的
                if tail == head { 
                        return nil, false
                } 
                // 这里需要head--之后再获取slot
                head--
                ptrs2 := d.pack(head, tail)
                if atomic.CompareAndSwapUint64(&amp;amp;d.headTail, ptrs, ptrs2) { 
                        slot = &amp;amp;d.vals[head&amp;amp;uint32(len(d.vals)-1)]
                        break
                }
        } 
        val := *(*interface{})(unsafe.Pointer(slot))
        // 说明没取到缓存的对象，返回 nil
        if val == dequeueNil(nil) {
                val = nil
        } 
        // 重置slot 
        *slot = eface{}
        return val, true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;poolDequeue的popHead方法首先会获取到headTail的值，然后调用unpack解包，headTail是一个64位的值，高32位表示head，低32位表示tail。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断head和tail是否相等，相等那么这个队列就是空的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果队列不是空的，那么将head减一之后再使用，因为head当前指的位置是空值，表示下一个新对象存放的位置；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CAS重新设值新的headTail，成功之后获取slot，这里因为vals大小是2的n 次幂，因此&lt;code&gt;len(d.vals)-1)&lt;/code&gt;之后低n位全是1，和head取与之后可以获取到head的低n位的值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果slot所对应的对象是dequeueNil，那么表示是空值，直接返回，否则将slot指针对应位置的值置空，返回val。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果shared的popHead方法也没获取到值，那么就需要调用getSlow方法获取了。&lt;/p&gt;
&lt;h4 id=&quot;getslow&quot;&gt;getSlow&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) getSlow(pid int) interface{} { 
        size := atomic.LoadUintptr(&amp;amp;p.localSize) // load-acquire
        locals := p.local                        // load-consume 
        // 遍历locals列表，从其他的local的shared列表尾部获取对象
        for i := 0; i &amp;lt; int(size); i++ {
                l := indexLocal(locals, (pid+i+1)%int(size))
                if x, _ := l.shared.popTail(); x != nil {
                        return x
                }
        } 
        size = atomic.LoadUintptr(&amp;amp;p.victimSize)
        if uintptr(pid) &amp;gt;= size {
                return nil
        }
        locals = p.victim
        l := indexLocal(locals, pid)
        // victim的private不为空则返回
        if x := l.private; x != nil {
                l.private = nil
                return x
        }
        //  遍历victim对应的locals列表，从其他的local的shared列表尾部获取对象
        for i := 0; i &amp;lt; int(size); i++ {
                l := indexLocal(locals, (pid+i)%int(size))
                if x, _ := l.shared.popTail(); x != nil {
                        return x
                }
        } 
        // 获取不到，将victimSize置为0
        atomic.StoreUintptr(&amp;amp;p.victimSize, 0)
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getSlow方法会遍历locals列表，这里需要注意的是，遍历是从索引为 pid+1 的 poolLocal 处开始，尝试调用shared的popTail方法获取对象；如果没有拿到，则从 victim 里找。如果都没找到，那么就将victimSize置为0，下次就不找victim了。&lt;/p&gt;
&lt;h4 id=&quot;poolchainpoptail&quot;&gt;poolChain&amp;amp;popTail&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (c *poolChain) popTail() (interface{}, bool) {
        d := loadPoolChainElt(&amp;amp;c.tail)
        // 如果最后一个节点是空的，那么直接返回
        if d == nil {
                return nil, false
        }

        for { 
                // 这里获取的是next节点，与一般的双向链表是相反的
                d2 := loadPoolChainElt(&amp;amp;d.next)
                // 获取尾部对象
                if val, ok := d.popTail(); ok {
                        return val, ok
                }

                if d2 == nil { 
                        return nil, false
                } 
                // 因为d已经没有数据了，所以重置tail为d2，并删除d2的上一个节点
                if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) {
                        storePoolChainElt(&amp;amp;d2.prev, nil)
                }
                d = d2
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;判断poolChain，如果最后一个节点是空的，那么直接返回；&lt;/li&gt;
&lt;li&gt;进入for循环，获取tail的next节点，这里需要注意的是这个双向链表与一般的链表是反向的，不清楚的可以再去看看第一张图；&lt;/li&gt;
&lt;li&gt;调用popTail获取poolDequeue列表的对象，有对象直接返回；&lt;/li&gt;
&lt;li&gt;d2为空则表示已经遍历完整个poolChain双向列表了，都为空，那么直接返回；&lt;/li&gt;
&lt;li&gt;通过CAS将tail重置为d2，因为d已经没有数据了，并将d2的prev节点置为nil，然后将d置为d2，进入下一个循环；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;pooldequeuepoptail&quot;&gt;poolDequeue&amp;amp;popTail&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (d *poolDequeue) popTail() (interface{}, bool) {
        var slot *eface
        for {
                ptrs := atomic.LoadUint64(&amp;amp;d.headTail)
                // 和pophead一样，将headTail解包
                head, tail := d.unpack(ptrs)
                // 首位相等，表示列表中没有数据，返回
                if tail == head { 
                        return nil, false
                } 
                ptrs2 := d.pack(head, tail+1)
                // CAS重置tail位置
                if atomic.CompareAndSwapUint64(&amp;amp;d.headTail, ptrs, ptrs2) { 
                        // 获取tail位置对象
                        slot = &amp;amp;d.vals[tail&amp;amp;uint32(len(d.vals)-1)]
                        break
                }
        } 
        val := *(*interface{})(unsafe.Pointer(slot))
        // 判断对象是不是为空
        if val == dequeueNil(nil) {
                val = nil
        } 
        // 将slot置空
        slot.val = nil
        atomic.StorePointer(&amp;amp;slot.typ, nil) 
        return val, true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看懂了popHead，那么这个popTail方法是和它非常的相近的。&lt;/p&gt;
&lt;p&gt;popTail简单来说也是从队列尾部移除一个元素，如果队列为空，返回 false。但是需要注意的是，这个popTail可能会被多个消费者调用，所以需要循环CAS获取对象；在poolDequeue环状列表中tail是有数据的，不必像popHead中&lt;code&gt;head--&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，需要将slot置空。&lt;/p&gt;
&lt;p&gt;大家可以再对照一下图回顾一下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201226184358.png&quot; alt=&quot;Group 39&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;put方法&quot;&gt;Put方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *Pool) Put(x interface{}) {
        if x == nil {
                return
        }
        ...
        l, _ := p.pin()
        if l.private == nil {
                l.private = x
                x = nil
        }
        if x != nil {
                l.shared.pushHead(x)
        }
    runtime_procUnpin()
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完了Get方法，看Put方法就容易多了。同样Put方法首先会去Pin住当前goroutine和P，然后尝试将 x 赋值给 private 字段。如果private不为空，那么就调用pushHead将其放入到shared队列中。&lt;/p&gt;
&lt;h4 id=&quot;poolchainpushhead&quot;&gt;poolChain&amp;amp;pushHead&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (c *poolChain) pushHead(val interface{}) {
        d := c.head
        // 头节点没有初始化，那么设值一下
        if d == nil {
                const initSize = 8 // Must be a power of 2
                d = new(poolChainElt)
                d.vals = make([]eface, initSize)
                c.head = d
                storePoolChainElt(&amp;amp;c.tail, d)
        }
        // 将对象加入到环状队列中
        if d.pushHead(val) {
                return
        }
        newSize := len(d.vals) * 2
        // 这里做了限制，单个环状队列不能超过2的30次方大小
        if newSize &amp;gt;= dequeueLimit {
                newSize = dequeueLimit
        }
        // 初始化新的环状列表，大小是d的两倍
        d2 := &amp;amp;poolChainElt{prev: d}
        d2.vals = make([]eface, newSize)
        c.head = d2
        storePoolChainElt(&amp;amp;d.next, d2)
        // push到新的队列中
        d2.pushHead(val)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果头节点为空，那么需要创建一个新的poolChainElt对象作为头节点，大小为8；然后调用pushHead放入到环状队列中；&lt;/p&gt;
&lt;p&gt;如果放置失败，那么创建一个 poolChainElt 节点，并且双端队列的长度翻倍，当然长度也不能超过dequeueLimit，即2的30次方；&lt;/p&gt;
&lt;p&gt;然后将新的节点d2和d互相绑定一下，并将d2设值为头节点，将传入的对象push到d2中；&lt;/p&gt;
&lt;h4 id=&quot;pooldequeuepushhead&quot;&gt;poolDequeue&amp;amp;pushHead&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (d *poolDequeue) pushHead(val interface{}) bool {
        ptrs := atomic.LoadUint64(&amp;amp;d.headTail)
        // 解包headTail
        head, tail := d.unpack(ptrs)
        // 判断队列是否已满
        if (tail+uint32(len(d.vals)))&amp;amp;(1&amp;lt;&amp;lt;dequeueBits-1) == head { 
                return false
        }
        // 找到head的槽位
        slot := &amp;amp;d.vals[head&amp;amp;uint32(len(d.vals)-1)] 
        // 检查slot是否和popTail有冲突
        typ := atomic.LoadPointer(&amp;amp;slot.typ)
        if typ != nil { 
                return false
        } 
        if val == nil {
                val = dequeueNil(nil)
        }
        // 将 val 赋值到 slot，并将 head 指针值加 1
        *(*interface{})(unsafe.Pointer(slot)) = val 
        atomic.AddUint64(&amp;amp;d.headTail, 1&amp;lt;&amp;lt;dequeueBits)
        return true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过位运算判断队列是否已满，也就是将尾部指针加上 &lt;code&gt;len(d.vals)&lt;/code&gt; ，因为head指向的是将要被填充的位置，所以head和tail位置是相隔&lt;code&gt;len(d.vals)&lt;/code&gt;，然后再取低 31 位，看它是否和 head 相等。如果队列满了，直接返回 false；&lt;/p&gt;
&lt;p&gt;然后找到找到head的槽位slot，并判断typ是否为空，因为popTail 是先设置 val，再将 typ 设置为 nil，所以如果有冲突，那么直接返回；&lt;/p&gt;
&lt;p&gt;最后设值slot，并将head加1返回；&lt;/p&gt;
&lt;h3 id=&quot;gc&quot;&gt;GC&lt;/h3&gt;
&lt;p&gt;在pool.go文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func init() {
        runtime_registerPoolCleanup(poolCleanup)
}

func poolCleanup() { 
        for _, p := range oldPools {
                p.victim = nil
                p.victimSize = 0
        } 
        for _, p := range allPools {
                p.victim = p.local
                p.victimSize = p.localSize
                p.local = nil
                p.localSize = 0
        } 
        oldPools, allPools = allPools, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poolCleanup&lt;/code&gt; 会在 STW 阶段被调用。主要是将 local 和 victim 作交换，那么不至于GC 把所有的 Pool 都清空了，而是需要两个 &lt;code&gt;GC&lt;/code&gt; 周期才会被释放。如果 &lt;code&gt;sync.Pool&lt;/code&gt; 的获取、释放速度稳定，那么就不会有新的池对象进行分配。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Pool这个概念在后台优化中是一个非常重要的手段，比如说在使用Http的时候会使用Http连接池，使用数据库的时候，也会用到数据库连接池。这些通过对象重用和预先分配可以减少服务器的压力。&lt;/p&gt;
&lt;p&gt;当我们在后期的项目开发中，如果发现GC耗时很高，有大量临时对象时不妨可以考虑使用Pool。&lt;/p&gt;
&lt;p&gt;例如发现现系统中的 goroutine 数量非常多，由于一个goroutine初始栈是2048字节，所以一个服务器上运行数十万的goroutine 也是非常耗时的；这时候就可以考虑使用Worker Pool 来减少 goroutine 的使用。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10&quot; target=&quot;_blank&quot;&gt;https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;amp;mid=2247487149&amp;amp;idx=1&amp;amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;amp;source=41#wechat_redirect&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;amp;mid=2247487149&amp;amp;idx=1&amp;amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;amp;source=41#wechat_redirect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/99710992&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/99710992&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/commit/d5fd2dd6a17a816b7dfd99d4df70a85f1bf0de31#diff-491b0013c82345bf6cfa937bd78b690d&quot; target=&quot;_blank&quot;&gt;https://github.com/golang/go/commit/d5fd2dd6a17a816b7dfd99d4df70a85f1bf0de31#diff-491b0013c82345bf6cfa937bd78b690d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://morsmachine.dk/go-scheduler&quot; target=&quot;_blank&quot;&gt;https://morsmachine.dk/go-scheduler&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Dec 2020 15:03:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>转载请声明出处哦~，本篇文章发布于luozhiyun的博客：https://www.luozhiyun.com 本文使用的go的源码时14.4 Pool介绍 总所周知Go 是一个自动垃圾回收的编程语言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/14194872.html</dc:identifier>
</item>
<item>
<title>SpringMVC学习笔记（一） - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/14194866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/14194866.html</guid>
<description>&lt;p&gt;&lt;span&gt;Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看官方文档：&lt;a href=&quot;https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Spring的web框架围绕&lt;span&gt;&lt;strong&gt;&lt;span&gt;DispatcherServlet&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;[ 调度Servlet ] 设计。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet的作用是将请求分发到不同的处理器&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;SpringMVC执行原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202012/1717524-20201226222428749-1703195486.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;简要分析执行流程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;13&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Handler让具体的Controller执行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;视图解析器将解析的逻辑视图名传给DispatcherServlet。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;最终视图呈现给用户。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;配置web.xml&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;注册DispatcherServlet&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt;
        xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
        xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;&lt;/span&gt;&lt;span&gt;
        version&lt;/span&gt;&lt;span&gt;=&quot;4.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1.注册servlet&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过初始化参数指定SpringMVC配置文件的位置，进行关联&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:springmvc-servlet.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 启动顺序，数字越小，启动越早 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;所有请求都会被springmvc拦截 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;/ 和 /&lt;span&gt;* &lt;span&gt;的区别：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt; url-pattern &amp;gt; / &amp;lt;/ url-pattern &amp;gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt;/p&gt;
&lt;p&gt;&amp;lt; url-pattern &amp;gt; /* &amp;lt;/ url-pattern &amp;gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。&lt;/p&gt;
&lt;div class=&quot;list-paddingleft-2&quot; start=&quot;&quot;&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;注意web.xml版本问题，要最新版！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;注册DispatcherServlet&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;关联SpringMVC的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;启动级别为1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;映射路径为 / 【不要用/*，会404】&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;添加Spring MVC配置文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
      xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.kuang.controller&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 让Spring MVC不处理静态资源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:default-servlet-handler &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
   支持mvc注解驱动
       在spring中一般采用@RequestMapping注解来完成映射关系
       要想使@RequestMapping注解生效
       必须向上下文中注册DefaultAnnotationHandlerMapping
       和一个AnnotationMethodHandlerAdapter实例
       这两个实例分别在类级别和方法级别处理。
       而annotation-driven配置帮助我们自动完成上述两个实例的注入。
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 视图解析器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;
         id&lt;/span&gt;&lt;span&gt;=&quot;internalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 前缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/jsp/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 后缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;创建Controller&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/HelloController&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;真实访问地址 : 项目名/HelloController/hello&lt;/span&gt;
   @RequestMapping(&quot;/hello&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(Model model){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向模型中添加属性msg与值，可以在JSP页面中取出并渲染&lt;/span&gt;
       model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;web-inf/jsp/hello.jsp&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;@Controller是为了让Spring IOC容器初始化时自动扫描到；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;方法中声明Model类型的参数是为了把Action中的数据带到视图中；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/&lt;strong&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/strong&gt;.jsp。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;创建视图层&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过EL表示取出Model中存放的值，或者对象；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
${msg}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;实现步骤其实非常的简单：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;新建一个web项目&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;导入相关jar包&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;编写web.xml , 注册DispatcherServlet&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;编写springmvc配置文件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;接下来就是去创建对应的控制类 , controller&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;最后完善前端视图和controller之间的对应&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;测试运行调试.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用RESTful操作资源&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;http://127.0.0.1/item/1 &lt;span&gt;查询,GET&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;http://127.0.0.1/item &lt;span&gt;新增,POST&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;http://127.0.0.1/item &lt;span&gt;更新,PUT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;http://127.0.0.1/item/1 &lt;span&gt;删除,DELETE&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;测试使用&lt;/h2&gt;
&lt;h3&gt;@PathVariable 注解&lt;/h3&gt;
&lt;p&gt;在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RestFulController {

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射访问路径&lt;/span&gt;
   @RequestMapping(&quot;/commit/{p1}/{p2}&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String index(@PathVariable &lt;span&gt;int&lt;/span&gt; p1, @PathVariable &lt;span&gt;int&lt;/span&gt;&lt;span&gt; p2, Model model){
       
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = p1+&lt;span&gt;p2;
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Spring MVC会自动实例化一个Model对象用于向视图中传值&lt;/span&gt;
       model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+&lt;span&gt;result);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回视图位置&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
       
  }
   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来修改下对应的参数类型，再次测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/commit/{p1}/{p2}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String index(@PathVariable &lt;span&gt;int&lt;/span&gt;&lt;span&gt; p1, @PathVariable String p2, Model model){

   String result &lt;/span&gt;= p1+&lt;span&gt;p2;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Spring MVC会自动实例化一个Model对象用于向视图中传值&lt;/span&gt;
   model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+&lt;span&gt;result);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回视图位置&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;使用method属性指定请求类型&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射访问路径,必须是POST请求&lt;/span&gt;
@RequestMapping(value = &quot;/hello&quot;,method =&lt;span&gt; {RequestMethod.POST})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index2(Model model){
   model.addAttribute(&lt;/span&gt;&quot;msg&quot;, &quot;hello!&quot;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们使用浏览器地址栏进行访问默认是Get请求，会报错405：&lt;/p&gt;
&lt;p&gt;也可以通过注解处理 HTTP 请求的方法：@GetMapping；@PostMapping；@PutMapping；@DeleteMapping；@PatchMapping，效果是一样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
@GetMapping(&quot;/add/{a}/{b}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String test(@PathVariable &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,@PathVariable String b, Model model)
    {
        String res&lt;/span&gt;=a+&lt;span&gt;b;
        model.addAttribute(&lt;/span&gt;&quot;msg&quot;,&quot;get结果为&quot;+&lt;span&gt;res);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
    }
    @PostMapping(&lt;/span&gt;&quot;/add/{a}/{b}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String test2(@PathVariable &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,@PathVariable String b, Model model)
    {
        String res&lt;/span&gt;=a+&lt;span&gt;b;
        model.addAttribute(&lt;/span&gt;&quot;msg&quot;,&quot;method方法结果为&quot;+&lt;span&gt;res);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;跳转&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResultSpringMVC2 {
   @RequestMapping(&lt;/span&gt;&quot;/rsm2/t1&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test1(){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转发&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
  }

   @RequestMapping(&lt;/span&gt;&quot;/rsm2/t2&quot;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test2(){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; &quot;redirect:/index.jsp&quot;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return &quot;redirect:hello.do&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello.do为另一个请求/&lt;/span&gt;
&lt;span&gt;  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;数据处理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;处理提交数据&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、提交的域名称和处理方法的参数名一致&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提交数据 : &lt;span&gt;http://localhost:8080/hello?name=kuangshen&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理方法 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(String name){
   System.out.println(name);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、提交的域名称和处理方法的参数名不一致&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提交数据 : &lt;span&gt;http://localhost:8080/hello?username=kuangshen&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理方法 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@RequestParam(&quot;username&quot;) : username提交的域的名称 .&lt;/span&gt;
@RequestMapping(&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String hello(@RequestParam(&quot;username&quot;&lt;span&gt;) String name){
   System.out.println(name);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、提交的是一个对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求提交的表单域和对象的属性名一致  , 参数使用对象即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、实体类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get/set
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tostring()&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、提交数据 : &lt;span&gt;http://localhost:8080/mvc04/user?name=kuangshen&amp;amp;id=1&amp;amp;age=15&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、处理方法 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String user(User user){
   System.out.println(user);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;数据显示到前端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过Model&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/ct2/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String hello(@RequestParam(&quot;username&quot;&lt;span&gt;) String name, Model model){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装要显示到视图中的数据
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于req.setAttribute(&quot;name&quot;,name);&lt;/span&gt;
   model.addAttribute(&quot;msg&quot;&lt;span&gt;,name);
   System.out.println(name);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;test&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过ModelAndView&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ControllerTest1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Controller {

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个模型视图对象&lt;/span&gt;
       ModelAndView mv = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
       mv.addObject(&lt;/span&gt;&quot;msg&quot;,&quot;ControllerTest1&quot;&lt;span&gt;);
       mv.setViewName(&lt;/span&gt;&quot;test&quot;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过ModelMap&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String hello(@RequestParam(&quot;username&quot;&lt;span&gt;) String name, ModelMap model){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装要显示到视图中的数据
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于req.setAttribute(&quot;name&quot;,name);&lt;/span&gt;
   model.addAttribute(&quot;name&quot;&lt;span&gt;,name);
   System.out.println(name);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;乱码问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;输入中文测试，发现乱码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改了xml文件需要重启服务器！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;utf-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;明天任务：进行ssm框架的整合&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Dec 2020 15:02:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>什么是SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/14194866.html</dc:identifier>
</item>
</channel>
</rss>