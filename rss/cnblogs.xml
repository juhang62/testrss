<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>可用于区块链的共识算法 - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/13443367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/13443367.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;

&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;引言&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇写了&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/13365768.html&quot;&gt;分布式一致性协议&lt;/a&gt;相关理论与算法，那些算法不可用于区块链系统之中，不可防止作恶情况，只能容忍节点宕机、网络分区等情况。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这节，我们一起看看&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/12676437.html&quot;&gt;区块链&lt;/a&gt;中常用的共识算法。先来看看为什么分布式网络需要共识？&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;两军问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghgbd5o31zj30al04rjre.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，白军军队实力强大，且居于要地，蓝军被白军隔开成为了两个军队，只有两个蓝军达成一致（具体几点几分开始进攻白军），方可战胜白军。但蓝军1、蓝军2要想达成一致，必须使用信使穿过白军领地进行互相通信，才能同时进攻取胜。但由于白军可能抓捕信使，导致两方蓝军无法达成共识情况。&lt;strong&gt;所以两军问题表达的是，信道不可信（消息丢失，超时等），如果存在可信信道，则两军问题可解。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两军通信，就像TCP的三次握手，需要双方发送并且得到反馈才能确认彼此以收到正确消息达到共识。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;拜占庭将军问题&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拜占庭将军问题是一个共识问题: 首先是由**莱斯利·兰伯特(Leslie Lamport)**及其他两人于1982年提出，被称为Byzantine Failure。&lt;strong&gt;核心描述是军中可能有叛徒，却要保证进攻一致。与分布式系统类比，节点中有作恶节点，也可能被黑客攻击。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghgbdai41ij309s0b6dgf.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图是丑了一点，大家将就了[捂脸哭]。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拜占庭帝国想要进攻一个强大的城市，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。&lt;strong&gt;困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该明确的是，&lt;strong&gt;拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道是可信安全的。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。以下已假定信道是安全可靠的&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个问题说到底是一个关于一致性和正确性的算法问题，这个算法是针对的是忠诚的将军，因为叛徒可以不传，或者乱传消息捣乱。我们就是要在有叛徒的干扰下，找到一个容忍干扰的算法——BFT（Byzantine fault tolerance）拜占庭容错。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，两军问题是拜占庭将军问题的特例。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么可以称为拜占庭错误？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;作恶节点，或者被黑客攻击的节点。节点宕机、网络分区、超时等都不是拜占庭错误。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;如何解决拜占庭将军问题？&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;司令副官模型&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拜占庭将军问题中：每一个将军都需要与所有将军进行通信，已得知其他将军的进攻安排，从而达到共识。所以拜占庭将军问题可简化为司令——副官模型。一个司令，多个副官，需要一致性协议保证，司令发出的命令，多个副官可以得到一致的结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个司令把自己的命令传递给n-1个副官，使得：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​ &lt;strong&gt;一致性&lt;/strong&gt;：所有忠诚的副官遵守一个命令（结果集中的大多数 n/2+1）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​ &lt;strong&gt;正确性&lt;/strong&gt;：若司令是忠诚的，每一个忠诚的副官遵守他发出的命令。（若将军是作恶的，则只需要遵守第一条）&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;BFT为什么需要节点数n&amp;gt;=3f+1?&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;f为拜占庭错误节点数，也是BFT可以容忍的叛徒数量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反证法，如果n&amp;lt;3f+1 即当f= 1时，n = 3。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;如果司令是忠诚的，一个副官忠诚，一个副官叛徒。当司令发送进攻命令给两个副官，两个副官会彼此询问司令的命令是什么，这时候叛徒副官就会伪造假命令，说司令给他的命令是撤退，那忠诚副官就懵了，因为他收到的是进攻命令，此时忠诚副官不知道司令是叛徒还是另一个副官是叛徒。&lt;/li&gt;
&lt;li&gt;如果司令是叛徒，两个副官是忠诚的。司令分别给两个副官一个进攻，一个撤退；两个副官通信时发现彼此收到的命令不一致，也无法达成共识。&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以得出n&amp;lt;3f+1时无法达到拜占庭容错，需要n&amp;gt;=3f+1。具体推导可看参考里的论文，或者李永乐老师的视频。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;PBFT（Practical Byzantine Fault Tolerance）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BFT假设信道没有问题，也就是不考虑消息不可达、消息丢失、乱序、重复、网络分区等情况。Miguel Castro (卡斯特罗)和 Barbara Liskov （利斯科夫）在1999年发表的论文《 Practical Byzantine Fault Tolerance 》中首次提出 pbft 算法，该算法容错数量也满足 3f+1&amp;lt;=n。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pbft 算法的基本流程主要有以下四步：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端发送请求给主节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主节点广播请求给其它节点，节点执行 pbft 算法的三阶段共识流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;节点处理完三阶段流程后，返回消息给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端收到来自 f+1 个节点的相同消息后，代表共识已经正确完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ghgbevcbjmj319u0p2gp1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图片来于源论文截图，此图中主节点是忠诚的，编号3节点是拜占庭节点（叛徒）。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PBFT是三阶段提交协议。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;客户端将请求发送给主节点，主节点打包为pre-prepare消息分发给系统中的副本。&lt;/li&gt;
&lt;li&gt;副本节点收到主节点发送的pre-prepare消息，并验证；验证通过后广播prepare消息。注意：主节点不广播prepare消息。&lt;/li&gt;
&lt;li&gt;所有节点（包括主节点）在一定时间范围内收到验证通过的，不同的2f个prepare（包含自己的）消息后，开始广播commit消息。&lt;/li&gt;
&lt;li&gt;所有节点收到2f+1个commit消息后，今天提交操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成后响应客户端。客户端收到f+1个消息后即可确定操作共识结束。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么客户端只需要f+1个消息呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设如果没有收到f个消息，但无法判断那f个节点就是拜占庭节点，所以可能最坏的情况下，收到的消息中有f个是拜占庭节点的发出的，那要保持容错性，就需要忠诚的节点数量大于拜占庭节点数量（多数派），即f+1个忠诚节点。所以客户端只需要收到f+1个相同消息，就可以断定已经共识成功了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是PBFT容错只能f个，n&amp;gt;=f+f+(f+1) = 3f + 1。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PBFT还有一个View的概念，使用View进行主节点切换。当副本节点与主节点间的心跳超时， 就会发起视图变更，进行主节点切换。每次视图变更，view=view+1。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主节点 = view % n 。&lt;/strong&gt; 可以看出，PBFT使用轮询当选主节点。我们看prepare阶段，如果主节点是作恶节点，这个阶段是无法收到2f个prepare消息的，因为主节点会像集群中发送多个不同的消息，此时大家收到的不一致，就判断主节点有问题，就会进行视图变更，重选主节点。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;比特币的POW共识&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;POW(proof-of-work)&lt;/strong&gt; 使用计算一个合法的随机数，来增加作恶节点的成本。因为你想作恶，就需要计算合法nonce，如果想要更改某个区块的信息，就需要从那个区块开始，重新计算所有后置区块的合法nonce，成本巨大且不可能实现。所以比特币依靠POW安全运行快十年之久。想要了解POW的可以看一看我之前的文章：&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/13236096.html&quot;&gt;比特币入门&lt;/a&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;POS（Proof of Stake）共识&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;POS：股权证明。大白话就是：持有的币量越多，持有的越久（币龄：比如你持有100个币，持有一天，就是100币龄），可以挖矿的概率越大，获得的币就会越多。比如Dash币，拥有1000Dash，就可以成为master，成为master就有机会去挖矿。POS会让富有的人越富有，但币龄到达某一个值时，会重置为0。这样就可以更换新的人来进行挖矿，避免贫富差距过大。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;DPOS（Delegated Proof of Stake）共识&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DPOS：委托权益证明。通常被理解的DPOS在于Delegated（委托），将自己的权益委托给超级节点，选出超级节点代为出块，自己根据委托权益的比例获得利息。有兴趣的可以看看Bitshares、Steem、EOS、Asch等项目。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我从0到1参与过两条公链开发，我们选用的也是DPOS思想，都是自研的DPOS算法。我理解的DPOS是，通过某种规则选出见证者节点（也可以理解为超级节点），这些节点只负责在矿工打包出区块后对区块进行共识，验证等。而矿工则可以通过其他方式选取，选取方式就可以多种多样，可以采用积分、可以采用信用分（发送的交易数、持有的币量、部署的合约数量、对全网的贡献等），只要能够保证全网使用相同的数据，计算出来的结果是唯一的，可验证追溯的，那就没有问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见证者节点之间的共识就很有意思，基本思想离不开BFT，因为要防止作恶节点。你有什么好的想法，可以互相讨论。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从两军问题，到拜占庭将军问题，以及如何解决拜占庭将军问题，引出了BFT，PBFT。最后泛谈了区块链中常见的共识算法，共识算法主要理解思想，个人认为不该被某种算法禁锢，可根据实际情况进行思维扩展，可能就会创造出更优雅的共识算法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重要&lt;/strong&gt;：文中有错误之处，敬请各位大佬指出。也欢迎对区块链有兴趣的小伙伴进行讨论交流。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考链接&lt;/strong&gt;：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://web.archive.org/web/20170123205550/http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf&quot;&gt;拜占庭将军问题论文&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1yJ411v7xV?t=147&quot;&gt;李永乐老师关于“拜占庭将军问题”视频&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.8btc.com/article/70370&quot;&gt;拜占庭将军问题深入探讨&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://pmg.csail.mit.edu/papers/osdi99.pdf&quot;&gt;PBFT论文&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美团技术团队：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35847127&quot;&gt;共识算法系列之一：raft和pbft算法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 00:51:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>引言 两军问题 拜占庭将军问题 如何解决拜占庭将军问题？ 司令副官模型 PBFT（Practical Byzantine Fault Tolerance） 比特币的POW共识 POS（Proof of</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/9dragon/p/13443367.html</dc:identifier>
</item>
<item>
<title>Spark Streaming——Spark第一代实时计算引擎 - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13444099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13444099.html</guid>
<description>&lt;p&gt;虽然SparkStreaming已经停止更新，Spark的重点也放到了 Structured Streaming ，但由于Spark版本过低或者其他技术选型问题，可能还是会选择SparkStreaming。&lt;br/&gt;SparkStreaming对于时间窗口，事件时间虽然支撑较少，但还是可以满足部分的实时计算场景的，SparkStreaming资料较多，这里也做一个简单介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805160512369-109959799.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spark Streaming在当时是为了与当时的Apache Storm竞争，也让Spark可以用于流式数据的处理。根据其官方文档介绍，Spark Streaming有高吞吐量和容错能力强等特点。Spark Streaming支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ和简单的TCP套接字等等。数据输入后可以用Spark的高度抽象原语如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如HDFS，数据库等。另外Spark Streaming也能和MLlib（机器学习）以及Graphx完美融合。&lt;br/&gt;当然Storm目前已经渐渐淡出，Flink开始大放异彩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805160534384-2133653011.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;spark与storm的对比&quot;&gt;&lt;strong&gt;Spark与Storm的对比&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805160621549-278237844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、sparkstreaming入门&quot;&gt;二、SparkStreaming入门&lt;/h2&gt;
&lt;p&gt;Spark Streaming 是 Spark Core API 的扩展，它支持弹性的，高吞吐的，容错的实时数据流的处理。数据可以通过多种数据源获取，例如 Kafka，Flume，Kinesis 以及 TCP sockets，也可以通过例如 &lt;code&gt;map&lt;/code&gt;，&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;join&lt;/code&gt;，&lt;code&gt;window&lt;/code&gt; 等的高级函数组成的复杂算法处理。最终，处理后的数据可以输出到文件系统，数据库以及实时仪表盘中。事实上，你还可以在 data streams（数据流）上使用 [机器学习] 以及 [图计算] 算法。&lt;br/&gt;在内部，它工作原理如下，Spark Streaming 接收实时输入数据流并将数据切分成多个 batch（批）数据，然后由 Spark 引擎处理它们以生成最终的 stream of results in batches（分批流结果）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805160903163-1300240571.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spark Streaming 提供了一个名为 &lt;em&gt;discretized stream&lt;/em&gt; 或 &lt;em&gt;DStream&lt;/em&gt; 的高级抽象，它代表一个连续的数据流。DStream 可以从数据源的输入数据流创建，例如 Kafka，Flume 以及 Kinesis，或者在其他 DStream 上进行高层次的操作以创建。在内部，一个 DStream 是通过一系列的 [RDDs] 来表示。&lt;/p&gt;
&lt;p&gt;本指南告诉你如何使用 DStream 来编写一个 Spark Streaming 程序。你可以使用 Scala，Java 或者 Python（Spark 1.2 版本后引进）来编写 Spark Streaming 程序。&lt;/p&gt;
&lt;p&gt;在idea中新建maven项目&lt;/p&gt;
&lt;p&gt;引入依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spark-streaming_2.11&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.4.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Project Structure —— Global Libraries —— 把scala 添加到 add module&lt;/p&gt;
&lt;p&gt;新建Scala Class&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.log4j.{Level, Logger}
import org.apache.spark.SparkConf
import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream}
import org.apache.spark.streaming.{Seconds, StreamingContext}


object Demo {

  //屏蔽日志
  Logger.getLogger(&quot;org.apache&quot;)setLevel(Level.WARN)

  def main(args: Array[String]): Unit = {

    //local会有问题  最少两个线程  一个拿数据 一个计算
    //val conf = new SparkConf().setAppName(s&quot;${this.getClass.getSimpleName}&quot;).setMaster(&quot;local&quot;)
    val conf = new SparkConf().setAppName(s&quot;${this.getClass.getSimpleName}&quot;).setMaster(&quot;local[2]&quot;)

    //时间间隔
    val ssc = new StreamingContext(conf,Seconds(1))

    //接收数据 处理

    //socket  demo
    val value: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;localhost&quot;, 9999)


    val words: DStream[String] = value.flatMap(_.split(&quot; &quot;))

    val wordsTuple: DStream[(String, Int)] = words.map((_, 1))

    val wordcount: DStream[(String, Int)] = wordsTuple.reduceByKey(_ + _)

    //触发action
    wordcount.print()

    ssc.start()

    //保持流的运行  等待程序被终止
    ssc.awaitTermination()

  }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;下载一个win10 用的netcat&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eternallybored.org/misc/netcat/&quot;&gt;https://eternallybored.org/misc/netcat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载&lt;a href=&quot;https://eternallybored.org/misc/netcat/netcat-win32-1.12.zip&quot;&gt;netcat 1.12&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压 在目录下启动cmd&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nc  -L -p 9999
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始输入单词 在idea中验证接收&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;h5 id=&quot;初始化streamingcontext&quot;&gt;初始化StreamingContext&lt;/h5&gt;
&lt;p&gt;为了初始化一个 Spark Streaming 程序，一个 &lt;strong&gt;StreamingContext&lt;/strong&gt; 对象必须要被创建出来，它是所有的 Spark Streaming 功能的主入口点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.spark._
import org.apache.spark.streaming._

val conf = new SparkConf().setAppName(appName).setMaster(master)
val ssc = new StreamingContext(conf, Seconds(1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;appName&lt;/code&gt; 参数是展示在集群 UI 界面上的应用程序的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master&lt;/code&gt; 是local 或者spark集群的url（mesos yarn）&lt;/p&gt;
&lt;p&gt;本地测试可以用&lt;strong&gt;local[*]&lt;/strong&gt; 注意要多于两个线程&lt;/p&gt;
&lt;p&gt;Second（1）定义的是batch interval 批处理间隔 就是间隔多久去拿一次数据&lt;/p&gt;
&lt;p&gt;在定义一个 context 之后,您必须执行以下操作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过创建输入 DStreams 来定义输入源。&lt;/li&gt;
&lt;li&gt;通过应用转换和输出操作 DStreams 定义流计算（streaming computations）。&lt;/li&gt;
&lt;li&gt;开始接收输入并且使用 &lt;code&gt;streamingContext.start()&lt;/code&gt; 来处理数据。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;streamingContext.awaitTermination()&lt;/code&gt; 等待处理被终止（手动或者由于任何错误）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;streamingContext.stop()&lt;/code&gt; 来手动的停止处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要记住的几点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一旦一个 context 已经启动，将不会有新的数据流的计算可以被创建或者添加到它。&lt;/li&gt;
&lt;li&gt;一旦一个 context 已经停止，它不会被重新启动。&lt;/li&gt;
&lt;li&gt;同一时间内在 JVM 中只有一个 StreamingContext 可以被激活。&lt;/li&gt;
&lt;li&gt;在 StreamingContext 上的 stop() 同样也停止了 SparkContext。为了只停止 StreamingContext，设置 &lt;code&gt;stop()&lt;/code&gt; 的可选参数，名叫 &lt;code&gt;stopSparkContext&lt;/code&gt; 为 false。&lt;/li&gt;
&lt;li&gt;一个 SparkContext 就可以被重用以创建多个 StreamingContexts，只要前一个 StreamingContext 在下一个StreamingContext 被创建之前停止（不停止 SparkContext）。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;discretized-stream-or-dstream&quot;&gt;&lt;strong&gt;Discretized Stream&lt;/strong&gt; or &lt;strong&gt;DStream&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Discretized Stream&lt;/strong&gt; or &lt;strong&gt;DStream&lt;/strong&gt; 是 Spark Streaming 提供的基本抽象。它代表了一个连续的数据流。可能是数据源接收的流，也可能是转换后的流。&lt;/p&gt;
&lt;p&gt;DStream就是多个和时间相关的一系列连续RDD的集合，比如本例就是间隔一秒的一堆RDD的集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805161950426-906145656.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DStream也是有依赖关系的&lt;/p&gt;
&lt;p&gt;flatMap 操作也是直接作用在DStream上的，就和作用于RDD一样 这样很好理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805161937182-1675969293.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先来看数据源接收的流 这种叫做Input DStreams 他会通过Receivers接收器去不同的数据源接收数据。&lt;/p&gt;
&lt;p&gt;Spark Streaming内置了两种数据源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础的数据源：比如刚才用的socket接收 还有file systems&lt;/li&gt;
&lt;li&gt;高级的数据源：比如kafka 还有flume kinesis等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意本地运行时，不要用local或者local[1],一个线程不够。放到集群上时分配给SparkStreaming的核数必须大于接收器的数量，留一个核去处理数据。&lt;/p&gt;
&lt;p&gt;我们也可以自定义数据源，那我们就需要自己开发一个接收器。&lt;/p&gt;
&lt;h5 id=&quot;transformations&quot;&gt;Transformations&lt;/h5&gt;
&lt;p&gt;在我们接收到Dstreams之后可以进行转换操作，常见转换如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Transformation（转换）&lt;/th&gt;
&lt;th&gt;Meaning（含义）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;30&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;map&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;利用函数 &lt;em&gt;func&lt;/em&gt; 处理原 DStream 的每个元素，返回一个新的 DStream。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;flatMap&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;与 map 相似，但是每个输入项可用被映射为 0 个或者多个输出项。。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;filter&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回一个新的 DStream，它仅仅包含原 DStream 中函数 &lt;em&gt;func&lt;/em&gt; 返回值为 true 的项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;repartition&lt;/strong&gt;(&lt;em&gt;numPartitions&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;通过创建更多或者更少的 partition 以改变这个 DStream 的并行级别（level of parallelism）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;union&lt;/strong&gt;(&lt;em&gt;otherStream&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回一个新的 DStream，它包含源 DStream 和 &lt;em&gt;otherDStream&lt;/em&gt; 的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;count&lt;/strong&gt;()&lt;/td&gt;
&lt;td&gt;通过 count 源 DStream 中每个 RDD 的元素数量，返回一个包含单元素（single-element）RDDs 的新 DStream。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;reduce&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;利用函数 &lt;em&gt;func&lt;/em&gt; 聚集源 DStream 中每个 RDD 的元素，返回一个包含单元素（single-element）RDDs 的新 DStream。函数应该是相关联的，以使计算可以并行化。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;countByValue&lt;/strong&gt;()&lt;/td&gt;
&lt;td&gt;在元素类型为 K 的 DStream上，返回一个（K,long）pair 的新的 DStream，每个 key 的值是在原 DStream 的每个 RDD 中的次数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;reduceByKey&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;当在一个由 (K,V) pairs 组成的 DStream 上调用这个算子时，返回一个新的，由 (K,V) pairs 组成的 DStream，每一个 key 的值均由给定的 reduce 函数聚合起来。&lt;strong&gt;注意&lt;/strong&gt;：在默认情况下，这个算子利用了 Spark 默认的并发任务数去分组。你可以用 numTasks 参数设置不同的任务数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;join&lt;/strong&gt;(&lt;em&gt;otherStream&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;当应用于两个 DStream（一个包含（K,V）对，一个包含 (K,W) 对），返回一个包含 (K, (V, W)) 对的新 DStream。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;cogroup&lt;/strong&gt;(&lt;em&gt;otherStream&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;当应用于两个 DStream（一个包含（K,V）对，一个包含 (K,W) 对），返回一个包含 (K, Seq[V], Seq[W]) 的 tuples（元组）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;transform&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;通过对源 DStream 的每个 RDD 应用 RDD-to-RDD 函数，创建一个新的 DStream。这个可以在 DStream 中的任何 RDD 操作中使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;updateStateByKey&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回一个新的 &quot;状态&quot; 的 DStream，其中每个 key 的状态通过在 key 的先前状态应用给定的函数和 key 的新 valyes 来更新。这可以用于维护每个 key 的任意状态数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里我们特别介绍一下updateStateByKey&lt;/p&gt;
&lt;p&gt;我们如果需要对历史数据进行统计，可能需要去kafka里拿一下之前留存的数据，也可以用updateStateByKey这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//保存状态  聚合相同的单词
    val  wordcount = wordsTuple.updateStateByKey[Int](
      //updateFunction _
      (newValues: Seq[Int], runningCount: Option[Int])=&amp;gt; {
        val newCount = Some(newValues.sum + runningCount.getOrElse(0))
        newCount
      }
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如刚才的单词计数，我们只能统计每一次发过来的消息，但是如果希望统计多次消息就需要用到这个，我们要指定一个checkpoint，就是从哪开始算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//增加成员变量
val checkpointDir = &quot;./ckp&quot;

//在方法中加入checkpoint
ssc.checkpoint(checkpointDir)
    val value: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;localhost&quot;, 9999)
    value.checkpoint(Seconds(4))//官方建议批次时间的1-5倍
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们建立StreamingContext的方法就要改变了 我们把刚才的创建过程提取成方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def creatingFunc():StreamingContext = {

    val conf = new SparkConf().setAppName(s&quot;${this.getClass.getSimpleName}&quot;).setMaster(&quot;local[*]&quot;)
    val ssc = new StreamingContext(conf, Seconds(1))

    ssc.checkpoint(checkpointDir)


    val value: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;localhost&quot;, 9999)

    value.checkpoint(Seconds(4))//官方建议批次时间的1-5倍

    val words: DStream[String] = value.flatMap(_.split(&quot; &quot;))

    val wordsTuple: DStream[(String, Int)] = words.map((_, 1))


    //保存状态  聚合相同的单词
    val  wordcount = wordsTuple.updateStateByKey[Int](
      //updateFunction _
      (newValues: Seq[Int], runningCount: Option[Int])=&amp;gt; {
        val newCount = Some(newValues.sum + runningCount.getOrElse(0))
        newCount
      }
    )

    //触发action
    wordcount.print()
    ssc
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在mian函数中修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def main(args: Array[String]): Unit = {
      val ssc = StreamingContext.getOrCreate(checkpointDir,creatingFunc _)
      ssc.start()
      //保持流的运行  等待程序被终止
      ssc.awaitTermination()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就是，如果有checkpoint，程序会在checkpoint中把程序加载回来（程序被保存为二进制），没有checkpoint的话才会创建。&lt;/p&gt;
&lt;p&gt;将目录下的checkpoint删除，就可以将状态删除。&lt;/p&gt;
&lt;p&gt;生产中updateStateByKey由于会将数据备份要慎重使用，可以考虑用hbase，redis等做替代。或者借助kafka做聚合处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//如果不用updatestateByKey  可以考虑redis
    wordsTuple.foreachRDD(rdd =&amp;gt; {
      rdd.foreachPartition(i =&amp;gt;
        {
          //redis
        }
      )
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;窗口操作&quot;&gt;窗口操作&lt;/h5&gt;
&lt;p&gt;Spark Streaming 也支持 _windowed computations（窗口计算），它允许你在数据的一个滑动窗口上应用 transformation（转换）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805162139288-1841949559.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图显示，窗口在源 DStream 上 _slides（滑动），任何一个窗口操作都需要指定两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;window length（窗口长度）&lt;/em&gt; - 窗口的持续时间。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;sliding interval（滑动间隔）&lt;/em&gt; - 执行窗口操作的间隔。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如计算过去30秒的词频：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val windowedWordCounts = pairs.reduceByKeyAndWindow((a:Int,b:Int) =&amp;gt; (a + b), Seconds(30), Seconds(10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一些常用的窗口操作如下所示，这些操作都需要用到上文提到的两个参数 - &lt;em&gt;windowLength（窗口长度）&lt;/em&gt; 和 &lt;em&gt;slideInterval（滑动的时间间隔）&lt;/em&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Transformation（转换）&lt;/th&gt;
&lt;th&gt;Meaning（含义）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;window&lt;/strong&gt;(&lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回一个新的 DStream，它是基于 source DStream 的窗口 batch 进行计算的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;countByWindow&lt;/strong&gt;(&lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回 stream（流）中滑动窗口元素的数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;strong&gt;reduceByWindow&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;, &lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;返回一个新的单元素 stream（流），它通过在一个滑动间隔的 stream 中使用 &lt;em&gt;func&lt;/em&gt; 来聚合以创建。该函数应该是 associative（关联的）且 commutative（可交换的），以便它可以并行计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;&lt;strong&gt;reduceByKeyAndWindow&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;, &lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;在一个 (K, V) pairs 的 DStream 上调用时，返回一个新的 (K, V) pairs 的 Stream，其中的每个 key 的 values 是在滑动窗口上的 batch 使用给定的函数 &lt;em&gt;func&lt;/em&gt; 来聚合产生的。&lt;strong&gt;Note（注意）:&lt;/strong&gt; 默认情况下，该操作使用 Spark 的默认并行任务数量（local model 是 2，在 cluster mode 中的数量通过 &lt;code&gt;spark.default.parallelism&lt;/code&gt; 来确定）来做 grouping。您可以通过一个可选的 &lt;code&gt;numTasks&lt;/code&gt; 参数来设置一个不同的 tasks（任务）数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;&lt;strong&gt;reduceByKeyAndWindow&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;, &lt;em&gt;invFunc&lt;/em&gt;, &lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;上述 &lt;code&gt;reduceByKeyAndWindow()&lt;/code&gt; 的更有效的一个版本，其中使用前一窗口的 reduce 值逐渐计算每个窗口的 reduce值。这是通过减少进入滑动窗口的新数据，以及 “inverse reducing（逆减）” 离开窗口的旧数据来完成的。一个例子是当窗口滑动时”添加” 和 “减” keys 的数量。然而，它仅适用于 “invertible reduce functions（可逆减少函数）”，即具有相应 “inverse reduce（反向减少）” 函数的 reduce 函数（作为参数 &lt;em&gt;invFunc &amp;lt;/ i&amp;gt;）。像在 reduceByKeyAndWindow 中的那样，reduce 任务的数量可以通过可选参数进行配置。请注意，针对该操作的使用必须启用 checkpointing.&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;countByValueAndWindow&lt;/strong&gt;(&lt;em&gt;windowLength&lt;/em&gt;, &lt;em&gt;slideInterval&lt;/em&gt;, [&lt;em&gt;numTasks&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;在一个 (K, V) pairs 的 DStream 上调用时，返回一个新的 (K, Long) pairs 的 DStream，其中每个 key 的 value 是它在一个滑动窗口之内的频次。像 code&amp;gt;reduceByKeyAndWindow 中的那样，reduce 任务的数量可以通过可选参数进行配置。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;join操作&quot;&gt;Join操作&lt;/h5&gt;
&lt;p&gt;在 Spark Streaming 中可以执行不同类型的 join&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val stream1: DStream[String, String] = ...
val stream2: DStream[String, String] = ...
val joinedStream = stream1.join(stream2)
//也可以用窗口
val windowedStream1 = stream1.window(Seconds(20))
val windowedStream2 = stream2.window(Minutes(1))
val joinedStream = windowedStream1.join(windowedStream2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;dstreams输出操作&quot;&gt;DStreams输出操作&lt;/h5&gt;
&lt;p&gt;输出操作允许将 DStream 的数据推送到外部系统，如数据库或文件系统。&lt;/p&gt;
&lt;p&gt;会触发所有变换的执行，类似RDD的action操作。有如下操作：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Output Operation&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;print&lt;/strong&gt;()&lt;/td&gt;
&lt;td&gt;在运行流应用程序的 driver 节点上的DStream中打印每批数据的前十个元素。这对于开发和调试很有用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Python API 这在 Python API 中称为 &lt;strong&gt;pprint()&lt;/strong&gt;。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;saveAsTextFiles&lt;/strong&gt;(&lt;em&gt;prefix&lt;/em&gt;, [&lt;em&gt;suffix&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;将此 DStream 的内容另存为文本文件。每个批处理间隔的文件名是根据 &lt;em&gt;前缀&lt;/em&gt; 和 &lt;em&gt;后缀_：&lt;/em&gt;&quot;prefix-TIME_IN_MS[.suffix]&quot;_ 生成的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;saveAsObjectFiles&lt;/strong&gt;(&lt;em&gt;prefix&lt;/em&gt;, [&lt;em&gt;suffix&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;将此 DStream 的内容另存为序列化 Java 对象的 &lt;code&gt;SequenceFiles&lt;/code&gt;。每个批处理间隔的文件名是根据 &lt;em&gt;前缀&lt;/em&gt; 和 &lt;em&gt;后缀_：&lt;/em&gt;&quot;prefix-TIME_IN_MS[.suffix]&quot;_ 生成的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Python API 这在Python API中是不可用的。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;saveAsHadoopFiles&lt;/strong&gt;(&lt;em&gt;prefix&lt;/em&gt;, [&lt;em&gt;suffix&lt;/em&gt;])&lt;/td&gt;
&lt;td&gt;将此 DStream 的内容另存为 Hadoop 文件。每个批处理间隔的文件名是根据 &lt;em&gt;前缀&lt;/em&gt; 和 &lt;em&gt;后缀_：&lt;/em&gt;&quot;prefix-TIME_IN_MS[.suffix]&quot;_ 生成的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Python API 这在Python API中是不可用的。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;foreachRDD&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;对从流中生成的每个 RDD 应用函数 &lt;em&gt;func&lt;/em&gt; 的最通用的输出运算符。此功能应将每个 RDD 中的数据推送到外部系统，例如将 RDD 保存到文件，或将其通过网络写入数据库。请注意，函数 &lt;em&gt;func&lt;/em&gt; 在运行流应用程序的 driver 进程中执行，通常会在其中具有 RDD 动作，这将强制流式传输 RDD 的计算。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;foreachrdd设计模式使用&quot;&gt;foreachRDD设计模式使用&lt;/h5&gt;
&lt;p&gt;dstream.foreachRDD允许将数据发送到外部系统。&lt;/p&gt;
&lt;p&gt;但我们不要每次都创建一个连接，解决方案如下：&lt;/p&gt;
&lt;p&gt;减少开销，分区分摊开销&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dstream.foreachRDD { rdd =&amp;gt;
  rdd.foreachPartition { partitionOfRecords =&amp;gt;
    val connection = createNewConnection()
    partitionOfRecords.foreach(record =&amp;gt; connection.send(record))
    connection.close()
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更好的做法是用静态资源池：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dstream.foreachRDD { rdd =&amp;gt;
  rdd.foreachPartition { partitionOfRecords =&amp;gt;
    // ConnectionPool is a static, lazily initialized pool of connections
    val connection = ConnectionPool.getConnection()
    partitionOfRecords.foreach(record =&amp;gt; connection.send(record))
    ConnectionPool.returnConnection(connection)  // return to the pool for future reuse
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;连接kafka&quot;&gt;连接Kafka&lt;/h2&gt;
&lt;p&gt;Apache Kafka是一个高性能的消息系统，由Scala 写成。是由Apache 软件基金会开发的一个开源消息系统项目。&lt;/p&gt;
&lt;p&gt;Kafka 最初是由LinkedIn 开发，并于2011 年初开源。2012 年10 月从Apache Incubator 毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待（低延时）的平台。&lt;/p&gt;
&lt;p&gt;更多kafka相关请查看&lt;a href=&quot;https://mp.weixin.qq.com/s/oFEv5c5zO7NAMA3YYB3CrQ&quot;&gt;Kafka入门宝典（详细截图版）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spark Streaming 2.4.4兼容 kafka 0.10.0 或者更高的版本&lt;/p&gt;
&lt;p&gt;Spark Streaming在2.3.0版本之前是提供了对kafka 0.8 和 0.10的支持的 ，不过在2.3.0以后对0.8的支持取消了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note: Kafka 0.8 support is deprecated as of Spark 2.3.0.&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;&lt;a href=&quot;http://spark.apache.org/docs/latest/streaming-kafka-0-8-integration.html&quot;&gt;spark-streaming-kafka-0-8&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://spark.apache.org/docs/latest/streaming-kafka-0-10-integration.html&quot;&gt;spark-streaming-kafka-0-10&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Broker Version&lt;/td&gt;
&lt;td&gt;0.8.2.1 or higher&lt;/td&gt;
&lt;td&gt;0.10.0 or higher&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;API Maturity&lt;/td&gt;
&lt;td&gt;Deprecated&lt;/td&gt;
&lt;td&gt;Stable&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Language Support&lt;/td&gt;
&lt;td&gt;Scala, Java, Python&lt;/td&gt;
&lt;td&gt;Scala, Java&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Receiver DStream&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Direct DStream&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SSL / TLS Support&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Offset Commit API&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Dynamic Topic Subscription&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;receiver&quot;&gt;Receiver&lt;/h5&gt;
&lt;p&gt;这里简单介绍一下对kafka0.8的一种支持方式：基于Receiver&lt;/p&gt;
&lt;p&gt;依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;groupId = org.apache.spark
 artifactId = spark-streaming-kafka-0-8_2.12
 version = 2.4.4
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.spark.streaming.kafka._

 val kafkaStream = KafkaUtils.createStream(streamingContext,
     [ZK quorum], [consumer group id], [per-topic number of Kafka partitions to consume])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况 程序停掉数据会丢失，为了不丢失自己又写了一份，这种是很多余的。&lt;/p&gt;
&lt;p&gt;由于采用了kafka高阶api，偏移量offset不可控。&lt;/p&gt;
&lt;h5 id=&quot;direct&quot;&gt;Direct&lt;/h5&gt;
&lt;p&gt;Kafka 0.10.0版本以后,采用了更好的一种Direct方式，这种我们需要自己维护偏移量offset。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202008/1089984-20200805161732402-907962801.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直连方式 并行度会更高 生产环境用的最多，0.8版本需要在zk或者redis等地方自己维护偏移量。我们使用0.10以上版本支持自己设置偏移量，我们只需要自己将偏移量写回kafka就可以。&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;groupId = org.apache.spark
artifactId = spark-streaming-kafka-0-10_2.12
version = 2.4.4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kafka 0.10以后 可以将offset写回kafka 我们不需要自己维护offset了，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val conf = new SparkConf().setAppName(&quot;KafkaStreaming&quot;).setMaster(&quot;local[*]&quot;)
    val ssc = new StreamingContext(conf,Seconds(2))
    val kafkaParams = Map[String, Object](
      &quot;bootstrap.servers&quot; -&amp;gt; &quot;localhost:9092,anotherhost:9092&quot;,
      &quot;key.deserializer&quot; -&amp;gt; classOf[StringDeserializer],
      &quot;value.deserializer&quot; -&amp;gt; classOf[StringDeserializer],
      &quot;group.id&quot; -&amp;gt; &quot;use_a_separate_group_id_for_each_stream&quot;,
      //latest  none   earliest
      &quot;auto.offset.reset&quot; -&amp;gt; &quot;earliest&quot;,
      //自动提交偏移量 false
      &quot;enable.auto.commit&quot; -&amp;gt; (false: java.lang.Boolean)
    )
    //val topics = Array(&quot;topicA&quot;, &quot;topicB&quot;)
    val topics = Array(&quot;test_topic&quot;)
    val stream = KafkaUtils.createDirectStream[String, String](
      ssc,
      // 与kafka broker不在一个节点上  用不同策略
      //在一个节点用 PreferBrokers策略  很少见
      LocationStrategies.PreferConsistent,
      ConsumerStrategies.Subscribe[String, String](topics, kafkaParams)
    )
    stream.foreachRDD(rdd =&amp;gt; {
      //普通的RDD不能强转HasOffsetRanges   但kafkaRDD有 with这个特性 可以强转
      val offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges
      //处理数据 计算逻辑
      rdd.foreachPartition { iter =&amp;gt;
        //一次处理一个分区的数据  获取这个分区的偏移量
        //计算完以后修改偏移量  要开启事务 类似数据库 connection -&amp;gt; conn.setAutoCommit(false) 各种操作  conn.commit(); conn.rollback()
        //获取偏移量  如果要自己记录的话这个
        //val o: OffsetRange = offsetRanges(TaskContext.get.partitionId)
        //println(s&quot;${o.topic} ${o.partition} ${o.fromOffset} ${o.untilOffset}&quot;)
        //处理数据
         iter.foreach(println)
      }
      //kafka 0.10新特性  处理完数据后  将偏移量写回kafka
      // some time later, after outputs have completed
      //kafka有一个特殊的topic  保存偏移量
      stream.asInstanceOf[CanCommitOffsets].commitAsync(offsetRanges)
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多Flink，Kafka，Spark等相关技术博文，科技资讯，欢迎关注实时流式计算 公众号后台回复 “电子书” 下载300页Flink实战电子书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 00:35:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>虽然SparkStreaming已经停止更新，Spark的重点也放到了 Structured Streaming ，但由于Spark版本过低或者其他技术选型问题，可能还是会选择SparkStreami</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13444099.html</dc:identifier>
</item>
<item>
<title>MinIO很强-让我放弃FastDFS拥抱MinIO的8个理由 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13444086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13444086.html</guid>
<description>&lt;p&gt;目前可用于文件存储的网络服务选择有很多，比如阿里云OSS、七牛云、腾讯云等等，但是收费都有点小贵。为了帮公司节约成本，之前一直是使用fastDFS作为文件服务器，准确的说是图片服务器。直到我发现了MinIO，我决定放弃FastDFS。&lt;br/&gt;关于MinIO的使用方法，我就不说了。大家去看MinIO官网地址：&lt;a href=&quot;https://docs.min.io/cn/&quot;&gt;docs.min.io/cn/&lt;/a&gt; ，非常详细。我就从对比的角度来说说我为什么果断的放弃了fastDFS，转而使用MinIO作为图片存储服务器。&lt;/p&gt;
&lt;h2 id=&quot;理由一：安装部署运维复杂度&quot;&gt;理由一：安装部署(运维)复杂度&lt;/h2&gt;
&lt;p&gt;之前公司在使用fastDFS的时候，只有少数的几个人能够掌握fasdtDFS的部署结构。所以只要出现有点问题，能够顶上的只有这么几个人。如果将一个fastDFS分布式服务部署完成，需要具备以下的知识&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;linux基础的目录操作&lt;/li&gt;
&lt;li&gt;常用的分布式主从原理&lt;/li&gt;
&lt;li&gt;C语言代码的编译&lt;/li&gt;
&lt;li&gt;nginx安装部署&lt;/li&gt;
&lt;li&gt;nginx插件的使用（防盗链）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果仅仅是上面的这些基础知识，安排几个程序员学一学还好说。主要是fastdfs的部署结构之复杂，如果我长时间不回顾，自己都会忘了这复杂的架构是怎么回事。&lt;br/&gt;当我看到MinIO的安装过程之后，以及分布式的部署命令之后（&lt;a href=&quot;https://docs.min.io/cn/distributed-minio-quickstart-guide.html&quot;&gt;分布式MinIO快速入门&lt;/a&gt;），放弃fastDFS的决心就已经做出了一大半。&lt;br/&gt;说白了：FastDFS的部署不过是零件的组装过程，需要你去理解fastDFS的架构设计，才能够正确的安装部署。MinIO在安装的过程是黑盒的，你不用去深入关注它的架构，也不需要你进行零件组装，基本上可以做到开箱即用。普通的技术人员就能够参与后期运维。&lt;/p&gt;
&lt;h2 id=&quot;理由二：文档&quot;&gt;理由二：文档&lt;/h2&gt;
&lt;p&gt;我觉得从我知道fastDFS开始，也有十年了。竟然没有官方文档，所有的文档全是某某公司的自己总结的文档，或者是某某网友自己总结的文档。&lt;br/&gt;从这点上看fastDFS真的是一败涂地，当然阿里余庆大神在做这个项目的时候可能也没有考虑到后来会有这么多人用。即使用的人多了，在余庆大神眼里可能觉得这只是自己开发的一个小玩具，没有继续深入运营的必要。&lt;/p&gt;
&lt;h2 id=&quot;理由三：开源项目运营组织&quot;&gt;理由三：开源项目运营组织&lt;/h2&gt;
&lt;p&gt;fastdfs是阿里余庆做的一个个人项目，在一些互联网创业公司中有应用，没有官网，不活跃，6个contributors。目前已经很少做更新。&lt;br/&gt;MinIO目前是由2014年在硅谷创立的公司MinIO.Inc运营的开源项目，社区论坛的活跃度目前也非常的不错。&lt;/p&gt;
&lt;h2 id=&quot;理由四：ui界面&quot;&gt;理由四：UI界面&lt;/h2&gt;
&lt;p&gt;我们都知道fastDFS默认是不带UI界面的，看看MinIO的界面吧。这个界面不需要你单独的部署，和服务端一并安装。开箱即用，爱了爱了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200806082637754-1178423266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理由五：性能&quot;&gt;理由五：性能&lt;/h2&gt;
&lt;p&gt;MinIO号称是世界上速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以达到183 GB/s和171 GB/s。关于fastDFS我曾经单线程测试写了20万个文件，总共200G，大约用时10个小时。总体上是很难达到MinIO“号称的”以G为单位的每秒读写速度。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200806082638831-1607794313.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理由六：容器化支持&quot;&gt;理由六：容器化支持&lt;/h2&gt;
&lt;p&gt;MinIO提供了与k8s、etcd、docker等容器化技术深度集成方案，可以说就是为了云环境而生的。这点是FastDFS不具备的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200806082639330-1212346584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理由七：丰富的sdk支持&quot;&gt;理由七：丰富的SDK支持&lt;/h2&gt;
&lt;p&gt;fastDFS目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。下图是MinIO提供的SDK支持，MinIO几乎提供了所有主流开发语言的SDK以及文档。同志们，重要的是文档。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不是说PHP不主流啊，不想引战。求生欲很强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200806082639552-1716004316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;理由八：aws-s3标准兼容&quot;&gt;理由八：AWS S3标准兼容&lt;/h2&gt;
&lt;p&gt;Amazon的S3 API是对象存储领域的事实标准。MinIO是S3兼容性的事实上的标准，是第一个采用API和第一个添加对S3 Select支持的标准之一。包括微软Azure在内的750多家公司使用MinIO的S3网关，这一数字超过了业内其他公司的总和。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200806082639746-45090711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么意思？就是说你现在为了节约成本使用MinIO，等你的公司壮大了、有钱了。不想自己运维基础设施了，你就可以把对象存储放到云上，只要云厂商支持S3标准，你的应用程序是不需要重新开发的。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 00:27:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>目前可用于文件存储的网络服务选择有很多，比如阿里云OSS、七牛云、腾讯云等等，但是收费都有点小贵。为了帮公司节约成本，之前一直是使用fastDFS作为文件服务器，准确的说是图片服务器。直到我发现了Mi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13444086.html</dc:identifier>
</item>
<item>
<title>【译】10 款国外实用、有趣的 GitHub 简介 README  - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13441511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13441511.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174449838-1785465593.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5314685314685&quot;&gt;
&lt;p&gt;本文翻译自 dev.to 文章《10 Standout GitHub Profile READMEs》&lt;br/&gt;原文链接见：&lt;a href=&quot;https://dev.to/github/10-standout-github-profile-readmes-h2o&quot;&gt;https://dev.to/github/10-standout-github-profile-readmes-h2o&lt;/a&gt;&lt;br/&gt;作者 Lee Reilly 介绍：GitHub 官方人员 / 工程师 / 市场 / 社区&lt;br/&gt;译者：HelloGitHub-小鱼干｜校对：HelloGitHub-丫丫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的好友兼同事 &lt;a href=&quot;https://dev.to/bdougieyo&quot;&gt;@bdougieyo&lt;/a&gt; 今天在逛 &lt;a href=&quot;https://codelandconf.com/&quot;&gt;Codeland&lt;/a&gt; （一个由程序员和设计师构成的国外技术社区）时，给三个写 GitHub 简介 README（我们上周刚发布的新功能）的幸运儿开放了 &lt;a href=&quot;https://github.com/features/codespaces/&quot;&gt;Codespaces&lt;/a&gt; （GitHub 官方的云 IDE）的早期访问权。&lt;/p&gt;
&lt;p&gt;如果你正在为定制 GitHub 简介 README 寻找灵感或者素材，这里有一些过去几周让我大吃一惊的 README 例子。无论是纯粹的装扮和展示信息，或是令人惊叹的有趣艺术品，这些例子中都有。&lt;/p&gt;
&lt;h2 id=&quot;1-hello-world&quot;&gt;1 Hello, world!&lt;/h2&gt;
&lt;p&gt;机智如 &lt;a href=&quot;https://github.com/M0nica&quot;&gt;@M0nica&lt;/a&gt; ，用简短的个人介绍、鲜艳的封面图及同她个人有关的 GitHub 外链就做了人群中最靓的“仔”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174606778-1976492490.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;花絮&lt;/strong&gt;: &lt;a href=&quot;https://github.com/M0nica&quot;&gt;@M0nica&lt;/a&gt; 刚发布了&lt;a href=&quot;https://www.aboutmonica.com/blog/how-to-create-a-github-profile-readme/&quot;&gt;如何创建 GitHub 简介 README 的博文&lt;/a&gt;，如果你要添加 GitHub 简介 README 这是一个不错的参考文。&lt;/p&gt;
&lt;h2 id=&quot;2-秀下-github-数值-&quot;&gt;2 秀下 GitHub 数值 💪🏻&lt;/h2&gt;
&lt;p&gt;之前在别的地方我可能聊过这个事情，如果你要用 GitHub 作为你的简历或者是作品集，那么 &lt;a href=&quot;https://github.com/anuraghazra&quot;&gt;@anuraghazra&lt;/a&gt; 做的这个精致小玩意可以很好地帮你展示 GitHub 统计信息。直接在你的仓库中启用 anuraghazra 开源的 &lt;a href=&quot;https://github.com/anuraghazra/github-readme-stats&quot;&gt;github-readme-stats&lt;/a&gt; 就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174616675-1502911312.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-别忘了留言&quot;&gt;3 别忘了留言&lt;/h2&gt;
&lt;p&gt;我的好友 &lt;a href=&quot;https://github.com/jasonetco&quot;&gt;@JasonEtco&lt;/a&gt; 一直在尽 Action 所能来推广 GitHub 和 Action，这次他用 Action 在 GitHub 简介做了一个留言簿。等着你们的点击、浏览、留言三连击，这样我们就功德圆满了哟~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者有话说：如果这句有更好的翻译，欢迎大家和译者说，等你们呦~❤️&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174630918-314732499.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小恶作剧&lt;/strong&gt;: 想到 Jason 个人主页可以留言的特性，欢迎你去他的主页分享一个有趣的笑话或者记录任意一个小事，他不知道本文的存在，所以对这些突然冒出来的留言他肯定会很懵逼 😂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* 小提示&lt;/strong&gt;: 记得明儿取消 Jason 对服务器日志的访问权...&lt;/p&gt;
&lt;h2 id=&quot;4-访客-counter-1&quot;&gt;4 访客 Counter +1&lt;/h2&gt;
&lt;p&gt;提到数字，一定要提下这个 SVG 做的小工具可以帮你展示你的历史访问人数。如果你和我一样是个 Web 老用户，还是足够资深的那种，应该知道曾经每个网页都是有个人主页访问人数统计，谢谢 &lt;a href=&quot;https://github.com/sagar-viradiya&quot;&gt;@sagar-viradiya&lt;/a&gt; 的小工具！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174639220-2138261498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;译者有话说：截止到 2020.07.30 sagar-viradiya 的个人主页访问人数从原作者发文的 1337 涨到了 7287，如果你喜欢这个小工具，可以在本文的评论区留下你是 sagar-viradiya 第几位访客 😊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5-游戏吗？&quot;&gt;5 游戏吗？&lt;/h2&gt;
&lt;p&gt;GitHub 简介出现游戏只是时间的问题，&lt;a href=&quot;https://github.com/jonathangin52&quot;&gt;@jonathangin52&lt;/a&gt; 是一个好榜样 💙 ❤️这款社区主导的 Connect4 可以做你想到任何事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174646694-114950738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者有话说：Connect4 配有英雄榜，可看到获胜数排名前十的玩家 🌚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;6-不来一盘象棋吗？&quot;&gt;6 不来一盘象棋吗？&lt;/h2&gt;
&lt;p&gt;只要可以找到更多的个人简介的游戏，我一定会尽我所能。&lt;/p&gt;
&lt;p&gt;没错！ &lt;a href=&quot;https://github.com/timburgan&quot;&gt;@timburgan&lt;/a&gt; 做的这款小游戏可以让你在 GitHub 简介里下象棋。只要单击链接去创建一个带有移动棋子命令的 issue ，剩下的事情 GitHub Actions 工作流会处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174654570-15041606.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7-不得不提的游戏&quot;&gt;7 不得不提的游戏…&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ethomson&quot;&gt;@ethomson&lt;/a&gt; 对简介 README 的贡献是做了一个外观和感觉都很像 Game of Life 的模拟器 💚&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174703235-978549762.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在后台它用了 &lt;a href=&quot;https://www.npmjs.com/package/contributions&quot;&gt;contributions&lt;/a&gt; 库（可用 GitHub 贡献图构造数据结构的库）和 &lt;a href=&quot;https://www.npmjs.com/package/dat-life&quot;&gt;dat-life&lt;/a&gt; 库（可用于实现 Conway's Game of Life 的库）。 更多详情参见 &lt;a href=&quot;https://github.com/ethomson#how-does-it-work&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;8-在-readme-中播放你在听的音乐-♩-♪-♫-♬&quot;&gt;8 在 README 中播放你在听的音乐 ♩ ♪ ♫ ♬&lt;/h2&gt;
&lt;p&gt;用 Vercel serverless 函数动态呈现 SVG, 再加上 Spotify API 如何？炸了! 你将得到一张你正在听的 Spotify 音乐的封面图。优秀的 &lt;a href=&quot;https://github.com/natemoo-re&quot;&gt;@natemoo-re&lt;/a&gt;，了不起 👏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174714716-890804046.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迫不及待要在我的简介中加上它！🤘&lt;/p&gt;
&lt;h2 id=&quot;9-自我更新的-readme&quot;&gt;9 自我更新的 README&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/simonw&quot;&gt;@simonw&lt;/a&gt; 的简介可以用 GitHub Action 进行自我更新，包括最近 release 信息、博文、学到的玩意。 如果你对这个 README 的实现原理有兴趣，可以阅读下 Simon 发布的&lt;a href=&quot;https://simonwillison.net/2020/Jul/10/self-updating-profile-readme/&quot;&gt;这篇博文&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174724019-2102544274.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;10-恐龙跳一跳&quot;&gt;10 恐龙跳一跳&lt;/h2&gt;
&lt;p&gt;压轴来了，虽然它只是一个 GIF，但是我的天，我竟然盯着它看了好几个小时。这个由 &lt;a href=&quot;https://github.com/saadeghi&quot;&gt;@saadeghi&lt;/a&gt; 制作，大家熟悉的小动画说明，即使只是一个简单的小动画也可以让你的 GitHub 简介多一份个性，与众不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200805174732911-1114735195.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;希望这些例子能给你的制作自己的 README 带来一些灵感。做一个 README 还简单的，只要按照这个&lt;a href=&quot;https://www.aboutmonica.com/blog/how-to-create-a-github-profile-readme/#how-do-i-create-a-profile-readme&quot;&gt;说明&lt;/a&gt;，期待在评论区看到你的大作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200729212020024-1640694833.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Aug 2020 00:16:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文翻译自 dev.to 文章《10 Standout GitHub Profile READMEs》 原文链接见：https://dev.to/github/10-standout-github-p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13441511.html</dc:identifier>
</item>
<item>
<title>mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构 - 六点半起床</title>
<link>http://www.cnblogs.com/chentianming/p/13444045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chentianming/p/13444045.html</guid>
<description>&lt;p&gt;InnoDB一个支持事务安全的存储引擎，同时也是mysql的默认存储引擎。本文主要从数据结构的角度，详细介绍InnoDB行记录格式和数据页的实现原理，从底层看清InnoDB存储引擎。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;innodb简介&quot;&gt;InnoDB简介&lt;/h2&gt;
&lt;p&gt;大家都知道mysql中数据是存储在物理磁盘上的，而真正的数据处理又是在内存中执行的。由于磁盘的读写速度非常慢，如果每次操作都对磁盘进行频繁读写的话，那么性能一定非常差。为了上述问题，&lt;strong&gt;InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB&lt;/strong&gt;。这样的话，一次性至少读取1页数据到内存中或者将1页数据写入磁盘。通过减少内存与磁盘的交互次数，从而提升性能。&lt;/p&gt;
&lt;p&gt;其实，这本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从&lt;code&gt;时间维度&lt;/code&gt;或者&lt;code&gt;空间维度&lt;/code&gt;进行考量的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;时间维度&lt;/code&gt;：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为&lt;code&gt;热点数据缓存&lt;/code&gt;都属于这种思路的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;空间维度&lt;/code&gt;：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。&lt;code&gt;InnoDB的数据页&lt;/code&gt;和&lt;code&gt;操作系统的页缓存&lt;/code&gt;则是这种思路的体现。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;innodb行格式&quot;&gt;InnoDB行格式&lt;/h2&gt;
&lt;p&gt;mysql是以记录(一行数据)为单位向数据表中插入数据的，这些记录在磁盘上的存放方式称为&lt;code&gt;行格式&lt;/code&gt;。mysql支持4种不同类型的行格式：&lt;code&gt;Compact&lt;/code&gt;、&lt;code&gt;Redundant&lt;/code&gt;（比较老，本文就不具体介绍了）、&lt;code&gt;Dynamic&lt;/code&gt;、&lt;code&gt;Compressed&lt;/code&gt;。&lt;br/&gt;我们可以在创建或修改表的语句中指定行格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如，我们要创建一个行格式为&lt;code&gt;Compact&lt;/code&gt;，字符集为&lt;code&gt;ascii&lt;/code&gt;的数据表&lt;code&gt;record_format_demo&lt;/code&gt;，sql如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE record_format_demo (
    -&amp;gt;     c1 VARCHAR(10),
    -&amp;gt;     c2 VARCHAR(10) NOT NULL,
    -&amp;gt;     c3 CHAR(10),
    -&amp;gt;     c4 VARCHAR(10)
    -&amp;gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们向&lt;code&gt;record_format_demo&lt;/code&gt;表中插入了2行数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;compact行格式&quot;&gt;COMPACT行格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806080604976-1787214736.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，一条完整的记录包含&lt;code&gt;记录的额外信息&lt;/code&gt;和&lt;code&gt;记录的真实数据&lt;/code&gt;两大部分。&lt;/p&gt;
&lt;h4 id=&quot;记录的额外信息&quot;&gt;记录的额外信息&lt;/h4&gt;
&lt;p&gt;记录的额外信息主要包含3类：&lt;code&gt;变长字段长度列表&lt;/code&gt;、&lt;code&gt;NULL值列表&lt;/code&gt;和&lt;code&gt;记录头信息&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;变长字段长度列表&quot;&gt;变长字段长度列表&lt;/h5&gt;
&lt;p&gt;mysql中支持一些变长数据类型（比如&lt;code&gt;VARCHAR(M)&lt;/code&gt;、&lt;code&gt;TEXT&lt;/code&gt;等），它们存储数据占用的存储空间不是固定的，而是会随着存储内容的变化而变化。为了准确描述这种数据，这种变长字段占用的存储空间要同时包含：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;真正的数据内容&lt;/li&gt;
&lt;li&gt;占用的字节数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在Compact行格式中，把&lt;strong&gt;所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序&lt;code&gt;逆序&lt;/code&gt;存放&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们以&lt;code&gt;record_format_demo&lt;/code&gt;第一行数据为例。由于&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;c2&lt;/code&gt;和&lt;code&gt;c4&lt;/code&gt;都是变成数据类型(&lt;code&gt;VARCHAR(10)&lt;/code&gt;),因此要将这3列值得长度保存在记录的开头处。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806080628111-2035904548.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外需要注意的一点是，&lt;strong&gt;变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的&lt;/strong&gt;。也就是说对于第二条记录来说，因为c4列的值为NULL，所以第二条记录的变长字段长度列表只需要存储c1和c2列的长度即可。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806080642685-1140236156.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;null值列表&quot;&gt;NULL值列表&lt;/h5&gt;
&lt;p&gt;对于可为NULL的列，为了节约存储空间，mysql不会将&lt;code&gt;NULL&lt;/code&gt;值保存在&lt;code&gt;记录的真实数据&lt;/code&gt;部分。而是会将其保存在&lt;code&gt;记录的额外信息&lt;/code&gt;里面的&lt;code&gt;NULL值列表&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;具体的做法是先统计表中允许存储&lt;code&gt;NULL&lt;/code&gt;值的列，然后将每个允许存储&lt;code&gt;NULL&lt;/code&gt;值的列对应一个二进制位（1：值为&lt;code&gt;NULL&lt;/code&gt;，0：值不为&lt;code&gt;NULL&lt;/code&gt;）用来表示是否存储&lt;code&gt;NULL&lt;/code&gt;值，并按照逆序排列。MySQL规定&lt;strong&gt;NULL值列表必须用整数个字节的位表示&lt;/strong&gt;，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。&lt;br/&gt;对应&lt;code&gt;record_format_demo&lt;/code&gt;表中，&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;c3&lt;/code&gt;、&lt;code&gt;c4&lt;/code&gt;都是允许存储NULL值的。前两条记录在填充了&lt;code&gt;NULL&lt;/code&gt;值列表后的示意图就是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081409577-1805080081.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;记录头信息&quot;&gt;记录头信息&lt;/h5&gt;
&lt;p&gt;记录头信息是由固定的5个字节(40位)组成, 不同的位代表不同的含义：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081454476-1107653214.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;暂时不详细展开。&lt;/p&gt;
&lt;h3 id=&quot;记录的真实数据&quot;&gt;记录的真实数据&lt;/h3&gt;
&lt;p&gt;记录的真实数据除了包含各列具体的数据外，还会自动添加一些隐藏列数据。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;占用空间&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;row_id&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;6字节&lt;/td&gt;
&lt;td&gt;行ID，唯一标识一条记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;transaction_id&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;6字节&lt;/td&gt;
&lt;td&gt;事务ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;roll_pointer&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;7字节&lt;/td&gt;
&lt;td&gt;回滚指针&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，为了美观才写成了row_id、transaction_id和roll_pointer。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只有当数据库没有定义&lt;code&gt;主键&lt;/code&gt;或者&lt;code&gt;唯一键&lt;/code&gt;时，隐藏列&lt;code&gt;row_id&lt;/code&gt;才会存在，并且将其作为数据表&lt;code&gt;主键&lt;/code&gt;。&lt;br/&gt;因为表&lt;code&gt;record_format_demo&lt;/code&gt;并没有定义主键，所以MySQL服务器会为每条记录增加上述的3个列。现在看一下加上&lt;code&gt;记录的真实数据&lt;/code&gt;的两个记录的数据结构：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081530765-473954705.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;charm列的存储格式&quot;&gt;CHAR(M)列的存储格式&lt;/h3&gt;
&lt;p&gt;对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而&lt;strong&gt;如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表&lt;/strong&gt;。&lt;br/&gt;另外有一点还需要注意，变长字符集的&lt;code&gt;CHAR(M)&lt;/code&gt;类型的列要求至少占用&lt;code&gt;M&lt;/code&gt;个字节，而&lt;code&gt;VARCHAR(M)&lt;/code&gt;却没有这个要求。比方说对于使用&lt;code&gt;utf8&lt;/code&gt;字符集的&lt;code&gt;CHAR(10)&lt;/code&gt;的列来说，该列存储的数据字节长度的范围是&lt;code&gt;10～30&lt;/code&gt;个字节，即使我们向该列中存储一个空字符串也会占用&lt;code&gt;10&lt;/code&gt;个字节。&lt;/p&gt;
&lt;h3 id=&quot;行溢出数据&quot;&gt;行溢出数据&lt;/h3&gt;
&lt;h4 id=&quot;varcharm最多能存储的数据&quot;&gt;VARCHAR(M)最多能存储的数据&lt;/h4&gt;
&lt;p&gt;MySQL对一条记录占用的最大存储空间是有限制的，除了&lt;code&gt;BLOB&lt;/code&gt;或者&lt;code&gt;TEXT&lt;/code&gt;类型的列之外，&lt;strong&gt;其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节&lt;/strong&gt;。可以不严谨的认为，&lt;strong&gt;mysql一行记录占用的存储空间不能超过65535个字节&lt;/strong&gt;。这个65535个字节除了列本身的数据之外，还包括一些其他的数据（storage overhead），比如说我们为了存储一个VARCHAR(M)类型的列，其实需要占用3部分存储空间：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;真实数据&lt;/li&gt;
&lt;li&gt;真实数据占用字节的长度&lt;/li&gt;
&lt;li&gt;NULL值标识，如果该列有NOT NULL属性则可以没有这部分存储空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假设&lt;code&gt;varchar_size_demo&lt;/code&gt;只有一个&lt;code&gt;VARCHAR&lt;/code&gt;类型的字段，那么该字段最大占用的65532个字节。因为真实数据的长度可能占用2个字节，&lt;code&gt;NULL值标识&lt;/code&gt;需要占用1个字节。如果该&lt;code&gt;VARCHAR&lt;/code&gt;类型的列没有&lt;code&gt;NOT NULL&lt;/code&gt;属性，那最多只能存储&lt;code&gt;65532&lt;/code&gt;个字节的数据。如果该列是&lt;code&gt;ascii&lt;/code&gt;字符集，对应的最大字符数最大为&lt;code&gt;65532&lt;/code&gt;；如果是&lt;code&gt;utf8&lt;/code&gt;字符集，则对应的最大字符数为&lt;code&gt;21844&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;记录中的数据太多产生的溢出&quot;&gt;记录中的数据太多产生的溢出&lt;/h4&gt;
&lt;p&gt;我们以ascii字符集下的&lt;code&gt;varchar_size_demo&lt;/code&gt;表为例，插入一条记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE varchar_size_demo(
    -&amp;gt;       c VARCHAR(65532)
    -&amp;gt; ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysql中磁盘与内存交互的基本单位是页，一般为16KB，16384个字节，而一行记录最大可以占用&lt;code&gt;65535&lt;/code&gt;个字节，这就造成了&lt;strong&gt;一页存不下一行数据的情况&lt;/strong&gt;。在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页，如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081631133-1055269002.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这种&lt;strong&gt;在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中的情况就叫做&lt;code&gt;行溢出&lt;/code&gt;，存储超出768字节的那些页面也被称为&lt;code&gt;溢出页&lt;/code&gt;&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081701129-101451663.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;行溢出的临界点&quot;&gt;行溢出的临界点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MySQL中规定一个页中至少存放两行记录&lt;/strong&gt;。以上边的&lt;code&gt;varchar_size_demo&lt;/code&gt;表为例，它只有一个列&lt;code&gt;c&lt;/code&gt;，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会行溢出的现象呢？这得分析一下页中的空间都是如何利用的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个页除了存放我们的记录以外，也需要存储一些额外的信息，大概132个字节。&lt;/li&gt;
&lt;li&gt;每个记录需要的额外信息是27字节。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假设一个列中存储的数据字节数为n，如要要保证该列不发生溢出，则需要满足：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;132 + 2×(27 + n) &amp;lt; 16384
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是&lt;code&gt;n &amp;lt; 8099&lt;/code&gt;。&lt;strong&gt;也就是说如果一个列中存储的数据小于8099个字节，那么该列就不会成为溢出列&lt;/strong&gt;。如果表中有多个列，那么这个值更小。&lt;/p&gt;
&lt;h3 id=&quot;dynamic和compressed行格式&quot;&gt;Dynamic和Compressed行格式&lt;/h3&gt;
&lt;p&gt;mysql中默认的行格式就是&lt;code&gt;Dynamic&lt;/code&gt;。&lt;code&gt;Dynamic&lt;/code&gt;和&lt;code&gt;Compressed&lt;/code&gt;行格式和&lt;code&gt;Compact&lt;/code&gt;行格式很像，只是在处理&lt;code&gt;行溢出&lt;/code&gt;数据上有差异。&lt;code&gt;Dynamic&lt;/code&gt;和&lt;code&gt;Compressed&lt;/code&gt;行格式不会在&lt;code&gt;记录的真实数据&lt;/code&gt;出存放前768个字节，而是将所有字节都存储在其它页面中。&lt;code&gt;Compressed&lt;/code&gt;行格式会采用压缩算法对页面进行压缩，以节省空间。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081747475-849913741.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;innodb数据页结构&quot;&gt;InnoDB数据页结构&lt;/h2&gt;
&lt;p&gt;我们已经知道页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的设计了许多不同类型的页，我们这里主要关注&lt;code&gt;存储数据记录&lt;/code&gt;的页，官方称为&lt;code&gt;索引页&lt;/code&gt;。由于还没介绍索引，暂且我们先称为&lt;code&gt;数据页&lt;/code&gt;吧。&lt;/p&gt;
&lt;h3 id=&quot;数据页结构的快速浏览&quot;&gt;数据页结构的快速浏览&lt;/h3&gt;
&lt;p&gt;数据页在结构上可以划分为多个部分，不同的部分有不同的功能，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081833243-1628676923.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个InnoDB数据页被划分为了7个部分，下面大概描述一下这7个部分内容。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;中文名&lt;/th&gt;
&lt;th&gt;占用空间大小&lt;/th&gt;
&lt;th&gt;简单描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;File Header&lt;/td&gt;
&lt;td&gt;文件头部&lt;/td&gt;
&lt;td&gt;38字节&lt;/td&gt;
&lt;td&gt;页的一些通用信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Page Header&lt;/td&gt;
&lt;td&gt;页面头部&lt;/td&gt;
&lt;td&gt;56字节&lt;/td&gt;
&lt;td&gt;数据页专有的一些信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Infimum + Supremum&lt;/td&gt;
&lt;td&gt;最小记录和最大记录&lt;/td&gt;
&lt;td&gt;26字节&lt;/td&gt;
&lt;td&gt;两个虚拟的行记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;User Records&lt;/td&gt;
&lt;td&gt;用户记录&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;实际存储的行记录内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Free Space&lt;/td&gt;
&lt;td&gt;空闲空间&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;页中尚未使用的空间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Page Directory&lt;/td&gt;
&lt;td&gt;页面目录&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;页中的某些记录的相对位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;File Trailer&lt;/td&gt;
&lt;td&gt;文件尾部&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;td&gt;校验页是否完整&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;记录在页中的存储&quot;&gt;记录在页中的存储&lt;/h3&gt;
&lt;p&gt;用户自己的存储的数据会按照对应的&lt;code&gt;行格式&lt;/code&gt;存在&lt;code&gt;User Records&lt;/code&gt;中。实际上，新生成的页面是没有&lt;code&gt;User Records&lt;/code&gt;的，只有当我们第一次插入数据时，才会从&lt;code&gt;Free Space&lt;/code&gt;划一个记录大小的空间给&lt;code&gt;User Records&lt;/code&gt;。当&lt;code&gt;Free Space&lt;/code&gt;用完之后，就意味着当前的数据页也使用完了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081905015-1993340775.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了能够将&lt;code&gt;User Records&lt;/code&gt;讲清楚，我们先得理解前面提到的&lt;code&gt;记录头信息&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;理解记录头信息&quot;&gt;理解记录头信息&lt;/h4&gt;
&lt;p&gt;先简单介绍一下记录头信息各属性描述：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;大小（单位：bit）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;预留位1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;预留位2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;delete_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;标记该记录是否被删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;min_rec_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B+树的每层非叶子节点中的最小记录都会添加该标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;n_owned&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;表示当前记录拥有的记录数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;heap_no&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;表示当前记录在记录堆的位置信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;record_type&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;next_record&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;表示下一条记录的相对位置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;接下来以&lt;code&gt;page_demo&lt;/code&gt;表为例，并插入一些数据,详细介绍记录头信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE page_demo(
    -&amp;gt;     c1 INT,
    -&amp;gt;     c2 INT,
    -&amp;gt;     c3 VARCHAR(10000),
    -&amp;gt;     PRIMARY KEY (c1)
    -&amp;gt; ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)

mysql&amp;gt; INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这4条记录在InnoDB中的行格式如下（只展示记录头和真实数据），列中数据均用十进制表示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806081935829-87913632.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对照着这个图来重点介绍几个属性的详细信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;delete_mask&lt;/code&gt;：标记着当前记录是否被删除，0表示未删除，1表示删除。未删除的记录不会立即从磁盘上移除，而是先打上删除标记，所有被删除的记录会组成一个&lt;code&gt;垃圾链表&lt;/code&gt;。之后新插入的记录可能会重用&lt;code&gt;垃圾链表&lt;/code&gt;占用的空间，因此垃圾链表占用的存储空间也被成为&lt;code&gt;可重用空间&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_no&lt;/code&gt;：表示当前记录在本页中的位置，比如上边4条记录在本页中的位置分别是&lt;code&gt;2、3、4、5&lt;/code&gt;。实际上，InnoDB会自动为每页加上两条虚拟记录，一条是&lt;code&gt;最小记录&lt;/code&gt;，另一条是&lt;code&gt;最大记录&lt;/code&gt;。这两条记录的构造十分简单，都是由&lt;code&gt;5字节大小的记录头信息&lt;/code&gt;和&lt;code&gt;8字节大小的固定部分&lt;/code&gt;(其实内容就是infimum或者supremum)组成的。这两条记录被单独放在&lt;code&gt;Infimum + Supremum&lt;/code&gt;的部分。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806082015090-1664878733.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从图中我们可以看出来，最小记录和最大记录的&lt;code&gt;heap_no&lt;/code&gt;值分别是0和1，也就是说它们的位置最靠前。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next_record&lt;/code&gt;：表示从&lt;strong&gt;当前记录的真实数据到下一条记录的真实数据的地址偏移量&lt;/strong&gt;。可以简单理解为是一个单向链表，最小记录的下一个是第一条记录，最后一条记录的下一个是最大记录。为了更加形象的展示，我们可以用箭头来替代一下next_record中的地址偏移量：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806082046405-991436877.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从图中也能看出来，&lt;strong&gt;用户记录实际上按照主键大小正序排序行成一个单向链表&lt;/strong&gt;。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806082116517-1791910847.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;ul&gt;&lt;li&gt;第2条记录并没有从存储空间中移除，而是把该条记录的&lt;code&gt;delete_mask&lt;/code&gt;值设置为1。&lt;/li&gt;
&lt;li&gt;第2条记录的&lt;code&gt;next_record&lt;/code&gt;值变为了0，意味着该记录没有下一条记录了。&lt;/li&gt;
&lt;li&gt;第1条记录的&lt;code&gt;next_record&lt;/code&gt;指向了第3条记录。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;page-directory（页目录）&quot;&gt;Page Directory（页目录）&lt;/h3&gt;
&lt;p&gt;我们已经知道，记录在页中按照主键大小正序串联成了一个单链表。如果我们要根据主键查找具体的某条记录应该怎么办，简单的方式是根据链表进行遍历。但是在数据量比较大的情况下，这种方式显然效率太差了。因此mysql使用了&lt;code&gt;Page Directory（页目录）&lt;/code&gt;来解决这个问题。&lt;code&gt;Page Directory（页目录）&lt;/code&gt;大致的原理如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。怎么划分先不关注。&lt;/li&gt;
&lt;li&gt;每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组内共有几条记录。&lt;/li&gt;
&lt;li&gt;将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页尾部的地方，这个地方就是所谓的&lt;code&gt;Page Directory&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;mysql规定对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1-8 条之间，剩下的分组中记录的条数范围只能在是 4-8 条之间&lt;/strong&gt;。&lt;br/&gt;比方说现在的&lt;code&gt;page_demo&lt;/code&gt;表中正常的记录共有18条，InnoDB会把它们分成5组，第一组中只有一个最小记录，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806082152411-1371630834.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Page Directory&lt;/code&gt;在一个数据页中查找指定主键值的记录的过程分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过记录的&lt;code&gt;next_record&lt;/code&gt;属性遍历该槽所在的组中的各个记录。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于链表的查询性能优化，思想上基本上都是通过&lt;code&gt;二分法&lt;/code&gt;实现的。上面介绍的&lt;code&gt;Page Directory&lt;/code&gt;，&lt;code&gt;跳跃表&lt;/code&gt;和&lt;code&gt;查找树&lt;/code&gt;都是如此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Page Header&lt;/code&gt;专门用来存储数据页相关的各种状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。固定占用56个字节，各部分字节属性含义如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;占用空间大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_N_DIR_SLOTS&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;在页目录中的槽数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_HEAP_TOP&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;还未使用的空间最小地址，也就是说从该地址之后就是&lt;code&gt;Free Space&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_N_HEAP&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PAGE_FREE&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_GARBAGE&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;已删除记录占用的字节数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_LAST_INSERT&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;最后插入记录的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_DIRECTION&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;最后一条记录插入的方向&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PAGE_N_DIRECTION&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;一个方向连续插入的记录数量，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_N_RECS&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_MAX_TRX_ID&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;td&gt;修改当前页的最大事务ID，该值仅在二级索引中定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_LEVEL&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;当前页在B+树中所处的层级&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_INDEX_ID&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;td&gt;索引ID，表示当前页属于哪个索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_BTR_SEG_LEAF&lt;/td&gt;
&lt;td&gt;10字节&lt;/td&gt;
&lt;td&gt;B+树叶子段的头部信息，仅在B+树的Root页定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PAGE_BTR_SEG_TOP&lt;/td&gt;
&lt;td&gt;10字节&lt;/td&gt;
&lt;td&gt;B+树非叶子段的头部信息，仅在B+树的Root页定义&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里只是罗列出来，暂时不需要全部理解。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;File Header&lt;/code&gt;是用来描述各种页都适用的一些通用信息的，由以下内容组成：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;占用空间大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_SPACE_OR_CHKSUM&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;td&gt;页的校验和（checksum值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_OFFSET&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;td&gt;页号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_PREV&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;td&gt;上一个页的页号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_NEXT&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;td&gt;下一个页的页号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_LSN&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;td&gt;页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;td&gt;该页的类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_FILE_FLUSH_LSN&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;td&gt;仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;td&gt;页属于哪个表空间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里只是罗列出来，暂时不需要全部理解。我们重点关注一下几个属性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;FIL_PAGE_SPACE_OR_CHKSUM&lt;/code&gt;&lt;br/&gt;当前页面的校验和（checksum）。对于一个很长的字节串来说，我们可以通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为&lt;code&gt;校验和&lt;/code&gt;。通过&lt;code&gt;校验和&lt;/code&gt;可以大幅度提升字符串等值比较的效率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIL_PAGE_OFFSET&lt;/code&gt;&lt;br/&gt;每一个页都有一个唯一的页号，&lt;code&gt;InnoDB&lt;/code&gt;通过页号来可以定位一个页。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIL_PAGE_TYPE&lt;/code&gt;&lt;br/&gt;代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型。
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型名称&lt;/th&gt;
&lt;th&gt;十六进制&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_TYPE_ALLOCATED&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;最新分配，还没使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_TYPE_ALLOCATED&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;最新分配，还没使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_UNDO_LOG&lt;/td&gt;
&lt;td&gt;0x0002&lt;/td&gt;
&lt;td&gt;Undo日志页&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_INODE&lt;/td&gt;
&lt;td&gt;0x0003&lt;/td&gt;
&lt;td&gt;段信息节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_IBUF_FREE_LIST&lt;/td&gt;
&lt;td&gt;0x0004&lt;/td&gt;
&lt;td&gt;Insert Buffer空闲列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_IBUF_BITMAP&lt;/td&gt;
&lt;td&gt;0x0005&lt;/td&gt;
&lt;td&gt;Insert Buffer位图&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE_SYS&lt;/td&gt;
&lt;td&gt;0x0006&lt;/td&gt;
&lt;td&gt;系统页&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE_TRX_SYS&lt;/td&gt;
&lt;td&gt;0x0007&lt;/td&gt;
&lt;td&gt;事务系统数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE_FSP_HDR&lt;/td&gt;
&lt;td&gt;0x0008&lt;/td&gt;
&lt;td&gt;表空间头部信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE_XDES&lt;/td&gt;
&lt;td&gt;0x0009&lt;/td&gt;
&lt;td&gt;扩展描述页&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIL_PAGE_TYPE_BLOB&lt;/td&gt;
&lt;td&gt;0x000A&lt;/td&gt;
&lt;td&gt;溢出页&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FIL_PAGE_INDEX&lt;/td&gt;
&lt;td&gt;0x45BF&lt;/td&gt;
&lt;td&gt;索引页，也就是我们所说的数据页&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIL_PAGE_PREV&lt;/code&gt;和F&lt;code&gt;IL_PAGE_NEXT&lt;/code&gt;&lt;br/&gt;表示本页的上一个和下一个页的页号，各个页通过&lt;code&gt;FIL_PAGE_PREV&lt;/code&gt;和F&lt;code&gt;IL_PAGE_NEXT&lt;/code&gt;形成双向链表。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1361032/202008/1361032-20200806082229540-330163084.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;file-trailer&quot;&gt;File Trailer&lt;/h3&gt;
&lt;p&gt;mysql中内存和磁盘的基本交互单位是页。如果内存中页被修改了，那么某个时刻一定会将内存页同步到磁盘中。如果在同步的过程中，系统出现问题，就可能导致磁盘中的页数据没能完全同步，也就是发生了&lt;code&gt;脏页&lt;/code&gt;的情况。为了避免发生这种问题，mysql在每个页的尾部加上了&lt;code&gt;File Trailer&lt;/code&gt;来校验页的完整性。&lt;code&gt;File Trailer&lt;/code&gt;由8个字节组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前4个字节代表页的校验和&lt;br/&gt;这个部分是和File Header中的校验和相对应的。简单理解，就是&lt;code&gt;File Header&lt;/code&gt;和&lt;code&gt;File Trailer&lt;/code&gt;都有校验和，如果两者一致则表示数据页是完整的。否则，则表示数据页是&lt;code&gt;脏页&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;后4个字节代表页面被最后修改时对应的日志序列位置（LSN）&lt;br/&gt;这个部分也是为了校验页的完整性的，暂不详细了解。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Aug 2020 23:58:00 +0000</pubDate>
<dc:creator>六点半起床</dc:creator>
<og:description>InnoDB一个支持事务安全的存储引擎，同时也是mysql的默认存储引擎。本文主要从数据结构的角度，详细介绍InnoDB行记录格式和数据页的实现原理，从底层看清InnoDB存储引擎。 本文主要内容是根</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chentianming/p/13444045.html</dc:identifier>
</item>
<item>
<title>如何利用NLog输出结构化日志，并在Kibana优雅分析日志？ - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/13442591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/13442591.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/0aa65ab7-ba13-4fee-8330-2f9f4a36555d.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=YbYtYmiy%252FZe0MHbmLOc5zMJ17do%253D&amp;amp;Expires=1596706001&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上文我们演示了使用NLog向ElasticSearch写日志的基本过程(输出的是普通文本日志)，今天我们来看下如何向ES输出结构化日志、并利用Kibana中分析日志。&lt;/p&gt;
&lt;h3 id=&quot;什么是结构化日志？&quot;&gt;什么是结构化日志？&lt;/h3&gt;
&lt;p&gt;当前互联网、物联网、大数据突飞猛进，软件越复杂，查找任何给定问题的起因就越困难（且成本更高）。&lt;/p&gt;
&lt;p&gt;在实践中我们开发了各种规避、诊断应用程序错误行为的利器：&lt;br/&gt;&lt;code&gt;静态类型检查&lt;/code&gt;，&lt;code&gt;自动化测试&lt;/code&gt;，&lt;code&gt;事件探查器&lt;/code&gt;，&lt;code&gt;崩溃转储&lt;/code&gt;和&lt;code&gt;监视系统&lt;/code&gt;。但是记录程序执行步骤的日志仍然是事后诊断最丰富的数据源。&lt;/p&gt;
&lt;p&gt;在日志分析时，小批量普通的文本对于人类很友好，但却很难从大量普通文本中快速定位、精准提取特定信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.....
[2018-04-07T13:45:56.789Z INF] https://example.com/api/warehouse,query reserve,took 100 ms
[2018-04-07T13:45:56.789Z INF] api/commitOrder,OrderId:9876543210,commit order took 50 ms
......
[2018-04-07T13:45:56.789Z INF] /login,user:Kenny,from ip_address:127.0.0.1,took 100 ms
......
[2018-04-07T13:45:56.789Z INF] https://example.com/api/warehouse,OrderId:9876543210,decrease reserve took 10000 ms
[2018-04-07T13:45:56.789Z INF] /api/creatNewOrder,OrderId:9876543210, create order took 100 ms
.....
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果找到特定OrderId？&lt;/li&gt;
&lt;li&gt;如何找到哪些请求耗时较长(比如大于2S)？&lt;/li&gt;
&lt;li&gt;如何定位到该耗时请求处理管道中哪一段出现性能瓶颈？&lt;/li&gt;
&lt;li&gt;出现性能瓶颈的请求占比？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;普通文本对人类友好，对于机器不友好。&lt;br/&gt;结构化日志提出了&lt;code&gt;Message template&lt;/code&gt;来解决日志对机器不友好的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Messgae Template: 是一个与语言无关的规范，以对人类和机器友好的格式捕获、呈现结构化的日志事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;var traceid = _.TraceIdentifier;
 // 【锁定库存】 这个动作耗时较长
_logger.LogInformation(&quot;{TraceId},{endpoint},OrderId:{orderId},decrease reserve took {elasped} ms&quot;, traceid, &quot;https://example.com/api/warehouse&quot;, 9876543210, 10000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意命名占位符，它们能如格式化字符串占位符{0}{1}一样占位，而且能将属性名称与每个匹配位置的消息数据相关联，如下图以json格式提取了关键消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587720/202008/587720-20200805205557796-450682240.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息模板的优势在于：既能保持普通文本的格式，又具备捕获结构化数据的能力(对机器友好)。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面来完整输出、分析&lt;code&gt;提交订单请求&lt;/code&gt;的日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587720/202008/587720-20200805205639053-341276538.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;利用nlog向es输出结构化日志&quot;&gt;利用NLog向ES输出结构化日志&lt;/h4&gt;
&lt;p&gt;NLog4.5引入结构化日志，支持&lt;code&gt;Message Template&lt;/code&gt;， 在ASP.NET Core脚手架&lt;code&gt;Startup文件&lt;/code&gt;---&amp;gt;&lt;code&gt;Configure方法&lt;/code&gt;添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; app.MapWhen(_ =&amp;gt; _.Request.Path.Value == &quot;/&quot; ,
                      appBuilder =&amp;gt; appBuilder.Run(_ =&amp;gt;
                     {
                         var traceid = _.TraceIdentifier;
                         // 查询库存
                         _logger.LogInformation(&quot;{traceId},{endpoint},query reserve,took{elasped} ms&quot;, traceid, &quot;https://example.com/api/warehouse&quot;, 100);

                         // 创建订单
                         _logger.LogInformation(&quot;{traceId},{endpoint},OrderId:{orderId}, create order took {elasped} ms&quot;, traceid, &quot;/api/creatNewOrder&quot;, 9876543210, 100);

                         // 锁定库存
                         _logger.LogInformation(&quot;{traceId},{endpoint},OrderId:{orderId},decrease reserve took {elasped} ms&quot;, traceid, &quot;https://example.com/api/warehouse&quot;, 9876543210, 10000);

                         // 提交订单
                         _logger.LogInformation(&quot;{traceId},{endpoint},OrderId:{orderId},commit order took {elasped} ms&quot;, traceid, &quot;api/commitOrder&quot;, 9876543210, 50);

                        _.Response.StatusCode = StatusCodes.Status200OK;
                        _.Response.WriteAsync(&quot;Generate Order OK!&quot;);  
                       return Task.CompletedTask;
                    }));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们关注如何向ElasticSearch输出结构化日志，请务必将&lt;code&gt;includeAllProperties=&quot;true&quot;&lt;/code&gt;,这样输出到ES的才会包含所有事件属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;target name=&quot;elastic&quot; xsi:type=&quot;BufferingWrapper&quot; flushTimeout=&quot;5000&quot;&amp;gt;
      &amp;lt;target xsi:type=&quot;ElasticSearch&quot; includeAllProperties=&quot;true&quot; index=&quot;logstash-20200805&quot;  uri=&quot;${configsetting:item=ConnectionStrings.ElasticUrl}&quot; /&amp;gt;
 &amp;lt;/target&amp;gt;    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;kibana中分析日志&quot;&gt;Kibana中分析日志&lt;/h4&gt;
&lt;p&gt;这个订单请求，会产生6条日志(这里你也会看到日志的显示顺序可能不能如你所愿):&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587720/202008/587720-20200805210140857-1131499729.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面给出[锁定库存]日志ES文档， 文档上已经出现了关键的消息属性[traceId] [endpoint] [orderId] [elasped]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;_index&quot;: &quot;logstash-20200805&quot;,
  &quot;_type&quot;: &quot;logevent&quot;,
  &quot;_id&quot;: &quot;emTivXMBwcdwe4RliB9f&quot;,
  &quot;_version&quot;: 1,
  &quot;_score&quot;: null,
  &quot;_source&quot;: {
    &quot;@timestamp&quot;: &quot;2020-08-05T17:10:00.7170456+08:00&quot;,
    &quot;level&quot;: &quot;Info&quot;,
    &quot;message&quot;: &quot;2020-08-05 17:10:00.7170|INFO|EqidManager.Startup|0HM1P3TAGNJ5Q:00000001,https://example.com/api/warehouse,OrderId:9876543210,decrease reserve took 10000 ms&quot;,
    &quot;TraceId&quot;: &quot;0HM1P3TAGNJ5Q:00000001&quot;,
    &quot;endpoint&quot;: &quot;https://example.com/api/warehouse&quot;,
    &quot;orderId&quot;: 9876543210,
    &quot;elasped&quot;: 10000
  },
  &quot;fields&quot;: {
    &quot;@timestamp&quot;: [
      &quot;2020-08-05T09:10:00.717Z&quot;
    ]
  },
  &quot;sort&quot;: [
    1596618600717
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Kibana界面我们可以便捷地完成如下分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过{TraceId}找到某次请求所有日志&lt;/li&gt;
&lt;li&gt;通过{elasped} &amp;gt;=10s 过滤出处理时长大于10s的阶段&lt;/li&gt;
&lt;li&gt;通过{ordeid} 追踪该订单完整链路&lt;br/&gt;......&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587720/202008/587720-20200805205715026-295923213.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文肝时较长(elasped&amp;gt;=10天)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从常规诊断日志谈到[对机器友好，适用于分析的结构化日志]，其中的核心是消息模板。&lt;/li&gt;
&lt;li&gt;再谈到我是如何利用NLog输出结构化日志，其中注意在NLog Target中设置&lt;code&gt;includeAllProperties=true&lt;/code&gt;(默认是false)， 摸索了很久&lt;/li&gt;
&lt;li&gt;最后在Kibana中演示便捷的分析结构化日志&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;干货周边&quot;&gt;干货周边&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;[消息模板] &lt;a href=&quot;https://messagetemplates.org/&quot;&gt;https://messagetemplates.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[如何利用NLog输出结构化日志] &lt;a href=&quot;https://github.com/nlog/nlog/wiki/How-to-use-structured-logging&quot;&gt;https://github.com/nlog/nlog/wiki/How-to-use-structured-logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[NLog to ES] &lt;a href=&quot;https://github.com/markmcdowell/NLog.Targets.ElasticSearch&quot;&gt;https://github.com/markmcdowell/NLog.Targets.ElasticSearch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[TraceId]&lt;/li&gt;
&lt;li&gt;Logging with ElasticSearch, Kibana, ASP.NET Core and Docker&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 05 Aug 2020 23:54:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>上文我们演示了使用NLog向ElasticSearch写日志的基本过程(输出的是普通文本日志)，今天我们来看下如何向ES输出结构化日志、并利用Kibana中分析日志。 什么是结构化日志？ 当前互联网、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/13442591.html</dc:identifier>
</item>
<item>
<title>JVM系列之:从汇编角度分析NullCheck - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-assembly-nullcheck.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-assembly-nullcheck.html</guid>
<description>&lt;p&gt;之前我们在讲Virtual call的时候有提到，virtual call方法会根据传递的参数实例的不同而进行优化，从而优化成为classic call,从而提升执行效率。&lt;/p&gt;
&lt;p&gt;今天我们考虑一下，在virtual call中执行nullcheck的时候，如果已经知道传递的参数是非空的。JIT会对代码进行优化吗？&lt;/p&gt;
&lt;p&gt;一起来看看吧。&lt;/p&gt;

&lt;p&gt;我们来分析一下在方法中调用list.add方法的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestNull {

    public static void main(String[] args) throws InterruptedException {
        List&amp;lt;String&amp;gt; list= new ArrayList();
            list.add(&quot;www.flydean.com&quot;);
        for (int i = 0; i &amp;lt; 10000; i++)
        {
            testMethod(list);
        }
        Thread.sleep(1000);
    }
    private static void testMethod(List&amp;lt;String&amp;gt; list)
    {
        list.get(0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单，我们在循环中调用testMethod方法，而这个方法里面又调用了list.get(0)方法，来获取list的第一个参数。&lt;/p&gt;
&lt;p&gt;单纯的看testMethod，这个方法是有可能抛出NullPointerException的，但是从整体运行的角度来看，因为我们的list是有值的， 所以不会抛出异常。&lt;/p&gt;
&lt;p&gt;使用JIT Watcher看看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701195852757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先看第二个和第三个红框，我们可以看到代码先做了参数类型的比较，然后对testMethod进行了优化，这里还可以看到get方法是内联到testMethod中的。&lt;/p&gt;
&lt;p&gt;代码优化的部分我们找到了，那么异常处理呢？如果list为空，应该怎么处理异常呢？&lt;/p&gt;
&lt;p&gt;第一个红框，大家可以看到是一个隐式的异常处理，它重定向到1152b4f01这个地址。&lt;/p&gt;
&lt;p&gt;第四个红框就是这地址，表示的是异常处理的代码。&lt;/p&gt;

&lt;p&gt;我们在上面的普通方法里面加上一个null check：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestNull1 {

    public static void main(String[] args) throws InterruptedException {
        List&amp;lt;String&amp;gt; list= new ArrayList();
        list.add(&quot;www.flydean.com&quot;);
        for (int i = 0; i &amp;lt; 10000; i++)
        {
            testMethod(list);
        }
        Thread.sleep(1000);
    }

    private static void testMethod(List&amp;lt;String&amp;gt; list)
    {
        if(list !=null ){
            list.get(0);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们添加了一个list ！=null的判断。&lt;/p&gt;
&lt;p&gt;运行看下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020070120075074.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比较而言，我们可以看到，代码其实没有太多的变化，说明JIT在代码优化的过程中，将null check优化掉了。&lt;/p&gt;
&lt;p&gt;那么null check到底在什么地方呢？ 看我标红的第二个框，这里是之前的异常处理区域，我们可以看到里面有一个ifnull，表明这里做了null check。&lt;/p&gt;

&lt;p&gt;上面的两个例子，我们可以看出在virtual method中，JIT对null check进行了优化。接下来我们再看一个例子，在这个例子中，我们显示的传递一个null给testMethod，然后再次循环testMethod，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (int i = 0; i &amp;lt; 10000; i++)
        {
            testMethod(list);
        }
        Thread.sleep(1000);
        testMethod(null);
for (int i = 0; i &amp;lt; 10000; i++)
        {
            testMethod(list);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下JIT的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701203135529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下结果有什么不同呢？&lt;/p&gt;
&lt;p&gt;第一，ifnull现在是显示调用的，并不包含在隐式异常中。&lt;br/&gt;第二，隐式异常也不见了，因为使用显示的ifnull。&lt;/p&gt;

&lt;p&gt;JIT会根据不同的情况，对代码进行不同程度的优化，希望大家能够喜欢。&lt;/p&gt;
&lt;blockquote readability=&quot;8.4950495049505&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-assembly-nullcheck/&quot;&gt;http://www.flydean.com/jvm-assembly-nullcheck/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Aug 2020 23:45:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 之前我们在讲Virtual call的时候有提到，virtual call方法会根据传递的参数实例的不同而进行优化，从而优化成为classic call,从而提升执行效率。 今天我们考虑一下，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-assembly-nullcheck.html</dc:identifier>
</item>
<item>
<title>设计模式之模板方法 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/template-method-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/template-method-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法模式，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算的结构即使重定义该算法的某些特定步骤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;模板方法模式是通过把不变行为搬移到基类中，去除子类中的重复代码来体现它的优势，提供了一个很好的代码复用平台。&lt;/p&gt;
&lt;p&gt;当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现，我们通过可以借助模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;来看一个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;internal abstract class AbstractClass
{
    protected abstract void PrimitiveOperation1();

    protected abstract void PrimitiveOperation2();

    public void TemplateMethod()
    {
        Console.WriteLine(&quot;-------Begin-------&quot;);
        PrimitiveOperation1();
        PrimitiveOperation2();
        Console.WriteLine(&quot;-------End-------&quot;);
    }
}

internal class ConcreteClassA : AbstractClass
{
    protected override void PrimitiveOperation1()
    {
        Console.WriteLine(&quot;具体类A 方法1 的实现&quot;);
    }

    protected override void PrimitiveOperation2()
    {
        Console.WriteLine(&quot;具体类A 方法2 的实现&quot;);
    }
}

internal class ConcreteClassB : AbstractClass
{
    protected override void PrimitiveOperation1()
    {
        Console.WriteLine(&quot;具体类B 方法1 的实现&quot;);
    }

    protected override void PrimitiveOperation2()
    {
        Console.WriteLine(&quot;具体类B 方法2 的实现&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。&lt;/p&gt;
&lt;p&gt;我一直觉得模板方法这个设计模式是最简单最实用最能体现面向对象特性的一个设计模式&lt;/p&gt;
&lt;p&gt;面向对象的三大特性，封装、继承、多态在模板方法模式中都有体现&lt;/p&gt;
&lt;p&gt;一些通用的逻辑通常会 &lt;strong&gt;封装&lt;/strong&gt; 在父类中，不同的部分通常在父类中定义一个抽象方法或者虚方法（具体根据实际场景选择），然后在子类中 &lt;strong&gt;继承&lt;/strong&gt; 父类以复用父类中的通用逻辑，在具体的子类中实现需要重写的逻辑，以此来实现 &lt;strong&gt;多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板方法模式在有些场景下可能需要一些变通，标准的模板方法模式需要继承，但是 C# 是单继承的语言，在没有办法继承的时候，通常我们可以借助委托来实现，不同的逻辑需要重写的逻辑抽象换成一个委托，通过委托来替换不同的实现逻辑&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 05 Aug 2020 23:19:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>不得不知的模板方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/template-method-pattern.html</dc:identifier>
</item>
<item>
<title>Flask基础 - 嗨，阿良</title>
<link>http://www.cnblogs.com/fengting0913/p/13443945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengting0913/p/13443945.html</guid>
<description>&lt;h2 id=&quot;配置文件&quot;&gt;配置文件&lt;/h2&gt;
&lt;h3 id=&quot;配置文件导入原理&quot;&gt;配置文件导入原理&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;根据 &quot;settings.DevelopmentConfig&quot; 这个字符串形式的路径可以导入 &quot;settings&quot; 这个模块，并且可以找到模块中的 &quot;DevelopmentConfig&quot; 这个类，还可以根据 &quot;dir&quot; 找到 &quot;DevelopmentConfig&quot; 类中的大写的静态字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import importlib


path = &quot;settings.DevelopmentConfig&quot;

p, c = path.rsplit('.', maxsplit=1)
m = importlib.import_module(p)
cls = getattr(m, c)


# 如何根据cls这个类获取到类中的静态字段

for key in dir(cls):
    if key.isupper():
        print(key, getattr(cls, key))     
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;settings.py&lt;/code&gt; 配置文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import datetime


class Config(object):
    TESTING = False
    PROPAGATE_EXCEPTIONS = None
    PRESERVE_CONTEXT_ON_EXCEPTION = None
    SECRET_KEY = None
    PERMANENT_SESSION_LIFETIME = datetime.timedelta(days=31)
    USE_X_SENDFILE = False
    SERVER_NAME = None
    APPLICATION_ROOT = '/'
    SESSION_COOKIE_NAME = 'session'
    SESSION_COOKIE_DOMAIN = None
    SESSION_COOKIE_PATH = None
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SECURE = False
    SESSION_COOKIE_SAMESITE = None
    SESSION_REFRESH_EACH_REQUEST = True
    MAX_CONTENT_LENGTH = None
    SEND_FILE_MAX_AGE_DEFAULT = datetime.timedelta(seconds=43200)
    TRAP_BAD_REQUEST_ERRORS = None
    TRAP_HTTP_EXCEPTIONS = False
    EXPLAIN_TEMPLATE_LOADING = False
    PREFERRED_URL_SCHEME = 'http'
    JSON_AS_ASCII = True
    JSON_SORT_KEYS = True
    JSONIFY_PRETTYPRINT_REGULAR = False
    JSONIFY_MIMETYPE = 'application/json'
    TEMPLATES_AUTO_RELOAD = None
    MAX_COOKIE_SIZE = 4093


class ProductionConfig(Config):
    DEBUG = False


class DevelopmentConfig(Config):
    DEBUG = True

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;appconfigfrom_object-导入配置信息&quot;&gt;app.config.from_object 导入配置信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;app.py&lt;/code&gt; 中可以使用&lt;strong&gt;按需修改后&lt;/strong&gt;的 &lt;code&gt;settings.py&lt;/code&gt; 中的配置信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import Flask

app = Flask(__name__)

app.config.from_object(&quot;settings.DevelopmentConfig&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;路由系统&quot;&gt;路由系统&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;flask 中的路由url是&lt;strong&gt;依据带参数的装饰器&lt;/strong&gt;写的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;endpoint=&quot;n1&quot; 相当于 django 路由系统 url 中的 name 起别名进行反向解析&lt;/li&gt;
&lt;li&gt;如果不写 endpoint=&quot;...&quot; 则默认为：url_for(&quot;index&quot;) 视图函数名称 index&lt;/li&gt;
&lt;li&gt;flask 路由反向解析用的是 url_for(&quot;n1&quot;)&lt;/li&gt;
&lt;li&gt;动态路由
&lt;ul&gt;&lt;li&gt;&lt;code&gt;/&amp;lt;int:nid&amp;gt;&lt;/code&gt; 动态接收 id 值（int类型），可以传参&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&amp;lt;nid&amp;gt;&lt;/code&gt; 未定义类型则默认接收 string 字符串类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import Flask
from flask import url_for


@app.route('/index/&amp;lt;int:nid&amp;gt;', methods=[&quot;GET&quot;, &quot;POST&quot;], endpoint=&quot;n1&quot;)
# endpoint=&quot;n1&quot; 相当于 django 路由系统 url 中的 name 起别名进行反向解析
# 如果不写 endpoint=&quot;...&quot; 则默认为：url_for(&quot;index&quot;) 视图函数名称 index
# flask 路由反向解析用的是 url_for(&quot;n1&quot;)

# 动态路由
# '/&amp;lt;int:nid&amp;gt;' 动态接收 id 值（int类型），可以传参
# '/&amp;lt;nid&amp;gt;' 未定义类型则默认接收 string 字符串类型
def index(nid):
    print(url_for(&quot;n1&quot;, nid=1))
    # /index/1
    return &quot;Index&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;视图&quot;&gt;视图&lt;/h2&gt;
&lt;h3 id=&quot;fbv-模式&quot;&gt;FBV 模式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import functools
from flask import Flask
from flask import render_template
from flask import request
from flask import redirect
from flask import session
from flask import url_for
from flask import Markup
from flask import flash
from flask import get_flashed_messages

app = Flask(__name__)
app.config.from_object(&quot;settings.DevelopmentConfig&quot;)

# 模拟数据库中存储的用户
STUDENT_DICT = {
    1: {'name': '小明', 'age': 18, 'gender': '男'},
    2: {'name': '小李', 'age': 19, 'gender': '男'},
    3: {'name': '小花', 'age': 17, 'gender': '女'},
}


# def auth(func):
#     # '@functools.wraps(func)' 加上这个装饰器，可以避免被装饰的函数名变为'inner'
#     @functools.wraps(func)
#     def inner(*args, **kwargs):
#         if not session.get('user'):
#             return redirect(url_for('login'))
#         ret = func(*args, **kwargs)
#         return ret
#     return inner


# 被'@app.before_request' 此装饰器装饰的业务逻辑会在所有视图函数执行之前执行
# 跟 'django' 的 'process_request' 极为相似
# 当被此装饰器装饰的业务逻辑有返回值时，整个flask框架中的所有视图函数都不会被执行
# 直接显示 &quot;被此装饰器装饰的业务逻辑的返回值&quot;
@app.before_request
def auth():
    if request.path == '/login':
        return None
    if session.get('user'):
        return None
    return redirect(url_for('login'))


# 被此全局模板函数装饰器所装饰的业务逻辑，不需要借助任何视图函数传递此方法给模板，
# 此方法会自动传递到需要应用此方法的模板中！
# 模板只需要调用即可 {{global_template_func(1, 2)}} 即可在页面相应的位置显示出 3
@app.template_global()
def global_template_func(a, b):
    return a + b


# {{ 1|filter_template_func(2, 3) }}
# 页面显示 6
@app.template_filter()
def filter_template_func(a, b, c):
    return a + b + c


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        user = request.form.get('user')
        password = request.form.get('password')
        if user == 'aliang' and password == '007':
            session['user'] = user
            return redirect(url_for('index'))
        return render_template('login.html', error='用户名或密码错误！')
    return render_template('login.html')


@app.route('/index')
# @auth
def index():
    return render_template('index.html', stu_dic=STUDENT_DICT)


@app.route('/delete/&amp;lt;int:nid&amp;gt;')
# @auth
def delete(nid):
    del STUDENT_DICT[nid]
    return redirect(url_for('index'))


@app.route('/detail/&amp;lt;int:nid&amp;gt;')
# @auth
def detail(nid):
    info = STUDENT_DICT[nid]
    return render_template('detail.html', info=info)


def func(arg):
    return arg + 1


@app.route('/tpl')
def tpl():
    context = {
        'users': ['小明', '小李', '小花'],
        # 'txt': &quot;&amp;lt;input type='text' /&amp;gt;&quot;,
        'txt': Markup(&quot;&amp;lt;input type='text' /&amp;gt;&quot;),
        'func': func
    }
    return render_template('tpl.html', **context)


@app.route('/page1')
def page1():
    flash('存储临时数据')

    return &quot;Session&quot;


@app.route('/page2')
def page2():
    flash_msg = get_flashed_messages()

    return flash_msg


class Middleware(object):
    def __init__(self, origin_wsgi_app):
        self.origin_wsgi_app = origin_wsgi_app

    def __call__(self, *args, **kwargs):
        # 在请求之前做相应的业务逻辑

        ret = self.origin_wsgi_app(*args, **kwargs)

        # 在请求之后做相应的业务逻辑

        return ret


if __name__ == '__main__':
    app.wsgi_app = Middleware(app.wsgi_app)
    app.run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;请求相关&quot;&gt;请求相关&lt;/h2&gt;
&lt;h3 id=&quot;request&quot;&gt;request&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;request.method

requestd.args

request.form

request.values

requesdt.cookies

request.headers

request.path

request.full_path

request.script_root

request.url

request.base_url

request.url_root

request.host_url

request.host

request.files

obj = request.files['the_file_name']
obj.save('/var/www/uploads/' + secure_filename(f.filename))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;响应相关&quot;&gt;响应相关&lt;/h2&gt;
&lt;h3 id=&quot;return&quot;&gt;return&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import render_template
from flask import redirect
from flask import jsonify


# 以下4种返回的数据都是请求体，能不能将请求头也返回？可以封装！

dic = {'k1': 'v1'}

# return json.dumps(dic)
# 相当于&quot;django&quot;中的JsonResponse
return jsonify(dic)

return &quot;Index&quot;

return render_template(&quot;index.html&quot;)

return redirect(&quot;/index&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;封装响应头响应体后再返回&quot;&gt;封装&amp;lt;响应头&amp;gt;&amp;amp;&amp;lt;响应体&amp;gt;后再返回&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定制返回的响应头&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import make_response

# 将要返回的字符串&quot;Index&quot;封装到&quot;make_response&quot;中
# 设置了响应体
obj = make_response(&quot;Index&quot;)

# 设置了响应头
obj.headers['xxxx'] = 'oooo'

# 设置cookie信息
obj.set_cookie('key', 'value')

return obj
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模板渲染&quot;&gt;模板渲染&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;flask 模板渲染语法跟python语法极其相似&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;视图传参模板渲染&quot;&gt;视图传参——&amp;gt;模板渲染&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# app.py 文件中
from flask import Markup


def func(arg):
    return arg + 1


@app.route('/tpl')
def tpl():
    context = {
        'users': ['小明', '小李', '小花'],
        # 'txt': &quot;&amp;lt;input type='text' /&amp;gt;&quot;,
        'txt': Markup(&quot;&amp;lt;input type='text' /&amp;gt;&quot;),
        'func': func
    }
    return render_template('tpl.html', **context)

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
{{users.0}}
{{users[0]}}
{{txt}}
{{txt|safe}}
{{func(6)}}
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apptemplate_global-全局模板函数装饰器之一&quot;&gt;@app.template_global() 全局模板函数装饰器之一&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;被此全局模板函数装饰器所装饰的业务逻辑，不需要借助任何视图函数传递此方法给模板，&lt;br/&gt;此方法会自动传递到需要应用此方法的模板中！&lt;/p&gt;
&lt;p&gt;模板只需要调用即可 {{global_template_func(1, 2)}} 即可在页面相应的位置显示出 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# app.py 文件中

@app.template_global()
def global_template_func(a, b):
    return (a + b)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{global_template_func(1, 2)}}
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apptemplate_filter-全局模板函数装饰器之二&quot;&gt;@app.template_filter() 全局模板函数装饰器之二&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在模板中这样调用：{{ 1|filter_template_func(2, 3) }}&lt;br/&gt;则在页面相应位置显示 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# app.py 文件中

@app.template_filter()
def filter_template_func(a, b, c):
    return a + b + c
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{1|filter_template_func(2, 3)}}
 
{% if 1|filter_template_func(2, 3) %}
    &amp;lt;div&amp;gt;返回值为6&amp;lt;/div&amp;gt;
{% else %}
    &amp;lt;div&amp;gt;没有返回值&amp;lt;/div&amp;gt;
{% endif %}
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模板继承-extends-layouthtml&quot;&gt;模板继承——&amp;gt; extends &quot;layout.html&quot;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;layout.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    {% block content%}
    
    {% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tpl.html 继承 layout.html 模板文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;{% extends &quot;layout.html&quot;%}

{% block content%}
    {{users.0}}
        {{users[0]}}
        {{txt}}
        {{txt|safe}}
        {{func(6)}}
{% endblock %}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模板插件导入-include-navhtml&quot;&gt;模板插件导入——&amp;gt; include &quot;nav.html&quot;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;nav.html 模板插件——&amp;gt;导航栏等插件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;......
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;{% extends &quot;layout.html&quot;%}

{% block content%}
        {% include &quot;nav.html&quot; %}
    {{users.0}}
        {{users[0]}}
        {{txt}}
        {{txt|safe}}
        {{func(6)}}
{% endblock %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模板宏定义-macro-----endmacro-&quot;&gt;模板宏定义——&amp;gt;{% macro ...%} ... {% endmacro %}&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;适用于某个标签在整个页面上多次使用，可以按照宏定义的方式将此标签定义为一个代码块，在需要使用时直接调用即可！就不需要重写很多遍了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;模板宏定义的意思是可以在模板中定义一个代码块，代码块中可以按照python函数的定义方式去定义某个需要在特定时刻使用的标签&lt;/p&gt;
&lt;p&gt;在需要显示此标签时，直接调用即可&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;{% macro tag(name, type='text', value='') %}
        &amp;lt;h1&amp;gt;宏定义input标签&amp;lt;/h1&amp;gt;
        &amp;lt;input type=&quot;{{ type }}&quot; name=&quot;{{ name }}&quot; value=&quot;{{ value }}&quot;&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;
{% endmacro %}

{{tag(&quot;user&quot;)}}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;session&quot;&gt;Session&lt;/h2&gt;
&lt;h3 id=&quot;利用session保存用户的登录状态&quot;&gt;利用session保存用户的登录状态&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可以做权限管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;每个需要登录后才可以访问的页面所对应的视图函数中都&lt;strong&gt;查询一次是否有session信息&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;利用装饰器，在每个需要登录后才可以访问的页面所对应的视图函数上加装饰器，在&lt;strong&gt;走相应的视图函数之前先走装饰器中定义好的判断是否存在session信息的业务逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;装饰器（&lt;strong&gt;应用于被装饰的视图函数较少时&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import functools


def auth(func):
    @functools.wraps(func)  # 加上这个装饰器，可以避免被装饰的函数名变为'inner'
    def inner(*args, **kwargs):
        if not session.get('user'):
            return redirect(url_for('login'))
        ret = func(*args, **kwargs)
        return ret
    return inner
    
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法三：&lt;/strong&gt;使用 '@app.before_request' 装饰器&lt;br/&gt;&lt;strong&gt;被'@app.before_request' 此装饰器&lt;/strong&gt;装饰的业务逻辑&lt;strong&gt;会在所有视图函数执行之前执行&lt;/strong&gt;，跟 &lt;strong&gt;'django' 的 'process_request'&lt;/strong&gt; 极为相似&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当被此装饰器装饰的业务逻辑&lt;strong&gt;有返回值&lt;/strong&gt;时，&lt;strong&gt;整个flask框架中的所有视图函数都不会被执行&lt;/strong&gt;，但&lt;strong&gt;所有被 '@app.after_request' 装饰器装饰的业务逻辑都会按照定义好的顺序倒序执行&lt;/strong&gt;后&lt;strong&gt;直接显示 &quot;被此装饰器装饰的业务逻辑的返回值&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;当被此装饰器装饰的业务逻辑中返回 None 时，其他的视图才能正常执行&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@app.before_request
def auth():
    if request.path == '/login':
        return None
    if session.get('user'):
        return None
    return redirect(url_for('login'))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;闪现flash&quot;&gt;闪现——&amp;gt;flash&lt;/h2&gt;
&lt;h3 id=&quot;基于session信息的设置原理封装好方法：临时存临时取&quot;&gt;基于session信息的设置原理封装好方法：&amp;lt;临时存&amp;gt;&amp;amp;&amp;lt;临时取&amp;gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;原理：在session中存储一个数据，读取一次之后，通过pop将数据移除，可以达到存一次取一次即失效的效果！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;flask中的session 信息是经过加密后保存在cookie中的，可以一直取，只要不过期，不手动删除，则session信息一直存在！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;借助 &lt;code&gt;flash&lt;/code&gt; 存储某一临时数据 &amp;amp; &lt;code&gt;get_flashed_messages&lt;/code&gt; 获取临时数据，取一次即失效&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;临时存，临时取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;取出来的是列表类型的数据，第二次取得就是空列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import flash
from flask import get_flashed_messages


@app.route('/page1')
def page1():
    flash('存储临时数据')

    return &quot;Session&quot;


@app.route('/page2')
def page2():
    flash_msg = get_flashed_messages()

    return flash_msg

# ['存储临时数据']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分类临时存，按分类临时取&quot;&gt;分类临时存，按分类临时取&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from flask import flash
from flask import get_flashed_messages


@app.route('/page1')
def page1():
    flash('存储临时数据1', '类别1')
    flash('存储临时数据2', '类别1')
    flash('存储临时数据3', '类别2')

    return &quot;Session&quot;


@app.route('/page2')
def page2():
    flash_msg = get_flashed_messages(category_filter=['类别1'])

    return flash_msg


# ['存储临时数据1', '存储临时数据2']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;中间件&quot;&gt;中间件&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;跟django的中间件的实现有较大区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;flask-框架开始执行流程&quot;&gt;flask 框架开始执行流程&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;flask 项目启动接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if __name__ == '__main__':
    app.run()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行 run 方法后使得服务端处于&lt;strong&gt;监听状态&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;当有请求连接时，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    run_simple(host, port, self, **options)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run_simple(host, port, self, **options)&lt;/code&gt; 中的第三个参数 &lt;code&gt;self()&lt;/code&gt; 即 flask 的实例化对象 &lt;code&gt;app()&lt;/code&gt; 会执行类的 &lt;code&gt;__call__&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def __call__(self, environ, start_response):
    &quot;&quot;&quot;The WSGI server calls the Flask application object as the
    WSGI application. This calls :meth:`wsgi_app` which can be
    wrapped to applying middleware.&quot;&quot;&quot;
    return self.wsgi_app(environ, start_response)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;即在客户端请求连接时，基于flask框架的项目服务端会执行 &lt;code&gt;__call__&lt;/code&gt; 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而我们知道中间件的作用就是&lt;strong&gt;在请求通过wsgi封装后经过路由匹配执行相应的视图函数再返回相应的模板页面&lt;/strong&gt;之前做相应的业务逻辑，比如：发送某一请求访问特定的页面需要先登录之后才可以正常访问。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;flask 框架中的中间件即在 &lt;code&gt;__call__&lt;/code&gt; 方法执行之前做相关定义&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义中间件&quot;&gt;定义中间件&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;flask 框架中的中间件即在 &lt;code&gt;Flask&lt;/code&gt; 类的 &lt;code&gt;__call__&lt;/code&gt; 方法执行之前做相关定义&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Middleware(object):
    def __init__(self, origin_wsgi_app):
        self.origin_wsgi_app = origin_wsgi_app

    def __call__(self, *args, **kwargs):
        # 在请求之前做相应的业务逻辑

        ret = self.origin_wsgi_app(*args, **kwargs)

        # 在请求之后做相应的业务逻辑

        return ret
        

if __name__ == '__main__':
    app.wsgi_app = Middleware(app.wsgi_app)
    app.run()

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;特殊的装饰器&quot;&gt;特殊的装饰器&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类比于django的中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;appbefore_first_request&quot;&gt;@app.before_first_request&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;被'@app.before_first_request' 此装饰器装饰的业务逻辑会在 '@app.before_request' 装饰的业务逻辑之前仅执行一次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@app.before_first_request
def excute_first():
    print(&quot;项目启动之后第一次请求到来时，会在@app.before_request装饰的业务逻辑之前仅仅执行一次&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;appbefore_request&quot;&gt;@app.before_request&lt;/h3&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;被'@app.before_request' 此装饰器装饰的业务逻辑会在所有视图函数执行之前执行，&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;跟 'django' 的 'process_request' 极为相似&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当被此装饰器装饰的业务逻辑有返回值时，整个flask框架中的所有视图函数都不会被执行，但所有被 '@app.after_request' 装饰器装饰的业务逻辑都会按照定义顺序倒序执行后直接显示 &quot;被此装饰器装饰的业务逻辑的返回值&quot;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当被此装饰器装饰的业务逻辑没有返回值即返回 None 时，请求按流程正常执行！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@app.before_request
def auth():
    print('请先登录！')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;appafter_request&quot;&gt;@app.after_request&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;被'@app.after_request' 此装饰器装饰的业务逻辑会在所有视图函数执行之后执行跟 'django' 的 'process_response' 极为相似&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;被装饰的业务逻辑必须要有返回值，若没有返回值，程序会报错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@app.after_request
def after(response):
    print('请求已经得到响应！')
    return response
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apptemplate_global-全局模板函数装饰器之一-2&quot;&gt;@app.template_global() 全局模板函数装饰器之一&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;被此全局模板函数装饰器所装饰的业务逻辑，不需要借助任何视图函数传递此方法给模板，此方法会自动传递到需要应用此方法的模板中！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;模板只需要调用即可 {{global_template_func(1, 2)}} 即可在页面相应的位置显示出 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# app.py 文件中

@app.template_global()
def global_template_func(a, b):
    return (a + b)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{global_template_func(1, 2)}}
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apptemplate_filter-全局模板函数装饰器之二-2&quot;&gt;@app.template_filter() 全局模板函数装饰器之二&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在模板中这样调用：{{ 1|filter_template_func(2, 3) }}&lt;br/&gt;则在页面相应位置显示 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# app.py 文件中

@app.template_filter()
def filter_template_func(a, b, c):
    return a + b + c
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;tpl.html 模板文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{1|filter_template_func(2, 3)}}
 
{% if 1|filter_template_func(2, 3) %}
    &amp;lt;div&amp;gt;返回值为6&amp;lt;/div&amp;gt;
{% else %}
    &amp;lt;div&amp;gt;没有返回值&amp;lt;/div&amp;gt;
{% endif %}
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apperrorhandler&quot;&gt;@app.errorhandler&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;被'@app.errorhandler(404)' 此装饰器装饰的业务逻辑可以自定义访问出错后的错误信息展示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;@app.errorhandler(404)
def not_found(error_msg):
    print(error_msg)
    return &quot;访问的页面不存在！&quot;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 05 Aug 2020 19:10:00 +0000</pubDate>
<dc:creator>嗨，阿良</dc:creator>
<og:description>flask 框架基础应用总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengting0913/p/13443945.html</dc:identifier>
</item>
<item>
<title>能动手绝不多说：开源评论系统remark42上手指南 - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/13443831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/13443831.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;写博客嘛，&lt;/p&gt;
&lt;p&gt;谁不喜欢自己倒腾一下呢。&lt;/p&gt;
&lt;p&gt;从自建系统到 Github Page，&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&quot;http://jekyllcn.com/&quot;&gt;Jekyll&lt;/a&gt; 到 &lt;a href=&quot;https://hexo.io/zh-cn/index.html&quot;&gt;Hexo&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;年轻的时候谁不喜欢多折腾折腾呢。&lt;/p&gt;
&lt;p&gt;年纪稍稍长了一下之后， 最后我自己还是选了 Hexo 直接做静态博客生成，&lt;/p&gt;
&lt;p&gt;结合一下 Gitlab CI 推代码之后自动构建之后更新到自己的服务器了。&lt;/p&gt;
&lt;p&gt;后来又基于“多说”直接支持了博客内容评论，&lt;/p&gt;
&lt;p&gt;再后来，多说倒下了，评论功能就一直没有维护了。&lt;/p&gt;
&lt;p&gt;前阵子因为某些需求，对市面上部分评论系统做了一次调研，&lt;/p&gt;
&lt;p&gt;这时候发现其实大家都做了好多轮子了，近期空出来了终于可以再玩玩了。&lt;/p&gt;
&lt;h2 id=&quot;开源评论系统调研&quot;&gt;开源评论系统调研&lt;/h2&gt;
&lt;p&gt;调研前提：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开源，协议友好，可商用&lt;/li&gt;
&lt;li&gt;项目代码“正常”（实在不太想看 Ruby/PHP），维护积极&lt;/li&gt;
&lt;li&gt;部署简单，二开方便&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面直接扔了上次的调研结果出来。&lt;/p&gt;
&lt;h3 id=&quot;vkuznecovasmouthful&quot;&gt;vkuznecovas/mouthful&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Mouthful is a self-hosted alternative to Disqus &lt;a href=&quot;https://mouthful.dizzy.zone/&quot;&gt;https://mouthful.dizzy.zone/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Golang 编写，支持 MySQL、PG、SQLIte，支持评论审核&lt;/li&gt;
&lt;li&gt;维护状态：2018 年之后没看到更新了&lt;br/&gt;Features&lt;/li&gt;
&lt;li&gt;Multiple database support(sqlite, mysql, postgres, dynamodb)&lt;/li&gt;
&lt;li&gt;Moderation with an administration panel&lt;/li&gt;
&lt;li&gt;Server side caching to prevent excessive database calls&lt;/li&gt;
&lt;li&gt;Rate limiting&lt;/li&gt;
&lt;li&gt;Honeypot feature, to prevent bots from posting comments&lt;/li&gt;
&lt;li&gt;Migrations from existing commenting engines(isso, disqus)&lt;/li&gt;
&lt;li&gt;Configuration - most of the features can be turned on or off, as well as customized to your preferences.&lt;/li&gt;
&lt;li&gt;Admin login through third parties such as facebook and twitter, and 35 more.&lt;/li&gt;
&lt;li&gt;Dumping comments out, and importing an old dump.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;schn4ckschnack&quot;&gt;schn4ck/schnack&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Simple self-hosted node app for Disqus-like drop-in commenting on static websites &lt;a href=&quot;https://schnack.cool/&quot;&gt;https://schnack.cool/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node js 编写, SQLite, 没看到其他数据库的支持&lt;/li&gt;
&lt;li&gt;维护状态：最后一次更新是 15 个月前&lt;br/&gt;Features&lt;/li&gt;
&lt;li&gt;Tiny! It takes only ~8 KB!!! to embed Schnack.&lt;/li&gt;
&lt;li&gt;Open source and self-hosted.&lt;/li&gt;
&lt;li&gt;Ad-free and Tracking-free. Schnack will not disturb your users.&lt;/li&gt;
&lt;li&gt;It's simpy to moderate, with a minimal and slick UI to allow/reject comments or trust/block users.&lt;/li&gt;
&lt;li&gt;webpush protocol to notify the site owner about new comments awaiting for moderation.&lt;/li&gt;
&lt;li&gt;Third party providers for authentication like Github, Twitter, Google and Facebook. Users are not required to register a new account on your system and you don't need to manage a user management system.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;A fast, bloat-free comments platform (Github mirror) &lt;a href=&quot;https://commento.io&quot;&gt;https://commento.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;golang 编写，支持 PG&lt;/li&gt;
&lt;li&gt;维护状态：两个月还在更新，支持本地部署&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.commento.io/&quot;&gt;https://docs.commento.io/&lt;/a&gt;&lt;br/&gt;What features does Commento have?&lt;br/&gt;Commento comes with a lot of useful features out-of-the-box: rich text support, upvotes and downvotes, automatic spam detection, moderation tools, sticky comments, thread locking, OAuth login, email notifications, and more!&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;posativisso&quot;&gt;posativ/isso&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;a Disqus alternative &lt;a href=&quot;https://posativ.org/isso/&quot;&gt;https://posativ.org/isso/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python，SQLIte，引入了 ORM 组件但是暂时没看到其他数据库的支持&lt;/li&gt;
&lt;li&gt;Admin panel to moderate comments&lt;/li&gt;
&lt;li&gt;维护状态：活跃，几天前还在更新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Isso – Ich schrei sonst – is a lightweight commenting server written in Python and JavaScript. It aims to be a drop-in replacement for Disqus.&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;comment engine &lt;a href=&quot;https://remark42.com&quot;&gt;https://remark42.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Golang + SQLIte + 支持 Admin&lt;/li&gt;
&lt;li&gt;维护状态：活跃，几天前还在更新&lt;br/&gt;Remark42 is a self-hosted, lightweight, and simple (yet functional) comment engine, which doesn't spy on users. It can be embedded into blogs, articles or any other place where readers add comments.&lt;/li&gt;
&lt;li&gt;Social login via Google, Twitter, Facebook, GitHub and Yandex&lt;/li&gt;
&lt;li&gt;Login via email&lt;/li&gt;
&lt;li&gt;Optional anonymous access&lt;/li&gt;
&lt;li&gt;Multi-level nested comments with both tree and plain presentations&lt;/li&gt;
&lt;li&gt;Import from Disqus and WordPress&lt;/li&gt;
&lt;li&gt;Markdown support with friendly formatter toolbar&lt;/li&gt;
&lt;li&gt;Moderator can remove comments and block users&lt;/li&gt;
&lt;li&gt;Voting, pinning and verification system&lt;/li&gt;
&lt;li&gt;Sortable comments&lt;/li&gt;
&lt;li&gt;Images upload with drag-and-drop&lt;/li&gt;
&lt;li&gt;Extractor for recent comments, cross-post&lt;/li&gt;
&lt;li&gt;RSS for all comments and each post&lt;/li&gt;
&lt;li&gt;Telegram and email notifications&lt;/li&gt;
&lt;li&gt;Export data to json with automatic backups&lt;/li&gt;
&lt;li&gt;No external databases, everything embedded in a single data file&lt;/li&gt;
&lt;li&gt;Fully dockerized and can be deployed in a single command&lt;/li&gt;
&lt;li&gt;Self-contained executable can be deployed directly to Linux, Windows and MacOS&lt;/li&gt;
&lt;li&gt;Clean, lightweight and customizable UI with white and dark themes&lt;/li&gt;
&lt;li&gt;Multi-site mode from a single instance&lt;/li&gt;
&lt;li&gt;Integration with automatic ssl (direct and via nginx-le)&lt;/li&gt;
&lt;li&gt;Privacy focused&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;jacobwbhashover&quot;&gt;jacobwb/hashover&lt;/h3&gt;
&lt;h2 id=&quot;开始实践&quot;&gt;开始实践&lt;/h2&gt;
&lt;p&gt;调研搞完之后，停了一阵子，最近把项目扔给同事做进一步 demo 搭建，&lt;/p&gt;
&lt;p&gt;同事花了点时候搭了一下 demo 和看了代码，最后在 commento 和 remark42 中“犹豫了”&lt;/p&gt;
&lt;p&gt;最后比较了代码结构和二次开发成本， 选择了 remark42&lt;/p&gt;
&lt;p&gt;所以，我这边最后也使用 remark42 直接搭了自己的评论系统。&lt;/p&gt;
&lt;h2 id=&quot;开始搞事&quot;&gt;开始“搞事”&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/umputun/remark42&quot;&gt;remark42&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于文档写得实在太好了，部署也没遇到什么奇怪问题，&lt;/p&gt;
&lt;p&gt;部署服务端这一步真的跳过了，有奇怪的问题需要的朋友自行提问吧。&lt;/p&gt;

&lt;p&gt;这一段是需要写写的。&lt;/p&gt;
&lt;p&gt;看完了文档的朋友应该知道，&lt;/p&gt;
&lt;p&gt;在某个页面集成评论只需要加下面这些代码。&lt;/p&gt;
&lt;h3 id=&quot;页面插入-script&quot;&gt;页面插入 script&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
  var remark_config = {
    host: &quot;REMARK_URL&quot;, // hostname of remark server, same as REMARK_URL in backend config, e.g. &quot;https://demo.remark42.com&quot;
    site_id: &quot;YOUR_SITE_ID&quot;,
    components: [&quot;embed&quot;], // optional param; which components to load. default to [&quot;embed&quot;]
    // to load all components define components as ['embed', 'last-comments', 'counter']
    // available component are:
    //     - 'embed': basic comments widget
    //     - 'last-comments': last comments widget, see `Last Comments` section below
    //     - 'counter': counter widget, see `Counter` section below
    url: &quot;PAGE_URL&quot;, // optional param; if it isn't defined
    // `window.location.origin + window.location.pathname` will be used,
    //
    // Note that if you use query parameters as significant part of url
    // (the one that actually changes content on page)
    // you will have to configure url manually to keep query params, as
    // `window.location.origin + window.location.pathname` doesn't contain query params and
    // hash. For example default url for `https://example/com/example-post?id=1#hash`
    // would be `https://example/com/example-post`.
    //
    // The problem with query params is that they often contain useless params added by
    // various trackers (utm params) and doesn't have defined order, so Remark treats differently
    // all this examples:
    // https://example.com/?postid=1&amp;amp;date=2007-02-11
    // https://example.com/?date=2007-02-11&amp;amp;postid=1
    // https://example.com/?date=2007-02-11&amp;amp;postid=1&amp;amp;utm_source=google
    //
    // If you deal with query parameters make sure you pass only significant part of it
    // in well defined order
    max_shown_comments: 10, // optional param; if it isn't defined default value (15) will be used
    theme: &quot;dark&quot;, // optional param; if it isn't defined default value ('light') will be used
    page_title: &quot;Moving to Remark42&quot;, // optional param; if it isn't defined `document.title` will be used
    locale: &quot;en&quot;, // set up locale and language, if it isn't defined default value ('en') will be used
  };

  (function (c) {
    for (var i = 0; i &amp;lt; c.length; i++) {
      var d = document,
        s = d.createElement(&quot;script&quot;);
      s.src = remark_config.host + &quot;/web/&quot; + c[i] + &quot;.js&quot;;
      s.defer = true;
      (d.head || d.body).appendChild(s);
    }
  })(remark_config.components || [&quot;embed&quot;]);
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;页面插入评论框&quot;&gt;页面插入评论框&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;remark42&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了，在 hexo 的 next 主题里面怎么做呢？&lt;/p&gt;
&lt;p&gt;答案是： 肯定是抄代码啊！！！&lt;/p&gt;
&lt;h3 id=&quot;hexo-next-主题&quot;&gt;hexo next 主题&lt;/h3&gt;
&lt;p&gt;首先知道（鬼知道啊），next 主题一般在项目 themes/next 路径，&lt;/p&gt;
&lt;p&gt;themes/next/layout 这个文件夹存放了布局文件，其中_layout.swig 是一个重要的全局布局文件。&lt;/p&gt;
&lt;p&gt;所以，明显是修改_layout.swig 引入上面的 script 代码啦。&lt;/p&gt;
&lt;p&gt;看了一眼_layout.swig 的代码, 底部基本是 include 引入同级的 swig 文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  {% include '_scripts/boostrap.swig' %}

  {% include 'remark42.swig' %}

  {% include '_third-party/comments/index.swig' %}
  {% include '_third-party/search/index.swig' %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明显，我们也可以加一个 swig，然后在上面引入一下。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-HTML&quot;&gt;
&amp;lt;script&amp;gt;
  var remark_config = {
    host: &quot;你部署的remark42 服务&quot;, // hostname of remark server, same as REMARK_URL in backend config, e.g. &quot;https://demo.remark42.com&quot;
    site_id: '你的站点Id,部署的时候指定的',
    components: ['embed'], // optional param; which components to load. default to [&quot;embed&quot;]
                           // to load all components define components as ['embed', 'last-comments', 'counter']
                           // available component are:
                           //     - 'embed': basic comments widget
                           //     - 'last-comments': last comments widget, see `Last Comments` section below
                           //     - 'counter': counter widget, see `Counter` section below
    url: window.location.origin + window.location.pathname, // optional param; if it isn't defined
                     // `window.location.origin + window.location.pathname` will be used,
                     //
                     // Note that if you use query parameters as significant part of url
                     // (the one that actually changes content on page)
                     // you will have to configure url manually to keep query params, as
                     // `window.location.origin + window.location.pathname` doesn't contain query params and
                     // hash. For example default url for `https://example/com/example-post?id=1#hash`
                     // would be `https://example/com/example-post`.
                     //
                     // The problem with query params is that they often contain useless params added by
                     // various trackers (utm params) and doesn't have defined order, so Remark treats differently
                     // all this examples:
                     // https://example.com/?postid=1&amp;amp;date=2007-02-11
                     // https://example.com/?date=2007-02-11&amp;amp;postid=1
                     // https://example.com/?date=2007-02-11&amp;amp;postid=1&amp;amp;utm_source=google
                     //
                     // If you deal with query parameters make sure you pass only significant part of it
                     // in well defined order
    max_shown_comments: 10, // optional param; if it isn't defined default value (15) will be used
    theme: 'dark', // optional param; if it isn't defined default value ('light') will be used
    page_title: 'Moving to Remark42', // optional param; if it isn't defined `document.title` will be used
    locale: 'en' // set up locale and language, if it isn't defined default value ('en') will be used
  };

  (function(c) {
    for(var i = 0; i &amp;lt; c.length; i++){
      var d = document, s = d.createElement('script');
      s.src = remark_config.host + '/web/' +c[i] +'.js';
      s.defer = true;
      (d.head || d.body).appendChild(s);
    }
  })(remark_config.components || ['embed']);
&amp;lt;/script&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;  {% include '_scripts/boostrap.swig' %}

  {% include 'remark42.swig' %}

  {% include '_third-party/comments/index.swig' %}
  {% include '_third-party/search/index.swig' %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搞完这个，全局脚本引用已经搞掂了。&lt;/p&gt;
&lt;p&gt;下面就是每个文章页面需要新增 remark42 评论框了&lt;/p&gt;
&lt;h3 id=&quot;明显，应该是-postswig&quot;&gt;明显，应该是 post.swig&lt;/h3&gt;
&lt;p&gt;观察一下 themes/next/layout 目录不难发现，&lt;/p&gt;
&lt;p&gt;每个文章的的样式模板都在 post.swig，&lt;/p&gt;
&lt;p&gt;明显评论框也应该直接在 post.swig。&lt;/p&gt;
&lt;p&gt;打开一看，感觉应该加在&lt;/p&gt;
&lt;div class=&quot;post-spread&quot; readability=&quot;35&quot;&gt;下面
&lt;p&gt;于是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&amp;gt;
  {{ post_template.render(page) }}

  &amp;lt;div class=&quot;post-spread&quot;&amp;gt;
    {% if theme.jiathis %} {% include '_partials/share/jiathis.swig' %} {%
    elseif theme.baidushare %} {% include '_partials/share/baidushare.swig' %}
    {% elseif theme.add_this_id %} {% include '_partials/share/add-this.swig' %}
    {% elseif theme.duoshuo_shortname and theme.duoshuo_share %} {% include
    '_partials/share/duoshuo_share.swig' %} {% endif %}
  &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;remark42&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完事...&lt;/p&gt;
&lt;h2 id=&quot;最后效果&quot;&gt;最后效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniudns.woyaozufang.live/remark42-demo.png&quot; alt=&quot;remark42&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎评论来玩！！&quot;&gt;欢迎评论来玩！！&lt;/h2&gt;
&lt;/div&gt;



</description>
<pubDate>Wed, 05 Aug 2020 17:23:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>能动手绝不多说：开源评论系统 remark42 上手指南 前言 写博客嘛， 谁不喜欢自己倒腾一下呢。 从自建系统到 Github Page， 从 Jekyll 到 Hexo， 年轻的时候谁不喜欢多折腾</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liguobao/p/13443831.html</dc:identifier>
</item>
</channel>
</rss>