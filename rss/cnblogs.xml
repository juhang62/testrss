<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 WebGL 的医疗物流系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/11558748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/11558748.html</guid>
<description>&lt;p&gt;物联网( IoT )，简单的理解就是物体之间通过互联网进行链接。世界上的万事万物，都可以通过数据的改变进行智能化管理。ioT 的兴起在医疗行业中具有拯救生命的潜在作用。&lt;br/&gt;不断的收集用户信息并且实时的进行诊断，所以未来 iot 肯定在医疗行业的应用会呈覆盖性。下面是我最近做的一个医疗物流系统，用来观察医疗物流过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920135025781-2114795492.gif&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ht官网链接：&lt;a href=&quot;http://www.hightopo.com/cn-index.html&quot;&gt;http://www.hightopo.com/cn-index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;demo链接： &lt;a href=&quot;https://www.hightopo.com/demo/pivas/&quot;&gt;https://www.hightopo.com/demo/pivas/&lt;/a&gt;&lt;a href=&quot;https://www.hightopo.com/demo/flight-monitor/&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;增加光源&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; 整个原场景其实是非常暗的，所以需要使用灯光的效果照亮整个场景，使其接近真实世界的场景。&lt;/p&gt;
&lt;p&gt; 我们看下对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920154613834-1841508251.png&quot; alt=&quot;&quot; width=&quot;812&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;light &lt;/span&gt;&lt;/strong&gt;的一些属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;type &lt;/span&gt;&lt;/strong&gt;代表灯光的类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;color &lt;/span&gt;&lt;/strong&gt;代表灯光的颜色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;intensity &lt;/span&gt;&lt;/strong&gt;代表灯光的强度（1是最大值）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;range &lt;/span&gt;&lt;/strong&gt;代表范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;addLight() {
        const skyBox &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.dm.getDataByTag('skyBox'&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 限制视野在天空球之内&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.gv.setSkyBox(skyBox)
        const light &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Light()&lt;/span&gt;&lt;span&gt;
        const lightSource &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.dm.getDataByTag('sunlight'&lt;span&gt;).p3()&lt;/span&gt;&lt;span&gt;

        const config &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;'light.type': 'point'&lt;span&gt;,
            &lt;/span&gt;'light.color': 'white'&lt;span&gt;,
            &lt;/span&gt;'light.intensity': 0.3&lt;span&gt;,
            &lt;/span&gt;'light.range': 10000&lt;span&gt;
        }

        light.s(config)
        light.p3(lightSource)&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dm.add(light)
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;看向物体&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;看到左下角的一个小窗口，其实是另一个3d场景，把它定位到左下角的，两个场景都使用了反序列化（ &lt;span&gt;&lt;strong&gt;deserialize &lt;/strong&gt;&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920160926011-1412135203.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;717&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt; 因为要定位医疗箱移动，所以这里使用到了 &lt;span&gt;&lt;strong&gt;flyTo&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;方法 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; renderCanvas = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (medical, duration) {
    ht.Default.startAnim({
       duration,
       easing(v, t) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t
       },
       action(v, t) {
         outScreenG3d.flyTo(medical, { direction: [&lt;/span&gt;-5, 3, 5], distance: 300&lt;span&gt; })
       }
    })
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;封装动画&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果要实现这么多的动画，首先想到的是一个个物体进行移动的过程。医疗箱的行走、电梯的升降、传送带运送医疗箱等我们都可以对他们的动作进行封装。&lt;/p&gt;
&lt;p&gt;如图可以看到医疗箱总是在动，所以定义了一个行走的动画，每次医疗箱行走的距离、行走方向、动画的配置都进行传参。&lt;/p&gt;
&lt;p&gt;这里要说明的参数：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;&lt;span&gt;node&lt;/span&gt;&lt;/strong&gt;（对应的元素）&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/strong&gt;（动画执行完进行回调的函数）&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;&lt;span&gt;config&lt;/span&gt;&lt;/strong&gt;（动画配置）&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;&lt;span&gt;coord&lt;/span&gt;&lt;/strong&gt;（方向轴）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 行走动画&lt;/span&gt;
&lt;span&gt;    walkAnim(node, fn, config, coord) {
        const { duration, space } &lt;/span&gt;=&lt;span&gt; config
        const positionArray &lt;/span&gt;=&lt;span&gt; node.p3()

        let isShadow &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        let ShadowNode &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果移动的元素是icu车或者供应车的话 获取它的阴影跟随元素移动&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (node.getTag() === 'supply' || node.getTag() === 'icuCar'&lt;span&gt;) {
            isShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            ShadowNode &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dm.getDataByTag(`${node.getTag()}Shadow`)
        }

        ht.Default.startAnim({
            duration,
            easing: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (t) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t
            },
            action(v, t) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (coord === 'x'&lt;span&gt;) {
                    node.p3(positionArray[&lt;/span&gt;0] + t * space, positionArray[1], positionArray[2&lt;span&gt;])
                    isShadow &lt;/span&gt;&amp;amp;&amp;amp; ShadowNode.p3(positionArray[0] + t * space, positionArray[1], positionArray[2&lt;span&gt;])
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (coord === 'y'&lt;span&gt;) {
                    node.p3(positionArray[&lt;/span&gt;0], positionArray[1] + t * space, positionArray[2&lt;span&gt;])
                    isShadow &lt;/span&gt;&amp;amp;&amp;amp; ShadowNode.p3(positionArray[0], positionArray[1] + t * space, positionArray[2&lt;span&gt;])
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    node.p3(positionArray[&lt;/span&gt;0], positionArray[1], positionArray[2] + t *&lt;span&gt; space)
                    isShadow &lt;/span&gt;&amp;amp;&amp;amp; ShadowNode.p3(positionArray[0], positionArray[1], positionArray[2] + t *&lt;span&gt; space)
                }
            },
            finishFunc() {
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; fn === 'function' &amp;amp;&amp;amp;&lt;span&gt; fn(node)
            }
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;云中穿行效果&quot;&gt;&lt;strong&gt;物体之间的影响&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;电梯的升降会影响很多东西，比如频台的移动会带着传送带和医疗箱，这里我用到了 &lt;span&gt;&lt;strong&gt;sethost&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;吸附&lt;/span&gt;方法（吸附：节点指定宿主，宿主进行改变会影响节点）。&lt;/p&gt;
&lt;p&gt;很多场景下非常合适，我需要电梯升降的过程中带用医疗箱和频台一起上升，还有医疗箱放到传送带的时候，医疗箱要动起来，感觉是这真的传送带在带动医疗箱进行运动。&lt;/p&gt;

&lt;p&gt;这里要说明的参数：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;&lt;span&gt;node&lt;/span&gt;&lt;/strong&gt;（操作的电梯元素）&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;&lt;span&gt;medicalKit&lt;/span&gt;&lt;/strong&gt;（医疗箱）&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/strong&gt;（动画执行完进行回调的函数）&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;&lt;span&gt;status&lt;/span&gt;&lt;/strong&gt; （电梯上升和下降的状态）&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;&lt;span&gt;config&lt;/span&gt;&lt;/strong&gt;（动画配置）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电梯升降动画&lt;/span&gt;
&lt;span&gt;    elevatorAnim(node, medicalKit, fn, status, config) {
        const self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取电梯的index 让对应的频台也跟着动&lt;/span&gt;
        const elevatorIndex = node.getTag().replace(/[^0-9]/ig, '') - 0

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取医疗箱的index 控制电梯升降的距离&lt;/span&gt;
        const medicalKitIndex = medicalKit.getTag().replace(/[^0-9]/ig, '') - 0&lt;span&gt;
        const positionArray &lt;/span&gt;=&lt;span&gt; node.p3()
        const station &lt;/span&gt;=&lt;span&gt; self.dm.getDataByTag(`station${elevatorIndex}`)
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;吸附宿主&lt;/span&gt;
&lt;span&gt;        station.setHost(node)
        medicalKit.setHost(node)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置升降状态&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (elevatorIndex === 3) self.elevatorRunning = &lt;span&gt;true&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 升降距离 status 为 0 的时候是下降 最低部位的距离是固定的 所以只需要控制上升的距离&lt;/span&gt;
        const medicalKitLevel =&lt;span&gt; self.returnMedicalKitLevel(medicalKitIndex)

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 电梯的属性&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最低点的位置 Lowest&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有轨道的话 就去轨道的位置  否则就按照层数 orbitalP&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一层的位置  distance&lt;/span&gt;
&lt;span&gt;        let space
        const addSpace &lt;/span&gt;= medicalKitIndex === 7 ? 100 : 0
        &lt;span&gt;if&lt;/span&gt; (status == 1&lt;span&gt;) {
            space &lt;/span&gt;= config.orbitalP ? config.orbitalP : config.distance + addSpace + (400 *&lt;span&gt; medicalKitLevel)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            space &lt;/span&gt;=&lt;span&gt; config.Lowest
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下降状态时 医疗箱不会做动作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (status === 0&lt;span&gt;) {
            medicalKit.setHost()
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ht.Default.startAnim({
            duration: config.orbitalP &lt;/span&gt;? 2000 : (medicalKitLevel === 0 &amp;amp;&amp;amp; elevatorIndex == 3 ? 700 : 2500 + (medicalKitLevel * 1000&lt;span&gt;)),
            action(v, t) {
                node.p3(
                    positionArray[&lt;/span&gt;0&lt;span&gt;],
                    positionArray[&lt;/span&gt;1] + ((space - positionArray[1]) *&lt;span&gt; t),
                    positionArray[&lt;/span&gt;2&lt;span&gt;]
                )
            },
            finishFunc() {
                station.setHost()
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; fn === 'function' &amp;amp;&amp;amp;&lt;span&gt; fn(node)
            }
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;云中穿行效果&quot;&gt;动画暂停&lt;/h2&gt;
&lt;p&gt; 动画的过程中有个问题需要处理就是等待电梯的动画，医疗箱在动画过程中，需要判断电梯是否在上升，如果不在地面的话，需要等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920165548438-1173893912.gif&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;592&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我的思路是，当医疗箱走到离电梯一点距离的时候，需要判断电梯是否在上升状态，如果是的话，需要调用动画暂停的方法。&lt;/p&gt;



&lt;p&gt; 当 &lt;strong&gt;&lt;span&gt;elevatorRunning&lt;/span&gt;&lt;/strong&gt; 为 &lt;span&gt;false&lt;/span&gt; 的时候代表电梯没有运动，否则在运动中。&lt;/p&gt;
&lt;p&gt; 电梯动画开始的时候设置为 true，结束后设置变量为 false，  就可以监控它的状态了。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;ht.Default.startAnim&lt;/span&gt;&lt;/strong&gt; 方法会返回一个实例，通过实例的方法可以对当前动画进行一些操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const anim =&lt;span&gt; ht.Default.startAnim({
            duration,
            action(v, t) {
                node.p3(
                    positionArray[&lt;/span&gt;0&lt;span&gt;],
                    positionArray[&lt;/span&gt;1&lt;span&gt;],
                    positionArray[&lt;/span&gt;2] - (tpMax - positionArray[2]) *&lt;span&gt; t
                );
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;gt; 1 &amp;amp;&amp;amp; self.elevatorRunning === &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.p3()[2] &amp;lt;=&lt;span&gt; stopMax) {
                        anim.pause();
                        const t &lt;/span&gt;= setInterval(() =&amp;gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (self.elevatorRunning === &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                                anim.resume();
                                clearInterval(t);
                            }
                        }, &lt;/span&gt;100&lt;span&gt;);
                    }
                }
            },
            finishFunc() {
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; fn === &quot;function&quot; &amp;amp;&amp;amp;&lt;span&gt; fn();
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; anim;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;云中穿行效果&quot;&gt;事件监听（发布、订阅）&lt;/h2&gt;
&lt;p&gt; 因为需要监听某个当前动画的结束，然后进行相机位移。&lt;/p&gt;
&lt;p&gt; 如图，我需要监听第一个 3d 场景中显示提示文字动画结束，然后执行第二个 3d 场景的显示。因为2个是不同的场景，是不能用回调的方法监听到的，所以这里就用到了 &lt;strong&gt;&lt;span&gt;eventBus&lt;/span&gt;&lt;/strong&gt; 事件总线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920171551661-1001225928.gif&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;



&lt;p&gt;下面是 &lt;strong&gt;&lt;span&gt;eventBus&lt;/span&gt;&lt;/strong&gt; 的使用，第一个参数代表要监听的注册函数名，第二个是回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件总线 监听事件&lt;/span&gt;
eventbus.on('animation1', _ =&amp;gt;&lt;span&gt; {
  const medical &lt;/span&gt;= dm.getDataByTag('medicalKit1'&lt;span&gt;)
  renderView(medical, dm, gv)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是 &lt;strong&gt;&lt;span&gt;eventBus &lt;/span&gt;&lt;/strong&gt;发射的使用，第一个参数代表要触发的函数名，第二个是发射给函数的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发事件&lt;/span&gt;
eventbus.emit(&quot;animation1&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 做完这个 demo 之后，除了对 HT for Web 更加熟练之外，对物联网也有了更深刻的概念。&lt;/p&gt;
&lt;p&gt; 我身为一名前端工作者，在这个时代感觉非常的自豪，因为我能通过自己的技能创造出许多能造福和改善人们生活的东西。&lt;/p&gt;
&lt;p&gt; 希望大家看到我的 demo 能够得到一些启发，同时也要相信自己能够创造不可能，为社会做出贡献。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Sep 2019 00:31:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 物联网( IoT )，简单的理解就是物体之间通过互联网进行链接。世界上的万事万物，都可以通过数据的改变进行智能化管理。ioT 的兴起在医疗行业中具有拯救生命的潜在作用。不断的收集用户信息并且实时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/11558748.html</dc:identifier>
</item>
<item>
<title>1小时让你掌握响应式编程，并入门Reactor - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/step-into-reactive-programing-in-an-hour.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/step-into-reactive-programing-in-an-hour.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我看同步阻塞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“你知道什么是同步阻塞吗”，当然知道了。“那你怎么看它呢”，这个。。。&lt;/p&gt;&lt;p&gt;在同步阻塞的世界里，代码执行到哪里，数据就跟到哪里。如果数据很慢跟不上来，代码就停在那里等待数据的到来，然后再带着数据一起往下执行。&lt;/p&gt;&lt;p&gt;可以说是，代码执行和数据是结伴而行，不离不弃。执子之手与子偕老。让人老感动了。&lt;/p&gt;&lt;p&gt;如果还不太理解的话，可以认为代码执行其实就是一些行为动作，这些行为动作的目的就是为了获取/操作数据。&lt;/p&gt;&lt;p&gt;例如加法，这里的行为动作就是执行相加，数据就是加数和被加数。操作结果就是得到了另一个数据，即两个数的和。&lt;/p&gt;&lt;p&gt;只是在这个加法里，数据跑的特别快，（CPU的寄存器，能不快吗），我们几乎觉察不到执行动作在等数据的过程。怎么办呢，那就看一个能把它们拉开的例子。&lt;/p&gt;&lt;p&gt;那自然非数据库查询莫属了，既有网络I/O，又有磁盘I/O，肯定会慢一些。&lt;/p&gt;&lt;p&gt;假设我的业务是这样的，代码先去数据库查询一个用户，接着修改用户的密码，然后再更新回数据库，最后代码返回成功。&lt;/p&gt;&lt;p&gt;如果网速和数据库都很慢的话，可能是这样的。代码执行一个查询数据库动作，然后等啊等啊等，等的花都谢了，终于数据库把用户返回过来了，接着，代码飞快的修改了密码，并执行一个更新数据库的动作，然后又是等啊等啊等，等的花又开了，数据库终于回话了，更新成功。然后代码返回成功，全部执行完了。&lt;/p&gt;&lt;p&gt;所以同步阻塞代码的最大特点就是，带着数据上路，数据不到位就阻塞住。&lt;/p&gt;&lt;p&gt;最后来个小小的升华：&lt;/p&gt;&lt;p&gt;●所谓同步就是快的等慢的，然后一起往前走，表示的是目的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;所谓阻塞就是想办法让快的停滞不前，等待慢的到来，表示的是手段。&lt;/p&gt;&lt;p&gt;一言以蔽之，同步是目的，阻塞是手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我看异步非阻塞&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“你知道什么是异步非阻塞吗”，当然知道了，不过我不知道该怎么看它。“哦，恭喜你都会抢答了。。。”。&lt;/p&gt;&lt;p&gt;我们生活在异步的世界，却是最不懂异步的人。&lt;/p&gt;&lt;p&gt;你去饭店吃饭，服务员把你的菜单写好，交给厨房后就去服务别人了。&lt;/p&gt;&lt;p&gt;厨房把饭做好后，通过按铃通知服务员，服务员再把饭送到你的位置上。&lt;/p&gt;&lt;p&gt;服务员是主（或I/O）线程，把任务交给厨房这个工作线程去执行，厨房接到任务的同时还要记住送来该任务的服务员，然后厨房去执行任务，服务员也去忙别的了。&lt;/p&gt;&lt;p&gt;厨房执行完任务后，对当时的那个服务员进行通知，服务员接到通知后，再去执行接下来的内容，如把饭送到客人餐桌。&lt;/p&gt;&lt;p&gt;这是一个非常常见的异步场景，由于其中一方不愿意等待（或时时刻刻关注）另一方，但又不知道对方什么时候能做完，所以只能寄希望于对方做完的时候告诉自己一声，然后自己再进行后续的工作。&lt;/p&gt;&lt;p&gt;这就是我们常说的异步回调（或通知）。&lt;/p&gt;&lt;p&gt;早上项目经理开完会，给大家分好任务，并把测试用例代码也给了大家，说谁做完了跑一边测试用例，通了就可以了。然后就散会，各自忙去了。&lt;/p&gt;&lt;p&gt;下午5点你做完了，开始跑测试用例，很幸运，一次性全部通过。你的任务就算完成了，接下来就可以干自己想干的事情，比如看“编程新说”公众号。&lt;/p&gt;&lt;p&gt;项目经理是主（或I/O）线程，把任务交给各个开发人员这些工作线程，并给每个人一段逻辑代码，告诉他们在自己的任务完成后再执行这一段逻辑代码。&lt;/p&gt;&lt;p&gt;开发人员完成任务后，接着执行逻辑代码，执行完逻辑代码后，就算已经结束了。不再需要告知项目经理一声。&lt;/p&gt;&lt;p&gt;这也是一个常见的异步场景，一方给另一方安排好任务后，再给它一段逻辑代码，接着彼此就分道扬镳。之后的日子里，你走你的阳关道，我过我的独木桥，井水不犯河水，老死不相往来。&lt;/p&gt;&lt;p&gt;这段逻辑代码通常是由一个Runnable接口传入，且是在任务完成时执行，就暂且称它为的“完成执行”吧。&lt;/p&gt;&lt;p&gt;所以异步非阻塞代码的最大特点就是，我给你分配任务，你完事给我回复，咱俩互相不耽误。&lt;/p&gt;&lt;p&gt;最后来个小小的升华：&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;所谓异步就是你走你的，我走我的，大家各自往前走，表示的是一种事实形态。&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;所谓非阻塞就是快的快走，慢的慢走，一刻都不为你停留，表示的是一种直观现象。&lt;/p&gt;&lt;p&gt;一言以蔽之，异步是形态，非阻塞是现象。&lt;/p&gt;&lt;p&gt;异步非阻塞它本身并没有什么明显的可圈可点的特征，注意我说的是它“本身”。因为我们整个世界都是按照异步非阻塞模式在运行。&lt;/p&gt;&lt;p&gt;上厕所的时候玩手机，等车的时候玩手机，上班的时候玩手机，等饭的时候玩手机，回家以后玩手机，睡觉做梦玩手机。第二天还是这样的。哈哈。一个人就没有被阻塞住的时候。&lt;/p&gt;&lt;p&gt;不可否认，我们生活的社会又很复杂，主要是因为人和人之间的沟通、交流和协调有时并非一件容易之事。&lt;/p&gt;&lt;p&gt;同理，异步非阻塞“本身”并不难，难就难在怎么实现它。毕竟让一群听不懂人话的二货线程们互相沟通协调更非一件易事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我看响应式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓响应式就是外界发生了变化，你要做出反应。所以响应式编程就是围绕着变化来构建的。&lt;/p&gt;&lt;p&gt;如何收集到原始变化，如何把这个变化告知相关处理者，处理者如何做出反应，做出反应的过程其实就是引发了新的变化，这个新的变化又该如何被收集，又该如何告知下一个处理者，如此往复，直至全部结束。&lt;/p&gt;&lt;p&gt;可以说整个自然界都是响应式的，因为它们都会对外界的变化或自身的变化产生反应。&lt;/p&gt;&lt;p&gt;先说人类，冷的时候加衣，饿的时候吃饭，病的时候去医院。看到绿色放松，看到蓝色镇定，看到红色易激动。&lt;/p&gt;&lt;p&gt;再说动植物，向日葵围绕太阳转叫趋光性，植物的根系朝水多的地方生长叫趋水性，鸽子可以磁场辨别方向，鲸鱼、海归都可以利用磁场记住自己走过的路。&lt;/p&gt;&lt;p&gt;所以响应式“本身”是一个很简单的模型，你给我一个变化，我做出一个反应。&lt;/p&gt;&lt;p&gt;动植物都有一套完善的感觉器官，能够感受到外界变化。同时他们又有超高的智商或完善的一套生物系统能够对这种变化作出反应。这是数万年甚至数千万年进化的结果，是基因决定的，所以看起来很自然。&lt;/p&gt;&lt;p&gt;再来看看编程界的响应式，也是这两个问题，一是如何知道外界的变化，二是如何对这种变化作出反应。&lt;/p&gt;&lt;p&gt;代码可是没有生命的，那就只能简单粗暴了。如何知道变化，那就让别人告诉你呗。如何做出反应，那就执行一段逻辑代码呗。&lt;/p&gt;&lt;p&gt;别人告诉你就等于异步回调/通知，执行的这段逻辑代码，可以是外界传入的，也可以是自己本身的一个方法。&lt;/p&gt;&lt;p&gt;现在明白了吧，异步非阻塞就是响应式。&lt;/p&gt;&lt;p&gt;最后来个小小升华：&lt;/p&gt;&lt;p&gt;所谓响应式就是一个概念，或是一种编程模式，它并不是一个知识，也不是一个技术。但它需要用到一个技术，那就是实现异步非阻塞的技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我看Reactor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在传统的编码中，会将逻辑处理代码写成方法，需要的数据由方法参数传入，处理过的数据由方法的返回值返回。&lt;/p&gt;&lt;p&gt;执行时以main方法为入口点启动，按照一定的顺序执行这些方法，数据依次流入流出每个方法，当所有的方法执行完时，数据也处理完了，就结束了。&lt;/p&gt;&lt;p&gt;整个过程是以逻辑代码的执行为主线，数据只是一个必须的参与者而已，因为代码要处理数据，如果数据不到位，代码就停下来不执行，等待数据的到来。&lt;/p&gt;&lt;p&gt;这就是典型的同步阻塞式的执行过程，非常简单，易于理解，而且代码也很好写。&lt;/p&gt;&lt;p&gt;到目前为止，我们提到的都是响应式的理论，那应该怎样去实现它呢，一时间还真没有头绪。&lt;/p&gt;&lt;p&gt;响应式是异步非阻塞，和同步阻塞应该是相对的。那我们不妨就拿响应式往同步阻塞上套一下，看看能得到什么有价值的发现。&lt;/p&gt;&lt;p&gt;响应式关注两点，变化和反应，而且是变化在前，反应在后。同步阻塞也关注两点，执行逻辑和数据，而且是执行逻辑在前，数据在后。&lt;/p&gt;&lt;p&gt;那就开始建立对应关系。因为“反应”是一系列行为动作，所以应该和“执行逻辑”对应。那“变化”只能和“数据”对应，其实这是对的，“数据”由不可用到可用，本身就是发生了一个“变化”。&lt;/p&gt;&lt;p&gt;这个对应关系建立的很完美，但是逻辑顺序却完全冲突。响应式是由变化主导反应，这很好理解，我都没有变化，你无须做出反应。同步阻塞是由执行逻辑主导数据，这也很好理解，我代码都没执行呢，根本不需要数据。&lt;/p&gt;&lt;p&gt;可见，它们的对应关系非常完美，但主导顺序完全相反，这就是一个非常非常有价值的发现。&lt;/p&gt;&lt;p&gt;因为我们只需把同步阻塞倒过来，就是实现响应式的大致方向。这样的推理貌似是对的，但实际当中是这样的吗？嗯，是这样的。&lt;/p&gt;&lt;p&gt;现在请大家和我一起扭转思维。原来以逻辑代码执行作为主线，数据作为参与者。现在以数据作为主线，逻辑代码执行作为参与者。说的再白一些，原来是数据传递到逻辑代码里，现在是逻辑代码传递到数据里。&lt;/p&gt;&lt;p&gt;有人也许会问，逻辑代码怎么传递？哈哈，Lambda表达式呀，函数式编程呀。&lt;/p&gt;&lt;p&gt;想象一下，有一个长长的管子，里面的水一直在流。&lt;/p&gt;&lt;p&gt;如果你想让水变成橙色的，只需在管子上开个口，加装一个可以持续投放橙色染料的装置，结果流经它的水都变成橙色的了。&lt;/p&gt;&lt;p&gt;如果你想让橙色的水变甜的话，只需在后面的管子上开个口，加装一个可以持续投放白糖的装置，结果流经它的水都变成甜的了。&lt;/p&gt;&lt;p&gt;同理，可以在后面继续加装投放柠檬酸的装置，让水变酸，在后面继续加装压入二氧化碳的装置，让水带气泡。&lt;/p&gt;&lt;p&gt;最后发现，自来水经过多道工序处理后变成了芬达。&lt;/p&gt;&lt;p&gt;如果把水流看作是数据流，把投放装置看作是逻辑代码，就变成了，数据先流入第一个逻辑代码，处理后再流入第二个逻辑代码，依次流下去直至结束。&lt;/p&gt;&lt;p&gt;这就是以数据作为主线，逻辑代码只是参与者，同时它也是Reactor实现响应式编程的原理，Spring官方使用的响应式类库就是Reactor。&lt;/p&gt;&lt;p&gt;其中，“以数据为主线”和“在变化时通知处理者”这两个功能Reactor库都已经实现了，我们需要做的就是“对变化做出反应”，即插入逻辑代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Reactor入门&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Reactor中，有两个非常重要的类，就是Mono和Flux，它们都是数据源，在它们内部都已经实现了“以数据为主线”和“在变化时通知处理者”这两个功能，而且还提供了方法让我们来插入逻辑代码用于“对变化做出反应”。&lt;/p&gt;&lt;p&gt;Mono表示0个或1个数据，Flux表示0到多个数据。先从简单的Mono开始。&lt;/p&gt;&lt;p&gt;设计一个简单的示例，首先创建一个数据源，只包含一个数据10，第一个处理就是加1，第二个处理就是奇偶性过滤，第三个处理就是把这个数据消费掉，然后就结束了。&lt;/p&gt;&lt;p&gt;为了清楚地看出来主线程执行的是哪些代码，工作线程执行的是哪些代码，特意打印了很多信息。&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;8&quot;&gt;&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;15&quot;&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;displayCurrTime(&lt;span class=&quot;&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;displayCurrThreadId(&lt;span class=&quot;&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//创建一个数据源&lt;/span&gt;&lt;br/&gt;Mono.just(&lt;span class=&quot;&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//延迟5秒再发射数据&lt;/span&gt;&lt;br/&gt;.delayElement(Duration.ofSeconds(&lt;span class=&quot;&quot;&gt;5&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//在数据上执行一个转换&lt;/span&gt;&lt;br/&gt;.map(n -&amp;gt; {&lt;br/&gt;displayCurrTime(&lt;span class=&quot;&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;displayCurrThreadId(&lt;span class=&quot;&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;displayValue(n);&lt;br/&gt;delaySeconds(&lt;span class=&quot;&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; n + &lt;span class=&quot;&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;})&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//在数据上执行一个过滤&lt;/span&gt;&lt;br/&gt;.filter(n -&amp;gt; {&lt;br/&gt;displayCurrTime(&lt;span class=&quot;&quot;&gt;3&lt;/span&gt;);&lt;br/&gt;displayCurrThreadId(&lt;span class=&quot;&quot;&gt;3&lt;/span&gt;);&lt;br/&gt;displayValue(n);&lt;br/&gt;delaySeconds(&lt;span class=&quot;&quot;&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; n % &lt;span class=&quot;&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;})&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//如果数据没了就用默认值&lt;/span&gt;&lt;br/&gt;.defaultIfEmpty(&lt;span class=&quot;&quot;&gt;9&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//订阅一个消费者把数据消费了&lt;/span&gt;&lt;br/&gt;.subscribe(n -&amp;gt; {&lt;br/&gt;displayCurrTime(&lt;span class=&quot;&quot;&gt;4&lt;/span&gt;);&lt;br/&gt;displayCurrThreadId(&lt;span class=&quot;&quot;&gt;4&lt;/span&gt;);&lt;br/&gt;displayValue(n);&lt;br/&gt;delaySeconds(&lt;span class=&quot;&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;out&lt;/span&gt;.println(n + &lt;span class=&quot;&quot;&gt;&quot; consumed, worker Thread over, exit.&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;displayCurrTime(&lt;span class=&quot;&quot;&gt;5&lt;/span&gt;);&lt;br/&gt;displayCurrThreadId(&lt;span class=&quot;&quot;&gt;5&lt;/span&gt;);&lt;br/&gt;pause();&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;&quot;&gt;//显示当前时间&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;displayCurrTime&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;int&lt;/span&gt; point&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;out&lt;/span&gt;.println(point + &lt;span class=&quot;&quot;&gt;&quot; : &quot;&lt;/span&gt; + LocalTime.now());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;//显示当前线程Id&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;displayCurrThreadId&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;int&lt;/span&gt; point&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;out&lt;/span&gt;.println(point + &lt;span class=&quot;&quot;&gt;&quot; : &quot;&lt;/span&gt; + Thread.currentThread().getId());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;//显示当前的数值&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;displayValue&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;int&lt;/span&gt; n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;&quot;&gt;&quot;input : &quot;&lt;/span&gt; + n);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;//延迟若干秒&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;delaySeconds&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;int&lt;/span&gt; seconds&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;TimeUnit.SECONDS.sleep(seconds);&lt;br/&gt;} &lt;span class=&quot;&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;//主线程暂停&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;pause&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;&quot;&gt;&quot;main Thread over, paused.&quot;&lt;/span&gt;);&lt;br/&gt;System.&lt;span class=&quot;&quot;&gt;in&lt;/span&gt;.read();&lt;br/&gt;} &lt;span class=&quot;&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;以下是输出结果：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;8&quot;&gt;1 : 15&lt;span class=&quot;&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;&quot;&gt;:39.809&lt;/span&gt;&lt;br/&gt;1 : 1&lt;br/&gt;5 : 15&lt;span class=&quot;&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;&quot;&gt;:40.158&lt;/span&gt;&lt;br/&gt;5 : 1&lt;br/&gt;&lt;span class=&quot;&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;&quot;&gt;over&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;paused&lt;/span&gt;.&lt;p&gt;2 : 15&lt;span class=&quot;&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;&quot;&gt;:45.158&lt;/span&gt;&lt;br/&gt;2 : 9&lt;br/&gt;&lt;span class=&quot;&quot;&gt;input&lt;/span&gt; : 10&lt;/p&gt;&lt;p&gt;3 : 15&lt;span class=&quot;&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;&quot;&gt;:47.160&lt;/span&gt;&lt;br/&gt;3 : 9&lt;br/&gt;&lt;span class=&quot;&quot;&gt;input&lt;/span&gt; : 11&lt;/p&gt;&lt;p&gt;4 : 15&lt;span class=&quot;&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;&quot;&gt;:50.162&lt;/span&gt;&lt;br/&gt;4 : 9&lt;br/&gt;&lt;span class=&quot;&quot;&gt;input&lt;/span&gt; : 9&lt;br/&gt;9 &lt;span class=&quot;&quot;&gt;consumed&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;worker&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;&quot;&gt;over&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;exit&lt;/span&gt;.&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;可以看到不到1秒钟时间主线程就执行完了。然后5秒后数据从数据源发射出来进入第一步处理，2秒后进入第二步处理，3秒后进入第三步处理，数据被消费掉，就结束了。其中主线程Id是1，工作线程Id是9。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这段代码其实是建立了一个数据通道，在通道的指定位置上插入处理逻辑，等待数据到来。&lt;/p&gt;&lt;p&gt;主线程执行的是建立通道的代码，主线程很快执行完，通道就建好了。此时只是一个空的通道，根本就没有数据。&lt;/p&gt;&lt;p&gt;在数据到来时，由工作线程执行每个节点的逻辑代码来处理数据，然后把数据传入下一个节点，如此反复直至结束。&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在写响应式代码的时候，心里一定要默念着，我所做的事情就是建立一条数据通道，在通道上指定的位置插入适合的逻辑处理代码。同时还要切记，主线程执行完时，只是建立了通道，并没有数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;如果本文内容你没有看懂，那就多看几遍，保证能懂。如果你都看懂了，那恭喜你已经入门响应式编程了。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;（END）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Sep 2019 00:22:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>我看同步阻塞 “你知道什么是同步阻塞吗”，当然知道了。“那你怎么看它呢”，这个。。。在同步阻塞的世界里，代码执行到哪里，数据就跟到哪里。如果数据很慢跟不上来，代码就停在那里等待数据的到来，然后再带着数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/step-into-reactive-programing-in-an-hour.html</dc:identifier>
</item>
<item>
<title>静态路由与三层交换机 - 脑洞大开好青年</title>
<link>http://www.cnblogs.com/a1972/p/11570311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a1972/p/11570311.html</guid>
<description>&lt;p&gt;配置三层交换机实现跨vlan通信&lt;br/&gt;1.创建所有主机ip和网关&lt;br/&gt;2.针对二层交换机，创建vlan（全局模式下），配置truck&lt;br/&gt;   Switch(config)#vlan 10&lt;br/&gt;   对交换机接口进行vlan分区（接口模式）&lt;br/&gt;   Switch(config)#interface range f0/1-2&lt;br/&gt;   Switch(config-if-range)#switchport mode access&lt;br/&gt;   Switch(config-if-range)#switchport access vlan 10&lt;br/&gt;   配置truck&lt;br/&gt;   Switch(config)#interface f0/3&lt;br/&gt;   Switch(config-if)#switchport mode truck&lt;br/&gt;   (二层交换机默认802.1q封装模式）&lt;br/&gt;3.针对三层交换机，创建vlan,开启路由，设置ip，配置truck&lt;br/&gt;   创建vlan同上&lt;br/&gt;   开启路由&lt;br/&gt;   Switch(config)#ip routing&lt;br/&gt;   配置各vlan的ip地址&lt;br/&gt;   Switch(config)#interface vlan 10&lt;br/&gt;   Switch(config-if)#ip address 192.168.1.3 255.255.255.0&lt;br/&gt;   (切记如果是vlan 1,记得no shutdown)&lt;br/&gt;   Switch(config-if)#no shutdown&lt;br/&gt;   配置truck&lt;br/&gt;   Switch(config)#interface range f0/1-2&lt;br/&gt;   Switch(config-if-range)#switchport truck encapsulation dot1q&lt;br/&gt;   Switch(config-if-range)#switchport mode truck&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   查看路由表&lt;br/&gt;   Switch#show vlan brief&lt;/p&gt;
&lt;p&gt;   查看某个vlan信息的指令&lt;br/&gt;   Switch#show vlan 10&lt;/p&gt;
&lt;p&gt;   查看虚拟网关ip地址&lt;br/&gt;    Switch#show ip route&lt;/p&gt;

&lt;p&gt;   静态路由&lt;br/&gt;   1.设置所有PC的ip以及子网掩码和网关&lt;br/&gt;   2.设置router网关IP以及static route and defult route&lt;br/&gt;   3.static route&lt;br/&gt; Router(config)#ip route 目标网段+子网掩码+下一跳地址&lt;br/&gt;   4.defult route&lt;br/&gt; Router(config)#ip route 0.0.0.0 0.0.0.0 下一跳地址&lt;br/&gt; &lt;br/&gt;  &lt;/p&gt;


</description>
<pubDate>Mon, 23 Sep 2019 00:05:00 +0000</pubDate>
<dc:creator>脑洞大开好青年</dc:creator>
<og:description>配置三层交换机实现跨vlan通信1.创建所有主机ip和网关2.针对二层交换机，创建vlan（全局模式下），配置truck Switch(config)#vlan 10 对交换机接口进行vlan分区（接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/a1972/p/11570311.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.2 : 二十三. 深入聊一聊配置的内部处理机制 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore_23.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore_23.html</guid>
<description>&lt;p&gt;上一章介绍了配置的多种数据源被注册、加载和获取的过程，本节看一下这个过程系统是如何实现的。(&lt;a href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot;&gt;ASP.NET Core 系列目录&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;在上一节介绍的数据源设置中，appsettings.json、命令行、环境变量三种方式是被系统自动加载的，这是因为系统在webHost.CreateDefaultBuilder(args)中已经为这三种数据源进了注册，那么就从这个方法说起。这个方法中同样调用了ConfigureAppConfiguration方法，代码如下：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateDefaultBuilder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; newWebHostBuilder();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
    builder.UseKestrel((builderContext, options) =&amp;gt;&lt;span&gt;
        {
            options.Configure(builderContext.Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Kestrel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        })
        .ConfigureAppConfiguration((hostingContext, config) &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; env =&lt;span&gt; hostingContext.HostingEnvironment;
            config.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    .AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{env.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional:&lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(env.IsDevelopment())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; appAssembly =&lt;span&gt; Assembly.Load(newAssemblyName(env.ApplicationName));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(appAssembly != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    config.AddUserSecrets(appAssembly, optional: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                }
            }

            config.AddEnvironmentVariables();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(args != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                config.AddCommandLine(args);
            }
       })

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;看一下其中的ConfigureAppConfiguration方法，加载的内容主要有四种，首先加载的是appsettings.json和appsettings.{env.EnvironmentName}.json两个JSON文件，关于env.EnvironmentName在前面的章节已经说过，常见的有Development、Staging 和 Production三种值，在我们开发调试时一般是Development，也就是会加载appsettings.json和appsettings. Development.json两个JSON文件。第二种加载的是用户机密文件，这仅限于Development状态下，会通过config.AddUserSecrets方法加载。第三种是通过config.AddEnvironmentVariables方法加载的环境变量，第四种是通过config.AddCommandLine方法加载的命令行参数。&lt;/p&gt;
&lt;p&gt;注意：这里的ConfigureAppConfiguration方法这时候是不会被执行的，只是将这个方法作为一个Action&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt; configureDelegate添加到了WebHostBuilder的_configureServicesDelegates属性中。configureServicesDelegates是一个List&amp;lt;Action&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt;&amp;gt;类型的集合。对应代码如下：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; IWebHostBuilder ConfigureAppConfiguration(Action&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(configureDelegate == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(configureDelegate));
    }

    _configureAppConfigurationBuilderDelegates.Add(configureDelegate);
    returnthis;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;上一节的例子中，我们在webHost.CreateDefaultBuilder(args)方法之后再次调用ConfigureAppConfiguration方法添加了一些自定义的数据源，这个方法也是没有执行，同样被添加到了这个集合中。直到WebHostBuilder通过它的Build()方法创建WebHost的时候，才会遍历这个集合逐一执行。这段代码写在被Build()方法调用的BuildCommonServices()中：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; IServiceCollection BuildCommonServices(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; AggregateException hostingStartupErrors)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
        .SetBasePath(_hostingEnvironment.ContentRootPath)
        .AddConfiguration(_config);

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; configureAppConfiguration &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _configureAppConfigurationBuilderDelegates)
    {
        configureAppConfiguration(_context, builder);
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration =&lt;span&gt; builder.Build();
    services.AddSingleton&lt;/span&gt;&amp;lt;IConfiguration&amp;gt;&lt;span&gt;(configuration);
    _context.Configuration &lt;/span&gt;=&lt;span&gt; configuration;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;首先创建了一个ConfigurationBuilder对象，然后通过foreach循环逐一执行被添加到集合_configureAppConfigurationBuilderDelegates中的configureAppConfiguration方法，那么在执行的时候，这些不同的数据源是如何被加载的呢？这部分功能在namespace Microsoft.Extensions.Configuration命名空间中。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以appsettings.json对应的config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)方法为例，进一步看一下它的实现方式。首先介绍的是IConfigurationBuilder接口，对应的实现类是ConfigurationBuilder，代码如下：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationBuilder : IConfigurationBuilder
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;IConfigurationSource&amp;gt; Sources { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IConfigurationSource&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; Properties { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IConfigurationBuilder Add(IConfigurationSource source)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(source));
            }

            Sources.Add(source);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了IConfigurationRoot Build()方法，下文介绍&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;ConfigureAppConfiguration方法中调用的AddJsonFile方法来自JsonConfigurationExtensions类，代码如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonConfigurationExtensions
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddJsonFile(&lt;span&gt;this&lt;/span&gt; IConfigurationBuilder builder, IFileProvider provider, &lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;bool&lt;/span&gt; optional, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; reloadOnChange)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(builder));
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(path))
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentException(Resources.Error_InvalidFilePath, nameof(path));
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.AddJsonFile(s =&amp;gt;&lt;span&gt;
        {
            s.FileProvider &lt;/span&gt;=&lt;span&gt; provider;
            s.Path &lt;/span&gt;=&lt;span&gt; path;
            s.Optional &lt;/span&gt;=&lt;span&gt; optional;
            s.ReloadOnChange &lt;/span&gt;=&lt;span&gt; reloadOnChange;
            s.ResolveFileProvider();
        });
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationBuilder AddJsonFile(&lt;span&gt;this&lt;/span&gt; IConfigurationBuilder builder, Action&amp;lt;JsonConfigurationSource&amp;gt;&lt;span&gt; configureSource)
        &lt;/span&gt;=&amp;gt;&lt;span&gt; builder.Add(configureSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;AddJsonFile方法会创建一个JsonConfigurationSource并通过ConfigurationBuilder的Add(IConfigurationSource source)方法将这个JsonConfigurationSource添加到ConfigurationBuilder的IList&amp;lt;IConfigurationSource&amp;gt; Sources集和中去。&lt;/p&gt;
&lt;p&gt;同理，针对环境变量，存在对应的EnvironmentVariablesExtensions，会创建一个对应的EnvironmentVariablesConfigurationSource添加到ConfigurationBuilder的IList&amp;lt;IConfigurationSource&amp;gt; Sources集和中去。这样的还有CommandLineConfigurationExtensions和CommandLineConfigurationSource等，最终结果就是会根据数据源的加载顺序，生成多个XXXConfigurationSource对象（它们都直接或间接实现了IConfigurationSource接口）添加到ConfigurationBuilder的IList&amp;lt;IConfigurationSource&amp;gt; Sources集和中。&lt;/p&gt;
&lt;p&gt;在Program文件的WebHost.CreateDefaultBuilder(args)方法中的ConfigureAppConfiguration方法被调用后，如果在CreateDefaultBuilder方法之后再次调用了ConfigureAppConfiguration方法并添加了数据源（如同上一节的例子），同样会生成相应的XXXConfigurationSource对象添加到ConfigurationBuilder的IList&amp;lt;IConfigurationSource&amp;gt; Sources集和中。&lt;/p&gt;
&lt;p&gt;注意：这里不是每一种数据源生成一个XXXConfigurationSource，而是按照每次添加生成一个XXXConfigurationSource，并且遵循添加的先后顺序。例如添加多个JSON文件，会生成多个JsonConfigurationSource。&lt;/p&gt;
&lt;p&gt;这些ConfigurationSource之间的关系如下图1：&lt;/p&gt;
&lt;p class=&quot;affc&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190922215415518-186735720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1&lt;/p&gt;
&lt;p&gt;到这里各种数据源的收集工作完成，都添加到了ConfigurationBuilder的IList&amp;lt;IConfigurationSource&amp;gt; Sources属性中。&lt;/p&gt;
&lt;p&gt;回到BuildCommonServices方法中，通过foreach循环逐一执行了configureAppConfiguration方法获取到IList&amp;lt;IConfigurationSource&amp;gt;之后，下一句是varconfiguration = builder.Build()，这是调用ConfigurationBuilder的Build()方法创建了一个IConfigurationRoot对象。对应代码如下：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationBuilder : IConfigurationBuilder
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;IConfigurationSource&amp;gt; Sources { &lt;span&gt;get&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IConfigurationSource&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IConfigurationRoot Build()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; providers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; source &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Sources)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider = source.Build(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                providers.Add(provider);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationRoot(providers);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;这个方法主要体现了两个过程：首先，遍历IList&amp;lt;IConfigurationSource&amp;gt; Sources集合，主要调用其中的各个IConfigurationSource的Build方法创建对应的IConfigurationProvider，最终生成一个List&amp;lt;IConfigurationProvider&amp;gt;；第二，通过集合List&amp;lt;IConfigurationProvider&amp;gt;创建了ConfigurationRoot。ConfigurationRoot实现了IConfigurationRoot接口。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先看第一个过程，依然以JsonConfigurationSource为例，代码如下：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonConfigurationSource : FileConfigurationSource
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            EnsureDefaults(builder);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonConfigurationProvider(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;JsonConfigurationSource会通过Build方法创建一个名为JsonConfigurationProvider的对象。通过JsonConfigurationProvider的名字可知，它是针对JSON类型的，也就是意味着不同类型的IConfigurationSource创建的IConfigurationProvider类型也是不一样的，对应图18‑4中的IConfigurationSource，生成的IConfigurationProvider关系如下图2。&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;affc&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190922215502406-289703191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2&lt;/p&gt;
&lt;p&gt;系统中添加的多个数据源被转换成了一个个对应的ConfigurationProvider，这些ConfigurationProvider组成了一个ConfigurationProvider的集合。&lt;/p&gt;
&lt;p&gt;再看一下第二个过程，ConfigurationBuilder的Build方法的最后一句是return new ConfigurationRoot(providers)，就是通过第一个过程创建的ConfigurationProvider的集合创建ConfigurationRoot。ConfigurationRoot代码如下：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationRoot : IConfigurationRoot
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; _providers;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConfigurationReloadToken _changeToken = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationRoot(IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; providers)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (providers == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(providers));
            }

            _providers &lt;/span&gt;=&lt;span&gt; providers;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; providers)
            {
                p.Load();
                ChangeToken.OnChange(() &lt;/span&gt;=&amp;gt; p.GetReloadToken(), () =&amp;gt;&lt;span&gt; RaiseChanged());
            }
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;可以看出，ConfigurationRoot的构造方法主要的作用就是将ConfigurationProvider的集合作为自己的一个属性的值，并遍历这个集合，逐一调用这些ConfigurationProvider的Load方法，并为ChangeToken的OnChange方法绑定数据源的改变通知和处理方法。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;从图18‑5可知，所有类型数据源最终创建的&lt;em&gt;XXX&lt;/em&gt;ConfigurationProvider都继承自ConfigurationProvider，所以它们都有一个Load方法和一个IDictionary&amp;lt;string, string&amp;gt; 类型的Data 属性，它们是整个配置系统的重要核心。Load方法用于数据源的数据的读取与处理，而Data用于保存最终结果。通过逐一调用Provider的Load方法完成了整个配置系统的数据加载。&lt;/p&gt;
&lt;p&gt;以JsonConfigurationProvider为例，它继承自FileConfigurationProvider，所以先看一下FileConfigurationProvider的代码：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileConfigurationProvider : ConfigurationProvider
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Load(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; reload)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = Source.FileProvider?&lt;span&gt;.GetFileInfo(Source.Path);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;file.Exists)
        {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reload)
            {
                Data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);
            }
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stream =&lt;span&gt; file.CreateReadStream())
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Load(stream);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
                {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
&lt;span&gt;                }
            }
        }
        OnReload();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load()
    {
        Load(reload: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load(Stream stream);
}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本段代码的主要功能就是读取文件生成stream，然后调用Load(stream)方法解析文件内容。从图18‑5可知，JsonConfigurationProvider、IniConfigurationProvider、XmlConfigurationProvider都是继承自FileConfigurationProvider，而对应JSON、INI、XML三种数据源来说，只是文件内容的格式不同，所以将通用的读取文件内容的功能交给了FileConfigurationProvider来完成，而这三个子类的ConfigurationProvider只需要将FileConfigurationProvider读取到的文件内容的解析即可。所以这个参数为stream 的Load方法写在JsonConfigurationProvider、IniConfigurationProvider、XmlConfigurationProvider这样的子类中，用于专门处理自身对应的格式的文件。&lt;/p&gt;
&lt;p&gt;JsonConfigurationProvider代码如下：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonConfigurationProvider : FileConfigurationProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonConfigurationProvider(JsonConfigurationSource source) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(source) { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load(Stream stream)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            Data &lt;/span&gt;=&lt;span&gt; JsonConfigurationFileParser.Parse(stream);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JsonReaderException e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; errorLine = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stream.CanSeek)
            {
                stream.Seek(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SeekOrigin.Begin);

                IEnumerable&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; fileContent;
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; streamReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream))
                {
                    fileContent &lt;/span&gt;=&lt;span&gt; ReadLines(streamReader);
                    errorLine &lt;/span&gt;=&lt;span&gt; RetrieveErrorContext(e, fileContent);
                }
            }

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormatException(Resources.FormatError_JSONParseError(e.LineNumber, errorLine), e);
        }
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;JsonConfigurationProvider中关于JSON文件的解析由JsonConfigurationFileParser.Parse(stream)完成的。最终的解析结果被赋值给了父类ConfigurationProvider的名为Data的属性中。&lt;/p&gt;
&lt;p&gt;所以最终每个数据源的内容都分别被解析成了IDictionary&amp;lt;string, string&amp;gt;集合，这个集合作为对应的ConfigurationProvider的一个属性。而众多ConfigurationProvider组成的集合又作为ConfigurationRoot的属性。最终它们的关系图如下图3：&lt;/p&gt;
&lt;p class=&quot;affc&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190922215532733-2002489865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3&lt;/p&gt;
&lt;p&gt;到此，配置的加载与数据的转换工作完成。下图4展示了这个过程。&lt;/p&gt;
&lt;p class=&quot;affc&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;affc&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190922215927882-372366852.png&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;789&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4&lt;/p&gt;

&lt;h4&gt;三、配置的读取&lt;/h4&gt;
&lt;p&gt;第一节的例子中，通过_configuration[&quot;Theme:Color&quot;]的方式获取到了对应的配置值，这是如何实现的呢？现在我们已经了解了数据源的加载过程，而这个_configuration就是数据源被加载后的最终产出物，即ConfigurationRoot，见图18‑7。它的代码如下：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationRoot : IConfigurationRoot
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; _providers;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConfigurationReloadToken _changeToken = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了上文已讲过的构造方法&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationProvider&amp;gt; Providers =&amp;gt;&lt;span&gt; _providers;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key]
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers.Reverse())
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (provider.TryGet(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; value))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_providers.Any())
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException(Resources.Error_NoSources);
            }

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
            {
                provider.Set(key, value);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildren() =&amp;gt; GetChildrenImplementation(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildrenImplementation(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _providers
            .Aggregate(Enumerable.Empty&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(),
                (seed, source) &lt;/span&gt;=&amp;gt;&lt;span&gt; source.GetChildKeys(seed, path))
            .Distinct()
            .Select(key &lt;/span&gt;=&amp;gt; GetSection(path == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; key : ConfigurationPath.Combine(path, key)));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetReloadToken() =&amp;gt;&lt;span&gt; _changeToken;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationSection GetSection(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key) 
        &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt; ConfigurationSection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, key);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reload()
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
        {
            provider.Load();
        }
        RaiseChanged();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RaiseChanged()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; previousToken = Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt; _changeToken, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken());
        previousToken.OnReload();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;对应_configuration[&quot;Theme:Color&quot;]的读取方式的是索引器“string this[string key]”，通过查看其get方法可知，它是通过倒序遍历所有ConfigurationProvider，在ConfigurationProvider的Data中尝试查找是否存在Key为&quot;Theme:Color&quot;的值。这也说明了第一节的例子中，在Theme.json中设置了Theme对象的值后，原本在appsettings.json设置的Theme的值被覆盖的原因。从图18‑6中可以看到，该值其实也是被读取并加载的，只是由于ConfigurationRoot的“倒序”遍历ConfigurationProvider的方式导致后注册的Theme.json中的Theme值先被查找到了。同时验证了所有配置值均认为是string类型的约定。&lt;/p&gt;
&lt;p&gt;ConfigurationRoot还有一个GetSection方法，会返回一个IConfigurationSection对象，对应的是ConfigurationSection类。它的代码如下：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationSection : IConfigurationSection
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ConfigurationRoot _root;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _path;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _key;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationSection(ConfigurationRoot root, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(root));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(path));
            }

            _root &lt;/span&gt;=&lt;span&gt; root;
            _path &lt;/span&gt;=&lt;span&gt; path;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Path =&amp;gt;&lt;span&gt; _path;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Key
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Key is calculated lazily as last portion of Path&lt;/span&gt;
                    _key =&lt;span&gt; ConfigurationPath.GetSectionKey(_path);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _key;
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Value
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _root[Path];
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _root[Path] &lt;/span&gt;=&lt;span&gt; value;
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key]
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _root[ConfigurationPath.Combine(Path, key)];
            }

            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _root[ConfigurationPath.Combine(Path, key)] &lt;/span&gt;=&lt;span&gt; value;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationSection GetSection(&lt;span&gt;string&lt;/span&gt; key) =&amp;gt;&lt;span&gt; _root.GetSection(ConfigurationPath.Combine(Path, key));

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildren() =&amp;gt;&lt;span&gt; _root.GetChildrenImplementation(Path);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetReloadToken() =&amp;gt;&lt;span&gt; _root.GetReloadToken();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;它的代码很简单，可以说没有什么实质的代码，它只是保存了当前路径和对ConfigurationRoot的引用。它的方法大多是通过调用ConfigurationRoot的对应方法完成的，通过它自身的路径计算在ConfigurationRoot中对应的Key，从而获取对应的值。而ConfigurationRoot对配置值的读取功能以及数据源的重新加载功能（Reload方法）也是通过ConfigurationProvider实现的，实际数据也是保存在ConfigurationProvider的Data值中。所以ConfigurationRoot和ConfigurationSection就像一个外壳，自身并不负责数据源的加载（或重载）与存储，只负责构建了一个配置值的读取功能。&lt;/p&gt;
&lt;p&gt;而由于配置值的读取是按照数据源加载顺序的倒序进行的，所以对于Key值相同的多个配置，只会读取后加载的数据源中的配置，那么ConfigurationRoot和ConfigurationSection就模拟出了一个树状结构，如下图5：&lt;/p&gt;
&lt;p class=&quot;affc&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201909/548134-20190922220033897-1793601684.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;572&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5&lt;/p&gt;
&lt;p&gt;本图是以如下配置为例：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0921DC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;ConfigurationRoot利用它制定的读取规则，将这样的配置模拟成了如图18‑8这样的树，它有这样的特性：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A．所有节点都认为是一个ConfigurationSection，不同的是对于“Theme”这样的节点的值为空（图中用空心椭圆表示），而“Name”和“Color”这样的节点有对应的值（图中用实心椭圆表示）。&lt;/p&gt;
&lt;p&gt;B．由于对Key值相同的多个配置只会读取后加载的数据源中的配置，所以不会出现相同路径的同名节点。例如第一节例子中多种数据源配置了“Theme”值，在这里只会体现最后加载的配置项。&lt;/p&gt;

&lt;p&gt;由于ConfigurationRoot未实际保存数据源中加载的配置值，所以配置的更新实际还是由对应的ConfigurationProvider来完成。以JsonConfigurationProvider、IniConfigurationProvider、XmlConfigurationProvider为例，它们的数据源都是具体文件，所以对文件内容的改变的监控也是放在FileConfigurationProvider中。FileConfigurationProvider的构造方法中添加了对设置了对应文件的监控，当然这里会首先判断数据源的ReloadOnChange选项是否被设置为True了。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileConfigurationProvider : ConfigurationProvider
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FileConfigurationProvider(FileConfigurationSource source)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(source));
            }
            Source &lt;/span&gt;=&lt;span&gt; source;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Source.ReloadOnChange &amp;amp;&amp;amp; Source.FileProvider != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                changeToken.OnChange(
                    () &lt;/span&gt;=&amp;gt;&lt;span&gt; Source.FileProvider.Watch(Source.Path),
                    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                        Thread.Sleep(Source.ReloadDelay);
                        Load(reload: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    });
            }
        }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略其他代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;所以当数据源发生改变并且ReloadOnChange被设置为True的时候，对应的ConfigurationProvider就会重新加载数据。但ConfigurationProvider更新数据源也不会改变它在ConfigurationRoot的IEnumerable&amp;lt;IConfigurationProvider&amp;gt;列表中的顺序。如果在列表中存在A和B两个ConfigurationProvider并且含有相同的配置项，B排在A后面，那么对于这些相同的配置项来说，A中的是被B中的“覆盖”的。即使A的数据更新了，它依然处于“被覆盖”的位置，应用中读取相应配置项的依然是读取B中的配置项。&lt;/p&gt;
&lt;h4&gt;五、配置的绑定&lt;/h4&gt;
&lt;p&gt;在第一节的例子中讲过了两种获取配置值的方式，类似这样_configuration[&quot;Theme:Name&quot;]和_configuration.GetValue&amp;lt;string&amp;gt;(&quot;Theme:Color&quot;,&quot;#000000&quot;)可以获取到Theme的Name和Color的值，那么就会有下面这样的疑问：&lt;/p&gt;
&lt;p&gt;appsettings.json中存在如下这样的配置&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0921DC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;新建一个Theme类如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Theme
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Color { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;是否可以将配置值获取并赋值到这样的一个Theme的实例中呢？&lt;/p&gt;
&lt;p&gt;当然可以，系统提供了这样的功能，可以采用如下代码实现：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     Theme theme = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Theme();
     _configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Bind(theme);
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;affbCxSpFirst&quot;&gt;绑定功能由ConfigurationBinder实现，逻辑不复杂，读者如果感兴趣的可自行查看其代码。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Mon, 23 Sep 2019 00:04:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>上一章介绍了配置的多种数据源被注册、加载和获取的过程，本节看一下这个过程系统是如何实现的。(ASP.NET Core 系列目录) 一、数据源的注册 在上一节介绍的数据源设置中，appsettings.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FlyLolo/p/ASPNETCore_23.html</dc:identifier>
</item>
<item>
<title>从Hybrid到React-Native: JS在移动端的南征北战史 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11538146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11538146.html</guid>
<description>&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dbj93-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;dbj93-0-0&quot;&gt;注：因为不了解Dart，所以本文不对flutter相关内容进行阐述, 实在抱歉&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dbj93-0-0&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;dbj93-0-0&quot;&gt;其实写这篇文章的时候，我就知道，肯定有人问我：为什么不写flutter？抱歉了，flutter的大名我当然知道，可我只是一个写JS的，同时了解一些Java的知识，而flutter采用的编程语言，我暂时没有碰过，所以自然不敢妄加猜度，还请谅解&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dbj93-0-0&quot;&gt;&lt;span data-offset-key=&quot;dbj93-0-0&quot;&gt;Hybrid&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;8j5ao-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8j5ao-0-0&quot;&gt;Hybird是一种混合开发应用，可以实现JS和Java代码的互通，单纯使用ios/android原生实现，开发进度和成本受不了，而单纯使用h5/js开发，页面体验更加受不了。Hybird的目的是实现H5和Naive两者之间的权衡&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ckft1-0-0&quot;&gt;&lt;span data-offset-key=&quot;ckft1-0-0&quot;&gt;Hybird的实现方式&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;8usgb-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8usgb-0-0&quot;&gt;Hybrid是基于原生webview控件实现的，&lt;span data-offset-key=&quot;8usgb-0-1&quot;&gt;它主要要解决的问题有两个：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;fsqrm-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;fsqrm-0-0&quot;&gt;这个问题进一步扩展，又细分为以下4个问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;ai7a3-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;ai7a3-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ai7a3-0-0&quot;&gt;&lt;strong&gt;Q1&lt;/strong&gt;&lt;span data-offset-key=&quot;ai7a3-0-1&quot;&gt;: JS怎么调用Android代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;2nq8o-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2nq8o-0-0&quot;&gt;&lt;strong&gt;Q2&lt;/strong&gt;&lt;span data-offset-key=&quot;2nq8o-0-1&quot;&gt;: Android代码怎么调用JS&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;eciae-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eciae-0-0&quot;&gt;&lt;strong&gt;Q3&lt;/strong&gt;&lt;span data-offset-key=&quot;eciae-0-1&quot;&gt;: JS怎么调用IOS代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;75sbt-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;75sbt-0-0&quot;&gt;&lt;strong&gt;Q4&lt;/strong&gt;&lt;span data-offset-key=&quot;75sbt-0-1&quot;&gt;: IOS代码怎么调用JS&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bjh1i-0-0&quot;&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bjh1i-0-0&quot;&gt;Q1&lt;span data-offset-key=&quot;bjh1i-0-1&quot;&gt;: JS怎么调用Android代码&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;b8qke-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b8qke-0-0&quot;&gt;我们先讲下JS是怎么调Android代码的&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;ep7sj-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ep7sj-0-0&quot;&gt;主要有3种&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;8u6sh-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;8u6sh-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8u6sh-0-0&quot;&gt;JSInterface&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;988bb-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;988bb-0-0&quot;&gt;JSBridge&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;1rv2s-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1rv2s-0-0&quot;&gt;UrlRouter&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;6f2i9-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;6f2i9-0-0&quot;&gt;1）JSInterface&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7b30c-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7b30c-0-0&quot;&gt;从我们前端的角度看啊，是这样子滴～ ：在Android中啊，有个叫做WebView的控件，这个控件的作用是可以在里面放一个网页然后运行它！我们前端就暂时把它理解成一个安卓APP里嵌入的微型浏览器吧，哈哈。然后呢，这个WebView控件对象还可以调用一个方法。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;6mv4-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6mv4-0-0&quot;&gt;一个叫webView.addJavascriptInterface(接口对象，接口名)的方法，调用后，webView控件里面的HTML页面里的JS代码，就可以调用刚才addJavascriptInterface方法里的接口对象的原生方法了！ 于是就这样，我们可以从JS间接调用原生Android代码，从此桥梁建立&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;5g3vm-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5g3vm-0-0&quot;&gt;例如，比如说我们下面定一个JSInterface的类，里面的showToast方法可以弹出一个原生的Toast&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;4fljs-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;4fljs-0-0&quot;&gt;Android的原生代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4fljs-0-0&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
webView.addJavascriptInterface(&lt;span&gt;new&lt;/span&gt; JsInterface(), &quot;control”);
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; …&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsInterface {
        @JavascriptInterface
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showToast(String toast) {
            Toast.makeText(MainActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, toast, Toast.LENGTH_SHORT).show();
            log(&lt;/span&gt;&quot;show toast success&quot;&lt;span&gt;);
        }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;3a714-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3a714-0-0&quot;&gt;JS代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;3a714-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; WebView中的JS代码，注意control就是上面addJavascriptInterface定义的命名空间&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showToast(toast) {
  javascript:control.showToast(toast);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;



&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;e2fap-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;e2fap-0-0&quot;&gt;2）JSbridge&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;1b6fo-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1b6fo-0-0&quot;&gt;从我们前端的角度看啊，其实是这样子滴～：就是在Android中啊，有这么一个WebChromeClient的组件，它就是上面讲到的WebView控件的一个子类。没错，它也可以在里面放一个网页去运行它，而且它牛啤的地方在于：你这个内部网页里的JS干的三件事可以被外层WebChromeClient给监听到：分别是前端的alert方法，confirm方法和prompt方法。只要你动了这三个方法，它们传递的数据就会被外部的WebChromeClient拦截和获取，这就为JS调Android的代码提供了一种方便的渠道。哎呀，三个方法这么多选哪个呢？ 一般情况下，我们会选prompt方法，因为alert方法JS相对用的比较频繁，存在起冲突的可能&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;a4u0a-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;a4u0a-0-0&quot;&gt;3）UrlRouter&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7anpv-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7anpv-0-0&quot;&gt;这个东东还是和上面是一样的，Android的WebChromeClient控件这个类，它有个shouldOverrideUrlLoading这个方法，这个方法可以把控件内部网页的JS的Url请求给拦截了，当然了，你写在Url中的数据也同时被一并获取了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;3fap1-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3fap1-0-0&quot;&gt;总结：说白了JSInterface，JSBridge和UrlRouter主要的作用就是提供JS调原生代码的方式，搭一座桥梁&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;eu7md-0-0&quot;&gt;&lt;span data-offset-key=&quot;eu7md-0-0&quot;&gt;Q2: Android怎么调JS代码？&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;8di3a-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;8di3a-0-0&quot;&gt;1）web view.loadUrl&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;dbeed-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dbeed-0-0&quot;&gt;有了上面的经验你肯定知道，这事还是webview这位老哥来做的，它可以通过调用webview.loadUrl方法加载一个HTML页面，这样HTML中的JS脚本不就被调用了吗？&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9h84h-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
webView.loadUrl(“...&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my.html”);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;sddo-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;sddo-0-0&quot;&gt;2）webView.evaluateJavascript&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;a98ou-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a98ou-0-0&quot;&gt;上面的loadUrl有一个问题，它会导致页面刷新，而且通过加载文件的方式执行JS代码总不是我们认为最优雅的方式，我们可能期望的是执行一段指定的代码，而非一个文件，webView.evaluateJavascript就是做这件事情的，以下的代码可以执行一段JS代码&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fvo6e-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
webView.evaluateJavascript（“JS代码”，Callback对象）
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;bocur-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bocur-0-0&quot;&gt;哦，对了，不好意思，上面讲的是Android的，下面讲下IOS怎么做&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6736m-0-0&quot;&gt;&lt;span data-offset-key=&quot;6736m-0-0&quot;&gt; &lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;c2d3u-0-0&quot;&gt;&lt;span data-offset-key=&quot;c2d3u-0-0&quot;&gt;Q3&lt;span data-offset-key=&quot;c2d3u-0-1&quot;&gt;: IOS代码怎么调用JS&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;40r9j-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;40r9j-0-0&quot;&gt;1.可通过webview.stringByEvaluatingJavaScriptFromString方法调用JS方法，但前提是该JS方法在顶层Window对象上&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;erk3c-0-0&quot;&gt;webview.stringByEvaluatingJavaScriptFromString(&quot;方法名(参数)”)&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6p8gh-0-0&quot;&gt;&lt;span data-offset-key=&quot;6p8gh-0-0&quot;&gt;Q4&lt;span data-offset-key=&quot;6p8gh-0-1&quot;&gt;: JS怎么调用IOS代码&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;bbbro-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bbbro-0-0&quot;&gt;可通过 shouldStartLoadWithRequest方法进行拦截JS请求，从而感知JS的调用发起，并进行相应处理，以达到JS调用ios的效果&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7bq7r-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7bq7r-0-0&quot;&gt;Hybrid也曾在移动端连接H5的童话世界中风靡一时，但由于对webview以及H5的过度依赖，导致它的体验性问题一直让人困扰，所以自从React-Native横空出世后，后者便蚕食了前者的半壁江山。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dpobd-0-0&quot;&gt;&lt;span data-offset-key=&quot;dpobd-0-0&quot;&gt;React-Native&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e2m02-0-0&quot;&gt;&lt;span data-offset-key=&quot;e2m02-0-0&quot;&gt;RN的作用&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;f0q7j-0-0&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;f0q7j-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f0q7j-0-0&quot;&gt;跨平台：可以为IOS/Android，甚至Windows Phone开发原生应用&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;342ke-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;342ke-0-0&quot;&gt;相对良好的UI体验，平衡开发成本和用户体验后相对合理的选择&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;f1io0-0-0&quot;&gt;&lt;span data-offset-key=&quot;f1io0-0-0&quot;&gt;RN的本质&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;327fr-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;327fr-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;327fr-0-0&quot;&gt;不是WebView,和Cordova等Hybrid方案划清界限&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7vrtl-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7vrtl-0-0&quot;&gt;不将JavaScript预编译为Native代码，和Xamarin等方案划清界限。Xammarin的方案是AOT的，运行前就编译为原生代码，RN则采用JIT+解释器的方案（IOS另当别论）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;fvsq-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fvsq-0-0&quot;&gt;RN是虚拟机类的方案，依靠运行时系统JavaScriptCore运行&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6kjc4-0-0&quot;&gt;&lt;span data-offset-key=&quot;6kjc4-0-0&quot;&gt;RN的4个线程&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;ef191-0-0&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;ef191-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ef191-0-0&quot;&gt;UI线程：也成为主线程，负责本机的Android/iOS的UI呈现，在android中它负责android测量/布局/绘制&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;97ah2-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;97ah2-0-0&quot;&gt;JS线程：执行JS/React代码，进行API调用，处理触摸事件等，对视图的更新被进行批处理，并在事件循环结束时发送给UI线程&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;fjmvj-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fjmvj-0-0&quot;&gt;Shadow线程：处理虚拟DOM布局变更的线程&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;9dnip-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9dnip-0-0&quot;&gt;本机模块线程： 如android/ios系统自带的原生API&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fr9g-0-0&quot;&gt;&lt;span data-offset-key=&quot;fr9g-0-0&quot;&gt;RN的3部分&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;7t7nr-0-0&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7t7nr-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7t7nr-0-0&quot;&gt;Native端（IOS/android）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;ffrfl-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ffrfl-0-0&quot;&gt;JavaScript端&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;53avt-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;53avt-0-0&quot;&gt;Bridge：上面介绍的多个线程之间相互通信，以及JS和Native端通信的方式的统称&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6hgjn-0-0&quot;&gt;&lt;span data-offset-key=&quot;6hgjn-0-0&quot;&gt;线程协调过程示例&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;b2o33-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b2o33-0-0&quot;&gt;以下面一段RN代码的执行为例，它在JS线程中执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;b2o33-0-0&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;View &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;={{ &lt;/span&gt;&lt;span&gt;flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; }}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;View &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;={{width: &lt;/span&gt;&lt;span&gt;100, height: 100, backgroundColor: &quot;red&quot;}}&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;View&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;View&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1a9rh-0-0&quot;&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;prism-token token punctuation&quot;&gt;注意原生端有自己的布局实现，所以上面的flex属性和CSS是没有任何关系的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-offset-key=&quot;bkof9-0-0&quot;&gt;为了实现布局，同时又不阻塞JS线程，布局计算将转移到Shadow线程中进行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-offset-key=&quot;e1bom-0-0&quot;&gt;Shadow线程进行计算，并最终将计算结果得到的布局参数传递给主线程（UI线程），实现UI的构建&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9hphd-0-0&quot;&gt;&lt;span data-offset-key=&quot;9hphd-0-0&quot;&gt;RN中的Bridge做了什么？ &amp;amp;&amp;amp; RN线程如何交互？&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;1325a-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;1325a-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1325a-0-0&quot;&gt;异步：线程之间，例如JS线程和UI线程，以异步的方式进行通信，这样它们就不会互相阻塞了&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;rmbt-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;rmbt-0-0&quot;&gt;批处理： 以优化的方式， 把消息从一个线程传递到另外一个线程&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;bbeip-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bbeip-0-0&quot;&gt;序列化： 两个线程不会操作或者共享同一块数据，它们之间会通过序列化和反序列化的方式交换消息&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e9fcs-0-0&quot;&gt;&lt;span data-offset-key=&quot;e9fcs-0-0&quot;&gt;RN线程异步带来的某些问题 &amp;amp;&amp;amp; 未来的解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;k7he-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;k7he-0-0&quot;&gt;RN中的JS线程和UI线程之间是没有同步的方式的，这可能造成一些问题，但RN未来的Fabric也许能提供这一功能&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4itgf-0-0&quot;&gt;&lt;span data-offset-key=&quot;4itgf-0-0&quot;&gt;RN的Web化:react-native-web&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;hie9-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;hie9-0-0&quot;&gt;react-native-web 组件的内部，会把 React Native 的 API 映射成了浏览器支持的 API。将RN的代码转化成浏览器能支持的代码&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dn5jf-0-0&quot;&gt;&lt;span data-offset-key=&quot;dn5jf-0-0&quot;&gt;RN-web和普通的React的区别？&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;bo7oi-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bo7oi-0-0&quot;&gt;RN-web尽量做到不侵入RN代码，不影响RN代码的逻辑，争取能够在基本不动RN项目代码的情况下，将其H5化，RN-web项目的基本逻辑还是RN，不是React&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;51bpo-0-0&quot;&gt;&lt;span data-offset-key=&quot;51bpo-0-0&quot;&gt;RN-WEB的作用&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;rve0&quot; data-offset-key=&quot;7h5rf-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7h5rf-0-0&quot;&gt;实现IOS/Android/Web的三端构建&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;884dd-0-0&quot;&gt;&lt;span data-offset-key=&quot;884dd-0-0&quot;&gt;参考文章&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Sun, 22 Sep 2019 23:43:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>介绍Hybrid 到 React-Native的变化过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11538146.html</dc:identifier>
</item>
<item>
<title>HTTP协议web开发知识点 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/11570281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/11570281.html</guid>
<description>&lt;h2 id=&quot;http协议简介&quot;&gt;HTTP协议简介&lt;/h2&gt;
&lt;p&gt;超文本传输协议（英文：&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。&lt;/p&gt;
&lt;p&gt;HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。&lt;/p&gt;
&lt;p&gt;2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。&lt;/p&gt;
&lt;h2 id=&quot;http协议概述&quot;&gt;HTTP协议概述&lt;/h2&gt;
&lt;p&gt;HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。&lt;/p&gt;
&lt;p&gt;尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。&lt;/p&gt;
&lt;p&gt;通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。&lt;/p&gt;
&lt;h2 id=&quot;http工作原理&quot;&gt;HTTP工作原理&lt;/h2&gt;
&lt;p&gt;HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。&lt;/p&gt;
&lt;p&gt;以下是 HTTP 请求/响应的步骤：&lt;/p&gt;
&lt;p&gt;\1. 客户端连接到Web服务器&lt;br/&gt;一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，&lt;a href=&quot;http://www.luffycity.com&quot; class=&quot;uri&quot;&gt;http://www.luffycity.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;\2. 发送HTTP请求&lt;br/&gt;通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。&lt;/p&gt;
&lt;p&gt;\3. 服务器接受请求并返回HTTP响应&lt;br/&gt;Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。&lt;/p&gt;
&lt;p&gt;\4. 释放连接TCP连接&lt;br/&gt;若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;&lt;/p&gt;
&lt;p&gt;\5. 客户端浏览器解析HTML内容&lt;br/&gt;客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。&lt;/p&gt;
&lt;p&gt;例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;&lt;/li&gt;
&lt;li&gt;解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;&lt;/li&gt;
&lt;li&gt;浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;&lt;/li&gt;
&lt;li&gt;服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;&lt;/li&gt;
&lt;li&gt;释放 TCP连接;&lt;/li&gt;
&lt;li&gt;浏览器将该 html 文本并显示内容; 　&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418160227278-698810818.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;http协议是基于TCP/IP协议之上的应用层协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;基于 请求-响应 的模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418160433297-1726664935.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;无状态保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418160546133-1479186889.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;无连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。&lt;/p&gt;
&lt;h2 id=&quot;http请求方法&quot;&gt;HTTP请求方法&lt;/h2&gt;
&lt;p&gt;HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：&lt;/p&gt;
&lt;h3 id=&quot;get&quot;&gt;GET&lt;/h3&gt;
&lt;p&gt;向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。&lt;/p&gt;
&lt;h3 id=&quot;head&quot;&gt;HEAD&lt;/h3&gt;
&lt;p&gt;与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。&lt;/p&gt;
&lt;h3 id=&quot;post&quot;&gt;POST&lt;/h3&gt;
&lt;p&gt;向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。&lt;/p&gt;
&lt;h3 id=&quot;put&quot;&gt;PUT&lt;/h3&gt;
&lt;p&gt;向指定资源位置上传其最新内容。&lt;/p&gt;
&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;
&lt;p&gt;请求服务器删除Request-URI所标识的资源。&lt;/p&gt;
&lt;h3 id=&quot;trace&quot;&gt;TRACE&lt;/h3&gt;
&lt;p&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/p&gt;
&lt;h3 id=&quot;options&quot;&gt;OPTIONS&lt;/h3&gt;
&lt;p&gt;这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。&lt;/p&gt;
&lt;h3 id=&quot;connect&quot;&gt;CONNECT&lt;/h3&gt;
&lt;p&gt;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。&lt;/li&gt;
&lt;li&gt;HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源&lt;em&gt;。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;请求方式-get与post请求通过form表单我们自己写写看&quot;&gt;请求方式: get与post请求（通过form表单我们自己写写看）&lt;/h4&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;amp;相连，如EditBook?name=test1&amp;amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了，这句废话昂。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;http状态码&quot;&gt;HTTP状态码&lt;/h2&gt;
&lt;p&gt;所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。&lt;/p&gt;
&lt;p&gt;状态代码的第一个数字代表当前响应的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1xx消息——请求已被服务器接收，继续处理&lt;/li&gt;
&lt;li&gt;2xx成功——请求已成功被服务器接收、理解、并接受&lt;/li&gt;
&lt;li&gt;3xx重定向——需要后续操作才能完成这一请求&lt;/li&gt;
&lt;li&gt;4xx请求错误——请求含有词法错误或者无法被执行&lt;/li&gt;
&lt;li&gt;5xx服务器错误——服务器在处理某个正确请求时发生错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然 RFC 2616 中已经推荐了描述状态的短语，例如&quot;200 OK&quot;，&quot;404 Not Found&quot;，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418161321986-304902913.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;url&quot;&gt;URL&lt;/h2&gt;
&lt;p&gt;超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传送协议。&lt;/li&gt;
&lt;li&gt;层级URL标记符号(为[//],固定不变)&lt;/li&gt;
&lt;li&gt;访问资源需要的凭证信息（可省略）&lt;/li&gt;
&lt;li&gt;服务器。（通常为域名，有时为IP地址）&lt;/li&gt;
&lt;li&gt;端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）&lt;/li&gt;
&lt;li&gt;路径。（以“/”字符区别路径中的每一个目录名称）&lt;/li&gt;
&lt;li&gt;查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）&lt;/li&gt;
&lt;li&gt;片段。以“#”字符为起点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以http://www.luffycity.com:80/news/index.html?id=250&amp;amp;page=1 为例, 其中：&lt;/p&gt;
&lt;p&gt;http，是协议；&lt;br/&gt;www.luffycity.com，是服务器；&lt;br/&gt;80，是服务器上的默认网络端口号，默认不显示；&lt;br/&gt;/news/index.html，是路径（URI：直接定位到对应的资源）；&lt;br/&gt;?id=250&amp;amp;page=1，是查询。&lt;br/&gt;大多数网页浏览器不要求用户输入网页中“&lt;a href=&quot;http://%E2%80%9D%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E6%98%AF%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6%E3%80%82%E5%90%8C%E6%A0%B7&quot; class=&quot;uri&quot;&gt;http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样&lt;/a&gt;，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（www.luffycity.com:80/news/index.html?id=250&amp;amp;page=1）就可以了。&lt;/p&gt;
&lt;p&gt;由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。&lt;/p&gt;
&lt;h2 id=&quot;http请求格式请求协议&quot;&gt;HTTP请求格式(请求协议)&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001733298-201433635.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　URL包含：/index/index2?a=1&amp;amp;b=2；路径和参数都在这里。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418160914403-902015370.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　请求头里面的内容举个例子：这个length表示请求体里面的数据长度，其他的请求头里面的这些键值对，陆续我们会讲的，大概知道一下就可以了，其中有一个user-agent，算是需要你记住的吧，就是告诉你的服务端，我是用什么给你发送的请求。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217180939495-1485103656.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　以京东为例，看一下user-agent&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217181850193-212820996.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217182211177-715034357.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　看一个爬虫的例子，爬京东的时候没问题，但是爬抽屉的时候必须带着user-agent，因为抽屉对user-agent做了判断，来判断你是不是一个正常的请求，算是反扒机制的一种。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217200715895-666653052.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　打开我们保存的demo.html文件，然后通过浏览器打开看看就能看到页面效果。&lt;/p&gt;
&lt;p&gt;　　　　　　写上面这些内容的意思是让你知道有这么个请求头的存在，有些是有意义的，请求头我们还可以自己定义，就在requests模块里面那个headers={}，这个字典里面加就行。&lt;/p&gt;


&lt;h2 id=&quot;http响应格式响应协议&quot;&gt;HTTP响应格式（响应协议）&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001744323-654009411.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418161014087-738990087.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Sep 2019 23:43:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>'HTTP协议那些事儿（Web开发补充知识点）' HTTP协议 HTTP协议简介 超文本传输协议（英文： H yper T ext T ransfer P rotocol，缩写：HTTP）是一种用于分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/11570281.html</dc:identifier>
</item>
<item>
<title>【Unity与Android】01-Unity与Android交互通信的简易实现 - 子非鱼`</title>
<link>http://www.cnblogs.com/imteach/p/11567481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imteach/p/11567481.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;使用Unity也有不短的时间了，安卓包也打过不少，但是对Unity与Android的交互却知之甚少。&lt;/p&gt;
&lt;p&gt;因工作需求，需要在Android平台接一些sdk（扩展功能）。我就借此机会了解了下Unity与Android交互的一些知识，并做了一个简易实现。&lt;/p&gt;
&lt;p&gt;现将实现步骤记录下来以供日后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一、开发准备&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Unity、Android Stuido以及JDK安装，这些都是基本操作了，网上也有很多教程，这里不细述。&lt;/p&gt;
&lt;p&gt;本次开发所使用的软件版本如下：&lt;/p&gt;
&lt;p&gt;Android Studio 3.5&lt;/p&gt;
&lt;p&gt;Unity 2018.3.10f1&lt;/p&gt;
&lt;p&gt;Java 1.8.0191&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;二、要实现的功能&lt;/h2&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;要在unity项目中进行安卓功能扩展，有两种方式：&lt;/p&gt;
&lt;p&gt;1、Unity项目导出为Android工程，然后在Android Studio（以后简称为&lt;strong&gt;AS&lt;/strong&gt;）中进行二次开发，添加扩展功能。这样的方式开发起来很灵活，改动起来也很方便，但是就是很麻烦，因为每次改动都要打一回安卓工程。&lt;/p&gt;
&lt;p&gt;2、将扩展功能制作成Android库文件（jar包），然后将jar包导入到Unity中，直接使用。这样的方式，使用者无法修改这个库文件的功能，但也更便于使用 。&lt;/p&gt;

&lt;p&gt;因为我将要做的功能可能会在团队内传播使用，也不需要每个人都去做改动。因此选择第二种方式。&lt;/p&gt;
&lt;p&gt;所以本文的目的就是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;制作一个Android库文件（jar包），然后在Unity中使用它。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;三、如何制作Android库文件&lt;/h2&gt;
&lt;blockquote readability=&quot;101.5&quot;&gt;
&lt;h3&gt;1、新建Android工程&lt;/h3&gt;
&lt;p&gt; 打开AS，新建一个Android工程，选择Empty Activity，配置工程名称、包名、位置以及语言，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922145335931-1464353836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 语言最好选Java，因为Java和C#的语法极为相似，学习成本很低。&lt;/p&gt;

&lt;p&gt;工程创建之后，默认显示的是Android视图下app的工程结构，如下图。能看到在包名下有一个MainActivity.java的文件，这是安卓app的入口，不过这里并不打算使用它，忽略即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922144243270-543025395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、创建一个&lt;strong&gt;Android Library&lt;/strong&gt; 模块&lt;/h3&gt;
&lt;p&gt; 选中app，然后右键，选Module，在Create New Module窗口中选择 &lt;strong&gt;Android Library &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163200600-1229167956.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 填入Library name、Module name 、Package name以及Language后，点完成。&lt;/p&gt;
&lt;p&gt; 这里的Package name好像是可以改的，不必和之前创建工程时完全一样（未验证）。不过为了少点事，还是先保持一致吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163244893-678571752.png&quot; alt=&quot;&quot; width=&quot;833&quot; height=&quot;626&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 现在可以看到，在工程中同时存在着app和mysdk模块，它俩是平级存在的，并且都有自己的源码目录（com.letui.mysdk），以及清单目录（manifests）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163331854-216435176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; app部分可以不用管了，后续只对mysdk模块进行操作。&lt;/p&gt;

&lt;h3&gt; 3、引入Unity对接Android的库文件 &lt;/h3&gt;
&lt;p&gt;　　1）在unity的安装目录下件，找到一个名为classes.jar的文件&lt;/p&gt;
&lt;p&gt;　　我的目录为 D:\Unity2018\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Development\Classes&lt;/p&gt;
&lt;p&gt;　　2）然后将classes.jar粘贴到mysdk模块的libs目录下（需要将工程切换到project视图）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　额外说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在il2cpp目录下也有一个名称一样的classes.jar文件，其目录为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 D:\Unity2018\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\il2cpp\Development\Classes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这两个文件的选择，与unity的Player Setting中脚本后端设置有关。如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922150302954-2108855241.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　脚本后端用哪个就，就选哪个目录下的classes.jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　3）选中刚粘贴的classes.jar文件，右键，选择 Add as Library，出现一个弹窗口，默认选中mysdk模块，直接点确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163419274-1837073353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  然后，这个classes.jar文件就被引入到工程中了，展开三角，可以看到如下三个模块，其中就有com.unity3d.player。如下&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163437248-1938794374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 4、创建本模块的Activity文件&lt;/h3&gt;
&lt;p&gt;　　1）展开mysdk模块下的src目录，选中com.leitui.mysdk，然后右键，新建一个Activity，选择Empty Activity，输入Activity Name以及Package Name和Language，勾掉Generate Layout File, 完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163607071-657686320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 新建的SDKMainAcivity.java脚本，默认继承自AppCompatActivity，并带有一个onCreate方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922163641874-1959837736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现将SDKMainActivity脚本内容修改为继续自UnityPlayerActivity ，并添加两个方法 &lt;strong&gt;UnityCallAndroid&lt;/strong&gt; 和 &lt;strong&gt;AndroidCallUnity&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UnityCallAndroid&lt;/strong&gt; 用来接受Unity的调用，&lt;strong&gt;AndroidCallUnity&lt;/strong&gt;用于向unity发起调用。具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.letui.mysdk;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.appcompat.app.AppCompatActivity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.unity3d.player.UnityPlayer;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.unity3d.player.UnityPlayerActivity;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SDKMainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; UnityPlayerActivity {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;unity调用Android&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UnityCallAndroid () {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;unity调用android成功&quot;&lt;span&gt;, Toast.LENGTH_LONG).show();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        AndroidCallUnity();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;android调用unity&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AndroidCallUnity () {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第1个参数为Unity场景中用于接收android消息的对象名称
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第2个参数为对象上的脚本的一个成员方法名称（脚本名称不限制）
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第3个参数为unity方法的参数&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         UnityPlayer.UnitySendMessage(&quot;receiveObj&quot;, &quot;UnityMethod&quot;, &quot;This is args.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5、将模块打包&lt;/h3&gt;
&lt;p&gt;　　打包方法有两种。&lt;/p&gt;
&lt;p&gt;　　一是手动进行构建，然后在Build/intermediates/packaged-classes/release目录下找到相应的jar包（这个jar包默认名称为classes.jar，为了区分，需要自己改名称）；&lt;/p&gt;
&lt;p&gt;　　二是用gradle命令。&lt;/p&gt;
&lt;p&gt;　　打开本模块的build.gradle文件，在文件尾添加如下的一组命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;----------------这是一组将module导出为jar的gradle命令-------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mysdk为自定义的jar包名称
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;task to delete the old jar&lt;/span&gt;
&lt;span&gt;task deleteOldJar(type: Delete) {
    delete &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;release/mysdk.jar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;task to export contents as jar&lt;/span&gt;
&lt;span&gt;task exportJar(type: Copy) {
    from(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;build/intermediates/packaged-classes/release/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    into(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;release/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    include(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classes.jar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;Rename the jar&lt;/span&gt;
    rename(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classes.jar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysdk.jar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
}

exportJar.dependsOn(deleteOldJar, build)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------命令结束------------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922175855436-818175809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这组命令的功能就是打包方法1的自动化版。&lt;/p&gt;
&lt;p&gt; build.gradle文件修改后，会提示要求同步，直接同步即可。同步结束，在IDE右上点开Gradle窗口，在other下找到exportJar命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922175935128-18720067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 双击exportJar命令，等一会就会自动生成本模块的jar文件了。&lt;/p&gt;
&lt;p&gt;生成的文件位于mysdk/release/目录下，如下图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922175957258-746833248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;6、修改AndroidManifest.xml文件&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;1）打开本模块的AndroidManifest.xml文件，文件位于mysdk/src/main目录下，如下图：&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922175744379-1209189431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个文件的内容，目前只有一对application标签和activity标签 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922175216368-638140738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　删掉这三行，将其内容修改为如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;manifest &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    package&lt;/span&gt;&lt;span&gt;=&quot;com.letui.mysdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这个android:label设置后，unity中ProductName就不生效了，记得改这个&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;application &lt;/span&gt;&lt;span&gt;android:label&lt;/span&gt;&lt;span&gt;=&quot;MySDK&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这个android:name的值必须为包名+类名&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activity &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;com.letui.mysdk.SDKMainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.action.MAIN&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;category &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.intent.category.LAUNCHER&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;intent-filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这一行不能少，否则会闪退&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta-data &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;unityplayer.UnityActivity&quot;&lt;/span&gt;&lt;span&gt; android:value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activity&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这其中有三个要注意的点，注释中都有说明。修改完成后保存。&lt;/p&gt;
&lt;p&gt;至此，在AS中的操作就结束了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;四、在unity中使用jar文件&lt;/h2&gt;
&lt;blockquote readability=&quot;53.5&quot;&gt;
&lt;h3&gt;1、新建一个Unity工程。&lt;/h3&gt;
&lt;p&gt;　　a.新建一个Unity工程，在Assets目录下新建Plugins/Android/bin目录。&lt;/p&gt;
&lt;p&gt;　　b.将第三步修改的AndroidManifest.xml文件拷贝到Assets/Plugins/Android目录下&lt;/p&gt;
&lt;p&gt;　　c.将第三步生成的mysdk.jar文件拷贝到Assets/Plugins/Android/bin目录下&lt;/p&gt;
&lt;p&gt;　　完成之后文件结构图如下：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922180139782-702542932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  libs目录用于存放其它android插件的jar文件，没有也可以不用创建。&lt;/p&gt;

&lt;h3&gt; 2、制作一个UI界面&lt;/h3&gt;
&lt;p&gt;　a.在SampleScene场景中创建一个Canvas，并创建一个名为&quot;receiveObj&quot;的对象，在receiveObj之下再放一个按钮和一个Text。&lt;/p&gt;
&lt;p&gt;　按钮用于触发调用Android方法。&lt;/p&gt;
&lt;p&gt;　Text用于显示Android调用Unity方法传递来的参数。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922180228136-1336595905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里要注意，receiveObj的名称必须与SDKMainActivity类的AndroidCallUnity方法中的UnityPlayer.UnitySendMessage方法的第一个参数保持一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190923022241406-2020563730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; b.创建一个SDKTest.cs文件，将脚本挂在receiveObj对象上。如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922180251898-736996415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;SDKTest脚本的内容如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.UI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SDKTest : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AndroidJavaClass jc;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AndroidJavaObject jo;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button btn;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Text text;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Awake()
    {
        btn &lt;/span&gt;= transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
        text &lt;/span&gt;= transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这两行是固定写法&lt;/span&gt;
        jc = &lt;span&gt;new&lt;/span&gt; AndroidJavaClass(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.unity3d.player.UnityPlayer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        jo &lt;/span&gt;= jc.GetStatic&amp;lt;AndroidJavaObject&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentActivity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        btn.onClick.AddListener(OnBtnClickHandler);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnBtnClickHandler ()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用Android中的方法UnityCallAndroid&lt;/span&gt;
        jo.Call(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityCallAndroid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  被Android中AndroidCallUnity调用
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;str&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UnityMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
    {
        Debug.Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityMethod被调用，参数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
        text.text &lt;/span&gt;=&lt;span&gt; str;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其中必须要有UnityMethod方法，因为它在AndroidCallUnity方法中的UnityPlayer.UnitySendMessage的第二个参数已经指定了。如果不存在的话，调用就会出错。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;  jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;);
  jo = jc.GetStatic&amp;lt;AndroidJavaObject&amp;gt;(&quot;currentActivity&quot;);&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这两句，一个是获取到UnityPlayer类，一个是获取到类的实例。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;到于为什么这样能取到我创建的模块的SDKMainActivity的实例，还有待探究。反正目前这么写了就行了。&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt; 3、打包并测试。&lt;/h3&gt;
&lt;p&gt;　　在unity中设置Bundle Identifier和Company等信息之后，打一个apk包。&lt;/p&gt;
&lt;p&gt;　　安装后运行，能正常显示UI。&lt;/p&gt;
&lt;p&gt;　　点击按钮后，显示了一个Toast，提示“Unity调用Android成功”，说明jar包中的UnityCallAndroid方法被调用。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Unity-&amp;gt;Android通信成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　同时屏幕上方的NewText被变更为“This is args”，&quot;This is args&quot;是 AndroidCallUnity方法中传递给UnityMethod方法的参数。&lt;/p&gt;
&lt;p&gt;　　这表示&lt;strong&gt;Android-&amp;gt;Unity通信成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　演示见下图：&lt;/p&gt;
&lt;p&gt;调用 前：&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922180547537-302594977.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;678&quot;/&gt;，调用后： &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201909/634826-20190922180610874-1418361389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt;五、一点说明&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;1、模块的包名和Unity的Bundle Identifier可以不一致（至少在Module模式下，是可以不一致的）。&lt;/p&gt;
&lt;p&gt;说明：写这条是因为其它相关文章全都要求两边保持一致，而如果模块的包名要跟着Unity工程走，也太蛋疼了，所以验证了下。&lt;/p&gt;
&lt;p&gt;2、将AndroidManifest.xml引入到Unity之后，在unity中设置的Product Name就无效了。&lt;/p&gt;
&lt;p&gt;需要在AndroidManifest.xml的application标签中，添加android:label属性来指定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;      初次接触Android开发，以上内容如有错误，还请不吝指出。&lt;/p&gt;

&lt;p&gt;　　本文件所使用的Android工程和Unity工程源码在此：&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/imteach/MySDKProject.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;安卓工程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 　&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/imteach/CustomAndroidSDK.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Unity工程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Sep 2019 18:58:00 +0000</pubDate>
<dc:creator>子非鱼`</dc:creator>
<og:description>前言 使用Unity也有不短的时间了，安卓包也打过不少，但是对Unity与Android的交互却知之甚少。 因工作需求，需要在Android平台接一些sdk（扩展功能）。我就借此机会了解了下Unity</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imteach/p/11567481.html</dc:identifier>
</item>
<item>
<title>Java NIO之理解I/O模型（二） - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/11462457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/11462457.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jimoer/p/11450667.html&quot; target=&quot;_blank&quot;&gt;上一篇文章&lt;/a&gt;讲解了I/O模型的一些基本概念，包括同步与异步，阻塞与非阻塞，同步IO与异步IO，阻塞IO与非阻塞IO。这次一起来了解一下现有的几种IO模型，以及高效IO的两种设计模式，也都是属于IO模型的基础知识。&lt;/p&gt;
&lt;h2&gt;UNIX下可用的五种I/O模型&lt;/h2&gt;
&lt;p&gt;根据UNIX网络编程对IO模型的分类，UNIX提供了5种IO模型，下面分别来介绍一下。&lt;/p&gt;
&lt;h3&gt;阻塞I/O模型&lt;/h3&gt;
&lt;p&gt;最常见的一种IO模型，之前介绍过，一个read操作是分两个阶段的，第一个阶段是，等待数据准备就绪，第二个阶段是将数据拷贝到调用这个IO的线程中。阻塞是发生在第一个阶段的，当数据没有准备好时，会一直阻塞用户线程，当数据就绪后再将数据拷贝到线程中，并返回结果给用户线程。&lt;/p&gt;
&lt;p&gt;大致过程如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190911001429708-1430880358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实，大部分的socket接口都是典型的阻塞型。所谓阻塞型的接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。&lt;/p&gt;
&lt;p&gt;通过介绍了阻塞IO，我们很容易就会发现它的问题，那就是阻塞会是用户线程无法进行任何运算和请求。一般我们的处理这种问题的情况是使用多线程，每个链接创建一个线程，或是使用线程池来管理线程，或许可以缓解部分压力，但是不能解决所有问题。多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。&lt;/p&gt;
&lt;h3&gt;非阻塞I/O模型&lt;/h3&gt;
&lt;p&gt;非阻塞IO模型是这样一个过程，当应用程序发起一个read操作时，并不会阻塞，而是立刻会收到一个结果。应用程序的线程发现返回结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户内存，然后返回。&lt;/p&gt;
&lt;p&gt;这样的一个过程，其实是需要用户线程不断的去询问系统是否准备好了数据，这样就会一直占用CPU资源。但是这种模型是在只专门提供某种功能的系统才有。&lt;/p&gt;
&lt;p&gt;大致过程如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190918225114022-453587150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;多路I/O复用模型 &lt;/h3&gt;
&lt;p&gt;在介绍多路复用I/O时就要先简单说明一下，select函数和poll函数。&lt;/p&gt;
&lt;h4&gt;select函数&lt;/h4&gt;
&lt;p&gt;select函数允许进程指示内核等待多个事件中的任何一个事件发生，并且只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;举个例子，我们可以调用select，告知内核仅在下列情况发生时才返回：&lt;/li&gt;
&lt;li&gt;集合 {1,4,5} 中的任何描述符准备好读；&lt;/li&gt;
&lt;li&gt;集合 {2,7} 中的任何描述符准备好写；&lt;/li&gt;
&lt;li&gt;集合 {1,4} 中的任何描述符有异常条件待处理；&lt;/li&gt;
&lt;li&gt;已经经历10.2秒；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，我们调用select告知内核对哪些描述符（读、写或异常条件）感兴趣以及等待多长时间。&lt;/p&gt;
&lt;h4&gt;poll函数&lt;/h4&gt;
&lt;p&gt;poll函数起源于SVR3，最初局限于流设备。SVR4取消了这种限制，允许poll工作在任何描述符上。poll函数提供的功能与select函数类似，但是poll没有最大文件描述符数量的限制。&lt;/p&gt;
&lt;p&gt;select函数和poll函数将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select函数或者poll函数时会再次报告这些文件描述符， 所以他们一般不会丢失就绪的消息，这种方式称为水平触发(Level Triggered)。&lt;/p&gt;
&lt;p&gt;简单的解了select函数和poll函数后，下面我们就继续说多路I/O复用模型。多路IO复用模型就是调用select或poll函数，并且此模型的阻塞过程就是发生在调用这两个函数中的，而不是发生在真正的的I/O系统调用上的，使用select或poll的好处在于可以用单个线程或进程，处理多个网络连接的IO。整个过程就是select或poll函数会不断的轮询所负责的socket，当某个socket有数据到达了，就通知用户线程或进程。&lt;/p&gt;
&lt;p&gt;大概调用如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190922154110595-59419353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java中的NIO实际上就是使用的多路IO复用模型，通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此多路复用IO模型也会阻塞用户线程，只不过线程是被select函数阻塞的而不是被scoket IO阻塞的。&lt;/p&gt;
&lt;p&gt;所以多路复用IO模型和非阻塞IO有类似之处，但是多路复用IO模型的效率是比非阻塞IO模型要高的，因为在非阻塞IO中，不断的询问scoket状态的是通过用户线程去进行的，而多路复用IO模型，轮询每个scoket状态是内核在进行的，这个效率是比用户线程要高很多的。这样也能看出来多路复用IO模型比较适合链接数比较多的情况。&lt;/p&gt;
&lt;p&gt;不过此模型也是存在问题的，由于多路复用IO模型是通过轮询的方式来检测是否有事件到达，并对到达的事件逐一响应，一旦事件响应体很大或是响应事件数量过多，就会消耗大量的时间去处理事件，从而影响整个过程的及时性。为了应对这种情况linux系统提供了epoll接口，但是除了linux的其他操作系统对epoll接口的支持又有很多差异，所以虽然epoll解决了事件检测的时效性问题，但是在跨平台能力上却并不能得到很好的支持。&lt;/p&gt;
&lt;h3&gt;信号驱动IO模型&lt;/h3&gt;
&lt;p&gt;在信号驱动IO模型中，让内核在数据报准备就绪时发送SIGIO信号通知用户线程。&lt;/p&gt;
&lt;p&gt;整个过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190922172245805-84723612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，也就是说没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后就可以在信号处理函数中调用recvfrom读取数据报，并通知用户进程数据已经准备好了，可以读取了。&lt;/p&gt;
&lt;p&gt;这种模型的优点在于等待数据报到达期间不会被阻塞，用户进程可以继续执行，只要等待来自信号处理函数的通知即可。&lt;/p&gt;
&lt;h3&gt;异步IO模型&lt;/h3&gt;
&lt;p&gt;异步IO模型的过程是这样的，当用户线程发起read操作时，告知内核启动读取数据操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这样在内核执行读取数据操作时，用户线程可以继续执行，当接收到内核在整个操作都完成的信号时，就可以直接去使用数据了。&lt;/p&gt;
&lt;p&gt;大致过程如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190922231653677-860141924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程或进程，这两个阶段都是由内核完成的，然后发送一个信号告知用户线程或进程操作已完成。异步IO模型与信号驱动IO模型的区别在于，信号驱动IO模型是由内核通知用户线程何时启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成，异步IO模型中用户线程并不需要进行实际的读写操作，只需要在内核操作完成后，接到读取完成信号后，直接使用数据即可。&lt;/p&gt;
&lt;p&gt;异步IO是需要操作系统底层支持的，Linux从内核2.6版本才开始支持异步IO。在Java 7中就已经支持异步IO了。&lt;/p&gt;
&lt;h3&gt;两种高性能IO设计模式Reactor和Proactor&lt;/h3&gt;
&lt;h4&gt;Reactor模式&lt;/h4&gt;
&lt;p&gt;Reactor的意思是反应器，字面意思就是立即反应。&lt;/p&gt;
&lt;p&gt;Reactor的工作方式：&lt;/p&gt;
&lt;p&gt;（1）应用程序注册读就绪事件和相关联的事件处理器&lt;/p&gt;
&lt;p&gt;（2）Reactor阻塞等待内核事件通知&lt;/p&gt;
&lt;p&gt;（3）Reactor收到通知，然后分发可读写事件（读写准备就绪）到用户事件处理函数&lt;/p&gt;
&lt;p&gt;（4）用户读取数据，并处理数据&lt;/p&gt;
&lt;p&gt;（5）事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。&lt;/p&gt;
&lt;p&gt;大致过程是，每个应用程序宣布它对某个socket感兴趣，然后就需要到Reactor中注册感兴趣事件以及相关的处理函数。当socket发现有事件到达时，就会按顺序对每个事件进行处理（调用处理函数），当所有事件处理完成后，会继续循环这整个操作。&lt;/p&gt;
&lt;p&gt;过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190923003552665-301508781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从这个设计模式的处理过程中可以看出，多路IO复用模型就是使用的 Reactor模式，并且这种设计模式还是体现的同步IO。&lt;/p&gt;
&lt;h4&gt;Proactor模式&lt;/h4&gt;
&lt;p&gt;Proactor的意思是主动器，主动去完成相应的工作不影响主流程。&lt;/p&gt;
&lt;p&gt;Proactor模式的工作方式：&lt;/p&gt;
&lt;p&gt;（1）应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。&lt;/p&gt;
&lt;p&gt;（2）事件分离器等待读取操作完成事件&lt;/p&gt;
&lt;p&gt;（3）在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。&lt;/p&gt;
&lt;p&gt;（4）事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。&lt;/p&gt;
&lt;p&gt;异步IO模型就是使用的Proactor模式。&lt;/p&gt;




&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《Unix网络编程》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3916526.html&quot;&gt;https://www.cnblogs.com/dolphin0520/p/3916526.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/findumars/p/6361627.html&quot;&gt;https://www.cnblogs.com/findumars/p/6361627.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ifeve.com/io%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%83%91/&quot;&gt;http://ifeve.com/io%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%83%91/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Sep 2019 17:01:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 上一篇文章讲解了I/O模型的一些基本概念，包括同步与异步，阻塞与非阻塞，同步IO与异步IO，阻塞IO与非阻塞IO。这次一起来了解一下现有的几种IO模型，以及高效IO的两种设计模式，也都是属于IO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/11462457.html</dc:identifier>
</item>
<item>
<title>Django-官网查询部分翻译（1.11版本文档）-QuerySet-字段查找-06 - suwanbin</title>
<link>http://www.cnblogs.com/suwanbin/p/11570151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suwanbin/p/11570151.html</guid>
<description>&lt;blockquote readability=&quot;4.0740740740741&quot;&gt;
&lt;p&gt;本文将翻译 django 官网的 模型层的 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/db/queries/&quot;&gt;QuerySet 章节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档版本：1.11&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一旦你创建了 数据表模型类，django 会自动给你一些数据库抽象API，让你可以创建、查询、更新、删除对象，下文将介绍如何使用这些API（以一个网页应用为例展开）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先是创建表模型类&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先分析一下他们的表关系，会有助于理解下面的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):              # __unicode__ on Python 2
        return self.headline&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 django（ORM）中，数据库与 python 对象的映射关系十分形象，一个表模型类（class）即代表一张表，实例化出一个对象即代表一条数据记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建一个对象一条数据记录&quot;&gt;创建一个对象（一条数据记录）&lt;/h2&gt;
&lt;p&gt;在 django 中要想创建一个数据对象，只需要实例化他，传入这个表模型类的关键字参数，然后调用 .save() 方法把这个对象保存到数据库中即可&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from blog.models import Blog

b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
b.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这段代码背后其实是一条数据库 插入语句，django 并不会直接执行这个语句，直到你调用了 .save() 方法（ .save() 没有返回值）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;保存修改的表对象&quot;&gt;保存修改的表对象&lt;/h2&gt;
&lt;p&gt;想要保存一个已经改动过的对象，调用 .save() 方法即可（更新一条记录）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下面是一个 Blog 表模型类的实例化对象 b5，他已经在数据库里有对应的记录了，下面的语句将修改他的 name 属性值，然后更新它到数据库中去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;b5.name = 'New name'
b5.save()  # 代码运行到这里才会进行数据库操作，真正地更新到数据库！&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;保存外键字段或多对多字段foreignkey-or-manytomanyfield-fields&quot;&gt;保存外键字段或多对多字段（&lt;code&gt;ForeignKey&lt;/code&gt; or &lt;code&gt;ManyToManyField&lt;/code&gt; fields）&lt;/h3&gt;
&lt;h4 id=&quot;外键字段-foreignkey&quot;&gt;外键字段 &lt;code&gt;ForeignKey&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;更新一个外键字段的写法和普通字段的完全一致，只需要将正确类型的对象分配给相关字段即可，下面的语句是更新一个 Entry 模型类实例化出来的 entry 对象的 blog 属性（请确保下面用到的 Entry 和 Blog 的实例化对象已经存在在数据库中，这样我们的语句才能将它们查出来）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from blog.models import Blog, Entry

entry = Entry.objects.get(pk=1)  # 查出主键是 1 的 entry 对象（记录）
cheese_blog = Blog.objects.get(name=&quot;Cheddar Talk&quot;)
entry.blog = cheese_blog  # 将 blog 对象直接赋值给 entry 对象的 blog 属性（对象赋值给字段）
entry.save()  # 调用 .save() 方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;manytomanyfield&quot;&gt;&lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;想要保存多对多字段，写法和外键字段有点小区别，使用 .add() 方法来记录一个关系。&lt;/p&gt;
&lt;p&gt;下面的案例把 Author 表模型类的实例 joe 对象增加到了 entry 对象中（加了一个对应关系）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from blog.models import Author

joe = Author.objects.create(name=&quot;joe&quot;)  # 创建了一个 Author类的对象 joe, 它的 name 属性是 joe
entry.authors.add(joe)  # 给已经查出来了的 entry 对象增加...（建立关联关系）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;插入多个多对多字段&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;john = Author.objects.create(name=&quot;John&quot;)
paul = Author.objects.create(name=&quot;Paul&quot;)
george = Author.objects.create(name=&quot;George&quot;)
ringo = Author.objects.create(name=&quot;Ringo&quot;)
entry.authors.add(john, paul, george, ringo)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果你传的对象类型不正确，django 将会报错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;注意把-add-方法解释一下对象可以直接传如果是值要传元组&quot;&gt;注意！把 add 方法解释一下（对象可以直接传，如果是值，要传元组？）&lt;/h4&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h2 id=&quot;retrieving-objects-查出对象queryset&quot;&gt;Retrieving objects 查出对象（QuerySet）&lt;/h2&gt;
&lt;p&gt;从数据库中查询对象，通过 表模型类的 Manager 管理器 来构造一个 QuerySet 。&lt;/p&gt;
&lt;p&gt;一个 QuerySet 代表着你数据库中的一系列对象的集合，它可以是 0 个、 1 个 或者多个 filters，filters 可以基于你给出的参数 缩小查询结果的范围，对于 SQL ，一个 QuerySet 相当于一个 SELECT 语句，一个 filter 就相当于一个限制条件，比如 WHERE 或者 LIMIT。&lt;/p&gt;
&lt;p&gt;我们通过使用表模型类的 Manager 来构造（获得）一个 QuerySet ，每一个表模型类至少有一个 Manager ，他可以直接被对象调用（封装好了的），我们可以通过表模型类直接访问它，就像下面这样：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Blog.objects
# 内部对应的是：&amp;lt;django.db.models.manager.Manager object at ...&amp;gt;
b = Blog(name='Foo', tagline='Bar')  # 表模型类实例化会返回实例化好的对象
b.objects  # 会报错 AttributeError: &quot;Manager isn't accessible via Blog instances.&quot; --&amp;gt; Manager 不能通过 Blog 实例来访问&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Managers 只能通过表模型类来访问，而不是模型类的实例（对象）&lt;/p&gt;
&lt;p&gt;请你&lt;strong&gt;一定要分清楚你当前使用的是 表层面 的操作还是 记录层面 的操作（只有表层面才有Manager）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;retrieving-all-objects-查出所有对象&quot;&gt;Retrieving all objects 查出所有对象&lt;/h3&gt;
&lt;p&gt;最简单的方式从表里获取全部记录对象（QuerySet）是在 Manager 上调用 .all() 方法&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;all_entries = Entry.objects.all()  # 查出 Entry 模型类对应表中的所有数据记录，是一个 QuerySet&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;retrieving-specific-objects-with-filters-通过-filter-查出指定的对象&quot;&gt;Retrieving specific objects with filters 通过 filter 查出指定的对象&lt;/h3&gt;
&lt;p&gt;.all() 方法可以返回 数据库中所有记录的对象 但是通常情况下，我们只需要查询出里面的一小部分对象。&lt;/p&gt;
&lt;p&gt;想要得到这么一小部分对象，我们需要细化（约束）最初的 QuerySet ，增加过滤条件，细化 QuerySet 最常用的两种写法如下：&lt;/p&gt;
&lt;h4 id=&quot;filterkwargs&quot;&gt;filter(**kwargs)&lt;/h4&gt;
&lt;p&gt;返回一个&lt;strong&gt;符合&lt;/strong&gt;你给出的查找参数（条件）的 QuerySet（满足条件的）&lt;/p&gt;
&lt;h4 id=&quot;excludekwargs&quot;&gt;exclude(**kwargs)&lt;/h4&gt;
&lt;p&gt;返回一个&lt;strong&gt;不符合&lt;/strong&gt;你给出的查找参数（条件）的 QuerySet（不满足条件的）&lt;/p&gt;
&lt;p&gt;查找参数（**kwargs）应该符合 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/db/queries/#field-lookups&quot;&gt;Field lookups（字段查找）&lt;/a&gt;格式（day 55 博客里有）&lt;/p&gt;
&lt;p&gt;就比如，你想得到 2006年发表的 blog entries 的 QuerySet ，可以通过 filter 这么实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Entry.objects.filter(pub_date__year=2006)
# 也可以这么写（使用 表模型类的 Manager 来调用 filter）
Entry.objects.all().filter(pub_date__year=2006)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;链式-filter&quot;&gt;链式 filter&lt;/h4&gt;
&lt;p&gt;细化 QuerySet 后的&lt;strong&gt;结果自身&lt;/strong&gt;还是一个 QuerySet ，所以我们可以链式地细分（再次筛选）它，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Entry.objects.filter(
    headline__startswith='What'
).exclude(
    pub_date__gte=datetime.date.today()
).filter(
    pub_date__gte=datetime.date(2005, 1, 30)
)  # 不写成一行是这样看起来更清楚点&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面语句的最终查询条件（含义）是：查出所有 headline 以 “What” 开头，pub_date 非今天及今天以后，并且 pub_date 是在 2005-1-30 之后的 QuerySet （包含了满足条件的记录）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大白话一点就是&lt;/strong&gt;：查出 标题以 What 开头，在2005年1月30日至今（天）的所有书籍记录（QuerySet）&lt;/p&gt;
&lt;h4 id=&quot;queryset-是相互隔离的不同的对象了&quot;&gt;QuerySet 是相互隔离的（不同的对象了）&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;个人理解：&lt;/strong&gt;QuerySet 就等同于 SQL 语句，你加条件会产生一条新的语句，新的语句并不会影响 旧的语句，多次执行同一个 QuerySet 结果不同是由于数据库里&lt;strong&gt;符合该条件的记录&lt;/strong&gt;少了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一次你细化 QuerySet，你将得到一个崭新的 QuerySet，他跟细分之前的 QuerySet 没有绑定关系，互不影响。&lt;/p&gt;
&lt;p&gt;每次细化都会创建一个单独而又独特的 QuerySet 对象，它可以被用来存储、使用、重用。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;q1 = Entry.objects.filter(headline__startswith=&quot;What&quot;)
q2 = q1.exclude(pub_date__gte=datetime.date.today())
q3 = q1.filter(pub_date__gte=datetime.date.today())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的三个 QuerySet 是相互独立的&lt;/p&gt;
&lt;p&gt;第一个 QuerySet 包含了所有的 文章标题（headline） 以 What 开头的 QuerySet 对象（记录对象集合）&lt;/p&gt;
&lt;p&gt;第二个 QuerySet 是第一个集合的子集合（再次筛选后的对象），附加条件：pub_date 不是（exclude）今天或者将来的 --&amp;gt; 今天及今天之前的&lt;/p&gt;
&lt;p&gt;第三个 QuerySet 是第一个集合的子集合（在第一个的条件上再加条件），附加条件：pub_date 是今天或者将来的&lt;/p&gt;
&lt;p&gt;第一个 QuerySet（q1） 不受 其他两个（q2、q3）的影响。&lt;/p&gt;
&lt;h4 id=&quot;queryset-是惰性的不会主动执行&quot;&gt;QuerySet 是惰性的（不会主动执行）&lt;/h4&gt;
&lt;p&gt;QuerySet 是惰性的，创建 QuerySet 的行为（语句）并不会涉及任何数据库操作。&lt;/p&gt;
&lt;p&gt;你可以给 QuerySet 叠加许多许多过滤条件，但是 django 并不会去执行他们，直到 QuerySet 被 evaluated （检查，评估？--&amp;gt; 推测是 遍历、取值，翻译成取值好像更合适一点），看看下面的例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;q = Entry.objects.filter(headline__startswith=&quot;What&quot;)
q = q.filter(pub_date__lte=datetime.date.today())
q = q.exclude(body_text__icontains=&quot;food&quot;)
print(q)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来像执行了几次数据库操作？三次？不！其实它只执行了一次，只在执行最后一行 print(q) 的时候执行了数据库操作。通常来说，QuerySet 的结果只会在你 “访问” 它们的时候才会从数据库获取，当你执行时，QuerySet 会通过访问数据库来取值（&lt;code&gt;When you do, the QuerySet is evaluated by accessing the database&lt;/code&gt;，翻不出来）&lt;/p&gt;
&lt;h5 id=&quot;触发-queryset-让其真正执行数据库操作的几种情况&quot;&gt;触发 QuerySet 让其真正执行数据库操作的几种情况&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;迭代（for 循环遍历）&lt;/li&gt;
&lt;li&gt;加了步长的切片操作、索引取值、get、all、first 等&lt;/li&gt;
&lt;li&gt;pikle 序列化时&lt;/li&gt;
&lt;li&gt;触发了 &lt;code&gt;__repr__() 或者 __str__()&lt;/code&gt; 时&lt;/li&gt;
&lt;li&gt;触发了 &lt;code&gt;__len__() 或者 len()&lt;/code&gt; 时
&lt;ul&gt;&lt;li&gt;如果你想获取满足条件的数据条数而不需要其他信息，可以使用 &lt;code&gt;.count()&lt;/code&gt; 来更高效的获取数据条数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;list()&lt;/code&gt; 把 QuerySet 强制转换成 list 时&lt;/li&gt;
&lt;li&gt;强转成 bool 类型或者 作为 if 条件 时
&lt;ul&gt;&lt;li&gt;如果 QuerySet 的查询结果至少有一个（数据对象），返回 True，如果没有结果，返回 False&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;caching-and-querysets-缓存-和-querysets&quot;&gt;Caching and QuerySets 缓存 和 QuerySets&lt;/h5&gt;
&lt;p&gt;每一个 QuerySet 都包含一个缓存，来最小化数据库访问次数，知道它的工作原理可以让你写出更高效的代码。&lt;/p&gt;
&lt;p&gt;新创建的 QuerySet 的缓存（cache）是空的，QuerySet 第一次取值执行（evaluatad）的时候进行数据库查询操作，Django 会将查询结果保存到 QuerySet 的 cache 缓存中，并返回查询出来的结果集。后续取值可以复用 QuerySet 的缓存结果。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 下面的这两行代码会走两次数据库操作，很可能他们两次得到的数据是相同的。
# 为什么我们不避免它呢？ --&amp;gt; 很可能两次查询请求之间可能有对象被删除或者新增，会造成两次结果不一致
print([e.headline for e in Entry.objects.all()])
print([e.pub_date for e in Entry.objects.all()])


# 下面的代码只会走一次数据库操作
queryset = Entry.objects.all()
print([p.headline for p in queryset]) # 真正地执行数据库操作
print([p.pub_date for p in queryset]) # 重用上一次查询出来的结果（cache）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;when-querysets-are-not-cached-不会保存-cache-缓存的情况&quot;&gt;When QuerySets are not cached 不会保存 cache 缓存的情况&lt;/h4&gt;
&lt;p&gt;QuerySet 也不总是会缓存他的查询结果，当只需要（取值）结果集中的一部分时，cache 会被检查，但如果没有被填充，则不会缓存后续查询返回的项目（&lt;code&gt;but if it is not populated then the items returned by the subsequent query are not cached.&lt;/code&gt;），具体来说，这意味着使用数组切片或者索引限制查询结果集将不会保存缓存。&lt;/p&gt;
&lt;p&gt;比如，每次获取一个明确的索引值都会执行一次数据库操作&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 下面的操作执行了两次数据库查询
queryset = Entry.objects.all()
print(queryset[5]) # 查询数据库
print(queryset[5]) # 又一次查询了数据库&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，如果整个 QuerySet 已经被取值（evaluated），那么 cache 将会被缓存&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 下面的操作只执行了一次数据库查询
queryset = Entry.objects.all()
entry_list = [entry for entry in queryset] # 执行了数据库操作
print(queryset[5]) # 使用 cache
print(queryset[5]) # 使用 cache&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一些可以将会整个取值（evaluated）的一些案例，可以将数据存到 cache 中（让后续使用 cache，减少数据库操作次数）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;[entry for entry in queryset]
bool(queryset)
entry in queryset
list(queryset)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;小心这个特性&lt;/strong&gt;，你可以用它来提升代码的性能（减少查询次数，降低数据库压力），但也可能因为用了 cache 造成数据紊乱（使用的数据不是最新的，读取到修改之间发生了另一次修改，这次使用的数据在数据库里已经更新过了（高并发很可能发生），）！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;retrieving-a-single-object-with-get-使用-get-只取一个数据对象&quot;&gt;Retrieving a single object with &lt;code&gt;get()&lt;/code&gt; 使用 get() 只取一个数据对象&lt;/h3&gt;
&lt;p&gt;. filter() 方法返回的是一个 QuerySet ，即使他里面只有一个数据对象，如果你确定查询结果只有一个对象，你可以用 表模型类的 Manager 对象来调用 .get() 方法，往里面传入查询条件来直接获取到数据对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;one_entry = Entry.objects.get(pk=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在任何 查询语句 后面使用 .get() 方法，他也可以接收一些关键字参数，同样支持字段查找语法（__gt=18）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住这个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;.get()&lt;/code&gt; 和 &lt;code&gt;.filter()[0]&lt;/code&gt; 有点不一样，如果没有满足条件的查询结果， &lt;code&gt;.get()&lt;/code&gt; 会报一个 &lt;code&gt;DoesNotExist&lt;/code&gt; 的错，这个报错是执行的表模型类的一个属性，所以，在上面的代码中，如果 Entry 对应的表中没有任何对象符合 主键 是 1，那么 django 将会报错：&lt;code&gt;Entry.DoesNotExist&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样，如果有多个对象同时满足这个条件，那么 django 将会报错：&lt;code&gt;MultipleObjectsReturned&lt;/code&gt;，这个报错也是执行的模型类的一个属性。&lt;/p&gt;
&lt;h3 id=&quot;other-queryset-methods-其他的-queryset-方法&quot;&gt;Other QuerySet methods 其他的 QuerySet 方法&lt;/h3&gt;
&lt;blockquote readability=&quot;7.3684210526316&quot;&gt;
&lt;p&gt;通常情况下，你会使用 &lt;code&gt;.all()、.get()、.exclude()&lt;/code&gt; 去查询数据库，但我们提供的远不止这些。&lt;/p&gt;
&lt;p&gt;更多详情可以看 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/models/querysets/#queryset-api&quot;&gt;QuerySet API&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，当你使用 QuerySet 时会结合 filter 等链式调用，为了实现链式调用，大多数的 QuerySet 方法都会返回一个新的 QuerySet&lt;/p&gt;
&lt;p&gt;QuerySet 类有两个公共属性你可以用于反省？（use for introspection）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ordered&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 QuerySet 的查询结果是有序的，会返回 True，如果是无序的，会返回False&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;db&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将会用于执行查询语句的数据库&lt;/p&gt;
&lt;p&gt;query&lt;/p&gt;
&lt;p&gt;可以查看当前 QuerySet 对应的 SQL 语句&lt;/p&gt;
&lt;h4 id=&quot;methods-that-return-new-querysets-返回新的-querysets-的方法&quot;&gt;Methods that return new QuerySets 返回新的 QuerySets 的方法&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 常见的几个
.filter(**kwargs) 符合条件的
.exclude(**kwargs) 不符合条件的
.annnotate(*args, **kwargs)  分组
.order_by(*fields) 排序
.reverse()  反序
.distinct(*fields) 去重
.values(*fields, **expressions*) 过滤字段
.values_list(*fields, flat=False) 过滤字段
.all()
.select_related(*field) 优化，可以把对象查出来，并附带字段，后期对象 .字段 不会再触发数据库操作
.prefetch_related(*lookups) 优化相关
.defer(*fields) 优化相关
.only(*fields) 优化相关
.select_for_update(nowait=False, skip_locked=False)

# 不常见的几个
.dates(field, kind, order=‘ASC’) 
.datetimes(field_name, kind, order=‘ASC’, tzinfo=None)
.none() 创建空的 QuerySet
.union(*other_qs, all=False) 
.intersection(*other_qs)
.difference(*other_qs)
.extra(一堆参数) 自定义SQL（将被舍弃的方法）
.extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
.using(alias)  多个数据库时指定数据库（数据库配置可以配好几个数据库连接）
.raw(raw_query, params=None, translations=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;filterkwargs-符合条件的&quot;&gt;.filter(**kwargs) 符合条件的&lt;/h5&gt;
&lt;p&gt;会返回一个新的 QuerySet ，里面包含的对象都是满足你给出的查询参数（条件）的，多个查询（关键字）参数以逗号间隔，对应到 SQL 语句中是 AND 连接，如果你想执行更多复杂的操作（比如 OR 或）可以使用 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/db/queries/#complex-lookups-with-q&quot;&gt;Q 对象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q对象 的使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.db.models import *
&quot;&quot;&quot;
, 间隔 Q 对象，是 and 关系 ( &amp;amp; 也是)
| 间隔 Q 对象，是 or  关系
~ 放在 Q 对象前面，是 ! 取反关系
&quot;&quot;&quot;

Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
# --&amp;gt; SELECT * from polls WHERE question LIKE 'Who%' AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;excludekwargs-不符合条件的&quot;&gt;.exclude(**kwargs) 不符合条件的&lt;/h5&gt;
&lt;p&gt;会返回一个新的 QuerySet ，里面包含的对象都是不满足括号内指定的查询条件的，多个查询（关键字）参数以逗号间隔，参数之间是 AND 关系，其最外层逻辑是 NOT()。如果你想执行更多复杂的操作（比如 OR 或）可以使用 &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/db/queries/#complex-lookups-with-q&quot;&gt;Q 对象&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')
# 对应的SQL ：SELECT ... WHERE NOT (pub_date &amp;gt; '2005-1-3' AND headline = 'Hello')

# 同样他也支持像 filter 那样链式调用
Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')
# 对应的SQL ：SELECT ... WHERE NOT pub_date &amp;gt; '2005-1-3' AND NOT headline = 'Hello'&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;annnotateargs-kwargs-分组---暂时看不懂&quot;&gt;.annnotate(*args, **kwargs) 分组-- 暂时看不懂&lt;/h5&gt;
&lt;h5 id=&quot;order_byfields-排序----太长了先放&quot;&gt;.order_by(*fields) 排序 -- 太长了，先放&lt;/h5&gt;
&lt;h5 id=&quot;reverse-反序&quot;&gt;.reverse() 反序&lt;/h5&gt;
&lt;p&gt;只能对排过序的 QuerySet 使用...&lt;/p&gt;
&lt;h5 id=&quot;distinctfields-去重&quot;&gt;.distinct(*fields) 去重&lt;/h5&gt;
&lt;h5 id=&quot;valuesfields-expressions-过滤字段&quot;&gt;.values(*fields, **expressions*) 过滤字段&lt;/h5&gt;
&lt;h5 id=&quot;values_listfields-flatfalse-过滤字段&quot;&gt;.values_list(*fields, flat=False) 过滤字段&lt;/h5&gt;
&lt;h5 id=&quot;none-创建空的-queryset&quot;&gt;.none() 创建空的 QuerySet&lt;/h5&gt;
&lt;p&gt;调用 .none() 方法会创建一个空的 QuerySet ，里面不包含任何数据对象，并且在取值时也不会执行任何数据库操作（是 EmptyQuerySet 的实例）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Entry.objects.none()
# &amp;lt;QuerySet []&amp;gt;


from django.db.models.query import EmptyQuerySet

isinstance(Entry.objects.none(), EmptyQuerySet)
# True

# 下面两句不会执行数据库操作
print(models.Book.objects.none())
# &amp;lt;QuerySet []&amp;gt;
print(models.Book.objects.none().filter(title__contains='三国'))
# &amp;lt;QuerySet []&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;all&quot;&gt;.all()&lt;/h5&gt;
&lt;h5 id=&quot;unionother_qs-allfalse&quot;&gt;.union(*other_qs, all=False)&lt;/h5&gt;
&lt;h5 id=&quot;intersectionother_qs&quot;&gt;.intersection(*other_qs)&lt;/h5&gt;
&lt;h5 id=&quot;differenceother_qs&quot;&gt;.difference(*other_qs)&lt;/h5&gt;
&lt;h5 id=&quot;select_relatedfield-优化可以把对象查出来并附带字段后期对象-.字段-不会再触发数据库操作&quot;&gt;.select_related(*field) 优化，可以把对象查出来，并附带字段，后期对象 .字段 不会再触发数据库操作&lt;/h5&gt;
&lt;h5 id=&quot;prefetch_relatedlookups-优化相关&quot;&gt;.prefetch_related(*lookups) 优化相关&lt;/h5&gt;

&lt;p&gt;.extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)&lt;/p&gt;
&lt;h5 id=&quot;deferfields-优化相关&quot;&gt;.defer(*fields) 优化相关&lt;/h5&gt;
&lt;h5 id=&quot;onlyfields-优化相关&quot;&gt;.only(*fields) 优化相关&lt;/h5&gt;
&lt;h5 id=&quot;usingalias-多个数据库时指定数据库数据库配置可以配好几个数据库连接&quot;&gt;.using(alias) 多个数据库时指定数据库（数据库配置可以配好几个数据库连接）&lt;/h5&gt;
&lt;h5 id=&quot;select_for_updatenowaitfalse-skip_lockedfalse&quot;&gt;.select_for_update(nowait=False, skip_locked=False)&lt;/h5&gt;
&lt;h5 id=&quot;rawraw_query-paramsnone-translationsnone&quot;&gt;.raw(raw_query, params=None, translations=None)&lt;/h5&gt;
&lt;h4 id=&quot;methods-that-do-not-return-querysets-不返回queryset-对象的方法&quot;&gt;Methods that do not return QuerySets 不返回QuerySet 对象的方法&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;下面这些 QuerySet 方法会直接触发数据库操作然后返回一些其他东西，而不是 QuerySet&lt;/p&gt;
&lt;p&gt;这些方法不会使用 cache 缓存，相反，每次调用他们都会执行数据库操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 常见的几个
.get(**kwargs) 返回当个对象
.create(**kwargs) 
.count()
.latest(field_name=None)
.earliest(field_name=None)
.first()
.last()
.aggregate(*args, **kwargs)
.exists()
.update(**kwargs)
.delete()

# 不常见的几个
.get_or_create(defaults=None, **kwargs)
.update_or_create(defaults=None, **kwargs)
.bulk_create(objs, batch_size=None)
.in_bulk(id_list=None)
.iterator()
.as_manager()&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;getkwargs-返回当个对象&quot;&gt;.get(**kwargs) 返回当个对象&lt;/h5&gt;
&lt;h5 id=&quot;createkwargs&quot;&gt;.create(**kwargs)&lt;/h5&gt;
&lt;h5 id=&quot;count&quot;&gt;.count()&lt;/h5&gt;
&lt;h5 id=&quot;first&quot;&gt;.first()&lt;/h5&gt;
&lt;h5 id=&quot;last&quot;&gt;.last()&lt;/h5&gt;
&lt;h5 id=&quot;aggregateargs-kwargs&quot;&gt;.aggregate(*args, **kwargs)&lt;/h5&gt;
&lt;h5 id=&quot;exists&quot;&gt;.exists()&lt;/h5&gt;
&lt;h5 id=&quot;updatekwargs&quot;&gt;.update(**kwargs)&lt;/h5&gt;
&lt;h5 id=&quot;delete&quot;&gt;.delete()&lt;/h5&gt;
&lt;h5 id=&quot;latestfield_namenone&quot;&gt;.latest(field_name=None)&lt;/h5&gt;
&lt;h5 id=&quot;earliestfield_namenone&quot;&gt;.earliest(field_name=None)&lt;/h5&gt;
&lt;h3 id=&quot;aggregation-functions-聚合函数&quot;&gt;Aggregation functions 聚合函数&lt;/h3&gt;
&lt;h2 id=&quot;field-lookups-字段查找字段查询条件双下划线查询&quot;&gt;field-lookups 字段查找（字段查询条件，双下划线查询）&lt;/h2&gt;
&lt;blockquote readability=&quot;1.8115942028986&quot;&gt;
&lt;p&gt;此部分参考文档： &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/models/querysets/#field-lookups&quot;&gt;django官网 字段查找（field-lookups）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;字段查找（field-lookups）对应的是 SQL 语句中的 WHERE 条件，一般放在 QuerySet 对象的 filter() 、exclude()、get() 方法中作为条件&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;常见形式&quot;&gt;常见形式&lt;/h3&gt;
&lt;h3 id=&quot;注意点&quot;&gt;注意点&lt;/h3&gt;
&lt;p&gt;不同数据库对这些方法支持不同，django orm 对应不同数据库也能翻译成不同的 SQL 语句&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sqlite 对日期类型支持不友好、数据（字符串）大小写不敏感（忽略大小写）&lt;/li&gt;
&lt;li&gt;python 对浮点数精度不敏感（price=66.66 --&amp;gt; 可能有这么一条记录，但它却匹配不到（python（好像是 sqlite吧？） 把它变成了 66.651556464））&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;书写格式&quot;&gt;书写格式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;field__lookuptype --&amp;gt; price_gt&lt;/code&gt; (两个下划线)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 省略一些要导入的文件
Entry.objects.filter(pub_date__lte='2006-01-01')

# 翻译成对应的 SQL 语句就是：
SELECT * FROM blog_entry WHERE pub_date &amp;lt;= '2006-01-01';

# pub_date__lte='2006-01-01' --&amp;gt; pub_date &amp;lt;= '2006-01-01'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面表名为什么是 blog_entry ？&lt;/p&gt;
&lt;p&gt;用 django 表模型类创建的表会自动加上 app 的前缀（显然这里的 app 叫 blog）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;lookuptype-查找类型分类整理&quot;&gt;lookuptype 查找类型分类整理&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此部分为&lt;strong&gt;伪代码&lt;/strong&gt;，仅演示这些字段查询的功能用法以及对应 SQL 语句什么样&lt;/p&gt;
&lt;p&gt;这里都是直接以模型表类开头的（相当于 &lt;code&gt;from app01.models import *&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;关系比较类&quot;&gt;关系比较类&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__gt
# 字段大于...
Entry.objects.filter(id__gt=4)
# --&amp;gt; SELECT ... WHERE id &amp;gt; 4;

__gte
# 大于等于

__lt
# 小于

__lte
# 小于等于

__isnull
# 字段是否为空
Entry.objects.filter(pub_date__isnull=True)
# --&amp;gt; SELECT ... WHERE pub_date IS NULL;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;模糊匹配类正则&quot;&gt;模糊匹配类、正则&lt;/h4&gt;
&lt;p&gt;精准匹配直接就是 = / exact&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# --------- 是否包含 --------------
__contains
# 字段值是否包含 __ 
Entry.objects.get(headline__contains='Lennon')
# --&amp;gt; SELECT ... WHERE headline LIKE '%Lennon%';

__icontains
# 字段值是否包含 __ ，忽略大小写的包含
Entry.objects.get(headline__icontains='Lennon')
# --&amp;gt; SELECT ... WHERE headline ILIKE '%Lennon%';

# --------- 以 ... 开头 或 结尾 --------------
__startswith
# 字段以 __ 开头
Entry.objects.filter(headline__startswith='Lennon')
# --&amp;gt; SELECT ... WHERE headline LIKE 'Lennon%';

__istartswith
# 字段以 __ 开头，忽略大小写
Entry.objects.filter(headline__istartswith='Lennon')
# --&amp;gt; SELECT ... WHERE headline ILIKE 'Lennon%';

__endswith
# 字段以 __ 结尾
Entry.objects.filter(headline__endswith='Lennon')
# --&amp;gt; SELECT ... WHERE headline LIKE '%Lennon';

__iendswith
# 字段以 __ 结尾，忽略大小写
Entry.objects.filter(headline__iendswith='Lennon')
# --&amp;gt; SELECT ... WHERE headline ILIKE '%Lennon'

# --------- 全文检索 --------------
__search
# 全文检索（django 1.10 开始有改动）
Entry.objects.filter(headline__search=&quot;+Django -jazz Python&quot;)
# --&amp;gt; SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);

# --------- 正则相关 --------------
__regex
# 正则匹配
Entry.objects.get(title__regex=r'^(An?|The) +')
# --&amp;gt; SELECT ... WHERE title REGEXP BINARY '^(An?|The) +';  # -- MySQL，对于这个字段查询，django orm 对应不同的 数据库 会解析成不同的 SQL 语句

__iregex
# 忽略大小写的正则匹配
# 案例
Entry.objects.get(title__iregex=r'^(an?|the) +')
# --&amp;gt;SELECT ... WHERE title REGEXP '^(an?|the) +';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;范围类&quot;&gt;范围类&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__in
# 字段的值在不在给定的列表范围内
Entry.objects.filter(id__in=[1, 3, 4])
# --&amp;gt; SELECT ... WHERE id IN (1, 3, 4);

# 补充：也可以使用会动态的查询 QuerySet 作为列表
inner_qs = Blog.objects.filter(name__contains='Cheddar')
entries = Entry.objects.filter(blog__in=inner_qs)
# --&amp;gt; SELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE '%Cheddar%')

__range
# 可以比较日期时间、数字范围、字符（串？没验证）范围
import datetime
start_date = datetime.date(2005, 1, 1)
end_date = datetime.date(2005, 3, 31)
Entry.objects.filter(pub_date__range=(start_date, end_date))
# --&amp;gt; SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;日期时间类&quot;&gt;日期时间类&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;日期时间与日期不能混用&lt;/p&gt;
&lt;p&gt;允许其他 关系类的字段查找（field-lookups， 大于小于这样的） 链式拼接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__date
# 匹配 datetime 类型字段，会将传入的值转换为日期，然后搭配 关系类的字段查找（field-lookups）进行比较
Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))
Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))
# --&amp;gt; ...

__year
# 匹配 datetime、date 类型字段，直接指定精确的哪一年
Entry.objects.filter(pub_date__year=2005)
# --&amp;gt; SELECT ... WHERE pub_date BETWEEN '2005-01-01' AND '2005-12-31';
Entry.objects.filter(pub_date__year__gte=2005)
# --&amp;gt; SELECT ... WHERE pub_date &amp;gt;= '2005-01-01';

__month
# 匹配 datetime、date 类型字段，范围是 1 (January) --- 12 (December)，语句视数据库引擎而定    
Entry.objects.filter(pub_date__month=12)
# --&amp;gt; SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';
Entry.objects.filter(pub_date__month__gte=6)
# --&amp;gt; SELECT ... WHERE EXTRACT('month' FROM pub_date) &amp;gt;= '6';

__day
# 匹配 datetime、date 类型字段，当月的第几天
Entry.objects.filter(pub_date__day=3)
# --&amp;gt; SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';
Entry.objects.filter(pub_date__day__gte=3)
# --&amp;gt; SELECT ... WHERE EXTRACT('day' FROM pub_date) &amp;gt;= '3';
# Note this will match any record with a pub_date on the third day of the month, such as January 3, July 3, etc.

__week
# 匹配 datetime、date 类型字段，当年的第几周（1-52/53，平闰年不同）
# django 1.11 中新增的
Entry.objects.filter(pub_date__week=52)
Entry.objects.filter(pub_date__week__gte=32, pub_date__week__lte=38)
# --&amp;gt; ...
# return the week number (1-52 or 53) according to ISO-8601, i.e., weeks start on a Monday and the first week starts on or before Thursday.

__week_day
# 匹配 datetime、date 类型字段 范围：1 (Sunday) -- 7 (Saturday)
Entry.objects.filter(pub_date__week_day=2)
Entry.objects.filter(pub_date__week_day__gte=2)
# --&amp;gt; ...

__time
# 匹配 datetime、time 类型字段的 minute， django 1.11 中新增的
Entry.objects.filter(pub_date__time=datetime.time(14, 30))
# 实现方式取决于数据库引擎（暂时没有例子）


__hour
# 匹配 datetime、time 类型字段的 minute，范围 0-23
Event.objects.filter(timestamp__hour=23)
# --&amp;gt; SELECT ... WHERE EXTRACT('hour' FROM timestamp) = '23';


__minute
# 匹配 datetime、time 类型字段的 minute，范围 0-59
Event.objects.filter(timestamp__minute=29)
# --&amp;gt; SELECT ... WHERE EXTRACT('minute' FROM timestamp) = '29';

__second
# datetime、time 类型字段相关的，看不太懂
Event.objects.filter(timestamp__second=31)
# --&amp;gt; SELECT ... WHERE EXTRACT('second' FROM timestamp) = '31';
# 文档：
# For datetime and time fields, an exact second match. Allows chaining additional field lookups. Takes an integer between 0 and 59.
# For datetime fields, when USE_TZ is True, values are converted to the current time zone before filtering.&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义字段查找custom-field-lookups&quot;&gt;自定义字段查找（custom field-lookups）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一般官方提供的这些就已经完全够用了，真的要自定义了再去文档里看吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每个翻译文档后面都写出来，方便查看&lt;/p&gt;
&lt;p&gt;后续再整合到一篇博客上，可以附上出现这个单词的整句话，翻译出来，这个学习英语的实际意义会更加明确且有效，积累看文档要用到的单词&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;lookuptype      查找类型
refine          细分、精细化（缩小范围）
brand-new       崭新的
in no way       绝对不
separate        独立的...
stored          存储
reuse           重用
an additional criteria      附加条件
the act of      ...的行为
involve         涉及
stack ... together      将...叠加在一起
evaluated       （检查，评估？--&amp;gt; 推测是 遍历、取值，翻译成取值好像更合适一点）
alias           别名&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;保存外键字段那里，可以直接给外键对象赋值一个对象（blog 对象 --&amp;gt; blog 属性）&lt;/p&gt;
&lt;p&gt;cache 机制&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Sep 2019 16:39:00 +0000</pubDate>
<dc:creator>suwanbin</dc:creator>
<og:description>[TOC] 本文将翻译 django 官网的 模型层的 'QuerySet 章节' 文档版本：1.11 Making queries 进行查询 一旦你创建了 数据表模型类，django 会自动给你一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suwanbin/p/11570151.html</dc:identifier>
</item>
<item>
<title>构建企业级数据湖？Azure Data Lake Storage Gen2实战体验（中） - 云间拾遗</title>
<link>http://www.cnblogs.com/yunjianshiyi/p/adls-gen2-part2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunjianshiyi/p/adls-gen2-part2.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相较传统的重量级OLAP数据仓库，“数据湖”以其数据体量大、综合成本低、支持非结构化数据、查询灵活多变等特点，受到越来越多企业的青睐，逐渐成为了现代数据平台的核心和架构范式。&lt;/p&gt;
&lt;p&gt;因此数据湖相关服务成为了云计算的发展重点之一。Azure平台早年就曾发布第一代Data Lake Storage，随后微软将它与Azure Storage进行了大力整合，于今年初正式对外发布了其第二代产品：&lt;strong&gt;Azure Data Lake Storage Gen2&lt;/strong&gt; (下称ADLS Gen2)。ADLS Gen2的口号是“不妥协的数据湖平台，它结合了丰富的高级数据湖解决方案功能集以及 Azure Blob 存储的经济性、全球规模和企业级安全性”。&lt;/p&gt;
&lt;p&gt;全新一代的ADLS Gen2实际体验如何？在架构及特性上是否堪任大型数据湖应用的主存储呢？在&lt;a href=&quot;https://www.cnblogs.com/yunjianshiyi/p/adls-gen2-part1.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt;中，我们已对ADLS Gen2的基本操作和权限体系有了初步的了解。接下来让我们继续深入探究，尤其是关注ADLS Gen2作为存储层挂载到大数据集群后的表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ADLS Gen2体验：集群挂载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据湖存储主要适用于大数据处理的场景，所以我们选择建立一个HDInsight大数据集群来进行实验，使用Spark来访问和操作数据湖中的数据。可以看到HDInsight已经支持ADLS Gen2了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234242439-1247307086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  接下来是比较关键的存储配置环节，我们指定使用一个新建的ADLS Gen2实例hdiclusterroot来作为整个集群的存储，文件系统名为hdfs-root，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234258031-672378425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（图中我们还配置了Additional storage accounts&lt;span&gt;，用于挂载传统Blob&lt;span&gt;，之后作性能对比时会用到。此处暂不展开。）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很有意思的是上图的下半部分，它允许我们指定一个&lt;strong&gt;Identity&lt;/strong&gt;，这个Identity可以代表Spark集群的身份和访问权限。这非常关键，&lt;strong&gt;意味着集群的身份能够完美地与ADLS Gen2的权限体系对应起来，在企业级的场景中能够很好地落地对于大数据资源访问的管控&lt;/strong&gt;。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里选择了专门建立的一个spark-cluster-identity作为集群的身份。我们事先为它赋予了hdiclusterroot这个存储账号的storage blob data owner权限，以便该identity能够对数据湖中的数据进行任意操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234319298-1980948998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成其他配置后按下创建按钮，Azure会一键生成Spark集群，大约十来分钟后整个集群就进入可用状态了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234332390-1948551644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们迫不及待地SSH&lt;span&gt;登录进集群，查看其默认挂载的文件系统。尝试使用hadoop fs -ls&lt;span&gt;列出根目录下的文件信息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sshuser@hn0-cloudp:~$ hadoop fs -ls /
Found 18 items
drwxr-xr-x   - sshuser sshuser          0 2019-08-26 03:10 /HdiNotebooks
drwxr-xr-x   - sshuser sshuser          0 2019-08-26 03:29 /HdiSamples
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /ams
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /amshbase
drwxrwx-wt   - sshuser sshuser          0 2019-08-26 02:54 /app-logs
drwxr-x---   - sshuser sshuser          0 2019-09-06 07:41 /apps
drwxr-x--x   - sshuser sshuser          0 2019-08-26 02:54 /atshistory
drwxr-xr-x   - sshuser sshuser          0 2019-08-26 03:25 /custom-scriptaction-logs
drwxr-xr-x   - sshuser sshuser          0 2019-08-26 03:19 /example
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /hbase
drwxr-x--x   - sshuser sshuser          0 2019-09-06 07:41 /hdp
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /hive
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /mapred
drwxrwx-wt   - sshuser sshuser          0 2019-08-26 03:19 /mapreducestaging
drwxrwx-wt   - sshuser sshuser          0 2019-08-26 02:54 /mr-history
drwxrwx-wt   - sshuser sshuser          0 2019-08-26 03:19 /tezstaging
drwxr-x---   - sshuser sshuser          0 2019-08-26 02:54 /tmp
drwxrwx-wt   - sshuser sshuser          0 2019-09-09 02:31 /user
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将文件列表和ADLS Gen2比对，可以看到这里的“根目录”事实上就完全对应着hdiclusterroot这个数据湖实例下hdfs-root文件系统中的数据，这说明集群实现了该数据湖文件系统的挂载：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234415466-1296023071.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么，这样的远程挂载是如何实现的呢？打开集群的core-site.xml 配置文件，答案在fs.defaultFS配置节中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;abfs://hdfs-root@hdiclusterroot.dfs.core.windows.net&amp;lt;/value&amp;gt;
    &amp;lt;final&amp;gt;true&amp;lt;/final&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原来，与通常使用hdfs不同，&lt;strong&gt;集群的fs.defaultFS在创建时就被设置为了以abfs为开头的特定url&lt;/strong&gt;，该url正是指向我们的数据湖存储。这个&lt;strong&gt;ABFS&lt;/strong&gt;驱动(Azure Blob File System)是微软专门为Data Lake Storage Gen2开发，全面实现了Hadoop的FileSystem接口，为Hadoop体系和ADLS Gen2架起了沟通桥梁。&lt;/p&gt;
&lt;p&gt;为证明数据湖文件系统能够正常工作，我们来运行一个经典的WordCount程序。笔者使用AzCopy往数据湖中上传了一本小说《双城记》 (&lt;span&gt;&lt;em&gt;ATaleOfTwoCities.txt&lt;/em&gt;)，然后到HDInsight集群自带的Jupyter Notebook里通过Scala脚本运用Spark来进行词频统计：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201909/1694308-20190922234449903-245791843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Great! 我们的Spark on ADLS Gen2实验完美运行，过程如丝般顺滑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Azure Data Lake Storage Gen2是微软Azure全新一代的大数据存储产品，专为企业级数据湖类应用所构建。它继承了Azure Blob Storage易于使用、成本低廉的特点，同时又加入了目录层次结构、细粒度权限控制等企业级特性。&lt;/p&gt;
&lt;p&gt;作为ADLS Gen2系列的第二篇，本文主要实践了大数据集群挂载ADLS Gen2作为主存储的场景，&lt;strong&gt;在证明ADLS Gen2具备良好Hadoop生态兼容性的同时，也体验了与传统HDFS不同的存储计算分离架构&lt;/strong&gt;。该种架构由于可独立扩展计算和存储部分，非常适合云端特点，正受到越来越多的欢迎。后续我们还将探索ADLS Gen2的更多特性，敬请关注。&lt;/p&gt;
&lt;p&gt;关联阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yunjianshiyi/p/adls-gen2-part1.html&quot; target=&quot;_blank&quot;&gt;构建企业级数据湖？Azure Data Lake Storage Gen2实战体验（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“云间拾遗”专注于从用户视角介绍云计算产品与技术，坚持以实操体验为核心输出内容，同时结合产品逻辑对应用场景进行深度解读。欢迎扫描下方二维码关注“云间拾遗”微信公众号，或订阅本博客。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694308/201906/1694308-20190616155946132-1448065740.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Sep 2019 16:28:00 +0000</pubDate>
<dc:creator>云间拾遗</dc:creator>
<og:description>ADLS Gen2是Azure上面向大数据分析的全新一代存储基础设施。它能够在现代数据湖架构中扮演怎样的关键角色呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yunjianshiyi/p/adls-gen2-part2.html</dc:identifier>
</item>
</channel>
</rss>