<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>5 个 Git 工作流，改善你的开发流程 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13524162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13524162.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200818161317199-1015274632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;我还没有遇到过一个开发人员，在查看 Git 分支合并的冲突信息时不抓耳挠腮。&lt;/p&gt;
&lt;p&gt;解决 Git 合并冲突是每个开发人员都讨厌的事情之一，尤其是当你准备进行生产环境部署时！&lt;/p&gt;
&lt;p&gt;正确的设置 Git 工作流可以改善你的 &lt;a href=&quot;https://zepel.io/blog/simple-software-development-workflow/&quot;&gt;开发流程&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;当然，拥有正确的 Git 工作流并不能解决你的所有问题。但这是朝正确方向迈出的一步。毕竟，由于每个团队都是远程工作的，在不破坏代码库的情况下共同开发产品功能是非常重要的。&lt;/p&gt;
&lt;p&gt;如何设置 Git 工作流取决于你正在开发的项目、团队的发布计划、团队的规模等等！&lt;/p&gt;
&lt;p&gt;在本文中，我们将向你介绍 5 种不同的 Git 工作流，它们的优点，缺点以及使用它们的时机。让我们开始吧！&lt;/p&gt;
&lt;h2 id=&quot;1-基本的-git-工作流&quot;&gt;1. 基本的 Git 工作流&lt;/h2&gt;
&lt;p&gt;最基本的 Git 工作流是只有一个分支 - master 分支的模式。开发人员直接提交 master 分支并使用它来部署到预发布和生产环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200818161329729-796929090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为基本的 Git 工作流，所有提交都直接添加到 master 分支。&lt;/p&gt;
&lt;p&gt;通常不建议使用此工作流，除非你正在开发一个 side 项目并且希望快速开始。&lt;/p&gt;
&lt;p&gt;由于只有一个分支，因此这里实际上没有任何流程。这样一来，你就可以轻松开始使用 Git。但是，使用此工作流时需要记住它的一些缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在代码上进行协作将导致多种冲突。&lt;/li&gt;
&lt;li&gt;生产环境出现 bug 的概率会大增。&lt;/li&gt;
&lt;li&gt;维护干净的代码将更加困难。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;2-git-功能分支工作流&quot;&gt;2. Git 功能分支工作流&lt;/h2&gt;
&lt;p&gt;当你有多个开发人员在同一个代码库上工作时，Git 功能分支工作流将成为必选项。&lt;/p&gt;
&lt;p&gt;假设你有一个正在开发一项新功能的开发人员。另一个开发人员正在开发第二个功能。现在，如果两个开发人员都向同一个分支提交代码，这将使代码库陷入混乱，并产生大量冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200818161338583-1267594128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为具有功能分支的 Git 工作流模型。&lt;/p&gt;
&lt;p&gt;为避免这种情况，两个开发人员可以分别从 master 分支创建两个单独的分支，并分别开发其负责的功能。完成功能后，他们可以将各自的分支合并到 master 分支，然后进行部署，而不必等待对方的功能开发完成。&lt;/p&gt;
&lt;p&gt;使用此工作流的优点是，Git 功能分支工作流使你可以在代码上进行协作，而不必担心代码冲突。&lt;/p&gt;
&lt;h2 id=&quot;3-带有-develop-分支的-git-功能分支工作流&quot;&gt;3. 带有 Develop 分支的 Git 功能分支工作流&lt;/h2&gt;
&lt;p&gt;此工作流是开发团队中比较流行的工作流之一。它与 Git 功能分支工作流相似，但它的 develop 分支与 master 分支并行存在。&lt;/p&gt;
&lt;p&gt;在此工作流中，master 分支始终代表生产环境的状态。每当团队想要部署代码到生产环境时，他们都会部署 master 分支。&lt;/p&gt;
&lt;p&gt;Develop 分支代表针对下一版本的最新交付的代码。开发人员从 develop 分支创建新分支，并开发新功能。功能开发完毕后，将对其进行测试，与 develop 分支合并，在合并了其他功能分支的情况下使用 develop 分支的代码进行测试，然后与 master 分支合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200818161349949-489956003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为具有 develop 分支的 Git 功能分支工作流模型。&lt;/p&gt;
&lt;p&gt;此工作流的优点是，它使团队能够一致地合并所有新功能，在预发布阶段对其进行测试并部署到生产环境中。尽管这种工作流让代码维护变得更加容易，但是对于某些团队来说，这样做可能会感到有些疲倦，因为频繁的 Git 操作可能会让你感到乏味。&lt;/p&gt;
&lt;h2 id=&quot;4-gitflow-工作流&quot;&gt;4. Gitflow 工作流&lt;/h2&gt;
&lt;p&gt;Gitflow 工作流与我们之前讨论的工作流非常相似，我们将它们与其他两个分支（ release 分支和 hot-fix 分支）结合使用。&lt;/p&gt;
&lt;h3 id=&quot;41-hot-fix-分支&quot;&gt;4.1 Hot-Fix 分支&lt;/h3&gt;
&lt;p&gt;Hot-fix 分支是唯一一个从 master 分支创建的分支，并且直接合并到 master 分支而不是 develop 分支。仅在必须快速修复生产环境问题时使用。该分支的一个优点是，它使你可以快速修复并部署生产环境的问题，而无需中断其他人的工作流，也不必等待下一个发布周期。&lt;/p&gt;
&lt;p&gt;将修复合并到 master 分支并进行部署后，应将其合并到 develop 和当前的 release 分支中。这样做是为了确保任何从 develop 分支创建新功能分支的人都具有最新代码。&lt;/p&gt;
&lt;h3 id=&quot;42-release-分支&quot;&gt;4.2 Release 分支&lt;/h3&gt;
&lt;p&gt;在将所有准备发布的功能的代码成功合并到 develop 分支之后，就可以从 develop 分支创建 release 分支了。&lt;/p&gt;
&lt;p&gt;Release 分支不包含新功能相关的代码。仅将与发布相关的代码添加到 release 分支。例如，与此版本相关的文档，错误修复和其他关联任务才能添加到此分支。&lt;/p&gt;
&lt;p&gt;一旦将此分支与 master 分支合并并部署到生产环境后，它也将被合并回 develop 分支中，以便之后从 develop 分支创建新功能分支时，新的分支能够具有最新代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200818161400164-1833173904.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为具有 hot-fix 和 release 分支的 Gitflow 工作流模型&lt;/p&gt;
&lt;p&gt;此工作流由 &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;Vincent Driessen&lt;/a&gt; 首次发布并广受欢迎，已被具有预定发布周期的组织广泛使用。&lt;/p&gt;
&lt;p&gt;由于 git-flow 是对 Git 的包装，因此你可以为当前代码库安装 git-flow。git-flow 非常简单，除了为你创建分支外，它不会更改代码库中的任何内容。&lt;/p&gt;
&lt;p&gt;要在 Mac 机器上安装 ，请在终端中执行 &lt;code&gt;brew install git-flow&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;要在 Windows 机器上安装，你需要 &lt;a href=&quot;https://git-scm.com/download/win&quot;&gt;下载并安装 git-flow&lt;/a&gt; 。安装完成后，运行 &lt;code&gt;git flow init&lt;/code&gt; 命令，就可以在项目中使用它了。&lt;/p&gt;
&lt;h2 id=&quot;5-git-fork-工作流&quot;&gt;5. Git Fork 工作流&lt;/h2&gt;
&lt;p&gt;Fork 工作流在使用开源软件的团队中很流行。&lt;/p&gt;
&lt;p&gt;该流程通常如下所示：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发人员 fork 开源软件的官方代码库。在他们的帐户中创建此代码库的副本。&lt;/li&gt;
&lt;li&gt;然后，开发人员将代码库从其帐户克隆到本地系统。&lt;/li&gt;
&lt;li&gt;官方代码库的远端源已添加到克隆到本地系统的代码库中。&lt;/li&gt;
&lt;li&gt;开发人员创建一个新的功能分支，该分支将在其本地系统中创建，进行更改并提交。&lt;/li&gt;
&lt;li&gt;这些更改以及分支将被推送到其帐户上开发人员的代码库副本。&lt;/li&gt;
&lt;li&gt;从该新功能分支创建一个 pull request，提交到官方代码库。&lt;/li&gt;
&lt;li&gt;官方代码库的维护者检查 pull request 中的修改并批准将这些修改合并到官方代码库中。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;你自己的工作流！&quot;&gt;你自己的工作流！&lt;/h2&gt;
&lt;p&gt;我在本文中描述的 Git 工作流是一些在开发团队中非常流行和最佳的工作流的示例。也有一些团队为预发布创建分支，并且该分支非常适合他们。所以你可以参考这些工作流，然后创建自己的 Git 工作流。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文使用免费文档翻译工具 &lt;strong&gt;Breword&lt;/strong&gt; 进行翻译，它支持：机器预翻译、可视化编辑器、协作翻译、审校、一键生成文档网站、自动监测文档更新、导出等。让翻译工作变得更加简单、高效、可维护，快去试试吧！&lt;/p&gt;
&lt;blockquote readability=&quot;2.0731707317073&quot;&gt;
&lt;p&gt;breword 官网：&lt;a href=&quot;https://www.breword.com/&quot;&gt;https://www.breword.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143823578-1303441549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译开源项目文档、文章都是为开源社区做贡献（题材：GitHub、编程、程序员）​，欢迎热爱技术和开源的小伙伴加入 HG 推出的译文亦舞系列的翻译中来，可添加微信号：HelloGitHub（备注：翻译）。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 00:34:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>原文地址：5 Git workflows you can use to deliver better code and improve your development process 原文作者：Vi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13524162.html</dc:identifier>
</item>
<item>
<title>打破国外垄断，开发中国人自己的编程语言（2）：使用监听器实现计算器 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/13539090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/13539090.html</guid>
<description>&lt;p&gt;本文详细讲解如何用Listener方式实现一个可以计算表达式的程序，该程序不仅可以计算表达式，也可以识别表达式的错误，如果某一个表达式出错，那么该表达式不会输出任何结果。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;113.66656667167&quot;&gt;
&lt;p&gt;上一篇：&lt;a href=&quot;https://www.cnblogs.com/nokiaguy/p/13385386.html&quot; target=&quot;_blank&quot;&gt;实现可以解析表达式的计算器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;本文已经同步到公众号「&lt;span&gt;极客起源&lt;/span&gt;」，输入&lt;span&gt;379404&lt;/span&gt;开始学习！&lt;/p&gt;

&lt;p&gt;本文是&lt;span&gt;《打破国外垄断，开发中国人自己的编程语言》&lt;/span&gt;系列文章的第1篇。本系列文章的主要目的是教大家学会如何从零开始设计一种编程语言（marvel语言），并使用marvel语言开发一些真实的项目，如移动App、Web应用等。marvel语言可以通过下面3种方式运行：&lt;/p&gt;
&lt;p&gt;1. 解释执行&lt;/p&gt;
&lt;p&gt;2. 编译成Java Bytecode，利用JVM执行&lt;/p&gt;
&lt;p&gt;3. 编译成二进制文件，本地执行（基于LLVM）&lt;/p&gt;

&lt;div readability=&quot;99.5&quot;&gt;
&lt;p&gt;本文详细讲解如何用Listener方式实现一个可以计算表达式的程序，该程序不仅可以计算表达式，也可以识别表达式的错误，如果某一个表达式出错，那么该表达式不会输出任何结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Visitor与Listener&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上一篇文章中使用Antlr和Visitor实现了一个可以计算表达式的程序MarvelCalc。这个程序非常简单，相当于Antlr的HelloWorld。不过Antlr除了Visitor方式外，还支持Listener方式，也就是监听器方式。不管是哪种方式，其目的都是遍历AST（抽象语法树），只是Visitor方式需要显式访问子节点（通过visit方法访问），例如，下面的代码访问了MulDiv的两个子节点，也就是MulDiv的左右操作数（ctx.expr(0)和ctx.expr(1)）。&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; expr op=('*'|'/') expr      # MulDiv&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer visitMulDiv(CalcParser.MulDivContext ctx) {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; left = visit(ctx.expr(0));          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问MulDiv的左操作数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; right = visit(ctx.expr(1));         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问MulDiv的右操作数&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; ( ctx.op.getType() == CalcParser.MUL ) &lt;span&gt;return&lt;/span&gt; left *&lt;span&gt; right;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; left /&lt;span&gt; right; 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;而Listener方式是由系统自动访问当前节点的子节点的，并不需要显式访问子节点。而且Listener可以拦截当前节点的开始处理和结束处理动作。开始处理动作的事件方法以enter开头，结束处理动作的事件方法以exit开头。例如，处理MulDiv动作时，会生成两个事件方法：enterMulDiv和exitMulDiv，分别表示开始处理MulDiv和结束处理MulDiv，这两个方法的代码如下：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterMulDiv(CalcParser.MulDivContext ctx) {
}
@Override 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitMulDiv(CalcParser.MulDivContext ctx) {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

 那么开始处理动作和结束处理动作有什么区别呢？如果是原子表达式（内部不包含其他表达式的表达式），如id、数值等，这两个事件方法没什么不同的（用哪一个处理表达式都可以）。但如果是非原子表达式，就要考虑下使用enter还是exit了。例如，下面的表达式：&lt;/div&gt;

&lt;div id=&quot;1860-1597842392848&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
3 * (20 / x * 43)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这个表达式明显是非原子的。编译器会从左向右扫描整个表达式，当扫描到第一个乘号（*）时，会将右侧的所有内容（20 / x * 43）当做一个整体处理，这就会第一次调用enterMulDiv方法和exitMulDiv方法。只不过在调用enterMulDiv方法后，还会做很多其他的工作，最后才会调用exitMulDiv方法。那么中间要做什么工作呢？当然是处理表达式(20 / x * 43)了。由于这个表达式中有一个变量x，所以在扫描到x时，需要搜索该变量是否存在，如果存在，需要提取该变量的值。也就是说，在第一次调用enterMulDiv方法时还没有处理这个变量x，如果在enterMulDiv方法中要计算整个表达式的值显然是不可能的（因为x的值还没有确定），所以正确的做法应该是在exitMulDiv方法中计算整个表达式的值，因为在该方法被调用时，整个表达式的每一个子表达式的值都已经计算完了。&lt;/p&gt;

&lt;p&gt;enterXxx和exitXxx方法也经常被用于处理作用域，例如，在扫描到下面的函数时， 在该函数对应的enterXxx方法中会将当前作用域切换到myfun函数（通常用Stack处理），而在exitXxx方法中，会恢复myfun函数的parent作用域。类、条件语句、循环语句也同样涉及到作用域的问题。关于作用域的问题，在后面的文章中会详细介绍作用域的实现方法。&lt;/p&gt;
&lt;div id=&quot;6328-1597842980528&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; myfun() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;从前面的介绍可知，Listener比Visitor更灵活，Listener也是我推荐的遍历AST的方式，后面的文章也基本上使用Listener的方式实现编译器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Listener对应的接口和基类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在回到本文的主题上来，本文的目的是使用Listener的方式取代Visitor的方式实现计算器。在编译Calc.g4时，除了生成CalcVisitor.java和CalcBaseVisitor.java，还生成了另外两个文件：CalcListener.java和CalcBaseListener.java。其中CalcListener.java文件是Listener的接口文件，接口中的方法会根据Calc.g4文件中的产生式生成，该文件的代码如下：&lt;/p&gt;

&lt;div id=&quot;8053-1597844239205&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.tree.ParseTreeListener;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; CalcListener &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParseTreeListener {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterProg(CalcParser.ProgContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitProg(CalcParser.ProgContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterPrintExpr(CalcParser.PrintExprContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitPrintExpr(CalcParser.PrintExprContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterAssign(CalcParser.AssignContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitAssign(CalcParser.AssignContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterBlank(CalcParser.BlankContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitBlank(CalcParser.BlankContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterParens(CalcParser.ParensContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitParens(CalcParser.ParensContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterMulDiv(CalcParser.MulDivContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitMulDiv(CalcParser.MulDivContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterAddSub(CalcParser.AddSubContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitAddSub(CalcParser.AddSubContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterId(CalcParser.IdContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitId(CalcParser.IdContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterInt(CalcParser.IntContext ctx);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitInt(CalcParser.IntContext ctx);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;通常来讲，并不需要实现CalcListener接口中的所有方法，所以antlr还为我们生成了一个默认实现类CalcBaseListener，该类位于CalcBaseListener.java文件中。CalcListener接口的每一个方法都在CalcBaseListener类中提供了一个空实现，所以使用Listener方式遍历AST，只需要从CalcBaseListener类继承，并且覆盖必要的方法即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 用Listener方式实现可计算器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在创建一个MyCalcParser.java文件，并在该文件中编写一个名为MyCalcParser的空类，代码如下：&lt;/p&gt;
&lt;div id=&quot;1465-1597844698682&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyCalcParser  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt;  CalcBaseListener{
    ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现在的问题是，在MyCalcParser类中到底要覆盖CalcBaseListener中的哪一个方法，而且如何实现这些方法呢？&lt;/p&gt;

&lt;p&gt;要回答这个问题，就要先分析一下上一篇文章中编写的EvalVisitor类的代码了。其实在EvalVisitor中覆盖了哪一个动作对应的方法，在MyCalcParser类中也同样需要覆盖该动作对应的方法，区别只是使用enterXxx，还是使用exitXxx，或是都使用。&lt;/p&gt;

&lt;p&gt;现在将EvalVisitor类的关键点提出来：&lt;/p&gt;
&lt;p&gt;（1） 在EvalVisitor类中有一个名为memory的Map对象，用来保存变量的值，这在Listener中同样需要；&lt;/p&gt;
&lt;p&gt;（2）在EvalVisitor类中有一个error变量，用来标识分析的过程中是否有错误，在Listener中同样需要；&lt;/p&gt;
&lt;p&gt;（3）每一个visitXxx方法都有返回值，其实这个返回值是向上一层节点传递的值。而Listener中的方法并没有返回值，但仍然需要将值向上一层节点传递，所以需要想其他的方式实现向上传值；&lt;/p&gt;


&lt;p&gt;那么为什么要向上传值呢？先来举一个例子，看下面的表达式：&lt;/p&gt;



&lt;p&gt;这是一个乘法表达式，编译器对这个表达式扫描时，会先识别两个整数（4和5），这两个整数是两个原子表达式。如果使用Listener的方式，需要在这两个整数对应的enterInt方法（exitInt方法也可以）中将'4'和'5'转换为整数，这是因为不管值是什么类型，编译器读上来的都是字符串，所以需要进行类型转换。&lt;/p&gt;

&lt;p&gt;包含4和5的表达式是MulDiv，对应的动作方法是exitMulDiv（不能用enterMulDiv，因为这时4和5还没有扫描到）。在exitMulDiv方法中要获取乘号（*）左右两个操作数的值（ctx.expr(0)和ctx.expr(1)）。而这两个操作数的值在enterInt方法中已经获取了，我们要做的只是将获取的值传递给上一层表达式，也就是MulDiv表达式。向上一层传值的方法很多，这里采用一个我非常推荐的方式，通过用一个Map对象保存所有需要传递的值，key就是上一层节点的ParseTree对象（每一个enterXxx和exitXxx方法的ctx参数的类型都实现了ParseTree接口），而value则是待传递的值，可以使用下面的方式定义这个Map对象。&lt;/p&gt;

&lt;div id=&quot;5370-1597845753046&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; Map&amp;lt;ParseTree,Integer&amp;gt; values = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;同时还需要两个方法来设置和获取值，分别是setValue和getValue，代码如下：&lt;/p&gt;
&lt;div id=&quot;7025-1597845825622&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setValue(ParseTree node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
    values.put(node,value);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue(ParseTree node) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values.get(node);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;下面给出MyCalcParser类的完整代码：&lt;/p&gt;
&lt;div id=&quot;8078-1597845901019&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.tree.ParseTree;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyCalcParser  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt;  CalcBaseListener{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;ParseTree,Integer&amp;gt; values = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存向上一层节点传递的值&lt;/span&gt;
    Map&amp;lt;String, Integer&amp;gt; memory = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt;();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于保存变量的值&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; error = &lt;span&gt;false&lt;/span&gt;;                                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于标识分析的过程是否出错
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setValue(ParseTree node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
        values.put(node,value);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue(ParseTree node) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values.get(node);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }

    }
    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterPrintExpr(CalcParser.PrintExprContext ctx) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当开始处理表达式时，默认没有错误&lt;/span&gt;
        error = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitPrintExpr(CalcParser.PrintExprContext ctx) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;error) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有在没有错误的情况下，才会输出表达式的值 &lt;/span&gt;
&lt;span&gt;            System.out.println(getValue(ctx.expr()));
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须要放在exitAssign里&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitAssign(CalcParser.AssignContext ctx) {
        String id &lt;/span&gt;= ctx.ID().getText();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取变量名&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; value = getValue(ctx.expr());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取右侧表达式的值&lt;/span&gt;
        memory.put(id, value);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存变量&lt;/span&gt;
&lt;span&gt;    }    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须在exitParens中完成&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitParens(CalcParser.ParensContext ctx) {
        setValue(ctx,getValue(ctx.expr()));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算乘法和除法（必须在exitMulDiv中完成）&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitMulDiv(CalcParser.MulDivContext ctx) {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; left =  getValue(ctx.expr(0));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取左操作数的值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; right = getValue(ctx.expr(1));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取右操作数的值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( ctx.op.getType() ==&lt;span&gt; CalcParser.MUL )
            setValue(ctx,left &lt;/span&gt;* right);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向上传递值&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            setValue(ctx,left &lt;/span&gt;/ right);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向上传递值&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算加法和减法（必须在exitAddSub中完成）&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitAddSub(CalcParser.AddSubContext ctx) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; left =  getValue(ctx.expr(0));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取左操作数的值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; right = getValue(ctx.expr(1));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取右操作数的值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( ctx.op.getType() ==&lt;span&gt; CalcParser.ADD )
            setValue(ctx,left &lt;/span&gt;+&lt;span&gt; right);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            setValue(ctx,left &lt;/span&gt;-&lt;span&gt; right);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在enterId方法中也可以&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exitId(CalcParser.IdContext ctx) {
        String id &lt;/span&gt;=&lt;span&gt; ctx.ID().getText();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( memory.containsKey(id) ) {
            setValue(ctx,memory.get(id));      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将变量的值向上传递&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量不存在，输出错误信息（包括行和列）， &lt;/span&gt;
            System.err.println(String.format(&quot;行：%d, 列：%d, 变量&amp;lt;%s&amp;gt; 不存在！&quot;,ctx.getStart().getLine(),ctx.getStart().getCharPositionInLine() + 1&lt;span&gt;,  id));
            error &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理int类型的值&lt;/span&gt;
    @Override &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterInt(CalcParser.IntContext ctx) {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; Integer.valueOf(ctx.getText());
        setValue(ctx, value);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将整数值向上传递&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现在编写用于遍历AST和计算结果的MarvelListenerCalc类，代码如下：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.CharStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.CharStreams;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.CommonTokenStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.tree.ParseTree;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.antlr.v4.runtime.tree.ParseTreeWalker;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MarvelListenerCalc {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception  {
        String inputFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( args.length&amp;gt;0&lt;span&gt; ) {
            inputFile &lt;/span&gt;= args[0&lt;span&gt;];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;语法格式：MarvelCalc inputfile&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        InputStream is &lt;/span&gt;=&lt;span&gt; System.in;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( inputFile!=&lt;span&gt;null&lt;/span&gt; ) is = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(inputFile);


        CharStream input &lt;/span&gt;=&lt;span&gt; CharStreams.fromStream(is);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建词法分析器&lt;/span&gt;
        CalcLexer lexer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalcLexer(input);
        CommonTokenStream tokens &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommonTokenStream(lexer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
        CalcParser parser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalcParser(tokens);
        ParseTree tree &lt;/span&gt;=&lt;span&gt;  parser.prog();
        MyCalcParser calc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyCalcParser();
        ParseTreeWalker walker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParseTreeWalker();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始遍历AST&lt;/span&gt;
&lt;span&gt;        walker.walk(calc, tree);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
 &lt;/div&gt;

&lt;p&gt;我们仍然使用上一篇文章使用的测试用例：&lt;/p&gt;

&lt;div id=&quot;4632-1597846417104&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1+3 * 4 - 12 /6&lt;span&gt;;
x &lt;/span&gt;= 40&lt;span&gt;;
y &lt;/span&gt;= 13&lt;span&gt;;
x &lt;/span&gt;* y + 20 - 42/6&lt;span&gt;;
z &lt;/span&gt;= 12&lt;span&gt;;
&lt;/span&gt;4&lt;span&gt;;
x &lt;/span&gt;+ 41 * z - y;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;运行MarvelListenerCalc的执行结果如下图所示：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202008/32818-20200821082311261-1528415109.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;433&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/0B00AEFB331944619126C97F19221C6A&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;本文实现的程序还支持错误捕捉，例如，将最后一个表达式的变量x改成xx，再执行程序，就会抛出异常，出错的表达式没有输出任何值，异常会指示出错的位置（行和列），如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/22ED0D795A9D4C37B645E8B3BEF828B5&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202008/32818-20200821082332982-155277063.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;337&quot; loading=&quot;lazy&quot;/&gt;

&lt;/div&gt;
&lt;p&gt;请关注微信公众号「&lt;span&gt;极客起源&lt;/span&gt;」，更多精彩内容期待您的光临！&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202007/32818-20200727144809192-1450907133.jpg&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;315&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 21 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>本文详细讲解如何用Listener方式实现一个可以计算表达式的程序，该程序不仅可以计算表达式，也可以识别表达式的错误，如果某一个表达式出错，那么该表达式不会输出任何结果。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nokiaguy/p/13539090.html</dc:identifier>
</item>
<item>
<title>.Net Core中的诊断日志DiagnosticSource讲解 - yi念之间</title>
<link>http://www.cnblogs.com/wucy/p/13532534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucy/p/13532534.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;    近期由于需要进行分布式链路跟踪系统的技术选型，所以一直在研究链路跟踪相关的框架。作为能在.Net Core中使用的APM，SkyWalking自然成为了首选。&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot;&gt;SkyAPM-dotnet&lt;/a&gt;是SkyWalking在.Net Core端的探针实现，其主要的收集日志的手段就是基于DiagnosticSource来进行诊断跟踪的。不得不说SkyAPM-dotnet的设计还是非常优秀的，它本身定义了一套非常规范的标准，而且提供了非常良好的扩展性，虽然框架本身可支持的采集端有限，但是基于这套标准扩展起来还是非常方便的。&lt;/p&gt;
&lt;h3 id=&quot;概念介绍&quot;&gt;概念介绍&lt;/h3&gt;
&lt;p&gt;    关于DiagnosticSource它本身是一个基于发布订阅模式的工作模式，由于它本身的实现方式是异步的，所以不仅仅可以把它用到日志上，还可以用它实现异步操作，或者用它简化实现发布订阅的功能。DiagnosticSource本身是一个抽象类，我们最常用到的是它的子类DiagnosticListener，通过DiagnosticSource的Write方法实现发布一条有具体名称的消息，然后通过IObserver去订阅消息。DiagnosticListener可以实现不同的实例，每个实例可以有自己的名称，每个实例还可以发布不同名称的消息，好比一个在写代码的时候我们可以定义多个程序集，一个程序集下面可以包含多个命名空间。&lt;/p&gt;
&lt;h3 id=&quot;使用方式&quot;&gt;使用方式&lt;/h3&gt;
&lt;p&gt;上面我们大致的介绍了关于DiagnosticSource相关的概念，相信大家已经有了初步的了解，接下来我们就来看一下在代码中如何使用DiagnosticSource，还说到了它一个重要的子类DiagnosticListener，基本上关于DiagnosticSource的工作方式都是围绕着DiagnosticListener实现的，首先我们来看一下如何发布一条消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//声明DiagnosticListener并命名为MyTest
DiagnosticSource diagnosticSource = new DiagnosticListener(&quot;MyTest&quot;);
string pubName = &quot;MyTest.Log&quot;;
//判断是否存在MyTest.Log的订阅者
if (diagnosticSource.IsEnabled(pubName))
{
    //发送名为MyTest.Log的消息，包含Name，Address两个属性
    diagnosticSource.Write(pubName, new { Name = &quot;old王&quot;, Address=&quot;隔壁&quot; });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，我们就可以完成针对消息的发布，其中用到了IsEnabled方法，这个方法是在实际使用DiagnosticSource过程中比较常用的方法，用于判断是够存在对应名称的消费者，这样可以有效的避免发送消息浪费。&lt;br/&gt;发送相对还是比较简单的，接下来我们看一下如何订阅发布的消息。上面我们提到了订阅消息是通过IObserver接口实现的，IObserver代表了订阅者。虽然我们通过DiagnosticSource去发布消息，但是真正描述发布者身份的是IObservable接口，IObservable的唯一方法Subscribe是用来注册订阅者IObserver，但是默认系统并没有为我们提供一个具体的实现类，所以我们需要定义一个IObserver订阅者的实现类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class MyObserver&amp;lt;T&amp;gt;:IObserver&amp;lt;T&amp;gt;
{
    private Action&amp;lt;T&amp;gt; _next;
    public MyObserver(Action&amp;lt;T&amp;gt; next)
    {
        _next = next;
    }

    public void OnCompleted()
    {
    }

    public void OnError(Exception error)
    {
    }

    public void OnNext(T value) =&amp;gt; _next(value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了具体的订阅者实现类，我们就可以为发布者注册订阅者了,同样是使用DiagnosticListener，个人认为虽然操作都是通过DiagnosticSource来完成的，但它只是一个外观类，但是并不能直接描述发布者和订阅者本身。接下来我们看一下具体实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//AllListeners获取所有发布者，Subscribe为发布者注册订阅者MyObserver
DiagnosticListener.AllListeners.Subscribe(new MyObserver&amp;lt;DiagnosticListener&amp;gt;(listener =&amp;gt;
{
    //判断发布者的名字
    if (listener.Name == &quot;MyTest&quot;)
    {
        //获取订阅信息
        listener.Subscribe(new MyObserver&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;(listenerData =&amp;gt;
        {
            System.Console.WriteLine($&quot;监听名称:{listenerData.Key}&quot;);
            dynamic data = listenerData.Value;
            //打印发布的消息
            System.Console.WriteLine($&quot;获取的信息为:{data.Name}的地址是{data.Address}&quot;);
        }));

        listener.SubscribeWithAdapter(new MyDiagnosticListener());
    }
}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现可总结为两步，首先为发布者注册订阅者，然后获取订阅者获取发布的消息。这种写法还是比较复杂的，首先需要实现订阅者类，然后通过一系列复杂的操作，才能完成消息订阅，然后还要自己获取发布的消息，解析具体的消息值，总之操作流程非常繁琐。微软似乎也意识到了这个问题，于是乎给我提供了一个关于实现订阅者的便利方法，编辑项目文件引入DiagnosticAdapter包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.Extensions.DiagnosticAdapter&quot; Version=&quot;3.1.7&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过包管理器直接搜索安装，道路千万条都是通罗马。通过这个包解决了我们两个痛点，首先是关于订阅者的注册难问题，其次解决了关于发布消息解析难的痛点。我们可以直接订阅一个适配类来充当订阅者的载体，其次我们可以定义方法模拟订阅去订阅消息，而这个方法的参数就是我们发布的消息内容。说了这么多，不如直接上代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class MyDiagnosticListener
{
    //发布的消息主题名称
    [DiagnosticName(&quot;MyTest.Log&quot;)]
    //发布的消息参数名称和发布的属性名称要一致
    public void MyLog(string name,string address)
    {
        System.Console.WriteLine($&quot;监听名称:MyTest.Log&quot;);
        System.Console.WriteLine($&quot;获取的信息为:{name}的地址是{address}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以随便定义一个类来充当订阅者载体,类里面可以自定义方法来实现获取解析消息的实现。想要让方法可以订阅消息，需要在方法上声明DiagnosticName，然后名称就是你要订阅消息的名称，而方法的参数就是你发布消息的字段属性名称，&lt;span&gt;这里需要注意的是订阅的参数名称需要和发布声明属性名称一致。&lt;/span&gt;&lt;br/&gt;然后我们直接可以通过这个类去接收订阅消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DiagnosticListener.AllListeners.Subscribe(new MyObserver&amp;lt;DiagnosticListener&amp;gt;(listener =&amp;gt;
{
    if (listener.Name == &quot;MyTest&quot;)
    {
        //适配订阅
        listener.SubscribeWithAdapter(new MyDiagnosticListener());
    }
}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能你觉得这样还是不够好，因为还是没有脱离需要自定义订阅者，这里还有更简洁的实现方式。细心的你可能已经发现了SubscribeWithAdapter是DiagnosticListener的扩展方法，而我们声明DiagnosticSource就是使用的DiagnosticListener实例，所以上面的代码可以简化为一下方式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DiagnosticListener diagnosticListener = new DiagnosticListener(&quot;MyTest&quot;);
DiagnosticSource diagnosticSource = diagnosticListener;
//直接去适配订阅者
diagnosticListener.SubscribeWithAdapter(new MyDiagnosticListener());

string pubName = &quot;MyTest.Log&quot;;
if (diagnosticSource.IsEnabled(pubName))
{
    diagnosticSource.Write(pubName, new { Name = &quot;old王&quot;, Address=&quot;隔壁&quot; });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式也是我们比较推荐的使用方式，极大的节省了工作的方式，而且代码非常的简洁。但是存在唯一的不足，这种写法只能针对特定的DiagnosticListener进行订阅处理，如果你需要监听所有发布者，就需要使用DiagnosticListener.AllListeners.Subscribe的方式。&lt;/p&gt;
&lt;h3 id=&quot;dotnetcore源码中诊断日志的埋点&quot;&gt;DotNetCore源码中诊断日志的埋点&lt;/h3&gt;
&lt;p&gt;在.Net Core的源码中，微软默认在涉及到网络请求或处理请求等许多重要的节点都使用了DiagnosticListener来发布拦截的消息，接下来就罗列一些我知道的比较常见的埋点，通过这些操作我们就可以看出，诊断日志还是很便利的，而且微软在.Net Core中也非常重视它的使用。&lt;/p&gt;
&lt;h4 id=&quot;在aspnet-core中&quot;&gt;在ASP.NET Core中&lt;/h4&gt;
&lt;p&gt;当我们通过ConfigureWebHostDefaults配置Web主机的时候，程序就已经默认给我们注入了诊断名称为Microsoft.AspNetCore的DiagnosticListener和DiagnosticSource，这样我们就可以很方便的在程序中直接获取DiagnosticListener实例去发布消息或者监听发布的内部消息，具体注入逻辑位于可以去GenericWebHostBuilder类中查看[&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v3.1.7/src/Hosting/Hosting/src/GenericHost/GenericWebHostBuilder.cs#L80&quot;&gt;点击查看源码👈&lt;/a&gt;]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var listener = new DiagnosticListener(&quot;Microsoft.AspNetCore&quot;);
services.TryAddSingleton&amp;lt;DiagnosticListener&amp;gt;(listener);
services.TryAddSingleton&amp;lt;DiagnosticSource&amp;gt;(listener);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Server启动的时候传递了DiagnosticListener实例[&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v3.1.7/src/Hosting/Hosting/src/GenericHost/GenericWebHostedService.cs#L118&quot;&gt;点击查看源码👈&lt;/a&gt;]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var httpApplication = new HostingApplication(application, Logger, DiagnosticListener, HttpContextFactory);
await Server.StartAsync(httpApplication, cancellationToken);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在Server运行期间我们可以通过DiagnosticListener诊断跟踪请求相关的信息，我们可以看下在处理请求的过程中DiagnosticListener都发布了哪些消息，我们找到发送诊断跟踪的位置位于HostingApplicationDiagnostics中[&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v3.1.7/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs&quot;&gt;点击查看源码👈&lt;/a&gt;]，这事集中处理请求相关的诊断跟踪，接下来我们就大致查看一下它发布了哪些事件消息，首先找到定义发布名称的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private const string ActivityName = &quot;Microsoft.AspNetCore.Hosting.HttpRequestIn&quot;;
private const string ActivityStartKey = ActivityName + &quot;.Start&quot;;
private const string ActivityStopKey = ActivityName + &quot;.Stop&quot;;

private const string DeprecatedDiagnosticsBeginRequestKey = &quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;;
private const string DeprecatedDiagnosticsEndRequestKey = &quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;;
private const string DiagnosticsUnhandledExceptionKey = &quot;Microsoft.AspNetCore.Hosting.UnhandledException&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这些发布消息的名称我们就可以看出，在请求开始、请求进入、请求结束、请求停止、请求异常等都发布了诊断消息，我们以BeginRequest为例查看一下具体发送的消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;if (_diagnosticListener.IsEnabled(DeprecatedDiagnosticsBeginRequestKey))
{
    startTimestamp = Stopwatch.GetTimestamp();
    RecordBeginRequestDiagnostics(httpContext, startTimestamp);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到RecordBeginRequestDiagnostics方法的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[MethodImpl(MethodImplOptions.NoInlining)]
private void RecordBeginRequestDiagnostics(HttpContext httpContext, long startTimestamp)
{
    _diagnosticListener.Write(
        DeprecatedDiagnosticsBeginRequestKey,
        new
        {
            httpContext = httpContext,
            timestamp = startTimestamp
        });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这里我们可以看出在BeginRequest中诊断日志发出的消息中包含了HttpContext和开始时间戳信息，然后再来看一下请求结束发布的诊断消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[MethodImpl(MethodImplOptions.NoInlining)]
private void RecordEndRequestDiagnostics(HttpContext httpContext, long currentTimestamp)
{
    _diagnosticListener.Write(
        DeprecatedDiagnosticsEndRequestKey,
        new
        {
            httpContext = httpContext,
            timestamp = currentTimestamp
        });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过发布的这些跟踪日志我们可以获取请求信息,请求时间并且能得到输出信息和结束时间，有了这些关键信息，我们就可以监听请Asp.Net Core处理请求的情况，我们上面提到过SkyAPM-dotnet正是通过这些发出诊断跟踪日志，来实现对程序无入侵的方式来处理应用系统监控的，具体我们可以查看相关实现，我们找到订阅这些消息的地方&lt;br/&gt;[&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet/blob/master/src/SkyApm.Diagnostics.AspNetCore/HostingDiagnosticProcessor.cs&quot;&gt;点击查看源码👈&lt;/a&gt;],拿出来类的结构，大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class HostingTracingDiagnosticProcessor : ITracingDiagnosticProcessor
{
    public string ListenerName { get; } = &quot;Microsoft.AspNetCore&quot;;

    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;)]
    public void BeginRequest([Property] HttpContext httpContext)
    {
    }

    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;)]
    public void EndRequest([Property] HttpContext httpContext)
    {
    }

    [DiagnosticName(&quot;Microsoft.AspNetCore.Diagnostics.UnhandledException&quot;)]
    public void DiagnosticUnhandledException([Property] HttpContext httpContext, [Property] Exception exception)
    {
    }

    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.UnhandledException&quot;)]
    public void HostingUnhandledException([Property] HttpContext httpContext, [Property] Exception exception)
    {
    }

    //[DiagnosticName(&quot;Microsoft.AspNetCore.Mvc.BeforeAction&quot;)]
    public void BeforeAction([Property] ActionDescriptor actionDescriptor, [Property] HttpContext httpContext)
    {
    }

    //[DiagnosticName(&quot;Microsoft.AspNetCore.Mvc.AfterAction&quot;)]
    public void AfterAction([Property] ActionDescriptor actionDescriptor, [Property] HttpContext httpContext)
    {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不得不承认SkyAPM-dotnet非常巧妙的利用了系统内部发出的诊断跟踪日志，实现了对请求的处理跟踪，真的是非常优秀。&lt;/p&gt;
&lt;h4 id=&quot;在httpclient中&quot;&gt;在HttpClient中&lt;/h4&gt;
&lt;p&gt;上面我们看到的是AspNetCore处理请求的诊断日志埋点，在发出请求的HttpClient中，微软也做了埋点处理。我们在之前的文章&lt;a href=&quot;https://www.cnblogs.com/wucy/p/12964869.html&quot;&gt;.NET Core HttpClient源码探究&lt;/a&gt;中提到过HttpClient通过HttpClientHandler发送请求的，在HttpClientHandler SendAsync方法中我们可以看到如下实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;protected internal override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request,
            CancellationToken cancellationToken)
{
    return DiagnosticsHandler.IsEnabled() &amp;amp;&amp;amp; _diagnosticsHandler != null ?
        _diagnosticsHandler.SendAsync(request, cancellationToken) :
        _underlyingHandler.SendAsync(request, cancellationToken);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说如果满足DiagnosticsHandler.IsEnabled()并且_diagnosticsHandler不为空的情况下将会使用DiagnosticsHandler发送请求，关于DiagnosticsHandler.IsEnabled()的大致实现逻辑如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;if (AppContext.TryGetSwitch(&quot;System.Net.Http.EnableActivityPropagation&quot;, out bool enableActivityPropagation))
{
    return enableActivityPropagation;
}

string? envVar = Environment.GetEnvironmentVariable(&quot;DOTNET_SYSTEM_NET_HTTP_ENABLEACTIVITYPROPAGATION&quot;);
if (envVar != null &amp;amp;&amp;amp; (envVar.Equals(&quot;false&quot;, StringComparison.OrdinalIgnoreCase) || envVar.Equals(&quot;0&quot;)))
{
    return false;
}
return true;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个逻辑可以看出，默认情况下我们不做特殊处理返回的就是true，也就是说发送请求会通过DiagnosticsHandler，我们找到DiagnosticsHandler的实现[&lt;a href=&quot;https://github.com/dotnet/runtime/blob/34a9820567/src/libraries/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs#L66&quot;&gt;点击查看源码👈&lt;/a&gt;]，抽离出来SendAsyncCore方法中关于诊断跟踪的核心实现逻辑，大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DiagnosticListener diagnosticListener = new DiagnosticListener(&quot;HttpHandlerDiagnosticListener&quot;);
if (diagnosticListener.IsEnabled(&quot;System.Net.Http.Request&quot;))
{
    long timestamp = Stopwatch.GetTimestamp();
    loggingRequestId = Guid.NewGuid();
    //请求开始之前发送诊断日志
    diagnosticListener.Write(&quot;System.Net.Http.Request&quot;,new RequestData(request, loggingRequestId, timestamp));
}
HttpResponseMessage? response = null;
TaskStatus taskStatus = TaskStatus.RanToCompletion;
try
{
    response = async ?
        await base.SendAsync(request, cancellationToken).ConfigureAwait(false) :
        base.Send(request, cancellationToken);
    return response;
}
catch (OperationCanceledException)
{
    taskStatus = TaskStatus.Canceled;
    throw;
}
catch (Exception ex)
{
    taskStatus = TaskStatus.Faulted;
    if (diagnosticListener.IsEnabled(&quot;System.Net.Http.Exception&quot;))
    {  
        //如果请求出现异常发出异常消息诊断日志
        diagnosticListener.Write(&quot;System.Net.Http.Exception&quot;, new ExceptionData(ex, request));
    }
    throw;
}
finally
{
    if (activity != null)
    {
        diagnosticListener.StopActivity(activity, new ActivityStopData(response,request,taskStatus));
    }
    if (diagnosticListener.IsEnabled(&quot;System.Net.Http.Response&quot;))
    {
        long timestamp = Stopwatch.GetTimestamp();
        //得到输出结果后发送诊断日志
        diagnosticListener.Write(&quot;System.Net.Http.Response&quot;,new ResponseData(response,loggingRequestId,timestamp,taskStatus));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的思路HttpClient会在发送请求之前发出请求信息相关的诊断跟踪，会在得到相应之后发送响应相关诊断跟踪，通过这些信息我们可以捕获到由程序发出的Http请求相关的信息，从而监控请求相关的数据，我们来看一下SkyAPM-dotnet订阅Http请求相关的实现，在HttpClientTracingDiagnosticProcessor类中[&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet/blob/master/src/SkyApm.Diagnostics.HttpClient/HttpClientDiagnosticProcessor.cs&quot;&gt;点击查看源码👈&lt;/a&gt;]，抽离实现的框架大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class HttpClientTracingDiagnosticProcessor : ITracingDiagnosticProcessor
{
    public string ListenerName { get; } = &quot;HttpHandlerDiagnosticListener&quot;;

    [DiagnosticName(&quot;System.Net.Http.Request&quot;)]
    public void HttpRequest([Property(Name = &quot;Request&quot;)] HttpRequestMessage request)
    {
    }

    [DiagnosticName(&quot;System.Net.Http.Response&quot;)]
    public void HttpResponse([Property(Name = &quot;Response&quot;)] HttpResponseMessage response)
    {
    }

    [DiagnosticName(&quot;System.Net.Http.Exception&quot;)]
    public void HttpException([Property(Name = &quot;Request&quot;)] HttpRequestMessage request,
        [Property(Name = &quot;Exception&quot;)] Exception exception)
    {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里正是监听的HttpClient发出的诊断日志。假如存在系统A和系统B，系统A通过HttpClient发送请求调用Asp.Net Core系统B，通过订阅他们发出的诊断跟踪日志，而这些数据正是实现系统监控和链路跟踪重要依据。&lt;/p&gt;
&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;p&gt;    在.Net Core相关的源码中还有许多其他关于DiagnosticListener的埋点信息比如请求执行到Action的时候或者出现全局异常的时候都有类似的处理。同样在EFCore中也存在这些埋点信息，有兴趣的可以自行查阅相关源码和SkyAPM-dotnet源码，了解DiagnosticSource工作方式，以及如何通过这些信息实现APM系统。虽然SkyAPM-dotnet本身实现的框架个数有限，但是它给我们实现了良好的扩展性，我们可以通过DiagnosticSource和DiagnosticListener自行实现SkyAPM-dotnet的扩展，比如你可以扩展Redis MongoDb等其它中间件。比如SkyApm.Diagnostics.CAP是CAP纳入SkyAPM中程序包，正是杨总参与了相关代码的实现。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;    DiagnosticSource诊断跟踪涉及到的概念虽然不是很多，但是在.Net Core相关的框架中使用的还是非常广泛的，通过这些信息我们可以拿到框架执行过程中关键节点得到的信息，为我们提供了很大的便利。加上SkyAPM-dotnet巧妙的使用了这一特点使得DiagnosticSource更变得强大而且通用。上面我们讲述的只是冰山一角，还有更多更深的应用，比如Azure监控.Net Core应用程序也是利用了这些。有兴趣的可以查看相关源码，也可以学习一下SkyAPM-dotnet相关源码，体会一下DiagnosticSource精髓所在。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;👇欢迎扫码关注我的公众号👇&lt;/span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 20 Aug 2020 16:34:00 +0000</pubDate>
<dc:creator>yi念之间</dc:creator>
<og:description>前言 近期由于需要进行分布式链路跟踪系统的技术选型，所以一直在研究链路跟踪相关的框架。作为能在.Net Core中使用的APM，SkyWalking自然成为了首选。SkyAPM-dotnet是SkyW</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucy/p/13532534.html</dc:identifier>
</item>
<item>
<title>线程池之Executor框架 - Chiakiiii</title>
<link>http://www.cnblogs.com/chiaki/p/13538829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiaki/p/13538829.html</guid>
<description>&lt;p&gt;Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作机单元和执行机制分离开来。&lt;strong&gt;工作单元包括Runnable和Callable，而执行机制由Executor框架提供。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-executor框架简介&quot;&gt;1. Executor框架简介&lt;/h3&gt;
&lt;h4 id=&quot;11-executor框架的两级调度模型&quot;&gt;1.1 Executor框架的两级调度模型&lt;/h4&gt;
&lt;p&gt;在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程。&lt;/p&gt;
&lt;p&gt;在底层，操作系统内核将这些线程映射到硬件处理器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820220148034.png&quot; alt=&quot;image-20200820220148034&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;12-executor框架的结构&quot;&gt;1.2 Executor框架的结构&lt;/h4&gt;
&lt;p&gt;Executor框架主要由3部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;任务&lt;/strong&gt;。包括被执行任务需要实现的接口：Runnable接口或者Callable接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务的执行&lt;/strong&gt;。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步计算的结果&lt;/strong&gt;。包括Future和实现Future的FutureTask类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Executor框架的成员及其关系可以用一下的关系图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820221319222.png&quot; alt=&quot;image-20200820221319222&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Executor框架的使用示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820222719384.png&quot; alt=&quot;image-20200820222719384&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主线程首先创建实现Runnable或Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（&lt;code&gt;Executors.callable(Runnable task)&lt;/code&gt;或&lt;code&gt;Executors.callable(Runnable task, Object result)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;创建Executor接口的实现类ThreadPoolExecutor类或者ScheduledThreadPoolExecutor类的对象，然后调用其execute()方法或者submit()方法把工作任务添加到线程中，如果有返回值则返回Future对象。其中Callable对象有返回值，因此使用submit()方法；而Runnable可以使用execute()方法，此外还可以使用submit()方法，只要使用callable(Runnable task)或者callable(Runnable task, Object result)方法把Runnable对象包装起来就可以，使用callable(Runnable task)方法返回的null，使用callable(Runnable task, Object result)方法返回result。&lt;/li&gt;
&lt;li&gt;主线程可以执行Future对象的get()方法获取返回值，也可以调用cancle()方法取消当前线程的执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;13-executor框架的使用案例&quot;&gt;1.3 Executor框架的使用案例&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.*;

public class ExecutorDemo {
    // 创建ThreadPoolExecutor实现类
    private static ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,
            10,
            100,
            TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue&amp;lt;&amp;gt;(5),
    );

    public static void main(String[] args) {
        // 采用submit()方法提交Callable对象并返回Future对象
        Future&amp;lt;String&amp;gt; future = executor.submit(new callableDemo());
        try {
            // get()方法获取返回值
            System.out.println(future.get());
        } catch (InterruptedException | ExecutionException e) {
            // 处理异常
            e.printStackTrace();
        } finally {
            // 关闭线程池
            executor.shutdown();
        }
    }
}

/**
 * 创建Callable接口的实现类
 */
class callableDemo implements Callable&amp;lt;String&amp;gt; {
    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        String s = &quot;return string&quot;;
        return s;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-executor框架成员&quot;&gt;2. Executor框架成员&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820225956625.png&quot; alt=&quot;image-20200820225956625&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;21-threadpoolexecutor&quot;&gt;2.1 ThreadPoolExecutor&lt;/h4&gt;
&lt;p&gt;直接创建ThreadPoolExecutor的实例对象，见https://www.cnblogs.com/chiaki/p/13536624.html&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor通常使用工厂类Executors创建，可以创建3种类型的ThreadPoolExecutor，即FixedThreadPool、SingleThreadExecutor以及CachedThreadPool。&lt;/p&gt;
&lt;ul readability=&quot;27&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;FixedThreadPool&lt;/strong&gt;：&lt;strong&gt;适用于为了满足资源管理的需求，而需要限制当先线程数量的应用场景，适用于负载比较重的服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService es = Executors.newFixedThreadPool(int threadNums);
public static ExecutorService es = Executors.newFixedThreadPool(int threadNums, ThreadFactory threadFactory);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把线程池最大线程数量maxmumPoolSize和核心线程池的数量corePoolSize设置为&lt;code&gt;threadNums&lt;/code&gt;，将参数keepAliveTime设置为&lt;code&gt;0L&lt;/code&gt;。使用无界队列&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为阻塞队列，因此当任务不能立刻执行时，都会添加到阻塞队列中，而且maximumPoolSize，keepAliveTime都是无效的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;SingleThreadExecutor：&lt;/strong&gt;适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动地应用场景。**&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService es = Executors.newSingleThreadExecutor();
public static ExecutorService es = Executors.newSingleThreadExecutor(ThreadFactory threadFactory);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为阻塞队列使用的是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;，因此和FixedThreadPool一样，参数maximumPoolSize以及keepAliveTime都是无效的。corePoolSize为&lt;code&gt;1&lt;/code&gt;，因此&lt;strong&gt;最多只能创建一个线程&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;strong&gt;CachedThreadPool&lt;/strong&gt;：&lt;strong&gt;大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService es = Executors.newCachedThreadPool();
public static ExecutorService es = Executors.newCachedThreadPool(ThreadFactory threadFactory);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CachedThreadPool使用&lt;code&gt;SynchronizedQueue&lt;/code&gt;作为阻塞队列，SynchronizedQueue是不存储元素的阻塞队列，实现&lt;strong&gt;“一对一的交付”&lt;/strong&gt;，也就是说，每次向队列中put一个任务必须等有线程来take这个任务，否则就会一直阻塞该任务，如果一个线程要take一个任务就要一直阻塞知道有任务被put进阻塞队列。&lt;/p&gt;
&lt;p&gt;因为CachedThreadPool的maximumPoolSize为&lt;code&gt;Integer.MUX_VALUE&lt;/code&gt;，因此&lt;strong&gt;CachedThreadPool是无界的线程池，也就是说可以一直不断的创建线程，这样可能会使CPU和内存资源耗尽&lt;/strong&gt;。corePoolSize为&lt;code&gt;0&lt;/code&gt; ，因此在&lt;strong&gt;CachedThreadPool中直接通过阻塞队列来进行任务的提交&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;22-scheduledthreadpoolexecutor&quot;&gt;2.2 ScheduledThreadPoolExecutor&lt;/h4&gt;
&lt;p&gt;ScheduledThreadPoolExecutor类继承了ThreadPoolExecutor并实现了ScheduledExecutorService接口。&lt;strong&gt;主要用于在给定的延迟后执行任务或者定期执行任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor通常使用Executors工厂类来创建，可创建2种类型的ScheduledThreadPoolExecutor，即ScheduledThreadPoolExecutor和SingleThreadScheduledExecutor。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;ScheduledThreadPoolExecutor：适用于若干个（固定）线程延时或者定期执行任务，同时为了满足资源管理的需求而需要限制后台线程数量的场景。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ScheduledExecutorService ses = Executors.newScheduledThreadPool(int threadNums);
public static ScheduledExecutorService ses = Executors.newScheduledThreadPool(int threadNums, ThreadFactory threadFactory);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;SingleThreadScheduledExecutor：适用于需要单个线程延时或者定期的执行任务，同时需要保证各个任务顺序执行的应用场景。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor(int threadNums);
public static ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor(int threadNums, ThreadFactory threadFactory);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ScheduledThreadPoolExecutor的实现：&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor的实现主要是通过&lt;strong&gt;把任务封装为ScheduledFutureTask来实现&lt;/strong&gt;。通过调用scheduledAtFixedTime()方法或者scheduledWithFixedDelay()方法向阻塞队列添加一个实现了RunnableScheduledFutureTask接口的ScheduledFutureTask类对象。ScheduledFutureTask主要包括3个成员变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 序列号，用于保存任务添加到阻塞队列的顺序
private final long sequenceNumber;
// 用于保存该任务将要被执行的具体时间
private long time;
// 周期，用于保存任务直线的间隔周期
private final long period;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ScheduledTreadPoolExecutor的阻塞队列是用&lt;strong&gt;无界队列&lt;/strong&gt;&lt;code&gt;DelayQueue&lt;/code&gt;实现的，可以实现元素延时delayTime后才能获取元素，在ScheduledThreadPoolExecutor中，DelayQueue内部封装了一个PriorityQueue，来对任务进行排序，首先对time排序，time小的在前，如果time一样，则sequence小的在前，也就是说如果time一样，那么先被提交的任务先执行。&lt;/p&gt;
&lt;p&gt;因为DelayQueue是一个无界的队列，因此线程池的maximumPoolSize是无效的。ScheduledThreadPoolExecutor的工作流程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820233614169.png&quot; alt=&quot;image-20200820233614169&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;23-future接口futuretask实现类&quot;&gt;2.3 Future接口/FutureTask实现类&lt;/h4&gt;
&lt;p&gt;Future接口和实现Future接口的FutureTask实现类，代表异步计算的结果。&lt;/p&gt;
&lt;h5 id=&quot;231-futuretask的使用&quot;&gt;2.3.1 FutureTask的使用&lt;/h5&gt;
&lt;p&gt;FutureTask除了实现Future接口外还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以条用线程直接执行（&lt;code&gt;FutureTask.run()&lt;/code&gt;）。根据FutureTask.run()方法被执行的时机，FutureTask可处于以下3种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;未启动：创建了一个FutureTask对象但没有执行FutureTask.run()；&lt;/li&gt;
&lt;li&gt;已启动：FutureTask.run()方法被执行的过程中；&lt;/li&gt;
&lt;li&gt;已完成：FutureTask.run()正常执行结束，或者FutureTask被取消（&lt;code&gt;FutureTask.cancel()&lt;/code&gt;），或者执行FutureTask.run()时抛出异常而异常结束；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;状态迁移示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820234612077.png&quot; alt=&quot;image-20200820234612077&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FutureTask的get和cancle执行示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820234818187.png&quot; alt=&quot;image-20200820234818187&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;232-futuretask的实现&quot;&gt;2.3.2 FutureTask的实现&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;FutureTask是一个基于AQS同步队列实现的一个自定义同步组件&lt;/strong&gt;，通过对同步状态state的竞争实现acquire或者release操作。&lt;/p&gt;
&lt;p&gt;FutureTask的内部类Sync实现了AQS接口，通过&lt;strong&gt;对tryAcquire等抽象方法的重写和模板方法的调用来实现内部类Sync的tryAcquireShared等方法&lt;/strong&gt;，然后聚合Sync的方法来实现FutureTask的get和cancel等方法。&lt;/p&gt;
&lt;p&gt;FutureTask的设计示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200820235358434.png&quot; alt=&quot;image-20200820235358434&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FutureTask的get方法最终会调用&lt;code&gt;AQS.acquireSharedInterruptibly(int arg)&lt;/code&gt;方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用&lt;code&gt;AQS.acquireSharedInterruptibly(int arg)&lt;/code&gt;方法会首先调用&lt;code&gt;tryAcquireShared()&lt;/code&gt;方法判断acquire操作是否可以成功，可以成功的条件是state为执行完成状态RAN或者已取消状态CANCELLED，且runner不为null；&lt;/li&gt;
&lt;li&gt;如果成功则&lt;code&gt;get()&lt;/code&gt;方法立即返回，如果失败则到线程等待队列执行release操作；&lt;/li&gt;
&lt;li&gt;当其他线程执行release操作唤醒当前线程后（比如&lt;code&gt;FutureTask.run()&lt;/code&gt;或&lt;code&gt;FutureTask.cancle(...)&lt;/code&gt;），当前线程再次执行&lt;code&gt;tryAcquireShared()&lt;/code&gt;将返回正值1，当前线程离开现场等待队列并唤醒它的后继线程（级联唤醒）；&lt;/li&gt;
&lt;li&gt;最后返回计算的结果或抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://chiaki.oss-cn-beijing.aliyuncs.com/image-20200821000310543.png&quot; alt=&quot;image-20200821000310543&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;233-futuretask的使用场景&quot;&gt;2.3.3 FutureTask的使用场景&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当一个线程需要等待另一个线程把某个任务执行完以后它才能继续执行时；&lt;/li&gt;
&lt;li&gt;有若干线程执行若干任务，每个任务最多只能被执行一次；&lt;/li&gt;
&lt;li&gt;当多个线程师徒执行同一个任务，但只能允许一个线程执行此任务，其它线程需要等这个任务被执行完毕以后才能继续执行时。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;24-runnable和callable接口&quot;&gt;2.4 Runnable和Callable接口&lt;/h4&gt;
&lt;p&gt;用于实现线程要执行的工作单元。&lt;/p&gt;
&lt;h4 id=&quot;25-executors工厂类&quot;&gt;2.5 Executors工厂类&lt;/h4&gt;
&lt;p&gt;提供了常见配置线程池的方法，因为ThreadPoolExecutor的参数众多且意义重大，为了避免配置出错，才有了Executors工厂类。&lt;/p&gt;
&lt;h3 id=&quot;3-为什么不建议使用executors创建线程池？&quot;&gt;3. 为什么不建议使用Executors创建线程池？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FixedThreadPool&lt;/strong&gt;和&lt;strong&gt;SingleThreadExecutor&lt;/strong&gt;：允许请求的队列长度为Integer.MAX_VALUE（无界的阻塞队列），可能堆积大量的请求，从而导致OOM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CachedThreadPool&lt;/strong&gt;和&lt;strong&gt;ScheduledThreadPool&lt;/strong&gt;：允许创建的线程数量为Integer.MAX_VALUE（无界的阻塞队列），可能会创建大量线程，从而导致OOM。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 16:18:00 +0000</pubDate>
<dc:creator>Chiakiiii</dc:creator>
<og:description>线程池之Executor框架 Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作机单元和执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiaki/p/13538829.html</dc:identifier>
</item>
<item>
<title>Keras结合Keras后端搭建个性化神经网络模型（不用原生Tensorflow） - 颀周</title>
<link>http://www.cnblogs.com/qizhou/p/13530440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qizhou/p/13530440.html</guid>
<description>&lt;p&gt;　　Keras是基于Tensorflow等底层张量处理库的高级API库。它帮我们实现了一系列经典的神经网络层（全连接层、卷积层、循环层等），以及简洁的迭代模型的接口，让我们能在模型层面写代码，从而不用仔细考虑模型各层张量之间的数据流动。&lt;/p&gt;
&lt;p&gt;　　但是，当我们有了全新的想法，想要个性化模型层的实现，Keras的高级API是不能满足这一要求的，而换成Tensorflow又要重新写很多轮子，这时，Keras的后端就派上用场了。Keras将底层张量库的函数功能统一封装在“backend”中，用户可以用统一的函数接口调用不同的后端实现的相同功能。所以，如果不追求速度的话，可以仅使用Keras实现你的任何独特想法，从而避免使用原生Tensorflow写重复的轮子。&lt;/p&gt;
&lt;p&gt;　　我们定义并训练一个神经网络模型需要考虑的要素有三个：层、损失函数、优化器。而我们创新主要在于前两个，因此下面介绍如何结合Keras高级API与后端，自定义特殊神经网络层以及损失函数。&lt;/p&gt;

&lt;p&gt;　　自定义层可以通过两种方式实现：使用Lambda层和继承Layer类。&lt;/p&gt;
&lt;h2&gt;lambda层&lt;/h2&gt;
&lt;p&gt;　　Lambda层仅能对输入做&lt;strong&gt;固定的变换&lt;/strong&gt;，并不能定义可以通过反向传播训练的参数（通过Keras的fit训练），因此能实现的东西较少。以下代码实现了Dropout的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_layer(x):     
  mask &lt;/span&gt;= K.random_binomial(K.shape(x),0.5&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x*mask*2&lt;span&gt;
x &lt;/span&gt;= layers.Lambda(my_layer)(x) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中my_layer函数是自定义层要实现的操作，传递参数只能是Lambda层的输入。定义好函数后，直接在layers.Lambda中传入函数对象即可。实际上，这些变换不整合在lambda层中而直接写在外面也是可以的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers

x &lt;/span&gt;= layers.Dense(500,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x) 
mask &lt;/span&gt;=&lt;span&gt; K.random_binomial(K.shape(x),0.5)
x &lt;/span&gt;= x*mask*2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　数据先经过一个全连接层，然后再被0.5概率Dropout。以上实现Dropout只是作举例，你可以以同样的方式实现其它的功能。&lt;/p&gt;
&lt;h2&gt;继承layer类&lt;/h2&gt;
&lt;p&gt;　　如果你想自定义可以训练参数的层，就需要继承实现Keras的抽象类Layer。主要实现以下三个方法：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、__init__(self, *args, **kwargs)&lt;/strong&gt;：构造函数，在实例化层时调用。此时还没有添加输入，也就是说此时输入规模未知，但可以定义输出规模等与输入无关的变量。类比于Dense层里的units、activations参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2、build(self, input_shape)&lt;/strong&gt;：在添加输入时调用（__init__之后），且参数只能传入输入规模input_shape。此时输入规模与输出规模都已知，可以定义训练参数，比如全连接层的权重w和偏执b。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、call(self, *args, **kwargs)&lt;/strong&gt;：编写层的功能逻辑。&lt;/p&gt;
&lt;h3&gt;单一输入&lt;/h3&gt;
&lt;p&gt;　　当输入张量只有一个时，下面是实现全连接层的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers,Model,Input,utils
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyDense(layers.Layer): 
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, units=32): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
    super(MyDense, self).&lt;span&gt;__init__&lt;/span&gt;()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化父类&lt;/span&gt;
    self.units = units  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输出规模&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; build(self, input_shape):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义训练参数&lt;/span&gt;
    self.w = K.variable(K.random_normal(shape=[input_shape[-1],self.units]))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练参数&lt;/span&gt;
    self.b = tf.Variable(K.random_normal(shape=[self.units]),trainable=True)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练参数&lt;/span&gt;
    self.a = tf.Variable(K.random_normal(shape=[self.units]),trainable=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;非训练参数&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; call(self, inputs): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能实现&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; K.dot(inputs, self.w) +&lt;span&gt; self.b
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型&lt;/span&gt;
input_feature = Input([None,28,28&lt;span&gt;]) 
x &lt;/span&gt;= layers.Reshape(target_shape=[28*28&lt;span&gt;])(input_feature)
x &lt;/span&gt;= layers.Dense(500,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)  
x &lt;/span&gt;= MyDense(100&lt;span&gt;)(x)
x &lt;/span&gt;= layers.Dense(10,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x) 
  
model &lt;/span&gt;=&lt;span&gt; Model(input_feature,x) 
model.summary() &lt;br/&gt;utils.plot_model(model)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模型结构如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1908255/202008/1908255-20200820223347734-452616859.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;273&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1908255/202008/1908255-20200820233136265-368910824.png&quot; alt=&quot;&quot; width=&quot;167&quot; height=&quot;273&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　在build()中，训练参数可以用K.variable或tf.Variable定义。并且，只要是用这两个函数定义并存入self中，就会被keras认定为训练参数，不管是在build还是__init__或是其它函数中定义。但是K.variable没有trainable参数，不能设置为Non-trainable params，所以还是用tf.Variable更好更灵活些。&lt;/p&gt;
&lt;h3&gt;多源输入&lt;/h3&gt;
&lt;p&gt;　　如果输入包括多个张量，需要传入张量列表。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers,Model,Input,utils
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyLayer(layers.Layer): 
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, output_dims):
    super(MyLayer, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()  
    self.output_dims &lt;/span&gt;=&lt;span&gt; output_dims
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build(self, input_shape):  
    [dim1,dim2] &lt;/span&gt;=&lt;span&gt; self.output_dims
    self.w1 &lt;/span&gt;= tf.Variable(K.random_uniform(shape=[input_shape[0][-1&lt;span&gt;],dim1]))
    self.b1 &lt;/span&gt;= tf.Variable(K.random_uniform(shape=&lt;span&gt;[dim1]))  
    self.w2 &lt;/span&gt;= tf.Variable(K.random_uniform(shape=[input_shape[1][-1&lt;span&gt;],dim2])) 
    self.b2 &lt;/span&gt;= tf.Variable(K.random_uniform(shape=&lt;span&gt;[dim2])) 
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; call(self, x): 
    [x1, x2] &lt;/span&gt;=&lt;span&gt; x
    y1 &lt;/span&gt;= K.dot(x1, self.w1)+&lt;span&gt;self.b1 
    y2 &lt;/span&gt;= K.dot(x2, self.w2)+&lt;span&gt;self.b2
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; K.concatenate([y1,y2],axis = -1&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型&lt;/span&gt;
input_feature = Input([None,28,28])&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入&lt;/span&gt;
x = layers.Reshape(target_shape=[28*28&lt;span&gt;])(input_feature) 
x1 &lt;/span&gt;= layers.Dense(500,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)  
x2 &lt;/span&gt;= layers.Dense(500,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)  
x &lt;/span&gt;= MyLayer([100,80&lt;span&gt;])([x1,x2])   
x &lt;/span&gt;= layers.Dense(10,activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x) 
  
model &lt;/span&gt;=&lt;span&gt; Model(input_feature,x) 
model.summary() 
utils.plot_model(model,show_layer_names&lt;/span&gt;=False,show_shapes=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模型结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1908255/202008/1908255-20200820232953967-305129242.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;334&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总之，传入张量列表，build传入的input_shape就是各个张量形状的列表。其它都与单一输入类似。&lt;/p&gt;

&lt;p&gt;　　根据Keras能添加自定义损失的特性，这里将添加损失的方法分为两类：&lt;/p&gt;
&lt;p&gt;　　1、损失需要根据模型输出与真实标签来计算，也就是只有模型的输出与外部真实标签作为计算损失的参数。&lt;/p&gt;
&lt;p&gt;　　2、损失无需使用外部真实标签，也就是只用模型内部各层的输出作为计算损失的参数。&lt;/p&gt;
&lt;p&gt;　　这两类损失添加的方式并不一样，希望以后Keras能把API再改善一下，这种冗余有时让人摸不着头脑。&lt;/p&gt;
&lt;h2&gt;第一类损失&lt;/h2&gt;
&lt;p&gt;　　这类损失可以通过自定义函数的形式来实现。函数的参数必须是两个：真实标签与模型输出，不能多也不能少，并且顺序不能变。然后你可以在这个函数中定义你想要的关于输出与真实标签之间的损失。然后在model.compile()中将这个函数对象传给loss参数。代码示例如下（&lt;a href=&quot;https://stackoverflow.com/questions/45961428/make-a-custom-loss-function-in-keras&quot; target=&quot;_blank&quot;&gt;参考链接&lt;/a&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; customed_loss(true_label,predict_label): 
  loss =&lt;span&gt; keras.losses.categorical_crossentropy(true_label,predict_label)  
  loss +=&lt;span&gt; K.max(predict_label)
  return&lt;span&gt; loss

model.compile(optimizer='rmsprop', loss=customed_loss)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果硬是想用这种方法把模型隐层的输出拿来算损失的话，也不是不可以。只要把相应隐层的输出添加到模型的输出列表中，自定义损失函数就可以从模型输出列表中取出隐层输出来用了。即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
model = Model(input,[model_output, hidden_layer_output])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，这样就把模型结构改了，如果不想改模型的结构而添加“正则化”损失，可以使用下面的方法。&lt;/p&gt;
&lt;h2&gt;第二类损失&lt;/h2&gt;
&lt;p&gt;　　这类损失可以用Model.add_loss(loss)方法实现，loss可以使用Keras后端定义计算图来实现。但是显然，计算图并不能把未来训练用的真实标签传入，所以，add_loss方法只能计算模型内部的“正则化”损失。&lt;/p&gt;
&lt;p&gt;　　add_loss方法可以使用多次，损失就是多次添加的loss之和。使用了add_loss方法后，compile中就可以不用给loss赋值，不给loss赋值的话使用fit()时就不能传入数据的标签，也就是y_train。如果给compile的loss赋值，最终的目标损失就是多次add_loss添加的loss和compile中loss之和。另外，如果要给各项损失加权重的话，直接在定义loss的时候加上即可。代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
loss = 100000*K.mean(K.square(somelayer_output))#somelayer_output是定义model时获得的某层输出
&lt;span&gt;model.add_loss(loss)
model.compile(optimizer='rmsprop')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上讲的都是关于层输出的损失，层权重的正则化损失并不这样添加，自定义正则项可以看下面。&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/qq_34840129/article/details/89083624&quot;&gt;keras中添加正则化_Bebr的博客-CSDN博客_keras 正则化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　里面介绍了已实现层的自定义正则化，但没有介绍自定义层的自定义正则化，这里先挖个坑，以后要用再研究。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Aug 2020 15:51:00 +0000</pubDate>
<dc:creator>颀周</dc:creator>
<og:description>Keras是基于Tensorflow等底层张量处理库的高级API库。它帮我们实现了一系列经典的神经网络层（全连接层、卷积层、循环层等），以及简洁的迭代模型的接口，让我们能在模型层面写代码，从而不用仔细</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qizhou/p/13530440.html</dc:identifier>
</item>
<item>
<title>Hyperledger Fabric 手动搭建【区块链学习三】 - 晨曦001</title>
<link>http://www.cnblogs.com/chenxi001/p/13509829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxi001/p/13509829.html</guid>
<description>&lt;blockquote readability=&quot;6.1393442622951&quot;&gt;
&lt;p&gt;前面我们学习了&lt;a href=&quot;https://www.cnblogs.com/chenxi001/p/13496269.html&quot;&gt;区块链是什么&lt;/a&gt;、还有&lt;a href=&quot;https://www.cnblogs.com/chenxi001/p/13472111.html&quot;&gt;自动搭建&lt;/a&gt;学习东西我们就要从简单到深入（入门到放弃），现在自动部署已经跑通了接下来就是手动搭建Fabric 网络可以更好的理解为什么要这么做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用cryptogen（密码生成器）和configtxgen（配置交易生成器）手动生成证书密钥和各种配置构件（等同于执行byfnsh-generate）&quot;&gt;使用cryptogen（密码生成器）和configtxgen（配置交易生成器）手动生成证书/密钥和各种配置构件（等同于执行./byfn.sh generate）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;密钥生成器 cryptogen
&lt;ul&gt;&lt;li&gt;cryptogen 工具为我们的网络实体生成各种加密材料（ x509 证书和签名秘钥）。这些证书是身份的代表，在实体之间通信和交易的时候，它们允许对身份验证进行签名和验证&lt;/li&gt;
&lt;li&gt;crypto-config.yaml，为所有组织和属于这些组织的组件生成一组证书和秘钥。每一个组织被分配一个唯一的根证书（ca-cert），它绑定该组织的特定组件（Peer 节点和排序节点）。通过为每个组织分配一个唯一的 CA 证书，我们模拟了一个典型的网络，网络中的成员可以使用它自己的证书授权中心。Fabric 中的事务和通信由一个实体的私钥（keystore）签名，然后通过公钥（signcerts）验证。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# crypto-config.yaml 文件结构
OrdererOrgs:    #定义一个Order组织
  - Name: Orderer    #order节点的名称,当前网络模式为solo类型，所以只定义了一个Order节点
    Domain: example.com    #order节点的域
    Specs:      #暂时用不到
      - Hostname: orderer
      - Hostname: orderer2
      - Hostname: orderer3
      - Hostname: orderer4
      - Hostname: orderer5

PeerOrgs:      #定义Peer组织
  - Name: Org1      #声明Peer组织名称为Org1
    Domain: org1.example.com    #Org1组织的域
    EnableNodeOUs: true    #暂时没搞清楚该字段的意义
    Template:       #在这里可以定义所生成的Org1组织中的Peer节点证书数量，不包括Admin
      Count: 2      #表明需要生成两个Peer节点的证书，如果需要其他数量的Peer节点，只需要更改这里的数量。
    Users:        #在这里可以定义所生成的Org1组织中类型为User的证书数量，不包括Admin
      Count: 1    #生成用户的证书的数量

  - Name: Org2   #声明第二个Peer组织名称为Org2，如果需要更多的Peer组织证书，只需要按该模板添加即可。
    Domain: org2.example.com  #与以上相同 
    EnableNodeOUs: true
    Template:
      Count: 2
    Users:
      Count: 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置交易生成器 configtxgen
&lt;ul&gt;&lt;li&gt;使用configtxgen工具生成系统通道的创世区块，并将系统的配置操作（创建通道，设置某组织的锚节点等）作为系统事务生成提交到系统通道的事务文件（.tx），配置文件为&lt;a href=&quot;https://my.oschina.net/u/2476019/blog/2046258&quot;&gt;configtx.yaml&lt;/a&gt;，生成的配置组件位于channel-artifacts目录下、分别为：genesis.block，channel.tx，Org1MSPanchors.tx，Org2MSPanchors.tx，genesis.block为系统通道的创世区块，后三者分别为创建通道，设置组织一、组织二的锚节点的事务，这些配置操作作为系统事务提交到系统通道中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 会根据crypto-config.yaml文件配置生成两个锚节点交易，一个对应一个Peer组织
cryptogen generate --config=./crypto-config.yaml

#生成系统通道创世区块genesis.block生成的配置组件位于channel-artifacts目录下
configtxgen -profile SampleMultiNodeEtcdRaft -channelID byfn-sys-channel -outputBlock ./channel-artifacts/genesis.block

#通过环境变量设定通道名称
export CHANNEL_NAME=mychannel

#创建 通道配置 事务
configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME  

#创建 更新组织Org1在该通道上的锚节点（锚节点为某组织对order可见的节点） 的事务
configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP

#创建 更新组织Org2在该通道上的锚节点 的事务
configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动网络，创建并加入通道，更新组织锚节点，安装、定义并调用一个链代码（等同于执行byfnsh-up）&quot;&gt;启动网络，创建并加入通道，更新组织锚节点，安装、定义并调用一个链代码（等同于执行./byfn.sh up）&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#启动fabric网络 -d用于不显示网络的实时日志，若想查看日志流，则后续命令需要打开另一个终端来执行
#首先将first-network目录下的docker-compose-cli.yaml文件中cli容器配置信息中的FABRIC_LOGGING_SPEC=INFO修改为FABRIC_LOGGING_SPEC=DEBUG以看到更多的执行过程信息
docker-compose -f docker-compose-cli.yaml -f docker-compose-etcdraft2.yaml up -d   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动网络之后我们可以看到docker启动的容器&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202008/1808958-20200820215655459-195591862.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;进入容器 创建并加入通道，并指定（更新）组织的锚节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#进入cli容器内部
docker exec -it cli bash

#配置CLI容器作为peer0.org1.example.com节点执行命令的环境变量
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#以环境变量形式设定通道名称，必须全部小写，长度小于250个字符，并与正则表达式[a-z][a-z0-9.-]*匹配
export CHANNEL_NAME=mychannel  

#将通道配置事务发送给order节点以创建通道，指定order节点的证书以进行TLS握手，执行结束后该节点将收到来自order节点的对应于所创建通道的创世区块$CHANNEL_NAME.block
peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202008/1808958-20200820222508428-114220437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#将peer0.org1.example.com加入通道，注意命令中的$CHANNEL_NAME.block，根据通道名称而变化
peer channel join -b mychannel.block

#指定peer0.org1.example.com作为组织Org1的锚节点
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 

#配置CLI容器作为peer0.org2.example.com节点执行命令的环境变量
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:9051 
CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

#将peer0.org2.example.com加入通道，注意命令中的$CHANNEL_NAME.block，根据通道名称而变化
peer channel join -b mychannel.block

#指定peer0.org2.example.com作为组织Org2的锚节点
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

#下载安装并定义一个链代码
peer lifecycle chaincode package mycc.tar.gz --path github.com/hyperledger/fabric-samples/chaincode/abstore/go/ --lang golang --label mycc_1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1808958/202008/1808958-20200820223059320-455780581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#安装链码
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt

#安装链码
peer lifecycle chaincode install mycc.tar.gz

#查询已安装的链码
peer lifecycle chaincode queryinstalled 

#后续命令将需要链码包的ID，因此我们将它保存为一个环境变量，这个ID是动态的(上面查询出来的)
CC_PACKAGE_ID=mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173

#制定链码初始化链码TLS后面的命令是要权限才能初始化
#通道中的组织需要就链码的定义达成一致，以下命令用于批准一个chaincode定义，--init-required用于初始化chaincode时使init函数被调用，--package-id指定链码包的ID，我们还可以提供--signature-policy或--channel-config-policy参数来设置chaincode背书策略，若未提供将使用默认设置-大多数通道成员背书，这种情况下若在该渠道中添加或删除新组织，背书策略将自动更新，以要求更多或更少的背书。在本例中，默认策略将需要来自属于Org1和Org2的peer的背书(即两个背书)
peer lifecycle chaincode approveformyorg --channelID $CHANNEL_NAME --name mycc --version 1.0 --init-required --package-id $CC_PACKAGE_ID --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

#更改CLI容器的环境变量后，在其它节点上安装链码
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
CORE_PEER_ADDRESS=peer0.org2.example.com:9051
CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

#安装链码
peer lifecycle chaincode install mycc.tar.gz

#制定链码初始化链码TLS后面的命令是要权限才能初始化
#通道中的组织需要就链码的定义达成一致，以下命令用于批准一个chaincode定义，--init-required用于初始化chaincode时使init函数被调用，--package-id指定链码包的ID，我们还可以提供--signature-policy或--channel-config-policy参数来设置chaincode背书策略，若未提供将使用默认设置-大多数通道成员背书，这种情况下若在该渠道中添加或删除新组织，背书策略将自动更新，以要求更多或更少的背书。在本例中，默认策略将需要来自属于Org1和Org2的peer的背书(即两个背书)
peer lifecycle chaincode approveformyorg --channelID $CHANNEL_NAME --name mycc --version 1.0 --init-required --package-id $CC_PACKAGE_ID --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

#一旦足够多的通道成员组织批准了chaincode定义，一个成员组织就可以将定义提交给通道。可以通过发出以下查询来检查chaincode定义是否已准备好提交，并查看当前组织的批准情况
#查看各组织对chaincode定义的批准状况
peer lifecycle chaincode checkcommitreadiness --channelID $CHANNEL_NAME --name mycc --version 1.0 --init-required --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --output json

#一旦就链码定义达成一致，把两个组织中的链码提交到order组织--通知给其他节点我加入了
peer lifecycle chaincode commit -o orderer.example.com:7050 --channelID $CHANNEL_NAME --name mycc --version 1.0 --sequence 1 --init-required --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

#调用chaincode 将--isInit标志传递给链码的第一次调用，并将参数提供给Init函数。第一个调用将启动chaincode容器。我们可能需要等待容器启动。（确保通道名称和链码名称正确）
peer chaincode invoke -o orderer.example.com:7050 --isInit --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '{&quot;Args&quot;:[&quot;Init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;100&quot;]}' --waitForEvent

#查询chaincode
peer chaincode query -C $CHANNEL_NAME -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}'

#调用链码的invoke函数，a向b转账十元
peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}' --waitForEvent

#注：若通道成员组织的其它节点想和区块链网络进行交互，只需要加入通道并安装链码包即可，而不需要提交链码定义（每个组织批准一次链码定义即可）。
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Aug 2020 14:41:00 +0000</pubDate>
<dc:creator>晨曦001</dc:creator>
<og:description>#Hyperledger Fabric 手动搭建 前面我们学习了区块链是什么、还有自动搭建学习东西我们就要从简单到深入（入门到放弃），现在自动部署已经跑通了接下来就是手动搭建Fabric 网络可以更好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenxi001/p/13509829.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：解锁i.MXRTxxx上FlexSPI模块自带的地址重映射(Remap)功能 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13538105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13538105.html</guid>
<description>&lt;p&gt;前段时间痞子衡写了一篇文章 《利用i.MXRT1060,1010上新增的FlexSPI地址重映射(Remap)功能可安全OTA》，介绍了Remap功能在OTA设计中的重要性。如果你对比过i.MXRT三位数（RT500/600）和四位数（RT1xxx）的FlexSPI模块，你会发现它们是一样的，寄存器定义几乎完全一致。但是我们知道这两个系列又分别是来自不同平台（LPC/i.MX），i.MXRT三位数可没有i.MXRT四位数上用于存放Remap控制的IOMUXC_GPR模块，那么在i.MXRT500/600上到底有没有Remap功能呢？本文痞子衡将为你解答。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;152.4030075188&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;i.MXRT三位数系列隐藏的FlexSPI Remap功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　前段时间痞子衡写了一篇文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13510275.html&quot;&gt;《利用i.MXRT1060,1010上新增的FlexSPI地址重映射(Remap)功能可安全OTA》&lt;/a&gt;，介绍了Remap功能在OTA设计中的重要性。如果你对比过i.MXRT三位数（RT500/600）和四位数（RT1xxx）的FlexSPI模块，你会发现它们是一样的，寄存器定义几乎完全一致。但是我们知道这两个系列又分别是来自不同平台（LPC/i.MX），i.MXRT三位数可没有i.MXRT四位数上用于存放Remap控制的IOMUXC_GPR模块，那么在i.MXRT500/600上到底有没有Remap功能呢？本文痞子衡将为你解答。&lt;/p&gt;
&lt;h3 id=&quot;1-flexspi-nor系统映射地址&quot;&gt;1. FlexSPI NOR系统映射地址&lt;/h3&gt;
&lt;p&gt;　　老规矩还是先看一下FlexSPI在i.MXRT三位数上的系统映射空间。因为内核架构的差异，分配的映射地址与i.MXRT1xxx上完全不同。&lt;/p&gt;
&lt;p&gt;　　i.MXRT500中分配给FlexSPI的系统映射空间如下，两个FlexSPI各分配了128MB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_FlexSPI_Remap_RT500_flash_map.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　i.MXRT600中分配给FlexSPI的系统映射空间如下，一个FlexSPI分配了128MB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_FlexSPI_Remap_RT600_flash_map.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-flexspi-remap控制在哪里？&quot;&gt;2. FlexSPI Remap控制在哪里？&lt;/h3&gt;
&lt;p&gt;　　目前我们已经可以从恩智浦官网下载到i.MXRT600的SDK软件包和参考手册，i.MXRT500的资料暂时还没有公布。对于i.MXRT600，无论是在SDK软件包中的头文件还是在参考手册中搜索“Remap”关键字，都搜不到任何信息，莫非是没有Remap功能？&lt;/p&gt;
&lt;p&gt;　　好了，痞子衡就不卖关子了，其实Remap功能是支持的，而且直接做到了FlexSPI模块里，控制寄存器也在FlexSPI里，就在FLEXSPI BASE地址偏移0x420的地方（模块有更新，但文档暂时没有同步更新）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;typedef struct
{
    __IO uint32_t HADDRSTART;
    __IO uint32_t HADDREND;
    __IO uint32_t HADDROFFSET;
} FLEXSPI_REMAP_Type;

#define FLEXSPI_REMAP  ((FLEXSPI_REMAP_Type *)(FLEXSPI_BASE + 0x420u));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　因为Remap控制嵌在FlexSPI模块寄存器里，所以对于有两个FlexSPI模块的i.MXRT500，Remap控制也有两组，相互独立，这点跟同样有两个FlexSPI模块的i.MXRT1060上Remap设计是不一样的。&lt;/p&gt;
&lt;h3 id=&quot;3-flexspi-remap功能设计&quot;&gt;3. FlexSPI Remap功能设计&lt;/h3&gt;
&lt;p&gt;　　虽然i.MXRT500/600上的Remap控制嵌在FlexSPI模块内部，但Remap设计依然是属于系统架构层面的，只是在AHB总线层面做一个地址重定向。下面是Remap控制寄存器：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot;&gt;Remap功能&lt;/th&gt;
&lt;th colspan=&quot;2&quot;&gt;对应控制寄存器&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;寄存器名&lt;/td&gt;
&lt;td&gt;寄存器地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ADDR_START&lt;/td&gt;
&lt;td&gt;HADDRSTART&lt;/td&gt;
&lt;td&gt;FLEXSPI_BASE + 0x420&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ADDR_END&lt;/td&gt;
&lt;td&gt;HADDREND&lt;/td&gt;
&lt;td&gt;FLEXSPI_BASE + 0x424&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ADDR_OFFSET&lt;/td&gt;
&lt;td&gt;HADDROFFSET&lt;/td&gt;
&lt;td&gt;FLEXSPI_BASE + 0x428&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　Remap设计很简单，就是地址（addr）落在[ADDR_START, ADDR_END]里的AHB读访问，其实际访问到的是addr + ADDR_OFFSET位置处的数据。（注意ADDR_START, ADDR_END, ADDR_OFFSET都是4KB对齐的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_FlexSPI_Remap_remap_case_1.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Remap功能及寄存器定义上基本跟i.MX1xxx保持一致，但有一个小区别，就是HADDRSTART寄存器的bit0同时也承担了Remap功能开关控制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_FlexSPI_Remap_HADDRSTART_defn.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-remap对擦写flash的影响&quot;&gt;4. Remap对擦写Flash的影响&lt;/h3&gt;
&lt;p&gt;　　启用Remap功能后，调用FlexSPI NOR驱动函数去擦写Flash不会受影响，擦写Flash操作正常走的是FlexSPI IPG命令方式，数据没有经过AHB bus。&lt;/p&gt;
&lt;p&gt;　　下面这段测试代码是在MIMXRT500-EVK上跑的，用ROM API驱动擦写0x08100000地址，擦写操作前加了一段Remap设置干扰，实测下来Remap设置对擦写没有任何影响，复位后去读Flash，操作的还是原0x08100000地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;#define FLEXSPI0_REMAP  ((FLEXSPI_REMAP_Type *)(FLEXSPI0_BASE + 0x420u));

flexspi_nor_config_t flashConfig;
serial_nor_config_option_t configOption;
configOption.option0.U = 0xc0403004;

uint32_t programBuffer[64];
for (uint32_t i = 0; i &amp;lt; sizeof(programBuffer); i++)
{
    *((uint8_t *)programBuffer + i) = (uint8_t)(i &amp;amp; 0xFF);
}

g_bootloaderTree-&amp;gt;flexspiNorDriver-&amp;gt;get_config(1, &amp;amp;flashConfig, &amp;amp;configOption);
g_bootloaderTree-&amp;gt;flexspiNorDriver-&amp;gt;init(1, &amp;amp;flashConfig);

FLEXSPI0_REMAP-&amp;gt;HADDRSTART  = 0x08100000 | 0x01;
FLEXSPI0_REMAP-&amp;gt;HADDREND    = 0x08200000;
FLEXSPI0_REMAP-&amp;gt;HADDROFFSET = 0x100000;

g_bootloaderTree-&amp;gt;flexspiNorDriver-&amp;gt;erase(1, &amp;amp;flashConfig, 0x100000, 0x100);
g_bootloaderTree-&amp;gt;flexspiNorDriver-&amp;gt;page_program(1, &amp;amp;flashConfig, 0x100000, programBuffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　Remap寄存器因为在FlexSPI模块中，因此Remap设置代码要在FlexSPI模块初始化之后，仅有模块时钟被开启，模块寄存器才能正常赋值，否则不生效（实测时钟不打开，读写Remap寄存器永远是0，并且不产生HardFault）。&lt;/p&gt;
&lt;h3 id=&quot;5-关于rom-api传参的疑惑解释&quot;&gt;5. 关于ROM API传参的疑惑解释&lt;/h3&gt;
&lt;p&gt;　　最后再简单说一下第4节示例代码里一点让人疑惑的地方，我们是在MIMXRT500-EVK上做的测试，i.MXRT500有两个FlexSPI（0/1），Flash是连在FlexSPI0上，但是ROM API里的instance传参竟然需要是1（i.MXRT1060 ROM API的FLEXSPI0传参就是0），这是怎么回事？&lt;/p&gt;
&lt;p&gt;　　下面是i.MXRT500 BootROM中根据instance获取FLEXSPI模块基址的函数代码，其是根据i.MXRT500头文件中FLEXSPI_BASE_PTRS定义来获取基址值的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;static FLEXSPI_Type *const g_flexSpiInstances[] = FLEXSPI_BASE_PTRS;

static FLEXSPI_Type *flexspi_get_module_base(uint32_t instance)
{
    FLEXSPI_Type *baseAddr = NULL;
    baseAddr = g_flexSpiInstances[instance];
    return baseAddr;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　而BootROM中用的i.MXRT500头文件中FLEXSPI_BASE_PTRS定义如下所示，有点奇怪，跟正式SDK里的定义不一致。其实也可以理解，BootROM是芯片设计阶段的产物，那时候头文件是初版，后期有变化也正常。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;/** Array initializer of FLEXSPI peripheral base pointers */
#define FLEXSPI_BASE_PTRS                      \
    {                                          \
        (FLEXSPI_Type *)0u, FLEXSPI1, FLEXSPI2 \
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　至此，i.MXRT三位数系列隐藏的FlexSPI Remap功能痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 20 Aug 2020 13:58:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>前段时间痞子衡写了一篇文章 《利用i.MXRT1060,1010上新增的FlexSPI地址重映射(Remap)功能可安全OTA》，介绍了Remap功能在OTA设计中的重要性。如果你对比过i.MXRT三</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13538105.html</dc:identifier>
</item>
<item>
<title>C++ Templates (2.1 类模板Stack的实现 Implementation of Class Template Stack) - 失落孤舟</title>
<link>http://www.cnblogs.com/kaycharm/p/13532307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaycharm/p/13532307.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kaycharm/p/13433381.html#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AB%A0%E8%8A%82%E7%9B%AE%E5%BD%95&quot;&gt;返回完整目录&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;正如函数模板，可以如下方式在一个头文件中声明和定义类&lt;code&gt;Stack&amp;lt;&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// basics/stack1.hpp

#include &amp;lt;vector&amp;gt;
#include &amp;lt;cassert&amp;gt;

template &amp;lt;typename T&amp;gt;
class Stack
{
private:
      std::vector&amp;lt;T&amp;gt; elems;      //元素

public:
      void push(T const&amp;amp; elem);      //压入元素
      void pop();      // 弹出元素
      T const&amp;amp; top() const;      //返回顶上的元素
      bool empty()      //返回栈stack是否为空
      {
            return elems.empty();
      }
};

template &amp;lt;typename T&amp;gt;
void Stack&amp;lt;T&amp;gt;::push(T const&amp;amp; elem)
{
      elems.push_back(elem);      //将elem的拷贝放入elems末尾
}

template &amp;lt;typename T&amp;gt;
void Stack&amp;lt;T&amp;gt;::pop()
{
      assert(!elems.empty());
      elems.pop_back();      //移除最后一个元素
}

template &amp;lt;typename T&amp;gt;
T const&amp;amp; Stack&amp;lt;T&amp;gt;::top() const
{
      assert(!elems.empty());
      return elems.back();      //返回最后一个元素
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如所看到的，该类模板使用C++标准库的&lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt;实现，这样便无需实现内存管理、拷贝控制和赋值运算，这样便可以将重心放在类模板的接口上。&lt;/p&gt;
&lt;h2 id=&quot;211-声明类模板-declaration-of-class-templates&quot;&gt;2.1.1 声明类模板 Declaration of Class Templates&lt;/h2&gt;
&lt;p&gt;声明类模板与声明函数模板类似：在声明之前，必须声明一个或多个类型参数的标识符。再一次，T是一个常用的标识符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
class Stack
{
...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的关键字&lt;code&gt;typename&lt;/code&gt;也可以用&lt;code&gt;class&lt;/code&gt;代替：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;class T&amp;gt;
class Stack
{
...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在类模板中，T可以像其他任何类型一样用于声明成员和成员函数（member function）。该例子中，T用于声明成员的类型为T的向量vector，用于声明成员函数&lt;code&gt;push()&lt;/code&gt;使用T类型作为参数，用于声明成员函数&lt;code&gt;top()&lt;/code&gt;的返回类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
class Stack
{
private:
      std::vector&amp;lt;T&amp;gt; elems;      //元素

public:
      void push(T const&amp;amp; elem);      //压入元素
      void pop();      // 弹出元素
      T const&amp;amp; top() const;      //返回顶上的元素
      bool empty()      //返回栈stack是否为空
      {
            return elems.empty();
      }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类的类型为Stack，其中T为模板参数。因此，只要在声明中使用该类的类型，必须使用Stack，除非模板参数可以推断而得。然而，在类模板内，使用没有模板实参的类名意味着将类模板实参作为模板参数（However, inside a class template using the class name not followed by template arguments represents the class with its template parameters as its arguments.）（详见13.2.3节）。&lt;/p&gt;
&lt;p&gt;比如，如果必须声明构造函数和赋值运算符，这通常看起来像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
class Stack
{
      ...
      Stack(Stack const&amp;amp;);      //拷贝构造
      Stack&amp;amp; operator=(Stack const&amp;amp;);      //赋值运算符
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这与如下形式等价：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
class Stack
{
      ...
      Stack(Stack&amp;lt;T&amp;gt; const&amp;amp;);      //拷贝赋值
      Stack&amp;lt;T&amp;gt;&amp;amp; operator=(Stack&amp;lt;T&amp;gt; const&amp;amp;);      //赋值运算符
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但通常意味着对特殊模板参数的特殊处理，因此第一种形式更好。&lt;/p&gt;
&lt;p&gt;然而，在类结构之外需要指定模板参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
bool operator==(Stack&amp;lt;T&amp;gt; const&amp;amp; lhs, Stack&amp;lt;T&amp;gt; const&amp;amp; rhs);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到在需要类名而不是类的类型的地方，仅仅使用Stack便可以。这特别是在构造函数和析构函数名字的情形中。&lt;/p&gt;
&lt;p&gt;与非模板类不同，不能在函数内部或者&lt;code&gt;块作用域（block scope）&lt;/code&gt;内声明类模板。通常，模板只能定义在全局作用域（global scope）或者命名空间作用域（namespace scope）或者类声明内（详见12.1节）。&lt;/p&gt;
&lt;h2 id=&quot;212-成员函数实现-implementation-of-member-functions&quot;&gt;2.1.2 成员函数实现 Implementation of Member Functions&lt;/h2&gt;
&lt;p&gt;定义类模板的成员函数必须指定这是一个模板且必须使用类模板的完整类型限制。因此，类型Stack的成员函数&lt;code&gt;push()&lt;/code&gt;的实现为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
void Stack&amp;lt;T&amp;gt;::push(T const&amp;amp; elem)
{
      elems.push_back(elem);      //将elem的拷贝放入elems末尾
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该情况下，成员向量的&lt;code&gt;push_bask()&lt;/code&gt;方法被调用，将元素放入向量vector的末尾。&lt;/p&gt;
&lt;p&gt;注意到向量vector的&lt;code&gt;pop_back()&lt;/code&gt;将移除最后一个元素但不返回，这行为的原因是&lt;strong&gt;异常安全（exception safety）&lt;/strong&gt;。不可能实现一个返回移除元素的完全异常安全的&lt;code&gt;pop()&lt;/code&gt;版本（该问题首先由Tom Cargill在[CargilExceptionSafety]中的第10项条款[SutterExceptional]中讨论）。然而，如果忽略该危险，可以实现返回移除的元素的&lt;code&gt;pop()&lt;/code&gt;。为实现此功能，简单地使用T来声明类型为元素类型的局部变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
T Stack&amp;lt;T&amp;gt;::pop()
{
      assert(!elems.empty());
      T elem = elems.back();      //保存最后一个元素
      elems.pop_back();      //移除最后一个元素
      return elem;      //返回保存元素的拷贝
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于当vector中没有元素时，&lt;code&gt;back()&lt;/code&gt;（返回最后一个元素）和&lt;code&gt;pop_back()&lt;/code&gt;（移除最后一个元素）都将有未定义的行为，因此需要检查栈是否为空。如果为空，则断言（assert），因为在空的栈上调用&lt;code&gt;pop()&lt;/code&gt;是错误的。在&lt;code&gt;top()&lt;/code&gt;上也需要这么做，它返回顶上的元素但不移除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
T const&amp;amp; Stack&amp;lt;T&amp;gt;::top() const
{
      assert(elems.empty());
      return elems.back();      //返回最后一个元素
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，对于任何成员函数，也可以将类模板的成员函数在类的声明中实现为inline，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
class Stack
{
      ...
      void push(T const&amp;amp; elem)
      {
            elems.push_back(elem);      //将elem放入末尾
      }
};
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Aug 2020 13:57:00 +0000</pubDate>
<dc:creator>失落孤舟</dc:creator>
<og:description>返回完整目录 2.1 类模板Stack的实现 Implementation of Class Template Stack 正如函数模板，可以如下方式在一个头文件中声明和定义类Stack&amp;amp;lt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kaycharm/p/13532307.html</dc:identifier>
</item>
<item>
<title>【故障公告】阿里云 RDS 数据库突发 CPU 近 100% 引发全站故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/13538091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/13538091.html</guid>
<description>&lt;p&gt;今天晚上9点我们收到阿里云的告警通知，收到通知后，我们立即登录阿里云 RDS 控制台进行主备库切换，等主备库完成切换后一看并没有切换过来，赶紧再次进行切换，第2次切换成功了，切换完成后 CPU 立刻降至正常水平，全站恢复正常。这次故障发生时间是8月20日20:55~21:14，由此给您带来麻烦，请您谅解。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;66.619146722164&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35695/202008/35695-20200820213902223-1633586256.png&quot; width=&quot;600&quot; height=&quot;290&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天晚上9点我们收到阿里云的告警通知：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;【阿里云监控】华东1(杭州)-云数据库RDS版&amp;lt;cnblogsdb&amp;gt; [instanceId=xxx] 于21:00 发生告警， 前往诊断 CPU使用率平均值（98.25&amp;gt;=80 ）， 持续时间4分钟, rds_CpuUsage&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;收到通知后，我们立即登录阿里云 RDS 控制台进行主备库切换，等主备库完成切换后一看并没有切换过来，赶紧再次进行切换，第2次切换成功了，切换完成后 CPU 立刻降至正常水平，全站恢复正常。&lt;/p&gt;
&lt;p&gt;这次故障发生时间是8月20日20:55~21:14，由此给您带来麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;上次发生同样故障是6月24日，详见 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/cmt/p/13185741.html&quot;&gt;【故障公告】阿里云 RDS 实例 CPU 100% 故障引发全站无法正常访问&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;阿里云数据库专家分析后怀疑是“LINQ 生成的 SQL 存在问题，导致概率性 SQL Server 出现参数嗅探问题”。&lt;/p&gt;
&lt;p&gt;我们会进一步分析并优化这次引发参数嗅探问题的 SQL 语句。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 20 Aug 2020 13:55:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>今天晚上9点我们收到阿里云的告警通知，收到通知后，我们立即登录阿里云 RDS 控制台进行主备库切换，等主备库完成切换后一看并没有切换过来，赶紧再次进行切换，第2次切换成功了，切换完成后 CPU 立刻降</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/13538091.html</dc:identifier>
</item>
<item>
<title>Java进阶专题(十一) 探究JMM - 道阻且长啊</title>
<link>http://www.cnblogs.com/whgk/p/13534969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whgk/p/13534969.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;​ JMM即java内存模型，JMM研究的就是多线程下Java代码的执行顺序，共享变量的读写。它定义了Java虚拟机在计算机内存中的工作方式。从抽象角度看，JMM定义了线程和主存之间的抽象关系：线程之前的共享变量存储在主内存中，每个线程有个私有的本地内存，本地内存中存储了该线程读写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他硬件和编译器优化。&lt;/p&gt;
&lt;p&gt;​ 先抛出两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你写的代码一定是实际运行的代码吗？&lt;/li&gt;
&lt;li&gt;代码的编写顺序，一定是实际执行的顺序吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt;Java Language Specification Chapter 17. Threads and Locks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec/&quot;&gt;JSR-133: JavaTM Memory Model and Thread Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/dl/jmm/cookbook.html&quot;&gt;Doug Lea' s JSR-133 cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书籍：《Java Concurrency in Practice》&lt;/p&gt;
&lt;p&gt;并发测试框架：&lt;a href=&quot;https://wiki.openjdk.java.net/display/CodeTools/jcstress&quot;&gt;jcstress&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;多线程读写共享变量&quot;&gt;多线程读写共享变量&lt;/h2&gt;
&lt;h3 id=&quot;问题演示&quot;&gt;问题演示&lt;/h3&gt;
&lt;p&gt;猜猜一下代码在多线程的情况下，会发生什么样的情况？&lt;/p&gt;
&lt;h4 id=&quot;永远的循环&quot;&gt;永远的循环&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean stop;
@Actor
public void a1() {
   while(!stop){
   }
}
@Signal
void a2() {
   stop = true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;加加减减&quot;&gt;加加减减&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int balance = 10;
@Actor
public void deposit() {
   balance += 5;
}
@Actor
public void withdraw() {
   balance -= 5;
}
@Arbiter
public void query(I_Result r) {
   r.r1 = balance;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第四种可能&quot;&gt;第四种可能&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a;
int b;
@Actor
public void actor1(II_Result r) {
   b = 1;
   r.r2 = a;
}
@Actor
public void actor2(II_Result r) {
   a = 2;
   r.r1 = b;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题解密&quot;&gt;问题解密&lt;/h3&gt;
&lt;h4 id=&quot;循环问题-揭秘&quot;&gt;循环问题-揭秘&lt;/h4&gt;
&lt;p&gt;为了方便测试，改造下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo6;

import java.util.concurrent.TimeUnit;

public class WhileTest {
    static boolean stop;

    public static void a1() {
        while (true) {
            boolean b = stop;
            if (b) {
                break;
            }
        }
    }
    
    public static void main(String[] args) {
        new Thread(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            stop = true;
            System.out.println(&quot;stop&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;true!&quot;);
        }).start();
        a1();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820144049043-1517957044.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现main主线程中，调用了啊a1()方法，子线程1秒后，对stop修改了true，按正常逻辑，死循环应该会break终止了，但是实际上运行，我们发现，一直在循环中，并未终止！&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;先用 -XX:+PrintCompilation 来查看即时编译情况（% 的含义 On-Stack-Replacement（OSR））&lt;/p&gt;
&lt;p&gt;再尝试用 -Xint 强制解释执行&lt;/p&gt;
&lt;h4 id=&quot;加加减减问题-解密&quot;&gt;加加减减问题-解密&lt;/h4&gt;
&lt;p&gt;代码演示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo6;

import java.util.Arrays;
import java.util.List;

public class AddSubTest {
    static int balance = 10;

    private static void add(){
        balance+=5;
    }
    private static void sub(){
        balance-=5;
    }

    public static void main(String[] args) throws InterruptedException {
        List&amp;lt;Thread&amp;gt; threadList = Arrays.asList(new Thread(AddSubTest::add), new Thread(AddSubTest::sub));
        threadList.forEach(Thread::start);
        for (Thread thread : threadList) {
            thread.join();
        }
        System.out.println(balance);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回用一下ASM 工具，可以看到源码第10 行的 balance += 5 的字节码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;LINENUMBER 8 L0
   GETSTATIC TestAddSub.balance : I
   ICONST_5
   IADD
   PUTSTATIC TestAddSub.balance : I
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而第13 行的 balance -= 5 字节码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;LINENUMBER 12 L0
   GETSTATIC TestAddSub.balance : I
   ICONST_5
   ISUB
   PUTSTATIC TestAddSub.balance : I
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换成伪代后&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static int balance = 10;

    private static void add(){
        //balance+=5;
        int b = balance;
        b += 5;
        balance = b;
    }
    private static void sub(){
        //balance-=5;
        int c = balance;
        c -= 5;
        balance = c;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能出现的执行顺序如下:&lt;/p&gt;
&lt;p&gt;case1: 线程1和2串行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int b = balance; // 线程1
b += 5;          // 线程1
balance = b;     // 线程1
int c = balance; // 线程2
c -= 5;          // 线程2
balance = c;     // 线程2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case2:线程1和线程2同时拿到10,线程1执行完,线程2再执行完&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int c = balance; // 线程2
int b = balance; // 线程1
b += 5;          // 线程1
balance = b;     // 线程1
c -= 5;          // 线程2
balance = c;     // 线程2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case3:线程1和线程2同时拿到10,线程2执行完,线程1再执行完&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int b = balance; // 线程1
int c = balance; // 线程2
c -= 5;          // 线程2
balance = c;     // 线程2
b += 5;          // 线程1
balance = b;     // 线程1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第四种可能-揭秘&quot;&gt;第四种可能-揭秘&lt;/h4&gt;
&lt;p&gt;代码演示:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo6;

public class FourthResultTest {
    int a;
    int b;

    private void actor1(IIResult r){
        b=1;
        r.r2 = a;
    }

    private void actor2(IIResult r){
        a=2;
        r.r1 = b;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能出现的结果&lt;/p&gt;
&lt;p&gt;case1:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;b = 1;      // 线程1
r.r2 = a;   // 线程1
a = 2;      // 线程2
r.r1 = b;   // 线程2
// 结果 r1==1, r2==0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case2:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a = 2;      // 线程2
r.r1 = b;   // 线程2
b = 1;      // 线程1
r.r2 = a;   // 线程1
// 结果 r1==0, r2==2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case3:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a = 2;      // 线程2
b = 1;      // 线程1
r.r2 = a;   // 线程1
r.r1 = b;   // 线程2
// 结果 r1==1, r2==2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case4:这种结果是不是超乎你的预期了?这是因为可能是编译器调整了指令执行顺序&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;r.r2 = a;   // 线程1
a = 2;      // 线程2
r.r1 = b;   // 线程2
b = 1;      // 线程1
// 结果 r1==0, r2==0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;思考为什么&quot;&gt;思考为什么&lt;/h3&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果让一个线程总是占用CPU 是不合理的，所有任务调度器会让线程分时使用CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编译器以及硬件层面都会做层层优化，提升性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compiler/JIT 优化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Processor 流水线优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache 优化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;编辑器优化&quot;&gt;编辑器优化&lt;/h4&gt;
&lt;p&gt;case1:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//优化前
x=1
y=&quot;universe&quot;
x=2
//优化后
y=&quot;universe&quot;
x=2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case2:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//优化前
for(i=0;i&amp;lt;max;i++){
       z += a[i]
   }
//优化后
t = z
for(i=0;i&amp;lt;max;i++){
       t += a[i]
   }
z = t
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;case3:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//优化前
if(x&amp;gt;=0){
y = 1;
// ...
}
//优化后
y = 1;
if(x&amp;gt;=0){
// ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;processor优化&quot;&gt;Processor优化&lt;/h4&gt;
&lt;p&gt;流水线在CPU 的一个时钟周期内会执行多个指令的不同部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非流水线操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有三条指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;---|---|---|
1   2   3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每条指令执行花费300ps 时间，最后将结果存入寄存器需要20ps&lt;br/&gt;一秒能运行的指令数为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820144156563-587917450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流水线操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仔细分析就会发现，可以把每个指令细分为三个阶段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;A|B|C|          // 1
 A|B|C|        // 2
   A|B|C|      // 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加一些寄存器，缓存每一阶段的结果，这样就可以在执行 指令1-C 阶段时，同时执行 指令2-B 以及 指令3-A&lt;br/&gt;一秒能运行的指令数为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820144224741-525364635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;execute-out-of-order&quot;&gt;execute out of order&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在按序执行中，一旦遇到指令依赖的情况，流水线就会停滞&lt;/li&gt;
&lt;li&gt;如果采用乱序执行，就可以跳到下一个非依赖指令并发布它。这样，执行单元就可以总是处于工作状态，把&lt;br/&gt;时间浪费减到最少&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缓存优化&quot;&gt;缓存优化&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820144234091-1796783106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MESI (CPU缓存一致性)协议 引入缓存的副作用在于同一份数据可能保存了副本，一致性该如何保证呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Modified - 要向其它CPU 发送cache line 无效消息，并等待ack&lt;/li&gt;
&lt;li&gt;Exclusive - 独占、即将要执行修改&lt;/li&gt;
&lt;li&gt;Shared - 共享、一般读取时的初始状态&lt;/li&gt;
&lt;li&gt;Invalid - 一旦发现数据无效，需要重新加载数据&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;例子&quot;&gt;例子&lt;/h4&gt;
&lt;p&gt;就上文所说的第四种可能:r1 和r2 有没有可能同时为0&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;r.r1 = b;   // 线程2 与 a = 2 重排
r.r2 = a;   // 线程1 与 a = 1 重排
b = 1;      // 线程1
a = 2;      // 线程2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面从缓存的角度分析，注意假定指令没有重排&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;b = 1;      // 线程1 - 写入 CPU-0 的 store buffer
a = 2;      // 线程2 - 写入 CPU-1 的 store buffer
r.r1 = b;   // 线程2 - 马上执行
r.r2 = a;   // 线程1 - 马上执行
// 线程1 - 将 store buffer 中的 b = 1 写入 cache, 晚了
// 线程2 - 将 store buffer 中的 a = 2 写入 cache, 晚了
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;我们关注问题的点&quot;&gt;我们关注问题的点&lt;/h3&gt;
&lt;p&gt;​ 以上介绍了多线程读写共享变量可能发生的哪些问题?但对于程序员而言，我们不应当关注究竟是编译器优化、Processor 优化、缓存优化。否则，就好像打开了潘多拉魔盒！&lt;/p&gt;
&lt;h2 id=&quot;jmm内存模型&quot;&gt;JMM内存模型&lt;/h2&gt;
&lt;h3 id=&quot;什么是jmm&quot;&gt;什么是JMM&lt;/h3&gt;
&lt;p&gt;A memory model describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program. A high level, informal overview of the memory model shows it to be a set of rules for when writes by one thread are visible to another thread.&lt;/p&gt;
&lt;p&gt;多线程下，共享变量的读写顺序是头等大事，内存模型就是多线程下对共享变量的一组读写规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享变量值是否在线程间同步&lt;/li&gt;
&lt;li&gt;代码可能的执行顺序&lt;/li&gt;
&lt;li&gt;需要关注的操作就有两种Load、Store
&lt;ul&gt;&lt;li&gt;Load 就是从缓存读取到寄存器中，如果一级缓存中没有，就会层层读取二级、三级缓存，最后才是Memory&lt;/li&gt;
&lt;li&gt;Store 就是从寄存器运算结果写入缓存，不会直接写入Memory，当Cache line 将被eject 时，会&lt;br/&gt;writeback 到Memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jmm规范&quot;&gt;JMM规范&lt;/h2&gt;
&lt;h4 id=&quot;规则一-race-condition&quot;&gt;规则一 Race Condition&lt;/h4&gt;
&lt;p&gt;​ 在多线程下，没有关系依赖的代码，在操作共享变量时（至少有一个线程写），并不能保证按编写顺序（Program Order）执行，这称为发生了竞态条件（Race Conditon）。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;有共享变量 x，线程 1 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;r.r1 = y; 
r.r2 = x;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程 2 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;x = 1; 
y = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的结果可能是 r1&lt;mark&gt;1 而 r2&lt;/mark&gt;0&lt;/p&gt;
&lt;p&gt;竞态条件是为了更好的 data race free。&lt;/p&gt;
&lt;h4 id=&quot;规则二-syncronization-order&quot;&gt;规则二 Syncronization Order&lt;/h4&gt;
&lt;p&gt;​ 若要保证&lt;strong&gt;多线程&lt;/strong&gt;下，&lt;strong&gt;每个线程&lt;/strong&gt;的&lt;strong&gt;执行顺序&lt;/strong&gt;（Synchronization Order）按编写顺序（Program Order）执行，那么必须&lt;strong&gt;使用&lt;/strong&gt; &lt;strong&gt;Synchronization Actions&lt;/strong&gt; &lt;strong&gt;来保证&lt;/strong&gt;，这些 SA 有&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Synchronization Order&lt;/em&gt; 也称之为 &lt;em&gt;Total Order&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;用 volatile 修饰共享变量 y，线程 1 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;r.r1 = y; 
r.r2 = x;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程 2 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;x = 1; 
y = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的结果就&lt;strong&gt;不可能&lt;/strong&gt;是 r1&lt;mark&gt;1 而 r2&lt;/mark&gt;0&lt;/p&gt;
&lt;h5 id=&quot;so并不是阻止多线程切换&quot;&gt;SO并不是阻止多线程切换&lt;/h5&gt;
&lt;p&gt;错误的认识，线程 1 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;synchronized(LOCK) { 
  r1 = x; //1 处 
  r2 = x; //2 处 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程 2 执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;synchronized(LOCK) { 
  x = 1 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并不是说 //1 与 //2 处之间不能切换到线程 2，只是即使切换到了线程 2，因为线程 2 不能拿到 LOCK 锁导致被阻塞，执行权又会轮到线程 1&lt;/p&gt;
&lt;h5 id=&quot;volatile-只用了一半算-so-吗&quot;&gt;&lt;strong&gt;volatile&lt;/strong&gt; &lt;strong&gt;只用了一半算&lt;/strong&gt; &lt;strong&gt;SO&lt;/strong&gt; 吗?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;用例1&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int x; 
volatile int y;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后采用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;x = 10; //1 处 
y = 20; //2 处
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时 //1 处代码绝不会重排到 //2 处之后（只写了 volatile 变量）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用例&lt;/strong&gt; &lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int x; 
volatile int y;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行下面的测试用例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Actor 
public void a1(II_Result r) { 
  y = 1; //1 处 
  r.r2 = x; //2 处 
}
@Actor 
public void a2(II_Result r) { 
  x = 1; //3 处 
  r.r1 = y; //4 处 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;//1 //2 处的顺序可以保证（只写了 volatile 变量），但 //3 //4 处的顺序却不能保证（只读了 volatile 变量），仍会出现 r1&lt;mark&gt;r2&lt;/mark&gt;0 的问题&lt;/p&gt;
&lt;p&gt;有时会很迷惑人，例如下面的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用例3&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Actor 
public void a1(II_Result r) { 
  r.r2 = x; //1 处 
  y = 1; //2 处 
}
@Actor 
public void a2(II_Result r) { 
  r.r1 = y; //3 处 
  x = 1; //4 处 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回 //1 //2 （只写了 volatile 变量）//3 //4 处（只读了 volatile 变量）的顺序均能保证了，绝不会出现r1&lt;mark&gt;r2&lt;/mark&gt;1 的情况&lt;/p&gt;
&lt;p&gt;​ 此外将用例 2 中两个变量均用 volatile 修饰就不会出现 r1&lt;mark&gt;r2&lt;/mark&gt;0 的问题，因此也把全部都用 &lt;em&gt;volatile&lt;/em&gt; 修饰称为&lt;em&gt;total order&lt;/em&gt;，部分变量用 &lt;em&gt;volatile&lt;/em&gt; 修饰称为 &lt;em&gt;partial order&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;规则三-happens-before&quot;&gt;规则三 Happens Before&lt;/h4&gt;
&lt;p&gt;​ 若是变量读写时&lt;strong&gt;发生线程切换&lt;/strong&gt;（例如，线程 1 写入 x，切换至线程 2，线程 2 读取 x）在这些边界的处理上&lt;strong&gt;如果有&lt;/strong&gt;action1 &lt;strong&gt;先于&lt;/strong&gt; &lt;strong&gt;action 2&lt;/strong&gt; &lt;strong&gt;发生&lt;/strong&gt;，那么代码&lt;strong&gt;可以按确定的顺序&lt;/strong&gt;执行，这称之为 &lt;strong&gt;Happens-Before Order&lt;/strong&gt; 规则(&lt;em&gt;Happens-Before Order&lt;/em&gt; 也称之为 &lt;em&gt;Partial Order&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;用公式表达就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212223348-1145987560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;含义为：如果 action1 先于 action2 发生，那么 action1 之前的共享变量的修改对于 action2 &lt;strong&gt;可见&lt;/strong&gt;，且代码按 PO&lt;strong&gt;顺序&lt;/strong&gt;执行&lt;/p&gt;
&lt;h5 id=&quot;具体规则&quot;&gt;具体规则&lt;/h5&gt;
&lt;p&gt;其中 $T_{n}$ 代表线程，而 x 未加说明，是普通共享变量，使用 volatile 会单独说明&lt;/p&gt;
&lt;h5 id=&quot;1）线程的启动和运行边界&quot;&gt;1）线程的启动和运行边界&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212234711-905975963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;2）线程的结束和join边界&quot;&gt;2）线程的结束和join边界&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212247535-1019908661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3）线程的打断和得知打断的边界&quot;&gt;3）线程的打断和得知打断的边界&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212302937-492808887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;4）unlock-与-lock-边界&quot;&gt;4）&lt;strong&gt;unlock&lt;/strong&gt; &lt;strong&gt;与&lt;/strong&gt; &lt;strong&gt;lock&lt;/strong&gt; &lt;strong&gt;边界&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212315977-1829899709.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;5）volatile-write-与-volatile-read-边界&quot;&gt;5）&lt;strong&gt;volatile write&lt;/strong&gt; &lt;strong&gt;与&lt;/strong&gt; &lt;strong&gt;volatile read&lt;/strong&gt; &lt;strong&gt;边界&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212327955-291320079.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;6）传递性&quot;&gt;6）传递性&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212336616-783991906.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;规则四-causality&quot;&gt;规则四 Causality&lt;/h4&gt;
&lt;p&gt;Causality 即因果律：代码之间如&lt;strong&gt;存在依赖关系&lt;/strong&gt;，&lt;strong&gt;即使没有加&lt;/strong&gt; &lt;strong&gt;SA&lt;/strong&gt; 操作，代码的执行顺序也是可以预见的&lt;/p&gt;
&lt;p&gt;回顾一下&lt;/p&gt;
&lt;p&gt;​ &lt;em&gt;多线程下，没有依赖关系的代码，在共享变量读写操作（至少有一个线程写）时，并不能保证以编写顺序（Program Order）执行，这称为发生了竞态条件（Race Condition）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果有一定的依赖关系呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JCStressTest
@Outcome(id = {&quot;0&quot;, &quot;0&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(expect = Expect.FORBIDDEN, desc = &quot;FORBIDDEN&quot;)
@State
public class Case {
    int x;
    int y;

    @Actor
    public void a1(IIResult r) {
        r.r1 = x;
        y = r.r1;
    }

    @Actor
    public void a2(IIResult r){
        r.r2 = y;
        x = r.r2;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;x 的值来自于 y，y 的值来自于 x，而二者的初始值都是 0，因此没有可能有其他结果&lt;/p&gt;
&lt;h4 id=&quot;规则五安全发布&quot;&gt;规则五安全发布&lt;/h4&gt;
&lt;p&gt;若要安全构造对象，并将其共享使用，&lt;strong&gt;需要用&lt;/strong&gt; &lt;strong&gt;final&lt;/strong&gt; &lt;strong&gt;或&lt;/strong&gt; &lt;strong&gt;volatile&lt;/strong&gt; &lt;strong&gt;修饰其成员变量&lt;/strong&gt;，并&lt;strong&gt;避免&lt;/strong&gt; &lt;strong&gt;this&lt;/strong&gt; &lt;strong&gt;溢出&lt;/strong&gt;情况(静态成员变量可以安全地发布)&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Holder{
    int x1;
    volatile int x2;

    public Holder(int x) {
        x1=x;
        x2=x;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要将它作为全局使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Holder f;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个线程，一个创建，一个使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Holder holder;

@Actor
public void a1(){
  holder = new Holder(1);
}

@Actor
public void a2(IIResult r){
  Holder holder = this.holder;
  if (holder != null){
    r.r1 = holder.x1 +holder.x2;
  }else {
    r.r1 = -1;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能看见未构造完整的对象&lt;/p&gt;
&lt;h2 id=&quot;同步动作&quot;&gt;同步动作&lt;/h2&gt;
&lt;p&gt;前面没有详细展开从规则 2 之后的讲解，是因为要理解规则，还需理解底层原理，即内存屏障&lt;/p&gt;
&lt;h3 id=&quot;内存屏障&quot;&gt;内存屏障&lt;/h3&gt;
&lt;h4 id=&quot;loadload&quot;&gt;LoadLoad&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212350869-2013411859.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;防止 y 的 Load 重排到 x 的 Load 之前&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if(x) { 
  LoadLoad 
    return y 
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;意义：x == true 时，再去获取 y，否则可能会由于重排导致 y 的值相对于 x 是过期的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;loadstore&quot;&gt;LoadStore&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212403522-1224380374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;防止 y 的 Store 被重排到 x 的 Load 之前&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;storesotre&quot;&gt;StoreSotre&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212413582-412954655.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;防止 A 的 Store 被重排到 B 的 Store 之后&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;A = x 
StoreStore 
B = true
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;意义：在 B 修改为 true 之前，其它线程别想看到 A 的修改&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有点类似于 sql 中更新后，commit 之前，其它事务不能看到这些更新（B 的赋值会触发 commit 并撤除屏障）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;storeload&quot;&gt;StoreLoad&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212423763-1970844561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;意义：屏障前的改动都&lt;strong&gt;同步到主存&lt;/strong&gt; ，屏障后的 Load &lt;strong&gt;获取主存最新数据&lt;/strong&gt;，发生在线程切换时，并且使得蓝色线程所有的写操作写入主存，使得红色线程能读取到最新数据
&lt;ul&gt;&lt;li&gt;防止屏障前所有的写操作，被重排序到屏障后的任何的读操作，可以认为此 store -&amp;gt; load 是连续的&lt;/li&gt;
&lt;li&gt;有点类似于 git 中先 commit，再远程 poll，而且这个动作是原子的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;如何记忆&quot;&gt;如何记忆&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;LoadLoad + LoadStore = Acquire 即让同一线程内读操作之后的读写上不去，第一个 Load 能读到主存最新值&lt;/li&gt;
&lt;li&gt;LoadStore + StoreStore = Release 即让同一线程内写操作之前的读写下不来，后一个 Store 能将改动都写入主存&lt;/li&gt;
&lt;li&gt;StoreLoad 最为特殊，还能用在线程切换时，对变量的写操作 &lt;strong&gt;+&lt;/strong&gt; 读操作做同步，只要是对同一变量先写后读，那么屏障就能生效&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;volatile&quot;&gt;Volatile&lt;/h3&gt;
&lt;h4 id=&quot;本质&quot;&gt;本质&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212434687-2145733747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上对 volatile 而言 Store-Load 屏障最为有用，简化起见以后的分析省略部分其他屏障&lt;/p&gt;
&lt;h4 id=&quot;作用&quot;&gt;作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;保证单一变量的原子性&lt;/li&gt;
&lt;li&gt;控制了可能的执行路径： 线程内按屏障有序，线程切换时按HB有序&lt;/li&gt;
&lt;li&gt;可见性：线程切换时若发生了读写则变量可见，顺带影响普通变量可见&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;volatile的用途&quot;&gt;volatile的用途&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;凡是需要cas操作的地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如AtomicInteger的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AtomicInteger extends Number implements java.io.Serializable {
    private static final Unsafe U = Unsafe.getUnsafe();
    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);
    private volatile int value; 
    
    // ...

    public final boolean compareAndSet(int expectedVal, int newVal) {
        return U.compareAndSetInt(this, VALUE, expectedVal, newVal);
    }
    
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;AbstractQueuedSynchronizer&lt;/em&gt;的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    private transient volatile Node head;
    private transient volatile Node tail;
    private volatile int state;

    protected final int getState() {
        return state;
    }

    protected final boolean compareAndSetState(int e, int n) {
        return U.compareAndSetInt(this, STATE, e, n);
    }

    final void enqueue(Node node) {
        if (node != null) {
            for (; ; ) {
                Node t = tail;
                node.setPrevRelaxed(t);
                if (t == null) tryInitializeHead();

                else if (casTail(t, node)) {
                    t.next = node;
                    if (t.status &amp;lt; 0) LockSupport.unpark(node.waiter);
                    break;
                }
            }
        }
    }

    private void tryInitializeHead() {
        Node h = new ExclusiveNode(); // 头
        if (U.compareAndSetReference(this, HEAD, null, h)) tail = h;
    }

    private boolean casTail(Node c, Node v) {
        return U.compareAndSetReference(this, TAIL, c, v);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;ConcurrentHashMap&lt;/em&gt;源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcurrentHashMap&amp;lt;K, V&amp;gt; extends AbstractMap&amp;lt;K, V&amp;gt; implements ConcurrentMap&amp;lt;K, V&amp;gt;, Serializable {
    /**
     * Table initialization and resizing control. When negative, the
     * table is being initialized or resized: -1 for initialization,
     * else -(1 + the number of active resizing threads). Otherwise,
     * when table is null, holds the initial table size to use upon
     * reation, or 0 for default. After initialization, holds the
     * next element count value upon which to resize the table.
     */
    private transient volatile int sizeCtl;
    /**
     * The array of bins. Lazily initialized upon first insertion.
     * Size is always a power of two. Accessed directly by iterators.
     */
    transient volatile Node&amp;lt;K, V&amp;gt;[] table;

    private final Node&amp;lt;K, V&amp;gt;[] initTable() {
        Node&amp;lt;K, V&amp;gt;[] tab;
        int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) &amp;lt; 0) Thread.yield();
            else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                        Node&amp;lt;K, V&amp;gt;[] nt = (Node&amp;lt;K, V&amp;gt;[]) new Node&amp;lt;?, ?&amp;gt;[n];
                        table = tab = nt;
                        sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
    // ... 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile负责保证可见性，cas来保证原子&lt;/p&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;Synchronized&lt;/h3&gt;
&lt;p&gt;本质&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212452659-2135317720.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;起始synchronized本质就是通两个JVM指令：monitorenter和monitorexit来实现了，我们可以通过下面一段代码的来研究下，其原理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com;

public class SynchronizedTest {
    static int i = 0;
    public static void main(String[] args) {
        synchronized (SynchronizedTest.class){
            i++;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过反编译看下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; #......
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: ldc           #2                  // class com/SynchronizedTest
         2: dup
         3: astore_1
         4: monitorenter
         5: getstatic     #3                  // Field i:I
         8: iconst_1
         9: iadd
        10: putstatic     #3                  // Field i:I
        13: aload_1
        14: monitorexit
        15: goto          23
        18: astore_2
        19: aload_1
        20: monitorexit
        21: aload_2
        22: athrow
        23: return
#......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到就是通过jvm指令monitorenter、monitorexit实现的，结合上图，具体步骤如下：&lt;/p&gt;
&lt;p&gt;我们知道synchronized是通加对象锁来实现的，但是这个对象是否作为锁而存在呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当线程1执行synchronized时，jvm调用monitorenter时，就会先操作系统申请一个操作系统的Moniter锁（底层由c++实现的），并把其地址存放在LOCK对象头中。&lt;/li&gt;
&lt;li&gt;当线程1根据LOCK对象头找到Moniter锁，判断owner是否被占用，没有被占用，就会修改其值，等于持有了锁。&lt;/li&gt;
&lt;li&gt;大概线程2同样会执行monitorenter指令，根据LOCK对象头找到Moniter锁，判断owner是否被占用，发现已经被占用，首先会自旋尝试获取，一定次数没获取到，就会进入EntryList队列等待，并从运行状态变成阻塞状态，线程3也是如此。&lt;/li&gt;
&lt;li&gt;当线程1执行完毕或出现异常时就会执行monitorexit，释放owner并唤醒EntryList中的被阻塞线程，具体都队列头还是队列尾部去唤醒，这个根据具体算法实现，这里不做赘述。&lt;/li&gt;
&lt;li&gt;假如线程2被唤醒就会去获取owner是否空闲，空闲了就占用，线程3依然处于阻塞状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相关内存屏障&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202008/874710-20200820212506305-1753503154.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优化（jdk16之后）&quot;&gt;优化（JDK1.6之后）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;重量级
&lt;ul&gt;&lt;li&gt;当有竞争时，仍会向系统申请 Monitor 互斥锁&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;轻量级锁
&lt;ul&gt;&lt;li&gt;如果线程加锁、解锁时间上刚好是错开的，这时候就可以使用轻量级锁，只是使用 cas 尝试将对象头替换为该线程的锁记录地址，如果 cas 失败，会锁重入或触发重量级锁升级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;偏向锁
&lt;ul&gt;&lt;li&gt;打个比方，轻量级锁就好比用课本占座，线程每次占座前还得比较一下，课本是不是自己的（cas），频繁 cas 性能也会受到影响&lt;/li&gt;
&lt;li&gt;而偏向锁就好比座位上已经刻好了线程的名字，线程【专用】这个座位，比 cas 更为轻量&lt;/li&gt;
&lt;li&gt;但是一旦其他线程访问偏向对象，那么比较麻烦，需要把座位上的名字擦去，这称之为&lt;strong&gt;偏向锁撤销&lt;/strong&gt;，锁也升级为轻量级锁&lt;/li&gt;
&lt;li&gt;偏向锁撤销也属于昂贵的操作，怎么减少呢，JVM 会记录&lt;strong&gt;这一类对象&lt;/strong&gt;被撤销的次数，如果超过了 20 这个阈值，下次新线程访问偏向对象时，就不用撤销了，而是刻上新线程的名字，这称为&lt;strong&gt;重偏向&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果撤销次数进一步增加，超过 40 这个阈值，JVM 会认为&lt;strong&gt;这一类对象&lt;/strong&gt;不适合采用偏向锁，会对它们禁用偏向锁，下次新建对象会直接加轻量级锁&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;无锁与有锁&quot;&gt;无锁与有锁&lt;/h4&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;synchronized 更为重量，申请锁、锁重入都要&lt;strong&gt;发起系统调用&lt;/strong&gt;，频繁调用性能会受影响&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;synchronized 如果无法获取锁时，线程会陷入阻塞，引起的&lt;strong&gt;线程上下文切换&lt;/strong&gt;成本高&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;虽然做了一系列优化，但&lt;strong&gt;轻量级锁&lt;/strong&gt;、&lt;strong&gt;偏向锁&lt;/strong&gt;都是针对&lt;strong&gt;无数据竞争场景&lt;/strong&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果数据的原子操作时间较长，仍应该让线程阻塞，无锁适合的是&lt;strong&gt;短频快的共享数据修改操作&lt;/strong&gt;主要用于&lt;strong&gt;计数器&lt;/strong&gt;、&lt;strong&gt;停止标记&lt;/strong&gt;、或是&lt;strong&gt;阻塞前的有限尝试&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;varhandle&quot;&gt;VarHandle&lt;/h3&gt;
&lt;h4 id=&quot;目前无锁问题实现&quot;&gt;目前无锁问题实现&lt;/h4&gt;
&lt;p&gt;​ 目前Java 中的无锁技术主要体现在以AtomicInteger 为代表的的原子操作类，它的底层使用Unsafe 实现，而Unsafe 的问题在于安全性和可移植性&lt;br/&gt;​ 此外，volatile 主要使用了Store-Load 屏障来控制顺序，这个屏障还是太强了，有没有更轻量级的解决方法呢？&lt;/p&gt;
&lt;h4 id=&quot;varhandle快速上手&quot;&gt;Varhandle快速上手&lt;/h4&gt;
&lt;p&gt;​ 在Java9 中引入了VarHandle，来提供更细粒度的内存屏障，保证共享变量读写可见性、有序性、原子性。提供了更好的安全性和可移植性，替代Unsafe 的部分功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestVarHandle {
   int x;
   static VarHandle X;
   
   static {
       try {
           X = MethodHandles.lookup()
               .findVarHandle(TestVarHandle.class, &quot;x&quot;, int.class);
       } catch (NoSuchFieldException | IllegalAccessException e) {
           e.printStackTrace();
       }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读写&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;获取值&lt;/td&gt;
&lt;td&gt;与普通变量取值一样，会重排、有不可见现象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;设置值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getOpaque&lt;/td&gt;
&lt;td&gt;获取值&lt;/td&gt;
&lt;td&gt;对其保护的变量，保证其不重排和可见性，但不使用屏障，不阻碍其它变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;setOpaque&lt;/td&gt;
&lt;td&gt;设置值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getAcquire&lt;/td&gt;
&lt;td&gt;获取值&lt;/td&gt;
&lt;td&gt;相当于get 之后加LoadLoad + LoadStore&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setRelease&lt;/td&gt;
&lt;td&gt;设置值&lt;/td&gt;
&lt;td&gt;相当于set 之前加LoadStore + StoreStore&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getVolatile&lt;/td&gt;
&lt;td&gt;获取值&lt;/td&gt;
&lt;td&gt;语义同volatile，相当于获取之后加LoadLoad + LoadStore&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setVolatile&lt;/td&gt;
&lt;td&gt;设置值&lt;/td&gt;
&lt;td&gt;语义同volatile，相当于设置之前加LoadStore + StoreStore，设置之后加StoreLoad&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;compareAndSet&lt;/td&gt;
&lt;td&gt;原子赋值&lt;/td&gt;
&lt;td&gt;原子赋值，成功返回true，失败返回false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;更多安全问题&quot;&gt;更多安全问题&lt;/h2&gt;
&lt;h3 id=&quot;单个变量读写原子性&quot;&gt;单个变量读写原子性&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;64 位系统vs 32 位系统&lt;br/&gt;如果需要保证long 和double 在32 位系统中原子性，需要用volatile 修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;JMM9 之前&lt;br/&gt;JMM9 32 位系统下double 和long 的问题，double 没有问题，long 在-server -XX:+UnlockExperimentalVMOptions -XX:-AlwaysAtomicAccesses 才有问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;object-alignment&quot;&gt;Object alignment&lt;/h3&gt;
&lt;p&gt;​ 你或许听说过对象对齐，它的一个主要目的就是为了单个变量读写的原子性，可以使用jol 工具查看java 对象的内存布局&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;0.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestJol {
   public static void main(String[] args) {
       String layout = ClassLayout.parseClass(Test.class).toPrintable();
       System.out.println(layout);
   }
   public static class Test {
       private byte a;
       private byte b;
       private byte c;
       private long e;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启对象头压缩（默认）输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;com.itheima.test.TestJol$Test object internals:
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0    12        (object header)                           N/A
12     1   byte Test.a                                    N/A
13     1   byte Test.b                                    N/A
14     1   byte Test.c                                    N/A
15     1        (alignment/padding gap)             
16     8   long Test.e                                    N/A
Instance size: 24 bytes
Space losses: 1 bytes internal + 0 bytes external = 1 bytes total
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不开启对象头压缩 -XX:-UseCompressedOops 输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;com.itheima.test.TestJol$Test object internals:
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0    16        (object header)                           N/A
16     8   long Test.e                                    N/A
24     1   byte Test.a                                    N/A
25     1   byte Test.b                                    N/A
26     1   byte Test.c                                    N/A
27     5        (loss due to the next object alignment)
Instance size: 32 bytes
Space losses: 0 bytes internal + 5 bytes external = 5 bytes total
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字分裂&quot;&gt;字分裂&lt;/h3&gt;
&lt;p&gt;前面也看到了，Java 能够保证单个共享变量读写是原子的，类似的数组元素的读写，也会提供这样的保证&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;byte[8]
[0][1][2][3]
[0][1][2][3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上述效果不能保证，则称之为发生了字分裂现象，java 中没有字分裂，但Java 中某些实现会有类似字分裂现象，例如BitSet、Unsafe 读写等&lt;/p&gt;
&lt;h4 id=&quot;数组元素读写测试&quot;&gt;数组元素读写测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JCStressTest
@Outcome(id = {&quot;0&quot;, &quot;-1&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(expect = Expect.FORBIDDEN, desc = &quot;FORBIDDEN&quot;)
@State
public static class Case4 {
   byte[] b = new byte[256];
   int off = ThreadLocalRandom.current().nextInt(256);
   @Actor
   public void actor1() {
       b[off] = (byte) 0xFF;
   }
   @Actor
   public void actor2(I_Result r) {
       r.r1 = b[off];
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bigset读写测试&quot;&gt;BigSet读写测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JCStressTest
@Outcome(id = &quot;true, true&quot;, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;INTERESTING&quot;)
@State
public static class Case6 {
   BitSet b = new BitSet();
   @Actor
   public void a() {
       b.set(0);
   }
   @Actor
   public void b() {
       b.set(1);
   }
   @Arbiter
   public void c(ZZ_Result r) {
       r.r1 = b.get(0);
       r.r2 = b.get(1);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;unsafe-直接操作内存&quot;&gt;Unsafe 直接操作内存&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestUnsafe {
   public static final long ARRAY_BASE_OFFSET =
UnsafeHolder.U.arrayBaseOffset(byte[].class);
   static byte[] ss = new byte[8];
   public static void main(String[] args) {
       System.out.println(ARRAY_BASE_OFFSET);
       UnsafeHolder.U.putInt(ss, ARRAY_BASE_OFFSET, 0xFFFFFFFF);
       System.out.println(Arrays.toString(ss));
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;16
[-1, -1, -1, -1, 0, 0, 0, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来个压测&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JCStressTest
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(id = &quot;-1&quot;, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;INTERESTING&quot;)
@State
public static class Case5 {
   byte[] ss = new byte[256];
   long base = UnsafeHolder.U.arrayBaseOffset(byte[].class);
   long off = base + ThreadLocalRandom.current().nextInt(256 - 4);
   @Actor
   public void writer() {
       UnsafeHolder.U.putInt(ss,  off, 0xFFFF_FFFF);
   }
   @Actor
   public void reader(I_Result r) {
       r.r1 = UnsafeHolder.U.getInt(ss, off);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Observed state   Occurrences              Expectation  Interpretation
-1    25,591,098               ACCEPTABLE  ACCEPTABLE
-16777216           877   ACCEPTABLE_INTERESTING  INTERESTING
-256           923   ACCEPTABLE_INTERESTING  INTERESTING
-65536           925   ACCEPTABLE_INTERESTING  INTERESTING
0     5,093,890               ACCEPTABLE  ACCEPTABLE
16777215         1,673   ACCEPTABLE_INTERESTING  INTERESTING
255         1,758   ACCEPTABLE_INTERESTING  INTERESTING
65535         1,707   ACCEPTABLE_INTERESTING  INTERESTING
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安全发布&quot;&gt;安全发布&lt;/h3&gt;
&lt;h4 id=&quot;构造也不安全&quot;&gt;构造也不安全&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JCStressTest
@Outcome(id = {&quot;16&quot;, &quot;-1&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ACCEPTABLE&quot;)
@Outcome(expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;INTERESTING&quot;)
@State
public static class Case1 {
   Holder f;
   int v = 1;
   @Actor
   public void a1() {
       f = new Holder(v);
   }
   @Actor
   void a2(I_Result r) {
       Holder o = this.f;
       if (o != null) {
           r.r1 = o.x8 + o.x7 + o.x6 + o.x5 + o.x4 + o.x3 + o.x2 + o.x1;
           r.r1 += o.y8 + o.y7 + o.y6 + o.y5 + o.y4 + o.y3 + o.y2 + o.y1;
       } else {
           r.r1 = -1;
       }
   }
   static class Holder {
       int x1, x2, x3, x4;
       int x5, x6, x7, x8;
       int y1, y2, y3, y4;
       int y5, y6, y7, y8;
       
       public Holder(int v) {
           x1 = v;
           x2 = v;
           x3 = v;
           x4 = v;
           x5 = v;
           x6 = v;
           x7 = v;
           x8 = v;
           y1 = v;
           y2 = v;
           y3 = v;
           y4 = v;
           y5 = v;
           y6 = v;
           y7 = v;
           y8 = v;
       }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因分析&lt;/p&gt;
&lt;p&gt;比如有个Student类代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Student{
    final String name;
    int age;
    
    public Student(name,age){
        this.name =name;
        this.age = age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Student stu为共享变量
stu = new Student(&quot;zhangsan&quot;,18);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name如果没有final修饰&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;t =new Student(name,age)
stu = t
this.name = name
this.age =age
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name如果有final修饰,位置任意&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;t=new Student(name,age)
this.name=name
this.age=age
&amp;gt;----StoreStore----&amp;lt;
stu = t
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用volatile改进&quot;&gt;使用volatile改进&lt;/h4&gt;
&lt;p&gt;name 有volatile 修饰，注意位置必须在最后&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;t=new Student(name,age)
this.age=age
this.name=name
&amp;gt;----Store Load----&amp;lt;
stu =t
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;JMM 是研究的是&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;多线程下Java 代码的执行顺序，实际代码的执行顺序与你编写的代码顺序不同&lt;/li&gt;
&lt;li&gt;共享变量的读写操作，在竞态条件下，需要考虑共享变量读写的原子性、可见性、有序性&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;共享变量的问题起因&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;原子性是由于操作系统的分时机制，线程切换所致&lt;/li&gt;
&lt;li&gt;有序性和可见性可能来自于编译器优化、处理器优化、缓存优化&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;JMM 制定了一些规则，理解这些规则，才能写出正确的线程安全代码&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;竞态条件会导致代码顺序被重排&lt;/li&gt;
&lt;li&gt;利用synchronized、volatile 一些SA，可以控制线程内代码的执行顺序&lt;/li&gt;
&lt;li&gt;线程切换时的执行顺序与可见性，遵守HB 规则&lt;/li&gt;
&lt;li&gt;HB 规则还不足够，需要因果律作为补充&lt;/li&gt;
&lt;li&gt;可以通过final 或volatile 实现对象的安全发布&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;从底层理解volatile 与synchronized&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;内存屏障&lt;/li&gt;
&lt;li&gt;synchronized 是如何解决原子性、可见性、有序性问题的，有哪些优化&lt;/li&gt;
&lt;li&gt;volatile 是如何解决可见性、有序性问题的，与cas 结合的威力&lt;/li&gt;
&lt;li&gt;VarHandle 是如何解决可见性、有序性问题的&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;更多安全问题&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;单个变量、数组元素的读写原子性&lt;/li&gt;
&lt;li&gt;能够列举字分裂的几个相关例子&lt;/li&gt;
&lt;li&gt;构造方法什么情况下会线程不安全，如何改进&lt;/li&gt;
&lt;li&gt;彻底掌握DCL 安全单例&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 20 Aug 2020 13:26:00 +0000</pubDate>
<dc:creator>道阻且长啊</dc:creator>
<og:description>前言 ​	JMM即java内存模型，JMM研究的就是多线程下Java代码的执行顺序，共享变量的读写。它定义了Java虚拟机在计算机内存中的工作方式。从抽象角度看，JMM定义了线程和主存之间的抽象关系：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whgk/p/13534969.html</dc:identifier>
</item>
</channel>
</rss>