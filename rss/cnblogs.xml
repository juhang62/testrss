<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>马云，你不缺孩子，很多人叫你爸爸 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10847606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10847606.html</guid>
<description>&lt;p&gt;不得了不得了，昨天马老师教你生孩子你的通知收到了吗？没收到的，我传达一下中心思想啊&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/l08695hwa02.html&quot;&gt;马云：工作996，生活669&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没错，结婚不是为了买房子买车子，而是一起生孩子！&lt;/p&gt;
&lt;p&gt;那我首先是不是得有个对象？&lt;/p&gt;
&lt;p&gt;我天天996，我脑子里都是程序，你倒是给我new 一个出来啊！&lt;/p&gt;
&lt;p&gt;马老板还说了，工作上我们要996，婚姻里我们要669。&lt;/p&gt;
&lt;p&gt;你们知道669是什么意思吗？6天6次还要持久。&lt;/p&gt;
&lt;p&gt;前段时间，你说要996，我特么信了你的鬼，还给你洗白，为此我都和老婆闹翻了，你今天再来个669？老婆能放过我？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221537158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着马老板就说了&lt;/p&gt;
&lt;p&gt;“孩子是无价之宝，所有东西都可能是别人的，都可能是假的，只有孩子才是真正自己的。”&lt;/p&gt;
&lt;p&gt;你实话实说，到底程序重要还是孩子重要？&lt;/p&gt;
&lt;p&gt;你要选孩子，请让我6点回家找孩子&lt;/p&gt;
&lt;p&gt;你要选程序，请你现在给自己一个击掌&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221545465.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你跟我说生孩子是婚姻的KPI&lt;/p&gt;
&lt;p&gt;那生1个叫刚过及格线，生2个叫超额完成目标，生3个那叫扶贫帮困咯？&lt;/p&gt;
&lt;p&gt;当然这种事情也不是没有过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221551942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们响应号召，我们积极面对，我们欣然接受，我们……&lt;/p&gt;
&lt;p&gt;但你要保证哦，不要在下一个时间，你又让我&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221558552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;马老板，你说的道理我懂，孩子是国家的栋梁&lt;/p&gt;
&lt;p&gt;少年强则国强，少年富则国富，少年独立则国独立&lt;/p&gt;
&lt;p&gt;那少年我现在刚结婚，你让我在弄个少年出来，不合适啊&lt;/p&gt;
&lt;p&gt;你不能自己669，让我们也跟着669啊，我们还得996不是&lt;/p&gt;
&lt;p&gt;只有996，才能买房子&lt;/p&gt;
&lt;p&gt;只有996，才能买车子&lt;/p&gt;
&lt;p&gt;只有996，才能进ICU啊&lt;/p&gt;
&lt;p&gt;现在假设我听你的话了，我行动起来了！&lt;/p&gt;
&lt;p&gt;我开始按照你说的&lt;/p&gt;
&lt;p&gt;“30年前投资房子，这是一种增值，现在我们要投资孩子，因为未来孩子就是最有价值的”&lt;/p&gt;
&lt;p&gt;感情以后马路上行走的都是悍马、劳斯莱斯咯？&lt;/p&gt;
&lt;p&gt;我们骑着自行车，给悍马、劳斯莱斯导航咯？&lt;/p&gt;
&lt;p&gt;说实话，我丈母娘20年前就有这么一个梦&lt;/p&gt;
&lt;p&gt;所以每天坚持买彩票，买的时候就一句话&lt;/p&gt;
&lt;p&gt;“一翻五”&lt;/p&gt;
&lt;p&gt;一个号码，买5次！要么不中，一中就是2500w！&lt;/p&gt;
&lt;p&gt;所以我老婆到现在还在吃低保&lt;/p&gt;
&lt;p&gt;要不是嫁给了我&lt;/p&gt;
&lt;p&gt;早改善生活了，早买爱马仕了，为什么？&lt;/p&gt;
&lt;p&gt;因为我们有孩子了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221610737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生孩子这件事情，马老师你可能缺少点经验&lt;/p&gt;
&lt;p&gt;我来告诉你&lt;/p&gt;
&lt;p&gt;女人从怀上到生育，你知道要经过多少时间吗？&lt;/p&gt;
&lt;p&gt;10个月！&lt;/p&gt;
&lt;p&gt;这个知识点你记住了，以后会考&lt;/p&gt;
&lt;p&gt;10个月能干嘛？&lt;/p&gt;
&lt;p&gt;她们每天要受到多少情绪的影响&lt;/p&gt;
&lt;p&gt;要跑多少次医院&lt;/p&gt;
&lt;p&gt;做多少次检查&lt;/p&gt;
&lt;p&gt;被多少个陌生人围观&lt;/p&gt;
&lt;p&gt;你倒好，让刚熬过来的再来一次轮回&lt;/p&gt;
&lt;p&gt;你这是典型的生产队啊&lt;/p&gt;
&lt;p&gt;你还是车间主任了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190510221620982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我老婆生孩子，我都陪着，遭了多少罪，那都是在她身上看得到的&lt;/p&gt;
&lt;p&gt;你要不要试试身上拉一刀&lt;/p&gt;
&lt;p&gt;然后在你缝合的刀口上每半个小时用力按5-6次&lt;/p&gt;
&lt;p&gt;马老师，你今天这番言论你算是崩了&lt;/p&gt;
&lt;p&gt;我要像那些取关我还留言给我取关的读者一样&lt;/p&gt;
&lt;p&gt;我要告诉你&lt;/p&gt;
&lt;p&gt;马老师，我要路转黑了，我要取关你微博了，我要撤资阿里巴巴了&lt;/p&gt;
&lt;p&gt;如果你想和我一起撤资的，转发出去，让大家一起撤资&lt;/p&gt;
&lt;p&gt;转发后记得截图发我，我的微信在公众号「Python专栏」里获取，我会在明天晚上20:00拉群，发大红包！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426060447314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70#pic_center%20=200x200&quot; alt=&quot;python专栏&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 23:01:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>你们知道669是什么意思吗？6天6次还要持久。 前段时间，你说要996，我特么信了你的鬼，还给你洗白，为此我都和老婆闹翻了，你今天再来个669？老婆能放过我？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10847606.html</dc:identifier>
</item>
<item>
<title>从零开始制作cli工具，快速创建项目脚手架 - 海角在眼前</title>
<link>http://www.cnblogs.com/lovesong/p/10847433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesong/p/10847433.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在工作过程中，我们常常会从一个项目工程复制代码到一个新的项目，改项目配置信息、删除不必要的代码。&lt;/p&gt;
&lt;p&gt;这样做的效率比较低，也挺繁琐，更不易于分享协作。&lt;/p&gt;
&lt;p&gt;所以，我们可以制作一个cli工具，用来快速创建一个新项目的脚手架。如vue-cli就是一个非常好用的cli工具。&lt;/p&gt;
&lt;p&gt;PS：cli 是一个全局安装的 npm 包。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;制作一个cli工具，步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、将我们的工程模板放到Github上。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果工程模板有很多个，可以新建一个Organizations，统一放置到这里面。我工程模板有很多个，会统一放Organizations下面。&lt;/p&gt;
&lt;p&gt;如果工程模板是放在公司gitlab上，则可以新建一个Group来统一管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、定义控制台命令，包含其参数。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数一般有 -v 显示包版本， -h 显示帮助信息，create 作为创建项目的命令参数。&lt;/p&gt;
&lt;p&gt;如vue-cli的创新项目命令是 vue create [name]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、创建一个npm包工程，实现以上command功能。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如今Github已有很多cli工具，可以clone一个作为参考模板。&lt;/p&gt;
&lt;p&gt;PS：我做的cli工具将在最下面放出链接。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;刚开始要做cli工具时，我头脑里就有几个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、怎么快速获取到输入的命令行参数？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我相信已有好的npm包可以完成这功能，我不想自己再从头做一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、怎么做选项选择功能、文字输入？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于我的工程模板会有很多个，就想做个选项功能，创建工程时可以选择其中一个模板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、怎么优雅地输出日志？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;console.log虽然可以用，但样式不好看，需要区分info、error日志。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、怎么快速获取到输入的命令行参数？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yargs模块能够解决如何处理命令行参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、怎么做选项选择功能、文字输入？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;inquirer模块能够处理命令行交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、怎么优雅地输出日志？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;chalk模块解决字符串样式问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体实现步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、获取模板列表&lt;/p&gt;
&lt;p&gt;2、设置模板选项&lt;/p&gt;
&lt;p&gt;3、获取模板的tag列表&lt;/p&gt;
&lt;p&gt;4、设置tag选项&lt;/p&gt;
&lt;p&gt;5、设置项目信息输入&lt;/p&gt;
&lt;p&gt;6、下载zip_ball，并复制到目标位置&lt;/p&gt;
&lt;p&gt;7、修改项目的信息&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体实现代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_b2a12e52-24b8-4de2-85d9-e8b8002e2ad4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b2a12e52-24b8-4de2-85d9-e8b8002e2ad4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b2a12e52-24b8-4de2-85d9-e8b8002e2ad4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #!/usr/bin/env node
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; yargs = require(&quot;yargs&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; info = require(&quot;./info.js&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; args =&lt;span&gt; yargs
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    .command({
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         command: &quot;create &amp;lt;name&amp;gt;&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         desc: &quot;Create a bingolink template.&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        builder: {},
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(argv) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; projectName =&lt;span&gt; argv.name;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取模板列表&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             info.getTemplates(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(templates){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.设置选项&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 info.showTemplateList(templates, (templateName) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; t = templates.find((template) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; template.name ==&lt;span&gt; templateName;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.获取标签列表&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     info.getTags(t.tagsUrl, (tags) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.设置选项&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                         info.showTagList(tags, (tagName) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; tag = tags.find((tag) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                                 &lt;span&gt;return&lt;/span&gt; tag.name ==&lt;span&gt; tagName;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.项目信息输入&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                             info.showProjectInputView(projectName, (project) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                 projectName =&lt;span&gt; project.project_name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.下载zip_ball，并复制到目标位置&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                                 info.downloadZipball(tag.zipUrl, projectName, () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.修改项目的信息&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                                    info.editProjectInfo(project);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                                })
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                            })
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                        })
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    })
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     .version() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use package.json's version&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    .help()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    .alias({
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &quot;h&quot;: &quot;help&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &quot;v&quot;: &quot;version&quot;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     .strict(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    .demandCommand()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     .argv;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面是入口js的代码，虽然有回调地狱，但还算比较清晰。&lt;/p&gt;
&lt;p&gt;其他代码就不贴上，可以clone我的工程下来看。&lt;/p&gt;
&lt;p&gt;工程地址：&lt;a href=&quot;https://github.com/codingforme/bingolink-cli&quot;&gt;https://github.com/codingforme/bingolink-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;发布npm包&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、npm adduser&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发布npm包前，需要先登录npm。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、npm publish&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在工程的根目录，执行这命令即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、npm adduser可能会出现如下的错误。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/555379/201905/555379-20190511001620929-1770016952.png&quot; alt=&quot;&quot; width=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现第一错误时，有人说要在Username前加个~号。&lt;/p&gt;
&lt;p&gt;我加了，也确实显示登录成功了，但还是怎么都发布不上，一直显示User Not Found。&lt;/p&gt;
&lt;p&gt;所以我重新注册了一个npmjs帐号，然后npm logout，再npm adduser新帐号，才发布成功！！！&lt;/p&gt;

&lt;p&gt;本文为原创文章，转载请保留原出处，方便溯源，如有错误地方，谢谢指正。&lt;/p&gt;
&lt;p&gt;本文地址 ：&lt;a href=&quot;http://www.cnblogs.com/lovesong/p/10847433.html&quot;&gt;http://www.cnblogs.com/lovesong/p/10847433.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 16:21:00 +0000</pubDate>
<dc:creator>海角在眼前</dc:creator>
<og:description>背景 在工作过程中，我们常常会从一个项目工程复制代码到一个新的项目，改项目配置信息、删除不必要的代码。 这样做的效率比较低，也挺繁琐，更不易于分享协作。 所以，我们可以制作一个cli工具，用来快速创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesong/p/10847433.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Swagger接入使用IdentityServer4 的 WebApi - 乔达摩</title>
<link>http://www.cnblogs.com/xiaxiaolu/p/10847248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxiaolu/p/10847248.html</guid>
<description>&lt;p&gt;是这样的，我们现在接口使用了Ocelot做网关，Ocelot里面集成了基于IdentityServer4的开发的授权中心用于对Api资源的保护。问题来了，我们的Api用了&lt;a href=&quot;https://swagger.io/&quot;&gt;SwaggerUI&lt;/a&gt;做接口的自文档，那就蛋疼了，你接入了IdentityServer4的Api，用SwaggerUI调试、调用接口的话，妥妥的401，未授权啊。那有小伙伴就会说了，你SwaggerUI的Api不经过网关不就ok了？诶，好办法。但是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我不想改变Url规则啊，我是&lt;code&gt;/api&lt;/code&gt;开头的Url都是经过网关的，如果不经过网关要加端口或者改变Url规则，会给其他部门的同事带来麻烦（多个Url规则容易混淆）；&lt;/li&gt;
&lt;li&gt;另外是，因为生产环境是接入了IdentityServer4，我想测试环境从一开始就需要调用方熟悉的接入，避免平时用没有经过授权中心的Url调试，一到生产就出问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ok，废话讲得有点多，我们就直奔主题。&lt;/p&gt;
&lt;p&gt;下面我们需要创建两个示例项目：&lt;/p&gt;
&lt;p&gt;1、IdentityServer4的授权中心；&lt;/p&gt;
&lt;p&gt;2、使用SwaggerUI做自文档的WebApi项目；&lt;/p&gt;
&lt;blockquote readability=&quot;1.1150442477876&quot;&gt;
&lt;p&gt;本文源码地址：&lt;a href=&quot;https://github.com/gebiWangshushu/cnblogs-demos/tree/master/SwggerUI.IdentityServer4.Example&quot; class=&quot;uri&quot;&gt;https://github.com/gebiWangshushu/cnblogs-demos/tree/master/SwggerUI.IdentityServer4.Example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;新建空白解决方案并添加一个空的webapi项目identityserver&quot;&gt;1、新建空白解决方案，并添加一个空的WebApi项目，IdentityServer&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232425540-891232538.png&quot; alt=&quot;1557495509700&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;引用包&quot;&gt;2、引用包。&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package IdentityServer4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加配置类config.cs&quot;&gt;3、添加配置类：Config.cs&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace IdentityServer
{
    public class Startup
    {
        public IHostingEnvironment Environment { get; }

        public Startup(IHostingEnvironment environment)
        {
            Environment = environment;
        }
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            var builder = services.AddIdentityServer()
                    .AddInMemoryIdentityResources(Config.GetIdentityResources())
                    .AddInMemoryApiResources(Config.GetApis())
                    .AddInMemoryClients(Config.GetClients())
                    .AddTestUsers(Config.GetUsers());

            if (Environment.IsDevelopment())
            {
                builder.AddDeveloperSigningCredential();
            }
            else
            {
                throw new Exception(&quot;need to configure key material&quot;);
            }
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseIdentityServer();
            app.UseIdentityServer();
            app.UseMvcWithDefaultRoute();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改startup.cs&quot;&gt;4、修改Startup.cs&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace IdentityServer
{
    public class Startup
    {
        public IHostingEnvironment Environment { get; }

        public Startup(IHostingEnvironment environment)
        {
            Environment = environment;
        }
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            var builder = services.AddIdentityServer()
                    .AddInMemoryIdentityResources(Config.GetIdentityResources())
                    .AddInMemoryApiResources(Config.GetApis())
                    .AddInMemoryClients(Config.GetClients())
                    .AddTestUsers(Config.GetUsers());

            if (Environment.IsDevelopment())
            {
                builder.AddDeveloperSigningCredential();
            }
            else
            {
                throw new Exception(&quot;need to configure key material&quot;);
            }
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseIdentityServer();
            app.UseIdentityServer();
            app.UseMvcWithDefaultRoute();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok,跑起来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232425017-1406967804.png&quot; alt=&quot;1557497033760&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;添加webapi项目swaggeruiapi&quot;&gt;1、添加WebApi项目，SwaggerUIApi&lt;/h2&gt;
&lt;p&gt;现在项目结构这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232424462-387713103.png&quot; alt=&quot;1557497204567&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;先添加swaggerui先不接入identityserver&quot;&gt;2、先添加SwaggerUI，&lt;strong&gt;先不接入IdentityServer&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;修改Startup.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Swashbuckle.AspNetCore.Swagger;

namespace SwggerUIApi
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddSwaggerGen(c =&amp;gt;
            {
                c.SwaggerDoc(&quot;v1&quot;, new Info
                {
                    Version = &quot;v1&quot;,
                    Title = &quot;ToDo API&quot;,
                    Description = &quot;A simple example ASP.NET Core Web API&quot;,
                    TermsOfService = &quot;None&quot;,
                    Contact = new Contact
                    {
                        Name = &quot;Shayne Boyer&quot;,
                        Email = string.Empty,
                        Url = &quot;https://twitter.com/spboyer&quot;
                    },
                    License = new License
                    {
                        Name = &quot;Use under LICX&quot;,
                        Url = &quot;https://example.com/license&quot;
                    }
                });
                var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                c.IncludeXmlComments(xmlPath);
            });
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseSwagger();

            // Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), 
            // specifying the Swagger JSON endpoint.
            app.UseSwaggerUI(c =&amp;gt;
            {
                c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;My API V1&quot;);
            });
            app.UseMvc();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到这样的SwaggerUI：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232423908-2112322595.png&quot; alt=&quot;1557497953754&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们调用一下接口：&lt;/p&gt;
&lt;p&gt;杠杠的200：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232423235-2082891182.png&quot; alt=&quot;1557497995457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、接口项目我们接入IdentityServer4&lt;/p&gt;
&lt;p&gt;修改：Startup.cs ,ConfigureServices方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  .AddIdentityServerAuthentication(options =&amp;gt;
           {
              options.Authority = &quot;http://localhost:5000&quot;; // IdentityServer服务器地址
              options.ApiName = &quot;swagger_api&quot;; // 用于针对进行身份验证的API资源的名称
              options.RequireHttpsMetadata = false; // 指定是否为HTTPS
          });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改：Startup.cs ,Configure方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.UseAuthentication();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ok，可以看到我们接入进去了，401，未授权了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232422598-1480842350.png&quot; alt=&quot;1557498423814&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;接入identityserver&quot;&gt;3、接入IdentityServer&lt;/h2&gt;
&lt;h3 id=&quot;添加授权响应操作的过滤器authresponsesoperationfilter.cs&quot;&gt;1、添加授权响应操作的过滤器，AuthResponsesOperationFilter.cs&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.AspNetCore.Authorization;
using Swashbuckle.AspNetCore.Swagger;
using Swashbuckle.AspNetCore.SwaggerGen;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace SwggerUIApi
{
    public class AuthResponsesOperationFilter : IOperationFilter
    {
        public void Apply(Operation operation, OperationFilterContext context)
        {
            //获取是否添加登录特性
            var authAttributes = context.MethodInfo.DeclaringType.GetCustomAttributes(true)
             .Union(context.MethodInfo.GetCustomAttributes(true))
             .OfType&amp;lt;AuthorizeAttribute&amp;gt;().Any();

            if (authAttributes)
            {
                operation.Responses.Add(&quot;401&quot;, new Response { Description = &quot;暂无访问权限&quot; });
                operation.Responses.Add(&quot;403&quot;, new Response { Description = &quot;禁止访问&quot; });
                operation.Security = new List&amp;lt;IDictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt;
                {
                    new Dictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; {{&quot;oauth2&quot;, new[] { &quot;swagger_api&quot; } }}
                };
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改startup.cs-configureservices方法的services.addswaggergen&quot;&gt;2、修改Startup.cs ,ConfigureServices方法的，services.AddSwaggerGen()&lt;/h3&gt;
&lt;p&gt;配置成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     services.AddSwaggerGen(c =&amp;gt;
            {
                c.SwaggerDoc(&quot;v1&quot;, new Info
                {
                    Version = &quot;v1&quot;,
                    Title = &quot;ToDo API&quot;,
                    Description = &quot;A simple example ASP.NET Core Web API&quot;,
                    TermsOfService = &quot;None&quot;,
                    Contact = new Contact
                    {
                        Name = &quot;Shayne Boyer&quot;,
                        Email = string.Empty,
                        Url = &quot;https://twitter.com/spboyer&quot;
                    },
                    License = new License
                    {
                        Name = &quot;Use under LICX&quot;,
                        Url = &quot;https://example.com/license&quot;
                    }
                });
                var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                c.IncludeXmlComments(xmlPath);

                //接入identityserver
                c.AddSecurityDefinition(&quot;oauth2&quot;, new OAuth2Scheme
                {
                    Flow = &quot;implicit&quot;, // 只需通过浏览器获取令牌（适用于swagger）
                    AuthorizationUrl = &quot;http://localhost:5000/connect/authorize&quot;,//获取登录授权接口
                    Scopes = new Dictionary&amp;lt;string, string&amp;gt; {
                        { &quot;swagger_api_scopde&quot;, &quot;swagger_api access&quot; }//指定客户端请求的api作用域。 如果为空，则客户端无法访问
                    }
                });
                c.OperationFilter&amp;lt;AuthResponsesOperationFilter&amp;gt;();
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;我们还需给授权中心添加一个登陆界面&quot;&gt;3、我们还需给授权中心添加一个登陆界面&lt;/h3&gt;
&lt;p&gt;去： &lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4/tree/master/samples/Quickstarts/3_ImplicitFlowAuthentication/src/IdentityServer&quot; class=&quot;uri&quot;&gt;https://github.com/IdentityServer/IdentityServer4/tree/master/samples/Quickstarts/3_ImplicitFlowAuthentication/src/IdentityServer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载这个两个文件夹，丢到IdentityServer项目下面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232421906-476130098.png&quot; alt=&quot;1557500638819&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目结构：&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232421298-1624338697.png&quot; alt=&quot;1557500675473&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;我们运行看看&quot;&gt;4、我们运行看看&lt;/h3&gt;
&lt;p&gt;先启动Identityserver项目&lt;/p&gt;
&lt;p&gt;运行SwaggerUI可以看到，这两个地方了个小锁头，表示已启用安全保护：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232420841-721502578.png&quot; alt=&quot;1557500788279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点一下上面的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232420256-1506107525.png&quot; alt=&quot;1557500876183&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哇，我们跳到了这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232419507-584375052.png&quot; alt=&quot;1557501003686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入：alice/alice,点登录：&lt;/p&gt;
&lt;p&gt;哇哇：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232418929-745229599.png&quot; alt=&quot;1557501070248&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然是Yes啦，然后这边变成这样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232418384-179263448.png&quot; alt=&quot;1557501113274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是已获得授权状态，我们再次调用看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201905/641760-20190510232417567-1667716162.png&quot; alt=&quot;1557501152535&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们看到已经调用成功，仔细看请求，与前面简短的请求不同的是，现在请求里面带了access_token了，&lt;/p&gt;
&lt;p&gt;这才是我们折腾这么久得来的宝贝。&lt;/p&gt;

&lt;p&gt;写得有点匆忙，希望大家能看得懂[捂脸];&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/gebiWangshushu/cnblogs-demos/tree/master/SwggerUI.IdentityServer4.Example&quot; class=&quot;uri&quot;&gt;https://github.com/gebiWangshushu/cnblogs-demos/tree/master/SwggerUI.IdentityServer4.Example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; class=&quot;uri&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; class=&quot;uri&quot;&gt;https://github.com/IdentityServer/IdentityServer4&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 15:26:00 +0000</pubDate>
<dc:creator>乔达摩</dc:creator>
<og:description>﻿ 写在前面 是这样的，我们现在接口使用了Ocelot做网关，Ocelot里面集成了基于IdentityServer4的开发的授权中心用于对Api资源的保护。问题来了，我们的Api用了 'Swagge</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaxiaolu/p/10847248.html</dc:identifier>
</item>
<item>
<title>java数据结构和算法06（红黑树） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10811702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10811702.html</guid>
<description>&lt;p&gt;　　这一篇我们来看看红黑树，首先说一下我啃红黑树的一点想法，刚开始的时候比较蒙，what？这到底是什么鬼啊？还有这种操作？有好久的时间我都缓不过来，直到我玩了两把王者之后回头一看，好像有点儿意思，所以有的时候碰到一个问题困扰了很久可以先让自己的头脑放松一下，哈哈！&lt;/p&gt;
&lt;p&gt;　　不瞎扯咳，开始今天的正题；&lt;/p&gt;
&lt;p&gt;　　前提：看红黑树之前一定要先会搜索二叉树&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.红黑树的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　红黑树到底是个什么鬼呢？我最开始也在想这个问题，你说前面的搜索二叉树多牛，各种操作效率也不错，用起来很爽啊，为什么突然又冒出来了红黑树啊？&lt;/p&gt;
&lt;p&gt;　　确实，搜索二叉树一般情况下足够了，但是有个很大的缺陷，向搜索二叉树中插入的数据必须是随机性比较强大的；如果你是插入的顺序是按照一定的顺序的，比如10、9、8、7、6、5、4、3、2、1，你把这十个数据插入到搜索二叉树中你就会看到一个比较有趣的现象；玛德，这二叉树居然变成链表了（此时的链表也可以说是不平衡树），这就意味着变成链表之后就丧失了身为搜索二叉树的所有特性，这就很可怕，而且当这种有顺序的数据很多的时候，就特别坑爹，查询的效率贼慢；&lt;/p&gt;
&lt;p&gt;　　所以就出现了红黑树这种数据结构，可以说这是一种特殊的搜索二叉树，是对搜索二叉树进行改进之后的一种很完美的二叉树，这种数据结构最厉害的就是可以自动调整树的结构，就比如上面这种有顺序的数据插入到红黑树之后，红黑树就会自动的啪啪啪给你一顿调节最后还是一棵正常的搜索二叉树，不会变成链表就对了；&lt;/p&gt;
&lt;p&gt;　　那么就有人要问了，要怎么样才能将一个搜索二叉树变成红黑树呢？&lt;/p&gt;
&lt;p&gt;　　答：这很容易回答，字如其名，你把搜索二叉树的每个节点要么涂成红色要么涂成黑色，使得最后这个二叉树中所有节点只有红黑两种颜色，这就是一个红黑树；&lt;/p&gt;
&lt;p&gt;　　这时还有人要问了，是不是可以随意把搜索二叉树中的节点涂成红色或者黑色呢？&lt;/p&gt;
&lt;p&gt;　　答：emmmm.....你觉得有这么容易么？哪有这么随便的！肯定是要符合一些规则你才能涂啊，而且大佬们已经把这些规则总结出来了，我们只需要记好这些笔记就好了！&lt;/p&gt;
&lt;p&gt;　　下面我们就看看红黑树要满足的规则：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;（1）：每个节点不是红色就是黑色；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　（2）：根节点总是黑色；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　（3）：不能有两个连续的红色节点；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　（4）：从根节点到每一个叶节点或空子节点的黑色节点的数量一定要相同，这个黑色节点的数量叫做黑色高度，所以这个规则换句话来说就是根节点到每一个叶节点或空子节点的黑色高度相等；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这四个规则很重要，&lt;strong&gt;&lt;span&gt;任何红黑树都必须同时满足这四个规则&lt;/span&gt;&lt;/strong&gt;，否则就不是红黑树，前三个很容易，话说第四个的空子节点是什么意思呢？字如其名，就是一个空的节点，里面什么都没有，可以当作一个null节点，比如下图所示，这个其实理解就好，不用在意；&lt;/p&gt;
&lt;p&gt;　　第四条规则为了好理解才从根节点开始的，其实从任意一个节点开始也是一样的；可以拆分为两条，某个节点到该节点每一个叶节点的黑色高度要一样，同时还要该节点到该节点的每一个空子节点的黑色高度要一样；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506110441814-908007450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　空子节点的定义为：非叶节点可以接子节点的位置；（注意，有的版本没有这个空子节点这个说法，只是说每一个叶节点（NIL）都是黑色的。。。。而且这里的叶节点和之前我们理解的叶节点还不一样，看看下图，但本篇我们还是按照空子节点的这个说法，参考《java数据结构和算法第二版》），理解了之后其实是一样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190510092357925-1770416220.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们再看看下面这个我截的图，假如不看那两个空子节点，看起来好像是符合红黑树规则的，但是我们还要判断根节点到每个空子节点的黑色高度是不是一样，结果不一样，于是下图其实违背了规则四；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506212329596-1564743319.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里继续说一点东西：&lt;/p&gt;
&lt;p&gt;　　新插入的节点必须是红色的，为什么呢？你想啊，你往一个正常的红黑树中插入一个黑色节点，肯定就会百分之百违反第四规则，这就比较坑，每插入一个节点你都要想办法去调整整个树的颜色和结构，这很影响效率；但是假如你插入的节点是红色的，而且这个红色节点还刚好是插入在一个黑色的叶节点那里，诶呀，舒服，什么都不用动；当然还有可能插入到另一个红色节点下面，所以插入红色节点违反规则的概率是百分之五十，用脚趾头都能想到新插入的节点肯定要是红色的啊！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.红黑树调整的方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对了，知不知道计算机中红黑树怎么区分红黑色节点啊？我们不可能真的去给计算机中的节点涂颜色吧。。。。其实我们只需要在节点类中添加一个Boolean color的属性即可，color为true表示黑色，false为红色；&lt;/p&gt;
&lt;p&gt;　　我们在插入红色的节点的时候有两种可能：（1）刚好把这个红色节点插入到一个黑色节点下面，这个时候直接添加就好；（2）比较不幸，插入到一个红色节点下面，这个时候就违反规则3，连续两个节点为红色，这个时候我们要对红黑树的颜色和进行一定调整；&lt;/p&gt;
&lt;p&gt;　　我们对不符合规则的红黑树进行调整操作主要是分为两个步骤：改变颜色和旋转&lt;/p&gt;
&lt;p&gt;　　改变颜色就不多说了，看名字就知道，我们重点就看看旋转到底是什么鬼？通过改变一些节点的颜色使得满足红黑树规则；&lt;/p&gt;
&lt;p&gt;　　通常情况下旋转分为左旋（逆时针）和右旋（顺时针），我们就简单看看右旋吧，左旋差不多；注意下图这里的右旋可不是绕着节点A旋转啊，A叫做顶端，这里相当于是把这两个节点之间的路径进行了一个旋转；（这里很像绕着A节点旋转，很抱歉不是绕着A旋转，下面我们看看红黑树中的右旋就看的很明显了。。。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507202605012-1271301093.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在红黑树中的右旋，在下图中80是“顶端节点”，经过右旋之后顶端节点变为右子节点，而原来的左子节点50变为顶端节点，这样调整了之后70这个节点就没地方放了，于是我们可以顺着右旋之后的50节点的右子节点找到可以存放的位置，也就是80的左子节点，我们可以把70这个节点的移动看作横向移动；&lt;/p&gt;
&lt;p&gt;　　从右往左看就是左旋，这里就不详说了。。。，&lt;/p&gt;
&lt;p&gt;　　对了，顺便提一下，假如这里的70节点有子节点，那么子节点也会跟着一起移动的；我们把70这个节点叫做80这个顶端节点的内侧子孙节点，把30叫做顶端节点80的外侧子孙节点，这个还是很好理解的，30这个节点在树的靠外面，70这个节点始终都是在中里面。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506224942239-1269098702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　网上找到两张动态的图可以看看右旋和左旋，可以好好理解这旋转，&lt;span&gt;&lt;strong&gt;旋转真的很重要！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506224613271-1693496789.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506224629931-186166773.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.添加红黑树节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们通过慢慢的添加一个一个节点，看看红黑树当遇到问题的时候是怎么调整的；&lt;/p&gt;
&lt;p&gt;　　（1）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506205458358-1229250814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（2）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506205940319-624571376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（3）右图这种情况下根节点左边两层，右边一层，稍微有点不平衡，但是没有违反红黑树规则，于是我们不必在意什么；但是假如一条路径比另外一条路径多两层或者两层以上，这个肯定是会违反红黑树规则的，为什么呢？我也不是怎么清楚可能是经过大佬们无数次试验得出来的结论吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190506210921725-363187129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（4）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507203429819-241035456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时我们碰到这种情况，第一感觉是改变10和25的颜色，下图所示，看起来貌似是符合红黑树结构的；但是我们要记住当一条路径多于另外一条路径两层及以上的时候肯定会违反红黑树规则，我们再仔细看看这个图就会发现违反了第四规则中：根节点到空子节点的黑色长度要一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507203646983-1242976702.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;228&quot;/&gt;                  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507204426762-1555608549.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以我们可以知道只是单纯的改变颜色肯定是不能满足红黑树规则的，我们还要再进行旋转，我们以25为顶端节点进行右旋，变成了下图，满足条件，ok！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507204837192-1166579138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（5）.对上面（4）中进行的完善　　&lt;/p&gt;
&lt;p&gt;　　当我们以为（4）这就完美解决的时候，很抱歉还有另外一种情况，当我们新添加的红色节点在10的右子节点上，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507205434823-2137440507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这种情况就比较坑爹，肯定不能像（4）中那样右旋，比如我就不信这个邪，我就要右旋，于是结果如下图一所示，我就默默地信了这个邪！&lt;/p&gt;
&lt;p&gt;　　那么我就要换一个方法了，我就想啊，如果我们能把这个图变成（4）中的那样的结构那不就可以直接用（4）中的解决方法了吗？基于这个想法，我们可以先试着以10为顶点节点，和15节点一起进行左旋，如图二所示，然后我们就发现世界原来一切如此美好，后面的就跟（4）中一样了，这里就不多说了；&lt;/p&gt;
&lt;p&gt;　　但是在这里要注意颜色的变换和上面那个有一点不同，（4）中是改变父节点和爷爷节点的颜色，而图二是经过旋转之后也是改变父节点和爷爷节点的颜色，就是相当于旋转之前的当前节点和爷爷节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507210145002-1862679326.png&quot; alt=&quot;&quot;/&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507210613259-450027313.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在我们把上面调整方式整理一下（想必大家应该知道爷爷节点的意思吧。。。通常都叫做祖父节点，我就喜欢叫爷爷节点，哈哈）：&lt;/p&gt;
&lt;p&gt;　　第一种：假如我们添加的红色节点是添加在黑色节点下，完美；&lt;/p&gt;
&lt;p&gt;　　第二种：假如我们添加的红色节点不小心添加到红色节点下，这里要分为两种情况：&lt;/p&gt;
&lt;p&gt;　　　　假如是左节点（也可以叫做爷爷节点的外侧子孙），那么就改变父节点和爷爷节点的颜色，并且以爷爷节点为顶端节点进行右旋，就ok了；&lt;/p&gt;
&lt;p&gt;　　　　假如是右节点（也可以叫做爷爷节点的内侧子孙） ，那么就改变当前节点和爷爷节点的颜色，然后要以父节点为顶端节点进行左旋，再绕爷爷节点右旋；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;小知识&lt;/span&gt;：怎么快速的判断一个节点是不是它爷爷节点的外侧子孙还是内侧子孙呢？你要看当前节点和父节点是不是在同侧，同侧的就是外侧节点，不同侧就是内侧节点；举个例子，假如当前节点的父节点是左节点，当前节点也是属于左节点，都是左边，那当前节点就是其爷爷节点的外侧节点，如果当前节点是右节点，那就是内侧子孙。。。 　　&lt;/p&gt;

&lt;p&gt;　　（6）.对上面（5）中进一步的完善&lt;/p&gt;
&lt;p&gt;　　╮(￣▽￣&quot;)╭，是不是觉得各种补充的内容啊，哈哈哈，正常！这是最后一个补充了。。。&lt;/p&gt;
&lt;p&gt;　　说出来你们可能不信，上面的（4）和（5）其实都是针对在节点插入之后导致树不平衡而做出的调整，但是会有点小问题，就比如在（4）中，假如50这个节点不是根节点而是一个普通的红色节点，那么在我们首先进行颜色变换的时候就会出现问题，例如下图，那么我们后面的所谓右旋也就没啥用了，所以我们要解决一下这种隐患，最好是在插入数据之前首先对红黑树中的这种有隐患的节点首先进行颜色调整或者旋转；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507214010497-437567534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　那么肯定有人要问了，卧槽！这该怎么做啊？我不会呀，怎么办？&lt;/p&gt;
&lt;p&gt;　　答：不会才正常啊，才能显示那些大佬很牛啊！我们只需要在&lt;span&gt;&lt;strong&gt;插入节点之前&lt;/strong&gt;&lt;/span&gt;对树的一些有隐患的结构进行调整即可（颜色调整和旋转），调整这个有隐患的结构是为了让我们后续的插入节点更加方便；&lt;/p&gt;
&lt;p&gt;　　6.1.颜色调整：红黑树中我们要插入节点，其实是和搜索二叉树一样，从根节点开始一个一个的比较节点数值大小，小就继续和左子节点比较.....最终肯定可以找到确定的位置，在这个找的过程中，假如一个节点为黑色，它的两个子节点都为红色，这就是一种有隐患的结构，我们需要将父节点和两个子节点颜色都改变一下，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190507220443008-1590855091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6.2.旋转：在6.1中虽然对这样的结构进行了颜色的改变，但是有个小缺陷，假如10节点的父节点是红色的呢？那么我们这样改变颜色也是不符合红黑树规则三（不能有连续的两个红节点）的，于是我们还要进行旋转操作，而旋转操作的的话，无非还是上面说的那两种，外侧子孙和内侧子孙；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意：这里的内侧子孙和外侧子孙，不是指新插入的节点，而是两个连续红色节点中的子节点。。。。也就是下面第二个图中的节点10就是爷爷节点50的外侧子孙&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这样说起来比较抽象，我们来实际看看两个例子就ok了；&lt;/p&gt;
&lt;p&gt;　　外侧子孙：假如在向下查找插入点的途中找到了如下结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190510095156744-681406145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190510095715374-912119907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　对红黑树的调整就结束了，有没有发现经过这种调整之后使得后续插入红色节点就容易了很多，而且纵观整棵红黑树，红色节点在慢慢向上运动，直到根节点也被调整成红色，最终我们只需要把根节点变成黑色就好！ 插入节点2就不用多说了吧！&lt;/p&gt;
&lt;p&gt;　　内侧子孙：这个我是在不想说了，偷个懒，嘿嘿嘿！其实和前面一样的，就是先改变两个连续红节点的子节点和爷爷节点的颜色，然后绕父节点左旋，最后绕爷爷节点右旋，换汤不换药；&lt;/p&gt;

&lt;p&gt; 4.总结重点&lt;/p&gt;
&lt;p&gt;　　我们把这篇的重点提出来，其实就是分为插入前和插入后两步：&lt;/p&gt;
&lt;p&gt;　　（1）.插入前我们必须调整一下有隐患的结构，具体操作：当一个黑色节点有两个红色节点的时候，我们就改变这三个节点的颜色，红变黑，黑变红；但是由于这个黑色节点的父节点可能是黑色，也可能是红色&lt;/p&gt;
&lt;p&gt;　　　　　当黑色节点的父节点是黑色的时候，那么这个改变颜色不会造成任何影响&lt;/p&gt;
&lt;p&gt;　　　　   当黑色节点的父节点是红色的时候，改变颜色之后就会违反红黑树规则三，有连续的两个红色节点，我们就需要进行旋转，对于旋转，我们有两种情况&lt;/p&gt;
&lt;p&gt;　　　　　　　　第一种，假如两个连续的红色节点的子节点是外侧子孙，那么就先改变父节点和爷爷节点的颜色，然后以这个外侧子孙的爷爷节点进行右旋&lt;/p&gt;
&lt;p&gt;　　　　　　　　第二种，假如两个连续的红色节点的子节点是内侧子孙，那么就先改变内侧子孙和爷爷节点的颜色，然后先绕内侧子孙的父节点进行左旋，最后绕爷爷节点右旋；&lt;/p&gt;
&lt;p&gt;　　（2）插入节点之后，假如插入的是黑色节点下面，那没有什么改变；假如是插入在红色节点之下，那么就会违反红黑树规则三，两个连续的红色节点，此时就会有两种调整方式：&lt;/p&gt;
&lt;p&gt;　　　　　　　　第一种，假如这个新插入的节点是外侧子孙，那么改变父节点和爷爷节点的颜色，然后绕着爷爷节点进行右旋&lt;/p&gt;
&lt;p&gt;　　　　　　　　第二种，假如这个新插入的节点是内侧子孙，那么改变当前插入节点和爷爷节点的颜色，再绕着父节点左旋，再绕着爷爷节点右旋&lt;/p&gt;

&lt;p&gt;5.代码&lt;/p&gt;
&lt;p&gt;　　看看前面的逻辑贼多，所以代码的话最好心里准备，下面我们就用java代码来看一下红黑树添加节点的过程；&lt;/p&gt;
&lt;p&gt;　　为什么暂时不说删除红黑树节点呢？因为删除节点有点儿复杂，后面有时间再说吧！而且删除的分为真正的删除和伪删除，真正的删除就是慢慢研究每一个删除的步骤每一步代码，从树中删除节点；而伪删除其实就是在节点类中加一个boolean变量，标识该节点是否为已删除节点，伪删除其实避免了删除红黑树的全部复杂的逻辑，很容易，但是缺陷也很大，因为删除的节点还保存在树中。。。&lt;/p&gt;
&lt;p&gt;　　emmm....本来想自己实现一下的，然而看到一些大佬的博客实现代码，瞬间感觉自己的代码很丑陋，就借用一下大佬的代码；&lt;/p&gt;
&lt;p&gt;节点类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_8afe753c-9b8d-4ea4-b6db-78e9d50ce22b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8afe753c-9b8d-4ea4-b6db-78e9d50ce22b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8afe753c-9b8d-4ea4-b6db-78e9d50ce22b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RBTree&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RBTNode&amp;lt;T&amp;gt; mRoot;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根结点&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; RED   = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; BLACK = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RBTNode&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; color;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色&lt;/span&gt;
        T key;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关键字(键值)&lt;/span&gt;
        RBTNode&amp;lt;T&amp;gt; left;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左孩子&lt;/span&gt;
        RBTNode&amp;lt;T&amp;gt; right;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子&lt;/span&gt;
        RBTNode&amp;lt;T&amp;gt; parent;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父结点&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; RBTNode(T key, &lt;span&gt;boolean&lt;/span&gt; color, RBTNode&amp;lt;T&amp;gt; parent, RBTNode&amp;lt;T&amp;gt; left, RBTNode&amp;lt;T&amp;gt;&lt;span&gt; right) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left =&lt;span&gt; left;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right =&lt;span&gt; right;
        }

    }

    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 右旋&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c590a5d7-4e32-4a6b-97c2-3199051e8263&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c590a5d7-4e32-4a6b-97c2-3199051e8263&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c590a5d7-4e32-4a6b-97c2-3199051e8263&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x                  
 *         /  \      --(右旋)-.            /  \                     #
 *        x   ry                           lx   y  
 *       / \                                   / \                   #
 *      lx  rx                                rx  ry
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rightRotate(RBTNode&amp;lt;T&amp;gt;&lt;span&gt; y) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置x是当前节点的左孩子。&lt;/span&gt;
    RBTNode&amp;lt;T&amp;gt; x =&lt;span&gt; y.left;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “x的右孩子” 设为 “y的左孩子”；
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”&lt;/span&gt;
    y.left =&lt;span&gt; x.right;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        x.right.parent &lt;/span&gt;=&lt;span&gt; y;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “y的父亲” 设为 “x的父亲”&lt;/span&gt;
    x.parent =&lt;span&gt; y.parent;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mRoot = x;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 “y的父亲” 是空节点，则将x设为根节点&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y ==&lt;span&gt; y.parent.right)
            y.parent.right &lt;/span&gt;= x;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            y.parent.left &lt;/span&gt;= x;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “y” 设为 “x的右孩子”&lt;/span&gt;
    x.right =&lt;span&gt; y;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “y的父节点” 设为 “x”&lt;/span&gt;
    y.parent =&lt;span&gt; x;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;左旋&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ee5c6aaa-36d4-419a-9618-4a04ac54d01f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ee5c6aaa-36d4-419a-9618-4a04ac54d01f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ee5c6aaa-36d4-419a-9618-4a04ac54d01f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                              px
 *     /                               /
 *    x                               y                
 *   /  \      --(左旋)-.           / \                #
 *  lx   y                          x  ry     
 *     /   \                       /  \
 *    ly   ry                     lx  ly  
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; leftRotate(RBTNode&amp;lt;T&amp;gt;&lt;span&gt; x) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置x的右孩子为y&lt;/span&gt;
    RBTNode&amp;lt;T&amp;gt; y =&lt;span&gt; x.right;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “y的左孩子” 设为 “x的右孩子”；
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”&lt;/span&gt;
    x.right =&lt;span&gt; y.left;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        y.left.parent &lt;/span&gt;=&lt;span&gt; x;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “x的父亲” 设为 “y的父亲”&lt;/span&gt;
    y.parent =&lt;span&gt; x.parent;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mRoot = y;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 “x的父亲” 是空节点，则将y设为根节点&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.parent.left ==&lt;span&gt; x)
            x.parent.left &lt;/span&gt;= y;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            x.parent.right &lt;/span&gt;= y;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”&lt;/span&gt;
&lt;span&gt;    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “x” 设为 “y的左孩子”&lt;/span&gt;
    y.left =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 “x的父节点” 设为 “y”&lt;/span&gt;
    x.parent =&lt;span&gt; y;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;插入节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_202e5e46-e224-437e-b14e-c5ba904225b4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_202e5e46-e224-437e-b14e-c5ba904225b4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_202e5e46-e224-437e-b14e-c5ba904225b4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
 * 将结点插入到红黑树中
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的node
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(RBTNode&amp;lt;T&amp;gt;&lt;span&gt; node) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cmp;
    RBTNode&lt;/span&gt;&amp;lt;T&amp;gt; y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    RBTNode&lt;/span&gt;&amp;lt;T&amp;gt; x = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mRoot;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        y &lt;/span&gt;=&lt;span&gt; x;
        cmp &lt;/span&gt;=&lt;span&gt; node.key.compareTo(x.key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
            x &lt;/span&gt;=&lt;span&gt; x.left;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            x &lt;/span&gt;=&lt;span&gt; x.right;
    }

    node.parent &lt;/span&gt;=&lt;span&gt; y;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        cmp &lt;/span&gt;=&lt;span&gt; node.key.compareTo(y.key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
            y.left &lt;/span&gt;=&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            y.right &lt;/span&gt;=&lt;span&gt; node;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mRoot =&lt;span&gt; node;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 设置节点的颜色为红色&lt;/span&gt;
    node.color =&lt;span&gt; RED;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 将它重新修正为一颗二叉查找树&lt;/span&gt;
&lt;span&gt;    insertFixUp(node);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
 * 新建结点(key)，并将其插入到红黑树中
 *
 * 参数说明：
 *     key 插入结点的键值
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T key) {
    RBTNode&lt;/span&gt;&amp;lt;T&amp;gt; node=&lt;span&gt;new&lt;/span&gt; RBTNode&amp;lt;T&amp;gt;(key,BLACK,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果新建结点失败，则返回。&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        insert(node);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 红黑树插入修正函数
 *
 * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的z
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertFixUp(RBTNode&amp;lt;T&amp;gt;&lt;span&gt; node) {
    RBTNode&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; parent, gparent;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若“父节点存在，并且父节点的颜色是红色”&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (((parent = parentOf(node))!=&lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; isRed(parent)) {
        gparent &lt;/span&gt;=&lt;span&gt; parentOf(parent);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若“父节点”是“祖父节点的左孩子”&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (parent ==&lt;span&gt; gparent.left) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 1条件：叔叔节点是红色&lt;/span&gt;
            RBTNode&amp;lt;T&amp;gt; uncle =&lt;span&gt; gparent.right;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((uncle!=&lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node &lt;/span&gt;=&lt;span&gt; gparent;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 2条件：叔叔是黑色，且当前节点是右孩子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (parent.right ==&lt;span&gt; node) {
                RBTNode&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; tmp;
                leftRotate(parent);
                tmp &lt;/span&gt;=&lt;span&gt; parent;
                parent &lt;/span&gt;=&lt;span&gt; node;
                node &lt;/span&gt;=&lt;span&gt; tmp;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 3条件：叔叔是黑色，且当前节点是左孩子。&lt;/span&gt;
&lt;span&gt;            setBlack(parent);
            setRed(gparent);
            rightRotate(gparent);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若“z的父节点”是“z的祖父节点的右孩子”
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 1条件：叔叔节点是红色&lt;/span&gt;
            RBTNode&amp;lt;T&amp;gt; uncle =&lt;span&gt; gparent.left;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((uncle!=&lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node &lt;/span&gt;=&lt;span&gt; gparent;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 2条件：叔叔是黑色，且当前节点是左孩子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (parent.left ==&lt;span&gt; node) {
                RBTNode&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; tmp;
                rightRotate(parent);
                tmp &lt;/span&gt;=&lt;span&gt; parent;
                parent &lt;/span&gt;=&lt;span&gt; node;
                node &lt;/span&gt;=&lt;span&gt; tmp;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 3条件：叔叔是黑色，且当前节点是右孩子。&lt;/span&gt;
&lt;span&gt;            setBlack(parent);
            setRed(gparent);
            leftRotate(gparent);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将根节点设为黑色&lt;/span&gt;
    setBlack(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mRoot);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;参考大佬博客：https://www.cnblogs.com/skywang12345/p/3624343.html&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 14:28:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>这一篇我们来看看红黑树，首先说一下我啃红黑树的一点想法，刚开始的时候比较蒙，what？这到底是什么鬼啊？还有这种操作？有好久的时间我都缓不过来，直到我玩了两把王者之后回头一看，好像有点儿意思，所以有的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10811702.html</dc:identifier>
</item>
<item>
<title>玩转matlab之一维 gauss 数值积分公式及matlab源代码 - 孙振威</title>
<link>http://www.cnblogs.com/sunzhenwei/p/10847059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunzhenwei/p/10847059.html</guid>
<description>&lt;p&gt;在数值分析中，尤其是&lt;strong&gt;有限元&lt;/strong&gt;刚度矩阵、质量矩阵等的计算中，必然要求如下定积分:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I=\int_a^b f(x)dx \]&lt;/span&gt;学好&lt;strong&gt;gauss&lt;/strong&gt;积分也是学好&lt;strong&gt;有限元&lt;/strong&gt;的重要基础，学过高等数学的都知道，手动积分能把人搞死（微笑脸），而且有些函数还不存在原函数，使用原始的手动算出原函数几乎是不现实的。因此非常有必要学习数值积分，简单讲就是近似计算，只要这个近似值精确度高和稳定性好就行。Gauss积分公式就是这么一个非常好用的工具。本文介绍高斯积分公式的使用以及简单的数值算例。&lt;/p&gt;

&lt;p&gt;先考虑特殊情况，对于一般区间呢？待会会处理这个问题。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I=\int_{-1}^1 f(x)dx \]&lt;/span&gt;&lt;br/&gt;不加证明的直接给出gauss公式如下：详情参阅任何一本数值分析书都有详细的证明过程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I=\int_{-1}^1 f(x)dx=\Sigma_{i=1}^n A_if(x_i) \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;称作&lt;strong&gt;权&lt;/strong&gt;，&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;称作 &lt;strong&gt;gauss 点&lt;/strong&gt;。&lt;br/&gt;下面的问题就是如何选择&lt;span class=&quot;math inline&quot;&gt;\(n,A_i,x_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;理论表明&lt;strong&gt;n&lt;/strong&gt;个点的Gauss公式代数精度为&lt;span class=&quot;math inline&quot;&gt;\(2n-1\)&lt;/span&gt;，其选择如下表，（这里仅仅举1-4个点情况，实际使用的时候一般2点或者3点的精度已经完全够了）更多积分点可参考 &lt;a href=&quot;http://blog.sina.com.cn/s/blog_67c5d9870102xafw.html&quot;&gt;gauss表&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;=0&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;=2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{1,2}=\pm1/\sqrt{3}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1=A_2=1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_1=-\sqrt{3/5}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_2=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_3=\sqrt{3/5}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1=5/9\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2=8/9\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_3=5/9\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{1}=-\sqrt{\dfrac{15+2\sqrt{30}}{35}}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{2}=-\sqrt{\dfrac{15-2\sqrt{30}}{35}}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{3}=\sqrt{\dfrac{15-2\sqrt{30}}{35}}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{4}=\sqrt{\dfrac{15+2\sqrt{30}}{35}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1=\frac{90-5\sqrt{30}}{180}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2=\frac{90+5\sqrt{30}}{180}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_3=\frac{90+5\sqrt{30}}{180}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_4=\frac{90-5\sqrt{30}}{180}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ I=\int_a^b f(x)dx \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上面的讨论情况，可知只要做变换(相当于换元积分一样)&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 令\quad x=\frac{b+a+(b-a)s}{2},\\ 则\quad dx = \frac{b-a}{2}ds. \]&lt;/span&gt;&lt;br/&gt;那么有&lt;span class=&quot;math inline&quot;&gt;\(s\in[-1,1]\)&lt;/span&gt;，于是即可使用标准区间公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I = \int_a^bf(x)dx=\int_{-1}^1f(\frac{b+a+(b-a)s}{2})\times\frac{b-a}{2}ds\\ =\frac{b-a}{2}\Sigma_{i=1}^mA_if(\frac{b+a+(b-a)s_i}{2}) \]&lt;/span&gt;&lt;br/&gt;上述公式中的&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;即为表格中的权重，&lt;span class=&quot;math inline&quot;&gt;\(s_i\)&lt;/span&gt;即为上表中对应的gauss点，代入公式即可计算积分值。&lt;/p&gt;

&lt;p&gt;所有实验在MATLAB2018a版本下完成。（建议安装新版本，因为很多函数在新版中已经优化了或者改名字了，比如老版本积分函数&lt;strong&gt;quad&lt;/strong&gt; 新版已经改为&lt;strong&gt;integral&lt;/strong&gt;，只不过目前quad函数还是可以使用的，将来会被删除）。&lt;/p&gt;
&lt;p&gt;我们取2个函数做实验，分别计算出其gauss积分值再与matlab自带的函数 &lt;strong&gt;integral&lt;/strong&gt; 计算结果作比较，实验模型是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 计算 \quad I= \int_1^2 f(x)dx \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验一&quot;&gt;实验一&lt;/h2&gt;
&lt;p&gt;取函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=lnx, \quad 即自然对数函数以e为底. \]&lt;/span&gt;&lt;br/&gt;使用matlab函数 integral 计算得到: &lt;span class=&quot;math inline&quot;&gt;\(I= 0.386294361119891\)&lt;/span&gt;。&lt;br/&gt;使用gauss积分的matlab计算结果为：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0.386594944116741&lt;/td&gt;
&lt;td&gt;3.01E-04&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0.386300421584011&lt;/td&gt;
&lt;td&gt;6.06E-06&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0.386294496938714&lt;/td&gt;
&lt;td&gt;1.36E-07&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.386294364348948&lt;/td&gt;
&lt;td&gt;3.23E-09&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实验二&quot;&gt;实验二&lt;/h2&gt;
&lt;p&gt;取函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x)=\dfrac{x^2+2x+1}{1+(1+x)^4}, \]&lt;/span&gt;&lt;br/&gt;使用matlab函数 integral 计算得到: &lt;span class=&quot;math inline&quot;&gt;\(I= 0.161442165779443\)&lt;/span&gt;。&lt;br/&gt;使用gauss积分的matlab计算结果为：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0.161394581386268&lt;/td&gt;
&lt;td&gt;4.76E-05&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0.161442818737102&lt;/td&gt;
&lt;td&gt;6.53E-07&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0.161442196720137&lt;/td&gt;
&lt;td&gt;3.09E-08&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.161442166345131&lt;/td&gt;
&lt;td&gt;5.66E-10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ol&gt;&lt;li&gt;随着gauss点m的个数增多，精度在逐渐提高，但是要注意的是，gauss点取得多的话，计算量也会增大，只是因为我们计算的问题规模比较小，所以感觉不到而已。&lt;/li&gt;
&lt;li&gt;另外可以看到2点3点的gauss公式的精度已经很高了，说明并不需要取太多的点，而在实际计算中，比如有限元的计算中，也仅仅取2点或者3点gauss积分就完全足够。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下次介绍gauss积分的二维公式使用以及matlab数值实验，欢迎有问题与我交流，偏微分方程，矩阵计算，数值分析等问题，我的qq 群 315241287&lt;/p&gt;

&lt;pre class=&quot;matlab&quot;&gt;
&lt;code&gt;clc;clear;
%   using 2 3 4 5 points compute the integral
%   x \in [a,b]
%
%%  test
a=1;    b = 2;
fun = @(x)  log(x);
% fun = @(x)  2*x./(1+x.^4);
% fun = @(x)  exp(-x.^2/2);
% fun = @(x)  (x.^2+2*x+1)./(1+(1+x).^4);
%%  setup the gauss data
for gauss = 2:5
    if gauss == 2
        s=[-1 1]/sqrt(3);
        wt=[1 1];
        fprintf('***************************  2     points gauss  *******')
    elseif gauss == 3
        s = [-sqrt(3/5) 0 sqrt(3/5)];
        wt = [5 8 5]/9;
        fprintf('***************************    3   points gauss  *******')
    elseif gauss == 4
        fprintf('***************************    4   points gauss  *******')
        s = [   -sqrt((15+2*sqrt(30))/35),  -sqrt((15-2*sqrt(30))/35), ...
            sqrt((15-2*sqrt(30))/35),   sqrt((15+2*sqrt(30))/35)];
        wt = [  (90-5*sqrt(30))/180,    (90+5*sqrt(30))/180,...
            (90+5*sqrt(30))/180,    (90-5*sqrt(30))/180];
    elseif gauss == 5
        fprintf('***************************    5    points gauss *******')
        s(1)=.906179845938664 ; s(2)=.538469310105683;
        s(3)=.0;      s(4)=-s(2) ; s(5)=-s(1);
        wt(1)=.236926885056189 ; wt(2)=.478628670499366;
        wt(3)=.568888888888889 ; wt(4)=wt(2) ; wt(5)=wt(1);
    end
    %%
    %   区间变换到   s \in[-1,1]
    s = (b-a)/2*s+(b+a)/2;
    jac = (b-a)/2;% dx = jac * ds
    f = fun(s);
    f = wt.* f .* jac;
    format long
    exact = integral(fun,a,b);
    comp = sum(f)
    fprintf('the error is norm(comp-exact)=%10.6e\n\n\n',norm(comp-exact))
end
fprintf('\n\n*********  matlab  built-in function ''integral''*********\n')
exact = integral(fun,a,b)
format short

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 10 May 2019 14:21:00 +0000</pubDate>
<dc:creator>孙振威</dc:creator>
<og:description>在数值分析中，尤其是 有限元 刚度矩阵、质量矩阵等的计算中，必然要求如下定积分: $$ I=\int_a^b f(x)dx $$学好 gauss 积分也是学好 有限元 的重要基础，学过高等数学的都知道</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunzhenwei/p/10847059.html</dc:identifier>
</item>
<item>
<title>两种方法使vue实现jQuery调用 - lianjy357</title>
<link>http://www.cnblogs.com/lianjy/p/10847049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lianjy/p/10847049.html</guid>
<description>&lt;p&gt;如果说vue是前端工程化使用较多的骨架，那么JavaScript就是我们的前端的细胞。MVVM模式让我们体验到前端开发的便携，无需再过多的考虑DOM的操作。而vue的渐进式开发（逐步引用组件，按需引入），也让许多新手前端开发人员逐步绕过对jQuery的学习。jQuery需要记忆的内容颇多，这也让jQuery变得不那么受新入行开发者喜欢。&lt;br/&gt;在前端工程化的需求没有普及的时候，许多公司使用的是后端渲染技术，为了能够实现友好的前端交互效果，需要写好大量的jQuery、JavaScript和CSS，所以到目前还是有大量的公司维护和使用jQuery。&lt;br/&gt;前端工程化让许多人看到了开发的效率，但公司还是需要维护产品线，所以解决jQuery在vue的使用是每位前端工程师的必经之路，毕竟从零造轮子是一个非常痛苦耗时的事。&lt;br/&gt;今天我们提供两种方法引用，切记二选其一。&lt;/p&gt;

&lt;h2 id=&quot;在vue中安装jquery组件&quot;&gt;在vue中安装jQuery组件&lt;/h2&gt;
&lt;p&gt;老乡已经默认你的已经使用vue-cli脚手架进行操作了。至于如何使用vue-cli，可以进入vue的官网中查看相关开发文档。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;在项目终端中输入&lt;code&gt;npm install jquery -save-dev&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在build文件夹中找到webpack.base.conf.js文件，打开，在第一行添加&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var webpack = require('webpack')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.base.conf.js
var webpack = require('webpack')
'use strict'
const path = require('path')
const utils = require('./utils')
const config = require('../config')&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;在同样这个文件中（webpack.base.conf.js）的module.exports里添加：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;plugins: [
  new webpack.ProvidePlugin({
    $:&quot;jquery&quot;,
    jQuery:&quot;jquery&quot;,
    &quot;windows.jQuery&quot;:&quot;jquery&quot;
  })
 ],&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在入口文件main.js中输入：&lt;br/&gt;&lt;code&gt;import $ from 'jQuery'&lt;/code&gt;&lt;br/&gt;提示：这里无需再下面注册，有些IDE会提示标红，无需处理。&lt;/p&gt;
&lt;h2 id=&quot;查看执行效果&quot;&gt;查看执行效果&lt;/h2&gt;
&lt;p&gt;在app.vue中写一个案例&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1415730/201905/1415730-20190510221635635-1712498784.png&quot; alt=&quot;点击后弹出框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法是在开发中比较看好的方法，方便易用。同样，也有不希望在所有的页面都引用到jQuery，这样我们就会考虑到按需引用。&lt;/p&gt;

&lt;p&gt;这种方法只在单页面中使用jQuery时进行操作。这种方法适用于极个别的交互页面中。&lt;/p&gt;
&lt;h2 id=&quot;jquery的安装和配置&quot;&gt;jQuery的安装和配置&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;和“方法一”中的操作一致，在终端中输入&lt;br/&gt;&lt;code&gt;npm install jquery --save-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到build中webpack.base.conf文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.base.conf
module.exports = {
  resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
      'jquery': path.resolve(__dirname, '../node_modules/jquery/src/jquery')
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jq的引用&quot;&gt;jq的引用&lt;/h2&gt;
&lt;p&gt;在APP.vue中或者需要使用的地方&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p class=&quot;jj&quot;&amp;gt;请点击我&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import $ from 'jquery'
export default {
  name: 'app',
  mounted () {
    $('.jj').click(function(){
      alert(1)
    })
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;方法千万条，道理第一条。本文是我在开发中遇到jq无法引入后查阅资料后整理的方法。但不论是什么方法，我们最终的目标都是要完成项目的需求。技术的革新速度和时代的发展飞快，jQuery也在不断发展，许多人觉得这类语言过于复杂多变，但这就如同学习python一样，开始“学习一时爽，一直学习一直爽”，但到达技术瓶颈时，你会发现总会让人很棘手。我就多次遇到vue处理的问题而就迫使我去阅读底层技术。所以，学无止境，有效努力，持续输出。&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 14:18:00 +0000</pubDate>
<dc:creator>lianjy357</dc:creator>
<og:description>引言 如果说vue是前端工程化使用较多的骨架，那么JavaScript就是我们的前端的细胞。MVVM模式让我们体验到前端开发的便携，无需再过多的考虑DOM的操作。而vue的渐进式开发（逐步引用组件，按</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lianjy/p/10847049.html</dc:identifier>
</item>
<item>
<title>内核对象&amp;句柄 - shell_nut</title>
<link>http://www.cnblogs.com/MisterXu/p/10846918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MisterXu/p/10846918.html</guid>
<description>&lt;p&gt;  项目工程代码中设计句柄的使用，一时不知句柄是何物，通过查阅自学之后，对句柄及其使用有一个初步的了解。分享出来，算是抛砖引玉吧。&lt;br/&gt;  在阐述句柄之前，先说明一下内核对象。&lt;/p&gt;

&lt;p&gt;  内核对象就是一个内存块，有内核分配，只能由内核访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222913/201905/1222913-20190510214706545-1049065105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  内存块是一种数据结构，其中的数据成员负责维护该对象的相应信息，这个数据结构以及其中的数据成员只能由内核访问，应用程序是无法访问到的，更别说修改其中的数据成员了。&lt;/p&gt;
&lt;p&gt;  如何访问这些内核对象（内存块）呢？&lt;/p&gt;
&lt;p&gt;  操作系统为使用者封装了一组API，使用者可以通过这些API访问内核对象（内存块）。比如，创建内核对象（内存块）时，使用者调用API中的创建内核对象函数，由内核创建一个内核对象（分配一块内存）。&lt;/p&gt;
&lt;p&gt;  内核对象创建好之后，用一个&lt;strong&gt;句柄&lt;/strong&gt;来标识该内核对象（内存块），这个句柄作为函数值返回。这个句柄就是个整数，32位机句柄就是32bit，64位机句柄就是64bit，同一进程中的任何线程都能使用这个句柄，当需要操作内核对象（内存块）时，通过API将这个句柄传给内核，内核就知道是对哪个内核对象（内存块）进行操作了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;创建内核对象，引出句柄。 &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;  在应用程序中，可能有多个进程，这些进程中的一个或多个可能会访问同一个内核对象。内核对象有使用就会有撤销，那么什么情况下内核会撤销某个内核对象呢。内核的使用计数就派上用场了。使用计数是内核对象这个数据结构的数据成员，通过使用计数就能知道该内核对象被多少个进程使用。开始创建内核对象时，使用计数置为1,之后每多一个不同的进程使用该内核对象，使用计数就自加1.&lt;/p&gt;
&lt;p&gt;  无论什么方式创建内核对象,我们都需要调用 &lt;code&gt;ClosseHandle&lt;/code&gt; 向系统表明我们已经结束使用对象.就在 &lt;code&gt;CloseHandle&lt;/code&gt; 函数返回前,它会清除进程句柄表中对应的记录项 -- 这个句柄现在对我们的进程来说是无效的,不要在试图利用它.换句话说,一旦调用 &lt;code&gt;CloseHandle&lt;/code&gt;, 我们的进程就不能访问那个内核对象.&lt;/p&gt;
&lt;p&gt;  当进程关闭时，内核自动访问该进程仍然打开的内核对象的使用计数，该进程关联的每个内核对象的使用计数自减1，当使用计数减到0时，内核就会撤销该内核对象。&lt;/p&gt;
&lt;p&gt;  内核对象的使用计数有些像智能指针。&lt;/p&gt;

&lt;p&gt;  内核对象创建好之后，用一个句柄来标识该内核对象（内存块），这个句柄作为函数值返回。这个句柄就是个整数，32位机句柄就是32bit，64位机句柄就是64bit。&lt;/p&gt;
&lt;p&gt;  在同一进程中，一个句柄对应一个内核对象，我们在访问内核对象（内存块）时，就是通过句柄告诉内核，我要访问哪个内核对象。&lt;/p&gt;
&lt;p&gt;  通俗的说，句柄，就是个编号，操作系统对于我们来说就是个黑箱，我们通过句柄向操作系统要东西。&lt;/p&gt;

&lt;p&gt;  当一个进程被初始化时,系统要为它分配一个句柄表.该句柄表只用于内核对象,不用于用户对象或GDI对象.句柄表也是由内核操作。进程表包含的元素如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引  内核对象  内存块的指针访问屏蔽(标志位的DWORD)  标志(标志位的DWORD)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  进程被初次初始化时，句柄表是空的。&lt;/p&gt;
&lt;p&gt;  当进程中的线程创建内核对象时，内核给该对象分配一块内存，并对其初始化。内核遍历该进程的句柄表，找出一个空闲位置，设置内核对象，内存块指针，访问掩码，标识，并获取该位置的索引，作为函数值返回，这个索引就是我们所说的句柄。这个句柄只能有&lt;strong&gt;同一个进程&lt;/strong&gt;的所有线程使用， 系统用索引来表示内核对象的信息保存在进程句柄表中的具体位置。其他进程不能使用该进程的索引，因为句柄表不同（每个进程有一个单独的句柄表）。&lt;/p&gt;
&lt;p&gt;  所以，句柄实际上是句柄表的索引。可以这么理解，指针指向一块内存空间，那么句柄就是指向其对应的内核对象，通过操作系统提供的API吧句柄传给内核，内核就知道要操作那个内核对象。&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 13:58:00 +0000</pubDate>
<dc:creator>shell_nut</dc:creator>
<og:description>  项目工程代码中设计句柄的使用，一时不知句柄是何物，通过查阅自学之后，对句柄及其使用有一个初步的了解。分享出来，算是抛砖引玉吧。   在阐述句柄之前，先说明一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MisterXu/p/10846918.html</dc:identifier>
</item>
<item>
<title>基于STM8的IIC协议--实例篇--时钟模块(DS3231)读取 - 浩宇99✌</title>
<link>http://www.cnblogs.com/zhenghaoyu/p/10841542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghaoyu/p/10841542.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 综述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由上篇博客可知道IIC协议如何用代码实现，本篇博客就不涉及协议内容，只讲解如何使用。&lt;/p&gt;
&lt;p&gt;　　本次的实验传感为：DS3231（时钟模块），对于时钟模块的具体信息我也就不多介绍大家可以自行度娘，具体功能无非就是在单片机中起到一个获取时间的作用。然后该模块是可以由IIC协议去驱动的，再加上所要的操作也是比较简单，适合部分刚接触IIC协议而找不但传感练手的一个模块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 明确任务顺序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;　个人习惯，在每驱动一个新传感的时候，我会将我要完成的传感分为几个任务点。接下来我就展示以下我在写DS3231模块时的任务栏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;一．硬件部分
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.完成排针焊接
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.完成传感引角和单片机引角的接线
&lt;strong&gt;&lt;span&gt;二．软件部分
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 找到该传感的官方手册并认真阅读
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 找到并定义该传感的地址（7位地址、8位地址）&lt;br/&gt;3. 找到并定义该传感器的寄存器地址
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;. 完成读写函数的代码
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;. 测试传感是否有响应&lt;br/&gt;6. 查看手册，了解传感的工作模式&lt;br/&gt;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;. 完成传感参数初始化
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;. 传感数据的获取
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　根据上面这些小任务一一解决，这样一来，大多数传感就能成功驱动了，这里在给一个建议，驱动传感器的代码最好不要一次性全部写完再进行测试，这样成功率不高且大大增加你找问题的难度，将每个功能函数测试完再进行下一个功能函数的编写，会大大加大你的效率。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 具体任务实现步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.1. 硬件部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在STM8S103芯片中，我所定义的IIC协议中的SDA引角为PD3,SCL引角为PD4，该时钟模块所需提供的电源为3.3V。所以接线图如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201905/1545743-20190510122451548-1111900733.jpg&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;3.2. 软件部分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;（1）官方手册&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;我这里提供的是全英版的官方手册，多看点英文对你有好处的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接：https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pan.baidu.com/s/1Oo6o68SoVr7gt8tPZIoQxw &lt;/span&gt;
提取码：uzih 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;（2）器件地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在说明手册中，我们可以在第16页的右下角找到下面这句话：&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;The slave address byte contains the 7-bit DS3231 address, which is 1101000, followed by the direction bit (R/W), which is 0 for a write.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　这句话的大意为，从机的7位地址为1101000，后跟一位读写位，读写位为0时是写位。即7位地址的为0x68，8位地址为0xD0。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;（3）寄存器地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201905/1545743-20190510134525101-1057847598.jpg&quot; alt=&quot;&quot; width=&quot;1040&quot; height=&quot;731&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　DS3231的寄存器地址都在这了，大家可根据所需要用的功能定义相应的寄存器。&lt;/p&gt;
&lt;p&gt;　　以下是我在头文件所定义的格式，因为我只需要获取时间，不需要进行其他操作，所以部分寄存器没有使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; DS3231_Address           0xD0                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备地址&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Seconds_Register         0x00                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒钟寄存器&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Minutes_Register         0x01                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分钟寄存器&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Hour_Register            0x02                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小时寄存器&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Day_Register             0x03                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;星期寄存器&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Date_Register            0x04                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期寄存器&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Month_Register           0x05                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;月份寄存器（第七位是世纪位）&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Year_Register            0x06                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;年份寄存器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 例程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 编译环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我的编译环境是IAR，这款软件是现在STM8的主流平台，比较推荐。不过我打算等到STCubeMX更新出比较方便的版本后再去使用Keil5，因为我在用STM32的时候就是利用Keil5，的确很方便，你们也可以学着用一下。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 主芯片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我的主芯片是STM8S系列中的103，其中STM8S的003、005、和103、105，配置一样（外设和CPU频率，FLASH），在代码相同的情况下均可进行烧写。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3 库文件的添加&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们的工程可以在IAR中的官方例程中复制，操作过程：打开STM8S_StdPeriph_Lib（这是一个官方的库文件，下载IAR STM8包的时候就携带，里面有库文件和相对应的例程），将Libraries文件复制到你工程所在的文件下，并将有关于ADC的库文件添加到你的工程列表当中。添加完成后，就可以开始编写代码了（如果你将全部的库文件都添加进来的话，编译程序后库文件还有红点报错的话，这是因为你选的芯片上没有该功能，你需要将其删掉才能不报错。）如图。&lt;/p&gt;
&lt;p&gt;                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190412195741836-607381978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4 代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4.1 SDA、SCL引角的定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我这里将SDA、SCL都设置为了推挽输出，具体为什么可与参考上一片IIC协议讲解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC引脚 &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  GPIO_Init(IIC_SCL_GPIO_Port, IIC_SCL_Pin, GPIO_MODE_OUT_PP_HIGH_FAST);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   GPIO_Init(IIC_SDA_GPIO_Port, IIC_SDA_Pin, GPIO_MODE_OUT_PP_HIGH_FAST);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4.2 DS3231句柄定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了能够方便数据的管理，所以我定义了DS3231的一个句柄。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DS3231
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   uint8_t uSeconds;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   uint8_t uMinutes;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分钟&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   uint8_t uHour;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小时&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   uint8_t uDay;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;星期&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   uint8_t uData;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   uint8_t uMouth;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;月份&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   uint8_t uyear;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;年份&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   uint8_t uTime[&lt;span&gt;3&lt;/span&gt;];                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将秒、分钟、小时、日期包括在内&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   
&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}DS3231_HandleTypeDef;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4.3 BCD格式和B格式转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在手册中可以看到，写入到DS3231中的格式是BCD模式，而读取到的却是B格式，所以我们需要两个函数将其转换，也方便我们察看数据的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;uint8_t Byte_Transform_BCD(uint8_t uData)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  uint8_t i, j, uBCD_Code;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt;   i = uData / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   j = uData % &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   uBCD_Code = j + ( i &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uBCD_Code;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;uint8_t BCD_Transform_Byte(uint8_t uData)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    uint8_t uByte_Code;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     uByte_Code  = (uData &amp;amp; &lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     uData     &amp;gt;&amp;gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     uData      &amp;amp;= &lt;span&gt;0x0f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     uData      *= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     uByte_Code +=&lt;span&gt; uData;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uByte_Code;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4.4读写函数编写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　读写函数我们如果不去看手册说明的话是无法编写代码的，所以我们需要去看手册，根据手册中的IIC命令顺序进行编写代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201905/1545743-20190510140540447-1115006083.jpg&quot; alt=&quot;&quot; width=&quot;902&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这幅图为 IIC数据传输概述。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;写函数流程图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201905/1545743-20190510140910003-1675424772.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个流程图是在DS3231中的官方图，根据图中的命令可以写出代码，其中，代码中出现IIC_HandleTypedef * &lt;span data-mce-=&quot;&quot;&gt;iicHandle&lt;/span&gt;等参数，是IIC的句柄，具体可看上一篇博客，下面所出现的也是一样的意思。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; uint8_t vSen_DS3231_Write_Bytes(IIC_HandleTypedef *&lt;span&gt; iicHandle, uint8_t Register_Address, uint8_t Data_Byte)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   
&lt;span&gt; 4&lt;/span&gt;   vIIC_Start_Signal(iicHandle);                                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.  IIC_Start                 ;  起始信号                               &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   vIIC_SendByte(iicHandle, Slave_Address);                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.  IIC_Send Device Address(W);  发送（设备地址）告诉总线即将操作的设备   &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(!bIIC_ReadACK(iicHandle))                                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.  IIC_ReadAck               ;  等待响应&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  {                                                                                   
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    vIIC_Stop_Signal(iicHandle);                                                   
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;                                                                     
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt;   vIIC_SendByte(iicHandle, Register_Address);                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.  IIC_Send Register Address ; 发送（寄存器）   告诉设备我们即将操作的寄存器&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   bIIC_ReadACK(iicHandle);                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.  IIC_ReadAck               ; 等待响应&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   vIIC_SendByte(iicHandle, Data_Byte);                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.  IIC_Send the data to Reg  ; 发送（数据）     写入数据到指定设备的寄存器中&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   bIIC_ReadACK(iicHandle);                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.  IIC_ReadAck               ; 等待响应&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   vIIC_Stop_Signal(iicHandle);                                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.  IIC_Stop                  ; 结束信号&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   
&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;读函数流程图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; uint8_t vSen_DS3231_Read_Bytes(IIC_HandleTypedef *&lt;span&gt; iicHandle, uint8_t Register_Address)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   uint8_t uRev_Register_Data = &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt;   vIIC_Start_Signal(iicHandle);                                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.  IIC_Start                 ;  起始信号                                                                                                                                                  &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   vIIC_SendByte(iicHandle, Slave_Address);                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.  IIC_Send Device Address(W);  发送（设备地址）告诉总线即将操作的设备       &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                                                                                          
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(!bIIC_ReadACK(iicHandle))                                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.  IIC_ReadAck               ;  等待响应&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  {                                                                                      
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    vIIC_Stop_Signal(iicHandle);                                                      
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;                                                                        
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }                                                                                      
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                                                                                          
&lt;span&gt;14&lt;/span&gt;   vIIC_SendByte(iicHandle, Register_Address);                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.  IIC_Send Register Address ; 发送（寄存器）   告诉设备我们即将操作的寄存器&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   vIIC_Ack(iicHandle);                                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.  IIC_Ack                   ; 主动响应&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   vIIC_Start_Signal(iicHandle);                                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.  &lt;span data-mce-=&quot;&quot;&gt;IIC_Start                 ; 起始信号&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   vIIC_SendByte(iicHandle, Slave_Address+&lt;span&gt;1&lt;/span&gt;);                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.  IIC_Send Device Address(R); 发送（设备地址）告诉总线即将操作的设备 &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;   vIIC_Ack(iicHandle);                                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.  IIC_Ack                   ; 主动响应&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   uRev_Register_Data = uIIC_RecvByte(iicHandle);                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.  IIC_ReadByte              ; 读取寄存器中的数据 &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;   vIIC_NAck(iicHandle);                                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10. IIC_Nack                  ; 主动不应答&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;   vIIC_Stop_Signal(iicHandle);                                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;11. IIC_Stop                  ; 结束信号&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;  
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uRev_Register_Data;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　完成读写函数的编写后，那么我们就可测试传感是否通信成功，具体可检测的方法有挺多，最直观的是用示波器察看波形，若在读写函数发送器件地址后，有接下来的发送寄存器地址和数据等操作波形的话，即有返回到ACK，则单片机与传感通信成功。这里再说一个不需要用到的示波器的操作，同样的，在读写函数发送器件地址后，用Uart发送功能，在串口助手上打印一个数，若有数显示，则没有return 跳出函数，证明SDA的电平被器件拉低，也是有ACK返回的情况，则单片机于传感通信成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4.5 修改时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们在读取时间之前需要对时间进行一个手动输入的方法去给予时钟模块一个初始值，这样才能开始计时，这个函数可以当作修改时间的功能，具体代码可以自行编写，我这里的代码就写成全部修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vSen_DS3231_Modify_Time(IIC_HandleTypedef *&lt;span&gt; iicHandle, uint8_t uyear, uint8_t uMouth, uint8_t uData, uint8_t uDay, uint8_t uHour, uint8_t uMinutes, uint8_t uSeconds)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Year_Register,    Byte_Transform_BCD(uyear));                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改年份&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                   
&lt;span&gt; 6&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Month_Register,   Byte_Transform_BCD(uMouth));               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改月份&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                   
&lt;span&gt; 8&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Date_Register,    Byte_Transform_BCD(uData));                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改日期&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       
&lt;span&gt;10&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Day_Register,     Byte_Transform_BCD(uDay));                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改星期&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       
&lt;span&gt;12&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Hour_Register,    Byte_Transform_BCD(uHour));                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改小时&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                   
&lt;span&gt;14&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Minutes_Register, Byte_Transform_BCD(uMinutes));             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改分钟&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;   vSen_DS3231_Write_Bytes(iicHandle, Seconds_Register, Byte_Transform_BCD(uSeconds));             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改秒钟&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4.6 获取时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获取时间就直接读取相应的寄存器获取数值即可，最后将其输出就行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vSen_DS3231_Get_Times(IIC_HandleTypedef * iicHandle, DS3231_HandleTypeDef *&lt;span&gt; hDS3231)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   hDS3231-&amp;gt;uyear    =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Year_Register));      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取年份&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   hDS3231-&amp;gt;uMouth   =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Month_Register));     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取月份 &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt;   hDS3231-&amp;gt;uData    =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Date_Register));      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取日期  &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt;   hDS3231-&amp;gt;uDay     =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Day_Register));       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取星期  &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt;   hDS3231-&amp;gt;uHour    =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Hour_Register));      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取小时   &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      
&lt;span&gt;13&lt;/span&gt;   hDS3231-&amp;gt;uMinutes =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Minutes_Register));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取分钟&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;   hDS3231-&amp;gt;uSeconds =  BCD_Transform_Byte(vSen_DS3231_Read_Bytes(iicHandle, Seconds_Register));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取秒钟  &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                                                                               
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;4.5 成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为我这里用的是数码管显示，但数码管格数不够，就只显示了时分秒三个数值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201905/1545743-20190510214807401-2110983915.jpg&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;639&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 结尾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　DS3231模块已经成功驱动了，毕竟这个模块是比较容易的一个IIC传感，基本不用配置什么寄存器，直接写入再直接读取即可，算是一个IIC小入门难度，不过其他传感也大同小异，都非常类似。&lt;/p&gt;
&lt;p&gt;　　对STM8的I&lt;sup&gt;2&lt;/sup&gt;C传感模块驱动讲解到这里结束，感谢各位看官的点击。&lt;/p&gt;
&lt;p&gt;　　如果觉得有所收获请点下推荐，若认为该博客中存在错误的说明或者对博客中某方面有疑问请留言。&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;27.609022556391&quot;&gt;
&lt;pre&gt;
作 者：浩宇99✌
出 处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 基于STM8的IIC协议--实例篇--时钟模块(DS3231)读取&quot; href=&quot;https://www.cnblogs.com/zhenghaoyu/p/10841542.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhenghaoyu/p/10841542.html&lt;/a&gt;&lt;br/&gt;版权声明：本文原创发表于 博客园，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 10 May 2019 13:56:00 +0000</pubDate>
<dc:creator>浩宇99✌</dc:creator>
<og:description>本次的实验传感为：DS3231（时钟模块），对于时钟模块的具体信息我也就不多介绍大家可以自行度娘，具体功能无非就是在单片机中起到一个获取时间的作用。然后该模块是可以由IIC协议去驱动的，再加上所要的操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghaoyu/p/10841542.html</dc:identifier>
</item>
<item>
<title>C#ModBus Tcp 报文解析 - ′Peter.Pan</title>
<link>http://www.cnblogs.com/pandefu/p/10824848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pandefu/p/10824848.html</guid>
<description>&lt;p&gt;上一篇博客已经完成 &lt;strong&gt;&lt;a title=&quot;C#ModBus Tcp Master的实现(1)&quot; href=&quot;https://www.cnblogs.com/pandefu/p/10824331.html&quot; target=&quot;_blank&quot;&gt;C#ModBus Tcp Master的实现&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇主要对不同的功能码所发出的报文进行解析(包括请求报文及响应报文)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;读操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;功能码 0x01 读一组线圈 读取站号为1 从地址12开始的10个线圈&lt;/p&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510181441380-1035543879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一篇博客已经总结了&lt;span&gt;读操作&lt;/span&gt;报文格式,就按照格式划分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190507125605486-1036070568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510183553735-2007331914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：报文中线圈起始地址 00000 对应设备中 10001 地址，其他顺延&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;功能码0x02 报文格式与功能码0x01一致,只是第八字节的功能码变为02 其他完全一致,不再重复解析&lt;/p&gt;
&lt;p&gt;功能码0x03 读一组保持寄存器 读取站号为1 从地址12开始的10个值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510190045552-230039486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510191353804-697453985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 功能码0x04 报文格式与功能码0x03一致,只是第八字节的功能码变为04 其他完全一致,也不再重复解析&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;写操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作码:0x05 写单个线圈  将站号为1 地址为21的线圈置为On&lt;/p&gt;
&lt;p&gt;注意:在报文中 &lt;span&gt;指定线圈通断标志  FF00 置线圈为ON  0000置线圈为OFF&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510201738294-757735980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510202713559-525769030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;功能码0x0F 写一组线圈  将站号1 起始地址21  的连续五个线圈置为 通,断,断,通,通&lt;/p&gt;
&lt;p&gt;测试结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510205207418-869645667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510205259390-1138719863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;功能码 0x06  写单个保持寄存器  将6666写入从站1 地址为21 的保持寄存器中&lt;/p&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510210234553-451130699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510210250406-1451441253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能码0x10  写一组保持寄存器   例如 将12 23 34 45 56 67 78 分别写入从站1 起始地址为21的7个连续的保持寄存器中&lt;/p&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510211859008-180180752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文解析:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630815/201905/1630815-20190510211938701-1859410713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;到此为止,我们常用的几个ModBus功能码报文都解析完毕了 有错误之处 希望大家不吝赐教,感谢(抱拳~)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a title=&quot;C#ModBus Tcp Master的实现(1)&quot; href=&quot;https://www.cnblogs.com/pandefu/p/10824331.html&quot; target=&quot;_blank&quot;&gt;C#ModBus Tcp Master&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 May 2019 13:26:00 +0000</pubDate>
<dc:creator>′Peter.Pan</dc:creator>
<og:description>上一篇博客已经完成 C#ModBus Tcp Master的实现 本篇主要对不同的功能码所发出的报文进行解析(包括请求报文及响应报文) 读操作 功能码 0x01 读一组线圈 读取站号为1 从地址12开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pandefu/p/10824848.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 配置文件 - 阿飞24</title>
<link>http://www.cnblogs.com/afei-24/p/10816523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/10816523.html</guid>
<description>&lt;p&gt;　　在ASP.NET Core 中，应用程序配置数据可以使用JSON, XML 和 INI格式 和内置环境变量，命令行参数或内存中的集合。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.如何获取和设置配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core配置系统针对以前的依赖于System.Configuration和XML配置文件(如Web.config)的ASP,NET 版本进行了重构。新的配置模型提供了精简高效的，能够通过检索多样化提供程序来获取基于键/值对配置的能力。应用程序和框架可以通过新的选择模式访问配置。&lt;/p&gt;
&lt;p&gt;　　可以在ASP.NET Core应用程序中的Startup类中只实例化一个Configuration示例，然后选择模式来访问各自的设置。&lt;/p&gt;
&lt;p&gt;　　Configuration类是一个提供读写键/值对能力的Providers集合。如果一个键值对写入Configuration，它不会持久，当源再次读写值时将会丢失。因此至少需要配置一个数据源，使得configuration能正常工作。&lt;/p&gt;
&lt;p&gt;　　下面通过内存配置演示Configuration处理键值对：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/984232/201905/984232-20190507211916327-736745412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　内存配置一般用在一次请求中需要暂存数据的情况，例如，如果管道中有多个中间件，可以在某一个中间件中暂存数据，后面的某一个中使用。&lt;/p&gt;
&lt;p&gt;　　在开发中一般会把配置值放在一个有层次的数据结构中，例如appsettings.json，在这种情况下，可以使用以: 符号分割（从层次结构的根开始）的键读取值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=.;Initial Catalog=AccessManagement;Integrated Security=True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Option1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ww&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Option2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在应用程序中通过Configuration获取配置的连接字符串，可以通过ConnectionStrings:DefaultConnection读取ConnectionStrings的设置，也可以通过GetConnectionString扩展方法加参数&quot;DefaultConnection&quot;来获取。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/984232/201905/984232-20190507213343683-658453161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　应用程序所需要的设置和指定配置的机制都可以通过使用选择模式解耦。创建自己的配置类时，可以是几个不同的类，分别对应不同的配置组，然后通过选项服务注入到应用程序中。这样就可以通过配置或其他所选择的机制来设置了。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.使用内置数据源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　开发时并不局限于必须使用单个配置提供程序，可以把多个配置提供程序组合在一起。&lt;/p&gt;
&lt;p&gt; 　　扩展方法支持为配置添加额外的配置文件提供程序。这些方法能被独立的或链式调用在ConfigurationBuilder实例之上：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　public&lt;/span&gt;&lt;span&gt; Startup()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder();
            builder.SetBasePath(Directory.GetCurrentDirectory());
            builder.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; builder.Build();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　指定配置提供程序的顺序很重要，这将影响他们的设置被应用的优先级：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration,IHostingEnvironment env)
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile(“appsettings.json&quot;,optional:true,reloadOnChange:true)&lt;/span&gt;&lt;span&gt;
                .AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{env.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,optional:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置环境变量&lt;/span&gt;
&lt;span&gt;            builder.AddEnvironmentVariables();
            Configuration &lt;/span&gt;=&lt;span&gt; builder.Build();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　IHostingEnvironment 服务用于获取当前环境。在Development环境中，AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;,optional:true)将会查找appsettings.Development.json配置文件，并覆盖appsettings.json中存在的值。同样环境变量也会覆盖它们两个的值。&lt;/p&gt;
&lt;p&gt;　　一旦将指定文件作为配置源，就可以选择当文件发生变化后，是否重新再付这部分的配置，reloadOnChange:true。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.使用选项和配置对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　选择模式可使用自定义的配置类表示一组相关设置。这个配置类需要为配置项提供公开的 属性和一个无参的构造函数。可以根据应用程序的功能分解为多个配置对象。&lt;/p&gt;
&lt;p&gt;　　下面自定义appsettings.json的配置类，并使用：&lt;/p&gt;
&lt;p&gt;　　先创建配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MVCTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppSettingOptions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultConnec ConnectionStrings { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AllowedHosts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultConnec
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DefaultConnection { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在ConfigureServices中调用选项服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration,IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configuration = configuration;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,optional:&lt;span&gt;true&lt;/span&gt;,reloadOnChange:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;,optional:true);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置环境变量&lt;/span&gt;
&lt;span&gt;            builder.AddEnvironmentVariables();
            Configuration &lt;/span&gt;=&lt;span&gt; builder.Build();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddOptions();//提供依赖注入
            services.Configure&lt;/span&gt;&amp;lt;AppSettingOptions&amp;gt;&lt;span&gt;(Configuration); //绑定配置选项     
   services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　在HomeController中使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptions&amp;lt;AppSettingOptions&amp;gt;&lt;span&gt; _options;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HomeController(IOptions&amp;lt;AppSettingOptions&amp;gt;&lt;span&gt; options,)
        {
            _options &lt;/span&gt;=&lt;span&gt; options;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger nlog =&lt;span&gt; LogManager.GetCurrentClassLogger();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; AllowedHosts =&lt;span&gt; _options.Value.AllowedHosts;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; DefaultConnection =&lt;span&gt; _options.Value.ConnectionStrings.DefaultConnection;
        }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/984232/201905/984232-20190509215606770-163790922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　当通过绑定选项来配置选项类型的每一个属性时，实际上是绑定到每一个配置键。配置键是大小写不敏感的。&lt;/p&gt;
&lt;p&gt; 　　当通过调用services.Configure&amp;lt;AppSettingOptions&amp;gt;(Configuration);代码，将一个IConfigureOptions&amp;lt;AppSettingOptions&amp;gt;服务加入服务容器，是为了后面应用程序或框架能通过IOptions&amp;lt;AppSettingOptions&amp;gt;服务来获取配置。若想从其他途径（从数据库通过EF获取）获取配置，可以使用ConfigureOptions&amp;lt;TOptions&amp;gt;扩展方法直接指定经过定制的IConfigureOptions&amp;lt;TOptions&amp;gt;服务。&lt;/p&gt;
&lt;p&gt;　　其他方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过代码编写&lt;/span&gt;
            services.Configure&amp;lt;AppSettingOptions&amp;gt;(options=&amp;gt;&lt;span&gt;
            {
                options.AllowedHosts &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只配置部分&lt;/span&gt;
            services.Configure&amp;lt;AppSettingOptions&amp;gt;(Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 10 May 2019 13:21:00 +0000</pubDate>
<dc:creator>阿飞24</dc:creator>
<og:description>在ASP.NET Core 中，应用程序配置数据可以使用JSON, XML 和 INI格式 和内置环境变量，命令行参数或内存中的集合。 1.如何获取和设置配置 ASP.NET Core配置系统针对以前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/afei-24/p/10816523.html</dc:identifier>
</item>
</channel>
</rss>