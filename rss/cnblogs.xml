<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>脱单狗福利!每天不同时间段给女友定时给女友发消息,不错过早上起床、中午吃饭、晚上吃饭、晚安时间! - 云外孤鸟</title>
<link>http://www.cnblogs.com/cloudbird/p/10534658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudbird/p/10534658.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;有时候，你很想关心她，但是你太忙了，以至于她一直抱怨，觉得你不够关心她。你暗自下决心，下次一定要准时发消息给她，哪怕是几句话，可是你又忘记了。你觉得自己很委屈😭，但是她又觉得你不负责。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;现在，再不用担心了&lt;/strong&gt;，用python就可以给女友定时发提示消息了，&lt;strong&gt;而且不会漏过每一个关键时刻&lt;/strong&gt;，每天&lt;strong&gt;早上起床、中午吃饭、晚上吃饭、晚上睡觉&lt;/strong&gt;，都会准时发消息给她了，而且还可以让她&lt;strong&gt;学习英语单词&lt;/strong&gt;哦！等你了解了全部这100行代码，你可以加上每个节日自动发问候语哦，比如&lt;strong&gt;三八妇女节、女神节、情人节、春节、圣诞节&lt;/strong&gt;，再也不用担心他说你没有仪式感了！😀&lt;/p&gt;
&lt;h2 id=&quot;编写思路&quot;&gt;编写思路&lt;/h2&gt;
&lt;p&gt;为了方便快速开发，我们使用python中的wxpy模块完成微信的基本操作。&lt;/p&gt;
&lt;p&gt;首先，，我们开始设置一些相关的参数，这些参数一看就懂，所以无需多言&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 设置你的微信名称和对方的微信名称，记住，不是微信ID也不是微信备注
# 你的微型名称，记住，不是微信ID也不是微信备注
my_wechat_name = u'你的微信名字'
# 你女友的微信名称，记住，不是微信ID也不是微信备注
my_lady_wechat_name = u'她的微信名字'

# 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间
say_good_morning = &quot;07:00&quot;
say_good_lunch = &quot;11:50&quot;
say_good_dinner = &quot;17:50&quot;
say_good_dream = &quot;23:10&quot;

# 不同时间段想要发送的内容
str_good_morning = &quot;小宝贝~起床啦~\n\n已经7点钟啦，起来晒太阳啦！&quot;
str_good_lunch = &quot;ლ(°◕‵ƹ′◕ლ)亲亲,不要太累啦，中午饭记得吃哦，劳逸结合(*^__^*) 嘻嘻……&quot;
str_good_dinner = &quot;n(*≧▽≦*)n小可爱，又到了下班时间啦，一起来吃晚饭吧&quot;
str_good_dream = &quot;⊙﹏⊙∥∣°猪猪，晚上23点了，时间不早了哦，记得早点休息。&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你愿意，可以在上面对时间的判断中，加入一些其他你想要的，比如&lt;strong&gt;节日问候(情人节、圣诞节、三八妇女节等)&lt;/strong&gt;，这样你女友就更开心啦！后期如果有时间，我将会加上以上节日问候功能。😀&lt;/p&gt;
&lt;p&gt;接着，开启微信机器人，为了程序的健壮性，自动判断一下操作系统，根据不同操作系统执行不同指令&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 启动微信机器人，自动根据操作系统执行不同的指令
# windows系统或macOS Sierra系统使用bot = Bot()
# linux系统或macOS Terminal系统使用bot = Bot(console_qr=2)
if('Windows' in platform.system()):
    # Windows
    bot = Bot()
elif('Darwin' in platform.system()):
    # MacOSX
    bot = Bot()
elif('Linux' in platform.system()):
    # Linux
    bot = Bot(console_qr=2,cache_path=True)
else:
    # 自行确定
    print(&quot;无法识别你的操作系统类型，请自己设置&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完相关参数以后，我们再来学习一下，如何每天教女友&lt;code&gt;学英语&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 获取每日励志精句
def get_message():
    r = requests.get(&quot;http://open.iciba.com/dsapi/&quot;)
    note = r.json()['note']
    content = r.json()['content']
    return note,content&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;教完女友&lt;code&gt;学英语&lt;/code&gt;后，开始把我们的关心语发给他。这里涉及到wxpy模块的相关操作，很简单，看我的例子就会了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 发送消息给她
def send_message(your_message):
    try:
        # 对方的微信名称
        my_friend = bot.friends().search(my_lady_wechat_name)[0]

        # 发送消息给对方
        my_friend.send(your_message)
    except:

        # 你的微信名称
        my_friend = bot.friends().search(my_wechat_name)[0]

        # 提示
        my_friend.send(u&quot;守护女友出问题了，赶紧去看看咋回事~&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，就是如何每天定时发关心语给女友的问题了。首先来个while循环，365天无限关心😀&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 来个死循环，24小时关心她
    while(True):

        # 提示
        print(&quot;守护中，时间:%s&quot;% time.ctime())

        # 获取时间，只获取时和分，对应的位置为倒数第13位到倒数第8位
        now_time = time.ctime()[-13:-8]

        if (now_time == say_good_morning):
            if(first_say_good_morning == False):
                message = str_good_morning
                send_message(message)
                first_say_good_morning = True
                first_say_good_lunch = False
                first_say_good_dinner = False
                first_say_good_dream = False
                print(&quot;提醒女友早上起床:%s&quot; % time.ctime())


        这下面还有很多代码，我就不列出来了

        # 延时10秒
        time.sleep(10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;first_say_good_morning&lt;/code&gt;，&lt;code&gt;first_say_good_lunch&lt;/code&gt;，&lt;code&gt;first_say_good_dinner&lt;/code&gt;，&lt;code&gt;first_say_good_dream&lt;/code&gt;是干什么用的呢？其实是用来做标志检测的，防止同一时间断内多次发送同样的消息给女友，发多了被拉黑怎么办😰，所以标志位是必须要的。&lt;/p&gt;
&lt;p&gt;最后，输入&lt;code&gt;start_care()&lt;/code&gt;开始守护女友模式吧~&lt;/p&gt;
&lt;h2 id=&quot;使用教程&quot;&gt;使用教程&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;pip安装下列包&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;[x] pip install wxpy&lt;/li&gt;
&lt;li&gt;[x] pip install requests&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;设置你的微信名字和她的微信名字&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 设置你的微信名称和对方的微信名称，记住，不是微信ID也不是微信备注
    # 你的微型名称，记住，不是微信ID也不是微信备注
    my_wechat_name = u'你的微信名字'
    # 你女友的微信名称，记住，不是微信ID也不是微信备注
    my_lady_wechat_name = u'她的微信名字'&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 设置早上起床时间，中午吃饭时间，下午吃饭时间，晚上睡觉时间
    say_good_morning = &quot;07:00&quot;
    say_good_lunch = &quot;11:50&quot;
    say_good_dinner = &quot;17:50&quot;
    say_good_dream = &quot;23:10&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;设置想要提醒的内容&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 不同时间段想要发送的内容
    str_good_morning = &quot;小宝贝~起床啦~\n\n已经7点钟啦，起来晒太阳啦！&quot;
    str_good_lunch = &quot;ლ(°◕‵ƹ′◕ლ)亲亲,不要太累啦，中午饭记得吃哦，劳逸结合(*^__^*) 嘻嘻……&quot;
    str_good_dinner = &quot;n(*≧▽≦*)n小可爱，又到了下班时间啦，一起来吃晚饭吧&quot;
    str_good_dream = &quot;⊙﹏⊙∥∣°猪猪，晚上23点了，时间不早了哦，记得早点休息。&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;演示图片&quot;&gt;演示图片&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/4.%E6%AF%8F%E5%A4%A9%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E6%AE%B5%E9%80%9A%E8%BF%87%E5%BE%AE%E4%BF%A1%E5%8F%91%E6%B6%88%E6%81%AF%E6%8F%90%E9%86%92%E5%A5%B3%E5%8F%8B/example1.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/4.%E6%AF%8F%E5%A4%A9%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E6%AE%B5%E9%80%9A%E8%BF%87%E5%BE%AE%E4%BF%A1%E5%8F%91%E6%B6%88%E6%81%AF%E6%8F%90%E9%86%92%E5%A5%B3%E5%8F%8B/example2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;完整源代码&quot;&gt;完整源代码&lt;/h2&gt;
&lt;p&gt;项目源代码在&lt;a href=&quot;https://github.com/shengqiangzhang/examples-of-web-crawlers&quot;&gt;GitHub仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目持续更新，欢迎您&lt;a href=&quot;https://github.com/shengqiangzhang/examples-of-web-crawlers&quot;&gt;star本项目&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 18:16:00 +0000</pubDate>
<dc:creator>云外孤鸟</dc:creator>
<og:description>有时候，你很想关心她，但是你太忙了，以至于她一直抱怨，觉得你不够关心她。你暗自下决心，下次一定要准时发消息给她，哪怕是几句话，可是你又忘记了。你觉得自己很委屈😭，但是她又觉得你不负责。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudbird/p/10534658.html</dc:identifier>
</item>
<item>
<title>第8章 模块 - 牧牛人</title>
<link>http://www.cnblogs.com/ooo888ooo/p/10360654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ooo888ooo/p/10360654.html</guid>
<description>&lt;h2&gt; 8.1 模块概述&lt;/h2&gt;
&lt;p&gt;模块的英文是Modules，可以认为是一盒（箱）主题积木，通过它可以拼出某一个主题的东西。这与第6章介绍的函数不同，一个函数相当于一块积木，而一个模块中可以包括很多函数，也就是很多积木，所以也可以说模块相当于一盒积木。&lt;/p&gt;
&lt;p&gt;在Python中，一个拓展名为“.py”的文件就称之为一个模块。&lt;/p&gt;
&lt;p&gt;通常情况下，我们把能够实现某一特定功能的代码放置在一个文件中作为一个模块，从而方便其他程序和脚本导入并使用。另外，使用模块也可以避免函数名和变量名冲突。&lt;/p&gt;
&lt;p&gt;经过前面的学习，我们知道对于Python代码可以写到一个文件中。但是随着程序不断变大，为了便于维护，需要将其分为多个文件，这样可以提高代码的可维护性。另外，使用模块还可以提高代码的可重用性。即编写好一个模块后，只要是实现该功能的程序，都可以导入这个模块实现。&lt;/p&gt;
&lt;h2&gt;8.2 自定义模块&lt;/h2&gt;
&lt;p&gt;在Python中，自定义模块有两个作用：一个是规范代码，让代码更易于阅读，另一个是方便其他程序使用已经编写好的代码，提高开发效率。&lt;/p&gt;
&lt;p&gt;实现自定义模块主要分为两部分，一部分是创建模块，另一个部分是导入模块。&lt;/p&gt;
&lt;h3&gt;8.2.1 创建模块&lt;/h3&gt;
&lt;p&gt;创建模块时，可以将模块中相关的代码（变量定义和函数定义等）编写在一个单独的文件中，并且将该文件命名为“模块名+.py”的形式。&lt;/p&gt;
&lt;p&gt;注意：创建模块时，设置的模块名不能是Python自带的标准模块名称。&lt;/p&gt;
&lt;p&gt;实例01：创建计算BMI指数的模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun_bmi(person,height,weight):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：根据身高和体重计算BMI指数
        person：姓名
        height：身高，单位：米
        weight：体重，单位：千克
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                     
    &lt;span&gt;print&lt;/span&gt;(person + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的身高:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(height) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;米\t体重:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(weight) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千克&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    bmi&lt;/span&gt;=weight/(height*height)                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于计算BMI指数，公式为：BMI=体重/身高的平方&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(person + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的BMI指数为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str(bmi))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出BMI指数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处省略了显示判断结果的代码&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; fun_bmi_upgrade(*&lt;span&gt;person):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：根据身高和体重计算BMI指数（升级版）
        *person：可变参数该参数中需要传递带3个元素的列表，
        分别为姓名、身高（单位：米）和体重（单位：千克）
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处省略了函数主体代码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：模块文件的扩展名必须是“.py”。&lt;/p&gt;
&lt;h3&gt;8.2.2 使用import 语句导入模块&lt;/h3&gt;
&lt;p&gt;创建模块后，就可以在其他程序中使用该模块了。要使用模块需要以模块的形式加载模块中的代码，这可以使用import语句实现。import语句的基本语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; modulename[as alias]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，modulename为要导入模块的名称；[as alias]为给模块起的别名，通过该别名也可以使用模块。&lt;/p&gt;
&lt;p&gt; 下面将导入实例01所编写的模块bmi，并执行该模块中的函数。在模块文件bmi.py的同级目录下创建一个名称为mai.py的文件，在该文件中，导入模块bmi，并且执行该模块中的fun_bmi()函数，代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; bmi                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入bmi模块&lt;/span&gt;
bmi.fun_bmi(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大白&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1.80,130)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行模块中的fun_bmi()函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码，运行结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
大白的身高:1&lt;span&gt;.8米    体重:130千克
大白的BMI指数为:&lt;/span&gt;40.123456790123456
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明：在调用模块中的变量、函数或者类时，需要在变量名、函数名或者类名前添加“模块名.”作为前缀。例如，上面代码中的bmi.fun_bmi，表示调用bm i模块中的fun_bmi() 函数。&lt;/p&gt;
&lt;p&gt;多学两招：&lt;/p&gt;
&lt;p&gt;如果模块名比较长不容易记住，可以在导入模块时，使用as 关键字为其设置一个别名，然后就可以通过这个别名来调用模块中的变量、函数和类等。例如，将上面导入模块的代码修改为以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; bmi as m                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入bmi模块并设置别名为m&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，在调用bmi 模块中的fun_bmi() 函数时，可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
m.fun_bmi(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大白&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1.80,130)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行模块中的fun_bmi()函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用import 语句还可以一次导入多个模块，在导入多个模块时，模块名之间使用逗号“,”进行分隔。例如，分别创建了bmi.py、tips.py 和 differenttree.py 3 个模块文件。想要将这3个模块全部导入，可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; bmi,tips,differenttree
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;8.2.3 使用from...import 语句导入模块&lt;/h3&gt;
&lt;p&gt;在使用import 语句导入模块时，每执行一条import 语句都会创建一个新的命名空间（namespace），并且在该命名空间中执行与.py 文件相关的所有语句。在执行时，需在具体的变量、函数和类名前加上“模块名.”前缀。如果不想在每次导入模块时都创建一个新的命名空间，而是将具体的定义导入到当期的命名空间，这时可以使用from...import 语句。使用from...import 语句导入模块后，不需要在添加前缀，直接通过具体的变量、函数和类名等访问即可。&lt;/p&gt;
&lt;p&gt;说明：命名空间可以理解我记录对象名字和对象之间对应关系的空间。目前Python的命名空间大部分都是通过字典（dict）来实现的。其中，key 是标识符；value 是具体的对象。例如，key 是变量的名字，value 则是变量的值。&lt;/p&gt;
&lt;p&gt;from...import 语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; modelname &lt;span&gt;import&lt;/span&gt; member
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;modelname：模块名称，区分字母大小写，需要和定义模块时设置的模块名称大小写保存一致。&lt;/li&gt;
&lt;li&gt;member：用于指定要导入的变量、函数或者类等。可以同时导入多个定义，各个定义之间使用逗号“.” 分隔。如果想导入全部定义，也可以使用通配符号“*” 代替。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多学两招：在导入模块时，如果使用通配符“*” 导入全部定义后，想查看具体导入了哪些定义，可以通过显示dir() 函数的值来查看。例如，执行print(dir()) 语句后将显示类似下面的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__annotations__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;例如，通过下面的3 条语句都可以从模块导入指定的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bmi &lt;span&gt;import&lt;/span&gt; fun_bmi                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入bmi模块的fun_bmi函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; bmi &lt;span&gt;import&lt;/span&gt; fun_bmi,fun_bmi_uparade  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入bmi模块的fun_bmi和fun_upgrade函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; bmi &lt;span&gt;import&lt;/span&gt; *                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入bmi模块的全部定义（包括变量和函数）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：在使用from...import 语句导入模块中的定义时，需要保证所导入的内容在当前的命名空间中是唯一的，否则将出现冲突，后导入的同名变量、函数或者会覆盖先导入的。这时就需要使用import语句进行导入。&lt;/p&gt;
&lt;p&gt;实例02：导入两个包括同名函数的模块&lt;/p&gt;
&lt;p&gt;创建两个模块，一个是矩形模块，其中包括计算矩形周长和面积的函数；另一个是圆形，其中包括计算圆形周长和面积的函数。然后在另一个Python文件中导入这两个模块，并调用相应的函数计算周长的面积。具体步骤如下：&lt;/p&gt;
&lt;p&gt;（1）创建矩形模块，对应的文件名为rectangle.py，在该文件中定义两个函数，一个用于计算矩形的周长，另一个用于计算矩形的面积，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; firth(width,height):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：计算周长
        参数：width（宽度）、height（高）
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;(width + height)*2
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; area(width,height):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：计算面积
        参数：width（宽度）、height（高）
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; width *&lt;span&gt; height
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(area(10,20))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）创建圆形模块，对应的文件名称为circular.py，在该文件中定义两个函数，一个用于计算圆形的周长，另一个用于计算圆形的面积，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; math                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入标志模块math&lt;/span&gt;
PI = math.pi                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 圆周率&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; girth(r):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：计算周长
        参数：r（半径）
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; round(2 * PI * r ,2 )        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算周长并保留两位小数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; area(r):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：计算面积
        参数：r（半径）
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; round(PI * r * r ,2 )      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算面积并保留两位小数&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(girth(10))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）创建一个名称为compute.py 的Python文件，首先导入矩形模块的全部定义，然后导入圆形模型的全部定义，最后分别调用计算矩形周长的函数和计算圆形周长的函数，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rectangle &lt;span&gt;import&lt;/span&gt; *                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入矩形模块&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; circular &lt;span&gt;import&lt;/span&gt; *                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入圆形模块&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;圆形的周长为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,girth(10))      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用计算圆形周长的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;矩形的周长为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,area(10,20))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用计算矩形周长的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行compute.py文件，将显示如下结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
圆形的周长为： 62.83&lt;span&gt;
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\python3.6.5\练习文件\main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 11, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;矩形的周长为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,girth(10,20))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用计算矩形周长的函数&lt;/span&gt;
TypeError: girth() takes 1 positional argument but 2 were given
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从图中可以看出执行步骤（3）的第5行代码时出现异常，这是因为原本想执行的矩形模块的girth() 函数被圆形模块的girth() 函数给盖住了。解决该问题的方法是，不使用from...import 语句导入，而是使用import 语句导入。修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; rectangle as r                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入矩形模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; circular as c                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入圆形模块&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;圆形的周长为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,c.girth(10))      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用计算圆形周长的函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;矩形的周长为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,r.area(10,20))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用计算矩形周长的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
圆形的周长为： 62.83&lt;span&gt;
矩形的周长为： &lt;/span&gt;200
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;8.2.4 模块搜索目录&lt;/h3&gt;
&lt;p&gt;当使用import 语句导入模块时，默认情况下，会按照以下顺序进行查找。&lt;/p&gt;
&lt;p&gt;（1）在当前目录（即执行的Python 脚本文件所在目录）下查找。&lt;/p&gt;
&lt;p&gt;（2）到PYTHONPATH（环境变量）下的每个目录中查找。&lt;/p&gt;
&lt;p&gt;（3）到Python 的默认安装目录下查找。&lt;/p&gt;
&lt;p&gt;以上各个目录的具体位置保存在标准模块sys 的sys.path 变量中。可以通过以下代码输出具体的目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; sys             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入标准模块sys&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(sys.path)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出具体目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;注意：使用import 语句导入模块时，模块名是区分字母大小写的。&lt;/p&gt;
&lt;p&gt;这时，我们可以通过以下3 种方式添加指定的目录到sys.path 中。&lt;/p&gt;
&lt;h4&gt;1. 临时添加&lt;/h4&gt;
&lt;p&gt;临时添加即在导入模块的Python 文件中添加。&lt;/p&gt;
&lt;h4&gt;2. 增加.pth文件（推荐）&lt;/h4&gt;
&lt;p&gt;注意：创建.pth 文件后，需要重新打开要执行的导入模块的Python 文件，否则新添加的目录不起作用。&lt;/p&gt;
&lt;p&gt;说明：通过该方法添加的目录只在当前版本的Python 中有效。&lt;/p&gt;
&lt;h4&gt;3. 在PYTHONPATH 环境变量中添加&lt;/h4&gt;
&lt;p&gt;说明：通过该方法添加的目录可以在不同版本的Python 中共享。&lt;/p&gt;
&lt;h2&gt;8.3 以主程序的形式执行&lt;/h2&gt;
&lt;p&gt;这里先来创建一个模块，名称为christmastree，该模块的内容为第6章中的编写的实例05的代码。该段代码中，首先定义一个全局变量，然后创建一个名称为fun_christmastree() 的函数，最后在通过print() 函数输出一些内容。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
pinetree = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是一棵松树&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个全局变量（松树）&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; fun_christmastree():                                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：一个梦
        无返回值
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    pinetree &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;挂上彩灯、礼物……我变成一棵圣诞树 @^.^@ \n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义局部变量&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(pinetree)                                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出局部变量的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;**************************函数体外*****************************#&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n下雪了……\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=============开始做梦……==============\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
fun_christmastree()                                           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用函数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=============梦醒了……==============\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
pinetree &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我身上落满雪花，&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ pinetree + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-_-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为全局变量赋值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(pinetree)                                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出全局变量的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在与Christmastree 模块同级的目录下，创建一个名称为main.py 的文件，在该文件中，导入christmastree 模块，再通过print() 语句输出模块中的全局变量pinetree 的值，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; christmastree                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入Christmastree模块&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全局变量的值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,christmastree.pinetree)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码，显示结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;下雪了……

&lt;/span&gt;=============开始做梦……==============&lt;span&gt;

挂上彩灯、礼物……我变成一棵圣诞树 @&lt;/span&gt;^.^&lt;span&gt;@ 

&lt;/span&gt;=============梦醒了……==============&lt;span&gt;

我身上落满雪花，我是一棵松树&lt;/span&gt;-_-&lt;span&gt;
全局变量的值为： 我身上落满雪花，我是一棵松树&lt;/span&gt;-_-
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上的运行结果可以看出，导入模块后，不仅输出了全局变量的值，而且模块中原有的测试代码也被执行了。这个结果显然不是我们想要的。那么如何输出全局变量的值呢？实际上，可以在模块中，将原本直接执行的代码放在一个if 语句中。因此，可以将模块Christmastree 的代码修改为以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
pinetree = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是一棵松树&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个全局变量（松树）&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; fun_christmastree():                                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;功能：一个梦
        无返回值
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    pinetree &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;挂上彩灯、礼物……我变成一棵圣诞树 @^.^@ \n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义局部变量&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(pinetree)                                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出局部变量的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;**************************函数体外*****************************#&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n下雪了……\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=============开始做梦……==============\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    fun_christmastree()                                           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=============梦醒了……==============\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    pinetree &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我身上落满雪花，&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ pinetree + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-_-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为全局变量赋值&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(pinetree)                                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出全局变量的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次执行导入模块的main.py 文件，可以看出示测试代码并没有执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
全局变量的值为： 我是一棵松树
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，如果执行christmastree.py 文件，结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;下雪了……

&lt;/span&gt;=============开始做梦……==============&lt;span&gt;

挂上彩灯、礼物……我变成一棵圣诞树 @&lt;/span&gt;^.^&lt;span&gt;@ 

&lt;/span&gt;=============梦醒了……==============&lt;span&gt;

我身上落满雪花，我是一棵松树&lt;/span&gt;-_-
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明：在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量，以确定它们在哪个模块中执行。如果一个模块不是被导入到其他程序中执行，那么它可能在解释器的顶级模块中执行。顶级模块的__name__变量的值为__main__。&lt;/p&gt;
&lt;h2&gt;8.4 Python中的包&lt;/h2&gt;
&lt;p&gt; 使用模块可以避免函数名和变量名重名引发的冲突。那么，如果模块名重复应该怎么办呢？在Python中，提出了包（Package）的概念。包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下。这样，既可以起到规范代码的作用，又能避免模块名重名引起的冲突。&lt;/p&gt;
&lt;p&gt;说明：包简单的理解就是“文件夹”，只不过在该文件夹下必须存在一个名称为“__init__.py”的文件。&lt;/p&gt;
&lt;h3&gt;8.4.1 Python程序的包结构&lt;/h3&gt;
&lt;p&gt;在实际项目开发时，通常情况下，会创建多个包用于存放不同类的文件。&lt;/p&gt;
&lt;h3&gt;8.4.2 创建和使用包&lt;/h3&gt;
&lt;p&gt;下面将分别介绍如何创建和使用包。&lt;/p&gt;
&lt;h4&gt;1. 创建包&lt;/h4&gt;
&lt;p&gt;创建包实际上就是创建一个文件夹，并且在该文件夹中创建一个名称为“__init__.py”的Python文件。在__init__.py文件中，可以不编写任何代码，也可以编写一些Python代码。在__init__.py文件中所编写的代码，在导入包时会自动执行。&lt;/p&gt;
&lt;p&gt;说明：__init__.py文件是一个模块文件，模块名称对应的包名。例如，在settings包中创建的__init__.py文件，对应的模块名为settings。&lt;/p&gt;
&lt;p&gt;至此，名称为settings的包创建完毕了，创建完毕之后便可以在该包中创建所需的模块了。&lt;/p&gt;
&lt;h4&gt;2. 使用包&lt;/h4&gt;
&lt;p&gt;创建包以后，就可以在包中创建相应的模块，然后再使用import语句从包中加载模块。从包中加载模块通常有以下3 种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过“import+完整包名+模块名”形式加载指定模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过“import+完整包名+模块名”形式是指：假如有一个名称为settings的包，在该包下有一个名称为size 的模块，那么要导入size 模块，可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; settings.size
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过该方式导入模块后，在使用时需要使用完整的名称。例如，在已经创建的settings包中创建一个名称为size的模块，并且在该模块中定义两个变量，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
width = 800             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 宽度&lt;/span&gt;
heigtht = 600          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 高度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这时，通过“import+完整包名+模块名”形式导入size模块后，在调用width和height变量时，就需要在变量名前加入“settings.size”前缀。对应的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; settings.size                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入settings包下的size模块&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宽度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,settings.size.width)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,settings.size.height)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码后，将显示以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
宽度: 800&lt;span&gt;
高度: &lt;/span&gt;600
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;通过“from+完整包名+import+模块名”形式加载指定模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;“from+完整包名+import+模块名”形式是指：假如有一个名称为settings的包，在该包下有一个名称为size的模块，那么要导入size模块，可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
form settings &lt;span&gt;import&lt;/span&gt; size
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过该方式导入模块后，在使用时不需要带包前缀，但是需要带模块名。例如，想通过“from+完整包名+import+模块名”形式导入上面已经创建的size模块，并且调用width和height变量，就可以通过下面的代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; settings &lt;span&gt;import&lt;/span&gt; size                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入settings包下的size模块&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宽度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,size.width)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,size.height)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码后，将显示以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
宽度: 800&lt;span&gt;
高度: &lt;/span&gt;600
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;通过“from+完整包名+模块名+import+定义名”形式加载指定模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;“from+完整包名+模块名+import+定义名”形式是指：加入有一个名称为settings的包，在该包下有一个名称为size的模块，那么要导入size模块中的width和height变量，可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; settings.size &lt;span&gt;import&lt;/span&gt; width,height
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过该方式导入模块的函数、变量或类后，在使用时直接使用函数、变量或类名即可。例如，想通过“from+完整包名+模块名+import+定义名”形式导入上面已经创建的size模块的width和height，并输出，就可以通过下面的代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入settings包下size模块中的width和height变量&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; settings.size &lt;span&gt;import&lt;/span&gt;&lt;span&gt; width,height
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宽度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,width)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出宽度&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高度:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,height)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出高度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码后，将显示以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
宽度: 800&lt;span&gt;
高度: &lt;/span&gt;600
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明：在通过“from+完整包名+模块名+import+定义名”形式加载指定模块时，可以使用星号“*” 代替定义名，表示加载该模块下的全部定义。&lt;/p&gt;
&lt;p&gt;实例03：在指定包中创建通过的设置和获取尺寸的模块&lt;/p&gt;
&lt;p&gt;创建一个名称为settings 的包，在该包下创建一个名称为size的模块，通过该模块实现设置和获取尺寸的通用功能。具体步骤如下：&lt;/p&gt;
&lt;p&gt;（1）在settings包中，创建一个名称为size的模块，在该模块中，定义两个保护类型的的全局变量，分别代表宽度和高度，然后定义一个change()函数，用于修改两个全局变量的值，在定义两个函数，分别用于获取宽度和高度，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
width = 800             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义保护类型的全局变量（宽度）&lt;/span&gt;
height = 600            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义保护类型的全局变量（高度）&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change(w,h):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt; _width       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全局变量(宽度)&lt;/span&gt;
    _width = w          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新给宽度赋值&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt; _height      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全局变量（高度）&lt;/span&gt;
    _height = h         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新给高度赋值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; getWidth():         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取宽度的函数&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt;&lt;span&gt; _width
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _width
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; getHeight():        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取高度的函数&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt;&lt;span&gt; _height
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _height
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在settings 包的上一层目录中创建一个名称为main.py的文件，在该文件中导入settings包下的size模块的全部定义，并且调用change()函数重新设置宽度和高度，然后在分别调用getWidth()和getHeight()函数获取修改后的宽度和高度，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; settings.size &lt;span&gt;import&lt;/span&gt; *         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入size模块下的全部定义&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    change(&lt;/span&gt;1024,768)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用change()函数改变尺寸&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宽度：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,getWidth())      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出宽度&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高度：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,getHeight())     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出高度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行本实例，显示结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
宽度： 1024&lt;span&gt;
高度： &lt;/span&gt;768
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;8.5 引用其他模块&lt;/h2&gt;
&lt;p&gt;在Python中，除了可以自定义模块外，还可以引用其他模块，主要包括使用标准模块和第三方模块。下面分别进行介绍。&lt;/p&gt;
&lt;h3&gt;8.5.1 导入和使用标准模块&lt;/h3&gt;
&lt;p&gt;在Python中，自带了很多实用的模块，称为标准模块（也可以称为标准库），对于标准模块，我们可以直接使用import语句导入Python文件中使用。例如，导入标准模块random（用于生成随机数），可以使用下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; random             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入标准模块random&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：在导入标准模块时，也可以使用as 关键字为其指定别名。通常情况下，如果模块名比较长，则可以为其设置别名。&lt;/p&gt;
&lt;p&gt;导入标准模块后，可以通过模块名调用其提供的函数。例如，导入random模块后，就可以调用randint()函数生成一个指定范围的随机数整数。例如，生成一个0~10（包括0和10）的随机整数的时代代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; random                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入标准模块random&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(random.randint(0,10)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出0~10的随机数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面的代码，可能会输出0~10 中的任意一个数。&lt;/p&gt;
&lt;p&gt;实例04：生成有数字、字母组成的4 位验证码&lt;/p&gt;
&lt;p&gt;在IDLE 中创建一个名称为checkcode.py 的文件，然后在该文件中导入Python 标准模块中random 模块（用于生成随机数），然后定义一个保存验证码的变量，在应用for 语句实现一个重复4 次的循环，在该循环中，调用random 模块提供的randrange() 和randint() 方法生成符合要求的验证码，最后输出生成的验证码，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; random                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入标准模块中的random&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    checkcode &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存验证码的变量&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4):              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环4次&lt;/span&gt;
        index = random.randrange(0,4) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成0~3中的一个数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; index != i &lt;span&gt;and&lt;/span&gt; index + 1 !=&lt;span&gt; i:
            checkcode &lt;/span&gt;+= chr(random.randint(97,122)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成a~z中的一个小写字母&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; index + 1 ==&lt;span&gt; i:
            checkcode &lt;/span&gt;+= chr(random.randint(65,90))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成A~Z中的一个大写字母&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            checkcode &lt;/span&gt;+= str(random.randint(1,9))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成1~9中的一个数字&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,checkcode)                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出生成的验证码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行本实例，显示如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
验证码： k5Ni
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了random模块外，Python还提供了大约200多个内置的标准模块，涵盖了Python运行时服务、文字模式匹配、操作系统接口、数学运算、对象永久保存、网络和Internet脚本和GUI构建等方面。&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;caption&gt;Python常用的内置标准模块&lt;/caption&gt;
&lt;tbody readability=&quot;12&quot;&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;模块名&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys&lt;/td&gt;
&lt;td&gt;与Python解释器及其环境操作相关的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time&lt;/td&gt;
&lt;td&gt;提供与时间相关的各种函数的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;os&lt;/td&gt;
&lt;td&gt;提供了访问凑在哦系统服务功能的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;calendar&lt;/td&gt;
&lt;td&gt;提供了与日期相关的各种函数的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;urllib&lt;/td&gt;
&lt;td&gt;用于读取来自网上（服务器上）的数据的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;json&lt;/td&gt;
&lt;td&gt;用于使用JSON序列化和反序列化对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;re&lt;/td&gt;
&lt;td&gt;用于在字符串中执行正则表达式匹配和替换&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math&lt;/td&gt;
&lt;td&gt;提供算术运算函数的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;shutil&lt;/td&gt;
&lt;td&gt;用于进行高级文件操作，如复制、移动和重命名等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;logging&lt;/td&gt;
&lt;td&gt;提供了灵活的记录事件、错误、警告和调试信息等日志的功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tkinter&lt;/td&gt;
&lt;td&gt;使用Python进行GUI编程的标准库&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;8.5.2 第三方模块的下载与安装&lt;/h3&gt;
&lt;p&gt;在进行Python程序开发时，除了可以使用Python内置的标准模块外，还有很多第三方模块可以被我们所使用。对于这些第三方模块，可以在Python官方推出的&lt;a href=&quot;http://pypi.python.org/pypi&quot; target=&quot;_blank&quot;&gt;http://pypi.python.org/pypi&lt;/a&gt;中找到。&lt;/p&gt;
&lt;p&gt;在使用第三方模块时，需要先下载并安装该模块，然后就可以像使用标准模块一样导入并使用了。本节主要介绍如何下载和安装。下载和安装第三方模块可以使用Python提供的pip命令实现。pip命令的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip&amp;lt;command&amp;gt;[modulename]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;command：用于指定要执行的命令。常用的参数值有install（用于安装第三方模块）、uninstall（用于卸载已经安装的第三方模块）、list（用于显示已经安装的第三方模块）等。&lt;/li&gt;
&lt;li&gt;modulename：可选参数，用于指定要安装或者卸载的模块名，当command为install或者uninstall时不能省略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，安装第三方numpy模块（用于科学计算），可以在命令行窗口中输入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install mumpy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行上面代码，将在线安装numpy模块。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372012/201903/1372012-20190315002022730-920427040.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：添加完环境变量需要重启命令窗口。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;说明：在大型程序中可能需要导入很多模块，推荐先导入Python提供的标准模块，然后在导入第三方模块，最后导入自定义模块。&lt;/p&gt;
&lt;p&gt;多学两招：如果想要查看Python中的都有哪些模块（包括标准模块和第三方模块），可以在INLE中输入以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
help(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;modules&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果只是想要查看已经安装的第三方模块，可以在命令行窗口中输入以下命令：&lt;/p&gt;


</description>
<pubDate>Thu, 14 Mar 2019 16:22:00 +0000</pubDate>
<dc:creator>牧牛人</dc:creator>
<og:description>第8章 模块 8.1 模块概述 模块的英文是Modules，可以认为是一盒（箱）主题积木，通过它可以拼出某一个主题的东西。这与第6章介绍的函数不同，一个函数相当于一块积木，而一个模块中可以包括很多函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ooo888ooo/p/10360654.html</dc:identifier>
</item>
<item>
<title>日常报错记录2： MyBatis：DEBUG [main] - Logging initialized using 'class org.apache.ibatis.logging.slf4j.Slf4jImpl' adapter.------------ Cause: java.lang.NoSuchMethodException: com.offcn.dao.ShopDao.() - 十三山入秋</title>
<link>http://www.cnblogs.com/shiyuzhahan/p/10534490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiyuzhahan/p/10534490.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 直接上干货：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 报错归纳1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; DEBUG [main] - Logging initialized using 'class org.apache.ibatis.logging.slf4j.Slf4jImpl' adapter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565547/201903/1565547-20190314194259077-935736547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因：xml里面不能有java方不存在的类，它是会去找的，找不到就报错，所以，万一删掉java类了，xml里面的相对应映射的字段也要注释掉。遇到两次了！浪费不少时间！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.MyBatis     他要加空构造   实例化对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565547/201903/1565547-20190314204802357-1722644807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因：MyBitis ，他实体类pojo  class里 要加空构造&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;3.写法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565547/201903/1565547-20190315000530585-1566356659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; class 是点，路径是斜杠&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml 控制多级级联查数据库，是可以的，（MyBatis xml作为实现 数据库查询），我这里四级连着查询&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;?xml version&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;1.0&lt;/span&gt;&quot; encoding&lt;span&gt;=&lt;/span&gt;&quot;UTF&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&quot;?&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;!DOCTYPE mapper
        &lt;/span&gt;&lt;span&gt;PUBLIC&lt;/span&gt; &quot;&lt;span&gt;-//&lt;/span&gt;mybatis.org&lt;span&gt;//&lt;/span&gt;DTD Mapper &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EN&quot;
        &quot;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;mybatis.org&lt;span&gt;/&lt;/span&gt;dtd&lt;span&gt;/&lt;/span&gt;mybatis&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;mapper.dtd&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;mapper namespace&lt;span&gt;=&lt;/span&gt;&quot;com.XXXX.dao.ShopDao&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;--&lt;/span&gt;&lt;span&gt;private int sid;&lt;/span&gt;
&lt;span&gt;
    private String sname;

    private List&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;Book&lt;span&gt;&amp;gt;&lt;/span&gt; blist;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;resultMap id&lt;span&gt;=&lt;/span&gt;&quot;resultMap_shop&quot; type&lt;span&gt;=&lt;/span&gt;&quot;shop&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;id property&lt;span&gt;=&lt;/span&gt;&quot;sid&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;sid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;sname&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;sname&quot; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;collection property&lt;span&gt;=&lt;/span&gt;&quot;blist&quot;  ofType&lt;span&gt;=&lt;/span&gt;&quot;book&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;id property&lt;span&gt;=&lt;/span&gt;&quot;bid&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;bid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;bname&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;bname&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;association property&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;user&lt;/span&gt;&quot; javaType&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;user&lt;/span&gt;&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;id property&lt;span&gt;=&lt;/span&gt;&quot;uid&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;uid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;uname&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;uname&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;password&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;password&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;association property&lt;span&gt;=&lt;/span&gt;&quot;p&quot; javaType&lt;span&gt;=&lt;/span&gt;&quot;person&quot; &lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;id property&lt;span&gt;=&lt;/span&gt;&quot;pid&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;pid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;pname&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;pname&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;sex&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;sex&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;result property&lt;span&gt;=&lt;/span&gt;&quot;birthday&quot; &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;birthday&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;association&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;association&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;collection&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;--&lt;/span&gt;&lt;span&gt; &amp;lt;association property=&quot;blist&quot; javaType=&quot;&quot;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;resultMap&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;--&lt;/span&gt;&lt;span&gt; List&amp;lt;Shop&amp;gt; getAll(int sid);--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&quot;getAll&quot; parameterType&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;int&lt;/span&gt;&quot; resultMap&lt;span&gt;=&lt;/span&gt;&quot;resultMap_shop&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t_shop s,t_book b,t_user u,t_person p &lt;span&gt;where&lt;/span&gt; u.user_person_fk&lt;span&gt;=&lt;/span&gt;p.pid &lt;span&gt;and&lt;/span&gt; b.book_user_fk&lt;span&gt;=&lt;/span&gt;u.uid &lt;span&gt;and&lt;/span&gt; s.sid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;#{sid}

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;




&lt;span&gt;&amp;lt;/&lt;/span&gt;mapper&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cause: java.lang.NoSuchMethodException: com.offcn.dao.ShopDao.&amp;lt;init&amp;gt;()，其实是缺少构造，但构造没问题，之后发现是这个写错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565547/201903/1565547-20190315000653535-549952985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 15:58:00 +0000</pubDate>
<dc:creator>十三山入秋</dc:creator>
<og:description>直接上干货： 报错归纳1： DEBUG [main] - Logging initialized using 'class org.apache.ibatis.logging.slf4j.Sl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiyuzhahan/p/10534490.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-6 直接光源采样 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10534492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10534492.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Chapter7 Sample Lights Directly&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Preface&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天我们来讲这个还算牛逼的技术——直接光源采样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前我们提到过，在&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10307569.html&quot; target=&quot;_blank&quot;&gt;2-7&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314191120859-432178464.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前两篇我们也提到要减少噪点，就是图片上的黑点点，所以，所有的矛头都指向了这一篇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说一下为什么会有那么多小点点，就是因为光线路径中没有触碰到光源，路径计算之后就会是黑色的点，可以通过发射大量的光线，比如计算每个像素点的时候发射8k~1w条采样光线进行路径计算；也可以路径计算方面做文章，比如加深路径计算递归深度；等等诸如此类。但是上述方法都是暴力解决法，相当耗时，我们可以运用数学对其进行优化，从而实现画质和效率的双面提升，这就是我们今天要讲的——直接光源采样！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Ready&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能您需要以下基础：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.微分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.立体角 （蒙特卡罗（三））&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没了，剩下全靠想象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;content&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简明扼要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们朝光源方向发送光线或者生成朝向光源的随机方向都是很容易实现的，但是我们需要知道的是，&lt;em&gt;&lt;strong&gt;pdf（direction）&lt;/strong&gt;&lt;/em&gt;是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用书上一张图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314194434992-798000737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个光源区域A，如果我们均匀采样该区域，那么这个pdf就等于1/A，意思就是每个点的概率均等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是和我们的单位球体结合在一起的话，就比较麻烦了，见上图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;？为什么老是提到单位球体呢？？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我们的光线和物体表面的交点，会作为下一个eye，然后新的视线方向是表面单位球随机产生的方向，具体见&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10198423.html&quot; target=&quot;_blank&quot;&gt;1-5中的diagram7-3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314202342581-1994870346.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;好了，渊源就是酱紫，我们继续&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果那个小的微分区域dA的采样概率为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;em&gt;&lt;strong&gt;p_q(&lt;span&gt;q&lt;/span&gt;)*dA&lt;/strong&gt;&lt;/em&gt;（采样比例乘以微分区域）,也就是dA/A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对应到单位球体表面的很小的区域，即我们所述的方位角。方位角微分dΩ对应的采样概率为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;em&gt;p(direction)*dΩ&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有一个用来描述dΩ 和 dA 的表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;dΩ&lt;/em&gt; = dA cos&lt;em&gt;α&lt;/em&gt; / （&lt;em&gt;distance（&lt;strong&gt;&lt;span&gt;p,q&lt;/span&gt;&lt;/strong&gt;）&lt;/em&gt;^2）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即：方位角微分区域：光源微分区域分成（球心到A中心距离平方）份，取其中的cosα代表的份额数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为这个dA 和 dΩ的概率是相同的，所以就有如下等式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p(direction) * cosα * dA / (distance(p,q)^2) = p_q(q) * dA = dA / A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p(direction) = distance(p,q)^2 / (cosα * A)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们接下来就检验一下这个数学公式是否正确&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是代码可能非常丑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要之前的光源的区域参数&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    list[cnt++] = &lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;, &lt;span&gt;220&lt;/span&gt;, &lt;span&gt;340&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;, light);
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;所以我们有以下的代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
rtvec lerp(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, intersect* world, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
{
    hitInfo info;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (world-&amp;gt;hit(sight, (rtvar)&lt;span&gt;0.001&lt;/span&gt;&lt;span&gt;, rtInf(), info))
    {
        ray scattered;
        rtvec emitted &lt;/span&gt;= info._materialp-&amp;gt;&lt;span&gt;emitted(info._u, info._v, info._p);
        rtvar pdf;
        rtvec albedo;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (depth &amp;lt; &lt;span&gt;50&lt;/span&gt; &amp;amp;&amp;amp; info._materialp-&amp;gt;&lt;span&gt;scatter(sight, info, albedo, scattered, pdf))
        {
            rtvec on_light &lt;/span&gt;= rtvec(&lt;span&gt;213&lt;/span&gt; + lvgm::rand01() * (&lt;span&gt;343&lt;/span&gt; - &lt;span&gt;213&lt;/span&gt;), &lt;span&gt;554&lt;/span&gt;, &lt;span&gt;227&lt;/span&gt; + lvgm::rand01() * (&lt;span&gt;332&lt;/span&gt; - &lt;span&gt;227&lt;/span&gt;&lt;span&gt;));
            rtvec to_light &lt;/span&gt;= on_light -&lt;span&gt; info._p;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; distance_squared =&lt;span&gt; to_light.squar();
            to_light.self_unitization();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dot(to_light, info._n) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)    
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; emitted;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; light_area = (&lt;span&gt;343&lt;/span&gt; - &lt;span&gt;213&lt;/span&gt;)*(&lt;span&gt;332&lt;/span&gt; - &lt;span&gt;227&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; light_cosine =&lt;span&gt; fabs(to_light.y());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (light_cosine &amp;lt; 1e-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;)    
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; emitted;
            pdf &lt;/span&gt;= distance_squared / (light_cosine*&lt;span&gt;light_area);
            scattered &lt;/span&gt;=&lt;span&gt; ray(info._p, to_light, sight.time());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; emitted + albedo *info._materialp-&amp;gt;scatter_pdf(sight, info, scattered)*lerp(scattered, world, depth + &lt;span&gt;1&lt;/span&gt;) /&lt;span&gt; pdf;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; emitted;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314233752096-1235237108.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因为我们一路做测试，做图形分析对比，所以我们上图是sample为250时候的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;据说，sample为10时，效果依旧很好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以又超快速运行了一个sample为10的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314233925974-1211549259.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管怎样，我们的图形噪点已经做到了比较不错的境地了，sample为10！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看看之前的sample为250的图形效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314234136627-406089393.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简直噪出天际线&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于本篇的那个图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天花板上灯光周围的噪声是由于灯光是双面的，灯光和天花板之间有一个狭窄空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过将灯光法向量调至垂直向下来解决这一问题，同时让我们的灯光发射函数也做相应的处理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec emitted(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, &lt;span&gt;const&lt;/span&gt; rtvar u, rtvar v, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt;&lt;span&gt; 
        {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dot(info._n,rIn.direction())&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _emit-&amp;gt;&lt;span&gt;value(u, v, p); 
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; 
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;记得一起改了material基类，以及lerp的emit函数调用根据上述参数描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们又得到了一个sample为10的新图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190314235342516-1758806455.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没什么大的变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只是灯光周围的噪点少了，解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为灯光的法向量垂直向下，而我们的反射光线与反射之后与法向量的夹角为锐角的时候才进行纹理计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而来自屋顶上面的光线与灯光区域碰撞反射的方向与法向量呈钝角（注意是反射之后的新方向不是入射光方向）则不计算返回黑色，默认光无法到达&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 15:58:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Sample Lights Directly</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10534492.html</dc:identifier>
</item>
<item>
<title>学习笔记——二叉树相关算法的实现（Java语言版） - 殇灬央</title>
<link>http://www.cnblogs.com/shangyang/p/10531779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangyang/p/10531779.html</guid>
<description>&lt;h3&gt;遍历（Traverse）：&lt;/h3&gt;
&lt;p&gt;　　所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。&lt;/p&gt;

&lt;p&gt;　　从二叉树的&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%92%E5%BD%92&quot; target=&quot;_blank&quot;&gt;递归&lt;/a&gt;定义可知，一棵非空的二叉树由根结点及左、右子树这三个基本部分组成。&lt;/p&gt;
&lt;p&gt;　　因此，在任一给定结点上，可以按某种次序执行三个操作：&lt;/p&gt;
&lt;p&gt;　　　　⑴ 访问结点本身（D），&lt;/p&gt;
&lt;p&gt;　　　　⑵ 遍历该结点的左子树（L），&lt;/p&gt;
&lt;p&gt;　　　　⑶ 遍历该结点的右子树（R）。&lt;/p&gt;

&lt;p&gt;　　先序/根遍历DLR：根   左子树     右子树&lt;br/&gt;　　中序/根遍历LDR：左子树   根     右子树&lt;br/&gt;　　后根/序遍历LRD：左子树     右子树  根&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;注意：由于树的递归定义，其实对三种遍历的概念其实也是一个递归的描述过程&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;二叉树结点类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190314162542790-994262253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 二叉链表的结点
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; shangyang
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    
    Object value;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结点值&lt;/span&gt;
    Node leftChild;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左子树的引用&lt;/span&gt;
    Node rightChild;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右子树的引用&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(Object value) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(Object value, Node leftChild, Node rightChild) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.leftChild =&lt;span&gt; leftChild;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rightChild =&lt;span&gt; rightChild;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Node [value=&quot; + value + &quot;, leftChild=&quot; + leftChild + &quot;, rightChild=&quot; + rightChild + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 二叉树方法接口类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('020630f0-9b42-4d49-a236-a16829b316f6')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_020630f0-9b42-4d49-a236-a16829b316f6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_020630f0-9b42-4d49-a236-a16829b316f6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('020630f0-9b42-4d49-a236-a16829b316f6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_020630f0-9b42-4d49-a236-a16829b316f6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 二叉树的接口
 * 可以有不同的实现类，每个类可以使用不同的存储结构，比如顺序结构、链式结构
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; shangyang
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BinaryTree {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否为空树
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 树结点数量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取树的高度
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getHeight();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询指定值的结点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node findKey(Object value);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 前序递归遍历
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrderTraverse();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 中序递归遍历
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrderTraverse();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 后序递归遍历
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrderTraverse();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按照层次遍历（借助队列）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelOrderByStack();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 中序非递归遍历
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrderByStack();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;二叉树接口类&lt;/span&gt;&lt;/div&gt;
&lt;h3 class=&quot;para&quot;&gt;实现二叉树接口类&lt;/h3&gt;
&lt;p&gt;创建树的根对象，并写出构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedBinaryTree &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BinaryTree {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node root;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根结点&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedBinaryTree() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedBinaryTree(Node root) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; root;
    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 创建二叉树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201903/1591870-20190314230754456-929720430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个二叉树&lt;/span&gt;
    Node nodeF = &lt;span&gt;new&lt;/span&gt; Node(&quot;F&quot;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    Node nodeE &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;E&quot;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    Node nodeD &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;D&quot;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    Node nodeC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;C&quot;,nodeF,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    Node nodeB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;B&quot;&lt;span&gt;,nodeD,nodeE);
    Node nodeA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;A&quot;&lt;span&gt;,nodeB,nodeC);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明nodeA为根结点&lt;/span&gt;
    BinaryTree btree = &lt;span&gt;new&lt;/span&gt; LinkedBinaryTree(nodeA);        
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 判断二叉树是否为空&lt;/h3&gt;
&lt;p&gt;为空返回true，不为空返回false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;输出二叉树结点数量&lt;/h3&gt;
&lt;p&gt;运用递归的思想，二叉树结点树 = 左子树结点数量 + 右子树结点数量 + 1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        System.out.println(&lt;/span&gt;&quot;二叉树结点数量： &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size(root);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size(Node root) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取左子树的数量&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; nl = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size(root.leftChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取右子树的数量&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; nr = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size(root.rightChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回左子树、右子树size之和并加1&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; nl + nr + 1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二叉树的深度（高度）&lt;/h3&gt;
&lt;p&gt;如果二叉树为空，则其深度为0。&lt;/p&gt;
&lt;p&gt;如果二叉树只有根结点，无左右子树，则其深度为1。&lt;/p&gt;
&lt;p&gt;如果二叉树结点数大于1,则用递归的思想计算其深度。二叉树的深度 = 左右子树的最大深度 + 1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getHeight() {
        System.out.println(&lt;/span&gt;&quot;二叉树的高度是 ：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHeight(root);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getHeight(Node root) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取左子树的高度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; nl = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHeight(root.leftChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取右子树的高度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; nr = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHeight(root.rightChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回左子树、右子树较大高度并加1&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; nl &amp;gt; nr ? nl + 1 : nr + 1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在二叉树中查找某个值&lt;/h3&gt;
&lt;p&gt;运用递归的思想，将要查找的值逐个与根结点，根结点的左子树和右子树的值进行比较，并进行返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node findKey(Object value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.findKey(value,root);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node findKey(Object value,Node root) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结点为空，可能是整个树的根结点，也可能是递归调用中叶子结点中左孩子和右孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.value ==&lt;span&gt; value) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归体&lt;/span&gt;
            Node leftnode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.findKey(value,root.leftChild);
            Node rightnode &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.findKey(value, root.rightChild);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftnode != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; leftnode.value ==&lt;span&gt; value) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; leftnode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (rightnode != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; rightnode.value ==&lt;span&gt; value) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightnode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;先序递归遍历&lt;/h3&gt;
&lt;p&gt;若二叉树非空，则依次执行如下操作：&lt;/p&gt;
&lt;p&gt;　　⑴ 访问根结点；&lt;/p&gt;
&lt;p&gt;　　⑵ 遍历左子树；&lt;/p&gt;
&lt;p&gt;　　⑶ 遍历右子树。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrderTraverse() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出根结点的值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(root != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.print(root.value &lt;/span&gt;+ &quot;  &quot;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对左子树进行先序遍历
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建一个二叉树，根是左子树的根&lt;/span&gt;
            BinaryTree leftTree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedBinaryTree(root.leftChild);
            leftTree.preOrderTraverse();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对右子树进行先序遍历
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建一个二叉树，根是左子树的根&lt;/span&gt;
            BinaryTree rightTree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedBinaryTree(root.rightChild);
            rightTree.preOrderTraverse();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;中序递归遍历&lt;/h3&gt;
&lt;p&gt;若二叉树非空，则依次执行如下操作：&lt;/p&gt;
&lt;p&gt;　　⑴ 遍历左子树；&lt;/p&gt;
&lt;p&gt;　　⑵ 访问根结点；&lt;/p&gt;
&lt;p&gt;　　⑶ 遍历右子树。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrderTraverse() {
        System.out.println(&lt;/span&gt;&quot;中序遍历&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inOrderTraverse(root);
        System.out.println();
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrderTraverse(Node root) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历左子树&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inOrderTraverse(root.leftChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出根的值&lt;/span&gt;
            System.out.print(root.value + &quot;  &quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历右子树&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inOrderTraverse(root.rightChild);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 后续递归遍历&lt;/h3&gt;
&lt;p&gt;若二叉树非空，则依次执行如下操作：&lt;/p&gt;
&lt;p&gt;　　⑴ 遍历左子树；&lt;/p&gt;
&lt;p&gt;　　⑵ 遍历右子树；&lt;/p&gt;
&lt;p&gt;　　⑶ 访问根结点。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrderTraverse() {
        System.out.println(&lt;/span&gt;&quot;后序遍历&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.postOrderTraverse(root);
        System.out.println();
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrderTraverse(Node root) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历左子树&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.postOrderTraverse(root.leftChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历右子树&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.postOrderTraverse(root.rightChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出根的值&lt;/span&gt;
            System.out.print(root.value + &quot;  &quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 按照层次遍历（借助队列）&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;该方法可以借助java中提供queue队列接口来完成。&lt;strong&gt;LinkedList&lt;/strong&gt;实现了该接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelOrderByStack() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        Queue&lt;/span&gt;&amp;lt;Node&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Node&amp;gt;&lt;span&gt;();
        queue.add(root);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(queue.size() != 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; queue.size();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {
                Node temp &lt;/span&gt;=&lt;span&gt; queue.poll();
                System.out.print(temp.value &lt;/span&gt;+ &quot;  &quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp.leftChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    queue.add(temp.leftChild);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp.rightChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                    queue.add(temp.rightChild);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt; 中序非递归遍历（借助栈）&lt;/h3&gt;
&lt;p&gt;（1) 若根结点不为空，则将其放如栈中，并判断其左子树是否为空。&lt;/p&gt;
&lt;p&gt;（2) 若不为空，则将子树根结点放入栈中，并继续向下判断，直至左子树为空。&lt;/p&gt;
&lt;p&gt;（3) 若栈中有结点，则将其取出，并对其右子树根结点进行（1)（2)步骤，直至无结点或栈中元素为空。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrderByStack() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建栈&lt;/span&gt;
        Deque&amp;lt;Node&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Node&amp;gt;&lt;span&gt;();
        Node current &lt;/span&gt;=&lt;span&gt; root;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(current != &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;stack.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(current);
                current &lt;/span&gt;=&lt;span&gt; current.leftChild;
            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;stack.isEmpty()) {
                current &lt;/span&gt;=&lt;span&gt; stack.pop();
                System.out.print(current.value &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
                current &lt;/span&gt;=&lt;span&gt; current.rightChild;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 14 Mar 2019 15:56:00 +0000</pubDate>
<dc:creator>殇灬央</dc:creator>
<og:description>Java语言实现二叉树的基本算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangyang/p/10531779.html</dc:identifier>
</item>
<item>
<title>LoRaWAN 1.1 网络协议规范 - 5 MAC指令 - 在路上的Ye子</title>
<link>http://www.cnblogs.com/eydonmlau/p/10534469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eydonmlau/p/10534469.html</guid>
<description>&lt;center&gt;&lt;span&gt;LoRaWAN 1.1 网络协议规范&lt;/span&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;em&gt;LoRaWAN 1.1 版本封稿很久了也没有完整啃过一遍，最近边啃边翻译，趁着这个机会把它码下来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果觉得哪里有问题，欢迎留言斧正。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;翻译不易，转载请申明出处和链接。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;网络管理时会在网络服务器和终端设备的MAC层之前传输一系列的MAC指令。MAC层指令对应用、应用服务器或终端设备的应用永不可见。&lt;/p&gt;
&lt;p&gt;单个数据帧可以包含任何MAC指令序列，MAC指令既可以包含在&lt;strong&gt;FOpts&lt;/strong&gt;字段中和正常数据一起发送，也可以放在&lt;strong&gt;FRMPayload&lt;/strong&gt;字段单独发送，这是FPorts为0。放在FOpts中的MAC指令必须加密且不得超过15个字节。放在&lt;strong&gt;FRMPayload&lt;/strong&gt;中的MAC必须加密，且&lt;span&gt;不能&lt;/span&gt;超过&lt;strong&gt;FRMPayload&lt;/strong&gt;的最大长度。&lt;/p&gt;
&lt;p&gt;一条MAC指令由一个字节的命令ID(&lt;strong&gt;CID&lt;/strong&gt;)和可能为空的特定命令序列组成。&lt;/p&gt;
&lt;p&gt;接收端回复(answered)或应答(acknowledged)MAC指令，都是按照收到的顺序进行传输。每一条MAC指令的回复都是按顺序添加到缓冲区数据。所有以单独帧接收的MAC指令都必须以单独帧进行回复，这意味着包含有回复的缓冲区数据必须以单独帧发送。如果MAC回复数据的长度大于最大的FOpt字段长度，设备&lt;span&gt;必须&lt;/span&gt;把这条缓冲区数据的端口设为0，同时放进FRMPayload里进行发送。如果设备同时有应用负载和MAC回复需要发送，且两者不能同时放进一帧里，那么MAC回复&lt;span&gt;应该&lt;/span&gt;优先发送。如果缓冲区数据长度大于最大的FRMPayload可用大小，设备&lt;span&gt;应该&lt;/span&gt;在拼接帧数据时减短缓冲区数据至最大FRMPayload长度。因此，最新的一条MAC指令有可能是被截断不完整的。在任何情况下，列表里所有的MAC指令都是可执行的，即便MAC回复的缓冲区数据被减短过。网络服务器&lt;span&gt;不应该&lt;/span&gt;产生一系列的MAC指令，因为终端设备不能在单条上行中回复这么多条的MAC指令。网络服务器&lt;span&gt;应该&lt;/span&gt;参照以下来计算MAC指令回复的最大FRMPayload可用长度：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果最新的上行的ADR位为0时：&lt;span&gt;必须&lt;/span&gt;考虑最低速数据速率对应的最大负载大小。&lt;/li&gt;
&lt;li&gt;如果最新的上行的ADR位为1时：&lt;span&gt;必须&lt;/span&gt;考虑设备最新上行的数据速率对应的最大负载大小。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：当网络服务器收到被减短的MAC回复时，可以对没有收到回复的MAC指令进行重传。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;table readability=&quot;21.5&quot;&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;CID&lt;/strong&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;Command&lt;/strong&gt;&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Transmitted by&lt;/strong&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;short Description&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;终端&lt;/td&gt;
&lt;td&gt;网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;ResetInd&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;由ABP设备发送，告知网络服务器设备有重启以及协商协议版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;ResetConf&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;ResetInd指令的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x02&lt;/td&gt;
&lt;td&gt;LinkCheckReq&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;终端利用这个命令来判断网络连接情况&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x02&lt;/td&gt;
&lt;td&gt;LinkCheckAns&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;LinkCheckReq的回复。包含接收信号强度，预估终端设备的接收能力(链路余量)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x03&lt;/td&gt;
&lt;td&gt;LinkADRReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;向终端请求改变数据速率，发射功率，重传率以及信道&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x03&lt;/td&gt;
&lt;td&gt;LinkADRAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;LinkADRReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;DutyCycleReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;向终端设置发送的最大占空比&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;DutyCycleAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;DutyCycleReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x05&lt;/td&gt;
&lt;td&gt;RXParamSetupReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;向终端设置接收时隙参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x05&lt;/td&gt;
&lt;td&gt;RXParamSetupAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;RXParamSetupReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;DevStatusReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;向终端查询其状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;DevStatusAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;返回终端设备的状态，即电池余量和链路解调预算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x07&lt;/td&gt;
&lt;td&gt;NewChannelReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;创建或修改 1个射频信道&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x07&lt;/td&gt;
&lt;td&gt;NewChannelAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;NewChannelReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x08&lt;/td&gt;
&lt;td&gt;RXTimingSetupReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;设置接收时隙的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x08&lt;/td&gt;
&lt;td&gt;RXTimingSetupAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;RXTimingSetupReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x09&lt;/td&gt;
&lt;td&gt;TxParamSetupReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;网络服务器用于设置基于当地规定的终端的最大允许驻留时间和最大EIRP&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x09&lt;/td&gt;
&lt;td&gt;TxParamSetupAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;TxParamSetupReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;0x0A&lt;/td&gt;
&lt;td&gt;DlChannelReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;通过从上行链路频率移位下行链路频率（即创建非对称信道）来修改下行链路RX1无线电信道的定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x0A&lt;/td&gt;
&lt;td&gt;DlChannelAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;DlChannelReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0B&lt;/td&gt;
&lt;td&gt;RekeyInd&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;有空中升级设备使用，告知一个安全的上下文升级(重新获取密钥)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0x0B&lt;/td&gt;
&lt;td&gt;RekeyConf&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;RekeyInd的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0C&lt;/td&gt;
&lt;td&gt;ADRParamSetupReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;网络服务器用于设置终端设备的ADR_ACK_LIMIT和ADR_ACK_DELAY参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0C&lt;/td&gt;
&lt;td&gt;ADRParamSetupAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;ADRParamSetupReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0D&lt;/td&gt;
&lt;td&gt;DeviceTimeReq&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;终端设备用于获取当前日期和时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0D&lt;/td&gt;
&lt;td&gt;DeviceTimeAns&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;由网络服务器应答，DeviceTimeReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0E&lt;/td&gt;
&lt;td&gt;ForceRejoinReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;网络服务器请求设备立即重新入网，可周期性重试&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0F&lt;/td&gt;
&lt;td&gt;RejoinParamSetupReq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;网络服务器设备的周期性入网消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x0F&lt;/td&gt;
&lt;td&gt;RejoinParamSetupAns&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;RejoinParamSetupReq的应答&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0x80~0xFF&lt;/td&gt;
&lt;td&gt;私有&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;给私有网络命令拓展做预留。&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表4：MAC指令集&lt;/center&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注意：一般终端设备对收到的MAC指令只作一次回复。如果回复丢失，那么网络服务器需要重新发送一次该指令。当网络服务器在新的上行没有收到想要的MAC的回复时，自行决定是否重传MAC指令。只有&lt;strong&gt;&lt;em&gt;RxParamSetupReq&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;RxTimingSetupReq&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;DLChannelReq&lt;/em&gt;&lt;/strong&gt;三个指令有不同的应答机制，因为它们会影响到下行的参数，相关细节在相应的章节里有描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：当设备终端请求MAC指令时，网络服务器会在请求之后的RX1/RX2窗口尽可能地回复相应地应答/回复指令。如果在相应地窗口没有接收到回复，那么终端设备自行决定是否重传。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：MAC指令地长度尽管没有明确给出，但MAC命令执行端必须隐性获知。因此位置地MAC指令不能被忽略，一旦遇到不明地MAC指令，就会终止MAC指令队列的处理。因此建议把LoRaWAN网络协议规范最先描述的MAC指令放在前面。这样的话，所有当前本本的LoRaWAN规范中实现的MAC指令都可以被更高版本的规范兼容处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;标志着重启了的指令resetind-resetconf&quot;&gt;5.1 标志着重启了的指令(&lt;em&gt;ResetInd&lt;/em&gt;, &lt;em&gt;ResetConf&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;这条MAC指令只对ABP设备和兼容LoRaWAN 1.1版本协议的网络服务器有效。LoRaWAN 1.0服务器不实现这条指令。&lt;/p&gt;
&lt;p&gt;OTA设备&lt;span&gt;不应该&lt;/span&gt;实现这条指令。网络服务器&lt;span&gt;应该&lt;/span&gt;忽略来自OTA设备的&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;p&gt;ABP设备使用&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令来通知网络服务器，设备进行了重启，且重新初始化成缺省的MAC和射频参数(换言之，除了三个帧计数器以外的参数都重新出厂化设置了)。&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令在未收到&lt;strong&gt;&lt;em&gt;ResetConf&lt;/em&gt;&lt;/strong&gt;前都&lt;span&gt;必须&lt;/span&gt;加到所有的上行的FOpt字段。&lt;/p&gt;
&lt;p&gt;这条命令并非告知网络服务器下行帧计数器已经重置。相反，ABP设备的帧计数器(包括上行和下行的帧计数器)&lt;span&gt;应该从不&lt;/span&gt;重启。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：对ABP设备来说这条命令意味着电源中断过(例如更换电池)。设备可能丢失了存贮在RAM里的MAC层的上下文(帧计数器必须存贮在NVM(非易失性内存)里)。在这种情况，设备需要这种方法来传达给网络服务器说上下文丢失。在后续的LoRaWAN协议版本，这条指令可能也在设备和网络服务器间用来协商一些协议的选项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令包含设备支持的LoRaWAN的次版本号。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ResetInd Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Dev LoRaWAN version&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图21：ResetInd 负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Dev LoRaWAN version&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Minor=1&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;次版本号字段表明终端设备支持的LoRaWAN的次版本号。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Minor version&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Minor&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1(LoRaWAN x.1)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;2:15&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;当网络服务器收到&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令时，应该回复&lt;strong&gt;&lt;em&gt;ResetConf&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;p&gt;ResetConf指令包含一个字节的负载，即网络服务器支持的LoRaWAN 版本，这和&quot;Dev LoRaWAN version&quot;格式一致。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ResetConf Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Serv LoRaWAN version&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图22：ResetConf 负载格式&lt;/center&gt;
&lt;p&gt;由&lt;strong&gt;&lt;em&gt;ResetConf&lt;/em&gt;&lt;/strong&gt;携带的服务器的版本必须和设备的版本一致。其他值都是无效的。&lt;/p&gt;
&lt;p&gt;如果服务器的版本是无效的，那么设备&lt;span&gt;应该&lt;/span&gt;丢弃这条&lt;strong&gt;&lt;em&gt;ResetConf&lt;/em&gt;&lt;/strong&gt;指令，并在下一条上行帧时重传&lt;strong&gt;&lt;em&gt;ResetInd&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;h2 id=&quot;链路检查命令linkcheckreq-linkcheckans&quot;&gt;5.2 链路检查命令(LinkCheckReq, LinkCheckAns)&lt;/h2&gt;
&lt;p&gt;终端设备使用&lt;strong&gt;&lt;em&gt;LinkCheckReq&lt;/em&gt;&lt;/strong&gt;指令来确认和网络服务器之间的连接。这条指令没有负载。&lt;/p&gt;
&lt;p&gt;网络服务器通过单个或者多个网络收到&lt;strong&gt;&lt;em&gt;LinkCheckReq&lt;/em&gt;&lt;/strong&gt;指令，然后回复一条&lt;strong&gt;&lt;em&gt;LinkCheckAns&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;LinkCheckAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Margin&lt;/td&gt;
&lt;td&gt;GwCnt&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图23：LinkCheckAns 负载格式&lt;/center&gt;
&lt;p&gt;解调预算(&lt;strong&gt;Margin&lt;/strong&gt;)是一个范围为0-254的8位的无符号整数，表明成功接收到最新的&lt;strong&gt;&lt;em&gt;LinkCheckReq&lt;/em&gt;&lt;/strong&gt;指令的链路预算(单位为 dB)。若值为0则表明帧是在解调的下限(0 dB或者没有预算了)收到数据，若值为20表明网关在比解调下限高出20 dB的信号强度上收到了数据。255为保留值。&lt;/p&gt;
&lt;p&gt;网关数量(&lt;strong&gt;GwCnt&lt;/strong&gt;)是最近一次成功收到&lt;strong&gt;&lt;em&gt;LinkCheckReq&lt;/em&gt;&lt;/strong&gt;指令的网关的数量。&lt;/p&gt;
&lt;h2 id=&quot;链路adr指令linkadrreq-linkadrans&quot;&gt;5.3 链路ADR指令(LinkADRReq, LinkADRAns)&lt;/h2&gt;
&lt;p&gt;网络服务器使用&lt;strong&gt;&lt;em&gt;LinkADRReq&lt;/em&gt;&lt;/strong&gt;指令来要求终端设备进行速率自适应。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;LinkADRReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DataRate_TXPower&lt;/td&gt;
&lt;td&gt;ChMask&lt;/td&gt;
&lt;td&gt;Redundancy&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图23：LinkADRReq 负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DataRate_TXPower&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DataRate&lt;/td&gt;
&lt;td&gt;TXPower&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;请求设置的数据速率(&lt;strong&gt;DataRate&lt;/strong&gt;)和发射功率(&lt;strong&gt;TXPower&lt;/strong&gt;)以不同区域不同特性地被定义在[LoRaWAN区域特性参数文档]。指令中的发射功率被视作设备可用的最大的发射功率。如果指令中指定的发射功率高于终端设备的实际的最大发射功率，终端设备也要回复应答，且需要尽可能提高到最大的发射功率。0xF（十进制15）对数据速率和发射功率意味着设备&lt;span&gt;应该&lt;/span&gt;忽略该字段且保持当前的参数值。信道掩码(&lt;strong&gt;ChMask&lt;/strong&gt;)代表了可用的上行链路信道。最低为是从0开始的。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits#&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Usable channels&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Channel1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Channel2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;Channel16&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表5：信道状态表&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;ChMask&lt;/strong&gt;字段中的某一个位设置为1代表着相应的信道可以进行上行传输，且设备允许该信道使用当前的数据速率。如果是0，代表着相应的信道不可用。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;[6:4]&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Redundancy bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;ChMaskCntl&lt;/td&gt;
&lt;td&gt;NbTrans&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;冗余(Redundancy)位中，&lt;strong&gt;NbTrans&lt;/strong&gt;字段表示每条上行消息的发送次数。这对&quot;确认&quot;和&quot;非确认&quot;帧都有效。缺省值位1,表示每帧只传输一次。有效范围为[1:15]。如果收到&lt;strong&gt;NbTrans&lt;/strong&gt;==0，终端&lt;span&gt;应该&lt;/span&gt;保持当前NbTrans值不变。&lt;/p&gt;
&lt;p&gt;信道掩码控制(&lt;strong&gt;ChMaskCntl&lt;/strong&gt;)字段负责控制之前定义的&lt;strong&gt;ChMask&lt;/strong&gt;的掩码位。它负责控制包含16个信道的块，决定哪个&lt;strong&gt;ChMask&lt;/strong&gt;可以使用。还可以用来全局性的打开或关闭所有的信道来使用特定的调制。这个字段的使用方法以不同区域不同特性地被定义在[LoRaWAN区域特性参数文档]。&lt;/p&gt;
&lt;p&gt;网络服务器在单条下行消息里可以包含多条LinkADRReq指令。终端设备为了配置信道掩码，&lt;span&gt;必须&lt;/span&gt;按照下行消息中的命令块(即多条LinkADRReq指令)，依照顺序处理所有的LinkADRReq消息。网络服务器在一条下行消息中&lt;span&gt;不应该&lt;/span&gt;包含超过一个命令块。终端设备&lt;span&gt;应该&lt;/span&gt;发送单个LinkADRAns应答来全部接受或者全部拒绝拒绝这个命令块。如果下行包含多于一个ADR命令块，终端设备&lt;span&gt;应该&lt;/span&gt;处理第一个块，对于其余地ADR命令块则回复一条NAck(即一条所有状态位都设置为0的LinkADRAns应答)。对于数据速率，发射功率和重传次数，因为它们是全局性的设置，所以设备&lt;span&gt;只需&lt;/span&gt;按照连续ADR命令块中最后一条LinkADRReq指令中的来执行即可。按顺序处理完连续ADR命令块，信道掩码应答位应该是指最后信道方案的接受还是拒绝。&lt;/p&gt;
&lt;p&gt;信道频率以不同区域不同特性地被定义在[LoRaWAN区域特性参数文档]。终端设备用&lt;strong&gt;LinkADRAns&lt;/strong&gt;指令来回复&lt;strong&gt;LinkADRReq&lt;/strong&gt;指令。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;LinkADRAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图25：LinkADRAns负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[7:3]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status Bit&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Power ACK&lt;/td&gt;
&lt;td&gt;Data rate ACK&lt;/td&gt;
&lt;td&gt;Channel mask ACK&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;LinkADRAns 状态&lt;/strong&gt;位为以下含义：&lt;/p&gt;
&lt;center&gt;
&lt;table readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;&lt;strong&gt;Bit = 0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Bit = 1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;Channel mask ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;发送的 channel mask 使能了未定义的信道或者禁用所有信道。命令被丢弃，终端设备状态不变。&lt;/td&gt;
&lt;td&gt;发送的 channel mask 成功解析，已按照 mask 设置了当前的信道状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;Data rate ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;所请求的数据速率，终端无法识别，或者无法应用在当前信道中（不被任何使能的信道所支持)。命令被丢弃，终端设备状态不变。&lt;/td&gt;
&lt;td&gt;数据速率成功设置，或者要求设置的数据速率为15，这表明忽略掉。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;Power ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;所请求的发射功率不能或者不得低于在终端上执行。命令被丢弃，终端状态不变。&lt;/td&gt;
&lt;td&gt;功率等级成功设置，或者要求设置的发射功率为15，这表明应该忽略掉。&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表6：LinkADRAns 状态位的含义&lt;/center&gt;
&lt;p&gt;如果三个位中任意一个为0，表明这个指令设置不成功，节点将保持之前状态。&lt;/p&gt;
&lt;h2 id=&quot;终端设备发射占空比dutycyclereqdutycycleans&quot;&gt;5.4 终端设备发射占空比(&lt;em&gt;DutyCycleReq&lt;/em&gt;,&lt;em&gt;DutyCycleAns&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;DutyCycleReq&lt;/em&gt;&lt;/strong&gt;指令被网络协调者用来限制终端设备的总发射占空比的最大值。总发射占空比指所有子频带的发射占空比。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DutyCycleReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DutyCyclePL&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图26：DutyCycleReq负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DutyCyclePL&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;MaxDCycle&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;终端设备允许的最大发射占空比为：&lt;/p&gt;
&lt;center&gt;总发射占空比=1/2&lt;sup&gt;MaxDCycle&lt;/sup&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;MaxDutyCycle&lt;/strong&gt;的有效范围值是[0：15].值0代表着“没有占空比限制”，有限制地区的除外。&lt;/p&gt;
&lt;p&gt;终端设备用&lt;strong&gt;DutyCycleAns&lt;/strong&gt;指令来回复&lt;strong&gt;DutyCycleReq&lt;/strong&gt;。&lt;strong&gt;DutyCycleAns&lt;/strong&gt;的MAC应答不包含任何的负载。&lt;/p&gt;
&lt;h2 id=&quot;接收窗口参数rxparamsetupreq-rxparamsetupans&quot;&gt;5.5 接收窗口参数(&lt;strong&gt;&lt;em&gt;RXParamSetupReq, RXParamSetupAns&lt;/em&gt;&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;RXParamSetupReq&lt;/em&gt;&lt;/strong&gt;指令可以对每个上行消息之后的第二接收窗口(RX2)的频率和数据速率进行改变。该指令同时允许修改下行RX1的数据速率，使下行RX1的数据速率相对上行进行偏移。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RXParamSetupReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DLsettings&lt;/td&gt;
&lt;td&gt;Frequency&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图27：RXParamSetupReq负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DLsettings&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;RX1DRoffset&lt;/td&gt;
&lt;td&gt;RX2DataRate&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;RX1DRoffset字段用来设置终端设备上行和下行第一个接收窗口(RX1)数据速率之间的偏移。偏移的缺省值为0。偏移量用来考量一些地区的基站最大功率密度限制和平衡上下行的射频链路预算。&lt;/p&gt;
&lt;p&gt;数据速率(RX2&lt;strong&gt;DataRate&lt;/strong&gt;)字段定义了第二接收窗口使用的下行数据速率，用法和&lt;strong&gt;&lt;em&gt;LinkADRReq&lt;/em&gt;&lt;/strong&gt;指令一致(例如，0表示DR0/125kHz)。频率(&lt;strong&gt;Frequency&lt;/strong&gt;)字段表示第二接收窗口使用信道的频率，因此频率编码规则的定义详见&lt;strong&gt;&lt;em&gt;NewChannelReq&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;p&gt;终端设备使用&lt;strong&gt;&lt;em&gt;RXParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令来应答&lt;strong&gt;&lt;em&gt;RXParamSetupReq&lt;/em&gt;&lt;/strong&gt;。终端设备在收到A类下行之前，&lt;strong&gt;&lt;em&gt;RXParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令&lt;span&gt;必须&lt;/span&gt;添加在所有的上行数据帧的FOpt字段中。这样可以保证即使上行链路存在丢包，网络服务器也总能知道设备使用的下行链路参数。&lt;/p&gt;
&lt;p&gt;负载包含单字节的状态信息。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RXParamSetupAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图28：RXParamSetupAns负载格式&lt;/center&gt;
&lt;p&gt;状态(&lt;strong&gt;Status&lt;/strong&gt;)位有以下含义:&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[7:3]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;RX1DRoffset ACK&lt;/td&gt;
&lt;td&gt;RX2DataRate ACK&lt;/td&gt;
&lt;td&gt;Channel ACK&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;LinkADRAns&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;状态&lt;/strong&gt;位有以下含义：&lt;/p&gt;
&lt;center&gt;
&lt;table readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;&lt;strong&gt;Bit = 0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Bit = 1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Channel ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;终端请求的频率不可用&lt;/td&gt;
&lt;td&gt;RX2信道设置成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;RX2DataRate ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;终端请求的数据速率未知&lt;/td&gt;
&lt;td&gt;RX2数据速率设置成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;RX1DRoffset ACK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RX1上行/下行数据速率的偏移不在允许的范围之内&lt;/td&gt;
&lt;td&gt;RX1DRoffset设置成功&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表7：RXParamSetupAns 状态位的含义&lt;/center&gt;
&lt;p&gt;如果三个位中任意一个为0，表明这个指令设置不成功，&lt;span&gt;必须&lt;/span&gt;保持之前状态。&lt;/p&gt;
&lt;h2 id=&quot;终端设备状态devstatusreq-devstatusans&quot;&gt;5.6 终端设备状态(DevStatusReq, DevStatusAns)&lt;/h2&gt;
&lt;p&gt;网络服务器使用&lt;strong&gt;&lt;em&gt;DevStatusReq&lt;/em&gt;&lt;/strong&gt;指令来查询终端设备的状态信息。这个指令没有负载。如果终端设备收到&lt;strong&gt;&lt;em&gt;DevStatusReq&lt;/em&gt;&lt;/strong&gt;，它&lt;span&gt;必须&lt;/span&gt;回复&lt;strong&gt;&lt;em&gt;DevStatusAns&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DevStatusAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Battery&lt;/td&gt;
&lt;td&gt;Margin&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图29：DevStatusAns负载格式&lt;/center&gt;
&lt;p&gt;报告电池电量(&lt;strong&gt;Battery&lt;/strong&gt;)的编码如下：&lt;/p&gt;
&lt;center&gt;
&lt;table readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Battery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;终端连接到外部电源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1..254&lt;/td&gt;
&lt;td&gt;数值表示电池电量，1表示最低，254表示最高&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;终端无法测量电池电量&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表8：电池电量编码&lt;/center&gt;
&lt;p&gt;余量(&lt;strong&gt;Margin&lt;/strong&gt;)是最近一次成功接收&lt;strong&gt;&lt;em&gt;DevStatusReq&lt;/em&gt;&lt;/strong&gt;指令的解调信噪比，其值为四舍五入取整，单位为Db。它是6位的有符号整数，最大值为31， 最小值为-32&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:6&lt;/td&gt;
&lt;td&gt;5:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Margin&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;h2 id=&quot;信道的创建或修改newchannelreq-newchannelans-dichannelreq-dichannelans&quot;&gt;5.7 信道的创建或修改(NewChannelReq, NewChannelAns, DIChannelReq, DIChannelAns)&lt;/h2&gt;
&lt;p&gt;设备工作在固定的信道方案区域时，这些MAC指令不应该起作用。设备&lt;span&gt;不应该&lt;/span&gt;回复这些指令。&lt;/p&gt;
&lt;p&gt;请参照[LoRaWAN区域特性参数文档]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NewChannelReq&lt;/em&gt;&lt;/strong&gt;指令可以用来修改现有的双向信道或者创建一个新的信道。这条指令设置新的信道的中心频率以及该信道的上行数据速率的范围。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;NewChannelReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ChIndex&lt;/td&gt;
&lt;td&gt;Freq&lt;/td&gt;
&lt;td&gt;DrRange&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图30：NewChannelReq负载格式&lt;/center&gt;
&lt;p&gt;信道索引(&lt;strong&gt;ChIndex&lt;/strong&gt;)是将要创建或修改的信道索引。根据所使用的区域和频带，在[LoRaWAN区域特性参数文档]里LoRaWAN网络协议规范规定了缺省信道，这些信道所有的设备都通用且不能通过&lt;strong&gt;&lt;em&gt;NewChannelReq&lt;/em&gt;&lt;/strong&gt;指令修改。如果缺省信道的数量为&lt;em&gt;N&lt;/em&gt;，那缺省信道就是从0到N-1，且&lt;strong&gt;ChIndex&lt;/strong&gt;的可接收范围为N到15。设备必须具备处理至少16个个不同的信道的能力。在某些地区，设备可以存贮超过16个信道。&lt;/p&gt;
&lt;p&gt;频率字段是一个24位无符号整数。实际信道频率为(100 x &lt;strong&gt;Freq&lt;/strong&gt;),单位为Hz，其中低于100 MHz的频率数值将会保留供将来使用。这允许以100 Hz为步长，设置100 MHz到1.67 GHz之间的信道频率。&lt;strong&gt;Freq&lt;/strong&gt;的值为0代表关闭这个信道。终端设备&lt;span&gt;必须&lt;/span&gt;检查实际能使用的频率硬件射频能否支持，否则返回错误。&lt;/p&gt;
&lt;p&gt;数据速率范围(&lt;strong&gt;DrRange&lt;/strong&gt;)字段表示这个信道允许的上行数据速率的范围。该字段被分成两个4位：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DrRange&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;MaxDR&lt;/td&gt;
&lt;td&gt;MinDR&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;按照章节5.2所定义的规则，最小数据速率(&lt;strong&gt;MinDR&lt;/strong&gt;)字段规定了该信道最低上行数据速。例如以欧洲地区参数而言，0表示DR0 / 125 KHz，同样的，最大数据速率(&lt;strong&gt;MaxDR&lt;/strong&gt;)字段规定了该信道最大上行数据速。例如,DrRange = 0x77 表示该信道只允许使用 50 kbps的GFSK。DrRange = 0x50 表示支持DR0 / 125 kHz 到 DR5 /125kHz。&lt;/p&gt;
&lt;p&gt;新增加或修改的信道一旦使能，可以立即用来通讯。RX1下行频率和上行频率相同。&lt;/p&gt;
&lt;p&gt;终端设备通过回复&lt;strong&gt;&lt;em&gt;NewChannelAns&lt;/em&gt;&lt;/strong&gt;指令来应答&lt;strong&gt;&lt;em&gt;NewChannelReq&lt;/em&gt;&lt;/strong&gt;。这条消息的负载包含以下信息:&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;NewChannelAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图31：NewChannelAns负载格式&lt;/center&gt;
&lt;p&gt;状态(&lt;strong&gt;Status&lt;/strong&gt;)位有以下含义:&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[7:2]&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Data rate range ok&lt;/td&gt;
&lt;td&gt;Channel frequency ok&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;center&gt;
&lt;table readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;Bit = 0&lt;/td&gt;
&lt;td&gt;Bit = 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;Data rate range ok&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;指定的数据速率范围超出了终端当前范围&lt;/td&gt;
&lt;td&gt;该数据速率与终端能够兼容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;Channel frequency ok&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;终端无法使用该频率&lt;/td&gt;
&lt;td&gt;终端能够使用该频率&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表9：NewChannelAns 状态位的含义&lt;/center&gt;
&lt;p&gt;如果两个位中任意一个为0，表明这个指令设置不成功，新的信道没有被创建成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;DIChannelReq&lt;/em&gt;&lt;/strong&gt;指令允许网络服务器在RX1时使用不同的下行频率。这个指令适用于所有支持&lt;strong&gt;&lt;em&gt;NewChannelReq&lt;/em&gt;&lt;/strong&gt;指令的区域(例如欧盟或者中国，但不适用于美国或澳大利亚)。&lt;/p&gt;
&lt;p&gt;这个指令设置下行RX1的中心频率，如下：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DIChannelReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ChIndex&lt;/td&gt;
&lt;td&gt;Freq&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图32：DLChannelReq负载格式&lt;/center&gt;
&lt;p&gt;信道索引(&lt;strong&gt;ChIndex&lt;/strong&gt;)是被修改的下行频率的信道索引。&lt;/p&gt;
&lt;p&gt;频率(&lt;strong&gt;Freq&lt;/strong&gt;)字段是一个24位无符号整数。实际信道频率为(100 x &lt;strong&gt;Freq&lt;/strong&gt;),单位为Hz，其中低于100 MHz的频率数值将会保留供将来使用。终端设备&lt;span&gt;必须&lt;/span&gt;检查实际能使用的频率硬件射频能否支持，否则返回错误。&lt;/p&gt;
&lt;p&gt;终端设备通过回复&lt;strong&gt;&lt;em&gt;DIChannelAns&lt;/em&gt;&lt;/strong&gt;指令来应答&lt;strong&gt;&lt;em&gt;DIChannelReq&lt;/em&gt;&lt;/strong&gt;。终端设备在收到A类下行之前，&lt;strong&gt;&lt;em&gt;DIChannelAns&lt;/em&gt;&lt;/strong&gt;指令&lt;span&gt;必须&lt;/span&gt;添加在所有的上行数据帧的FOpt字段中。这样可以保证即使上行链路存在丢包，网络服务器也总能知道设备使用的下行频率。&lt;/p&gt;
&lt;p&gt;这条消息的负载包含以下信息：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DIChannelAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图33：DLChannelAns负载格式&lt;/center&gt;
&lt;p&gt;状态(&lt;strong&gt;Status&lt;/strong&gt;)位有以下含义:&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[7:2]&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Uplink frequency exists&lt;/td&gt;
&lt;td&gt;Channel frequency ok&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;center&gt;
&lt;table readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;Bit = 0&lt;/td&gt;
&lt;td&gt;Bit = 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;Channel frequency ok&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;设备无法使用该频率&lt;/td&gt;
&lt;td&gt;设备可以使用该频率&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;Uplink frequency exists&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这个信道的上行频率没有定义，下行频率只能设置已经存在的上行频率的信道&lt;/td&gt;
&lt;td&gt;这个信道的上行频率是有效的&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表10：DIChannelAns 状态位的含义&lt;/center&gt;
&lt;h2 id=&quot;tx和rx之间的延时设置rxtimingsetupreq-rxtimingsetupans&quot;&gt;5.8 TX和RX之间的延时设置(&lt;strong&gt;&lt;em&gt;RXTimingSetupReq, RXTimingSetupAns&lt;/em&gt;&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;RXTimingSetupReq&lt;/em&gt;&lt;/strong&gt;指令允许配置上行传输结束与第一个接收窗口开启之间的时间间隔。第二接收窗口比第一个接收窗口晚一秒开启。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RXTimingSetupReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Settings&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图34：RXTimingSetupReq 负载格式&lt;/center&gt;
&lt;p&gt;延迟(&lt;strong&gt;Delay&lt;/strong&gt;)字段指定时间间隔。这字段分成两个4字节：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Settings&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Del&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;延迟的单位为秒。&lt;strong&gt;Del&lt;/strong&gt; = 0 对应于 1秒&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Del&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Delay[s]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表11：RXTimingSetup 延迟映射表&lt;/center&gt;
&lt;p&gt;终端设备使用不带负载的&lt;strong&gt;&lt;em&gt;RXTimingSetupAns&lt;/em&gt;&lt;/strong&gt;指令来回复&lt;strong&gt;&lt;em&gt;RXTimingSetupReq&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;终端设备在收到A类下行之前，&lt;strong&gt;&lt;em&gt;RXTimingSetupAns&lt;/em&gt;&lt;/strong&gt;指令&lt;span&gt;必须&lt;/span&gt;添加在所有的上行数据帧的FOpt字段中。这样可以保证即使上行链路存在丢包，网络服务器也总能知道设备使用的下行参数。&lt;/p&gt;
&lt;h2 id=&quot;终端设备重传参数txparamsetupreqtxparamsetupans&quot;&gt;5.9 终端设备重传参数(&lt;strong&gt;&lt;em&gt;TxParamSetupReq,TxParamSetupAns&lt;/em&gt;&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;这个MAC指令只在管控的特定区域执行。请参考[LoRaWAN区域特性参数文档]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TxParamSetupReq&lt;/em&gt;&lt;/strong&gt;指令可以用来通知终端设备的最大驻留时间。换言之，一包数据在空中的最大持续传输时间，以及终端设备所允许的最大等效全向辐射功率(EIRP)。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;TxParamSetupReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;EIRP_DwellTime&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图35：TXParamSetupReq 负载格式&lt;/center&gt;
&lt;p&gt;EIRP_DwellTime字段的结构如下：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;MaxDwellTime&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;DownlinkDwellTime&lt;/td&gt;
&lt;td&gt;UplinkDwellTime&lt;/td&gt;
&lt;td&gt;MaxEIPR&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TxParamSetupReq&lt;/em&gt;&lt;/strong&gt;指令的0..3位用来对最大EIRP值的编码，如下表。表中EIRP值包含不同区域管控的最大EIRP限制的最大范围。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Coded Value&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Max EIRP(dBm)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
表12：TxParamSetup EIRP 编码表&lt;/center&gt;
&lt;p&gt;最大EIRP指的是设备无线电发射的功率上限。设备不要求使用该功率进行传输。，但不应该超过该EIRP。&lt;/p&gt;
&lt;p&gt;第4、第5位分别定义了最大上行和下行的驻留时间。编码如下：&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Coded Value&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Dwell Time&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;No Limit&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;400 ms&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;当这个MAC指令生效时（因区域而定），设备回复&lt;strong&gt;&lt;em&gt;TxParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令来应答TxParamSetupReq。这个&lt;strong&gt;&lt;em&gt;TxParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令不能包含任何的负载。&lt;/p&gt;
&lt;p&gt;当在一个对此没有要求的区域使用该指令，设备不处理且不会回复。&lt;/p&gt;
&lt;h2 id=&quot;重新获取密钥指令rekeyind-rekeyconf&quot;&gt;5.10 重新获取密钥指令(&lt;strong&gt;&lt;em&gt;RekeyInd, RekeyConf&lt;/em&gt;&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;这条MAC指令只对OTA设备和兼容LoRaWAN 1.1版本协议的网络服务器有效。LoRaWAN 1.0服务器不实现这条指令。&lt;/p&gt;
&lt;p&gt;ABP设备&lt;span&gt;不应该&lt;/span&gt;实现这条指令。网络服务器&lt;span&gt;应该&lt;/span&gt;忽略来自ABP设备的&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;p&gt;对于OTA设备来说，&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令用来确定安全密钥的升级和在后续的LoRaWAN版本(大于1.1)用来确定运行在终端设备和网络服务器之间的LoRaWAN的次版本号。这个命令并不意味着MAC和射频参数的重置(参照6.2.3章节)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令包含终端设备所支持的LoRaWAN的次版本号。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RekeyInd Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Dev LoRaWAN version&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图36：RekeyInd 负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Dev LoRaWAN version&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Minor = 1&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;最小字段代表设备支持的LoRaWAN的次版本号。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Minor version&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Minor&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1(LoRaWAN x.1)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;2..15&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;OTA设备&lt;span&gt;应该&lt;/span&gt;在成功处理完入网请求之后(新的会话密钥生成之后),一直在所有的确认和非确认上行帧里包含&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令，直到收到&lt;strong&gt;&lt;em&gt;RekeyConf&lt;/em&gt;&lt;/strong&gt;。如果设备在&lt;span&gt;ADR_ACK_LIMIT&lt;/span&gt;上行到来之前没有收到&lt;strong&gt;&lt;em&gt;RekeyConf&lt;/em&gt;&lt;/strong&gt;，那么它应该变回请求入网状态。在之后任何时候设备发送的&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令网络服务器都&lt;span&gt;应该&lt;/span&gt;丢弃掉。在收到入网请求之后的新安全的密钥以及带有&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令的第一条上行帧之前，网络服务器&lt;span&gt;应该&lt;/span&gt;丢弃所有的上行帧。&lt;/p&gt;
&lt;p&gt;当网络服务器收到&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令时，回复一条&lt;strong&gt;&lt;em&gt;RekeyConf&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;p&gt;ResetConf指令包含一个字节的负载，即网络服务器支持的LoRaWAN 版本，这和&quot;Dev LoRaWAN version&quot;格式一致。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RekeyConf Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Serv LoRaWAN version&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图37：RekeyConf 负载格式&lt;/center&gt;
&lt;p&gt;服务器版本必须大于0（不允许为0）。小于或等于设备的LoRaWAN版本。因此对于一个LoRaWAN1.1版本的终端设备来说，有效值只能为1。如果服务器的版本无效，终端设备&lt;span&gt;应该&lt;/span&gt;丢弃这条&lt;strong&gt;&lt;em&gt;RekeyConf&lt;/em&gt;&lt;/strong&gt;指令，并在下一个上行帧时重传&lt;strong&gt;&lt;em&gt;RekeyInd&lt;/em&gt;&lt;/strong&gt;指令。&lt;/p&gt;
&lt;h2 id=&quot;自适应参数adrparamsetupreq-adrparamsetupans&quot;&gt;5.11 自适应参数(ADRParamSetupReq, ADRParamSetupAns)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ADRParamSetupReq&lt;/em&gt;&lt;/strong&gt;指令允许改变&lt;span&gt;ADR_ACK_LIMIT和ADR_ACK_DELAY&lt;/span&gt;这两个在ADR回退机制中使用的参数。ADRParamSetupReq指令由一个单字节负载。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ADRParamSetupReq Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ADRparam&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图38：ADRParamSetupReq 负载格式&lt;/center&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ADRparam&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Limit_exp&lt;/td&gt;
&lt;td&gt;Delay_exp&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;Limit_exp字段设置&lt;span&gt;ADR_ACK_LIMIT&lt;/span&gt;参数的值：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;ADR_ACK_LIMIT&lt;/span&gt; = 2^Limit_exp&lt;/center&gt;
&lt;p&gt;Limit_exp有效范围为0到15， 对应的&lt;span&gt;ADR_ACK_LIMIT&lt;/span&gt;是1到32768。&lt;/p&gt;
&lt;p&gt;Delay_exp字段设备&lt;span&gt;ADR_ACK_DELAY&lt;/span&gt;参数的值：&lt;/p&gt;
&lt;center&gt;&lt;span&gt;ADR_ACK_DELAY&lt;/span&gt; = 2^Limit_exp&lt;/center&gt;
&lt;p&gt;Limit_exp有效范围为0到15， 对应的&lt;span&gt;ADR_ACK_DELAY&lt;/span&gt;是1到32768。&lt;/p&gt;
&lt;p&gt;终端设备使用&lt;strong&gt;&lt;em&gt;ADRParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令来应答&lt;strong&gt;&lt;em&gt;ADRParamSetupReq&lt;/em&gt;&lt;/strong&gt;。&lt;strong&gt;&lt;em&gt;ADRParamSetupAns&lt;/em&gt;&lt;/strong&gt;指令不包含负载字段。&lt;/p&gt;
&lt;h2 id=&quot;设备时间指令devicetimereq-devicetimeans&quot;&gt;5.12 设备时间指令(DeviceTimeReq, DeviceTimeAns)&lt;/h2&gt;
&lt;p&gt;这条MAC指令只对兼容LoRaWAN 1.1版本协议的网络服务器有效。LoRaWAN 1.0服务器不实现这条指令。&lt;/p&gt;
&lt;p&gt;终端设备使用&lt;strong&gt;&lt;em&gt;DeviceTimeReq&lt;/em&gt;&lt;/strong&gt;指令来请求服务器的当前网络日期和时间。该请求没有负载。&lt;/p&gt;
&lt;p&gt;网络服务器使用&lt;strong&gt;&lt;em&gt;DeviceTimeAns&lt;/em&gt;&lt;/strong&gt;来给终端设备提供网络日期和时间。这个时间是上行传输结束时的网络时间。这个命令包含5个字节的负载，如下：&lt;/p&gt;
&lt;center&gt;
&lt;table readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size(bytes)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;DeviceTimeAns Payload&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;32位无符号整数：1980年1月6日凌晨0点(&lt;sup&gt;*&lt;/sup&gt;)至至今走过的秒&lt;/td&gt;
&lt;td&gt;8位无符号整数：分秒，以1/2^8步长&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图39：DeviceTimeAns 负载格式&lt;/center&gt;
&lt;p&gt;网络服务器提供的时间最差的时间精度&lt;span&gt;必须&lt;/span&gt;在正负 100 毫秒。&lt;/p&gt;
&lt;p&gt;(&lt;sup&gt;*&lt;/sup&gt;)GPS 纪元(换言之，指1980年1月6日凌晨0点)作为起点。“秒”字段是以纪元为起点，经过的秒的数量。这个字段每秒单纯的加1。把这个字段转成UTC时间，闰秒必须考虑在内。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;例如：2016年2月12日的14点24分31秒对于的GPS纪元时间是1139322288秒。2017年6月，GPS时间比UTC时间多出17秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;重新入网指令forcerejoinreq&quot;&gt;5.13 重新入网指令(&lt;strong&gt;&lt;em&gt;ForceRejoinReq&lt;/em&gt;&lt;/strong&gt;)&lt;/h2&gt;
&lt;p&gt;网络服务器通过重新入网指令要求设备立即发送重新入网请求(Rejoin-Request)类型0或类型2消息，并带有可编程的重传字段，发送周期和数据速率。服务器可以使用这个RejoinReq上行帧来重新生成设备的密钥或初始化漫游切换过程。&lt;/p&gt;
&lt;p&gt;这个命令有2个字节的负载。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;15:14&lt;/td&gt;
&lt;td&gt;13:11&lt;/td&gt;
&lt;td&gt;10:8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;ForceRejoinReq bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;Period&lt;/td&gt;
&lt;td&gt;Max_Retries&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;RejoinType&lt;/td&gt;
&lt;td&gt;DR&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图40：ForceRejoinReq 负载格式&lt;/center&gt;
&lt;p&gt;这些参数的编码如下规则：&lt;/p&gt;
&lt;p&gt;Period： 重传之间的时隙&lt;span&gt;应该&lt;/span&gt;等于32秒 x 2&lt;sup&gt;period&lt;/sup&gt; + Rand32， Rand32是在[0：32]之间的一个随机数。&lt;/p&gt;
&lt;p&gt;Max_Retries：设备重新发送重新入网请求(Rejoin-request) 的总的次数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0: 重新入网请求只发送一次(不重发)&lt;/li&gt;
&lt;li&gt;1: 重新入网请求&lt;span&gt;应该&lt;/span&gt;发送2次(1 + 1次重试)&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;7:重新入网请求&lt;span&gt;应该&lt;/span&gt;发送8次(1 + 7次重试)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RejoinType： 这个字段表示设备应该发送的重新入网请求的类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0或1： 一个类型为0的重新入网请求将被发送&lt;/li&gt;
&lt;li&gt;2： 一个类型为2的重新入网请求将被发送&lt;/li&gt;
&lt;li&gt;3到7： RFU&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DR:重新入网请求帧&lt;span&gt;应该&lt;/span&gt;使用该数据速率DR传输。在实际物理调制的数据速率和DR值的对于关系，和&lt;strong&gt;&lt;em&gt;LinkADRReq&lt;/em&gt;&lt;/strong&gt;指令中的一致，且以不同区域不同特性地被定义在[LoRaWAN区域特性参数文档]。&lt;/p&gt;
&lt;p&gt;这条指令没有回复，当终端收到这条命令时&lt;span&gt;必须&lt;/span&gt;发送重新新入网请求。在收到这条指令时，&lt;span&gt;应该&lt;/span&gt;立马进行第一次RejoinReq消息的传输(但有可能网络服务器没有收到RejoinReq)。如果设备在未达到最大重传次数时收到一条新的&lt;strong&gt;&lt;em&gt;ForceRejoinReq&lt;/em&gt;&lt;/strong&gt;指令，设备&lt;span&gt;应该&lt;/span&gt;继续传输新参数的RejoinReq。&lt;/p&gt;
&lt;h2 id=&quot;rejoinparamsetreqrejoinparamsetupans&quot;&gt;5.14 RejoinParamSetReq(RejoinParamSetupAns)&lt;/h2&gt;
&lt;p&gt;网络服务器使用RejoinParamSetupReq指令来请求设备定期发送一条RejoinReq类型为0的消息，这条消息包含可编程的周期，即上行的时间和数量。&lt;/p&gt;
&lt;p&gt;时间和数量从可能没有时间测量功能的设备中复制。这个周期规定了两条RejoinReq传输之间的最大时间或上行的数量。设备&lt;span&gt;可能&lt;/span&gt;发送RejoinReq很频繁。&lt;/p&gt;
&lt;p&gt;这个指令有单字节的负载。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7:4&lt;/td&gt;
&lt;td&gt;3:0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;RejoinParamSetupReq bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;MaxTimeN&lt;/td&gt;
&lt;td&gt;MaxCountN&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图41：RejoinParamSetupReq 负载格式&lt;/center&gt;
&lt;p&gt;这些参数定义如下：&lt;/p&gt;
&lt;p&gt;MaxCountN = C = 0到15。至少在每2&lt;sup&gt;C+4&lt;/sup&gt;条上行消息，设备&lt;span&gt;必须&lt;/span&gt;发送一条类型为0的重新入网请求。&lt;/p&gt;
&lt;p&gt;MaxTimeN = T = 0到15。至少在每2&lt;sup&gt;T+10&lt;/sup&gt;秒，设备&lt;span&gt;必须&lt;/span&gt;发送一条类型为0的重新入网请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;T = 0 表示大概时17分钟&lt;/li&gt;
&lt;li&gt;T = 15 大概是1年&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上两种情况种的一种满足(帧上行数量或者时间)，RejoinReq帧都会被发送。&lt;/p&gt;
&lt;p&gt;设备&lt;span&gt;必须&lt;/span&gt;实现上行数量的周期功能(MaxCountN)。基于时间的周期功能是可选的。设备不能实现时间限制&lt;span&gt;必须&lt;/span&gt;在回复中说明。&lt;/p&gt;
&lt;p&gt;回复有单字节的负载。&lt;/p&gt;
&lt;center&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Bits 7:1&lt;/td&gt;
&lt;td&gt;Bit 0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Status bits&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;RFU&lt;/td&gt;
&lt;td&gt;TimeOK&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
图42：RejoinParamSetupAns 负载格式&lt;/center&gt;
&lt;p&gt;如果第0位等于1，设备接受最大时间和上行数量的的限制。如果等于0，那么只接受上行数量的限制。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：对于有非常低消息频率和没有时间测量能力的设备，可选的上行的数量这个机制不在LoRaWAN范围内。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Mar 2019 15:52:00 +0000</pubDate>
<dc:creator>在路上的Ye子</dc:creator>
<og:description>LoRaWAN 1.1 网络协议规范 LoRaWAN 1.1 版本封稿很久了也没有完整啃过一遍，最近边啃边翻译，趁着这个机会把它码下来。 如果觉得哪里有问题，欢迎留言斧正。 翻译不易，转载请申明出处和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eydonmlau/p/10534469.html</dc:identifier>
</item>
<item>
<title>补习系列(18)-springboot H2 迷你数据库 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10534319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10534319.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190314231312640-813017380.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-h2&quot;&gt;关于 H2&lt;/h2&gt;
&lt;p&gt;H2 数据库是一个纯 Java 实现的开源的嵌入式数据库，笔者第一次使用时还是在多年前的一个客户端项目中。&lt;br/&gt;当时就觉得这个数据库很方便，如果你希望你的应用程序能&quot;自带数据库，随处运行”，那么H2是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190314231243522-2040928650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;H2 的由来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;H2 的前身是 HyperSQL(HSQL)，后者也是一个类似的嵌入式数据库，H2的作者 Thomas Mueller 一开始就是 HSQL的贡献者。&lt;br/&gt;到后来因为一些未知的原因分成了两个项目分支，H2 大概就是第二代的意思..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有什么特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于是Java写的，自带跨平台能力&lt;/li&gt;
&lt;li&gt;小，非常的小，完整的 Jar 包只有1-2M&lt;/li&gt;
&lt;li&gt;支持多种模式，包括内存形态、文件形态(持久化)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，使用H2 的场景大概会是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算资源受限，如嵌入式计算环境中，由于CPU、内存、Disk等限制，要求采用小巧的数据库存储方案；&lt;/li&gt;
&lt;li&gt;项目预研，在项目立项之前可能无法立即采购昂贵的数据库软件，此时往往可以退而选择临时解决方案，利用JDBC协议的通用性在后期完成切换；&lt;/li&gt;
&lt;li&gt;自动化测试，在自动化环境中可能需要大量模拟接口，包括数据存储接口，此时内存数据库是不二之选。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，介绍两种使用方式&lt;/p&gt;
&lt;h2 id=&quot;一h2-用作本地数据库&quot;&gt;一、H2 用作本地数据库&lt;/h2&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;1. 引入依赖：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.196&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;2. 配置文件&lt;/h3&gt;
&lt;p&gt;编辑 &lt;strong&gt;application.properties&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## Spring DATASOURCE (DataSourceAutoConfiguration &amp;amp; DataSourceProperties)
spring.datasource.url=jdbc:h2:file:D:/temp/h2
spring.datasource.username=
spring.datasource.password=

# The SQL dialect makes Hibernate generate better SQL for the chosen database
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect

# Hibernate ddl auto (create, create-drop, validate, update)
spring.jpa.hibernate.ddl-auto = update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;strong&gt;&lt;em&gt;jdbc:h2:file:D:/temp/h2&lt;/em&gt;&lt;/strong&gt; 将指示H2 启用本地文件模式，数据库文件将写入 &lt;strong&gt;&lt;em&gt;D:/temp/h2&lt;/em&gt;&lt;/strong&gt; 这个目录。&lt;/p&gt;
&lt;h3 id=&quot;样例数据&quot;&gt;3. 样例数据&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;LogRecord.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Entity
@Table(name=&quot;log_record&quot;)
    public class LogRecord {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO )
    private Long id;

    private String level;

    private String message;

    private Date createTime;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LogRepository.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Repository
public interface LogRecordRepository extends JpaRepository&amp;lt;LogRecord, Long&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LogRecordInitializer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class LogRecordInitializer {

    @Autowired
    private LogRecordRepository logRecordRepository;
    private static final Logger logger = LoggerFactory.getLogger(LogRecordInitializer.class);

    @PostConstruct
    void initData(){

        if(logRecordRepository.count() &amp;gt; 0){

            List&amp;lt;LogRecord&amp;gt; logRecords = logRecordRepository.findAll();

            logger.info(&quot;read records: {}&quot;, JsonUtil.toPrettyJson(logRecords));
            return;
        }
        for(int i=0; i&amp;lt;100; i++){

            LogRecord record = new LogRecord();
            record.setLevel(&quot;info&quot;);

            record.setMessage(&quot;Heartbeat message &quot; + UUID.randomUUID().toString());
            record.setCreateTime(new Date());

            logRecordRepository.save(record);

            logger.info(&quot;save record - &quot; + record.getMessage());
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现的逻辑大致是，第一次启动时写入100条数据，后面每次启动将数据读取出来并打印到日志。&lt;/p&gt;
&lt;p&gt;执行SpringBoot 启动程序，发现目录中生成了&lt;strong&gt;h2.mv.db&lt;/strong&gt;文件，说明写入成功！&lt;/p&gt;
&lt;h2 id=&quot;二h2-用于单元测试&quot;&gt;二、H2 用于单元测试&lt;/h2&gt;
&lt;p&gt;H2 数据库的典型应用是 在Web项目中做单元测试。&lt;/p&gt;
&lt;p&gt;一般，测试的流程为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据初始化&lt;/li&gt;
&lt;li&gt;执行测试&lt;/li&gt;
&lt;li&gt;销毁数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在真实的测试代码开发中，有几类问题会造成困扰：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库环境的搭建比较费时费力；&lt;/li&gt;
&lt;li&gt;数据库的数据难以保持&quot;干净&quot;，一些垃圾数据容易影响测试的成功率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;H2作为内存数据库使用则能解决这些问题&lt;/strong&gt;，本身作为内置数据库并不需要额外的看护成本，&lt;br/&gt;而且在程序退出时，所有数据都能保证完全清除。&lt;/p&gt;
&lt;h3 id=&quot;依赖包&quot;&gt;1. 依赖包&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- springboot test --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.196&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试配置&quot;&gt;2. 测试配置&lt;/h3&gt;
&lt;p&gt;编辑 &lt;strong&gt;&lt;em&gt;src/test/resources/application.properties&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 数据源连接
spring.datasource.url=jdbc:h2:mem:test
# DDL脚本
spring.datasource.schema=classpath:script/test-schema.sql
# DML脚本
spring.datasource.data=classpath:script/test-data.sql

spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto = update&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试代码&quot;&gt;3. 测试代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(classes = BootJpa.class)
public class CityViewRepositoryTest {

    @Autowired
    private CityViewRepository cityViewRepository;

    @Test
    public void testGetAll(){

        List&amp;lt;CityView&amp;gt; views = cityViewRepository.findAll();
        System.out.println(JsonUtil.toPrettyJson(views));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本篇介绍了 H2 数据库常用的两种使用场景。尽管此前也写过关于H2 做单元测试的文章，&lt;br/&gt;但除此之外，其作为嵌入式数据库也是不错的选择，从行业趋势来看，终端计算对于嵌入式DB的需求会越来越多，后面也是比较看好的。&lt;br/&gt;与H2 类似的数据库还有HSQL、Derby，有兴趣的朋友可以研究对比下。&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 15:14:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 关于 H2 H2 数据库是一个纯 Java 实现的开源的嵌入式数据库，笔者第一次使用时还是在多年前的一个客户端项目中。 当时就觉得这个数据库很方便，如果你希望你的应用程序能'自带数据库，随</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10534319.html</dc:identifier>
</item>
<item>
<title>Django实战(一)-----用户登录与注册系统4（图片验证码） - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10534175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10534175.html</guid>
<description>&lt;p&gt;为了防止机器人频繁登录网站或者破坏分子恶意登录，很多用户登录和注册系统都提供了图形验证码功能。&lt;/p&gt;
&lt;p&gt;验证码（CAPTCHA）是一种区分用户是计算机还是人的公共全自动程序。&lt;/p&gt;
&lt;p&gt;可以防止恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。&lt;/p&gt;
&lt;p&gt;图形验证码的历史比较悠久，到现在已经有点英雄末路的味道了。因为机器学习、图像识别的存在，机器人已经可以比较正确的识别图像内的字符了。&lt;/p&gt;
&lt;p&gt;但不管怎么说，作为一种防御手段，至少还是可以抵挡一些低级入门的攻击手段，抬高了攻击者的门槛。&lt;/p&gt;
&lt;p&gt;在Django中实现图片验证码功能非常简单，有现成的第三方库可以使用。这个库叫做&lt;code&gt;django-simple-captcha&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;captcha&quot;&gt;一、安装captcha&lt;/h2&gt;
&lt;p&gt;在Pycharm的terminal中，首先进入mysite_env虚拟环境，然后安装第三方库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
pip install django-simple-captcha
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django自动帮我们安装了相关的依赖库&lt;code&gt;six&lt;/code&gt;、&lt;code&gt;olefile&lt;/code&gt;和&lt;code&gt;Pillow&lt;/code&gt;，其中的Pillow是大名鼎鼎的绘图模块。&lt;/p&gt;
&lt;h2 id=&quot;captcha_1&quot;&gt;二、注册captcha&lt;/h2&gt;
&lt;p&gt;在settings中，将‘captcha’注册到app列表里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'login',
    'captcha',
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;captcha需要在数据库中建立自己的数据表，所以需要执行migrate命令生成数据表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
python manage.py migrate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190314224034335-393656666.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;url&quot;&gt;三、添加url路由&lt;/h2&gt;
&lt;p&gt;在根目录下的urls.py文件中增加captcha对应的网址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
from django.conf.urls import url
from django.conf.urls import include
from django.contrib import admin
from login import views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^index/', views.index),
    url(r'^login/', views.login),
    url(r'^register/', views.register),
    url(r'^logout/', views.logout),
    url(r'^captcha', include('captcha.urls'))
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于使用了二级路由机制，需要在顶部&lt;code&gt;from django.conf.urls import include&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;formspy&quot;&gt;四、修改forms.py&lt;/h2&gt;
&lt;p&gt;如果上面都OK了，就可以直接在我们的forms.py文件中添加CaptchaField了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
from django import forms
from captcha.fields import CaptchaField

class UserForm(forms.Form):
    username = forms.CharField(label=&quot;用户名&quot;, max_length=128, widget=forms.TextInput(attrs={'class': 'form-control'}))
    password = forms.CharField(label=&quot;密码&quot;, max_length=256, widget=forms.PasswordInput(attrs={'class': 'form-control'}))
    captcha = CaptchaField(label='验证码')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意需要提前导入&lt;code&gt;from captcha.fields import CaptchaField&lt;/code&gt;，然后就像写普通的form字段一样添加一个captcha字段就可以了！&lt;/p&gt;
&lt;h2 id=&quot;loginhtml&quot;&gt;五、修改login.html&lt;/h2&gt;
&lt;p&gt;由于我们前面是手动生成的form表单，所以还要修改一下，添加captcha的相关内容，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
{% extends 'login/../base.html' %}
{% load staticfiles %}
{% block title %}登录{% endblock %}
{% block css %}&amp;lt;link href=&quot;{% static 'css/login.css' %}&quot; rel=&quot;stylesheet&quot;/&amp;gt;{% endblock %}


{% block content %}
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-4 col-md-offset-4&quot;&amp;gt;
          &amp;lt;form class='form-login' action=&quot;/login/&quot; method=&quot;post&quot;&amp;gt;

              {% if message %}
                  &amp;lt;div class=&quot;alert alert-warning&quot;&amp;gt;{{ message }}&amp;lt;/div&amp;gt;
              {% endif %}
              {% csrf_token %}
              &amp;lt;h2 class=&quot;text-center&quot;&amp;gt;欢迎登录&amp;lt;/h2&amp;gt;
              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.username.label_tag }}
                  {{ login_form.username}}
              &amp;lt;/div&amp;gt;
              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.password.label_tag }}
                  {{ login_form.password }}
              &amp;lt;/div&amp;gt;

              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.captcha.errors }}
                  {{ login_form.captcha.label_tag }}
                  {{ login_form.captcha }}
              &amp;lt;/div&amp;gt;

              &amp;lt;button type=&quot;reset&quot; class=&quot;btn btn-default pull-left&quot;&amp;gt;重置&amp;lt;/button&amp;gt;
              &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot;&amp;gt;提交&amp;lt;/button&amp;gt;

          &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt;
{% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里额外增加了一条&lt;code&gt;{{ login_form.captcha.errors }}&lt;/code&gt;用于明确指示用户，你的验证码不正确。&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;六、查看效果&lt;/h2&gt;
&lt;p&gt;重启服务器，进入登录页面，尝试用用户名错误、密码不对、验证码不对、全对的不同情况，看看我们新增的四位验证码的效果如何。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190314224552853-2019820690.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是这么简单！&lt;/p&gt;
&lt;p&gt;我们加入了一个防止机器人或者恶意登录的图形验证码功能，虽然界面难看了点，但底子是好的，你可以根据需要进行美化。&lt;/p&gt;
&lt;p&gt;其中验证图形码是否正确的工作都是在后台自动完成的，只需要使用&lt;code&gt;is_valid()&lt;/code&gt;这个forms内置的验证方法就一起进行了，完全不需要在视图函数中添加任何的验证代码，非常方便快捷！&lt;/p&gt;
&lt;p&gt;关于captcha的功能，当然绝不仅限于此，你可以设置六位、八位验证码，可以对图形噪点的生成模式进行定制，这些就留待你自己学习和研究了。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 14:47:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>为了防止机器人频繁登录网站或者破坏分子恶意登录，很多用户登录和注册系统都提供了图形验证码功能。 验证码（CAPTCHA）是一种区分用户是计算机还是人的公共全自动程序。 可以防止恶意破解密码、刷票、论坛</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinyuanliu/p/10534175.html</dc:identifier>
</item>
<item>
<title>面向过程和面向对象的区别 - 吴永吉</title>
<link>http://www.cnblogs.com/wuyongji/p/10534105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongji/p/10534105.html</guid>
<description>&lt;p&gt;　　先来看生活中的一个例子。&lt;/p&gt;
&lt;p&gt;　　想必每个人都下过五子棋吧？在下棋的整个过程中可以有两种不同的思路来实现：&lt;/p&gt;
&lt;p&gt;　　1、按步骤来看：&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　（1）、开始游戏，（2）、黑子先走，（3）、绘制画面，（4）、判断输赢，（5）、轮到白子，（6）、绘&lt;em id=&quot;__mceDel&quot;&gt;制画面，（7）、判断输赢，（8）、返回步骤（2），（9）输出最后结果&lt;/em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　2、按组成模块来看：&lt;br/&gt;　　&lt;em id=&quot;__mceDel&quot;&gt;（1）&lt;/em&gt;、黑白双方模块，&lt;em id=&quot;__mceDel&quot;&gt;（2）&lt;/em&gt;、棋盘模块，&lt;em id=&quot;__mceDel&quot;&gt;（3）&lt;/em&gt;、规则模块&lt;/p&gt;
&lt;p&gt;　　以上两种完全不同的设计思路，正好对应于编程中完全不同的两种思想：前者侧重于游戏步骤的设计，对应于编程中的面向过程思想；后者着重于分层，有模块化设计理念，对应于编程中的面向对象思想。可以很明显地看出：面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。&lt;/p&gt;
&lt;p&gt;　　C语言是典型的“面向过程”设计语言。面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。“面向过程”是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，它们不支持丰富的“面向对象”特性（比如继承、多态）。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190314222216655-1664246684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Java是典型的“面向对象”设计语言。“面向对象”是一种以事物为中心的编程思想。是把构成问题的事物分解成各个对象，建立对象的目的不是为了完成某一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190314222327434-1488483357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　面向过程适合于一个人的小量工作，而面向对象更侧重于团队合作，需要很多人完成的大量工作。面向过程思想是我们每一个人天生具备的。在编程时，我们总会不自觉的去考虑怎么来完成某一需求，分析出具体的步骤，然后按照步骤来一步步实现。但是在现实生活当中，并不是每一件事都可以自己独立来完成，我们需要团队，需要合作才可以完成某一项复杂的工作。这样来看的话，面向对象思想似乎更符合人们的做事方式，也更生活化。是的呢，不管是生活中，亦或是编程中，面向对象才是我们更应该具备的一种思想，先来看几组概念。&lt;/p&gt;
&lt;p&gt;　　对象：对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看做对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件等。&lt;br/&gt;　　类：具有相同特性(数据元素)和行为(功能)的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例化是对象，类实际上就是一种数据类型。&lt;br/&gt;　　面向对象三大特征：封装、继承、多态。&lt;/p&gt;
&lt;p&gt;　　封装：封装是一种把代码和代码所操作的数据捆绑在一起，使这两者不受外界干扰和误用的机制。封装可被理解为一种用作保护的包装器，以防止代码和数据被包装器外部所定义的其它代码任意访问。&lt;br/&gt;　　继承：继承是指一个对象从另一个对象中获得属性和方法的过程。它支持按层次分类的概念，如果不使用层次的概念，每个对象需要明确定义各自的全部特征，通过层次分类方式，一个对象只需要在它的类中定义使它成为唯一的各个属性和方法。&lt;br/&gt;　　多态：多态是指同一个实体同时具有多种形式。同一操作作用于不用的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的引用，来调用实现派生类中的方法。&lt;/p&gt;
&lt;p&gt;　　面向过程&lt;br/&gt;　　优点：性能比面向对象高。&lt;br/&gt;　　缺点：没有面向对象易维护、易复用、易扩展。&lt;br/&gt;　　面向对象&lt;br/&gt;　　优点：易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特征，可以设计出低耦合的系统，使系统更加灵活，更加易于维护和扩展。&lt;br/&gt;　　缺点：性能比面向过程低。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 14:32:00 +0000</pubDate>
<dc:creator>吴永吉</dc:creator>
<og:description>封装、继承、多态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongji/p/10534105.html</dc:identifier>
</item>
<item>
<title>java8 Stream的实现原理 (从零开始实现一个stream流) - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</guid>
<description>&lt;h3&gt;1.1 java8 stream介绍&lt;/h3&gt;
&lt;p&gt;　　java8新增了stream流的特性，能够让用户以函数式的方式、更为简单的操纵集合等数据结构，并实现了用户无感知的并行计算。&lt;/p&gt;
&lt;h3&gt;1.2 &lt;strong&gt;从零开始实现一个stream流&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　相信很多人在使用过java8的streamAPI接口之后，都会对其实现原理感到好奇，但往往在看到jdk的stream源码后却被其复杂的抽象、封装给弄糊涂了，而无法很好的理解其背后的原理。究其原因，是因为jdk的stream源码是高度工程化的代码，工程化的代码为了效率和满足多种多想的需求，会将代码实现的极其复杂，不易理解。&lt;/p&gt;
&lt;p&gt;　　在这里，我们将抛开jdk的实现思路，&lt;strong&gt;从零开始实现一个stream流&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　我们的&lt;strong&gt;stream流&lt;/strong&gt;同样拥有&lt;strong&gt;惰性求值&lt;/strong&gt;，&lt;strong&gt;函数式编程接口&lt;/strong&gt;等特性，并&lt;strong&gt;兼容jdk的Collection等数据结构&lt;/strong&gt;(但不支持并行计算 orz)。&lt;/p&gt;
&lt;p&gt;　　相信在亲手实现一个stream流的框架之后，大家能更好的理解流计算的原理。&lt;/p&gt;

&lt;p&gt;　　在探讨探究stream的实现原理和动手实现之前，我们先要体会stream流计算的独特之处。&lt;/p&gt;
&lt;p&gt;　　举个例子： 有一个List&amp;lt;Person&amp;gt;列表,我们需要获得年龄为70岁的前10个Person的姓名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程式的解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;稍加思考，我们很快就写出了一个过程式的解决方案(&lt;strong&gt;伪代码&lt;/strong&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; limit = 10; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 限制条件&lt;/span&gt;
List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收集的姓名集合&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person personItem : personList){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(personItem.age == 70){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 满足条件&lt;/span&gt;
        nameList.add(personItem.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入姓名集合&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(nameList.size() &amp;gt;= 10){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否超过限制&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nameList;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数式stream解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们给出一种基于stream流的解决方案(&lt;strong&gt;伪代码&lt;/strong&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
List&amp;lt;String&amp;gt; nameList =&lt;span&gt; personList.stream()
　　　　　　.filter(item&lt;/span&gt;-&amp;gt;item.age == 70) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
　　　　　　.limit(10)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit限制条件&lt;/span&gt;
　　　　　　.map(item-&amp;gt;item.name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得姓名&lt;/span&gt;
　　　　　　.collect(Collector.toList()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转化为list&lt;/span&gt;

&lt;span&gt;return&lt;/span&gt; nameList;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;两种方案的不同之处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;从函数式的角度上看，&lt;strong&gt;过程式的代码实现将收集元素、循环迭代、各种逻辑判断耦合在一起，暴露了太多细节&lt;/strong&gt;。当未来需求变动和变得更加复杂的情况下，过程式的代码将变得难以理解和维护(需要控制台打印出 年龄为70岁的前10个Person中，姓王的Person的名称）。&lt;/p&gt;
&lt;p&gt;　　函数式的解决方案&lt;strong&gt;解开了代码细节和业务逻辑的耦合&lt;/strong&gt;，类似于sql语句，表达的是&lt;strong&gt;&quot;要做什么&quot;&lt;/strong&gt;而不是&lt;strong&gt;&quot;如何去做&quot;&lt;/strong&gt;，使程序员可以更加专注于业务逻辑，写出易于理解和维护的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
&lt;span&gt;personList.stream()
    .filter(item&lt;/span&gt;-&amp;gt;item.age == 70) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
    .limit(10)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit限制条件&lt;/span&gt;
    .filter(item-&amp;gt;item.name.startWith(&quot;王&quot;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
    .map(item-&amp;gt;item.name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得姓名&lt;/span&gt;
    .forEach(System.out::println);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　stream API的接口是函数式的，尽管java 8也引入了lambda表达式，但java实质上依然是由&lt;strong&gt;接口-匿名内部类&lt;/strong&gt;来实现函数传参的，所以需要事先定义一系列的函数式接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function: 类似于 y = F(x)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Function&amp;lt;R,T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * 类似于 y = F(x)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    R apply(T t);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;BiFunction: 类似于 z = F(x,y)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiFunction&amp;lt;R, T, U&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * 类似于 z = F(x,y)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    R apply(T t, U u);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ForEach: 遍历处理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ForEach &amp;lt;T&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 迭代器遍历
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 被迭代的每一项
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; apply(T item);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Comparator: 比较器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparator&amp;lt;T&amp;gt;&lt;span&gt;  {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较方法逻辑
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o1    参数1
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o2    参数2
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      返回值大于0 ---&amp;gt; (o1 &amp;gt; o2)
     *              返回值等于0 ---&amp;gt; (o1 = o2)
     *              返回值小于0 ---&amp;gt; (o1 &amp;lt; o2)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(T o1, T o2);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Predicate: 条件判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Predicate &amp;lt;T&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 迭代的每一项
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 满足条件
     *          false 不满足条件
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; satisfy(T item);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Supplier：提供初始值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Supplier&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 提供初始值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 初始化的值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T get();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;EvalFunction：stream求值函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; EvalFunction&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream流的强制求值方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 求值返回一个新的stream
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; apply();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;stream API接口：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * stream流的API接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Stream&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 映射 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mapper 转换逻辑 T-&amp;gt;R
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R,T&amp;gt;&lt;span&gt; mapper);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扁平化 映射 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mapper 转换逻辑 T-&amp;gt;MyStream&amp;lt;R&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  一个新的流(扁平化之后)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;, T&amp;gt;&lt;span&gt; mapper);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; predicate 谓词判断
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中元素是满足predicate条件的
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 截断 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; n 截断流，只获取部分
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不超过 n
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 去重操作 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不重复(!equals）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; distinct();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不重复(!equals）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 遍历 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumer 遍历逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 浓缩 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; initVal 浓缩时的初始值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; accumulator 浓缩时的 累加逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 浓缩之后的结果
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R, R, T&amp;gt;&lt;span&gt; accumulator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; collector 传入所需的函数组合子，生成高阶函数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 收集之后的结果
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;T,A,R&amp;gt;&lt;span&gt; collector);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最大值 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 大小比较逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 流中的最大值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T max(Comparator&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; comparator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最小值 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 大小比较逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 流中的最小值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T min(Comparator&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; comparator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 计数 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  当前流的个数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流中是否存在满足predicate的项
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 存在 匹配项
     *          false 不存在 匹配项
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流中的元素是否全部满足predicate
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 全部满足
     *          false 不全部满足
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回空的 stream
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 空stream
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; makeEmptyStream(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; isEnd = true&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;().isEnd(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　简单介绍了API接口定义之后，我们开始深入探讨流的内部实现。&lt;/p&gt;
&lt;p&gt;　　流由两个重要的部分所组成，&lt;strong&gt;&quot;当前数据项(head)&quot;&lt;/strong&gt;和&lt;strong&gt;&quot;下一数据项的求值函数(nextItemEvalProcess)&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　其中，&lt;strong&gt;nextItemEvalProcess是流能够实现&quot;惰性求值&quot;的关键&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190312160335800-2131049743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流的基本属性：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyStream&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Stream&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流的头部
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流的下一项求值函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; NextItemEvalProcess nextItemEvalProcess;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否是流的结尾
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnd;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; target;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Builder() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target = &lt;span&gt;new&lt;/span&gt; MyStream&amp;lt;&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt; head(T head){
            target.head &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        Builder&lt;/span&gt;&amp;lt;T&amp;gt; isEnd(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnd){
            target.isEnd &lt;/span&gt;=&lt;span&gt; isEnd;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt; nextItemEvalProcess(NextItemEvalProcess nextItemEvalProcess){
            target.nextItemEvalProcess &lt;/span&gt;=&lt;span&gt; nextItemEvalProcess;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; build(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
        }
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前流强制求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 求值之后返回一个新的流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; eval(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess.eval();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前流 为空
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmptyStream(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEnd;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 下一个元素求值过程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NextItemEvalProcess {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 求值方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EvalFunction evalFunction;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(EvalFunction evalFunction) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.evalFunction =&lt;span&gt; evalFunction;
    }

    MyStream eval(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; evalFunction.apply();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.1 stream&lt;/strong&gt;流在使用过程中的三个阶段&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;1.  生成并构造一个流&lt;/strong&gt; (List.stream() 等方法)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.  在流的处理过程中添加、绑定惰性求值流程  &lt;/strong&gt;(map、filter、limit 等方法)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.  对流使用强制求值函数，生成最终结果 &lt;/strong&gt;(max、reduce、collect等方法)&lt;/p&gt;
&lt;h3&gt;4.2 &lt;strong&gt;生成并构造一个流&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;流在生成时是&quot;纯净&quot;的，其最初的&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;求值之后就是指向自己的下一个元素&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们以一个Integer整数流的生成为例。&lt;strong&gt;IntegerStreamGenerator.getIntegerStream(1,10) &lt;/strong&gt;会返回一个流结构，其逻辑上等价于一个从1到10的整数流。但实质是一个惰性求值的stream对象，这里称其为&lt;strong&gt;IntStream&lt;/strong&gt;，其NextItemEvalProcess是一个闭包，方法体是一个递归结构的求值函数，其中下界参数low = low + 1。&lt;/p&gt;
&lt;p&gt;　　当IntStream第一次被求值时，流开始初始化，isStart = false。当初始化完成之后，每一次求值，都会生成一个新的流对象，其中head(low) = low + 1。当low &amp;gt; high时，流被终止，返回空的流对象。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190314215343735-1476943174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 整数流生成器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntegerStreamGenerator {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得一个有限的整数流 介于[low-high]之间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; low 下界
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; high 上界
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyStream&amp;lt;Integer&amp;gt; getIntegerStream(&lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getIntegerStreamInner(low,high,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数。配合getIntegerStream(int low,int high)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyStream&amp;lt;Integer&amp;gt; getIntegerStreamInner(&lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; high, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isStart){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low &amp;gt;&lt;span&gt; high){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到达边界条件，返回空的流&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isStart){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;Integer&amp;gt;&lt;span&gt;()
                    .process(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;getIntegerStreamInner(low,high,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;Integer&amp;gt;&lt;span&gt;()
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素 low&lt;/span&gt;
&lt;span&gt;                    .head(low)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一个元素 low+1&lt;/span&gt;
                    .process(&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;getIntegerStreamInner(low+1,high,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，&lt;strong&gt;生成一个流的关键在于确定如何求值下一项元素。&lt;/strong&gt;对于整数流来说，low = low + 1就是其下一项的求值过程。&lt;/p&gt;
&lt;p&gt;　　那么对于我们非常关心的jdk集合容器，又该如何生成对应的流呢?&lt;/p&gt;
&lt;p&gt;　　答案是&lt;strong&gt;Iterator迭代器&lt;/strong&gt;，jdk的集合容器都实现了Iterator迭代器接口，通过迭代器我们可以轻易的取得容器的下一项元素，而不用关心容器内部实现细节。换句话说，&lt;strong&gt;只要实现过迭代器接口，就可以自然的转化为stream流，从而获得流计算的所有能力&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 集合流生成器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CollectionStreamGenerator {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将一个List转化为stream流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; getListStream(List&amp;lt;T&amp;gt;&lt;span&gt; list){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getListStream(list.iterator(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; iterator list 集合的迭代器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; isStart 是否是第一次迭代
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; getListStream(Iterator&amp;lt;T&amp;gt; iterator, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isStart){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在迭代的下一个元素，返回空的流&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isStart){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化，只需要设置 求值过程&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt; getListStream(iterator,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非初始化，设置head和接下来的求值过程&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .head(iterator.next())
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt; getListStream(iterator,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;思考一个小问题，如何生成一个无穷的整数流？&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.3 &lt;/strong&gt;在流的处理过程中添加、绑定惰性求值流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;我们以map接口举例说明。API的map接口是一个&lt;strong&gt;惰性求值&lt;/strong&gt;接口，在流执行了map方法后(stream.map())，不会进行任何的求值运算。map在执行时，会生成一个新的求值过程&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;，新的过程将之前流的求值过程给&lt;strong&gt;&quot;包裹&quot;&lt;/strong&gt;起来了，仅仅是在&lt;strong&gt;&quot;流的生成&quot;&lt;/strong&gt;到&lt;strong&gt;&quot;流的最终求值&quot;&lt;/strong&gt;之间增加了一道处理工序，最终返回了一个新的stream流对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;API.map所依赖的内部静态map方法是一个惰性求值方法，其每次调用&lt;strong&gt;&quot;&lt;/strong&gt;只会&lt;strong&gt;&quot;&lt;/strong&gt;将当前流的head部分进行map映射操作，并且生成一个新的流。新生成流的&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;和之前逻辑基本保持一致(递归)，唯一的区别是，第二个参数传入的&lt;strong&gt;stream&lt;/strong&gt;在调用方法之前会被强制求值&lt;strong&gt;(eval)&lt;/strong&gt;后再传入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R, T&amp;gt;&lt;span&gt; mapper) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map(mapper, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process map&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess)
                .build();
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.map
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R, T&amp;gt; mapper, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        R head &lt;/span&gt;=&lt;span&gt; mapper.apply(myStream.head);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                .head(head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;map(mapper, myStream.eval())))
                .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　惰性求值接口的实现大同小异，大家需要体会一下&lt;strong&gt;闭包&lt;/strong&gt;、&lt;strong&gt;递归、&lt;/strong&gt;&lt;strong&gt;惰性求值&lt;/strong&gt;等概念，限于篇幅就不一一展开啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flatMap：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a812fa6e-832e-4211-8aae-1a173d9ad889')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a812fa6e-832e-4211-8aae-1a173d9ad889',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;,T&amp;gt;&lt;span&gt; mapper) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flatMap(mapper, Stream.makeEmptyStream(), myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process map&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
            .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess)
            .build();
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.flatMap
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;,T&amp;gt; mapper, MyStream&amp;lt;R&amp;gt; headMyStream, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(headMyStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                T outerHead &lt;/span&gt;=&lt;span&gt; myStream.head;
                MyStream&lt;/span&gt;&amp;lt;R&amp;gt; newHeadMyStream =&lt;span&gt; mapper.apply(outerHead);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flatMap(mapper, newHeadMyStream.eval(), myStream.eval());
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                        .head(headMyStream.head)
                        .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt; flatMap(mapper, headMyStream.eval(), myStream)))
                        .build();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;filter：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('04ae6647-9a85-4ed4-8511-3242cecc711e')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('04ae6647-9a85-4ed4-8511-3242cecc711e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt;&lt;span&gt; predicate) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter(predicate, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process filter&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.filter
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt; predicate, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .head(myStream.head)
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;filter(predicate, myStream.eval())))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter(predicate, myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;limit：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7902b0da-e55d-4de9-8c71-b3a9d0526a2a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7902b0da-e55d-4de9-8c71-b3a9d0526a2a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; limit(n, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process limit&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.limit
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt; num, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num == 0 ||&lt;span&gt; myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                .head(myStream.head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;limit(num-1&lt;span&gt;, myStream.eval())))
                .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;distinct：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('53eedd00-28c2-4bf9-a99e-21e59c5eca69')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('53eedd00-28c2-4bf9-a99e-21e59c5eca69',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; distinct() {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distinct(&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;(), myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process limit&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.distinct
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; distinct(Set&amp;lt;T&amp;gt; distinctSet,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;distinctSet.contains(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入集合&lt;/span&gt;
&lt;span&gt;            distinctSet.add(myStream.head);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                .head(myStream.head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;distinct(distinctSet, myStream.eval())))
                .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; distinct(distinctSet, myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;peek：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56525837-edf6-43ab-960f-ffb819c3c73d')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56525837-edf6-43ab-960f-ffb819c3c73d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; peek(consumer,myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process peek&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.peek
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt; consumer,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        consumer.apply(myStream.head);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
            .head(myStream.head)
            .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;peek(consumer, myStream.eval())))
            .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.4 &lt;/strong&gt;对流使用强制求值函数，生成最终结果&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;我们以&lt;strong&gt;forEach&lt;/strong&gt;方法举例说明。强制求值方法&lt;strong&gt;forEach&lt;/strong&gt;会不断的对当前stream进行求值并让consumer接收处理，直到当前流成为空流。&lt;/p&gt;
&lt;p&gt;有两种可能的情况会导致递归传入的流参数成为空流(&lt;strong&gt;empty-stream&lt;/strong&gt;)：&lt;/p&gt;
&lt;p&gt;　　1. 最初生成流的求值过程返回了空流(整数流，low &amp;gt; high 时，返回空流 )&lt;/p&gt;
&lt;p&gt;　　2. limit之类的短路操作，会提前终止流的求值返回空流(n == 0 时，返回空流)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        forEach(consumer,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.forEach
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt; consumer, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        consumer.apply(myStream.head);
        forEach(consumer, myStream.eval());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　强制求值的接口的实现也都大同小异，限于篇幅就不一一展开啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f827a47e-0490-43e0-8195-ef9c5d3ee0e4')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f827a47e-0490-43e0-8195-ef9c5d3ee0e4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.reduce
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R,R,T&amp;gt; accumulator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initVal;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        R result &lt;/span&gt;=&lt;span&gt; reduce(initVal,accumulator, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accumulator.apply(result,head);
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.reduce
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R,R,T&amp;gt; accumulator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initVal;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        R result &lt;/span&gt;=&lt;span&gt; reduce(initVal,accumulator, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accumulator.apply(result,head);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;max：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de8bf932-faad-439b-9948-46cbdfa11e48')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de8bf932-faad-439b-9948-46cbdfa11e48',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T max(Comparator&amp;lt;T&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        MyStream&amp;lt;T&amp;gt; eval = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(eval.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator,eval,eval.head);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.max
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T max(Comparator&amp;lt;T&amp;gt; comparator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream, T max){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEnd){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 和 max 进行比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(comparator.compare(head,max) &amp;gt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 较大 作为新的max传入&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator, myStream.eval(),head);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; max 较大 不变&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator, myStream.eval(),max);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;min：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b89f4b0f-8246-4aea-a20b-2ec494b0b17e')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b89f4b0f-8246-4aea-a20b-2ec494b0b17e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T min(Comparator&amp;lt;T&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        MyStream&amp;lt;T&amp;gt; eval = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(eval.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator,eval,eval.head);
        }
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.min
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T min(Comparator&amp;lt;T&amp;gt; comparator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream, T min){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEnd){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 和 min 进行比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(comparator.compare(head,min) &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 较小 作为新的min传入&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator, myStream.eval(),head);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; min 较小 不变&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator, myStream.eval(),min);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;count：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9e80cbb6-0bb5-44b8-8477-aac172bd58cf')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9e80cbb6-0bb5-44b8-8477-aac172bd58cf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count(&lt;span&gt;this&lt;/span&gt;.eval(),0&lt;span&gt;);
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.count
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; count(MyStream&amp;lt;T&amp;gt; myStream, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count+1 进行递归&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count(myStream.eval(),count+1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;anyMatch：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('61e40265-3030-4bc7-8b7d-f60367d1bc2c')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('61e40265-3030-4bc7-8b7d-f60367d1bc2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; anyMatch(predicate,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.anyMatch
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截止末尾，不存在任何匹配项&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配 存在匹配项 返回true&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不匹配，继续检查，直到存在匹配项&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; anyMatch(predicate,myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;allMatch：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d84867b6-eeb6-441a-a486-44956de1b80a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d84867b6-eeb6-441a-a486-44956de1b80a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; allMatch(predicate,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.anyMatch
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全部匹配&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前项匹配，继续检查&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; allMatch(predicate,myStream.eval());
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在不匹配的项，返回false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.5 &lt;/strong&gt;&lt;strong&gt;collect方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;collect方法是强制求值方法中，最复杂也最强大的接口，其作用是将流中的元素收集(collect)起来，并转化成特定的数据结构。&lt;/p&gt;
&lt;p&gt;　　从函数式编程的角度来看，collect方法是一个高阶函数，其接受三个函数作为参数(&lt;strong&gt;supplier&lt;/strong&gt;，&lt;strong&gt;accumulator&lt;/strong&gt;，&lt;strong&gt;finisher&lt;/strong&gt;)，最终生成一个更加强大的函数。在java中，三个函数参数以Collector实现对象的形式呈现。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;supplier&lt;/strong&gt; 方法：用于提供收集collect的初始值。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;accumulator&lt;/strong&gt; 方法：用于指定收集过程中，初始值和流中个体元素聚合的逻辑。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;finnisher&lt;/strong&gt; 方法：用于指定在收集完成之后的收尾转化操作(例如：StringBuilder.toString() ---&amp;gt; String)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;collect接口实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;T, A, R&amp;gt;&lt;span&gt; collector) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        A result = collect(collector,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过finish方法进行收尾&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.finisher().apply(result);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.collect
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R, A, T&amp;gt; A collect(Collector&amp;lt;T, A, R&amp;gt; collector, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.supplier().get();
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        A tail &lt;/span&gt;=&lt;span&gt; collect(collector, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.accumulator().apply(tail,head);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;collector接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * collect接口 收集器
 * 通过传入组合子，生成高阶过程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Collector&amp;lt;T, A, R&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集时，提供初始化的值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Supplier&lt;/span&gt;&amp;lt;A&amp;gt;&lt;span&gt; supplier();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A = A + T
     * 累加器，收集时的累加过程
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    BiFunction&lt;/span&gt;&amp;lt;A, A, T&amp;gt;&lt;span&gt; accumulator();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集完成之后的收尾操作
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Function&lt;/span&gt;&amp;lt;A, R&amp;gt;&lt;span&gt; finisher();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;了解jdk源码的读者可能会注意到，jdk的stream实现中collector接口多了一个combiner接口，combiner接口用于指定并行计算之后的结果集合并的逻辑，由于我们的实现不支持并行计算，因此也不需要添加combiner接口了。&lt;/p&gt;
&lt;p&gt;　　同时，jdk还提供了一个Collectors工具类，很好的满足了平时常见的需求(Collector.toList()、Collctor.groupingBy())等等。但特殊时刻还是需要用户自己指定collect传入的参数，精细的控制处理逻辑的，因此还是有必要了解一下collect方法内部原理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stream.collect()参数常用工具类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * stream.collect() 参数常用工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CollectUtils {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream 转换为 List
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; toList(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; supplier() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ArrayList::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BiFunction&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;, T&amp;gt;&lt;span&gt; accumulator() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (list, item) -&amp;gt;&lt;span&gt; {
                    list.add(item);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
                };
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Function&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; finisher() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list -&amp;gt;&lt;span&gt; list;
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream 转换为 Set
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; toSet(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Supplier&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; supplier() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HashSet::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BiFunction&amp;lt;Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;, T&amp;gt;&lt;span&gt; accumulator() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (set, item) -&amp;gt;&lt;span&gt; {
                    set.add(item);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set;
                };
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Function&amp;lt;Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; finisher() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; set -&amp;gt;&lt;span&gt; set;
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.6 &lt;/strong&gt;&lt;strong&gt;举例分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们选择一个简单而又不失一般性的例子，串联起这些内容。通过完整的描述一个流求值的全过程，加深大家对流的理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){&lt;/span&gt;&lt;span&gt;
        Integer sum &lt;/span&gt;=&lt;span&gt; IntegerStreamGenerator.getIntegerStream(1,10)
                    .filter(item&lt;/span&gt;-&amp;gt; item%2 == 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤出偶数&lt;/span&gt;
                    .map(item-&amp;gt; item * item)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射为平方&lt;/span&gt;
                    .limit(2)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截取前两个&lt;/span&gt;
                    .reduce(0,(i1,i2)-&amp;gt; i1+i2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终结果累加求和(初始值为0)&lt;/span&gt;
&lt;span&gt;
        System.out.println(sum); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于我们的stream实现采用的是链式编程的方式，不太好理解，将其展开为逻辑等价的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　 //&lt;/span&gt;&lt;span&gt; 生成整数流 1-10&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; intStream =&lt;span&gt; IntegerStreamGenerator.getIntegerStream(1,10);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; intStream基础上过滤出偶数&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; filterStream =  intStream.filter(item-&amp;gt; item%2 == 0&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; filterStream基础上映射为平方&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; mapStream = filterStream.map(item-&amp;gt; item *&lt;span&gt; item);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mapStream基础上截取前两个&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; limitStream = mapStream.limit(2&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终结果累加求和(初始值为0)&lt;/span&gt;
        Integer sum = limitStream.reduce(0,(i1,i2)-&amp;gt; i1+&lt;span&gt;i2);

        System.out.println(sum); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;reduce强制求值操作之前的执行过程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190313105216236-879324712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce强制求值过程中的执行过程图 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190314220758233-258101617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，stream的求值过程并不会一口气将初始的流全部求值，而是按需的、一个一个的进行求值。&lt;/p&gt;
&lt;p&gt;　　stream的一次求值过程至多只会遍历流中元素一次；如果存在短路操作(limit、anyMatch等)，实际迭代的次数会更少。&lt;/p&gt;
&lt;p&gt;　　因此不必担心多层的map、filter处理逻辑的嵌套会让流进行多次迭代，导致效率急剧下降。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190313190402408-471866930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.1 当前版本缺陷&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 递归调用效率较低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了代码的简洁性和更加的函数式，在实现中很多地方都用递归代替了循环迭代。&lt;/p&gt;
&lt;p&gt;　　虽然逻辑上递归和迭代是等价的，但在目前的计算机硬件上，每一层的递归调用都会使得函数调用栈增大。当流处理的数据量很大时，将会出现栈溢出，栈空间不足之类的系统错误。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;将递归优化为迭代能够增加当前版本流的执行效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. API接口较少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;限于篇幅，我们只提供了一些较为常用的API接口。在jdk中，Collector工具类提供了很多方便易用的接口；对于同一API接口也提供了多种重载函数给用户使用。以目前已经实现的功能为基础，提供一些更加方便的接口并不困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 不支持并行计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;由于流在求值计算时生成的是对象的副本，是无副作用的，很适合通过数据分片的执行并行计算。限于个人水平，在设计之初并没有考虑将并行计算这一特性加入进来。&lt;/p&gt;
&lt;h3&gt;5.2 函数式编程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;仔细分析整个流的执行过程，&lt;strong&gt;与其说流是一个对象，不如说流是一个高阶函数(high-order function)。&lt;/strong&gt;每当map、filter绑定了一个流，新生成的流其实是一个更加复杂的函数；每一层封装，都会使新生成的流这一高阶函数比起原基础变得更加强大和复杂。map、filter就像一个个的基础算子，在接收对应的过程后(filter(过滤出偶数)、map(平方映射))，可以不断的叠加，完成许许多多非常复杂的操作。&lt;/p&gt;
&lt;p&gt;　　这也是函数式编程的中心思想之一：&lt;strong&gt;将计算过程转化为一系列嵌套函数的调用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.3 总结&lt;/h3&gt;
&lt;p&gt;　　最初是在学习&lt;a href=&quot;https://www.zhihu.com/question/26549715&quot; target=&quot;_blank&quot;&gt;《计算机程序的构造和解释》(SICP)&lt;/a&gt;中stream流计算时突发奇想的，想着能不能用java来实现一个和书上类似的流计算框架，能和jdk的stream流功能大致相同，最终，通过反复地思考和尝试才将心中所想以java代码的形式呈现出来。&lt;/p&gt;
&lt;p&gt;　　SICP是一本小众但别具一格的计算机书籍，许多人认为它不太实用。我个人认为，虽然计算机技术发展日新月异，但是计算机技术的基础理论却往往变化缓慢，如果能够抓住技术发展背后那不变的元知识，就不容易在技术的浪潮中失去方向。SICP就是这样一本教授计算机科学元知识的书籍，虽然一开始有点枯燥，却能慢慢品味出其美妙之处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;希望大家在阅读完这篇博客之后，能更好的理解流计算，更好的理解函数式编程。&lt;/p&gt;
&lt;p&gt;　　SICP公开课视频(中英字幕)：&lt;a href=&quot;https://www.bilibili.com/video/av8515129&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/av8515129&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　这篇博客的完整代码在我的github上：&lt;a href=&quot;https://github.com/1399852153/Streamjava&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/Streamjava&lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 14:12:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.Stream 流的介绍 1.1 java8 stream介绍 java8新增了stream流的特性，能够让用户以函数式的方式、更为简单的操纵集合等数据结构，并实现了用户无感知的并行计算。 1.2&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</dc:identifier>
</item>
</channel>
</rss>