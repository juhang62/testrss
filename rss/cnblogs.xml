<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一些有趣有用的位运算 - murphy_gb</title>
<link>http://www.cnblogs.com/kyoner/p/11179157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kyoner/p/11179157.html</guid>
<description>&lt;p&gt;本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n &amp;amp; (n - 1)操作，顺便把用到的这个技巧的算法题列出来讲解一下，因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。&lt;/p&gt;
&lt;p&gt;位操作（Bit Manipulation)可以玩出很多奇淫技巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只要记住一些有用的操作即可。&lt;/p&gt;

&lt;h3 id=&quot;利用或操作-和空格将英文字符转换为小写&quot;&gt;&lt;em&gt;1&lt;/em&gt;. 利用或操作 | 和空格将英文字符转换为小写&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;('a' | ' ') = 'a'
('A' | ' ') = 'a'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;利用与操作-和下划线将英文字符转换为大写&quot;&gt;&lt;em&gt;2&lt;/em&gt;. 利用与操作 &amp;amp; 和下划线将英文字符转换为大写&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;('b' &amp;amp; '_') = 'B'
('B' &amp;amp; '_') = 'B'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;利用异或操作-和空格进行英文字符大小写互换&quot;&gt;&lt;em&gt;3&lt;/em&gt;. 利用异或操作 ^ 和空格进行英文字符大小写互换&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。&lt;/p&gt;
&lt;h3 id=&quot;判断两个整数是否异号&quot;&gt;&lt;em&gt;4&lt;/em&gt;. 判断两个整数是否异号&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int x = -1, y = 2;
bool f = ((x ^ y) &amp;lt; 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) &amp;lt; 0); // false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。关于补码编码和溢出。&lt;/p&gt;
&lt;h3 id=&quot;交换两个数&quot;&gt;&lt;em&gt;5&lt;/em&gt;. 交换两个数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
// 现在 a = 2, b = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加一&quot;&gt;&lt;em&gt;6.&lt;/em&gt; 加一&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int n = 1;
n = -~n;
// 现在 n = 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;减一&quot;&gt;&lt;em&gt;7&lt;/em&gt;. 减一&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int n = 2;
n = ~-n;
// 现在 n = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看这个图就很容易理解了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201907/1566782-20190713011351943-15730504.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面看两道用到此技巧的算法题目。&lt;/p&gt;
&lt;h3 id=&quot;计算汉明权重hamming-weight&quot;&gt;1. 计算汉明权重（Hamming Weight）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201907/1566782-20190713011431674-209706962.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是让你返回 n 的二进制表示中有几个 1。因为 n &amp;amp; (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n &amp;amp; (n - 1);
        res++;
    }
    return res;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断一个数是不是-2-的指数&quot;&gt;&lt;em&gt;2&lt;/em&gt;. 判断一个数是不是 2 的指数&lt;/h3&gt;
&lt;p&gt;一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用位运算技巧就很简单了（注意运算符优先级，括号不可以省略）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;bool isPowerOfTwo(int n) {
    if (n &amp;lt;= 0) return false;
    return (n &amp;amp; (n - 1)) == 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 12 Jul 2019 17:15:00 +0000</pubDate>
<dc:creator>murphy_gb</dc:creator>
<og:description>本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 n &amp; (n 1)操作，顺便把用到的这个技巧的算法题列出来讲解一下，因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kyoner/p/11179157.html</dc:identifier>
</item>
<item>
<title>JVM内存结构解析 - zohy</title>
<link>http://www.cnblogs.com/ZoHy/p/11178966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZoHy/p/11178966.html</guid>
<description>&lt;p&gt;月初的时候个人网站到期了，不想再折腾重新建站了，以后还是来第三方博客写文章吧，可以省去很多问题。之前写的文章也不是很多，备份懒得做了，从头开始吧。博文仅仅是用来记录和学习总结，如有错误之处请帮忙指正！&lt;/p&gt;
&lt;p&gt;今天想说说JVM内存结构的问题，说到JVM大家肯定首先想到的是栈和堆。的确，这两块说是JVM内存结构最重要的部分也不为过。先来简单介绍一下吧，&lt;/p&gt;
&lt;p&gt;内存结构按照私有和共享划分方式如下：&lt;/p&gt;
&lt;p&gt;线程私有：栈区、本地方法栈、程序计数器&lt;/p&gt;
&lt;p&gt;线程共享：堆区、方法区&lt;/p&gt;
&lt;p&gt;其他不说了，重点说说栈和堆&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;栈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈的特点就是快。每个线程对应一个栈，每个栈含有1个或多个栈帧，栈帧用来存放方法的局部变量表、操作数栈、动态链接、returnAddress等信息，每运行一个方法就会创建一个栈帧，从方法运行到结束对应着栈帧在栈区里面入栈和出栈的过程。&lt;/p&gt;
&lt;p&gt;局部变量表包含两类数据结构，一是八大基本类型，byte short int long float double char boolean; 第二类是reference类型，占用空间是4byte，不管是对象是大是小，操控它仅需要用一个4byte的变量即可，而且可以按需销毁，这足以体现栈堆分离的好处。&lt;/p&gt;
&lt;p&gt;栈空间是可以重复利用的，遇到左括号入栈，遇到右括号出栈，我们当系统进行递归调用时，系统会连续多次执行入栈操作，直到最深处才执行出栈操作，这就可能导致栈空间不足，StackOverFlowError异常，因此遇到该异常一般不是对象太大导致的，多是因为不正确递归或栈空间不足以容纳导致。在栈区还可能会遇到OOM异常，当线程过多时或分配空间过小时，如果无法申请到足够内存时，便会报OOM异常（栈区OOM异常的原因暂不确定也为遇见过，只是周志明JVM书中提到栈区OOM异常，上网也未查到）。JVM调优：通过-Xss来控制栈空间大小。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;堆：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆是JVM内存中最大的一块，是用来为对象和数组元素分配空间的地方，而对象的引用变量和数组引用都是在栈中存放的。“几乎所有的对象都在这里创建”，那么什么情况下对象不在堆中创建呢？随着JIT编译器的发展，在编译期间，如果JIT经逃逸分析后发现对象没有逃逸出方法，那么该对象坑会在栈上分配内存而不是堆，但是也不绝对。测试：为JVM分配足够空间，关闭逃逸分析，创建一百万个User对象，jmap命令发现堆中创建了一百万个对象，开启逃逸分析，发现堆中的对象变成了八万个，也就是说JIT编译器确实会将对象分配在栈里，但并不绝对。&lt;/p&gt;
&lt;p&gt;使用逃逸分析，编译器可以针对分析结果做以下优化：&lt;/p&gt;
&lt;p&gt;1、同步省略（锁消除优化）：如果一个对象被发现只能被一个线程访问，那么可以不考虑该对象的同步；&lt;/p&gt;
&lt;p&gt;2、栈上分配对象；如果一个对象在子程序中被分配，要是指向该对象的指针永远不会逃逸，对象可能会在栈中被分配，而不是在堆中；&lt;/p&gt;
&lt;p&gt;3、分离对象或标量替换：有的对象可能不需要连续的内存结构，可以将该对象的部分或全部存储到CPU的寄存器中。&lt;/p&gt;
&lt;p&gt;逃逸分析：-XX:+/-DoEscapeAnalysis&lt;/p&gt;
&lt;p&gt;关于堆的分代和垃圾收集下次再讲。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;顺带讲一下，参数传递的时候，Java是传值还是传引用？这个问题相信每个程序员都会思考过，也肯定遇到过由此引发的问题。&lt;/p&gt;
&lt;p&gt;要说明这个问题，首先要说明两点：一是不要和C语言类比，Java没有指针的概念；二是程序运行永远都是在栈中进行，因而参数传递时涉及到的只会是基本数据类型和引用类型，理论上来说不会涉及到对象本身。而Java中没有指针的概念，因此Java可以说是传值调用，当参数是引用类型时传递的是引用变量的值；&lt;strong&gt;但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象，&lt;/strong&gt;这个时候如果对其进行修改，修改的并不是引用本身，而是对象的属性，所以对对象的修改会保持。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个引用，则可以修改这个引用背后的东西。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 15:29:00 +0000</pubDate>
<dc:creator>zohy</dc:creator>
<og:description>月初的时候个人网站到期了，不想再折腾重新建站了，以后还是来第三方博客写文章吧，可以省去很多问题。之前写的文章也不是很多，备份懒得做了，从头开始吧。博文仅仅是用来记录和学习总结，如有错误之处请帮忙指正！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZoHy/p/11178966.html</dc:identifier>
</item>
<item>
<title>windows container 踩坑记 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/troubleshot-windows-container.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/troubleshot-windows-container.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;我们有一些服务是 dotnet framework 的，不能直接跑在 docker linux container 下面，最近一直在折腾把它部署在 windows container 下，折腾的有点恶心，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;windows-container-介绍&quot;&gt;Windows Container 介绍&lt;/h2&gt;
&lt;p&gt;Windows Container 是微软在 Windows 上的虚拟化实践，它可以提供操作系统级别的虚拟化。&lt;br/&gt;通过我们说的容器化大多是指 Linux Container，基于 linux 的 container 实践，除此之外还有 windows container，如果你使用的是 windows 且使用过 Docker for Desktop，你也许会注意到 docker 右键的时候会有一个 “Switch to windows container” 的选项。&lt;/p&gt;
&lt;p&gt;Windows container 架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190712232331513-2107314194.png&quot; alt=&quot;Windows Container Architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows container 分为两大部分： windows container on windows(下文简称 Windows Container), linux container on windows(下文简称 Linux Container), 我们今天将要用到的是 Windows container.&lt;/p&gt;
&lt;p&gt;上图所示的两种方式对应着 Docker for Desktop 里 Windows Container 和 Linux Container 两种 docker 容器化运行时，两种运行时不能同时使用，可以切换，切换过程中数据是不会丢失的，你不可以在 windows container 环境下操作 linux container 的镜像与容器，更不能在 linux container 环境 下操作 windows container 的镜像和容器，两者架构上不一致。&lt;/p&gt;
&lt;p&gt;windows container 是相当于 docker 在 linux 下的原生实现，linux container 是通过 Hyper-V 托管了一个小型虚拟机以实现 linux 环境。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/about/index#windows-container-types&quot;&gt;Windows 容器类型&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;你应该知道, 有两个不同的容器类型 (也称为运行时)。&lt;/p&gt;
&lt;p&gt;Windows Server 容器通过进程和命名空间隔离技术提供应用程序隔离, 这就是这些容器也称为进程隔离的容器的原因。 Windows Server 容器与容器主机和该主机上运行的所有容器共享内核。 这些进程隔离的容器不提供敌意安全边界, 不应用于隔离不受信任的代码。 由于共享内核空间，这些容器要求具有相同的内核版本和配置。&lt;/p&gt;
&lt;p&gt;Hyper-v 隔离通过在高度优化的虚拟机中运行每个容器来扩展 Windows Server 容器提供的隔离。 在此配置中, 容器主机不与同一主机上的其他容器共享其内核。 这些容器旨在托管敌对多租户，并且具有与虚拟机相同的安全保证。 由于这些容器不与主机上的主机或其他容器共享内核, 因此它们可以运行具有不同版本和配置 (受支持版本内) 的内核。 例如, Windows 10 上的所有 Windows 容器都使用 Hyper-v 隔离来利用 Windows Server 内核版本和配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管两者在技术架构上有差异，但是 docker 的基本操作都是适用的，如果你的磁盘不够大网速不够好，不建议直接在自己电脑上尝试 windows container，windows container 大部分是基于 windows-sever 的镜像，动则十几个G，下载镜像都不一定能下载成功。&lt;/p&gt;
&lt;h2 id=&quot;getstarted&quot;&gt;GetStarted&lt;/h2&gt;
&lt;p&gt;部署一个简单的 dotnet framework 应用到 windows 容器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker pull microsoft/iis&lt;/code&gt; 拉一个 iis 的 docker 镜像&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run --rm -p 8080:80 --name=iis microsoft/iis:latest

docker run --it iis powershell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着上面的命令是不是感觉很熟悉啊，下面再看一个 Dockerfile&lt;br/&gt;这是一个 asp.net 的应用的 dockerfile，来自微软的官方&lt;a href=&quot;https://github.com/microsoft/dotnet-framework-docker/blob/master/samples/aspnetapp/Dockerfile&quot;&gt;示例&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM mcr.microsoft.com/dotnet/framework/sdk:4.8 AS build
WORKDIR /app

# copy csproj and restore as distinct layers
COPY *.sln .
COPY aspnetapp/*.csproj ./aspnetapp/
COPY aspnetapp/*.config ./aspnetapp/
RUN nuget restore

# copy everything else and build app
COPY aspnetapp/. ./aspnetapp/
WORKDIR /app/aspnetapp
RUN msbuild /p:Configuration=Release

FROM mcr.microsoft.com/dotnet/framework/aspnet:4.8 AS runtime
WORKDIR /inetpub/wwwroot
COPY --from=build /app/aspnetapp/. ./&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;踩的坑&quot;&gt;踩的坑&lt;/h2&gt;
&lt;p&gt;项目是 AspNetCore 只是项目是 dotnet framework471 的，并且有引用几个 netstandard2.0 的项目，&lt;/p&gt;
&lt;ol readability=&quot;3.212890625&quot;&gt;&lt;li readability=&quot;9.1666666666667&quot;&gt;
&lt;p&gt;在 msbuild 的时候出错，尚未找到解决方法，提了一个 issue 还没回复&lt;br/&gt;&lt;a href=&quot;https://github.com/microsoft/dotnet-framework-docker/issues/315&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/dotnet-framework-docker/issues/315&lt;/a&gt;&lt;br/&gt;看到有人说要引用 “Microsoft.Net.Compilers” 这个包，在项目里加上了这个包的引用还是有问题，这个问题很神奇，本地 &lt;code&gt;dotnet build&lt;/code&gt;/&lt;code&gt;msbuild&lt;/code&gt; 都是正常的&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\MSBuild\Current\Bin\Roslyn\Microsoft.CSharp.Core.targets(59,5):
error MSB6006: &quot;csc.exe&quot; exited with code -2146232576&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;msbuild 有问题之后便想用 &lt;code&gt;dotnet build&lt;/code&gt; 来编译，最初尝试安装 dotnet core 后来发现这个 framework 镜像里已经安装 dotnet core sdk，太好了不用再自己装了，后来用 &lt;code&gt;dotnet build&lt;/code&gt; 代替了 msbuild&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;host 应用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;dotnet 不能执行 dotnet framework 生成的 exe，原本想着像在 linux 下面跑 dotnet core 一样，直接&lt;code&gt;dotnet &amp;lt;xxx.dll&amp;gt;&lt;/code&gt;使用 kestrel 来托管，然而并不能直接运行，起初按错误提示以为要手动加一个 runtimeconfig.json 来指定框架类型及版本，后来才知道 runtimeconfig.json 只支持 dotnetcore，详见&lt;a href=&quot;https://github.com/dotnet/core-setup/issues/7149&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet/core-setup/issues/7149&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;后来还是放到 iis 下面，当时使用的是 &lt;code&gt;microsoft/iis&lt;/code&gt; 这个镜像，发现放上去之后不能运行，报 500 错误，后来又装 dotnetcore-windows-hosting ，还是不行最终在 Event-Log 中发现没有framework471 ...&lt;/li&gt;
&lt;li&gt;后来使用 &lt;code&gt;mcr.microsoft.com/dotnet/framework/aspnet:4.7.1&lt;/code&gt; 这个镜像，然后在安装 dotnetcore-windows-hosting 的时候又是一波多折。。最后先安装了 chocolatey , chocolatey 是 windows 上的一个包管理器，像管理nuget包一样管理你PC上的软件，然后使用 &lt;code&gt;choco install dotnetcore-windowshosting -y&lt;/code&gt; 来安装 dotnetcore-windowshosting 模块。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;最终使用的 Dockerfile 如下：&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM mcr.microsoft.com/dotnet/framework/sdk:4.7.1 AS build

WORKDIR /app

# copy csproj and restore as distinct layers

COPY Projects/*.csproj ./Projects/
COPY nuget.config ./

RUN dotnet restore ./Projects/Projects.csproj

# copy everything else and build app
COPY . .

WORKDIR /app/Projects
RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/framework/aspnet:4.7.1

WORKDIR /inetpub/wwwroot

# install choco
RUN Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
# install dotnetcore-windowshosting
RUN choco install dotnetcore-windowshosting -y

RUN powershell -NoProfile -Command Remove-Item -Recurse C:\inetpub\wwwroot\*

COPY --from=build /app/Projects/out/ ./&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;memo&quot;&gt;Memo&lt;/h2&gt;
&lt;p&gt;折腾起来真是麻烦，可以直接上 dotnetcore 还是直接上 dotnetcore 吧&lt;/p&gt;
&lt;h3 id=&quot;tips&quot;&gt;Tips&lt;/h3&gt;
&lt;p&gt;windows container 里 &lt;code&gt;RUN&lt;/code&gt; 是相当于在 powershell 中执行命令&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 12 Jul 2019 15:26:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>我们有一些服务是 dotnet framework 的，不能直接跑在 docker linux container 下面，最近一直在折腾把它部署在 windows container 下，折腾的有点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/troubleshot-windows-container.html</dc:identifier>
</item>
<item>
<title>python爬虫登陆问题 - 青小记</title>
<link>http://www.cnblogs.com/qing0228/p/11178958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing0228/p/11178958.html</guid>
<description>&lt;p&gt; &lt;span&gt;根据腾讯课堂网页登陆问题进行解说（需要安装谷歌浏览器）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、导入库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、根据腾讯课堂链接，进入页面，获取页面中登陆的xpath，并进行点击操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609670/201907/1609670-20190712225059512-661184860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;driver =&lt;/span&gt;&lt;span&gt;&lt;span&gt; w&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ebdriver.Chrome()
driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://ke.qq.com/course/403521&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;js_login&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;.click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、进入登陆页面之后获取登陆方式，本次选择使用qq进行登陆，获取qq登陆的xpath并进行点击操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609670/201907/1609670-20190712225404546-1727875681.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/h&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;tml/body/div[4]/div/div[2]/div[2]/a[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;).click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4、点击使用账号密码登陆。在该登陆过程中出现以下错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609670/201907/1609670-20190712230226622-1121668809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  主要原因是无法找到我们定位的xpath，需要先找到定位元素所处的frame，并从frame中寻找该元素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609670/201907/1609670-20190712225737999-1484164362.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;driver.switch_to_frame(&lt;/span&gt;&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;login_frame_qq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;引号中添加&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;frame标签中的name或id值
&lt;/span&gt;driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;switcher_plogin&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;).click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、获取到输入账号密码以及登陆位置的xpath。当运行时再次出现定位不到xpath的情况，使用第四步的方法依旧没能成功，提示所在框架不对，估计是跟第4步的frame标签的name相同的原因吧。最后的解决方法是：先回到最外层框架，之后进入要定位元素的框架，最后对账号密码进行定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609670/201907/1609670-20190712231143216-1948553507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;driver.switch_to.default_content()//回到最外层框架
driver.switch_to_frame(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login_frame_qq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)//进入定位元素的框架
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;u&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).clear()
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;u&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入自己的账号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;p&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).clear()
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;p&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入自己的密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6、点击登陆按钮，至此就已经进入网页版的腾讯课堂了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;login_button&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 完整代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

driver &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://ke.qq.com/course/403521&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;js_login&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/html/body/div[4]/div/div[2]/div[2]/a[1]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()

&lt;span data-mce-=&quot;&quot;&gt;driver.switch_to_frame(&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;login_frame_qq&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;)//&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;引号中添加&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;frame标签中的name或id值&lt;br/&gt;driver.find_element_by_xpath(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;//*[@id=&quot;switcher_plogin&quot;]&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;).click()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;

&lt;span data-mce-=&quot;&quot;&gt;driver.switch_to.default_content()//回到最外层框架&lt;br/&gt;driver.switch_to_frame(&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;login_frame_qq&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;)//进入定位元素的框架&lt;br/&gt;driver.find_element_by_xpath(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;//*[@id=&quot;u&quot;]&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;).clear()&lt;br/&gt;driver.find_element_by_xpath(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;//*[@id=&quot;u&quot;]&lt;span data-mce-=&quot;&quot;&gt;').send_keys(&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;输入自己的账号&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;)&lt;br/&gt;driver.find_element_by_xpath(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;//*[@id=&quot;p&quot;]&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;).clear()&lt;br/&gt;driver.find_element_by_xpath(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;//*[@id=&quot;p&quot;]&lt;span data-mce-=&quot;&quot;&gt;').send_keys(&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;输入自己的密码&lt;span data-mce-=&quot;&quot;&gt;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
driver.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;login_button&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 12 Jul 2019 15:26:00 +0000</pubDate>
<dc:creator>青小记</dc:creator>
<og:description>根据腾讯课堂网页登陆问题进行解说（需要安装谷歌浏览器）： 1、导入库 2、根据腾讯课堂链接，进入页面，获取页面中登陆的xpath，并进行点击操作 3、进入登陆页面之后获取登陆方式，本次选择使用qq进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing0228/p/11178958.html</dc:identifier>
</item>
<item>
<title>Jpa 笔记 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11178879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11178879.html</guid>
<description>&lt;h3 id=&quot;orm-思想&quot;&gt;ORM 思想&lt;/h3&gt;
&lt;p&gt;对象关系映射, 建立实体类和表的关系映射关系, 实体类和表中字段的映射关系,我们操作实体类底层是操作数据表, 进而自动的拼接出SQL语句&lt;/p&gt;
&lt;h3 id=&quot;jpa规范&quot;&gt;Jpa规范&lt;/h3&gt;
&lt;p&gt;Jpa(Java Persistence Api) java持久层的api,是SUN公司提出的一套规范,也就是说,是由接口和抽象类组成,jpa本身不干活,真正干活的是hibernate,toplink等等对规范具体实现的框架, 有了这套规范之后,我们是面向这套规范编程的,也就是说,当我们想把项目中的Hibernate替换成toplink,我们的java代码是不需要修改的,而仅仅修改配置文件,切换jar包&lt;/p&gt;
&lt;h3 id=&quot;上手-jpa规范&quot;&gt;上手: jpa规范&lt;/h3&gt;
&lt;h4 id=&quot;常见的注解&quot;&gt;常见的注解&lt;/h4&gt;
&lt;p&gt;我们通过注解完成两件事:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实体类和数据表之间的关系的映射&lt;/li&gt;
&lt;li&gt;实例类属性和数据表字段之前的映射&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;添加在类头上的注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 声明此类是实体类
@Entity
// 声明此类是实体类
@Table(name = &quot;表名&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;标记主键&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;IDENTITY&lt;/td&gt;
&lt;td&gt;自增(要求底层的数据库支持自增如mysql, Oracle就不支持)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SEQUENCE&lt;/td&gt;
&lt;td&gt;序列(要求底层的数据库支持序列, 如Oracle)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;TABLE&lt;/td&gt;
&lt;td&gt;JPA的支援, JPA会帮我们生成另一张表, 里面记载了本表的记录数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AUTO&lt;/td&gt;
&lt;td&gt;自适应,让程序根据运行的环境自动选择策略, 我的程序选择了 TABLE策略&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Id
@GeneratedValue(strategy = GenerationType.AUTO)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实体类属性和表中的字段的映射&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Column(name = &quot;表中的字段名&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;进行crud的开发步骤&quot;&gt;进行CRUD的开发步骤:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;加载配置文件, 得到实体管理类工厂&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;myJpa = Persistence.createEntityManagerFactory(&quot;myJpa&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过实体管理类工厂获取实体管理器&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;myJpa.createEntityManager()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取事务对象, 开启事务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; EntityTransaction transaction = entityManager.getTransaction();
 transaction.begin();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CRUD&lt;/li&gt;
&lt;li&gt;提交事务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; transaction.commit();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; entityManager.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意点: 1. 如果不添加事务, 是不会持久化的 2. 获取实体管理类工厂的方法是耗时的,而且实体管理类工厂可重复使用,因此把他抽取出去, 类一加载就执行&lt;/p&gt;
&lt;p&gt;常用方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;public void persist(Object entity);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据主键Id查找&lt;code&gt;public &amp;lt;T&amp;gt; T getReference(Class&amp;lt;T&amp;gt; entityClass, Object primaryKey);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据主键Id查找&lt;code&gt;public &amp;lt;T&amp;gt; T find(Class&amp;lt;T&amp;gt; entityClass, Object primaryKey);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;public void remove(Object entity);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;find()和getReference()&lt;/code&gt;的区别:&lt;br/&gt;find立即执行,返回实体类对象,而和getReference返回的是实体类的代理对象, 懒加载,当我使用对象的属性时才执行查询语句&lt;/p&gt;
&lt;h4 id=&quot;jpql&quot;&gt;jpql&lt;/h4&gt;
&lt;p&gt;jpql: Java Persistence Query Language 根据实体类和属性进行查询&lt;/p&gt;
&lt;p&gt;其中jpql没有select * 这种写法,而是直接省去了, 因为是面向对象的查询语言, 所以它的查询语句向下面这样写&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; from 带包名的类的全路径/直接写类名&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;from  类名 order by id desc/asc&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;统计数量&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;select count(id) from 类名&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;带条件的查询&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;EntityManager entityManager = JpaUtils.getEntityManager();
EntityTransaction transaction = entityManager.getTransaction();
transaction.begin();
// 查询全部
String jpql = &quot;from 类名 where name like ?&quot;;
//  String jpql = &quot;from  类名&quot;;   可省略包名
Query query = entityManager.createQuery(jpql);
// 参数1: 占位符的位置
// 参数2: 参数的值
query.setParameter(1,&quot;张%&quot;);
query.getResultList().forEach(System.out::println);
transaction.commit();
entityManager.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分页查询&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; EntityManager entityManager = JpaUtils.getEntityManager();
EntityTransaction transaction = entityManager.getTransaction();
transaction.begin();
// 查询全部
String jpql = &quot;from 类名&quot;;
Query query = entityManager.createQuery(jpql);
// 对分页的参数赋值
// 起始索引
query.setFirstResult(0);
// 分页参数, 每次查询两条
query.setMaxResults(2);
// 查询,斌封装结果集
List resultList = query.getResultList();
resultList.forEach(System.out::println);
transaction.commit();
entityManager.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spring-data-jpa&quot;&gt;Spring Data Jpa&lt;/h3&gt;
&lt;p&gt;SpringDataJpa是Spring对jpa的整合,封装,基于SpringDataJpa的规范我们可以更方便的进行持久层的操作, SpringDataJpa底层干活的是Hibernate框架&lt;/p&gt;
&lt;h4 id=&quot;开发步骤&quot;&gt;开发步骤&lt;/h4&gt;
&lt;p&gt;被spring整合后,相关的配置可通过spring.jpa....设置&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;做好实体类和数据表之间的关系的映射&lt;/li&gt;
&lt;li&gt;面向接口编程,我们只要自己新建一个接口,并且继承JpaRepository和JpaSpecificationExecutor这两个接口就可以使用它的方法,而不需要关心实现类如何,就像下面:具体的实现类会通过JDK的动态代理为我们自动生成,&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface CustomerRepository extends JpaRepository&amp;lt;Customer,Long&amp;gt;, JpaSpecificationExecutor&amp;lt;Customer&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JpaRepository(继承自CRUDRepository) 封装了基本的CRUD&lt;/li&gt;
&lt;li&gt;JpaSpecificationExecutor 封装了复杂查询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的CRUD&lt;br/&gt;当我们使用自定义的Repository点一下的时,基本的CRUD基本上打眼一看就知道怎么使用了, 下面说一下,比较相似的方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;getOne()&lt;/td&gt;
&lt;td&gt;根据Id获取单个实体类,底层使用的是Jpa的&lt;code&gt;getReference()&lt;/code&gt; 懒加载&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;findOne()&lt;/td&gt;
&lt;td&gt;同样是根据Id获取单个实体,立即加载&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;save()&lt;/td&gt;
&lt;td&gt;更新 若id存在 / 新增 若id为空&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;支持-自定义sql-jpql-方法命名规则-查询&quot;&gt;支持 自定义sql / jpql / 方法命名规则 查询&lt;/h4&gt;
&lt;p&gt;使用注解&lt;code&gt;@Query&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Query(value = &quot;select * from  Customer where name = ?&quot;, nativeQuery = true)
public Customer findByNameAndSQL(String name);

// 查询全部
@Query(value = &quot;select * from  Customer&quot;, nativeQuery = true)
public List&amp;lt;Customer&amp;gt; findAllBySQL();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;@Query的第三个参数默认是false&lt;/code&gt; 表示不是sql查询,而是jpql查询&lt;/p&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// jpql 查询全部
@Query(value = &quot;from  Customer where name =?1&quot;, nativeQuery = false)
public Customer findAllByNameAndJpql();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringDataJpa对jpql再次进行了封装,支持方法命名规则查询:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;根据某个字段查询&lt;/td&gt;
&lt;td&gt;find实体类名By字段名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;模糊查询&lt;/td&gt;
&lt;td&gt;find实体类名By字段名Like , 注意传参时不要忘了添加%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;多条件并列查询&lt;/td&gt;
&lt;td&gt;find实体类名By字段名And字段名 ,使用and关键字隔开&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;多条件或查询&lt;/td&gt;
&lt;td&gt;find实体类名By字段名Or字段名 ,使用Or关键字隔开&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;复杂查询&quot;&gt;复杂查询&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Optional&amp;lt;T&amp;gt; findOne(@Nullable Specification&amp;lt;T&amp;gt; spec);

List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; spec);

//Page 是 SpringDataJpa提供的
Page&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; spec, Pageable pageable);

// 查询条件spec
// 排序条件 sort
List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; spec, Sort sort);

// 按照条件统计
long count(@Nullable Specification&amp;lt;T&amp;gt; spec);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他们的公共入参都有&lt;code&gt;Specification&lt;/code&gt; 这是个接口,我们需要自己实现, 重写它的抽象方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; Predicate toPredicate(Root&amp;lt;T&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder criteriaBuilder);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;root: 是我们查询的根对象(查询的任何属性都能从根对象中获取)&lt;/li&gt;
&lt;li&gt;CriteriaQuery: 顶层的查询对象&lt;/li&gt;
&lt;li&gt;CriteriaBuilder: 查询的构造器, 封装了很多查询条件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例:&lt;br/&gt;分页查询&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 当前查询第几页, 每一页查询的条数
Pageable pageable =  PageRequest.of(0,2);

Page&amp;lt;Customer&amp;gt; page =  customerRepository.findAll((root, query, criteriaBuilder)-&amp;gt;{
    return null;
}, pageable);

System.out.println(&quot;page.getTotalElements():  &quot;+        page.getTotalElements()); // 总条数
System.out.println(&quot;page.getTotalPages():  &quot;+        page.getTotalPages()); // 总页数
page.getContent().forEach(System.out::println);  // 当前页结果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排序&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 *  参数1 ; 正序 / 倒叙
 *  参数2 : 属性名
 */
Sort orders = new Sort(Sort.Direction.DESC,&quot;id&quot;);

List&amp;lt;Customer&amp;gt; list=  customerRepository.findAll((root,query,criteriaBuilder)-&amp;gt;{
    Path&amp;lt;Object&amp;gt; name = root.get(&quot;name&quot;);
    Predicate like = criteriaBuilder.like(name.as(String.class), &quot;武%&quot;);
    return like;
},orders);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模糊查询&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Customer&amp;gt; list=  customerRepository.findAll((root,query,criteriaBuilder)-&amp;gt;{
    Path&amp;lt;Object&amp;gt; name = root.get(&quot;name&quot;);
    Predicate like = criteriaBuilder.like(name.as(String.class), &quot;武%&quot;);
    return like;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多条件查询&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 *  root 获取属性
 *  criteriaBuilder: 构造查询条件
 */
Optional&amp;lt;Customer&amp;gt; customer=  customerRepository.findOne((root,query,criteriaBuilder)-&amp;gt;{
      Path&amp;lt;Object&amp;gt; name = root.get(&quot;name&quot;);
      Path&amp;lt;Object&amp;gt; industry = root.get(&quot;industry&quot;);
      Predicate namepre = criteriaBuilder.equal(name, &quot;张三&quot;);
      Predicate indpre = criteriaBuilder.equal(industry, &quot;学生&quot;);

    /* 组合条件
        1. 满足条件1和条件2
        2. 满足条件1或条件2
    * */
   Predicate andpre = criteriaBuilder.and(namepre, indpre);
  //  Predicate or = criteriaBuilder.and(namepre, indpre);
    //  以 或的条件查询
    return andpre;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分页两种: 带条件的分页&lt;code&gt;findAll(Specification spec,Pageable pageable)&lt;/code&gt; 和不带条件的分页&lt;code&gt;findAll(Pageable pageable)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此外: 对于criteriaBuilder的equals方法,可以直接使用path对象,但是对于 &lt;code&gt;gt lt le like&lt;/code&gt;我们需要分步, 1. 得到path对象,2. 根据path对象指定比较的参数类型在进行下一步比较,因为可能比较的是字符串, 也可能是数字&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;多表操作的级联相关&quot;&gt;多表操作的级联相关&lt;/h3&gt;
&lt;h4 id=&quot;一对多配置&quot;&gt;一对多配置&lt;/h4&gt;
&lt;p&gt;数据库表之间难免会出现彼此的约束, 如商品分类表和商品表之间,就是典型的一对多的关系,同一个分类下有多种不同的商品,下面就是jpa如何通过注解控制一对多的关系&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;双方都有一个彼此之间的引用, 如在one的一方,维护着多的一方的一个集合,一般使用HashSet,而在many的一方维护着一的一方的引用&lt;/li&gt;
&lt;li&gt;在一的一方使用注解&lt;code&gt;@OneToMany&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在多的一方使用注解&lt;code&gt;@ManyToOne&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;维护主键的一方需要使用&lt;code&gt;@JoinColumn(name = &quot;customer_id&quot;,referencedColumnName = &quot;id&quot;)&lt;/code&gt; 注解, 作用是指明外键列名,以及引用的主键列名&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于主键的维护:&lt;br/&gt;一般我们会选在让多的一方维护外键,不是因为一的一方不能维护,在一对多的关系中,双方都可以进行主键的维护,并且我们把这种关系叫做双向管理,但是双方都维护主键,就会使得多出一条update语句,产生资源的浪费,原因如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓维护主键,就比如说我们通过jpa的save方法插入主表中的实体1和从表中的实体2,如果我们没有进行双方之间的关联,两条数据会被添加进数据库,但是外键部分却为null; 因此我们可以把维护主键看作是负责更新外键字段,这时如果双方都维护的话,就会出现两次update外键字段的sql&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结: 以下是OneToMany的最终方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;one:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mappedBy通过他指明,自己放弃维护外键,而参考Many端对外键的维护的实现
@OneToMany(mappedBy= &quot;customer&quot;) 
private Set&amp;lt;LinkMan&amp;gt; linkManSet = new HashSet&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Many&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;targetEntity: 指明One的一方的字节码
name: 本表中的外键的列名, 因为在多的一方维护的外键
referencedColumnName:  外键引用的主键的列名
@ManyToOne(targetEntity:  = Customer.class)
@JoinColumn(name = &quot;customer_id&quot;,referencedColumnName = &quot;id&quot;)
private Customer customer;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一对多的级联cascade&quot;&gt;一对多的级联&lt;code&gt;cascade&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;级联操作再One的一端进行配置&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ALL&lt;/td&gt;
&lt;td&gt;级联所有(推荐)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PERSIST&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MERGE&lt;/td&gt;
&lt;td&gt;更新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REMOVE&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @OneToMany(mappedBy = &quot;customer&quot;,cascade = CascadeType.ALL,fetch = FetchType.EAGER)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;级联保存: 同时存在One和Many两个对象,我们在保存One的同时级联保存Many方的对象&lt;/p&gt;
&lt;p&gt;级联删除:&lt;br/&gt;情况1: One的一方在维护主键, 这是的级联删除就会分两步走 ,首先删除外键,然后删除One的一方,同时删除One级联的去全部Many方&lt;/p&gt;
&lt;p&gt;情况2: One的一方不再维护主键,不能级联删除&lt;/p&gt;
&lt;h4 id=&quot;多对多配置&quot;&gt;多对多配置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;多对多配置中,同样需要一方主动的放弃对外键维护权&lt;/li&gt;
&lt;li&gt;双方维护着代表对方的set集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子: User和Role 多对多的关系&lt;/p&gt;
&lt;p&gt;在User端,主动放弃对外键的维护权&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ManyToMany(mappedBy = &quot;users&quot;,cascade = CascadeType.ALL)
public Set&amp;lt;Role&amp;gt; roles = new HashSet&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Role端,维护着外键, 负责对中间表上外键的更新的操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 *  配置多对多
 *   1. 声明关系的配置
 *   2. 配置中间表(包含两个外键)
 *   targetEntity: 对方的 实体类字节码
 *
 */
@ManyToMany(targetEntity =User.class)
@JoinTable(
        name = &quot;user_role&quot;,// name 中间表名称
        joinColumns = {@JoinColumn(name = &quot;sys_role_id&quot;,referencedColumnName = &quot;role_id&quot;)}, // 当前对象,在中间表中的外键名, 以及参照的本表的哪个主键名
        inverseJoinColumns = {@JoinColumn(name = &quot;sys_user_id&quot;, referencedColumnName = &quot;user_id&quot;)} // 对方对象在中间表的外键
)
public Set&amp;lt;User&amp;gt; users = new HashSet&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对象导航查询&quot;&gt;对象导航查询&lt;/h4&gt;
&lt;p&gt;所谓对象导航查询,就是首先使用jpa为我们提供的Repository查询得到结果对象,再通过该对象,使用该对象的get方法,进而查询出它关联的对象的操作&lt;/p&gt;
&lt;p&gt;在一对多的关系中, get的属性是 Set集合, 而在多对一的关系中,get的属性是它维护的那个One端的引用&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;一查多&lt;/td&gt;
&lt;td&gt;默认延迟加载,因为有可能一下子级联查询出成百上千的数据,但是我们却不用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;多查一&lt;/td&gt;
&lt;td&gt;默认立即查询,多查一条数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果想更改默认的加载模式, 就在@OneToMany(一的一方)注解上添加属性&lt;code&gt;fetch = FetchType.EAGER&lt;/code&gt;&lt;br/&gt;属性 | 作用&lt;br/&gt;---|---&lt;br/&gt;EAGER | 立即加载&lt;br/&gt;LAZY | 延迟加载&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 15:01:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>ORM 思想 对象关系映射, 建立实体类和表的关系映射关系, 实体类和表中字段的映射关系,我们操作实体类底层是操作数据表, 进而自动的拼接出SQL语句 Jpa规范 Jpa(Java Persisten</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11178879.html</dc:identifier>
</item>
<item>
<title>对比 C++ 和 Python，谈谈指针与引用 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/11178705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/11178705.html</guid>
<description>&lt;p&gt;花下猫语：本文是学习群内 &lt;strong&gt;樱雨楼&lt;/strong&gt; 小姐姐的投稿。之前已发布过她的一篇作品《&lt;a href=&quot;https://mp.weixin.qq.com/s/Be4tHnR0BY-C__xoPPBjhQ&quot;&gt;当谈论迭代器时，我谈些什么？&lt;/a&gt;》，大受好评。本文依然是对比 C++ 与 Python，来探讨编程语言中极其重要的概念。祝大家读有所获，学有所成！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g4xcd8e8sqj21g80yl41g.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;樱雨楼 | &lt;strong&gt;原创作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;豌豆花下猫 | &lt;strong&gt;编辑润色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文原创并首发于公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】，未经授权，请勿转载。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/k0VNL6uyvBHT7PWdzEPROQ&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/k0VNL6uyvBHT7PWdzEPROQ&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;0 引言&lt;/h2&gt;
&lt;p&gt;指针（Pointer）是 C、C++ 以及 Java、Go 等语言的一个非常核心且重要的概念，而引用（Reference）是在指针的基础上构建出的一个同样重要的概念。&lt;/p&gt;
&lt;p&gt;指针对于任何一个编程语言而言都是必须且重要的，虽然 Python 对指针这一概念进行了刻意的模糊与限制，但指针对于 Python 而言依然是一个必须进行深入讨论的话题。&lt;/p&gt;
&lt;p&gt;本文基于 C++ 与 Python，讨论了 Python 中与指针及引用相关的一些行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g4xc5k233pg20b405w4mc.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是指针为什么需要指针&quot;&gt;1 什么是指针？为什么需要指针？&lt;/h2&gt;
&lt;p&gt;指针有两重含义：&lt;/p&gt;
&lt;p&gt;（1）指代某种数据类型的指针类型，如整形指针类型、指针指针类型&lt;/p&gt;
&lt;p&gt;（2）指代一类存放有内存地址的变量，即指针变量&lt;/p&gt;
&lt;p&gt;指针的这两重含义是紧密联系的：作为一种变量，通过指针可以获取某个内存地址，从而为访问此地址上的值做好了准备；作为一种类型，其决定了内存地址的正确偏移长度，其应等于当前类型的单位内存大小。&lt;/p&gt;
&lt;p&gt;如果一个指针缺少指针类型，即 void *，则显然，其虽然保存了内存地址，但这仅仅是一个起点地址，指针会因为无法获知从起点向后进行的偏移量，从而拒绝解指针操作；而如果一个指针缺少地址，即 nullptr，则其根本无法读取特定位置的内存。&lt;/p&gt;
&lt;p&gt;指针存在的意义主要有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;承载通过 malloc、new、allocator 等获取的动态内存&lt;/li&gt;
&lt;li&gt;使得 pass-by-pointer 成为可能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;pass-by-pointer 的好处包括但不限于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免对实参无意义的值拷贝，大幅提高效率&lt;/li&gt;
&lt;li&gt;使得对某个变量的修改能力不局限于变量自身的作用域&lt;/li&gt;
&lt;li&gt;使得 swap、移动构造函数、移动赋值运算等操作可以仅针对数据结构内部的指针进行操作，从而避免了对临时对象、移后源等对象的整体内存操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此可见，&lt;strong&gt;与指针相关的各操作对于编程而言都是必须的或十分重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g4xc6ogkvtj20sg0f4755.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;c中的引用&quot;&gt;2 C++中的引用&lt;/h2&gt;
&lt;p&gt;在 C++ 中，引用具有与指针相似的性质，但更加隐形与严格。C++ 的引用分为以下两种：&lt;/p&gt;
&lt;h3 id=&quot;左值引用&quot;&gt;2.1 左值引用&lt;/h3&gt;
&lt;p&gt;左值引用于其初始化阶段绑定到左值，且不存在重新绑定。&lt;/p&gt;
&lt;p&gt;左值引用具有与被绑定左值几乎一样的性质，其唯一的区别在于 decltype 声明：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int numA = 0, &amp;amp;lrefA = numA;  // Binding an lvalue
cout &amp;lt;&amp;lt; ++lrefA &amp;lt;&amp;lt; endl;      // Use the lvalue reference as lvalue &amp;amp; rvalue
decltype(lrefA) numB = 1;     // Error!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;左值引用常用于 pass-by-reference：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void swap(int &amp;amp;numA, int &amp;amp;numB)
{
    int tmpNum = numA;
    numA = numB;
    numB = tmpNum;
}

int main()
{
    int numA = 1, numB = 2;
    swap(numA, numB);
    cout &amp;lt;&amp;lt; numA &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; numB &amp;lt;&amp;lt; endl;  // 2 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;右值引用&quot;&gt;2.2 右值引用&lt;/h3&gt;
&lt;p&gt;右值引用于其初始化阶段绑定到右值，其常用于移动构造函数和移动赋值操作。在这些场合中，移动构造函数和移动赋值操作通过右值引用接管被移动对象。&lt;/p&gt;
&lt;p&gt;右值引用与本文内容无关，故这里不再详述。&lt;/p&gt;
&lt;h2 id=&quot;python中的引用&quot;&gt;3 Python中的引用&lt;/h2&gt;
&lt;h3 id=&quot;python不存在引用&quot;&gt;3.1 Python不存在引用&lt;/h3&gt;
&lt;p&gt;由上文讨论可知，虽然“引用”对于 Python 而言是一个非常常用的术语，但这显然是不准确的——由于 Python 不存在对左/右值的绑定操作，故不存在左值引用，更不存在右值引用。&lt;/p&gt;
&lt;h3 id=&quot;python的指针操作&quot;&gt;3.2 Python的指针操作&lt;/h3&gt;
&lt;p&gt;不难发现，虽然 Python 没有引用，但其变量的行为和指针的行为具有高度的相似性，这主要体现在以下方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在任何情况下（包括赋值、实参传递等）均不存在显式值拷贝，当此种情况发生时，只增加了一次引用计数&lt;/li&gt;
&lt;li&gt;变量可以进行重绑定（对应于一个不含顶层 const（top-level const）的指针）&lt;/li&gt;
&lt;li&gt;在某些情况下（下文将对此问题进行详细讨论），可通过函数实参修改原值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此可见，&lt;strong&gt;Python 变量更类似于（某种残缺的）指针变量，而不是引用变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g4xc891rijj21hc0swjux.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造函数返回指针&quot;&gt;3.2.1 构造函数返回指针&lt;/h3&gt;
&lt;p&gt;对于 Python 的描述，有一句非常常见的话：“一切皆对象”。&lt;/p&gt;
&lt;p&gt;但在这句话中，有一个很重要的事实常常被人们忽略：对象是一个值，不是一个指针或引用。&lt;/p&gt;
&lt;p&gt;所以，这句话的准确描述应该更正为：“一切皆（某种残缺的）指针”。虽然修改后的描述很抽象，但这是更准确的。&lt;/p&gt;
&lt;p&gt;而由于对象从构造函数而来，至此我们可知：&lt;strong&gt;Python 的构造函数将构造匿名对象，且返回此对象的一个指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是 Python 与指针的第一个重要联系。&lt;/p&gt;
&lt;p&gt;用代码描述，对于Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sampleNum = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其不类似于 C++ 代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int sampleNum = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而更类似于：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int __tmpNum = 0, *sampleNum = &amp;amp;__tmpNum;

// 或者：
shared_ptr&amp;lt;int&amp;gt; sampleNum(new int(0));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setitems__操作将隐式解指针&quot;&gt;3.2.2 __setitems__操作将隐式解指针&lt;/h3&gt;
&lt;p&gt;Python 与指针的另一个重要联系在于 Python 的&lt;strong&gt;隐式解指针行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 Python 不存在显式解指针操作，但（有且仅有）__setitems__操作将进行隐式解指针，通过此方法对变量进行修改等同于通过解指针操作修改变量原值。&lt;/p&gt;
&lt;p&gt;此种性质意味着：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任何不涉及__setitems__的操作都将成为指针重绑定。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于Python代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;numList = [None] * 10

# Rebinding
numList = [None] * 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其相当于：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int *numList = new int[10];

// Rebinding
delete[] numList;
numList = new int[5];
delete[] numList;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，对 numList 的非__setitems__操作，导致 numList 被绑定到了一个新指针上。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;任何涉及__setitems__的操作都将成为解指针操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 Python 对哈希表的高度依赖，“涉及__setitems__的操作”在 Python 中实际上是一个非常广泛的行为，这主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对数组的索引操作&lt;/li&gt;
&lt;li&gt;对哈希表的查找操作&lt;/li&gt;
&lt;li&gt;涉及__setattr__的操作（由于 Python 将 attribute 存储在哈希表中，所以__setattr__操作最终将是某种__setitems__操作）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们用一个稍复杂的例子说明这一点：&lt;/p&gt;
&lt;p&gt;对于以下Python代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Complex(object):
    def __init__(self, real = 0., imag = 0.):
        self.real = real
        self.imag = imag

    def __repr__(self):
        return '(%.2f, %.2f)' % (self.real, self.imag)

def main():
    complexObj = Complex(1., 2.)
    complexObj.real += 1
    complexObj.imag += 1
    # (2.00, 3.00)
    print(complexObj)

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g4xcaddxjbg20b405zqv5.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其相当于：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Complex
{
public:
    double real, imag;
    Complex(double _real = 0., double _imag = 0.): real(_real), imag(_imag) {}
};

ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;os, const Complex &amp;amp;complexObj)
{
    return os &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; complexObj.real &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; complexObj.imag &amp;lt;&amp;lt; &quot;)&quot;;
}

int main()
{
    Complex *complexObj = new Complex(1., 2.);
    complexObj-&amp;gt;real++;
    complexObj-&amp;gt;imag++;
    cout &amp;lt;&amp;lt; *complexObj &amp;lt;&amp;lt; endl;
    delete complexObj;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，无论是 int、float 这种简单的 Python 类型，还是我们自定义的类，其构造行为都类似使用 new 构造对象并返回指针。&lt;/p&gt;
&lt;p&gt;且在 Python 中任何涉及“.”和“[]”的操作，都类似于对指针的“-&amp;gt;”或“*”解指针操作。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;4 后记&lt;/h2&gt;
&lt;p&gt;本文探讨了 Python 变量与指针、引用两大概念之间的关系，主要论证了“&lt;strong&gt;Python 不存在引用&lt;/strong&gt; ”以及“&lt;strong&gt;Python 变量的行为类似于某种残缺的指针&lt;/strong&gt; ”两个论点。&lt;/p&gt;
&lt;p&gt;所有论点均系作者个人观点，如有错误，恭迎指正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bly1g2aiq1kpa8j21hc0nmgs4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 14:11:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>花下猫语：本文是学习群内 樱雨楼 小姐姐的投稿。之前已发布过她的一篇作品《 '当谈论迭代器时，我谈些什么？' 》，大受好评。本文依然是对比 C++ 与 Python，来探讨编程语言中极其重要的概念。祝</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/11178705.html</dc:identifier>
</item>
<item>
<title>客户端持久化数据库---indexedDB使用 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11178623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11178623.html</guid>
<description>&lt;p&gt;一：什么是indexedDB数据库？&lt;/p&gt;
&lt;p&gt;indexedDB是浏览器中的事务类型对象存储数据库。indexedDB适合大量的结构的数据存储。&lt;/p&gt;
&lt;p&gt;适用场景：当数据量不是很大的时候，我们可以使用sessionStorage或LocalStorage来进行存储，但是当数据量非常大的时候，我们需要使用本地数据库来存储，因此这个时候 indexedDB 浏览器数据库应运而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;indexedDB 有如下特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）异步的；indexedDB打开数据库或获取数据的时候都是异步的，也就是说它不会堵塞浏览器操作。异步就是为了防止大量数据的读写操作，防止网页变慢或卡顿。&lt;/p&gt;
&lt;p&gt;2）键值对存储。indexedDB内部采用对象仓库(object store) 来存放数据的，所有类型的数据都可以直接存储。在对象仓库中，&lt;br/&gt;数据以 &quot;键值对&quot; 的形式保存，每一个数据记录都有对应的主键，主键是不可重复的。&lt;/p&gt;
&lt;p&gt;3）支持事务型的。indexedDB执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败。&lt;/p&gt;
&lt;p&gt;4）同源限制。indexedDB有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问。&lt;/p&gt;
&lt;p&gt;5）存储空间大。存储空间可以达到几百兆甚至更多。&lt;/p&gt;
&lt;p&gt;6）支持二进制存储。它不仅可以存储字符串，而且还可以存储二进制数据(ArrayBuffer对象或Blob对象)。&lt;/p&gt;

&lt;p&gt;2.1 打开或创建数据库&lt;/p&gt;
&lt;p&gt;使用indexedDB的第一步是打开我们的数据库，使用 indexedDB.open()方法，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;indexedDB数据库使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; request &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.indexedDB.open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;my-database&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    console.log(request);
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印 如上的 信息，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712213612486-270877043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法接收2个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在的话，就会新建该数据库。第二个参数是一个整数，它表示的是数据库的版本。如果省略第二个参数的话，如果是新建数据库的话，默认为1. 如果是打开已有的数据库的话，默认就为当前的版本。&lt;/p&gt;
&lt;p&gt;数据库被创建完成后，我们可以打开我们的控制台 -&amp;gt; application -&amp;gt; indexedDB 下 就有 我们刚刚的 my-database 数据库了，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712213654848-98424646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面打印的信息我们可以看到，创建一个数据库完成后，该实列有 onerror, onsuccess, onupgradeneeded 监听函数。及 result 属性值。&lt;/p&gt;
&lt;p&gt;indexedDB.open() 方法返回的是一个IDBRequest对象，代表一个请求连接数据库的请求对象。该对象通过三种事件：onerror、onsuccess、onupgradeneeded 处理打开数据库的操作结果的。我们可以通过监听请求对象的 onsuccess 和 onerror 事件来定义连接成功或失败需要执行的方法。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
  request.onerror &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'数据库打开报错'&lt;span&gt;);
  }
  request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
    console.log(event.target);
    db &lt;/span&gt;=&lt;span&gt; request.result;
    console.log(&lt;/span&gt;'数据库打开成功'&lt;span&gt;);
  }
  request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
    console.log(&lt;/span&gt;'数据库升级事件'&lt;span&gt;);
    console.log(event.target);
    db &lt;/span&gt;=&lt;span&gt; event.target.result;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码执行的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712213746678-1516783734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们可以看到，会执行我们的 onsuccess的方法，但是 onupgradeneeded 是不会执行的，该监听函数只监听当当前的版本号升级的时候才会被触发，也就是说，数据库的版本号更改为大于当前的数据库的版本才会被执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：从上面我们也可以看到 event.target === request 实列对象.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们现在把数据库的版本号升级到2的时候，之前的版本号是1，现在数据库的版本升级了，就会触发 onupgradeneeded 事件，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(&lt;/span&gt;'数据库升级事件'&lt;span&gt;);
  console.log(event.target);
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712213838192-94334217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.2 创建对象仓库(或叫创建表)&lt;/p&gt;
&lt;p&gt; 如上我们的indexedDB数据库新建完成后，我们现在要做的事情就行新建表格了。不过在indexedDB中没有数据库表，而叫对象仓库，不过它的作用就相当于一个数据库表。它使用的 createObjectStore 来创建的，如下代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; store;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('Users'&lt;span&gt;)) {
    store &lt;/span&gt;= db.createObjectStore('Users', {keyPath: 'id', autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  }
  console.log(&lt;/span&gt;'创建对象仓库成功'&lt;span&gt;);
  console.log(store);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，db.createObjectStore 方法接收2个参数，第一个为对象的仓库名(也可以理解我们之前的数据库表名)，第二个参数为可选参数，值为一个js对象，该对象中的 keyPath属性为主键，autoIncrement 属性为 true，表示主键值自增。&lt;/p&gt;
&lt;p&gt;db.objectStoreNames.contains('Users') 的含义：是否包含该对象仓库名(或叫表名)。如果不包含就创建一个。&lt;/p&gt;

&lt;p&gt;2.3 创建索引&lt;/p&gt;
&lt;p&gt;在indexedDB中，我们使用 createIndex 来创建它的索引。通过数据对象的某个属性来创建索引，在数据库中进行检索数据的时候，我们只能通过被设置为索引的属性来进行检索的。&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; store;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('newUsers'&lt;span&gt;)) {
    store &lt;/span&gt;= db.createObjectStore('newUsers', {keyPath: 'id', autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  }
  console.log(store);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建索引&lt;/span&gt;
  store.createIndex('userIndex', 'userName', { unique: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
  store.createIndex(&lt;/span&gt;'userEmail', 'email', { unique: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  console.log(&lt;/span&gt;'创建索引成功'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码：store.createIndex 方法接收三个参数，第一个为索引名，第二个为数据对象的属性，第三个参数是可选参数，值为一个js对象，该对象中的 unique 属性值为true，代表该索引值是唯一的，不可以相同的。如果为false的话，则可以相同。&lt;/p&gt;
&lt;p&gt;索引创建完成后，我们需要事务操作了。&lt;/p&gt;

&lt;p&gt;2.4 新增数据&lt;/p&gt;
&lt;p&gt;在indexedDB中，我们能够使用事务来进行数据库的操作，事务有三个模式。&lt;/p&gt;
&lt;p&gt;1. readOnly: 只读&lt;br/&gt;2. readwrite: 可读可写&lt;br/&gt;3. versionchange: 数据库版本变化&lt;/p&gt;
&lt;p&gt;我们创建一个事务时，需要选择一种模式，如果不指定的话，则默认为只读模式。比如代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['customers'], 'readwrite');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建事务我们使用 db.transaction方法。该方法接收2个参数，第一个参数是字符串或数组，字符串是一个对象的仓库名。数组则是由对象仓库名组成的数组。第二个参数是事务模式。比如上面的模式是只读，或 可读可写。&lt;/p&gt;
&lt;p&gt;新增数据指的是向对象仓库写入数据记录，这需要通过事务完成。该方法接收一个参数，保存到对象仓库中的对象。&lt;br/&gt;如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; store;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('newUsers'&lt;span&gt;)) {
    store &lt;/span&gt;= db.createObjectStore('newUsers', {keyPath: 'id', autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  }
  console.log(store);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建索引&lt;/span&gt;
  store.createIndex('userIndex', 'userName', { unique: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
  store.createIndex(&lt;/span&gt;'userEmail', 'email', { unique: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  console.log(&lt;/span&gt;'创建索引成功'&lt;span&gt;);
}
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);
  objStore.add({name: &lt;/span&gt;'a', age: 10&lt;span&gt;});
  objStore.add({name: &lt;/span&gt;'b', age: 20&lt;span&gt;});
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们使用 var transaction = db.transaction(['newUsers'], 'readwrite'); 代码来创建一个事务，第一个参数 'newUsers' 是对象仓库名，是我们之前在 onupgradeneeded 函数里面创建仓库的。事务新建以后，我们使用 transaction.objectStore('newUsers') 这个方法，拿到 IDBObjectStore 对象，再通过表格对象的add()方法，向表格写入一条记录。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214406408-1699152748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.5 读取数据&lt;/p&gt;
&lt;p&gt; 读取数据也是通过事务完成的。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取数据&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; req = objStore.get(1&lt;span&gt;);
  req.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (req.result) {
      console.log(&lt;/span&gt;'已经查询到数据为：'&lt;span&gt;);
      console.log(req.result);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'未查询到数据'&lt;span&gt;);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面代码中，objStore.get()方法用于读取数据，参数是主键的值。比如我们来查看下我们的主键key在我们的Application下有如下key值；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214452682-1745991600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们获取的key = 1；因此打印的效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214509164-752075663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.6 遍历数据&lt;/p&gt;
&lt;p&gt;如果我们需要遍历整个存储空间的数据时，我们就需要使用流标，流标通过对象仓库的 openCursor方法创建打开，该方法可以传递2个参数，第一个参数是 IDBKeyRange对象，第二个参数表示流标的读取方向。&lt;br/&gt;我们来看下第一个参数的使用方法如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 boundRange 表示主键从1到10(包含1和10)的集合
 如果第三个参数是true的话，则表示不包含最小的键值1。
 如果第四个参数是true的话，则表示不包含最大键值10，默认都为false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; boundRange = IDBKeyRange.bound(1, 10, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; onlyRange 表示由一个主键值的集合。only里面的参数值为主键值，整数类型。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; onlyRange = IDBKeyRange.only(1&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 lowerRange 表示大于等于1的主键值的集合。
 第二个参数可选，为true表示不包含最小主键1，默认为false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lowerRange = IDBKeyRange.lowerBound(1, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 upperRange 表示小于等于10的主键值的集合。
 第二个参数可选，为true则表示不包含最大主键10，false则包含，默认为false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; upperRange = IDBKeyRange.upperBound(10, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;openCursor方法 的第二个参数表示流标的读取方向，主要有以下几种：&lt;/p&gt;
&lt;p&gt;next: 流标中的数据按主键值升序排序，主键值相等的数据都被读取到。&lt;br/&gt;nextunique: 流标中的数据按主键值升序排序，主键值相等只读取第一条数据。&lt;br/&gt;prev: 流标中的数据按主键值降序排序，主键值相等的数据都被读取。&lt;br/&gt;prevunique: 流标中的数据按主键值降序排序，主键值相等只读取第一条数据。&lt;/p&gt;
&lt;p&gt;如果不使用参数的话，则是查询所有的记录，使用方法代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; datas =&lt;span&gt; [];
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用流标 openCursor&lt;/span&gt;
  objStore.openCursor().onsuccess = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; e.target.result;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cursor) {
      console.log(cursor);
      datas.push(cursor);
      cursor.&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'没有数据了'&lt;span&gt;);
      console.log(datas);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印 cursor 信息如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214643596-1945213228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们使用 openCursor中两个参数来看下demo，如下所示代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; datas =&lt;span&gt; [];
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(IDBKeyRange)
  console.log(&lt;/span&gt;111&lt;span&gt;);
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; range = IDBKeyRange.bound(2, 10&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用流标 openCursor&lt;/span&gt;
  console.log(222&lt;span&gt;);
  objStore.openCursor(range, &lt;/span&gt;'next').onsuccess = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; e.target.result;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cursor) {
      console.log(cursor);
      datas.push(cursor);
      cursor.&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'没有数据了'&lt;span&gt;);
      console.log(datas);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上 IDBKeyRange.bound(2, 10)方法的含义是：表示主键从2到10的集合. objStore.openCursor(range, 'next') 的含义是：流标中的数据按主键值升序排序，主键值相等的数据都被读取到。我们首先来看下我们的 my-database 数据库中 newUsers表中的数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214725720-1440194581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到如上面我们的id就是我们的主键。然后我们如上运行结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214745577-1082610866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多的相关IDBKeyRange的API&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange/bound&quot; target=&quot;_blank&quot;&gt;请看官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.7 更新数据&lt;/p&gt;
&lt;p&gt; 更新数据我们需要使用 IDBObject.put() 方法。该方法也是接收一个参数，为需要保存到对象仓库中的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(IDBKeyRange)
  console.log(&lt;/span&gt;111&lt;span&gt;);
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newValue =&lt;span&gt; {
    &lt;/span&gt;'name': 'kongzhi'&lt;span&gt;,
    &lt;/span&gt;'age': '30'&lt;span&gt;,
    &lt;/span&gt;'id': 1&lt;span&gt;
  };
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新数据&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; req1 =&lt;span&gt; objStore.put(newValue);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主键为1的数据&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; req2 = objStore.get(1&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载主键为1的数据&lt;/span&gt;
  req2.onsuccess = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; e.target.result;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cursor) {
      console.log(cursor);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'没有数据了'&lt;span&gt;);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们使用 objStore.put(newValue); 这个方法去更新主键为1的数据，然后使用 objStore.get(1) 方法来获取主键为1的数据，最后监听 success 方法函数，成功后获取数据，打印信息如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214926318-1380458787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们继续来看下 我们的控制台 -&amp;gt; application 下的 newUsers中的数据被更新成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712214945551-1931821929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.8 删除数据&lt;/p&gt;
&lt;p&gt;我们使用 IDBObjectStore.delete() 方法用于删除记录。代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(IDBKeyRange)
  console.log(&lt;/span&gt;111&lt;span&gt;);
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除主键为1的数据&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; res = objStore.&lt;span&gt;delete&lt;/span&gt;(1&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载主键为1的数据&lt;/span&gt;
  res.onsuccess = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    console.log(&lt;/span&gt;'删除成功了'&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们使用 objStore.delete(1) 方法删除主键为1的代码，然后在控制台中我们看到会打印 删除成功的 文案，然后我们到 我们的 application 再看看如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712215034184-661685752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们可以看到，我们的主键为1的记录没有了。&lt;/p&gt;

&lt;p&gt;2.9 使用索引&lt;/p&gt;
&lt;p&gt;索引的作用就是可以让我们搜索任意字段，我们可以根据索引来搜索任何一条记录，有索引使我们搜索的速度更快，就好比我们的一本书目录一样，它也有&lt;br/&gt;对应的索引含义，我们可以根据该索引能快速查找到我们这一本书上的某一个知识点在第几页。在这里我们默认是按照主键来搜索。&lt;/p&gt;
&lt;p&gt;如上创建索引那块的地方，我们可以看到使用如下语法创建索引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
store.createIndex('userIndex', 'userName', { unique: &lt;span&gt;false&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们首先来看下我们 索引userIndex 有如下值：如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712215124517-654919460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们使用普通的流标的方法来获取索引，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; datas =&lt;span&gt; [];
request.onupgradeneeded &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; store;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('newUsers2'&lt;span&gt;)) {
    store &lt;/span&gt;= db.createObjectStore('newUsers2', {keyPath: 'id', autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
    console.log(store);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建索引&lt;/span&gt;
    store.createIndex('userIndex', 'userName', { unique: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
    console.log(&lt;/span&gt;'创建索引成功1111'&lt;span&gt;);
  }
}

request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers2'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers2'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; req = objStore.index('userIndex'&lt;span&gt;).openCursor();
  req.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; e.target.result;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res) {
      console.log(res);
      datas.push(res);
      res.&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      console.log(&lt;/span&gt;'没有数据了'&lt;span&gt;);
      console.log(datas);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在onsuccess函数内部使用 datas数组，往数组里面添加一条数据，然后使用 res.continue(); 继续调用，因此多条数据都会被添加到 datas 数组里面去了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712215203326-1850283828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.10 清空所有的数据 clear() 方法&lt;/p&gt;
&lt;p&gt; 我们现在来清空下 newUsers 仓库里面的数据，我们没有调用 clear() 方法清空之前，我们来看下 newUsers 表中有哪些数据，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712215229607-1963558986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们看如下代码，就可以清空 newUsers 仓库中所有的数据了，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; request = window.indexedDB.open('my-database', 6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; db;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; datas =&lt;span&gt; [];
request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(IDBKeyRange)
  console.log(&lt;/span&gt;111&lt;span&gt;);
  db &lt;/span&gt;=&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transaction = db.transaction(['newUsers'], 'readwrite'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objStore = transaction.objectStore('newUsers'&lt;span&gt;);
  objStore.clear();
  objStore.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; e.target.result;
    console.log(res);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们继续来查看下我们的 Application 下的数据如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190712215309249-956108262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们所有的数据都被清空了。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 13:54:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>客户端持久化数据库---indexedDB使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11178623.html</dc:identifier>
</item>
<item>
<title>MyBatis 核心配置综述之Executor - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/11178489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/11178489.html</guid>
<description>&lt;p&gt;上一篇我们对&lt;strong&gt;SqlSession&lt;/strong&gt;和&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;的创建过程有了一个详细的了解，但上述的创建过程只是为SQL执行和SQL映射做了基础的铺垫而已，就和我们Spring源码为Bean容器的加载进行许多初始化的工作相同，那么做好前期的准备工作接下来该做什么了？该做数据库连接驱动管理和SQL解析工作了！那么本篇本章就来讨论一下数据库驱动连接管理和SQL解析的管理组件之 Executor执行器。&lt;/p&gt;
&lt;h2 id=&quot;mybatis四大组件之-executor执行器&quot;&gt;MyBatis四大组件之 Executor执行器&lt;/h2&gt;
&lt;p&gt;每一个SqlSession都会拥有一个Executor对象，这个对象负责增删改查的具体操作，我们可以简单的将它理解为JDBC中Statement的封装版。&lt;/p&gt;
&lt;h3 id=&quot;executor的继承结构&quot;&gt;Executor的继承结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201907/1515111-20190712212021056-370260467.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，位于继承体系最顶层的是Executor执行器，它有两个实现类，分别是&lt;code&gt;BaseExecutor&lt;/code&gt;和 &lt;code&gt;CachingExecutor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BaseExecutor&lt;/code&gt; 是一个抽象类，这种通过抽象的实现接口的方式是&lt;code&gt;适配器设计模式之接口适配&lt;/code&gt;的体现，是Executor的默认实现，实现了大部分Executor接口定义的功能，降低了接口实现的难度。BaseExecutor的子类有三个，分别是&lt;code&gt;SimpleExecutor&lt;/code&gt;、&lt;code&gt;ReuseExecutor&lt;/code&gt;和&lt;code&gt;BatchExecutor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleExecutor&lt;/strong&gt;: 简单执行器，是MyBatis中默认使用的执行器，每执行一次update或select，就开启一个Statement对象，用完就直接关闭Statement对象(可以是Statement或者是PreparedStatment对象)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReuseExecutor&lt;/strong&gt;: 可重用执行器，这里的重用指的是重复使用Statement，它会在内部使用一个Map把创建的Statement都缓存起来，每次执行SQL命令的时候，都会去判断是否存在基于该SQL的Statement对象，如果存在Statement对象并且&lt;strong&gt;对应的connection还没有关闭的情况下&lt;/strong&gt;就继续使用之前的Statement对象，&lt;strong&gt;并将其缓存起来&lt;/strong&gt;。因为每一个SqlSession都有一个新的Executor对象，所以我们缓存在ReuseExecutor上的Statement作用域是同一个SqlSession。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BatchExecutor&lt;/strong&gt;: 批处理执行器，用于将多个SQL一次性输出到数据库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CachingExecutor&lt;/code&gt;: 缓存执行器，先从缓存中查询结果，如果存在，就返回；如果不存在，再委托给Executor delegate 去数据库中取，delegate可以是上面任何一个执行器&lt;/p&gt;
&lt;h3 id=&quot;executor创建过程以及源码分析&quot;&gt;Executor创建过程以及源码分析&lt;/h3&gt;
&lt;p&gt;上面我们分析完SqlSessionFactory的创建过程的准备工作后，我们下面就开始分析会话的创建以及Executor的执行过程。&lt;/p&gt;
&lt;p&gt;在创建完SqlSessionFactory之后，调用其&lt;code&gt;openSession&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SqlSession sqlSession = factory.openSession();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SqlSessionFactory的默认实现是DefaultSqlSessionFactory，所以我们需要关心的就是DefaultSqlSessionFactory中的openSession()方法&lt;/p&gt;
&lt;p&gt;openSession调用的是&lt;code&gt;openSessionFromDataSource&lt;/code&gt;方法，传递执行器的类型，方法传播级别，是否自动提交，然后在openSessionFromDataSource方法中会创建一个执行器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public SqlSession openSession() {
  return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}

private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      // 得到configuration 中的environment
      final Environment environment = configuration.getEnvironment();
      // 得到configuration 中的事务工厂
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      // 获取执行器
      final Executor executor = configuration.newExecutor(tx, execType);
      // 返回默认的SqlSession
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用newExecutor方法，根据传入的ExecutorType类型来判断是哪种执行器，然后执行相应的逻辑&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    // defaultExecutorType默认是简单执行器, 如果不传executorType的话，默认使用简单执行器
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    // 根据执行器类型生成对应的执行器逻辑
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    // 如果允许缓存，则使用缓存执行器
    // 默认是true，如果不允许缓存的话，需要手动设置
    if (cacheEnabled) {
      executor = new CachingExecutor(executor);
    }
    // 插件开发。
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;ExecutorType的选择：&lt;/p&gt;
&lt;p&gt;ExecutorType来决定Configuration对象创建何种类型的执行器，它的赋值可以通过两个地方进行赋值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以通过标签来设置当前工程中所有的SqlSession对象使用默认的Executor&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;settings&amp;gt;
&amp;lt;!--取值范围 SIMPLE, REUSE, BATCH --&amp;gt;
  &amp;lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;另外一种直接通过Java对方法赋值的方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;session = factory.openSession(ExecutorType.BATCH);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExecutorType是一个枚举，它只有三个值SIMPLE, REUSE, BATCH&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建完成Executor之后，会把Executor执行器放入一个DefaultSqlSession对象中来对四个属性进行赋值，他们分别是 &lt;code&gt;configuration&lt;/code&gt;、&lt;code&gt;executor&lt;/code&gt;、 &lt;code&gt;dirty&lt;/code&gt;、&lt;code&gt;autoCommit&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;executor接口的主要方法&quot;&gt;Executor接口的主要方法&lt;/h3&gt;
&lt;p&gt;Executor接口的方法还是比较多的，这里我们就几个主要的方法和调用流程来做一个简单的描述&lt;/p&gt;
&lt;h4 id=&quot;大致流程&quot;&gt;大致流程&lt;/h4&gt;
&lt;p&gt;Executor中的大部分方法的调用链其实是差不多的，下面都是深入源码分析执行过程，如果你没有时间或者暂时不想深入研究的话，给你下面的执行流程图作为参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201907/1515111-20190712212051749-963201761.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;query方法&quot;&gt;query()方法&lt;/h4&gt;
&lt;p&gt;query方法有两种形式，一种是&lt;strong&gt;直接查询&lt;/strong&gt;；一种是&lt;strong&gt;从缓存中查询&lt;/strong&gt;，下面来看一下源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;

&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有一个查询请求访问的时候，首先会经过Executor的实现类&lt;strong&gt;CachingExecutor&lt;/strong&gt;，先从缓存中查询SQL是否是第一次执行，如果是第一次执行的话，那么就直接执行SQL语句，&lt;strong&gt;并创建缓存&lt;/strong&gt;，如果第二次访问相同的SQL语句的话，那么就会直接从缓存中提取&lt;/p&gt;
&lt;p&gt;CachingExecutor.j&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 第一次查询，并创建缓存
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameterObject);
  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
  return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;MapperStatement&lt;/code&gt;&lt;strong&gt;维护了一条&amp;lt;select|update|delete|insert&amp;gt;节点的封装&lt;/strong&gt;，包括资源(resource)，配置(configuration)，SqlSource(sql源文件)等。使用Configuration的getMappedStatement方法来获取MappedStatement对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201907/1515111-20190712212110273-112823282.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;BoundSql&lt;/code&gt;这个类包括SQL的基本信息，基本的SQL语句，参数映射，参数类型等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201907/1515111-20190712212123894-1966786410.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的query方法会调用到CachingExecutor类中的query查询缓存的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
  throws SQLException {
  // 得到缓存
  Cache cache = ms.getCache();
  if (cache != null) {
    // 如果需要的话刷新缓存
    flushCacheIfRequired(ms);
    if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
      ensureNoOutParams(ms, boundSql);
      @SuppressWarnings(&quot;unchecked&quot;)
      List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);
      if (list == null) {
        list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
        tcm.putObject(cache, key, list); 
      }
      return list;
    }
  }
  // 委托模式，交给SimpleExecutor等实现类去实现方法。
  return delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由delegate执行query方法，delegate即是&lt;strong&gt;BaseExecutor&lt;/strong&gt;，然后由具体的执行器去真正执行query方法&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：源码中一般以do** 开头的方法都是真正加载执行的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 经过一系列的调用，会调用到下面的方法(与主流程无关，故省略)
// 以SimpleExecutor简单执行器为例
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  Statement stmt = null;
  try {
    // 获取环境配置
    Configuration configuration = ms.getConfiguration();
    // 创建StatementHandler，解析SQL语句
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
    stmt = prepareStatement(handler, ms.getStatementLog());
    // 由handler来对SQL语句执行解析工作
    return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
  } finally {
    closeStatement(stmt);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上面的源码可以看出，Executor执行器所起的作用相当于是管理StatementHandler 的整个生命周期的工作，包括创建、初始化、解析、关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReuseExecutor&lt;/strong&gt;完成的doQuery 工作：几乎和SimpleExecutor完成的工作一样，其内部不过是使用一个Map来存储每次执行的查询语句，为后面的SQL重用作准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BatchExecutor&lt;/strong&gt;完成的doQuery 工作：和SimpleExecutor完成的工作一样。&lt;/p&gt;
&lt;h4 id=&quot;update-方法&quot;&gt;update() 方法&lt;/h4&gt;
&lt;p&gt;在分析完上面的查询方法后，我们再来聊一下update()方法，update()方法不仅仅指的是&lt;strong&gt;update()&lt;/strong&gt;方法，它是一条update链，什么意思呢？就是*insert、update、delete在语义上其实都是更新的意思，而查询在语义上仅仅只是表示的查询，那么我们来偷窥一下update方法的执行流程，与select的主要执行流程很相似，所以一次性贴出。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 首先在顶级接口中定义update 方法，交由子类或者抽象子类去实现

// 也是首先去缓存中查询是否具有已经执行过的相同的update语句
public int update(MappedStatement ms, Object parameterObject) throws SQLException {
  flushCacheIfRequired(ms);
  return delegate.update(ms, parameterObject);
}

// 然后再交由BaseExecutor 执行update 方法
public int update(MappedStatement ms, Object parameter) throws SQLException {
  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());
  if (closed) {
    throw new ExecutorException(&quot;Executor was closed.&quot;);
  }
  clearLocalCache();
  return doUpdate(ms, parameter);
}

// 往往do* 开头的都是真正执行解析的方法，所以doUpdate 应该就是真正要执行update链的解析方法了
// 交给具体的执行器去执行
public int doUpdate(MappedStatement ms, Object parameter) throws SQLException {
  Statement stmt = null;
  try {
    Configuration configuration = ms.getConfiguration();
    StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);
    stmt = prepareStatement(handler, ms.getStatementLog());
    return handler.update(stmt);
  } finally {
    closeStatement(stmt);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ReuseExecutor&lt;/strong&gt;完成的doUpdate 工作：几乎和SimpleExecutor完成的工作一样，其内部不过是使用一个Map来存储每次执行的更新语句，为后面的SQL重用作准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BatchExecutor&lt;/strong&gt;完成的doUpdate 工作：和SimpleExecutor完成的工作相似，只是其内部有一个List列表来一次行的存储多个Statement，&lt;strong&gt;用于将多个sql语句一次性输送到数据库执行.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;querycursor方法&quot;&gt;queryCursor()方法&lt;/h4&gt;
&lt;p&gt;我们查阅其源码的时候，在执行器的执行过程中并没有发现其与query方法有任何不同之处，但是在&lt;strong&gt;doQueryCursor&lt;/strong&gt; 方法中我们可以看到它返回了一个cursor对象，网上搜索cursor的相关资料并查阅其基本结构，得出来的结论是：用于逐条读取SQL语句，应对数据量&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 查询可以返回Cursor&amp;lt;T&amp;gt;类型的数据，类似于JDBC里的ResultSet类，
// 当查询百万级的数据的时候，使用游标可以节省内存的消耗，不需要一次性取出所有数据，可以进行逐条处理或逐条取出部分批量处理。
public interface Cursor&amp;lt;T&amp;gt; extends Closeable, Iterable&amp;lt;T&amp;gt; {

    boolean isOpen();

    boolean isConsumed();
  
    int getCurrentIndex();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;flushstatements-方法&quot;&gt;flushStatements() 方法&lt;/h4&gt;
&lt;p&gt;flushStatement()的主要执行流程和query，update 的执行流程差不多，我们这里就不再详细贴代码了，简单说一下flushStatement()的主要作用，flushStatement()主要用来释放statement，或者用于ReuseExecutor和BatchExecutor来刷新缓存&lt;/p&gt;
&lt;h4 id=&quot;createcachekey-方法&quot;&gt;createCacheKey() 方法&lt;/h4&gt;
&lt;p&gt;createCacheKey()方法主要由BaseExecutor来执行并创建缓存，MyBatis中的缓存分为一级缓存和二级缓存，关于缓存的讨论我们将在Mybatis系列的缓存章节&lt;/p&gt;
&lt;h4 id=&quot;executor-中的其他方法&quot;&gt;Executor 中的其他方法&lt;/h4&gt;
&lt;p&gt;Executor 中还有其他方法，提交commit，回滚rollback，判断是否时候缓存isCached，关闭close，获取事务getTransaction一级清除本地缓存clearLocalCache等&lt;/p&gt;
&lt;h3 id=&quot;executor-的现实抽象&quot;&gt;Executor 的现实抽象&lt;/h3&gt;
&lt;p&gt;在上面的分析过程中我们了解到，Executor执行器是MyBatis中很重要的一个组件，Executor相当于是外包的boss，它定义了甲方(SQL)需要干的活(Executor的主要方法)，这个外包公司是个小公司，没多少人，每个人都需要干很多工作，boss接到开发任务的话，一般都找项目经理(CachingExecutor)，项目经理几乎不懂技术，它主要和技术leader(BaseExecutor)打交道，技术leader主要负责框架的搭建，具体的工作都会交给下面的程序员来做，程序员的技术也有优劣，高级程序员(BatchExecutor)、中级程序员(ReuseExecutor)、初级程序员(SimpleExecutor)，它们干的活也不一样。一般有新的项目需求传达到项目经理这里，项目经理先判断自己手里有没有现成的类库或者项目直接套用(Cache)，有的话就直接让技术leader拿来直接套用就好，没有的话就需要搭建框架，再把框架存入本地类库中，再进行解析。&lt;/p&gt;
&lt;p&gt;(本文完)&lt;/p&gt;
&lt;p&gt;下文预告： MyBatis 核心配置综述之StatementHandler&lt;/p&gt;
&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/19686af69b0d&lt;/p&gt;
&lt;p&gt;http://www.mybatis.org/mybatis-3/getting-started.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/virgosnail/p/10067964.html&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 13:22:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] 上一篇我们对 SqlSession 和 SqlSessionFactory 的创建过程有了一个详细的了解，但上述的创建过程只是为SQL执行和SQL映射做了基础的铺垫而已，就和我们Sprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/11178489.html</dc:identifier>
</item>
<item>
<title>ubuntu18.04上搭建KVM虚拟机环境超完整过程 - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11178181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11178181.html</guid>
<description>&lt;p&gt;看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是个管人的活，更多的是在你的部下遇到难题或者无人能上的时候，你能协助他解决或亲自上阵，这比只会“吆五喝六”的管理者将能获得更高的敬重与威信。闲话不多说了，记录下整个KVM虚拟机的搭建过程吧。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-KVM安装&quot;&gt;1. KVM安装&lt;/h2&gt;
&lt;h3 id=&quot;1-1-配置确认&quot;&gt;1.1 配置确认&lt;/h3&gt;
&lt;p&gt;首先需要确认服务器的硬件是否支持虚拟化，执行如下命令确认&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ &lt;span&gt;egrep&lt;/span&gt; -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(vmx|svm)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /proc/&lt;span&gt;cpuinfo
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果输出结果大于0，意味着服务器硬件是支持虚拟化的。否则，重启进入BIOS设置中启用VT技术。&lt;br/&gt;执行如下命令安装kvm-ok程序，来确定服务器是否能够运行硬件加速的KVM虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;
devuser@server_01:&lt;/span&gt;~$ &lt;span&gt;sudo&lt;/span&gt; kvm-&lt;span&gt;ok
INFO: &lt;/span&gt;/dev/&lt;span&gt;kvm exists
KVM acceleration can be used&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-2-安装KVM&quot;&gt;1.2 安装KVM&lt;/h3&gt;
&lt;p&gt;安装KVM及依赖项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; apt update
devuser@server_01:&lt;/span&gt;~$ &lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动libvirtd服务，并设置开机自动启动 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl start libvirtd.service
devuser@server_01:&lt;/span&gt;~$ &lt;span&gt;sudo&lt;/span&gt; systemctl enable libvirtd.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;code&gt;service libvirtd status&lt;/code&gt;查看libvirtd服务状态，如图 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm1.png&quot; alt=&quot;libvirtd-status&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-3-桥接网络配置&quot;&gt;1.3 桥接网络配置&lt;/h3&gt;
&lt;p&gt;一般虚拟机网络配置有Bridge、NAT等几种模式。NAT模式下，虚拟机不需要配置自己的IP，通过宿主机来访问外部网络；Bridge模式下， 虚拟机需要配置自己的IP，然后虚拟出一个网卡， 与宿主机的网卡一起挂到一个虚拟网桥上（类似于交换机）来访问外部网络，这种模式下，虚拟机拥有独立的IP，局域网其它主机能直接通过IP与其通信。简单理解，就是NAT模式下，虚机隐藏在宿主机后面了，虚机能通过宿主机访问外网，但局域网其它主机访问不到它，Bridge模式下，虚机跟宿主机一样平等地存在，局域网其它主机可直接通过IP与其通信。一般我们创建虚机是用来部署服务供使用的， 所以都是用Bridge模式。&lt;/p&gt;
&lt;p&gt;ubuntu 18中，网络配置通过netplan来实现了，如下，更改配置文件 /etc/netplan/50-cloud-init.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;devuser@cserver_01:~$ sudo vim /etc/netplan/50-cloud-init.yaml
# This file is generated from information provided by
# the datasource.  Changes to it will not persist across an instance.
# To disable cloud-init's network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        enp6s0:
            dhcp4: true
        enp7s0:
            dhcp4: no
            dhcp6: no
    version: 2

    bridges:
         br0:
             interfaces: [enp7s0]
             dhcp4: no
             addresses: [192.168.40.241/24]
             gateway4: 192.168.40.1
             nameservers:
                 addresses: [114.114.114.114,8.8.8.8]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 将宿主机原有网卡enp7s0挂到网桥br0上，并指定IP地址为192.168.40.241，nameservers指定DNS服务器。修改完后，通过&lt;code&gt;sudo netplan apply&lt;/code&gt;重启网络服务生效，然后通过&lt;code&gt;ifconfig&lt;/code&gt;查看，&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm2.png&quot; alt=&quot;kvm2&quot;/&gt;&lt;br/&gt;原来挂在enp7s0网卡下的IP现在挂到了br0上，宿主机及所有其它虚拟机都通过该网桥来与外部通讯。我们也可以通过&lt;code&gt;brctl show&lt;/code&gt;来直观地查看，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~&lt;span&gt;$ brctl show
bridge name        bridge &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;        STP enabled        interfaces
br0            &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.2a5be3ec2698    no                enp7s0
docker0        &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.02424524dcce    no                veth580af8e
                                                      veth74119f3
                                                　　　 vethe7a2b0f
                                                      vethfe89039&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;目前因为还没虚机，所以只有宿主机的网卡enp7s0挂在网桥br0上。同时也可以看到docker容器也是通过网桥docker0来通讯的。&lt;/p&gt;
&lt;h2 id=&quot;2-虚拟机安装&quot;&gt;2. 虚拟机安装&lt;/h2&gt;
&lt;h3 id=&quot;2-1-安装虚拟机&quot;&gt;2.1 安装虚拟机&lt;/h3&gt;
&lt;p&gt;安装命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; virt-&lt;span&gt;install&lt;/span&gt; --name=dev-server1 --memory=&lt;span&gt;16384&lt;/span&gt;,maxmemory=&lt;span&gt;16384&lt;/span&gt; \&lt;br/&gt;--vcpus=&lt;span&gt;4&lt;/span&gt;,maxvcpus=&lt;span&gt;4&lt;/span&gt; --os-type=linux --os-variant=rhel7 \&lt;br/&gt;--location=/home/devuser/tools/CentOS-&lt;span&gt;7&lt;/span&gt;-x86_64-DVD-&lt;span&gt;1810&lt;/span&gt;.iso \&lt;br/&gt;--disk path=/var/lib/libvirt/images/devserver1.img,size=&lt;span&gt;300&lt;/span&gt; \&lt;br/&gt;--bridge=br0 --graphics=none --console=pty,target_type=serial \&lt;br/&gt;--extra-args=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;console=tty0 console=ttyS0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中–name指定虚机名称，后面可通过virsh管理；–memory=16384,maxmemory=16384配置了16G内存；–vcpus=4,maxvcpus=4配置了4个CPU内核；centos7需要制定–os-variant=rhel7；–disk path=xx,size=300制定了磁盘路径与大小，这里是300G。 &lt;/p&gt;
&lt;p&gt;如果执行上述命令出现&lt;span&gt;&lt;code&gt;qemu-kvm: could not open 'xx/CentOS-7-x86_64-DVD-1810.iso': Permission denied&lt;/code&gt;&lt;/span&gt;异常退出时，可通过修改&lt;code&gt;/etc/libvirt/qemu.conf&lt;/code&gt;文件将&lt;code&gt;user = &quot;root&quot;&lt;/code&gt;，&lt;code&gt;group = &quot;root&quot;&lt;/code&gt;前面的注释去掉解决（&lt;a href=&quot;https://github.com/jedi4ever/veewee/issues/996%EF%BC%89&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/jedi4ever/veewee/issues/996）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如无问题，安装程序将出现如下配置界面&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm3.png&quot; alt=&quot;kvm3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可通过输入选项对应的数字来选择不同的配置，依次操作如下步骤完成时区设置：&lt;br/&gt;输入2，回车，选择时区设置；输入1，回车，选择“Set timezone”；输入2，回车，选择“Asia”；回车，输入64，回车，选择“Shanghai”&lt;/p&gt;
&lt;p&gt;然后进行安装设置，&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm4.png&quot; alt=&quot;kvm4&quot;/&gt;&lt;br/&gt;依次操作如下：&lt;br/&gt;输入5，回车，进入安装设置；输入c，回车，选择默认的磁盘进行安装；输入c，回车，使用默认的“2) Use All&lt;br/&gt;Space”；输入1，回车，选择“1) Standard Partition”进行标准分区；输入c，回车，完成分区设置&lt;/p&gt;
&lt;p&gt;最后进入root密码设置，&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm5.png&quot; alt=&quot;kvm5&quot;/&gt;&lt;br/&gt;操作如下：&lt;br/&gt;输入8，回车，进入root密码设置；输入密码，回车；输入确认密码，回车&lt;/p&gt;
&lt;p&gt;完成上述设置后，输入b开始进行安装&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm6.png&quot; alt=&quot;kvm6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等待一段时间后，安装程序停在如下界面&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm7.png&quot; alt=&quot;kvm7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按回车继续，最后输入用户名root，及前面设置的密码登录系统&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm8.png&quot; alt=&quot;kvm8&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-虚拟机网络配置&quot;&gt;2.2 虚拟机网络配置&lt;/h3&gt;
&lt;p&gt;虚拟机安装完后，是没有分配IP的，我们通过&lt;code&gt;ip a&lt;/code&gt;命令查看，&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm9.png&quot; alt=&quot;kvm9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候的eth0下面空空如也，什么都没有。在&lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt;文件中添加如下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# &lt;span&gt;vi&lt;/span&gt; /etc/sysconfig/network-scripts/ifcfg-eth0
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;TYPE=Ethernet&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;PROXY_METHOD=none&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BROWSER_ONLY=no&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;BOOTPROTO=static #静态指定IP&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;DEFROUTE=yes&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV4_FAILURE_FATAL=no&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV6INIT=yes&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV6_AUTOCONF=yes&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV6_DEFROUTE=yes&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV6_FAILURE_FATAL=no&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;#IPV6_ADDR_GEN_MODE=stable-privacy&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;NAME=eth0&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;UUID=449ed621-97a8-45b9-902f-0d347e27de98&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;DEVICE=eth0&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;ONBOOT=yes  #开机自动启动&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;IPADDR=192.168.40.96&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;NETMASK=255.255.255.0&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;GATEWAY=192.168.40.1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;DNS1=192.168.40.1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并通过&lt;code&gt;systemctl restart network&lt;/code&gt;重启网络生效，这时候再运行&lt;code&gt;ip a&lt;/code&gt;查看，eth0下面已经有配置的IP了。不出意外的话，局域网其它主机就可以通过该IP来远程SSH连接了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/kvm10.png&quot; alt=&quot;kvm10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候我们再通过&lt;code&gt;brctl show&lt;/code&gt;来查看网桥挂载情况，br0下面已经多了一个vnet0虚拟网卡了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
devuser@server_01:~&lt;span&gt;$ brctl show
bridge name        bridge &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;        STP enabled        interfaces
br0            &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.2a5be3ec2698    no                enp7s0
                                                      vnet0
docker0        &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.02424524dcce    no                veth580af8e
                                                　　　 veth74119f3
                                                　　   vethd270ee8
                                                　　   vethe7a2b0f
                                                　　   vethfe89039&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虚拟机装完后，默认的hostname是localhost，针对centos7，我们可以通过如下命令来修改hostname &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# hostnamectl set-&lt;span&gt;hostname&lt;/span&gt; dev-server1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在/etc/hosts文件中添加127.0.0.1的host映射 dev-server1 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# &lt;span&gt;vi&lt;/span&gt; /etc/&lt;span&gt;hosts
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;   localhost localhost.localdomain localhost4 localhost4.localdomain4 dev-&lt;span&gt;server1
::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;         localhost localhost.localdomain localhost6 localhost6.localdomain6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3. 虚拟机管理&lt;/span&gt; &lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;列出当前运行的虚拟机&lt;code&gt;&lt;code&gt;virsh list&lt;br/&gt;&lt;/code&gt;&lt;/code&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~&lt;span&gt;$ virsh list
 Id    Name                           State
&lt;/span&gt;----------------------------------------------------
 &lt;span&gt;5&lt;/span&gt;     dev-server1                    running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果列出所有的，则&lt;code&gt;virsh list --all&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;从宿主机进入虚拟机&lt;code&gt;virsh console&lt;/code&gt;，后面接虚拟机ID或名称&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ virsh console &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
Connected to domain dev&lt;/span&gt;-&lt;span&gt;server1
Escape character is &lt;/span&gt;^&lt;span&gt;]

CentOS Linux &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; (Core)
Kernel &lt;/span&gt;&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;957&lt;/span&gt;&lt;span&gt;.el7.x86_64 on an x86_64

dev&lt;/span&gt;-server1 &lt;span&gt;login&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入用户名，密码即可登录虚拟机，按&lt;code&gt;Ctrl+]&lt;/code&gt;可退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;3&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;启动与关闭虚拟机&lt;code&gt;virsh start|shutdown&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@cserver_01:~$ virsh start dev-&lt;span&gt;server1
Domain dev&lt;/span&gt;-&lt;span&gt;server1 started

devuser@server_01:&lt;/span&gt;~$ virsh shutdown &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
Domain &lt;/span&gt;&lt;span&gt;5&lt;/span&gt; is being shutdown
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;libvirtd启动时，自动启动虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ virsh autostart dev-&lt;span&gt;server1
Domain dev&lt;/span&gt;-server1 marked as autostarted
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;挂起/恢复虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ virsh suspend dev-&lt;span&gt;server1    # 挂起虚拟机
devuser@server_01:&lt;/span&gt;~$ virsh resume dev-server1    # 恢复挂起的虚拟机
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;销毁虚拟机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
devuser@server_01:~$ virsh undefine dev-server1   # 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我的个人博客地址：&lt;a href=&quot;http://blog.jboost.cn/&quot;&gt;http://blog.jboost.cn&lt;/a&gt;&lt;br/&gt;我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）&lt;br/&gt;—————————————————————————&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jul 2019 12:11:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>看标题这是篇纯运维的文章。在中小型企业中，一般很少配置专业的运维人员，都是由开发人员兼着。同时，对有志于技术管理的开发人员来说，多了解一些运维及整个软件生命周期的知识，是很有帮助的，因为带团队不仅仅是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11178181.html</dc:identifier>
</item>
<item>
<title>从无到有构建vue实战项目（四） - 啃土豆的菜鸟</title>
<link>http://www.cnblogs.com/ktddcn/p/11178078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ktddcn/p/11178078.html</guid>
<description>&lt;h4 id=&quot;六webpack的安装和配置&quot;&gt;六、webpack的安装和配置&lt;/h4&gt;
&lt;ol readability=&quot;40.77551477171&quot;&gt;&lt;li readability=&quot;14.35&quot;&gt;
&lt;p&gt;为了快速构建vue项目，webpack是一个必不可少的工具，我们先来安装它，附上官网地址：&lt;a href=&quot;https://www.webpackjs.com/&quot; class=&quot;uri&quot;&gt;https://www.webpackjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要安装最新版本或特定版本，请运行以下命令之一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev webpack
npm install --save-dev webpack@&amp;lt;version&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你使用 webpack 4+ 版本，你还需要安装 CLI:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev webpack-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下的 NPM 安装方式，将使 &lt;code&gt;webpack&lt;/code&gt; 在全局环境下可用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --global webpack&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我推荐使用全局安装，这样可以避免后面使用过程中让你意想不到的各种个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;68.565425394363&quot;&gt;
&lt;p&gt;接下来我们对webpack进行简单的配置：&lt;/p&gt;
&lt;p&gt;我们先理解四个&lt;strong&gt;核心概念&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入口(entry)&lt;/li&gt;
&lt;li&gt;输出(output)&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;插件(plugins)&lt;/li&gt;
&lt;li&gt;模式&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;入口entry&quot;&gt;入口(entry)&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;入口起点(entry point)&lt;/strong&gt;指示 webpack 应该使用哪个模块，来作为构建其内部&lt;em&gt;依赖图&lt;/em&gt;的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。&lt;/p&gt;
&lt;p&gt;每个依赖项随即被处理，最后输出到称之为 &lt;em&gt;bundles&lt;/em&gt; 的文件中，我们将在下一章节详细讨论这个过程。&lt;/p&gt;
&lt;p&gt;可以通过在 &lt;a href=&quot;https://www.webpackjs.com/configuration&quot;&gt;webpack 配置&lt;/a&gt;中配置 &lt;code&gt;entry&lt;/code&gt; 属性，来指定一个入口起点（或多个入口起点）。默认值为 &lt;code&gt;./src&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;看一个 &lt;code&gt;entry&lt;/code&gt; 配置的最简单例子:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module.exports = {
  entry: './path/to/my/entry/file.js'
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;出口output&quot;&gt;出口(output)&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;output&lt;/strong&gt; 属性告诉 webpack 在哪里输出它所创建的 &lt;em&gt;bundles&lt;/em&gt;，以及如何命名这些文件，默认值为 &lt;code&gt;./dist&lt;/code&gt;。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 &lt;code&gt;output&lt;/code&gt; 字段，来配置这些处理过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过 &lt;code&gt;output.filename&lt;/code&gt; 和 &lt;code&gt;output.path&lt;/code&gt; 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 &lt;a href=&quot;https://nodejs.org/api/modules.html&quot;&gt;Node.js 核心模块&lt;/a&gt;，用于操作文件路径。&lt;/p&gt;
&lt;h5 id=&quot;loader&quot;&gt;loader&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;loader&lt;/em&gt; 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效&lt;a href=&quot;https://www.webpackjs.com/concepts/modules&quot;&gt;模块&lt;/a&gt;，然后你就可以利用 webpack 的打包能力，对它们进行处理。&lt;/p&gt;
&lt;p&gt;本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。&lt;/p&gt;
&lt;p&gt;在 webpack 的配置中 &lt;strong&gt;loader&lt;/strong&gt; 有两个目标：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;test&lt;/code&gt; 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use&lt;/code&gt; 属性，表示进行转换时，应该使用哪个 loader。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const path = require('path');

const config = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};

module.exports = config;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上配置中，对一个单独的 module 对象定义了 &lt;code&gt;rules&lt;/code&gt; 属性，里面包含两个必须属性：&lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;use&lt;/code&gt;。这告诉 webpack 编译器(compiler) 如下信息：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“嘿，webpack 编译器，当你碰到「在 &lt;code&gt;require()&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先&lt;strong&gt;使用&lt;/strong&gt; &lt;code&gt;raw-loader&lt;/code&gt; 转换一下。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;插件plugins&quot;&gt;插件(plugins)&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。&lt;a href=&quot;https://www.webpackjs.com/api/plugins&quot;&gt;插件接口&lt;/a&gt;功能极其强大，可以用来处理各种各样的任务。&lt;/p&gt;
&lt;p&gt;想要使用一个插件，你只需要 &lt;code&gt;require()&lt;/code&gt; 它，然后把它添加到 &lt;code&gt;plugins&lt;/code&gt; 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 &lt;code&gt;new&lt;/code&gt; 操作符来创建它的一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 用于访问内置插件

const config = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};

module.exports = config;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;模式&quot;&gt;模式&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;通过选择 &lt;code&gt;development&lt;/code&gt; 或 &lt;code&gt;production&lt;/code&gt; 之中的一个，来设置 &lt;code&gt;mode&lt;/code&gt; 参数，你可以启用相应模式下的 webpack 内置的优化&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = {
  mode: 'production'
};&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;七本项目中的webpack.config.js的基本配置和出错情况&quot;&gt;七、本项目中的webpack.config.js的基本配置和出错情况&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;先来看我的基础配置（最终版）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;var path = require('path')  // 引入操作路径模块
const VueLoaderPlugin = require('vue-loader/lib/plugin') //引入vue-loader
module.exports = {
    mode: 'development',
    // 输入文件
    entry: './src/main.js',
    output: {
        // 输出目录
        path: path.resolve(__dirname, 'dist'),
        // 静态目录,从这里取文件
        publicPath: '/dist/',
        // 文件名
        filename: 'index.js'
    },
    module: {
        rules: [
            //解析vue后缀文件
            {
                test: /\.vue$/, 
                loader: 'vue-loader'
            },
            //用巴babel解析js文件 排除模块安装目录的文件
            {
                test: /\.js$/, 
                loader: 'babel-loader',
                query: {
                    presets: ['es2015']
                },
                include: '/src',
                exclude:'/node_modules/'
            },
            {
                test: /\.css$/,
                use: [ 'style-loader', 'css-loader' ]
              },
            {
 
                test: /\.scss$/,
                loader: 'style-loader!css-loader!sass-loader' 
                },
                {
                    test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/,
                    loader: 'file-loader'
            }
        ]
    },
    plugins: [
        // 请确保引入这个插件！
        new VueLoaderPlugin()
      ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在以上配置过程中，出现了一系列的问题：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489272/201907/1489272-20190712194721085-1838338952.png&quot;/&gt;&lt;br/&gt;出现这个错误是因为每个 &lt;code&gt;vue&lt;/code&gt; 包的新版本发布时，一个相应版本的 &lt;code&gt;vue-template-compiler&lt;/code&gt; 也会随之发布。编译器的版本必须和基本的 &lt;code&gt;vue&lt;/code&gt; 包保持同步，这样 &lt;code&gt;vue-loader&lt;/code&gt; 就会生成兼容运行时的代码。这意味着&lt;strong&gt;你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你应该将 &lt;code&gt;vue-loader&lt;/code&gt; 和 &lt;code&gt;vue-template-compiler&lt;/code&gt; 一起安装——除非你是使用自行 fork 版本的 Vue 模板编译器的高阶用户：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm install -D vue-loader vue-template-compiler&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在webpack.config.js中分别写入：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const VueLoaderPlugin = require('vue-loader/lib/plugin')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;module: {
    ...
  plugins: [
    // 请确保引入这个插件！
    new VueLoaderPlugin()
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489272/201907/1489272-20190712194738979-1646709434.png&quot;/&gt;&lt;br/&gt;很明显，该错误是由element-ui引起的，解决这个问题我们只需要插入这样一段语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
                    test: /\.(eot|svg|ttf|woff|woff2)(\?\S*)?$/,
                    loader: 'file-loader'
            }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 12 Jul 2019 11:48:00 +0000</pubDate>
<dc:creator>啃土豆的菜鸟</dc:creator>
<og:description>六、webpack的安装和配置 1. 为了快速构建vue项目，webpack是一个必不可少的工具，我们先来安装它，附上官网地址： 要安装最新版本或特定版本，请运行以下命令之一： 如果你使用 webpa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ktddcn/p/11178078.html</dc:identifier>
</item>
</channel>
</rss>