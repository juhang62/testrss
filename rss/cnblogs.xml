<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>不知何为安全模式，怎能说懂电脑？ - ProvokeXun</title>
<link>http://www.cnblogs.com/Mo-Maek/p/10314924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mo-Maek/p/10314924.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、什么情况需要进入电脑的安全模式&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;第一步启动计算机，在系统进入Windows启动画面前，按下F8键(或者在启动计算机时按住Ctrl键不放)，在出现的启动选项菜单中，选择安全模式选项.稍等一端时间就进入了安&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;全模式 接下来我再想大家介绍介绍通常在什么情况下需要进入安全模式了:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt; 系统崩溃正常模式运行不够稳定甚至无法进入时..我们可以进入安全模式, 如果是由于注册表有问题而引起的系统故障；此方法非常有效，因为Windows在安全模式下启动时可以自动修复  注册表问题，在安全模式下启动Windows成功后，一般就可以在正常  模式(Normal)下启动了。 如果用户是在安装了新的软件或者更改了某些设置后，导致系统无法正常启动，也需要进入安全模式下解决，如果是安装了新软件引起的，请在安全模式中卸载该软件，如果是更改了某些设置，比如显示分辨率设置超出显示器显示范围，导致了黑屏，那么进入安全模式后就可以改变回来，还有把带有密码的屏幕保护程序放在“启动”菜单中，忘记密码后，导致无法正常操作该计算机，也可以进入安全模式更改。 实在不行如果您使用了还原软件或XP自带的备份过可以直接还原。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当要进行杀毒的时候，我们可以进入安全模式 安全模式启动只加载基本必要驱动，可以有效的避免病毒木马进程正在运行,给杀毒带来不便。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我们在Windows下删除一些文件或者清除回收站内容时，系统有时候会提示“某某某文件正在被使用，无法删除”的字样，有意思的是，通常这些文件并没有正在被使用，&lt;/span&gt;&lt;span&gt;那么是不是让这些文件永远霸占我们的硬盘呢？请不要着急，重新启动计算机，并在启动时按下F8键进入安全模式，试着删除那些顽固文件并清空回收站看一看，没了！&lt;/span&gt; &lt;span&gt;原来Windows已经放弃了对这些文件的保护，可以把它们删除了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;要进行碎片整理时候(不过相信现在很少有人在碎片整理了，一段时间可以直接把系统格了重装)&lt;/span&gt; &lt;span&gt;在碎片整理的过程中，是不能运行其它程序的；因为每当其它程序进行磁盘读写操作时，碎片整理程序就会自动重新开始，而一般在正常启动Windows时，&lt;/span&gt; &lt;span&gt;系统会加载一些自动启动的程序，有时这些程序又不易手动关闭，常常会对碎片整理程序造成干扰。这种情况下，我们就应该重新启动计算机，进入安全模式，&lt;/span&gt; &lt;span&gt;安全模式是不会启动任何自动启动程序的，可以保证磁盘碎片整理的顺利进行。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;   &lt;strong&gt;  &lt;span&gt;二、 进入安全模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　       &lt;span&gt;只要在启动计算机时，在系统进入Windows启动画面前，按下F8键(或者在启动计算机时按住Ctrl键)，就会出现操作系统多模式启动菜单，只需要选择“Safe Mode”，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;就可以将计算机启动到安全模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1. 删除顽固文件&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          我们在Windows下删除一些文件或清除资源回收站内容时，系统有时会提示「某某文件正在使用中，无法删除」的字样，不过这些文件并无使用中，此时可试着重新启动计算机并在启动时进入安全模式。进入安全模式后，Windows会自动   释放这些文件的控制权，便可以将它们删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;2. “安全模式”还原&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　     　如果计算机不能正常启动，可以使用“安全模式”或者其它启动选项来启动计算机，在电脑启动时按下F8键，在启动模式菜单中选择安全模式，然后按下面方&lt;/span&gt;&lt;span&gt;法进行系统还原：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　点击“开始”→“所有程序”→“附件”→“系统工具” →“系统还原”，打开系统还原向导，然后选择“恢复我的计算机到一个较早的时间”选项，点击“下&lt;/span&gt;&lt;span&gt;一步”按钮，在日历上点击黑体字显示的日期选择系统还原点(图3)，点击“下一步”按钮即可进行系统还原。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3. 查杀病毒&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　    现在病毒一天比一天多，杀毒软件也天天更新。但是，在Windows下杀毒我们未免有些不放心，因为它们极有可能会交叉感染。而一些杀毒程序又无法在DOS下运行，&lt;/span&gt;&lt;span&gt;这时候我们当然也可以把系统启动至安全模式，使Windows只加载最基本的驱动程序，这样杀起病毒来就更彻底、更干净了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4. 解除组策略锁定&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　    　其实Windows中组策略限制是通过加载注册表特定键值来实现的，而在安全模式下并不会加载这个限制。重启开机后按住F8键，在打开的多重启动菜单窗口，&lt;/span&gt;&lt;span&gt;选择“带命令提示符的安全模式”。进入桌面后，在启动的命令提示符下输入“C:\Windows\System32\XXX.exe(你启动的程序)”，启动控制台，再按照如上操作即可解除限制，&lt;/span&gt;&lt;span&gt;最后重启正常登录系统即可解锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　注：组策略的很多限制在安全模式下都无法生效，如果碰到无法解除的限制，不妨进入下寻找解决办法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;5. 修复系统故障&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　    如果Windows运行起来不太稳定或者无法正常启动，这时候先不要忙着重装系统，试着重新启动计算机并切换到安全模式启动，之后再重新启动计算机，&lt;/span&gt;&lt;span&gt;系统是不是已经恢复正常了?如果是由于注册表有问题而引起的系统故障，此方法非常有效，因为Windows在安全模式下启动时可以自动修复注册表问题，&lt;/span&gt;&lt;span&gt;在安全模式下启动Windows成功后，一般就可以在正常模式(Normal)下启动了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　6. 恢复系统设置&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　       如果用户是在安装了新的软件或者更改了某些设置后，导致系统无法正常启动，也需要进入安全模式下解决，如果是安装了新软件引起的，请在安全模式中卸载该软件，&lt;/span&gt;&lt;span&gt;如果是更改了某些设置；比如显示分辨率设置超出显示器显示范围，导致了黑屏，那么进入安全模式后就可以改变回来，还有把带有密码的屏幕保护程序放在“启动”菜单中，忘记密码后，导致无法正常操作该计算机，也可以进入安全模式更改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;7. 揪出恶意的自启动程序或服务&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       　如果电脑出现一些莫明其妙的错误，比如上不了网，按常规思路又查不出问题，可启动到带网络连接的安全模式下看看，如果在这里能上，则说明是某些自启动程序或服&lt;/span&gt;&lt;span&gt;务影响了网络的正常连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;8. 检测不兼容的硬件&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　XP由于采用了数字签名式的驱动程序模式，对各种硬件的检测也比以往严格，所以一些设备可能在正常状态下不能驱动使用。例如一些早期的CABLE MODEM，如果你发现在正常模式下XP不能识别硬件，可以在启动的时候按F8，然后选进入安全模式，在安全模式里检测新硬件，就有可能正确地为CABLE MODEM加载驱动了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;9. 卸载不正确的驱动程序&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　一般的驱动程序，如果不适用你的硬件，可以通过XP的驱动还原来卸载。但是显卡和硬盘IDE驱动，如果装错了，有可能一进入GUI界面就死机;一些主板的ULTRA DMA补丁也是如此，因为Windows是要随时读取内存与磁盘页面文件调整计算机状态的，所以硬盘驱动一有问题马上系统就崩溃。此时怎么办呢?&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　某些情况下，禁用管理员账户可能造成维护上的困难。例如，在域环境中，当用于建立连接的安全信道由于某种原因失败时，如果没有其他的本地管理员账户，则必须以安全模式重新启动计算机来修复致使连接状态中断的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果试图重新启用已禁用的管理员账户，但当前的管理员密码不符合密码要求，则无法重新启用该账户。这种情况下，该管理员组的可选成员必须通过“本地用户和组”用户界面来设置该管理员账户的密码。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 07:50:00 +0000</pubDate>
<dc:creator>ProvokeXun</dc:creator>
<og:description>一、什么情况需要进入电脑的安全模式第一步启动计算机，在系统进入Windows启动画面前，按下F8键(或者在启动计算机时按住Ctrl键不放)，在出现的启动选项菜单中，选择安全模式选项.稍等一端时间就进入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mo-Maek/p/10314924.html</dc:identifier>
</item>
<item>
<title>Java初学者容易犯的代码错误 - 冰湖一角</title>
<link>http://www.cnblogs.com/bingyimeiling/p/10314882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingyimeiling/p/10314882.html</guid>
<description>&lt;p&gt;1. 不会判断空&lt;/p&gt;
&lt;p&gt;空指针异常是所有Java初学者接触最多的异常，没有之一。原因是，你们拿到一个对象后容易不假思索的直接使用（直接给这个对象的属性赋值，直接调用这个对象的方法等），不报异常才怪呢！下面是最经典的判断空的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty(String str){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str==&lt;span&gt;null&lt;/span&gt; || &quot;&quot;&lt;span&gt;.equals(str)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 在for循环嵌套里调用底层查询数据库的方法&lt;/p&gt;
&lt;p&gt;这种方式一定要避免！！因为查询数据库是很耗时的，而在for循环里不停的查询数据库性能有多低可想而知，那么怎么替换这种方式呢？很简单：在for循环外面先把符合条件的数据获取到，存在map里，然后在for循环里面根据key获取对应的value值。这种情况虽然多些循环，但是只需要查询一次数据库即可。&lt;/p&gt;
&lt;p&gt;3. 在List循环里删除元素&lt;/p&gt;
&lt;p&gt;java.util.ConcurrentModificationException这个异常就是你在循环list是删除元素造成的。List是按照下标寻找元素的，而且有大小长度，如何你删除一个元素，list列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。这个时候应该将list转成Iterator遍历删除，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt; strList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
strList.add(&lt;/span&gt;&quot;one&quot;&lt;span&gt;);
strList.add(&lt;/span&gt;&quot;two&quot;&lt;span&gt;);
strList.add(&lt;/span&gt;&quot;three&quot;&lt;span&gt;);
strList.add(&lt;/span&gt;&quot;four&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String s : strList){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s.equals(&quot;two&quot;&lt;span&gt;)){
        strList.remove(s);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;span&gt;    }
}
Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iter =&lt;span&gt; strList.iterator();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter.hasNext()) {
    String s &lt;/span&gt;=&lt;span&gt; iter.next();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.equals(&quot;two&quot;&lt;span&gt;)) {
        iter.remove();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 不会重构代码&lt;/p&gt;
&lt;p&gt;学习java的时候，每个人都遇到过这种情况：不同方法里包含相同的功能代码块，例如日期转换，初学者经常会在一个方法里实现的代码，如果另一个方法也要用，就采用复制粘贴的方法，把相同的代码拷到另一个方法里面去，这种代码看起来多臃肿啊，后期也很难维护。遇到这种情况应该把公共代码进行封装（面向对象第一特征），不管谁要用到这个功能，只需要调用公共方法即可。&lt;/p&gt;
&lt;p&gt;5. 创建对象太多&lt;/p&gt;
&lt;p&gt;我曾经见过一个程序员写的方法里到处都是new对象，把我吓了一跳，这给jvm得造成多少垃圾啊！不是说不让创建对象，这要根据业务情况而定，最起码不要创造垃圾（不使用的对象）。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:44:00 +0000</pubDate>
<dc:creator>冰湖一角</dc:creator>
<og:description>1. 不会判断空 空指针异常是所有Java初学者接触最多的异常，没有之一。原因是，你们拿到一个对象后容易不假思索的直接使用（直接给这个对象的属性赋值，直接调用这个对象的方法等），不报异常才怪呢！下面是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bingyimeiling/p/10314882.html</dc:identifier>
</item>
<item>
<title>使用MaxCompute Java SDK运行安全相关命令 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10314868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10314868.html</guid>
<description>&lt;p&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont686985.i1.4b827573pnZh9h&quot;&gt;使用MaxCompute Console的同学，可能都使用过MaxCompute安全相关的命令。官方文档上有详细的MaxCompute&lt;span&gt;安全指南&lt;/span&gt;，并给出了安全相关语句汇总。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;简而言之，&lt;span&gt;权限管理&lt;/span&gt;、&lt;span&gt;列级别访问控制&lt;/span&gt;、&lt;span&gt;项目空间安全配置&lt;/span&gt;以及&lt;span&gt;跨项目空间的资源分享&lt;/span&gt;都属于 MaxCompute 安全命令相关的范畴。&lt;/p&gt;

&lt;p&gt;再直白一点，以下列关键字开头的命令，都是MaxCompute安全相关操作命令：&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;pre class=&quot; language-none&quot;&gt;
&lt;code class=&quot; language-none&quot;&gt;GRANT/REVOKE ...
SHOW  GRANTS/ACL/PACKAGE/LABEL/ROLE/PRINCIPALS
SHOW  PRIV/PRIVILEGES
LIST/ADD/REOVE  USERS/ROLES/TRUSTEDPROJECTS
DROP/CREATE   ROLE
CLEAR EXPIRED  GRANTS
DESC/DESCRIBE   ROLE/PACKAGE
CREATE/DELETE/DROP  PACKAGE
ADD ... TO  PACKAGE
REMOVE ... FROM  PACKAGE
ALLOW/DISALLOW  PROJECT
INSTALL/UNINSTALL  PACKAGE
LIST/ADD/REMOVE   ACCOUNTPROVIDERS
SET  LABLE  ...&lt;/code&gt;
&lt;/pre&gt;

那么，这些能在 MaxCompute Console 上运行的命令，该如何使用 MaxCompute Java SDK 运行呢？它们是与 SQL 一样通过创建 instance 的方式来运行吗？&lt;/div&gt;

&lt;p&gt;答案：不可以，这些命令不是 SQL ， 不可以通过 SQL Task 来运行。&lt;/p&gt;

&lt;p&gt;需要使用接口 &lt;code&gt;SecurityManager.runQuery()&lt;/code&gt; 来运行。&lt;span&gt;详细 SDK Java Doc 戳这里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SecurityManager&lt;/code&gt; 类在 odps-sdk-core 中，因此在使用时请添加依赖：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;&lt;pre class=&quot; language-none&quot;&gt;
&lt;code class=&quot; language-none&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.aliyun.odps&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;odps-sdk-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.29.11-oversea-public&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

下面通过一个例子来演示如何通过 MaxCompute Java SDK 来设置表 &lt;code&gt;test_label&lt;/code&gt; 列的访问级别为 2，也就是运行命令&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SET LABEL 2 TO TABLE test_label(key, value);&lt;/code&gt;。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;pre class=&quot; language-java&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.Column&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.Odps&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.OdpsException&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.OdpsType&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.TableSchema&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.account&lt;span class=&quot;token punctuation&quot;&gt;.Account&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.account&lt;span class=&quot;token punctuation&quot;&gt;.AliyunAccount&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com&lt;span class=&quot;token punctuation&quot;&gt;.aliyun&lt;span class=&quot;token punctuation&quot;&gt;.odps&lt;span class=&quot;token punctuation&quot;&gt;.security&lt;span class=&quot;token punctuation&quot;&gt;.SecurityManager&lt;span class=&quot;token punctuation&quot;&gt;;

&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;span class=&quot;hljs-class&quot;&gt; &lt;span class=&quot;token class-name&quot;&gt;test&lt;span class=&quot;hljs-class&quot;&gt; &lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;hljs-function&quot;&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;span class=&quot;hljs-function&quot;&gt; OdpsException &lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try &lt;span class=&quot;token punctuation&quot;&gt;{
      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;运行结果：&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/066f62c329e0309fc40dbdfa3698dad4&quot; alt=&quot;34&quot;/&gt;&lt;/div&gt;

&lt;p&gt;程序运行完成后，在 MaxCompute Console 中运行 ｀desc test_lable;` 命令，可以看到 set label 已经生效了。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3634132b518285aedaea37cf486ff92e&quot; alt=&quot;DingTalk20161017205014&quot;/&gt;&lt;/div&gt;

&lt;p&gt;其他安全相关的命令，都可以这样子通过 MaxCompute Java SDK 来运行呢，快来试试吧！&lt;/p&gt;

&lt;div data-spm-anchor-id=&quot;a2c4e.11153940.blogcont686985.i2.4b827573pnZh9h&quot; readability=&quot;5.9367088607595&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/686985?utm_content=g_1000039645&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:43:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>使用MaxCompute Console的同学，可能都使用过MaxCompute安全相关的命令。官方文档上有详细的MaxCompute安全指南，并给出了安全相关语句汇总。 简而言之，权限管理、列级别访</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10314868.html</dc:identifier>
</item>
<item>
<title>Python使用Zero-Copy和Buffer Protocol实现高性能编程 - 疯人院主任</title>
<link>http://www.cnblogs.com/erhuabushuo/p/10314803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erhuabushuo/p/10314803.html</guid>
<description>&lt;p&gt;无论你程序是做什么的，它经常都需要处理大量的数据。这些数据大部分表现形式为strings（字符串）。然而，当你对字符串大批量的拷贝，切片和修改操作时是相当低效的。为什么？&lt;/p&gt;
&lt;p&gt;让我们假设一个读取二进制数据的大文件示例，然后将部分数据拷贝到另外一个文件。要展示该程序所使用的内存，我们使用&lt;a href=&quot;https://pypi.python.org/pypi/memory_profiler&quot;&gt;memory_profiler&lt;/a&gt;，一个强大的Python包，让我们可以一行一行观察程序所使用的内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@profile
def read_random():
    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
        content = source.read(1024 * 10000)
        content_to_write = content[1024:]
    print(f&quot;content length: {len(content)}, content to write length {len(content_to_write)}&quot;)
    with open(&quot;/dev/null&quot;, &quot;wb&quot;) as target:
        target.write(content_to_write)


if __name__ == &quot;__main__&quot;:
    read_random()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用memory_profiler模块来执行以上程序，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python -m memory_profiler example.py 
content length: 10240000, content to write length 10238976
Filename: example.py

Line #    Mem usage    Increment   Line Contents
================================================
     1   14.320 MiB   14.320 MiB   @profile
     2                             def read_random():
     3   14.320 MiB    0.000 MiB       with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
     4   24.117 MiB    9.797 MiB           content = source.read(1024 * 10000)
     5   33.914 MiB    9.797 MiB           content_to_write = content[1024:]
     6   33.914 MiB    0.000 MiB       print(f&quot;content length: {len(content)}, content to write length {len(content_to_write)}&quot;)
     7   33.914 MiB    0.000 MiB       with open(&quot;/dev/null&quot;, &quot;wb&quot;) as target:
     8   33.914 MiB    0.000 MiB           target.write(content_to_write)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过&lt;strong&gt;source.read&lt;/strong&gt;从&lt;strong&gt;/dev/unrandom&lt;/strong&gt;加载了10 MB数据。Python需要大概需要分配10 MB内存来以字符串存储这个数据。之后的&lt;strong&gt;content[1024:]&lt;/strong&gt;指令越过开头的一个单位的KB数据进行数据拷贝，也分配了大概10 MB。&lt;/p&gt;
&lt;p&gt;这里有趣的是在哪里呢，也就是构建&lt;strong&gt;content_to_write&lt;/strong&gt;时10 MB的程序内存增长。切片操作拷贝了除了开头的一个单位的KB其他所有的数据到一个新的字符串对象。&lt;/p&gt;
&lt;p&gt;如果处理类似大量的字节数组对象操作那是简直就是灾难。如果你之前写过C语言，在使用&lt;strong&gt;memcpy()&lt;/strong&gt;需要注意点是：在内存使用以及总体性能来说，复制内存很慢。&lt;/p&gt;
&lt;p&gt;然而，作为C程序员的你，知道字符串其实就是由字符数组构成，你不非得通过拷贝也能只处理部分字符，通过使用基本的指针运算——只需要确保整个字符串是连续的内存区域。&lt;/p&gt;
&lt;p&gt;在Python同样提供了buffer protocol实现。buffer protocol定义在&lt;a href=&quot;http://www.python.org/dev/peps/pep-3118/&quot;&gt;PEP 3118&lt;/a&gt;，描述了使用C语言API实现各种类型的支持，例如字符串。&lt;/p&gt;
&lt;p&gt;当一个对象实现了该协议，你就可以使用&lt;strong&gt;memoryview&lt;/strong&gt;类构造一个&lt;strong&gt;memoryview&lt;/strong&gt;对象引用原始内存对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = b&quot;abcdefgh&quot;
&amp;gt;&amp;gt;&amp;gt; view = memoryview(s)
&amp;gt;&amp;gt;&amp;gt; view[1]
98
&amp;gt;&amp;gt;&amp;gt; limited = view[1:3]
&amp;gt;&amp;gt;&amp;gt; limited
&amp;lt;memory at 0x7f6ff2df1108&amp;gt;
&amp;gt;&amp;gt;&amp;gt; bytes(view[1:3])
b'bc'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：98是字符b的ACSII码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的例子中，在使用&lt;strong&gt;memoryview&lt;/strong&gt;对象的切片操作，同样返回一个&lt;strong&gt;memoryview&lt;/strong&gt;对象。意味着它并没有拷贝任何数据，而是通过引用部分数据实现的。&lt;/p&gt;
&lt;p&gt;下面图示解释发生了什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thyrsi.com/t6/662/1548313690x2890174202.png&quot; alt=&quot;alt&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我们可以将之前的程序改造得更加高效。我们需要使用&lt;strong&gt;memoryview&lt;/strong&gt;对象来引用数据，而不是开辟一个新的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@profile
def read_random():
    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
        content = source.read(1024 * 10000)
        content_to_write = memoryview(content)[1024:]
    print(f&quot;content length: {len(content)}, content to write length {len(content_to_write)}&quot;)
    with open(&quot;/dev/null&quot;, &quot;wb&quot;) as target:
        target.write(content_to_write)


if __name__ == &quot;__main__&quot;:
    read_random()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再一次使用memory profiler执行上面程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python -m memory_profiler example.py 
content length: 10240000, content to write length 10238976
Filename: example.py

Line #    Mem usage    Increment   Line Contents
================================================
     1   14.219 MiB   14.219 MiB   @profile
     2                             def read_random():
     3   14.219 MiB    0.000 MiB       with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
     4   24.016 MiB    9.797 MiB           content = source.read(1024 * 10000)
     5   24.016 MiB    0.000 MiB           content_to_write = memoryview(content)[1024:]
     6   24.016 MiB    0.000 MiB       print(f&quot;content length: {len(content)}, content to write length {len(content_to_write)}&quot;)
     7   24.016 MiB    0.000 MiB       with open(&quot;/dev/null&quot;, &quot;wb&quot;) as target:
     8   24.016 MiB    0.000 MiB           target.write(content_to_write)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该程序中，&lt;strong&gt;source.read&lt;/strong&gt;仍然分配了10 MB内存来读取文件内容。然而，使用memoryview来引用部分内容时，并没有额外在分配内存。&lt;/p&gt;
&lt;p&gt;相比之前的版本，这里节省了大概50%的内存开销。&lt;/p&gt;
&lt;p&gt;该技巧，在处理sockets通信的时候极其有用。当通过socket发送数据时，所有的数据可能并没有在一次调用就发送。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
s = socket.socket(…)
s.connect(…)
# Build a bytes object with more than 100 millions times the letter `a`
data = b&quot;a&quot; * (1024 * 100000)
while data:
    sent = s.send(data)
    # Remove the first `sent` bytes sent
    data = data[sent:] &amp;lt;2&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下实现，程序一次次拷贝直到所有的数据发出。通过使用&lt;strong&gt;memoryview&lt;/strong&gt;，可以实现zero-copy（零拷贝）方式来完成该工作，具有更高的性能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
s = socket.socket(…)
s.connect(…)
# Build a bytes object with more than 100 millions times the letter `a`
data = b&quot;a&quot; * (1024 * 100000)
mv = memoryview(data)
while mv:
    sent = s.send(mv)
    # Build a new memoryview object pointing to the data which remains to be sent
    mv = mv[sent:]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里就不会发生任何拷贝，也不会在给&lt;strong&gt;data&lt;/strong&gt;分配了100 MB内存之后再分配多余的内存来进行多次发送了。&lt;/p&gt;
&lt;p&gt;目前，我们通过使用&lt;strong&gt;memoryview&lt;/strong&gt;对象实现高效数据写入，但在某些情况下读取也同样适用。在Python中大部分 I/O 操作已经实现了buffer protocol机制。在本例中，我们并不需要&lt;strong&gt;memoryview&lt;/strong&gt;对象，我可以请求 I/O 函数写入我们预定义好的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ba = bytearray(8)
&amp;gt;&amp;gt;&amp;gt; ba
bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00')
&amp;gt;&amp;gt;&amp;gt; with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
...     source.readinto(ba)
... 
8
&amp;gt;&amp;gt;&amp;gt; ba
bytearray(b'`m.z\x8d\x0fp\xa1')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过该机制，我们可以很简单写入到预定义的buffer中（在C语言中，你可能需要多次调用&lt;strong&gt;malloc()&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;适用&lt;strong&gt;memoryview&lt;/strong&gt;，你甚至可以将数据放入到内存区域任意点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ba = bytearray(8)
&amp;gt;&amp;gt;&amp;gt; # Reference the _bytearray_ from offset 4 to its end
&amp;gt;&amp;gt;&amp;gt; ba_at_4 = memoryview(ba)[4:]
&amp;gt;&amp;gt;&amp;gt; with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as source:
... # Write the content of /dev/urandom from offset 4 to the end of the
... # bytearray, effectively reading 4 bytes only
...     source.readinto(ba_at_4)
... 
4
&amp;gt;&amp;gt;&amp;gt; ba
bytearray(b'\x00\x00\x00\x00\x0b\x19\xae\xb2')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buffer protocol是实现低内存开销的基础，具备很强的性能。虽然Python隐藏了所有的内存分配，开发者不需要关系内部是怎么样实现的。&lt;/p&gt;
&lt;p&gt;可以再去了解一下&lt;strong&gt;array&lt;/strong&gt;模块和&lt;strong&gt;struct&lt;/strong&gt;模块是如何处理buffer protocol的，zero copy操作是相当高效的。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:34:00 +0000</pubDate>
<dc:creator>疯人院主任</dc:creator>
<og:description>无论你程序是做什么的，它经常都需要处理大量的数据。这些数据大部分表现形式为strings（字符串）。然而，当你对字符串大批量的拷贝，切片和修改操作时是相当低效的。为什么？ 让我们假设一个读取二进制数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erhuabushuo/p/10314803.html</dc:identifier>
</item>
<item>
<title>windows环境下配置GeoServer - 王小豆又叫小王子</title>
<link>http://www.cnblogs.com/mohanchen/p/10314732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mohanchen/p/10314732.html</guid>
<description>&lt;p&gt;　　首先介绍下Geoserver是用来做什么的？&lt;/p&gt;
&lt;p&gt;　　GeoServer是一个基于Java的软件服务器，允许用户查看和编辑地理空间数据。使用开放地理空间联盟（OGC）提出的开放标准，GeoServer可以在地图创建和数据共享方面提供极大的灵活性。&lt;/p&gt;
&lt;p&gt;　　下面介绍下在windows环境下配置Geoserver的过程，当然配置方式有很多种，笔者只介绍一种简单的配置方式，闲言碎语不要讲，下面开整：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;安装JAVA环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;因为我们要用tomcat作为服务器，所以必须要有JAVA环境；如果你不知道自己的及其上是否安装了JDK,那么先检查一下，命令行执行：java -version&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/929027/201901/929027-20190124142731898-51099990.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可见笔者已经装了 JDK8  64bit；如果没有装就先装一个，下载地址：&lt;a href=&quot;http://www.oracle.com/index.html&quot;&gt;http://www.oracle.com/&lt;/a&gt;，最好下载JDK8。下载安装完成后记得配置环境变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建-&amp;gt;变量名&quot;JAVA_HOME&quot;，变量值&quot;D:\Java\jdk1.8.0_40&quot;（即JDK的安装路径）&lt;/li&gt;
&lt;li&gt;编辑-&amp;gt;变量名&quot;Path&quot;，在原变量值的最后面加上“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”&lt;/li&gt;
&lt;li&gt;新建-&amp;gt;变量名“CLASSPATH”,变量值“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;配置Tomcat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　先简单介绍下tomcat:&lt;/p&gt;
&lt;p&gt;　　tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如tomcat管理和控制平台、安全域管理和tomcat阀等。由于tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。tomcat 包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。&lt;/p&gt;
&lt;p&gt;　　说是配置，其实很简单下载下来就差不多可以用了，下载地址：&lt;a title=&quot;tomat官网&quot; href=&quot;http://tomcat.apache.org/&quot; target=&quot;_blank&quot;&gt;http://tomcat.apache.org/&lt;/a&gt; ，注意一点下载的Tomcat的位数要和Java环境位数一致，例如笔者JDK安装的是64位的，那tomcat也应该选择下载部署64位的。&lt;/p&gt;
&lt;p&gt;　　下载后，解压到一个目录的目录，比如笔者就放在了D:\apache-tomcat-8.5.37，只需解压，无需安装；这个时候可以双击执行上述目录下bin下的startup.bat文件启动服务器来检查环境是否正确。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;安装GeoServer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;GeoServer前面已经介绍过了，直接去官网下载包，下载地址：&lt;a title=&quot;GeoServer官网&quot; href=&quot;http://geoserver.org/&quot; target=&quot;_blank&quot;&gt;http://geoserver.org/&lt;/a&gt; 。由于我们使用Tomcat作为服务器，所以选择下载Web Archive (war)包；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/929027/201901/929027-20190124145007873-1182859496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　下载解压后得到 geoserver.war 文件，把该文件放置到tomcat目录下的webapps目录下，比如放置该文件后，我的路径为：D:\apache-tomcat-8.5.37\webapps\geoserver.war。然后启动tomcat，如果启动成功，会得到如下提示：&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/929027/201901/929027-20190124145410497-1698780014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器输入http://localhost:8080/geoserver打开geoserver的管理页面，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/929027/201901/929027-20190124152440131-1235777335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此配置成功。&lt;/p&gt;
&lt;p&gt;　　同时，由于tomcat从7.0.41版本开始就支持跨域了，只需要进行下面的简单配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到geoserver的web.xml文件，我的电脑对应的路径为D:\apache-tomcat-8.5.37\webapps\geoserver\WEB-INF\web.xml；&lt;/li&gt;
&lt;li&gt;打开该文件，将下面的配置添加至该文件：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;CorsFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.apache.catalina.filters.CorsFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CorsFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　注意：geoserver默认的管理员账号为：admin/geoserver&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 24 Jan 2019 07:25:00 +0000</pubDate>
<dc:creator>王小豆又叫小王子</dc:creator>
<og:description>首先介绍下Geoserver是用来做什么的？ GeoServer是一个基于Java的软件服务器，允许用户查看和编辑地理空间数据。使用开放地理空间联盟（OGC）提出的开放标准，GeoServer可以在地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mohanchen/p/10314732.html</dc:identifier>
</item>
<item>
<title>小程序场景流程化构建 - Yika丶J</title>
<link>http://www.cnblogs.com/YikaJ/p/10314697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YikaJ/p/10314697.html</guid>
<description>&lt;h2 id=&quot;what-is-流程&quot;&gt;What is 流程&lt;/h2&gt;
&lt;p&gt;第一步我们需要对流程有一个认识，需要知道一个流程的基本形态是怎样的。&lt;/p&gt;
&lt;h3 id=&quot;流程案例&quot;&gt;流程案例&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用 APP 第三方支付时，点击选择使用微信支付后会拉起应用，用户可以选择各种银行卡或信用卡进行支付，若密码失败则在微信内继续处理，最终跳回 APP 后确认支付成功后，即可进行后续处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用 APP 第三方登录时，点击选择使用 QQ 登录后会拉起应用，用户可以选择快速登录或输入账号密码进行登录，若密码失败则在 QQ 内继续处理，最终跳回 APP 后确认为登录成功后，即可进行后续处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用微信小程序人脸识别时，点击开始使用人脸识别后会拉起微信的人脸识别，若识别失败则在人脸识别内重新进行人脸识别，最终回到拉起人脸识别前的那个页面，得到是否成功的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;流程抽象&quot;&gt;流程抽象&lt;/h3&gt;
&lt;p&gt;从上面的案例来看，其实我大部分都是 Copy/Paste 的文案，说明一个流程的基本形态是很固定的，它不仅限于在 APP 之间的跳转，小程序与微信 API 的使用，在任何我们认为属于流程的场景，我们都可以尝试去构建我们自己的流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670552/201901/670552-20190124152207669-466950811.jpg&quot; alt=&quot;基础流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将刚才说的以流程图来表示就是这样的，各种复杂的处理都在流程页面内，业务页面最终只需要知道成功还是失败即可。如果我们以开发者的角度来看，我们在业务侧只需要这样处理。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 对开发者来说，是可以抽象成一个 Promise 来表示的。
// pending 表示流程未结束
// resolve 表示流程返回成功
// reject  表示流程返回失败

sdk.pay(opts).then(successHandler).catch(failHandler)
sdk.face(opts).then(successHandler).catch(failHandler)
sdk.login(opts).then(successHandler).catch(failHandler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对开发者来说，这样的流程调用只能说非常的清爽！当流程结束后，开发者可以在 &lt;code&gt;then&lt;/code&gt; 里进行后续处理。若无法正常开启流程或用户主动取消流程，则可以在 &lt;code&gt;catch&lt;/code&gt; 内进行处理。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;一般我们会在各种通用场景下，都会需要调用流程。当你发现你的项目，在各种场景下都可能需要某个流程时，你就可以开始考虑将相关内容抽象流程化。&lt;/p&gt;
&lt;p&gt;在我们开发政务服务相关的小程序时，在整个小程序内，我们都需要涉及实名校验，整个流程一环扣一环，远远不是检查一下是否要登录就选择登录这么简单的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670552/201901/670552-20190124152224421-517246497.jpg&quot; alt=&quot;认证流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里是一个政务服务的认证场景，场景的流程是很长的。&lt;/p&gt;
&lt;h2 id=&quot;why-we-need-流程&quot;&gt;Why we need 流程&lt;/h2&gt;
&lt;p&gt;知道大致什么样的形态我们可以称为流程后，就需要思考一下在开发阶段为什么需要抽象流程。&lt;/p&gt;
&lt;h3 id=&quot;流程优势&quot;&gt;流程优势&lt;/h3&gt;
&lt;p&gt;我在实际使用场景下感觉到的优势：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在任何需要掉起流程地方都可以调起流程。&lt;/li&gt;
&lt;li&gt;开发者只需关心流程成功还是失败，无需知道内部复杂实现。&lt;/li&gt;
&lt;li&gt;多个简单的流程可自由组合成一个复杂流程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果我们把上面的实名认证进行流程化抽象后，我们可以得到下面这样的流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670552/201901/670552-20190124152246779-2039599366.jpg&quot; alt=&quot;抽象认证流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们把流程拆分出来后，逻辑就简单很多了，每一个流程都是独立的模块。各个模块之间还可以互相调用，来组合出一个更大型的流程。&lt;/p&gt;
&lt;h3 id=&quot;流程哲学&quot;&gt;流程哲学&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;程序应该只关注一个目标，并尽可能把它做好。让程序能够互相协同工作。应该让程序处理文本数据流，因为这是一个通用的接口。 —— Malcolm Douglas McIlroy 道格拉斯·麦克罗伊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这里也符合 unix 哲学，每个流程只做一件事。这样我们只需要维护好单个流程内部的逻辑就可以了，每个流程返回的数据还可以带到下一个流程内进行使用，这非常像一个 Promise 链。&lt;/p&gt;
&lt;h2 id=&quot;how-to-make-流程&quot;&gt;How to make 流程&lt;/h2&gt;
&lt;p&gt;在我们知道是什么、为什么后，就可以看看具体到代码层面上我们如何去构建流程，当然这里的场景是小程序，但只要是 SPA 架构的 web 页面，类似的思路一样是可以尝试使用的。我们先来整理一下所需开发的功能点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;何时知道要跳回起始页面&lt;/li&gt;
&lt;li&gt;怎么知道起始页面是哪个&lt;/li&gt;
&lt;li&gt;多流程的数据流向是怎样的。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;基本原理&quot;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;其实问题很简单，解决方法也是我为什么说需要 SPA 架构进行实现。我们只需要在调用 API 后，记录当前页面栈并全局监听一个事件。当流程结束后，我们再通过事件通知来决定是否需要跳回调用页。我们只需要记录页面栈，配合全局唯一的事件，跨页面通信并进行相应处理。而多数据流向，我们是可以通过前一个流程返回的数据直接带到新流程进行使用。&lt;/p&gt;
&lt;p&gt;以下提供基本代码，除基础库外，示例代码不可直接运行（有许多伪代码）。&lt;/p&gt;
&lt;p&gt;流程基础库&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;  // sdk.js

  interface FlowOpts {
    // 决定是如何开启一个流程
    startType: 'navigateTo' | 'redirctTo',      
    // 流程结束后，是否需要保留当前页面
    finishType: 'keep' | 'pop',
    // 带给页面的参数
    params: Record&amp;lt;string, any&amp;gt;
  }

  /**
   * 创建通用流程
   * @param url 跳转参数
   * @param options 创建参数，具体类型参照 FlowOpts
   * @return Promise Response
   */
  function createFlow(url: string, options: FlowOpts = {}) {
    const startPageLength = getCurrentPages().length
    const successEvent = url + '-' + extend.generateGUID()

    options.startType = options.startType || 'navigateTo'
    options.finishType = options.finishType || 'pop'
    options.params = options.params || {}

    const urlWithOptions = urlJoinParams(url, {
        successEvent,
        ...options.params
    })

    return new Promise((resolve, reject) =&amp;gt; {
      Event.addEventListener(successEvent, (res: any) =&amp;gt; {
        if (options.finishType === 'keep') {
          // 保存到当前页面
          resolve(res.target)
        } else {
          // 如果是弹回流程开始页
          udb.navigatoBackToStart(startPageLength)
            .then(() =&amp;gt; {
              resolve(res.target)
            })
        }
      })
  
      wx[options.finishType]({
        url: urlWithOptions,
        complete() {
          Event.removeEventListener(successEvent)
        }
      })
    })
  },

  // 流程跳回开始
  navigatoBackToStart(startPageLength: number) {
    return new Promise((resolve, reject) =&amp;gt; {
      const endPageLength = getCurrentPages().length
      const delta = endPageLength - startPageLength

      // 回退页面
      wx.navigateBack({ delta })
      delayResolve()

      // 确保异步回退成功
      function delayResolve() {
        setTimeout(() =&amp;gt; {
          const currentPageLength = getCurrentPages().length
          if (endPageLength &amp;gt; 1 &amp;amp;&amp;amp; startPageLength === currentPageLength) {
            resolve()
          } else {
            delayResolve()
          }
        }, 100)
      }
    })
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建流程&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// my-flow.js

// 业务创建流程
function startFlowOne(options) {
  if(!canStart) {
    // 能否发起流程的业务逻辑判断
    return Promise.reject()
  }

  return createFlow('/pages/flow-one/index', options)
}
function startFlowTwo(options) {
  return createFlow('/pages/flow-two/index', options)
}
// 组合流程
function startFlowOneTwo(options) {
  return startFlowOne({
    startType: 'keep',
    params: options
  }).then(flowRes =&amp;gt; {
    // 多流程数据合并
    return startFlowTwo({
      params: {
        ...flowRes,
        ...options
      }
    })
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体流程页面，处理完业务后发起成功事件&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// page/flow-one/index.js

Page({
  onLoad(parmas) {
    if(params) {
      this.successEvent = params.successEvent
    }
  },
  handleSubmit() {
    request({
      url: 'example.com',
      data: params,
      methods: 'POST'
    }).then((res) =&amp;gt; {
      Event.dispatch(this.successEvent, res)
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真正提供到给业务开发使用。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// pages/index/index.js

Page({
  handleTap() {
    // 非常简单！
    return sdk.startFlowOneTwo({ id: 3 })
      .then((res) =&amp;gt; {
        // 成功后的业务代码
      })
      .catch(() =&amp;gt; {
        // 无法正常调起流程
      })
  }
}) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码，我们就可以把业务再进行合理抽象，通过流程化降低业务复杂度。&lt;/p&gt;
&lt;h2 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h2&gt;
&lt;p&gt;在小程序上使用还有哪些特别要注意的点呢，其中有一个就是要千万注意页面栈的问题。在小程序内是有十层页面栈限制的，如果你的流程特别的长，需要格外注意这一点并进行相应的优化。但如果我们在 web 页面使用，是没有这类问题的。&lt;/p&gt;
&lt;h2 id=&quot;ending&quot;&gt;Ending&lt;/h2&gt;
&lt;p&gt;快去尝试将你的业务场景流程化吧！&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:24:00 +0000</pubDate>
<dc:creator>Yika丶J</dc:creator>
<og:description>What is 流程 第一步我们需要对流程有一个认识，需要知道一个流程的基本形态是怎样的。 流程案例 使用 APP 第三方支付时，点击选择使用微信支付后会拉起应用，用户可以选择各种银行卡或信用卡进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YikaJ/p/10314697.html</dc:identifier>
</item>
<item>
<title>理解webpack4.splitChunks - 渴望做梦</title>
<link>http://www.cnblogs.com/kwzm/p/10314438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwzm/p/10314438.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;之前一直也没有研究过webpack4是基于怎样的规则去拆分模块的，现在正好有时间打算好好了解一下，看了官方文档也陆陆续续的看了看网上别人写的文章，感觉大部分都是将官方文档翻译了一遍，很多问题都没有解释清楚，无奈只好自己写demo去通过实际编译结果来理解，经过一天多的不断调试和百度，基本弄清楚了splitChuns的运行规则了，特此记录下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、webpack中的三个概念module、chunk和bundle&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在研究splitChunks之前，我们必须先弄明白这三个名词是什么意思，主要是chunk的含义，要不然你就不知道splitChunks是在什么的基础上进行拆分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从官网上貌似没找太多的解释，去网上搜了搜基本上都在转述这位老哥的回答&lt;a href=&quot;https://stackoverflow.com/questions/42523436/what-are-module-chunk-and-bundle-in-webpack&quot; target=&quot;_blank&quot;&gt;《what are module,chunk and bundle in webpack》&lt;/a&gt;，我根据自己的理解给出我个人的看法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;module：就是js的模块化webpack支持commonJS、ES6等模块化规范，简单来说就是你通过import语句引入的代码。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;chunk: chunk是webpack根据功能拆分出来的，包含三种情况：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　1、你的项目入口（entry）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、通过Import()动态引入的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、通过splitChunks拆分出来的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　chunk包含着module，可能是一对多也可能是一对一。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;bundle：bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，bundle就是对chunk进行编译压缩打包等处理之后的产出。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、splitChunks&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、默认配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;下面进入正题讲解splitChunks，splitChunks就算你什么配置都不做它也是生效的，源于webpack有一个默认配置，这也符合webpack4的开箱即用的特性，它的默认配置如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  optimization: {
    splitChunks: {
      chunks: &lt;/span&gt;'async'&lt;span&gt;,
      minSize: &lt;/span&gt;30000&lt;span&gt;,
      minChunks: &lt;/span&gt;1&lt;span&gt;,
      maxAsyncRequests: &lt;/span&gt;5&lt;span&gt;,
      maxInitialRequests: &lt;/span&gt;3&lt;span&gt;,
      automaticNameDelimiter: &lt;/span&gt;'~'&lt;span&gt;,
      name: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      cacheGroups: {
        vendors: {
          test: &lt;/span&gt;/[\\/]node_modules[\\/]/&lt;span&gt;,
          priority: &lt;/span&gt;-10&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: {
          minChunks: &lt;/span&gt;2&lt;span&gt;,
          priority: &lt;/span&gt;-20&lt;span&gt;,
          reuseExistingChunk: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }
    }
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们现在用一个简单的react项目来测试下打包之后的效果如何，我的这个项目有两个页面entry1.js和page1.js，entry1.js是入口文件，entry1.js里面动态引入了page1.js。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;entry1.js&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import React from 'react'
&lt;span&gt; 2&lt;/span&gt; import ReactDOM from 'react-dom'
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; const App = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   let Page1 = &lt;span&gt;null&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   import(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;page1&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;'./routes/page1').then(comp =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Page1 =&lt;span&gt; comp
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  console.log($)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &amp;lt;div&amp;gt;
&lt;span&gt;14&lt;/span&gt;       &amp;lt;div&amp;gt;App&amp;lt;/div&amp;gt;
&lt;span&gt;15&lt;/span&gt;       &amp;lt;Page1 /&amp;gt;
&lt;span&gt;16&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  )
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById('root'))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;page1.js&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import React from 'react'
&lt;span&gt; 2&lt;/span&gt; import _ from 'lodash'
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; const Page1 = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  console.log($)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &amp;lt;div&amp;gt;
&lt;span&gt;10&lt;/span&gt;       &amp;lt;div&amp;gt;Page1&amp;lt;/div&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  )
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt; Page1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;让我们想一想打包之后的代码是怎样的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/708604/201901/708604-20190124145744042-388973749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上就是打包之后的代码，是否如你所想呢，让我们分析一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、第一个main文件就是打包之后的入口文件，这个我们上面说了webpack会把入口文件单独拆成一个chunk，这个没有问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、第三个page1文件，我们上面也说过动态加载得文件webpack会将其拆分为一个chunk，这个也没有问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、第二个vendor~page1文件，这个是对page1文件里面引入的第三方库进行打吧，具体就是lodash那个第三方库了，这个涉及到cacheGroup，我们稍后会讲到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上就是所有被拆分出来的包，但是我们发现有一个文件没有拆分出来，那就是entry1里面引入的第三方库react-dom，这个是为什么呢，这个就要涉及到我们接下来讲到的chunks属性的配置，让我们下回再说。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:09:00 +0000</pubDate>
<dc:creator>渴望做梦</dc:creator>
<og:description>一、前言 之前一直也没有研究过webpack4是基于怎样的规则去拆分模块的，现在正好有时间打算好好了解一下，看了官方文档也陆陆续续的看了看网上别人写的文章，感觉大部分都是将官方文档翻译了一遍，很多问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwzm/p/10314438.html</dc:identifier>
</item>
<item>
<title>ReentrantLock和ReentrantReadWriteLock对比 - 追梦1819</title>
<link>http://www.cnblogs.com/yanfei1819/p/10314533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanfei1819/p/10314533.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文系作者原创，转载请注明：https://www.cnblogs.com/yanfei1819/p/10314533.html&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;reentrantlock&quot;&gt;ReentrantLock&lt;/h3&gt;
&lt;h4 id=&quot;一简介&quot;&gt;一、简介&lt;/h4&gt;
&lt;p&gt;ReentrantLock重入锁和synchronize关键字一样，是互斥锁。比synchronize关键字更加灵活。&lt;/p&gt;
&lt;h4 id=&quot;二基本方法&quot;&gt;二、基本方法&lt;/h4&gt;
&lt;h4 id=&quot;三与synchronize对比&quot;&gt;三、与synchronize对比&lt;/h4&gt;
&lt;ol readability=&quot;23&quot;&gt;&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;demo演示&lt;/p&gt;
&lt;p&gt;线程不安全：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WriteAndReadThread {
    public static void main(String[] args) {
        Person person = new Person();
        Thread t1 = new Output(person);
        Thread t2 = new Input(person);
        t1.start();
        t2.start();
    }
}
// 写数据的线程
class Output extends Thread {
    private Person person;
    public Output(Person person) {
        this.person = person;
    }
    @Override
    public void run() {
        int count = 0;
        while (true) {
            if (count == 0) {
                person.name = &quot;小明&quot;;
                person.gender = &quot;男&quot;;
            } else {
                person.name = &quot;小红&quot;;
                person.gender = &quot;女&quot;;
            }
            count = (count + 1) % 2; // 奇数偶数轮流展现
            person.flag = true;
        }
    }
}
// 读数据的线程
class Input extends Thread {
    private Person person;
    public Input(Person person) {
        this.person = person;
    }
    @Override
    public void run() {
        while (true) {
            System.out.println(person.name + &quot;,&quot; + person.gender);
        }
    }
}
class Person {
    public String name;
    public String gender;
    public boolean flag = false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码没有考虑线程安全问题，读写线程会竞争共享资源，导致数据紊乱。&lt;/p&gt;
&lt;p&gt;1）线程安全（加synchronize关键字）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadTwo {
    public static void main(String[] args) {
        Person person = new Person();
        Thread t1 = new Output(person);
        Thread t2 = new Input(person);
        t1.start();
        t2.start();
    }
}

// 写的线程
class Output extends Thread{
    private Person person;
    public Output(Person person){
        this.person=person;
    }
    @Override
    public void run(){
        int count = 0;
        while (true){
            synchronized (person){
                if(person.flag){
                    try {
                        person.wait(); // 唤醒等待的线程
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                if(count==0){
                    person.name=&quot;小明&quot;;
                    person.gender=&quot;男&quot;;
                }else {
                    person.name=&quot;小红&quot;;
                    person.gender=&quot;女&quot;;
                }
                count=(count+1)%2;
                person.flag=true;
                person.notify();
            }
        }
    }
}
// 读数据的线程
class Input extends Thread{
    private Person person;
    public Input(Person person){
        this.person=person;
    }
    @Override
    public void run(){
        while (true){
            synchronized (person){
                if(!person.flag){
                    try {
                        person.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(person.name+&quot;,&quot;+person.gender);
                person.flag=false;
                person.notify();
            }
        }
    }
}
class Person{
    public String name;
    public String gender;
    public boolean flag=false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）线程安全（用Lock）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LockDemo {
    public static void main(String[] args) {
        Person2 person2 = new Person2();
        Condition condition = person2.lock.newCondition();
        Input2 input2 = new Input2(person2,condition);
        Output2 output2 = new Output2(person2,condition);
        input2.start();
        output2.start();
    }
}

// 写的线程
class Output2 extends Thread {
    private Person2 person;
    private Condition condition;
    public Output2(Person2 person, Condition condition) {
        this.person = person;
        this.condition = condition;
    }
    @Override
    public void run() {
        int count = 0;
        while (true) {
            try {
                person.lock.lock();
                if (person.flag) {
                    try {
                        condition.await(); // 使线程休眠，作用等于synchronize中的thread.wait()方法
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                if (count == 0) {
                    person.name = &quot;小明&quot;;
                    person.gender = &quot;男&quot;;
                } else {
                    person.name = &quot;小红&quot;;
                    person.gender = &quot;女&quot;;
                }
                count = (count + 1) % 2;
                person.flag = true;
                condition.signal();
            }catch (Exception e){
            }finally {
                person.lock.unlock(); // 必须手动关闭线程
            }
        }
    }
}

// 读的线程
class Input2 extends Thread {
    private Person2 person;
    private Condition condition; // 该接口的作用是精确控制锁的行为
    public Input2(Person2 person, Condition condition) {
        this.person = person;
        this.condition = condition;
    }

    @Override
    public void run() {
        while (true) {
            try {
                person.lock.lock();
                if (!person.flag) {
                    try {
                        condition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(person.name + &quot;,&quot; + person.gender);
                person.flag = false;
                condition.signal();//唤醒线程
            }catch (Exception e){

            }finally {
                person.lock.unlock();
            }
        }
    }
}

class Person2 {
    public String name;
    public String gender;
    public boolean flag = false; // 该属性是用来控制线程之间的通讯
    Lock lock = new ReentrantLock();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;p&gt;​ 都是用于线程同步锁，都是互斥锁。&lt;/p&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;p&gt;​ 1.如果用汽车来类比，synchronize相当于自动挡，Lock相当于手动挡。即：synchronize是内置锁，只要加上synchronize的代码的地方开始，代码结束的地方自动释放资源。lock必须手动加锁，手动释放资源。&lt;/p&gt;
&lt;p&gt;​ 2.synchronize优点是代码量少，自动化。缺点是扩展性低，不够灵活。&lt;/p&gt;
&lt;p&gt;​ 3.Lock优点是扩展性好，灵活。缺点是代码量相对稍多。&lt;/p&gt;
&lt;p&gt;​ 4.释放锁的情况：&lt;/p&gt;
&lt;p&gt;​ synchronize：1）线程执行完毕；2）线程发生异常；3）线程进入休眠状态。&lt;/p&gt;
&lt;p&gt;​ Lock：通过unLock()方法。&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;​ 1.wait()和notify()/notifyAll()必须出现在synchronize修饰的代码块中；&lt;/p&gt;
&lt;p&gt;​ 2.资源的释放通常放在finally中；&lt;/p&gt;
&lt;p&gt;​ 3.最好不要将lock()方法写在try{}中，因为如果 发生异常的话，抛出异常，同时锁资源无法释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;reentrantreadwritelock&quot;&gt;ReentrantReadWriteLock&lt;/h3&gt;
&lt;h4 id=&quot;一简介-1&quot;&gt;一、简介&lt;/h4&gt;
&lt;p&gt;​ ReentrantLock虽然可以灵活地实现线程安全，但是他是一种完全互斥锁，即某一时刻永远只允许一个线程访问共享资源，不管是读数据的线程还是写数据的线程。这导致的结果就是，效率低下。&lt;/p&gt;
&lt;p&gt;​ ReentrantReadWriteLock类的出现很好的解决了该问题。该类实现了ReadWriteLock接口，而ReadWriteLock接口中维护了两个锁：读锁（共享锁）和写锁（排他锁）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二基本方法-1&quot;&gt;二、基本方法&lt;/h4&gt;
&lt;h4 id=&quot;三使用&quot;&gt;三、使用&lt;/h4&gt;
&lt;p&gt;​ ReentrantReadWriteLock中维护了读锁和写锁。允许线程同时读取共享资源；但是如果有一个线程是写数据，那么其他线程就不能去读写该资源。即会出现三种情况：读读共享，写写互斥，读写互斥。&lt;/p&gt;
&lt;p&gt;以下以代码演示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
        Lock readLock = reentrantReadWriteLock.readLock();
        Lock writeLock = reentrantReadWriteLock.readLock();
        new Thread(new Runnable() {
            @Override
            public void run() {
                // writeLock.lock(); // 写锁加锁
                readLock.lock(); // 读锁加锁
                try {
                    for (int i = 0; i &amp;lt; 10; i++) {
                        System.out.println(&quot;我是第一个线程，线程名是&quot;+Thread.currentThread().getName()+&quot;，当前时间是&quot;+System.currentTimeMillis());
                    }
                    Thread.sleep(2000); // 休眠2s
                }catch (Exception e){
                }finally {
                    // writeLock.unlock();// 写锁释放锁
                    readLock.unlock();// 读锁释放锁
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                // writeLock.lock(); // 写锁加锁
                readLock.lock();// 读锁加锁
                try {
                    for (int i = 0; i &amp;lt; 10; i++) {
                        System.out.println(&quot;我是第二个线程，线程名是&quot;+Thread.currentThread().getName()+&quot;，当前时间是&quot;+System.currentTimeMillis());
                    }
                }catch (Exception e){
                }finally {
                    // writeLock.unlock();// 写锁释放锁
                    readLock.unlock();
                }
            }
        }).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两个线程如果是读锁，则会同时执行（打印的时间几乎相等），但是如果是写锁，则不会同时执行（打印时间相差2s）。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:07:00 +0000</pubDate>
<dc:creator>追梦1819</dc:creator>
<og:description>本文系作者原创，转载请注明：https://www.cnblogs.com/yanfei1819/p/10314533.html ReentrantLock 一、简介 ReentrantLock重入锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanfei1819/p/10314533.html</dc:identifier>
</item>
<item>
<title>知名协作工具 Slack 换新 logo 啦！ - 极光推送</title>
<link>http://www.cnblogs.com/jpush88/p/10314591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpush88/p/10314591.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;简评：本文系译文。Slack 在自家 Blog 上解释了新的设计 —— 旧版的 logo 有 11 种颜色，在非白色背景的情况下，logo 不仅难看，而且很容易在多个地方上表现不一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新年换新装，Slack 已经用新的 logo 来迎接 2019 年了。目前在平台上已经更换完毕，所以现在已经是新的 logo 囖 ~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/09496c72e85efc4f8ca091ac7dce669762d.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于新旧 logo 变更可能引发的争议，Slack 显然已经有所准备。&lt;/p&gt;
&lt;p&gt;首先，它并不是为了改变而改变，这次改变后的 logo 会比原来的更具有现代感，样式也会更简单。&lt;/p&gt;
&lt;p&gt;Slack 的第一个 logo 是在公司成立时创建的，我们把它设计成一个类似「#」的样子，它由 11 种不同的颜色组成，因此很容易出错。&lt;/p&gt;
&lt;p&gt;如果 logo 放在不是白色的其他颜色上，或者角度没控制好的话（精确的 18°），看起来都会很糟糕，看看下面的例子就知道了👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/b293f8f4fc1996d40029e5e15e144b76372.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个问题，我们设计了不同版本的 logo 来降低影响。但这也意味着每个平台或者 App 上的按钮不尽相同，而每个按钮又与 logo 不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/3b0d06f19c0f014f84c5abe6857d712e912.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管这几个不同版本都还不错，但是这也造成了品牌辨识度下降的问题。品牌的第一要义就是 —— 无论何时何地，人们一看到你，就能认识你。&lt;/p&gt;
&lt;p&gt;而下面这些简直就是教科书式的反例👇&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/07f5624c2c3ebd40ffa732f9608f442097a.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我们内部的设计团队、品牌团队协同 Michael Bierut 及其 Pentagram 团队，合力创造了一个更具品牌一体性的全新视觉形象，也就是我们今天开始使用的新图标。&lt;/p&gt;
&lt;p&gt;新的 logo 使用更简洁的色彩搭配，直接回归到最原本的四种颜色：浅蓝、红色、黄色和绿色。&lt;/p&gt;
&lt;p&gt;我们认为它比旧版 logo 要更加精致，但依然包含了原始精神 (the spirit of the original)。它也能帮助我们的产品在更多地方扩展和更好地工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/dbed63241bb7eeff5d15be269ff2067ca7c.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于其中的设计理念、以及新 logo 中每个角度每条曲线的意义，本文都不会过多阐述。&lt;/p&gt;
&lt;p&gt;本文的目的也仅仅是让用户知道这个变化 —— 当你在不同设备上发现图标似乎有些不同时，惊讶之余又会觉得它们看起来有种让人心安的相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/61f22e2f23d82d0b9fac81ae47f23e85b1c.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.5714285714286&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//slackhq.com/say-hello-new-logo%3Futm_source%3Dwanqu.co%26utm_campaign%3DWanqu%2BDaily%26utm_medium%3Dwebsite&quot; title=&quot;Say hello, new logo.&quot;&gt;Say hello, new logo.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 24 Jan 2019 07:06:00 +0000</pubDate>
<dc:creator>极光推送</dc:creator>
<og:description>简评：本文系译文。Slack 在自家 Blog 上解释了新的设计 —— 旧版的 logo 有 11 种颜色，在非白色背景的情况下，logo 不仅难看，而且很容易在多个地方上表现不一致。 新年换新装，S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpush88/p/10314591.html</dc:identifier>
</item>
<item>
<title>vue监听页面大小变化重新刷新布局 - 紫藤萝yu</title>
<link>http://www.cnblogs.com/luoxuemei/p/10314221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoxuemei/p/10314221.html</guid>
<description>&lt;p&gt;在项目中由于某些div元素在布局的时候需要初始化宽高，因为当浏览器缩小屏幕的时候需要重新刷新页面视图。&lt;/p&gt;
&lt;p&gt; 分析思路：&lt;/p&gt;
&lt;p&gt;　　1、在store中创建state，用于保存当前浏览器的宽、高值。&lt;/p&gt;
&lt;p&gt;　　2、在mounted中，使用window.onresize，监听页面大小是否发生变化。若发生变化则，则this.$store.commit修改store中的的宽、高；&lt;/p&gt;
&lt;p&gt;　　3、在computed中获取到宽高的值。由于页面宽或者高其中一个变化都需要重新进行页面视图刷新，因此在computed中进行宽高合并，只需要监听合并后的值widthOrHight既可。&lt;/p&gt;
&lt;p&gt;　　4、在watch中监听widthOrHight，若widthOrHight发生变化，则重新初始化div的宽高。&lt;/p&gt;
&lt;p&gt;　　　　另外，由于子组件中图表初始化的宽高是父组件的宽高，在父组件中页面视图重新发生了变化，需要子组件重新渲染视图，因此只需要给子组件定义一个key值，然后修改key值则子组件会重新初始化。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;省略DOM代码&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;videoDoorCtrl &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height: 90%;width: 100%;background-color: rgba(2, 31, 95, 0.3);&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;compKey.videoDoorCtrl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;videoDoorCtrl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;里面是echarts图表&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;wifiCollect &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height: 90%;width: 100%;background-color: rgba(2, 31, 95, 0.3);&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;compKey.wifiCollect&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;wifiCollect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;里面是echarts图表&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  import { mapGetters } from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vuex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  import videoDoorCtrl from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./components/videoDoorCtrl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频门禁信息&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  import wifiCollect from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./components/wifiCollect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wifi数据采集&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deviceQueryEle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    components:{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      videoDoorCtrl,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      wifiCollect
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    data() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        compKey:{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          videoDoorCtrl:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;          wifiCollect:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    mounted() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;      window.onresize &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; () &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.commit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bodyWidthMut&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,document.body.clientWidth);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$store.commit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bodyHightMut&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,document.body.clientHeight);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        })()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    computed: {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;      ...mapGetters([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bodyWidth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bodyHeight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;      widthOrHight(){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并宽高，只需要监听一个值变化既可&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bodyWidth,&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bodyHeight]
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    watch: {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;      widthOrHight(){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听页面宽度或者高度&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        let that &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;          that.initPage();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听到页面size发生变化，则重新初始化div的宽高&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;          const index &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随便定义一个随机数&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;          that.compKey.videoDoorCtrl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;that.compKey.videoDoorCtrl&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要刷新子组件的数据，只需要改变子组件的定义的key值&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;          that.compKey.wifiCollect &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; that.compKey.wifiCollect&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要刷新子组件的数据，只需要改变子组件的定义的key值&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }, &lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    computed: {},
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    beforeCreate() {},
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    created() {},
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    methods: {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;      mapFun(param){
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  ……&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;      initPage() {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        let pageHig &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(window).height();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        let pageWidth &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(window).width();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        let pageHeaderHig &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        let pageMainHig &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; pageHig &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; pageHeaderHig;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得出地图部分的区域&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#headerID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(pageHeaderHig);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mainID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(pageMainHig);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mapLeftID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(pageMainHig &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mapLeftID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).width(pageWidth &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;0.23&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mapRightID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(pageMainHig &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mapRightID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).width(pageWidth &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;0.23&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        mapFun(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapParam);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化地图&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet/scss&quot;&lt;/span&gt;&lt;span&gt; lang&lt;/span&gt;&lt;span&gt;=&quot;scss&quot;&lt;/span&gt;&lt;span&gt; scoped&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 24 Jan 2019 06:53:00 +0000</pubDate>
<dc:creator>紫藤萝yu</dc:creator>
<og:description>在项目中由于某些div元素在布局的时候需要初始化宽高，因为当浏览器缩小屏幕的时候需要重新刷新页面视图。 分析思路： 1、在store中创建state，用于保存当前浏览器的宽、高值。 2、在mounte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luoxuemei/p/10314221.html</dc:identifier>
</item>
</channel>
</rss>