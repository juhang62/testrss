<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Docker入门（一）用hello world入门docker - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10342101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10342101.html</guid>
<description>&lt;h3 id=&quot;初识docker&quot;&gt;初识Docker&lt;/h3&gt;
&lt;h4 id=&quot;docker是什么&quot;&gt;Docker是什么？&lt;/h4&gt;
&lt;p&gt;  Docker 是一个开源的应用容器引擎，基于 Go 语言并遵从Apache2.0协议开源。&lt;br/&gt;  Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;br/&gt;  容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-07636b7aedefa57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;docker与传统虚拟化的不同之处&quot;&gt;Docker与传统虚拟化的不同之处&lt;/h4&gt;
&lt;p&gt;  Docker与传统虚拟化的不同之处在于：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;
&lt;h4 id=&quot;docker的优势&quot;&gt;Docker的优势&lt;/h4&gt;
&lt;p&gt;  Docker的五大优势为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;持续集成&lt;/li&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于其说明，具体可参考网址：http://dockone.io/article/389 。&lt;/p&gt;
&lt;h3 id=&quot;docker的安装&quot;&gt;Docker的安装&lt;/h3&gt;
&lt;p&gt;  本文以Mac系统为例，讲解Docker的安装，其它系统的安装方式可参考：&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/install/&quot;&gt;安装 Docker&lt;/a&gt; 。&lt;/p&gt;
&lt;h5 id=&quot;使用-homebrew-安装&quot;&gt;使用 Homebrew 安装&lt;/h5&gt;
&lt;p&gt;  &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt; 的 &lt;a href=&quot;https://caskroom.github.io/&quot;&gt;Cask&lt;/a&gt; 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew cask install docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;手动下载安装&quot;&gt;手动下载安装&lt;/h5&gt;
&lt;p&gt;  如果需要手动下载，可以通过这个链接下载：&lt;a href=&quot;https://download.docker.com/mac/stable/Docker.dmg&quot; class=&quot;uri&quot;&gt;https://download.docker.com/mac/stable/Docker.dmg&lt;/a&gt; 。如同 MacOS 其它软件一样，安装也非常简单，双击下载的 &lt;code&gt;.dmg&lt;/code&gt; 文件，然后将鲸鱼图标拖拽到 &lt;code&gt;Application&lt;/code&gt; 文件夹即可。&lt;/p&gt;
&lt;h3 id=&quot;启动docker&quot;&gt;启动Docker&lt;/h3&gt;
&lt;p&gt;  从应用中找到 Docker 图标并点击，即可启动Docker，启动后在最上侧的菜单栏状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-c096379135ace36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;启动docker&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  启动终端后，通过命令可以检查安装后的 Docker 版本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker --version
Docker version 18.09.1, build 4c52b90&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  接着我们运行docker中的hello world来验证docker是否安装且启动成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-ac7d4e2d6f8bc02b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;docker run hello-world&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dockerhub账号注册&quot;&gt;Dockerhub账号注册&lt;/h3&gt;
&lt;p&gt;  为了方便展示以及后续的docker使用，我们最好在DockerHub上注册一个自己的账号。 DockerHub，类似于代码管理的Github，可以简单高效地管理我们的docker项目。&lt;br/&gt;  DockerHub的注册地址为：https://hub.docker.com/signup，界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-1efc7d59e1211d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DockerHub注册界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  注册完DockerHub后，我们登录个人账号。点击&lt;code&gt;Create Repository +&lt;/code&gt;按钮新建Docker仓库，名字为dockertest。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-ec8f95d67d29eca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;create repository&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再点击&lt;code&gt;Create&lt;/code&gt;按钮即可。创建后的dockertest项目如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-bad2c0e0d44b834f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dockertest仓库&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  至此，我们已经在DockerHub上创建了一个自己的账号，并且新建的一个dockertest仓库，尽管这个仓库里面没有任何东西。&lt;br/&gt;  下一步，我们往dockertest这个仓库里面装点什么。&lt;/p&gt;
&lt;h3 id=&quot;docker使用实例hello-world&quot;&gt;Docker使用实例：hello world&lt;/h3&gt;
&lt;p&gt;  首先，我们需要用docker在本地打包一个docker镜像，然后对其打标签（tag），然后将其推送（push）至个人的dockerhub账号中的dockertest仓库，最后将该镜像拉下来，并运行。&lt;/p&gt;
&lt;h5 id=&quot;镜像打包&quot;&gt;镜像打包&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;新建mydocker文件夹&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;$ tree mydocker
mydocker
├── src
│   └── test_docker.py
└── test_docker.build&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;test_docker.py代码:&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print &quot;hello world from python!&quot;
print &quot;this is from docker!&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;test_docker.build代码(利用Dockerfile打包镜像):&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;FROM centos:7.2.1511

#环境变量硬编码及时区
ENV ENVIRONMENT DOCKER_PROD
RUN cd / &amp;amp;&amp;amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

# 拷贝并so加密代码
COPY src /root/src

# 工作目录
WORKDIR /root/src/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们不再过多讲述上述Dockerfile中的命令，有兴趣的同学可移步：http://blog.51cto.com/wutengfei/2156797 ， 笔者也会在后续的文章中给出Dockerfile命令的详细讲述。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令行打包镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cd ./mydocker
docker build -f test_docker.build -t hub.docker.com/dockertest:test.1111 .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-0ff04c2d885b58c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;docker打镜像&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;列出镜像&quot;&gt;列出镜像&lt;/h5&gt;
&lt;p&gt;  在打包完镜像后，我们可以列出docker的镜像，查看镜像的ID,方便后续操作。命令为&lt;code&gt;docker images&lt;/code&gt;，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-2566c53521ae9c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;docker images&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可知，我们新打包的docker镜像的ID为be236e996983。&lt;/p&gt;
&lt;h5 id=&quot;推送镜像&quot;&gt;推送镜像&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;打标签（tag）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker tag be236e996983 jclian91/dockertest:hello_world_test_19.01.31.1100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;镜像ID可通过docker images查看。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;登录dockerhub账号&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker login&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再输入自己的账号、密码即可。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;推送（push）镜像&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker push jclian91/dockertest:hello_world_test_19.01.31.1100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有命令的界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-5323625fa0ee8a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;docker推送镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们去dockerhub的dockertest仓库中去查看，发现已经上传一个镜像了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-c2d2077e20644203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;docktest仓库多了一个镜像&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;运行镜像&quot;&gt;运行镜像&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;为了运行新上传的镜像，我们先删除本地打包的镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;$ docker rmi -f be236e996983
Untagged: jclian91/dockertest:hello_world_test_19.01.31.1100
Untagged: jclian91/dockertest@sha256:c2ac02cb725a8256c2d752461133004cc05a6060390220b15a0aaefefc7c95e7
Untagged: hub.docker.com/dockertest:test.1111
Deleted: sha256:be236e996983339318796f588fd5acda1da5f942289a2559f948a4811d68428d
Deleted: sha256:5c46baa463a1e86d0924c493bb0e12888fc6aaefdcaf128d8193406eb0ef4ed1
Deleted: sha256:f76e87a3e84bf1a03e81dfdc53a569a7adce6cfc80bb56d7d2040e118e2848f7&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;拉取（pull）新上传的镜像&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker pull jclian91/dockertest:hello_world_test_19.01.31.1100&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;运行(run)该镜像&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker run -it be236e996983 bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：其中 &lt;code&gt;-i&lt;/code&gt;：交互式操作， &lt;code&gt;-t&lt;/code&gt;：终端，如存在-d参数，&lt;code&gt;-d&lt;/code&gt;：后台运行。&lt;br/&gt;这样我们就能进入到这台用docker创建好的虚拟机内部了，我们在该Linux虚拟机内部运行命令，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@ca9070ce82e1 src]# ls
test_docker.py
[root@ca9070ce82e1 src]# python test_docker.py 
hello world from python!
this is from docker!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;   hello world是所有编程语言的入门例子，在本文中，我们用docker自己创建了一个hello world的例子，用来展示docker的基本用法，希望能给初入门的同学一个明显直观的例子。&lt;br/&gt;   后续的文章将会更多地介绍docker方面的知识，欢迎大家关注，如有任何疑问，请在留言区留言。&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献：&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Docker —— 从入门到实践： https://yeasy.gitbooks.io/docker_practice/content/install/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Docker基本介绍和操作：http://blog.51cto.com/wutengfei/2156381&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Docker 教程： http://www.runoob.com/docker/docker-tutorial.html&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;《第一本Docker书 修订版》 詹姆斯·特恩布尔 人民邮电出版社&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 31 Jan 2019 07:16:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>docker入门第一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10342101.html</dc:identifier>
</item>
<item>
<title>ASP.Net Core 中使用Zookeeper搭建分布式环境中的配置中心系列一：使用Zookeeper.Net组件演示基本的操作 - 菠萝吹雪—Code</title>
<link>http://www.cnblogs.com/runningsmallguo/p/10340343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningsmallguo/p/10340343.html</guid>
<description>&lt;p&gt;前言：马上要过年了，祝大家新年快乐！在过年回家前分享一篇关于Zookeeper的文章，我们都知道现在微服务盛行，大数据、分布式系统中经常会使用到Zookeeper，它是微服务、分布式系统中必不可少的分布式协调框架。它的作用体现在分布式系统中解决了配置中心的问题，以及解决了在分布式环境中不同进程之间争夺资源的问题，也就是分布式锁的功能以及分布式消息队列功能等等。所以在微服务的环境中Zookeeper是现在很多公司首选的分布式协调框架，包括我之前的公司也在使用Zookeeper。说了这么多，没别的就是想说一下Zookeeper的重要性，废话不多说，进入正题。本篇博客只是演示在.Net Core 环境中如何使用Zookeeper组件进行基本的增删改查和一些注意的要点，如果对Zookeeper还不是太了解的话，建议认认真真、仔仔细细地阅读该文章：http://www.cnblogs.com/sunddenly/p/4033574.html   否则可能下面演示的你会看不懂。&lt;/p&gt;


&lt;p&gt;概念：&lt;/p&gt;
&lt;p&gt;Zookeeper是一个开源的分布式协调框架，它具有高性能 、高可用的特点，同时具有严格的顺序访问控制能力（主要是写操作的严格顺序性），基于对ZAB（Zookeeper原子消息广播协议）的实现，它能够很好的保证分布式环境下的数据一致性。也正是基于这样的特征，使得Zookeeper称为解决分布式数据一致性问题的利器，&lt;em id=&quot;__mceDel&quot;&gt;Zookeeper由两部分组成：Zookeeper服务端和客户端。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局一致性：每个server保存一份相同的数据副本，client无论链接哪个server，展示的数据都是一致的，这是最重要的特征。&lt;/li&gt;
&lt;li&gt;可靠性：如果消息其中一台服务器接受，那么将被所有的服务器接受。&lt;/li&gt;
&lt;li&gt;顺序性：包括全局有序性和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。&lt;/li&gt;
&lt;li&gt;数据更新原子性：一次数据更新要么成功，要么失败，不存在中间状态。&lt;/li&gt;
&lt;li&gt;实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失败的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131003725764-259941154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源：（https://www.cnblogs.com/xums/p/7074008.html）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Zookeeper的数据结构模型采用类似于文件系统的树结构。树上的每个节点称为ZNode，而每个节点都可能有一个或者多个子节点。ZNode的节点路径标识方式是由一系列斜杠&quot;/&quot;进行分割的路径表示，必须是绝对路径。既可以向ZNode节点写入、修改和读取数据，也可以创建、删除ZNode节点或ZNode节点下的子节点。&lt;/li&gt;
&lt;li&gt;值的注意的是，Zookeeper的设计目标不是传统的数据库存储或大数据对象存储，而是协同数据的存储，因此在实现的时候，ZNode存储的数据大小不应该超过1MB。另外，每一个节点都有一个ACL（访问控制列表），据此控制该节点的访问权限。&lt;/li&gt;
&lt;li&gt;ZNode数据节点是有生命周期的，其生命周期的长短取决于数据节点的节点类型。节点类型共有四种：持久节点、持久顺序节点、临时节点、临时顺序节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，基本的概念就聊到这里，先有一个印象，如果需要详细的学习，建议认认真真阅读这篇博客：http://www.cnblogs.com/sunddenly/p/4033574.html，下面就开始演示基本的api操作。&lt;/p&gt;


&lt;p&gt; 首先，添加下面的依赖包：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131120739070-3785804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建一个.Net Core的控制台应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131120822978-973383745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Zookeeper的服务端使用的是张辉清老师新书《中小研发团队架构实践》里面的服务，我这里不再安装Zookeeper服务端，只是介绍一下Zookeeper的目录结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Zookeeper目录介绍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）bin：主要的一些运行命令&lt;/p&gt;
&lt;p&gt;（2）conf：存放配置文件，其中我们需要修改zk.cfg&lt;/p&gt;
&lt;p&gt;（3）contrib：附加的一些功能&lt;/p&gt;
&lt;p&gt;（4）dist-maven:mvn编译后的目录&lt;/p&gt;
&lt;p&gt;（5）docs:文档&lt;/p&gt;
&lt;p&gt;（6）lib：需要依赖的jar包&lt;/p&gt;
&lt;p&gt;配置文件zk.cfg文件内容介绍（单机版）&lt;/p&gt;
&lt;p&gt;（1）trickTime:用于计算的时间单元，比如session超时：N*trickTime&lt;/p&gt;
&lt;p&gt;（2）initLimit:用于集群，允许从节点链接并同步到master节点的初始化链接时间，以trickTime的倍数来表示&lt;/p&gt;
&lt;p&gt;（3）syncLimit:用于集群，master主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）&lt;/p&gt;
&lt;p&gt;（4）dataDir:必须配置&lt;/p&gt;
&lt;p&gt;（5）dataLogDir：日志目录，如果不配置会和dataDir公用&lt;/p&gt;
&lt;p&gt;（6）clientPort：链接服务器的端口，默认是2181&lt;/p&gt;
&lt;p&gt;好了就介绍到这里，下面让我会演示关于Zookeeper  API的各种操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何连接Zookeeper的服务端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher.Event;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZookeeperNetCore
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZookeeperClient
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZooKeeper ZK { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置项&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueryPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点状态信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Stat Stat { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ConfigData { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperClient(&lt;span&gt;string&lt;/span&gt; serviceAddress, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout)
        {
            &lt;span&gt;ZK &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new ZooKeeper(serviceAddress, timeout, new ConfigServiceWatcher(this&lt;/span&gt;&lt;span&gt;&lt;span&gt;));&lt;/span&gt;

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端开始连接zookeeper服务器...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接状态：{ZK.getState()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           &lt;span&gt; Thread.Sleep(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1000);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：为什么要加上这行代码，如果不加会出现什么问题&lt;/span&gt;
            Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接状态：{ZK.getState()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取节点的配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ReadConfigDataAsync()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ZK == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stat = &lt;span&gt;await&lt;/span&gt; ZK.existsAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Stat =&lt;span&gt; stat;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataResult = &lt;span&gt;await&lt;/span&gt; ZK.getDataAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetString(dataResult.Data);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher :&lt;span&gt; Watcher&lt;/span&gt;
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZookeeperClient _cs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher(ZookeeperClient cs)
            {
                _cs &lt;/span&gt;=&lt;span&gt; cs;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;  &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper链接成功:{@event.getState() == KeeperState.SyncConnected}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (@event.get_Type() ==&lt;span&gt; EventType.NodeDataChanged)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _cs.ReadConfigDataAsync();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}收到修改此节点【{1}】值的通知，其值已被改为【{2}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, _cs.QueryPath, data);
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131125519056-1431559411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt; 首先，我们来看看创建Zookeeper对象时，应该注意的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131125902681-2064357496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Zookeeper的构造函数参数解释如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131125952950-1855907492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端和zk服务端链接是一个异步的过程，当连接成功后后，客户端会收的一个watch通知，就是调用回调函数：ConfigServiceWatcher.process(WatchedEvent @event)注意这个类ConfigServiceWatcher必须要继承Watcher，重写 process(WatchedEvent @event)，所以就打印出了&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131130355354-1590623501.png&quot; alt=&quot;&quot;/&gt;。关于Zookeeper的watcher后面会详细介绍，不明白的不要紧，后面会通过代码给大家演示。&lt;/p&gt;
&lt;p&gt;（1）connectString：连接服务器的ip字符串，比如: &quot;192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181&quot;可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群，也可以在ip后加路径。&lt;/p&gt;
&lt;p&gt;（2）sessionTimeout：超时时间，心跳收不到了，那就超时&lt;/p&gt;
&lt;p&gt;（3）watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null，在上面的演示中，我们设置了一个watcher。&lt;/p&gt;
&lt;p&gt;（4）canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用。&lt;/p&gt;
&lt;p&gt;（5）sessionId：会话的id&lt;/p&gt;
&lt;p&gt;（6）sessionPasswd：会话密码 当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话。&lt;/p&gt;
&lt;p&gt;好了，基本的参数已经介绍完毕，那么，来解释一下为什么在创建Zookeeper对象时添加下面这句代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131131205072-165590909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实上面我已经解释了，由于客户端和zk服务端链接是一个异步的过程，需要一定的时间间隔，所以，如果不添加效果这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131131422724-1043999846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）zookeeper 恢复之前的会话连接演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher.Event;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZookeeperNetCore
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZookeeperClient
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZooKeeper ZK { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置项&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueryPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点状态信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Stat Stat { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ConfigData { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperClient(&lt;span&gt;string&lt;/span&gt; serviceAddress, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout)
        {
            ZK &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(serviceAddress, timeout, &lt;span&gt;new&lt;/span&gt; ConfigServiceWatcher(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperClient(&lt;span&gt;string&lt;/span&gt; serviceAddress, &lt;span&gt;int&lt;/span&gt; timeout, &lt;span&gt;long&lt;/span&gt; sessionId, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] sessionPasswd)
        {
            ZK &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(serviceAddress, timeout, &lt;span&gt;new&lt;/span&gt; ConfigServiceWatcher2(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;), sessionId, sessionPasswd);

        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取节点的配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ReadConfigDataAsync()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ZK == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stat = &lt;span&gt;await&lt;/span&gt; ZK.existsAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Stat =&lt;span&gt; stat;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataResult = &lt;span&gt;await&lt;/span&gt; ZK.getDataAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetString(dataResult.Data);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher : Watcher
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZookeeperClient _cs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher(ZookeeperClient cs)
            {
                _cs &lt;/span&gt;=&lt;span&gt; cs;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;  &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper链接成功:{@event.getState() == KeeperState.SyncConnected}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (@event.get_Type() ==&lt;span&gt; EventType.NodeDataChanged)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _cs.ReadConfigDataAsync();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}收到修改此节点【{1}】值的通知，其值已被改为【{2}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, _cs.QueryPath, data);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher2 : Watcher
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZookeeperClient _cs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher2(ZookeeperClient cs)
            {
                _cs &lt;/span&gt;=&lt;span&gt; cs;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper链接成功:{@event.getState() == KeeperState.SyncConnected}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (@event.get_Type() ==&lt;span&gt; EventType.NodeDataChanged)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _cs.ReadConfigDataAsync();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}收到修改此节点【{1}】值的通知，其值已被改为【{2}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, _cs.QueryPath, data);
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131133205694-1628921443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131133050184-1330924007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; ZNode创建删除修改查询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher.Event;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.ZooDefs;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZookeeperNetCore
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZookeeperClient
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZooKeeper ZK { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置项&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueryPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点状态信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Stat Stat { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ConfigData { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperClient(&lt;span&gt;string&lt;/span&gt; serviceAddress, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout)
        {
            ZK &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(serviceAddress, timeout, &lt;span&gt;new&lt;/span&gt; ConfigServiceWatcher(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperClient(&lt;span&gt;string&lt;/span&gt; serviceAddress, &lt;span&gt;int&lt;/span&gt; timeout, &lt;span&gt;long&lt;/span&gt; sessionId, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] sessionPasswd)
        {
            ZK &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(serviceAddress, timeout, &lt;span&gt;new&lt;/span&gt; ConfigServiceWatcher2(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;), sessionId, sessionPasswd);

        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取节点的配置数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ReadConfigDataAsync()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ZK == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stat = &lt;span&gt;await&lt;/span&gt; ZK.existsAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Stat =&lt;span&gt; stat;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataResult = &lt;span&gt;await&lt;/span&gt; ZK.getDataAsync(QueryPath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetString(dataResult.Data);
        }

        

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher : Watcher
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZookeeperClient _cs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher(ZookeeperClient cs)
            {
                _cs &lt;/span&gt;=&lt;span&gt; cs;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;  &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper链接成功:{@event.getState() == KeeperState.SyncConnected}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (@event.get_Type() ==&lt;span&gt; EventType.NodeDataChanged)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _cs.ReadConfigDataAsync();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}收到修改此节点【{1}】值的通知，其值已被改为【{2}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, _cs.QueryPath, data);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher2 : Watcher
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZookeeperClient _cs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigServiceWatcher2(ZookeeperClient cs)
            {
                _cs &lt;/span&gt;=&lt;span&gt; cs;
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task process(WatchedEvent @event)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zookeeper链接成功:{@event.getState() == KeeperState.SyncConnected}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (@event.get_Type() ==&lt;span&gt; EventType.NodeDataChanged)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _cs.ReadConfigDataAsync();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}收到修改此节点【{1}】值的通知，其值已被改为【{2}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, _cs.QueryPath, data);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭ZooKeeper连接
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放资源&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Close()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ZK != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
               &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; ZK.closeAsync();
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ZK = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }


        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; org.apache.zookeeper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.ZooDefs;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ZookeeperNetCore
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; timeout = &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conf = &lt;span&gt;new&lt;/span&gt; ZookeeperClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, timeout);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                conf.QueryPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端开始连接zookeeper服务器...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接状态：{conf.ZK.getState()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：为什么要加上这行代码，如果不加会出现什么问题&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接状态：{conf.ZK.getState()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;await&lt;/span&gt; conf.ZK.existsAsync(conf.QueryPath, &lt;span&gt;false&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    conf.ConfigData &lt;/span&gt;= Encoding.Default.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guozheng&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; conf.ZK.createAsync(conf.QueryPath, conf.ConfigData, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
                }

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; configData = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; conf.ReadConfigDataAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;节点【{0}】目前的值为【{1}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, conf.QueryPath, configData);
                Console.ReadLine();


                Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Random((&lt;span&gt;int&lt;/span&gt;)DateTime.Now.Ticks &amp;amp; &lt;span&gt;0x0000FFFF&lt;/span&gt;&lt;span&gt;);
                conf.ConfigData &lt;/span&gt;= Encoding.UTF8.GetBytes(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mike_{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, random.Next(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)));

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; conf.ZK.setDataAsync(conf.QueryPath, conf.ConfigData, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;节点【{0}】的值已被修改为【{1}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, conf.QueryPath, Encoding.UTF8.GetString(conf.ConfigData));

                Console.ReadLine();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;await&lt;/span&gt; conf.ZK.existsAsync(conf.QueryPath, &lt;span&gt;false&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; conf.ZK.deleteAsync(conf.QueryPath, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已删除此【{0}】节点。{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, conf.QueryPath, Environment.NewLine);
                }

            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (conf.ZK == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已关闭ZooKeeper的连接。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Console.ReadLine();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抛出异常：{0}【{1}】。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Environment.NewLine, ex.ToString());
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; conf.Close();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已关闭ZooKeeper的连接。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.ReadLine();
            }



            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/开始会话重连&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(&quot;开始会话重连...&quot;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var conf2 = new ZookeeperClient(&quot;&quot;, timeout, sessionId, sessionPassword);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(conf2.ZK.getSessionId());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine( Encoding.UTF8.GetString(conf2.ZK.getSessionPasswd()));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine($&quot;重新连接状态zkSession：{conf2.ZK.getState()}&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.Sleep(1000);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：为什么要加上这行代码，如果不加会出现什么问题
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine($&quot;重新连接状态zkSession：{conf2.ZK.getState()}&quot;);&lt;/span&gt;
&lt;span&gt;

            Console.ReadKey();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896449/201901/896449-20190131143433642-1121706321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 解释：&lt;/p&gt;
&lt;p&gt;关于异步创建节点的方法，是不支持子节点的递归创建，参数介绍：&lt;/p&gt;
&lt;p&gt;（1）path：创建的路径&lt;/p&gt;
&lt;p&gt;（2）data：存储的数据的byte[]&lt;/p&gt;
&lt;p&gt;（3）acl：控制权限策略   Ids.OPEN_ACL_UNSAFE --&amp;gt; world:anyone:cdrwa      CREATOR_ALL_ACL --&amp;gt; auth:user:password:cdrwa&lt;/p&gt;
&lt;p&gt;（4）createMode： 节点类型, 是一个枚举    PERSISTENT：持久节点   PERSISTENT_SEQUENTIAL：持久顺序节点   EPHEMERAL：临时节点   EPHEMERAL_SEQUENTIAL：临时顺序节点&lt;/p&gt;
&lt;p&gt; 关于上面参数引出来的知识点，需要几章来讲解，本篇文章先不介绍，后面会介绍。好了，关于.Net Core中使用Zookeeper的介绍就到这里，关于上面演示的结果，我先抛出一个问题，大家可以思考一下：为什么“Zookeeper链接成功：True”会输出多次？也就是我们下节要讨论的Zookeeper的watcher机制。时间到了，收拾行李，准备一下回家啦，先写到这里，祝大家新年快乐！希望对你有帮助，过完年来见！&lt;/p&gt;


&lt;p&gt; 可能有些地方解释的不是太清楚，大家多多见谅，有些的不对的地方，希望能指正出来。&lt;/p&gt;
&lt;p&gt;说明：演示代码里面使用的Zookeeper服务过一段时间能用，不能用的话，在评论区留言，后面用阿里云自己搭建一个。&lt;/p&gt;
&lt;p&gt; 代码地址：&lt;/p&gt;
&lt;p&gt; https://github.com/guozheng007/ZookeeperNetCoreDemo&lt;/p&gt;


&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;（1）张辉清：《中小研发团队架构实践》&lt;/p&gt;
&lt;p&gt;（2） 风间影月：《ZooKeeper分布式专题与Dubbo微服务入门》&lt;a class=&quot;course-tname&quot; href=&quot;https://www.imooc.com/u/3078817&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; （3）sunddenly：http://www.cnblogs.com/sunddenly/p/4033574.html&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：郭峥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：http://www.cnblogs.com/runningsmallguo/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 31 Jan 2019 07:00:00 +0000</pubDate>
<dc:creator>菠萝吹雪—Code</dc:creator>
<og:description>前言：马上要过年了，祝大家新年快乐！在过年回家前分享一篇关于Zookeeper的文章，我们都知道现在微服务盛行，大数据、分布式系统中经常会使用到Zookeeper，它是微服务、分布式系统中必不可少的分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningsmallguo/p/10340343.html</dc:identifier>
</item>
<item>
<title>Docker swarm结合Openresty部署rabbitmq集群 - jerry-Tom</title>
<link>http://www.cnblogs.com/mbailing/p/docker_rabbitmq.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mbailing/p/docker_rabbitmq.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Docker swarm结合Openresty部署rabbitmq集群&lt;/h2&gt;

&lt;p&gt;　　大家好，年底了，年味儿越来越浓了．2019年的寒冬被定义为未来10年中最好的一年，对于这一说法悲观的人和乐观的人的理解是不一样的．但是不管是寒冬还是盛夏，我们都应该坚持不断的积累和主动的思考．拥抱变化，坚定信心．&lt;/p&gt;

&lt;p&gt;        简单描述一下我们的需求，就是通过docker 来搭建一套rabbitmq的集群，用于接受业务传来的数据，然后把数据写到消息队列中，然后消费者消费消息，生成日志文件，接着大数据采集系统定时来采集数据．这样做的一个好处就是，我们的服务可以直接部署到业务系统所在的服务器集群中．　　 　　&lt;/p&gt;

&lt;p&gt;　　年末的时候，在忙完了各种活动项目之后，接到了一个新的项目，数据打点项目．需要在各指定机房搭建数据采集服务，然后有数据中心定时去拉取数据．为此我们采用的解决方案是　基于docker　搭建rabbitmq，利用Openresty 来进行数据的生产和nginx代理．来，让我们一起了解一些概念．&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;以下内容是从官网搬来的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;OpenResty&lt;/strong&gt;® 是一个基于 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;OpenResty&lt;/strong&gt;® 通过汇聚各种设计精良的 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 模块（主要由 OpenResty 团队自主开发），从而将 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;OpenResty&lt;/strong&gt;® 的目标是让你的Web服务直接跑在 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 服务内部，充分利用 &lt;a href=&quot;https://openresty.org/cn/nginx.html&quot;&gt;Nginx&lt;/a&gt; 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。&lt;/p&gt;

&lt;p&gt;　　之所以选择OpenResty，是看中了其中nginx服务和对lua脚本的支持，nginx可以做服务代理，lua脚本我们可以用来编写消息生产者的脚本．好了，开始我们的部署之旅吧（再罗嗦一句，你需要提前了解docker，同时保证部署环境已经安装了docker，为了部署成功，请保证有俩台服务器，或者虚拟机也行，同时保持俩台服务器或者虚拟机的ip在统一网段）！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;一．搭建swarm集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　swarm集群的角色包含有leader，node 在swarm集群搭建中，重要的是保证 token的一致&lt;/p&gt;
&lt;p&gt;       1.swarm manager(初始化swarm leader): docker swarm init --advertise-addr 192.168.7.201             &lt;/p&gt;
&lt;p&gt;         提示：这一步会产生token，token为swarm集群的唯一标识&lt;/p&gt;
&lt;p&gt;　   2.swarm group(成员加入集群)&lt;/p&gt;
&lt;p&gt;　　  docker swarm join --token SWMTKN-1-35ucts3e9bg5onl1pyqwh03j1z1micdb88ziq78m4pfr1zulhf-70w2bdzpjyr8xqc1p77mue04r  192.168.7.201:2377&lt;/p&gt;
&lt;p&gt;         token是在初始化swarm manager时返回的．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　  &lt;/strong&gt;&lt;span&gt;注意：记得为集群成员追加label，便于rabbitmq绑定相应的节点，bi-tool-02是节点名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　docker node update --label-add rabbitmq=master bi-tool-02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　docker node update --label-add rabbitmq=slave1 bi-tool-01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;这里的label是我们给swarm集群中各节点起的一个别名，以　docker node update --label-add rabbitmq=master bi-tool-02　为例，是给节点bi-tool-02增加标签，标签为： rabbitmq=master　　，我们可以通过 docker node inspect bi-tool-02 来查看节点配置内容．可以看到的内容如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/span&gt;&quot;Labels&quot;: {&lt;/p&gt;
&lt;p&gt;　　　　　　&quot;rabbitmq&quot;: &quot;master&quot;&lt;/p&gt;
&lt;p&gt;　　　},&lt;/p&gt;
&lt;p&gt;　　追加标签的目的是为了我们在搭建rabbitmq集群的时候，方便rabbitmq节点的绑定．&lt;/p&gt;

&lt;p&gt;　　二．&lt;strong&gt;启动network服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　network 用于提供容器间通许&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;命令：&lt;/strong&gt;docker network create --driver overlay rabbitmq-network&lt;/p&gt;

&lt;p&gt;　　三．&lt;strong&gt;搭建rabbitmq集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; &lt;strong&gt;1.创建镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 docker build -t stomp-rabbitmq:latest .　　&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;创建镜像所需要的dockerfile文件见附件 (博客园不能上传附件吗？？？？等我咨询完了，我再补充这个附件)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        放在了百度网盘上：&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;https://pan.baidu.com/s/1PI1nL6TL9pJxsWUaTBleig   &lt;/span&gt;    &lt;/p&gt;
&lt;p&gt;        提取码：sg9p            &lt;/p&gt;

&lt;p&gt;        &lt;strong&gt;2.创建rabbitmq master队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;命令(&lt;/strong&gt;master)：sudo docker service create --name stomp-rabbitmq-master --hostname=&quot;stomp-rabbitmq-master&quot; --network rabbitmq-network -p 5772:5672 -p 15772:15672 -p 12345:12345 --mount type=bind,target=/var/lib/rabbitmq/,source=/home/agent/rabmq/ --constraint node.labels.rabbitmq==master -e &lt;strong&gt;RABBITMQ_CLUSTER_NODES='rabbit@stomp-rabbitmq-slave1'&lt;/strong&gt; -e &quot;AUTOCLUSTER_CLEANUP=true&quot; -e &quot;CLEANUP_WARN_ONLY=false&quot; -e &quot;RABBITMQ_ERLANG_COOKIE=thisissecretkey&quot;  stomp-rabbitmq:latest&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;要确保/home/agent/rabmq/ 路径的存在&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　--network 为设置网络环境，rabbitmq-network是创建好的docker network，类型为overlay。&lt;/p&gt;
&lt;p&gt;　　-p 为将容器的端口暴露到宿主机的端口上，这样可以通过宿主机也就是服务器的端口访问到容器对应的端口，前方前为宿主机端口，后方为容器端口。其中5672为amqp通信端口，15672为管理界面端口，12345为stomp通信端口。&lt;/p&gt;
&lt;p&gt;　　--mount 为将容器内的目录映射到宿主机上（/var/lib/rabbitmq/ 保存了队列与交换机等的信息，而且保存了持久化的队列里的消息），这样当容器出现问题时，启动新容器时由于已经挂载到了宿主机上持久化，关键信息可以不丢失，新容器相当于和旧容器一样。前方为容器，后方为宿主机目录。&lt;/p&gt;
&lt;p&gt;　　--constraint 为创建service时将service指定在某台机器上创建，本次使用的是通过lable指定，在之前我已经对这三台服务器进行了label指定。&lt;/p&gt;
&lt;p&gt;　　-e 为指定容器内的环境变量，比如其中的    &quot;RABBITMQ_ERLANG_COOKIE=thisissecretkey&quot;&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;3.创建rabbitmq slave 队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　命令(&lt;/strong&gt;slave)：sudo docker service create --name stomp-rabbitmq-slave1 --hostname=&quot;stomp-rabbitmq-slave1&quot; --network rabbitmq-network -p 5773:5672 -p 15773:15672 -p 23456:12345 --mount type=bind,target=/var/lib/rabbitmq/,source=/home/agent/rabmq/ --constraint node.labels.rabbitmq==slave1 -e &lt;strong&gt;RABBITMQ_CLUSTER_NODES='rabbit@rabbitmq-master'&lt;/strong&gt; -e &quot;AUTOCLUSTER_CLEANUP=true&quot; -e &quot;CLEANUP_WARN_ONLY=false&quot; -e &quot;RABBITMQ_ERLANG_COOKIE=thisissecretkey&quot; stomp-rabbitmq:latest&lt;/p&gt;
&lt;p&gt;        在执行完　sudo docker service create --name stomp-rabbitmq-slave1　后，其实就相当于启动了一个容器，可以通过　docker ps 看到，如果看不到，那说明服务启动失败，通过进程守护进入容器用到的 id　就是　此处看到的id&lt;/p&gt;
&lt;p&gt; 　　(将分支１加入到集群)，通过守护进程进入到容器内部执行&lt;/p&gt;
&lt;p&gt;        (进入容器)命令：docker exec -it &lt;strong&gt;36383eefcf87&lt;/strong&gt; /bin/sh&lt;/p&gt;
&lt;p&gt;                                    docker exec -it  /bin/sh&lt;/p&gt;
&lt;pre class=&quot;sourcecode bash hljs&quot;&gt;
&lt;em&gt; 　　rabbitmqctl stop_app&lt;/em&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sourcecode bash hljs&quot;&gt;
&lt;em&gt; 　　rabbitmqctl join_cluster rabbit@stomp-rabbitmq-master&lt;/em&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sourcecode bash hljs&quot;&gt;
&lt;em&gt; 　　rabbitmqctl start_app&lt;/em&gt;　&lt;strong&gt;4.创建Openresty（nginx+lua）&lt;br/&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; 　　docker build -t openresty-product:0.0.1 .&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        命令：&lt;/strong&gt;docker service create  --name openresty-product-service --mode global -p 8080:80 --mount type=bind,target=/var/log/nginx/,source=/home/agent/openresty-file/var/log/nginx --mount type=bind,target=/opt/,source=/home/agent/openresty-file/openrestyFile --mount type=bind,target=/etc/nginx/conf.d,source=/home/agent/openresty-file/etc/nginx/conf.d --mount type=bind,target=/usr/local/openresty/nginx/conf,source=/home/agent/openresty-file/usr/local/openresty/nginx/conf openresty-product:0.0.1 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;        用于外网访问下载数据文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;命令：docker&lt;strong&gt; &lt;/strong&gt;service create  --name openresty-file-server --constraint node.labels.rabbitmq==master -p 80:80 --mount type=bind,target=/var/log/nginx/,source=/home/agent/finalDataFile/var/log/nginx --mount type=bind,target=/opt/,source=/home/agent/finalDataFile --mount type=bind,target=/etc/nginx/conf.d,source=/home/agent/finalDataFile/etc/nginx/conf.d openresty/openresty:xenial&lt;/p&gt;

&lt;p&gt;        nginx 的相关配置，我们就不在此细说了，我可以给大家看个例子&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
    server_name  localhost;

    #charset koi8&lt;/span&gt;-&lt;span&gt;r;
    access_log  &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;host.access.log  main;

    location &lt;/span&gt;/&lt;span&gt; {
        root   &lt;/span&gt;/usr/local/openresty/nginx/&lt;span&gt;html;
        index  index.html index.htm;
    }


    location &lt;/span&gt;/&lt;span&gt;hello {
#        root   &lt;/span&gt;/usr/local/openresty/nginx/&lt;span&gt;html;
#        index  index.html index.htm;

        default_type &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        content_by_lua &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngx.say(&quot;hello world&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }

    location &lt;/span&gt;/&lt;span&gt;file {
       proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.7.201:8090/;&lt;/span&gt;
       access_log  /&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;file.access.log  main;
       error_log  &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;file.error.log;
    }

    location &lt;/span&gt;/dataagent/v1/&lt;span&gt;test {&lt;/span&gt;&lt;span&gt;
#        deny all;
         default_type &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
#        lua_code_cache off;
#        content_by_lua &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngx.say(&quot;test.test.com access&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        access_log  &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;chaoshen.access.log  main;
        error_log  &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;chaoshen.error.log;
        content_by_lua_file &lt;/span&gt;/opt/openresty-docker/openresty/lua-dataagent/&lt;span&gt;chaoshen_yuenan.lua;
    }

    error_page   &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;
    location &lt;/span&gt;= /&lt;span&gt;50x.html {
        root   &lt;/span&gt;/usr/local/openresty/nginx/&lt;span&gt;html;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
配置中　/dataagent/v1/&lt;span&gt;test　&lt;/span&gt;content_by_lua_file　对应的脚本文件就是用来生产消息的，我们也直接来看代码
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package.path&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/opt/openresty-docker/openresty/lua-dataagent/lib/resty/?.lua;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; rabbitmq = &lt;span&gt;require&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rabbitmqstomp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;local&lt;/span&gt; opts =&lt;span&gt; {
    username &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;guest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    password &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;guest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    vhost &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; mq, err =&lt;span&gt; rabbitmq:new(opts)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; mq &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cannot new mq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,err)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;&lt;span&gt;

mq:set_timeout(&lt;/span&gt;&lt;span&gt;60000&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; connect to the rabbitmq on local machine&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; ok, err = mq:connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.7.201&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12345&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; ok &lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; connect to other rabbitmq in cluster&lt;/span&gt;
    ok, err = mq:connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.7.200&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;23456&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; ok &lt;span&gt;then&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; connect to last rabbitmq in cluster&lt;/span&gt;
        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; put messages into errorLog&lt;/span&gt;
        ngx.log(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cannot connect mq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,err)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt; 
&lt;span&gt;end&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;  local msg = &quot;d.g.test.com/gp.do?ac=s_publishgame&amp;amp;action=login&amp;amp;appId=133214321432&amp;amp;serverId=bj_server1&amp;amp;channel=test_gamecenter&amp;amp;accountId=q1132143214&amp;amp;playerId=q1132143214&amp;amp;tm=1458874365&amp;amp;first=1&quot;&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; msg = &lt;span&gt;string.sub&lt;/span&gt;(ngx.var.request_uri,&lt;span&gt;22&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; result = &lt;span&gt;string.gsub&lt;/span&gt;(msg,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.*/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d.g.test.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; send_receipt_id = ngx.now()*&lt;span&gt;1000&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; headers =&lt;span&gt; {}
headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destination&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/exchange/statistical/statistical.test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receipt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; send_receipt_id
headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app-id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;luaresty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;persistent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content-type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/plian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;local&lt;/span&gt; ok, err =&lt;span&gt; mq:send(result, headers)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; ok &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cannot send mq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,err)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;

&lt;span&gt;local&lt;/span&gt; ok, err = mq:set_keepalive(&lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; ok &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cannot set_keepalive mq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ngx.log(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,err)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ngx.say('success: ',msg)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;        &lt;strong&gt;5.配置RabbitMq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　RabbitMq比较好的一个资料站点：&lt;a class=&quot;external-link&quot; href=&quot;https://www.jianshu.com/p/124cda48e4ea&quot; rel=&quot;nofollow&quot;&gt;https://www.jianshu.com/p/124cda48e4ea&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　　　　　　  　　　　&lt;a class=&quot;external-link&quot; href=&quot;https://www.jianshu.com/p/61a90fba1d2a&quot; rel=&quot;nofollow&quot;&gt;https://www.jianshu.com/p/61a90fba1d2a&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;               交换机，statistical&lt;br/&gt;               路由规则，&lt;a class=&quot;external-link&quot; href=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxcheckurl?requrl=http%3A%2F%2Fstatistical.saiche&amp;amp;skey=%40crypt_5c9ecbfe_ff781212a41fc3abe64a1ae9820cad9a&amp;amp;deviceid=e270398035265328&amp;amp;pass_ticket=PHgh7%252BM86RzGhmsfz1Xwdg81jTbPVAYPpyAn3gn%252Fiog%253D&amp;amp;opcode=2&amp;amp;scene=1&amp;amp;username=@1cda7a7a127faf122dea2ec2e5b3caa5&quot; rel=&quot;nofollow&quot;&gt; statistical.t&lt;/a&gt;est&lt;br/&gt;               队列，test&lt;br/&gt;               在rabbitmq中建好，就能往里发消息了&lt;/p&gt;
&lt;p&gt;　　　　添加　＂交换机＂，＂路由规则＂，＂消息队列＂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//声明交换机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　rabbitmqctl eval 'rabbit_exchange:declare({resource, &amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;, exchange, &amp;lt;&amp;lt;&quot;statistical&quot;&amp;gt;&amp;gt;}, topic, true, false, false, []).'&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//声明消息队列&lt;/strong&gt;&lt;br/&gt;　　　　rabbitmqctl eval 'rabbit_amqqueue:declare({resource, &amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;, queue, &amp;lt;&amp;lt;&quot;test&quot;&amp;gt;&amp;gt;}, true, false, [], none).'&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　//绑定交换机，路由规则，消息队列&lt;/strong&gt;&lt;br/&gt;　　　　rabbitmqctl eval 'rabbit_binding:add({binding, {resource, &amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;, exchange, &amp;lt;&amp;lt;&quot;statistical&quot;&amp;gt;&amp;gt;}, &amp;lt;&amp;lt;&quot;statistical.test&quot;&amp;gt;&amp;gt;, {resource, &amp;lt;&amp;lt;&quot;/&quot;&amp;gt;&amp;gt;, queue, &amp;lt;&amp;lt;&quot;test&quot;&amp;gt;&amp;gt;}, []}).'&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;6.测试消息生产&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　curl -i &quot;http://192.168.7.200:8080/dataagent/v1/test/topic-sendtime-id/d.g.test.com/gp.do&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　重点提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.首先要理解集群的架构&lt;/p&gt;
&lt;p&gt;　　2.保证打点日志文件的存储空间足够大&lt;/p&gt;
&lt;p&gt;　　3.了解openresty&lt;/p&gt;
&lt;p&gt;　　　openresty:是一个基于 &lt;a class=&quot;external-link&quot; href=&quot;http://openresty.org/cn/nginx.html&quot; rel=&quot;nofollow&quot;&gt;Nginx&lt;/a&gt; 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;
&lt;p&gt;　　4.要了解rabbitmq的相关知识，保证交换机，路由，消息队列的正常创建&lt;/p&gt;
&lt;p&gt;　　5.注意容器中配置文件和物理路径的映射关系&lt;/p&gt;
&lt;p&gt;　　6.lua脚本中，rabbitMq的地址一版是内网(局域网)地址&lt;/p&gt;
&lt;p&gt;　　7.swarm集群中，注意个集群节点 label　的自定义&lt;/p&gt;
&lt;p&gt;   　　上面都有关于此问题的描述&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　问题排查思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.查看nginx 日志来排查nginx异常日志&lt;/p&gt;
&lt;p&gt;　　2.理解架构途中消息的传递路径，顺着路近一步步追查&lt;/p&gt;

&lt;p&gt;　　好了，就写道这里，我是jerry百&lt;/p&gt;


</description>
<pubDate>Thu, 31 Jan 2019 06:44:00 +0000</pubDate>
<dc:creator>jerry-Tom</dc:creator>
<og:description>docker搭建rabbitmq集群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mbailing/p/docker_rabbitmq.html</dc:identifier>
</item>
<item>
<title>python异常处理的哲学 - alpha_panda</title>
<link>http://www.cnblogs.com/yssjun/p/10326300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yssjun/p/10326300.html</guid>
<description>&lt;p&gt;所谓异常指的是程序的执行出现了非预期行为，就好比现实中的做一件事过程中总会出现一些意外的事。异常的处理是跨越编程语言的，和具体的编程细节相比，程序执行异常的处理更像是哲学。限于认知能力和经验所限，不可能达到像解释器下import this看到的python设计之禅一样，本文就结合实际使用简单的聊一聊。&lt;/p&gt;
&lt;h3&gt;0. 前言&lt;/h3&gt;
&lt;p&gt;工作中，程序员之间一言不合就亮代码，毕竟不管是代码本身还是其执行过程，不会存在二义性，更不会含糊不清，代码可谓是程序员之间的官方语言。但是其处理问题的逻辑或者算法则并非如此。&lt;/p&gt;
&lt;p&gt;让我至今记忆犹新的两次程序员论剑有：&lt;/p&gt;
&lt;p&gt;反问一：项目后期所有的异常处理都要去掉，不允许上线后出现未知的异常，把你这里的异常处理去掉，换成if else；&lt;/p&gt;
&lt;p&gt;反问二：这里为什么要进行异常处理？代码都是你写的，怎么会出现异常呢？&lt;/p&gt;
&lt;p&gt;这是我亲身经历的，不知道大家碰到这两个问题会怎样回答，至少我当时竟无言以对。这两个问题分别在不同的时间针对不同的问题出自一个互联网巨头中某个资深QA和资深开发的反问。&lt;/p&gt;
&lt;p&gt;暂且不论对错，毕竟不同人考虑问题的出发点是不同的。但是从这么坚决的去异常处理的回答中至少有一点可以肯定，那就是很多人对自己的代码太过自信或者说是察觉代码潜在问题的直觉力不够，更别提正确的处理潜在的问题以保证重要业务逻辑的处理流程。写代码的时候如果只简单考虑正常的情况，那是在往代码中下毒。&lt;/p&gt;
&lt;p&gt;接下类本篇博文将按照套路出牌（避免被Ctrl + W），介绍一下python的异常处理的概念和具体操作.&lt;/p&gt;
&lt;h3&gt;1. 为什么要异常处理&lt;/h3&gt;
&lt;p&gt;常见的程序bug无非就两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法错误；&lt;/li&gt;
&lt;li&gt;逻辑不严谨或者思维混乱导致的逻辑错误；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显然第二种错误更难被发现，且后果往往更严重。无论哪一种bug，有两种后果等着我们：一、程序崩掉；二、执行结果不符合预期；&lt;/p&gt;
&lt;p&gt;对于一些重要关键的执行操作，异常处理可以控制程序在可控的范围执行，当然前提是正确的处理。&lt;/p&gt;
&lt;p&gt;比如我们给第三方提供的API或者使用第三方提供的API。多数情况下要正确的处理调用者错误的调用参数和返回异常结果的情况，不然就可能要背黑锅了。&lt;/p&gt;
&lt;p&gt;在不可控的环境中运行程序，异常处理是必须的。然而困难的地方是当异常发生时，如何进行处理。&lt;/p&gt;
&lt;h3&gt;2. python异常处理&lt;/h3&gt;
&lt;p&gt;下面逐步介绍一下python异常处理相关的概念。&lt;/p&gt;
&lt;h4&gt;2.1 异常处理结构&lt;/h4&gt;
&lt;p&gt;必要的结构为try ... except，至少有一个except，else 和 finally 可选。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    code blocks
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (Exception Class1, Exception Class2, ...) as e:
    catch &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; process exception
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception ClassN:
    catch &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; process exception
... ...
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    when nothing unexpected happened 
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    always executed when all to end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2 python 内置异常类型&lt;/h4&gt;
&lt;p&gt;模块exceptions中包含了所有内置异常类型，类型的继承关系如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a907e814-37df-4dc3-ad67-246ee6afab6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a907e814-37df-4dc3-ad67-246ee6afab6c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a907e814-37df-4dc3-ad67-246ee6afab6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BaseException
 &lt;/span&gt;+--&lt;span&gt; SystemExit
 &lt;/span&gt;+--&lt;span&gt; KeyboardInterrupt
 &lt;/span&gt;+--&lt;span&gt; GeneratorExit
 &lt;/span&gt;+--&lt;span&gt; Exception
      &lt;/span&gt;+--&lt;span&gt; StopIteration
      &lt;/span&gt;+--&lt;span&gt; StandardError
      &lt;/span&gt;|    +--&lt;span&gt; BufferError
      &lt;/span&gt;|    +--&lt;span&gt; ArithmeticError
      &lt;/span&gt;|    |    +--&lt;span&gt; FloatingPointError
      &lt;/span&gt;|    |    +--&lt;span&gt; OverflowError
      &lt;/span&gt;|    |    +--&lt;span&gt; ZeroDivisionError
      &lt;/span&gt;|    +--&lt;span&gt; AssertionError
      &lt;/span&gt;|    +--&lt;span&gt; AttributeError
      &lt;/span&gt;|    +--&lt;span&gt; EnvironmentError
      &lt;/span&gt;|    |    +--&lt;span&gt; IOError
      &lt;/span&gt;|    |    +--&lt;span&gt; OSError
      &lt;/span&gt;|    |         +--&lt;span&gt; WindowsError (Windows)
      &lt;/span&gt;|    |         +--&lt;span&gt; VMSError (VMS)
      &lt;/span&gt;|    +--&lt;span&gt; EOFError
      &lt;/span&gt;|    +--&lt;span&gt; ImportError
      &lt;/span&gt;|    +--&lt;span&gt; LookupError
      &lt;/span&gt;|    |    +--&lt;span&gt; IndexError
      &lt;/span&gt;|    |    +--&lt;span&gt; KeyError
      &lt;/span&gt;|    +--&lt;span&gt; MemoryError
      &lt;/span&gt;|    +--&lt;span&gt; NameError
      &lt;/span&gt;|    |    +--&lt;span&gt; UnboundLocalError
      &lt;/span&gt;|    +--&lt;span&gt; ReferenceError
      &lt;/span&gt;|    +--&lt;span&gt; RuntimeError
      &lt;/span&gt;|    |    +--&lt;span&gt; NotImplementedError
      &lt;/span&gt;|    +--&lt;span&gt; SyntaxError
      &lt;/span&gt;|    |    +--&lt;span&gt; IndentationError
      &lt;/span&gt;|    |         +--&lt;span&gt; TabError
      &lt;/span&gt;|    +--&lt;span&gt; SystemError
      &lt;/span&gt;|    +--&lt;span&gt; TypeError
      &lt;/span&gt;|    +--&lt;span&gt; ValueError
      &lt;/span&gt;|         +--&lt;span&gt; UnicodeError
      &lt;/span&gt;|              +--&lt;span&gt; UnicodeDecodeError
      &lt;/span&gt;|              +--&lt;span&gt; UnicodeEncodeError
      &lt;/span&gt;|              +--&lt;span&gt; UnicodeTranslateError
      &lt;/span&gt;+--&lt;span&gt; Warning
           &lt;/span&gt;+--&lt;span&gt; DeprecationWarning
           &lt;/span&gt;+--&lt;span&gt; PendingDeprecationWarning
           &lt;/span&gt;+--&lt;span&gt; RuntimeWarning
           &lt;/span&gt;+--&lt;span&gt; SyntaxWarning
           &lt;/span&gt;+--&lt;span&gt; UserWarning
           &lt;/span&gt;+--&lt;span&gt; FutureWarning
       &lt;/span&gt;+--&lt;span&gt; ImportWarning
       &lt;/span&gt;+--&lt;span&gt; UnicodeWarning
       &lt;/span&gt;+-- BytesWarning
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;2.3 except clause&lt;/h4&gt;
&lt;p&gt;excpet子句的常用的写法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;except:　　　　　　　　　　　　　　　　　　　　　　　　　# 默认捕获所有类型的异常&lt;/li&gt;
&lt;li&gt;except Exception Class:　　　　　　　　　　　　　　　　　  # 捕获Exception Class类型的异常&lt;/li&gt;
&lt;li&gt;except Exception Class as e:　　　　　　　　　　　　　　　  # 捕获Exception Class类型的异常，异常对象赋值到e&lt;/li&gt;
&lt;li&gt;except (Exception Class1, Exception Class2, ...) as e:　　　　  # 捕获列表中任意一种异常类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的异常类可以是下面python内置异常类型，也可以是自定义的异常类型。&lt;/p&gt;
&lt;h4&gt;2.4 异常匹配原则&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;所有except子句按顺序一一匹配，匹配成功则忽略后续的except子句；&lt;/li&gt;
&lt;li&gt;若抛出异常对象为except子句中给出的异常类型的对象或给出的异常类型的派生类对象，则匹配成功；&lt;/li&gt;
&lt;li&gt;如果所有的except子句均匹配失败，异常会向上传递；&lt;/li&gt;
&lt;li&gt;如果依然没有被任何try...except捕获到，程序在终止前会调用sys.excepthook进行处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.5 else &amp;amp; finally&lt;/h4&gt;
&lt;p&gt;如果没有异常发生，且存在else子句，则执行else子句。只要存在finally子句，无论任何情况下都会被执行。&lt;/p&gt;
&lt;p&gt;可能唯一不好理解的地方就是finally。没有异常、捕获异常、异常上传以及异常处理过程中发生异常等均会执行finally语句。&lt;/p&gt;
&lt;p&gt;下面看个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; division(a, b):
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;res = %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (a /&lt;span&gt; b)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (ZeroDivisionError, ArithmeticError) as e:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str(e)　　#&lt;span&gt; 注意此处使用的是return
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s / %s = %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (a, b, a /&lt;span&gt; b)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;finally clause&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 分别输入参数（1, 2），（1, 0）和 （1，“0”）执行：&lt;/p&gt;
&lt;p&gt;print 'return value: %s' % division(a, b)&lt;/p&gt;
&lt;p&gt;得到的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_3638aeb6-5de5-4b90-a0fd-9e190296221e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3638aeb6-5de5-4b90-a0fd-9e190296221e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3638aeb6-5de5-4b90-a0fd-9e190296221e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
res =&lt;span&gt; 0
&lt;/span&gt;1 / 2 =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; clause
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value: None

&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; clause
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value: integer division &lt;span&gt;or&lt;/span&gt;&lt;span&gt; modulo by zero

&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; clause
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 217, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return value: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % division(1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 208, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; division
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;res = %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (a /&lt;span&gt; b)
TypeError: unsupported operand type(s) &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; /: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;可以看到纵使程序发生异常且没有被正确处理，在程序终止前，finally语句依旧被执行了。可以将此看做程序安全的最后一道有效屏障。主要进行一些善后清理工作，比如资源释放、断开网络连接等。当然with声明可以自动帮我们进行一些清理工作。&lt;/p&gt;
&lt;h4&gt;2.6 raise抛出异常&lt;/h4&gt;
&lt;p&gt;程序执行过程中可以使用raise主动的抛出异常. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    e &lt;/span&gt;= Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    e.message &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ni Hao!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as inst:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; type(inst), inst, inst.args, inst.message
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&amp;lt;type 'exceptions.Exception'&amp;gt; ('Hello', 'World') ('Hello', 'World') Ni Hao!&lt;/p&gt;
&lt;p&gt;上面展示了except对象的属性args, message。&lt;/p&gt;
&lt;h4&gt;2.7 自定义异常&lt;/h4&gt;
&lt;p&gt;绝大部分情况下内置类型的异常已经能够满足平时的开发使用，如果想要自定义异常类型，可以直接继承内置类型来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZeroDivZeroError(ZeroDivisionError):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, value):
        self.value &lt;/span&gt;=&lt;span&gt; value
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; repr(self)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.value

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; do something and find 0 / 0&lt;/span&gt;
    &lt;span&gt;raise&lt;/span&gt; ZeroDivZeroError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hahajun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ZeroDivZeroError as err:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;except info %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % err
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 自定义异常应该直接继承自Exception类或其子类，而不要继承自BaseException.&lt;/p&gt;
&lt;h3&gt;3. Stack Trace&lt;/h3&gt;
&lt;p&gt;python执行过程中发生异常，会告诉我们到底哪里出现问题和什么问题。这两种类型的错误信息分别为stack trace和 exception，在程序中分别用traceback object和异常对象表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line &lt;span&gt;270&lt;/span&gt;, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;1&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
ZeroDivisionError: integer division or modulo by zero&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的错误信息包含错误发生时当前的堆栈信息(stack trace， 前三行)和异常信息(exception，最后一行)，分别存放在traceback objects和抛出的异常对象中。&lt;/p&gt;
&lt;p&gt;异常对象及异常信息前面已经介绍过，接下来我们在看一下异常发生时，stack trace的处理。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Traceback objects represent a stack trace of an exception. A traceback object is created when an exception occurs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;异常被try...except捕获&lt;/li&gt;
&lt;li&gt;没有被捕获或者干脆没有处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;正常的代码执行过程，可以使用traceback.print_stack()输出当前调用过程的堆栈信息。&lt;/p&gt;
&lt;h4&gt;3.1 捕获异常&lt;/h4&gt;
&lt;p&gt; 对于第一种情况可以使用下面两种方式获取stack trace信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
trace_str = traceback.format_exc()
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
或者从sys.exc_info()中获取捕获的异常对象等的信息，然后格式化成trace信息。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_trace_str(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    从当前栈帧或者之前的栈帧中获取被except捕获的异常信息;
    没有被try except捕获的异常会直接传递给sys.excepthook
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    t, v, tb &lt;/span&gt;=&lt;span&gt; sys.exc_info()
    trace_info_list &lt;/span&gt;=&lt;span&gt; traceback.format_exception(t, v, tb)
    trace_str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(trace_info_list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于抛出的包含异常信息的异常对象则可以在try...except结构中的except Exception class as e中获取。 &lt;/p&gt;
&lt;h4&gt;3.2 未捕获异常&lt;/h4&gt;
&lt;p&gt;第二种情况，如果异常没有被处理或者未被捕获则会在程序推出前调用sys.excepthook将traceback和异常信息输出到sys.stderr。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; except_hook_func(tp, val, tb):
    trace_info_list &lt;/span&gt;=&lt;span&gt; traceback.format_exception(tp, val, tb)
    trace_str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(trace_info_list)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys.excepthook&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt; trace_str
sys.excepthook &lt;/span&gt;= except_hook_func
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面自定义except hook函数来取代sys.excepthook函数。在hook函数中根据异常类型tp、异常值和traceback对象tb获取stack trace。这种情况下不能从sys.exc_info中获取异常信息。&lt;/p&gt;
&lt;h4&gt;3.3 测试&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; except_hook_func(tp, val, tb):
    trace_info_list &lt;/span&gt;=&lt;span&gt; traceback.format_exception(tp, val, tb)
    trace_str &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(trace_info_list)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys.excepthook&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt; trace_str
sys.excepthook &lt;/span&gt;=&lt;span&gt; except_hook_func
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;1 /&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; TypeError as e:
    res &lt;/span&gt;=&lt;span&gt; traceback.format_exc()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;try...except&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt; str(e.message)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; res
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;走的是sys.excepthook处理流程结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sys.excepthook
Traceback (most recent call last):
   File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 259, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    1 /&lt;span&gt; 0
 ZeroDivisionError: integer division &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; modulo by zero
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将except TypeError as e 改为 except ZeroDivisionError as e，则走的是try...except捕获异常流程，结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;...&lt;span&gt;except&lt;/span&gt;&lt;span&gt;
integer division &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; modulo by zero
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 259, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    1 /&lt;span&gt; 0
ZeroDivisionError: integer division &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; modulo by zero
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 异常信息收集&lt;/h3&gt;
&lt;p&gt;讲了这么多，我们看一下如何实现一个程序中trace信息的收集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TracebackMgr(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _get_format_trace_str(self, t, v, tb):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         _trace =&lt;span&gt; traceback.format_exception(t, v, tb)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(_trace)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle_one_exception(self):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        从当前栈帧或者之前的栈帧中获取被except捕获的异常信息;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        没有被try except捕获的异常会自动使用handle_traceback进行收集
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         t, v, tb =&lt;span&gt; sys.exc_info()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.handle_traceback(t, v, tb, False)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; handle_traceback(self, t, v, tb, is_hook =&lt;span&gt; True):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        将此函数替换sys.excepthook以能够自动收集没有被try...except捕获的异常，
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        使用try except处理的异常需要手动调用上面的函数handle_one_exception才能够收集
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         trace_str =&lt;span&gt; self._get_format_trace_str(t, v, tb)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        self.record_trace(trace_str, is_hook)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; do something else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; record_trace(self, trace_str, is_hook):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do somethind&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_hook: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; is_hook
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; trace_str
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其用法很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
trace_mgr =&lt;span&gt; TracebackMgr()
sys.excepthook &lt;/span&gt;=&lt;span&gt; trace_mgr.handle_traceback
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;1 /&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
    trace_mgr.handle_one_exception()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; process trace&lt;/span&gt;

1 / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果用两种方式收集到两个trace信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;is_hook: False
Traceback (most recent call last):
   File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 299, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    1 /&lt;span&gt; 0
 ZeroDivisionError: integer division &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; modulo by zero

is_hook: True
Traceback (most recent call last):
   File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\My Folders\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 304, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    1 / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
 TypeError: unsupported operand type(s) &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; /: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以将标准的输入和输出重定向，将打印日志和错误信息输入到文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dumpfile(object):
    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; write(str_info):
        with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./dump_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as fobj:
            fobj.write(str_info)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; flush(self):
        self.write(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
sys.stdout &lt;/span&gt;= sys.stderr = Dumpfile()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;trace的收集主要用到两点：如何捕获异常和两种情况下异常信息的收集，前面都介绍过。&lt;/p&gt;
&lt;h3&gt;5. 总结&lt;/h3&gt;
&lt;p&gt;python 异常处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用对象来表示异常错误信息，每种异常均有一种对应的类，BaseException为所有表示异常处理类的基类。&lt;/li&gt;
&lt;li&gt;程序执行过程中抛出的异常会匹配该对象对应的异常类和其所有的基类。&lt;/li&gt;
&lt;li&gt;可以从内置类型的异常类派生出自定义的异常类。&lt;/li&gt;
&lt;li&gt;被捕获的异常可以再次被抛出。&lt;/li&gt;
&lt;li&gt;可以的话尽量使用内置的替代方案，如if getattr(obj, attr_name, None)，或者with结构等。&lt;/li&gt;
&lt;li&gt;sys.exc_info()保存当前栈帧或者之前的栈帧中获取被try, except捕获的异常信息。&lt;/li&gt;
&lt;li&gt;未处理的异常导致程序终止前会被sys.excpethook处理，可以自定义定义sys.excpethook。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;异常的陷阱：&lt;/p&gt;
&lt;p&gt;正确的异常处理能让代码有更好的鲁棒性，但是错误的使用异常会过犹不及。&lt;/p&gt;
&lt;p&gt;捕获异常却忽略掉或者错误的处理是不可取的。滥用异常处理不仅达不到提高系统稳定性的效果，还会隐藏掉引起错误的诱因，导致排查问题的难度增加。&lt;/p&gt;
&lt;p&gt;因此比如何捕获异常更重要的是，异常发生时应当如何处理。&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 06:42:00 +0000</pubDate>
<dc:creator>alpha_panda</dc:creator>
<og:description>所谓异常指的是程序的执行出现了非预期行为，就好比现实中的做一件事过程中总会出现一些意外的事。异常的处理是跨越编程语言的，和具体的编程细节相比，程序执行异常的处理更像是哲学。限于认知能力和经验所限，不可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yssjun/p/10326300.html</dc:identifier>
</item>
<item>
<title>分布式锁 - mrguozp</title>
<link>http://www.cnblogs.com/guozp/p/10341337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guozp/p/10341337.html</guid>
<description>&lt;h3 id=&quot;单机&quot;&gt;单机&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;方案比较多，synchronized和juc很丰富&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分布式锁&quot;&gt;分布式锁&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;互斥性:在任意时刻，只有一个客户端能持有锁&lt;/li&gt;
&lt;li&gt;不会发生死锁:即有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;文章来源：https://www.cnblogs.com/guozp/p/10341337.html&lt;/p&gt;
&lt;h5 id=&quot;常见方案&quot;&gt;常见方案&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;基于数据库&lt;/li&gt;
&lt;li&gt;基于分布式缓存（redis、tair等）&lt;/li&gt;
&lt;li&gt;基于zk&lt;br/&gt;要基于你的业务场景选择合适方案&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;数据库mysql&quot;&gt;数据库(mysql)&lt;/h4&gt;
&lt;p&gt;基于数据库的ACID以及MVCC(多版本并发控制机)，MVCC是通过保存数据在某个时间点的快照来实现的，不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;基于悲观锁（for update）&lt;/p&gt;
&lt;p&gt;select * from table where *** for update&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;基于乐观锁（version）&lt;/p&gt;
&lt;p&gt;乐观锁是基于数据的版本号实现的,表增加一个字段version，每次读取的时候，将version取出，更新的时候，比较version是否一致，一致，处理完后把version加1；不一致，本次未拿到锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;tair&quot;&gt;tair&lt;/h4&gt;
&lt;p&gt;Tair没有直接提供分布式锁的api，但是可以借助提供的其他api实现分布式锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;incr/decr(不可重入锁)
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;原理：通过计数api的上下限值约束来实现(增加/减少计数。可设置最大值和最小值)&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;api:
&lt;ol&gt;&lt;li&gt;增加计数（加锁）：&lt;br/&gt;&lt;code&gt;Result&amp;lt;Integer&amp;gt; incr(int namespace, Serializable key, int value, int defaultValue, int expireTime, int lowBound, int upperBound)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;减少计数（释放锁）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Result&amp;lt;Integer&amp;gt; decr(int namespace, Serializable key, int value, int defaultValue, int expireTime, int lowBound, int upperBound)  &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;关键参数解释：&lt;/li&gt;
&lt;/ol&gt;&lt;code&gt;defaultValue: 第一次调用incr时的key的count初始值，第一次返回的值为defaultValue + value, decr第一次返回defaultValue - value lowBound: 最小值 upperBound: 最大值&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用
&lt;ol&gt;&lt;li&gt;线程一调用incr加锁,加锁后，key的值变成1，而key的上限值为1，其他线程再调用该接口时会报错COUNTER_OUT_OF_RANGE&lt;/li&gt;
&lt;li&gt;待线程一使用完成后，调用decr解锁,此时key已经有值1，返回 1-1=0，解锁成功。多次调用会失败，因为范围是0~1。&lt;/li&gt;
&lt;li&gt;通过0、1的来回变化，达到分布式锁的目的，当key为1时获取到锁，为0时释放锁&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Get/Put
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;原理：使用put的version校验实现&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;api
&lt;ol&gt;&lt;li&gt;put&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;ResultCode put(int namespace, Serializable key, Serializable value, int version, int expireTime)`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一定要设置过期参数expireTime，否则锁执行过程中进程crash，锁不会释放，会长期占有，影响业务，加上后，业务至少可以自行恢复&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;关键参数解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  version - 为了解决并发更新同一个数据而设置的参数。当version为0时，表示强制更新
  这里注意：
  此处version，除了0、1外的任何数字都可以，传入0，tair会强制覆盖；而传入1，第一个client写入会成功，但是新写入时服务端的version以0开始计数啊，所以此时version也是1，所以下一个到来的client写入也会成功，这样造成了冲突。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里针对网络等问题做了重试，同时改造支持可重入锁，不可重入锁，目前这里可重入没有做计数以及重新设置过期时间，使用的各位可以根据实际情况进行改造&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;   @Override
  public boolean tryLock(String lockKey, int expireTime, boolean reentrant) {
      if (expireTime &amp;lt;= 0) {
          expireTime = DEFAULT_EXPIRE_TIME;
      }
      int retryGet = 0;
      try {
          Result&amp;lt;DataEntry&amp;gt; result = tairManager.get(NAMESPACE, lockKey);
          while (retryGet++ &amp;lt; LOCK_GET_MAX_RETRY &amp;amp;&amp;amp; result != null &amp;amp;&amp;amp; isError(result.getRc())) {
              result = tairManager.get(NAMESPACE, lockKey);
          }
          if (result == null) {
              log.error(&quot;tryLock error, maybe Tair service is unavailable&quot;);
              return false;
          }
          if (ResultCode.DATANOTEXSITS.equals(result.getRc())) {
              // version 2表示为空，若不是为空，则返回version error
              ResultCode code = tairManager.put(NAMESPACE, lockKey, getLockValue(), DEFAULT_VERSION, expireTime);
              if (ResultCode.SUCCESS.equals(code)) {
                  return true;
              } else if (retryPut.get() &amp;lt; LOCK_PUT_MAX_RETRY &amp;amp;&amp;amp; isError(code)) {
                  retryPut.set(retryPut.get() + 1);
                  return tryLock(lockKey, expireTime);
              }
          } else if (reentrant &amp;amp;&amp;amp; result.getValue() != null &amp;amp;&amp;amp; getLockValue().equals(result.getValue().getValue())) {
              return true;
          }
      } catch (Exception e) {
          log.error(&quot;try lock is error, msg is {}&quot;, e);
      } finally {
          retryPut.remove();
      }
      return false;
  }

  @Override
  public void unlock(String lockKey) {
      unlock(lockKey, false);
  }

  @Override
  public boolean unlock(String lockKey, boolean reentrant) {
      if (!reentrant) {
          ResultCode invalid = tairManager.invalid(NAMESPACE, lockKey);
          return invalid != null &amp;amp;&amp;amp; invalid.isSuccess();
      }
      Result&amp;lt;DataEntry&amp;gt; result = tairManager.get(NAMESPACE, lockKey);
      if (result != null &amp;amp;&amp;amp; result.isSuccess() &amp;amp;&amp;amp; result.getValue() != null) {
          String value = result.getValue().getValue().toString();
          if (getLockValue().equals(value)) {
              ResultCode rc = tairManager.invalid(NAMESPACE, lockKey);
              if (rc != null &amp;amp;&amp;amp; rc.isSuccess()) {
                  return true;
              } else {
                  log.error(&quot;unlock failed, tairLockManager.invalidValue fail, key is {}, ResultCode is {}&quot;,
                      lockKey, rc);
                  return false;
              }
          } else {
              log.warn(&quot;unlock failed,value is not equal lockValue, key is {}, lockValue is {}, value is {}&quot;,
                  lockKey, getLockValue(), value);
              return false;
          }
      }
      return false;
  }

  @Override
  public boolean lockStatus(String lockKey) {
      Result&amp;lt;DataEntry&amp;gt; result = tairManager.get(NAMESPACE, lockKey);
      if (result != null &amp;amp;&amp;amp; result.isSuccess() &amp;amp;&amp;amp; result.getValue() != null) {
          return true;
      }
      return false;
  }

  private boolean isError(ResultCode code) {
      return code == null || ResultCode.CONNERROR.equals(code) || ResultCode.TIMEOUT.equals(code) || ResultCode.UNKNOW
          .equals(code);
  }

  private String getLockValue() {
      return NetUtils.getLocalIp() + &quot;_&quot; + Thread.currentThread().getName();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis&quot;&gt;redis&lt;/h4&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li&gt;正确的加锁逻辑
&lt;ul readability=&quot;10&quot;&gt;&lt;li&gt;API：
&lt;ol&gt;&lt;li&gt;加锁&lt;br/&gt;&lt;code&gt;SET key value [EX seconds] [PX milliseconds] [NX|XX]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;释放锁&lt;br/&gt;&lt;code&gt;EVAL script numkeys key [key ...] arg [arg ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;关键参数解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;加锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;```
EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value
PX millisecond ：设置键的过期时间为 millisecond 毫秒。SET key value PX   millisecond 效果等同于 PSETEX key millisecond value 
NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value
XX ：只在键已经存在时，才对键进行设置操作。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;gt;释放
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;script 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。&lt;br/&gt;numkeys 参数用于指定键名参数的个数。&lt;br/&gt;键名参数 key [key ...] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。&lt;br/&gt;在命令的最后，那些不是键名参数的附加参数 arg [arg ...] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。&lt;br/&gt;```&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
*1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作
**/
public boolean tryLock(String lockKey, String requestId, int expireTime) {

      String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

      if (LOCK_SUCCESS.equals(result)) {
          return true;
      }
      return false;

  }

  public boolean unlock(String lockKey, String requestId) {

      String script = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;
      Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

      if (RELEASE_SUCCESS.equals(result)) {
          return true;
      }
      return false;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先，set()加入了NX参数，可以保证如果key已存在，则函数不会调用成功，即只有一个客户端能持有锁。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生crash而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。&lt;/li&gt;
&lt;li&gt;释放锁，这段Lua代码的功能：首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？&lt;strong&gt;因为lua可以确保上述操作是原子性的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;15.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;tair的rdb引擎目前不支持上述命令&lt;/strong&gt;，所以需要写成两行命令（或许新版本支持了，因为我使用的的还是旧版本,所以rdb的实现方式：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;支持可重入锁，不可重入锁，目前这里可重入没有做计数以及重新设置过期时间，使用的各位可以根据实际情况进行改造&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * rdb 不支持多参数，所以使用两个命令
     *
     * @param lockKey
     * @param expireTime 超时时间
     * @param reentrant  是否可重入,重入后会延长时间
     * @return
     */
    @Override
    public boolean tryLock(String lockKey, int expireTime, boolean reentrant) {
        if (expireTime &amp;lt;= 0) {
            expireTime = DEFAULT_EXPIRE_TIME;
        }
        boolean result = redisRepo.setNx(lockKey, getLockValue(), expireTime);
        if (!reentrant) {
            return result;
        }
        String value = redisRepo.get(lockKey);
        if (getLockValue().equals(value)) {
            result = redisRepo.setNx(lockKey, getLockValue(), expireTime);
        }
        return result;
    }

    /**
     * 版本不支持lua，所以使用两个命令
     *
     * @param lockKey
     * @param reentrant 是否可以释放其它人创建的锁
     * @return
     */
    @Override
    public boolean unlock(String lockKey, boolean reentrant) {
        if (!reentrant) {
            return redisRepo.delKeys(lockKey) &amp;gt; 0;
        }
        long result = 0;
        String value = redisRepo.get(lockKey);
        if (getLockValue().equals(value)) {
            result = redisRepo.delKeys(lockKey);
        }
        return result &amp;gt; 0;
    }

    @Override
    public boolean lockStatus(String lockKey) {
        String value = redisRepo.get(lockKey);
        return StringUtils.isNotBlank(value);
    }

    private String getLockValue() {
        return NetUtils.getLocalIp() + &quot;_&quot; + Thread.currentThread().getName();
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;错误的加锁示例
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;8.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，但是由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后crash，由于锁没有设置过期时间，将会发生死锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;  public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) {
    Long result = jedis.setnx(lockKey, requestId);
    if (result == 1) {
        jedis.expire(lockKey, expireTime);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。&lt;/li&gt;
&lt;li&gt;如果锁存在则获取锁过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;```&lt;br/&gt;public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) {&lt;/p&gt;
&lt;p&gt;long expires = System.currentTimeMillis() + expireTime;&lt;br/&gt;String expiresStr = String.valueOf(expires);&lt;/p&gt;
&lt;p&gt;if (jedis.setnx(lockKey, expiresStr) == 1) {&lt;br/&gt;return true;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;String currentValueStr = jedis.get(lockKey);&lt;br/&gt;if (currentValueStr != null &amp;amp;&amp;amp; Long.parseLong(currentValueStr) &amp;lt; System.currentTimeMillis()) {&lt;br/&gt;String oldValueStr = jedis.getSet(lockKey, expiresStr);&lt;br/&gt;if (oldValueStr != null &amp;amp;&amp;amp; oldValueStr.equals(currentValueStr)) {&lt;br/&gt;return true;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;return false;&lt;br/&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;```&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;上述代码问题出在哪里？
 * 由于是客户端自己生成过期时间，所以强制要求每个客户端的时间必须同步
 * 当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。
 * 锁不具备拥有者标识，即任何客户端都可以解锁（看个人业务）&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;错误的锁释放示例
&lt;ol&gt;&lt;li&gt;使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;```
  public static void wrongReleaseLock1(Jedis jedis, String lockKey) {
      jedis.del(lockKey);
  }

```

2. 以下代码分成两条命令去执行，如果调用jedis.del()的时候，锁已经不属于当前客户端的时,会解除他人加的锁

  ```    
  public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) {

          // 判断加锁与解锁是不是同一个客户端
          if (requestId.equals(jedis.get(lockKey))) {
              // 若在此时，这把锁过期不属于这个客户端的，则会误解锁
              jedis.del(lockKey);
          } 
      }
  ``` &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;redis官方锁&quot;&gt;redis官方锁&lt;/h5&gt;
&lt;p&gt;Redis的官方曾提出了一个容错的分布式锁算法：RedLock，只要有超过一半的缓存服务器能够正常工作，系统就可以保证分布式锁的可用性。&lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;详情参考&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;zk&quot;&gt;zk&lt;/h4&gt;
&lt;p&gt;有机会或者留言需要的在写吧, &lt;strong&gt;略略略&lt;/strong&gt;&lt;br/&gt;文章来源：https://www.cnblogs.com/guozp/p/10341337.html&lt;/p&gt;
&lt;h4 id=&quot;方案比较从低到高&quot;&gt;方案比较（从低到高）&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从理解的难易程度角度：数据库 &amp;gt; 缓存 &amp;gt; Zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从实现的复杂性角度：Zookeeper &amp;gt;= 缓存 &amp;gt; 数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从性能角度：缓存 &amp;gt; Zookeeper &amp;gt;= 数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从可靠性角度：Zookeeper &amp;gt; 缓存 &amp;gt; 数据库&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 31 Jan 2019 06:33:00 +0000</pubDate>
<dc:creator>mrguozp</dc:creator>
<og:description>单机 方案比较多，synchronized和juc很丰富 分布式锁 互斥性:在任意时刻，只有一个客户端能持有锁 不会发生死锁:即有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guozp/p/10341337.html</dc:identifier>
</item>
<item>
<title>SpringBoot入门 (八) Cache使用 - 梓&amp;艺</title>
<link>http://www.cnblogs.com/love-wzy/p/10341566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-wzy/p/10341566.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文记录学习在SpringBoot中使用Cache。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;一 为什么要使用缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　缓存是一个数据交换的缓冲区，在一些条件下可以替代数据库。举个例子：我们有一个查询的业务，访问数据的频率特别高，且每次访问时的查询条件都一样，数据库的数据一直保存不变，这样我们每次查询出来的结果都是一样的。为了降低高频率访问数据库给数据库带来的压力，我们可以在第一次访问后把数据缓存起来，以后再做相同查询时只去缓存中取数据，而不用取数据库再做查询。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;二 使用Cache&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;SpringBoot对缓存做了支持以供我们方便快速的使用，我们只需要引入相关依赖就可以了。在项目启动时会自动根据配置进行识别和初始化操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在pom.xml文件中引入对Cache支持的依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　要使用Cache，我们必须在启动时开启Cache，@EnableCaching 说明开启缓存&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@SpringBootApplication
@EnableCaching
public class CacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(CacheApplication.class, args);
    }

}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Spring Cache有3个比较重要的注解@Cacheable，@CachePut，@CacheEvict，我们一个一个说明：&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;1 @Cacheable&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　这个注解表明对操作进行缓存，它可以放在类上，表明对当前类中所有的方法的结果进行缓存；也可以放在方法上，表明对当前方法的结果进行缓存。它有3个参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Value 缓存的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Key 缓存的键，可以为空，如果指定要按照 SpEL 表达式编写；如果不指定，则缺省按照方法的所有参数进行组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Condition 缓存触发的条件，返回值是true和false，只有满足条件的情况(true)才会加入缓存，默认为空，既表示全部都加入缓存，支持 SpEL表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　实现代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RestController
public class CacheController {

    @RequestMapping(&quot;/hello&quot;)
    @Cacheable(value=&quot;helloCache&quot;, key = &quot;#name&quot;, condition = &quot;#name.length()&amp;gt;2&quot;)
    public String hello(@RequestParam(value=&quot;name&quot;, required = true) String name){
        System.out.println(&quot;没有走缓存，去数据库查询数据&quot;);
        return &quot;hello,&quot;+name;
    }

}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们的方法中有一个参数，模拟数据库查询时的条件，如上，当我们的参数name的长度大于2时，参数加入的缓存中。如果我们请求http://localhost:8080/hello?name=ch，不管我们请求多少次控制台中都会打印出‘没有走缓存，去数据库查询数据’，说明缓存没有触发，如果我们请求http://localhost:8080/hello?name=cache，第一次请求时控制台会打印出‘没有走缓存，去数据库查询数据’，之后不会再有，说明在方法执行前会先去缓存中看是否有结果，有则返回结果，没则执行请求方法，如第一次请求时执行后已经对结果进行了缓存，我们再请求时会直接去缓存中取结果，不会再去执行方法请求数据库了。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;2 @CachePut&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　它与@Cacheable类似，都是说明要做缓存，而且属性Key，Value，Condition的用法都一样，也可以使用在类或者方法上，区别是它每次都会执行实际方法(如查询数据库)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/hello1&quot;)
    @CachePut(value=&quot;helloCache&quot;, key = &quot;#name&quot;, condition = &quot;#name.length()&amp;gt;2&quot;)
    public String hello1(@RequestParam(value=&quot;name&quot;, required = true) String name){
        System.out.println(&quot;没有走缓存，去数据库查询数据&quot;);
        return &quot;hello,&quot;+name;
    }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　当我们请求http://localhost:8080/hello1?name=cache时，不管我们请求第几次，都会在控制台输出‘没有走缓存，去数据库查询数据’。如果数据库数据发生了变化，则会用新的数据替换之前的同value同Key缓存的数据。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3 CacheEvict&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　它是用来清除缓存的，同样是可以标记在类和方法上，标记在类上时说明所有方法都会清除缓存。Key，Value，Condition属性用法与Cacheable一样，还有2个属性allEntries和beforeInvocation。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　allEntries表示是否删除缓存中的所有属性，默认是false，表示不，true表示是。当被指定为true时，会忽略掉指定的Key而删除所有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　beforeInvocation表示删除缓存的时机，默认是false，表示在方法执行完后才删除缓存，true表示在方法执行前就先删除缓存。在方法执行过程中如果发生了异常，默认设置下(false)将不能删除掉缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/hello2&quot;)
    @CacheEvict(value=&quot;helloCache&quot;, key=&quot;#name&quot;, condition=&quot;#name.length()&amp;gt;2&quot;, allEntries = true, beforeInvocation = true)
    public String hello2(@RequestParam(value=&quot;name&quot;, required = true) String name){
        System.out.println(&quot;CacheEvict 清除缓存&quot;);
        return &quot;hello,&quot;+name;
    }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　使用同样的参数如cache，先请求执行hello方法进行数据缓存，在执行hello2进行删除缓存操作，然后再执行hello1方法会发现在控制台上又输出了‘没有走缓存，去数据库查询数据’，说明执行hello2方法时已经将缓存删除掉了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：SpEL（Spring Expression Language）是一个支持运行时查询和操作对象图的强大的表达式语言，其语法类似于统一 EL，但提供了额外特性，显式方法调用和基本字符串模板函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 31 Jan 2019 06:14:00 +0000</pubDate>
<dc:creator>梓&amp;amp;艺</dc:creator>
<og:description>本文记录学习在SpringBoot中使用Cache。 一 为什么要使用缓存 缓存是一个数据交换的缓冲区，在一些条件下可以替代数据库。举个例子：我们有一个查询的业务，访问数据的频率特别高，且每次访问时的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/love-wzy/p/10341566.html</dc:identifier>
</item>
<item>
<title>高性能消息队列NSQ - LinkinStar</title>
<link>http://www.cnblogs.com/linkstar/p/10341685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linkstar/p/10341685.html</guid>
<description>&lt;h2 id=&quot;toc_0&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近我再网上寻找使用golang实现的mq，因为我知道golang一般实现的应用部署起来很方便，所以我就找到了一个叫做nsq的mq，其实它并不能完全称为队列，但是它的轻量和性能的高效，让我真的大开眼界。&lt;/p&gt;
&lt;p&gt;如果你有兴趣，我觉得也可以了解一下：&lt;br/&gt;网上有人翻译了国外的一篇文章：&lt;br/&gt;&lt;a href=&quot;http://www.jfh.com/jfperiodical/article/1949?&quot; target=&quot;_blank&quot;&gt;我们是如何使用NSQ处理7500亿消息的&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;安装和部署&lt;/h2&gt;
&lt;h4 id=&quot;toc_2&quot;&gt;官网提供&lt;/h4&gt;
&lt;p&gt;如果你有能力的话直接阅读官方的说明进行操作就可以了&lt;br/&gt;&lt;a href=&quot;https://nsq.io/overview/quick_start.html&quot; target=&quot;_blank&quot;&gt;https://nsq.io/overview/quick_start.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果看不懂我还找到了中文翻译过的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/nsq-guide/&quot; target=&quot;_blank&quot;&gt;http://wiki.jikexueyuan.com/project/nsq-guide/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;toc_3&quot;&gt;简单部署&lt;/h4&gt;
&lt;p&gt;下面是我使用的最快部署测试方式，使用服务器环境centos7.4，防火墙开放端口4160，4161，4151&lt;br/&gt;4171&lt;br/&gt;1、在下载页面下载对应版本(可能有的时候需要科学上网)&lt;br/&gt;&lt;a href=&quot;https://nsq.io/deployment/installing.html&quot;&gt;https://nsq.io/deployment/installing.html&lt;/a&gt;&lt;br/&gt;这里使用linux版本&lt;br/&gt;nsq-1.1.0.linux-amd64.go1.10.3.tar.gz&lt;/p&gt;
&lt;p&gt;2、将包上传至服务器后解压；&lt;br/&gt;tar xvf nsq-1.1.0.linux-amd64.go1.10.3.tar.gz&lt;/p&gt;
&lt;p&gt;3、进入bin目录 cd nsq-1.1.0.linux-amd64.go1.10.3/bin&lt;/p&gt;
&lt;p&gt;4、后台启动三个服务&lt;br/&gt;nohup ./nsqlookupd &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;br/&gt;nohup ./nsqd --lookupd-tcp-address=127.0.0.1:4160 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;br/&gt;nohup ./nsqadmin --lookupd-http-address=127.0.0.1:4161 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;

&lt;h4 id=&quot;toc_4&quot;&gt;简单使用&lt;/h4&gt;
&lt;p&gt;1、使用&lt;br/&gt;curl -d 'hello world' '&lt;a href=&quot;http://127.0.0.1:4151/pub?topic=test&quot;&gt;http://127.0.0.1:4151/pub?topic=test&lt;/a&gt;'&lt;br/&gt;会创建一个test主题，并发送一个hello world消息&lt;/p&gt;
&lt;p&gt;2、外部通过：&lt;a href=&quot;http://127.0.0.1:4171/&quot;&gt;http://127.0.0.1:4171/&lt;/a&gt;&lt;br/&gt;进行访问可以看到NSQ的管理界面，非常的简洁&lt;br/&gt;其中127.0.0.1为服务器IP&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201901/899548-20190131135434019-1998583427.jpg&quot; alt=&quot;&quot; width=&quot;1144&quot; height=&quot;351&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3、使用&lt;br/&gt;./nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161&lt;br/&gt;消费test中刚才的消息，并输出到服务器/tmp目录中&lt;/p&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;特性&lt;/h2&gt;
&lt;p&gt;官方给出的文档给出了很多特性的说明，针对于一个MQ来说，我认为下面几个特性是你必须知道的：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;默认一开始消息不是持久化的&lt;br/&gt;nsq采用的方式时内存+硬盘的模式，当内存到达一定程度时就会将数据持久化到硬盘&lt;br/&gt;1、如果将 --mem-queue-size 设置为 0，所有的消息将会存储到磁盘。&lt;br/&gt;2、但是即使服务器重启也会将当时在内存中的消息持久化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息是没有顺序的&lt;br/&gt;这一点很关键，由于nsq使用内存+磁盘的模式，而且还有requeue的操作，所以发送消息的顺序和接收的顺序可能不一样&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;官方不推荐使用客户端发消息&lt;br/&gt;官方提供相应的客户端发送消息，但是HTTP可能更方便一些&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有复制&lt;br/&gt;nsq节点相对独立，节点与节点之间没有复制或者集群的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有鉴权相关模块&lt;br/&gt;当前release版本的nsq没有鉴权模块，只有版本v0.2.29+高于这个的才有&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;几个小点&lt;br/&gt;topic名称有长度限制，命名建议用下划线连接；&lt;br/&gt;消息体大小有限制；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_6&quot;&gt;优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;br/&gt;1、部署极其方便，没有任何环境依赖，直接启动就行&lt;br/&gt;2、轻量没有过多的配置参数，只需要简单的配置就可以直接使用&lt;br/&gt;3、性能高&lt;br/&gt;4、消息不存在丢失的情况&lt;/p&gt;
&lt;p&gt;缺点：&lt;br/&gt;1、消息无顺序&lt;br/&gt;2、节点之间没有消息复制&lt;br/&gt;3、没有鉴权&lt;/p&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;多节点部署&lt;/h2&gt;
&lt;h4 id=&quot;toc_8&quot;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;nsqd：基本的节点&lt;br/&gt;nsqlookupd：汇总节点信息，提供查询和管理topic等服务&lt;br/&gt;nsqadmin：管理端展示UI界面，能有一个web页面去查看和操作&lt;/p&gt;
&lt;h4 id=&quot;toc_9&quot;&gt;结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201901/899548-20190131135433826-14293005.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;最简单的多节点部署可以是这样的一个结构&lt;/p&gt;
&lt;h4 id=&quot;toc_10&quot;&gt;部署步骤和命令&lt;/h4&gt;
&lt;p&gt;PS：后台启动使用nohup即可，下面只是为了说明启动方式和命令参数&lt;/p&gt;
&lt;p&gt;第一步需要启动nsqlookupd&lt;br/&gt;./nsqlookupd&lt;br/&gt;默认占用4161和4160两个端口&lt;br/&gt;使用-http-address和-tcp-address可以修改&lt;/p&gt;
&lt;p&gt;第二步启动两个nsqd&lt;br/&gt;./nsqd -lookupd-tcp-address=192.168.1.102:4160 -broadcast-address=192.168.1.103 -data-path=&quot;/temp/nsq&quot;&lt;br/&gt;其中&lt;br/&gt;-lookupd-tcp-address为上面nsqlookupd的IP和tcp的端口4160&lt;br/&gt;-broadcast-address我填写的是自己的IP，这个IP官网上写的是会注册到nsqlookupd&lt;br/&gt;-data-path为消息持久化的位置&lt;/p&gt;
&lt;p&gt;第三步启动nsqadmin&lt;br/&gt;./nsqadmin -lookupd-http-address=192.168.4.102:4161&lt;br/&gt;同样需要指定-lookupd-http-address但是这次是http的端口也就是4161因为admin通过http请求来查询相关信息&lt;/p&gt;
&lt;h4 id=&quot;toc_11&quot;&gt;后续扩展&lt;/h4&gt;
&lt;p&gt;上面只是最简单的两个节点的部署，如果后续想扩展就会如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201901/899548-20190131135433893-1288367898.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其中nginx是可以不需要的，你可以果断选择同时向多个节点发送消息，或者当消息没有处理的时候重新进行发送，因为这样也是nsq设计之初的考虑。你也可以根据自己的需要设计你自己的架构。&lt;/p&gt;

&lt;h2 id=&quot;toc_12&quot;&gt;客户端&lt;/h2&gt;
&lt;p&gt;官方提供了很多语言接入的客户端 &lt;a href=&quot;https://nsq.io/clients/client_libraries.html&quot;&gt;https://nsq.io/clients/client_libraries.html&lt;/a&gt;&lt;br/&gt;针对消息生产者的客户端，官方还推荐直接使用post请求发送消息，如：&lt;br/&gt;curl -d 'hello world' '&lt;a href=&quot;http://127.0.0.1:4151/pub?topic=test&quot;&gt;http://127.0.0.1:4151/pub?topic=test&lt;/a&gt;'&lt;br/&gt;表示向test主题发送hello world这个消息&lt;/p&gt;
&lt;p&gt;下面介绍两种客户端，一种是golang的客户端，一种是java的客户端&lt;/p&gt;
&lt;h2 id=&quot;toc_13&quot;&gt;Golang的客户端&lt;/h2&gt;
&lt;p&gt;其中192.168.4.102:4150为发送消息的地址，消费者里面写的也是相同的地址就可以了。&lt;/p&gt;
&lt;h4 id=&quot;toc_14&quot;&gt;生产者：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; main

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&quot;github.com/nsqio/go-nsq&quot;
    &quot;time&quot;&lt;span&gt;
)

func main() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := 0 ; i &amp;lt; 10; i++&lt;span&gt;  {
        sendMessage()
    }
    time.Sleep(time.Second &lt;/span&gt;* 10&lt;span&gt;)
}

func sendMessage() {
    url :&lt;/span&gt;= &quot;192.168.4.102:4150&quot;&lt;span&gt;
    producer, err :&lt;/span&gt;=&lt;span&gt; nsq.NewProducer(url, nsq.NewConfig())
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        panic(err)
    }
    err &lt;/span&gt;= producer.Publish(&quot;test&quot;, []&lt;span&gt;byte&lt;/span&gt;(&quot;hello world&quot;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        panic(err)
    }
    producer.Stop()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&quot;toc_15&quot;&gt;消费者：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; main

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&quot;fmt&quot;
    &quot;github.com/nsqio/go-nsq&quot;
    &quot;sync&quot;&lt;span&gt;
)

func main() {
    testNSQ()
}

type NSQHandler struct {
}

func (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; *NSQHandler) HandleMessage(msg *&lt;span&gt;nsq.Message) error {
    fmt.Println(&lt;/span&gt;&quot;receive&quot;, msg.NSQDAddress, &quot;message:&quot;&lt;span&gt;, string(msg.Body))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
}

func testNSQ() {
    url :&lt;/span&gt;= &quot;192.168.4.102:4150&quot;&lt;span&gt;
    
    waiter :&lt;/span&gt;=&lt;span&gt; sync.WaitGroup{}
    waiter.Add(&lt;/span&gt;1&lt;span&gt;)

    go func() {
        defer waiter.Done()
        config:&lt;/span&gt;=&lt;span&gt;nsq.NewConfig()
        config.MaxInFlight&lt;/span&gt;=9

        &lt;span&gt;for&lt;/span&gt; i := 0; i&amp;lt;10; i++&lt;span&gt; {
            consumer, err :&lt;/span&gt;= nsq.NewConsumer(&quot;test&quot;, &quot;struggle&quot;&lt;span&gt;, config)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; nil !=&lt;span&gt; err {
                fmt.Println(&lt;/span&gt;&quot;err&quot;&lt;span&gt;, err)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            }

            consumer.AddHandler(&lt;/span&gt;&amp;amp;&lt;span&gt;NSQHandler{})
            err &lt;/span&gt;=&lt;span&gt; consumer.ConnectToNSQD(url)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; nil !=&lt;span&gt; err {
                fmt.Println(&lt;/span&gt;&quot;err&quot;&lt;span&gt;, err)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            }
        }
        select{}
    }()

    waiter.Wait()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2 id=&quot;toc_16&quot;&gt;Java的客户端&lt;/h2&gt;
&lt;p&gt;说实话java的客户端确实用的人比较少，因为我看到实际在github上面的星星和关注就比较少，所以客户端多多少少都存在一些问题。nsq-j和JavaNSQClient是官方排的考前的客户端。&lt;br/&gt;这里说一下nsq-j&lt;br/&gt;&lt;a href=&quot;https://github.com/sproutsocial/nsq-j&quot;&gt;https://github.com/sproutsocial/nsq-j&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;toc_17&quot;&gt;生产者&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Publisher publisher = &lt;span&gt;new&lt;/span&gt; Publisher(&quot;192.168.4.102:4150&quot;&lt;span&gt;);
System.out.print(publisher);

&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data = &quot;Hello nsq&quot;&lt;span&gt;.getBytes();
publisher.publish(&lt;/span&gt;&quot;example_topic&quot;&lt;span&gt;, data);
publisher.publish(&lt;/span&gt;&quot;example_topic&quot;&lt;span&gt;, data);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意这里需要这样关闭，不然的话就阻塞住了&lt;/span&gt;
publisher.getClient().stop();
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id=&quot;toc_18&quot;&gt;消费者&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PubExample {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleData(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data) {
        System.out.println(&lt;/span&gt;&quot;Received:&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(data));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Subscriber subscriber &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Subscriber(&quot;192.168.4.102:4161&quot;&lt;span&gt;);
        subscriber.subscribe(&lt;/span&gt;&quot;test&quot;, &quot;struggle&quot;&lt;span&gt;, PubExample::handleData);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是其中192.168.4.102:4161这个是nsqlookupd的http地址和端口和生产者是不一样的&lt;/p&gt;
&lt;p&gt;java客户端是根据nsqlookupd来找到对应消费端口&lt;/p&gt;
&lt;p&gt;所以启动nsqlookupd的时候需要注意，启动nsqd需要加上参数--broadcast-address&lt;br/&gt;如：./nsqd --lookupd-tcp-address=127.0.0.1:4160 --broadcast-address=192.168.4.102&lt;/p&gt;
&lt;p&gt;这样java消费者才能找到对应的地址否则会出现&lt;br/&gt;ERROR com.sproutsocial.nsq.Subscription - error connecting to:localhost.localdomain:4150&lt;br/&gt;java.net.UnknownHostException: localhost.localdomain&lt;br/&gt;这样类似的错误&lt;/p&gt;

&lt;h2 id=&quot;toc_19&quot;&gt;我建议的客户端&lt;/h2&gt;
&lt;p&gt;官方也说了，发送消息其实不建议使用客户端，而建议使用http请求，所以我自己是使用okhttp进行消息的发送，案例如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
OkHttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpClient();

MediaType mediaType &lt;/span&gt;= MediaType.parse(&quot;application/json&quot;&lt;span&gt;);
RequestBody body &lt;/span&gt;= RequestBody.create(mediaType, &quot;{&quot;code&quot;: 1}&quot;&lt;span&gt;);

Request request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request.Builder()
.url(&lt;/span&gt;&quot;http://192.168.4.102:4151/pub?topic=test&quot;&lt;span&gt;)
.post(body)
.addHeader(&lt;/span&gt;&quot;Content-Type&quot;, &quot;application/json&quot;&lt;span&gt;)
.build();

Response response &lt;/span&gt;=&lt;span&gt; client.newCall(request).execute();
System.out.println(response);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然这里没有对client进行配置，这就涉及okhttp了，这里不再赘述&lt;/p&gt;
&lt;p&gt;至于消费端还是使用nsq-j的&lt;/p&gt;

&lt;h2 id=&quot;toc_20&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用下来我们可以看到，nsq为了提供性能在一些方面是做出了妥协的，我们可以总结出下面几个方面供大家参考：&lt;br/&gt;1、暂时nsq的鉴权功能在高版本才支持，但是高版本没有release所以建议nsq在内网环境下使用，或者在一些安全的端口使用，避免被攻击&lt;br/&gt;2、部署节点在3个以上，nsq已经对于消息丢失做了很多的考虑，基本上不会出现丢失的情况，在你考虑幂等性的情况下，同时部署多个节点有利于消息进行处理&lt;br/&gt;3、如果对消息顺序有要求的情况下，nsq是不能使用的，因为nsq不能保证消息的顺序&lt;br/&gt;4、节点之间没有消息复制，所以即使多个节点部署，万一节点出现问题，还是有一段时间会出现消息无法接收到的情况，所以向多个节点同时发送消息也是一种解决方式&lt;br/&gt;5、因为nsq抛弃了一些东西，那么所带来的自然是方便，整体使用下来主要感受就是轻量，部署和配置都很方便，而且对于节点的监控能有界面&lt;/p&gt;
&lt;p&gt;希望后续nsq能在几个版本更新之后能给我们带来更加牛逼的表现。&lt;/p&gt;

</description>
<pubDate>Thu, 31 Jan 2019 05:55:00 +0000</pubDate>
<dc:creator>LinkinStar</dc:creator>
<og:description>前言 最近我再网上寻找使用golang实现的mq，因为我知道golang一般实现的应用部署起来很方便，所以我就找到了一个叫做nsq的mq，其实它并不能完全称为队列，但是它的轻量和性能的高效，让我真的大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linkstar/p/10341685.html</dc:identifier>
</item>
<item>
<title>使用fiddle处理跨域 - starWind</title>
<link>http://www.cnblogs.com/star-wind/p/10341573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/star-wind/p/10341573.html</guid>
<description>&lt;div id=&quot;myContain&quot; readability=&quot;61.579316389132&quot;&gt;
&lt;h5 class=&quot;myH5&quot;&gt;认真的用fiddle处理跨域&lt;/h5&gt;
&lt;p class=&quot;smallTitle&quot;&gt;相信很多前端的同学都或多或少被跨域这个问题烦恼过，网上很多处理的方式其实都是要后端处理，&lt;br/&gt;用fiddle来处理 ，就不必看后端的脸色了，自己安安心心的倒腾接口，何乐而不为。&lt;/p&gt;
&lt;p class=&quot;smallTitle&quot;&gt;在使用fiddle处理跨域之前，所需要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、是http请求还是的https请求，如果是https请求的话，要导入下证书，具体的步骤的：&lt;/li&gt;
&lt;li&gt;2、下载证书 &lt;a href=&quot;https://pan.baidu.com/s/1ZP6FgAIuDblZjOfaWaf4lg&quot; target=&quot;_blank&quot;&gt;点击下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3、下载完后双击安装即可。&lt;/li&gt;
&lt;li&gt;4、然后是fiddle的一些配置，可以参考下&lt;a href=&quot;https://blog.csdn.net/laofashi2015/article/details/78476499&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;只需要看前面半部分的配置即可&lt;/li&gt;
&lt;li&gt;5、可以输入 https://www.baidu.com 测试下是否能够捕获https请求。&lt;/li&gt;
&lt;li&gt;6、到这里前期工作基本完成。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 class=&quot;myH5&quot;&gt;要区分需要处理跨域的场景&lt;/h5&gt;
&lt;p class=&quot;smallTitle&quot;&gt;1、网上百花撩乱的fiddle处理方式&lt;/p&gt;
&lt;p&gt;如果去搜索fiddle处理跨域，想必会搜索出来满屏幕的fiddle的处理方式。&lt;br/&gt;不能用的不能说是错的，只是可能不适用当前自己所需要的场景。&lt;/p&gt;
&lt;p class=&quot;smallTitle&quot;&gt;2、场景1，用本地的文件来替代网络上的文件，进行规则替换&lt;/p&gt;
&lt;p&gt;这类的文章少说占了搜索结果的一半，&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;例如csdn的一篇 &lt;a href=&quot;https://blog.csdn.net/qq_39207948/article/details/79758866&quot;&gt;前端开发fiddler跨域请求代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际上就是对线上的文件进行替换，单个替换，正则匹配都行。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://file.yyyno.com/file/img/blog/fiddle-3.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;替换成功后，便可以在本地修改代码使之生效。&lt;/p&gt;
&lt;p class=&quot;smallTitle&quot;&gt;3、场景2，修改的Customize Rules，通常我们都这这类去修改规则，才能解决自己的跨域问题&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;值得注意的是，在这个场景值其实也分为两块，一块是在OnBeforeRequest中，还有一块是在OnBeforeResponse中，&lt;br/&gt;就是一个发送请求之前，另一个是在发送请求之后响应之前 搞清楚了这个以后，就很容易知道自己在哪个地方，去添加什么代码了&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://file.yyyno.com/file/img/blog/fiddle-1.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://file.yyyno.com/file/img/blog/fiddle-2.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h5 class=&quot;myH5&quot;&gt;具体举例说明：&lt;/h5&gt;
&lt;p&gt;1、当需求在请求返回的时候解决跨域，要设置 Access-Control-Allow-Origin:*&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
       static function OnBeforeResponse(oSession: Session) {
        if (m_Hide304s &amp;amp;&amp;amp; oSession.responseCode == 304) {
            oSession[&quot;ui-hide&quot;] = &quot;true&quot;;
        }
        oSession.responseCode=200;
        oSession.oResponse.headers.Add(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type,x-requested-with&quot;);
        oSession.oResponse.headers.Add(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;notice&quot;&gt;可以参考 &lt;a href=&quot;https://segmentfault.com/a/1190000017102559&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、当要设置请求头部的时候，就需要在OnBeforeRequest做文章了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
  if (oSession.HostnameIs(&quot;xxx.xxx.com&quot;)){
          oSession.oRequest.headers.Remove(&quot;Origin&quot;);
      }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如可以针对特定的域名移除掉Origin&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;此外也可以处理重定向&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
      var origin_host=&quot;172.16.11.21&quot;;
            var origin_port=&quot;8080&quot;;
            var origin_domain=origin_host+&quot;:&quot;+origin_port;
            var replace_host=&quot;www.hongbaorili.com&quot;;
            var replace_port=&quot;80&quot;;
            var replace_domain=replace_host+&quot;:&quot;+replace_port;

            if(oSession.host==origin_domain){
                oSession.host=replace_domain;
                }

            if ( (oSession.PathAndQuery == (origin_host+&quot;:&quot;+origin_port))) {
                oSession.PathAndQuery = replace_host+&quot;:&quot;+replace_port;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如 &lt;a href=&quot;https://blog.csdn.net/u010565244/article/details/51094319&quot; target=&quot;_blank&quot;&gt;fiddler重定向本地服务器URL到线上URL&lt;/a&gt;&lt;/p&gt;
&lt;h5 class=&quot;myH5&quot;&gt;结尾：&lt;/h5&gt;
&lt;p&gt;其实在Customize Rules.js这个文件中还可以处理很多场景下的东西，有兴趣的话可以自己再多研究，另外这一篇文章，也介绍的蛮多详情点，&lt;a href=&quot;https://www.cnblogs.com/hhhyaaon/p/5839283.html&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段时间都一直浸淫在小程序当中，有愿意讨论的童鞋欢迎，目前小程序已稳定上线2个多月，社区类的小程序。&lt;/p&gt;
&lt;p&gt;转载请注明&lt;a href=&quot;https://www.cnblogs.com/star-wind/p/10341573.html&quot; target=&quot;&quot;&gt;原文地址&lt;/a&gt; https://www.cnblogs.com/star-wind/p/10341573.html:谢谢&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/qianyinghuanmie&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt;,欢迎拍砖&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 31 Jan 2019 05:42:00 +0000</pubDate>
<dc:creator>starWind</dc:creator>
<og:description>认真的用fiddle处理跨域 相信很多前端的同学都或多或少被跨域这个问题烦恼过，网上很多处理的方式其实都是要后端处理， 用fiddle来处理 ，就不必看后端的脸色了，自己安安心心的倒腾接口，何乐而不为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/star-wind/p/10341573.html</dc:identifier>
</item>
<item>
<title>《ASP.NET Core In Action》读书笔记系列，这是一个手把手的从零开始的教学系列目录 - china_fucan</title>
<link>http://www.cnblogs.com/VolcanoCloud/p/10341531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/VolcanoCloud/p/10341531.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;最近打算系统学习一下asp.net  core ，苦于没有好的中文书藉，只好找来一本英文的 《ASP.NET Core In Action》学习。我和多数人一样，学习英文会明显慢于中文。希望与我相同情况的人避免这样的低效，决定把书重要的部分提取出来分享给大家。这本书从零开始，深入浅出的介绍了ASP.NET Core。即使是初学者，也一看就懂，希望你能坚持看来，同进也希望我自己能坚持抽出时间完成此系列，如果你准了，那就让我们一起开始这段学习旅程。记得推荐一下，以示鼓励和赞同。谢谢！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/VolcanoCloud/p/10304405.html&quot;&gt;《ASP.NET Core In Action》读书笔记系列一 ASP.NET Core 的诞生&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/VolcanoCloud/p/10310321.html&quot;&gt;《ASP.NET Core In Action》读书笔记系列二 ASP.NET Core 能用于什么样的应用，什么时候选择ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/VolcanoCloud/p/10313928.html&quot;&gt;《ASP.NET Core In Action》读书笔记系列三 ASP.NET Core如何处理请求的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/VolcanoCloud/p/10320923.html&quot;&gt;《ASP.NET Core In Action》读书笔记系列四 创建ASP.NET Core 应用步骤及相应CLI命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/VolcanoCloud/p/10338342.html&quot;&gt;《ASP.NET Core In Action》读书笔记系列五 ASP.NET Core 解决方案结构解析1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新中....&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 05:00:00 +0000</pubDate>
<dc:creator>china_fucan</dc:creator>
<og:description>最近打算系统学习一下asp.net core ，苦于没有好的中文书藉，只好找来一本英文的 《ASP.NET Core In Action》学习。我和多数人一样，学习英文会明显慢于中文。希望与我相同情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/VolcanoCloud/p/10341531.html</dc:identifier>
</item>
<item>
<title>F# 4.6 预览版正式公布 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/10341510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/10341510.html</guid>
<description>&lt;p&gt;1月24日，F# 4.6 预览版正式公布，与以往一样，新版本的设计与开发过程是整个 F# 开源社区共同努力的结果，这次更新的具体讨论内容可以通过下面两个链接来查看：&lt;/p&gt;
&lt;p&gt;这次更新的主要内容有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;匿名记录类型（Anonymous Records）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ValueOption&lt;/code&gt; 模块&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;List&lt;/code&gt;，&lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;Seq&lt;/code&gt; 新增的 &lt;code&gt;tryExactlyOne&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;匿名记录类型anonymous-records&quot;&gt;匿名记录类型（Anonymous Records）&lt;/h2&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;p&gt;F# 新增了匿名记录类型，举个例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;// {| ... |} 用来声明一个匿名的记录
let data = {| X = 1; Y = &quot;abc&quot; |}
// val data : {| X : int; Y : string |}

let result = data.X + data.Y.Length

// 匿名记录同样可以使用 with 关键字复制并更新
let newData = {| data with Z = data.X + 5 |}

// 匿名记录还可以作为函数的参数使用
let someFunc (d: {| X : int; Y: string |}) =
    printfn &quot;X: %d; Y: %s&quot; d.X d.Y&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为什么我们需要这个新特性&quot;&gt;为什么我们需要这个新特性&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;F# 中声明一个记录类型真的很繁琐，尤其是我们只需要一次性的引用一个记录类型的时候&lt;/li&gt;
&lt;li&gt;C# 3.0 引入的匿名对象在 F# 中找不到对应的概念，这在把 C# 代码转换为 F# 代码的时候带来很大的痛苦&lt;/li&gt;
&lt;li&gt;C# 7.0 为元组类型添加了命名字段，而当前的 F# 会忽略掉这部分的信息&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;匿名记录的类型&quot;&gt;匿名记录的类型&lt;/h3&gt;
&lt;p&gt;为了保证程序集中拥有相同结构的匿名记录类型的一致性，编译器会使用 SHA1 算法根据匿名记录的字段名列表（排序后）为匿名记录生成唯一的类型标识。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;{| X : int |}&lt;/code&gt; 与 &lt;code&gt;{| Y : int |}&lt;/code&gt; 会被生成为两个不同的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{| X : int; Y : int |}&lt;/code&gt; 与 {| Y : int; X : int |} 是同一个类型&lt;/li&gt;
&lt;li&gt;匿名记录可以使用 &lt;code&gt;struct&lt;/code&gt; 关键字修饰，这样生成出来的就是结构体类型的记录了&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;与-record-的不同&quot;&gt;与 Record 的不同&lt;/h3&gt;
&lt;h4 id=&quot;拷贝更新&quot;&gt;拷贝更新&lt;/h4&gt;
&lt;p&gt;匿名记录的拷贝更新功能非常的灵活，这是因为匿名记录的拷贝更新并不要求原始类型与结果类型一致，所以下面的代码都是成立的：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;
type RefRecord = { X : int; }
let refRecord = { X = 1 }

// 结果类型不必与原始类型相同
let dataA = {| refRecord with Y = &quot;string&quot; |}   // 结果为 {| X = 1; Y = &quot;string&quot; |}
let dataB = {| dataA with Y = 23333 |}          // 结果为 {| X = 1; Y = 23333 |}

// 甚至还可以从引用类型中拷贝数据到结构体中，反过来也是可以的
let dataC = struct {| dataB with Z = true |}    // 结果为 {| X = 1; Y = 23333; Z = true |}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过在现阶段，我们还是无法通过拷贝更新的方法用匿名记录来创建 Record。&lt;/p&gt;
&lt;h4 id=&quot;模式匹配&quot;&gt;模式匹配&lt;/h4&gt;
&lt;p&gt;由于匿名记录的特点，现阶段还无法对匿名记录使用模式匹配解构，这是因为当我们把匿名记录中的某些字段在模式匹配中忽略掉的时候，可能会产生新的类型，如上面所说的，匿名记录的类型标识是由其全部的字段决定的。&lt;/p&gt;
&lt;h4 id=&quot;其他的一些限制&quot;&gt;其他的一些限制&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;无法使用 &lt;code&gt;CLIMutable&lt;/code&gt; 特性修饰，这也意味着匿名记录是不可变的&lt;/li&gt;
&lt;li&gt;匿名记录无法定义类成员（包括成员字段、属性、方法等），这是因为记录仅仅只是用来保存数据的，&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;valueoption-模块&quot;&gt;&lt;code&gt;ValueOption&lt;/code&gt; 模块&lt;/h2&gt;
&lt;p&gt;FSharp.Core 4.6.0 中带来了 &lt;code&gt;ValueOption&lt;/code&gt; 模块，为 FSharp.Core 4.5.0 中引入的 &lt;code&gt;ValueOption&lt;/code&gt; 类型带来了大量的实用函数，详情请见 &lt;a href=&quot;https://github.com/fsharp/fslang-design/blob/master/FSharp.Core-4.6.0/FS-1065-valueoption-parity.md&quot;&gt;RFC 说明页面&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为-listarrayseq-新增的-tryexactlyone&quot;&gt;为 &lt;code&gt;List&lt;/code&gt;，&lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;Seq&lt;/code&gt; 新增的 &lt;code&gt;tryExactlyOne&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这个函数类似于 LINQ 中的 &lt;code&gt;SingleOrDefault&lt;/code&gt;，不过它并不会抛出异常，而是以一个温和的 &lt;code&gt;Option&lt;/code&gt; 类型作为返回值：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;List.tryExactlyOne []
// None
List.tryExactlyOne [1]
// Some 1
List.tryExactlyOne [1; 2]
// None

Array.tryExactlyOne null
// ArgumentNullException
Array.tryExactlyOne [||]
// None
Array.tryExactlyOne [|1|]
// Some 1
Array.tryExactlyOne [|1; 2|]
// None

Seq.tryExactlyOne null
// ArgumentNullException
Seq.tryExactlyOne (Seq.ofList [])
// None
Seq.tryExactlyOne (Seq.ofList [1])
// Some 1
Seq.tryExactlyOne (Seq.ofList [1; 2])
// None&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;尽管 F# 4.6 只是一个小小的功能特性更新，但是匿名记录出现给 F# 开发带来了新的活力，除了能够减少代码量之外，匿名记录也让 F# 开发者能够更加轻松的使用以 C# 为主导的 .NET 生态。&lt;/p&gt;
&lt;p&gt;以上就是 F# 4.6 的更新简介，更加详细的介绍可以查看&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2019/01/24/announcing-f-4-6-preview/&quot;&gt;微软博客的公告&lt;/a&gt;以及相关的 RFC 记录。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;同步发表于个人博客： &lt;a href=&quot;https://gianthard.rocks/a/50&quot;&gt;F# 4.6 预览版正式公布&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Jan 2019 04:51:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<og:description>1月24日，F 4.6 预览版正式公布，与以往一样，新版本的设计与开发过程是整个 F 开源社区共同努力的结果，这次更新的具体讨论内容可以通过下面两个链接来查看： 'F 4.6 意见征求记录' 'FSh</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/10341510.html</dc:identifier>
</item>
</channel>
</rss>