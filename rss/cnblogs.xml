<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2019.NET Conf，我们在共同期待 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/11789069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/11789069.html</guid>
<description>&lt;p&gt;不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉了一个技术社区，并在腾讯云加社区、微软Azure云技术社区的大力支持，在华邦互联、百师通教育、校管家、心莱科技、长沙冉星信息、深圳纵网长沙分公司、北大青鸟海纳学院等优秀企业的赞助下，在四月组织了一次技术大会，上午场邀请到了张善友老师、梁桐铭老师和汪鹏老师，下午场邀请到了腾讯云的胡李伟老师和卓伟老师，一天的分享安排的满满当当，在小城长沙的.net技术圈掀起了一波小浪潮。&lt;/p&gt;
&lt;p&gt;不过大概我们几个996程序员们和几位创业者们的业余时间着实有点匮乏，许下了不少宏伟蓝图，转眼间就把自己的flag吞掉，让组织者之一我感觉到颇为尴尬。一个优秀的社区，一定得持续的把活动拉起来，让更多优秀开发者能够在这里传递更多正能量，让技术的星星之火点燃，推向更加广阔的人群。只有更多的人参与进来，社区之水能够源远流长的持续不断的流下去，才能真正获得长效的发展。&lt;/p&gt;
&lt;p&gt;不过显然，虽然企业和开发者都对一个积极优秀的社区充满兴趣，但是却缺少真正能够站出来积极拉动社区的开发者，由于社区初成立、大部分参与者都只是以看热闹的态度，这也让那些对原本充满热情的早期参与者的热情熄灭，很快就偃旗息鼓，然后社区就看起来名存实亡了。&lt;/p&gt;
&lt;p&gt;无论是作为组织者的我们，或者是做为观众的开发者们，对社区期许过高。总是高估了自己的计划能力，组织者们太想更早的出成绩、有时候又心态不纯，想借此机会获得一些虚名，但是一旦遇到挫折就会浇灭火苗，然后曾经的豪言壮语都将成为泡影。而作为参与者，确实苦于没有社区这样一个集体，于是总想着更早的看到成绩，然后发现这个社区其实有点名不副实之后，就失去兴趣了。&lt;/p&gt;
&lt;p&gt;无论作为组织者，还是参与者都是或许一样的三分钟热度。在技术这条路上，追求三天打鱼、两天晒网、恨不能一口吃成大胖子的心态数见不鲜。每个人都能在这个波澜壮阔的大时代成为网红，但只有少数人真正能成为明星，大部分人都将在红完他那五分钟后，瞬间谢幕。&lt;/p&gt;
&lt;p&gt;也就像许多年轻的开发者们总是能很快的成长，在技术的甘泉中以飞快的速度汲取到足够的养分，但是却只有区区百分之五的掌握了优秀学习方法的、最优秀、能够一步一个脚印的开发者最终能够一直长期的走下去。他们既有长远规划、也有短期计划，不过分在乎眼前得失、不汲汲于名利、不戚戚于自我，他们的每一天都在坚持，让他们靠自己的努力创造了不菲的业绩。&lt;/p&gt;

&lt;p&gt;有人说，大环境不好，再努力都是徒劳。对于.NET开发者来说，9012年的今天，大环境似乎没那么好了。在过去十年，正是互联网产业大爆发、中国经济飞速增长的十年。&lt;/p&gt;
&lt;p&gt;在这十年的前五年里，执掌微软的Steve Ballmeerr犯了许多错误，首先是错过了移动互联网的爆发，失去了手机阵地、买了诺基亚，然后却将其埋葬。错过了从软件到硬件转型的大时代，他自称为最大的遗憾。&lt;/p&gt;
&lt;p&gt;其次在云端战略中，失去了先机，在阿里云开始大规模铺云端战略时，微软和中国互联网三巨头中的两家，百度和腾讯一样，并没有在第一时间看到企业级市场对于云的巨大需求，还好后期继任者纳德拉及时按下了刷新键，才得以转型成功。毕竟是一家有着四十多年历史的公司，基因决定了企业的思维模式，能够实现自我变革，确实是一家伟大的企业。&lt;/p&gt;
&lt;p&gt;而对于广大.NET开发者来说，则错过了跟随中国互联网发展的最佳时期，由于.NET技术与微软windows平台的深度绑定、windows平台本身较高的授权费用，让对互联网基础平台需求非常旺盛、而对成本效益最为在意的互联网公司最终纷纷抛弃了.NET平台，转移到了开源和授权费用相对较低的Linux平台，并开始逐步使用Java、Go、Python等作为主力开发语言。&lt;/p&gt;
&lt;p&gt;说来也有点遗憾，在20世纪末时，微软也曾是Java主要推动者的Sun公司最大的竞争对手，C#之父Anders Hejlsberg，在他的职业生涯的早期，开发出了Delphi，是大杀器；而职业生涯的中期，基于开源的Java开发出的J#和在Windows上使用的虚拟机，甚至比Sun公司自己开发的虚拟机都好用，最终让Sun不得不通过法律手段来寻求庇佑。然后Anders Hejlsberg大神将主要精力投入到.NET和C#这种优秀的语言中，并大杀四方，获得了非常广泛的用户。&lt;/p&gt;
&lt;p&gt;然而，三十年河东，三十年河西。本世纪前几年Windows平台的火爆，确实有力的推动了中国信息产业的繁荣昌盛和发展、微软甚至被称为互联网的黄埔军校，号称撑起了中国互联网的半边天，许多大型互联网公司的CTO或高管（包括阿里云的王坚博士），都是从微软出来的。但是由于后来微软自身的战略原因和中国互联网产业的独特性，让Windows开始失宠，而.NET技术开始走向下滑。以至于今日，许多培训机构也不再开设这门技术。&lt;/p&gt;
&lt;p&gt;有人说：大环境不好，所以开发者找工作都很困难。但是也得承认，在环境下的个人，其实不过是此起彼伏翻转、甚至被拍打在沙滩上的浮萍，被人生裹挟着，难免会失去目标，当然也得承认，适应环境的能力非常重要。就像许多开发者都转型到其他语言，这就是在环境下的自然选择，这或许会让大家会有点遗憾。不过我觉得，逐利是人性自然的需求，能够在一门语言上一直走下去固然重要，但是选择变化也无可厚非。毕竟真正掌握了像.NET这种优秀的技术、以及C#这门优秀的语言，不仅在windows下能够做出优秀的产品，也同样能够驾驭包括像Java这样优秀的技术。我们都是程序员，而不仅仅是某个专门领域的程序员，始终抱有开放的心态，能够让我们的职场更加顺畅、也让我们的人生更加圆满。&lt;/p&gt;

&lt;p&gt;而一个人的成长，其实与某种语言本身无关、取决于对待技术的认真态度、和孜孜不倦的求索精神。就像我们对社区充满了殷切期待，却不能指望他一天就成为巨人，这需要一次又一次的设计、测试、调试和优化、甚至还需要进行大规模的重构，才足以成为更加完美的软件。这需要许多人一起努力，有共同的目标和执着的信念，每个人或许是不同的角色、职位、岗位、或技能特色，但是大家的心在一起，这就是一个完整的生态。&lt;/p&gt;
&lt;p&gt;我还记得我刚刚参加工作的2009年，恰好是Java最低迷的一个时期，优秀的技术先锋Sun公司被迫以白菜价被Oracle收购，一度让.NET带来了机遇。（这也是我选择.NET的一个大环境原因）。时至今日，这门技术我已经用了十年，虽然技术不好，但是我很庆幸见到了几位对技术执着追求的优秀开发者。对于他们，我们或许认识，或许不认识，或许他们出名、也或许他们低调，但是他们都是我们值得学习的优秀榜样。&lt;/p&gt;
&lt;p&gt;当博客园的创始人dudu把博客园搭起来时，他为了实现个人技术理想使用了.NET技术来构建博客站、而且这个小站是在扬州这样一个小城市成立的，当时的类似的轻博客竞争对手也很多，所以许多人都不看好他。但是十五年的成长，博客园已经成为许多程序员的心灵港湾，在这里各种不同技术的开发者在这里交流，打造了一个和谐宁静的技术圣地。&lt;/p&gt;
&lt;p&gt;有一个或许有人熟悉的论坛，叫做苏飞论坛，是一个历史悠久的小论坛，站长苏飞不仅是一位老程序员、目前也是一位创业者，他的论坛非常活跃，技术氛围浓烈，许多开发者在这里获得了大量有用的知识，包括我就是获益者之一。&lt;/p&gt;
&lt;p&gt;从CSkin开始，到DSkin，小红帽和乔克斯他们几位开发者，他们基于.NET构建了一套完整的界面库、效果优美，性能优异，打造了一个不错的小圈子。&lt;/p&gt;
&lt;p&gt;张善友老师运营.NET社区、公众号和博客，虽然同期有数十位开发者与他一起开始经营公众号，但是他一直坚持下来，目前公众号已经拥有数万粉丝，堪称.NET领域的KOL。&lt;/p&gt;
&lt;p&gt;苏盛巍老师把他的全部精力都投入到基于微信的SDK开发过程中，到目前已经拥有数十万用户基于这套SDK组件，开发出大量优秀的应用，极大的促进了微信应用市场的繁荣。&lt;/p&gt;
&lt;p&gt;刘怡、谢炀、刘浩杨、何镇汐、娄宇等五位老师，他们不仅自己学习技术，还积极分享技术，组成一个社区，邀请了许多优秀开发者一起来贡献更加优秀的.NET Core技术，让中国的.NET Core开源社区越发的强大。&lt;/p&gt;
&lt;p&gt;这些都是我恰好认识并曾经熟悉的优秀开发者，而在我们身边还有更多知名或不知名的优秀开发者，他们用他们的实际行动，一点点的点亮了黑暗时代，并迎来了新的黎明-----脱离Windows平台、开源的.NET Core技术。&lt;/p&gt;
&lt;p&gt;时至今日.NET Core已经发布了3.0的版本，惠及数十万开发者。&lt;/p&gt;

&lt;p&gt;使用.NET、.NET Core技术的开发者，这就是一个完整的生态。&lt;/p&gt;
&lt;p&gt;而.NET Core技术，将成为我们的武器，带领我们开启新的征程。曾经.NET技术的发展只能依靠微软，而今，要依靠的不仅仅是微软、更是真正的社区力量，更好的生态、将在我们的手中塑造。 互联网的大时代，或许一波波浪潮将不再滚滚，但是产业互联网的大势已经即将拉开，这是我们的.NET开发者们的主场。&lt;/p&gt;
&lt;p&gt;云原生、多平台、以及开放、创新的.NET 新时代，已经到来。&lt;/p&gt;
&lt;p&gt;2019年11月9日，我们在上海等你，不见不散。这是一次完全有社区力量倾力打造的技术盛会，组织者们力求完美，只为给你献上一道力求优秀的技术盛宴，数十位.NET圈子的技术大牛，他们无偿付出，就是想让大家知道，.NET 技术什么都能干，什么都能干得最好。&lt;/p&gt;
&lt;p&gt;我们期待大家一起来关注，也请大家相信，.NET社区，从来不是一个人在战斗，齐心协力，生态将更加美好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分享一下活动地址（来自dotNET跨平台）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大会的日期是：2019年11月9日 09:00-18：00 &lt;/p&gt;
&lt;p&gt;大会地址：（上海杨浦）佳木斯路777号上海中谷小南国花园酒店&lt;/p&gt;
&lt;p&gt;门票优惠：每张门票299， 购买团体票（大于10张）享受整单8折优惠，请通过邮箱联系主办方 dotnet@dotnetconf.cn&lt;/p&gt;
&lt;p&gt;报名方式 &lt;/p&gt;
&lt;p&gt;活动行：&lt;a href=&quot;https://www.huodongxing.com/event/4514005355700&quot; class=&quot;uri&quot;&gt;https://www.huodongxing.com/event/4514005355700&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201911/191302-20191103205716348-1147688880.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;百格活动：&lt;a href=&quot;https://www.bagevent.com/event/6069892&quot; class=&quot;uri&quot;&gt;https://www.bagevent.com/event/6069892&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201911/191302-20191103205716348-1147688880.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;center&gt;本文版权归原作者和博客园共同拥有。作品采用知识共享署名-非商业性使用-相同方式共享4.0 国际许可协议进行许可。&lt;/center&gt;
&lt;center&gt;本文来自： 溪源 | 长沙.NET技术社区。阅读更多精彩好文，欢迎关注长沙.NET技术社区公众号【DotNET技术圈】。&lt;/center&gt;
&lt;center&gt;首发于溪源的个人博客www.techq.xyz&lt;/center&gt;
</description>
<pubDate>Mon, 04 Nov 2019 00:21:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>（一）回顾一个小社区红过的五分钟 不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/11789069.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（9）：K-means聚类算法. slides - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11790227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11790227.html</guid>
<description>&lt;p&gt;注：本系列所有博客将持续更新并发布在&lt;a href=&quot;https://github.com/ChenHuabin321/machine_learning_review&quot;&gt;github&lt;/a&gt;和&lt;a href=&quot;https://gitee.com/chenhuabin/machine_learning_review&quot;&gt;gitee&lt;/a&gt;上，您可以通过github、gitee下载本系列所有文章笔记文件。&lt;/p&gt;

&lt;p&gt;本文我们来总结K-means算法。&lt;/p&gt;
&lt;p&gt;与之前介绍过的诸多分类算法不同，K-means算法属于聚类算法的范畴。说到这里，必须得所以说分类算法与聚类算法的区别。&lt;/p&gt;
&lt;p&gt;分类算法与聚类算法最本质的区别在于分类算法是一种有监督学习方法，这一类算法在真正用于实践前，必须通过已知样本标签的数据进行训练，以建立样本特征属性到样本标签的最佳拟合模型；与之相反，无监督学习方法可以在没有任何先验知识的情况下进行分类，这种方法根据相似性原则，将具有较高相似度的数据对象划分至同一类簇，将具有较高相异度的数据对象划分至不同类簇，最终实现对数据集的分类。&lt;/p&gt;

&lt;h2 id=&quot;2.1-算法思想&quot;&gt;2.1 算法思想&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/11790227.html#2.1-算法思想&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;K-means算法是一种基于距离的聚类算法，这类聚类算法以距离来度量对象间的相似性，两样本对象间距离越大，相似性越小。关于K-means算法，有一个非常经典的故事：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有4个牧师去郊区村庄授课，刚开始，4个牧师在村庄里分别随机选了一个位置，然后将位置公布给全村村民，村民收到消息后，纷纷选择最近的一个牧师那里去听课。牧师授课时，众多村民反馈路途太远，于是牧师记录了来听自己授课的所有村民的居住地址，第二次授课时，牧师选择自己记录的村民的中心位置作为新的授课位置，然后将位置公布给全村村民，村民收到4位牧师新的授课位置后，同样根据距离选择最近的牧师去听课。之后4位牧师的每次一次授课都根据来听自己讲课的村民登记的居住地址来更新下一次授课的位置，而村民也更新4位牧师更新的位置来选择授课牧师，直到村民的选择不再发生变化，则牧师授课的位置也彻底稳定下来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;K-means算法思想与上面故事中牧师选位所表现出来的原理是十分相似的，最终的目的都是实现所有样本数据（村民）到聚类中心（牧师）的距离之和最小化。K-means算法实现步骤如下：&lt;/p&gt;
&lt;p&gt;输入：数据集$D = \{ {x_1},{x_2}, \cdots ,{x_n}\} $，聚类个数$k$&lt;/p&gt;
&lt;p&gt;输出：聚类结果类簇&lt;/p&gt;
&lt;p&gt;（1）随机初始化$k$个样本作为聚类中心$\{ {\mu _1},{\mu _2}, \cdots ,{\mu_k}\} $；&lt;/p&gt;
&lt;p&gt;（2）计算数据集中所有样本$x_i$到各个聚类中心$\mu_j$的距离$dist({x_i},{\mu _j})$，并将$x_i$划分到距离最小的聚类中心所在类簇中；&lt;/p&gt;
&lt;p&gt;（3）对于每一个类簇，更新其聚类中心：${\mu _i} = \frac{1}{{|{c_i}|}}\sum\limits_{x \in {c_i}} x $&lt;/p&gt;
&lt;p&gt;（4）重复（2）（3）步骤，直到聚类中心不再有明显变化或满足迭代次数。&lt;/p&gt;
&lt;p&gt;总结而言，K-means算法整个流程可总结为一个优化问题，通过不断迭代使得目标函数收敛，K-means算法目标函数为： $$J = \sum\nolimits_{j = 1}^k {\sum\nolimits_{i = 1}^n {dist({x_i},{\mu _j})} } $$&lt;/p&gt;
&lt;p&gt;从目标函数中可以看出，有两个因素对聚类结果有着至关重要的影响：$k$值、距离度量方式。&lt;/p&gt;
&lt;p&gt;对于$k$值，这是K-means算法一个绕不开的问题，直接影响着最终聚类结果的准确性，在如何确定$k$值问题上，传统的的K-means算法在对数据分布未知的情况下只能通过多次尝试不同的$k$值来探索最优取值。值得一说的是，众多专家学者针对K-means算法中如何确定$k$值、甚至避开$k$值的的问题对K-means算法进行优化改进，设计了许多改进的K-means算法，这又是一个大话题了，本文不在深究。&lt;br/&gt;下面在说说距离度量的问题。&lt;/p&gt;
&lt;h2 id=&quot;2.2-距离度量&quot;&gt;2.2 距离度量&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/11790227.html#2.2-距离度量&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于K-means算法这类基于距离（其他还有基于密度、网格、层次、模型）的聚类算法，距离度量贯穿了算法的整个流程，所以选择一种合适的距离度量方式尤为重要。&lt;br/&gt;这里列举几种常见的距离度量方式。&lt;/p&gt;
&lt;p&gt;（1）闵可夫斯基距离（Minkowski Distance） 对于两个给定的$d$维数据样本$X = ({x_1},{x_2}, \cdots ,{x_p})$，$Y = ({y_1},{y_2}, \cdots ,{y_p})$，闵可夫斯基距离定义为： $$dist(X,Y) = \root p \of {\sum\limits_{i = 1}^d {|{x_i} - {y_i}{|^p}} } $$&lt;/p&gt;
&lt;p&gt;当$p=1$时，闵可夫斯基距离又被称为曼哈顿距离(Manhattan Distance)： $$dist(X,Y) = \sum\limits_{i = 1}^d {|{x_i} - {y_i}|} $$ 曼哈顿距离可以看做是数据样本在各维度差值的绝对值之和，又被称为折线距离、街区距离。相比于欧氏距离，曼哈顿距离没进行平方运算，所以对离群点不敏感。&lt;/p&gt;
&lt;p&gt;当$p=2$时，闵可夫斯基距离就是我们熟悉的欧氏距离： $$dist(X,Y) = \sqrt {\sum\limits_{i = 1}^d {|{x_i} - {y_i}{|^2}} } $$&lt;/p&gt;
&lt;p&gt;（2）余弦距离（Cosine）&lt;/p&gt;
&lt;p&gt;余弦距离以两向量夹角余弦值来反映相似度，取值在$[0,1]$之间，值越大，相似度越大。&lt;br/&gt;$$dist(X,Y) = \cos (X,Y) = \frac{{\sum\nolimits_{i = 1}^d {{x_i}{y_i}} }}{{\sqrt {\sum\nolimits_{i = 1}^d {{{({x_i})}^2}} } \sqrt {\sum\nolimits_{i = 1}^d {{{({y_i})}^2}} } }}$$&lt;/p&gt;
&lt;p&gt;余弦距离在文本识别中应用比较普遍。&lt;/p&gt;
&lt;p&gt;（3）切比雪夫距离 (Chebyshev Distance )&lt;/p&gt;
&lt;p&gt;切比雪夫距离是以各维度差值的最大值作为最终的相似度： $$dist(X,Y) = \mathop {\max }\limits_i (|{x_i} - {y_i}|)$$&lt;/p&gt;
&lt;p&gt;除了这三个常用距离外，还有马氏距离、皮尔逊相关系数、KL散度等等距离度量方法。&lt;/p&gt;
&lt;h2 id=&quot;2.3-算法总结&quot;&gt;2.3 算法总结&lt;a class=&quot;anchor-link&quot; href=&quot;https://www.cnblogs.com/chenhuabin/p/11790227.html#2.3-算法总结&quot;&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;K-means算法是一个应用十分广泛、出场率极高的一个聚类算法，思想简单，解释性强，设定好$k$值后即可输出指定数量的类簇。不过，在实际应用中，也需要注意K-means算法的不足之处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;K-means算法的$k$值必须在聚类前确定，在缺乏对数据集分布认知的情况下这往往是很难估计的，只能通过多次的尝试探索最佳的$k$值。&lt;/li&gt;
&lt;li&gt;K-means算法第一次迭代时的$k$个聚类中心对算法最终结果有很大影响，但在K-means算法中，第一次迭代的$k$各聚类中心是随机选定的，这给算法聚类结果带来了不确定性。&lt;/li&gt;
&lt;li&gt;K-means算法对非球状分布的数据集上表现不佳。K-means算法这类基于距离的聚类算法基本假设是同一类簇内部对象间距离远小于不同类簇间对象距离，这种假设相当于将类簇看作是一个球状，所以对非球状分布的数据集，K-means算法表现可能并不佳。&lt;/li&gt;
&lt;li&gt;K-means算法在不断迭代过程中使得算法逐渐优化，在每一次迭代中，都必须计算每一个对象与聚类中心的距离，所以当数据量非常大时，时间开销比较大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;天下没有免费的误差，也没有适合所有场景的算法，想要享受算法有点，就必须承受算法的不足，根据实际应用选择合适的算法才是最佳选择。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Nov 2019 00:08:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>K-means算法是一种基于距离的聚类算法，这类聚类算法以距离来度量对象间的相似性，两样本对象间距离越大，相似性越小。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11790227.html</dc:identifier>
</item>
<item>
<title>Java8系列  (五)  Optional类 - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/11783499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/11783499.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在Java8之前, 如果需要对一个变量做一次 null 检查, 通常会像下面这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    T t =&lt;span&gt; service1.query();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        K k &lt;/span&gt;=&lt;span&gt; service2.update(t);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            U u &lt;/span&gt;=&lt;span&gt; service3.save(k);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果业务比较复杂, 可能会像上面那样, 使用 if 语句进行多层嵌套, 后期难以扩展。&lt;/p&gt;
&lt;p&gt;在Java8中新引入了一个 Optional 类, Optional 类会对可能为 null 值的变量进行建模, 这样你就不必直接将 null 赋值给变量, 也就不必像上面那样进行多层嵌套检查。&lt;/p&gt;
&lt;p&gt;在正式介绍 Optional 类的 API之前, 先引入一些实体类, 后面的代码示例会经常用到它们。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fe060bd8-58d7-4219-ac9b-f678d235082c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fe060bd8-58d7-4219-ac9b-f678d235082c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fe060bd8-58d7-4219-ac9b-f678d235082c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fe060bd8-58d7-4219-ac9b-f678d235082c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fe060bd8-58d7-4219-ac9b-f678d235082c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Optional&amp;lt;Car&amp;gt;&lt;span&gt; getCar() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.ofNullable(car);
    }
}

@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Insurance insurance;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Optional&amp;lt;Insurance&amp;gt;&lt;span&gt; getInsurance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.ofNullable(insurance);
    }
}

@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Insurance {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建Optional对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Optional 类提供了三种方式来创建 Optional 对象&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;empty(): 创建一个空的 Optional 对象&lt;/li&gt;
&lt;li&gt;of(): 将指定值用 Optional 封装之后返回,如果该值为 null ,则抛出一个 NullPointerException 异常&lt;/li&gt;
&lt;li&gt;ofNullable(): 将指定值用 Optional 封装之后返回,如果该值为 null ,则返回一个空的 Optional 对象&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个空的optional&lt;/span&gt;
        Optional&amp;lt;Car&amp;gt; c1 =&lt;span&gt; Optional.empty();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据一个非空的值创建optional, 如果传入的值是null，会抛出空指针异常&lt;/span&gt;
        Optional&amp;lt;Car&amp;gt; c2 = Optional.of(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可接受null的Optional&lt;/span&gt;
        Optional&amp;lt;Object&amp;gt; c3 = Optional.ofNullable(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;flatMap和map用法&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;flatMap()和map()都是在指定值存在时, 就对该值执行提供的 mapping 函数调用, 返回一个 Optional 类型的值, 否则就返回一个空的 Optional 对象。&lt;/p&gt;
&lt;p&gt;注意 flatMap() 方法的转换函数是 &lt;span class=&quot;cnblogs_code&quot;&gt;Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, Optional&amp;lt;U&amp;gt;&amp;gt; mapper&lt;/span&gt; , 这个特性和前面介绍的 Stream 类的 flatMap() 很像。&lt;/p&gt;
&lt;p&gt;查看一下 Optional 类的源码, flatMap() 会将 Optional&amp;lt;T&amp;gt; 中的 T 转换成 Optional&amp;lt;U&amp;gt;, 再将转换后的 Optional&amp;lt;U&amp;gt; 直接作为方法返回值返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        Optional&lt;/span&gt;&amp;lt;Person&amp;gt; person = Optional.ofNullable(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person());
        String name &lt;/span&gt;= person.flatMap(Person::getCar).flatMap(Car::getInsurance).map(Insurance::getName).orElse(&quot;哪吒之魔童降世&quot;&lt;span&gt;);
        System.out.println(name); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: 哪吒之魔童降世&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码示例中,  因为 Person 实体类中 car 属性是一个 null 值, 所以  &lt;span class=&quot;cnblogs_code&quot;&gt;person.flatMap(Person::getCar)&lt;/span&gt; 这个操作会得到一个空的Optional 对象。&lt;/p&gt;
&lt;p&gt;这样就导致了后面的 flatMap() 和 map() 两次转换都返回一个空的 Optional 对象。orElse() 方法的含义是如果有值则将其返回,否则返回一个默认值。所以最后的输出结果是默认值  &lt;span class=&quot;cnblogs_code&quot;&gt;哪吒之魔童降世&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;在实际业务中, 你可以像下面这样将 Optional 作为方法入参和返回值使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3() {
        Optional&lt;/span&gt;&amp;lt;Insurance&amp;gt; insurance1 = find(Optional.of(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person()), Optional.empty());
        System.out.println(insurance1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: Optional.empty&lt;/span&gt;
        Optional&amp;lt;Insurance&amp;gt; insurance2 = find(Optional.of(&lt;span&gt;new&lt;/span&gt; Person()), Optional.of(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car()));
        System.out.println(insurance2);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: Optional[Insurance(name=null)]&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Optional&amp;lt;Insurance&amp;gt; find(Optional&amp;lt;Person&amp;gt; person, Optional&amp;lt;Car&amp;gt;&lt;span&gt; car) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; person.flatMap(p -&amp;gt; car.map(c -&amp;gt;&lt;span&gt; find(p, c)));
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Insurance find(Person p, Car c) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Insurance();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;filter和ifPresent&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;filter(): 如果值存在并且满足提供的谓词, 就返回包含该值的 Optional 对象; 否则返回一个空的 Optional 对象&lt;/li&gt;
&lt;li&gt;ifPresent(): 如果值存在, 就执行使用该值的方法调用, 否则什么也不做&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4() {
        Optional.of(&lt;/span&gt;&quot;攀登者&quot;).filter(i -&amp;gt; i.length() &amp;lt; 4).ifPresent(System.out::println);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印: 攀登者&lt;/span&gt;
        Optional.&amp;lt;String&amp;gt;empty().filter(i -&amp;gt; i.length() &amp;lt; 4).ifPresent(System.out::println);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有输出&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个测试示例, 到本地去运行看下输出结果, 它可以帮你重新理解一下前面介绍的几个 API 的用法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5() {
        System.out.println(getCarInsuranceName(Optional.empty(), &lt;/span&gt;8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: 命运之夜&lt;/span&gt;
        Person p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        p.setAge(&lt;/span&gt;10&lt;span&gt;);
        System.out.println(getCarInsuranceName(Optional.of(p), &lt;/span&gt;8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: 命运之夜&lt;/span&gt;
        Insurance insurance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Insurance();
        insurance.setName(&lt;/span&gt;&quot;知否知否&quot;&lt;span&gt;);
        Car car &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car();
        car.setInsurance(insurance);
        p.setCar(car);
        System.out.println(getCarInsuranceName(Optional.of(p), &lt;/span&gt;8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: 知否知否&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出年龄大于或者等于 minAge 参数的 Person 所对应的保险公司列表。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String getCarInsuranceName(Optional&amp;lt;Person&amp;gt; person, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minAge) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; person.filter(p -&amp;gt; p.getAge() &amp;gt;= minAge).flatMap(Person::getCar).flatMap(Car::getInsurance).map(Insurance::getName).orElse(&quot;命运之夜&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Optional与异常的对比&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通常在由于某种因素下, 函数无法正确返回某个值, 常见的做法就是使用 try/catch 语句处理返回一个null值, 或者不做任何处理直接抛出一个异常。&lt;/p&gt;
&lt;p&gt;如果函数无法正确返回某个值, 且你不需要它抛出异常, 而是要它返回一个默认值, 那么 Optional 可以帮您更优雅的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test6() {
        String value &lt;/span&gt;= &quot;test&quot;&lt;span&gt;;
        Integer res &lt;/span&gt;= Optional.of(value).flatMap(&lt;span&gt;this&lt;/span&gt;::str2Int).filter(i -&amp;gt; i &amp;gt; 0).orElse(0&lt;span&gt;);
        System.out.println(res);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result: 0&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Optional&amp;lt;Integer&amp;gt;&lt;span&gt; str2Int(String str) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果能正确解析, 就将其封装在 Optional 中返回&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.of(Integer.valueOf(str));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException ex) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果解析发生异常, 就返回一个空的 Optional&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.empty();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码清单,   &lt;span class=&quot;cnblogs_code&quot;&gt;Integer.valueOf()&lt;/span&gt; 会在入参不是一个整型数值时, 抛出 &lt;span class=&quot;cnblogs_code&quot;&gt;NumberFormatException&lt;/span&gt; , 我们这里对它做了处理, 当解析发生异常时, 就返回一个空的 Optional 对象。&lt;/p&gt;
&lt;p&gt;上面的用例只有在 value 变量是大于零的整型数值时, 才会输出 value 变量的值, 否则, 输出结果都是默认值 0。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;最后, 来一张大图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201911/1278884-20191102205651575-453227367.png&quot; alt=&quot;&quot; width=&quot;780&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26772632//&quot; target=&quot;_blank&quot;&gt;Java8 实战&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;AllanboltSignature&quot; readability=&quot;8.6943620178042&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/qingshanli/&quot; target=&quot;_blank&quot;&gt;张小凡&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/qingshanli/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qingshanli/&lt;/a&gt;&lt;br/&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。如果觉得还有帮助的话，可以点一下右下角的【推荐】。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 04 Nov 2019 00:05:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<og:description>概述 在Java8之前, 如果需要对一个变量做一次 null 检查, 通常会像下面这样写 如果业务比较复杂, 可能会像上面那样, 使用 if 语句进行多层嵌套, 后期难以扩展。 在Java8中新引入了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qingshanli/p/11783499.html</dc:identifier>
</item>
<item>
<title>【深入理解多态】从“妈妈我想吃烤山药”讲起 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11790201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11790201.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;
&lt;p&gt;在我认为多态绝对是面向对象的第三大特性中让很多小白同学以及初学者难以跨越的鸿沟，因为多态有很多细节性的知识，不花点时间，还真不好理解多态。这么说吧，如果你觉得你已经完全理解了多态，你不妨做做下面的程序，如果你能全都答对，那没问题了，多态对你来说真的不是问题！如果在第四个就趴下了，那可以看看这篇文章，或许对你有所帮助，可能会让你重新见识到多态的魅力。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;
//爷爷类
class Ye {
    public String show(Sun obj) {
        return (&quot;Ye and Sun&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Ye and Ye&quot;);
    }

}
//爸爸类
class Fu extends Ye {
    public String show(Fu obj) {
        return (&quot;Fu and Fu&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Fu and Ye&quot;);
    }
}
//儿子类
class Zi extends Fu {

}
//孙子类
class Sun extends Fu {

}

public class PolymorphicTest {
    public static void main(String[] args) {
         Ye y = new Ye();
        Ye y2 = new Fu(); //向上
        Fu f = new Fu();
        Zi z = new Zi();
        Sun s = new Sun();


        System.out.println(&quot;第一题 &quot; + y.show(f));
        System.out.println(&quot;第二题 &quot; + y.show(z));
        System.out.println(&quot;第三题 &quot; + y.show(s));
        System.out.println(&quot;第四题 &quot; + y2.show(f));  //到这里挂了？？？
        System.out.println(&quot;第五题 &quot; + y2.show(z));
        System.out.println(&quot;第六题 &quot; + y2.show(s));
        System.out.println(&quot;第七题 &quot; + f.show(f));
        System.out.println(&quot;第八题 &quot; + f.show(z));
        System.out.println(&quot;第九题 &quot; + f.show(s));
     
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先把答案记在小本本上吧，再对照下面结果看看&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;第一题 Ye and Ye
第二题 Ye and Ye
第三题 Ye and Sun
第四题 Fu and Ye
第五题 Fu and Ye
第六题 Ye and Sun
第七题 Fu and Fu
第八题 Fu and Fu
第九题 Ye and Sun&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你对上面的结果很意外，或者不解，那么恭喜你，你又能学到新知识了，成功的向架构师前进了一步！好了，让我们一起重新见识见识多态的魅力吧！&lt;/p&gt;
&lt;h2 id=&quot;从吃烤山药重新认识多态&quot;&gt;1、从吃烤山药重新认识多态&lt;/h2&gt;
&lt;p&gt;最近不是正火着吃烤山药么，学习就要走有趣化路线，毕竟兴趣永远最好的老师，咋们放开点，怎么有趣怎么来。&lt;/p&gt;
&lt;p&gt;小明妈妈的情绪非常不稳定，心情好的时候巴不得给小明花一个亿，，心情不好的时候巴不得把小明打成麻瓜，可是小明永远不知道妈妈的情绪变化。这不，今天一位老大爷在卖烤山药，边烤还边跳激光雨，嗨得不行，小明特别喜欢激光雨，马上就忍不住了，心里默默想着，刚烤的山药它不香嘛，激光雨烤的山药它不香嘛。于是忍不住对妈妈说：“妈妈，我想吃烤山药”，这个时候，来了,来了,他来了，它真的来了....你激动个锤子啊......是代码来了：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;


     class  Matcher{
        public void matcherSpeak(){
            System.out.println(&quot;想吃烤山药？&quot;);
        }
    }

     class HappyMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;开心的妈妈说：吃，吃大块的，一火车够吗&quot;);
        }
    }

     class SadMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;不开心的妈妈说：吃你个憨皮，看我回家扎不扎你就完事了&quot;);
        }
    }

     class VeryHappyMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;异常开心的妈妈说：买买买，烤山药咱全买了，顺便把大爷也买回家，天天给你表演激光雨（大爷懵逼中）&quot;);
        }
    }

    public class UnderstandPolymorphic{
        public static void main(String[] args) {
            Matcher m = new HappyMother();
            m.matcherSpeak();

            m = new SadMother();
            m.matcherSpeak();

            m = new VeryHappyMother();
            m.matcherSpeak();

        }
    }
运行结果：

开心的妈妈说：吃，吃大块的，一火车够吗
不开心的妈妈说：吃你个憨皮，看我回家扎不扎你就完事了
异常开心的妈妈说：买买买，烤山药咱全买了，顺便把大爷也买回家，天天给你表演激光雨（大爷懵逼中）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;妈妈听到小明想吃烤山药这同一行为，表现出不同的表现形式，这就是多态。多态专业定义则是：&lt;span&gt;程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定&lt;/span&gt;，这种情况叫做多态没错是没错就是脑壳有点大，所以我选择简单点定义多态： &lt;span&gt;&lt;strong&gt;多态指同一行为，具有多个不同表现形式&lt;/strong&gt;&lt;/span&gt;。为何会有如此微妙的变化呢，那我们就必须了解进行多态的前提了。&lt;/p&gt;
&lt;h2 id=&quot;多态前提条件重点&quot;&gt;2、 多态前提条件【重点】&lt;/h2&gt;
&lt;p&gt;如果多态不能满足以下三个前提条件，那还玩犊子的多态【构不成多态，缺一不可】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承或者实现【二选一】&lt;/li&gt;
&lt;li&gt;方法的重写【意义体现：不重写，无意义】&lt;br/&gt;子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象（也可以说向上转型）【体现在格式上】&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回过头来看烤山药例子，确实都有继承，同样都重写了&lt;code&gt;motherSpeak（）&lt;/code&gt;方法，最关键的代码则是&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; Matcher m = new HappyMother();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是所谓的 父类引用指向子类对象，这其实就是向上转型！对向上转型概念不清晰没事，下面会详细讲解。&lt;/p&gt;
&lt;h2 id=&quot;多态的体现&quot;&gt;3、 多态的体现&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;多态体现的格式： &lt;strong&gt;父类/父接口类型 变量名 = new 子类对象&lt;/strong&gt;； &lt;strong&gt;变量名.方法名()&lt;/strong&gt;;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误 ,如果有，执行的是子类重写后的方法&lt;/strong&gt;&lt;/span&gt;，也就是向上转型时， &lt;span&gt;&lt;strong&gt;子类单独定义的方法丢失问题&lt;/strong&gt;&lt;/span&gt;。编译报错。 代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){//=========================父类matcherSpeak()方法
        System.out.println(&quot;吃烤山药？&quot;);
    }
}

class HappyMother extends Matcher {
    public void matcherSpeak(){//=========================子类matcherSpeak()方法
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一蛇皮袋够吗&quot;);
    }

    public void fatherSpeak(){//=========================子类独有的fatherSpeak()方法
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一麻袋够吗&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher m=new HappyMother();
        m.matcherSpeak();
        m.fatherSpeak();  //编译失败，无法解析fatherSpeak方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/31/16e2225bd601a8ab?w=1920&amp;amp;h=882&amp;amp;f=png&amp;amp;s=276574&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;当然这个例子只是入门级的，接下来看个有点水平的例子&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }

}

class HappyMother extends Matcher {
    public void matcherSpeak(){
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一火车够吗&quot;);
    }
}
class SadMother extends HappyMother{
    public void tt(){
        System.out.println(&quot;ttttttt&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher mm=new SadMother();
        mm.matcherSpeak();
    }

运行结果：开心的妈妈说：吃，吃大块的，一火车够吗
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了第一个基础这个相信不难理解，接着看&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }
}

class HappyMother extends Matcher {
    
}
class SadMother extends HappyMother{
    public void tt(){
        System.out.println(&quot;ttttttt&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher mm=new SadMother();
        mm.matcherSpeak();
    }
    
运行结果：想吃烤山药？

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，再来回味下这句话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误 ,如果有，执行的是子类重写后的方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可能会说子类中都没有这些个方法啊，何来执行子类重写后的方法一说？它好像是去父类中找该方法了。事实上，子类中是有这些方法的，这个方法继承自父类，只不过没有覆盖该方法，所以没有在子类中明确写出来而已，看起来像是调用了父类中的方法，实际上调用的还是子类中的。同学继承方面的知识该补补了，可以参考下面这篇&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102375196&quot;&gt;【java基础】java继承从“我爸是李刚”讲起&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;向上转型&quot;&gt;4、向上转型&lt;/h2&gt;
&lt;p&gt;向上转型：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的。你可以把这个过程理解为基本类型的小类型转大类型自动转换，不需要强制转换。 当&lt;span&gt;&lt;strong&gt;父类引用指向一个子类对象时，便是向上转型&lt;/strong&gt;&lt;/span&gt;。 向上转型格式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;父类类型 变量名 = new 子类类型(); 如：&lt;code&gt;Father f= new Son();&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子的话，烤山药的例子就是一个典型的向上转型例子&lt;/p&gt;
&lt;h2 id=&quot;向下转型&quot;&gt;5、向下转型&lt;/h2&gt;
&lt;p&gt;向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。同样可以把这个过程理解为基本类型的自动转换，大类型转小类型需要强制转换。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，向下转使用格式：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Father father = new Son();&lt;/code&gt;&lt;br/&gt;子类类型 变量名 = (子类类型) 父类变量名; 如:&lt;code&gt;Son s =(Son) father;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道你们有没有发现，向下转型的前提是父类对象指向的是子类对象（也就是说，在&lt;span&gt;向下转型之前，它得先向上转型&lt;/span&gt;），当然，向下转型还是有它的意义所在，下面就讲解向下转型的意义。&lt;/p&gt;
&lt;p&gt;到这里，我们讲解一下为什么要向下转型？上面已经讲到过当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&quot;小麻烦&quot;。所以，&lt;span&gt;&lt;strong&gt;想要调用子类特有的方法，必须做向下转型&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }
}

class XiongHaiZi extends Matcher {
    public void eat(){
        System.out.println(&quot;妈妈，我想吃烤山药&quot;);
    }

    public void eatSuLi(){//============================子类特有的eatSuLi方法
        System.out.println(&quot;麻麻，我想吃酥梨，要吃麻瓜那么大的酥梨&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        
        Matcher m = new XiongHaiZi();//向上转型
        
        XiongHaiZi x = (XiongHaiZi)m;//向下转型
        
        x.eatSuLi();//执行子类特有方法

    }
    
    运行结果：麻麻，我想吃酥梨，要吃麻瓜那么大的酥梨
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了向下转型就讲到这里...等等，你真的以为就讲完了？肯定不行喽，向下转型还有一个要说的知识，讲之前先来看个程序先&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山猪？&quot;);
    }

}

class Boy extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;妈妈，我想吃烤山猪&quot;);
    }
}

class Girl extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;妈妈，我想吃烤山猪2333&quot;);
    }
}

public class Test {
    public static void main(String[] args) {

        Matcher g = new Girl();//向上转型编译通过

        Boy x = (Boy)g;//向下转型

        x.eatKaoYang();//编译通过,但运行报ClassCastException

    }
    
 运行结果：  运行报ClassCastException

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码可以通过编译，但是运行时，却报出了 &lt;code&gt;ClassCastException&lt;/code&gt; ，类型转换异常！这是因为，明明创建了&lt;code&gt;Girl&lt;/code&gt;类型对象，运行时，当然不能转换成&lt;code&gt;Boy&lt;/code&gt;对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。 为了避免&lt;code&gt;ClassCastException&lt;/code&gt;的发生，Java提供了 &lt;code&gt;instanceof&lt;/code&gt; 关键字，给引用变量做类型的校验。&lt;/p&gt;
&lt;h4 id=&quot;instanceof的使用&quot;&gt;instanceof的使用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 的格式：&lt;br/&gt;变量名 instanceof 数据类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 的使用&lt;br/&gt;如果变量属于该数据类型，返回true。&lt;br/&gt;如果变量不属于该数据类型，返回false。&lt;/p&gt;
&lt;p&gt;所以，转换前，我们最好使用&lt;code&gt;instanceof&lt;/code&gt; 先做一个判断，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }

}

class Boy extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;Boy：妈妈，我想吃烤羊&quot;);
    }
}

class Girl extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;Girl：妈妈，我想吃烤全羊2333&quot;);
    }
}

public class Test {
    public static void main(String[] args) {

        Matcher g = new Girl();//向上转型

        if(g instanceof Girl){
            Girl x = (Girl)g;//向下转型
            x.eatKaoYang();  //=====================调用Girl的eatKaoYang()方法
        }else if(g instanceof Boy){ //不执行
            Boy x = (Boy)g;//向下转型
            x.eatKaoYang();  //=====================调用Boy的eatKaoYang()方法
        }
    }
}

运行结果： Girl：妈妈，我想吃烤全羊2333&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了到这里，你get到了咩？&lt;/p&gt;
&lt;h2 id=&quot;向上向下转型再次分析加餐不加价&quot;&gt;6、向上向下转型再次分析【加餐不加价】&lt;/h2&gt;
&lt;p&gt;看完之后是不是还是不够清晰向上向下转型？多态转型问题其实并不复杂，只要记住一句话：&lt;span&gt;&lt;strong&gt;父类引用指向子类对象&lt;/strong&gt;&lt;/span&gt;。那什么叫父类引用指向子类对象？看下面例子吧&lt;/p&gt;
&lt;p&gt;有两个类，&lt;code&gt;Father&lt;/code&gt; 是父类，&lt;code&gt;Son&lt;/code&gt; 类继承自 &lt;code&gt;Father&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第 1 个例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//  f1 引用指向一个Son对象
Father f1 = new Son();   // 这就叫 upcasting （向上转型)
// f1 还是指向 Son对象
Son s1 = (Son)f1;   // 这就叫 downcasting (向下转型)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第 2 个例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// f1现在指向father对象
Father f2 = new Father();
Son s2 = (Son)f2;       // 出错，子类引用不能指向父类对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你或许会问，第1个例子中：&lt;code&gt;Son s1 = (Son)f1&lt;/code&gt;; 为什么是正确的呢。很简单因为 &lt;code&gt;f1&lt;/code&gt; 指向一个子类对象，&lt;code&gt;Father f1 = new Son()&lt;/code&gt;; 子类 &lt;code&gt;s1&lt;/code&gt; 引用当然可以指向子类对象了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;f2&lt;/code&gt; 被传给了一个 &lt;code&gt;Father&lt;/code&gt; 对象，&lt;code&gt;Father f2 = new Father()&lt;/code&gt;; 子类 &lt;code&gt;s2&lt;/code&gt; 引用不能指向父类对象。&lt;/p&gt;
&lt;h2 id=&quot;多态与构造器之间的微妙&quot;&gt;7、多态与构造器之间的微妙&lt;/h2&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;

class EatKaoShanYao {
    EatKaoShanYao () {
        System.out.println(&quot;吃烤山药之前...&quot;);
        eat();
        System.out.println(&quot;吃烤山药之后(熊孩子懵逼中)....&quot;);
    }
    public void eat() {
        System.out.println(&quot;7岁半就喜欢吃烤山药&quot;);
    }
}
public class KaoShanYao extends EatKaoShanYao {
    private String Weight = &quot;110斤&quot;;
    public KaoShanYao(String Weight) {
        this.Weight = Weight;
        System.out.println(&quot;熊孩子的体重：&quot; + this.Weight);
    }

    public void eat() { // 子类覆盖父类方法
        System.out.println(&quot;熊孩子吃烤山药之前的体重是：&quot; + this.Weight);
    }

    //Main方法
    public static void main(String[] args) {
           EatKaoShanYaok = new KaoShanYao(&quot;250斤&quot;);
                      
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;童鞋们可以试想一下运行结果，再看下面的输出结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; 运行结果：
                吃烤山药之前...
                熊孩子吃烤山药之前的体重是：null
                吃烤山药之后(熊孩子懵逼中)....
                熊孩子的体重：250斤&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很疑惑？结果为啥是这样？你看，熊孩子又懵逼了，Why？&lt;/p&gt;
&lt;p&gt;原因其实很简单，因为在创建子类对象时，会先去调用父类的构造器，而父类构造器中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么（先初始化父类的时候还没开始初始化子类），于是把&lt;code&gt;String&lt;/code&gt;类型的属性暂时初始化为默认值&lt;code&gt;null&lt;/code&gt;，然后再调用子类的构造器（这个时子类构造器已经初始&lt;code&gt;Weight&lt;/code&gt;属性，所以子类构造器知道熊孩子的体重&lt;code&gt;Weight&lt;/code&gt;是250）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果有什么不理解的可以及时告诉我，楼主一直都在，还有如果楼主哪里写错了或者理解错了，请及时告诉我，一定要告诉我！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;多态的优点&quot;&gt;8、多态的优点&lt;/h2&gt;
&lt;p&gt;讲了这么久的多态，我觉得其优点已经不明觉厉了。但是还是来聊聊多态在实际开发的过程中的优点。在实际开发中父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。&lt;br/&gt;为了更好的对比出多态的优点，下面程序不使用多态，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;
//父类：动物类
class Animal{
    public void eat(){
        System.out.println(&quot;eat&quot;);
    }
}
//猫类
class Cat {
    //方法重写
    public void eat(){
        System.out.println(&quot;猫吃猫骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;猫叫&quot;);
    }
}
//狗类
class Dog {
    public void eat(){
        System.out.println(&quot;狗吃狗骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;狗叫&quot;);
    }
}

//针对动物操作的工具类
class AnimalTool{

    private AnimalTool(){}//把工具类的构造方法私有，防止别人创建该类的对象。

    //调用猫的功能
    public static void catLife(Cat c){  //工具类，方法就写成static的，然后直接在测试类：工具类名.方法 使用。
        c.eat();
        c.call();
    }
    //调用狗的功能
    public static void dogLife(Dog d){
        d.eat();
        d.call();
    }
}

public class Test{
    public static void main(String[] args){

        Cat c= new Cat();
        AnimalTool.catLife(c);

        Dog d= new Dog();
        AnimalTool.dogLife(d);

    }
}
运行结果：
        猫吃猫骨头
        猫叫
        狗吃狗骨头
        狗叫&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只写了两只动物，如果再来一种动物猪，则需要定义个猪类，提供猪的两个方法，再到工具类中添加对应的&lt;code&gt;XXLife&lt;/code&gt;方法，这三步都是必须要做的，而且每多一种动物就需要在工具类中添加一种一个对应的&lt;code&gt;XXLife&lt;/code&gt;方法，这样维护起来就很麻烦了，毕竟动物种类成千上万！崩溃吧，没事多态来拯救你，如下使用多态代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;
//父类：动物类
class Animal{
    public void eat(){
        System.out.println(&quot;eat&quot;);
    }
    public void call(){
        System.out.println(&quot;call&quot;);
    }
}
//猫类
class Cat extends Animal {
    //方法重写
    public void eat(){
        System.out.println(&quot;猫吃猫骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;猫叫&quot;);
    }
}
//狗类
class Dog extends Animal {
    public void eat(){
        System.out.println(&quot;狗吃狗骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;狗叫&quot;);
    }
}

//针对动物操作的工具类
class AnimalTool{

    private AnimalTool(){}//最好把工具类的构造方法私有，防止别人创建该类的对象。该类是工具类。

    //调用所以动物的功能
    public static void animalLife(Animal a){  //工具类，方法就写成static的，然后直接在测试类：工具类名.方法 使用。
        a.eat();
        a.call();
    }

}

public class Test{
    public static void main(String[] args){

        Cat c= new Cat();
        AnimalTool.animalLife(c);

        Dog d= new Dog();
        AnimalTool.animalLife(d);
运行结果：
        猫吃猫骨头
        猫叫
        狗吃狗骨头
        狗叫
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意： 上面动物类都继承了&lt;code&gt;animal&lt;/code&gt;父类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候再分析，如果再来一种动物猪，则需要定义个猪类，提供猪的两个方法，再继承&lt;code&gt;Animal&lt;/code&gt;父类，这个时候就不需要在工具类中添加对应的&lt;code&gt;XxLife&lt;/code&gt;方法，只写一个&lt;code&gt;animalLife&lt;/code&gt;方法即可，而且每多一种动物都不需要在工具类中添加对应的&lt;code&gt;XxLife&lt;/code&gt;方法，这样维护起来就很乐观了。&lt;/p&gt;
&lt;p&gt;由于多态特性的支持，&lt;code&gt;animalLife&lt;/code&gt;方法的Animal类型，是&lt;code&gt;Cat&lt;/code&gt;和&lt;code&gt;Dog&lt;/code&gt;的父类类型，父类类型接收子类对象，当 然可以把&lt;code&gt;Cat&lt;/code&gt;对象和&lt;code&gt;Dog&lt;/code&gt;对象传递给方法。 当&lt;code&gt;eat&lt;/code&gt;和&lt;code&gt;call&lt;/code&gt;方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与&lt;code&gt;Animal&lt;/code&gt;的子类中的&lt;code&gt;eat&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;方法一致， 所以&lt;code&gt;animalLife&lt;/code&gt;完全可以替代以上两方法。 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写&lt;code&gt;XxLife&lt;/code&gt;方法了，直接使用 &lt;code&gt;animalLife&lt;/code&gt;就可以完成。 所以，多态的好处，体现在可以使程序编写的更简单，并有良好的扩展。&lt;/p&gt;
&lt;h2 id=&quot;分析开篇的九个问题&quot;&gt;9、分析开篇的九个问题&lt;/h2&gt;
&lt;p&gt;看到这里，相信童鞋们多多少少都应该对多态都一定的了解了，都应该很有信心解决开篇的难题了吧，我可以很负责的告诉你，文章看到这里，你依旧解决不了这几个问题，不要问我为啥知道，你可以试着再做一遍，代码贴在下面：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;
//爷爷类
class Ye {
    public String show(Sun obj) {
        return (&quot;Ye and Sun&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Ye and Ye&quot;);
    }

}
//爸爸类
class Fu extends Ye {
    public String show(Fu obj) {
        return (&quot;Fu and Fu&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Fu and Ye&quot;);
    }
}
//儿子类
class Zi extends Fu {

}
//孙子类
class Sun extends Fu {

}

public class PolymorphicTest {
    public static void main(String[] args) {
         Ye y = new Ye();
        Ye y2 = new Fu(); //向上
        Fu f = new Fu();
        Zi z = new Zi();
        Sun s = new Sun();


        System.out.println(&quot;第一题 &quot; + y.show(f));
        System.out.println(&quot;第二题 &quot; + y.show(z));
        System.out.println(&quot;第三题 &quot; + y.show(s));
        System.out.println(&quot;第四题 &quot; + y2.show(f));  //到这里挂了？？？
        System.out.println(&quot;第五题 &quot; + y2.show(z));
        System.out.println(&quot;第六题 &quot; + y2.show(s));
        System.out.println(&quot;第七题 &quot; + f.show(f));
        System.out.println(&quot;第八题 &quot; + f.show(z));
        System.out.println(&quot;第九题 &quot; + f.show(s));
     
    }

打印结果：
    第一题 Ye and Ye
    第二题 Ye and Ye
    第三题 Ye and Sun
    第四题 Fu and Ye
    第五题 Fu and Ye
    第六题 Ye and Sun
    第七题 Fu and Fu
    第八题 Fu and Fu
    第九题 Ye and Sun
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想理解上面这个例子，童鞋们必须读懂这句话：&lt;span&gt;&lt;strong&gt;当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。首先会先去可调用的方法的父类中寻找，找到了就执行子类中覆盖的该方法，就算子类中有现成的该方法，它同样也会去父类中寻找，早到后未必执行子类中有现成的方法，而是执行重写在父类中找到的方法的子类方法（这里的子类也就是最后决定调用的类方法）。&lt;/strong&gt;&lt;/span&gt;你是不是晕了？读着都觉得拗口，要理解可就拗的不是口了而是拗头 ~啥玩意没听过这个词~ 咳咳，问题不大，楼主来通俗的给大家讲解，让大家理解。&lt;/p&gt;
&lt;p&gt;还记不记得楼主之前定义向上转型是怎么定义的？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;【v8提示】 向上转型：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的。你可以把这个过程理解为基本类型的小类型转大类型自动转换，不需要强制转换。 当&lt;span&gt;&lt;strong&gt;父类引用指向一个子类对象时，便是向上转型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可是，你真的理解了咩？什么叫做父类对象引用变量引用子类对象？其实还得从下面这句话找头绪&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;向上转型定义：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就好比&lt;code&gt;Father f = new Son()&lt;/code&gt;；有的童鞋就会说这个f也算是父类的对象引用？如果按字面理解是子类的引用只不过该引用的类型为&lt;code&gt;Father&lt;/code&gt;类型？这时你就大错特错了。&lt;/p&gt;
&lt;p&gt;我们把向上转型定义简化一下理解一下，简化如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;子类类型默认向父类类型向上转换的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在明白了咩？这句话可以理解为&lt;code&gt;Father f = new Son()&lt;/code&gt;这句代码原本是&lt;code&gt;Father f = （Father ）new Son()&lt;/code&gt;这样子的只是这个转换过程是默认自动转的，总的来说也就是 &lt;code&gt;new Son()&lt;/code&gt;其实本质就是&lt;code&gt;new Father&lt;/code&gt;，所以&lt;code&gt;f&lt;/code&gt;其实就是父类对象引用！这个时候再来拆开理解下面这段话&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当父类对象引用变量引用子类对象时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中&lt;span&gt;&lt;strong&gt;父类对象引用变量&lt;/strong&gt;&lt;/span&gt;指的就是&lt;code&gt;f&lt;/code&gt;，&lt;span&gt;&lt;strong&gt;子类对象&lt;/strong&gt;&lt;/span&gt;指的就是&lt;code&gt;new Son（）&lt;/code&gt;，所以加起来就是当f引用&lt;code&gt;new Son（）&lt;/code&gt;时&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的 &lt;span&gt;&lt;strong&gt;被引用对象的类型&lt;/strong&gt;&lt;/span&gt;则是指&lt;code&gt;new Son（）&lt;/code&gt;对象中的&lt;code&gt;Son&lt;/code&gt;类型， &lt;span&gt;&lt;strong&gt;引用变量类型&lt;/strong&gt;&lt;/span&gt;则是指&lt;code&gt;f&lt;/code&gt;的类型&lt;code&gt;Father&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;好了总结关联起来就是当：&lt;code&gt;f&lt;/code&gt;引用&lt;code&gt;new Son（）&lt;/code&gt;时，&lt;code&gt;Son&lt;/code&gt;决定了调用它的成员方法，&lt;code&gt;Father&lt;/code&gt;决定可调用&lt;code&gt;Father&lt;/code&gt;中的方法。所以以&lt;code&gt;Father f = new Son()&lt;/code&gt;举例，简单来说就是&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/31/16e2225bd5e1e45f?w=1740&amp;amp;h=439&amp;amp;f=png&amp;amp;s=103903&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/31/16e2225bd5f8715b?w=1444&amp;amp;h=232&amp;amp;f=png&amp;amp;s=41660&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后我们一起来正式分析那九个题&quot;&gt;10、最后我们一起来正式分析那九个题&lt;/h2&gt;
&lt;p&gt;前三个并没有涉及到多态（向上转型），所以只会调用&lt;code&gt;yeye&lt;/code&gt;本类的方法，这里只要掌握继承的知识就OK了。&lt;/p&gt;
&lt;p&gt;讲解第四题之前，你的答案是不是&lt;code&gt;&quot;Fu and Fu&quot;&lt;/code&gt;？来了喔，马上让你巅覆对多态的人生观！&lt;/p&gt;
&lt;p&gt;分析第四题，首先&lt;code&gt;Ye y2 = new Fu()&lt;/code&gt;; 向上转型了，所以首先会去&lt;code&gt;Fu&lt;/code&gt;类的父类&lt;code&gt;Ye&lt;/code&gt;类中找&lt;code&gt;show(f)&lt;/code&gt;方法，找到了&lt;code&gt;show(Ye obj)&lt;/code&gt;方法，之后回到&lt;code&gt;Fu&lt;/code&gt;类中看是否有&lt;code&gt;show(Ye obj)&lt;/code&gt;重写方法，发现&lt;code&gt;Fu&lt;/code&gt;类有&lt;code&gt;show(Ye obj)&lt;/code&gt;方法（重写），所以最后执行了&lt;code&gt;&quot;Fu and Ye&quot;&lt;/code&gt;，你get了咩？&lt;/p&gt;
&lt;p&gt;分析第五题，其实第五题和第四题基本差不多，第四题是&lt;code&gt;y2.show(f)&lt;/code&gt;；第五题是&lt;code&gt;y2.show(z)&lt;/code&gt;；只是&lt;code&gt;show&lt;/code&gt;的方法参数不同，相同的是&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;z&lt;/code&gt;在&lt;code&gt;Ye&lt;/code&gt;类中找的都是&lt;code&gt;show(Ye obj)&lt;/code&gt;方法，所以，最终第四题和第五题结果一致！&lt;/p&gt;
&lt;p&gt;分析第六题，第六题其实挺有趣，首先&lt;code&gt;y2.show(s)&lt;/code&gt;，到Ye类中找到&lt;code&gt;show(Sun obj)&lt;/code&gt;，之后在子类中看有没有重写，发现并没有&lt;code&gt;show(Sun obj)&lt;/code&gt;重写方法，确定没有咩？别忘了这是继承，子类&lt;code&gt;Fu&lt;/code&gt;中默认有着父类&lt;code&gt;Ye&lt;/code&gt;的方法，只是没有表面表示出来，从另一角度出发，&lt;code&gt;Fu&lt;/code&gt;类中默认重写了一个&lt;code&gt;show(Sun obj)&lt;/code&gt;方法，就算不写也是存在的，所以运行结果为&lt;code&gt;&quot;Ye and Sun&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第七、八题就不分析了，毕竟也没有涉及到向上转型（多态）。&lt;/p&gt;
&lt;p&gt;最后分析一下第九题，有的童鞋就要打楼主了，第九题不也是没有涉及到向上转型（多态）吗，楼主你个星星（**），当然，楼主就算背着黑锅也要分析第九题~就是这么傲娇~，确实没有涉及到向上转型（多态），我要讲的原因很简单，因为我觉得还是很有必要！首先&lt;code&gt;f.show(s)&lt;/code&gt;不涉及多态，它只会调用自己类（&lt;code&gt;Fu&lt;/code&gt;）的方法，但是你会发现&lt;code&gt;Fu&lt;/code&gt;中并没有&lt;code&gt;show(s)&lt;/code&gt;，唉唉唉，我运行你重新组织下语言，又忘了？这是继承啊，它有默认父类&lt;code&gt;Ye&lt;/code&gt;中的&lt;code&gt;show(Sun obj)&lt;/code&gt;方法鸭！好了到这里，我总结出一点，你多态以及没得问题了，不过你继承方面知识薄弱啊，不行不行楼主得给你补补，还在犹豫什么鸭，快来补补继承知识！！！&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102375196&quot;&gt;【java基础】java继承从“我爸是李刚”讲起&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文的最后，我只是个人对多态的理解，楼主只是个java小白，叫我老白也行，不一定全部正确，如果有什么错误请一定要告诉我，感激不尽感激不尽感激不尽！！！欢迎指正~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后的最后，如果本文对你有所帮助就点个爱心支持一下吧 ~佛系报大腿~&lt;/p&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/30/16e1cd84d248874c?w=430&amp;amp;h=430&amp;amp;f=png&amp;amp;s=94196&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Nov 2019 23:56:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 在我认为多态绝对是面向对象的第三大特性中让很多小白同学以及初学者难以跨越的鸿沟，因为多态有很多细节性的知识，不花点时间，还真不好理解多态。这么说吧，如果你觉得你已经完全理解了多态，你不妨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11790201.html</dc:identifier>
</item>
<item>
<title>Pandas | 17 缺失数据处理 - PythonGirl</title>
<link>http://www.cnblogs.com/Summer-skr--blog/p/11705887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer-skr--blog/p/11705887.html</guid>
<description>&lt;p&gt;&lt;span&gt;数据丢失(缺失)在现实生活中总是一个问题。 机器学习和数据挖掘等领域由于数据缺失导致的数据质量差，在模型预测的准确性上面临着严重的问题。 在这些领域，缺失值处理是使模型更加准确和有效的重点。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;h2--&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用重构索引(reindexing)，创建了一个缺少值的DataFrame。 在输出中，&lt;strong&gt;&lt;code&gt;NaN&lt;/code&gt;表示不是数字的值&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2-u68C0u67E5u7F3Au5931u503C&quot;&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为了更容易地检测缺失值(以及跨越不同的数组&lt;code&gt;dtype&lt;/code&gt;)，Pandas提供了&lt;code&gt;isnull()&lt;/code&gt;和&lt;code&gt;notnull()&lt;/code&gt;函数，它们也是Series和DataFrame对象的方法 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3&lt;span&gt;),
                  index&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                  columns&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].&lt;span&gt;isnull()&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
        one       two     three&lt;br/&gt;a  0.036297 -0.615260 -1.341327&lt;br/&gt;b       NaN       NaN       NaN&lt;br/&gt;c -1.908168 -0.779304  0.212467&lt;br/&gt;d       NaN       NaN       NaN&lt;br/&gt;e  0.527409 -2.432343  0.190436&lt;br/&gt;f  1.428975 -0.364970  1.084148&lt;br/&gt;g       NaN       NaN       NaN&lt;br/&gt;h  0.763328 -0.818729  0.240498&lt;p&gt;a    False&lt;br/&gt;b     True&lt;br/&gt;c    False&lt;br/&gt;d     True&lt;br/&gt;e    False&lt;br/&gt;f    False&lt;br/&gt;g     True&lt;br/&gt;h    False&lt;br/&gt;Name: one, dtype: bool
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;示例2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].&lt;span&gt;notnull()&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;language-python code-toolbar&quot;&gt;
&lt;span&gt;&lt;span&gt;输出&lt;/span&gt;&lt;span&gt;结果：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
a     True&lt;br/&gt;b    False&lt;br/&gt;c     True&lt;br/&gt;d    False&lt;br/&gt;e     True&lt;br/&gt;f     True&lt;br/&gt;g    False&lt;br/&gt;h     True&lt;br/&gt;Name: one, dtype: bool
&lt;/pre&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-shell&quot;&gt; &lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h4-u7F3Au5C11u6570u636Eu7684u8BA1u7B97&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在求和数据时，&lt;code&gt;NA&lt;/code&gt;将被视为&lt;code&gt;0&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果数据全部是&lt;code&gt;NA&lt;/code&gt;，那么结果将是&lt;code&gt;NA&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;实例1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].sum())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
        one       two     three&lt;br/&gt;a -1.191036  0.945107 -0.806292&lt;br/&gt;b       NaN       NaN       NaN&lt;br/&gt;c  0.127794 -1.812588 -0.466076&lt;br/&gt;d       NaN       NaN       NaN&lt;br/&gt;e  2.358568  0.559081  1.486490&lt;br/&gt;f -0.242589  0.574916 -0.831853&lt;br/&gt;g       NaN       NaN       NaN&lt;br/&gt;h -0.328030  1.815404 -1.706736&lt;p&gt;0.7247067964060545
&lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;示例2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

df &lt;/span&gt;= pd.DataFrame(index=[0,1,2,3,4,5],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].sum())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
   one  two&lt;br/&gt;0  NaN  NaN&lt;br/&gt;1  NaN  NaN&lt;br/&gt;2  NaN  NaN&lt;br/&gt;3  NaN  NaN&lt;br/&gt;4  NaN  NaN&lt;br/&gt;5  NaN  NaN&lt;p&gt;0
&lt;/p&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h2--&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Pandas&lt;/em&gt;提供了各种方法来清除缺失的值。&lt;strong&gt;&lt;code&gt;fillna()&lt;/code&gt;函数可以通过几种方法用非空数据“填充”&lt;code&gt;NA&lt;/code&gt;值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;h2--nan&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;以下程序显示如何用&lt;code&gt;0&lt;/code&gt;替换&lt;code&gt;NaN&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(3, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])&lt;br/&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NaN replaced with '0':&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;df.fillna(0)&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-shell&quot;&gt;        one       two     three
a -0.479425 -1.711840 -1.453384
b      &lt;span&gt; NaN &lt;/span&gt;    &lt;span&gt;  NaN       NaN&lt;/span&gt;
c -0.733606 -0.813315  0.476788&lt;br/&gt;NaN replaced with '0':
        one       two     three
a -0.479425 -1.711840 -1.453384
b  &lt;span&gt;0.000000  0.000000  0.000000&lt;/span&gt;
c -0.733606 -0.813315  0.476788
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;在这里填充零值; 当然，也可以填写任何其他的值。&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;h2--&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;很多时候，必须用一些具体的值取代一个通用的值。可以通过应用替换方法来实现这一点。&lt;/span&gt;&lt;span&gt;用标量值替换&lt;code&gt;NA&lt;/code&gt;是&lt;code&gt;fillna()&lt;/code&gt;函数的等效行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd

df &lt;/span&gt;= pd.DataFrame({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[10,20,30,40,50,2000],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[1000,0,30,40,50,60&lt;span&gt;]})

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df.replace({1000:10,2000:60}))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
    one   two&lt;br/&gt;0    10  &lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;1    20     0&lt;br/&gt;2    30    30&lt;br/&gt;3    40    40&lt;br/&gt;4    50    50&lt;br/&gt;5  &lt;span&gt;2000&lt;/span&gt;    60&lt;p&gt;one  two&lt;br/&gt;0   10   &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;1   20    0&lt;br/&gt;2   30   30&lt;br/&gt;3   40   40&lt;br/&gt;4   50   50&lt;br/&gt;5  &lt;span&gt; 60&lt;/span&gt;   60
&lt;/p&gt;&lt;/pre&gt;

&lt;h4 id=&quot;h2--na-&quot;&gt;&lt;span/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用重构索引章节讨论的填充概念，来填补缺失的值。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;动作&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;pad/fill&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;填充方法向前&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;code&gt;bfill/backfill&lt;/code&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;填充方法向后&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;示例1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df.fillna(&lt;span&gt;&lt;strong&gt;method='pad'&lt;/strong&gt;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
        one       two     three&lt;br/&gt;a -0.023243  1.671621 -1.687063&lt;br/&gt;b       NaN       NaN       NaN&lt;br/&gt;c -0.933355  0.609602 -0.620189&lt;br/&gt;d       NaN       NaN       NaN&lt;br/&gt;e  0.151455 -1.324563 -0.598897&lt;br/&gt;f  0.605670 -0.924828 -1.050643&lt;br/&gt;g       NaN       NaN       NaN&lt;br/&gt;h  0.892414 -0.137194 -1.101791&lt;p&gt;one       two     three&lt;br/&gt;a -0.023243  1.671621 -1.687063&lt;br/&gt;b -0.023243  1.671621 -1.687063&lt;br/&gt;c -0.933355  0.609602 -0.620189&lt;br/&gt;d -0.933355  0.609602 -0.620189&lt;br/&gt;e  0.151455 -1.324563 -0.598897&lt;br/&gt;f  0.605670 -0.924828 -1.050643&lt;br/&gt;g  0.605670 -0.924828 -1.050643&lt;br/&gt;h  0.892414 -0.137194 -1.101791
&lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;示例2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df.fillna(&lt;strong&gt;&lt;span&gt;method='backfill'&lt;/span&gt;&lt;/strong&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;code class=&quot; language-shell&quot;&gt;        one       two     three
a  2.278454  1.550483 -2.103731
b -0.779530  0.408493  1.247796
c -0.779530  0.408493  1.247796
d  0.262713 -1.073215  0.129808
e  0.262713 -1.073215  0.129808
f -0.600729  1.310515 -0.877586
g  0.395212  0.219146 -0.175024
h  0.395212  0.219146 -0.175024
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;h2-u4E22u5931u7F3Au5C11u7684u503C&quot;&gt;&lt;span&gt;四、&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;code&gt;dropna&lt;/code&gt;函数和&lt;code&gt;axis&lt;/code&gt;参数。&lt;strong&gt; 默认情况下，&lt;code&gt;axis = 0&lt;/code&gt;，即在行上应用，这意味着如果行内的任何值是&lt;code&gt;NA&lt;/code&gt;，那么整个行被排除。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df.dropna())
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;language-python code-toolbar&quot;&gt;
&lt;span&gt;输出结果 ：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;code class=&quot; language-shell&quot;&gt;        one       two     three
a -0.719623  0.028103 -1.093178
c  0.040312  1.729596  0.451805
e -1.029418  1.920933  1.289485
f  1.217967  1.368064  0.527406
h  0.667855  0.147989 -1.035978
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;示例2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

df &lt;/span&gt;= pd.DataFrame(np.random.randn(5, 3), index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

df &lt;/span&gt;= df.reindex([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (df.dropna(&lt;strong&gt;&lt;span&gt;axis=1&lt;/span&gt;&lt;/strong&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;language-python code-toolbar&quot;&gt;
&lt;span&gt;输出结果：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;language-shell code-toolbar&quot;&gt;
&lt;code class=&quot; language-shell&quot;&gt;&lt;strong&gt;Empty DataFrame&lt;/strong&gt;
Columns: []
Index: [a, b, c, d, e, f, g, h]
&lt;/code&gt;
&lt;/pre&gt;


</description>
<pubDate>Sun, 03 Nov 2019 23:50:00 +0000</pubDate>
<dc:creator>PythonGirl</dc:creator>
<og:description>数据丢失(缺失)在现实生活中总是一个问题。 机器学习和数据挖掘等领域由于数据缺失导致的数据质量差，在模型预测的准确性上面临着严重的问题。 在这些领域，缺失值处理是使模型更加准确和有效的重点。 使用重构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Summer-skr--blog/p/11705887.html</dc:identifier>
</item>
<item>
<title>你编写的Java代码是咋跑起来的？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11790091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11790091.html</guid>
<description>&lt;p&gt;如果你是一名 Java 开发人员，你肯定指定 Java 代码有很多种不同的运行方式。比如说可以在开发工具（IDEA、Eclipse等）中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至可以在网页（比如各种 OJ）中运行。当然，这些执行方式都离不开 JRE（Java 运行时环境）。&lt;/p&gt;
&lt;p&gt;JRE 包含运行 Java 程序的必需组件，包括 JVM（Java 虚拟机）以及 Java 核心类库等。Java 程序员经常接触到的 JDK（Java 开发工具包）同样包含了 JRE，并且还附带了一系列开发、诊断工具。&lt;/p&gt;
&lt;p&gt;本篇文章主要针对以下两个问题和大家一起探讨：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么需要 JVM？&lt;/li&gt;
&lt;li&gt;JVM 是怎样运行 Java 代码的呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java 的一个非常重要的特点就是与平台的无关性，而使用 JVM 是实现这一特点的关键。Java 作为一门高级程序语言，语法复杂，抽象程度高。因此，直接在硬件上运行这种复杂的程序并不现实。所以在运行 Java 程序之前，我们需要对其进行转换。&lt;/p&gt;
&lt;p&gt;设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列（因为 Java 字节码指令的操作码（opcode）被固定为一个字节，故又称 Java 字节码）。&lt;/p&gt;
&lt;p&gt;JVM 一般是在各个现有平台（如 Windows、Linux）上提供软件实现，这样可以使一旦一个程序被转换成 Java 字节码，那么便可以在不同平台上的虚拟机实现里运行（一次编写，到处运行）。&lt;/p&gt;
&lt;p&gt;JVM 另外一个好处是带有托管环境（Managed Runtime），托管环境能够代替处理一些代码中冗长而且容易出错的部分，其中包括自动内存管理与垃圾回收（GC）。&lt;/p&gt;
&lt;p&gt;另外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。&lt;/p&gt;

&lt;p&gt;JVM 具体是怎么运行 Java 字节码的呢？下面我们一起来看一下：&lt;/p&gt;
&lt;p&gt;从 JVM 来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 JVM 中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，JVM 会执行方法区内的代码。&lt;/p&gt;
&lt;p&gt;JVM 会在内存中划分出堆和栈来存储运行时数据，JVM 会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191104005135092-2091672522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在运行过程中，每当调用进入一个 Java 方法，JVM 会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。栈帧的大小是提前计算好的，而且 JVM 不要求栈帧在内存空间里连续分布。&lt;/p&gt;
&lt;p&gt;当退出当前执行的方法时，不管是正常返回还是异常返回，JVM 均会弹出当前线程的当前栈帧，并将之舍弃。&lt;/p&gt;
&lt;p&gt;从硬件视角来看，Java 字节码无法直接执行。因此，JVM 需要将字节码翻译成机器码。&lt;/p&gt;
&lt;p&gt;在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行（interpreter），即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191104005135823-2117618482.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191104005136288-1934290410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个 Java 代码执行过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 javac 把 .java 源文件编译为字节码（文件后缀名为 .class）&lt;/li&gt;
&lt;li&gt;字节码经过 JIT 环境变量进行判断，是否属于热点代码（多次调用的方法或循环体）&lt;/li&gt;
&lt;li&gt;热点代码使用 JIT 编译为可执行的机器码&lt;/li&gt;
&lt;li&gt;非热点代码使用解释器解释执行所有字节码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中，在运行过程中会被即时编译的热点代码有两类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;被多次调用的方法&lt;/li&gt;
&lt;li&gt;被多次执行的循环体&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;针对第一类，编译器会将整个方法作为编译对象，这也是标准的 JIT 编译方式。对于第二类是由循环体出发的，但是编译器依然会以整个方法作为编译对象，因为发生在方法执行过程中，称为栈上替换。&lt;/p&gt;
&lt;p&gt;HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。&lt;/p&gt;
&lt;p&gt;即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。&lt;/p&gt;
&lt;p&gt;对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。&lt;/p&gt;
&lt;p&gt;为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2。之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C1 （Client 编译器）面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。&lt;/li&gt;
&lt;li&gt;C2 （Server 编译器）面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。&lt;/p&gt;
&lt;p&gt;为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。&lt;/p&gt;
&lt;p&gt;在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。&lt;/p&gt;
&lt;p&gt;其中判断一段代码是否为热点代码，是不是需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection），探测算法有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于采样的热点探测（Sample Based Hot Spot Detection）：虚拟机会周期的对各个线程栈顶进行检查，如果某些方法经常出现在栈顶，这个方法就是热点方法。优点是实现简单、高效，很容易获取方法调用关系。缺点是很难确认方法的 reduce，容易受到线程阻塞或其他外因扰乱。&lt;/li&gt;
&lt;li&gt;基于计数器的热点探测（Counter Based Hot Spot Detection）：为每个方法（甚至是代码块）建立计数器，执行次数超过阈值就认为是热点方法。优点是统计结果精确严谨。缺点是实现麻烦，不能直接获取方法的调用关系。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;HotSpot 使用的是第二种-基于计数器的热点探测，并且有两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。&lt;/p&gt;

&lt;p&gt;这篇文章主要介绍了为什么需要 JVM 以及 JVM 是怎样运行 Java 代码的。&lt;/p&gt;
&lt;p&gt;为什么需要 JVM：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供了可移植性。一次编译，到处执行。&lt;/li&gt;
&lt;li&gt;提供了代码托管的环境，代替处理部分冗长而且容易出错的部分。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;JVM 将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 JVM 中运行。&lt;/p&gt;
&lt;p&gt;为了提高运行效率，HotSpot 虚拟机采用的是一种混合执行的策略，会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。&lt;/p&gt;
&lt;p&gt;HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。&lt;/p&gt;
&lt;p&gt;判断热点代码的探测算法包括基于采样和基于计数器两种，HotSpot 采用基于计数器的热点探测，计数器又分为方法调用计数器和回边计数器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191104005137835-1384037167.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Nov 2019 16:52:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>如果你是一名 Java 开发人员，你肯定指定 Java 代码有很多种不同的运行方式。比如说可以在开发工具（IDEA、Eclipse等）中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11790091.html</dc:identifier>
</item>
<item>
<title>如何让多个不同类型的后端网站用一个nginx进行反向代理实际场景分析 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/11790007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/11790007.html</guid>
<description>
&lt;p&gt;        前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合，断断续续一个月迁移完&lt;/p&gt;
&lt;p&gt;成大概优化掉了1/3的机器，完成之后遇到了一些问题，比如曾今零零散散部署在生产上一些可视化UI：apollo，kibana，grafana,jenkins 等等要么采用80端口，要&lt;/p&gt;
&lt;p&gt;么对公开放了其他端口，为了安全，现在不再开放非80之外的公网端口，由于机器少了，80端口不够，这些可视化UI不再能直接访问到了。所以需另寻其他出路。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一：用nginx做反向代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      为了解决这两个问题，自然第一反应想到的就是使用反向代理，我的理想构思下应该是下图这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230057336-52782006.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     既用户所有的请求都经过nginx，让nginx来判断当前url需要跳转到哪一个后端代理上，比较好的策略应该是让nginx来判断当前的host是什么来决定跳转到后端&lt;/p&gt;
&lt;p&gt;的哪一个webserver上，比如a.mip.com 就跳转到apollo，j.mip.com 就跳转到jenkins. 以此类推，这样就可以完美解决了，是吧？ 在nginx中你完全可以使用rewrite&lt;/p&gt;
&lt;p&gt;模块下if指令来进行判断。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二：使用if指令&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      这里要提一下，nginx比较原始化，如果需使用第三方module，你还需要重新编译nginx，用起来很麻烦，所以这里干脆使用OpenResty，它扩展了nginx，并且&lt;/p&gt;
&lt;p&gt;集成了很多成熟的lua模块，自行下载最新的&lt;a href=&quot;http://openresty.org/en/download.html&quot; target=&quot;_blank&quot;&gt;1.15.8&lt;/a&gt;，安装方式和nginx一模一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103230705182-358199087.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;默认是安装到/usr/local/目录下，当你看到有一个openresty目录表示你安装成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost local]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
bin  etc  games  include  lib  lib64  libexec  &lt;span&gt;openresty&lt;/span&gt;  sbin  share  src
[root@localhost local]# &lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;
/usr/local
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来你可以使用 nginx  -v 来看一下openresty版本号啥的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost sbin]# &lt;span&gt;pwd&lt;/span&gt;
/usr/local/openresty/nginx/&lt;span&gt;sbin
[root@localhost sbin]# 
[root@localhost sbin]# .&lt;/span&gt;/nginx -&lt;span&gt;v
&lt;span&gt;nginx version: openresty&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/1.15.8.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了方便，我就直接使用nginx开启三个server：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;1&amp;gt;  192.168.23.129:80    　  nginx上开启的第一个网站，就是proxy了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;2&amp;gt;  192.168.23.129:8001      nginx上开启的第二个网站，模拟apollo。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;3&amp;gt;  192.168.23.129:8002      nginx上开启的第三个网站,模拟jenkins。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.  apollo的模拟：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server {
        listen       &lt;/span&gt;&lt;span&gt;8001&lt;/span&gt;&lt;span&gt;;
        server_name  somename  alias  another.alias;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
           &lt;span&gt; index  apollo.html;&lt;/span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    8001端口网站的默认页是apollo.html，这个apollo.html所在路径就是在nginx下的html目录，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost html]# &lt;span&gt;pwd&lt;/span&gt;
/usr/local/openresty/nginx/&lt;span&gt;html
[root@localhost html]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
50x.html  &lt;span&gt;apollo.html&lt;/span&gt;  index.html  jenkins.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2. jenkins的模拟&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server {
        listen       &lt;/span&gt;&lt;span&gt;8002&lt;/span&gt;&lt;span&gt;;
        server_name  somename  alias  another.alias;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
       &lt;span&gt;     index  jenkins.html;&lt;/span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      jenkins.html的文件所在路径如上所示哈。不再赘述。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. proxy的模拟&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  localhost;

        location &lt;/span&gt;/&lt;span&gt; {

           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.mip.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
               proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8001;&lt;/span&gt;
&lt;span&gt;           }

           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j.mip.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
               proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8002;&lt;/span&gt;
&lt;span&gt;           }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      可以看到，只需要使用rewrite模块下的if条件语句，通过$host系统变量判断当前的url中的host的值跳转到相应的网站。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. host映射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       好了，接下来只需要将a.mip.com 和 j.mip.com 映射到nginx的ip地址192.168.23.129即可。因为这些域名方便记忆而不是真实存在的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.129&lt;/span&gt;&lt;span&gt; a.mip.com
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.129&lt;/span&gt; j.mip.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103232409410-115862404.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. 启动nginx&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost sbin]# &lt;span&gt;./&lt;/span&gt;&lt;span&gt;&lt;span&gt;nginx&lt;/span&gt; 
[root@localhost sbin]# 
[root@localhost sbin]# 
[root@localhost sbin]# &lt;span&gt;netstat &lt;/span&gt;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&lt;span&gt;tlnp&lt;/span&gt;
Active Internet connections (only servers)
Proto Recv&lt;/span&gt;-Q Send-Q Local Address           Foreign Address         State       PID/&lt;span&gt;Program name    
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8001&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;3802&lt;/span&gt;/&lt;span&gt;nginx: master  
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8002&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;3802&lt;/span&gt;/&lt;span&gt;nginx: master  
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;3802&lt;/span&gt;/&lt;span&gt;nginx: master  
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;              &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1172&lt;/span&gt;/&lt;span&gt;sshd           
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;1724&lt;/span&gt;/&lt;span&gt;master         
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; :::&lt;span&gt;22&lt;/span&gt;                   :::*                    LISTEN      &lt;span&gt;1172&lt;/span&gt;/&lt;span&gt;sshd           
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;                  :::*                    LISTEN      &lt;span&gt;1724&lt;/span&gt;/master  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    通过上图可以看到，80，8001，8002 端口都已经开启了，接下来大家可以到浏览器去验证一下了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201911/214741-20191103232858709-1676878325.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;          可以看到这个问题已经很完美的解决了，好了，这就是本篇和大家聊到的实际场景中遇到的一个问题，希望本篇对你有帮助，以下是全部的nginx.conf。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a71479db-6fcd-4e8c-b44d-d3f8c10a4658')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_a71479db-6fcd-4e8c-b44d-d3f8c10a4658&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a71479db-6fcd-4e8c-b44d-d3f8c10a4658&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a71479db-6fcd-4e8c-b44d-d3f8c10a4658',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a71479db-6fcd-4e8c-b44d-d3f8c10a4658&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#user  nobody;
worker_processes  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

#error_log  logs&lt;/span&gt;/&lt;span&gt;error.log;
#error_log  logs&lt;/span&gt;/&lt;span&gt;error.log  notice;
#error_log  logs&lt;/span&gt;/error.log  &lt;span&gt;info&lt;/span&gt;&lt;span&gt;;

#pid        logs&lt;/span&gt;/&lt;span&gt;nginx.pid;


events {
    worker_connections  &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
}


http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;

    log_format  main  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$host ----&amp;gt; $remote_addr - $remote_user [$time_local] &quot;$request&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                      &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                      &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    access_log  logs&lt;/span&gt;/&lt;span&gt;access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;

    #&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;  on;

    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  localhost;

        #charset koi8&lt;/span&gt;-&lt;span&gt;r;

        #access_log  logs&lt;/span&gt;/&lt;span&gt;host.access.log  main;

    # location &lt;/span&gt;= /&lt;span&gt;get {
        #     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc
        #     redis2_query get $key;
        #     redis2_pass &lt;/span&gt;&lt;span&gt;10.105&lt;/span&gt;.&lt;span&gt;13.174&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;;
        # }

        location &lt;/span&gt;/&lt;span&gt; {
           
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.mip.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
               proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8001;&lt;/span&gt;
&lt;span&gt;           }

           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j.mip.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
               proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8002;&lt;/span&gt;
&lt;span&gt;           }

           root   html;
           index  index.html index.htm;   
           
        }

        #error_page  &lt;/span&gt;&lt;span&gt;404&lt;/span&gt;              /&lt;span&gt;404&lt;/span&gt;&lt;span&gt;.html;

        # redirect server error pages to the static page &lt;/span&gt;/&lt;span&gt;50x.html
        #
        error_page   &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;
        location &lt;/span&gt;= /&lt;span&gt;50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
        #
        #location &lt;/span&gt;~&lt;span&gt; \.php$ {
        #    proxy_pass   http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1;&lt;/span&gt;
&lt;span&gt;        #}

        # pass the PHP scripts to FastCGI server listening on &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;
        #
        #location &lt;/span&gt;~&lt;span&gt; \.php$ {
        #    root           html;
        #    fastcgi_pass   &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  &lt;/span&gt;/&lt;span&gt;scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; Apache&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s document root&lt;/span&gt;
        # concurs with nginx&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s one&lt;/span&gt;
&lt;span&gt;        #
        #location &lt;/span&gt;~ /&lt;span&gt;\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP&lt;/span&gt;-, name-, and port-&lt;span&gt;based configuration
    #
    server {
        listen       &lt;/span&gt;&lt;span&gt;8001&lt;/span&gt;&lt;span&gt;;
        server_name  somename  alias  another.alias;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
            index  apollo.html;
        }
    }

    server {
        listen       &lt;/span&gt;&lt;span&gt;8002&lt;/span&gt;&lt;span&gt;;
        server_name  somename  alias  another.alias;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
            index  jenkins.html;
        }
    }

    # HTTPS server
    #
    #server {
    #    listen       &lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt; ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:&lt;/span&gt;!aNULL:!&lt;span&gt;MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location &lt;/span&gt;/&lt;span&gt; {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 03 Nov 2019 16:00:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>前段时间公司根据要求需要将聚石塔上服务器从杭州整体迁移到张家口，刚好趁这次机会将这些乱七八糟的服务器做一次梳理和整合，断断续续一个月迁移完 成大概优化掉了1/3的机器，完成之后遇到了一些问题，比如曾今</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/11790007.html</dc:identifier>
</item>
<item>
<title>Flask源码分析二：路由内部实现原理 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/11789983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/11789983.html</guid>
<description>&lt;p&gt;Flask是目前为止我最喜欢的一个Python Web框架了，为了更好的掌握其内部实现机制，这两天准备学习下Flask的源码，将由浅入深跟大家分享下，其中Flask版本为1.1.1。&lt;/p&gt;
&lt;p&gt;上次了解了Flask服务的启动流程，今天我们来看下路由的内部实现机理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flask系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/10125532.html&quot;&gt;Flask开发初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/11717347.html&quot;&gt;Flask源码分析一：服务启动&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;关于路由&quot;&gt;关于路由&lt;/h2&gt;
&lt;p&gt;所谓路由，就是处理请求URL和函数之间关系的程序。&lt;/p&gt;
&lt;p&gt;Flask中也是对URL规则进行统一管理的，创建URL规则有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用@app.route修饰器，并传入URL规则作为参数，将函数绑定到URL，这个过程便将一个函数注册为路由，这个函数则被称为视图函数。&lt;/li&gt;
&lt;li&gt;使用app.add_url_rule()。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在开始阅读源码之前，我是有这几点疑问的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;注册路由的过程是什么？&lt;/li&gt;
&lt;li&gt;Flask内部是如何进行URL规则管理的？&lt;/li&gt;
&lt;li&gt;一个视图函数绑定多个URL内部是如何实现的？&lt;/li&gt;
&lt;li&gt;动态URL是如何进行视图函数匹配的呢？&lt;/li&gt;
&lt;li&gt;匹配路由的过程是怎样的呢？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;那就让我们带着这几点疑问一起去学习源码吧！&lt;/p&gt;

&lt;h3 id=&quot;注册路由&quot;&gt;注册路由&lt;/h3&gt;
&lt;p&gt;首先，route()装饰器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def route(self, rule, **options):       

        def decorator(f):
            endpoint = options.pop(&quot;endpoint&quot;, None)
            self.add_url_rule(rule, endpoint, f, **options)
            return f

        return decorator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;route()有两个参数，rule表示url规则。该函数对参数进行处理之后，调用方法add_url_role()，这里也就验证了两种注册路由的方法等价。我们来看下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def add_url_rule(
        self,
        rule,
        endpoint=None,
        view_func=None,
        provide_automatic_options=None,
        **options
    ):
        
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)
        options[&quot;endpoint&quot;] = endpoint
        methods = options.pop(&quot;methods&quot;, None)

        # if the methods are not given and the view_func object knows its
        # methods we can use that instead.  If neither exists, we go with
        # a tuple of only ``GET`` as default.
        if methods is None:
            methods = getattr(view_func, &quot;methods&quot;, None) or (&quot;GET&quot;,)
        if isinstance(methods, string_types):
            raise TypeError(
                &quot;Allowed methods have to be iterables of strings, &quot;
                'for example: @app.route(..., methods=[&quot;POST&quot;])'
            )
        methods = set(item.upper() for item in methods)

        # Methods that should always be added
        required_methods = set(getattr(view_func, &quot;required_methods&quot;, ()))

        # starting with Flask 0.8 the view_func object can disable and
        # force-enable the automatic options handling.
        if provide_automatic_options is None:
            provide_automatic_options = getattr(
                view_func, &quot;provide_automatic_options&quot;, None
            )

        if provide_automatic_options is None:
            if &quot;OPTIONS&quot; not in methods:
                provide_automatic_options = True
                required_methods.add(&quot;OPTIONS&quot;)
            else:
                provide_automatic_options = False

        # Add the required methods now.
        methods |= required_methods

        rule = self.url_rule_class(rule, methods=methods, **options)
        rule.provide_automatic_options = provide_automatic_options

        self.url_map.add(rule)
        if view_func is not None:
            old_func = self.view_functions.get(endpoint)
            if old_func is not None and old_func != view_func:
                raise AssertionError(
                    &quot;View function mapping is overwriting an &quot;
                    &quot;existing endpoint function: %s&quot; % endpoint
                )
            self.view_functions[endpoint] = view_func
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;入参包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;rule: url规则&lt;/li&gt;
&lt;li&gt;endpoint : 要注册规则的endpoint，默认是视图函数的名儿&lt;/li&gt;
&lt;li&gt;view_func: 视图函数&lt;/li&gt;
&lt;li&gt;provide_automatic_options: 请求方法是否添加OPTIONS方法的一个标志&lt;/li&gt;
&lt;li&gt;options: 关于请求处理的一些方法等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到，add_url_rule()首先进行参数处理，包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;endpoint默认为视图函数的name&lt;/li&gt;
&lt;li&gt;url请求的方法默认为GET&lt;/li&gt;
&lt;li&gt;若请求方法中没有设置OPTIONS，添加该方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在处理完所有的参数后，将该URL规则写入url_map（创建好Rule对象，并添加到Map对象中），将视图函数写入view_function字典中。&lt;/p&gt;
&lt;p&gt;其中，url_map 是&lt;code&gt;werkzeug.routing:Map&lt;/code&gt; 类的对象，rule是 &lt;code&gt;werkzeug.routing:Rule&lt;/code&gt; 类的对象，也就是&lt;strong&gt;Flask的核心路由逻辑是在werkzeug中实现的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;werkzeug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;werkzeug是使用Python编写的一个WSGI工具集，werkzeug.routing模块主要用于url解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rule类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Rule类继承自RuleFactory类，一个Rule实例代表一个URL模式，一个WSGI应用会处理很多个不同的URL模式，与此同时产生很多个Rule实例，这些实例将作为参数传给Map类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Map类构造的实例存储所有的url规则，解析并匹配请求对应的视图函数。&lt;/p&gt;
&lt;h3 id=&quot;路由匹配&quot;&gt;路由匹配&lt;/h3&gt;
&lt;p&gt;在应用初始化的过程中，会注册所有的路由规则，可以调用（app.url_map）查看，当服务收到URL请求时，就需要进行路由匹配，以找到对应的视图函数，对应的流程和原理是什么呢？&lt;/p&gt;
&lt;p&gt;当用户请求进入Flask应用时，调用Flask类的wsgi_app方法:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wsgi_app(self, environ, start_response):
    
    ctx = self.request_context(environ)
    error = None
    try:
        try:
            ctx.push()
            response = self.full_dispatch_request()
        except Exception as e:
            error = e
            response = self.handle_exception(e)
        except:  # noqa: B001
            error = sys.exc_info()[1]
            raise
        return response(environ, start_response)
    finally:
        if self.should_ignore_error(error):
            error = None
        ctx.auto_pop(error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数的处理过程包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建RequestContext对象，在对象初始化的过程中调用app.create_url_adapter()方法，将请求参数environ传给Map对象创建MapAdapter对象，保存在url_adapter字段中&lt;/li&gt;
&lt;li&gt;将RequestContext对象推入_request_ctx_stack栈中&lt;/li&gt;
&lt;li&gt;通过RequestContext的match_request方法，调用MapAdapter对象的match方法找到匹配的Rule并解析出参数，保存在request的url_rule和view_args字段中&lt;/li&gt;
&lt;li&gt;调用full_dispatch_request()&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来我们看下full_dispatch_request方法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def full_dispatch_request(self):
    self.try_trigger_before_first_request_functions()
    try:
        request_started.send(self)
        rv = self.preprocess_request()
        if rv is None:
            rv = self.dispatch_request()
    except Exception as e:
        rv = self.handle_user_exception(e)
    return self.finalize_request(rv)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，重点执行dispatch_request()：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def dispatch_request(self):
    req = _request_ctx_stack.top.request
    if req.routing_exception is not None:
        self.raise_routing_exception(req)
    rule = req.url_rule
    # if we provide automatic options for this URL and the
    # request came with the OPTIONS method, reply automatically
    if (
        getattr(rule, &quot;provide_automatic_options&quot;, False)
        and req.method == &quot;OPTIONS&quot;
    ):
        return self.make_default_options_response()
    # otherwise dispatch to the handler for that endpoint
    return self.view_functions[rule.endpoint](**req.view_args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理的过程是：获取请求对象的request，找到对应的endpoint，继而从view_functions中找到对应的视图函数，传递请求参数，视图函数处理内部逻辑并返回，完成一次请求分发。&lt;/p&gt;
&lt;p&gt;以上，就是Flask路由的内部实现原理。&lt;/p&gt;
</description>
<pubDate>Sun, 03 Nov 2019 15:55:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文介绍Flask路由的内部实现原理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/11789983.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第44期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11789217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11789217.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;Elmish.WPF教程&quot; &quot;介绍Orleans 3.0&quot; &quot;GC配置历史&quot; &quot;介绍ONNX运行时1.0&quot; &quot;介绍微软Q&amp;A(预览)&quot; &quot;使用App中心持续布署与监控你的UWP，WPF与Windows Forms应用&quot; 视频及幻灯片 &quot;介绍F &quot; &quot;.NET设计审查：ARM Intrinsi</description>
<pubDate>Sun, 03 Nov 2019 15:35:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'Elmish.WPF教程' '介绍Orleans 3.0' 'GC配置历史' '介绍ONNX运行时1.0' '介绍微软Q&amp;A(预览)' '使用App中心持续布署与监控你的UWP，WPF与Win</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11789217.html</dc:identifier>
</item>
<item>
<title>被低估的.NET(下)-2019 中国.NET 开发者峰会 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/2019-dot-net-conf.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/2019-dot-net-conf.html</guid>
<description>&lt;p&gt;Time flies!不知不觉距离上篇《&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/Microsoft-MonkeyFest2018-GuangZhou.html&quot;&gt;被低估的.net(上) - 微软MonkeyFest 2018广州分享会活动回顾&lt;/a&gt;》和中篇《&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/dotnet-is-good.html&quot;&gt;被低估的.net(中) - 广州.net俱乐部2019年纲领&lt;/a&gt;》己经过去一年了。在这一年里发生了很多事情：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/summary-of-dec-8-2018-event.html&quot;&gt;2018年12月8日广州.NET俱乐部复活后第一次活动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/work-together.html&quot;&gt;2019年1月19日苏州微软技术俱乐部成立&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html&quot;&gt;2019年3月10日东莞.NET首次线下活动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/10777686.html&quot;&gt;2019年4月21日长沙.NET社区成立&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;此处还有更多, 我就不一一搜罗了.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里有&lt;a href=&quot;https://dotnet-china.com&quot;&gt;全国总计20个城市的.NET俱乐部列表&lt;/a&gt;。全国各个城市.NET俱乐部纷纷成立和复活都证明了.NET被低估。&lt;/p&gt;

&lt;p&gt;今年上半年我在欧洲生活，参与欧洲多个国家和城市的.NET俱乐部活动，发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/Tech-Club-Building-Belgrade-office-365-2019.html&quot;&gt;Serbia的Belgrade。人口只有165万，却有两个.NET俱乐部(.NET meetup和C# Meetup)。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/Muchen-dot-net-club-vs-2019-launch.html&quot;&gt;德国慕尼黑。人口只有130万，却有两个.NET俱乐部&lt;/a&gt;(.NET Meetup和Xamarin Meetup)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;国内外的这个差距证明了在中国，.NET是被低估的。&lt;/p&gt;

&lt;p&gt;在大家最关心的找工作方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;广州.NET俱乐部和上海.NET俱乐部一起协作帮助原来在广州工作的.NET程序员到上海工作。&lt;/li&gt;
&lt;li&gt;把多名在广州深圳珠三角地区想回老家工作生活的湖南籍.NET程序员拉进长沙.NET俱乐部。&lt;/li&gt;
&lt;li&gt;帮助广发银行佛山分行招聘到两名.NET程序员。&lt;/li&gt;
&lt;li&gt;帮助微软招聘程序员。在此推荐&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55680019&quot; target=&quot;_blank&quot;&gt;韩总，他在今年里成功内推了17 位候选人进入微软工作&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;特别高兴的是，我和8名广州.NET俱乐部成员成为同事。我们将继续招聘.NET和Python开发人员，要求五年以上工作经验，英语可以在日常工作中沟通，有兴趣的朋友可以发份英文简历给我(十分抱歉，目前不接受中文简历)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;星星之火可以燎原，在过去一年里，从广州.NET俱乐部的星星之火开始，全国各个城市.NET俱乐部迅猛发展最终得以燎原。现在我们集聚全国.NET社区的力量自发组织了&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/11651919.html&quot;&gt;2019 中国.NET 开发者峰会&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2019.11.9 在上海筹办的 &lt;a href=&quot;https://www.cnblogs.com/shanyou/p/11651919.html&quot;&gt;中国.NET 开发者峰会&lt;/a&gt; 也是我们社区进行自我刷新的一个表现，这次大会完全由社区筹办，得到社区的积极支持，各项筹备进展比预想的顺利，大会议题很丰富，还有很多议题没有机会分享。 这里也非常感谢微软Azure 对我们活动的支持以及社区里各位对活动的支持，有很多同学都是自掏腰包买票来支持大会，他们从远离上海的西南、西北一起来上海聚一聚，我们非常期待这次大会的成功举办。&lt;/p&gt;
&lt;p&gt;大会的日期是：2019年11月9日 09:00-18：00&lt;/p&gt;
&lt;p&gt;大会地址：（上海杨浦）佳木斯路777号上海中谷小南国花园酒店&lt;/p&gt;
&lt;p&gt;门票优惠：购买团体票（大于10张）享受整单8折优惠，请通过邮箱联系主办方 dotnet@dotnetconf.cn&lt;/p&gt;
&lt;p&gt;报名方式&lt;/p&gt;
&lt;p&gt;活动行：&lt;a href=&quot;https://www.huodongxing.com/event/4514005355700&quot;&gt;https://www.huodongxing.com/event/4514005355700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;百格活动：&lt;a href=&quot;https://www.bagevent.com/event/6069892&quot;&gt;https://www.bagevent.com/event/6069892&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Nov 2019 15:14:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>Time flies!不知不觉距离上篇《被低估的.net(上) - 微软MonkeyFest 2018广州分享会活动回顾》和中篇《被低估的.net(中) - 广州.net俱乐部2019年纲领》己经过去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adalovelacer/p/2019-dot-net-conf.html</dc:identifier>
</item>
</channel>
</rss>