<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构之队列and栈总结分析 - 猴子哥</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/XYH_dataStructureTest_queue_stack.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/XYH_dataStructureTest_queue_stack.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;数据结构中队列和栈也是常见的两个数据结构，队列和栈在实际使用场景上也是相辅相成的，下面简单总结一下，如有不对之处，多多指点交流，谢谢。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、队列简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;队列顾名思义就是排队的意思，根据我们的实际生活不难理解，排队就是有先后顺序，先到先得，其实在程序数据结构中的队列其效果也是一样，及先进先出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   队列大概有如下一些特性：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　1、操作灵活，在初始化时不需要指定其长度，其长度自动增加（默认长度为32）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;注：在实际使用中，如果事先能够预估其长度，那么在初始化时指定长度，可以提高效率&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　    　　2、泛型的引入，队列在定义时可以指定数据类型避免装箱拆箱操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　3、存储数据满足先进先出原则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　     &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;strong&gt;c#中有关队列的几个常用方法：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Count：Count属性返回队列中元素个数。&lt;/li&gt;
&lt;li&gt;Enqueue：Enqueue()方法在队列一端添加一个元素。&lt;/li&gt;
&lt;li&gt;Dequeue：Dequeue()方法在队列的头部读取和删除元素。如果在调用Dequeue()方法时，队列中不再有元素，就抛出一个InvalidOperationException类型的异常。&lt;/li&gt;
&lt;li&gt;Peek：Peek()方法从队列的头部读取一个元素，但不删除它。&lt;/li&gt;
&lt;li&gt;TrimExcess：TrimExcess()方法重新设置队列的容量。Dequeue()方法从队列中删除元素，但它不会重新设置队列的容量。要从队列的头部去除空元素，应使用TrimExcess()方法。&lt;/li&gt;
&lt;li&gt;Clear：Clear()方法从队列中移除所有的元素。&lt;/li&gt;
&lt;li&gt;ToArray：ToArray()复制队列到一个新的数组中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;下面通过队列来实例模拟消息队列的实现流程：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; dataStructureQueueTest
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通过Queue来模拟消息队列的实现&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            QueueTest queueTest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueueTest();

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入你操作的类型：1:代表生成一条消息，2：代表消费一条消息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; type =&lt;span&gt; Console.ReadLine();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入具体消息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; inforValue =&lt;span&gt; Console.ReadLine();
                    queueTest.InformationProducer(inforValue);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 在消费消息的时候，模拟一下，消费成功与消费失败下次继续消费的场景&lt;/span&gt;

                    &lt;span&gt;object&lt;/span&gt; inforValue =&lt;span&gt; queueTest.InformationConsumerGet();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inforValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前无可消息可消费&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取到的消息为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; inforValue);

                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入消息消费结果：1:成功消费消息，2：消息消费失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; consumerState =&lt;span&gt; Console.ReadLine();

                        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;// 备注：该操作方式线程不安全，在多线程不要直接使用&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (consumerState == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        {
                            queueTest.InformationConsumerDel();
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;操作有误，请重新选择&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 队列练习
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueTest
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义一个队列
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Queue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; Queue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成消息--入队列
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inforValue&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InformationProducer(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; inforValue)
        {
            queue.Enqueue(inforValue);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消费消息---出队列--只获取数据，不删除数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; InformationConsumerGet()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (queue.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue.Peek();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消费消息---出队列---获取数据的同时删除数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; InformationConsumerDel()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (queue.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue.Dequeue();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;strong&gt;三、栈简介&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;栈和队列在使用上很相似，只是栈的数据存储满足先进后出原则，栈有如下一些特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　1、操作灵活，在初始化时不需要指定其长度，其长度自动增加（默认长度为10）&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span&gt;&lt;strong&gt;注：在实际使用中，如果事先能够预估其长度，那么在初始化时指定长度，可以提高效率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　    　　2、泛型的引入，栈在定义时可以指定数据类型避免装箱拆箱操作&lt;/p&gt;
&lt;p&gt;　　　　　3、存储数据满足先进后出原则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　c#中有关栈的几个常用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Count：Count属性返回栈中的元素个数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Push：Push()方法在栈顶添加一个元素。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Pop：Pop()方法从栈顶删除一个元素，并返回该元素。如果栈是空的，就抛出一个InvalidOperationException类型的异常。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Peek：Peek()方法返回栈顶的元素，但不删除它。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Contains：Contains()方法确定某个元素是否在栈中，如果是，就返回true。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　　　&lt;span&gt;下面通过一个栈来模拟浏览器的回退前进操作的实现&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; dataStructureStackTest
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 通过栈来模拟浏览器回退前进操作
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/   1、定义两个栈，分别记录回退的地址集合，和前进地址集合
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/   2、在操作具体的回退或者前进操作时
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/      如果和前一次操作相同，那么就取出对应队列的一条数据存储到另外一个队列&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本练习模拟浏览器的回退前进操作：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 假设浏览器已浏览了20个网站记录&lt;/span&gt;
            StackTest stackTestBack = &lt;span&gt;new&lt;/span&gt; StackTest(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
            StackTest stackTestGo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StackTest(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
            {
                stackTestBack.PushStack(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网站&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToString());
            }

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 记录上一次操作&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; beforOpert = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入你操作的类型：1:回退，2：前进&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; type =&lt;span&gt; Console.ReadLine();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 出栈&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (beforOpert ==&lt;span&gt; type)
                    {
                        stackTestGo.PushStack(stackTestBack.GetAndDelStack());
                    }
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; wbeSit =&lt;span&gt; stackTestBack.GetStack();
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回退到页面：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; wbeSit);
                    beforOpert &lt;/span&gt;=&lt;span&gt; type;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 出栈&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (beforOpert ==&lt;span&gt; type)
                    {
                        stackTestBack.PushStack(stackTestGo.GetAndDelStack());
                    }
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; wbeSit =&lt;span&gt; stackTestGo.GetStack();

                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回退到页面：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; wbeSit);
                    beforOpert &lt;/span&gt;=&lt;span&gt; type;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入正确的操作方式！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 队列练习
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StackTest
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义一个栈
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Stack&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; stack;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;无参数构造函数，栈初始化为默认长度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StackTest()
        {
            stack &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;有参数构造函数，栈初始化为指定长度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;如果在定义队列时，如果知道需要存储的数据长度，那么最好预估一个长度，并初始化指定的长度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; StackTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; stackLen)
        {
            stack &lt;/span&gt;= stackLen &amp;gt; &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(stackLen) : &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 入栈
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inforValue&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PushStack(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; inforValue)
        {
            stack.Push(inforValue);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出栈（但不删除）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetStack()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stack.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.Peek();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出栈（并删除）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAndDelStack()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stack.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.Pop();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、使用场景总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;根据队列和栈的特点，下面简单总结一下队列和栈的一些实际使用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　队列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、异步记录日志，此处会涉及到单例模式的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、消息队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、业务排队，比如12306车票购买排队等候&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　4、其他符合先进先出原则的业务操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　栈：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、可回退的操作记录，比如：浏览器的回退操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、计算表达式匹配，比如：计算器表达式计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、其他符合先进后出原则的业务操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;附件：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这一些练习的代码，上传到github，有兴趣的可以看一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuyuanhong0902/dataStructureTest.git&quot; target=&quot;_blank&quot;&gt;https://github.com/xuyuanhong0902/dataStructureTest.git&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Nov 2019 16:49:00 +0000</pubDate>
<dc:creator>猴子哥</dc:creator>
<og:description>数据结构之队列、栈是很常见的数据结构，那么其使用场景是什么呢？以及其区别是什么，本文将通过简单的实例来分表模拟其实际使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/XYH_dataStructureTest_queue_stack.html</dc:identifier>
</item>
<item>
<title>快速搭建Jenkins集群 - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/11874717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/11874717.html</guid>
<description>&lt;h3 id=&quot;关于jenkins集群&quot;&gt;关于Jenkins集群&lt;/h3&gt;
&lt;p&gt;在Jenkins上同时执行多个任务时，单机性能可能达到瓶颈，使用Jenkins集群可以有效的解决此问题，让多台机器同时处理这些任务可以将压力分散，对单机版Jenkins的单点故障的隐患也有分散作用，今天就来实战快速搭建Jenkins集群，Jenkins版本是2.190.2；&lt;/p&gt;
&lt;h3 id=&quot;如何做到快速搭建集群&quot;&gt;如何做到快速搭建集群&lt;/h3&gt;
&lt;p&gt;通过Docker可以省去大部分准备工作，您只需在Linux电脑上安装docker，在辅以少量命令和操作即可完成集群搭建；&lt;/p&gt;
&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;p&gt;本次实战的环境一共要用三台电脑，它们的设置都是一样的，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.6.1810&lt;/li&gt;
&lt;li&gt;防火墙关闭&lt;/li&gt;
&lt;li&gt;docker：1.13.1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;三台电脑的信息如下：&lt;br/&gt;| 主机名 | IP地址 | 作用 |&lt;br/&gt;|--|--|--|&lt;br/&gt;| master | 192.168.133.131 | Jenkins集群的master节点，提供web服务 |&lt;br/&gt;| agent1 | 192.168.133.132 | Jenkins集群的一号工作接节点，标签是&lt;span&gt;maven&lt;/span&gt; |&lt;br/&gt;| agent2 | 192.168.133.133 | Jenkins集群的二号工作接节点，标签是&lt;span&gt;gradle&lt;/span&gt; |&lt;/p&gt;
&lt;p&gt;建议agent2节点的内存大于4G，因为下一篇的实战操作会用agent2编译构建spring-framework，对内存的需求略大；&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;后面的所有操作都是root账号；&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在每台电脑上创建文件夹&lt;span&gt;/usr/local/jenkins&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建jenkins的master&quot;&gt;创建Jenkins的master&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;登录master机器，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker run \
  -u root \
  -idt \
  --name master \
  -p 8080:8080 \
  -p 50000:50000 \
  -v /usr/local/jenkins:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  jenkinsci/blueocean:1.19.0&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;执行&lt;span&gt;docker logs master&lt;/span&gt;，会在控制台显示jenkins的登录秘钥，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234830694-263114519.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;浏览器输入地址：&lt;a href=&quot;http://192.168.133.131:8080&quot; class=&quot;uri&quot;&gt;http://192.168.133.131:8080&lt;/a&gt; ，显示Jenkins登录页面，如下图所示，在红框位置输入刚才复制的登录秘钥即可登录：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234836620-2088234234.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;选择&lt;span&gt;安装推荐的插件&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234841748-1281955888.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;静候插件在线安装完成：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234850128-373599307.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;接下来是创建管理员和使用实例url的操作，这里就不多说了，您按实际情况自行斟酌；&lt;/p&gt;&lt;p&gt;至此，Jenkins的master已经搭建好，接下来将agent1和agent2作为工作节点加入集群；&lt;/p&gt;
&lt;h3 id=&quot;加入agent1&quot;&gt;加入agent1&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;在Jenkins网页上新增节点，操作如下图，先进入节点管理页面：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234854410-820960052.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，新增一个节点，名为&lt;span&gt;agent1&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234855307-210588708.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来的节点详情信息如下图，注意四个红框中的内容要和图中保持一致：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234858194-1730329862.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;保存成功后会显示机器列表，如下图，图标上的红叉表示机器不在线（此时agent1还没有接入），点击红框：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234858869-795192069.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图所示，红框中的命令就是agent1的启动命令，执行该命令的机器会以agent1的身份加入集群：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234902020-365398851.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;注意上图红框中的&lt;span&gt;agent.jar&lt;/span&gt;是个名为agent.jar的文件的下载链接，将此文件下载到agent1电脑的&lt;span&gt;/usr/local/jenkins&lt;/span&gt;目录下；&lt;/li&gt;
&lt;li&gt;ssh登录agent1电脑，执行以下命令，即可将agent1加入Jenkins集群：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker run \
  -u root \
  -idt \
  --name agent \
  -v /usr/local/jenkins:/usr/local/jenkins \
  bolingcavalry/openjdk-with-sshpass:8u232 \
  java -jar /usr/local/jenkins/agent.jar \
  -jnlpUrl http://192.168.133.131:8080/computer/agent1/slave-agent.jnlp \
  -secret 44c3e8d1531754b8655b53294bbde6dd99b3aaa91a250092d0d3425534ae1058 \
  -workDir &quot;/usr/local/jenkins&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述命令中的后半部分，即&lt;span&gt;java -jar ......&lt;/span&gt;就是前面图片红框中的agent1启动命令，唯一要改变的是将&lt;span&gt;agent.jar&lt;/span&gt;改成绝对路径&lt;span&gt;/usr/local/jenkins/agent.jar&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上述命令的镜像是&lt;span&gt;bolingcavalry/openjdk-with-sshpass:8u232&lt;/span&gt;，其Dockerfile内容如下，可见非常简单，就是OpenJDK镜像里面安装了sshpass，这样的容器可以在执行ssh命令时带上远程机器的密码，而不用等待用户输入密码，这样便于shell脚本执行ssh命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;FROM openjdk:8u232

ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update &amp;amp;&amp;amp; apt-get install --assume-yes sshpass&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;0.9377990430622&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;去Jenkins的网页上查看节点列表，如下图，可见agent1已经成功加入：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234904037-216273294.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;加入agent2&quot;&gt;加入agent2&lt;/h3&gt;
agent2加入集群的方式和agent1大部分是一样的，只有以下两点要注意：&lt;/li&gt;
&lt;li&gt;在Jenkins页面上创建节点，名称是&lt;span&gt;agent2&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;agent2的标签是&lt;span&gt;gradle&lt;/span&gt;,如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234905512-1502339705.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;2.6497005988024&quot;&gt;
&lt;p&gt;此时agent2也加入成功：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191116234907592-2102563481.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;&lt;p&gt;至此，Jenkins集群搭建完成，这两个节点带有不同的标签，下一篇文章&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/103104441&quot;&gt;《Jenkins集群下的pipeline实战》&lt;/a&gt;中，我们在这个集群环境创建pipeline任务，并通过标签被分配到不同的节点上，实现多节点并行执行；&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 16 Nov 2019 15:49:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>关于Jenkins集群 在Jenkins上同时执行多个任务时，单机性能可能达到瓶颈，使用Jenkins集群可以有效的解决此问题，让多台机器同时处理这些任务可以将压力分散，对单机版Jenkins的单点故</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/11874717.html</dc:identifier>
</item>
<item>
<title>Ansibile之playbook初识 - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/11871741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/11871741.html</guid>
<description>&lt;p&gt;　　一、playbook简介&lt;/p&gt;
&lt;p&gt;　　ansiblie的任务配置文件被称为playbook，俗称“剧本”，每一个剧本（playbook）中都包含了一系列的任务，这每个任务在ansible中又被称为“戏剧”（play），一个剧本中包含多出戏剧。。&lt;/p&gt;
&lt;p&gt;　　前文我们了解了ansible有两种执行方式ad-hoc和ansible-playbook，ad-hoc主要用于临时命令的执行，而playbook我们可以理解为ad-hoc的集合，有点类似shell脚本，ad-hoc就相当于shell脚本里的某条任务语句，playbook就相当于整个shell脚本。playbook是由一个或多个“play”组成的列表，play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。task实际是调用ansible的一个模块，将多个play组织在一个playbook中，即可以让他们联合起来，按事先编排的机制执行预定义的动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/201911/1503305-20191116141054560-1943647015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如以上图示，用户可以把多条任务（ad-hoc任务）写到playbook中，用户用ansible-playbook命令调用执行编排好的playbook,ansible会读取playbook中的每一条play和task，并按照playbook中的顺序从上至下依次执行，ansible会调用每个task中定义的模块去依次执行相应的任务，并按照playbook中指定的主机去主机清单里匹配对应的主机，然后通过ssh认证，把编译好的相应的任务文件发送到对应的主机或网络设备上执行，最后返回执行的状态。&lt;/p&gt;
&lt;p&gt;　　二、YAML简介&lt;/p&gt;
&lt;p&gt;　　playbook采用yaml语言编写，yaml是一个可读性高的用来表达资料序列格式的语言，它参考了其他很多种语言，包括：XML、C语言、python、perl以及电子邮箱格式RFC2822等。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。YAML（ YAML Ain't Markup Language），即yaml不是标记语言。不过在开发这种语言时，yaml的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）&lt;/p&gt;
&lt;p&gt;　　ymal特性&lt;/p&gt;
&lt;p&gt;　　1）YAML的可读性好&lt;/p&gt;
&lt;p&gt;　　2）YAML和脚本语言的交互性好&lt;/p&gt;
&lt;p&gt;　　3）YAML使用实现语言的数据类型&lt;/p&gt;
&lt;p&gt;　　4）YAML有一个一致的信息模板&lt;/p&gt;
&lt;p&gt;　　5）YAML易于实现，可以基于流程处理，表达能力强，扩展性好&lt;/p&gt;
&lt;p&gt;更多的内容及规范请参考官方文档&lt;a href=&quot;http://www.yaml.org&quot; target=&quot;_blank&quot;&gt;http://www.yaml.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　三、playbook语法简介&lt;/p&gt;
&lt;p&gt;　　1）需要以“---”（3个减号）开始，且需顶行首写。另外还有选择性的连续三个点号（...）用来表示文件的结尾。&lt;/p&gt;
&lt;p&gt;　　2）次行开始正常写playbook的内容，建议次行写该playbook的功能，当然不写也是可以的。&lt;/p&gt;
&lt;p&gt;　　3）使用“#”号注释代码。&lt;/p&gt;
&lt;p&gt;　　4）缩进必须统一，不能空格tab混用。&lt;/p&gt;
&lt;p&gt;　　5）缩进的级别必须是一致的，同样的缩进代表同样级别，程序判别配置的级别是通过缩进结合换行来实现的。&lt;/p&gt;
&lt;p&gt;　　6）YAML文件内容和Linux系统大小写判断方式一直，区分大小写（大小写敏感），k/v的值均大小写敏感。&lt;/p&gt;
&lt;p&gt;　　7）k/v的值可同行写也可换行写。同行使用“：”分隔，换行写需要以“-”分隔。&lt;/p&gt;
&lt;p&gt;　　8）v可以是字符串，也可以另外一个列表，当然也可以是字典。&lt;/p&gt;
&lt;p&gt;　　9）一个完整的代码块功能最少需要有name:xxx（对任务的描述）。&lt;/p&gt;
&lt;p&gt;　　10）一个name只能包括一个task&lt;/p&gt;
&lt;p&gt;　　11）yaml文件扩展名通常为yml或yaml&lt;/p&gt;
&lt;p&gt;list:列表，其所有元素均使用“-”开头&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
# A list of tasty fruits

- apple
- orange
- strawberry
- mango
~          　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dictionary:字典，通常由多个key与value构成&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
#An employee record
name: example developer
job: developer
skill: elite　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以将key:value放置于{}中进行表示，用“，”分隔多个key:value&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
#An employee record
{name: example developer,job: developer, skill: elite}
~                                                       　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用&quot;-&quot;来代表，Map里的键值对用&quot;:&quot;分隔。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
name: John Smith
age: 41
gender: Male
spouse:
  name: Jane Smith
  age: 37
  gender: Female
children:
  - name: Jimmy Smith
    age: 17
    gender: Male
  - name: Jenny Smith
    age: 13
    gender: Female
~                    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　四、playbook核心元素&lt;/p&gt;
&lt;p&gt;　　1）hosts  ：指定执行任务的远程主机列表（主机清单定义的主机组或单个主机，支持前面的说的主机模式匹配）&lt;/p&gt;
&lt;p&gt;　　2）tasks  ：任务集&lt;/p&gt;
&lt;p&gt;　　3）varniables  ：内置变量或自定义变量在playbook中调用&lt;/p&gt;
&lt;p&gt;　　4）templates  ：模板，可替换模板文件中的变量并实现一些简单逻辑的文件&lt;/p&gt;
&lt;p&gt;　　5）handlers  和  notity结合使用，由特定条件出发的操作，满足条件方才执行，否则不执行&lt;/p&gt;
&lt;p&gt;　　6）tags标签  ：给指定的任务贴上标签，我们在执行playbook的时候可以根据标签选择性的挑选部分代码执行，如 ansible-playbook -t tagsname useradd.yml  ,这条命令的意思就是在useradd.yml中挑选标签名为tagsname的任务执行&lt;/p&gt;
&lt;p&gt; 　　五、playbook基础组件&lt;/p&gt;
&lt;p&gt;　　1）hosts:&lt;/p&gt;
&lt;p&gt;　　　　playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。hosts用于指定要执行任务的主机，须事先定义在主机清单中。hosts指定主机的形式同样支持像主机清单中定义的那样，支持通配，支持主机模式匹配与或非，支持IP地址，当然也支持混合匹配与或非。&lt;/p&gt;
&lt;p&gt;示例：在websers组，但不再dbsers组，可以这样定义hosts&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
- hosts: websers:!dbsers
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2)remote_user：可用于host和task中，也可以通过指定其通过sudo的方式在远程执行任务，其可用于play全局或某个任务；此外，甚至可以在sudo时使用用sudo_user指定sudo时切换的用户，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
- hosts: websers:!dbsers
  remote_user: root

  tasks:
    - name: test connection
      ping:
      remote_user: qiuhom
      sudo: yes
      sudo_user: qiuping
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：默认sudo 为root，上例指定了sudo_user 为qiuping，上述任务同sudo -u qiuping ping xxxx（代表某主机）命令一样的意思，当然在使用sudo 时 我们还需要在目标主机上对qiuhom授权，要让qiuhom这个用户具有代表qiuping的权限去执行ping命令。&lt;/p&gt;
&lt;p&gt;　　3）task列表和action：play的主体部分是task list，task list 中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务；task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量，模块执行时是幂等的，这意味着多次执行时是安全的，其结果均一致；每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务步骤，如未提供name，则action的结果将用于输出。&lt;/p&gt;
&lt;p&gt;　　tasks：任务列表,它有两种格式如下&lt;/p&gt;
&lt;p&gt;　　　　（1）action: module arguments&lt;/p&gt;
&lt;p&gt;　　　　（2）module： arguments        ##建议使用&lt;/p&gt;
&lt;p&gt; 　　注意：shell模块和command模块后面跟的是命令，而非key=value&lt;/p&gt;
&lt;p&gt;如果某项任务的状态在运行后为changed时，可通过“notify”通知给相应的handlers;当然任务可以通过“tags”打标签，可以在ansible-playbook命令上使用-t指定进行指定其标签名调用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[qiuhom@test ~]$cat test.yml 
---
- hosts: websers:!dbsers
  remote_user: root

  tasks:
    - name: test connection
      ping:
      remote_user: qiuhom
      sudo: yes
      sudo_user: qiuping 
      tags: test
    - name: test command
      shell: /bin/ls /home/qiuhom/
[qiuhom@test ~]$ansible-playbook -t test test.yml 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：用-t 指定标签名，表示只运行所指定标签所在的任务，当然同名的标签可以在多条任务中，一个任务也可以有多个标签。&lt;/p&gt;
&lt;p&gt;如果命令或脚本的退出码不为零，可用使用如下方式忽略或跳过继续执行以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
- hosts: websers:!dbsers
  remote_user: root

  tasks:
    - name: run this command and ignore the result
      shell: /usr/sbin/ip addr show eth0 || /bin/true
    - name: run this command and ignore the result
      shell: /usr/sbin/ip addr show eth0
      ignore_errors: True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：两种方式都可以跳过出错的命令而不打断playbook，继续执行以下的代码，前者使用的短路或的特性，后者使用ignore_errors参数来控制&lt;/p&gt;
&lt;p&gt;　　六、playbook运行的方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ansible-playbook &amp;lt;filename.yml&amp;gt; ... [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用选项：&lt;/p&gt;
&lt;p&gt;　　-C , --check  : 只检查可能会发生的改变，但不真正执行操作，相当于空跑一遍playbook，测试下是否和自己预想的结果一样，但它不会真正的去远端主机上执行。常用于测试写的playbook语法是否有误。&lt;/p&gt;
&lt;p&gt;　　--list-hosts  :列出playbook指定运行任务所匹配的主机&lt;/p&gt;
&lt;p&gt;　　--list-tags    :列出playbook中所有标签名称列表&lt;/p&gt;
&lt;p&gt;　　--list-tasks  :列出playbook中所有任务名称及标签名称&lt;/p&gt;
&lt;p&gt;　　--limit 主机列表   ：只针对指定主机列表中的主机执行当前playbook（指定主机列表必须是在playbook里定义的主机列表范围内）&lt;/p&gt;
&lt;p&gt;　　-v,-vv,-vvv       :  显示执行playbook的过程，-v,显示较简单，-vv显示较详细，-vvv显示整个过程（非常详细）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;77&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]#cat test.yml 
---
- hosts: websers
  remote_user: root

  tasks:
    - name: run this command 
      shell: hostname
      tags: hostname
      ignore_errors: True
    - name: show ip addr
      shell: /sbin/ip addr show
      tags: showip
[root@test ~]#ansible-playbook test.yml --list-hosts

playbook: test.yml

  play #1 (websers): websers    TAGS: []
    pattern: [u'websers']
    hosts (2):
      192.168.0.128
      192.168.0.218
[root@test ~]#ansible-playbook test.yml --list-tags

playbook: test.yml

  play #1 (websers): websers    TAGS: []
      TASK TAGS: [hostname, showip]
[root@test ~]#ansible-playbook test.yml --list-tasks

playbook: test.yml

  play #1 (websers): websers    TAGS: []
    tasks:
      run this command  TAGS: [hostname]
      show ip addr      TAGS: [showip]
[root@test ~]#ansible-playbook test.yml --limit 192.168.0.218

PLAY [websers] ********************************************************************************************************

TASK [Gathering Facts] ************************************************************************************************
ok: [192.168.0.218]

TASK [run this command] ***********************************************************************************************
changed: [192.168.0.218]

TASK [show ip addr] ***************************************************************************************************
changed: [192.168.0.218]

PLAY RECAP ************************************************************************************************************
192.168.0.218              : ok=3    changed=2    unreachable=0    failed=0   

[root@test ~]#ansible-playbook test.yml --limit 192.168.0.218 -v
Using /etc/ansible/ansible.cfg as config file

PLAY [websers] ********************************************************************************************************

TASK [Gathering Facts] ************************************************************************************************
ok: [192.168.0.218]

TASK [run this command] ***********************************************************************************************
changed: [192.168.0.218] =&amp;gt; {&quot;changed&quot;: true, &quot;cmd&quot;: &quot;hostname&quot;, &quot;delta&quot;: &quot;0:00:00.002139&quot;, &quot;end&quot;: &quot;2019-11-16 23:11:02.996962&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2019-11-16 23:11:02.994823&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;localhost.localdomain&quot;, &quot;stdout_lines&quot;: [&quot;localhost.localdomain&quot;]}

TASK [show ip addr] ***************************************************************************************************
changed: [192.168.0.218] =&amp;gt; {&quot;changed&quot;: true, &quot;cmd&quot;: &quot;/sbin/ip addr show&quot;, &quot;delta&quot;: &quot;0:00:00.002604&quot;, &quot;end&quot;: &quot;2019-11-16 23:11:03.733004&quot;, &quot;rc&quot;: 0, &quot;start&quot;: &quot;2019-11-16 23:11:03.730400&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 00:0c:29:e8:f6:7b brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.218/24 brd 192.168.0.255 scope global eth0\n    inet6 fe80::20c:29ff:fee8:f67b/64 scope link \n       valid_lft forever preferred_lft forever\n3: pan0: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN \n    link/ether d2:7a:38:cf:27:60 brd ff:ff:ff:ff:ff:ff&quot;, &quot;stdout_lines&quot;: [&quot;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN &quot;, &quot;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&quot;, &quot;    inet 127.0.0.1/8 scope host lo&quot;, &quot;    inet6 ::1/128 scope host &quot;, &quot;       valid_lft forever preferred_lft forever&quot;, &quot;2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000&quot;, &quot;    link/ether 00:0c:29:e8:f6:7b brd ff:ff:ff:ff:ff:ff&quot;, &quot;    inet 192.168.0.218/24 brd 192.168.0.255 scope global eth0&quot;, &quot;    inet6 fe80::20c:29ff:fee8:f67b/64 scope link &quot;, &quot;       valid_lft forever preferred_lft forever&quot;, &quot;3: pan0: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN &quot;, &quot;    link/ether d2:7a:38:cf:27:60 brd ff:ff:ff:ff:ff:ff&quot;]}

PLAY RECAP ************************************************************************************************************
192.168.0.218              : ok=3    changed=2    unreachable=0    failed=0   

[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：--limit 所指定的主机必须是在playbook中所指定的主机范围内。&lt;/p&gt;
&lt;p&gt; 　　七、playbook vs shell scripts&lt;/p&gt;
&lt;p&gt;　　1)shell脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#!/bin/bash
# 安装Apache
yum install --quiet -y httpd
# 复制配置文件
cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf
cp/tmp/vhosts.conf /etc/httpd/conf.d/
# 启动Apache，并设置开机启动
service httpd start
chkconfig httpd on
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）playbook&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
---
- hosts: websers
  remote_user: root

  tasks:
    - name: create apache group
      group: name=apache gid=80 system=yes
    - name: create apache user
      user: name=apache uid=80 group=apache system=yes shell=/sbin/nologin home=/var/www/html 
    - name: install httpd
      yum: name=httpd
    - name: copy config file
      copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/
    - name: copy config 2 file
      copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/
    - name: start httpd service
      service: name=httpd state=started enabled=yes     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：两者都是实现同样的目的，很明显playbook的优势要比脚本的优势多，playbook 可以针对很多台主机进行任务执行，而脚本只可以在某一台主机上执行；脚本重复执行没有幂等性，很有可能带来很多错误，而playbook却不会有这样的苦恼。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 15:43:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、playbook简介 ansiblie的任务配置文件被称为playbook，俗称“剧本”，每一个剧本（playbook）中都包含了一系列的任务，这每个任务在ansible中又被称为“戏剧”（pla</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/11871741.html</dc:identifier>
</item>
<item>
<title>玩转VSCode-完整构建VSCode开发调试环境 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/11874558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/11874558.html</guid>
<description>&lt;p&gt;随着VSCode的不断完善和强大，是时候将部分开发迁移到VS Code中了。&lt;/p&gt;
&lt;p&gt;目前使用VS2019开发.NET Core应用，一直有一个想法，在VS Code中复刻VS的开发环境，同时迁移到VS Code。&lt;/p&gt;
&lt;p&gt;那么现在就开始吧。&lt;/p&gt;
&lt;p&gt;首先，安装最新版的VS Code：&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;，安装完成后可能会提示升级，升级即可，升级后的版本信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
版本: &lt;span&gt;1.40&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt; (system setup)
提交: 8795a9889db74563ddd43eb0a897a2384129a619
日期: &lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-13T16:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;&lt;span&gt;.976Z
Electron: &lt;/span&gt;&lt;span&gt;6.1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Chrome: &lt;/span&gt;&lt;span&gt;76.0&lt;/span&gt;.&lt;span&gt;3809.146&lt;/span&gt;&lt;span&gt;
Node.js: &lt;/span&gt;&lt;span&gt;12.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
V8: &lt;/span&gt;&lt;span&gt;7.6&lt;/span&gt;.&lt;span&gt;303.31&lt;/span&gt;-electron.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
OS: Windows_NT x64 &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;16299&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来的操作分为几个步骤：&lt;/p&gt;
&lt;p&gt;1. 安装各种强大VS Code插件&lt;/p&gt;
&lt;p&gt;2. 创建.NET Core解决方案和工程&lt;/p&gt;
&lt;p&gt;3. 调试运行&lt;/p&gt;
&lt;p&gt;好的，那我们开始吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、安装各种强大的VS Code插件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. C# extension for Visual Studio Code&lt;/p&gt;
&lt;p&gt;这个插件最重要的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lightweight development tools for &lt;a title=&quot;https://dotnet.github.io&quot; href=&quot;https://dotnet.github.io/&quot;&gt;.NET Core&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Great C# editing support, including Syntax Highlighting, IntelliSense, Go to Definition, Find All References, etc.&lt;/li&gt;
&lt;li&gt;Debugging support for .NET Core (CoreCLR). NOTE: Mono debugging is not supported. Desktop CLR debugging has &lt;a title=&quot;https://github.com/OmniSharp/omnisharp-vscode/wiki/Desktop-.NET-Framework&quot; href=&quot;https://github.com/OmniSharp/omnisharp-vscode/wiki/Desktop-.NET-Framework&quot;&gt;limited support&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Support for project.json and csproj projects on Windows, macOS and Linux.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116223107121-1374307824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span class=&quot;name clickable&quot; title=&quot;扩展名&quot;&gt;C# Extensions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个插件最有用的功能是可以右键新建C#类和C#接口，同时支持各种code snippets，例如 ctor 、prop等，具体功能特性，可以查看插件的说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116223647555-152515035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3. Auto-Using for C#&lt;/p&gt;
&lt;p&gt;这个插件自动添加using引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116223819671-972028203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. vscode-solution-explorer&lt;/p&gt;
&lt;p&gt;这个插件给VS Code增加了解决方案tab, 支持新建解决方案、新建工程、添加引用、Nuget包，这个插件非常有用&lt;/p&gt;
&lt;p&gt;Adds a Solution Explorer panel where you can find a Visual Studio Solution File Explorer.&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Can load any .sln version&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Supports csproj, vcxproj, fsproj and vbproj (from vs2017 and before)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Supports dotnet core projects&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;You can create, delete, rename or move project folders and files.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;You can create, delete, rename or move solution, solution folders and projects.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;You can add or remove packages and references when the project is of kind CPS (dotnet core).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;name clickable&quot; title=&quot;扩展名&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224115650-1909428785.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;5. Code Runner（韩俊老师出品，必属精品）&lt;/p&gt;
&lt;p&gt;Run code snippet or code file for multiple languages: &lt;strong&gt;C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit&lt;/strong&gt;, and custom command&lt;/p&gt;
&lt;p&gt;即选中一段代码，直接run&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224309233-439651238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;span class=&quot;name clickable&quot; title=&quot;扩展名&quot;&gt;vscode-icons&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过这个插件，给各个文件和文件夹一个你更熟悉的图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224415866-1514804724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7. Visual Studio IntelliCode&lt;/p&gt;
&lt;p&gt;VS代码智能提示，根据上下文语境，自动推荐你下一步用到的代码，后台基于AI的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224557664-231040006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8. NuGet Package Manager&lt;/p&gt;
&lt;p&gt;Nuget包管理，快速查询定位Nuget包，并安装。不过尝试了一下午自定义Nuget源，没搞定，估计是URL不对&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224730570-1935243959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9. Docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224800451-1404785321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10. Kubernetes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116224832214-2073861928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他的还需要配置GitHub、TFS类似的源代码管理，TFS搞了两个插件，都不好使，后续搞定后再更新一次。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、创建.NET Core解决方案和工程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时，VS Code的环境基本配置差不多了，接下来有两种模式，创建解决方案和工程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 通过vscode-solution-explorer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225123269-1255973048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225214960-1302636527.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225236311-965364529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案有了，很熟悉的感觉。&lt;/p&gt;
&lt;p&gt;我们可以继续创建工程：右键sln，Add new project：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225409915-638684587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时会弹出工程模板，此时我们选择ASP.NET Core Web API工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225441838-1748805414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择C#&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225619826-463729342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续输入工程名称：例如 TestWebApi&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116225821497-1463083834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熟悉的感觉来了。此时就可以开始coding了。&lt;/p&gt;
&lt;p&gt;以上是我们通过vscode-solution-explorer新建解决方案和工程。同时我们可以通过命令行来搞定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 通过Dotnet CLI命令行&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建sln：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EricTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e:\Work\ServiceDependency&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建ASP.NET Core WebAPI工程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-lang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestWebApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestWebApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将TestWebApi工程添加到解决方案EricTest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e:\Work\ServiceDependency\EricTest.sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e:\Work\ServiceDependency\TestWebApi\TestWebApi.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、调试运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Debug选项卡中新增调试配置，重点设置要调试的program&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116232300570-1372643971.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保存后，启动调试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201911/23525-20191116232421614-1735396197.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;程序中增加断点，然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
输入URL：https://localhost:5001/WeatherForecast
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 既可以调试了。&lt;/p&gt;

&lt;p&gt;以上是今天集中配置VS Code开发调试环境的总结，分享给大家。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2019//11/16&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 15:26:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>随着VSCode的不断完善和强大，是时候将部分开发迁移到VS Code中了。 目前使用VS2019开发.NET Core应用，一直有一个想法，在VS Code中复刻VS的开发环境，同时迁移到VS Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/11874558.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：串行EEPROM接口事实标准及SPI EEPROM简介 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/11874565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/11874565.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;EEPROM接口标准及SPI EEPROM&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　痞子衡之前写过一篇文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/9251620.html&quot;&gt;《SLC Parallel NOR简介》&lt;/a&gt;，介绍过并行NOR Flash基本概念。众所周知，现如今嵌入式非易失性存储器基本被NOR Flash一统江湖了，但在Flash技术发明之前，EEPROM才是非易失性存储器的霸主。EEPROM的全称是&quot;电可擦除可编程只读存储器&quot;，即Electrically Erasable Programmable Read-Only Memory，EEPROM技术的发明可是拯救过一大批嵌入式工程师的，毕竟在这之前非易失性存储器技术的演进分别是ROM(只读), PROM(只能写一次), EPROM(紫外线可擦除)，擦除方式都不太友好，直到EEPROM的出现才变得人性化。虽说现在Flash是主流，但在较低容量（2Mb以下）尤其是超低容量（1Kb以下）的市场，EEPROM仍然有其不可替代的应用场合。今天痞子衡就来好好聊一聊EEPROM：&lt;/p&gt;
&lt;h3 id=&quot;一eeprom背景简介&quot;&gt;一、EEPROM背景简介&lt;/h3&gt;
&lt;p&gt;　　聊到EEPROM发展史，不得不提浮栅MOSFET，这是一项发明于1967年的技术，它是所有闪存的基础。1970年，第一款成功的浮栅型器件-EPROM被发明。1979年，大名鼎鼎的SanDisk(闪迪)创始人Eli Harari，发明了世界上首个电可擦除的浮栅型器件即EEPROM。&lt;br/&gt;　　讲到EEPROM必然要将它和与其相爱相杀的Flash一起对比。关于Flash大家都很熟悉，但其实Flash全称应该叫Flash EEPROM，它属于广义的EEPROM。而本文主角EEPROM，指的是狭义的EEPROM，Flash和EEPROM最大的区别是：Flash按扇区操作，EEPROM按字节操作。Flash的特点是结构简单，容量可以做得比较大且在大数据量下的操作速度更快，但缺点是操作过程麻烦，所以Flash适于当不需频繁改写的程序存储器。而在有些应用中往往需要频繁的改写某些小量数据且需掉电非易失，传统结构的EEPROM则非常适合。&lt;br/&gt;　　EEPROM不像NOR, NAND Flash技术演进得那么复杂，因此实际上关于EEPROM并没有成文的标准，即使最知名的电子行业标准之一JEDEC也没有关于EEPROM的标准出台，不过各大厂商生产的EEPROM似乎都遵从某种约定的事实标准，这在后面介绍的EEPROM接口命令里显得尤为明显。&lt;/p&gt;
&lt;h3 id=&quot;二serial-eeprom原理&quot;&gt;二、Serial EEPROM原理&lt;/h3&gt;
&lt;h4 id=&quot;serial-eeprom分类&quot;&gt;2.1 Serial EEPROM分类&lt;/h4&gt;
&lt;p&gt;　　从软件驱动开发角度而言，Serial EEPROM可以从以下几个方面进一步细分：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;地址码长度：1byte / 2byte / 3byte&lt;br/&gt;通信接口类型：I2C / SPI / Microwire / UNIO Bus / Single-Wire&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　本文的主要研究对象是SPI接口的EEPROM。&lt;/p&gt;
&lt;h4 id=&quot;spi-eeprom内存模型&quot;&gt;2.2 SPI EEPROM内存模型&lt;/h4&gt;
&lt;p&gt;　　EEPROM内存单元从大到小一般分为如下4层：Device、Sector、Page、Byte，其中Sector不是必有的，并且Page也只是个结构概念，跟NOR Flash里的Page/Sector意义不一样，因为&lt;span&gt;Byte就是EEPROM读写的最小单元（即可以任意地址随机访问）&lt;/span&gt;，所以你可以把EEPROM当做一个非易失性的RAM。当然有些高端EEPROM中集成了Page/Sector操作命令，这只是为了让EEPROM操作效率更高而已。&lt;/p&gt;
&lt;h4 id=&quot;spi-eeprom信号与封装&quot;&gt;2.3 SPI EEPROM信号与封装&lt;/h4&gt;
&lt;p&gt;　　SPI EEPROM一般有8个脚，除去电源Vcc,地GND/Vss，以及SPI四根信号线（CS#, SCK, SI, SO）不言而喻之外，还有两根特殊的控制信号，即WP#（写保护）和HOLD#（挂起）。WP#信号主要是从硬件层面上对EEPROM内存进行保护，防止电路上的噪声干扰篡改了EEPROM里的内容；而HOLD#则提供EEPROM写操作暂停的功能，当该信号有效的时候，SI信号输入将被忽略，因此主机可以做其他更高优先级的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_block_diagram.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　SPI EEPROM虽然只有8pin，但是封装种类还是比较齐全的，这其中最经典的当属JEDEC定义的8-lead SOIC，此外还有TSSOP8, UDFN8, WLCSP8，下图罗列了常见封装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_typical_packages.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spi-eeprom接口命令&quot;&gt;2.4 SPI EEPROM接口命令&lt;/h4&gt;
&lt;h5 id=&quot;事实标准&quot;&gt;2.4.1 事实标准&lt;/h5&gt;
&lt;p&gt;　　痞子衡在文章开头的时候讲过，SPI EEPROM并没有什么成文的接口命令标准，但是各大厂商生产的SPI EEPROM无一例外都支持下表的6条命令，即READ（读内存）、WRITE（写内存）、WREN（写使能）、WRDI（写禁止）、RDSR（读状态寄存器）、WRSR（写状态寄存器），所以从软件接口层面而言，这6条命令就是SPI EEPROM事实上的接口命令标准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_standard_cmds.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　除了6条标准命令外，SPI EEPROM内部还有一个8bit的状态寄存器，用于反馈命令执行状态，这8bit状态寄存器的位定义也是存在如下表所示的事实标准的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_status_register_all.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不考虑写保护特性的话，bit0 - RDY#和bit1 - WEL是比较常用的，RDY#位主要用于标示所有涉及改变内存或状态寄存器的命令的执行结果，WEL位则保存了上一次WREN和WRDI命令的执行结果。状态寄存器中的其他两处定义bit7 - WPEN, bit[3:2] - BP[1:0]则主要与写保护特性有关，它们的具体作用如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_status_register_protect.PNG&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;厂商个性化&quot;&gt;2.4.2 厂商个性化&lt;/h5&gt;
&lt;p&gt;　　除了6条事实标准的命令外，有些厂商还实现了一些自定义的命令，这些命令并不一定通用，一般用于较大容量（3byte地址码，512Kb以上）的EEPROM上。痞子衡找了一款非常经典的EEPROM，来自Microchip的25AA系列（25AA1024），让我们看看它有啥个性化的命令。这颗EEPROM容量为1Mb，属于大容量EEPROM，为了提高EEPROM操作效率，Microchip为这颗EEPROM增加了Page/Sector/Chip Erase命令，使得擦除操作效率变高了，如果没有这些个性化擦除命令，那么只能通过标准WRITE命令去手动实现擦除操作，既麻烦又低效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_special_cmds_microchip.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spi-eeprom数据速率&quot;&gt;2.5 SPI EEPROM数据速率&lt;/h4&gt;
&lt;p&gt;　　数据存取速率是个重要的技术指标，咱们来看看SPI EEPROM的读写时序，前面痞子衡在讲EEPROM分类的时候提到过EEPROM地址码有1byte/2byte/3byte之分，地址码的区别主要体现了EEPROM读写时序上。对于读时序，在SPI总线发完READ（0x03）命令后，紧接着要发送想要读取的内存地址，地址码不同，发送的地址字节数也不同。对于容量大于512Kb的EEPROM（即地址码为3byte），显然要发送3byte的地址，才能确定要读的数据所在地址，然后才能进行读数据操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_read_sequence_3byte_addr.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而对于容量小于等于512Kb的EEPROM，关于1byte和2byte地址码区分，有一个特殊的设计，即对于512byte容量的EEPROM，按容量来说其属于2byte地址码范畴，READ命令后需要发送2byte地址，但实际上只需要发送1byte地址(A7-A0)，而最高地址位A8放在了READ命令码bit3里，这样可以节省1个字节的地址码。因此1Kb - 512Kb容量的EEPROM地址码为2byte，512byte及以下容量的EEPROM地址码为1byte，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_read_sequence_1byte_addr.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_read_sequence_2byte_addr_v2.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面读时序可以看出，READ命令码和地址码发完之后几乎没有等待周期，就可以直接读取EEPROM中数据，因此EEPROM读数据速率完全取决于SPI总线速率，所以我们只需要打开EEPROM数据手册，看看它最高能支持多高的SPI总线速率即可（常见的有2MHz/5MHz/10MHz/20MHz）。&lt;br/&gt;　　对于写时序，就稍微复杂一些了，这里不考虑地址码区别，以2byte地址为例。首先在发送WRITE命令之前需要发送一个WREN命令使能写操作，因为默认EEPROM在执行完上一次写操作后会恢复写禁止状态，在发送WRITE命令进行写操作之前必须保证EEPROM处于写使能状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_wren_sequence.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　确保EEPROM进入写使能状态后，开始发送WRITE命令，然后是地址码，接着是要写入的数据，痞子衡前面讲过Page在EEPROM是个结构概念，但其实也跟WRITE命令有关，因为EEPROM既可以按byte去写，也可以按Page去写，如果需要存入连续的数据，显然按Page去写效率比按Byte写入更高。这里需要注意的是，WRITE命令后面跟的字节数不能超过要写入的首地址所在Page剩余的字节数。下图示例的Page写时序最大byte数为16/32，是因为示例EEPROM的page size即16/32 byte。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_write_sequence_2byte_addr.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当一次WRITE时序内要写入的数据全部发送完成之后，底下便进入等待周期，与READ时序不同的是，WRITE时序有等待周期，因为EEPROM内部要将缓存在page buffer里的数据编程到真正的内存空间里，这需要时间。用户只能通过不断地发送如下RDSR命令去读取状态寄存器bit0 - RDY#来判断WRITE等待周期是否结束。因此写时序速率不仅仅取决于SPI总线速率，还取决于等待周期时长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/eeprom_rdsr_sequence.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果想快捷地了解SPI EEPROM的性能，最简单的就是打开SPI EEPROM手册，看首页的feature介绍，如下是25AA080的简要feature：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;• Max. Clock 10 MHz
• 1024 x 8-bit Organization
• 16 Byte Page (‘C’ version devices)
• 32 Byte Page (‘D’ version devices)
• Self-Timed Erase and Write Cycles (5 ms max.)
• Block Write Protection:
  - Protect none, 1/4, 1/2 or all of array
• Built-In Write Protection:
  - Power-on/off data protection circuitry
  - Write enable latch
  - Write-protect pin
• Sequential Read
• High Reliability:
  - Endurance: &amp;gt; 1M erase/write cycles
  - Data retention: &amp;gt; 200 years&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三spi-eeprom产品&quot;&gt;三、SPI EEPROM产品&lt;/h3&gt;
&lt;p&gt;　　最后痞子衡收集了可以售卖SPI EEPROM芯片的厂商及产品系列：&lt;/p&gt;
&lt;p&gt;　　至此，EEPROM接口标准及SPI EEPROM痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 15:13:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>众所周知，现如今嵌入式非易失性存储器基本被NOR Flash一统江湖了，但在Flash技术发明之前，EEPROM才是非易失性存储器的霸主。EEPROM的全称是'电可擦除可编程只读存储器'，即Elect</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/11874565.html</dc:identifier>
</item>
<item>
<title>JVM原理速记复习Java虚拟机总结思维导图面试必备 - NeverTh</title>
<link>http://www.cnblogs.com/neverth/p/11874458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neverth/p/11874458.html</guid>
<description>&lt;h3 id=&quot;良心制作右键另存为保存&quot;&gt;良心制作，右键另存为保存&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/neverth/1592425/o_191116143745Java%E8%99%9A%E6%8B%9F%E6%9C%BA-min.png&quot; alt=&quot;JVM&quot;/&gt;&lt;br/&gt;喜欢可以点个赞哦&lt;/p&gt;

&lt;h2 id=&quot;一运行时数据区域&quot;&gt;一、运行时数据区域&lt;/h2&gt;
&lt;h3 id=&quot;线程私有&quot;&gt;线程私有&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;程序计数器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录正在执行的虚拟机字节码指令的地址（如果正在执行的是Native方法则为空），是唯一一个没有规定OOM（OutOfMemoryError）的区域。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java虚拟机栈&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个Java方法在执行的同时会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。从方法调用直到执行完成的过程，对应着一个栈桢在Java虚拟机栈中入栈和出栈的过程。（局部变量包含基本数据类型、对象引用reference和returnAddress类型）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为Native方法服务。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线程公有&quot;&gt;线程公有&lt;/h3&gt;
&lt;ul readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java堆（GC区）（Java Head）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;几乎所有的对象实例都在这里分配内存，是垃圾收集器管理的主要区域。分为新生代和老年代。对于新生代又分为Eden空间、From Survivor空间、To Survivor空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JDK1.7 方法区（永久代）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;br/&gt;对这块区域进行垃圾回收的主要目的是对常量池的回收和对类的卸载，但是一般难以实现。&lt;br/&gt;HotSpot虚拟机把它当做永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素的影响，并且每次Full GC之后永久代的大小都会改变，所以经常抛出OOM异常。&lt;br/&gt;从JDK1.8开始，移除永久代，并把方法区移至元空间。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时常量池&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是方法区的一部分&lt;br/&gt;Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。&lt;br/&gt;允许动态生成，例如String类的intern()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.8 元空间&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原本存在方法区（永久代）的数据，一部分移到了Java堆里面，一部分移到了本地内存里面（即元空间）。元空间存储类的元信息，静态变量和常量池等放入堆中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接内存&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在NIO中，会使用Native函数库直接分配堆外内存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二hotspot虚拟机&quot;&gt;二、HotSpot虚拟机&lt;/h2&gt;
&lt;h3 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当虚拟机遇到一条new指令时&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;检查参数能否在常量池中找到符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始过，没有的话先执行相应的类加载过程。&lt;/li&gt;
&lt;li&gt;在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。&lt;/li&gt;
&lt;li&gt;内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。&lt;/li&gt;
&lt;li&gt;对对象头进行必要的设置。&lt;/li&gt;
&lt;li&gt;执行构造方法按照程序员的意愿进行初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;对象的内存布局&quot;&gt;对象的内存布局&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;对象头&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向实现戳等。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;第二部分是类型指针，即对象指向它的类元数据的指针（如果使用直接对象指针访问），虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;如果对象是一个Java数组的话，还需要第三部分记录数据长度的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;实例数据&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;是对象真正存储的有效信息，也就是在代码中定义的各种类型的字段内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;对齐填充&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;不是必然存在的，仅仅起着占位符的作用。&lt;br/&gt;HotSpot需要对象的大小必须是8字节的整数倍。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对象的访问定位&quot;&gt;对象的访问定位&lt;/h3&gt;
&lt;ul readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;句柄访问&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Java堆中划分出一块内存作为句柄池。&lt;br/&gt;Java栈上的对象引用reference中存储的就是对象的句柄地址，而句柄中包含了到对象实例数据的指针和到对象类型数据的指针。&lt;br/&gt;对象实例数据在Java堆中，对象类型数据在方法区（永久代）中。&lt;br/&gt;优点：在对象被移动时只会改变句柄中的实例数据指针，而对象引用本身不需要修改。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;直接指针访问（HotSpot使用）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java栈上的对象引用reference中存储的就是对象的直接地址。&lt;br/&gt;在堆中的对象实例数据就需要包含到对象类型数据的指针。&lt;br/&gt;优点：节省了一次指针定位的时间开销，速度更快。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三垃圾收集&quot;&gt;三、垃圾收集&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;垃圾收集主要是针对Java堆和方法区。&lt;br/&gt;程序计数器、Java虚拟机栈个本地方法栈三个区域属于线程私有，线程或方法结束之后就会消失，因此不需要对这三个区域进行垃圾回收。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;判断对象是否可以被回收&quot;&gt;判断对象是否可以被回收&lt;/h3&gt;
&lt;ul readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一次标记（缓刑）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;引用计数算法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给对象添加一个引用计数器，当对象增加一个引用时引用计数值++，引用失效时引用计数值--，引用计数值为0时对象可以被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是它难以解决对象之间的相互循环引用的情况，此时这个两个对象引用计数值为1，但是永远无法用到这两个对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 可达性分析算法（Java使用）

    - 以一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连是，则证明此对象不可用，可以被回收。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GC Roots对象包括&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;虚拟机栈（栈桢中的本地变量表）中引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中共类静态属性引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI（即一般说的Native方法）引用的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;第二次标记&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过。&lt;br/&gt;如果对象在finalize方法中重新与引用链上的任何一个对象建立关联则将不会被回收。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;finalize()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任何一个对象的finalize()方法都只会被系统调用一次。&lt;br/&gt;它的出现是一个妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。&lt;br/&gt;finalize()能做的所有工作使用try-finally或者其他方式都可以做的更好，完全可以忘记在这个函数的存在。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方法区的回收&quot;&gt;方法区的回收&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在方法区进行垃圾回收的性价比一般比较低。&lt;br/&gt;主要回收两部分，废弃常量和无用的类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;满足无用的类三个判断条件才仅仅代表可以进行回收，不是必然关系，可以使用-Xnoclassgc参数控制。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。&lt;/li&gt;
&lt;li&gt;加载该类的ClassLoader已经被回收。&lt;/li&gt;
&lt;li&gt;该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;引用类型&quot;&gt;引用类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;强引用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用new一个新对象的方式来创建强引用。&lt;br/&gt;只要强引用还存在，被引用的对象则永远不会被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;软引用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用SoftReference类来实现软引用。&lt;br/&gt;用来描述一些还有用但是并非必须的对象，被引用的对象在将要发生内存溢出异常之前会被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;弱引用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用WeakReference类来实现弱引用。&lt;br/&gt;强度比软引用更弱一些，被引用的对象在下一次垃圾收集时会被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;虚引用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用PhantomReference类来实现虚引用。&lt;br/&gt;最弱的引用关系，不会对被引用的对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。&lt;br/&gt;唯一目的就是能在这个对象被收集器回收时收到一个系统通知。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;垃圾收集算法&quot;&gt;垃圾收集算法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;标记 - 清除&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象并取消标记。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;效率问题，标记和清除两个过程的效率都不高。&lt;/li&gt;
&lt;li&gt;空间问题，标记清除之后会产生大量不连续的内存碎片，没有连续内存容纳较大对象而不得不提前触发另一次垃圾收集。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;标记 - 整理&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;和标记 - 清除算法一样，但标记之后让所有存活对象都向一段移动，然后直接清理掉端边界以外的内存。&lt;br/&gt;解决了标记 - 清除算法的空间问题，但需要移动大量对象，还是存在效率问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;复制&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用多的内存空间一次清理掉。&lt;br/&gt;代价是将内存缩小为原来的一般，太高了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在商业虚拟机都采用这种算法用于新生代。&lt;br/&gt;因为新生代中的对象98%都是朝生暮死，所以将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。&lt;br/&gt;当回收时，如果另外一块Survivor空间没有足够的空间存放存活下来的对象时，这些对象将直接通过分配担保机制进入老年代。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;分代收集&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;一般把Java堆分为新生代和老年代。&lt;br/&gt;在新生代中使用复制算法，在老年代中使用标记 -清除 或者 标记 - 整理 算法来进行回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hotspot的算法实现&quot;&gt;HotSpot的算法实现&lt;/h3&gt;
&lt;ul readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;枚举根节点（GC Roots）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目前主流Java虚拟机使用的都是准确式GC。&lt;br/&gt;GC停顿的时候，虚拟机可以通过OopMap数据结构（映射表）知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用。因此可以快速且准确的完成GC Roots枚举。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为了节省GC的空间成本，并不会为每条指令都生成OopMap，只是在“特定的位置”记录OopMap，这些位置称为安全点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;程序执行只有到达安全点时才能暂停，到达安全点有两种方案。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;抢断式中断（几乎不使用）。GC时，先把所有线程中断，如果有线程不在安全点，就恢复该线程，让他跑到安全点。&lt;/li&gt;
&lt;li&gt;主动式中断（主要使用）。GC时，设置一个标志，各个线程执行到安全点时轮询这个标志，发现标志为直则挂起线程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是当线程sleep或blocked时无法响应JVM的中断请求走到安全点中断挂起，所以引出安全区域。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;安全区域&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全区域是指在一段代码片段之中，引用关系不会发生变化，是扩展的安全点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程进入安全区域时表示自己进入了安全区域，这个发生GC时，JVM就不需要管这个线程。&lt;br/&gt;线程离开安全区域时，检查系统是否完成GC过程，没有就等待可以离开安全区域的信号为止，否者继续执行。&lt;/p&gt;
&lt;h3 id=&quot;垃圾收集器&quot;&gt;垃圾收集器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;新生代&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;serial收集器&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;它是单线程收集器，只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：对比其他单线程收集器简单高效，对于单个CPU环境来说，没有线程交互的开销，因此拥有最高的单线程收集效率。&lt;/p&gt;
&lt;p&gt;它是Client场景下默认新生代收集器，因为在该场景下内存一般来说不会很大。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 2. parnew收集器

    - 它是Serial收集器的多线程版本，公用了相当多的代码。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至在2个CPU环境中也不能百分之百超越。&lt;/p&gt;
&lt;p&gt;它是Server场景下默认的新生代收集器，主要因为除了Serial收集器，只用它能与CMS收集器配合使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 3. parallel scavenge收集器

    - “吞吐优先”收集器，与ParNew收集器差不多。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是其他收集器的目标是尽可能缩短垃圾收集时用户线程停顿的时间，而它的目标是达到一个可控制的吞吐量。这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;老年代&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;serial old收集器&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;是Serial收集器老年代版本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也是给Client场景下的虚拟机使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 5. parallel old收集器

    - 是Parallel Scavenge收集器的老年代版本。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在注重吞吐量已经CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和Parallel Old收集器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 6. cms收集器

    - Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器。
    - 运作过程

        - 1. 初始标记（最短）。仍需要暂停用户线程。只是标记一下GC Roots能直接关联到的对象，速度很快&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;并发标记（耗时最长）。进行GC Roots Tracing（根搜索算法）的过程。&lt;/li&gt;
&lt;li&gt;重新标记。修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始标记长但远小于并发标记时间。&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1 和4 两个步骤并没有带上并发两个字，即这两个步骤仍要暂停用户线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    - 优缺点

        - 并发收集、低停顿。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;CMS收集器对CPU资源非常敏感。虽然不会导致用户线程停顿，但是占用CPU资源会使应用程序变慢。&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾。在并发清除阶段新垃圾还会不断的产生，所以GC时要控制“-XX:CMSinitiatingOccupancyFraction参数”预留足够的内存空间给这些垃圾，当预留内存无法满足程序需要时就会出现”Concurrent Mode Failure“失败，临时启动Serial Old收集。&lt;/li&gt;
&lt;li&gt;由于使用标记 - 清除算法，收集之后会产生大量空间碎片。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;g1收集器&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Garbage First是一款面向服务端应用的垃圾收集器&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运作过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;初始标记&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;li&gt;删选标记&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五类加载机制&quot;&gt;五、类加载机制&lt;/h2&gt;
&lt;h3 id=&quot;概述-1&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。&lt;br/&gt;Java应用程序的高度灵活性就是依赖运行期动态加载和动态连接实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的生命周期&quot;&gt;类的生命周期&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;加载 -&amp;gt; 连接（验证 -&amp;gt; 准备 -&amp;gt; 解析） -&amp;gt; 初始化 -&amp;gt; 使用 - &amp;gt;卸载&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类初始化时机&quot;&gt;类初始化时机&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;主动引用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机规范中没有强制约束何时进行加载，但是规定了有且只有五种情况必须对类进行初始化（加载、验证、准备都会随之发生）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;遇到new、getstatic、putstatic、invokestatic这四条字节码指令时没有初始化。&lt;/li&gt;
&lt;li&gt;反射调用时没有初始化。&lt;/li&gt;
&lt;li&gt;发现其父类没有初始化则先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;包含psvm（mian（）方法）的那个类。&lt;/li&gt;
&lt;li&gt;动态语言支持时，REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;被动引用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除上面五种情况之外，所有引用类的方式都不会触发初始化，称为被动引用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;通过子类引用父类的静态字段，不会导致子类的初始化。&lt;/li&gt;
&lt;li&gt;通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承Object的子类，其中包含数组的属性和方法，用户只能使用public的length和clone()。&lt;/li&gt;
&lt;li&gt;常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;类加载过程&quot;&gt;类加载过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;加载&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;通过类的全限定名来获取定义此类的二进制字节流。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的java.lang.Class对象（HotSpot将其存放在方法区中），作为方法区这个类的各种数据的访问入口。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;验证&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;为了确保Class文件的字节类中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。可以通过-Xverify:none关闭大部分类验证。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;文件格式验证。确保输入字节流能正确的解析并存储于方法区，后面的3个验证全部基于方法区的存储结构进行，不会再操作字节流。&lt;/li&gt;
&lt;li&gt;元数据验证。对字节码描述信息进行语义分析，确保其符合Java语法规范。（Java语法验证）&lt;/li&gt;
&lt;li&gt;字节码验证。最复杂，通过数据流和控制流分析，确定程序语义时合法的、符合逻辑的。可以通过参数关闭。（验证指令跳转范围，类型转换有效等）&lt;/li&gt;
&lt;li&gt;符号引用验证。将符号引用转化为直接引用，发生在第三个阶段——解析阶段中发生。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;准备&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;类变量是被static修饰的变量，准备阶段为类变量分配内存并设置零值（final直接设置初始值），使用的是方法区的内存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;解析&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将常量池内的符号引用替换为直接引用的过程。&lt;br/&gt;其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。&lt;br/&gt;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;初始化&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;初始化阶段才真正执行类中定义的Java程序代码，是执行类构造器()方法的过程。&lt;br/&gt;在准备阶段，类变量已经给过零值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类构造器方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的的语句合并产生的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;不需要显式调用父类构造器，JVM会保证在子类clinit执行之前，父类的clinit已经执行完成。&lt;/li&gt;
&lt;li&gt;接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的clinit不需要先执行父接口的clinit方法。接口的实现类也不会执行接口的clinit方法。&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;虚拟机会保证clinit在多线程环境中被正确的加锁、同步。其他线性唤醒之后不会再进入clinit方法，同一个类加载器下，一个类型只会初始化一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; - &amp;lt;init&amp;gt;()

     - 对象构造器方法。Java对象被创建时才会进行实例化操作，对非静态变量解析初始化。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;会显式的调用父类的init方法，对象实例化过程中对实例域的初始化操作全部在init方法中进行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;类加载-器&quot;&gt;类（加载） 器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;类与类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类加载器实现类的加载动作。&lt;br/&gt;类加载器和这个类本身一同确立这个类的唯一性，每个类加载器都有独立的类命名空间。在同一个类加载器加载的情况下才会有两个类相等。&lt;br/&gt;相等包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()、instanceof关键字。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类加载器分类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;启动类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由C++语言实现，是虚拟机的一部分。负责将JAVA_HOME/lib目录中，或者被-Xbootclasspath参数指定的路径，但是文件名要能被虚拟机识别，名字不符合无法被启动类加载器加载。启动类加载器无法被Java程序直接引用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩展类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由Java语言实现，负责加载JAVA_HOME/lib/ext目录，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义类加载器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由用户自己实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;如果不想打破双亲委派模型，那么只需要重写findClass方法即可。&lt;/li&gt;
&lt;li&gt;否则就重写整个loadClass方法。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;双亲委派模型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。父子不会以继承的关系类实现，而是都是使用组合关系来服用父加载器的代码。&lt;br/&gt;在java.lang.ClassLoader的loadClass()方法中实现。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成（它的搜索范围中没有找到所需要的类）时才尝试自己加载&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java类随着它的类加载器一起具备了一种带有优先级的层次关系，从而使得基础类库得到同意。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四内存分配与回收策略&quot;&gt;四、内存分配与回收策略&lt;/h2&gt;
&lt;h3 id=&quot;minor-gc-和-full-gc&quot;&gt;Minor GC 和 Full GC&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Minor GC&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发生在新生代的垃圾收集动作，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度快。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时机&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Eden不足&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full GC&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发生在老年区的GC，出现Full GC时往往伴随着Minor GC，比Minor GC慢10倍以上。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时机&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;调用System.gc()&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。&lt;br/&gt;不建议使用这种方式，而是让虚拟机管理内存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;老年代空间不足&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;常见场景就是大对象和长期存活对象进入老年代。&lt;br/&gt;尽量避免创建过大的对象以及数组，调大新生代大小，让对象尽量咋新生代中被回收，不进入老年代。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;JDK1.7 之前方法区空间不足&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;当系统中要加载的类、反射的类和常量较多时，永久代可能会被占满，在未配置CMS GC的情况下也会执行Full GC，如果空间仍然不够则会抛出OOM异常。&lt;br/&gt;可采用增大方法区空间或转为使用CMS GC。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;空间分配担保失败&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;发生Minor GC时分配担保的两个判断失败&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;Concurrent Mode Failure&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;CMS GC 并发清理阶段用户线程还在执行，不断有新的浮动垃圾产生，当预留空间不足时报Concurrent Mode Failure错误并触发Full GC。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;内存分配策略&quot;&gt;内存分配策略&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;对象优先在Eden分配&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC，当另外一个Survivor空间不足时则将存活对象通过分配担保机制提前转移到老年代。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;大对象直接进入老年代&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;配置参数-XX:PretenureSizeThreshold，大于此值得对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;长期存活对象进入老年代&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;虚拟机为每个对象定义了一个Age计数器，对象在Eden出生并经过Minor GC存活转移到另一个Survivor空间中时Age++，增加到默认16则转移到老年代。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;动态对象年龄绑定&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;虚拟机并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;空间分配担保&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代的所有对象，如果条件成立，那么Minor GC可以认为是安全的。&lt;br/&gt;可以通过HandlePromotionFailure参数设置允许冒险，此时虚拟机将与历代晋升到老年区对象的平均大小比较，仍小于则要进行一次Full GC。&lt;br/&gt;在JDK1.6.24之后HandlePromotionFailure已无作用，即虚拟机默认为true。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 16 Nov 2019 14:44:00 +0000</pubDate>
<dc:creator>NeverTh</dc:creator>
<og:description>良心制作，右键另存为保存 喜欢可以点个赞哦 Java虚拟机 一、运行时数据区域 线程私有 程序计数器 记录正在执行的虚拟机字节码指令的地址（如果正在执行的是Native方法则为空），是唯一一个没有规定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/neverth/p/11874458.html</dc:identifier>
</item>
<item>
<title>Cauchy-Binet公式的证明 及 对Denton et al. (2019)的个人注解 - 司徒鲜生</title>
<link>http://www.cnblogs.com/stxs/p/11874437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stxs/p/11874437.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cauchy-Binet公式的证明 及 对Denton et al. (2019)的个人注解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Denton et al. (2019) 即文献Denton, P.B., Parke, S.J., Tao, T., Zhang, X., 2019. Eigenvectors from Eigenvalues.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                                        -------- 司徒鲜生- 2019年11月15日@上海天文台&lt;/p&gt;

&lt;p&gt;　　据&lt;strong&gt;新闻报道,&lt;/strong&gt; 3个物理学家和数学天才陶哲轩研究出一个只用特征值就可以计算矩阵特征向量的公式, 我感觉很有趣, 这应该能够应用在很多领域中, 所以仔细研究了一波.&lt;/p&gt;
&lt;p&gt;　　研究公式耗费了我大半天, 我把所有的equation都推导了一遍, 也给出了一些我的看法, 现在把它们总结出来, 方便后人参考. 我给出了Cauchy-Binet公式(原文引理1)的更广义形式及其怎么过程, 对该公式取特殊条件即可证明引理2.(该引理就是全文的主要结论). 不过相比之下, 还是陶哲轩对于引理2的证明更加简洁, 虽然没有用到引理1.&lt;/p&gt;
&lt;p&gt;　　我的证明有些地方可能不严谨, 欢迎读者批评指正.&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;新闻报道(微信):&lt;/strong&gt; 3个搞物理的颠覆了数学常识, 数学天才陶哲轩: 我开始压根不相信&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116211458707-1422792459.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;189&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;参考&lt;span lang=&quot;EN-US&quot;&gt;(文献&lt;span lang=&quot;EN-US&quot;&gt;):&lt;/span&gt;&lt;/span&gt; Denton, P.B., Parke, S.J., Tao, T., Zhang, X., 2019. Eigenvectors from Eigenvalues. 未发表预印版.&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116211834383-2053458372.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;203&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;　　0.说明&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116225752006-1758608610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　1.  化简的方法&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116230054195-196944077.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;　　2.  特征分解的方法&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116230146108-642202046.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;

&lt;h2&gt;&lt;span&gt;　　3.  联立可得&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116230414644-240127680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　4.  特殊情况1&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116230721250-1956538712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　5.  特殊情况2&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116230849145-1687584823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　6.  特殊情况3&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231024564-2144069304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231105863-1456094602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　7.  特殊情况4&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231206366-1968193388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231236956-2064478494.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;　　8.  解释及备注&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231345996-1218479188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　9. 特征向量归一化的验证&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1357381/201911/1357381-20191116231719081-1375471842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Nov 2019 14:40:00 +0000</pubDate>
<dc:creator>司徒鲜生</dc:creator>
<og:description>Cauchy-Binet公式的证明 及 对Denton et al. (2019)的个人注解 Denton et al. (2019) 即文献Denton, P.B., Parke, S.J., Ta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stxs/p/11874437.html</dc:identifier>
</item>
<item>
<title>区块链和分布式数字账本正火？如何在7天内快速掌握这些必备的知识 - 宇宙之一粟</title>
<link>http://www.cnblogs.com/yuzhou-1su/p/11874379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzhou-1su/p/11874379.html</guid>
<description>&lt;p&gt;读研期间，几次被问到：“什么是区块链？”“我怎么学习区块链”。甚至跟“上至九十九”（爷爷奶奶），“下至刚会走的”（小学生的弟弟妹妹）解释过我的研究内容。因此想总结一份7天的学习计划（大量资料警告），让那些对区块链感兴趣的人快速入门。区块链技术的被运用到各行各业，尤其是各界（商界和政府）都对区块链技术创新高度重视。本文总结了诸多入门区块链的主要资源，博客、书籍和视频，希望帮你用7天时间获取必要的区块链基础知识。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;作者&lt;/em&gt;：&lt;em&gt;宇宙之一粟&lt;/em&gt;，转载请先声明出处&lt;br/&gt;&lt;em&gt;公众号&lt;/em&gt;：&lt;em&gt;宇宙之一粟&lt;/em&gt;，关注公众号获取更多相关资源&lt;/p&gt;

&lt;p&gt;区块链，刚开始听起来会很新颖，因为是一个英文组合词汇（ Block + Chain ）。区块：存放数据的载体（想象成箱子），链：把这些箱子首尾相连（类似数据结构中的单链表）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;区块链的本质：一个去中心化的分布式账本数据库。其本身是一串使用密码学相关联所产生的数据块，每一个数据块中包含了多次比特币网络交易有效确认的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区块链技术从比特币中发展而来，是比特币的底层技术，和比特币是&lt;strong&gt;相伴相生&lt;/strong&gt;的关系。目前这项技术已经不仅仅限于比特币——青出于蓝而胜于蓝。各行各业开始利用这项技术寻求突破。&lt;/p&gt;
&lt;p&gt;2019年6月，Facebook宣布了其加密货币项目——&lt;a href=&quot;https://libra.org&quot;&gt;Libra&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们国家央行也将发行自己的数字货币——&lt;a href=&quot;https://baike.baidu.com/item/DCEP&quot;&gt;DCEP&lt;/a&gt;（ Digital Currency Electronic Payment ），也采用了区块链技术，目前仍处于研究测试过程中。&lt;/p&gt;
&lt;p&gt;2019年10月24日下午，&lt;a href=&quot;http://www.xinhuanet.com/politics/2019-10/25/c_1125153665.htm&quot;&gt;中共中央政治局就区块链技术发展现状和趋势进行第十八次集体学习&lt;/a&gt;。一时间区块链技术又冲上了风口。&lt;/p&gt;
&lt;p&gt;因此，我们有必要对区块链技术做一个基本的了解。&lt;/p&gt;

&lt;p&gt;如果想快速学习区块链知识：收听音频课，阅读书籍，看论文或在线文章，学习白皮书以及参与区块链的相关学习计划或在线课程。其他针对想从事更加专业的学习人员——参加编程或智能合约编码课程。&lt;/p&gt;

&lt;p&gt;在区块链领域工作或打算工作的每个人至少应该能够理解并编写一个非常简单的智能合约，例如以程序语言Solidity通过几行代码实现的托管过程。尽管其他人会说，在学习区块链和DLT时应该把重点放在另一个方面，但在我们看来，这是一条清晰的声明。&lt;/p&gt;
&lt;p&gt;在我们看来，理解简单的智能合约（例如5-10行代码）的需求不仅对于信息系统领域的员工很重要，而且在商业，经济和法律领域也很重要。但是，关于如何配置节点的更深入的技术知识通常不是紧要的，但以后可以获取。&lt;/p&gt;
&lt;p&gt;任何寻求参与区块链技术并考虑以下步骤的人都可能拥有光荣的职业生涯。我们认为，区块链技术及其日益重要的潜力有可能对感兴趣的人的职业道路产生积极影响，因为在这个动态且快速增长的细分市场中，未来几年甚至数十年内还有很多工作要做。这样，可以将由于数字化和自动化程度提高而失业（例如在金融部门）的风险降到最低。&lt;/p&gt;
&lt;p&gt;但是感兴趣的人如何获得足够的知识呢？存在哪些研究区块链技术的机会？本文总结了区块链教育的一些不同策略。我们基本上设计了一个特定的程序，以在大约7个工作日内实现“区块链入门”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;所需时间：0.5天&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了获得一些理论知识之外，理解此技术非常重要的是您在操作上“弄脏手”。&lt;/strong&gt; 它的工作方式如下，为感兴趣的人提供有关什么是区块链技术的最重要学习。&lt;/p&gt;
&lt;p&gt;因此，开始的最佳练习是：购买加密货币（例如比特币）并在全球范围内进行转移。 如下所示，请找到分步指南：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在例如&lt;a href=&quot;https://www.coinbase.com/&quot;&gt;coinbase.com&lt;/a&gt;或比特派&lt;a href=&quot;https://bitpie.com/&quot;&gt;bitpie.com&lt;/a&gt;上开设一个帐户；其他选择：Bitstamp，Bitrex，Binance。&lt;/li&gt;
&lt;li&gt;购买比特币或者购买以太币。请注意，万一使用公钥或私钥出错，这笔钱将不可避免地丢失。因此，遵循此步骤当然是每个人自己的决定。&lt;/li&gt;
&lt;li&gt;开设第二个帐户（上面的示例）。&lt;/li&gt;
&lt;li&gt;从第二个帐户获取一个钱包地址，该地址类似于以太坊的0xd42899dcC146d4788649e6aa5B09f129fC269127。&lt;/li&gt;
&lt;li&gt;第一步，将您购买的一部分以太币或比特币转移到该地址。请注意，以太币和比特币的地址不同，因此请谨慎行事，切勿混淆。&lt;/li&gt;
&lt;li&gt;现在，您可以看到可以在几秒钟（以太）或几分钟（比特币）内将价值发送到世界各地。&lt;/li&gt;
&lt;li&gt;一个更高级的步骤，但对理解区块链非常有帮助：将插件&lt;a href=&quot;https://metamask.io/&quot;&gt;MetaMask&lt;/a&gt;添加到Google Chrome互联网浏览器中，以直接访问以太坊网络并将您的以太币存储在您自己的钱包中。之后，开设一个帐户并生成您自己的钱包地址。然后，将您的一些以太币从之前的步骤转移到这个新生成的钱包中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;所需时间：1.5天&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你喜欢听音频课，选择一个合适的音频可以快速入门：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Kryptoshow：&lt;/strong&gt; Julian Hosp博士很好地介绍了&lt;strong&gt;区块&lt;/strong&gt;链技术和加密货币这一主题。播客还涵盖了高级方面，例如在密码学和编程方面。在&lt;a href=&quot;https://julianhosp.com/de/kryptoshow-podcast/&quot;&gt;此处&lt;/a&gt;访问播客。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BTC Echo&lt;/strong&gt;：此播客面向更高级的受众，重点关注比特币和加密资产。在&lt;a href=&quot;https://www.btc-echo.de/podcast/&quot;&gt;此处&lt;/a&gt;访问播客。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从0到1全面学透区块链音频&lt;/strong&gt;教程，在&lt;a href=&quot;https://www.ximalaya.com/shangye/20070178/&quot;&gt;此处&lt;/a&gt;学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;所需时间：1天&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了了解区块链技术的起源和概念，有必要研究两种最重要的加密货币比特币和以太坊的白皮书。其他补充Filecoin白皮书。&lt;/p&gt;
&lt;p&gt;最重要的论文：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;所需时间：2天&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在通过阅读有关比特币和以太坊的原始著作从“科学”角度看待区块链技术之后，您可以使用视频进一步熟悉该技术并更深入地了解该技术的不同组成部分。我们推荐以下视频：&lt;/p&gt;
&lt;p&gt;最重要的视频：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;所需时间：1天&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过遵循建议的步骤，您现在应该已经对技术有了基本的高级知识。现在，是时候更深入地研究区块链技术了。我们建议阅读以下文章：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章或文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要了解的项目的网站：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所需时间：2天阅读&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ps: 关注公众号 &lt;em&gt;宇宙之一粟&lt;/em&gt; 获取电子版&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;所需时间：参加2次聚会（主要是免费）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下一步，我们建议您进入区块链社区，并与区块链专家进行首次讨论。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所需时间：0天，因为这是可选的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果您打算从科学的角度更多地探讨区块链的话题，那么就有可能研究有关区块链技术的论文。我们将进一步扩大此列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Eyal I , Gencer A E , Sirer E G , et al. &lt;a href=&quot;https://arxiv.org/pdf/1510.02037v2.pdf&quot;&gt;Bitcoin-NG: A Scalable Blockchain Protocol[J]. 2015.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Gilad, Yossi &amp;amp; Hemo, Rotem &amp;amp; Micali, Silvio &amp;amp; Vlachos, Georgios &amp;amp; Zeldovich, Nickolai. (2017). &lt;a href=&quot;https://www.researchgate.net/profile/Rotem_Hemo/publication/320362651_Algorand_Scaling_Byzantine_Agreements_for_Cryptocurrencies/links/5bc60d80299bf17a1c55bf64/Algorand-Scaling-Byzantine-Agreements-for-Cryptocurrencies.pdf&quot;&gt;Algorand: Scaling Byzantine Agreements for Cryptocurrencies. 51-68. 10.1145/3132747.3132757.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Li C , Li P , Zhou D , et al. &lt;a href=&quot;https://arxiv.org/pdf/1805.03870.pdf&quot;&gt;Scaling Nakamoto Consensus to Thousands of Transactions per Second[J]. 2018.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Yin M , Malkhi D , Reiter M K , et al. &lt;a href=&quot;https://arxiv.org/pdf/1803.05069.pdf&quot;&gt;HotStuff: BFT Consensus in the Lens of Blockchain[J]. 2018.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wang, Jiaping &amp;amp; Wang, Hao. (2019). &lt;a href=&quot;https://www.usenix.org/system/files/nsdi19-wang-jiaping.pdf&quot;&gt;Monoxide: Scale Out Blockchain with Asynchronous Consensus Zones. 10.13140/RG.2.2.32017.48489.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;更多区块链相关论文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是“阅读”有关区块链和DLT中的教育如何工作的信息。归根结底，只有一件重要的事情：&lt;strong&gt;那就去做。不要只是想，而要行动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;欢迎评论给我，无论您是否遵循我的建议--并向我提供反馈。如果您还有其他想法，请告诉我们如何学习和使用区块链。如果您使用其他来源来获取或增加您的区块链知识，那么如果您能与我分享这些知识，我将非常感激。&lt;/p&gt;

&lt;p&gt;在Medium看到Education in Blockchain and DLT: How to Acquire the Necessary Knowledge with a Workload of 10 Working Days的一篇博客，但是有很多网站和学习资料使我们不能访问的。基于此博客，制作了方便我们快速学习并掌握区块链必备知识的这篇文章。&lt;/p&gt;
&lt;p&gt;如果您喜欢本文，将其转发或分享（附上原文出处），我将非常高兴并表示感谢。&lt;br/&gt;也欢迎关注我的微信公众号：&lt;strong&gt;宇宙之一粟&lt;/strong&gt;，分享更多资料，与你读书学习精进。&lt;/p&gt;
&lt;blockquote readability=&quot;2.4478527607362&quot;&gt;
&lt;p&gt;参考博客： &lt;em&gt;Authors: Philipp Sandner, Jonas Groß&lt;/em&gt; ，&lt;a href=&quot;https://medium.com/@philippsandner/education-in-blockchain-how-to-acquire-the-necessary-knowledge-with-a-workload-of-10-working-days-9091dc8a3c53&quot;&gt;Education in Blockchain and DLT: How to Acquire the Necessary Knowledge with a Workload of 10 Working Days&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 16 Nov 2019 14:31:00 +0000</pubDate>
<dc:creator>宇宙之一粟</dc:creator>
<og:description>本文总结了诸多入门区块链的主要资源，博客、书籍和视频，希望帮你用7天时间获取必要的区块链基础知识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuzhou-1su/p/11874379.html</dc:identifier>
</item>
<item>
<title> 二叉搜索树BST(C语言实现可用) - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/11874342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/11874342.html</guid>
<description>&lt;h2&gt;1:概述&lt;/h2&gt;
&lt;p&gt;搜索树是一种可以进行插入，搜索，删除等操作的数据结构，可以用作字典或优先级队列。二叉搜索树是最简单的搜索树。其左子树的键值&amp;lt;=根节点的键值，右子树的键值&amp;gt;=根节点的键值。&lt;/p&gt;
&lt;p&gt;如果共有n个元素,那么每次操作需要的O(log n)的时间.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116221444358-104948468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;常用知识点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;满二叉树 : 一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。&lt;/li&gt;
&lt;li&gt;完全二叉树 : 而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^(k-1)个叶子节点，至多有2^k-1个节点。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.基本操作&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;查找(search)&lt;/li&gt;
&lt;li&gt;插入(insert)&lt;/li&gt;
&lt;li&gt;删除(remove)&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;3:操作原理&lt;/h2&gt;

&lt;h3&gt;查找&lt;/h3&gt;
&lt;p&gt;假设查找的值为x,从根节点的值开始比对,如果小于根节点的值,则往左儿子继续查找,如果大于根节点的值,则往右儿子继续查找.依次类推.直到当前节点的值等于要查找的值.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116221710139-820456640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　以查找数值10为例&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;p&gt;按照查找的步骤即可找到插入值应该在的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116221738666-1116951971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;以插入数值6为例&lt;/p&gt;
&lt;h3&gt;删除:&lt;/h3&gt;
&lt;p&gt;有四种情况:&lt;/p&gt;
&lt;p&gt;1: // 当前节点无左节点 ,右字节点7覆盖5, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116222014187-45905286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;: 3: // 当前节点无右节点 ,右字节点7覆盖5, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116222315859-1140500759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; : 4: // 删除节点5的左节点没有右节点, 只需要8作为3的右节点 ,3节点覆盖5&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116222023530-831245606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;: 2:  如果以上3中情况都没有,只需要寻找当前节点的左节点的所有字节点的最大值,用最大值填充5节点 4填充5&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1160484/201911/1160484-20191116222030245-944103675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;5:完整代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt; 
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; TNode{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode *&lt;span&gt;lt;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode *&lt;span&gt;rt;    
};
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode* insrtTree(&lt;span&gt;struct&lt;/span&gt; TNode *t,&lt;span&gt;int&lt;/span&gt; key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; printTree(&lt;span&gt;struct&lt;/span&gt; TNode *&lt;span&gt;root);
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode* delTree(&lt;span&gt;struct&lt;/span&gt; TNode* t,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;struct&lt;/span&gt; TNode* t,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key); 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; arr[&lt;span&gt;1000&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,t;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m); 
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode *root=&lt;span&gt;NULL;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;arr[i]); 
        root&lt;/span&gt;=&lt;span&gt;insrtTree(root,arr[i],i);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t=arr[m-1];&lt;/span&gt;
    
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    if(arr[m-1]==0){
        printf(&quot;Right child&quot;);
    }else{
        printf(&quot;Light child&quot;);
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    root&lt;/span&gt;=delTree(root,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    printTree(root);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;struct&lt;/span&gt; TNode* pt,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pt==NULL)&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;data==key)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;data&amp;gt;key) &lt;span&gt;return&lt;/span&gt; find(pt-&amp;gt;&lt;span&gt;lt,key);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;data&amp;lt;key) &lt;span&gt;return&lt;/span&gt; find(pt-&amp;gt;&lt;span&gt;rt,key);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除节点 &lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt; TNode* delTree(&lt;span&gt;struct&lt;/span&gt; TNode* pt,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pt==NULL)&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;data&amp;gt;key) pt-&amp;gt;lt=delTree(pt-&amp;gt;lt,key);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找左节点 &lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;data&amp;lt;key) pt-&amp;gt;rt=delTree(pt-&amp;gt;rt,key);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找右节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  找到节点 处理四种情况  &lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;lt==NULL){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点无左节点 &lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; TNode* curt=pt-&amp;gt;&lt;span&gt;rt;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pt);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curt;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;rt==NULL){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点无右节点 &lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; TNode* curt=pt-&amp;gt;&lt;span&gt;lt;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pt);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curt;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pt-&amp;gt;lt-&amp;gt;rt==NULL){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点的左节点无右节点 &lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; TNode* curt=pt-&amp;gt;&lt;span&gt;lt;
        curt&lt;/span&gt;-&amp;gt;rt=pt-&amp;gt;&lt;span&gt;rt;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pt);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curt;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以上不满足就把左儿子的子孙中最大的节点, 即右子树的右子树的...右子树, 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提到需要删除的节点位置&lt;/span&gt;
            &lt;span&gt;struct&lt;/span&gt; TNode*&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(p=pt-&amp;gt;lt;p-&amp;gt;rt-&amp;gt;rt!=NULL;p=p-&amp;gt;&lt;span&gt;rt);
            &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode* curt=p-&amp;gt;&lt;span&gt;lt;
            p&lt;/span&gt;-&amp;gt;rt=curt-&amp;gt;&lt;span&gt;rt;
            curt&lt;/span&gt;-&amp;gt;lt=pt-&amp;gt;&lt;span&gt;lt;
            curt&lt;/span&gt;-&amp;gt;rt=pt-&amp;gt;&lt;span&gt;rt;
            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curt;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pt;
}
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; TNode* insrtTree(&lt;span&gt;struct&lt;/span&gt; TNode *t,&lt;span&gt;int&lt;/span&gt; key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t==NULL){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理第一个节点 以及子节点为NULL情况 &lt;/span&gt;
        t=(&lt;span&gt;struct&lt;/span&gt; TNode*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; TNode));
        t&lt;/span&gt;-&amp;gt;lt=t-&amp;gt;rt=&lt;span&gt;NULL;
        t&lt;/span&gt;-&amp;gt;data=&lt;span&gt;key;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;data&amp;gt;key){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入左子树情况 &lt;/span&gt;
         arr[i]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        t&lt;/span&gt;-&amp;gt;lt=insrtTree(t-&amp;gt;&lt;span&gt;lt,key,i);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入右子树情况&lt;/span&gt;
        arr[i]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        t&lt;/span&gt;-&amp;gt;rt=insrtTree(t-&amp;gt;&lt;span&gt;rt,key,i);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; printTree(&lt;span&gt;struct&lt;/span&gt; TNode *&lt;span&gt;root){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root==NULL)&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,root-&amp;gt;&lt;span&gt;data);
    printTree(root&lt;/span&gt;-&amp;gt;&lt;span&gt;lt);
    printTree(root&lt;/span&gt;-&amp;gt;&lt;span&gt;rt);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明: 本身学习了 https://blog.csdn.net/li_l_il/article/details/88677927 但是完善了代码 &lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 14:27:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>1:概述 搜索树是一种可以进行插入，搜索，删除等操作的数据结构，可以用作字典或优先级队列。二叉搜索树是最简单的搜索树。其左子树的键值&amp;lt;=根节点的键值，右子树的键值&amp;gt;=根节点的键值。 如果共</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dgwblog/p/11874342.html</dc:identifier>
</item>
<item>
<title>.NET进阶篇06-async异步、thread多线程2 - 那是山</title>
<link>http://www.cnblogs.com/xibei/p/11874244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xibei/p/11874244.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;知识需要不断积累、总结和沉淀，思考和写作是成长的催化剂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;内容目录&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#hthread&quot;&gt;一、线程Thread&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h1&quot;&gt;1、生命周期&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h2&quot;&gt;2、后台线程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h3&quot;&gt;3、静态方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h1-1&quot;&gt;1.线程本地存储&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h2-1&quot;&gt;2.内存栅栏&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h4&quot;&gt;4、返回值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#hthreadpool&quot;&gt;二、线程池ThreadPool&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h1-2&quot;&gt;1、工作队列&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h2io&quot;&gt;2、工作线程和IO线程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h3thread&quot;&gt;3、和Thread区别&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xibei/p/11874244.html#h4-1&quot;&gt;4、定时器&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;hthread&quot;&gt;&lt;span&gt;一、线程Thread&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;.NET中线程操作封装为了Thread类，可以让开发者对线程进行直观操作。Thread提供了&lt;strong&gt;&lt;code&gt;实例方法用于管理线程的生命周期和静态方法用于控制线程的一些访问存储等一些外在的属性，相当于工作空间环境变量了&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h1&quot;&gt;&lt;span&gt;1、生命周期&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;线程的生命周期有&lt;strong&gt;&lt;code&gt;创建、启动、可能挂起、等待、恢复、异常、然后结束&lt;/code&gt;&lt;/strong&gt;。用Thread类可以容易控制一个线程的全生命周期&lt;/p&gt;
&lt;p&gt;Thread类的构造函数重载可以接受&lt;strong&gt;&lt;code&gt;ThreadStart无参数和ParameterizedThreadStart有参数的委托&lt;/code&gt;&lt;/strong&gt;，然后调用实例的&lt;strong&gt;&lt;code&gt;Start()方法&lt;/code&gt;&lt;/strong&gt;启动线程。Thread的构造函数的带有参数的委托，参数是一个object类型，因为我们可以传入任何信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;Thread t1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;新线程  {Thread.CurrentThread.ManagedThreadId.ToString(&quot;&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;)}&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;t1.Start();&lt;br/&gt;Thread t2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;新线程  {Thread.CurrentThread.ManagedThreadId.ToString(&quot;&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;)},参数 {obj.ToString()}&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;t2.Start(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程启动后，可以调用线程的&lt;strong&gt;&lt;code&gt;Suspend()&lt;/code&gt;&lt;/strong&gt;挂起线程，线程就会处于休眠状态（不继续执行线程内代码），调用&lt;strong&gt;&lt;code&gt;Resume()&lt;/code&gt;&lt;/strong&gt;唤醒线程，还有一个不太建议使用的&lt;strong&gt;&lt;code&gt;Abort()&lt;/code&gt;&lt;/strong&gt;通过抛出异常的方式来销毁线程，随后线程的状态就会变为AbortRequested&lt;/p&gt;
&lt;p&gt;常用的还有线程的等待，在主线程上启用工作线程后，有时需要等待工作线程的完成后，主线程才继续工作。可以调用实例方法&lt;strong&gt;&lt;code&gt;Join()&lt;/code&gt;&lt;/strong&gt;，当然我们可以传入时间参数来表明我主线程最多等你多久&lt;/p&gt;
&lt;h4 id=&quot;h2&quot;&gt;&lt;span&gt;2、后台线程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上一章我们知道Thread默认创建的是前台线程，&lt;strong&gt;&lt;code&gt;前台线程&lt;/code&gt;&lt;/strong&gt;会阻止系统进程的退出，&lt;strong&gt;&lt;code&gt;就是启动之后一定要完成任务的&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;code&gt;后台线程会伴随着进程的退出而退出&lt;/code&gt;&lt;/strong&gt;。通过设置属性IsBackground=true改为后台线程。另外还可以通过设置Priority指定线程的优先级。但这个并不总会如你所想设置了高优先级就一定最先执行。操作系统会优化调度，这也是线程不太好控制的原因之一&lt;/p&gt;
&lt;h4 id=&quot;h3&quot;&gt;&lt;span&gt;3、静态方法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上面介绍的都是Tread的实例方法，Thread还有一些常用静态方法。有时线程设置不当，会有些意想不到的的bug&lt;/p&gt;
&lt;h5 id=&quot;h1-1&quot;&gt;&lt;span&gt;1.线程本地存储&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;AllocateDataSlot和AllocateNamedDataSlot用于给所有线程分配一个数据槽。像下面例子所示，如果不在子线程中给数据槽中放入数据，是获取不到其他线程往里面放的数据。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; slot= Thread.AllocateNamedDataSlot(&lt;span class=&quot;hljs-string&quot;&gt;&quot;testSlot&quot;&lt;/span&gt;);&lt;br/&gt;Thread.SetData(slot, &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;);&lt;br/&gt;Thread t1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(() =&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = Thread.GetData(slot);&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;子线程：&lt;span class=&quot;hljs-subst&quot;&gt;{obj}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;t1.Start();&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj2 = Thread.GetData(slot);&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;主线程：&lt;span class=&quot;hljs-subst&quot;&gt;{obj2}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在声明数据槽的时候.NET提醒我们如果要更好的性能，请使用&lt;strong&gt;&lt;code&gt;ThreadStaticAttribute&lt;/code&gt;&lt;/strong&gt;标记字段。什么意思？我们来看下面这个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; LocalDataStoreSlot &lt;span class=&quot;hljs-title&quot;&gt;AllocateDataSlot&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中的如果不在静态字段上标记ThreadStatic输出结果就会一致。ThreadStatic标记&lt;strong&gt;&lt;code&gt;指示各线程的静态字段值是否唯一&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;ThreadStatic&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; name = &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;.Empty;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Function&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;kitty&quot;&lt;/span&gt;;&lt;br/&gt;Thread t1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(() =&amp;gt; {&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;子线程：&lt;span class=&quot;hljs-subst&quot;&gt;{name}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;t1.Start();&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;主线程：&lt;span class=&quot;hljs-subst&quot;&gt;{name}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个ThreadLocal提供线程数据的本地存储，用法和上面一样，在每个线程中声明数据仅供自己使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;ThreadLocal&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&amp;gt; local = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&amp;gt;() { };&lt;br/&gt;local.Value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;;&lt;br/&gt;Thread t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(() =&amp;gt; {&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;子线程：&lt;span class=&quot;hljs-subst&quot;&gt;{local.Value}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;t.Start();&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;主线程：&lt;span class=&quot;hljs-subst&quot;&gt;{local.Value}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的静态方法用于线程的本地存储TLS（Thread Local Storage）,Thread.Sleep方法在开发调试时也是经常用的，让线程挂起指定的时间来模拟耗时操作&lt;/p&gt;
&lt;h5 id=&quot;h2-1&quot;&gt;&lt;span&gt;2.内存栅栏&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;先说一个常识问题，为什么我们发布版本时候要用Release发布？Release更小更快，做了很多优化，但优化对我们是透明的（计算机里透明认为是个黑盒子，内部逻辑细节对我们不开放，和生活中透明意味着完全掌握了解不欺瞒刚好相反），一般优化不会影响程序的运行，我们先借用网上的一个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;bool isStop = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;Thread t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;bool isSuccess = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!isStop)&lt;br/&gt;{&lt;br/&gt;isSuccess = !isStop;&lt;br/&gt;}&lt;br/&gt;});&lt;br/&gt;t.Start();&lt;br/&gt;Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;isStop = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;t.Join();&lt;br/&gt;Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程执行结束&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子如果在debug下能正确执行完直到输出“主程序执行结束”，然而在release下却一直会等待子线程的完成。这里子线程中isStop一直为false。首先这是一个由多线程共享变量引起的问题，所以我们建议最好的解决办法就是&lt;strong&gt;&lt;code&gt;尽量不共享变量&lt;/code&gt;&lt;/strong&gt;，其次可以使用&lt;strong&gt;&lt;code&gt;Thread.MemoryBarrier和VolatileRead/Write&lt;/code&gt;&lt;/strong&gt;以及其他锁机制牺牲一点性能来换取数据的安全。（上面例子测试如果在子线程while中进行Console.writeLine操作，奇怪的发现release下也能正常输出了，猜测应该是进行了内存数据的更新）&lt;/p&gt;
&lt;p&gt;release优化会将t线程中的isStop变量的值加载到CPU Cache中，而主线程修改了isStop值在内存中，所以子线程拿不到更新后的值，造成数据不一致。那么解决办法就是取值时从内存中获取。Thread.MemoryBarrier()就可以让在此方法之前的内存写入都及时的从CPU Cache中更新到内存中，在此之后的内存读取都要从内存中获取，而不是CPU Cache。在例子中的while内增加Thread.MemoryBarrier()就能避免数据不一致问题。VolatileRead/Write是对MemoryBarrier的分开解释，从处理器读取，从处理器写入。&lt;/p&gt;
&lt;h4 id=&quot;h4&quot;&gt;&lt;span&gt;4、返回值&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;前面声明线程时，可以传递参数，那么想要有返回值该如何去做呢？Thread并没有提供返回值的操作，后面.NET给出的对Thead的高级封装给出了解决方案，直接使用即可。那目前我们使用thread类就要自己实现下带有返回值的线程操作，都是通过委托实现的，这里简单介绍一种，（共享外部变量也是可以，不建议）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;private Func&amp;lt;T&amp;gt; ThreadWithReturn&amp;lt;T&amp;gt;(Func&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;T t = &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;(T);&lt;br/&gt;Thread thread = &lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;br/&gt;{&lt;br/&gt;t = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;thread&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;thread.Join();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; t;&lt;br/&gt;};&lt;br/&gt;}&lt;br/&gt;Func&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; = &lt;span class=&quot;hljs-title&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThreadWithReturn&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;int&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-params&quot;&gt;(()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; DateTime.Now.Millisecond;&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; iResult = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Invoke&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hthreadpool&quot;&gt;&lt;span&gt;二、线程池ThreadPool&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;.NET起初提供Thread线程类，功能很丰富，API也很多，所以使用起来比较困难，况且线程还不都是很像理想中运行，所以从2.0开始提供了&lt;strong&gt;&lt;code&gt;ThreadPool&lt;/code&gt;&lt;/strong&gt;线程池静态类，全是静态方法，隐藏了诸多Thread的接口，让线程使用起来更轻松。&lt;strong&gt;&lt;code&gt;线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h1-2&quot;&gt;&lt;span&gt;1、工作队列&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;常用ThreadPool线程池静态方法&lt;strong&gt;&lt;code&gt;QueueUserWorkItem用于将方法排入线程池队列中执行&lt;/code&gt;&lt;/strong&gt;，如果线程池中有闲置线程就会执行，QueueUserWorkItem方法的参数可以指定一个回调函数委托并且传入参数，像下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;ThreadPool.QueueUserWorkItem(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj)&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;线程池中线程  {Thread.CurrentThread.ManagedThreadId.ToString(&quot;&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;)} ，传入 {obj.ToString()}&quot;&lt;/span&gt;);&lt;br/&gt;},&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h2io&quot;&gt;&lt;span&gt;2、工作线程和IO线程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;一般异步任务的执行，不涉及到网络文件等IO操作的，计算密集型，开发者来调用。而IO线程一般用在文件网络上，是CLR调用的，开发者无需管。工作线程发起文件访问调用，由驱动器完成后通知IO线程，IO线程则执行异步任务的回调函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/790441/201911/790441-20191116221208356-550735785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取和设置最小最大的工作线程和IO线程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;ThreadPool.GetMaxThreads(&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; workerThreads, &lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; completionPortThreads);&lt;br/&gt;ThreadPool.GetMinThreads(&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; workerThreads, &lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; completionPortThreads);&lt;br/&gt;ThreadPool.SetMaxThreads(&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;);&lt;br/&gt;ThreadPool.SetMinThreads(&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h3thread&quot;&gt;&lt;span&gt;3、和Thread区别&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如果计算机只有8个核，同时可以有8个任务运行。现在我们有10个任务需要运行，用Thread就需要创建10个线程，用ThreadPool可能只需要利用8个线程就行，&lt;strong&gt;&lt;code&gt;节约了空间和时间&lt;/code&gt;&lt;/strong&gt;。线程池中的线程默认先启动最小线程数量的线程，然后&lt;strong&gt;&lt;code&gt;根据需要增减数量&lt;/code&gt;&lt;/strong&gt;。线程池使用起来简单，但也有一些限制，线程池中的线程都是&lt;strong&gt;&lt;code&gt;后台线程，不能设置优先级，常用于耗时较短的任务&lt;/code&gt;&lt;/strong&gt;。线程池中线程也可以阻塞等待，利用ManualResetEvent去通知，但一般不会使用。&lt;/p&gt;
&lt;h4 id=&quot;h4-1&quot;&gt;&lt;span&gt;4、定时器&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;.NET中有很多可以实现定时器的功能，在ThreadPool中，我们可以利用&lt;strong&gt;&lt;code&gt;RegisterWaitForSingleObject&lt;/code&gt;&lt;/strong&gt;来注册一个指定时间的委托等待。像下面这样，将每隔一秒就输出消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;ThreadPool.RegisterWaitForSingleObject(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; AutoResetEvent(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;), &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; WaitOrTimerCallback(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj, b)&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;obj={obj},tid={Thread.CurrentThread.ManagedThreadId},datetime={DateTime.Now}&quot;&lt;/span&gt;);&lt;br/&gt;}),&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;,&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们平常见过比较多的还是&lt;strong&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/strong&gt;类，timer类在.net内是好几个地方都有的，在System.Threading、&lt;br/&gt;System.Timer、System.Windows.Form、System.Web.UI等里面都有Timer，后面都是在第一个System.Threading里的Timer扩展&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;System.Threading.Timer timer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; System.Threading.Timer(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;(obj)&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;obj={obj},tid={Thread.CurrentThread.ManagedThreadId},datetime={DateTime.Now}&quot;&lt;/span&gt;);&lt;br/&gt;},&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello kitty&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;timer的底层有一个TimerQueue，利用ThreadPool.UnsafeQueueUserWorkItem来完成定时功能，和上面我们使用的ThreadPool定时器有一点区别&lt;/p&gt;
&lt;p&gt;实际开发中，简单定时timer就够用，但一般业务场景比较复杂，需要定制个性化的定时器，比如每月几号执行，每月第几个星期几，几点执行，工作日执行等。因此我们使用&lt;strong&gt;&lt;code&gt;Quarz.NET&lt;/code&gt;&lt;/strong&gt;定时框架，后面框架整合时会用到，用起来也是很简单的&lt;/p&gt;
&lt;p&gt;先就啰嗦这两点吧，下一篇应该是Task、Parallel以及Async/Await，然后总结介绍下C#的线程模式、线程同步锁机制、异常处理，线程取消，线程安全集合和常见的线程问题&lt;/p&gt;
&lt;p&gt;天长水阔，见字如面，随缘更新，拜了个拜~&lt;/p&gt;
&lt;p&gt;&lt;sub&gt;可关注主页公号获取更多哈&lt;/sub&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 14:15:00 +0000</pubDate>
<dc:creator>那是山</dc:creator>
<og:description>知识需要不断积累、总结和沉淀，思考和写作是成长的催化剂 内容目录 一、线程Thread1、生命周期2、后台线程3、静态方法1.线程本地存储2.内存栅栏4、返回值二、线程池ThreadPool1、工作队</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xibei/p/11874244.html</dc:identifier>
</item>
</channel>
</rss>