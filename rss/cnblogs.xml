<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>往事不堪回首 - 世界游戏猪脚</title>
<link>http://www.cnblogs.com/CreatingV/p/13269024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreatingV/p/13269024.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200708201324036-1782990010.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开局一张图，内容全靠编&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从&lt;/span&gt;12&lt;span&gt;年大学毕业到如今，兜兜转转，依然在码工，码农，码代码的路上徘徊着，从最初的用&lt;/span&gt;&lt;span&gt;asp.net&lt;/span&gt;&lt;span&gt;写站点，写内部的&lt;/span&gt;&lt;span&gt;CRM&lt;/span&gt;&lt;span&gt;，内部管理系统，内部的&lt;/span&gt;&lt;span&gt;XXX&lt;/span&gt;&lt;span&gt;，很难想象内部的系统居然可以那么多。到如今的用着反编译工具，反编译者别人的作品，用着&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;组装着别人的功能进行调用，和古老的（老旧的版本的）&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;收集这&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;的数据，提供给&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;的支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200708201345474-7618185.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12&lt;span&gt;年，毕业前参加了招聘，得到了一个实习机会，也就是后来的第一家公司（其实楼主就待过&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;家公司，都没有达到楼主的同学们的数量的一半）。工作的内容没有太多可讲：无非就是三点，学着业务知识，扩充职业技能，脚踏实地编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;13&lt;span&gt;年，可以好景不长，楼主总是太闲逛了，逛网站，逛社区，年底居然被告知，你是最后的&lt;/span&gt;&lt;span&gt;10%&lt;/span&gt;&lt;span&gt;。（谁能明白我的心，可能是游戏打多了，没有精神，也可能是加班多了，没有自己的爱好了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;把加班之后打打游戏当成了自我安慰了，周六总是会在中午醒来吃饭）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;14&lt;span&gt;年，干完半年，辞职回老家了（把我剩下两个月的租房转租了出去，吃顿好的，准备回家），人生的路上，总是兜兜转转，回家了，又重新就业了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;15&lt;span&gt;年，还没怎么玩，就又就业了，当然生活水平降低了。（个中苦楚，小城市的苦恼有谁懂）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;20&lt;span&gt;年，又是一日如一日的，工作，今天&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;，明天&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，后天又来了一个&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;我都忘了，学了&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;又怎么样，&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;完全没用到，也许要过会儿才忘记。等忘记了，告诉你，&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;现在需要，之前学过，应该没问题吧。（打杂了几年，感觉自己就快废掉了。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间几年干什么，容我一一道来，做过微信公众号的网站，做过政府的网站，做过流媒体的服务，做过脚本群控，做过批量注册，做过半自动注册&lt;/span&gt;,...&lt;span&gt;做过一些无关紧要打打逆向破解的杂活，没办法，这样的公司，工作室而言全栈可能就是干杂活吧。偶尔我也会思考我都干了些什么，感觉也买了一些书，最后也就是买了一些书而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200708201353488-220309573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近解决了一个困扰我一两年的问题，结果居然是网上的教程，其中一环是错误的导致我一直编译成功，最后结果错误。在我向知识付费之后，问题居然奇迹的解决了，我也跟着从另外一种方案入手，居然成功了。&lt;/span&gt;Oh God&lt;span&gt;。之前也试验了几次，失败了，最后也放弃了。也许是，结婚之后带孩子，没有太多的时间自我研究了吧。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;已过而立，现在学习还晚么，有时候，遇见了一个知识，我想一晚上解决，一晚上搞定。感觉花一晚时间弄懂，应该是赚的，但是现在，已经刚不了呀。怎么办。。。明天再看吧&lt;/p&gt;
&lt;p&gt;只能说，有时候，真的是要从底层了解了，才真的了解了，了解了，就知道他为什么错，他为什么不错。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2090873/202007/2090873-20200708201438595-2010391500.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;砥砺初心&lt;/span&gt;，&lt;span&gt;不负韶华&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;初心是什么，也许我并没有自我审视过，或者现在的公司已经没有了初心，我就打打工，我咋知道有什么初心呢，无非就是多赚点钱，早点回家，早点退休，早点周游世界。&lt;/p&gt;
&lt;p&gt;美好的时光总是短暂的，但是也是弥足珍贵的。&lt;/p&gt;

&lt;p&gt;允许我自恋一下，我也想花点时间，作诗一首，陶冶情操。&lt;/p&gt;
&lt;p&gt;时光离骚了自我，&lt;/p&gt;
&lt;p&gt;风雨淡然了落寞。&lt;/p&gt;
&lt;p&gt;偶然间诗情万种，&lt;/p&gt;
&lt;p&gt;再回头韶华惜逝。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jul 2020 00:18:00 +0000</pubDate>
<dc:creator>世界游戏猪脚</dc:creator>
<og:description>开局一张图，内容全靠编 从12年大学毕业到如今，兜兜转转，依然在码工，码农，码代码的路上徘徊着，从最初的用asp.net写站点，写内部的CRM，内部管理系统，内部的XXX，很难想象内部的系统居然可以那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreatingV/p/13269024.html</dc:identifier>
</item>
<item>
<title>Alink漫谈(十) ：线性回归实现 之 数据预处理 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13282333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13282333.html</guid>
<description>&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和下文将介绍线性回归在Alink中是如何实现的，希望可以作为大家看线性回归代码的Roadmap。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;701.3035822097&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和下文将介绍线性回归在Alink中是如何实现的，希望可以作为大家看线性回归代码的Roadmap。&lt;/p&gt;
&lt;p&gt;因为Alink的公开资料太少，所以以下均为自行揣测，肯定会有疏漏错误，希望大家指出，我会随时更新。&lt;/p&gt;
&lt;p&gt;本系列目前已有十篇，欢迎大家指点&lt;/p&gt;
&lt;h2 id=&quot;0x01-概念&quot;&gt;0x01 概念&lt;/h2&gt;
&lt;h3 id=&quot;11-线性回归&quot;&gt;1.1 线性回归&lt;/h3&gt;
&lt;p&gt;线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w'x+e，e为误差服从均值为0的正态分布。&lt;/p&gt;
&lt;p&gt;在线性回归中，目标值与特征之间存在着线性相关的关系。即假设这个方程是一个线性方程，一个多元一次方程。&lt;/p&gt;
&lt;p&gt;基本形式：给定由 d 个属性描述的示例 ，线性模型试图学得一个通过属性的线性组合来进行预测的函数，即：&lt;/p&gt;
&lt;p&gt;\[f(x)=w_1x_1 +w_2x_2 ... +w_dx_d+b \]&lt;/p&gt;
&lt;p&gt;其中w为参数，也称为权重，可以理解为x1，x2...和 xd 对f(x)的影响度。&lt;/p&gt;
&lt;p&gt;一般形式为：&lt;/p&gt;
&lt;p&gt;\[f(x)=w^Tx+b \]&lt;/p&gt;
&lt;p&gt;假如我们依据这个公式来预测 f(x)，公式中的x是我们已知的，然而w，b的取值却不知道，只要我们把w，b的取值求解出来，模型就得以确定。我们就可以依据这个公式来做预测了。&lt;/p&gt;
&lt;p&gt;那么如何依据训练数据求解 w 和 b 的最优取值呢？关键是衡量 f 和 y 之间的差别。这就牵扯到另外一个概念：&lt;strong&gt;损失函数（Loss Function）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-优化模型&quot;&gt;1.2 优化模型&lt;/h3&gt;
&lt;p&gt;假如有一个模型 f(x)，如何判断这个模型是否优秀？这种定性的判断可以通过一个成为经验误差风险的数值来进行衡量，也就是模型 f 在所有训练样本上所犯错误的总和 E(x)。&lt;/p&gt;
&lt;p&gt;我们通过在训练集上最小化经验损失来训练模型。换言之，&lt;u&gt;通过调节 f 的参数 w&lt;/u&gt;，使得经验误差风险 E(x) 不断下降，最终达到最小值的时候，我们就获得了一个 “最优” 的模型。&lt;/p&gt;
&lt;p&gt;但是如果按照上面的定义，E(x) 是一组示性函数的和，因此是不连续不可导的函数，不易优化。为了解决这个问题，人们提出了&lt;strong&gt;“损失函数”&lt;/strong&gt;的概念。损失函数就是和误差函数有一定关系（比如是误差函数的上界），但是具有更好的数学性质（比如连续，可导，凸性等），比较容易进行优化。所以我们就可以对损失函数来优化。&lt;/p&gt;
&lt;p&gt;损失函数如果连续可导，所以我们可以用梯度下降法等一阶算法，也可以用牛顿法，拟牛顿法等二阶算法。当优化算法收敛后，我们就得到一个不错的模型。如果损失函数是一个凸函数，我们就可以得到最优模型。&lt;/p&gt;
&lt;p&gt;典型的优化方法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;一阶算法&lt;/th&gt;
&lt;th&gt;二阶算法&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;确定性算法&lt;/td&gt;
&lt;td&gt;梯度下降法 投影次梯度下降 近端梯度下降 Frank-Wolfe算法 Nesterov加速算法 坐标下降法 对偶坐标上升法&lt;/td&gt;
&lt;td&gt;牛顿法，拟牛顿法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;随机算法&lt;/td&gt;
&lt;td&gt;随机梯度下降法 随机坐标下降法 随机对偶坐标上升法 随机方差减小梯度法&lt;/td&gt;
&lt;td&gt;随机拟牛顿法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以我们可以知道，&lt;u&gt;优化LinearRegression模型 f 的手段一定是：确定损失函数，用 x，y 作为输入训练以求得损失函数最小值，从而确定 f 的参数 w&lt;/u&gt;。过程大致如下：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;处理输入，把 x, y 转换成算法需要的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;找一个合适的预测函数，一般表示为 &lt;strong&gt;h&lt;/strong&gt; 函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;构造一个Cost函数（损失函数），该函数表示预测的输出（&lt;strong&gt;h&lt;/strong&gt;）与训练数据类别（&lt;strong&gt;y&lt;/strong&gt;）之间的偏差，可以是二者之间的差（&lt;strong&gt;h-y&lt;/strong&gt;）或者是其他的形式。综合考虑所有训练数据的 “损失”，将Cost求和或者求平均，记为&lt;strong&gt;J(θ)&lt;/strong&gt;函数，表示所有训练数据预测值与实际类别的偏差。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;显然，损失函数 &lt;strong&gt;J(θ)&lt;/strong&gt; 函数的值越小表示预测函数越准确（即&lt;strong&gt;h&lt;/strong&gt;函数越准确），所以这一步需要做的是找到 &lt;strong&gt;J(θ)&lt;/strong&gt; 函数的最小值。注意，损失函数是关于 &lt;strong&gt;θ&lt;/strong&gt; 的函数！也就是说，对于损失函数来讲，&lt;strong&gt;θ&lt;/strong&gt;不再是函数的参数，而是损失函数的自变量！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;准备模型元数据，建立模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;13-损失函数目标函数&quot;&gt;1.3 损失函数&amp;amp;目标函数&lt;/h3&gt;
&lt;p&gt;先概括说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;损失函数：计算的是一个样本的误差；&lt;/li&gt;
&lt;li&gt;代价函数：是整个训练集上所有样本误差的平均，经常和损失函数混用；&lt;/li&gt;
&lt;li&gt;目标函数：代价函数 + 正则化项；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再详细阐释：&lt;/p&gt;
&lt;p&gt;假设我们用 f(X) 来拟合真实值Y。这个输出的f(X)与真实值Y可能是相同的，也可能是不同的，为了表示我们拟合的好坏，我们就用一个函数来度量拟合的程度。这个函数就称为损失函数(loss function)，或者叫代价函数(cost function)。&lt;/p&gt;
&lt;p&gt;损失函数用来衡量算法的运行情况，估量模型的预测值与真实值的不一致程度，是一个非负实值函数，通常使用 L(Y,f(x)) 来表示。损失函数越小，模型的鲁棒性就越好。损失函数是&lt;strong&gt;经验风险函数&lt;/strong&gt;的核心部分。&lt;/p&gt;
&lt;p&gt;目标函数是一个相关但更广的概念，对于目标函数来说在有约束条件下的最小化就是损失函数（loss function）。&lt;/p&gt;
&lt;p&gt;因为f(x)可能会过度学习历史数据，导致它在真正预测时效果会很不好，这种情况称为过拟合(over-fitting)。这样得到的函数会过于复杂。所以我们不仅要让经验风险最小化，还要让&lt;strong&gt;结构风险最小化&lt;/strong&gt;。这个时候就定义了一个函数 J(x)，这个函数专门用来度量&lt;strong&gt;模型的复杂度&lt;/strong&gt;，在机器学习中也叫正则化(regularization)。常用的有 L1, L2范数。&lt;/p&gt;
&lt;p&gt;到这一步我们就可以说我们最终的优化函数是：min(L(Y, f(x)) + J(x) ，即最优化经验风险和结构风险，而这个函数就被称为&lt;strong&gt;目标函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;在回归问题中，通过目标函数来求解最优解，常用的是平方误差（最小二乘线性回归）代价函数。损失函数则是平方损失函数&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;14-最小二乘法&quot;&gt;1.4 最小二乘法&lt;/h3&gt;
&lt;p&gt;均方误差是回归任务中最常用的性能度量，因此可以使均方误差最小。基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。在线性回归中，最小二乘法就是找到一条直线，使所有样本到直线的 &quot;欧式距离和&quot; 最小。于是&lt;u&gt;线性回归中损失函数就是平方损失函数&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;有了这些基础概念，下面我们就开始动手分析Alink的代码。&lt;/p&gt;
&lt;h2 id=&quot;0x02-示例代码&quot;&gt;0x02 示例代码&lt;/h2&gt;
&lt;p&gt;首先，我们给出线性回归的示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinearRegressionExample {
    static Row[] vecrows = new Row[] {
            Row.of(&quot;$3$0:1.0 1:7.0 2:9.0&quot;, &quot;1.0 7.0 9.0&quot;, 1.0, 7.0, 9.0, 16.8),
            Row.of(&quot;$3$0:1.0 1:3.0 2:3.0&quot;, &quot;1.0 3.0 3.0&quot;, 1.0, 3.0, 3.0, 6.7),
            Row.of(&quot;$3$0:1.0 1:2.0 2:4.0&quot;, &quot;1.0 2.0 4.0&quot;, 1.0, 2.0, 4.0, 6.9),
            Row.of(&quot;$3$0:1.0 1:3.0 2:4.0&quot;, &quot;1.0 3.0 4.0&quot;, 1.0, 3.0, 4.0, 8.0)
    };
    static String[] veccolNames = new String[] {&quot;svec&quot;, &quot;vec&quot;, &quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;label&quot;};
    static BatchOperator vecdata = new MemSourceBatchOp(Arrays.asList(vecrows), veccolNames);
    static StreamOperator svecdata = new MemSourceStreamOp(Arrays.asList(vecrows), veccolNames);

    public static void main(String[] args) throws Exception {
        String[] xVars = new String[] {&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;};
        String yVar = &quot;label&quot;;
        String vec = &quot;vec&quot;;
        String svec = &quot;svec&quot;;
        LinearRegression linear = new LinearRegression()
                .setLabelCol(yVar)  // 这里把变量都设置好了，后续会用到
                .setFeatureCols(xVars)
                .setPredictionCol(&quot;linpred&quot;);

        Pipeline pl = new Pipeline().add(linear);
        PipelineModel model = pl.fit(vecdata);

        BatchOperator result = model.transform(vecdata).select(
                new String[] {&quot;label&quot;, &quot;linpred&quot;});

        List&amp;lt;Row&amp;gt; data = result.collect();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;svec|vec|f0|f1|f2|label|linpred
----|---|--|--|--|-----|-------
$3$0:1.0 1:7.0 2:9.0|1.0 7.0 9.0|1.0000|7.0000|9.0000|16.8000|16.8148
$3$0:1.0 1:3.0 2:4.0|1.0 3.0 4.0|1.0000|3.0000|4.0000|8.0000|7.8521
$3$0:1.0 1:3.0 2:3.0|1.0 3.0 3.0|1.0000|3.0000|3.0000|6.7000|6.7739
$3$0:1.0 1:2.0 2:4.0|1.0 2.0 4.0|1.0000|2.0000|4.0000|6.9000|6.959
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据前文我们可以知道，在回归问题中，通过优化目标函数来求解最优解，常用的是平方误差（最小二乘线性回归）代价函数。损失函数则是平方损失函数。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;对应到Alink，优化函数或者优化器是拟牛顿法的L-BFGS算法，目标函数是UnaryLossObjFunc，损失函数是SquareLossFunc。线性回归训练总体逻辑是LinearRegTrainBatchOp。&lt;/u&gt;所以我们下面一一论述。&lt;/p&gt;
&lt;h2 id=&quot;0x03-整体概述&quot;&gt;0x03 整体概述&lt;/h2&gt;
&lt;p&gt;LinearRegression 训练 用到LinearRegTrainBatchOp，而LinearRegTrainBatchOp的基类是BaseLinearModelTrainBatchOp。所以我们来看BaseLinearModelTrainBatchOp。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinearRegression extends Trainer &amp;lt;LinearRegression, LinearRegressionModel&amp;gt; implements LinearRegTrainParams &amp;lt;LinearRegression&amp;gt;, LinearRegPredictParams &amp;lt;LinearRegression&amp;gt; {
   @Override
   protected BatchOperator train(BatchOperator in) {
      return new LinearRegTrainBatchOp(this.getParams()).linkFrom(in);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseLinearModelTrainBatchOp.linkFrom 代码如下，注释中给出了清晰的逻辑 ：&lt;/p&gt;
&lt;p&gt;大体是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取算法参数，label信息；&lt;/li&gt;
&lt;li&gt;准备，转换数据到 Tuple3 format &amp;lt;weight, label, feature vector&amp;gt;；&lt;/li&gt;
&lt;li&gt;获得统计信息，比如向量大小，均值和方差；&lt;/li&gt;
&lt;li&gt;对训练数据做标准化和插值；&lt;/li&gt;
&lt;li&gt;使用L-BFGS算法，通过对损失函数求最小值从而对模型优化；&lt;/li&gt;
&lt;li&gt;准备模型元数据；&lt;/li&gt;
&lt;li&gt;建立模型；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public T linkFrom(BatchOperator&amp;lt;?&amp;gt;... inputs) {
    BatchOperator&amp;lt;?&amp;gt; in = checkAndGetFirst(inputs);
    // Get parameters of this algorithm.
    Params params = getParams();
    // Get type of processing: regression or not
    boolean isRegProc = getIsRegProc(params, linearModelType, modelName);
    // Get label info : including label values and label type.
    Tuple2&amp;lt;DataSet&amp;lt;Object&amp;gt;, TypeInformation&amp;gt; labelInfo = getLabelInfo(in, params, isRegProc);
    // Transform data to Tuple3 format.//weight, label, feature vector.
    DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; initData = transform(in, params, labelInfo.f0, isRegProc);
    // Get statistics variables : including vector size, mean and variance of train data.
    Tuple2&amp;lt;DataSet&amp;lt;Integer&amp;gt;, DataSet&amp;lt;DenseVector[]&amp;gt;&amp;gt;
        statInfo = getStatInfo(initData, params.get(LinearTrainParams.STANDARDIZATION));
    // Do standardization and interception to train data.
    DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; trainData = preProcess(initData, params, statInfo.f1);
    // Solve the optimization problem.
    DataSet&amp;lt;Tuple2&amp;lt;DenseVector, double[]&amp;gt;&amp;gt; coefVectorSet = optimize(params, statInfo.f0,
        trainData, linearModelType, MLEnvironmentFactory.get(getMLEnvironmentId()));
    // Prepare the meta info of linear model.
    DataSet&amp;lt;Params&amp;gt; meta = labelInfo.f0
        .mapPartition(new CreateMeta(modelName, linearModelType, isRegProc, params))
        .setParallelism(1);
    // Build linear model rows, the format to be output.
    DataSet&amp;lt;Row&amp;gt; modelRows;
    String[] featureColTypes = getFeatureTypes(in, params.get(LinearTrainParams.FEATURE_COLS));
    modelRows = coefVectorSet
        .mapPartition(new BuildModelFromCoefs(labelInfo.f1,
            params.get(LinearTrainParams.FEATURE_COLS),
            params.get(LinearTrainParams.STANDARDIZATION),
            params.get(LinearTrainParams.WITH_INTERCEPT), featureColTypes))
        .withBroadcastSet(meta, META)
        .withBroadcastSet(statInfo.f1, MEAN_VAR)
        .setParallelism(1);
    // Convert the model rows to table.
    this.setOutput(modelRows, new LinearModelDataConverter(labelInfo.f1).getModelSchema());
    return (T)this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们后续还会对此逻辑进行细化。&lt;/p&gt;
&lt;h2 id=&quot;0x04-基础功能&quot;&gt;0x04 基础功能&lt;/h2&gt;
&lt;p&gt;我们首先介绍下相关基础功能和相关概念，比如损失函数，目标函数，梯度等。&lt;/p&gt;
&lt;h3 id=&quot;41-损失函数&quot;&gt;4.1 损失函数&lt;/h3&gt;
&lt;p&gt;损失函数涉及到若干概念。&lt;/p&gt;
&lt;h4 id=&quot;411-导数和偏导数&quot;&gt;4.1.1 导数和偏导数&lt;/h4&gt;
&lt;p&gt;导数也是函数，是函数的变化率与位置的关系。导数代表了在自变量变化趋于无穷小的时候，函数值的变化与自变量的变化的比值。几何意义是这个点的切线。物理意义是该时刻的（瞬时）变化率。&lt;/p&gt;
&lt;p&gt;导数反映的是函数y=f(x)在某一点处沿x轴正方向的变化率。直观地看，也就是在x轴上某一点处，如果f’(x)&amp;gt;0，说明f(x)的函数值在x点沿x轴正方向是趋于增加的；如果f’(x)&amp;lt;0，说明f(x)的函数值在x点沿x轴正方向是趋于减少的。&lt;/p&gt;
&lt;p&gt;一元导数表征的是：一元函数 f(x)与自变量 x 在某点附近变化的比率（变化率，斜率）。&lt;/p&gt;
&lt;p&gt;如果是多元函数呢？则为偏导数。偏导数是多元函数“退化”成一元函数时的导数，这里“退化”的意思是固定其他变量的值，只保留一个变量，依次保留每个变量，则N元函数有N个偏导数。偏导数为函数在每个位置处沿着自变量坐标轴方向上的导数（切线斜率）。二元函数的偏导数表征的是：函数 F(x,y) 与自变量 x（或y） 在某点附近变化的比率（变化率）。&lt;/p&gt;
&lt;h4 id=&quot;412-方向导数&quot;&gt;4.1.2 方向导数&lt;/h4&gt;
&lt;p&gt;导数和偏导数的定义中，均是沿坐标轴正方向讨论函数的变化率。那么当我们讨论函数沿任意方向的变化率时，也就引出了方向导数的定义，即：某一点在某一趋近方向上的导数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方向导数就是偏导数合成向量与方向向量的内积&lt;/strong&gt;。方向导数的本质是一个数值，简单来说其定义为：一个函数沿指定方向的变化率。&lt;/p&gt;
&lt;h4 id=&quot;413-hessian矩阵&quot;&gt;4.1.3 Hessian矩阵&lt;/h4&gt;
&lt;p&gt;在一元函数求解的问题中，我们可以很愉快的使用牛顿法求驻点。但在机器学习的优化问题中，我们要优化的都是多元函数，x往往不是一个实数，而是一个向量，所以将牛顿求根法利用到机器学习中时，x 是一个向量, y 也是一个向量，对 x 求导以后得到的是一个矩阵，就是Hessian矩阵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数学中，海森矩阵（Hessian matrix 或 Hessian）是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵&lt;/strong&gt;。&lt;strong&gt;多元函数的二阶导数就是一个海森矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;414-平方损失函数-in-alink&quot;&gt;4.1.4 平方损失函数 in Alink&lt;/h4&gt;
&lt;p&gt;前面提到，&lt;u&gt;线性回归中损失函数就是平方损失函数&lt;/u&gt;。我们来看看实现。后续实现将调用此类的 loss 和 derivative，具体遇到时候再讲。&lt;/p&gt;
&lt;p&gt;UnaryLossFunc是接口，代表一元损失函数。它定义的每个函数都有两个输入 (eta and y)，Alink把这两个输入的差作为损失函数的一元变量。基本API是求损失，求导数，求二阶导数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UnaryLossFunc extends Serializable {
        // Loss function.
        double loss(double eta, double y);
        // The derivative of loss function.
        double derivative(double eta, double y);
        // The second derivative of the loss function.
        double secondDerivative(double eta, double y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;平方损失函数具体实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SquareLossFunc implements UnaryLossFunc {

   @Override
   public double loss(double eta, double y) {
      return 0.5 * (eta - y) * (eta - y);
   }

   @Override
   public double derivative(double eta, double y) {
      return eta - y;
   }

   @Override
   public double secondDerivative(double eta, double y) {
      return 1;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-目标函数&quot;&gt;4.2 目标函数&lt;/h3&gt;
&lt;p&gt;这里涉及的概念是梯度，梯度下降法。&lt;/p&gt;
&lt;h4 id=&quot;421-梯度&quot;&gt;4.2.1 梯度&lt;/h4&gt;
&lt;p&gt;对于模型优化，我们要选择最优的 θ，使得 f(x) 最接近真实值。这个问题就转化为求解最优的 θ，使损失函数 J(θ) 取最小值。那么如何解决这个转化后的问题呢？这又牵扯到一个概念：&lt;strong&gt;梯度下降（Radient Descent）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我们首先要温习下梯度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向量的定义是有方向（direction）有大小（magnitude）的量。&lt;/li&gt;
&lt;li&gt;梯度其实是一个向量，即有方向有大小；其定义为：一个多元函数对于其自变量分别求偏导数，这些偏导数所组成的向量就是函数的梯度。&lt;/li&gt;
&lt;li&gt;梯度即函数在某一点最大的方向导数，函数沿梯度方向函数有最大的变化率。&lt;/li&gt;
&lt;li&gt;梯度的第一层含义就是&lt;strong&gt;“方向导数的最大值”&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当前位置的&lt;strong&gt;梯度方向&lt;/strong&gt;，为函数在该位置处&lt;strong&gt;方向导数最大的方向&lt;/strong&gt;，也是函数值&lt;strong&gt;上升最快的方向&lt;/strong&gt;，反方向为下降最快的方向；&lt;/li&gt;
&lt;li&gt;梯度的几何含义就是：沿向量所在直线的方向变化率最大。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;422-梯度下降法&quot;&gt;4.2.2 梯度下降法&lt;/h4&gt;
&lt;p&gt;梯度下降法是一个一阶最优化算法，它的核心思想是：要想最快找到一个函数的局部极小值，必须沿函数当前点对应“梯度”（或者近似梯度）的反方向（下降）进行规定步长“迭代”搜索。&lt;strong&gt;沿梯度（斜率）的反方向移动&lt;/strong&gt;，这就是&lt;strong&gt;“梯度下降法”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;既然在变量空间的某一点处，函数沿梯度方向具有最大的变化率，那么在优化目标函数的时候，自然是沿着负梯度方向去减小函数值，以此达到我们的优化目标。&lt;/p&gt;
&lt;p&gt;梯度下降中的下降，意思是让函数的未知数随着梯度的方向运动。什么是梯度的方向呢？把这一点带入到梯度函数中，结果为正，那我们就把这一点的值变小一些，同时就是让梯度变小些；当这一点带入梯度函数中的结果为负的时候，就给这一点的值增大一些。&lt;/p&gt;
&lt;p&gt;如何沿着负梯度方向减小函数值呢？既然梯度是偏导数的集合，同时梯度和偏导数都是向量，那么参考向量运算法则，&lt;u&gt;我们在每个变量轴上减小对应变量值即可&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;梯度下降就是让梯度中所有偏导函数都下降到最低点的过程.(划重点:下降)。都下降到最低点了,那每个未知数(或者叫维度)的最优解就得到了，所以他是解决函数最优化问题的算法。&lt;/p&gt;
&lt;p&gt;“最小二乘法”和“梯度下降法”，前者用于“搜索最小误差”，后者用于“用最快的速度搜索”，二者常常配合使用。对最小二乘法的参数调优就转变为了求这个二元函数的极值问题，也就是说可以应用“梯度下降法”了。&lt;/p&gt;
&lt;p&gt;在最小二乘函数中，已拥有的条件是一些样本点和样本点的结果，就是矩阵X和每一条X样本的lable值y。X是矩阵，y是向量。所以我们要知道，&lt;u&gt;梯度下降中求偏导数的未知数不是x和y，而是x的参数w&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;423-目标函数-in-alink&quot;&gt;4.2.3 目标函数 in Alink&lt;/h4&gt;
&lt;p&gt;目标函数的基类是OptimObjFunc，其提供API 比如计算梯度，损失，hessian矩阵，以及依据采样点更新梯度和hessian矩阵。 其几个派生类如下，从注释中可以看到使用范围。&lt;/p&gt;
&lt;p&gt;我们可以看到正则化(regularization) L1, L2范数，这是相比损失函数增加的模块。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class OptimObjFunc implements Serializable {
    protected final double l1;
    protected final double l2; // 正则化(regularization) L1, L2范数。
    protected Params params;   
  .....
}

// Unary loss object function.
public class UnaryLossObjFunc extends OptimObjFunc

// The OptimObjFunc for multilayer perceptron.
public class AnnObjFunc extends OptimObjFunc
  
// Accelerated failure time Regression object function.
public class AftRegObjFunc extends OptimObjFunc

// Softmax object function.
public class SoftmaxObjFunc extends OptimObjFunc 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于线性模型，BaseLinearModelTrainBatchOp 中会根据模型类型来生成目标函数，可以看到在生成目标函数同时，也相应设置了不同的损失函数，其中 SquareLossFunc 就是我们之前提到的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static OptimObjFunc getObjFunction(LinearModelType modelType, Params params) {
    OptimObjFunc objFunc;
    // For different model type, we must set corresponding loss object function.
    switch (modelType) {
        case LinearReg:
            // 我们这里！
            objFunc = new UnaryLossObjFunc(new SquareLossFunc(), params);
            break;
        case SVR:
            double svrTau = params.get(LinearSvrTrainParams.TAU);
            objFunc = new UnaryLossObjFunc(new SvrLossFunc(svrTau), params);
            break;
        case LR:
            objFunc = new UnaryLossObjFunc(new LogLossFunc(), params);
            break;
        case SVM:
            objFunc = new UnaryLossObjFunc(new SmoothHingeLossFunc(), params);
            break;
        case Perceptron:
            objFunc = new UnaryLossObjFunc(new PerceptronLossFunc(), params);
            break;
        case AFT:
            objFunc = new AftRegObjFunc(params);
            break;
        default:
            throw new RuntimeException(&quot;Not implemented yet!&quot;);
    }
    return objFunc;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;424-一元目标函数-in-alink&quot;&gt;4.2.4 一元目标函数 in Alink&lt;/h4&gt;
&lt;p&gt;一元目标函数就是我们线性回归用到的目标函数，其只有一个新增变量 ：unaryLossFunc。就是一元损失函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Unary loss object function.
 */
public class UnaryLossObjFunc extends OptimObjFunc {
    private UnaryLossFunc unaryLossFunc;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一元目标函数提供了很多功能，我们这里用到主要是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;calcGradient ：根据一组采样点计算梯度，这是从基类OptimObjFunc集成的。&lt;/li&gt;
&lt;li&gt;updateGradient ：根据一个采样点更新梯度；&lt;/li&gt;
&lt;li&gt;calcSearchValues ：为线性搜索计算损失；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;4241-依据一组采样点计算梯度&quot;&gt;4.2.4.1 依据一组采样点计算梯度&lt;/h4&gt;
&lt;p&gt;对于本文，这里更新的是损失函数的梯度。&lt;/p&gt;
&lt;p&gt;再次啰嗦下，损失函数用来度量拟合的程度，从而评估模型拟合的好坏，记为 &lt;em&gt;&lt;strong&gt;J(θ)&lt;/strong&gt;&lt;/em&gt;。注意，损失函数是关于 &lt;strong&gt;θ&lt;/strong&gt; 的函数！也就是说，对于损失函数来讲，&lt;strong&gt;θ&lt;/strong&gt;不再是函数的参数，而是损失函数的自变量！&lt;/p&gt;
&lt;p&gt;当我们计算损失时，是将每个样本中的特征 &lt;em&gt;&lt;strong&gt;xi&lt;/strong&gt;&lt;/em&gt; 和对应的目标变量真实值 &lt;em&gt;&lt;strong&gt;yi&lt;/strong&gt;&lt;/em&gt; 带入损失函数，此时，损失函数中就只剩下 &lt;strong&gt;θ&lt;/strong&gt; 是未知的。&lt;/p&gt;
&lt;p&gt;损失函数的梯度即对 &lt;strong&gt;θi&lt;/strong&gt; 求偏导，由于损失函数是关于 &lt;strong&gt;θ&lt;/strong&gt; 的函数，因此，&lt;strong&gt;θ&lt;/strong&gt; 的取值不同，得出来的的梯度向量也是不同的。借用“下山”的比喻来解释，&lt;strong&gt;θ&lt;/strong&gt; 的不同取值，相当于处于山上的不同位置，每一个位置都会计算出一个梯度向量▽J(θ)。&lt;/p&gt;
&lt;p&gt;这里的 l1, l2 就是之前提到的正则化(regularization) L1, L2范数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Calculate gradient by a set of samples.
 *
 * @param labelVectors train data.
 * @param coefVector   coefficient of current time.
 * @param grad         gradient.
 * @return weight sum
 */
public double calcGradient(Iterable&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; labelVectors,
                           DenseVector coefVector, DenseVector grad) {
    double weightSum = 0.0;
    for (int i = 0; i &amp;lt; grad.size(); i++) {
        grad.set(i, 0.0);
    }
  
// 对输入的样本集合labelVectors逐个计算梯度  
    for (Tuple3&amp;lt;Double, Double, Vector&amp;gt; labelVector : labelVectors) {
        if (labelVector.f2 instanceof SparseVector) {
           ((SparseVector)(labelVector.f2)).setSize(coefVector.size());
        }
      
// 以这个样本为例 
labelVector = {Tuple3@9895} &quot;(1.0,16.8,1.0 1.0 1.4657097546055162 1.4770978917519928)&quot;
 f0 = {Double@9903} 1.0
 f1 = {Double@9904} 16.8
 f2 = {DenseVector@9905} &quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot;
  
        weightSum += labelVector.f0; // labelVector.f0是权重
        updateGradient(labelVector, coefVector, grad);
    }
    if (weightSum &amp;gt; 0.0) {
        grad.scaleEqual(1.0 / weightSum);
    }
// l2正则化    
    if (0.0 != this.l2) {
        grad.plusScaleEqual(coefVector, this.l2 * 2);
    }
// l1正则化   
    if (0.0 != this.l1) {
        double[] coefArray = coefVector.getData();
        for (int i = 0; i &amp;lt; coefVector.size(); i++) {
            grad.add(i, Math.signum(coefArray[i]) * this.l1);
        }
    }
    return weightSum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4242-根据一个采样点更新梯度&quot;&gt;4.2.4.2 根据一个采样点更新梯度&lt;/h4&gt;
&lt;p&gt;这里 labelVector.f0是权重，labelVector.f1是 y，labelVector.f2是 x-vec 四维向量，coefVector是w系数向量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getEta是点积，即 x向量 与 当前w系数的点积，就是当前计算的 y。&lt;/li&gt;
&lt;li&gt;labelVector.f0 * unaryLossFunc.derivative(eta, labelVector.f1); 就是调用SquareLossFunc.derivative 函数来计算一阶导数。&lt;/li&gt;
&lt;li&gt;updateGrad.plusScaleEqual(labelVector.f2, div); 就是在原有梯度基础上更新梯度&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UnaryLossObjFunc extends OptimObjFunc {
    /**
     * Update gradient by one sample.
     *
     * @param labelVector a sample of train data.
     * @param coefVector  coefficient of current time.
     * @param updateGrad  gradient need to update.
     */
    @Override
    protected void updateGradient(Tuple3&amp;lt;Double, Double, Vector&amp;gt; labelVector, DenseVector coefVector, DenseVector updateGrad) {
        // 点积，就是当前计算出来的y
        double eta = getEta(labelVector, coefVector); 
        // 一阶导数。labelVector.f0是权重
        double div = labelVector.f0 * unaryLossFunc.derivative(eta, labelVector.f1); 
        // 点乘之后还需要相加。labelVector.f2 就是x—vec，比如 1.0 1.0 1.4657097546055162 1.4770978917519928
        updateGrad.plusScaleEqual(labelVector.f2, div);
    }
  
    private double getEta(Tuple3&amp;lt;Double, Double, Vector&amp;gt; labelVector, DenseVector coefVector) {
        // 点积，表示第 i 次迭代中节点上的第 k 个特征向量与特征权重分量的点乘。coefVector中第 c 项表示为第 i 次迭代中特征权重向量在第 c 列节点上的分量
        return MatVecOp.dot(labelVector.f2, coefVector);
    }
}

/**
* Plus with another vector scaled by &quot;alpha&quot;.
*/
public void plusScaleEqual(Vector other, double alpha) {
        if (other instanceof DenseVector) {
                BLAS.axpy(alpha, (DenseVector) other, this);
        } else {
                BLAS.axpy(alpha, (SparseVector) other, this);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43-优化函数&quot;&gt;4.3 优化函数&lt;/h3&gt;
&lt;p&gt;Alink中提供给了一系列并行优化函数，比如GD, SGD, LBFGS, OWLQN, NEWTON method。&lt;/p&gt;
&lt;p&gt;其基类是Optimizer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Optimizer {
    protected final DataSet&amp;lt;?&amp;gt; objFuncSet; // 具体目标函数，计算梯度和损失
    protected final DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; trainData; //训练数据
    protected final Params params; //参数
    protected DataSet&amp;lt;Integer&amp;gt; coefDim; //dimension of features.
    protected DataSet&amp;lt;DenseVector&amp;gt; coefVec = null; //最终系数w
    .......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线性回归主要用到了LBFGS算法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Lbfgs extends Optimizer 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体调用如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static DataSet&amp;lt;Tuple2&amp;lt;DenseVector, double[]&amp;gt;&amp;gt; optimize(.....) {
    // Loss object function
    DataSet&amp;lt;OptimObjFunc&amp;gt; objFunc = session.getExecutionEnvironment()
        .fromElements(getObjFunction(modelType, params));

    if (params.contains(LinearTrainParams.OPTIM_METHOD)) {
        LinearTrainParams.OptimMethod method = params.get(LinearTrainParams.OPTIM_METHOD);
        return OptimizerFactory.create(objFunc, trainData, coefficientDim, params, method).optimize();
    } else if (params.get(HasL1.L_1) &amp;gt; 0) {
        return new Owlqn(objFunc, trainData, coefficientDim, params).optimize();
    } else {
        // 我们的程序将运行到这里
        return new Lbfgs(objFunc, trainData, coefficientDim, params).optimize();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;机器学习基本优化套路是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;准备数据 ----&amp;gt; 优化函数 ----&amp;gt; 目标函数 ----&amp;gt; 损失函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应我们这里是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;BaseLinearModelTrainBatchOp.linkFrom(整体逻辑) -----&amp;gt; Lbfgs(继承Optimizer) ----&amp;gt; UnaryLossObjFunc(继承OptimObjFunc) ----&amp;gt; SquareLossFunc(继承UnaryLossFunc)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-数据准备&quot;&gt;0x05 数据准备&lt;/h2&gt;
&lt;p&gt;看完完底层功能，我们再次回到线性回归总体流程。&lt;/p&gt;
&lt;p&gt;总结 BaseLinearModelTrainBatchOp.linkFrom 的基本流程如下：(发现某些媒体对于列表排版支持不好，所以加上序号)。&lt;/p&gt;
&lt;p&gt;首先再给出输入一个例子：&lt;code&gt;Row.of(&quot;$3$0:1.0 1:7.0 2:9.0&quot;, &quot;1.0 7.0 9.0&quot;, 1.0, 7.0, 9.0, 16.8),&lt;/code&gt;这里后面 4 项对应列名是 &lt;code&gt;&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;label&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1)&lt;u&gt;获取到label的信息，包括label数值和种类&lt;/u&gt;。 labelInfo = getLabelInfo() 这里有一个 distinct 操作，所以会去重。最后得到label的可能取值范围 ：0，1，类型是 Double。&lt;/li&gt;
&lt;li&gt;2)用transform函数把输入转换成三元组Tuple3&amp;lt;weight, label, feature vector&amp;gt;。具体说，会把输入中的三个特征&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot; 转换为一个向量 vec, 我们以后称之为x-vec。重点就在于特征变成了一个向量。所以这个三元组可以认为是 &lt;strong&gt;&lt;u&gt;&amp;lt;权重, y-value, x-vec&amp;gt;&lt;/u&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;3)用statInfo = getStatInfo() &lt;u&gt;获取统计变量，包括vector size, mean和variance&lt;/u&gt;。这里流程比较复杂。
&lt;ul&gt;&lt;li&gt;3.1)用trainData.map{return value.f2;}来获取训练数据中的 x-vec。&lt;/li&gt;
&lt;li&gt;3.2)调用StatisticsHelper.summary来对 x-vec 做处理
&lt;ul&gt;&lt;li&gt;3.2.1)调用 summarizer
&lt;ul&gt;&lt;li&gt;3.2.1.1)调用 mapPartition(new VectorSummarizerPartition(bCov))
&lt;ul&gt;&lt;li&gt;3.2.1.1.1)调用VectorSummarizerPartition.mapPartition，其遍历列表，列表中的每一个变量 sv 是 x-vec。srt = srt.visit(sv)，会根据每一个新输入重新计算count，sum，squareSum，normL1..，这样就得到了本partiton中输入每列的这些统计数值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.2.1.2)调用 reduce(VectorSummarizerUtil.merge(value1, value2)) 来归并每一个partition的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.2.2)调用map(BaseVectorSummarizer summarizer)，其实调用到DenseVectorSummarizer，就是生成一个DenseVectorSummary向量，里面是count，sum，squareSum，normL1，min，max，numNonZero。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.3)调用 coefficientDim = summary.map&lt;/li&gt;
&lt;li&gt;3.4)调用 meanVar = coefficientDim.map，最后得到 Tuple2.of(coefficientDim, meanVar)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4)preProcess(initData, params, statInfo.f1) &lt;u&gt;用3) 计算的结果 对输入数据做标准化和插值 standardization and interception&lt;/u&gt;。上面得到的 meanVar 将会作为参数传入。这里是对 x-vec 做标准化。比如原始输入Row是&quot;(1.0,16.8,1.0 7.0 9.0)&quot;，其中 x-vec 是&quot;1.0 7.0 9.0&quot;，&lt;u&gt;进行标准化之后，x-vec 变成了 4 项&lt;/u&gt; ：{ 第1项是固定值 &quot;1.0 &quot;， 所以4 项 是 &quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot; }，所以转换后的Row是&quot;(1.0,16.8,1.0 1.0 1.4657097546055162 1.4770978917519928)&quot;。即weight 是1.0，y-value是16.8，后续4个是x-vec。&lt;/li&gt;
&lt;li&gt;以上完成了对数据的处理。&lt;/li&gt;
&lt;li&gt;5)调用 optimize(params, statInfo.f0, trainData, linearModelType) 通过对损失函数求最小值从而对模型优化。(使用L-BFGS算法，会单独拿出来讲解)&lt;/li&gt;
&lt;li&gt;6)调用 mapPartition(new CreateMeta()) 来准备模型元数据。&lt;/li&gt;
&lt;li&gt;7)调用 mapPartition(new BuildModelFromCoefs) 来建立模型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到，数据准备占据了很大部分，下面我们看看数据准备的几个步骤。&lt;/p&gt;
&lt;h3 id=&quot;51-获取label信息&quot;&gt;5.1 获取label信息&lt;/h3&gt;
&lt;p&gt;此处代码对应上面基本流程的 1)&lt;/p&gt;
&lt;p&gt;因为之前有一个distinct操作，所以会去重。最后得到label的可能取值范围 ：0，1，类型是 Double。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Tuple2&amp;lt;DataSet&amp;lt;Object&amp;gt;, TypeInformation&amp;gt; getLabelInfo(BatchOperator in,
                                                                  Params params,
                                                                  boolean isRegProc) {
        String labelName = params.get(LinearTrainParams.LABEL_COL);
        // Prepare label values
        DataSet&amp;lt;Object&amp;gt; labelValues;
        TypeInformation&amp;lt;?&amp;gt; labelType = null;
        if (isRegProc) {
            // 因为是回归，所以是这里
            labelType = Types.DOUBLE;
            labelValues = MLEnvironmentFactory.get(in.getMLEnvironmentId())
                .getExecutionEnvironment().fromElements(new Object());
        } else {
          .....
        }
        return Tuple2.of(labelValues, labelType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-把输入转换成三元组&quot;&gt;5.2 把输入转换成三元组&lt;/h3&gt;
&lt;p&gt;此处代码对应上面基本流程的 2) 。&lt;/p&gt;
&lt;p&gt;用transform函数把输入转换成三元组Tuple3&amp;lt;weight, label, feature vector&amp;gt;。具体说，会把输入中的三个特征&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot; 转换为一个向量 vec, 我们以后称之为x-vec。重点就在于特征变成了一个向量。所以这个三元组可以认为是 &lt;u&gt;&lt;strong&gt;&amp;lt;权重, y-value, x-vec&amp;gt;&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; transform(BatchOperator in,
                                                          Params params,
                                                          DataSet&amp;lt;Object&amp;gt; labelValues,
                                                          boolean isRegProc) {
    ......
    // 获取Schema
    TableSchema dataSchema = in.getSchema();
    // 获取各种index 
    int labelIdx = TableUtil.findColIndexWithAssertAndHint(dataSchema.getFieldNames(), labelName);
    ......
    int weightIdx = weightColName != null ? TableUtil.findColIndexWithAssertAndHint(in.getColNames(), weightColName) : -1;
    int vecIdx = vectorColName != null ? TableUtil.findColIndexWithAssertAndHint(in.getColNames(), vectorColName) : -1;
    // 用transform函数把输入转换成三元组Tuple3&amp;lt;weight, label, feature vector&amp;gt;
    return in.getDataSet().map(new Transform(isRegProc, weightIdx, vecIdx, featureIndices, labelIdx)).withBroadcastSet(labelValues, LABEL_VALUES);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对应的变量打印出来为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;params = {Params@2745} &quot;Params {featureCols=[&quot;f0&quot;,&quot;f1&quot;,&quot;f2&quot;], labelCol=&quot;label&quot;, predictionCol=&quot;linpred&quot;}&quot;
labelValues = {DataSource@2845} 
isRegProc = true
featureColNames = {String[3]@2864} 
 0 = &quot;f0&quot;
 1 = &quot;f1&quot;
 2 = &quot;f2&quot;
labelName = &quot;label&quot;
weightColName = null
vectorColName = null
dataSchema = {TableSchema@2866} &quot;root\n |-- svec: STRING\n |-- vec: STRING\n |-- f0: DOUBLE\n |-- f1: DOUBLE\n |-- f2: DOUBLE\n |-- label: DOUBLE\n&quot;
featureIndices = {int[3]@2878} 
 0 = 2
 1 = 3
 2 = 4
labelIdx = 5
weightIdx = -1
vecIdx = -1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体在runtime时候，会进入到Transform.map函数。我们可以看到，会把输入中的三个特征&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;,转换为一个向量 vec, 我们以后称之为x-vec。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class Transform extends RichMapFunction&amp;lt;Row, Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; {
    @Override
    public Tuple3&amp;lt;Double, Double, Vector&amp;gt; map(Row row) throws Exception {
        // 获取权重
        Double weight = weightIdx != -1 ? ((Number)row.getField(weightIdx)).doubleValue() : 1.0;
        // 获取label
        Double val = FeatureLabelUtil.getLabelValue(row, this.isRegProc,
            labelIdx, this.positiveLableValueString);
        if (featureIndices != null) {
            // 获取x-vec
            DenseVector vec = new DenseVector(featureIndices.length);
            for (int i = 0; i &amp;lt; featureIndices.length; ++i) {
                vec.set(i, ((Number)row.getField(featureIndices[i])).doubleValue());
            }
            // 构建三元组
            return Tuple3.of(weight, val, vec);
        } else {
            Vector vec = VectorUtil.getVector(row.getField(vecIdx));
            return Tuple3.of(weight, val, vec);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对应原始输入 &lt;code&gt;Row.of(&quot;$3$0:1.0 1:7.0 2:9.0&quot;, &quot;1.0 7.0 9.0&quot;, 1.0, 7.0, 9.0, 16.8),&lt;/code&gt; ，则程序中各种变量为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;row = {Row@9723} &quot;$3$0:1.0 1:7.0 2:9.0,1.0 7.0 9.0,1.0,7.0,9.0,16.8&quot;
weight = {Double@9724} 1.0
val = {Double@9725} 16.8
vec = {DenseVector@9729} &quot;1.0 7.0 9.0&quot;
vecIdx = -1
featureIndices = {int[3]@9726} 
 0 = 2
 1 = 3
 2 = 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;53-获取统计变量&quot;&gt;5.3 获取统计变量&lt;/h3&gt;
&lt;p&gt;用getStatInfo() 对输入数据做标准化和插值 standardization and interception。&lt;/p&gt;
&lt;p&gt;此处代码对应上面基本流程的 3)&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;用statInfo = getStatInfo() 获取统计变量，包括vector size, mean和variance。这里流程比较复杂。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1)用trainData.map{return value.f2;}来获取训练数据中的 x-vec。&lt;/li&gt;
&lt;li&gt;3.2)调用StatisticsHelper.summary来对 x-vec 做处理
&lt;ul&gt;&lt;li&gt;3.2.1)调用 summarizer
&lt;ul&gt;&lt;li&gt;3.2.1.1)调用 mapPartition(new VectorSummarizerPartition(bCov))
&lt;ul&gt;&lt;li&gt;3.2.1.1.1)调用VectorSummarizerPartition.mapPartition，其遍历列表，列表中的每一个变量 sv 是 x-vec。srt = srt.visit(sv)，会根据每一个新输入重新计算count，sum，squareSum，normL1..，这样就得到了本partiton中输入每列的这些统计数值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.2.1.2)调用 reduce(VectorSummarizerUtil.merge(value1, value2)) 来归并每一个partition的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.2.2)调用map(BaseVectorSummarizer summarizer)，其实调用到DenseVectorSummarizer，就是生成一个DenseVectorSummary向量，里面是count，sum，squareSum，normL1，min，max，numNonZero。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.3)调用 coefficientDim = summary.map&lt;/li&gt;
&lt;li&gt;3.4)调用 meanVar = coefficientDim.map，最后得到 Tuple2.of(coefficientDim, meanVar)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Tuple2&amp;lt;DataSet&amp;lt;Integer&amp;gt;, DataSet&amp;lt;DenseVector[]&amp;gt;&amp;gt; getStatInfo(
    DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; trainData, final boolean standardization) {
    if (standardization) {
        DataSet&amp;lt;BaseVectorSummary&amp;gt; summary = StatisticsHelper.summary(trainData.map(
            new MapFunction&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;, Vector&amp;gt;() {
                @Override
                public Vector map(Tuple3&amp;lt;Double, Double, Vector&amp;gt; value) throws Exception {
                    return value.f2; //获取训练数据中的 x-vec
                }
            }).withForwardedFields());

        DataSet&amp;lt;Integer&amp;gt; coefficientDim = summary.map(new MapFunction&amp;lt;BaseVectorSummary, Integer&amp;gt;() {
            public Integer map(BaseVectorSummary value) throws Exception {
                return value.vectorSize(); // 获取dimension
            }
        });

        DataSet&amp;lt;DenseVector[]&amp;gt; meanVar = summary.map(new MapFunction&amp;lt;BaseVectorSummary, DenseVector[]&amp;gt;() {
            public DenseVector[] map(BaseVectorSummary value) {
                if (value instanceof SparseVectorSummary) {
                    // 计算min, max
                    DenseVector max = ((SparseVector)value.max()).toDenseVector();
                    DenseVector min = ((SparseVector)value.min()).toDenseVector();
                    for (int i = 0; i &amp;lt; max.size(); ++i) {
                        max.set(i, Math.max(Math.abs(max.get(i)), Math.abs(min.get(i))));
                        min.set(i, 0.0);
                    }
                    return new DenseVector[] {min, max};
                } else {
                    // 计算standardDeviation
                    return new DenseVector[] {(DenseVector)value.mean(),
                        (DenseVector)value.standardDeviation()};
                }
            }
        });
        return Tuple2.of(coefficientDim, meanVar);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;54-对输入数据做标准化和插值&quot;&gt;5.4 对输入数据做标准化和插值&lt;/h3&gt;
&lt;p&gt;这里对应基本流程的 4) 。&lt;/p&gt;
&lt;p&gt;对输入数据做标准化和插值 standardization and interception。上面得到的 meanVar 作为参数传入。这里是对 x-vec 做标准化。&lt;/p&gt;
&lt;p&gt;比如原始输入Row是&lt;code&gt;&quot;(1.0,16.8,1.0 7.0 9.0)&quot;&lt;/code&gt;，其中 x-vec 是&lt;code&gt;&quot;1.0 7.0 9.0&quot;&lt;/code&gt;，进行标准化之后，x-vec 变成了 4 项，第一项是固定值 &quot;1.0 &quot;， 4 项 是 &lt;code&gt;&quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot;&lt;/code&gt;，所以转换后的Row是&lt;code&gt;&quot;(1.0,16.8,1.0 1.0 1.4657097546055162 1.4770978917519928)&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;为什么第一项是固定值 &quot;1.0 &quot; ？因为按照线性模型 &lt;code&gt;f(x)=w^Tx+b&lt;/code&gt;，我们应该得出一个常数 b，这里设定 &quot;1.0 &quot;，就是 b 的初始值。&lt;/u&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private DataSet&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt; preProcess(
    return initData.map(
        new RichMapFunction&amp;lt;Tuple3&amp;lt;Double, Double, Vector&amp;gt;, Tuple3&amp;lt;Double, Double, Vector&amp;gt;&amp;gt;() {
            private DenseVector[] meanVar;

            @Override
            public Tuple3&amp;lt;Double, Double, Vector&amp;gt; map(Tuple3&amp;lt;Double, Double, Vector&amp;gt; value){
// value = {Tuple3@9791} &quot;(1.0,16.8,1.0 7.0 9.0)&quot;
                Vector aVector = value.f2;
// aVector = {DenseVector@9792} &quot;1.0 7.0 9.0&quot;
                if (aVector instanceof DenseVector) {
                    DenseVector bVector;
                    if (standardization) {
                        if (hasInterceptItem) {
                            bVector = new DenseVector(aVector.size() + 1);
                            bVector.set(0, 1.0); // 设定了固定值
                            for (int i = 0; i &amp;lt; aVector.size(); ++i) {
                                // 对输入数据做标准化和插值
                                bVector.set(i + 1, (aVector.get(i) - meanVar[0].get(i)) / meanVar[1].get(i));
                            }
                        } 
                    } 
// bVector = {DenseVector@9814} &quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot;
                    return Tuple3.of(value.f0, value.f1, bVector);
                } 
            }
        }).withBroadcastSet(meanVar, MEAN_VAR);
}

// 这里是对 x-vec 做标准化。比如原始输入Row是&quot;(1.0,16.8,1.0 7.0 9.0)&quot;，其中 x-vec 是&quot;1.0 7.0 9.0&quot;，进行标准化之后，x-vec 变成了 4 项，第一项是 &quot;1.0 &quot;，是 &quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot;，所以转换后的Row是&quot;(1.0,16.8,1.0 1.0 1.4657097546055162 1.4770978917519928)&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，输入处理完毕。&lt;/p&gt;
&lt;p&gt;比如原始输入Row是&quot;(1.0,16.8,1.0 7.0 9.0)&quot;，其中 x-vec 是&quot;1.0 7.0 9.0&quot;。&lt;/p&gt;
&lt;p&gt;进行标准化之后，x-vec 变成了 4 项 ：{ 第1项是固定值 &quot;1.0 &quot;， 所以4 项 是 &quot;1.0 1.0 1.4657097546055162 1.4770978917519928&quot; }，&lt;/p&gt;
&lt;p&gt;转换后的Row是&quot;(1.0,16.8,1.0 1.0 1.4657097546055162 1.4770978917519928)&quot;。即weight 是1.0，y-value是16.8，后续4个是x-vec。&lt;/p&gt;
&lt;p&gt;下面我们可以开始进行优化模型了，敬请期待下文。&lt;/p&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/key1994/p/11503840.html&quot;&gt;终于理解了方向导数与梯度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tangjunjun/articles/11649356.html&quot;&gt;导数，方向导数，梯度（Gradient）与梯度下降法（Gradient Descent）的介绍（非原创）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Sagittarius_Warrior/article/details/78365581&quot;&gt;梯度向量与梯度下降法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/blogshinelee/article/details/102668951&quot;&gt;直观理解梯度，以及偏导数、方向导数和法向量等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/li_wen01/article/details/73222657&quot;&gt;梯度（Gradient）与梯度下降法（Gradient Descent）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d04a611e16df&quot;&gt;梯度与梯度下降法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mamicode.com/info-detail-2508527.html&quot;&gt;梯度下降算法过程详细解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/25627482/answer/321719657&quot;&gt;https://www.zhihu.com/question/25627482/answer/321719657&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lwzkiller/article/details/55050275&quot;&gt;Hessian矩阵以及在图像中的应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39445556/article/details/84502260&quot;&gt;https://blog.csdn.net/weixin_39445556/article/details/84502260&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/23110142?fr=aladdin&quot;&gt;《分布式机器学习算法、理论与实践_刘铁岩》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29672873&quot;&gt;https://zhuanlan.zhihu.com/p/29672873&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/36425542&quot;&gt;https://www.zhihu.com/question/36425542&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32821110&quot;&gt;https://zhuanlan.zhihu.com/p/32821110&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hei653779919/article/details/106409818&quot;&gt;https://blog.csdn.net/hei653779919/article/details/106409818&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/worisaa/article/details/59479394?utm_source=blogxgwz9&quot;&gt;CRF L-BFGS Line Search原理及代码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoxuesheng993/p/8647777.html&quot;&gt;步长与学习率&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/IMWTJ123/article/details/88709023&quot;&gt;https://blog.csdn.net/IMWTJ123/article/details/88709023&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/BYRans/p/4700202.html&quot;&gt;线性回归、梯度下降（Linear Regression、Gradient Descent）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhoubindut/p/12160116.html&quot;&gt;机器学习系列（三）——目标函数和损失函数&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 11 Jul 2020 00:16:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文和下文将介绍线性回归在Alink中是如何实现的，希望可以作为大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13282333.html</dc:identifier>
</item>
<item>
<title>YAML 语言教程与使用案例 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13282339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13282339.html</guid>
<description>
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;YAML语言教程与使用案例，如何编与读懂写YAML文件。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。&lt;/p&gt;
&lt;p&gt;YAML是一个类似 XML、JSON 的标记性语言。YAML 强调以数据为中心，并不是以标识语言为重点。因而 YAML 本身的定义比较简单，号称“一种人性化的数据格式语言”。&lt;/p&gt;

&lt;h2 id=&quot;基本语法&quot;&gt;基本语法&lt;/h2&gt;
&lt;p&gt;1、大小写敏感&lt;/p&gt;
&lt;p&gt;2、使用缩进表示层级关系&lt;/p&gt;
&lt;p&gt;3、缩进时不允许使用Tab键，只允许使用空格&lt;/p&gt;
&lt;p&gt;4、缩进的空格数不重要，只要相同层级的元素左侧对齐即可。【实际使用中建议两个空格作为一个层级的缩进】&lt;/p&gt;
&lt;p&gt;5、# 表示注释，从这个字符一直到行尾，都会被解释器忽略&lt;/p&gt;
&lt;p&gt;6、冒号，以冒号结尾除外，其他所有冒号后面必须有空格&lt;/p&gt;
&lt;p&gt;7、短横线，表示列表项，使用一个短横线加一个空格；多个项使用同样的缩进级别作为同一列表&lt;/p&gt;

&lt;h2 id=&quot;支持的数据结构&quot;&gt;支持的数据结构&lt;/h2&gt;
&lt;p&gt;1、对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）&lt;/p&gt;
&lt;p&gt;2、数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）&lt;/p&gt;
&lt;p&gt;3、字面量/纯量（数字、字符串、布尔值）(scalars)：单个的、不可再分的值&lt;/p&gt;

&lt;h2 id=&quot;YAML-组织结构&quot;&gt;YAML 组织结构&lt;/h2&gt;
&lt;p&gt;YAML 文件可以由&lt;span&gt;一或多个文档&lt;/span&gt;组成（即相对独立的组织结构组成），&lt;span&gt;文档间使用“---”（三个横线）在每文档开始作为分隔符(可选)&lt;/span&gt;。同时，&lt;span&gt;文档也可以使用“...”（三个点号）作为结束符（可选）&lt;/span&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;备注：&lt;span&gt;如果只是单个文档，分隔符“---”可省略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个文档并不需要使用结束符“...”来表示结束，但是对于网络传输或者流来说，有明确结束的符号，有利于软件处理。（例如不需要知道流关闭就能知道文档结束）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202007/1395193-20200711080312148-1336672498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;Python-pip-安装&quot;&gt;Python pip 安装&lt;/h2&gt;
&lt;p&gt;如果未安装pip，则可以使用以下方法来安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootstrap.pypa.io/get-pip.py -o get-pip.py   # 下载安装脚本&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; # python get-pip.py    # 运行安装脚本  或则：python3 get-&lt;span&gt;pip.py  根据使用的Python决定
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; # pip --version        # 版本查看
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本。&lt;/p&gt;

&lt;h2 id=&quot;pip安装yaml与导入&quot;&gt;pip安装yaml与导入&lt;/h2&gt;
&lt;p&gt;安装pyyaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# pip &lt;span&gt;install&lt;/span&gt; pyyaml  # 或者pip3 &lt;span&gt;install&lt;/span&gt; pyyaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查是否安装成功：&lt;/p&gt;
&lt;p&gt;1、命令行输入：python&lt;/p&gt;
&lt;p&gt;2、再输入：import yaml&lt;/p&gt;
&lt;p&gt;安装成功后，在脚本里导入的语句，都是 import yaml&lt;/p&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对象数据：是一组键值对，使用冒号结构表示。&lt;/p&gt;

&lt;h2 id=&quot;单个对象文档文件&quot;&gt;单个对象文档文件&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_01_obj.yml
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ---
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;name: zhang
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; age: &lt;span&gt;22&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_01_obj.py
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./demo_01_obj.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; ys = yaml.load(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; print ys
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_01_obj.py 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;多个对象文档文件&quot;&gt;多个对象文档文件&lt;/h2&gt;
&lt;p&gt;yaml文件，仔细对比下加了”---“和”...“ 的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_02_obj.yml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; ---
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;name: zhang
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; age: &lt;span&gt;22&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; ---
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;name: Jane
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; age: &lt;span&gt;20&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;key: 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   child-&lt;span&gt;key: value
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   child-&lt;span&gt;key2: value2
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; ---
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;obj: {obj_key1: value1, obj_key2: value2}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_02_obj.py
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_02_obj.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  #print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_02_obj.py
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child-key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;child-key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;obj_key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;obj_key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;# 或者如下
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_02_obj.py 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child-key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child-key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj_key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj_key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数组类型：一组连词线开头的行，构成一个数组&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_03_list.yml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;# 书写方式1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;color:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; -&lt;span&gt; red
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; -&lt;span&gt; blue
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; -&lt;span&gt; green
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; -&lt;span&gt; orange
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; -&lt;span&gt; white
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# 书写方式2：行内表示法
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; fruits: [orange, apple, banana]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_03_list.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_03_list.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  #print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_03_list.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fruits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 或者结果如下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_03_list.py
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  ], 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fruits&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;复合结构：对象和数组可以结合使用，形成复合结构&lt;/p&gt;
&lt;p&gt;yaml文件，注意其书序格式，并细细对比输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_04_compose.yml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;shop: GoodShopping
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;address: BJ
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;goods:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  Food:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   - sell_time: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 08:30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    food01: rice
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    food02: pork
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  Fruits:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   - sell_time: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 09:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   -&lt;span&gt; fruit01: orange
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     price: &lt;span&gt;3.50&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   -&lt;span&gt; fruit02: banana
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     price: &lt;span&gt;3.00&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  clothes:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   - sell_time: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 09:30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   -&lt;span&gt; clothe01
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   - clothe02
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_04_compose.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_04_compose.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys: 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   #print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果，仔细对比下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_04_compose.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GoodShopping&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;goods&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Food&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;food02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pork&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AM 08:30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;food01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fruits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AM 09:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fruit01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3.5&lt;/span&gt;}, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3.0&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fruit02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AM 09:30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothe01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothe02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 或者结果如下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_04_compose.py 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GoodShopping&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Food&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;food02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 08:30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;food01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    ], 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fruits&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 09:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }, 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fruit01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3.5&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      }, 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fruit02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    ], 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sell_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM 09:30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;      }, 
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clothe01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clothe02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    ]
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;  }, 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;纯量是最基本的，不可再分的值，包括：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;字符串
布尔值
整数
浮点数
Null
时间
日期&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;常用数据类型的表示格式进行了约定&quot;&gt;常用数据类型的表示格式进行了约定&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_05_scalars.yml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;boolean: 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   - TRUE   # &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,True都可以
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   - FALSE  # &lt;span&gt;false&lt;/span&gt;&lt;span&gt;，False都可以
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   - &lt;span&gt;3.14&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   - &lt;span&gt;6.8523015e+5&lt;/span&gt;&lt;span&gt;  #可以使用科学计数法
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   - &lt;span&gt;123&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   nodeName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   parent: ~  # 使用~&lt;span&gt;表示null
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   -&lt;span&gt; 哈哈
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   - &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  # 可以使用双引号或者单引号包裹特殊字符
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   -&lt;span&gt; newline
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    newline2    # 字符串可以拆成多行，非尾行的每一行换行符都转为空格
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;date&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   - &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;17&lt;/span&gt;    # 日期必须使用ISO 8601格式，即yyyy-MM-&lt;span&gt;dd&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;datetime: 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   -  &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-17T15:&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;+&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;双叹号强制转换类型&quot;&gt;双叹号强制转换类型&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_06_switch.yml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;# 原信息
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ori01: &lt;span&gt;3.14&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; ori02: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;# 强制转换
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; int_str: !!str &lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;  # value 整数强制转换为字符串
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; str_int: !!&lt;span&gt;int&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; # value 字符串强制转换为整数
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_06_switch.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_06_switch.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys: 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   #print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果，仔细对比下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_06_switch.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ori01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3.14&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;int_str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ori02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str_int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;123&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 或者输出如下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_06_switch.py 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ori01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int_str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ori02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str_int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;123&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;amp;&lt;/span&gt; 用来建立锚点（defaults），&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; 表示合并到当前数据，&lt;span&gt;*&lt;/span&gt; 用来引用锚点。&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_07_anchor.yml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; ---
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;hr:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   -&lt;span&gt; Mark McGwire
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  # Following node labeled SS
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   - &amp;amp;&lt;span&gt;SS Sammy Sosa            # 定义要复制的数据
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;rbi:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   - *&lt;span&gt;SS # Subsequent occurrence   这里是数据复制目标
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   -&lt;span&gt; Ken Griffey
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; ---
&lt;span&gt;12&lt;/span&gt; defaults: &amp;amp;&lt;span&gt;defaults
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  adapter:  postgres
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  host:     localhost
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;development:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  database: myapp_development
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &amp;lt;&amp;lt;: *&lt;span&gt;defaults
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;test:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  database: myapp_test
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;info&lt;/span&gt;: *&lt;span&gt;defaults
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_07_anchor.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_07_anchor.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys: 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   #print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果，仔细对比下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_07_anchor.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mark McGwire&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sammy Sosa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sammy Sosa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ken Griffey&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;development&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;database&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;myapp_development&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;database&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;myapp_test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;defaults&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 或者结果如下
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_07_anchor.py 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mark McGwire&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sammy Sosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  ], 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rbi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sammy Sosa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken Griffey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;database&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myapp_development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  }, 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }, 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;database&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myapp_test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  }, 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;defaults&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;postgres&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;备注：之所以对yaml文件使用Python进行解析，是因为我们要测验yaml文件格式是否书写正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;字符串是最常见，也是最复杂的一种数据类型。&lt;/p&gt;
&lt;p&gt;字符串默认不使用引号表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str: 这是一行字符串
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果字符串之中包含空格或特殊字符，需要放在引号之中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容： 字符串&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;单引号和双引号都可以使用，双引号不会对特殊字符转义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s1: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容\n字符串&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
s2: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内容\n字符串&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;单引号之中如果还有单引号，必须连续使用两个单引号转义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
str: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;labor&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;s day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;字符串可以写成多行，从第二行开始，必须有空格缩进。&lt;span&gt;换行符会被转为空格&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;str: 这是一段
  多行
  字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多行字符串可以使用 | 保留换行符，也可以使用 &amp;gt; 折叠换行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; this: |
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  Foo
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  Bar
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; that: &amp;gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  Foo
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   Bar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;+ 表示保留字符串行末尾的换行，- 表示删除字符串末尾的换行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; s1: |
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  Foo
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; s2: |+
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  Foo
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; s3: |-
&lt;span&gt;8&lt;/span&gt;   Foo
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;字符串之中可以插入 HTML 标记。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; message: |
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;   &amp;lt;p style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color: red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    段落
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符串测验案例&quot;&gt;字符串测验案例&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_08_str.yml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;str01: zhangsan
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; str02: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q: What are you doing?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; str03: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; str04: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; str05: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;What&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;s your name?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; str06: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;str07:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ken: Hello,&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  My name is Ken.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   What&lt;span&gt;''&lt;/span&gt;s your name?&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;str08:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken: Hello,&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  My name is Ken.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   What&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s your name?&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; str11: |
&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;111&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;222&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;333&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; str12: &amp;gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  aaa xxx
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;  bbb yyy
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  ccc zzz
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;# 之后有2行空行
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; str16: |
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;  zhangsan
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  lisi
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  wangwu
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;# 之后有2行空行
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; str17: |+
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;  zhangsan
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;  lisi
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;  wangwu
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;# 之后有2行空行
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; str18: |-
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;  zhangsan
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;  lisi
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;  wangwu
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; message: |
&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;   &amp;lt;p style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color: red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    one line str
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;   &amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 yaml]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; demo_08_str.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env&lt;/span&gt;&lt;span&gt; python
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# Author: zhang
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import yaml
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo_08_str.yml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; = open(file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; ys = yaml.load_all(&lt;span&gt;file&lt;/span&gt;.read(), Loader=&lt;span&gt;yaml.Loader)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ys: 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  # 两种打印方式都尝试下  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  print y
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   #print json.dumps(y, indent=&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果，仔细对比下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_08_str.py 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;str02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q: What are you doing?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str05&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken: Hello, My name is Ken. What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str06&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str17&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu\n\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&amp;lt;p style=&quot;color: red&quot;&amp;gt;\n  one line str\n&amp;lt;/p&amp;gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str03&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\\nlisi\\nwangwu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str04&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa xxx bbb yyy ccc zzz\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;111\n222\n333\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str07&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken: Hello, My name is Ken. What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 或者输出如下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 yaml]# python demo_08_str.py 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q: What are you doing?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str05&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str08&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken: Hello, My name is Ken. What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str06&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str17&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu\n\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&amp;lt;p style=\&quot;color: red\&quot;&amp;gt;\n  one line str\n&amp;lt;/p&amp;gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str03&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\\nlisi\\nwangwu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str04&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan\nlisi\nwangwu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa xxx bbb yyy ccc zzz\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111\n222\n333\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str07&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ken: Hello, My name is Ken. What's your name?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完毕！&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202007/1395193-20200711081336128-1517467773.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Jul 2020 00:15:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>YAML语言教程与使用案例，如何编与读懂写YAML文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13282339.html</dc:identifier>
</item>
<item>
<title>Java加密与安全 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/13264132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/13264132.html</guid>
<description>&lt;h2 id=&quot;数据安全&quot;&gt;数据安全&lt;/h2&gt;
&lt;p&gt;  什么是数据安全？假如Bob要给Alice发送一封邮件，在发送邮件的过程中，黑客可能会窃取到邮件的内容，所以我们需要防窃听；黑客也有可能会篡改邮件的内容，所以Alice必须要有能有去识别邮件是否被篡改；最后，黑客也可能假冒Bob给Alice发送邮件，所以Alice还必须有能力识别出伪造的邮件。所以数据安全的几个要点就是：防窃听、防篡改和防伪造。&lt;br/&gt;古代的加密方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;移位密码：HELLO =&amp;gt; IFMMP (把英文字母按顺序往后移动几位，这里就是HELLO中的每个字母向后移动一位，就变成了IFMMP)&lt;/li&gt;
&lt;li&gt;替代密码：HELLO =&amp;gt; p12,5,3（用某个书籍的某一页某一行的第几个单词来记录信息）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现代计算机加密：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立在严格的数学理论基础上&lt;/li&gt;
&lt;li&gt;密码学逐渐发展成一门科学&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设计一个安全的加密算法非常困难&lt;/li&gt;
&lt;li&gt;验证一个加密算法是否安全更加困难&lt;/li&gt;
&lt;li&gt;当前被认为安全的加密算法仅仅是迄今为止尚未被攻破&lt;/li&gt;
&lt;li&gt;不要自己去设计加密算法&lt;/li&gt;
&lt;li&gt;不要自己去实现加密算法&lt;/li&gt;
&lt;li&gt;不要自己修改已有的加密算法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编码算法&quot;&gt;编码算法&lt;/h2&gt;
&lt;p&gt;ASCII编码就是一种编码，部分编码如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字母&lt;/th&gt;
&lt;th&gt;编码（16进制）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;0x41&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;0x42&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;0x43&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;0x44&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;汉字使用不同的编码算法，得到的编码是不一样的，汉字是使用Unicode编码后是两个字节，经过UTF-8编码后得到三个字节：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;汉字&lt;/th&gt;
&lt;th&gt;Unicode编码&lt;/th&gt;
&lt;th&gt;UTF-8编码&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;0x4e2d&lt;/td&gt;
&lt;td&gt;0xe4b8ad&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;文&lt;/td&gt;
&lt;td&gt;0x6587&lt;/td&gt;
&lt;td&gt;0xe69687&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;编&lt;/td&gt;
&lt;td&gt;0x7f16&lt;/td&gt;
&lt;td&gt;0xe7bc96&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;码&lt;/td&gt;
&lt;td&gt;0x7801&lt;/td&gt;
&lt;td&gt;0xe7a081&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;URL编码是浏览器发送数据给服务器时使用的编码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key1=value1&amp;amp;key2=value2&amp;amp;key3=value3&lt;/li&gt;
&lt;li&gt;q=%E4%B8%AD%E6%95%87&lt;br/&gt;URL编码规则：&lt;/li&gt;
&lt;li&gt;A~Z,a~z,0~9以及-_.*保持不变&lt;/li&gt;
&lt;li&gt;其它字符以%xx(以%开头的16进制来表示)
&lt;ul&gt;&lt;li&gt;&amp;lt;: %3C&lt;/li&gt;
&lt;li&gt;中：%E4%B8%AD (正好对应UTF-8编码的16进制： 0xe4b8ad)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception {
        String orginal = &quot;URL 参数&quot;;
        // URL 编码
        String encode = URLEncoder.encode(orginal, &quot;UTF-8&quot;);
        System.out.println(encode); // URL+%E5%8F%82%E6%95%B0

        // URL解码
        String decode = URLDecoder.decode(encode, &quot;UTF-8&quot;);
        System.out.println(decode); // URL 参数
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  通过运行结果可以看到：URL编码英文字母保持不变，空格编码为&quot;+&quot;，一个中文经过UTF-8编码后，通常是以%开头的16进制编码。&lt;br/&gt;总结：URL编码是编码算法，不是加密算法；URL编码的目的是把任意文本数据编码为%前缀表示的文本，编码后的文本仅包含A~Z，a~z，0~9，-_.*，%，便于浏览器和服务器处理。&lt;/p&gt;
&lt;p&gt;  Base64编码：一种把二进制数据用文本表示的编码算法,例如我们有一个字节数组byte[]{0xe4,0xb8,0xad}，通过Base64编码后得到的字符串为&quot;5Lit&quot;。如何使用Base64进行编码？假如我们把汉字“中”用UTF8表示的字节表示出来，它就是{0xe4,0xb8,0xad}，这三个字节就是24位（11100100 10111000 10101101），我们把这24位按照每6位分组就形成4个字节，这四个字节对应的16进制就是{0x39,0x0b,0x22,0x2d}，通过查表就可得到分别对应的是{5,L,i,T}，所以最终编码出来的字符串就是5LiT。Base64对应的编码表从索引0开始，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用Base64编码的目的：一种用文本（A~Z，a~z，0~9，+/=）表示二进制内容的方式，适用于文本协议，但效率会下降（因为二进制经过Bse64编码长度会增加1/3），应用比如电子邮件协议。如果数组的长度不是3的整数倍，末尾补0x00或0x00 0x00，编码后加=表示补充了一个字节，编码后加==表示补充了2个字节。在解码时就可以去掉补充的字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) throws UnsupportedEncodingException {
        String orignal = &quot;Hello\u00ff编码测试&quot;;
//        String b64 = Base64.getEncoder().encodeToString(orignal.getBytes(&quot;UTF-8&quot;));

        //去掉等号，实际上有没等号在解码时是不影响的
        String b64 = Base64.getEncoder().withoutPadding().encodeToString(orignal.getBytes(&quot;UTF-8&quot;));
        System.out.println(b64);

        String ori = new String(Base64.getDecoder().decode(b64), &quot;UTF-8&quot;);
        System.out.println(ori);

        //实现URL的Base64编码和解码
        String urlB64 = Base64.getUrlEncoder().withoutPadding().encodeToString(orignal.getBytes(&quot;UTF-8&quot;));
        System.out.println(urlB64);

        String urlOri = new String(Base64.getUrlDecoder().decode(urlB64), &quot;UTF-8&quot;);
        System.out.println(urlOri);
        
        //在Java中，使用URL的Base64编码，它会把&quot;+&quot;变为&quot;-&quot;,把&quot;/&quot;变为&quot;_&quot;，这样我们在传递URL参数的时候，就不会引起冲突
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：Base64是编码算法，不是加密算法；Base64编码的目的是把任意二进制数据编码为文本（长度增加1/3）；其它编码：Base32，Base48，Base58&lt;/p&gt;
&lt;h2 id=&quot;摘要算法&quot;&gt;摘要算法&lt;/h2&gt;
&lt;p&gt;  摘要算法（哈希算法/Hash/Digst/数字指纹），计算任意长度数据的摘要（固定长度），相同数据的输入始终得到相同的输出，不同的输入数据尽量得到不同的输出，目的是为了验证原始数据是否被篡改。如果我们的输入是任意长度的数据，而输出的是固定长度的数据，我们就可以称之为摘要算法。Java中Object的hashCode()方法就是一个摘要算法。什么是碰撞呢？碰撞是指两个不同的输入得到了相同的输出，而且碰撞是不能避免的，这是因为输出的字节长度是固定的，而输入的字节的长度是不固定的，所以hash算法实际上是将一个无限的输入集合映射到一个有限的输出集合。&lt;br/&gt;Hash算法的安全性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;碰撞率低&lt;/li&gt;
&lt;li&gt;不能猜测输出&lt;/li&gt;
&lt;li&gt;输入的任意一个bit的变化会造成输出完全不同&lt;/li&gt;
&lt;li&gt;很难以从输出反推输入（只能依靠暴力穷举）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的摘要算法&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;算法&lt;/td&gt;
&lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;输出长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MD5&lt;/td&gt;
&lt;td&gt;128 bits&lt;/td&gt;
&lt;td&gt;16 bytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SHA-1&lt;/td&gt;
&lt;td&gt;160 bits&lt;/td&gt;
&lt;td&gt;20 bytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SHA-256&lt;/td&gt;
&lt;td&gt;256 bits&lt;/td&gt;
&lt;td&gt;32 bytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RipeMD-160&lt;/td&gt;
&lt;td&gt;160 bits&lt;/td&gt;
&lt;td&gt;20 bytes&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h3 id=&quot;md5算法&quot;&gt;MD5算法&lt;/h3&gt;
&lt;p&gt;在Java中使用MD5：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception {
        MessageDigest digest1 = MessageDigest.getInstance(&quot;MD5&quot;);
        digest1.update(&quot;helloworld&quot;.getBytes(&quot;UTF-8&quot;));
        byte[] result1 = digest1.digest();
        for (byte b : result1) {
            System.out.print(b + &quot;\t&quot;); // -4 94 3 -115       56 -91  112 50  8 84 65 -25 -2 112 16 -80
        }

        System.out.println();

        //输入的数据可以分片输入,得到的结果是一样的
        MessageDigest digest2 = MessageDigest.getInstance(&quot;MD5&quot;);
        digest2.update(&quot;hello&quot;.getBytes(&quot;UTF-8&quot;));
        digest2.update(&quot;world&quot;.getBytes(&quot;UTF-8&quot;));
        byte[] result2 = digest2.digest();
        for (byte b : result2) {
            System.out.print(b + &quot;\t&quot;); // -4 94 3 -115       56 -91  112 50  8 84 65 -25 -2 112 16 -80       
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  MD5用途：可以用来验证文件的完整性，比如我们在MySQL网站下载mysql时，mysql网站会给出每一个下载文件的MD5值，在下完文件后，通过计算MD5和网站给出的MD5对比，就可以计算出文件在下载过程中是否出现错误。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200708211129638-849536090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  MD5存储用户口令，由于系统不存储用户原始口令（例如数据库中存储的密码），系统存储用户原始口令的MD5。如何判断用户口令是否正确？系统计算用户输入的原始口令的MD5和数据库存储的MD5进行对比，相同则口令正确，不相同则口令错误。使用MD5要避免彩虹表攻击，什么是彩虹表呢？彩虹表就是预先计算好的常用口令。为了抵御彩虹表攻击，通常我们需要对每个口令额外添加随机数salt。&lt;/p&gt;
&lt;h3 id=&quot;sah-1算法&quot;&gt;SAH-1算法&lt;/h3&gt;
&lt;p&gt;  SAH-1算法是一种哈希算法，输出160 bits / 20 bytes，美国国家安全局开发，常见的有SHA-1 / SHA-256 / SHA-512。SAH-1算法是比MD5更安全的哈希算法。&lt;/p&gt;
&lt;h3 id=&quot;bouncycastle算法&quot;&gt;BouncyCastle算法&lt;/h3&gt;
&lt;p&gt;  BouncyCastle是第三方提供的一组加密/哈希算法，提供JDK没有提供的算法（RipeMD160 算法），如何使用第三方提供的算法？先添加第三方jar至classpath，注册第三方算法提供方（通过Security.addProvider()注册），正常使用JDK提供的接口。&lt;/p&gt;
&lt;h3 id=&quot;hmac算法&quot;&gt;Hmac算法&lt;/h3&gt;
&lt;p&gt;  Hmac：Hash-based Message Authentication Code的缩写，基于密钥的消息认证码算法，是更安全的消息摘要算法。HmacMD5相当于md5（secure_random_key,data），所以HmacMD5可以看作带安全Salt的MD5。Hmac是把key混入摘要的算法，并不是新发明的一种算法，必须配合MD5,SHA-1等摘要算法，摘要长度和原摘要算法长度相同。&lt;/p&gt;
&lt;h2 id=&quot;加密算法&quot;&gt;加密算法&lt;/h2&gt;
&lt;h3 id=&quot;对称加密算法&quot;&gt;对称加密算法&lt;/h3&gt;
&lt;p&gt;  对称加密算法的加密和解密使用同一个密钥，例如WinRAR，我们在对文件进行压缩时，可以设一个密码，再解压时，我们需要使用 同一个密码才能进行解压，winRAR就是使用的对称加密算法。加密：encrypt(密钥key,原文message)-&amp;gt;密文s，解密：decrypt（密钥key,密文s）-&amp;gt; 原文message。常用的对称加密算法有DES，AES，IDEA等。由于DES的密钥较短，可以在短时间内暴力破解，现在已经不使用了。&lt;br/&gt;Java使用 AES的ECB模式下的加密和解密：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AES_ECB_Cipher {

    private static final String CIPHER_NAME = &quot;AES/ECB/PKCS5Padding&quot;;

    //加密
    public static byte[] encrypt(byte[] key, byte[] input) throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_NAME);
        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
        //使用加密模式
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        //通过doFinal()得到加密后的字节数组
        return cipher.doFinal(input);
    }

    //解密
    public static byte[] decrypt(byte[] key, byte[] input) throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_NAME);
        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
        //使用解密模式
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        //通过doFinal()将密文还原为原文
        return cipher.doFinal(input);
    }

    public static void main(String[] args) throws Exception {
        //原文
        String message = &quot;Hello, World! encrypted using AES&quot;;
        System.out.println(&quot;Message: &quot; + message); // message: Hello, World! encrypted using AES

        //128位密钥 = 16 bytes key
        byte[] key = &quot;1234567890abcdef&quot;.getBytes(&quot;UTF-8&quot;);
        //加密
        byte[] data = message.getBytes(StandardCharsets.UTF_8);
        byte[] encrypted = encrypt(key, data);
        //加密后的密文： Encrypted data: g89TtEMHXpwwjrEbXcljDQIUi09dPO9fVx4OgZ7ozsFgo8Zilj6cypxChst75GTR
        System.out.println(&quot;Encrypted data: &quot; + Base64.getEncoder().encodeToString(encrypted));
        //解密
        byte[] decrypted = decrypt(key, encrypted);
        //解密后得到结果与原文相同：Decrypted data: Hello, World! encrypted using AES
        System.out.println(&quot;Decrypted data: &quot; + new String(decrypted,&quot;UTF-8&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java使用 AES的CBC模式下的加密和解密：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AES_CBC_Cipher {

    private static final String CIPHER_NAME = &quot;AES/CBC/PKCS5Padding&quot;;

    //加密
    public static byte[] encrypt(byte[] key, byte[] input) throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_NAME);
        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
        //CBC模式需要生成一个16字节的initiallization vector
        SecureRandom sr = SecureRandom.getInstanceStrong();
        //获取向量，即16位字节的随机数
        byte[] iv = sr.generateSeed(16);
        //把字节数组转为IvParameterSpec对象
        IvParameterSpec ivps = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);
        byte[] data = cipher.doFinal(input);
        //IV不需要保密，把IV和密文一起返回
        return join(iv, data);
    }

    private static byte[] join(byte[] iv, byte[] data) {
        byte[] r = new byte[iv.length + data.length];
        System.arraycopy(iv, 0 ,r, 0, iv.length);
        System.arraycopy(data, 0 ,r, iv.length, data.length);
        return r;
    }

    //解密
    public static byte[] decrypt(byte[] key, byte[] input) throws Exception {
        //把input分割成iv和密文
        byte[] iv = new byte[16];
        byte[] data = new byte[input.length - 16];
        System.arraycopy(input, 0 ,iv, 0, 16);
        System.arraycopy(input, 16 ,data, 0, data.length);

        //解密
        Cipher cipher = Cipher.getInstance(CIPHER_NAME);
        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
        IvParameterSpec ivps = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivps);
        return cipher.doFinal(data);
    }

    public static void main(String[] args) throws Exception {
        //原文
        String message = &quot;Hello, World! encrypted using AES&quot;;
        System.out.println(&quot;Message: &quot; + message); // message: Hello, World! encrypted using AES

        //128位密钥 = 16 bytes key
        byte[] key = &quot;1234567890abcdef&quot;.getBytes(&quot;UTF-8&quot;);
        //加密
        byte[] data = message.getBytes(StandardCharsets.UTF_8);
        byte[] encrypted = encrypt(key, data);
        //加密后的密文： Encrypted data: 3iwMkdAqR0eQYQqaxOEKao+N0gSp/05i+mULmLvndSKq4Z2xz122wmFARWbAwF6dElmnceO/x5pJHcwXSr8inQ==
        System.out.println(&quot;Encrypted data: &quot; + Base64.getEncoder().encodeToString(encrypted));
        //解密
        byte[] decrypted = decrypt(key, encrypted);
        //解密后得到结果与原文相同：Decrypted data: Hello, World! encrypted using AES
        System.out.println(&quot;Decrypted data: &quot; + new String(decrypted,&quot;UTF-8&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;口令加密算法&quot;&gt;口令加密算法&lt;/h3&gt;
&lt;p&gt;  PBE(Passwoord Based Encrytion)算法：由用户输入口令，采用随机数杂凑计算出密钥再进行加密，password：用户口令，例如&quot;hello123&quot;，Salt：随机生成的byte[]，密钥Key：generate(byte[] salt, String password)。如果把随机Salt存储在U盘，就得到了一个“口令”+USB Key加密软件，这样做的好处是即时用户使用非常弱的口令，没有USB Key仍然无法解密。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200709202541568-1961905622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：PBE算法通过用户口令和随机数Salt计算Key然后加密，Key通过用户口令和随机数Salt计算得出，提高了安全性，PBE算法内部仍然使用的是标准对称加密算法（例如AES）。&lt;/p&gt;
&lt;h3 id=&quot;密钥交换算法&quot;&gt;密钥交换算法&lt;/h3&gt;
&lt;p&gt;  我们在使用对称加密算法的时候，我们的加密和解密使用的是同一个密钥Key。我们以AES加密为例，当我们要加密明文，我们需要使用一个随机生成的Key作为密钥进行加解密，最后我们的问题就是如何传递密钥？因为不给对方密钥，对方就无法解密，而直接传递密钥，会被黑客监听，所以问题就变成了：&lt;span&gt;如何在不安全的信道上安全地传输密钥？&lt;/span&gt;密钥交换算法也就是Diff-Hellman算法，即DH算法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200709204601934-2040216640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;甲首先选择一个素数P=509，然后在选择一个底数g和一个随机数a，然后计算 A=&lt;span class=&quot;math inline&quot;&gt;\(g^a\)&lt;/span&gt; mod p =&amp;gt; 215&lt;/li&gt;
&lt;li&gt;甲发送P=509，g=5，A=215，乙收到以后，也选择一个随机数b=456，然后计算 B=&lt;span class=&quot;math inline&quot;&gt;\(g^b\)&lt;/span&gt; mod p =&amp;gt; 181，然后接着计算 s = &lt;span class=&quot;math inline&quot;&gt;\(A^b\)&lt;/span&gt; mod p =&amp;gt; 121&lt;/li&gt;
&lt;li&gt;乙把计算的B=181发送给甲，甲通过 s=&lt;span class=&quot;math inline&quot;&gt;\(B^a\)&lt;/span&gt; mod p 可以计算出也等于121。所以双方协商出的密钥就是121。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  要注意这个密钥并没有在网络上进行传输，通过网络传输的是p=509，g=5, A=215, B=181，但是通过这四个数，黑客是无法推算出密钥s的。更确切的说，DH算法它是一个密钥协商算法，双发最终协商出一个共同的密钥。我们把a看成是甲的私钥，A看成是甲的公钥，b看成是乙的私钥，B看成是乙的公钥，DH算法的本质就是：双方各自生成自己的私钥和公钥，然后交换公钥，并且根据自己的私钥和对方的公钥生成最终的密钥。DH算法根据数学定律保证了双方各自计算出来的key是相同的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;
import java.io.IOException;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

class Person {
    public final String name; // 表示人的名字

    public PublicKey publicKey; // 表示这个人的公钥
    public PrivateKey privateKey; // 表示这个人的私钥
    public SecretKey secretKey; //表示最终的密钥

    public Person(String name) {
        this.name = name;
    }

    //生成本地的KeyPair
    public void generateKeyPair() {
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;DH&quot;);
            keyGen.initialize(512); //创建一个512位的keyPair
            KeyPair keyPair = keyGen.generateKeyPair();
            this.privateKey = keyPair.getPrivate();
            this.publicKey = keyPair.getPublic();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public void generateSecreteKey(byte[] recivedPUblickeyBytes) {
        //从byte[]恢复PublcKey
        try {
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(recivedPUblickeyBytes);
            KeyFactory kf = KeyFactory.getInstance(&quot;DH&quot;);
            PublicKey recivedPublicKey = kf.generatePublic(keySpec);
            //生成本地密钥
            KeyAgreement keyAgreement = KeyAgreement.getInstance(&quot;DH&quot;);
            keyAgreement.init(this.privateKey); // 自己的私钥
            keyAgreement.doPhase(recivedPublicKey,true); // 对方的公钥
            //生成AES密钥
            this.secretKey = keyAgreement.generateSecret(&quot;AES&quot;);
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public void printKeys(){
        System.out.printf(&quot;Name: %s\n&quot;, this.name);
        System.out.printf(&quot;private key: %x\n&quot;,new BigInteger(1,this.privateKey.getEncoded()));
        System.out.printf(&quot;public key: %x\n&quot;,new BigInteger(1,this.publicKey.getEncoded()));
        System.out.printf(&quot;secrete key: %x\n&quot;,new BigInteger(1,this.secretKey.getEncoded()));
    }

    //发送加密信息
    public String sendMessage(String message){
        try {
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE,this.secretKey);
            byte[] data = cipher.doFinal(message.getBytes(&quot;UTF-8&quot;));
            return Base64.getEncoder().encodeToString(data);
        } catch (GeneralSecurityException |IOException e) {
           throw new RuntimeException(e);
        }
    }

    //接收加密信息并解密
    public String reciveMessage(String message){
        try {
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE,this.secretKey);
            byte[] data = cipher.doFinal(Base64.getDecoder().decode(message));
            return new String(data,&quot;UTF-8&quot;);
        } catch (GeneralSecurityException |IOException e) {
            throw new RuntimeException(e);
        }
    }

}

public class DH {

    public static void main(String[] args) {
        //Bob和Alice
        Person bob = new Person(&quot;Bob&quot;);
        Person alice = new Person(&quot;Alice&quot;);

        //生成各自的keyPair
        bob.generateKeyPair();
        alice.generateKeyPair();

        //双方交换各自的public Key
        //Bob根据Alice的public Key生成自己的本地密钥
        bob.generateSecreteKey(alice.publicKey.getEncoded());
        //Alice根据Bob的public Key生成自己的本地密钥
        alice.generateSecreteKey(bob.publicKey.getEncoded());

        //检查双方的本地密钥是否相同
        bob.printKeys();
        alice.printKeys();

        //双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密
        String msgBobToAlice = bob.sendMessage(&quot;Hello, Alice!&quot;);
        System.out.println(&quot;Bob -&amp;gt; Alice: &quot; + msgBobToAlice);
        String aliceDecrypted = alice.reciveMessage(msgBobToAlice);
        System.out.println(&quot;Alice decrypted: &quot; + aliceDecrypted);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200709215700097-185826179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果在运行过程中出现： Unsupported secret key algorithm: AES 异常信息，这是由于密钥所用的算法不被支持，这个是由于JDK8 update 161之后，DH的密钥长度至少为512位，但AES算法密钥不能达到这样的长度，长度不一致所以导致报错。&lt;br/&gt;解决办法：将 -Djdk.crypto.KeyAgreement.legacyKDF=true 写入JVM系统变量中。可以在IEDA中的Run - Edit Configurations -&amp;gt; VM options中配置，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200709220258736-1390387046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  但DH算法不能避免中间人攻击，如果黑客假冒乙和甲交换密钥，同时又假冒甲和乙交换密钥，这样就可以成功地进行工具。DH算法是一种安全的密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。&lt;/p&gt;
&lt;h2 id=&quot;非对称加密算法&quot;&gt;非对称加密算法&lt;/h2&gt;
&lt;p&gt;非对称加密就是加密和解密使用不同的密钥，非对称加密的典型算法就是RSA算法，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加密：用对方的公钥加密，然后发送给对方 encrypt(publicKeyB,message) -&amp;gt; encrypted&lt;/li&gt;
&lt;li&gt;解密：对方用自己私钥解密 decrypt(privateKeyB,encrypted) -&amp;gt; message&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import javax.crypto.Cipher;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RSAKeyPair {

    //私钥
    private PrivateKey sk;

    //公钥
    private PublicKey pk;

    //生成公钥/私钥对
    public RSAKeyPair() throws GeneralSecurityException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
        keyGen.initialize(1024);
        KeyPair kp = keyGen.generateKeyPair();
        this.sk = kp.getPrivate();
        this.pk = kp.getPublic();
    }

    //从已保存的字节中（例如读取文件）恢复公钥/密钥
    public RSAKeyPair(byte[] pk, byte[] sk) throws GeneralSecurityException {
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(pk);
        this.pk = keyFactory.generatePublic(keySpec);
        PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(sk);
        this.sk = keyFactory.generatePrivate(skSpec);
    }

    //把私钥到处为字节
    public byte[] getPrivateKey(){
        return this.sk.getEncoded();
    }

    //把公钥导出为字节
    public byte[] getPublicKey(){
        return this.pk.getEncoded();
    }

    //用公钥加密
    public byte[] encrypt(byte[] message) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
        cipher.init(Cipher.ENCRYPT_MODE,this.pk);
        return cipher.doFinal(message);
    }

    //用私钥解密
    public byte[] decrypt(byte[] input) throws GeneralSecurityException{
        Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
        cipher.init(Cipher.DECRYPT_MODE, this.sk);
        return cipher.doFinal(input);
    }

    public static void main(String[] args) throws Exception {
        //明文
        byte[] plain = &quot;Hello，使用RSA非对称加密算法对数据进行加密&quot;.getBytes();
        //创建公钥/私钥 对
        RSAKeyPair rsa = new RSAKeyPair();
        //加密
        byte[] encrypt = rsa.encrypt(plain);
        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypt));
        //解密
        byte[] decrypt = rsa.decrypt(encrypt);
        System.out.println(&quot;decrypted: &quot; + new String(decrypt,&quot;UTF-8&quot;));

        //保存公钥/私钥 对
        byte[] sk = rsa.getPrivateKey();
        byte[] pk = rsa.getPublicKey();
        System.out.println(&quot;sk: &quot; + Base64.getEncoder().encodeToString(sk));
        System.out.println(&quot;pk: &quot; + Base64.getEncoder().encodeToString(pk));

        //重新恢复公钥/私钥
        RSAKeyPair rsaKeyPair = new RSAKeyPair(pk, sk);
        //加密
        byte[] encrypted = rsaKeyPair.encrypt(plain);
        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));
        //解密
        byte[] decrypted = rsa.decrypt(encrypted);
        System.out.println(&quot;decrypted: &quot; + new String(decrypted,&quot;UTF-8&quot;));


    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200709225613918-2118345694.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;非堆成加密算法有如下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥&lt;/li&gt;
&lt;li&gt;N个人之间通信
&lt;ul&gt;&lt;li&gt;使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对&lt;/li&gt;
&lt;li&gt;使用对称加密需要N*(N-1)/2个密钥，每个人需要管理N-1个密钥&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;非对称加密的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运算速度慢&lt;/li&gt;
&lt;li&gt;不能防止中间人攻击&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数字签名算法&quot;&gt;数字签名算法&lt;/h2&gt;
&lt;h3 id=&quot;rsa签名算法&quot;&gt;RSA签名算法&lt;/h3&gt;
&lt;p&gt;  在非对称加密中，我们可以看到甲乙双方要进行通信，甲可以使用乙的publicKey对消息进行加密，然后乙使用自己的privateKey对消息进行解密，这个时候会出现一个问题，如果黑客使用乙的publicKey对消息进行加密，然后冒充甲发送给乙，那么乙怎么识别这个消息是甲发送的还是冒充的呢？所以我们就需要数字签名算法。甲在发送加密信息的时候，同时还要发送自己的签名，而这个签名是使用甲的privateKey计算的，而乙要验证这个签名是否是合法的，它会用甲的publicKey进行验证，如果验证成功，则说明这个消息确实是甲发送的。所以数字签名就是发送方用自己的私钥对消息进行签名（sig=signature(privateKey,'message')），接收方用发送方的公钥验证签名是否有效（boolen valid = verify(publicKey,sig,'message')），我们可以把数字签名理解为混入了私钥和公钥的摘要。&lt;br/&gt;数字签名的目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确认信息是某个发送方发的（因为只有它用他自己的privateKey签名，其他人才可以用它的publickey来验证这个签名）&lt;/li&gt;
&lt;li&gt;发送发不能抵赖它发送了消息（因为用谁的publicKey成功的验证了签名，则这个 签名也是用谁的privateKey进行的签名）&lt;/li&gt;
&lt;li&gt;数据在传输过程中没有被修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的数字签名算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MD5withRSA&lt;/li&gt;
&lt;li&gt;SHA1withRSA&lt;/li&gt;
&lt;li&gt;SHA256withRSA&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class SecRSASignature {

    private PublicKey pk;

    private PrivateKey sk;

    public SecRSASignature() throws GeneralSecurityException {
        //生成 KeyPair
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
        keyGen.initialize(1024);
        KeyPair kp = keyGen.generateKeyPair();
        this.sk = kp.getPrivate();
        this.pk = kp.getPublic();
    }

    //从已保存的字节中（例如读取文件）恢复公钥/密钥
    public SecRSASignature(byte[] pk, byte[] sk) throws GeneralSecurityException {
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(pk);
        this.pk = keyFactory.generatePublic(keySpec);
        PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(sk);
        this.sk = keyFactory.generatePrivate(skSpec);
    }

    //把私钥到处为字节
    public byte[] getPrivateKey(){
        return this.sk.getEncoded();
    }

    //把公钥导出为字节
    public byte[] getPublicKey(){
        return this.pk.getEncoded();
    }

    //对消息进行签名
    public byte[] sign(byte[] message) throws GeneralSecurityException {
        //sign by sk
        Signature signature = Signature.getInstance(&quot;SHA1withRSA&quot;);
        signature.initSign(this.sk);
        signature.update(message);
        return signature.sign();
    }

    //私用公钥验证签名
    public boolean verify(byte[] message, byte[] sign) throws GeneralSecurityException {
        //verify by pk
        Signature sha1withRSA = Signature.getInstance(&quot;SHA1withRSA&quot;);
        sha1withRSA.initVerify(this.pk);
        sha1withRSA.update(message);
        return sha1withRSA.verify(sign);
    }

    public static void main(String[] args) throws GeneralSecurityException {
        byte[] message = &quot;Hello,使用SHA1withRSA算法进行数字签名！&quot;.getBytes(StandardCharsets.UTF_8);
        SecRSASignature rsas = new SecRSASignature();
        byte[] sign = rsas.sign(message);
        System.out.println(&quot;sign: &quot; + Base64.getEncoder().encodeToString(sign));
        boolean verified = rsas.verify(message, sign);
        System.out.println(&quot;verified: &quot; + verified);
        //用另一个公钥验证
        boolean verified02 = new SecRSASignature().verify(message, sign);
        System.out.println(&quot;verify with another public key: &quot; + verified02);
        //修改原始信息
        message[0] = 100;
        boolean verified03 = rsas.verify(message, sign);
        System.out.println(&quot;verify changed message: &quot; + verified03);
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200710205532474-155959400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dsa签名算法&quot;&gt;DSA签名算法&lt;/h3&gt;
&lt;p&gt;  DSA(Digital Signature Algorithm)，使用EIGamal数字签名算法，DSA只能配合SHA算法使用，所以有SHA1withDSA,SHA256withDSA,SHA512withDSA算法。和RSA数字签名算法相比，DSA算法更快。测试代码和测试RSA数字签名算法的代码一致，只需要修改算法名称就行了。&lt;/p&gt;
&lt;h2 id=&quot;数字证书&quot;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;数字正数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非对称加密算法：对数据进行加密、解密&lt;/li&gt;
&lt;li&gt;签名算法：确保数据的完整性和抗否认性&lt;/li&gt;
&lt;li&gt;摘要算法：确保证书本身没有被篡改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.X509Certificate;

public class X509 {

    private final PrivateKey privateKey;
    public final X509Certificate certificate; // 证书和证书包含的公钥和摘要信息

    public X509(KeyStore keyStore, String certName, String password) {
        try {
            this.privateKey = (PrivateKey) keyStore.getKey(certName,password.toCharArray());
            this.certificate = (X509Certificate) keyStore.getCertificate(certName);
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    //加密
    public byte[] encrypt(byte[] message) {
        try {
            //获得加密算法
            Cipher cipher = Cipher.getInstance(this.privateKey.getAlgorithm());
            cipher.init(Cipher.ENCRYPT_MODE,this.privateKey);
            return cipher.doFinal(message);
        }  catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    //解密
    public byte[] decrypt(byte[] message) {
        try {
            PublicKey publicKey = this.certificate.getPublicKey();
            Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());
            cipher.init(Cipher.DECRYPT_MODE,publicKey);
            return cipher.doFinal(message);
        }  catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] sign(byte[] message) {
        try {
            Signature signature = Signature.getInstance(this.certificate.getSigAlgName());
            signature.initSign(this.privateKey);
            signature.update(message);
            return signature.sign();
        }  catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean verify(byte[] message, byte[] sign) {
        try {
            Signature signature = Signature.getInstance(this.certificate.getSigAlgName());
            signature.initVerify(this.certificate);
            signature.update(message);
            return signature.verify(sign);
        }  catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    //Java中的数字证书是存储在keyStore中的
    public static KeyStore loadKeyStore(String keyStoreFile, String password) {
        try (InputStream input = new BufferedInputStream(new FileInputStream(keyStoreFile))) {
            if (input == null) {
                throw new RuntimeException(&quot;file not found in classpath: &quot; + keyStoreFile);
            }
            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(input, password.toCharArray());
            return ks;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) throws Exception {
        byte[] message = &quot;Hello, 使用X.509证书进行加密和签名!&quot;.getBytes(&quot;UTF-8&quot;);
        // 读取KeyStore:
        KeyStore ks = loadKeyStore(&quot;my.keystore&quot;, &quot;123456&quot;);
        // 读取证书
        X509 x509 = new X509(ks,&quot;mycert&quot;, &quot;123456&quot;);
        // 加密:
        byte[] encrypted = x509.encrypt(message);
        System.out.println(String.format(&quot;encrypted: %x&quot;, new BigInteger(1, encrypted)));
        // 解密:
        byte[] decrypted = x509.decrypt(encrypted);
        System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));
        // 签名:
        byte[] sign = x509.sign(message);
        System.out.println(String.format(&quot;signature: %x&quot;, new BigInteger(1, sign)));
        // 验证签名:
        boolean verified = x509.verify(message, sign);
        System.out.println(&quot;verify: &quot; + verified);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202007/1975191-20200710220116725-879867179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开命令行，进入当前工程所在目录，输入命令:keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 36500 -alias mycert -keystore my.keystore -dname &quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot; 即可生成keystore文件，通过命令：keytool -list -keystore my.keystore -storepass 123456 可以看到keySore中的证书。&lt;br/&gt;数字证书的应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;https: HTTP over SSL
&lt;ul&gt;&lt;li&gt;服务器发送证书给客户端（发送公钥/签名/CA）&lt;/li&gt;
&lt;li&gt;客服端验证服务器证书（确认服务器身份）&lt;/li&gt;
&lt;li&gt;客户端用证书加密随机口令并发送给服务器端（公钥加密）&lt;/li&gt;
&lt;li&gt;服务器端解密获得口令（私钥解密）&lt;/li&gt;
&lt;li&gt;双方随后使用AES加密进行通信（对称加密）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种网络安全标准，数字证书采用链式签名管理，顶级CA证书已经内置于操作系统中，常用算法：MD5/SHA1/SHA256/RSA/DSA/...&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jul 2020 00:03:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>数据安全 什么是数据安全？假如Bob要给Alice发送一封邮件，在发送邮件的过程中，黑客可能会窃取到邮件的内容，所以我们需要防窃听；黑客也有可能会篡改邮件的内容，所以Alice必须要有能有去识别邮件是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/13264132.html</dc:identifier>
</item>
<item>
<title>一次排查线上接口偶发异常耗时引起的思考！ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13279319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13279319.html</guid>
<description>&lt;h2&gt;一、引子&lt;/h2&gt;
&lt;p&gt;这要从线上的一个接口偶发异常耗时说起，事情往往不是你想象的样子，尤其是在排查问题的时候，切忌有先入为主的的某些判断。&lt;/p&gt;
&lt;h2&gt;二、问题：&lt;/h2&gt;
&lt;p&gt;接口监控图：显示每天总会有那么几次耗时特别长的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200711015843325-1392872761.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;236&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、排查：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、直观的认识是“偶发”，每天零星的几个，不规律。&lt;/h3&gt;
&lt;p&gt;对于这种情况，第一感觉是因为服务的波动影响，因为没有服务能够达到100%的低延迟可用响应。&lt;/p&gt;
&lt;p&gt;首先检查了相应时段的其它接口的响应情况，发现并没有相似的情景。由此可以基本上排除了服务波动的影响，但是也不是十分确定。&lt;/p&gt;
&lt;h3&gt;2、接口逻辑&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200711004533175-1498283928.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;430&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑l3是一个存在很久的历史业务逻辑，首先假定认为了它没有问题排除掉了（呵呵）。&lt;/p&gt;
&lt;p&gt;l2是一个比较耗时的处理，首先的关注点放在了这里。l2是有超时设定的，最大超时为2s，但是我们的监控库里看到的最大的耗时是超过两秒的，或者考虑到其它处理逻辑的耗时，最坏的情况下，总的耗时是不应该超过3s的。为了确认l2服务的稳定性，线上添加了相应的监控，观察到最大耗时是在超时限定范围内的。因此排除掉此处的问题，&lt;/p&gt;
&lt;h3&gt;3、不得已而为之&lt;/h3&gt;
&lt;p&gt;经过以上几步的排查，现有的信息已经不足以定位问题了。只能把接口里的每一步逻辑耗时全部统计记录来进一步排查（其实，内心是非常拒绝的）。&lt;/p&gt;
&lt;h2&gt;四、StopWatch&lt;/h2&gt;
&lt;p&gt;StopWatch很多地方都提供了，Spring、Apache、Guava。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Spring示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;♣ id标识当前的StopWatch，比如统计一个接口的耗时，可以使用接口名称作为标识，从而在输出端进行识别。&lt;/p&gt;
&lt;p&gt;♣ 内部有task概念，用以表示内部每一阶段的执行逻辑，比如获取用户信息-&amp;gt;获取资金信息-&amp;gt;交易逻辑流转过程。&lt;/p&gt;
&lt;p&gt;♣ 的格式化输出比较明晰，包括StopWatch标识，任务标识，每个任务的耗时及总占比。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; springStopWatch() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        StopWatch stopWatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StopWatch(&quot;spring_stopwatch&quot;&lt;span&gt;);
        stopWatch.start(&lt;/span&gt;&quot;a&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始任务a&lt;/span&gt;
        Thread.sleep(1000&lt;span&gt;);
        stopWatch.stop(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务a执行完毕&lt;/span&gt;
        stopWatch.start(&quot;b&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始任务b&lt;/span&gt;
        Thread.sleep(2000&lt;span&gt;);
        stopWatch.stop(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务b执行完毕&lt;/span&gt;
        stopWatch.start(&quot;c&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始任务c&lt;/span&gt;
        Thread.sleep(100&lt;span&gt;);
        stopWatch.stop(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务c执行完毕&lt;/span&gt;
&lt;span&gt;        System.out.println(stopWatch.prettyPrint());
    }&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
StopWatch 'spring_stopwatch': running time (millis) = 3111
-----------------------------------------&lt;span&gt;
ms     &lt;/span&gt;%&lt;span&gt;     Task name
&lt;/span&gt;-----------------------------------------
01002  032%&lt;span&gt;  a
&lt;/span&gt;02006  064%&lt;span&gt;  b
&lt;/span&gt;00103  003%  c
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Apache StopWatch：&lt;/h3&gt;
&lt;p&gt;这里有个split概念，我愿意称之为时间“锚点”，当你执行完split操作后，在下一次执行split之前，你可以在任何时候获取开始时间到执行split的时间点之间的时间间隔：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200711011636953-1008084546.png&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;319&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;supend-resume：挂起、恢复，很容易理解，暂停计时、恢复继续计时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200711012759794-1263991821.png&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;420&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; apacheStopWatch() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        org.apache.commons.lang3.time.StopWatch stopWatch &lt;/span&gt;=&lt;span&gt; org.apache.commons.lang3.time.StopWatch.createStarted();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        stopWatch.stop(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束计时&lt;/span&gt;
        System.out.println(&quot;normal: &quot; +&lt;span&gt; stopWatch.getTime());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;split test&lt;/span&gt;
&lt;span&gt;        stopWatch.reset();
        stopWatch.start();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        stopWatch.split(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间锚点&lt;/span&gt;
        Thread.sleep(1000&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;split: &quot; + stopWatch.getSplitTime()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始到时间锚点的间隔

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;suspend&lt;/span&gt;
&lt;span&gt;        stopWatch.reset();
        stopWatch.start();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        stopWatch.suspend(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起watch&lt;/span&gt;
        Thread.sleep(1000); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;期间的时间是不计入总时间的&lt;/span&gt;
        stopWatch.resume(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复watch&lt;/span&gt;
        Thread.sleep(1000&lt;span&gt;);
        stopWatch.stop();
        System.out.println(&lt;/span&gt;&quot;suspend_resume: &quot; +&lt;span&gt; stopWatch.getTime());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
normal: 1002&lt;span&gt;
split: &lt;/span&gt;1004&lt;span&gt;
suspend_resume: &lt;/span&gt;2009
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、Guava：&lt;/h3&gt;
&lt;p&gt;just StopWatch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; guavaStopWatch() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Stopwatch stopwatch &lt;/span&gt;=&lt;span&gt; Stopwatch.createStarted();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        stopwatch.stop();
        System.out.println(stopwatch.elapsed(TimeUnit.MILLISECONDS));
        stopwatch.reset();
        stopwatch.start();
        Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        stopwatch.stop();
        System.out.println(stopwatch.elapsed(TimeUnit.MILLISECONDS));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;h2&gt;五、结论&lt;/h2&gt;
&lt;p&gt;这里采用的是Spring的StopWatch，四个Task，总耗时及分耗时不用额外的记录处理，对于总耗时超过一定值的请求，打印StopWatch明细：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202007/603942-20200711014338478-9008194.png&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;122&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;问题就在那个一开始就认定不会有问题的逻辑里。&lt;/p&gt;
&lt;p&gt;其实本篇的出发点并不是要描述什么疑难线上问题的排查过程、方法、技巧。&lt;/p&gt;
&lt;p&gt;当我们面对问题时，真正阻我们，或者说会把我们引向错误方向的正式我们所固有的一种惯性认知，思维模式。&lt;/p&gt;
&lt;p&gt;任何时候对于未知，不要轻易去假定任何不确定的东西，经验可以是助益，同时也可能成为阻碍。&lt;/p&gt;
&lt;p&gt;问题面前，一切都值得怀疑，平等的怀疑。&lt;/p&gt;

</description>
<pubDate>Fri, 10 Jul 2020 18:04:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>一、引子 这要从线上的一个接口偶发异常耗时说起，事情往往不是你想象的样子，尤其是在排查问题的时候，切忌有先入为主的的某些判断。 二、问题： 接口监控图：显示每天总会有那么几次耗时特别长的请求。 三、排</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/13279319.html</dc:identifier>
</item>
<item>
<title>微信小程序开发中遇到的几个小问题 - ccneko</title>
<link>http://www.cnblogs.com/minxiang-luo/p/13282155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minxiang-luo/p/13282155.html</guid>
<description>&lt;h2 id=&quot;本地图片不显示，开发工具运行是没问题的，但真机调试却显示不了&quot;&gt;本地图片不显示，开发工具运行是没问题的，但真机调试却显示不了&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;item.img = '/goods/img/图片.png'&lt;/code&gt;&lt;br/&gt;&lt;code&gt;&amp;lt;image src=&quot;{{item.img}}&quot; class=&quot;image&quot;&amp;gt;&amp;lt;/image&amp;gt;&lt;/code&gt;&lt;br/&gt;经过仔细观察发现，&lt;strong&gt;路径是没问题的&lt;/strong&gt;，问题在于图片名&lt;strong&gt;不能是中文&lt;/strong&gt;的，把它改成字母+数字就好了。&lt;/p&gt;
&lt;h2 id=&quot;使用filesystemmanagerreaddirobject-object方法读取本地文件夹中的所有图片，报错readdirfail-no-such-file-or-directory&quot;&gt;使用FileSystemManager.readdir(Object object)方法读取本地文件夹中的所有图片，报错'readdir:fail no such file or directory'&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dirPath = '/goods/img'&lt;/code&gt;&lt;br/&gt;同样在开发工具上运行是没问题的，但真机调试就报错了。&lt;br/&gt;问题所在：将dirPath设成'/'，读取该文件夹下的所有文件名后得：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0: &quot;app-service.js&quot;
1: &quot;app-config.json&quot;
2: &quot;app-service.js.map&quot;
3: &quot;page-frame.html&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真机调试时，readdir方法的根目录并不是项目的根目录&lt;/p&gt;
&lt;p&gt;解决方案：暂无好的解决方法。（暂时用暴力法解决了：直接存下所有图片的名称，读取后再分割拼接路径。&lt;code&gt;imgNames = '0.png,1.png,2.png'&lt;/code&gt;）&lt;/p&gt;
&lt;h2 id=&quot;在js里读取其它json文件的内容&quot;&gt;在js里读取其它json文件的内容&lt;/h2&gt;
&lt;p&gt;短时间内没找到读取方法，因此用了替代方案：&lt;br/&gt;将数据存在js文件里，设为一个变量，再用require方法来引用这个js文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let list = [
  {
    &quot;id&quot;: &quot;1&quot;,
    &quot;name&quot;: &quot;测试产品名字&quot;,
    &quot;category&quot;: &quot;分类1&quot;,
    &quot;price&quot;: &quot;123.5&quot;,
    &quot;description&quot;: &quot;产品的简单介绍&quot;,
    &quot;img&quot;: &quot;0.png&quot;,
  },
  {
    &quot;id&quot;: &quot;2&quot;,
    &quot;name&quot;: &quot;测试产品名字2&quot;,
    &quot;category&quot;: &quot;分类2&quot;,
    &quot;price&quot;: &quot;125.5&quot;,
    &quot;description&quot;: &quot;产品的简单介绍&quot;,
    &quot;img&quot;: &quot;1.png,2.png,3.png,4.png&quot;,
  },
  ...
]
module.exports = {
  goodsList: list
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;let goodsInfo = require('../../goods/info.js');
let list = goodsInfo.goodsList
for(let goods of list){
    console.log(goods)
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 10 Jul 2020 16:55:00 +0000</pubDate>
<dc:creator>ccneko</dc:creator>
<og:description>本地图片不显示，开发工具运行是没问题的，但真机调试却显示不了 item.img = &amp;amp;#39;/goods/img/图片.png&amp;amp;#39; &amp;amp;lt;image src=&amp;amp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/minxiang-luo/p/13282155.html</dc:identifier>
</item>
<item>
<title>Java集合类初探 - LifeOfCoding</title>
<link>http://www.cnblogs.com/life-of-coding/p/13282104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/life-of-coding/p/13282104.html</guid>
<description>&lt;p&gt;  Java中基本的常用的集合类，主要包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;Queue&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几种类型的继承关系如图: &lt;a href=&quot;https://blog.csdn.net/weixin_42143155/article/details/80634736&quot;&gt;图片引自——Collection 和 Map的继承体系&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm0s4bxmcj30l3082q3h.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;其中 List、Queue 和 Set 继承自 Collection 接口，这三种集合的结构都比较简单，都是普通的元素的集合，而 Map 相对复杂一点，是键值对（key-value）的结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm2r64hldj306i0300sv.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm2rrch43j30au04iaaf.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;iterable&quot;&gt;Iterable&lt;/h2&gt;
&lt;p&gt;  Iterable 接口是 Collection 接口的“超类”，也就是说 Iterable 接口是 List、Set、Queue 这类简单集合的顶级接口，看下 Iterable 接口有些啥：&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm33g7qnsj307o02rt8r.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Iterable 接口包含三个方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;iterator() 返回一个迭代器用于迭代、遍历集合；&lt;/li&gt;
&lt;li&gt;forEach(Consumer&amp;lt;? super T&amp;gt;) 增强型for循环，配合 lambda 表达式食用更香；&lt;/li&gt;
&lt;li&gt;spliterator() 同样返回一个迭代器，该迭代器是“可分割迭代器”，为并行遍历集合而设计。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Iterable 接口的 forEach() 和 spliterator() 方法是用 default 关键字修饰的，接口里包含了方法的默认实现。&lt;/p&gt;
&lt;h2 id=&quot;iterator&quot;&gt;Iterator&lt;/h2&gt;
&lt;p&gt;  Iterator 也是一个接口，用于集合的遍历：&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm3b94oimj309d03e0su.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hasNext() 是否还有下一个元素，用于控制集合的遍历的结束；&lt;/li&gt;
&lt;li&gt;next() 返回一个元素，游标往后移。&lt;/li&gt;
&lt;li&gt;remove() 去除当前的元素(最近一次调用 next() 返回的元素)。想要在遍历集合时删除元素，需要用到 Iterator 迭代器和该方法。&lt;/li&gt;
&lt;li&gt;forEachRemaining(Consumer&amp;lt;? super E&amp;gt;) 对剩下的元素（即尚未被遍历到的元素）进行某些操作。和 Iterable 接口的 forEach() 有点类似。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm3ubhmkbj308e0ckaas.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  Collection 接口包含了集合的基本的增删查操作。既然是集合，那么以下基本方法是非常必要的:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取集合大小: size();&lt;/li&gt;
&lt;li&gt;添加元素: add();&lt;/li&gt;
&lt;li&gt;移除元素: remove();&lt;/li&gt;
&lt;li&gt;判断包含: contains();&lt;/li&gt;
&lt;li&gt;判断元素是否相等: equals();&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了增加可用性，又加多了几个方法:&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isEmpty() 判空，少写几句 &quot;collection.size==0&quot;;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;containsAll() 判断是否包含另一个集合里的所有元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;toArray()、toArray(T[]) 把集合转化为数组;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;clear() 清除所有元素;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;removeIf() 条件删除；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stream() 流操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;removeAll() 取补集，把另一个集合也包含的元素去除；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;addAll() 把另一个集合的元素添加进来，相当于取并集；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;retainAll() 取交集，把另一个集合也包含的元素保留下来；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;stream()、parrallelStream() 流操作、并行流操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm555hw5qj30cb0obtbe.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  List 中文译作“清单、列表”，List 是有序的，是按照一定的顺序来存储元素的，既然是有序的集合，就应该可以通过“游标”来进行访问，因此，List 在 Collection 的基础上添加了通过游标访问元素，或通过元素获取游标的方法:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;get(int);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add(int, E);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remove(int);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;indexOf(Object);&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;subList(int, int);通过游标截取子序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;lastIndexOf(Object); 因为 List 是有序的，所以可以通过“游标”确定唯一的元素，因此 List 是允许集合中包含相同(相等)的多个元素的，lastIndexOf(Object) 可以用来在集合包含多个相同元素时，获取该元素最后出现的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，List 还加上了 Collection 没有的“改”操作，实现了集合的“增删查改”:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;set(int, E); 替换某个位置的元素，既然是替换，前提条件是该位置含有元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为 List 是有序集合，因此给 List 加上排序操作是可取的:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sort(Comparator&amp;lt;? super E&amp;gt;);&lt;br/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在List接口中有一个 “ListIerator()”的方法，该方法返回一个 ListIterator 对象。&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm65mkt18j30du0g90tz.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;ListIterator 继承了 Iterator 接口,提供了 previous 操作，以及与游标相关的 nextIndex() 和 previousIndex()。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm6464ufaj307b087dg8.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  Queue（队列）是一种特殊的线性表，有的时候我们会因为业务需求，需要一个“规定容量的Queue”，这时，如果队列满了却又要添加元素，该采取怎样的策略，或者队列为空时调用remove该如何处理，这是需要考虑的。Queue 继承了 Collection，又提供了几个自己的方法：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;offer(E): 队尾添加元素，与 add 对应，当队列已满时返回false, add()方法这种情况下则会抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;poll(): 查询并删除队头元素，与 remove 对应，当队列为空时，不会像 remove 那样抛出异常，而是会返回 null;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;element(): 查询队头元素但不删除，与 peek 对应，队列为空时抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;peek(): 查询队头元素但不删除，队列为空时返回 null;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm6ur6nc2j30gc03yjru.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  Set 中文是“一组、一套”的意思。与 List 相比，Set 没有 List 的“列表、清单”的“列”的语义。Set 是无序的。 Set 与 Collection 在语义以及属性上最为接近，Set 继承了 Collection 的方法，没有自己新添加的方法，如下所示:&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm6rhloc4j30b10dzdha.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  &lt;br/&gt;Set 是没有 List 的 Index 的概念的，List 可以用 index 唯一确定一个元素，Map 可以用 key 唯一确定一个元素，而 Set 只能靠自身来唯一确定一个元素，所以 Set 里面的元素是不能重复的。正因为 Set 这一特性，可以使用 Set 给集合去重。&lt;/p&gt;

&lt;p&gt;  在词典中，Map 作动词时是“映射”的意思，key-value，key 映射到 value，可以通过 key 来获取 value。Map 和 Iterable 一样是顶级接口。Map 接口 UML 图如下：&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm7fp43gfj30da0g6ac2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;虽然 Map 是一个顶级接口，但是 Map 和 Set、List、Queue应该是同一层级的接口，它们的方法很多是类似的（功能上）。&lt;br/&gt;基本的增删查改:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;size();&lt;/li&gt;
&lt;li&gt;isEmpty();&lt;/li&gt;
&lt;li&gt;containsKey();&lt;/li&gt;
&lt;li&gt;containsValue();&lt;/li&gt;
&lt;li&gt;get();&lt;/li&gt;
&lt;li&gt;put();&lt;/li&gt;
&lt;li&gt;remove();&lt;/li&gt;
&lt;li&gt;putAll();&lt;/li&gt;
&lt;li&gt;clear();&lt;/li&gt;
&lt;li&gt;replace()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;键和值的遍历:&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;keySet(): 返回 key 的 Set 集合，因为 Map 靠 key 来唯一确定一个元素，所以 Map 的 key 是不能重复的，自然地，返回的 key 集合是一个 Set;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;values(): value 的值不会影响到 Map 的结构，value 是可以重复的，也是可以为 null 的，所以返回的 value 集合应该是一个 Collection;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;entrySet: 该方法返回的是 Entry 的 Set 集合， Entry 是 Map 的内部接口，可把其看作一对键值对的组合:&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm9g69dgqj30gh07pwfe.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其它的方法:&lt;/p&gt;
&lt;ul readability=&quot;19.17398911353&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;getOrDefault(Object, V): 如果找到 key 为 object 的键值对，则返回其 value, 否则返回自己传入的 V；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;putIfAbsent(K, V): 与 put(K, V) 对应，如果 Map 中已经包含 key 为 K 的键值对或键值对的值为空，put(K, V) 方法会用 V 覆盖原来的值；而 putIfAbsent(K, V)方法仅返回现在的值，不覆盖；当 Map 中不存在 key 为 k 的键值对时，put 和 putIfAbsent 都会添加新的元素。 概况说就是如果指定的键尚未映射（映射即关联，就是 key 和 value 的关联关系， value 为 null 也视为未映射或者说未关联），将其与给定值相关联并返回 null ，否则返回当前值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5920303605313&quot;&gt;
&lt;p&gt;compute(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction): 传一个BiFunction 对象进去实现值的“计算”，此处的“计算”应该是指“操作”，不仅仅是指算术上的“计算”。这与 VueJS 的“计算属性”有点类似。可以通过该方法实现 Map 数据的转换、数据的统计。&lt;br/&gt;BiFunction是一个接口，关键方法和说明如下图所示，可配合 lambda 表达式，是函数式编程的思想。&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggmb58e35oj30i6021t92.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggmazrhts9j30f3053wf1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggmaxrk3wbj30p702pwex.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;详情见&lt;a href=&quot;https://blog.csdn.net/weixin_39723544/article/details/91359302&quot;&gt;Java基础之Java8中Map的compute的使用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;computeIfAbsent(K key, Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction): 同 putIfAbsent 一样，如果 key 未映射( value 为 null 也视为未映射)，则尝试使用给定的映射函数计算其值，并将其输入到此映射中（即设置 value ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;computeIfPresent(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction): Present 与 Absent 相反，前者是“存在”的意思，后者是“不在”的意思，顾名思义，该方法是在指定的 key 在 Map 中存在映射时，则尝试计算给定key 及其当前值的新值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;merge&lt;/span&gt;(K key, V &lt;span&gt;value&lt;/span&gt;, BiFunction&amp;lt;? super V, ? super V, ? extends V&amp;gt; remappingFunction): merge 其实与 compute 这几个方法的作用是一样的，对 key 映射的 value 值进行变换，只是该方法多提供了一个参数 “V &lt;span&gt;value&lt;/span&gt;”，相当于用这个参数的 &lt;span&gt;value&lt;/span&gt; 和 key 所对应的 value &lt;span&gt;结合&lt;/span&gt;（&lt;span&gt;merge&lt;/span&gt;）起来一起变换；&lt;br/&gt;  比如想要让 Map 中存储的学生的年龄加“1”，使用 computer 的话，可以在函数里写定参数“1”；使用 merge 的话，可以在调用 merge 方法时把“1”传进去。这时，如果需求变了，年龄不是加“1”，而是加“2”，使用compute 方法的话需要到方法里面改这个“1”(magic num)；而使用 merge 的话只需要在方法调用时改参数，不用改其它代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 10 Jul 2020 16:33:00 +0000</pubDate>
<dc:creator>LifeOfCoding</dc:creator>
<og:description>目录 概述 Iterable和Iterator Collection List Queue Set Map 概述 Java中基本的常用的集合类，主要包含： List Set Queue Map 这几种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/life-of-coding/p/13282104.html</dc:identifier>
</item>
<item>
<title>Java入门系列之重写 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13276324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13276324.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;关于所有Java系列文章面向有一定基础的童鞋，所写每一篇希望有一定含金量，有些内容可能会从Java整个语法全局考虑穿插后续要讲解的内容以成系统，若不理解，请看完后再学习。上一节我们讲解完了final关键字，本节我们继续来对比讲解Java和C#中的重写，二者语言的重写区分非常清晰，Java子类中基类方法签名一样或通过注解@Override显式声明，C#中基类通过virtual关键字修饰，子类通过ovveride关键字表示重写，具体细节请往下看。&lt;/p&gt;
&lt;h2&gt;重写&lt;/h2&gt;
&lt;p&gt;既然是重写必然就涉及到继承，我们首先来看看Java中的重写是怎样的呢？如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Main.f&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Main main &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
        main.f();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Sub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Sub.f&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202007/589642-20200710224305023-1090906421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当调用基类的f方法时，此时发现已被子类所重写，所以如上正常打印出Sub.f，要是我们将上述基类中方法修改为私有的呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202007/589642-20200710225026012-1520389766.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202007/589642-20200710225052438-1138785004.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能我们期待输出子类中的打印结果，但是修改为私有后，说明此时对子类不再可见，也就相当于使用了final，在这种情况下，子类中方法则是一个全新的方法，很显然说明：&lt;span&gt;只有非私有方法才可以被重写。&lt;/span&gt;对于这种情况下编译不会报错， 但是也不会按照我们所期望的结果来执行，所以建议对于基类中的私有方法命名为和子类不同的名字，为了让重写一目了然或更加明确，在1.5版本发布了注解功能，我们可以通过注解来显式声明要重写基类方法，若基类为私有，此时通过注解则会编译报错，因为找不到要重写的方法，这种体验更加友好，比如如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Main.f&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Main main &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
        main.f();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Sub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译错误，未找到基类（超类）中要重写的方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Sub.f&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举一反三，我们来思考一个问题，是不是方法签名一致，子类就可以重写基类方法呢？很显然不是，若是静态方法，必然不能被重写，如果通过注解@Override声明那么必然编译报错，否则调用基类方法，对于接口中的静态方法同理。所以还是建议使用注解来声明重写。那么为什么通过注解显式声明重写基类方法或通过关键字final修饰方法就会在编译阶段报错呢？因为它们在编译阶段就完成了静态绑定，而不是运行时动态绑定。问题又来了，上述我们讲解到若在子类中不通过注解显式声明重写，同时在基类中方法私有，此时一定可以编译通过（上述已演示），并且会调用基类方法并打印出结果，事实情况一定是这样吗？很显然也不是如此，如下示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Super {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Super.f&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Derived &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Super {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Derived.f&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Super aSuper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Derived();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译报错（因为基类方法私有）&lt;/span&gt;
&lt;span&gt;        aSuper.f();
    }
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初一看，这不是一样么，其实是不一样，上述可以那是因为调用方在基类里面，当然可以调用内部的私有方法，如上情况只对基类内部私有， 当然也就不能调用，这里就又引出一个问题，是不是声明为基类的私有方法，子类就无法进行重写呢？根据我们上述打印的结果来看，理论上不可行，事实情况是可以的，通过内部类（后续会出文章详细讲解）来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
        System.out.println(&lt;/span&gt;&quot;Main.f&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Inner &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Main {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; f() {
            System.out.println(&lt;/span&gt;&quot;Inner.f&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类实例必须通过外部类实例创建&lt;/span&gt;
        Main outer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Main();
        Inner inner &lt;/span&gt;= outer.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inner();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类可以在内部访问外部的所有成员（包括私有）&lt;/span&gt;
&lt;span&gt;        inner.f();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用外部类方法&lt;/span&gt;
        outer =&lt;span&gt; inner;
        outer.f();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202007/589642-20200711001011668-807594933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C#若明确需要重写，那么基类方法声明为虚有的virtual，子类通过ovverride关键字修饰方法达到重写目的，若没有这两个关键字，和Java中一样只是方法签名一致，那么说明编译器会提醒是否通过new关键字来表明隐藏基类的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; F()
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main.f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Program program &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
        program.F();

        Console.ReadKey();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sub : Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; F()
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sub.f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Java和C#中的重写区分度非常清晰，Java中只要方法签名一致就可以达到重写，不过建议通过注解方法来显式声明重写以免引起不必要的问题，同时，即使基类方法私有，我们也可借助于内部类来实现重写。&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jul 2020 16:15:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 关于所有Java系列文章面向有一定基础的童鞋，所写每一篇希望有一定含金量，有些内容可能会从Java整个语法全局考虑穿插后续要讲解的内容以成系统，若不理解，请看完后再学习。上一节我们讲解完了fin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13276324.html</dc:identifier>
</item>
<item>
<title>记【域名备案被注销】后的9个小时 - 古道</title>
<link>http://www.cnblogs.com/gudao119/p/13281983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gudao119/p/13281983.html</guid>
<description>&lt;h2 id=&quot;收到通知&quot;&gt;收到通知&lt;/h2&gt;
&lt;p&gt;7月6日下午收到运维转告公司收到ICP的邮件，告知公司主站已被注销，该站的备案号已被收回。收到通知的那一刻就傻了，这意味这上百个子域名将被停用，紧接着就发现部分网站已经开始出现TestPage 184的提示。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/20625210-a8ad9ac567cae789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更换域名&quot;&gt;更换域名&lt;/h2&gt;
&lt;p&gt;第一时间想到的是更换域名，被注销的域名是xxx.com，公司名下还有一个xxx.cn的域名备案正常。于是开始购买 cn 域名的 SSL 证书，先把用户无感知的一些后台服务换成了 *.xxx.cn 的子域名。更换的过程中发现好多代码中硬编码了好多域名进去，于是召集研发排查硬编码的域名并更换。&lt;/p&gt;
&lt;h2 id=&quot;cname-的诱惑&quot;&gt;CNAME 的诱惑&lt;/h2&gt;
&lt;p&gt;域名换了几个发现进度太慢，距离被注销已经1个小时了，发现原有域名下的 CDN 服务并没有失效，难道是因为阿里云的 DNS 只是屏蔽了主域名，增加一层 CNAME 就绕过去了？怀着侥幸心理，把一个 yyy.xxx.com CNAME 的记录改为了 yyy.xxx.cn 并将 yyy.xxx.cn 的 A 记录改为了源站的IP。结果是竟然可以了，暗自窃喜了10分钟后，访问 yyy.xxx.com 发现网站又是 TestPage 184了。&lt;/p&gt;
&lt;h2 id=&quot;无奈之举，境外服务器&quot;&gt;无奈之举，境外服务器&lt;/h2&gt;
&lt;p&gt;CNAME 方法失败后开始反思，可选的方案有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更换域名&lt;/li&gt;
&lt;li&gt;原有域名解析到境外服务器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两种方案的优劣比较：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;优势&lt;/th&gt;
&lt;th&gt;劣势&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;解析境外&lt;/td&gt;
&lt;td&gt;配置简单、业务影响小&lt;/td&gt;
&lt;td&gt;访问速度慢、非长久之计，后期需要再调整回来&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;更换域名&lt;/td&gt;
&lt;td&gt;风险小、可长久使用&lt;/td&gt;
&lt;td&gt;配置繁琐、业务影响大&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;综合考虑后还是决定解析至境外的服务器，并用Nginx反向代理回境内服务器上。需要做的就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;购买新加坡节点的服务器，安装 Nginx ，配置反向代理。&lt;/li&gt;
&lt;li&gt;解析原有域名至新加坡服务器的IP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面列出一个站点的 Nginx 配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 443 ssl;
    server_name libraryplus.api.xxx.com photo.api.xxx.com;
    root html;
    index index.html index.htm;
    ssl_certificate   /etc/nginx/api.xxx.com.pem;
    ssl_certificate_key  /etc/nginx/api.xxx.com.key;
    ssl_session_timeout 5m;
    ssl_ciphers RC4:HIGH:!aNULL:!MD5;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    client_max_body_size   1024m;
    location / {
            proxy_pass http://39.107.253.80:80;
            proxy_redirect  off;
             if ( $host ~* (.*)\.com )
            {
                set $host_my $1;
            }
            proxy_set_header  Host  $host_my.cn;
            proxy_set_header  X-Real-IP  $remote_addr;
            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中需要强调的一个地方是 &lt;code&gt;proxy_set_header Host&lt;/code&gt; 的配置。因为原有域名是被阿里云的防火墙过滤的，如果不修改回源的 Host 的话，即使 DNS 可以逃脱，内容还是会被拦截的。所以 Host 改为一个已备案的域名就可以了，上面我通过正则批量改成了 .cn ，对应的要在后端的web服务器上做对应的修改，如 IIS 里要在站点的网站绑定里添加对应 cn 域名的主机头。&lt;br/&gt;至此，在7日的凌晨3点把120多个子网站全部配置完成，客户感知的最长宕机时间为9个小时...&lt;/p&gt;
&lt;h2 id=&quot;恢复操作&quot;&gt;恢复操作&lt;/h2&gt;
&lt;p&gt;9日下午收到ICP的备案通过邮件，告知备案已通过，域名可以在7小时内生效。（正常的审核速度应该是7-14个工作日，后来才得知，注销和再次审核通过都是有背后操作的。）&lt;br/&gt;从境外的撤离操作就简单很多，业务站点几乎不用动，只要把域名的 DNS 重新解析回原来的IP就可以了，web站点绑定的备用域名主机头可以删了，境外服务器也可以释放了。&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jul 2020 15:29:00 +0000</pubDate>
<dc:creator>古道</dc:creator>
<og:description>收到通知 7月6日下午收到运维转告公司收到ICP的邮件，告知公司主站已被注销，该站的备案号已被收回。收到通知的那一刻就傻了，这意味这上百个子域名将被停用，紧接着就发现部分网站已经开始出现TestPag</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gudao119/p/13281983.html</dc:identifier>
</item>
<item>
<title>闲谈设计模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/design-patterns.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/design-patterns.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;/p&gt;
&lt;p&gt;了解这些前辈们总结出来的经验有助于帮助你写出来更优秀的代码，帮助你写出可扩展、可读、可维护的高质量代码。&lt;/p&gt;
&lt;p&gt;在极客时间里推出了数据结构和设计模式的王争说了一句话，如果说“数据结构与算法之美”是教你写出高效的代码，那设计模式就是教你写出高质量的代码。&lt;/p&gt;
&lt;h2 id=&quot;为什么要学习设计模式&quot;&gt;为什么要学习设计模式&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;提升自己代码质量，告别写被人吐槽的烂代码&lt;/li&gt;
&lt;li&gt;提高复杂代码的设计和开发能力，设计出扩展性良好，可维护性更强，可复用性更好的代码&lt;/li&gt;
&lt;li&gt;让读源码、学框架事半功倍，学会设计模式，在看框架源码的时候会更好的理解框架中的一些功能设计&lt;/li&gt;
&lt;li&gt;为你的职场发展做铺垫，提升自己 code review 能力，把控团队代码质量&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;设计模式设计原则&quot;&gt;设计模式设计原则&lt;/h2&gt;
&lt;p&gt;设计原则是指导我们代码设计的一些经验总结，对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单一职责原则&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;对于一个类而言，应该仅有一个引起它变化的原因&lt;/p&gt;
&lt;p&gt;如果一个类承担的职责过多，就等于把这些职责耦合再一起，一个职责的变化可能会削弱或者抑制这个类完全其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;开放-封闭原则&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;开放-封闭原则是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。&lt;/p&gt;
&lt;p&gt;对于扩展开放，对于更改封闭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依赖倒转原则&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;高层模块不应该依赖低层模式，两个都应该依赖抽象。&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节，细节应该依赖于抽象。基于接口编程。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;里氏代换原则&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;子类型必须能够替换掉它们的父类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;接口隔离原则&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用多个隔离的接口,比使用单个接口好，建立最小的接口&lt;/p&gt;
&lt;p&gt;一个接口只负责一个功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;迪米特法则&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。&lt;/p&gt;
&lt;p&gt;类的结构设计上，每一个类都应当尽量降低成员的访问权限&lt;/p&gt;
&lt;p&gt;类之间的耦合越弱，越有利于复用，一个处在弱耦合的类别修改，不会对有关系的类造成波及&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;overview-概览&quot;&gt;Overview 概览&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeihanLi/DesignPatterns&quot;&gt;【DesignPatterns】&lt;/a&gt; 项目是用 C# 写的一些设计模式的示例，基于 .netcore 3.1，大部分示例来自《大话设计模式》&lt;/p&gt;
&lt;p&gt;设计模式大体上可分为三类：&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;我们上面提到的设计原则有六个，现在有的文章说是有七个，多出来的一个原则是 “组合由于继承”，主要是强调多用组合而非继承，因为继承可能会引入很多不必要的东西，而且很多语言的设计是不允许多继承的，C# 就是单继承的语言，一个类只能有一个父类。&lt;/p&gt;
&lt;p&gt;继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题，所以很多情况下组合是比继承更好一些的。&lt;/p&gt;
&lt;p&gt;王争在设计模式专栏中总结了一些设计模式和设计原则的一些知识点，分享一下，可以作为学习设计模式的参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202007/489462-20200710223629310-642591316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 10 Jul 2020 15:03:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>设计模式瞎扯淡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/design-patterns.html</dc:identifier>
</item>
</channel>
</rss>