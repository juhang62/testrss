<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程池(详解)：三大方法、七大参数、四种拒绝策略 - 你的龙儿</title>
<link>http://www.cnblogs.com/liangbaolong/p/13193591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangbaolong/p/13193591.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程池（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
　　&lt;span&gt;池化技术：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　01：程序的运行，本质 ：占用系统的资源！ 优化资源的使用！  =&amp;gt;池化技术&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　02：线程池、连接池、内存池、对象池///......创建、销毁。 十分浪费资源&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　03：池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　线程池的好处：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　01：降低资源的消耗&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　02：提高响应的速度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    　　03：方便管理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   　　（重点）线程复用、可以控制最大并发数、管理线程&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;二：三大方法：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;01：Executors.newSingleThreadExecutor()　　//单个线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　&lt;span&gt;代码示例01&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Executors 工具类、3大方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo01 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         ExecutorService threadpool = Executors.newSingleThreadExecutor();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个线程&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 threadpool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             threadpool.shutdown();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果： （10个任务被同一个线程所操作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625230208858-615972971.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;362&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　&lt;span&gt;&lt;strong&gt;　02：newFixedThreadPool(int nThreads)　　　　 //创建一个固定的线程池的大小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;代码示例02&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Executors 工具类、3大方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo01 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最多5个线程同时执行，从控制台中查看结果&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         ExecutorService threadpool = Executors.newFixedThreadPool(5);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个固定的线程池的大小，（5个线程）&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 threadpool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             threadpool.shutdown();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：（最高同时有5个线程在执行）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625230939124-2118360533.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;314&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;　　&lt;strong&gt;&lt;span&gt;03：newCachedThreadPool() 　　　　 //缓存池，可伸缩的， 遇强则强，遇弱则弱&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　代码示例03&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Executors 工具类、3大方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo01 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         ExecutorService threadpool = Executors.newCachedThreadPool();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存池，可伸缩的， 遇强则强，遇弱则弱&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 threadpool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             threadpool.shutdown();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：（最高同时有10个线程在执行，可伸缩的， 遇强则强，遇弱则弱）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625231533889-382450339.png&quot; alt=&quot;&quot; width=&quot;502&quot; height=&quot;294&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;三：七大参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;　&lt;span&gt;01：三大方法之源码分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　 (1)  newSingleThreadExecutor()             &lt;strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个线程&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                                             0L&lt;span&gt;, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                                             &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         ==================================================================================
&lt;span&gt;10&lt;/span&gt;         (2)  newFixedThreadPool(&lt;span&gt;int&lt;/span&gt; nThreads)       &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个固定的线程池的大小&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                                               0L&lt;span&gt;, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                                               &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         ===================================================================================
&lt;span&gt;18&lt;/span&gt;         (3)  newCachedThreadPool()                  &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存池，可伸缩的， 遇强则强，遇弱则弱&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0, Integer.MAX_VALUE,     &lt;strong&gt;&lt;span&gt;//Integer.Max_VALUE  &lt;/span&gt;&lt;span&gt;约等于21亿  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们有这么多条线程一起跑的话，电脑会OOM(溢出)，出现问题&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;22&lt;/span&gt;                                               60L&lt;span&gt;, TimeUnit.SECONDS,                          
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                                               &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());             
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         ====================================================================================
&lt;span&gt;26&lt;/span&gt;         (4&lt;span&gt;) 三大方法所公共的  ThreadPoolExecutor() 方法
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                                         &lt;span&gt;&lt;strong&gt;******7大参数******&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt; corePoolSize,                        &lt;strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心线程池大小&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;31&lt;/span&gt;                                       &lt;span&gt;int&lt;/span&gt; maximumPoolSize,                  &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大核心线程池大小&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;32&lt;/span&gt;                                       &lt;span&gt;long&lt;/span&gt; keepAliveTime,                   &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了没有人调用就会释放&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;33&lt;/span&gt;                                       TimeUnit unit,                        &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时单位&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;34&lt;/span&gt;                                       BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,    &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞队列&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;35&lt;/span&gt;                                       ThreadFactory threadFactory,          &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程工厂，创建线程的，一般不用动&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;36&lt;/span&gt;                                       RejectedExecutionHandler handler) {   &lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拒绝策略&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||
&lt;span&gt;38&lt;/span&gt;                     maximumPoolSize &amp;lt;= 0 ||
&lt;span&gt;39&lt;/span&gt;                     maximumPoolSize &amp;lt; corePoolSize ||
&lt;span&gt;40&lt;/span&gt;                     keepAliveTime &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
　　&lt;span&gt;阿里巴巴开发手册中有如下规定：&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625232826809-688365608.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;193&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;例如银行办理业务图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625233315601-1126195643.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;429&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;四：四种拒绝策略：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625233948212-1753813460.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;span&gt;&lt;br/&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * new ThreadPoolExecutor.AbortPolicy()         //银行满了，还有人进来，不处理这个人的，抛出异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * new ThreadPoolExecutor.CallerRunsPolicy()    //哪来的去哪里！&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * new ThreadPoolExecutor.DiscardPolicy()       //队列满了，丢掉任务，不会抛出异常！&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试和最早的竞争，也不会抛出异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt; */&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五：手动（自定义）创建一个线程池：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　&lt;/p&gt;&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;代码示例01　　　　new ThreadPoolExecutor.AbortPolicy()　　//银行满了，还有人进来，不处理这个人的，抛出异常&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingDeque;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo02 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程池！ 工作中只会使用 ThreadPoolExecutor&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         ThreadPoolExecutor threadPool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 2,                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心线程池大小&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 5,                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大核心线程池大小&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 3,                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了没有人调用就会释放&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 TimeUnit.SECONDS,                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时单位&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3),          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞队列&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Executors.defaultThreadFactory(),               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程工厂，创建线程的，一般不用动&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.AbortPolicy());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;银行满了，还有人进来，不处理这个人的，抛出异常&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大承载数，Deque + Max    (队列线程数+最大线程数)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超出 抛出 RejectedExecutionException 异常&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 threadPool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             threadPool.shutdown();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果（对比）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625235125803-2091055123.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;252&quot; loading=&quot;lazy&quot;/&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625235333993-1728853073.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;252&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625235607146-2046523000.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;266&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625235800986-1308526764.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;266&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200625235926635-1452847183.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;287&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200626000125440-1812915957.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;285&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;　代码示例02　　　　new ThreadPoolExecutor.CallerRunsPolicy()　　　　//哪来的去哪里&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingDeque;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo02 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程池！ 工作中只会使用 ThreadPoolExecutor&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         ThreadPoolExecutor threadPool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 2,                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心线程池大小&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 5,                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大核心线程池大小&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 3,                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了没有人调用就会释放&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 TimeUnit.SECONDS,                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时单位&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3),          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞队列&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Executors.defaultThreadFactory(),               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程工厂，创建线程的，一般不用动&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;哪来的去哪里！&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大承载数，Deque + Max    (队列线程数+最大线程数)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超出 抛出 RejectedExecutionException 异常&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 threadPool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             threadPool.shutdown();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200626001050757-2099375262.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;306&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 　&lt;span&gt;　代码示例03　　　　new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingDeque;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo02 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程池！ 工作中只会使用 ThreadPoolExecutor&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         ThreadPoolExecutor threadPool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 2,                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心线程池大小&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 5,                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大核心线程池大小&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 3,                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了没有人调用就会释放&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 TimeUnit.SECONDS,                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时单位&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3),          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞队列&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Executors.defaultThreadFactory(),               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程工厂，创建线程的，一般不用动&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了，丢掉任务，不会抛出异常！&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大承载数，Deque + Max    (队列线程数+最大线程数)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超出 抛出 RejectedExecutionException 异常&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 threadPool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             threadPool.shutdown();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200626001450033-1538240602.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;292&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 　　04：代码示例　　　　new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试和最早的竞争，也不会抛出异常&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingDeque;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo02 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程池！ 工作中只会使用 ThreadPoolExecutor&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         ThreadPoolExecutor threadPool = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 2,                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心线程池大小&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 5,                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大核心线程池大小&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 3,                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了没有人调用就会释放&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 TimeUnit.SECONDS,                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时单位&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3),          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞队列&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Executors.defaultThreadFactory(),               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程工厂，创建线程的，一般不用动&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardOldestPolicy());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了，尝试和最早的竞争，也不会抛出异常&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大承载数，Deque + Max    (队列线程数+最大线程数)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超出 抛出 RejectedExecutionException 异常&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了线程池之后，使用线程池来创建线程&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 threadPool.execute(()-&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     System.out.println(Thread.currentThread().getName()+&quot; ok&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程池用完，程序结束，关闭线程池&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             threadPool.shutdown();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（为确保关闭，将关闭方法放入到finally中）&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1992438/202006/1992438-20200626001753899-1982247034.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;296&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jun 2020 00:37:00 +0000</pubDate>
<dc:creator>你的龙儿</dc:creator>
<og:description>线程池（重点） 一：线程池：三大方法，七大参数，四种拒绝策略 池化技术： 01：程序的运行，本质 ：占用系统的资源！ 优化资源的使用！ =&amp;gt;池化技术 02：线程池、连接池、内存池、对象池///.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liangbaolong/p/13193591.html</dc:identifier>
</item>
<item>
<title>Zookeeper分布式过程协同技术 -  部署及设置 - 汤圆爹爹</title>
<link>http://www.cnblogs.com/tydd/p/13192915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tydd/p/13192915.html</guid>
<description>[unable to retrieve full-text content]Zookeeper分布式过程协同技术 - 部署及设置 Zookeeper支持单机模式、伪集群模式、集群模式三种部署方式。演示部署环境为CentOS、jdk版本为1.8、Zookeeper版本为3.4.9。 单机模式 单机模式适合入门学习使用，只需要一台机器就可以轻松搭建Zookeeper服务用于学习</description>
<pubDate>Thu, 25 Jun 2020 23:41:00 +0000</pubDate>
<dc:creator>汤圆爹爹</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Ftydd%2Fp%2F13192915.html</dc:identifier>
</item>
<item>
<title>Django实现图片上传并前端页面显示 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13193677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13193677.html</guid>
<description>&lt;h4 id=&quot;django实现图片上传和图片显示&quot;&gt;Django实现图片上传和图片显示&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;开始之前我们先确认环境中已经安装了Pillow,如果没有安装,可以通过pip install Pillow来安装,这个是python的图像处理库&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据库设置&quot;&gt;数据库设置&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;我们创建好项目后先在项目创建一个app&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py startapp app01


# 然后将其加入到settings.py文件中
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app01',
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;数据库中建立保存图片的表&quot;&gt;数据库中建立保存图片的表&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models

class Userprofile(models.Model):
    name = models.CharField(max_length=20)
    icon = models.ImageField(upload_to=&quot;uploads/%Y/%m/%d&quot;,verbose_name=&quot;用户头像&quot;)

    class Meta:
        db_table = 'userprofile'
        verbose_name = '用户表'
        verbose_name_plural = verbose_name

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;这里的upload_to是指定图片存储的文件夹名称，上传文件之后会自动创建&lt;/p&gt;
&lt;p&gt;执行命令做数据迁移，在执行迁移文件在数据库中创建表。&lt;/p&gt;
&lt;p&gt;此处我们使用django自带的数据库,你也可以自己在settings里面配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;修改settingspy&quot;&gt;修改settings.py&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;只需要在最后的静态文件区加上下面两行代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.media'
            ],
        },
    },
]



STATIC_URL = '/static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
MEDIA_URL = '/static/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'static/media')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置项目逻辑&quot;&gt;配置项目逻辑&lt;/h4&gt;
&lt;h5 id=&quot;配置项目视图函数&quot;&gt;配置项目视图函数&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 项目根路径/urls.py
from django.conf.global_settings import MEDIA_ROOT
from django.contrib import admin
from django.urls import path, re_path, include
from django.views.static import serve

from app01.views import *

urlpatterns = [
    path('admin/', admin.site.urls),
    re_path(r'media/(?P&amp;lt;path&amp;gt;.*)$', serve, {'document_root': MEDIA_ROOT}),
    path('app01/', include('app01.urls')),
]

# app01/urls.py
from django.conf.global_settings import MEDIA_ROOT
from django.contrib import admin
from django.urls import path, re_path
from django.views.static import serve

from app01.views import index

urlpatterns = [
    path('index',index),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建模板&quot;&gt;创建模板&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在templates文件下创建一个文件（最好是我们的app的名字，以此来把页面按app分开），比如叫app1，然后在app1文件下创建我们的前端页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;aaaaaaa&amp;lt;/h1&amp;gt;
&amp;lt;img src={{ MEDIA_URL }}{{ url }} alt=&quot;test&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建admin后台账号&quot;&gt;创建admin后台账号&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py createsuperuser
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;定义admin后台&quot;&gt;定义admin后台&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;admin.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib import admin

from app01.models import Userprofile

admin.site.register(Userprofile)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;访问admin后台&quot;&gt;访问admin后台&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200626014507861-803934198.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200626014521996-607640393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;验证前端图片访问&quot;&gt;验证前端图片访问&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;我们先去数据库表看一下对应的url路径&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3333 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200626014535513-79928398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;我们可以先用IP:Port/static/icon路径访问看下能不能直接加载图片&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200626014646829-1137705221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200626014637837-1382482181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 17:47:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>Django实现图片上传和图片显示 开始之前我们先确认环境中已经安装了Pillow,如果没有安装,可以通过pip install Pillow来安装,这个是python的图像处理库 数据库设置 我们创</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13193677.html</dc:identifier>
</item>
<item>
<title>Jmeter系列（34）- 详解 Counter 计数器 - 小菠萝测试笔记</title>
<link>http://www.cnblogs.com/poloyy/p/13193447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/poloyy/p/13193447.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果你想从头学习Jmeter，可以看看这个系列的文章哦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/poloyy/category/1746599.html&quot;&gt;https://www.cnblogs.com/poloyy/category/1746599.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;简单介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;计数器的作用：循环递增生成数字&lt;/li&gt;
&lt;li&gt;计数器使用 long 来存储值，因此取值范围是 &lt;span&gt;&lt;strong&gt;-2 ^ 63&lt;/strong&gt;&lt;/span&gt; 到 &lt;span&gt;&lt;strong&gt;2 ^ 63-1 &lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可以在线程组任意地方添加计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计数器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625201757726-1437495883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;计数器界面介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625201806994-1957414503.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;字段介绍&lt;/h4&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Starting value&lt;/td&gt;
&lt;td&gt;初始值，long 整型，默认 0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Increment&lt;/td&gt;
&lt;td&gt;每次迭代的递增值，默认 0，表示不增加&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Maximum value&lt;/td&gt;
&lt;td&gt;最大值，包含此值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Number format&lt;/td&gt;
&lt;td&gt;数字可选格式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exported Variable Name&lt;/td&gt;
&lt;td&gt;引用名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Track counter independently for rach user&lt;/td&gt;
&lt;td&gt;每个用户都有一个独立的计数器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Reset counter on each Thread Group Iteration&lt;/td&gt;
&lt;td&gt;每次线程组迭代时计数器将重置为初始值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;最基础的栗子&lt;/h2&gt;
&lt;p&gt;只有计数器的情况下的栗子&lt;/p&gt;
&lt;h3&gt;线程组结构树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625230817998-79278903.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;线程组属性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231033309-147179514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;共有 15 个线程，模拟 15 个用户&lt;/p&gt;

&lt;h3&gt;计数器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625230827935-1591747622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计数器最多循环计数 10 次&lt;/p&gt;

&lt;h3&gt;运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231111507-1943328051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，因为有 15 个用户，但计数器最多循环计数 10 次，所以第一轮循环结束后会重头开始&lt;/p&gt;

&lt;h2&gt;计数器 + 循环控制器的栗子&lt;/h2&gt;
&lt;h3&gt;线程组结构树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231321344-333362685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;线程组属性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231417910-1438600170.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;共有 5 个线程，模拟 5 个用户&lt;/p&gt;

&lt;h3&gt;循环控制器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231519882-778911139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程运行 3 次&lt;/p&gt;

&lt;h3&gt;计数器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231438389-1987346442.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计数器最多循环计数 30 次&lt;/p&gt;

&lt;h3&gt;未勾选【与每用户独立的跟踪计数器】的运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231629128-2079350171.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为有 5 个线程，每个线程循环 3 次，一共 15 个请求，所以计数器是循环了 15 次&lt;/li&gt;
&lt;li&gt;此时计数器是对&lt;span&gt;&lt;strong&gt;所有线程共享&lt;/strong&gt;&lt;/span&gt;的，属于线程组全局计数器，所以计数器是累计循环了 15 次&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;勾选【与每用户独立的跟踪计数器】的运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202006/1896874-20200625231718371-1287559514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个线程运行时，计数器都是从初始值算起的&lt;/li&gt;
&lt;li&gt;此时计数器是&lt;span&gt;&lt;strong&gt;每个线程独享&lt;/strong&gt;&lt;/span&gt;的，不再是公共计数器，所以每次有&lt;span&gt;&lt;strong&gt;新的线程运行&lt;/strong&gt;&lt;/span&gt;时，都是新的计数器开始循环计数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计数器的一些注意事项&lt;/h2&gt;
&lt;p&gt;使用计数器生成的变量，值的类型为 string，所以有比较之类的操作时，需要带 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt; 操作&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jun 2020 15:30:00 +0000</pubDate>
<dc:creator>小菠萝测试笔记</dc:creator>
<og:description>如果你想从头学习Jmeter，可以看看这个系列的文章哦 https://www.cnblogs.com/poloyy/category/1746599.html 简单介绍 计数器的作用：循环递增生成数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/poloyy/p/13193447.html</dc:identifier>
</item>
<item>
<title>Zookeeper分布式过程协同技术 - 概念及基础 - 汤圆爹爹</title>
<link>http://www.cnblogs.com/tydd/p/13192980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tydd/p/13192980.html</guid>
<description>&lt;h2&gt;&lt;span&gt;Zookeeper是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Zookeeper是一种分布式过程协同技术，其所提供的客户端API功能强大，其中包括：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;保障强一致性。有序性和持久性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现通用的同步原语的能力。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在实际分布式系统中，并发往往导致不正确的行为。Zookeeper提供了一种简单的并发处理机制。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;关于Zookeeper名字的来源&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Zookeeper由雅虎研究院开发，开发团队原来想使用动物命名项目，在讨论时大家觉得分布式系统就像一个动物园，胡乱且难以管理，而Zookeeper就是将这一切变得可控。遂起名为Zookeeper，意为动物园管理员。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Zookeeper使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;命名服务&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;命名服务是指通过路径名称来获取服务的地址。首先zookeeper创建一个全局路径，服务方在全局路径下写入服务的地址（或者名称），服务消费方在启动后watch全局路径的数据和变化。注意，这里的节点均为临时节点，在服务连接中断或者宕机时，通过临时节点消失能够通知订阅方感知变化。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;配置管理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;服务分布部署在不同的机器上，将全局的配置信息存放于zookeeper的节点下，客户端通过订阅节点的数据变化获取到配置信息。当节点中的配置信息发生变化时，客户端可以通过watch节点发送的消息感知，从而修改服务本地的配置管理信息。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;集群管理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当有新机器加入集群时，由新机器的客户端在指定的目录下新建临时节点，服务注册管理端通过订阅指定目录的变化，收到了新增节点的通知后，将新机器加入集群服务的列表。当机器退出集群或者宕机时，临时节点将会被删除，同样可以通知服务注册管理端，有机器退出了集群。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;分布式锁&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;zookeeper的分布式锁可以分为2种，保持独占或者控制时序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于保持独占来说，可以把一个节点看做是一把锁，通过创建节点的方式来抢占锁资源。如果创建节点成功，客户端也就持有了这把锁，如果创建失败，则订阅节点的变化，如果收到节点删除消息，再次尝试创建节点来抢占锁资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于控制时序来说，通过在指定目录下创建临时有序节点，编号最小的节点首先持有锁资源，每个后续节点都订阅前一个节点。拥有锁资源的客户端在操作完毕后，删除自己创建的节点。后续节点收到前置节点的删除通知后，即获取了锁资源，可以进行业务操作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Zookeeper基础&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Zookeeper通过节点（znode）来实现原语的功能，并不直接暴露原语。Znode指Zookeeper操作和维护一个小型的数据节点，类似于文件系统的层级树状结构进行管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2056115/202006/2056115-20200625215907425-1377597255.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;图：Zookeeper数据结构示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt; /作为跟目录节点，根节点下有/workers和/tasks两个字节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;/workers节点作为父节点，其下的每一个znode子节点用于保存系统中的可用worker，节点中保存着worker子节点的元数据信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;/tasks节点作为父节点，其下每个znode子节点用于保存一个代执行的任务，节点中保存着任务的详细数据。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;API概念&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ZookeeperAPI提供了以下方法来实现地znode的控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;create /path data&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建一个名为/path的znode节点，并包含数据data。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delete /path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删除名为/path的znode。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exists /path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　检查是否存在名为/path的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;setData /path data&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　设置名为/path的znode节点的数据为data。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getData /path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　返回名为/path节点的数据信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getChildren /path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　返回所有/path节点的所有子节点列表。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Znode类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在新建znode时，需要指定该节点类型，不同的类型决定了znode节点的行为方式，Zookeeper提供了4种不同的znode类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;持久节点和临时节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;znode节点可以是持久（persistent）节点，还可以是临时（ephemeral）节点。持久的znode，如/path，只能通过delete来进行删除。临时的znode与之相反，当创建的客户端崩溃或者关闭了与Zookeeper的连接时，这个节点就会被删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持久znode是一种非常有用的znode，可以通过持久类型znode为应用保存一些数据，即使znode的创建者不再属于应用系统时，数据也可以保存下来而不丢失。例如，在主-从模式中，需要保存从节点的任务分配情况，即使分配任务的主节点已经崩溃了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个临时znode，在以下两种情况会被删除：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;当创建该znode的客户端的会话因超时或主动关闭而中止时。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当某个客户端（不一定是创建者）主动删除该节点时。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;注：因为临时的znode在其创建者的会话过期时被删除，所以我们现在不允许临时节点拥有子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;有序节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个有序znode节点被分配唯一一个单调递增的整数。当创建有序节点时，一个序号会被追加到路径之后。例如，客户端创建一个有序znode节点，其路径为/tasks/task-,那么该znode节点为/tasks/task-1。有序znode通过提供了创建具有唯一名称的znode的简单方式。同时也通过这种方式可以直观地查看znode的创建顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Znode一共有四种：持久节点、临时节点、持久有序节点，临时有序节点。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;监视与通知&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Zookeeper提供基于通知的机制提供对节点的监视能力。客户端向Zookeeper注册需要接收通知的znode，通过对znode的设置监视点（watch）来接收通知。监视点是一个单次触发的操作，每次设置只会触发一次。为了接收多个通知，客户端必须在每次通知后设置新的监视点。在设置新监视点前客户端会先读取znode中的数据，所以不同担心会错过状态的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zookeeper可以定义不同类型的通知，如监控znode的数据变化、监控znode子节点的变化、监控znode的创建或删除。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 14:33:00 +0000</pubDate>
<dc:creator>汤圆爹爹</dc:creator>
<og:description>Zookeeper分布式过程协同技术 - 概念及基础 Zookeeper是什么？ Zookeeper是一种分布式过程协同技术，其所提供的客户端API功能强大，其中包括： 保障强一致性。有序性和持久性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tydd/p/13192980.html</dc:identifier>
</item>
<item>
<title>面试官：你刚说你喜欢研究新技术，那么请说说你对 Blazor 的了解 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13193234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13193234.html</guid>
<description>&lt;p&gt;阅读本文大概需要 1.5 分钟。&lt;/p&gt;
&lt;p&gt;最近在几个微信 .NET 交流群里大家讨论比较频繁的话题就是这几天自己的面试经历。&lt;/p&gt;
&lt;p&gt;面试官：“你刚说你喜欢研究新技术，那么你对 Blazor 了解多少？”。&lt;/p&gt;
&lt;p&gt;作为一位专注于 .NET 开发的软件工程师，你好意思说你对 Blazor 一点也不解吗？.NET 新技术也就是那么几个，连微软最近在逛推的 Blazor 你都不了解，你好意思说你喜欢研究新技术？&lt;/p&gt;
&lt;p&gt;讲真，确实有很多童鞋对 Blazor 还不了解，平时埋头写代码改 Bug，哪有时间去研究 Blazor，再说这种玩意儿公司会不会采用还是个很大疑问呢。是这个理，但如果等你的公司（国内使用了.NET 技术的公司）都开始使用 Blazor 了，Blazor 还能算是新技术吗？出于真正对技术的兴趣和热爱，对于新技术，有人会主动地去了解（不一定要研究得很深），而不是等到需要用的时候再去了解。至少他们会知道新技术有哪些优点，在公司技术选型上就可以给到自己的意见甚至推广新技术的使用，这可能就是他们和普通程序员拉开差距的原因之一。&lt;/p&gt;
&lt;p&gt;不管你是真对 Blazor 感兴趣，还是只是为了应付面试，作为 .NET 开发者，你没用过 Blazor，至少应该了解一下吧，哪怕是花个一两分钟看看这篇文章的介绍。&lt;/p&gt;
&lt;h2 id=&quot;使用-c-实现-web-交互式-ui&quot;&gt;使用 C# 实现 Web 交互式 UI&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202006/191097-20200625222337470-1854195615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Blazor 允许你使用 C# 来实现 Web 交互式 UI，而不需要使用 JavaScript。尽管 JavaScript 的生态很强大，但这种弱类型语言在业务逻辑比较复杂的大型 Web 开发上还是存在较大的缺陷。当然，经过几年的发展 JavaScript 的弱类型问题可以通过工程手段来解决，甚至使用 TypeScript 来替代，但在实现可重用组件上还是有诸多的不理想。&lt;/p&gt;
&lt;p&gt;Blazor 应用可以使用 C#、HTML 和 CSS 实现可重用 Web UI 组件，客户端和服务器代码都用 C# 编写的，允许你共享代码和库。Blazor 是 ASP.NET Core 的一个新特性，所以可以很好的集成到 ASP.NET Core MVC/Razor Pages 应用中。&lt;/p&gt;
&lt;p&gt;下面是一段来自于模板的 Blazor 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;@page &quot;/counter&quot;

&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;

&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在-webassembly-或服务器端运行&quot;&gt;在 WebAssembly 或服务器端运行&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202006/191097-20200625222516902-1322827329.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Blazor 支持两种运行方式，一是在客户端使用 WebAssembly 运行，二是在服务器端运行直接渲染到浏览器。&lt;/p&gt;
&lt;p&gt;Blazor 可以使用 WebAssembly 直接在浏览器中运行客户端 C# 代码，正因为它是运行在 WebAssembly 上的 .NET 程序，所以客户端也可以重用服务器端的代码和库。&lt;/p&gt;
&lt;p&gt;即使不使用 WebAssembly，Blazor 也可以在服务器端运行客户端的业务逻辑。客户端 UI 事件使用实时消息框架 SignalR 发送回服务器，一旦执行完成，所需的 UI 更改将发送到客户端渲染到 DOM 中。&lt;/p&gt;
&lt;p&gt;目前主流开发单页应用（SPA）使用 Vue 或 React 的很多，但要实现服务器端渲染（SSR），还是挺麻烦的，尽管有现成的像 Next.js 或 Nuxt.js 这样的框架可以使用，但由于它们更新迭代比较快，依赖的 npm 包多而杂，后期维护和升级成本也很高。所以从 SSR 支持这一点来讲，Blazor 应用还是有明显优势的。&lt;/p&gt;
&lt;h2 id=&quot;基于开放的-web-标准&quot;&gt;基于开放的 Web 标准&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202006/191097-20200625222657160-499841321.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常是为了使用统一的编程语言或使用统一的标准，常见的做法是将一种编程语言编写的代码转换为另一种编程语言，比如将 TypeScript 编写代码转换成 JavaScript 以便在浏览器中运行。而 Blazor 使用的是开放的 Web 标准，不需要额外的插件或代码语言转换。Blazor 可以在所有主流的 Web 浏览器中工作，包括移动端浏览器。&lt;/p&gt;
&lt;p&gt;在客户端运行 Blazor 代码和 JavaScript 框架一样是在安全的沙箱中执行的，在基于开放的 Web 标准基础上，Blazor 具有服务器端代码的灵活性，比如直接连接数据库。&lt;/p&gt;
&lt;h2 id=&quot;和-javascript-交互&quot;&gt;和 JavaScript 交互&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202006/191097-20200625222734630-1709270087.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Blazor 应用中，你可以在 C# 代码中调用 JavaScript 代码，也可以在 JavaScript 代码中调用 C# 代码，两者可以很容易实现交互操作。好处是，在使用 C# 编写业务代码时，你依然可以继续使用现有庞大的 JavaScript 库生态系统。当使用服务器端运行代码时，Blazor 会负责在客户端使用 JavaScript 无缝调用 C# 代码。&lt;/p&gt;
&lt;p&gt;下面是一个 JavaScrit 调用 C# 的示例&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;先使用 JSInvokable 特性标注一个 C# 方法为允许 JavaScript 调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;&amp;lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;
        onclick=&quot;exampleJsFunctions.returnArrayAsyncJs()&quot;&amp;gt;
    Trigger .NET static method ReturnArrayAsync
&amp;lt;/button&amp;gt;

@code {
    [JSInvokable]
    public static Task&amp;lt;int[]&amp;gt; ReturnArrayAsync()
    {
        return Task.FromResult(new int[] { 1, 2, 3 });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 JavaScript 代码中调用 C# 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;window.exampleJsFunctions = {
  ...
  returnArrayAsyncJs: function () {
    DotNet.invokeMethodAsync('BlazorSample', 'ReturnArrayAsync')
      .then(data =&amp;gt; {
        data.push(4);
          console.log(data);
      });
  },
  ...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;对我来说 Blazor 最吸引的优点是前后端代码的共用以及组件的重用。通过 nuget 管理包不仅比 npm 方便，而且体积也小很多。&lt;/p&gt;
&lt;p&gt;Blazor 的生态也正逐步发展起来了，虽然还没有听说哪个大公司在用，但 Blazor 的理念是未来趋势，值得你花点时间了解和研究一下。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;http://dwz.win/EU4&quot;&gt;http://dwz.win/EU4&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;http://dwz.win/EU3&quot;&gt;http://dwz.win/EU3&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 14:30:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>阅读本文大概需要 1.5 分钟。 最近在几个微信 .NET 交流群里大家讨论比较频繁的话题就是这几天自己的面试经历。 面试官：“你刚说你喜欢研究新技术，那么你对 Blazor 了解多少？”。 作为一位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13193234.html</dc:identifier>
</item>
<item>
<title>Java Agent（上） - 邂逅那青春-VING</title>
<link>http://www.cnblogs.com/vingLiu/p/13193148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vingLiu/p/13193148.html</guid>
<description>&lt;p&gt;---》对用户透明，不侵入用户业务代码。让java虚拟机加载agent jar&lt;/p&gt;

&lt;p&gt;---&amp;gt;应用场景例如：调用链追踪项目，在用户无感知的情况下，记录日志。目前业内使用该技术的有，SkyWalking,Pinpoint(这个监控的粒度更小)&lt;/p&gt;
&lt;p&gt;-各个 Java IDE 的调试功能，例如 eclipse、IntelliJ ；&lt;/p&gt;
&lt;p&gt;-热部署功能，例如 JRebel、XRebel、 spring-loaded；&lt;/p&gt;
&lt;p&gt;-各种线上诊断工具，例如 Btrace、Greys，还有阿里的 Arthas；&lt;/p&gt;
&lt;p&gt;-各种性能分析工具，例如 Visual VM、JConsole 等&lt;/p&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/147375268&quot;&gt;https://zhuanlan.zhihu.com/p/147375268&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;41、-如何制造自己第一个java-agent-jar包&quot;&gt;4.1、 如何制造自己第一个java agent jar包&lt;/h2&gt;
&lt;h3 id=&quot;411、-第一步：我们需要一个插件来帮助我们生成带特定格式的mainifestmf的jar&quot;&gt;4.1.1、 第一步：我们需要一个插件来帮助我们生成带特定格式的MAINIFEST.MF的jar&lt;/h3&gt;
&lt;h3 id=&quot;412、-第二步：在启动项目的时候，在jvm参数中添加--javaagent-ving-agent-001-snapshotjar-（在jvm上先加载agent包）&quot;&gt;4.1.2、 第二步：在启动项目的时候，在jvm参数中添加 -javaagent: *\ving-agent-0.0.1-SNAPSHOT.jar （在jvm上先加载agent包）&lt;/h3&gt;
&lt;p&gt;（偷偷地问）特定格式的MAINIFEST.MF是怎样的？需要包括下面的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Manifest-Version: 1.0
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Premain-Class: cn.think.in.java.clazz.loader.asm.agent.PreMainTraceAgent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（再偷偷地问），难度每次都让我手动去弄这个文件，我觉得很麻烦呀，有没一个工具能帮我们将agent项目打包成包含MAINIFEST.MF的jar？&lt;br/&gt;-----》对，你猜对了，真的有这个工具。那就是maven插件。（说到打包，肯定要想到maven或者gradle了吧）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;archive&amp;gt;
                        &amp;lt;manifestEntries&amp;gt;
                            &amp;lt;Project-name&amp;gt;${project.name}&amp;lt;/Project-name&amp;gt;
                            &amp;lt;Project-version&amp;gt;${project.version}&amp;lt;/Project-version&amp;gt;
                            &amp;lt;Premain-Class&amp;gt;com.tuling.agent.Agent&amp;lt;/Premain-Class&amp;gt;
                            &amp;lt;Can-Redefine-Classes&amp;gt;true&amp;lt;/Can-Redefine-Classes&amp;gt;
                            &amp;lt;Can-Retransform-Classes&amp;gt;true&amp;lt;/Can-Retransform-Classes&amp;gt;
                            &amp;lt;Boot-Class-Path&amp;gt;javassist-3.18.1-GA.jar&amp;lt;/Boot-Class-Path&amp;gt;
                        &amp;lt;/manifestEntries&amp;gt;
                    &amp;lt;/archive&amp;gt;
                    &amp;lt;skip&amp;gt;true&amp;lt;/skip&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625221947465-119853787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打包之后&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625221930904-575658473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625222230926-1822401398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625222257257-313740919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625222339959-1951717786.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625222442180-105532176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题二：如果有一个类已经被虚拟机加载了，那么我们的agent包里面的逻辑就不能加载这个类。但是我就是想把这类替换掉，怎么办呢？（热更新，虚拟机不停的情况下，替换成用户最新的代码）&lt;/p&gt;
&lt;p&gt;插件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224544095-804993426.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;agent代码的修改&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224616419-1598865435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新打包&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224701979-1986520145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224809947-2144527101.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224829129-222204175.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625224844578-44668966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625225156620-288266716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题三：&lt;br/&gt;当JVM已装置某个类，但是我们想重新走一次premain方法，我们怎样做呢？&lt;br/&gt;插件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625231111829-699939489.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;修改agent代码&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625231200820-167003360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;打包&lt;/p&gt;
&lt;p&gt;测试&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625231232604-54827950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625231253936-1512161731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1601833/202006/1601833-20200625231333147-1419167037.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看到这里，细心的朋友，可能会带有疑问，我在实践的时候，发现这个类的字节码的生成并不简单，如果让我自己去手动去生成那就很麻烦呀？（麻烦--》复杂度高---》容易出错----》上线容易出问题---》那就直接不考虑该技术）&lt;br/&gt;----》为了解决这个问题，&lt;strong&gt;java-ssist&lt;/strong&gt;就出现了。关于java-ssist，请点击。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/vingLiu/p/13193517.html&quot;&gt;https://www.cnblogs.com/vingLiu/p/13193517.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 25 Jun 2020 14:27:00 +0000</pubDate>
<dc:creator>邂逅那青春-VING</dc:creator>
<og:description>1、java agent是什么？ 》对用户透明，不侵入用户业务代码。让java虚拟机加载agent jar 2、java agent有什么用？ &amp;amp;gt;应用场景例如：调用链追踪项目，在用户无感</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vingLiu/p/13193148.html</dc:identifier>
</item>
<item>
<title>摇摇棒，理工男的择偶权（上） - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/shake_led_1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/shake_led_1.html</guid>
<description>&lt;p&gt;一列LED，新手拿来做跑马灯，高手拿来做摇摇棒！相貌平平的棒，摇动起来竟显示出渐变色的图案！本文将从硬件、驱动、应用等角度，带你领略摇摇棒的技术核心与设计思想。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;673.24713265527&quot;&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;摇摇棒是载有一列LED的棒，通过适当的程序控制，在摇动起来时，由于人眼有视觉暂留现象（persistence of vision，POV），会形成一幅图像。你可以上淘宝搜索，关注一下摇摇棒的核心参数（卖点）与显示效果。&lt;/p&gt;

&lt;p&gt;一年多前，我做了一根摇摇棒，16个粉红色LED，在520那天送给了女朋友。她很喜欢，她的同学和我的同学都很好奇。&lt;/p&gt;
&lt;p&gt;那时候我做了两根，当然不是因为我是渣男。另一根我带去了高考（高二等级考）考场，内置了“全员A+”的字样，本来想交给老师来给我们应援的，但是在烈日之下我只能很勉强地看见摇摇棒显示的字，于是就不了了之了。&lt;/p&gt;
&lt;p&gt;我不服，又设计了摇摇棒2.0。制作完硬件以后，它就一直堆在我的书桌旁。&lt;/p&gt;

&lt;p&gt;一年过去了，女朋友丢了，体重增加了，唯一不变的是我还是什么降分约都没有——唉，又要参加等级考了（写作之时已经考完了）。&lt;/p&gt;
&lt;p&gt;我想起了摇摇棒。&lt;/p&gt;
&lt;p&gt;这一回，摇摇棒是我在高考前夕唯一的乐趣，是我在老师心中瓜皮形象的转折点，是我作为一个理工男的择偶权。&lt;/p&gt;

&lt;h3 id=&quot;系列概述&quot;&gt;系列概述&lt;/h3&gt;
&lt;p&gt;本系列文章分为三篇：上篇介绍单机的摇摇棒，中篇介绍联机的摇摇棒，下篇介绍图灵完全的摇摇棒。&lt;/p&gt;
&lt;p&gt;本文为上篇。目前进度大概到中篇的一半，但我觉得只有完成了后续（最好是所有）才能更好地审视前面的工作，用没有回溯的思路整理成一篇博客。&lt;/p&gt;
&lt;p&gt;写文章要照应标题，不过这简直就是做梦，我还是好好介绍摇摇棒吧，不去想那些有的没的。&lt;/p&gt;

&lt;p&gt;先放个效果图吧（曝光时间0.2s）：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624223941948-2027633195.jpg&quot; width=&quot;400&quot;/&gt;
&lt;h3 id=&quot;核心原理&quot;&gt;核心原理&lt;/h3&gt;
&lt;p&gt;人们对摇摇棒有所好奇，无非是好奇它的核心原理，至于细节与实现，我说出来也没有人要听。这也是我开通博客的原因。&lt;/p&gt;

&lt;p&gt;首先，棒上所有的输入输出设备都由程序控制，运行程序的是一块单片机。&lt;/p&gt;
&lt;p&gt;摇动周期是任意的（自适应的），别太夸张就行，所以摇摇棒需要检测运动周期。用于检测的硬件是位于棒顶端的水银开关：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624223958970-1090026473.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;真空、密封的玻璃管中有一滴水银，一个引脚始终与水银接触，另一个只有当水银位于一端时才接触。接触时两引脚导通，用一个很简单的电路就可以把导通与否转换成高低电平被单片机读取。&lt;/p&gt;
&lt;p&gt;改变水银位置需要施力，摇摇棒运动过程中有加速度，提供了惯性力。然而，水银开关只能指示加速度的方向，而不是更容易使用的加速度、速度、位置；加速度的方向也不能简单地认为是一个周期内翻转两次——这就需要一个精巧的程序来控制。&lt;/p&gt;
&lt;p&gt;我写的程序能让单片机知道（意会，别跟我杠什么单片机没有意识）它在一个周期中的相对位置，从而知道每一时刻该亮起图像的哪一部分。哦对了，字符是转换成点阵图像存储的，每一个像素点都是摇摇棒亮灯的依据。&lt;/p&gt;
&lt;p&gt;于是，在一个周期中，图像的每一列都被在对应的位置显示了一会。人眼有视觉暂留现象，这些列一起组成了一幅图像，它的内容是字符。当然，简单的图案也是可以的。&lt;/p&gt;

&lt;h3 id=&quot;硬件&quot;&gt;硬件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224020173-867357721.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上为摇摇棒的原理图，可以分为以下几个部分：&lt;/p&gt;
&lt;ul readability=&quot;15.207853403141&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;供电：18650电池座、电源开关、SX1308（B628）升压、AMS1117-3.3稳压；&lt;/p&gt;
&lt;p&gt;摇摇棒1.0直接用3.7V锂离子电池供电，但实际电压为2.7V到4.2V，亮度差异很大；2.0的供电部分先升压到5V，为了便于在高亮度下控制亮度。&lt;/p&gt;
&lt;p&gt;蓝牙模块需要3.3V电源，所以加了个LDO。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;控制：ATMega328P单片机、晶振、ISP下载接口；&lt;/p&gt;
&lt;p&gt;单片机选择的是我最擅长的AVR系列中的ATmega328P，与烂大街的Arduino相同（但我没从那边抄过哪怕一行代码）。晶振是20MHz的，官方允许的最高频率，为了获得更好的性能。&lt;/p&gt;
&lt;p&gt;下载器接口是我自己定义的ISP接口，比标准的占用更少空间，但毕竟是非标准的，这是个历史遗留问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;输入：电池电压检测、水银开关、光敏电阻、按键×2；&lt;/p&gt;
&lt;p&gt;水银开关接通时，&lt;code&gt;SWC&lt;/code&gt;为低电平；断开时，由于没有负载，&lt;code&gt;SWC&lt;/code&gt;为高电平；&lt;code&gt;R05&lt;/code&gt;称为上拉电阻。这就是那个很简单的电路。电容&lt;code&gt;C04&lt;/code&gt;本来想用于滤波的，实测反而碍事，拿掉了。两个按键同理，上拉电阻在单片机内部配置。&lt;/p&gt;
&lt;p&gt;光敏电阻&lt;code&gt;R06&lt;/code&gt;阻值与光强负相关，与定值电阻&lt;code&gt;R07&lt;/code&gt;分压后的输出电压与光强正相关，接到单片机的ADC（模-数转换器）上，从而检测环境光强度并调整亮度，深夜写代码与阳光下展（liào）示（mèi）都能适配。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.5334773218143&quot;&gt;
&lt;p&gt;输出：5片74HC595、2个N沟道MOS管、32个蓝绿双色LED、2个RGBW LED；&lt;/p&gt;
&lt;p&gt;595是串行转并行芯片，MOS是一种三极管，详见&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12245019.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程——矩阵键盘&lt;/a&gt;。595输出串联排阻后接LED再接到MOS管，连接方式下面细说。&lt;/p&gt;
&lt;p&gt;单片机上&lt;code&gt;DAT1&lt;/code&gt;、&lt;code&gt;DAT3&lt;/code&gt;、&lt;code&gt;DAT4&lt;/code&gt;、&lt;code&gt;CLK&lt;/code&gt;、&lt;code&gt;STO&lt;/code&gt;引脚控制595，前3个是数据信号。设计3个数据信号是为了加速输出，不过最快的输出方式是用SPI，没有用它是设计上的失误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;蓝牙：蓝牙模块、简单的电平转换电路。&lt;/p&gt;
&lt;p&gt;中篇内容，跳过。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个RGBW共8个灯，刚好对应595的8个输出。不幸的是，595位于下方RGBW的背面，而另一个RGBW位于顶端，在狭窄的PCB中避开其他元器件和信号线走4根线并不容易，这是PCB布线的难点。也许还有别的难点，只是时间太久远，我已经忘了。&lt;/p&gt;
&lt;p&gt;595输出串联电阻后接LED，输出低电平时LED不亮，高电平时有电流因而亮，电阻起到限流作用。不同颜色的灯串联不同阻值的电阻是为了平衡亮度，在RGB都点亮时颜色接近白色。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224036660-290634276.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;4片595输出&lt;code&gt;LED0&lt;/code&gt;到&lt;code&gt;LED31&lt;/code&gt;，越上方的编号越小。每个蓝绿双色LED的两个阳极共同连接一个&lt;code&gt;LEDx&lt;/code&gt;信号，绿、蓝阴极分别连接到&lt;code&gt;GRN&lt;/code&gt;和&lt;code&gt;BLU&lt;/code&gt;，是两个MOS管的漏极。当&lt;code&gt;Q&lt;/code&gt;的栅极&lt;code&gt;GRNC&lt;/code&gt;为高电平时，漏极和连接到&lt;code&gt;GND&lt;/code&gt;的源极之间导通，电阻忽略不计，如果此时&lt;code&gt;LEDx&lt;/code&gt;为高电平则对应绿灯亮起；低电平时不导通，无论&lt;code&gt;LEDx&lt;/code&gt;如何，绿灯一个都不会亮——这段时间留给蓝灯。&lt;/p&gt;
&lt;p&gt;简而言之，&lt;code&gt;GRNC&lt;/code&gt;为高电平时595控制绿灯，&lt;code&gt;BLUC&lt;/code&gt;为高电平时595控制蓝灯。如果&lt;code&gt;GRNC&lt;/code&gt;和&lt;code&gt;BLUC&lt;/code&gt;的电平转换非常快，快到电平变化的一个周期内LED只移动了很小一段距离，看起来就是天蓝色的。而事实上，&lt;code&gt;GRNC&lt;/code&gt;和&lt;code&gt;BLUC&lt;/code&gt;的电平变化还没那么简单。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224050437-1902073135.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PCB渲染图如上。大致布局是，正面最上方水银开关和光敏电阻，往下一个RGBW、32个蓝绿、一个RGBW，IC和电阻等贴片器件都在反面对应的位置。然后是下载器接口、电源开关、两个按键、电感、晶振，最后是电池，反面有升压电路、单片机、蓝牙模块等。在手握摇摇棒时这些元器件会被碰到，影响正常工作，所以全部被我盖了一层热熔胶：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224102619-1128347538.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;毕竟图吧签到12级。&lt;/p&gt;

&lt;p&gt;硬件设计决定了摇摇棒功能的上限。比如，它不可能显示红色的图像（除非你能摇得快到红移）。&lt;/p&gt;
&lt;p&gt;本篇中摇摇棒能实现的功能有：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以任意的蓝绿组合颜色呈现图像，包括渐变色；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动根据环境光强调整显示亮度；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用按键切换显示图像、复位周期检测、调整亮度等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;驱动&quot;&gt;驱动&lt;/h3&gt;
&lt;p&gt;这个项目不算简单，所以我要加上驱动层，把底层的寄存器操作封装成C语言函数，在适当的地方提供回调接口。后面将看到驱动层之上并非直接是应用程序，驱动负责到哪一步也是一个问题。我的想法是，应用程序不需要插入代码的地方就封装，否则就留给上层解决；明显的异步操作用回调。&lt;/p&gt;
&lt;p&gt;驱动层主要包括以下接口：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;LED，规定数据格式，提供以一定亮度亮灯的函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;水银开关，检测加速度方向，附带滤波；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按键，封装按键双击、长按等高级事件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ADC，检测电源电压与光强，后者可以异步；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定时器，程序结构的核心，定时回调与全局时钟；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;蓝牙，依旧跳过。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;详解一下奇数编号的驱动。&lt;/p&gt;

&lt;h4 id=&quot;led&quot;&gt;LED&lt;/h4&gt;
&lt;p&gt;32个双色LED加上2个RGBW的模式可以用5个字节表示，我规定第&lt;code&gt;[0]&lt;/code&gt;字节的最低位对应最上方的LED，第&lt;code&gt;[3]&lt;/code&gt;字节的最高位对应最下方，第&lt;code&gt;[4]&lt;/code&gt;字节最低位对应上方RGBW的红色，最高位对应下方RGBW的白色。这样就不难写出驱动5片595的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;uint8_t d0, d1, d2;
d0 = data[0];
d1 = data[2];
for (uint8_t i = 0; i != 8; ++i)
{
    cond_bit(read_bit(d0, 0), PORTC, 0);
    cond_bit(read_bit(d1, 0), PORTC, 1);
    d0 &amp;gt;&amp;gt;= 1;
    d1 &amp;gt;&amp;gt;= 1;
    clock_bit(PORTC, 3);
}
d0 = data[1];
d1 = data[3];
d2 = data[4];
for (uint8_t i = 0; i != 8; ++i)
{
    cond_bit(read_bit(d0, 0), PORTC, 0);
    cond_bit(read_bit(d1, 0), PORTC, 1);
    cond_bit(read_bit(d2, 0), PORTC, 2);
    d0 &amp;gt;&amp;gt;= 1;
    d1 &amp;gt;&amp;gt;= 1;
    d2 &amp;gt;&amp;gt;= 1;
    clock_bit(PORTC, 3);
}
clock_bit(PORTC, 4);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的位操作宏定义为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define set_bit(r, b) ((r) |= (1u &amp;lt;&amp;lt; (b)))
#define reset_bit(r ,b) ((r) &amp;amp;= ~(1u &amp;lt;&amp;lt; (b)))
#define read_bit(r, b) ((r) &amp;amp; (1u &amp;lt;&amp;lt; (b)))
#define cond_bit(c, r, b) ((c) ? set_bit(r, b) : reset_bit(r, b))
#define flip_bit(r, b) ((r) ^= (1u &amp;lt;&amp;lt; (b)))
#define clock_bit(r, b) (flip_bit(r, b), flip_bit(r, b)
#define bit_mask(n, b) (((1u &amp;lt;&amp;lt; (n)) - 1) &amp;lt;&amp;lt; (b))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合&lt;code&gt;GRNC&lt;/code&gt;和&lt;code&gt;BLUC&lt;/code&gt;的高低电平可以显示出绿、蓝和天蓝色，但这还不算完。&lt;code&gt;GRNC&lt;/code&gt;和&lt;code&gt;BLUC&lt;/code&gt;连接到单片机的&lt;code&gt;OC0A&lt;/code&gt;和&lt;code&gt;OC0B&lt;/code&gt;引脚，它们是定时器0的波形输出引脚，可以产生PWM波。一个PWM周期内一段时间高电平，对应LED亮，低电平时暗，切换快到人眼完全看不出来，从而感觉到亮度是均匀的，与PWM占空比正相关的。一会让&lt;code&gt;GRNC&lt;/code&gt;输出PWM波，&lt;code&gt;BLUC&lt;/code&gt;保持低电平，一会相反，切换依然快到看不出来，于是就实现了任意的蓝绿亮度组合。&lt;/p&gt;
&lt;p&gt;原先这种设计只是为了解决蓝绿亮度不相同的问题，后来渐渐地发展出了渐变色的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef enum
{
    COLOR_NONE, COLOR_GREEN, COLOR_BLUE
} color_t;

void led_set(color_t color, uint8_t duty, const uint8_t data[5])
{
    TCCR0A &amp;amp;= ~(bit_mask(2, COM0A0) | bit_mask(2, COM0B0));
    // ...
    uint8_t com0x;
    volatile uint8_t* ocr0x;
    switch (color)
    {
    case COLOR_GREEN:
        com0x = 0b10 &amp;lt;&amp;lt; COM0A0;
        ocr0x = &amp;amp;OCR0A;
        break;
    case COLOR_BLUE:
        com0x = 0b10 &amp;lt;&amp;lt; COM0B0;
        ocr0x = &amp;amp;OCR0B;
        break;
    default:
        return;
    }
    if (duty == 0)
        return;
    TCCR0A |= com0x;
    *ocr0x = duty - 1;
    TCNT0 = 0xFF;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间省略的是上面那段代码。&lt;/p&gt;

&lt;h4 id=&quot;按键&quot;&gt;按键&lt;/h4&gt;
&lt;p&gt;我一直想写一个能处理长按、双击等事件的按键库，这次正是一个机会。至少在这一篇中，按键是控制好摇摇棒的唯一方式。而按键一共只有两个，为了使输入方式更丰富，就只能在每个按键的事件种类上动手脚。&lt;/p&gt;
&lt;p&gt;首先要消抖。按键在被按下和抬起的过程中，电平并不是直上直下的，可能存在抖动。如果把每一次跳变都算一个事件的话，随意按一下可能就被算作双击了，所以需要消抖。我用的是最简单的消抖方法：用一个变量记录按键的状态，当按键的电平与原状态不同且保持10ms不变时，才认为此时按键进入新的状态。水银开关的消抖也是类似的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;

#define BUTTON_COUNT 2

static bool pin[BUTTON_COUNT];
static uint8_t filter[BUTTON_COUNT] = {0};

static inline bool button_read(uint8_t which)
{
    switch (which)
    {
    case 0:
        return read_bit(PINB, 1);
    case 1:
        return read_bit(PINB, 2);
    }
    return false;
}

static inline button_event_t button_filter(uint8_t which)
{
    if (which &amp;gt;= BUTTON_COUNT)
        return false;
    bool now = button_read(which);
    if (now == pin[which])
        filter[which] = 0;
    else if (++filter[which] == 50)
    {
        pin[which] = now;
        filter[which] = 0;
        return now ? BUTTON_LEFT_RELEASED : BUTTON_LEFT_PRESSED;
    }
    return BUTTON_NONE;
}

void button_init()
{
    set_bit(PORTB, 1);
    set_bit(PORTB, 2);
    for (uint8_t i = 0; i != BUTTON_COUNT; ++i)
        pin[i] = button_read(i);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义三种模式，最复杂的模式中包括以下事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef enum
{
    MODE_NONE, MODE_SIMPLE, MODE_ADVANCED
} button_mode_t;

typedef enum
{
    BUTTON_NONE,
    BUTTON_LEFT_PRESSED, BUTTON_LEFT_RELEASED,
    BUTTON_LEFT_SHORT, BUTTON_LEFT_LONG, BUTTON_LEFT_CONT,
    BUTTON_LEFT_DOUBLE,
    BUTTON_RIGHT_PRESSED, BUTTON_RIGHT_RELEASED,
    BUTTON_RIGHT_SHORT, BUTTON_RIGHT_LONG, BUTTON_RIGHT_CONT,
    BUTTON_RIGHT_DOUBLE,
    BUTTON_BOTH
} button_event_t;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BUTTON_LEFT_CONT&lt;/code&gt;指左按键长按以后保持按下的事件，每100毫秒触发一次；&lt;code&gt;BUTTON_BOTH&lt;/code&gt;是两个按键同时按下的事件。&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;button_get()&lt;/code&gt;返回一个&lt;code&gt;button_event_t&lt;/code&gt;变量。每次调用只更新一个按键，因此不会有多个返回值。该函数需要客户轮询。&lt;/p&gt;
&lt;p&gt;同时处理这么多事件的方法是用状态机：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224123968-191593898.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;&lt;code&gt;BOTH&lt;/code&gt;向&lt;code&gt;FREE&lt;/code&gt;的转移条件为另一个按键也处于&lt;code&gt;BOTH&lt;/code&gt;状态。具体&lt;code&gt;timeout&lt;/code&gt;值见下面的代码，代码中数值除以5得到毫秒数。&lt;/p&gt;
&lt;p&gt;比如，0ms时按下，200ms时抬起，400ms时按下，600ms时抬起，状态转移过程为：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;0ms，&lt;code&gt;FREE&lt;/code&gt;→&lt;code&gt;BOTH&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;100ms，&lt;code&gt;BOTH&lt;/code&gt;→&lt;code&gt;SHORT&lt;/code&gt;，事件&lt;code&gt;PRESSED&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;200ms，&lt;code&gt;SHORT&lt;/code&gt;→&lt;code&gt;DOUBLE&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;400ms，&lt;code&gt;DOUBLE&lt;/code&gt;→&lt;code&gt;FREE&lt;/code&gt;，事件&lt;code&gt;DOUBLE&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;typedef enum
{
    STATE_FREE, STATE_BOTH, STATE_SHORT, STATE_DOUBLE, STATE_LONG
} state_t;

static button_mode_t mode = MODE_NONE;
static const button_event_t base[BUTTON_COUNT] = {0, BUTTON_RIGHT_PRESSED - BUTTON_LEFT_PRESSED};
static state_t state[BUTTON_COUNT];
static uint16_t count[BUTTON_COUNT];
static uint8_t turn = 0;

void button_mode(button_mode_t m)
{
    if (mode == m)
        return;
    mode = m;
    if (m == MODE_ADVANCED)
        for (uint8_t i = 0; i != BUTTON_COUNT; ++i)
            state[i] = STATE_FREE;
}

button_event_t button_get()
{
    button_event_t result = BUTTON_NONE;
    button_event_t filter = button_filter(turn);
    if (mode == MODE_SIMPLE)
        result = filter;
    else if (mode == MODE_ADVANCED)
    {
        switch (state[turn])
        {
        case STATE_FREE:
            if (filter == BUTTON_LEFT_PRESSED)
            {
                state[turn] = STATE_BOTH;
                count[turn] = 0;
            }
            break;
        case STATE_BOTH:
        {
            uint8_t other = 1 - turn;
            if (state[other] == STATE_BOTH)
            {
                result = BUTTON_BOTH;
                state[turn] = STATE_FREE;
                state[other] = STATE_FREE;
            }
            else if (filter == BUTTON_LEFT_RELEASED)
            {
                result = BUTTON_LEFT_PRESSED;
                state[turn] = STATE_DOUBLE;
                count[turn] = 0;
            }
            else if (++count[turn] == 500)
            {
                result = BUTTON_LEFT_PRESSED;
                state[turn] = STATE_SHORT;
                count[turn] = 0;
            }
            break;
        }
        case STATE_SHORT:
            if (filter == BUTTON_LEFT_RELEASED)
            {
                state[turn] = STATE_DOUBLE;
                count[turn] = 0;
            }
            else if (++count[turn] == 2500)
            {
                result = BUTTON_LEFT_LONG;
                state[turn] = STATE_LONG;
                count[turn] = 0;
            }
            break;
        case STATE_DOUBLE:
            if (filter == BUTTON_LEFT_PRESSED)
            {
                result = BUTTON_LEFT_DOUBLE;
                state[turn] = STATE_FREE;
            }
            else if (++count[turn] == 500)
            {
                result = BUTTON_LEFT_SHORT;
                state[turn] = STATE_FREE;
            }
            break;
        case STATE_LONG:
            if (filter == BUTTON_LEFT_RELEASED)
            {
                result = BUTTON_LEFT_RELEASED;
                state[turn] = STATE_FREE;
            }
            else if (++count[turn] == 500)
            {
                result = BUTTON_LEFT_CONT;
                count[turn] = 0;
            }
            break;
        }
    }
    if (result != BUTTON_NONE &amp;amp;&amp;amp; result != BUTTON_BOTH)
        result += base[turn];
    if (++turn == BUTTON_COUNT)
        turn = 0;
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;废话两句。以前上课的时候有人问我单片机按键双击怎么写，当时我心里还没底，因为没写过，就让他多加一个按键。这时我们老师说，注册一个回调就可以了呀！&lt;/p&gt;
&lt;p&gt;嗯，算你懂得回调。&lt;/p&gt;

&lt;h4 id=&quot;定时器&quot;&gt;定时器&lt;/h4&gt;
&lt;p&gt;程序中主循环的周期为0.1ms，但是一个周期中执行指令的时间相比于周期长度而言已经不可忽略，为了精准地控制时间，需要使用定时器。没错，这里的定时器和之前提到的用于产生PWM波的是同一类东西，不同的是之前用的是定时器0，这里用的是定时器2，两者互不干扰。&lt;/p&gt;
&lt;p&gt;设置定时器2分频系数为8，匹配值为250，则每2000个CPU时钟周期产生一个中断。CPU时钟频率为20MHz，因此定时器中断的间隔为0.1ms。客户须在每次中断中调用&lt;code&gt;button_get&lt;/code&gt;，这就是除以5得到毫秒数的原理。&lt;/p&gt;
&lt;p&gt;定时器中断有两项职责，一是维护一个时钟，每一周期增加1，可重置，主要用于水银开关周期检测；二是调用上层的回调函数&lt;code&gt;timer_handler&lt;/code&gt;，驱动中仅声明为&lt;code&gt;extern&lt;/code&gt;（另一种方法是通过函数指针注册回调）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;

static uint16_t tick = 0;

ISR(TIMER2_COMPA_vect)
{
    ++tick;
    timer_handler();
}

void timer_init()
{
    if (0)
        TIMER2_COMPA_vect();
    TCCR2A = 0b10 &amp;lt;&amp;lt; WGM20;
    TCCR2B = 0 &amp;lt;&amp;lt; WGM22 | 0b010 &amp;lt;&amp;lt; CS20;
    OCR2A = 249;
    TIMSK2 = 1 &amp;lt;&amp;lt; OCIE2A;
    sei();
}

void clock_reset()
{
    tick = 0;
}

uint16_t clock_get()
{
    return tick;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;应用程序&quot;&gt;应用程序&lt;/h3&gt;
&lt;p&gt;驱动封装了硬件操作，而用户只想关心显示什么内容，两者之间还需要插入一层，这一层主要实现运动周期检测，并在周期中合适的时刻根据用户提供的数据进行显示。&lt;/p&gt;
&lt;p&gt;两层之间用回调函数和配置信息耦合。回调函数包括定时器回调、按键事件回调与图像更新回调；配置信息定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct
{
    uint8_t width;
    uint8_t height_byte;
    const uint8_t* display;
    uint8_t in_flash : 1;
    uint8_t bright;
    uint8_t color;
    uint8_t rgbw;
} Config;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;display&lt;/code&gt;指向点阵数据，共&lt;code&gt;width * height_byte&lt;/code&gt;字节，每&lt;code&gt;height_byte&lt;/code&gt;字节表示一列，RGBW另存。&lt;/p&gt;
&lt;p&gt;客户通过&lt;code&gt;set_config&lt;/code&gt;函数更新配置，&lt;code&gt;Config&lt;/code&gt;参数被立即拷贝到一个特定的位置，但不会立即应用于显示，而是等待当前显示周期（即运动周期）结束，在下次更新中应用，简而言之配置被缓冲了。&lt;/p&gt;

&lt;p&gt;在C语言中，即使一个数组声明为&lt;code&gt;const&lt;/code&gt;，它也存放在RAM中，但是ATmega328P只有2k字节RAM，显示的字数很多的话会放不下。AVR编程中可以用&lt;code&gt;PROGMEM&lt;/code&gt;宏指定数据存放在flash中，&lt;code&gt;in_flash&lt;/code&gt;即表示点阵是否存储在flash中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;avr/pgmspace.h&amp;gt;

static const uint8_t jiayou[] PROGMEM =
{
    0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x40, 0x00, 0x20, 0x40, 0x00, 0x18,
    0x40, 0x00, 0x07, 0x40, 0xF8, 0x09, 0xFE, 0x1F, 0x08, 0x40, 0x00, 0x10,
    0x40, 0x00, 0x30, 0x40, 0x00, 0x18, 0xC0, 0xFF, 0x0F, 0xC0, 0x07, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x7F, 0x40, 0x00, 0x08,
    0x40, 0x00, 0x08, 0x40, 0x00, 0x08, 0x40, 0x00, 0x08, 0x40, 0x00, 0x08,
    0xC0, 0xFF, 0x3F, 0x40, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x07, 0x72,
    0x08, 0x06, 0x7F, 0x18, 0xE0, 0x01, 0x10, 0x18, 0x00, 0x00, 0x07, 0x00,
    0xC0, 0x00, 0x00, 0xC0, 0xFF, 0x7F, 0xC0, 0xFF, 0x7F, 0x40, 0x20, 0x10,
    0x40, 0x20, 0x10, 0x40, 0x20, 0x10, 0xFE, 0xFF, 0x1F, 0xFE, 0xFF, 0x1F,
    0x40, 0x20, 0x10, 0x40, 0x20, 0x10, 0x40, 0x20, 0x10, 0xC0, 0xFF, 0x7F,
    0xC0, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（点阵数据可用PCtoLCD2002生成；原谅我用拼音命名变量。）&lt;/p&gt;
&lt;p&gt;指向flash中数据的指针与普通指针相同，但是不能直接解引用，要先用&lt;code&gt;memcpy_P&lt;/code&gt;函数拷贝到RAM中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;memcpy_P(display.current, display.ptr + display.phase * display.height_byte, display.height_byte);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并不是所有点阵数据都放在flash中，比如程序还可以通过蓝牙接收数据，把它写进flash就太麻烦了。&lt;/p&gt;

&lt;p&gt;程序结构为，先执行初始化，包括硬件与变量，然后进入死循环，保持程序运行。初始化的最后是启动定时器，随后定时器会每0.1ms产生一次中断，所有实际工作都在中断中完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{
    startup();
    while (1)
        ;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;周期检测&quot;&gt;周期检测&lt;/h4&gt;
&lt;p&gt;那时做完第一版发了个朋友圈，就有人问这个问题：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624224147200-1749825580.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;的确，周期检测是摇摇棒的难点（对于那些问我“把摇摇棒放在桌上不动能不能显示”的人就不是了），是我写第一版甚至第二版的程序时唯一心慌的地方。虽然免去了为MPU6050写I²C驱动的烦恼，但5毛钱的水银开关也自有麻烦之处。让我们来一探究竟吧！&lt;/p&gt;

&lt;p&gt;水银开关电路的输出信号首先要经过滤波，这是驱动层封装好的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef enum
{
    MERCURY_NONE, MERCURY_LEFT, MERCURY_RIGHT
} mercury_event_t;

static bool status;
static uint16_t count = 0;

static inline bool mercury_read()
{
    return !read_bit(PINB, 0);
}

void mercury_init()
{
    status = mercury_read();
}

mercury_event_t mercury_get()
{
    bool now = mercury_read();
    if (now == status)
        count = 0;
    else if (++count == 100)
    {
        status = now;
        count = 0;
        return now ? MERCURY_RIGHT : MERCURY_LEFT;
    }
    return MERCURY_NONE;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;然后就是算法的主体部分。算法可以用状态机描述，只有稳定与不稳定两个状态，用&lt;code&gt;stable&lt;/code&gt;变量表示，初始值为&lt;code&gt;false&lt;/code&gt;。&lt;code&gt;period&lt;/code&gt;为上一周期的长度，单位为定时器周期即0.1ms，是两个状态共用的；计数器&lt;code&gt;count&lt;/code&gt;在两个状态中有不同的含义，但共用一个变量。&lt;/p&gt;
&lt;p&gt;算法只监听水银珠从右到左这一事件，大致上是棒从右到左经过中点。定义局部变量&lt;code&gt;uint16_t clock = clock_get();&lt;/code&gt;，表示当前周期已经持续的时间。大多数分支都会调用&lt;code&gt;clock_reset&lt;/code&gt;复位时钟，并在使用完&lt;code&gt;clock&lt;/code&gt;后把它写为0，标志着新的周期开始。&lt;/p&gt;
&lt;p&gt;在不稳定状态中，要想进入稳定状态，必须连续若干次满足以下条件：本次周期长度大于前一周期的0.5倍并且小于1.5倍。&lt;code&gt;count&lt;/code&gt;记录这一条件成立的次数，一旦某一次条件不成立则清零，并把&lt;code&gt;period&lt;/code&gt;更新为当前周期长度。目标次数被设置为2。&lt;/p&gt;
&lt;p&gt;在稳定状态中，根据周期长度分3类讨论：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;周期长度大于等于前一周期的0.75倍并且小于1.5倍，这意味着当前周期和上一周期差不多长，用户在稳定地摇动。把&lt;code&gt;period&lt;/code&gt;设为两个周期的平均值，这样可以允许周期缓慢变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;周期长度小于0.75倍，这可能是噪音导致的，应该忽略，不复位时钟。但是这种情况连续出现很多次就不对了，用&lt;code&gt;count&lt;/code&gt;记录次数，达到一定值时要进入不稳定状态。这个值被设置为2。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;周期长度大于等于1.5倍，用户停止了摇动，直接进入不稳定状态。事实上停止摇动后LED还会闪一下，因为不免存在抖动，导致程序又判定出一个周期。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;测试过程中发现，如果突然把摇动频率翻倍，由于有第2个分支的存在，算法会把两个周期判定为一个；有时刚开始摇动就会这样。解决这个问题需要在分支1和2中动点手脚：用&lt;code&gt;half_flag&lt;/code&gt;表示分支1中&lt;code&gt;clock&lt;/code&gt;是否是&lt;code&gt;period&lt;/code&gt;的一半，具体来讲是3/8到5/8；&lt;code&gt;half_count&lt;/code&gt;表示连续出现“一周期中进入分支1一次且&lt;code&gt;half_flag&lt;/code&gt;为真”的次数。当&lt;code&gt;half_count&lt;/code&gt;达到2时就可以认为算法进入了错误的状态，需要减半&lt;code&gt;period&lt;/code&gt;以恢复正常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool stable;
uint16_t period;
uint8_t count;
bool half_flag;
uint8_t half_count;

void timer_handler()
{
    // ...
    uint16_t clock = clock_get();
    if (mercury_get() == MERCURY_LEFT)
    {
        if (stable)
        {
            if (clock &amp;lt; period * 3 / 4)
            {
                if (++count == 2)
                {
                    stable = false;
                    count = 0;
                }
                if (period * 3 / 8 &amp;lt; clock &amp;amp;&amp;amp; clock &amp;lt; period * 5 / 8)
                {
                    half_flag = true;
                }
            }
            else if (clock &amp;lt; period * 3 / 2)
            {
                clock_reset();
                if (count == 1 &amp;amp;&amp;amp; half_flag)
                {
                    if (++half_count == 2)
                    {
                        half_count = 0;
                        clock = 0;
                    }
                }
                else
                {
                    half_count = 0;
                }
                period = (period + clock) / 2;
                count = 0;
                half_flag = false;
                clock = 0;
            }
            else
            {
                stable = false;
                count = 0;
            }
        }
        else
        {
            clock_reset();
            if (period / 2 &amp;lt; clock &amp;amp;&amp;amp; clock &amp;lt; period * 3 / 2)
            {
                if (++count == 2)
                {
                    stable = true;
                    period = (period + clock) / 2;
                    count = 0;
                    half_flag = false;
                    half_count = 0;
                    clock = 0;
                }
            }
            else
            {
                period = clock;
                count = 0;
            }
        }
    }
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;知道了周期长度与起始时刻，也就知道了每一时刻在周期中的位置。一个周期的3/8到5/8，也就是从左到右中间的部分，可以显示图像，显示的列随&lt;code&gt;clock&lt;/code&gt;均匀变化，由于中间段接近匀速，显示的图像是比较均匀的。&lt;/p&gt;
&lt;p&gt;为什么不在从右到左过程中显示呢？因为周期起始的位置并不精确地是正中间，还受周期、重力和手的影响，取3/8到5/8而不是1/4到3/4就包含对这些因素的考量。如果在相差半个周期的位置也显示的话，两幅图像肯定无法重合，即使动态调整位置也无济于事。&lt;/p&gt;

&lt;h4 id=&quot;性能优化&quot;&gt;性能优化&lt;/h4&gt;
&lt;p&gt;也许你已经注意到，上面的代码中从未出现过&lt;code&gt;int&lt;/code&gt;，只有&lt;code&gt;uint8_t&lt;/code&gt;和&lt;code&gt;uint16_t&lt;/code&gt;等确定长度的整数类型。这样做可以带来可移植性，更重要的是AVR作为8位单片机对整数长度十分敏感，能用8位就不要用16位。&lt;/p&gt;
&lt;p&gt;mega系列有双周期硬件乘法器，但没有硬件除法器，除数确定的除法编译器会转化为乘法来计算，不确定的就只能调用除法路径了。这种除法偶尔算一次还行，每个定时器周期都算就会严重拖慢速度，比如这句判断是否该切换列的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (clock == period * 3 / 8 + (uint32_t)period * phase / width / 4)
    // ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要加&lt;code&gt;uint32_t&lt;/code&gt;转换是因为&lt;code&gt;period&lt;/code&gt;是&lt;code&gt;uint16_t&lt;/code&gt;类型，整数提升成&lt;code&gt;unsigned int&lt;/code&gt;（&lt;code&gt;int&lt;/code&gt;是16位整型），计算结果为&lt;code&gt;unsigned&lt;/code&gt;类型，但实际乘积会溢出，就不得不转换成更长的&lt;code&gt;long&lt;/code&gt;。这下可好，每周期计算32位整数除法，同时触犯两条禁忌。&lt;/p&gt;
&lt;p&gt;我的性能优化就从这里入手，逐渐扩展到所有计算过程不太简单但不常变化的量，它们都存储在结构体&lt;code&gt;compute&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct
{
    uint16_t threshold_low;
    uint16_t threshold_high;
    uint16_t half_low;
    uint16_t half_high;
    uint16_t clock_base;
    uint16_t clock_step;
    uint16_t clock_compare;
    uint16_t green_step;
    uint16_t blue_step;
    uint8_t rgbw_duty;
} compute;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clock&lt;/code&gt;开头的三个变量就是用来优化前述语句的。在显示周期开始，即&lt;code&gt;clock == 0&lt;/code&gt;时，先计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compute.clock_base = motion.period * 3 / 8;
compute.clock_step = motion.period / display.width;
compute.clock_compare = compute.clock_base;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;compute.clock_compare&lt;/code&gt;就是&lt;code&gt;if&lt;/code&gt;中与&lt;code&gt;clock&lt;/code&gt;比较的值。在&lt;code&gt;display.phase&lt;/code&gt;增加后，需要重新计算&lt;code&gt;compute.clock_compare&lt;/code&gt;的值，其中除以4是可以接受的计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compute.clock_compare = compute.clock_base + compute.clock_step * display.phase / 4;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也许会问，为什么不把除以4放进&lt;code&gt;compute.clock_step&lt;/code&gt;的计算中？考虑误差较大的情况：&lt;code&gt;motion.period == 2047, display.width == 128&lt;/code&gt;，&lt;code&gt;compute.clock_step&lt;/code&gt;比理想值小了6.2%，图像的宽度将压缩为原来的93.8%；如果把除以4放进去，误差会达到25.0%，这就比较严重了。&lt;/p&gt;
&lt;p&gt;转换为&lt;code&gt;uint32_t&lt;/code&gt;先乘后除无疑是更加精准的，优化后由于整数除法只能得到整数结果而产生了更大的误差，因此这里的性能优化与编译器优化还不同：编译器要遵守“as-if”规则，而我是在用可接受的精度下降换取可观的速度提升。&lt;/p&gt;
&lt;p&gt;利用超纲的手段（蓝牙），我得知优化前定时器中断的执行时间超过了定时器周期的80%，优化后下降到了40%以下（都是&lt;code&gt;-O3&lt;/code&gt;），性能提升十分明显。挤出来的计算资源将会在下篇中派上用场。&lt;/p&gt;

&lt;p&gt;一个相似的例子是渐变色模式中LED亮度（对应PWM占空比）的计算。原来的计算式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;duty = led.green * phase / width;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化以后为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compute.green_step = (led.green &amp;lt;&amp;lt; 8) / (display.width - 1);
duty = (compute.green_step * phase) &amp;gt;&amp;gt; 8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不左移8位直接除，因为有整数除法的误差，显示效果将是瞬变而不是渐变，所以我要先左移8位再右移8位，这与上面的除以4是类似的，只是更加显式。&lt;/p&gt;
&lt;p&gt;我的重点不在移位的艺术性上。请你看看优化后的第一个语句有什么问题，已知三个变量的类型分别为&lt;code&gt;uint16_t&lt;/code&gt;、&lt;code&gt;uint8_t&lt;/code&gt;和&lt;code&gt;uint8_t&lt;/code&gt;。&lt;/p&gt;
&lt;details readability=&quot;8&quot;&gt;点击展开答案
&lt;p&gt;&lt;code&gt;led.green&lt;/code&gt;在移位运算中被提升为&lt;code&gt;int&lt;/code&gt;（而不是&lt;code&gt;unsigned&lt;/code&gt;），移位运算结果为&lt;code&gt;int&lt;/code&gt;类型，除法运算结果亦为&lt;code&gt;int&lt;/code&gt;类型。当&lt;code&gt;led.green &amp;gt;= 128&lt;/code&gt;时，除法结果为负数，赋给无符号的&lt;code&gt;compute.green_step&lt;/code&gt;，变成无符号数与&lt;code&gt;phase&lt;/code&gt;相乘再移位。我搞不清楚结果是个什么东西，反正显示效果不是渐变色。&lt;/p&gt;
&lt;p&gt;解决方法很简单，把&lt;code&gt;led.green&lt;/code&gt;转换成&lt;code&gt;uint16_t&lt;/code&gt;再参与运算即可。发现这个问题花了我一个小时，真是成也抠门败也抠门啊！&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&quot;下期预告&quot;&gt;下期预告&lt;/h3&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202006/1734552-20200624233434226-641032221.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;另一端的效果图见&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/shake_led_1.html#picture&quot;&gt;文首&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;本文中的周期检测算法能实现其功能，并具有一定容错与自恢复能力，但是还不完美。&lt;/p&gt;
&lt;p&gt;即使算法能从双倍周期中恢复出来，半速显示仍会持续至少2个理论周期，或4个实际周期。从观赏者的角度上看，半速显示是相当丑陋的——翻转、拉伸、边缘畸变、交叠，可谓集大成者。有趣的是，这种自恢复是我在写作本文期间才想到并应用的；此前我给用户提供的对策是按下按键以重置算法，然而矛盾的是用户如果要给别人展示，自己就看不到显示效果，也就无从得知这种错误，只会让观赏者觉得我是个逊仔。&lt;/p&gt;
&lt;p&gt;这个问题也许可以归结于性能与容错性的权衡：要允许噪音，就必须接受短暂的半速显示。&lt;/p&gt;
&lt;p&gt;权衡归权衡，真正的缺陷依然存在：算法允许稳定以后周期内出现噪音，但是如果每个周期内都有噪音，也就无法进入稳定状态，但是信号的周期仍客观存在。其实噪音很大程度上来源于滤波没有滤干净，但滤波中的时间阈值也不能设置地太高，如果要把这种噪音留到滤波后级去解决，我就不知道该怎么办了。&lt;/p&gt;

&lt;p&gt;和摇摇棒一样利用POV原理的还有旋转灯，你可以在淘宝用“旋转 POV”关键字搜索。旋转灯可以说是升级版的摇摇棒，电机代替了手，无线输电代替了电池，显示效果也上了有一个档次，甚至可以柱面、球面显示。不过作为灵魂的水银开关被磁传感器替代了，所以我感觉旋转灯的编码难度不会高于摇摇棒，难度更偏向于硬件设计。&lt;/p&gt;
&lt;p&gt;前两天看到一篇微信推送，视频里出现4根棒组成的便携式旋转灯，甚至有旋转灯阵列组成的屏幕，评论区直呼看不懂，我直呼羡慕。&lt;/p&gt;
&lt;p&gt;旋转灯局限于面显示（球面也是面），而光立方能增加一个维度，是真正的立体显示。光立方是静态的，唯一动的部分大概就是动态扫描了，没有一点难度，只是焊接太累了。正因工作量大且效果花哨，送给女朋友非常合适，这一点我已经验证过了。&lt;/p&gt;
&lt;p&gt;光立方的致命缺陷在于分辨率低，难以提高LED数量的根本原因在于它是三维的。摇摇棒是一维的，动起来以后成为二维，不难想象二维的运动起来可以变成三维——我还真在网上见过把光立方的一个面转起来的，分辨率与维数兼得。&lt;/p&gt;
&lt;p&gt;这些东西记在这里，给读者拓宽眼界，也给我自己种棵草。&lt;/p&gt;

&lt;p&gt;我没有仔细看过别人的摇摇棒设计，在第二版的设计、装配、编程过程中甚至没有以“摇摇棒”为关键字搜索过，一方面因为网上大多都是我不会的51，另一方面我不喜欢读别人的单片机代码，这与51的扩展语法脱不了干系，更重要的是我觉得那些都是上个世代的代码——我的第一版摇摇棒的程序竟然是用C++14写的！更夸张的是，回调用的是&lt;code&gt;std::vector&amp;lt;std::function&amp;lt;void()&amp;gt;&amp;gt;&lt;/code&gt;，后来还逐渐演化为C#中&lt;code&gt;event&lt;/code&gt;的类似物。事实上，AVR工具链并没有C++的标准库，这两个类模板是我自己实现的。&lt;/p&gt;
&lt;p&gt;那时年幼无知，不懂得谦虚，包括对人与对单片机。&lt;/p&gt;

&lt;p&gt;文章写完了。除了前言和后记差强人意以外，中间的技术介绍完全就是半吊子——有所涉及，却无法深入。譬如LED的电路，我本应详细介绍595与PWM及其背后的思想；又譬如周期检测，我本应带领读者一步一步实现这个算法。所以我只能更改本文的目标，把完整清晰地介绍摇摇棒下调为仅供读者观赏（如果你有意深入了解我的摇摇棒，可以后台联系我），甚至连这个小目标都达不到。&lt;/p&gt;
&lt;p&gt;或许摇摇棒的材料更适合用于讲座或视频，文字这一形式对表达有所限制，然而高手不应该被表达形式限制，所以归根结底是我太菜了。&lt;/p&gt;

&lt;p&gt;不知怎的，完成了码量是前一版几倍的项目外加一篇博客，收获感甚至比不上许久以前就着别人的博客实现出一个&lt;code&gt;std::function&lt;/code&gt;。可能是这个项目对于目前的我过于简单，这当然是件值得欣喜的事；或者，&lt;/p&gt;
&lt;p&gt;是因为高考临近了吧。&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Thu, 25 Jun 2020 14:24:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>一列LED，新手拿来做跑马灯，高手拿来做摇摇棒！相貌平平的棒，摇动起来竟显示出渐变色的图案！本文将从硬件、驱动、应用等角度，带你领略摇摇棒的技术核心与设计思想。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/shake_led_1.html</dc:identifier>
</item>
<item>
<title>一文告诉你Linux如何配置KVM虚拟化--安装篇 - unreal-dream</title>
<link>http://www.cnblogs.com/udream/p/13193187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/udream/p/13193187.html</guid>
<description>&lt;p&gt;KVM全称&quot;Kernel-based Virtual Machine&quot;,即基于内核的虚拟机，在linux内启用kvm需要硬件，内核和软件(qemu)支持，这篇文章教你如何配置并安装KVM虚拟机.&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;检查硬件和系统的兼容性&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;检查硬件虚拟化:&lt;code&gt;LC_ALL=C lscpu | grep Virtualization&lt;/code&gt;&lt;br/&gt;这行代码其中 LC_ALL=C为设置输出语言用，lscpu输出CPU信息，在输出的CPU信息里面查找“Virtualization”(虚拟化),输出结果如果有&quot;AMD-V&quot;(AMD CPU) 或者&quot;VT-X&quot;(Intel CPU),则说明你的电脑硬件支持并且已开启虚拟化，可以下一步&lt;br/&gt;那如果没有显示以上两种呢，就进入BIOS(或者UEFI)找到虚拟化/virtualization/VT-X/AMD-V一般来说是这四个名字里面任意一个，当然，如果你的班子BIOS里面是virtualization里面有vt-x和vt-d两个的话，就两个都开。然后，理论上你就能继续了，除非，你的硬件 根本不支持虚拟化(除非厂家手动阉割,现在一般不会有这问题,博主的本本一开始买来BIOS里面就是没有AMD-V的，后来就是靠BIOS更新加上的)。&lt;br/&gt;举个例子：博主linux上的显示是:&lt;code&gt;Virtualization: AMD-V&lt;/code&gt;则证明该电脑支持AMD 的虚拟化技术&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;检查系统是否支持&lt;code&gt;lsmod | grep kvm&lt;/code&gt;&lt;br/&gt;这行代码告诉你系统是否加载了KVM有关模块，如果有输出相关模块，请看kvm配置，否则接着看kvm的安装(kvm基于内核，需要内核模块才能正常工作)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;KVM 安装过程&lt;br/&gt;KVM的依赖项除了内核和内核模块主要有这些:firewalld(防火墙),dnsmasq,ebtables(网络方面),libvirt(虚拟化接口),qemu(虚拟机本体)。另外，使用bridge-utils可以设置网卡桥接。&lt;br/&gt;知道了需要的包，安装就好了.&lt;br/&gt;如果你的系统是Centos(RHEL/Fedora同理)你完全可以在安装的时候就选择虚拟化服务器的,如果要手动安装，那么需要跑这样一条命令(CENTOS8/fedora可能需要把yum替换为dnf):&lt;br/&gt;&lt;code&gt;sudo yum install -y virt-* libvirt bridge-utils qemu qemu-img qemu-kvm&lt;/code&gt;,需不需要操作selinux就看着办，如果因为selinux的原因导致无法开机，那就改，没问题就不需要动了(博主不是专业的运维。平时主玩ARCH，对这块不是特别了解)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;玩Ubuntu系列(ubuntu/deepin/mate/kali……)的同学安装kvm的话也类似，不过这包名可能和上面有所不同，代码如下：&lt;br/&gt;&lt;code&gt;sudo apt install qemu qemu-kvm libvirt-bin bridge-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Arch用户&lt;br/&gt;&lt;code&gt;sudo pacman -S qemu libvirt ebtables dnsmasq firewalld bridge-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完软件包,接下来开启防火墙和libvirt守护进程&lt;br/&gt;&lt;code&gt;sudo systemctl start firewalld &amp;amp;&amp;amp; sudo systemctl start libvirtd&lt;/code&gt;需不需要enable看你们自己的需要，如果是虚拟化母机或者经常用到虚拟机的话，那么建议enable，开机自动把虚拟化服务启动。&lt;/p&gt;
&lt;p&gt;讲完了基础安装工作，剩下的就是你如何控制kvm的事情了。图形化/命令行&lt;/p&gt;
&lt;p&gt;图形化控制KVM一般使用virt-manager(中文名:虚拟系统管理器),剩下的就是图形化设置的工作了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625211249468-680450922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，没错，就是这个东西，创建虚拟机的话，只需要点创建虚拟机按钮就好了(就是图上那个亮着的按钮)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625211627278-1977851390.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，连接这里选择QEMU/KVM，就是使用KVM虚拟机创建.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    番外内容:[有的同学可能先装了libvirt和virt-manager后装qemu的，就会出现没有连接或者连接里面没有KVM的，那么，在确保kvm服务开启的状态下，点击文件，添加连接。
        ![](https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625211926555-1690702968.png)
    出来这个页面，这里不用动，直接确定，不出意外，你就能导入KVM的连接了，需要知道的是，如果你之前使用virsh或者qemu命令行管理的话，你能够在这里导入kvm连接，但是，并不能接管原来创建的虚拟机。]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于以何种方式创建虚拟机，就看你需要，不过一般使用第一项使用ISO安装系统，如果你之前有kvm/qemu的磁盘镜像(qcow2)，你也可以用第四个(导入现有磁盘镜像).&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625212436123-406964961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里选择需要使用的ISO镜像文件.&lt;br/&gt;点击浏览弹出这个窗口&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625212623093-181920734.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后本地浏览选择镜像&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625212721747-932268039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择CPU/运行内存资源&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2045563/202006/2045563-20200625212810044-931145032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后创建虚拟硬盘，这里如果你有现成的qcow2/row镜像，你也可以直接拿来用。&lt;br/&gt;番外内容：[需要注意这点:通过libvirt 创建qemu镜像的大小是固定的，就是分多少它马上就吃多少的，不像vmware这样会动态扩展，当然，也可以实现，需要参考下面使用代码创建虚拟机]&lt;br/&gt;然后没有什么问题了，就直接点完成，开始安装系统，安装系统过程，这里就不赘述了，至于基础的管理工作，进去虚拟机的窗口，点击那个管理按钮，会进入类似于vmware虚拟机设置的页面，在里面可以进行操作(部分操作需要关机)。&lt;/p&gt;
&lt;p&gt;下面是代码创建虚拟机的介绍(高级玩法可能需要手动修改XML文件，这里就暂时不介绍了)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，你需要使用virsh这个命令来管理虚拟机，先创建存储卷(磁盘镜像)&lt;br/&gt;&lt;code&gt;virsh vol-create-as poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk&lt;/code&gt;&lt;br/&gt;一般QEMU/KVM支持的镜像为qcow/qcow2/row&lt;br/&gt;或者使用qemu-img来创建镜像&lt;br/&gt;敲黑板:qemu-img除了可以创建镜像以外，也和virsh一样支持镜像修改，另外，qemu-img创建镜像可以选择预分配模式，从而解决上面使用图形化镜像过大的问题.&lt;br/&gt;&lt;code&gt;qemu-img create -f 'qcow2' -o preallocation=off /home/udream/test.qcow2 10G&lt;/code&gt; 这样就可以创建一个10G大小的，关闭预分配的qcow2镜像，这个镜像文件没安装系统之前的大小是192.2Kb,默认直接创建的大小为10G&lt;br/&gt;然后，有了磁盘镜像，就可以创建虚拟机了&lt;br/&gt;举例代码如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;             virt-install  \
  -        --name test \
           --memory 4096             \
           --vcpus=2,maxvcpus=4      \
           --cpu host                \
           --cdrom $HOME/test.iso \
           --disk  /home/udream/test.qcow2,size=10GiB  \
           --network user            \
           --virt-type kvm   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码指定了虚拟机名字test，内存1g，CPU最少2核最大4核，安装盘位置：$HOME/test.iso，盘的大小，网络类型，虚拟化接口KVM，使用之前创建的虚拟盘 /home/udream/test.qcow2 大小 10G&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  创建完成虚拟机以后使用```virsh start 虚拟机名字```启动虚拟机
  关闭虚拟机把start改为shutdown，强制关机为destory,重启是reboot
  管理虚拟网络，使用virsh net-后面跟操作(start/destory/create……)
  当然，还有pool设置存储池，vol设置存储卷，snapshot设置快照，具体的，因为字数原因(怕某些同学太长不看)，就不一个个码了，你可以敲virsh --help查看具体帮助信息，不过。这几个最常用的也就是create/start/stop/destory/list了，
  这里举个例子，启动虚拟网络:```virsh net-start 虚拟网络名``` 创建存储池```virsh pool-create XML描述文件名```，其他的命令可以按照这样的方式操作，下一篇是virsh命令的具体玩(配)法(制)介绍。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次就讲到这里了，本次内容原创纯手码，部分命令为了确认正确性，参考了arch wiki，测试环境为ARCHLINUX 5.7.4-arch1-1 桌面环境kde plasma。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 14:20:00 +0000</pubDate>
<dc:creator>unreal-dream</dc:creator>
<og:description>KVM全称&amp;amp;quot;Kernel-based Virtual Machine&amp;amp;quot;,即基于内核的虚拟机，在linux内启用kvm需要硬件，内核和软件(qemu)支持，这篇文章教</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/udream/p/13193187.html</dc:identifier>
</item>
<item>
<title>Halcon斑点分析官方示例讲解 - callcall</title>
<link>http://www.cnblogs.com/MorganMa/p/13186831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MorganMa/p/13186831.html</guid>
<description>&lt;p&gt;官方示例中有许多很好的例子可以帮助大家理解和学习Halcon，下面举几个经典的斑点分析例子讲解一下&lt;/p&gt;
&lt;h5 id=&quot;crystals&quot;&gt;Crystals&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114238262-1968730715.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中显示了在高层大气中采集到的晶体样本的图像。任务是分析对象以确定特定形状的频率。重要的对象之一是六角形。&lt;/p&gt;
&lt;p&gt;首先，使用read_image从文件中读取图像。由于晶体的对比度相对较低且结合了不均匀的背景，因此使用局部阈值执行对象的分割。该轮次由平均过滤器mean_image确定。选择滤光罩的尺寸，使其具有暗区宽度的大约三倍。 dyn_threshold现在将平滑的和原始的灰色进行比较，选择那些通过8个灰度值的对比而变暗的像素。connection将对象分为连接的组件。下图显示了此初始分割的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read_image (Image, 'crystal')
mean_image (Image, ImageMean, 21, 21)
dyn_threshold (Image, ImageMean, RegionDynThresh, 8, 'dark')
connection (RegionDynThresh, ConnectedRegions)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114308574-896377256.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在的任务是仅选择六边形的晶体。为此，首先变成他们的凸包，这就像在每个区域周围都使用橡皮筋。在这些区域中，选择那些具有较大的（select_shape）并具有给定灰度值分布（select_gray）的对象。确定选择的参数，以便仅保留相关的晶体如下图。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shape_trans (ConnectedRegions, ConvexRegions, 'convex')
select_shape (ConvexRegions, LargeRegions, 'area', 'and', 600, 2000)
select_gray (LargeRegions, Image, Crystals, 'entropy', 'and', 1, 5.6)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114319349-1175863371.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* crystal.hdev: extraction of hexagonally shaped crystals via local thresholding and region post-processing
* 
dev_close_window ()
dev_update_window ('off')
* ****
* step: acquire image获取图像
* ****
read_image (Image, 'crystal')
get_image_size (Image, Width, Height)
dev_open_window_fit_image (Image, 0, 0, Width, Height, WindowID)
set_display_font (WindowID, 12, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (2)
dev_display (Image)
disp_continue_message (WindowID, 'black', 'true')
stop ()
* ****
* step: segment image分割图像
* ****
* -&amp;gt; using a local threshold
mean_image (Image, ImageMean, 21, 21)
dyn_threshold (Image, ImageMean, RegionDynThresh, 8, 'dark')
* -&amp;gt; extract connected components
connection (RegionDynThresh, ConnectedRegions)
dev_display (ConnectedRegions)
disp_continue_message (WindowID, 'black', 'true')
stop ()
* ****
* step: process regions处理区域
* ****
shape_trans (ConnectedRegions, ConvexRegions, 'convex')
select_shape (ConvexRegions, LargeRegions, 'area', 'and', 600, 2000)
select_gray (LargeRegions, Image, Crystals, 'entropy', 'and', 1, 5.6)
dev_display (Image)
dev_display (Crystals)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;atoms&quot;&gt;Atoms&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114415407-243962897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;专业显微镜能够确定单个原子的大致位置，这对于例如分析PN结晶体的晶格变化很有用，使用分水岭方法在这类图片上细分效果很好。在这里，每个暗区作为单个区域返回。因为在图像的外部原子仅部分可见，第一个任务是仅提取那些不靠近图像边界的原子。最后提取不规则，这是通过寻找形状（被挤压）的异常原子实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gauss_filter (Image, ImageGauss, 5)
watersheds (ImageGauss, Basins, Watersheds)

select_shape (Basins, SelectedRegions1, 'column1', 'and', 2, Width - 1)
select_shape (SelectedRegions1, SelectedRegions2, 'row1', 'and', 2, Height - 1)
select_shape (SelectedRegions2, SelectedRegions3, 'column2', 'and', 1, Width - 3)
select_shape (SelectedRegions3, Inner, 'row2', 'and', 1, Height - 3)
select_shape (Inner, Irregular, ['moments_i1','moments_i1'], 'or', [0,9.5e8], [1.5e8,1e10])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分水岭方法划分图像&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114422187-1294753925.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114428648-1641386150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* atoms.hdev: Locates irregularities in an atomic grid structure
* 
dev_close_window ()
dev_update_window ('off')
* ****
* Acquire image获取图像
* ****
read_image (Image, 'atoms')
get_image_size (Image, Width, Height)
crop_rectangle1 (Image, Image, Height / 2, 0, Height - 1, Width - 1)
get_image_size (Image, Width, Height)
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowID)
set_display_font (WindowID, 14, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (2)
dev_display (Image)
disp_message (WindowID, 'Original image', 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowID, 'black', 'true')
stop ()
* ****
* Segment image分割图像
* ****
* -&amp;gt; Using watershed
gauss_filter (Image, ImageGauss, 5)
watersheds (ImageGauss, Basins, Watersheds)
dev_display (Image)
dev_set_colored (12)
dev_display (Watersheds)
disp_message (WindowID, 'Watersheds', 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowID, 'black', 'true')
stop ()
* ****
* Process regions处理区域
* ****
* -&amp;gt; Skip regions at the border of the image
smallest_rectangle1 (Basins, Row1, Column1, Row2, Column2)
select_shape (Basins, SelectedRegions1, 'column1', 'and', 2, Width - 1)
select_shape (SelectedRegions1, SelectedRegions2, 'row1', 'and', 2, Height - 1)
select_shape (SelectedRegions2, SelectedRegions3, 'column2', 'and', 1, Width - 3)
select_shape (SelectedRegions3, Inner, 'row2', 'and', 1, Height - 3)
* -&amp;gt; Select irregularly shaped atoms
select_shape (Inner, Irregular, ['moments_i1','moments_i1'], 'or', [0,9.5e8], [1.5e8,1e10])
dev_display (Image)
dev_set_line_width (1)
dev_set_color ('white')
dev_display (Inner)
dev_set_line_width (3)
dev_set_color ('red')
dev_display (Irregular)
disp_message (WindowID, 'Defects', 'window', 12, 12, 'black', 'true')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;analyzing-particles&quot;&gt;Analyzing Particles&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114456789-1254919337.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本示例的任务是分析液体中的颗粒。此应用程序的主要困难是存在两种类型的物体：大的明亮物体和对比度低的小物体。此外，还存在噪音干扰。&lt;/p&gt;
&lt;p&gt;该程序使用两种不同的方法分别对两类对象进行分段：全局阈值和局部阈值。通过附加的后处理，可以以可靠的方式提取小颗粒。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threshold (Image, Large, 110, 255)
dilation_circle (Large, LargeDilation, 7.5)

complement (LargeDilation, NotLarge)
reduce_domain (Image, NotLarge, ParticlesRed)
mean_image (ParticlesRed, Mean, 31, 31)
dyn_threshold (ParticlesRed, Mean, SmallRaw, 3, 'light')
opening_circle (SmallRaw, Small, 2.5)
connection (Small, SmallConnection)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114516229-713696362.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114524627-125022235.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* particle.hdev: Measurement of small particles
* 
dev_update_off ()
dev_close_window ()
dev_open_window (0, 0, 512, 512, 'black', WindowID)
set_display_font (WindowID, 14, 'mono', 'true', 'false')
read_image (Image, 'particle')
dev_display (Image)
dev_disp_text ('Original image', 'window', 12, 12, 'black', [], [])
dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])
stop ()
threshold (Image, Large, 110, 255)
* Dilate regions with a circular structuring element
dilation_circle (Large, LargeDilation, 7.5)
dev_display (Image)
dev_set_draw ('margin')
dev_set_line_width (3)
dev_set_color ('red')
dev_display (LargeDilation)
dev_set_draw ('fill')
dev_disp_text ('Exclude large areas from processing', 'window', 12, 12, 'black', [], [])
dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])
stop ()
* Continue to calculate small regions
* Return the complement of a region
complement (LargeDilation, NotLarge)
reduce_domain (Image, NotLarge, ParticlesRed)
mean_image (ParticlesRed, Mean, 31, 31)
* Segment the image using a local threshold
dyn_threshold (ParticlesRed, Mean, SmallRaw, 3, 'light')
opening_circle (SmallRaw, Small, 2.5)
connection (Small, SmallConnection)
dev_display (Image)
dev_set_colored (12)
dev_display (SmallConnection)
dev_disp_text ('Extracted small particles', 'window', 12, 12, 'black', [], [])
dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])
stop ()
* Continue to select several regions and to get information
dev_set_color ('green')
dev_display (Image)
dev_set_draw ('margin')
dev_display (SmallConnection)
Button := 1
* Define limits for the displayed message at the end of the while-loop.
MaxRow := 450
MaxColumn := 440
MinRow := 40
MinColumn := 100
while (Button == 1)
    dev_disp_text (['Select object with left mouse button','Right button to quit'], 'window', 12, 12, 'black', 'box_color', '#fce9d4dd')
    dev_set_color ('green')
    get_mbutton (WindowID, Row, Column, Button)
    dev_display (Image)
    dev_display (SmallConnection)
    dev_set_color ('red')
    select_region_point (SmallConnection, SmallSingle, Row, Column)
    dev_display (SmallSingle)
    count_obj (SmallSingle, NumSingle)
    if (NumSingle == 1)
        intensity (SmallSingle, Image, MeanGray, DeviationGray)
        area_center (SmallSingle, Area, Row, Column)
        * Limit the message so that it is displayed entirely inside the graphics window.
        if (Row &amp;gt; MaxRow)
            Row := MaxRow
        endif
        if (Column &amp;gt; MaxColumn)
            Column := MaxColumn
        endif
        if (Row &amp;lt; MinRow)
            Row := MinRow
        endif
        if (Column &amp;lt; MinColumn)
            Column := MinColumn
        endif
        dev_disp_text (['Area = ' + Area,'Intensity = ' + MeanGray$'.3'], 'image', Row + 10, Column - 90, 'black', 'box_color', '#fce9d4dd')
    endif
endwhile
dev_set_line_width (1)
dev_update_on ()
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114541350-1351081943.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本示例的任务是在图中所示的彩色红外图像中检测不同的对象类别：树（针叶和落叶），草地和道路&lt;/p&gt;
&lt;p&gt;图像数据是彩色红外图像，由于其特定的颜色，可以非常轻松地提取道路。需要做到那样的话，要将多通道图像拆分为单通道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read_image (Forest, 'forest_air1')
decompose3 (Forest, Red, Green, Blue)
threshold (Blue, BlueBright, 80, 255)
connection (BlueBright, BlueBrightConnection)
select_shape (BlueBrightConnection, Path, 'area', 'and', 100, 100000000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;山毛榉树根据其在红色通道中的强度和最小大小进行分割&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threshold (Red, RedBright, 120, 255)
connection (RedBright, RedBrightConnection)
select_shape (RedBrightConnection, RedBrightBig, 'area', 'and', 1500, 10000000)
closing_circle (RedBrightBig, RedBrightClosing, 7.5)
opening_circle (RedBrightClosing, RedBrightOpening, 9.5)
connection (RedBrightOpening, RedBrightOpeningConnection)
select_shape (RedBrightOpeningConnection, BeechBig, 'area', 'and', 1000, 100000000)
select_gray (BeechBig, Blue, Beech, 'mean', 'and', 0, 59)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114607415-634444689.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;草地具有相似的光谱特性，但亮度略高&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;union1 (Beech, BeechUnion)
complement (BeechUnion, NotBeech)
difference (NotBeech, Path, NotBeechNotPath)
reduce_domain (Red, NotBeechNotPath, NotBeechNotPathRed)
threshold (NotBeechNotPathRed, BrightRest, 150, 255)
connection (BrightRest, BrightRestConnection)
select_shape (BrightRestConnection, Meadow, 'area', 'and', 500, 1000000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114616744-1707682749.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用分水岭方法提取针叶树，并在盆地内部增加阈值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;union2 (Path, RedBrightClosing, BeechPath)
smooth_image (Red, RedGauss, 'gauss', 4.0)
invert_image (RedGauss, Invert)
watersheds (Invert, SpruceRed, Watersheds)
select_shape (SpruceRed, SpruceRedLarge, 'area', 'and', 100, 5000)
select_gray (SpruceRedLarge, Red, SpruceRedInitial, 'max', 'and', 100, 200)
gen_empty_obj (LocalThresh)
count_obj (SpruceRedInitial, NumSpruce)
dev_update_var ('off')
dev_update_pc ('off')
for i := 1 to NumSpruce by 1
    select_obj (SpruceRedInitial, SingleSpruce, i)
    min_max_gray (SingleSpruce, Red, 50, Min, Max, Range)
    reduce_domain (Red, SingleSpruce, SingleSpruceRed)
    threshold (SingleSpruceRed, SingleSpruceBright, Min, 255)
    connection (SingleSpruceBright, SingleSpruceBrightCon)
    select_shape_std (SingleSpruceBrightCon, MaxAreaSpruce, 'max_area', 70)
    concat_obj (MaxAreaSpruce, LocalThresh, LocalThresh)
endfor
opening_circle (LocalThresh, FinalSpruce, 1.5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114624781-1155732830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dev_close_window ()
dev_update_window ('off')
read_image (Forest, 'forest_air1')
get_image_size (Forest, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
decompose3 (Forest, Red, Green, Blue)
dev_display (Red)
threshold (Blue, BlueBright, 80, 255)
connection (BlueBright, BlueBrightConnection)
select_shape (BlueBrightConnection, Path, 'area', 'and', 100, 100000000)
dev_set_color ('red')
dev_set_draw ('margin')
dev_display (Path)
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
threshold (Red, RedBright, 120, 255)
connection (RedBright, RedBrightConnection)
select_shape (RedBrightConnection, RedBrightBig, 'area', 'and', 1500, 10000000)
closing_circle (RedBrightBig, RedBrightClosing, 7.5)
opening_circle (RedBrightClosing, RedBrightOpening, 9.5)
connection (RedBrightOpening, RedBrightOpeningConnection)
select_shape (RedBrightOpeningConnection, BeechBig, 'area', 'and', 1000, 100000000)
select_gray (BeechBig, Blue, Beech, 'mean', 'and', 0, 59)
dev_display (Red)
dev_display (Beech)
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
union1 (Beech, BeechUnion)
complement (BeechUnion, NotBeech)
difference (NotBeech, Path, NotBeechNotPath)
reduce_domain (Red, NotBeechNotPath, NotBeechNotPathRed)
threshold (NotBeechNotPathRed, BrightRest, 150, 255)
connection (BrightRest, BrightRestConnection)
select_shape (BrightRestConnection, Meadow, 'area', 'and', 500, 1000000)
dev_display (Red)
dev_display (Meadow)
disp_continue_message (WindowHandle, 'black', 'true')
stop ()
union2 (Path, RedBrightClosing, BeechPath)
smooth_image (Red, RedGauss, 'gauss', 4.0)
invert_image (RedGauss, Invert)
watersheds (Invert, SpruceRed, Watersheds)
select_shape (SpruceRed, SpruceRedLarge, 'area', 'and', 100, 5000)
select_gray (SpruceRedLarge, Red, SpruceRedInitial, 'max', 'and', 100, 200)
gen_empty_obj (LocalThresh)
count_obj (SpruceRedInitial, NumSpruce)
dev_update_var ('off')
dev_update_pc ('off')
for i := 1 to NumSpruce by 1
    select_obj (SpruceRedInitial, SingleSpruce, i)
    min_max_gray (SingleSpruce, Red, 50, Min, Max, Range)
    reduce_domain (Red, SingleSpruce, SingleSpruceRed)
    threshold (SingleSpruceRed, SingleSpruceBright, Min, 255)
    connection (SingleSpruceBright, SingleSpruceBrightCon)
    select_shape_std (SingleSpruceBrightCon, MaxAreaSpruce, 'max_area', 70)
    concat_obj (MaxAreaSpruce, LocalThresh, LocalThresh)
endfor
opening_circle (LocalThresh, FinalSpruce, 1.5)
dev_set_line_width (2)
dev_set_color ('red')
dev_display (Red)
dev_display (FinalSpruce)
dev_set_color ('green')
dev_display (Beech)
dev_set_color ('yellow')
dev_display (Meadow)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;checking-a-boundary-for-fins&quot;&gt;Checking a Boundary for Fins&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114759218-1209610930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本示例的任务是检查塑料零件的外边界。在这种情况下，某些对象会显示鳍&lt;/p&gt;
&lt;p&gt;程序首先提取背景区域（鳍显示为压痕）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;binary_threshold (Fin, Background, 'max_separability', 'light', UsedThreshold)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114706748-1969873591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用形态学运算符关闭背景区域中的压痕&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; closing_circle (Background, ClosedBackground, 250)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114713748-2017090774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;封闭区域与原始区域之间的显著差异是鳍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; difference (ClosedBackground, Background, RegionDifference)
 opening_rectangle1 (RegionDifference, FinRegion, 5, 5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624114720012-650766937.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* fin.hdev: Detection of a fin
* 
dev_update_window ('off')
read_image (Fins, 'fin' + [1:3])
get_image_size (Fins, Width, Height)
dev_close_window ()
dev_open_window (0, 0, Width[0], Height[0], 'black', WindowID)
set_display_font (WindowID, 14, 'mono', 'true', 'false')
for I := 1 to 3 by 1
    select_obj (Fins, Fin, I)
    dev_display (Fin)
    binary_threshold (Fin, Background, 'max_separability', 'light', UsedThreshold)
    dev_set_color ('blue')
    dev_set_draw ('margin')
    dev_set_line_width (4)
    dev_display (Background)
    disp_continue_message (WindowID, 'black', 'true')
    stop ()
    closing_circle (Background, ClosedBackground, 250)
    dev_set_color ('green')
    dev_display (ClosedBackground)
    disp_continue_message (WindowID, 'black', 'true')
    stop ()
    difference (ClosedBackground, Background, RegionDifference)
    opening_rectangle1 (RegionDifference, FinRegion, 5, 5)
    dev_display (Fin)
    dev_set_color ('red')
    dev_display (FinRegion)
    area_center (FinRegion, FinArea, Row, Column)
    if (I &amp;lt; 3)
        disp_continue_message (WindowID, 'black', 'true')
        stop ()
    endif
endfor
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;bonding-balls&quot;&gt;Bonding Balls&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624122604804-645709806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本示例的任务是检查图中PCB板所示的球形键合直径&lt;/p&gt;
&lt;p&gt;球形键的提取有两个步骤：首先，通过分割亮区来定位裸片，然后将它们转换为最小的矩形&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threshold (Bond, Bright, 100, 255)
shape_trans (Bright, Die, 'rectangle2')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624122614083-328096154.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，使用reduce_domain处理模具内部的区域。在此ROI中，程序检查与线材相对应的深色区域&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;reduce_domain (Bond, Die, DieGrey)
threshold (DieGrey, Wires, 0, 50)
fill_up_shape (Wires, WiresFilled, 'area', 1, 100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624122636069-1607218505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除不相关的结构,并按预定顺序排列键提取所需的特征&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;opening_circle (WiresFilled, Balls, 15.5)
connection (Balls, SingleBalls)
select_shape (SingleBalls, IntermediateBalls, 'circularity', 'and', 0.85, 1.0)
sort_region (IntermediateBalls, FinalBalls, 'first_point', 'true', 'column')
smallest_circle (FinalBalls, Row, Column, Radius)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* ball.hdev: Inspection of Ball Bonding
* 
dev_update_window ('off')
dev_close_window ()
dev_open_window (0, 0, 728, 512, 'black', WindowID)
read_image (Bond, 'die/die_03')
dev_display (Bond)
set_display_font (WindowID, 14, 'mono', 'true', 'false')
disp_continue_message (WindowID, 'black', 'true')
stop ()
threshold (Bond, Bright, 100, 255)
shape_trans (Bright, Die, 'rectangle2')
dev_set_color ('green')
dev_set_line_width (3)
dev_set_draw ('margin')
dev_display (Die)
disp_continue_message (WindowID, 'black', 'true')
stop ()
reduce_domain (Bond, Die, DieGrey)
threshold (DieGrey, Wires, 0, 50)
fill_up_shape (Wires, WiresFilled, 'area', 1, 100)
dev_display (Bond)
dev_set_draw ('fill')
dev_set_color ('red')
dev_display (WiresFilled)
disp_continue_message (WindowID, 'black', 'true')
stop ()
opening_circle (WiresFilled, Balls, 15.5)
dev_set_color ('green')
dev_display (Balls)
disp_continue_message (WindowID, 'black', 'true')
stop ()
connection (Balls, SingleBalls)
select_shape (SingleBalls, IntermediateBalls, 'circularity', 'and', 0.85, 1.0)
sort_region (IntermediateBalls, FinalBalls, 'first_point', 'true', 'column')
dev_display (Bond)
dev_set_colored (12)
dev_display (FinalBalls)
disp_continue_message (WindowID, 'black', 'true')
stop ()
smallest_circle (FinalBalls, Row, Column, Radius)
NumBalls := |Radius|
Diameter := 2 * Radius
meanDiameter := mean(Diameter)
minDiameter := min(Diameter)
dev_display (Bond)
disp_circle (WindowID, Row, Column, Radius)
dev_set_color ('white')
disp_message (WindowID, 'D: ' + Diameter$'.4', 'image', Row - 2 * Radius, Column, 'white', 'false')
dev_update_window ('on')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;surface-scratches&quot;&gt;Surface Scratches&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624132548992-298178817.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本示例检测金属表面上的划痕&lt;br/&gt;分割的主要困难是背景不均匀以及划痕是薄的结构。可以使用局部阈值解决这两个问题。即算子mean_image和dyn_threshold,在connection后，将小对象(主要是噪声)移除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mean_image (Image, ImageMean, 7, 7)
dyn_threshold (Image, ImageMean, DarkPixels, 5, 'dark')
connection (DarkPixels, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 10, 1000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624132604532-1148809515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择的一部分是划痕，但是如果我们仔细观察，就会发现它们被部分分割了。为了解决这个问题，我们将所有分割部分再次合并到一个大区域中。通过应用dilation_circle将具有给定最大距离的物体组合在一起。最终获得正确形状的划痕。由于膨胀的缘故，使用skeleton将形状变薄到一个像素的宽度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;union1 (SelectedRegions, RegionUnion)
dilation_circle (RegionUnion, RegionDilation, 3.5)
skeleton (RegionDilation, Skeleton)
connection (Skeleton, Errors)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624132619817-1924546762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624132627557-1907023429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一步是区分表面上的小点和划痕。这是通过使用大小作为特征的select_shape实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select_shape (Errors, Scratches, 'area', 'and', 50, 10000)
select_shape (Errors, Dots, 'area', 'and', 1, 50)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1570888/202006/1570888-20200624132637216-1251235957.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* This programm shows the extraction of surface scratches via
* local thresholding and morphological post-processing
* 
dev_update_off ()
dev_close_window ()
* 
* Step 1: Acquire image
* 
read_image (Image, 'surface_scratch')
get_image_size (Image, Width, Height)
dev_open_window_fit_image (Image, 0, 0, Width, Width, WindowID)
set_display_font (WindowID, 16, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (4)
dev_display (Image)
Message := 'This program shows the extraction of'
Message[1] := 'surface scratches via local thresholding'
Message[2] := 'and morphological post-processing'
disp_message (WindowID, Message, 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowID, 'black', 'true')
stop ()
* 
* Step 2: Segment image
* 
* Using a local threshold
mean_image (Image, ImageMean, 7, 7)
dyn_threshold (Image, ImageMean, DarkPixels, 5, 'dark')
* 
* Extract connected components
connection (DarkPixels, ConnectedRegions)
dev_set_colored (12)
dev_display (Image)
dev_display (ConnectedRegions)
Message := 'Connected components after image segmentation'
Message[1] := 'using a local threshold.'
disp_message (WindowID, Message, 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowID, 'black', 'true')
stop ()
* 
* Step 3: Process regions
* 
* Select large regions
select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 10, 1000)
dev_display (Image)
dev_display (SelectedRegions)
disp_message (WindowID, 'Large Regions', 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowID, 'black', 'true')
stop ()
* 
* Visualize fractioned scratch
open_zoom_window (0, round(Width / 2), 2, 303, 137, 496, 3, WindowHandleZoom)
dev_set_color ('blue')
dev_display (Image)
dev_display (SelectedRegions)
set_display_font (WindowHandleZoom, 16, 'mono', 'true', 'false')
disp_message (WindowHandleZoom, 'Fractioned scratches', 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowHandleZoom, 'black', 'true')
stop ()
* 
* Merge fractioned scratches via morphology
union1 (SelectedRegions, RegionUnion)
dilation_circle (RegionUnion, RegionDilation, 3.5)
dev_display (Image)
dev_display (RegionDilation)
Message := 'Region of the scratches after dilation'
disp_message (WindowHandleZoom, Message, 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowHandleZoom, 'black', 'true')
stop ()
skeleton (RegionDilation, Skeleton)
connection (Skeleton, Errors)
dev_set_colored (12)
dev_display (Image)
dev_display (Errors)
Message := 'Fractioned scratches merged via morphology'
disp_message (WindowHandleZoom, Message, 'window', 12, 12, 'black', 'true')
disp_continue_message (WindowHandleZoom, 'black', 'true')
stop ()
* 
* Distinguish small and large scratches
close_zoom_window (WindowHandleZoom, Width, Height)
select_shape (Errors, Scratches, 'area', 'and', 50, 10000)
select_shape (Errors, Dots, 'area', 'and', 1, 50)
dev_display (Image)
dev_set_color ('red')
dev_display (Scratches)
dev_set_color ('blue')
dev_display (Dots)
Message := 'Extracted surface scratches'
Message[1] := 'Not categorized as scratches'
disp_message (WindowID, Message, 'window', 440, 310, ['red','blue'], 'true')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;灵感来源于官方文档&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jun 2020 12:22:00 +0000</pubDate>
<dc:creator>callcall</dc:creator>
<og:description>官方示例中有许多很好的例子可以帮助大家理解和学习Halcon，下面举几个经典的斑点分析例子讲解一下 Crystals 图中显示了在高层大气中采集到的晶体样本的图像。任务是分析对象以确定特定形状的频率。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MorganMa/p/13186831.html</dc:identifier>
</item>
</channel>
</rss>