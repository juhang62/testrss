<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Flink on Yarn三部曲之二：部署和设置 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13844418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13844418.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;p&gt;本文是《Flink on Yarn三部曲》系列的第二篇，上一篇&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105356306&quot;&gt;《Flink on Yarn三部曲之一：准备工作》&lt;/a&gt;已将所需的机器和文件准备完毕，可以部署CDH和Flink了；&lt;/p&gt;
&lt;h3 id=&quot;全文链接&quot;&gt;全文链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105356306&quot;&gt;《Flink on Yarn三部曲之一：准备工作》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105356347&quot;&gt;《&lt;br/&gt;Flink on Yarn三部曲之二：部署和设置&lt;br/&gt;》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105356399&quot;&gt;《Flink on Yarn三部曲之三：提交Flink任务》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;执行ansible脚本部署cdh和flinkansible电脑&quot;&gt;执行ansible脚本部署CDH和Flink(ansible电脑)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;进入ansible电脑的&lt;span&gt;~/playbooks&lt;/span&gt;目录，经过上一篇的准备工作，该目录下应该是下图这些内容：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082740185-1713155421.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;检查ansible远程操作CDH服务器是否正常，执行命令&lt;span&gt;ansible deskmini -a &quot;free -m&quot;&lt;/span&gt;，正常情况下显示CDH服务器的内存信息，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082740896-1145604642.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;执行命令开始部署：&lt;span&gt;ansible-playbook cm6-cdh5-flink1.7-single-install.yml&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;整个部署过程涉及在线安装、传文件等耗时的操作，因此请耐心等待（半小时左右），如果部署期间出错退出（例如网络问题），只需重复执行上述命令即可，ansible保证了操作的幂等性；&lt;/li&gt;
&lt;li&gt;部署成功如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082741597-709986373.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;重启cdh服务器&quot;&gt;重启CDH服务器&lt;/h3&gt;
&lt;p&gt;由于修改了selinux和swap的设置，需要重启操作系统才能生效，因此请重启CDH服务器；&lt;/p&gt;
&lt;h3 id=&quot;执行ansible脚本启动cdh服务ansible电脑&quot;&gt;执行ansible脚本启动CDH服务(ansible电脑)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;等待CDH服务器重启成功；&lt;/li&gt;
&lt;li&gt;登录ansible电脑，进入&lt;span&gt;~/playbooks&lt;/span&gt;目录；&lt;/li&gt;
&lt;li&gt;执行初始化数据库和启动CDH的脚本：&lt;span&gt;ansible-playbook cdh-single-start.yml&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;启动完成输出如下信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082742065-1964553583.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ssh登录CDH服务器，执行此命令观察CDH服务的启动情况：&lt;span&gt;tail -f /var/log/cloudera-scm-server/cloudera-scm-server.log&lt;/span&gt;，看到下图红框中的内容时，表示启动完成，可以用浏览器登录了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082743823-1142348098.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;设置浏览器操作&quot;&gt;设置(浏览器操作)&lt;/h3&gt;
&lt;p&gt;现在CDH服务已经启动了，可以通过浏览器来操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问：&lt;a href=&quot;http://192.168.50.134:7180&quot;&gt;http://192.168.50.134:7180&lt;/a&gt; ，如下图，账号密码都是&lt;span&gt;admin&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082744471-1144400008.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;一路next，在选择版本页面选择60天体验版：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082744759-39923126.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;选择主机页面可见CDH服务器（deskmini）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082745126-1277596090.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在选择CDH版本的页面，请选择下图红框中的&lt;span&gt;5.16.2-1&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082745509-1369978133.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;进入安装Parcel的页面，由于提前上传了离线parcle包，因此下载进度瞬间变成百分之百，此时请等待分配、解压、激活的完成：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082745775-1447416443.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来有一些推荐操作，这里选择如下图红框，即可跳过：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082746169-1813421543.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来是选择服务的页面，我选择了自定义服务，然后选择了&lt;span&gt;HDFS、YARN、Zookeeper&lt;/span&gt;这三项，可以满足运行Flink的需要：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082746527-1137329058.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在选择主机的页面，都选择CDH服务器：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082746910-155704687.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来是数据库设置的页面，&lt;span&gt;您填写的内容必须与下图保持一致&lt;/span&gt;，即主机名为&lt;span&gt;localhost&lt;/span&gt;，Activity Monitor的数据库、用户、密码都是&lt;span&gt;amon&lt;/span&gt;，Reports Manager的数据库、用户、密码都是&lt;span&gt;rman&lt;/span&gt;，这些内容在ansible脚本中已经固定了，此处的填写必须保持一致：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082747287-251354828.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在设置参数的页面，请按照您的硬盘实际情况设置，我这里&lt;span&gt;/home&lt;/span&gt;目录下空间充足，因此存储位置都改为&lt;span&gt;/home&lt;/span&gt;目录下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082747614-452080997.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;等待服务启动：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082747926-1849780217.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;各服务启动完成：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082748319-1539668521.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;yarn设置&quot;&gt;YARN设置&lt;/h3&gt;
&lt;p&gt;默认的YARN参数是非常保守的，需要做一些设置才能顺利执行Flink任务：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点下图红框位置，进入YARN管理页：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082748630-1645558363.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图所示，检查参数&lt;span&gt;yarn.nodemanager.resource.cpu-vcores&lt;/span&gt;的值，该值必须大于1，否则提交Flink任务后YARN不分配资源执行任务，（如果您的CDH服务器是虚拟机，当CPU只有单核时，则此参数就会被设置为1，解决办法是先提升虚拟机CPU核数，再来修改此参数）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082748924-858423283.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;yarn.scheduler.minimum-allocation-mb&lt;/span&gt;：单个容器可申请的最小内存，我这里设置为&lt;span&gt;1G&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;yarn.scheduler.maximum-allocation-mb&lt;/span&gt;：单个容器可申请的最大内存，我这里设置为&lt;span&gt;8G&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;yarn.nodemanager.resource.memory-mb&lt;/span&gt;：节点最大可用内存，我这里设置为&lt;span&gt;8G&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;上述三个参数的值，是基于我的CDH服务器有32G内存的背景，请您按照自己硬件资源自行调整；&lt;/li&gt;
&lt;li&gt;设置完毕后重启YARN服务，操作如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201020082749329-303845470.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，部署和设置都已完成，Flink on Yarn的环境已经可用了，在下一篇文章中，我们就在此环境提交Flink任务，体验Flink on Yarn；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 20 Oct 2020 00:28:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13844418.html</dc:identifier>
</item>
<item>
<title>【Flutter 混合开发】与原生通信-MethodChannel - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13844339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13844339.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080909072-269017841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Flutter 混合开发系列 包含如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;嵌入原生View-Android&lt;/li&gt;
&lt;li&gt;嵌入原生View-iOS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与原生通信-MethodChannel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;与原生通信-BasicMessageChannel&lt;/li&gt;
&lt;li&gt;与原生通信-EventChannel&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 Android Activity&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 Android Fragment&lt;/li&gt;
&lt;li&gt;添加 Flutter 到 iOS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个工作日分享一篇，欢迎关注、点赞及转发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;平台通信的3中方式&quot;&gt;平台通信的3中方式&lt;/h4&gt;
&lt;p&gt;Flutter 与 Native 端通信有如下3个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MethodChannel&lt;/strong&gt;：Flutter 与 Native 端相互调用，调用后可以返回结果，可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。此方式为最常用的方式， Native 端调用需要在主线程中执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BasicMessageChannel&lt;/strong&gt;：用于使用指定的编解码器对消息进行编码和解码，属于双向通信，可以 Native 端主动调用，也可以Flutter主动调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EventChannel&lt;/strong&gt;：用于数据流（event streams）的通信， Native 端主动发送数据给 Flutter，通常用于状态的监听，比如网络变化、传感器数据等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;通信架构图&quot;&gt;通信架构图&lt;/h4&gt;
&lt;p&gt;此图为官方的&lt;a href=&quot;https://flutter.dev/docs/development/platform-integration/platform-channels&quot;&gt;架构图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080909398-1760873686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter 与 Native 端通信是异步的。&lt;/p&gt;
&lt;h4 id=&quot;通信与平台线程&quot;&gt;通信与平台线程&lt;/h4&gt;
&lt;p&gt;Native 端主动发送数据给 Flutter时，Native 端代码需要在主线程中执行，Android 端从子线程跳转到主线程方式：&lt;/p&gt;
&lt;p&gt;Kotlin 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;Handler(Looper.getMainLooper()).post {
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new Handler(Looper.getMainLooper()).post(new Runnable() {
  @Override
  public void run() {
    
  }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果可以获取到当前 Activity，也可以使用如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;activity.runOnUiThread {
   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;iOS 端从子线程跳转到主线程方式：&lt;/p&gt;
&lt;p&gt;Objective-C 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dispatch_async(dispatch_get_main_queue(), ^{
  
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Swift 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DispatchQueue.main.async {
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;methodchannel&quot;&gt;MethodChannel&lt;/h3&gt;
&lt;h4 id=&quot;flutter-端&quot;&gt;Flutter 端&lt;/h4&gt;
&lt;p&gt;Flutter 端创建 &lt;strong&gt;MethodChannel&lt;/strong&gt; 通道，用于与原生端通信：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var channel = MethodChannel('com.flutter.guide.MethodChannel');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;com.flutter.guide.MethodChannel&lt;/strong&gt; 是 MethodChannel 的名称，原生端要与之对应。&lt;/p&gt;
&lt;p&gt;发送消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await channel.invokeMethod('sendData',{'name': 'laomeng', 'age': 18})
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第一个参数表示&lt;strong&gt;method&lt;/strong&gt;，方法名称，原生端会解析此参数。&lt;/li&gt;
&lt;li&gt;第二个参数表示参数，类型任意，多个参数通常使用&lt;strong&gt;Map&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;返回 &lt;strong&gt;Future&lt;/strong&gt;，原生端返回的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MethodChannelDemo extends StatefulWidget {
  @override
  _MethodChannelDemoState createState() =&amp;gt; _MethodChannelDemoState();
}

class _MethodChannelDemoState extends State&amp;lt;MethodChannelDemo&amp;gt; {
  var channel = MethodChannel('com.flutter.guide.MethodChannel');

  var _data;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Column(
        children: [
          SizedBox(
            height: 50,
          ),
          RaisedButton(
            child: Text('发送数据到原生'),
            onPressed: () async {
              var result = await channel
                  .invokeMethod('sendData', {'name': 'laomeng', 'age': 18});
              var name = result['name'];
              var age = result['age'];
              setState(() {
                _data = '$name,$age';
              });
            },
          ),
          Text('原生返回数据：$_data')
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;android-端&quot;&gt;Android 端&lt;/h4&gt;
&lt;p&gt;android 下创建 &lt;strong&gt;MethodChannelDemo&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;package com.flutter.guide

import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel

/**
 * des:
 */
class MethodChannelDemo(messenger: BinaryMessenger): MethodChannel.MethodCallHandler {

    private var channel: MethodChannel

    init {
        channel = MethodChannel(messenger, &quot;com.flutter.guide.MethodChannel&quot;)
        channel.setMethodCallHandler(this)
    }

    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080909647-459416012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onMethodCall&lt;/strong&gt; 方法在 Flutter 端调用 invokeMethod 方法回调，解析方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
    if (call.method == &quot;sendData&quot;) {
        val name = call.argument(&quot;name&quot;) as String?
        val age = call.argument(&quot;age&quot;) as Int?

        var map = mapOf(&quot;name&quot; to &quot;hello,$name&quot;,
                &quot;age&quot; to &quot;$age&quot;
        )
        result.success(map)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;call.method&lt;/strong&gt; 字符串就是 invokeMethod 方法传入的 &lt;strong&gt;method&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;call.argument&lt;/strong&gt; 是 invokeMethod 传入的参数，由于 Flutter 端传入的是 Map，所以上面的解析按照 Map 解析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;result.success()&lt;/strong&gt; 是返回给 Flutter 的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Flutter 端解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await channel
    .invokeMethod('sendData', {'name': 'laomeng', 'age': 18});
var name = result['name'];
var age = result['age'];
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;两端的解析要相互对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;MainActivity&lt;/strong&gt; 启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : FlutterActivity() {
    
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        MethodChannelDemo(flutterEngine.dartExecutor.binaryMessenger)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080909835-1472934410.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ios-端&quot;&gt;iOS 端&lt;/h4&gt;
&lt;p&gt;ios 下创建 &lt;strong&gt;MethodChannelDemo&lt;/strong&gt;，按如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;import Flutter
import UIKit

public class MethodChannelDemo {
    
    init(messenger: FlutterBinaryMessenger) {
        let channel = FlutterMethodChannel(name: &quot;com.flutter.guide.MethodChannel&quot;, binaryMessenger: messenger)
        channel.setMethodCallHandler { (call:FlutterMethodCall, result:@escaping FlutterResult) in
            if (call.method == &quot;sendData&quot;) {
                if let dict = call.arguments as? Dictionary&amp;lt;String, Any&amp;gt; {
                    let name:String = dict[&quot;name&quot;] as? String ?? &quot;&quot;
                    let age:Int = dict[&quot;age&quot;] as? Int ?? -1
                    result([&quot;name&quot;:&quot;hello,\(name)&quot;,&quot;age&quot;:age])
                }
            }
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080909986-370621368.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;AppDelegate&lt;/strong&gt; 启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;import UIKit
import Flutter

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -&amp;gt; Bool {
    
    let controller : FlutterViewController = window?.rootViewController as! FlutterViewController
    MethodChannelDemo(messenger: controller.binaryMessenger)
    GeneratedPluginRegistrant.register(with: self)
    
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080910208-1078775291.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;原生端主动发送消息给flutter&quot;&gt;原生端主动发送消息给Flutter&lt;/h4&gt;
&lt;h5 id=&quot;flutter-端接收数据&quot;&gt;Flutter 端接收数据&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
void initState() {
  super.initState();
  channel.setMethodCallHandler((call) {
    setState(() {
      _nativeData = call.arguments['count'];
    });
  });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;android-发送数据&quot;&gt;Android 发送数据&lt;/h5&gt;
&lt;p&gt;原生端启动定时器，每隔一秒向 Flutter 发送数据，Android 端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MethodChannelDemo(var activity: Activity, messenger: BinaryMessenger) : MethodChannel.MethodCallHandler {

    private var channel: MethodChannel
    private var count = 0

    init {
        channel = MethodChannel(messenger, &quot;com.flutter.guide.MethodChannel&quot;)
        channel.setMethodCallHandler(this)
        startTimer()
    }


    fun startTimer() {
        var timer = Timer().schedule(timerTask {
            activity.runOnUiThread {
                var map = mapOf(&quot;count&quot; to count++)
                channel.invokeMethod(&quot;timer&quot;, map)
            }
        }, 0, 1000)

    }

    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
        if (call.method == &quot;sendData&quot;) {
            val name = call.argument(&quot;name&quot;) as String?
            val age = call.argument(&quot;age&quot;) as Int?

            var map = mapOf(&quot;name&quot; to &quot;hello,$name&quot;,
                    &quot;age&quot; to &quot;$age&quot;
            )
            result.success(map)
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：Android 端发送数据要在&lt;strong&gt;主现场&lt;/strong&gt;中调用，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;activity.runOnUiThread {
             var map = mapOf(&quot;count&quot; to count++)
             channel.invokeMethod(&quot;timer&quot;, map)
         }
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;启动修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-kotlin&quot;&gt;class MainActivity : FlutterActivity() {

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        MethodChannelDemo(this,flutterEngine.dartExecutor.binaryMessenger)
        flutterEngine.plugins.add(MyPlugin())
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080910391-858280313.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;ios-发送数据&quot;&gt;iOS 发送数据&lt;/h5&gt;
&lt;p&gt;iOS 端启动定时器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import Flutter
import UIKit

public class MethodChannelDemo {
    var count =  0
    var channel:FlutterMethodChannel
    init(messenger: FlutterBinaryMessenger) {
        channel = FlutterMethodChannel(name: &quot;com.flutter.guide.MethodChannel&quot;, binaryMessenger: messenger)
        channel.setMethodCallHandler { (call:FlutterMethodCall, result:@escaping FlutterResult) in
            if (call.method == &quot;sendData&quot;) {
                if let dict = call.arguments as? Dictionary&amp;lt;String, Any&amp;gt; {
                    let name:String = dict[&quot;name&quot;] as? String ?? &quot;&quot;
                    let age:Int = dict[&quot;age&quot;] as? Int ?? -1
                    result([&quot;name&quot;:&quot;hello,\(name)&quot;,&quot;age&quot;:age])
                }
            }
        }
        startTimer()
    }
    
    func startTimer() {
        var timer = Timer.scheduledTimer(timeInterval:1, target: self, selector:#selector(self.tickDown),userInfo:nil,repeats: true)
    }
    @objc func tickDown(){
        count += 1
        var args = [&quot;count&quot;:count]
        channel.invokeMethod(&quot;timer&quot;, arguments:args)
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080910649-539475233.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080911014-1581709250.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202010/467322-20201020080911433-588282424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 20 Oct 2020 00:09:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>Flutter 混合开发系列 包含如下： 嵌入原生View-Android 嵌入原生View-iOS 与原生通信-MethodChannel 与原生通信-BasicMessageChannel 与原生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13844339.html</dc:identifier>
</item>
<item>
<title>计算机网络基础知识总结 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13844269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13844269.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPLTI.png&quot; alt=&quot;computer network1001&quot; border=&quot;0&quot;/&gt;&lt;p&gt;如果说计算机把我们从工业时代带到了信息时代，那么计算机网络就可以说把我们带到了网络时代。随着使用计算机人数的不断增加，计算机也经历了一系列的发展，从大型通用计算机 -&amp;gt; 超级计算机 -&amp;gt; 小型机 -&amp;gt; 个人电脑 -&amp;gt; 工作站 -&amp;gt; 便携式电脑 -&amp;gt; 智能手机终端等都是这一过程的产物。计算机网络也逐渐从&lt;code&gt;独立模式&lt;/code&gt;演变为了 &lt;code&gt;网络互联模式&lt;/code&gt; 。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPq0A.png&quot; alt=&quot;computer network1002&quot; border=&quot;0&quot;/&gt;&lt;p&gt;可以看到，在独立模式下，每个人都需要排队等待其他人在一个机器上完成工作后，其他用户才能使用。这样的数据是单独管理的。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPT6e.png&quot; alt=&quot;computer network1003&quot; border=&quot;0&quot;/&gt;&lt;p&gt;现在切换到了网络互联模式，在这种模式下，每个人都能独立的使用计算机，甚至还会有一个服务器，来为老大哥、cxuan 和 sonsong 提供服务。这样的数据是集中管理的。&lt;/p&gt;
&lt;p&gt;计算机网络按规模进行划分，有 &lt;code&gt;WAN(Wide Area Network, 广域网)&lt;/code&gt; 和 &lt;code&gt;LAN(Local area Network, 局域网)&lt;/code&gt;。如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPbmd.png&quot; alt=&quot;computer network1004&quot; border=&quot;0&quot;/&gt;&lt;p&gt;上面是局域网，一般用在狭小区域内的网络，一个社区、一栋楼、办公室经常使用局域网。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP7OH.png&quot; alt=&quot;computer network1005&quot; border=&quot;0&quot;/&gt;&lt;p&gt;距离较远的地方组成的网络一般是广域网。&lt;/p&gt;
&lt;p&gt;最初，只是固定的几台计算机相连在一起形成计算机网络。这种网络一般是私有的，这几台计算机之外的计算机无法访问。随着时代的发展，人们开始尝试在私有网络上搭建更大的私有网络，逐渐又发展演变为互联网，现在我们每个人几乎都能够享有互联网带来的便利。&lt;/p&gt;
&lt;h2 id=&quot;计算机网络发展历程&quot;&gt;计算机网络发展历程&lt;/h2&gt;
&lt;h3 id=&quot;批处理&quot;&gt;批处理&lt;/h3&gt;
&lt;p&gt;就和早期的计算机操作系统一样，最开始都要先经历&lt;code&gt;批处理(atch Processing)&lt;/code&gt;阶段，批处理的目的也是为了能让更多的人使用计算机。&lt;/p&gt;
&lt;p&gt;批处理就是事先将数据装入卡带或者磁带，并且由计算机按照一定的顺序进行读入。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPISO.png&quot; alt=&quot;computer network1006&quot; border=&quot;0&quot;/&gt;&lt;p&gt;当时这种计算机的价格比较昂贵，并不是每个人都能够使用的，这也就客观暗示着，只有专门的操作员才能使用计算机，用户把程序提交给操作员，由操作员排队执行程序，等一段时间后，用户再来提取结果。&lt;/p&gt;
&lt;p&gt;这种计算机的高效性并没有很好的体现，甚至不如手动运算快。&lt;/p&gt;
&lt;h3 id=&quot;分时系统&quot;&gt;分时系统&lt;/h3&gt;
&lt;p&gt;在批处理之后出现的就是分时系统了，分时系统指的是多个终端与同一个计算机连接，允许多个用户同时使用一台计算机。分时系统的出现实现了&lt;code&gt;一人一机&lt;/code&gt;的目的，让用户感觉像是自己在使用计算机，实际上这是一种 &lt;code&gt;独占性&lt;/code&gt; 的特性。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP4fK.png&quot; alt=&quot;computer network1007&quot; border=&quot;0&quot;/&gt;&lt;p&gt;分时系统出现以来，计算机的可用性得到了极大的改善。分时系统的出现意味着计算机越来越贴近我们的生活。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;还有一点需要注意：分时系统的出现促进了像是 BASIC 这种人机交互语言的诞生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分时系统的出现，同时促进者计算机网络的出现。&lt;/p&gt;
&lt;h3 id=&quot;计算机通信&quot;&gt;计算机通信&lt;/h3&gt;
&lt;p&gt;在分时系统中，每个终端与计算机相连，这种独占性的方式并不是计算机之间的通信，因为每个人还是在独立的使用计算机。&lt;/p&gt;
&lt;p&gt;到了 20 世纪 70 年代，计算机性能有了高速发展，同时体积也变得越来越小，使用计算机的门槛变得更低，越来越多的用户可以使用计算机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有一个计算机是信息孤岛&lt;/strong&gt;促使着计算机网络的出现和发展。&lt;/p&gt;
&lt;h3 id=&quot;计算机网络的诞生&quot;&gt;计算机网络的诞生&lt;/h3&gt;
&lt;p&gt;20 世纪 80 年代，一种能够互连多种计算机的网络随之诞生。它能够让各式各样的计算机相连，从大型的超级计算机或主机到小型电脑。&lt;/p&gt;
&lt;p&gt;20 世纪 90 年代，真正实现了一人一机的环境，但是这种环境的搭建仍然价格不菲。与此同时，诸如&lt;code&gt;电子邮件(E-mail)&lt;/code&gt;、&lt;code&gt;万维网(WWW,World Wide Web)&lt;/code&gt; 等信息传播方式如雨后春笋般迎来了前所未有的发展，使得互联网从大到整个公司小到每个家庭内部，都得以广泛普及。&lt;/p&gt;
&lt;h3 id=&quot;计算机网络的高速发展&quot;&gt;计算机网络的高速发展&lt;/h3&gt;
&lt;p&gt;现如今，越来越多的终端设备接入互联网，使互联网经历了前所未有的&lt;code&gt;高潮&lt;/code&gt;，近年来 3G、4G、5G 通信技术的发展更是互联网高速发展的产物。&lt;/p&gt;
&lt;p&gt;许多发展道路各不相同的网络技术也都正在向互联网靠拢。例如，曾经一直作为通信基础设施、支撑通信网络的电话网。随着互联网的发展，其地位也随着时间的推移被 &lt;code&gt;IP(Internet Protocol)&lt;/code&gt; 网所取代，IP 也是互联网发展的产物。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPhY6.png&quot; alt=&quot;computer network1008&quot; border=&quot;0&quot;/&gt;&lt;h3 id=&quot;网络安全&quot;&gt;网络安全&lt;/h3&gt;
&lt;p&gt;正如互联网也具有两面性，互联网的出现方便了用户，同时也方便了一些不法分子。互联网的便捷也带来了一些负面影响，计算机病毒的侵害、信息泄漏、网络诈骗层出不穷。&lt;/p&gt;
&lt;p&gt;在现实生活中，通常情况下我们挨揍了会予以反击，但是在互联网中，你被不法分子攻击通常情况下是无力还击的，只能防御，因为还击需要你精通计算机和互联网，这通常情况下很多人办不到。&lt;/p&gt;
&lt;p&gt;通常情况下公司和企业容易被作为不法分子获利的对象，所以，作为公司或者企业，要想不受攻击或者防御攻击，需要建立安全的互联网连接。&lt;/p&gt;
&lt;h2 id=&quot;互联网协议&quot;&gt;互联网协议&lt;/h2&gt;
&lt;p&gt;协议这个名词不仅局限于互联网范畴，也体现在日常生活中，比如情侣双方约定好在哪个地点吃饭，这个约定也是一种&lt;code&gt;协议&lt;/code&gt;，比如你应聘成功了，企业会和你签订劳动合同，这种双方的雇佣关系也是一种 &lt;code&gt;协议&lt;/code&gt;。注意自己一个人对自己的约定不能成为协议，协议的前提条件必须是多人约定。&lt;/p&gt;
&lt;p&gt;那么网络协议是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;没有网络协议的互联网是混乱的，就和人类社会一样，人不能想怎么样就怎么样，你的行为约束是受到法律的约束的；那么互联网中的端系统也不能自己想发什么发什么，也是需要受到通信协议约束的。&lt;/p&gt;
&lt;p&gt;我们一般都了解过 HTTP 协议， &lt;strong&gt;HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是互联网又不只有 HTTP 协议，它还有很多其他的比如 IP、TCP、UDP、DNS 协议等。下面是一些协议的汇总和介绍&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;网络体系结构&lt;/th&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;主要用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;TCP/IP&lt;/td&gt;
&lt;td&gt;HTTP、SMTP、TELNET、IP、ICMP、TCP、UDP 等&lt;/td&gt;
&lt;td&gt;主要用于互联网、局域网&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IPX/SPX&lt;/td&gt;
&lt;td&gt;IPX、NPC、SPX&lt;/td&gt;
&lt;td&gt;主要用于个人电脑局域网&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AppleTalk&lt;/td&gt;
&lt;td&gt;AEP、ADP、DDP&lt;/td&gt;
&lt;td&gt;苹果公司现有产品互联&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;ISO 在制定标准化的 OSI 之前，对网络体系结构相关的问题进行了充分的探讨，最终提出了作为通信协议设计指标的 OSI 参考模型。这一模型将通信协议中必要的功能分为了 7 层。通过这 7 层分层，使那些比较复杂的协议简单化。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPRT1.png&quot; alt=&quot;computer network1009&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在 OSI 标准模型中，每一层协议都接收由它下一层所提供的特定服务，并且负责为上一层提供服务，上层协议和下层协议之间通常会开放 &lt;code&gt;接口&lt;/code&gt;，同一层之间的交互所遵守的约定叫做 &lt;code&gt;协议&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;osi-标准模型&quot;&gt;OSI 标准模型&lt;/h3&gt;
&lt;p&gt;上图只是简单的介绍了一下层与层之间的通信规范和上层与下层的通信规范，并未介绍具体的网络协议分层，实际上，OSI 标准模型将复杂的协议整理并分为了易于理解的 7 层。如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPgm9.png&quot; alt=&quot;computer network1010&quot; border=&quot;0&quot;/&gt;&lt;p&gt;互联网的通信协议都对应了 7 层中的某一层，通过这一点，可以了解协议在整个网络模型中的作用，一般来说，各个分层的主要作用如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPfFx.png&quot; alt=&quot;computer network1011&quot; border=&quot;0&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;应用层&lt;/code&gt;：应用层是 OSI 标准模型的最顶层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。包括文件传输、电子邮件远程登录和远端接口调用等协议。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;表示层&lt;/code&gt;: 表示层向上对应用进程服务，向下接收会话层提供的服务，表示层位于 OSI 标准模型的第六层，表示层的主要作用就是将设备的固有数据格式转换为网络标准传输格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;会话层&lt;/code&gt;：会话层位于 OSI 标准模型的第五层，它是建立在传输层之上，利用传输层提供的服务建立和维持会话。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;传输层&lt;/code&gt;：传输层位于 OSI 标准模型的第四层，它在整个 OSI 标准模型中起到了至关重要的作用。传输层涉及到两个节点之间的数据传输，向上层提供可靠的数据传输服务。传输层的服务一般要经历传输连接建立阶段，数据传输阶段，传输连接释放阶段 3 个阶段才算完成一个完整的服务过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;网络层&lt;/code&gt;：网络层位于 OSI 标准模型的第三层，它位于传输层和数据链路层的中间，将数据设法从源端经过若干个中间节点传送到另一端，从而向运输层提供最基本的端到端的数据传送服务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据链路层&lt;/code&gt;：数据链路层位于物理层和网络层中间，数据链路层定义了在单个链路上如何传输数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;物理层&lt;/code&gt;：物理层是 OSI 标准模型中最低的一层，物理层是整个 OSI 协议的基础，就如同房屋的地基一样，物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tcpip-协议簇&quot;&gt;TCP/IP 协议簇&lt;/h3&gt;
&lt;p&gt;TCP/IP 协议是我们程序员接触最多的协议，实际上，TCP/IP 又被称为 &lt;code&gt;TCP/IP 协议簇&lt;/code&gt;，它并不特指单纯的 TCP 和 IP 协议，而是容纳了许许多多的网络协议。&lt;/p&gt;
&lt;p&gt;OSI 模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP/IP协议中，它们被简化为了四个层次&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPyy4.png&quot; alt=&quot;computer network1012&quot; border=&quot;0&quot;/&gt;&lt;p&gt;和 OSI 七层网络协议的主要区别如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP/IP 协议中，它们被合并为应用层一个层次。&lt;/li&gt;
&lt;li&gt;由于数据链路层和物理层的内容很相似，所以在 TCP/IP 协议中它们被归并在网络接口层一个层次里。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们的主要研究对象就是 TCP/IP 的四层协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面 cxuan 和你聊一聊 TCP/IP 协议簇中都有哪些具体的协议&lt;/p&gt;
&lt;h4 id=&quot;ip-协议&quot;&gt;IP 协议&lt;/h4&gt;
&lt;p&gt;IP 是 &lt;code&gt;互联网协议(Internet Protocol)&lt;/code&gt; ，位于网络层。IP是整个 TCP/IP 协议族的核心，也是构成互联网的基础。IP 能够为运输层提供数据分发，同时也能够组装数据供运输层使用。它将多个单个网络连接成为一个互联网，这样能够提高网络的可扩展性，实现大规模的网络互联。二是分割顶层网络和底层网络之间的耦合关系。&lt;/p&gt;
&lt;h4 id=&quot;icmp-协议&quot;&gt;ICMP 协议&lt;/h4&gt;
&lt;p&gt;ICMP 协议是 &lt;code&gt;Internet Control Message Protocol&lt;/code&gt;， ICMP 协议主要用于在 IP 主机、路由器之间传递控制消息。ICMP 属于网络层的协议，当遇到 IP 无法访问目标、IP 路由器无法按照当前传输速率转发数据包时，会自动发送 ICMP 消息，从这个角度来说，ICMP 协议可以看作是 &lt;code&gt;错误侦测与回报机制&lt;/code&gt;，让我们检查网络状况、也能够确保连线的准确性。&lt;/p&gt;
&lt;h4 id=&quot;arp-协议&quot;&gt;ARP 协议&lt;/h4&gt;
&lt;p&gt;ARP 协议是 &lt;code&gt;地址解析协议&lt;/code&gt;，即 &lt;code&gt;Address Resolution Protocol&lt;/code&gt;，它能够根据 IP 地址获取物理地址。主机发送信息时会将包含目标 IP 的 ARP 请求广播到局域网络上的所有主机，并接受返回消息，以此来确定物理地址。收到消息后的物理地址和 IP 地址会在 ARP 中缓存一段时间，下次查询的时候直接从 ARP 中查询即可。&lt;/p&gt;
&lt;h4 id=&quot;tcp-协议&quot;&gt;TCP 协议&lt;/h4&gt;
&lt;p&gt;TCP 就是 &lt;code&gt;传输控制协议&lt;/code&gt;，也就是 &lt;code&gt;Transmission Control Protocol&lt;/code&gt;，它是一种面向连接的、可靠的、基于字节流的传输协议，TCP 协议位于传输层，TCP 协议是 TCP/IP 协议簇中的核心协议，它最大的特点就是提供可靠的数据交付。&lt;/p&gt;
&lt;p&gt;TCP 的主要特点有 &lt;strong&gt;慢启动、拥塞控制、快速重传、可恢复&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;udp-协议&quot;&gt;UDP 协议&lt;/h4&gt;
&lt;p&gt;UDP 协议就是 &lt;code&gt;用户数据报协议&lt;/code&gt;，也就是 &lt;code&gt;User Datagram Protocol&lt;/code&gt;，UDP 也是一种传输层的协议，与 TCP 相比，UDP 提供一种不可靠的数据交付，也就是说，UDP 协议不保证数据是否到达目标节点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 是一种无连接的协议，传输数据之前源端和终端无需建立连接，不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序等现象。但是 UDP 具有较好的实时性，工作效率较 TCP 协议高。&lt;/p&gt;
&lt;h4 id=&quot;ftp-协议&quot;&gt;FTP 协议&lt;/h4&gt;
&lt;p&gt;FTP 协议是 &lt;code&gt;文件传输协议&lt;/code&gt;，英文全称是 &lt;code&gt;File Transfer Protocol&lt;/code&gt;，应用层协议之一，是 TCP/IP 协议的重要组成之一，FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。&lt;/p&gt;
&lt;h4 id=&quot;dns-协议&quot;&gt;DNS 协议&lt;/h4&gt;
&lt;p&gt;DNS 协议是 &lt;code&gt;域名系统协议&lt;/code&gt;，英文全称是 &lt;code&gt;Domain Name System&lt;/code&gt;，它也是应用层的协议之一，DNS 协议是一个将域名和 IP 相互映射的分布式数据库系统。DNS 缓存能够加快网络资源的访问。&lt;/p&gt;
&lt;h4 id=&quot;smtp-协议&quot;&gt;SMTP 协议&lt;/h4&gt;
&lt;p&gt;SMTP 协议是 &lt;code&gt;简单邮件传输协议&lt;/code&gt;，英文全称是 &lt;code&gt;Simple Mail Transfer Protocol&lt;/code&gt;，应用层协议之一，SMTP 主要是用作邮件收发协议，SMTP 服务器是遵循 SMTP 协议的发送邮件服务器，用来发送或中转用户发出的电子邮件&lt;/p&gt;
&lt;h4 id=&quot;slip-协议&quot;&gt;SLIP 协议&lt;/h4&gt;
&lt;p&gt;SLIP 协议是指&lt;code&gt;串行线路网际协议（Serial Line Internet Protocol)&lt;/code&gt; ，是在串行通信线路上支持 TCP/IP 协议的一种&lt;code&gt;点对点(Point-to-Point&lt;/code&gt;)式的链路层通信协议。&lt;/p&gt;
&lt;h4 id=&quot;ppp-协议&quot;&gt;PPP 协议&lt;/h4&gt;
&lt;p&gt;PPP 协议是 &lt;code&gt;Point to Point Protocol&lt;/code&gt;，即点对点协议，是一种链路层协议，是在为同等单元之间传输数据包而设计的。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;网络核心概念&quot;&gt;网络核心概念&lt;/h2&gt;
&lt;h3 id=&quot;传输方式&quot;&gt;传输方式&lt;/h3&gt;
&lt;p&gt;网络根据传输方式可以进行分类，一般分成两种 &lt;strong&gt;面向连接型和面向无连接型&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向连接型中，在发送数据之前，需要在主机之间建立一条通信线路。&lt;/li&gt;
&lt;li&gt;面向无连接型则不要求建立和断开连接，发送方可用于任何时候发送数据。接收端也不知道自己何时从哪里接收到数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分组交换&quot;&gt;分组交换&lt;/h3&gt;
&lt;p&gt;在互联网应用中，每个终端系统都可以彼此交换信息，这种信息也被称为 &lt;code&gt;报文(Message)&lt;/code&gt;，报文是一个集大成者，它可以包括你想要的任何东西，比如文字、数据、电子邮件、音频、视频等。为了从源目的地向端系统发送报文，需要把长报文切分为一个个小的数据块，这种数据块称为&lt;code&gt;分组(Packets)&lt;/code&gt;，也就是说，报文是由一个个小块的分组组成。在端系统和目的地之间，每个分组都要经过&lt;code&gt;通信链路(communication links)&lt;/code&gt; 和&lt;code&gt;分组交换机(switch packets)&lt;/code&gt; ，分组要在端系统之间交互需要经过一定的时间，如果两个端系统之间需要交互的分组为 L 比特，链路的传输速率问 R 比特/秒，那么传输时间就是 L / R秒。&lt;/p&gt;
&lt;p&gt;一个端系统需要经过交换机给其他端系统发送分组，当分组到达交换机时，交换机就能够直接进行转发吗？不是的，交换机可没有这么无私，你想让我帮你转发分组？好，首先你需要先把整个分组数据都给我，我再考虑给你发送的问题，这就是&lt;code&gt;存储转发传输&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;存储转发传输&quot;&gt;存储转发传输&lt;/h4&gt;
&lt;p&gt;存储转发传输指的就是交换机再转发分组的第一个比特前，必须要接受到整个分组，下面是一个存储转发传输的示意图，可以从图中窥出端倪&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP1W8.png&quot; alt=&quot;computer network1013&quot; border=&quot;0&quot;/&gt;&lt;p&gt;由图可以看出，分组 1、2、3 向交换器进行分组传输，并且交换机已经收到了分组1 发送的比特，此时交换机会直接进行转发吗？答案是不会的，交换机会把你的分组先缓存在本地。这就和考试作弊一样，一个学霸要经过学渣 A 给学渣 B 传答案，学渣 A 说，学渣 A 在收到答案后，它可能直接把卷子传过去吗？学渣A 说，等我先把答案抄完（保存功能）后再把卷子给你。&lt;/p&gt;
&lt;h4 id=&quot;排队时延和分组丢失&quot;&gt;排队时延和分组丢失&lt;/h4&gt;
&lt;p&gt;什么？你认为交换机只能和一条通信链路进行相连？那你就大错特错了，这可是交换机啊，怎么可能只有一条通信链路呢？&lt;/p&gt;
&lt;p&gt;所以我相信你一定能想到这个问题，多个端系统同时给交换器发送分组，一定存在&lt;code&gt;顺序到达&lt;/code&gt;和&lt;code&gt;排队&lt;/code&gt;的问题。事实上，对于每条相连的链路，该分组交换机会有一个&lt;code&gt;输出缓存(output buffer)&lt;/code&gt; 和 &lt;code&gt;输出队列(output queue)&lt;/code&gt; 与之对应，它用于存储路由器准备发往每条链路的分组。如果到达的分组发现路由器正在接收其他分组，那么新到达的分组就会在输出队列中进行排队，这种等待分组转发所耗费的时间也被称为 &lt;code&gt;排队时延&lt;/code&gt;，上面提到分组交换器在转发分组时会进行等待，这种等待被称为 &lt;code&gt;存储转发时延&lt;/code&gt;，所以我们现在了解到的有两种时延，但是其实是有四种时延。这些时延不是一成不变的，其变化程序取决于网络的拥塞程度。&lt;/p&gt;
&lt;p&gt;因为队列是有容量限制的，当多条链路同时发送分组导致输出缓存无法接受超额的分组后，这些分组会丢失，这种情况被称为 &lt;code&gt;丢包(packet loss)&lt;/code&gt;，到达的分组或者已排队的分组将会被丢弃。&lt;/p&gt;
&lt;p&gt;下图说明了一个简单的分组交换网络&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP2wR.png&quot; alt=&quot;computer network1014&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在上图中，分组由三位数据平板展示，平板的宽度表示着分组数据的大小。所有的分组都有相同的宽度，因此也就有相同的数据包大小。&lt;strong&gt;下面来一个情景模拟：&lt;/strong&gt; 假定主机 A 和 主机 B 要向主机 E 发送分组，主机 A 和 B 首先通过100 Mbps以太网链路将其数据包发送到第一台路由器，然后路由器将这些数据包定向到15 Mbps 的链路。如果在较短的时间间隔内，数据包到达路由器的速率（转换为每秒比特数）超过15 Mbps，则在数据包在链路输出缓冲区中排队之前，路由器上会发生拥塞，然后再传输到链路上。例如，如果主机 A 和主机 B 背靠背同时发了5包数据，那么这些数据包中的大多数将花费一些时间在队列中等待。实际上，这种情况与许多普通情况完全相似，例如，当我们排队等候银行出纳员或在收费站前等候时。&lt;/p&gt;
&lt;h4 id=&quot;转发表和路由器选择协议&quot;&gt;转发表和路由器选择协议&lt;/h4&gt;
&lt;p&gt;我们刚刚讲过，路由器和多个通信线路进行相连，如果每条通信链路同时发送分组的话，可能会造成排队和丢包的情况，然后分组在队列中等待发送，现在我就有一个问题问你，队列中的分组发向哪里？这是由什么机制决定的？&lt;/p&gt;
&lt;p&gt;换个角度想问题，路由的作用是什么？&lt;strong&gt;把不同端系统中的数据包进行存储和转发&lt;/strong&gt; 。在因特网中，每个端系统都会有一个 &lt;code&gt;IP&lt;/code&gt; 地址，当原主机发送一个分组时，在分组的首部都会加上原主机的 IP 地址。每一台路由器都会有一个 &lt;code&gt;转发表(forwarding table)&lt;/code&gt;，当一个分组到达路由器后，路由器会检查分组的目的地址的一部分，并用目的地址搜索转发表，以找出适当的传送链路，然后映射成为输出链路进行转发。&lt;/p&gt;
&lt;p&gt;那么问题来了，路由器内部是怎样设置转发表的呢？详细的我们后面会讲到，这里只是说个大概，路由器内部也是具有&lt;code&gt;路由选择协议&lt;/code&gt;的，用于自动设置转发表。&lt;/p&gt;
&lt;h3 id=&quot;电路交换&quot;&gt;电路交换&lt;/h3&gt;
&lt;p&gt;在计算机网络中，另一种通过网络链路和路由进行数据传输的另外一种方式就是 &lt;code&gt;电路交换(circuit switching)&lt;/code&gt;。电路交换在&lt;code&gt;资源预留&lt;/code&gt;上与分组交换不同，什么意思呢？就是分组交换不会预留每次端系统之间交互分组的缓存和链路传输速率，所以每次都会进行排队传输；而电路交换会预留这些信息。一个简单的例子帮助你理解：这就好比有两家餐馆，餐馆 A 需要预定而餐馆 B 不需要预定，对于可以预定的餐馆 A，我们必须先提前与其进行联系，但是当我们到达目的地时，我们能够立刻入座并选菜。而对于不需要预定的那家餐馆来说，你可能不需要提前联系，但是你必须承受到达目的地后需要排队的风险。&lt;/p&gt;
&lt;p&gt;下面显示了一个电路交换网络&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPrSU.png&quot; alt=&quot;computer network1015&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在这个网络中，4条链路用于4台电路交换机。这些链路中的每一条都有4条电路，因此每条链路能支持4条并行的链接。每台主机都与一台交换机直接相连，当两台主机需要通信时，该网络在两台主机之间创建一条专用的 &lt;code&gt;端到端的链接(end-to-end connection)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;分组交换和电路交换的对比&quot;&gt;分组交换和电路交换的对比&lt;/h3&gt;
&lt;p&gt;分组交换的支持者经常说分组交换不适合实时服务，因为它的端到端时延时不可预测的。而分组交换的支持者却认为分组交换提供了比电路交换更好的带宽共享；它比电路交换更加简单、更有效，实现成本更低。但是现在的趋势更多的是朝着分组交换的方向发展。&lt;/p&gt;
&lt;h3 id=&quot;分组交换网的时延、丢包和吞吐量&quot;&gt;分组交换网的时延、丢包和吞吐量&lt;/h3&gt;
&lt;p&gt;因特网可以看成是一种基础设施，该基础设施为运行在端系统上的分布式应用提供服务。我们希望在计算机网络中任意两个端系统之间传递数据都不会造成数据丢失，然而这是一个极高的目标，实践中难以达到。所以，在实践中必须要限制端系统之间的 &lt;code&gt;吞吐量&lt;/code&gt; 用来控制数据丢失。如果在端系统之间引入时延，也不能保证不会丢失分组问题。所以我们从时延、丢包和吞吐量三个层面来看一下计算机网络&lt;/p&gt;
&lt;h4 id=&quot;分组交换中的时延&quot;&gt;分组交换中的时延&lt;/h4&gt;
&lt;p&gt;计算机网络中的分组从一台主机（源）出发，经过一系列路由器传输，在另一个端系统中结束它的历程。在这整个传输历程中，分组会涉及到四种最主要的时延：&lt;strong&gt;节点处理时延(nodal processing delay)、排队时延(queuing delay)、传输时延(total nodal delay)和传播时延(propagation delay)&lt;/strong&gt;。这四种时延加起来就是 &lt;code&gt;节点总时延(total nodal delay)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果用 dproc dqueue dtrans dpop 分别表示处理时延、排队时延、传输时延和传播时延，则节点的总时延由以下公式决定: dnodal = dproc + dqueue + dtrans + dpop。&lt;/p&gt;
&lt;h4 id=&quot;时延的类型&quot;&gt;时延的类型&lt;/h4&gt;
&lt;p&gt;下面是一副典型的时延分布图，让我们从图中进行分析一下不同的时延类型&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPslF.png&quot; alt=&quot;computer network1016&quot; border=&quot;0&quot;/&gt;&lt;p&gt;分组由端系统经过通信链路传输到路由器 A，路由器A 检查分组头部以映射出适当的传输链路，并将分组送入该链路。仅当该链路没有其他分组正在传输并且没有其他分组排在该该分组前面时，才能在这条链路上自由的传输该分组。如果该链路当前繁忙或者已经有其他分组排在该分组前面时，新到达的分组将会加入排队。下面我们分开讨论一下这四种时延&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点处理时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;节点处理时延&lt;/code&gt;分为两部分，第一部分是路由器会检查分组的首部信息；第二部分是决定将分组传输到哪条通信链路所需要的时间。一般高速网络的节点处理时延都在微妙级和更低的数量级。在这种处理时延完成后，分组会发往路由器的转发队列中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排队时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在队列排队转发过程中，分组需要在队列中等待发送，分组在等待发送过程中消耗的时间被称为&lt;code&gt;排队时延&lt;/code&gt;。排队时延的长短取决于先于该分组到达正在队列中排队的分组数量。如果该队列是空的，并且当前没有正在传输的分组，那么该分组的排队时延就是 0。如果处于网络高发时段，那么链路中传输的分组比较多，那么分组的排队时延将延长。实际的排队时延也可以到达微秒级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;队列&lt;/code&gt; 是路由器所用的主要的数据结构。队列的特征就是先进先出，先到达食堂的先打饭。传输时延是理论情况下单位时间内的传输比特所消耗的时间。比如分组的长度是 L 比特，R 表示从路由器 A 到路由器 B 的传输速率。那么传输时延就是 L / R 。这是将所有分组推向该链路所需要的时间。正是情况下传输时延通常也在毫秒到微妙级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传播时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从链路的起点到路由器 B 传播所需要的时间就是 &lt;code&gt;传播时延&lt;/code&gt;。该比特以该链路的传播速率传播。该传播速率取决于链路的物理介质(双绞线、同轴电缆、光纤)。如果用公式来计算一下的话，该传播时延等于两台路由器之间的距离 / 传播速率。即传播速率是 &lt;code&gt;d/s&lt;/code&gt; ，其中 d 是路由器 A 和 路由器 B 之间的距离，s 是该链路的传播速率。&lt;/p&gt;
&lt;h4 id=&quot;传输时延和传播时延的比较&quot;&gt;传输时延和传播时延的比较&lt;/h4&gt;
&lt;p&gt;计算机网络中的传输时延和传播时延有时候难以区分，在这里解释一下，&lt;code&gt;传输时延&lt;/code&gt;是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。而&lt;code&gt;传播时延&lt;/code&gt;是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的倒数，而与分组长度和链路传输速率无关。从公式也可以看出来，传输时延是 &lt;code&gt;L/R&lt;/code&gt;，也就是分组的长度 / 路由器之间传输速率。传播时延的公式是 &lt;code&gt;d/s&lt;/code&gt;，也就是路由器之间的距离 / 传播速率。&lt;/p&gt;
&lt;h4 id=&quot;排队时延&quot;&gt;排队时延&lt;/h4&gt;
&lt;p&gt;在这四种时延中，人们最感兴趣的时延或许就是排队时延了 dqueue。与其他三种时延（dproc、dtrans、dpop）不同的是，排队时延对不同的分组可能是不同的。例如，如果10个分组同时到达某个队列，第一个到达队列的分组没有排队时延，而最后到达的分组却要经受最大的排队时延（需要等待其他九个时延被传输）。&lt;/p&gt;
&lt;p&gt;那么如何描述排队时延呢？或许可以从三个方面来考虑：&lt;strong&gt;流量到达队列的速率、链路的传输速率和到达流量的性质&lt;/strong&gt;。即流量是周期性到达还是突发性到达，如果用 a 表示分组到达队列的平均速率（ a 的单位是分组/秒，即 pkt/s）前面说过 R 表示的是传输速率，所以能够从队列中推出比特的速率（以 bps 即 b/s 位单位）。假设所有的分组都是由 L 比特组成的，那么比特到达队列的平均速率是 La bps。那么比率 &lt;code&gt;La/R&lt;/code&gt; 被称为&lt;code&gt;流量强度(traffic intensity)&lt;/code&gt;，如果 La/R &amp;gt; 1，则比特到达队列的平均速率超过从队列传输出去的速率，这种情况下队列趋向于无限增加。所以，&lt;strong&gt;设计系统时流量强度不能大于1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在考虑 La / R &amp;lt;= 1 时的情况。流量到达的性质将影响排队时延。如果流量是&lt;code&gt;周期性&lt;/code&gt;到达的，即每 L / R 秒到达一个分组，则每个分组将到达一个空队列中，不会有排队时延。如果流量是 &lt;code&gt;突发性&lt;/code&gt; 到达的，则可能会有很大的平均排队时延。一般可以用下面这幅图表示平均排队时延与流量强度的关系&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP0YV.png&quot; alt=&quot;computer network1017&quot; border=&quot;0&quot;/&gt;&lt;p&gt;横轴是 La/R 流量强度，纵轴是平均排队时延。&lt;/p&gt;
&lt;h4 id=&quot;丢包&quot;&gt;丢包&lt;/h4&gt;
&lt;p&gt;我们在上述的讨论过程中描绘了一个公式那就是 La/R 不能大于1，如果 La/R 大于1，那么到达的排队将会无穷大，而且路由器中的排队队列所容纳的分组是有限的，所以等到路由器队列堆满后，新到达的分组就无法被容纳，导致路由器 &lt;code&gt;丢弃(drop)&lt;/code&gt; 该分组，即分组会 &lt;code&gt;丢失(lost)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;计算机网络中的吞吐量&quot;&gt;计算机网络中的吞吐量&lt;/h4&gt;
&lt;p&gt;除了丢包和时延外，衡量计算机另一个至关重要的性能测度是&lt;code&gt;端到端的吞吐量&lt;/code&gt;。假如从主机 A 向主机 B 传送一个大文件，那么在任何时刻主机 B 接收到该文件的速率就是 &lt;code&gt;瞬时吞吐量(instantaneous throughput)&lt;/code&gt;。如果该文件由 F 比特组成，主机 B 接收到所有 F 比特用去 T 秒，则文件的传送&lt;code&gt;平均吞吐量(average throughput)&lt;/code&gt; 是 F / T bps。&lt;/p&gt;
&lt;h3 id=&quot;单播、广播、多播和任播&quot;&gt;单播、广播、多播和任播&lt;/h3&gt;
&lt;p&gt;在网络通信中，可以根据目标地址的数量对通信进行分类，可以分为 &lt;strong&gt;单播、广播、多播和任播&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;单播unicast&quot;&gt;单播(Unicast)&lt;/h4&gt;
&lt;p&gt;单播最大的特点就是 1 对 1，早期的固定电话就是单播的一个例子，单播示意图如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPaoq.png&quot; alt=&quot;computer network1018&quot; border=&quot;0&quot;/&gt;&lt;h3 id=&quot;广播broadcast&quot;&gt;广播(Broadcast)&lt;/h3&gt;
&lt;p&gt;我们一般小时候经常会跳&lt;code&gt;广播体操&lt;/code&gt;，这就是广播的一个事例，主机和与他连接的所有端系统相连，主机将信号发送给所有的端系统。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPUwn.png&quot; alt=&quot;computer network1019&quot; border=&quot;0&quot;/&gt;&lt;h4 id=&quot;多播multicast&quot;&gt;多播(Multicast)&lt;/h4&gt;
&lt;p&gt;多播与广播很类似，也是将消息发送给多个接收主机，不同之处在于多播需要限定在某一组主机作为接收端。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPJyQ.png&quot; alt=&quot;computer network1020&quot; border=&quot;0&quot;/&gt;&lt;h4 id=&quot;任播anycast&quot;&gt;任播(Anycast)&lt;/h4&gt;
&lt;p&gt;任播是在特定的多台主机中选出一个接收端的通信方式。虽然和多播很相似，但是行为与多播不同，任播是从许多目标机群中选出一台最符合网络条件的主机作为目标主机发送消息。然后被选中的特定主机将返回一个单播信号，然后再与目标主机进行通信。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPlJf.png&quot; alt=&quot;computer network1021&quot; border=&quot;0&quot;/&gt;&lt;h2 id=&quot;物理媒介&quot;&gt;物理媒介&lt;/h2&gt;
&lt;p&gt;网络的传输是需要介质的。一个比特数据包从一个端系统开始传输，经过一系列的链路和路由器，从而到达另外一个端系统。这个比特会被转发了很多次，那么这个比特经过传输的过程所跨越的媒介就被称为&lt;code&gt;物理媒介(phhysical medium)&lt;/code&gt;，物理媒介有很多种，比如&lt;strong&gt;双绞铜线、同轴电缆、多模光纤榄、陆地无线电频谱和卫星无线电频谱&lt;/strong&gt;。其实大致分为两种：引导性媒介和非引导性媒介。&lt;/p&gt;
&lt;h3 id=&quot;双绞铜线&quot;&gt;双绞铜线&lt;/h3&gt;
&lt;p&gt;最便宜且最常用的引导性传输媒介就是&lt;code&gt;双绞铜线&lt;/code&gt;，多年以来，它一直应用于电话网。从电话机到本地电话交换机的连线超过 99% 都是使用的双绞铜线，例如下面就是双绞铜线的实物图&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPYLj.png&quot; alt=&quot;computer network1022&quot; border=&quot;0&quot;/&gt;&lt;p&gt;双绞铜线由两根绝缘的铜线组成，每根大约 1cm 粗，以规则的螺旋形状排列，通常许多双绞线捆扎在一起形成电缆，并在双绞馅的外面套上保护层。一对电缆构成了一个通信链路。&lt;code&gt;无屏蔽双绞线&lt;/code&gt;一般常用在局域网（LAN）中。&lt;/p&gt;
&lt;h3 id=&quot;同轴电缆&quot;&gt;同轴电缆&lt;/h3&gt;
&lt;p&gt;与双绞线类似，同轴电缆也是由两个铜导体组成，下面是实物图&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zP8SS.png&quot; alt=&quot;computer network1023&quot; border=&quot;0&quot;/&gt;&lt;p&gt;借助于这种结构以及特殊的绝缘体和保护层，同轴电缆能够达到较高的传输速率，同轴电缆普遍应用在在电缆电视系统中。同轴电缆常被用户引导型共享媒介。&lt;/p&gt;
&lt;h3 id=&quot;光纤&quot;&gt;光纤&lt;/h3&gt;
&lt;p&gt;光纤是一种细而柔软的、能够引导光脉冲的媒介，每个脉冲表示一个比特。一根光纤能够支持极高的比特率，高达数十甚至数百 Gbps。它们不受电磁干扰。光纤是一种引导型物理媒介，下面是光纤的实物图&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/19/0zPwF0.png&quot; alt=&quot;computer network1024&quot; border=&quot;0&quot;/&gt;&lt;p&gt;一般长途电话网络全面使用光纤，光纤也广泛应用于因特网的主干。&lt;/p&gt;
&lt;h3 id=&quot;陆地无线电信道&quot;&gt;陆地无线电信道&lt;/h3&gt;
&lt;p&gt;无线电信道承载电磁频谱中的信号。它不需要安装物理线路，并具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力。&lt;/p&gt;
&lt;h3 id=&quot;卫星无线电信道&quot;&gt;卫星无线电信道&lt;/h3&gt;
&lt;p&gt;一颗卫星电信道连接地球上的两个或多个微博发射器/接收器，它们称为地面站。通信中经常使用两类卫星：同步卫星和近地卫星。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;这是计算机网络的第一篇文章，也是属于基础前置知识，后面会陆续更新计算机网络的内容。&lt;/p&gt;
&lt;p&gt;如果文章还不错，希望小伙伴们可以点赞、在看、留言、分享，这就是最好的白嫖 。&lt;/p&gt;
&lt;p&gt;另外，我输出了 六本 PDF，全集 PDF 如下。&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1mYAeS9hIhdMFh2rF3FDk0A&quot;&gt;https://pan.baidu.com/s/1mYAeS9hIhdMFh2rF3FDk0A&lt;/a&gt; 密码: p9rs&lt;/p&gt;
</description>
<pubDate>Mon, 19 Oct 2020 23:00:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star https://github.com/crisxuan/bestJavaer 如果说计算机把我们从工业时代带到了信息时代，那么计算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13844269.html</dc:identifier>
</item>
<item>
<title>Java9系列第7篇：Java.util.Optional优化与增强 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13844268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13844268.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201020065916157-395982535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右，本文是第7篇。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.Optional&lt;/code&gt;是在Java 8版本中新增的类，一定程度上可以改善编程过程中的NullPointException的问题。在Java 9中对这个类新增了一些方法进行增强，下面我们一起来看一下，顺便也回顾一下在Java 8中它的用法。&lt;/p&gt;
&lt;h2 id=&quot;一、java9的ifpresentorelseconsumer，runnable&quot;&gt;一、Java9的ifPresentOrElse(Consumer，Runnable)&lt;/h2&gt;
&lt;h3 id=&quot;11java-9-中的增强&quot;&gt;1.1.Java 9 中的增强&lt;/h3&gt;
&lt;p&gt;如果存在值，则此新方法将执行给定的Consumer操作，否则运行给定的Runnable操作。下面的代码先使用Java 8的的Stream流过滤3的倍数，然后通过findFirst找到第一个3的倍数。如果找到一个这样的值，就print控制台打印出来；如果没找到一个这样的值，就输出&quot;没有找到3的倍数&quot;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ifPresentOrElse(Consumer，Runnable)的语义可以解释为：ifPresent就Consumer，OrElse就Runnable。这是Java 9 才有的增强方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; IntStream.of(1, 2, 4)
          .filter(i -&amp;gt; i % 3 == 0)
          .findFirst()
          .ifPresentOrElse(System.out::println, () -&amp;gt; {  
              System.out.println(&quot;没有找到3的倍数&quot;);
          });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在1、2、4中没有3的倍数，所以输出结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;没有找到3的倍数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是下面的2、6、8数组被过滤，最终控制台输出结果为：6&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; IntStream.of(2, 6, 8)
          .filter(i -&amp;gt; i % 3 == 0)
          .findFirst()
          .ifPresentOrElse(System.out::println, () -&amp;gt; {
              System.out.println(&quot;没有找到3的倍数&quot;);
          });   // 6
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12回顾一下java-8中的写法&quot;&gt;1.2.回顾一下Java 8中的写法&lt;/h3&gt;
&lt;h4 id=&quot;java-8-optionalispresent&quot;&gt;Java 8 Optional.isPresent():&lt;/h4&gt;
&lt;p&gt;如果使用Java 8 ，没有&lt;code&gt;ifPresentOrElse(Consumer，Runnable)&lt;/code&gt;方法，上文中同样的代码你应该是这样写的：自己去写if和else进行判断。同样输出：没有找到3的倍数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; OptionalInt opt = IntStream.of(1, 2, 4)
                            .filter(i -&amp;gt; i % 3 == 0)
                            .findFirst();
 if (opt.isPresent()) {
     System.out.println(opt.getAsInt());
 } else {
     System.out.println(&quot;没有找到3的倍数&quot;);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;java-8-optionalifpresent&quot;&gt;Java 8 Optional.ifPresent():&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ifPresent()&lt;/code&gt;方法在值不存在的时候，没有提供一个可选的操作。所以下面的代码在执行之后，没有orElse动作，没有任何输出，这样不是很友好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; IntStream.of(1, 2, 4)
          .filter(i -&amp;gt; i % 3 == 0)
          .findFirst()
          .ifPresent(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;java-8-optionalorelse&quot;&gt;Java 8 Optional.orElse():&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;orElse()&lt;/code&gt;方法在value返回值为空的之后，给出一个默认值。下文代码中给出一个默认值-1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; int result = IntStream.of(1, 2, 4)
                       .filter(i -&amp;gt; i % 3 == 0)
                       .findFirst()
                       .orElse(-1);
 System.out.println(result);   //-1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、java9的optionalorsupplier&quot;&gt;二、Java9的Optional.or(Supplier)&lt;/h2&gt;
&lt;p&gt;该方法在找不到值的时候，生成一个新的Optional出来。下文代码过滤数组['a', 'b', 'c'],isDigit判断数组中是否有数字字符，明显没有，所以findFirst找不到一个这样的值。所以生成一个默认值： &lt;code&gt;Optional.of('0')&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; char digit = Stream.of('a', 'b', 'c')
                    .filter(e -&amp;gt; Character.isDigit(e))
                    .findFirst()
                    .or(() -&amp;gt; Optional.of('0')).get();
 System.out.println(digit);   //0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;java8-中的-orelseget&quot;&gt;Java8 中的 orElseGet()&lt;/h4&gt;
&lt;p&gt;Java 8中的&lt;code&gt;Optional.orElseGet()&lt;/code&gt;方法也具备同样的功能。下文代码过滤数组['a', 'b', 'c'],isDigit判断数组中是否有数字字符，明显没有，所以findFirst找不到一个这样的值。所以通过orElseGet获取一个默认值： &lt;code&gt;'0'&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; char result = Stream.of('a', 'b', 'c')
                    .filter(c -&amp;gt; Character.isDigit(c))
                    .findFirst()
                    .orElseGet(()-&amp;gt;'0');
 System.out.println(result);   //0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、java9的optionalstream&quot;&gt;三、Java9的Optional.stream()&lt;/h2&gt;
&lt;p&gt;在本例中&lt;code&gt;Optional.stream()&lt;/code&gt;方法返回仅包含一个最大值元素的Stream流。如果该值不存在，则返回空Stream：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; OptionalInt opt1 = IntStream.of(2, 5, 6).max();  //求最大值
 OptionalInt opt2 = IntStream.of(1, 3, 7).max();  //求最大值
 IntStream.concat(opt1.stream(), opt2.stream())  //将2个流合并
          .forEach(System.out::println);   //将合并后的流数据打印
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 6
 7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Oct 2020 22:59:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13844268.html</dc:identifier>
</item>
<item>
<title>如何写一段死锁代码 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/how-to-implement-deadlock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/how-to-implement-deadlock.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;上次介绍了如何写一段代码造成 &lt;code&gt;StackOverflow&lt;/code&gt; ，今天来玩一下，看如何写一段代码造成死锁&lt;/p&gt;
&lt;h2 id=&quot;什么是死锁&quot;&gt;什么是死锁&lt;/h2&gt;
&lt;p&gt;首先我们需要明确一下什么是死锁，造成死锁需要满足哪些条件，知道这些就可以轻松写出一段死锁代码了&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;死锁&lt;/em&gt; 是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于&lt;em&gt;死锁&lt;/em&gt; 状态或系统产生了&lt;em&gt;死锁&lt;/em&gt;，这些永远在互相等待的进程称为&lt;em&gt;死锁&lt;/em&gt; 进程（线程）。 ---- 百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;产生死锁的必要条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。&lt;/li&gt;
&lt;li&gt;请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。&lt;/li&gt;
&lt;li&gt;环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;预防死锁方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）&lt;/li&gt;
&lt;li&gt;只要有一个资源得不到分配，也不给这个进程（线程）分配其他的资源：（破坏请保持条件）&lt;/li&gt;
&lt;li&gt;可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）&lt;/li&gt;
&lt;li&gt;资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;net-中的死锁&quot;&gt;.NET 中的死锁&lt;/h2&gt;
&lt;p&gt;通常的死锁的示例都是两个锁，多个资源导致的死锁，你有没有想过一个资源也会导致死锁，如何使用一个锁造成死锁呢？思考一下再看下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private static readonly object Lock = new object();

public static void Test()
{
    lock (Lock)
    {
        Task.Run(TestMethod1).Wait();
    }
}

private static void TestMethod1()
{
    lock (Lock)
    {
        Console.WriteLine(&quot;xxx&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 &lt;code&gt;Test&lt;/code&gt; 这个方法中首先获取锁，获取锁成功之后调用另外一个线程去调用 &lt;code&gt;TestMethod1&lt;/code&gt; 方法，而 &lt;code&gt;TestMethod1&lt;/code&gt; 方法中会再次尝试获取锁，此时因为锁已经被 &lt;code&gt;Test&lt;/code&gt; 方法获取而且并没有释放，所以会一直获取不到锁从而造成死锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这种情况还有很多变形，比如说 &lt;code&gt;lock(this)&lt;/code&gt;/&lt;code&gt;lock(&quot;lockedString&quot;)&lt;/code&gt; 这种都是比较危险的，所以不推荐使用，我们使用上面的示例做一个变形，使用 &lt;code&gt;lock(&quot;lockedString&quot;)&lt;/code&gt; 来测试一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static void Test()
{
    lock (&quot;Lock&quot;)
    {
        Task.Run(TestMethod1).Wait();
    }
}

private static void TestMethod1()
{
    lock (&quot;Lock&quot;)
    {
        Console.WriteLine(&quot;xxx&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样也会造成死锁，因为 lock 的 string 实际上是同一个引用，字符串池（string intern），所以类似于上面的示例，相当于是一个锁，对于 &lt;code&gt;lock(this)&lt;/code&gt; 也是类似的，所以通常 &lt;code&gt;lock&lt;/code&gt; 是不推荐 &lt;code&gt;lock(this)&lt;/code&gt;/&lt;code&gt;lock(&quot;string&quot;)&lt;/code&gt; 这些写法的，对于不同的资源要使用不同的 &lt;code&gt;lock&lt;/code&gt;，这样就可以避免上面这个示例的这种情况&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;使用锁的一些注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;锁要用来锁定对应的访问资源，不同的资源使用不同的锁来访问限制&lt;/li&gt;
&lt;li&gt;锁尽可能使用这样的格式 &lt;code&gt;private readonly object _locker = new object();&lt;/code&gt;，是否使用 &lt;code&gt;static&lt;/code&gt; 根据需要添加，多个资源有关联时，小心死锁的情况，一次全部分配，任意一个资源分配失败释放另外一个锁以避免死锁&lt;/li&gt;
&lt;li&gt;实现分布式锁的时候指定最大尝试时间，避免死锁避免长时间获取不到锁影响系统性能&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 SQL Server 中会有一个独立的死锁检测的进程，如果发生死锁的情况，会有一个事务会被选择为牺牲品来解决死锁的问题&lt;/p&gt;
&lt;p&gt;在通过 &lt;code&gt;Redis&lt;/code&gt; 实现分布式锁的时候，通常会指定一个锁的过期时间，过期时间通常是为了避免获取锁成功的系统突然宕机导致锁一直在锁定状态，从而导致其他服务获取锁的时候一直获取失败，除此之外，通常还会指定一个最大等待时间，如果别的服务获取到锁了，正在操作，那么会等待锁释放，但是为了避免死锁，如果长时间获取不到锁的话就会放弃获取锁，直接返回获取锁失败。&lt;/p&gt;
&lt;p&gt;除此之外你还了解哪些使用锁的注意事项和避免死锁的常用方法呢，欢迎补充，如果文中有误，欢迎指出，万分感谢。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 19 Oct 2020 16:14:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>怎样实现死锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/how-to-implement-deadlock.html</dc:identifier>
</item>
<item>
<title>Kubernetes K8S之存储Volume详解 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13844062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13844062.html</guid>
<description>
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;K8S之存储Volume概述与说明，并详解常用Volume示例&lt;/p&gt;
&lt;/blockquote&gt;


&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务器名称(hostname)&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;内网IP&lt;/th&gt;
&lt;th&gt;外网IP(模拟)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;k8s-master&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.110&lt;/td&gt;
&lt;td&gt;10.0.0.110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node01&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.111&lt;/td&gt;
&lt;td&gt;10.0.0.111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node02&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.112&lt;/td&gt;
&lt;td&gt;10.0.0.112&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;在容器中的文件在磁盘上是临时存放的，当容器关闭时这些临时文件也会被一并清除。这给容器中运行的特殊应用程序带来一些问题。&lt;/p&gt;
&lt;p&gt;首先，当容器崩溃时，kubelet 将重新启动容器，容器中的文件将会丢失——因为容器会以干净的状态重建。&lt;/p&gt;
&lt;p&gt;其次，当在一个 Pod 中同时运行多个容器时，常常需要在这些容器之间共享文件。&lt;/p&gt;
&lt;p&gt;Kubernetes 抽象出 Volume 对象来解决这两个问题。&lt;/p&gt;
&lt;p&gt;Kubernetes Volume卷具有明确的生命周期——与包裹它的 Pod 相同。 因此，Volume比 Pod 中运行的任何容器的存活期都长，在&lt;span&gt;容器重新启动时数据也会得到保留&lt;/span&gt;。 当然，当一个 Pod 不再存在时，Volume也将不再存在。更重要的是，&lt;span&gt;Kubernetes 可以支持许多类型的Volume卷，Pod 也能同时使用任意数量的Volume卷&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;使用卷时，Pod 声明中需要提供卷的类型 (.spec.volumes 字段)和卷挂载的位置 (.spec.containers.volumeMounts 字段).&lt;/p&gt;


&lt;p&gt;Kubernetes 支持下列类型的卷：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;awsElasticBlockStore
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;azureDisk
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;azureFile
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;cephfs
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;cinder
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;configMap
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;csi
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;downwardAPI
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;emptyDir
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;fc (fibre channel)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;flexVolume
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;flocker
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;gcePersistentDisk
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;gitRepo (deprecated)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;glusterfs
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;hostPath
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;iscsi
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;local
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;nfs
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;persistentVolumeClaim
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;projected
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;portworxVolume
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;quobyte
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;rbd
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;scaleIO
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;secret
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;storageos
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; vsphereVolume
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们只介绍常用的存储，包括：Secret、ConfigMap、emptyDir、hostPath。&lt;/p&gt;
&lt;p&gt;其中Secret参考文章：「&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13743024.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之存储Secret详解&lt;/a&gt;」&lt;/p&gt;
&lt;p&gt;ConfigMap参考文章：「&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13818190.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之存储ConfigMap详解&lt;/a&gt;」&lt;/p&gt;
&lt;p&gt;本文只说emptyDir和hostPath存储。&lt;/p&gt;


&lt;p&gt;当 Pod 指定到某个节点上时，首先创建的是一个 emptyDir 卷，并且只要 Pod 在该节点上运行，卷就一直存在。就像它的名称表示的那样，卷最初是空的。&lt;/p&gt;
&lt;p&gt;尽管 Pod 中每个容器挂载 emptyDir 卷的&lt;span&gt;路径可能相同也可能不同&lt;/span&gt;，但是这些容器都可以读写 emptyDir 卷中相同的文件。&lt;/p&gt;
&lt;p&gt;如果Pod中有多个容器，其中某个容器重启，不会影响emptyDir 卷中的数据。&lt;span&gt;当 Pod 因为某些原因被删除时，emptyDir 卷中的数据也会永久删除&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃时 emptyDir 卷中的数据是安全的。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;emptyDir的一些用途：&quot;&gt;emptyDir的一些用途：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;缓存空间，例如基于磁盘的归并排序&lt;/li&gt;
&lt;li&gt;为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行&lt;/li&gt;
&lt;li&gt;在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;emptyDir示例&quot;&gt;emptyDir示例&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master emptydir]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;emptydir
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master emptydir]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_emptydir.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Pod
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: pod-&lt;span&gt;emptydir
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  containers:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   - name: myapp-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    volumeMounts:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     - mountPath: /&lt;span&gt;cache
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       name: cache-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   - name: busybox-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/busybox:&lt;span&gt;1.24&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     command: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sleep 3600&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    volumeMounts:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     - mountPath: /test/&lt;span&gt;cache
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       name: cache-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  volumes:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;   - name: cache-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     emptyDir: {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动pod，并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master emptydir]# kubectl apply -&lt;span&gt;f pod_emptydir.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; pod/pod-&lt;span&gt;emptydir created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master emptydir]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master emptydir]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; pod-emptydir   &lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          10s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.166&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master emptydir]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master emptydir]# kubectl describe pod pod-&lt;span&gt;emptydir
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Name:         pod-&lt;span&gt;emptydir
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Priority:     &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; Node:         k8s-node02/&lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.112&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; Start Time:   Fri, &lt;span&gt;12&lt;/span&gt; Jun &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;15&lt;/span&gt; Annotations:  kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pod-emptydir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;containers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;Status:       Running
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; IP:           &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.166&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;IPs:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   IP:  &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.166&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Containers:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;   myapp-&lt;span&gt;pod:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     Container ID:   docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;d45663776b40a24e7cfc3cf46cb08cf3ed6b98b023a5d2cb5f42bee2234c7338&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     Image:          registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     Image ID:       docker-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.0.110:5000/k8s-secret/myapp@sha256:9eeca44ba2d410e54fccc54cbe9c021802aa8b9836a0bcf3d3229354e4c8870e&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     Port:           &amp;lt;none&amp;gt;
&lt;span&gt;27&lt;/span&gt;     Host Port:      &amp;lt;none&amp;gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    State:          Running
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;       Started:      Fri, &lt;span&gt;12&lt;/span&gt; Jun &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    Ready:          True
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     Restart Count:  &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Environment:    &amp;lt;none&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    Mounts:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       /cache from cache-&lt;span&gt;volume (rw)  ##### 挂载信息
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       /var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;v48g4 (ro)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   busybox-&lt;span&gt;pod:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     Container ID:  docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c2917ba30c3322fb0caead5d97476b341e691f9fb1990091264364b8cd340512&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     Image:         registry.cn-beijing.aliyuncs.com/google_registry/busybox:&lt;span&gt;1.24&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     Image ID:      docker-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;registry.cn-beijing.aliyuncs.com/ducafe/busybox@sha256:f73ae051fae52945d92ee20d62c315306c593c59a429ccbbdcba4a488ee12269&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     Port:          &amp;lt;none&amp;gt;
&lt;span&gt;41&lt;/span&gt;     Host Port:     &amp;lt;none&amp;gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    Command:
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;       /bin/&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;       -&lt;span&gt;c
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;       &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;3600&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    State:          Running
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;       Started:      Fri, &lt;span&gt;12&lt;/span&gt; Jun &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    Ready:          True
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     Restart Count:  &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     Environment:    &amp;lt;none&amp;gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    Mounts:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;       /test/cache from cache-&lt;span&gt;volume (rw)  ##### 挂载信息
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;       /var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;v48g4 (ro)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;Conditions:
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;  Type              Status
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;  Initialized       True 
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;  Ready             True 
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;  ContainersReady   True 
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;  PodScheduled      True 
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;Volumes:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;   cache-&lt;span&gt;volume:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     Type:       EmptyDir (a temporary directory that shares a pod&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s lifetime)&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    Medium:     
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     SizeLimit:  &amp;lt;unset&amp;gt;
&lt;span&gt;65&lt;/span&gt;   default-token-&lt;span&gt;v48g4:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    Type:        Secret (a volume populated by a Secret)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     SecretName:  default-token-&lt;span&gt;v48g4
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     Optional:    &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;QoS Class:       BestEffort
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; Node-Selectors:  &amp;lt;none&amp;gt;
&lt;span&gt;71&lt;/span&gt; Tolerations:     node.kubernetes.io/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                  node.kubernetes.io/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;Events:
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;  Type    Reason     Age   From                 Message
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;   ----    ------     ----  ----                 -------
&lt;span&gt;76&lt;/span&gt;   Normal  Scheduled  3s    default-scheduler    Successfully assigned default/pod-emptydir to k8s-&lt;span&gt;node02
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;   Normal  Pulled     2s    kubelet, k8s-node02  Container image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; already present on machine
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;   Normal  Created    2s    kubelet, k8s-node02  Created container myapp-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;   Normal  Started    2s    kubelet, k8s-node02  Started container myapp-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;   Normal  Pulled     2s    kubelet, k8s-node02  Container image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry.cn-beijing.aliyuncs.com/google_registry/busybox:1.24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; already present on machine
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;   Normal  Created    2s    kubelet, k8s-node02  Created container busybox-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;   Normal  Started    2s    kubelet, k8s-node02  Started container busybox-pod
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;emptyDir验证&quot;&gt;emptyDir验证&lt;/h2&gt;
&lt;p&gt;在pod中的myapp-pod容器内操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master emptydir]# kubectl exec -it pod-emptydir -c myapp-pod -- &lt;span&gt;sh&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; / # cd /&lt;span&gt;cache
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; /&lt;span&gt;cache # 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; /cache # &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; /&lt;span&gt;cache
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; /&lt;span&gt;cache # 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; /cache # &lt;span&gt;date&lt;/span&gt; &amp;gt;&amp;gt; data.&lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; /cache # &lt;span&gt;ls&lt;/span&gt; -&lt;span&gt;l
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; total &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; -rw-r--r--    &lt;span&gt;1&lt;/span&gt; root     root            &lt;span&gt;29&lt;/span&gt; Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; data.&lt;span&gt;info&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; /cache # &lt;span&gt;cat&lt;/span&gt; data.&lt;span&gt;info&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; Fri Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt; UTC &lt;span&gt;2020&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在pod中的busybox-pod容器内操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master emptydir]# kubectl exec -it pod-emptydir -c busybox-pod -- &lt;span&gt;sh&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; / # cd /test/&lt;span&gt;cache
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; /test/cache # &lt;span&gt;ls&lt;/span&gt; -&lt;span&gt;l
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; total &lt;span&gt;4&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; -rw-r--r--    &lt;span&gt;1&lt;/span&gt; root     root            &lt;span&gt;29&lt;/span&gt; Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; data.&lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; /test/cache # &lt;span&gt;cat&lt;/span&gt; data.&lt;span&gt;info&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; Fri Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt; UTC &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; /test/&lt;span&gt;cache # 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; /test/cache # &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; data.&lt;span&gt;info&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; /test/cache # &lt;span&gt;date&lt;/span&gt; &amp;gt;&amp;gt; data.&lt;span&gt;info&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; /test/cache # &lt;span&gt;cat&lt;/span&gt; data.&lt;span&gt;info&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; Fri Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt; UTC &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; ===
&lt;span&gt;14&lt;/span&gt; Fri Jun &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; UTC &lt;span&gt;2020&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由上可见，一个Pod中多个容器可共享同一个emptyDir卷。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;hostPath 卷能将主机node节点文件系统上的文件或目录挂载到你的 Pod 中。 虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。&lt;/p&gt;

&lt;h2 id=&quot;hostPath-的一些用法有&quot;&gt;hostPath 的一些用法有&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;运行一个需要访问 Docker 引擎内部机制的容器；请使用 hostPath 挂载 /var/lib/docker 路径。&lt;/li&gt;
&lt;li&gt;在容器中运行 cAdvisor 时，以 hostPath 方式挂载 /sys。&lt;/li&gt;
&lt;li&gt;允许 Pod 指定给定的 hostPath 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;支持类型&quot;&gt;支持类型&lt;/h2&gt;
&lt;p&gt;除了必需的 path 属性之外，用户可以选择性地为 hostPath 卷指定 type。支持的 type 值如下：&lt;/p&gt;
&lt;div class=&quot;table-box&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;取值&lt;/th&gt;
&lt;th&gt;行为&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DirectoryOrCreate&lt;/td&gt;
&lt;td&gt;如果指定的路径不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 Kubelet 相同的组和所有权&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Directory&lt;/td&gt;
&lt;td&gt;给定的路径必须存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;FileOrCreate&lt;/td&gt;
&lt;td&gt;如果给定路径的文件不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 Kubelet 相同的组和所有权【前提：文件所在目录必须存在；目录不存在则不能创建文件】&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;File&lt;/td&gt;
&lt;td&gt;给定路径上的文件必须存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Socket&lt;/td&gt;
&lt;td&gt;在给定路径上必须存在的 UNIX 套接字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CharDevice&lt;/td&gt;
&lt;td&gt;在给定路径上必须存在的字符设备&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BlockDevice&lt;/td&gt;
&lt;td&gt;在给定路径上必须存在的块设备&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;当使用这种类型的卷时要小心，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有相同配置（例如从 podTemplate 创建）的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。&lt;/li&gt;
&lt;li&gt;当 Kubernetes 按照计划添加资源感知的调度时，这类调度机制将无法考虑由 hostPath 卷使用的资源。&lt;/li&gt;
&lt;li&gt;基础主机上创建的文件或目录只能由 root 用户写入。需要在 特权容器 中以 root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 hostPath 卷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hostPath示例&quot;&gt;hostPath示例&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master hostpath]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;hostpath
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master hostpath]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_hostpath.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Pod
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: pod-&lt;span&gt;hostpath
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  containers:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   - name: myapp-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    volumeMounts:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     - name: hostpath-&lt;span&gt;dir&lt;/span&gt;-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       mountPath: /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     - name: hostpath-&lt;span&gt;file&lt;/span&gt;-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       mountPath: /test/hostpath-&lt;span&gt;file&lt;/span&gt;/&lt;span&gt;test.conf
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  volumes:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   - name: hostpath-&lt;span&gt;dir&lt;/span&gt;-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    hostPath:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      # 宿主机目录
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       path: /k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      # hostPath 卷指定 type，如果目录不存在则创建(可创建多层目录)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      type: DirectoryOrCreate
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   - name: hostpath-&lt;span&gt;file&lt;/span&gt;-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    hostPath:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       path: /k8s2/hostpath-&lt;span&gt;file&lt;/span&gt;/&lt;span&gt;test.conf
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;      # 如果文件不存在则创建。 前提：文件所在目录必须存在  目录不存在则不能创建文件
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       type: FileOrCreate
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动pod，并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master hostpath]# kubectl apply -&lt;span&gt;f pod_hostpath.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; pod/pod-&lt;span&gt;hostpath created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-&lt;span&gt;master hostpath]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-master hostpath]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;NAME           READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; pod-hostpath   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          17s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.133&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master hostpath]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master hostpath]# kubectl describe pod pod-&lt;span&gt;hostpath
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Name:         pod-&lt;span&gt;hostpath
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Priority:     &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; Node:         k8s-node01/&lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.111&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; Start Time:   Sat, &lt;span&gt;13&lt;/span&gt; Jun &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;15&lt;/span&gt; Annotations:  kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pod-hostpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;containers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;Status:       Running
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; IP:           &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.133&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;IPs:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   IP:  &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.133&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Containers:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;   myapp-&lt;span&gt;pod:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     Container ID:   docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8cc87217fb483288067fb6d227c46aa890d02f75cae85c6d110646839435ab96&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     Image:          registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     Image ID:       docker-pullable:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;registry.cn-beijing.aliyuncs.com/google_registry/myapp@sha256:9eeca44ba2d410e54fccc54cbe9c021802aa8b9836a0bcf3d3229354e4c8870e&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     Port:           &amp;lt;none&amp;gt;
&lt;span&gt;27&lt;/span&gt;     Host Port:      &amp;lt;none&amp;gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    State:          Running
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;       Started:      Sat, &lt;span&gt;13&lt;/span&gt; Jun &lt;span&gt;2020&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    Ready:          True
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     Restart Count:  &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Environment:    &amp;lt;none&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    Mounts:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt; from hostpath-&lt;span&gt;dir&lt;/span&gt;-&lt;span&gt;volume (rw)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       /test/hostpath-&lt;span&gt;file&lt;/span&gt;/test.conf from hostpath-&lt;span&gt;file&lt;/span&gt;-&lt;span&gt;volume (rw)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;       /var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;v48g4 (ro)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;Conditions:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;  Type              Status
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;  Initialized       True 
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;  Ready             True 
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;  ContainersReady   True 
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;  PodScheduled      True 
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;Volumes:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;   hostpath-&lt;span&gt;dir&lt;/span&gt;-&lt;span&gt;volume:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    Type:          HostPath (bare host directory volume)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     Path:          /k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    HostPathType:  DirectoryOrCreate
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;   hostpath-&lt;span&gt;file&lt;/span&gt;-&lt;span&gt;volume:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    Type:          HostPath (bare host directory volume)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     Path:          /k8s2/hostpath-&lt;span&gt;file&lt;/span&gt;/&lt;span&gt;test.conf
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    HostPathType:  FileOrCreate
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;   default-token-&lt;span&gt;v48g4:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    Type:        Secret (a volume populated by a Secret)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     SecretName:  default-token-&lt;span&gt;v48g4
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     Optional:    &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;QoS Class:       BestEffort
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; Node-Selectors:  &amp;lt;none&amp;gt;
&lt;span&gt;58&lt;/span&gt; Tolerations:     node.kubernetes.io/not-ready:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                  node.kubernetes.io/unreachable:NoExecute &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 300s
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;Events:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;  Type    Reason     Age        From                 Message
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;   ----    ------     ----       ----                 -------
&lt;span&gt;63&lt;/span&gt;   Normal  Scheduled  &amp;lt;unknown&amp;gt;  default-scheduler    Successfully assigned default/pod-hostpath to k8s-&lt;span&gt;node01
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;   Normal  Pulled     12m        kubelet, k8s-node01  Container image &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry.cn-beijing.aliyuncs.com/google_registry/myapp:v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; already present on machine
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;   Normal  Created    12m        kubelet, k8s-node01  Created container myapp-&lt;span&gt;pod
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;   Normal  Started    12m        kubelet, k8s-node01  Started container myapp-pod
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;hostPath验证&quot;&gt;hostPath验证&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;宿主机操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据pod，在k8s-node01节点宿主机操作【因为Pod分配到了该节点】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 对挂载的目录操作
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;dir&lt;/span&gt;]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; /k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;dir&lt;/span&gt;]# &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;dir&lt;/span&gt;]# &lt;span&gt;date&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;dir&lt;/span&gt;]# &lt;span&gt;cat&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;dir&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# 对挂载的文件操作
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;file&lt;/span&gt;]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; /k8s2/hostpath-&lt;span&gt;file&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;file&lt;/span&gt;]# &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;file&lt;/span&gt;]# &lt;span&gt;date&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;file&lt;/span&gt;&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; [root@k8s-node01 hostpath-&lt;span&gt;file&lt;/span&gt;]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在Pod 容器中操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 进入pod 中的指定容器【如果只有一个容器，那么可以不指定容器】
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [root@k8s-master hostpath]# kubectl exec -it pod-hostpath -c myapp-pod -- /bin/&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;##### 对挂载的目录操作
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; / # cd /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt; # &lt;span&gt;ls&lt;/span&gt; -&lt;span&gt;l
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; total &lt;span&gt;4&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; -rw-r--r--    &lt;span&gt;1&lt;/span&gt; root     root            &lt;span&gt;33&lt;/span&gt; Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt; # &lt;span&gt;cat&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt;&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt; # &lt;span&gt;date&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;info&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; /test-k8s/hostpath-&lt;span&gt;dir&lt;/span&gt; # &lt;span&gt;cat&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt; UTC &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;##### 对挂载的文件操作
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; # cd /test/hostpath-&lt;span&gt;file&lt;/span&gt;/
&lt;span&gt;19&lt;/span&gt; /test/hostpath-&lt;span&gt;file&lt;/span&gt; # &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; /test/hostpath-&lt;span&gt;file&lt;/span&gt; # &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; /test/hostpath-&lt;span&gt;file&lt;/span&gt; # &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; test.conf 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; Sat Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;====
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13743024.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之存储Secret详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/zhanglianghhh/p/13818190.html&quot; target=&quot;_blank&quot;&gt;Kubernetes K8S之存储ConfigMap详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/storage/volumes/&quot; target=&quot;_blank&quot;&gt;官网Volume详解&lt;/a&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201019235715651-1788785870.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Oct 2020 15:58:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>K8S之存储Volume概述与说明，并详解常用Volume示例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13844062.html</dc:identifier>
</item>
<item>
<title>记一次实现远程控制电脑开机过程 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/13843912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/13843912.html</guid>
<description>&lt;h2 id=&quot;一缘起&quot;&gt;一.缘起&lt;/h2&gt;
&lt;p&gt;先说说为什么有这个想法，比如在游戏首发的时候，想远程控制电脑开始下载；想远程电脑查询电脑 上的资料等等。作为一名IT行业的从业者，在生活和工作中需要电脑的地方很多，我们不能无时无刻把电脑带在身边，但是现在我们身边无时无刻伴随着两样东西：蜂窝网络和手机。因为我的习惯不喜欢电脑长时间的开着，我不用我就关掉，而且我的电脑散热风扇风比较大，我觉得长时间开着影响室内空气质量，所以我就有了远程控制电脑开机的需求，使用蜂窝网络和手机来实现此需求便可以随时随地的控制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231532713-2023580182.png&quot; alt=&quot;image-20201018205107269&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要说明的是，本文讲的是&lt;strong&gt;远程控制电脑开机&lt;/strong&gt;，而非电脑的远程桌面，远程桌面已经有非常多的方案 teamviewer、向日葵、anydesk等等，不过我不喜欢用这些方式（其实比较喜欢 teamviewer，但是经常被提示商用），我的远程桌面方式是搭建内网穿透（&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/13754597.html&quot;&gt;frp 内网穿透远程桌面（Windows 10）配置&lt;/a&gt;），然后直接使用自带的远程（PC），APP 的话使用的是微软开发的 “Microsoft 远程桌面”。回到正题，下面我分享我的远程控制电脑开机的实现过程。&lt;/p&gt;
&lt;h2 id=&quot;二解决方案一：wake-on-lan&quot;&gt;二.解决方案一：Wake on LAN&lt;/h2&gt;
&lt;p&gt;Wake on LAN 简称 WOL，简而言之就是可以通过网卡来唤醒电脑，现在的网卡基本上都是支持的。其原理为向网卡发送一个数据包，英文名：Magic Packet，中文：魔术包或幻包，网卡接收到以后便可以启动电脑。&lt;/p&gt;
&lt;p&gt;需要以下步骤来进行设置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入主板 BIOS 开启 Wake on LAN 功能，这里需要去查询自己的主板如何设置，一般在电源管理功能里面。&lt;/li&gt;
&lt;li&gt;关闭主板节电设置，关闭后最明显的特征是 USB 口关机后也带电，主板灯关机后也常亮。因为需要网卡带电，才能接受魔术包。&lt;/li&gt;
&lt;li&gt;路由器DHCP静态IP分配&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231532378-236562887.png&quot; alt=&quot;image-20201019222811764&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;进入 Windows 设备管理，设置网卡&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;电源管理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231532081-834609162.png&quot; alt=&quot;image-20201019222919337&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网卡属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231531743-480664669.png&quot; alt=&quot;image-20201019222958386&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置好以后，重启电脑，下载一个 WOL APP，填写电脑 IP 和 MAC 便可测试，我是 IOS 在 App Store 搜索 WOL 便可以搜到很多 APP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231530901-516388357.png&quot; alt=&quot;image-20201019223209902&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，会测试成功，向电脑发送魔术包以后，电脑会立即开启。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如遇到电脑关机长时间以后 WOL 无法唤醒电脑，那么需要进入路由器设置 ARP 绑定，若路由器没有相关功能，则需要 SSH 进入路由器，执行命令 &lt;code&gt;arp -s ip地址 mac地址&lt;/code&gt;，需要注意的是此命令执行后，重启路由器就失效了，有解决办法，就是加入路由器开启执行的脚本，这里不做详细讲述，因为不同的路由器ROM是有区别的。执行ARP绑定后就会解决这个问题（PS：这个问题困扰我很久了，还是同事给了这个解决办法）。&lt;/p&gt;
&lt;h3 id=&quot;1关于-广域网唤醒&quot;&gt;1.关于 广域网唤醒&lt;/h3&gt;
&lt;p&gt;若有公网 ip，那么直接设置端口转发，转发到电脑的 9 端口（一般都是）。没有公网 ip 可以在局域网的某一持续运行的设备设置内网穿透，建议在路由器上设置，若是梅林等固件可以安装现成的插件，我是小米路由器，进入SSH 装了一个 frp 内网穿透，配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[common]
server_addr = &amp;lt;公网服务器ip&amp;gt;
server_port = &amp;lt;公网服务器 frp 端口&amp;gt;
authentication_method = token
token = &amp;lt;认证 token&amp;gt;

[远程桌面]
type = tcp
local_ip = &amp;lt;电脑局域网ip&amp;gt;
local_port = 3389
remote_port = &amp;lt;远程桌面端口&amp;gt;

[WOL广域网]
type = udp
local_ip = &amp;lt;电脑局域网ip&amp;gt;
local_port = 9
remote_port = &amp;lt;WOL远程端口&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2魔术包&quot;&gt;2.魔术包&lt;/h3&gt;
&lt;p&gt;魔术包有一个标准的算法，网上有很多解释算法的文章以及各种语言的代码实现。&lt;/p&gt;
&lt;p&gt;C#: &lt;a href=&quot;https://github.com/nikeee/wake-on-lan&quot;&gt;https://github.com/nikeee/wake-on-lan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;java：&lt;a href=&quot;https://www.cnblogs.com/heidsoft/p/4011800.html&quot;&gt;https://www.cnblogs.com/heidsoft/p/4011800.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三解决方案二：ac-recovery&quot;&gt;三.解决方案二：AC Recovery&lt;/h2&gt;
&lt;p&gt;AC Recovery 又名 来电自动启动（回复），指电脑一&lt;strong&gt;通电&lt;/strong&gt;便可以自动启动。此方法是最简单的，不需要WOL各种设置，不需要主板支持 WOL，但是需要具备两个条件：&lt;/p&gt;
&lt;p&gt;1.主板具有来电启动功能&lt;/p&gt;
&lt;p&gt;2.智能插座（小米智能插座等等各种智能插座）&lt;/p&gt;
&lt;p&gt;我这里使用的是小米智能插座，设置的步骤如下：&lt;/p&gt;
&lt;p&gt;1.进入主板BIOS设置来电自动启动功能&lt;/p&gt;
&lt;p&gt;2.进入主板BIOS 关闭节电设置（经过我的实验，主板若开启节电无法正常来电启动）&lt;/p&gt;
&lt;p&gt;3.正确设置智能插座，接入米家APP，并连上主机插头。&lt;/p&gt;
&lt;p&gt;此时控制智能插座 断电-&amp;gt;通电 便可以实现来电自启动，若发现断电-&amp;gt;通电无法启动，则可以在中间加一个延时，等待主板完全断电，我的设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201019231528837-542296876.png&quot; alt=&quot;image-20201019230309971&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四解决方案三：开机卡&quot;&gt;四.解决方案三：开机卡&lt;/h2&gt;
&lt;p&gt;前两种方案都是我亲自实践并且成功了的，这里第三种方案，我只是在某宝看到，并为实验，此方法略微复杂一点。此方法是将独立的开机卡接入主板 PCI-E 插槽，在转接条线到齐上，在通过商家提供的APP来进行控制。这个需要一定的动手能力，想了解的同学可以去某宝搜一下。&lt;/p&gt;
&lt;h2 id=&quot;五结束&quot;&gt;五.结束&lt;/h2&gt;
&lt;p&gt;周末一个下午实验了两种方式，虽然简单，解决了我的生活里一个实际问题也是非常高兴，网上虽然设置的方法都很多，但是实践下来还是遇到了各种坑。&lt;/p&gt;
&lt;p&gt;最后提一下关于语音控制，方案一可以通过APP来添加 Siri 快捷指令来进行语音控制，方案二可以通过小爱同学来来进行语音控制。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Oct 2020 15:17:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.缘起 先说说为什么有这个想法，比如在游戏首发的时候，想远程控制电脑开始下载；想远程电脑查询电脑 上的资料等等。作为一名IT行业的从业者，在生活和工作中需要电脑的地方很多，我们不能无时无刻把电脑带在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/13843912.html</dc:identifier>
</item>
<item>
<title>选择SaaS平台的那些事 - RaymondTeng</title>
<link>http://www.cnblogs.com/tenghaohua/p/13843815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tenghaohua/p/13843815.html</guid>
<description>&lt;p&gt;将近一年多没有更新博客和自己的订阅号。除了本身有点懒之外，也有幸在上半年花了一些时间考出了CISSP。最近也在研究云平台相关的一些课题。&lt;/p&gt;
&lt;p&gt;写这篇文章本身是因为在工作中经常有IT乃至业务的同事会问及企业在选择SaaS平台时的考量以及如何保证其符合企业安全体系。因而我就以自己有限的认知提供一些有限的见解，以供参考。&lt;/p&gt;
&lt;p&gt;在这里首先简单介绍一下什么是SaaS。云的服务模式目前主要分为三种（SPI）：基础架构即服务（IaaS）,平台即服务（PaaS）以及软件即服务。其中SaaS平台供应商将应用软件统一部署在自己的服务器上，客户可以根据工作实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得Saas平台供应商提供的服务。&lt;/p&gt;
&lt;p&gt;从云平台的责任矩阵角度来解释就是你只需要负责使用供应商提供的公网应用平台，剩下的都交给供应商负责就行。当然账号，客户端安全以及数据的分类管理还是要客户自己负责的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1731663/202010/1731663-20201019192350547-996363660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那我们就要问第一个问题就是为什么我们要选择SaaS?&lt;/p&gt;
&lt;p&gt;通俗的一些好处往往是敏捷性，弹性以及潜在的经济性。最根本的可能往往是企业可以将更多的资源专注在业务层而不是底层的技术。虽然每个公司的业务模式不尽相同，但大多数都会根据业务的需求可以将非敏感非核心的业务需求通过SaaS的方式实现以节省出大量IT运维方面的成本（当然也有少部分把核心应用如ERP搬上云的）。Office 365就是最好的一个例子，你再也不需花大量的硬件软件人力成本去维护一套exchange,sharepoint或者Skype for business 系统，只需要按用户数以及需求购买相对应的license即可。让专业的供应商做专业的事。&lt;/p&gt;

&lt;p&gt;其次从架构的角度来看选择SaaS至少需要考虑以下几个方面：&lt;/p&gt;
&lt;p&gt;1. 和现有应用的整合是否有问题。比如数据传输，接口调用，以及和企业IAM的整合。&lt;/p&gt;
&lt;p&gt;2.平台成熟度和业务功能性是否满足业务需求&lt;/p&gt;
&lt;p&gt;3.管理的流程是否符合企业自身要求&lt;/p&gt;
&lt;p&gt;4.收费模式的确认&lt;/p&gt;
&lt;p&gt;当然可能还有其他因素，企业可以根据自身情况有更多其他的考量。&lt;/p&gt;

&lt;p&gt;那从安全方面SaaS平台会有哪些风险呢？&lt;/p&gt;
&lt;p&gt;可能有人会觉得SaaS的安全不是都由供应商全权负责的么？的确如此，但是有人的地方就有风险，工作可以授权或者外包,但责任不行。一旦你使用的平台出现了任何问题，受伤的往往都是公司自己的业务。&lt;/p&gt;
&lt;p&gt;以个人的经验来看SaaS的平台往往经常会遇到以下一些问题和风险：&lt;/p&gt;
&lt;p&gt;1.数据主权不清。曾有见过公司用供应商平台前连数据所有权都不确认，结果终止合同时极为被动痛苦。&lt;/p&gt;
&lt;p&gt;2. 供应商技术人员水平低，平台安全性差，没有BCM。由于平台本身是不透明的，即便安全做的很糟糕，云用户本身也无法察觉。&lt;/p&gt;
&lt;p&gt;3 .供应商财务状况不稳定,出现业务变动，跑路或者公司倒闭。也能使得云用户极为被动，可能事后换平台的成本反而还不如当初自己直接开发一套应用部署。&lt;/p&gt;
&lt;p&gt;4. 平台锁定，迁移成本高。然后被无良供应商各种牵着鼻子走。&lt;/p&gt;
&lt;p&gt;5. 数据生命周期管理-比如在合同终止时，没有按要求清除用户数据。&lt;/p&gt;


&lt;p&gt;既然SaaS本身不透明性决定了用户只能获得平台有限的信息，因此作为SaaS的用户，企业必须谨慎选择云平台，并在依靠一些治理手段对云供应商做一些限制。&lt;/p&gt;
&lt;p&gt;总体来说可以使用评估，合规审计，合同等治理方式&lt;/p&gt;
&lt;p&gt;1. 合同----合同是将治理扩展业务合作伙伴和服务提供者的重要工具，把一切落在条款上保证SLA和承诺不会违约的唯一方式。其中至少包括或定义数据主权，数据生命周期（数据删除），隐私适用规则，SLA要求和惩罚措施，责任划分，对平台审计权，由于云平台责任导致的安全事故所要做的财务赔偿等。一般来说小型SaaS提供商的合同谈判可行性更高，但是往往他们无法在复杂环境下满足或超过客户治理和风险管理的要求，最重要的是国内小型互联网公司非常容易亏损跑路。成熟的SaaS供应商往往有自己的合同模板，并且谈判性可能不高。合同的洽谈是一个很复杂的过程，一定要在法务和采购的共同协助下完成此事。&lt;/p&gt;
&lt;p&gt;2. 合规报告---主要通过第三方对云平台的安全性进行认证或者合规的报告。一般来说国内最近比较多的等保（SaaS考虑至少三级），国际上的ISO 27001(基础)+ISO 27017(云信息安全), STAR（中国版C-STAR），通用准则（CC），PCI-DSS， HIPPA, SSAE-16, SOC 等。企业本身也可以对平台进行审计，但是这项权限必须在合同内得以体现。一般来说都是通过第三方操作，大的SaaS供应商本身比较少愿意让客户直接审计。&lt;/p&gt;
&lt;p&gt;3. 评估----主要包括一些同行反馈，服务水平，财务水平（考虑跑路的可能性），平台的安全措施，第三方认证，数据导出的可能性（API或者供应商协助），平台的可迁移性（避免供应商过度锁定）。评估的过程也要包括合同以及合规的内容。&lt;/p&gt;

&lt;p&gt;一般来说企业本身必须要有具体的风险管理和风险接收/缓解的方法，以评估每个解决方案的风险。最后就是剩余风险的处理。由于风险的容忍度根据数据本身的价值和企业的风险偏好都有关，因此具体情况具体分析。&lt;/p&gt;
&lt;p&gt;最后强调几个我认为可能比较容易容易忽视的点：&lt;/p&gt;
&lt;p&gt;1.尽可能的要考虑平台可迁移性或者可移植性。即便你选择了一个比较靠谱的SaaS提供商，也不能排除由于企业自身内部出现的变化而调整整个企业架构，从而主动更换对应的SaaS平台。&lt;/p&gt;
&lt;p&gt;2.必须要有业务连续性方案和流程。虽然有SLA合同的保证但是针对重要的SaaS应用，企业自身还有要相对应的BCM方案。比如定期的将SaaS数据导出自己的内部数据平台，SaaS故障时用其他备用方案推进日常业务流程。&lt;/p&gt;
&lt;p&gt;3.合同上的条款尽可能详细，丑话一定要说在前。合同在使用SaaS平台过程中保护企业自身利益最好且唯一有效的工具。&lt;/p&gt;

&lt;p&gt;总的来说，业务选择上SaaS就像是把孩子交给了寄宿学校。在推进业务上可以根据需要八仙过海各显神通，有时候甚至可以激进一些。但是在安全上则不能当一个“莽夫”，IT部门要利用自己的专业知识帮业务规避风险，深入业务并保驾护航。业务部门在许多控制节点上也必须让专业的IT人员做守门员，因为不同的专业角度所看到的问题不尽相同，切不可保有侥幸心理。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot; id=&quot;uploading_image_93006&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Oct 2020 15:13:00 +0000</pubDate>
<dc:creator>RaymondTeng</dc:creator>
<og:description>将近一年多没有更新博客和自己的订阅号。除了本身有点懒之外，也有幸在上半年花了一些时间考出了CISSP。最近也在研究云平台相关的一些课题。 写这篇文章本身是因为在工作中经常有IT乃至业务的同事会问及企业</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tenghaohua/p/13843815.html</dc:identifier>
</item>
<item>
<title>Pytest学习（一）- 入门及基础 - 久曲健</title>
<link>http://www.cnblogs.com/longronglang/p/13843840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/13843840.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;十一也赶上自己刚出院，本想在十一放假前用假期刷完Pytest的，结果被希洛克神话吸引，再次回归毒奶粉，一直奋斗到距离上班还有两天，引导石刷没了，就没了智慧。&lt;/p&gt;
&lt;p&gt;当然也没出过神话，结果一怒之下卸载，开始收收心，准备学习，用了两个下午时间看了下pytest的官方文档，全是英文的，用谷歌翻译看的也是一知半解，基于理解产出文章两篇。&lt;/p&gt;
&lt;p&gt;十一节后上班，直到现在迟迟一直未更文学习。因为一些事，导致无法专心学习，但是刷完pytest这个事，我还是记得，毕竟2020年结束还有俩约，是时候在年底冲刺一波未完成的知识了。&lt;/p&gt;
&lt;h3 id=&quot;一、关于环境搭建&quot;&gt;一、关于环境搭建&lt;/h3&gt;
&lt;p&gt;可以参考文章《使用IDEA写Python之pytest环境搭建及第一个程序编写》&lt;/p&gt;
&lt;h3 id=&quot;二、关于开发工具&quot;&gt;二、关于开发工具&lt;/h3&gt;
&lt;p&gt;作为一个java党，对于IDEA的喜欢程度，不用我多说，相信每个java编码的同学，都是爱不释手的。&lt;/p&gt;
&lt;p&gt;上篇文章提及到用IDEA进行Python的编码，虽然能满足简单学习的需求，但IDEA支持也是作为一种插件的存在，所以作为长久想学习Python的话，那我们还是“跟风”选择pycharm吧。&lt;/p&gt;
&lt;h3 id=&quot;三、为什么要使用pytest&quot;&gt;三、为什么要使用Pytest&lt;/h3&gt;
&lt;p&gt;就Python的测试框架而言，目前比较流行的就是pytest和unittest，unittest广为人知，但就现在而言是老框架了，但是依旧有那么多喜欢使用他来做自动化测试，我猜想大部分人都和我一样，早期是从虫师开始接触和熟悉Python自动化的&lt;br/&gt;。&lt;br/&gt;pytest是基于unittest开发的另一款更高级更好用的单元测试框架，作为知识更新，也更该去学习新知识了，它就和Testng和junit一样，无论从逼格和好用程度来看，都是完胜后者。&lt;/p&gt;
&lt;h3 id=&quot;四、pytest特点&quot;&gt;四、pytest特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考&lt;/li&gt;
&lt;li&gt;能够支持简单的单元测试和复杂的功能测试&lt;/li&gt;
&lt;li&gt;支持参数化&lt;/li&gt;
&lt;li&gt;执行测试过程中可以将某些测试跳过（skip），或者对某些预期失败的case标记成失败&lt;/li&gt;
&lt;li&gt;支持重复执行(rerun)失败的 case&lt;/li&gt;
&lt;li&gt;支持运行由 nose, unittest 编写的测试 case&lt;/li&gt;
&lt;li&gt;可生成 html 报告&lt;/li&gt;
&lt;li&gt;方便的和持续集成工具 jenkins 集成&lt;/li&gt;
&lt;li&gt;可支持执行部分用例&lt;/li&gt;
&lt;li&gt;具有很多第三方插件，并且可以自定义扩展&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;五、快速入门&quot;&gt;五、快速入门&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: utf-8 -*-
# @Time    : 2020/10/15 20:10
# @Author  : longrong.lang
# @FileName: test_demo.py
# @Software: PyCharm
# @Cnblogs ：https://www.cnblogs.com/longronglang

def add(x):
    return x + 2;


class TestClass(object):
    # 测试是否相等
    def test_add(self):
        assert add(2) == 5

    # 测试包含
    def test_in(self):
        a = 'hello world'
        b = 'he'
        assert b in a

    # 测试不包含
    def test_not_in(self):
        a = 'Hello'
        b = 'hi'
        assert b not in a

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1、执行&quot;&gt;1、执行&lt;/h4&gt;
&lt;p&gt;命令行当前文件同级目录下，输入如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/c60ca6c7-cca8-4f5f-853c-325ae5cd606a.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=mR3ZhKEBVuTZaPm0b6QZn2W4K1E%253D&amp;amp;Expires=1603205076&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;说明：&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;只执行 pytest ，会查找当前目录及其子目录下以 test_*.py 或 *_test.py 文件，找到文件后，在文件中找到以 test 开头函数并执行&lt;/li&gt;
&lt;li&gt;只想执行某个文件，可以 pytest test_demo.py&lt;/li&gt;
&lt;li&gt;加上-q，就是显示简单的结果： pytest -q test_demo.py&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用Pytest写用例时候，一定要按照下面的规则去写，否则不符合规则的测试用例是不会执行的&lt;/p&gt;
&lt;h3 id=&quot;六、pytest用例的设计原则&quot;&gt;六、Pytest用例的设计原则&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;文件名以 test_&lt;em&gt;.py 文件和&lt;/em&gt;_test.py&lt;/li&gt;
&lt;li&gt;以 test_ 开头的函数&lt;/li&gt;
&lt;li&gt;以 Test 开头的类，不能包含 &lt;strong&gt;init&lt;/strong&gt; 方法&lt;/li&gt;
&lt;li&gt;以 test_ 开头的类里面的方法&lt;/li&gt;
&lt;li&gt;所有的包 pakege 必项要有__init__.py 文件&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;七、pytest执行用例规则&quot;&gt;七、Pytest执行用例规则&lt;/h3&gt;
&lt;p&gt;下面以windows系统为例，使用命令来来执行pytest&lt;/p&gt;
&lt;h4 id=&quot;1、指定目录下的所有用例&quot;&gt;1、指定目录下的所有用例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、执行某一个py文件下用例&quot;&gt;2、执行某一个py文件下用例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest 文件名.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3、运行test_demopy文件中模块里面的某个函数或者某个类，某个类里面的方法&quot;&gt;3、运行test_demo.py文件中模块里面的某个函数,或者某个类，某个类里面的方法&lt;/h4&gt;
&lt;p&gt;说明：加v和不加-v都可以，加-v的话，打印的信息更详细&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pytest -v test_demo.py::TestClass::test_add

pytest test_demo.py::TestClass::test_not_in

pytest test_demo.py::test_in
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4、运行test_demopy-模块里面测试类里面的某个方法&quot;&gt;4、运行test_demo.py 模块里面,测试类里面的某个方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_demo.py::test_in
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5、-m-标记表达式（后面有详解）&quot;&gt;5、-m 标记表达式（后面有详解）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -m login
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将运行用 @pytest.mark.login 装饰器修饰的所有测试，后面有详解!&lt;/p&gt;
&lt;h4 id=&quot;6、-q-简单打印，只打印测试用例的执行结果&quot;&gt;6、-q 简单打印，只打印测试用例的执行结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -q test_demo.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7、-s-详细打印&quot;&gt;7、-s 详细打印&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -s test_demo.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;8、-x-遇到错误时停止测试&quot;&gt;8、-x 遇到错误时停止测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_demo.py -x
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;9、maxfailnum，当用例错误个数达到指定数量时，停止测试&quot;&gt;9、—maxfail=num，当用例错误个数达到指定数量时，停止测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest test_demo.py --maxfail=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;10、-k-匹配用例名称&quot;&gt;10、-k 匹配用例名称&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -s -k _in test_demo.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;11、-k-根据用例名称排除某些用例&quot;&gt;11、-k 根据用例名称排除某些用例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -s -k &quot;not _in&quot; test_demo.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12、-k-同时匹配不同的用例名称&quot;&gt;12、-k 同时匹配不同的用例名称&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pytest -s -k &quot;add or _in&quot; test_demo.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八、使用pycharm执行pytest&quot;&gt;八、使用Pycharm执行pytest&lt;/h3&gt;
&lt;p&gt;1、File-&amp;gt;settings-&amp;gt;python integrated tools-&amp;gt;Testing下的default testrunner修改为Pytest&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/ce1a620e-7971-49de-8e09-22f82983a23d.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=jEiRkGKaM90iUvaZoxIUSve8M7k%253D&amp;amp;Expires=1603205638&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;注意：&quot;&gt;注意：&lt;/h5&gt;
&lt;p&gt;pytest兼容unittest脚本,所以不影响之前使用unittest编写的脚本&lt;/p&gt;
&lt;p&gt;2、并不是修改完以上配置，就一定好用，如上面方法修改完仍不好用，参考下面方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查pycharm中的python interpreter是否设置为Python安装目录下的Python.exe&lt;/li&gt;
&lt;li&gt;pycharm设置为国内源，如豆瓣、清华、阿里云等等！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、如果和我一样之前使用IDEA中pytest插件编码的话，在进行完以上两步操作后，执行如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开IDEA，将settings-&amp;gt;python integrated tools-&amp;gt;Testing下的default testrunner修改为Pytest&lt;/li&gt;
&lt;li&gt;你会在打开的.py文件右上角看到提示，提示你选择Python的sdk路径，选择为Python安装目录下的Python.exe，确定后，会自动编译更新，更新完你会发现使用IDEA可以使用pytest运行了&lt;/li&gt;
&lt;li&gt;再回头查看pycharm这时候也提示你选择sdk的安装目录，同上选择好Python安装目录，也会自动编译更新，更新完后，你会发现使用pycharm也可以使用pytest运行了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系列参考文章：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/poloyy/category/1690628.html&quot;&gt;https://www.cnblogs.com/poloyy/category/1690628.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Oct 2020 15:04:00 +0000</pubDate>
<dc:creator>久曲健</dc:creator>
<og:description>前言 十一也赶上自己刚出院，本想在十一放假前用假期刷完Pytest的，结果被希洛克神话吸引，再次回归毒奶粉，一直奋斗到距离上班还有两天，引导石刷没了，就没了智慧。 当然也没出过神话，结果一怒之下卸载，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/13843840.html</dc:identifier>
</item>
<item>
<title>.NET Core开源任务调度平台ScheduleMaster上新了 - balahoho</title>
<link>http://www.cnblogs.com/hohoa/p/13843622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hohoa/p/13843622.html</guid>
<description>&lt;p&gt;ScheduleMaster上一次比较大的更新还是在6月份，转眼已经快过去4个月了，这段时间比较忙，中间只更新过一次修复了几个小bug。要总结这次更新的话，必须要用“千呼万唤始出来”了，因为这次不仅经历的时间比较久，还带来了大家期待已久的功能-多数据库支持，再就是对.NET Framework的支持。&lt;/p&gt;
&lt;p&gt;不熟悉的朋友可以先参考以往的介绍文章：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;同时，项目也迎来了一个里程碑，那就是收到了第一个PR，瞬间感觉肩上责任重大[手动狗头]。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看一下本次的更新点。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;v22更新日志&quot;&gt;V2.2更新日志&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;新增了对SQLServer和PostgreSQL的支持（来自&lt;a href=&quot;https://github.com/xueandfeng&quot;&gt;@xueandfeng&lt;/a&gt;的PR，非常感谢！）&lt;/li&gt;
&lt;li&gt;新增了对.NET Standard 2.0的支持&lt;/li&gt;
&lt;li&gt;Worker节点支持配置最大并发数&lt;/li&gt;
&lt;li&gt;HTTP任务支持自定义超时时间&lt;/li&gt;
&lt;li&gt;修复了已知的bug&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h3 id=&quot;新功能可以做什么&quot;&gt;新功能可以做什么&lt;/h3&gt;
&lt;p&gt;项目最初使用的Mysql作为数据持久化方式，从发布开发，就有小伙伴一直问能不能支持其他数据库，因为对.NET平台的开发者来说使用SQLServer还是更多一些。但是那时候更多的考虑到整个项目部署的便捷性和跨平台（docker一条龙服务），而且刚好那段时间沉迷于Mysql，所以毫不犹豫的选择了它。虽然使用EntityFramework这样的ORM作为数据访问框架，但当时迫切的想完成核心功能快速发版，就没有考虑支持多种类型数据库，一直拖到现在。&lt;/p&gt;
&lt;p&gt;在这过程中，支持多数据库的需求实在太大，有很多小伙伴自己拉源码改改就用上了，也有热心的小伙伴改完提了PR，不过我由于个人问题还是拖了一段时间到现在才处理。所以，经常用SQLServer或者更喜欢PostgreSQL的朋友有福了，再次感谢&lt;a href=&quot;https://github.com/xueandfeng&quot;&gt;@xueandfeng&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，项目正式支持.NET Standard 2.0，这意味着项目不仅仅能支持.NET Core程序，同时也能支持.NET Framework（4.6.1及以上）程序了，一张图看个明明白白：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/614524/202010/614524-20201019222634240-1502955637.png&quot; alt=&quot;netsdandard&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;.NET 5马上就要正式发布了，据说.NET Standard就要成为历史，当年费了好大劲才理清楚这几个玩意的关系，转眼说没就没了，我啊一口老血.........吐完继续喊“.NET真香”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上之外，worker节点可以支持配置最大并发数量了，这是Quartz.Net线程池的一个特性。之前收到锄头哥多次反馈大任务量同时执行时会有丢失的问题&lt;a href=&quot;https://github.com/hey-hoho/ScheduleMasterCore/issues/38&quot;&gt;#38&lt;/a&gt;,多方排查后定位到线程池上。从Quartz.Net 3.0开始，默认线程池(Quartz.Simpl.DefaultThreadPool)开始使用CLR的线程池，但是仍然保留了maxConcurrency这个参数，它的默认值是10。在官网文档可以看到，在大任务量执行频率比较高时，建议调高最大并发量的值：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code&gt;quartz.threadPool.maxConcurrency&lt;/code&gt;&lt;br/&gt;This is the number of concurrent tasks that can be dispatched to CLR thread pool. If you only have a few jobs that fire a few times a day, then 1 tasks is plenty! If you have tens of thousands of jobs, with many firing every minute, then you probably want a max concurrency count more like 50 or 100 (this highly depends on the nature of the work that your jobs perform, and your systems resources!). Also note CLR thread pool configuration separate from Quartz itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过要注意的是，这个值并不严格意味着你最大能执行XX个任务，这取决于你的任务执行情况和系统环境。当你有大量高频率任务时，调高这个参数能明显改善任务丢失情况，ScheduleMaster给它的默认值是20。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;我在忙什么&quot;&gt;我在忙什么&lt;/h3&gt;
&lt;p&gt;6月底我从广州裸辞，回到武汉开始找工作。作为今年疫情的最中心，武汉受到的影响还是非常大的，很多朋友劝我不要在这个时候换工作，但是由于一些原因我还是坚决地回来了。所以，还是逃不过现实的残酷，工作这么多年来第一次感受到找个靠谱的工作如此困难，当然这也和武汉的.NET大环境有关，前前后后花了好几个月才阴差阳错地来到现在这家公司。&lt;/p&gt;
&lt;p&gt;目前从事云计算行业，有太多太多的专业知识要学习，而且还有好几门考证要求，实在应接不暇，初期曾一度想放弃。现在工作中主要的开发语言也转型到了Golang，什么前端后端运维数据库DevOps哪里需要往哪里搬，不断刷新自己的知识盲区。不过.NET还是会继续关注，这个项目还是会继续做下去。&lt;/p&gt;
&lt;p&gt;最后，佛系推广一下。&lt;br/&gt;作者唯一开源地址&lt;img src=&quot;https://img.shields.io/github/stars/hey-hoho/ScheduleMasterCore?style=social&quot; alt=&quot;GitHub stars&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/github/forks/hey-hoho/ScheduleMasterCore?style=social&quot; alt=&quot;GitHub forks&quot; loading=&quot;lazy&quot;/&gt;：&lt;/p&gt;
&lt;p&gt;文档（还在逐步更新中）：&lt;/p&gt;
&lt;p&gt;感谢大家支持~&lt;/p&gt;
</description>
<pubDate>Mon, 19 Oct 2020 14:46:00 +0000</pubDate>
<dc:creator>balahoho</dc:creator>
<og:description>ScheduleMaster上一次比较大的更新还是在6月份，转眼已经快过去4个月了，这段时间比较忙，中间只更新过一次修复了几个小bug。要总结这次更新的话，必须要用“千呼万唤始出来”了，因为这次不仅经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hohoa/p/13843622.html</dc:identifier>
</item>
</channel>
</rss>