<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java基础系列之ConcurrentHashMap源码分析（基于jdk1.8） - rainple</title>
<link>http://www.cnblogs.com/rainple/p/10708436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/10708436.html</guid>
<description>&lt;p&gt;　　在阅读这篇博客之前，希望你对HashMap已经是有所理解的，否则可以参考这篇博客： &lt;a href=&quot;https://www.noblogs.cn/rainple/blog/17853.html&quot; target=&quot;_blank&quot;&gt;jdk1.8源码分析-hashMap&lt;/a&gt;；另外你对java的cas操作也是有一定了解的，因为在这个类中大量使用到了cas相关的操作来保证线程安全的。&lt;/p&gt;

&lt;p&gt;　　ConcurrentHashMap这个类在java.lang.current包中，这个包中的类都是线程安全的。ConcurrentHashMap底层存储数据的结构与1.8的HashMap是一样的，都是数组+链表（或红黑树）的结构。在日常的开发中，我们最长用到的键值对存储结构的是HashMap，但是我们知道，这个类是非线程安全的，在高并发的场景下，在进行put操作的时候有可能进入死循环从而使服务器的cpu使用率达到100%；sun公司因此也给出了与之对应的线程安全的类。在jdk1.5以前，使用的是HashTable，这个类为了保证线程安全，在每个类中都添加了synchronized关键字，而想而知在高并发的情景下相率是非常低下的。为了解决HashTable效率低下的问题，官网在jdk1.5后推出了ConcurrentHashMap来替代饱受诟病的HashTable。jdk1.5后ConcurrentHashMap使用了分段锁的技术。在整个数组中被分为多个segment，每次get，put，remove操作时就锁住目标元素所在的segment中，因此segment与segment之前是可以并发操作的，上述就是jdk1.5后实现线程安全的大致思想。但是，从描述中可以看出一个问题，就是如果出现比较机端的情况，所有的数据都集中在一个segment中的话，在并发的情况下相当于锁住了全表，这种情况下其实是和HashTable的效率出不多的，但总体来说相较于HashTable，效率还是有了很大的提升。jdk1.8后，ConcurrentHashMap摒弃了segment的思想，转而使用cas+synchronized组合的方式来实现并发下的线程安全的，这种实现方式比1.5的效率又有了比较大的提升。那么，它是如何整体提升效率的呢？见下文分析吧！&lt;/p&gt;

&lt;p&gt;　　1、ziseCtr：在多个方法中出现过这个变量，该变量主要是用来控制数组的初始化和扩容的，默认值为0，可以概括一下4种状态：&lt;/p&gt;
&lt;p&gt;　　　　a、sizeCtr=0：默认值；&lt;/p&gt;
&lt;p&gt;　　　　b、sizeCtr=-1：表示Map正在初始化中；&lt;/p&gt;
&lt;p&gt;　　　　c、sizeCtr=-N：表示正在有N-1个线程进行扩容操作；&lt;/p&gt;
&lt;p&gt;　　　　d、sizeCtr&amp;gt;0: 未初始化则表示初始化Map的大小，已初始化则表示下次进行扩容操作的阈值；&lt;/p&gt;
&lt;p&gt;　　2、table：用于存储链表或红黑数的数组，初始值为null，在第一次进行put操作的时候进行初始化，默认值为16；&lt;/p&gt;
&lt;p&gt;　　3、nextTable：在扩容时新生成的数组，其大小为当前table的2倍，用于存放table转移过来的值；&lt;/p&gt;
&lt;p&gt;　　4、Node：该类存储数据的核心，以key-value形式来存储；&lt;/p&gt;
&lt;p&gt;　　5、ForwardingNode：这是一个特殊Node节点，仅在进行扩容时用作占位符，表示当前位置已被移动或者为null，该node节点的hash值为-1；&lt;/p&gt;

&lt;p&gt;　　先把源码摆上来:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        //key和value不能为空
        if (key == null || value == null) throw new NullPointerException();
        //通过key来计算获得hash值
        int hash = spread(key.hashCode());
        //用于计算数组位置上存放的node的节点数量
        //在put完成后会对这个参数判断是否需要转换成红黑树或链表
        int binCount = 0;
        //使用自旋的方式放入数据
        //这个过程是非阻塞的，放入失败会一直循环尝试，直至成功
        for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
            Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
            //第一次put操作，对数组进行初始化，实现懒加载
            if (tab == null || (n = tab.length) == 0)
                //初始化
                tab = initTable();
            //数组已初始化完成后
            //使用cas来获取插入元素所在的数组的下标的位置，该位置为空的话就直接放进去
            else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            //hash=-1,表明该位置正在进行扩容操作，让当前线程也帮助该位置上的扩容，并发扩容提高扩容的速度
            else if ((fh = f.hash) == MOVED)
                //帮助扩容
                tab = helpTransfer(tab, f);
            //插入到该位置已有数据的节点上，即用hash冲突
            //在这里为保证线程安全，会对当前数组位置上的第一个节点进行加锁，因此其他位置上
            //仍然可以进行插入，这里就是jdk1.8相较于之前版本使用segment作为锁性能要高效的地方
            else {
                V oldVal = null;
                synchronized (f) {
                    //再一次判断f节点是否为第一个节点，防止其他线程已修改f节点
                    if (tabAt(tab, i) == f) {
                        //为链表
                        if (fh &amp;gt;= 0) {
                            binCount = 1;
                            //将节点放入链表中
                            for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&amp;lt;K,V&amp;gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        //为红黑树
                        else if (f instanceof TreeBin) {
                            Node&amp;lt;K,V&amp;gt; p;
                            binCount = 2;
                            //将节点插入红黑树中
                            if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                //插入成功后判断插入数据所在位置上的节点数量，
                //如果数量达到了转化红黑树的阈值，则进行转换
                if (binCount != 0) {
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                        //由链表转换成红黑树
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        //使用cas统计数量增加1，同时判断是否满足扩容需求，进行扩容
        addCount(1L, binCount);
        return null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在代码上写注释可能看得不是很清晰，那么我就使用文字再来描述一下插入数据的整个流程：&lt;/p&gt;
&lt;p&gt;　　　　1、判断传进来的key和value是否为空，在ConcurrentHashMap中key和value都不允许为空，然而在HashMap中是可以为key和val都可以为空，这一点值得注意一下；&lt;/p&gt;
&lt;p&gt;　　　　2、对key进行重hash计算，获得hash值；&lt;/p&gt;
&lt;p&gt;　　　　3、如果当前的数组为空，说明这是第一插入数据，则会对table进行初始化；&lt;/p&gt;
&lt;p&gt;　　　　4、插入数据，这里分为3中情况：&lt;/p&gt;
&lt;p&gt;　　　　　　1）、插入位置为空，直接将数据放入table的第一个位置中；&lt;/p&gt;
&lt;p&gt;　　　　　　2）、插入位置不为空，并且改为是一个ForwardingNode节点，说明该位置上的链表或红黑树正在进行扩容，然后让当前线程加进去并发扩容，提高效率；&lt;/p&gt;
&lt;p&gt;　　　　　　3）、插入位置不为空，也不是ForwardingNode节点，若为链表则从第一节点开始组个往下遍历，如果有key的hashCode相等并且值也相等，那么就将该节点的数据替换掉，&lt;/p&gt;
&lt;p&gt;　　　　　　　　否则将数据加入　　到链表末段；若为红黑树，则按红黑树的规则放进相应的位置；&lt;/p&gt;
&lt;p&gt;　　　　5、数据插入成功后，判断当前位置上的节点的数量，如果节点数据大于转换红黑树阈值（默认为8），则将链表转换成红黑树，提高get操作的速度；&lt;/p&gt;
&lt;p&gt;　　　　6、数据量+1，并判断当前table是否需要扩容；&lt;/p&gt;
&lt;p&gt;　　所以，put操作流程可以简单的概括为上面的六个步骤，其中一些具体的操作会在下面进行详细的说明，不过，值得注意的是：&lt;/p&gt;
&lt;p&gt;　　　　1、ConcurrentHashMap不可以存储key或value为null的数据，有别于HashMap；&lt;/p&gt;
&lt;p&gt;　　　　2、ConcurrentHashMap使用了懒加载的方式初始化数据，把table的初始化放在第一次put数据的时候，而不是在new的时候；&lt;/p&gt;
&lt;p&gt;　　　　3、扩容时是支持并发扩容，这将有助于减少扩容的时间，因为每次扩容都需要对每个节点进行重hash，从一个table转移到新的table中，这个过程会耗费大量的时间和cpu资源。&lt;/p&gt;
&lt;p&gt;　　　　4、插入数据操作锁住的是表头，这是并发效率高于jdk1.7的地方；&lt;/p&gt;
&lt;h2&gt;　　4.1、hash计算的spread方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Spreads (XORs) higher bits of hash to lower and also forces top
     * bit to 0. Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don't benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int spread(int h) {
        return (h ^ (h &amp;gt;&amp;gt;&amp;gt; 16)) &amp;amp; HASH_BITS;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从源码中可以看到，jdk1.8计算hash的方法是先获取到key的hashCode，然后对hashCode进行高16位和低16位异或运算，然后再与 0x7fffffff 进行与运算。高低位异或运算可以保证haahCode的每一位都可以参与运算，从而使运算的结果更加均匀的分布在不同的区域，在计算table位置时可以减少冲突，提高效率，我们知道Map在put操作时大部分性能都耗费在解决hash冲突上面。得出运算结果后再和 0x7fffffff 与运算，其目的是保证每次运算结果都是一个正数。对于java位运算不了解的同学，建议百度自行了解相关内容。&lt;/p&gt;
&lt;h2&gt;　　4.2、java内存模型和cas操作&lt;/h2&gt;
&lt;p&gt;　　这里我只是简单的说一下java的内存模型和cas，因为这篇文章的主角的ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;　　java内存模型：在java中线程之间的通讯是通过共享内存（即我们在变成时声明的成员变量或叫全局变量）的来实现的。Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201904/1519364-20190421221242557-1457139239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　举一个非常简单的例子，就是我们常用的i++的操作，这个操作看起来只有一行，然而在编译器中这一行代码会被编译成3条指令，分别是读取、更新和写入，所以i++并不是一个原子操作，在多线程环境中是有问题了。其原因在于（我们假设当前 i 的值为1）当一条线程向主内存中读取数据时，还没来得及把更新后的值刷新到主内存中，另一个线程就已经开始向主内存中读取了数据，而此时内存中的值仍然为1，两个线程执行+1操作后得到的结果都为2，然后将结果刷新到主内存中，整个i++操作结果，最终得到的结果为2，但是我们预想的结果应该是3，这就出现了线程安全的问题了。&lt;/p&gt;
&lt;p&gt;　　cas： cas的全名称是Compare And Swap 即比较交换。cas算法在不需要加锁的情况也可以保证多线程安全。核心思想是： cas中有三个变量，要更新的变量V，预期值E和新值N,首先先读取V的值，然后进行相关的操作，操作完成后再向主存中读取一次取值为E，当且仅当V == E时才将N赋值给V，否则再走一遍上诉的流程，直至更新成功为止。就拿上面的i++的操作来做说明，假设当前i=1，两个线程同时对i进行+1的操作，线程A中V = 1，E = 1，N = 2；线程B中 V = 1，E = 1，N = 2；假设线程A先执行完整个操作，此时线程A发现 V = E = 1，所以线程A将N的值赋值给V，那么此时i的值就变成了 2 ；线程B随后也完成了操作，向主存中读取i的值，此时E = 2，V = 1，V ！= E，发现两个并不相等，说明i已经被其他线程修改了，因此不执行更新操作，而是从新读取V的值V = 2 ，执行+1后N = 3，完成后再读取主存中i的值，因为此时没有其他线程修改i的值了，所以E = 2，V = E = 2，两个值相等，因此执行赋值操作，将N的值赋值给i，最终得到的结果为3。在整过过程中始终没有使用到锁，却实现的线程的安全性。&lt;/p&gt;
&lt;p&gt;　　从上面的过程知道，cas会面临着两个问题，一个是当线程一直更新不成功的话，那么这个线程就一直处于死循环中，这样会非常耗费cpu的资源；另一种是ABA的问题，即对i =1进行+1操作后，再-1，那么此时i的值仍为1，而另外一个线程获取的E的值也是1，认为其他线程没有修改过i，然后进行的更新操作，事实上已经有其他线程修改过了这个值了，这个就是 A ---&amp;gt; B ---&amp;gt; A 的问题；&lt;/p&gt;
&lt;h2&gt;　　4.3、获取table对应的索引元素的位置&lt;/h2&gt;
&lt;p&gt;　　通过（n-1）&amp;amp; hash 的算法来获得对应的table的下标的位置，如果对于这条公式不是很理解的同学可以到： &lt;a href=&quot;https://www.noblogs.cn/rainple/blog/17853.html&quot; target=&quot;_blank&quot;&gt;jdk1.8源码分析-hashMap&lt;/a&gt; 博客中了解。&lt;/p&gt;
&lt;p&gt;　　tabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i)： 这个方法使用了java提供的原子操作的类来操作的，sun.misc.Unsafe.getObjectVolatile 的方法来保证每次线程都能获取到最新的值；&lt;/p&gt;
&lt;p&gt;　　casTabAt(Node&amp;lt;K,V&amp;gt;[] tab, int i,Node&amp;lt;K,V&amp;gt; c, Node&amp;lt;K,V&amp;gt; v): 这个方法是通过cas的方式来获取i位置的元素；&lt;/p&gt;
&lt;p&gt;　　4.4、扩容&lt;/p&gt;
&lt;p&gt;　　- 如果新增节点之后，所在的链表的元素个数大于等于8，则会调用treeifyBin把链表转换为红黑树。在转换结构时，若tab的长度小于MIN_TREEIFY_CAPACITY，默认值为64，&lt;/p&gt;
&lt;p&gt;　　则会将数组长度扩大到原来的两倍，并触发transfer，重新调整节点位置。（只有当tab.length &amp;gt;= 64, ConcurrentHashMap才会使用红黑树。）&lt;br/&gt;　　- 新增节点后，addCount统计tab中的节点个数大于阈值（sizeCtl），会触发transfer，重新调整节点位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Adds to count, and if table is too small and not already
     * resizing, initiates transfer. If already resizing, helps
     * perform transfer if work is available.  Rechecks occupancy
     * after a transfer to see if another resize is already needed
     * because resizings are lagging additions.
     *
     * @param x the count to add
     * @param check if &amp;lt;0, don't check resize, if &amp;lt;= 1 only check if uncontended
     */
    private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) &amp;lt; 0 ||
                (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                fullAddCount(x, uncontended);
                return;
            }
            if (check &amp;lt;= 1)
                return;
            s = sumCount();
        }
        if (check &amp;gt;= 0) {
            Node&amp;lt;K,V&amp;gt;[] tab, nt; int n, sc;
            while (s &amp;gt;= (long)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != null &amp;amp;&amp;amp;
                   (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc &amp;lt; 0) {
                    if ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex &amp;lt;= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　get操作中没有使用到同步的操作，所以相对来说比较简单一点。通过key的hashCode计算获得相应的位置，然后在遍历该位置上的元素，找到需要的元素，然后返回，如果没有则返回null：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &amp;lt;p&amp;gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; int n, eh; K ek;
        int h = spread(key.hashCode());
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (e = tabAt(tab, (n - 1) &amp;amp; h)) != null) {
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek)))
                    return e.val;
            }
            else if (eh &amp;lt; 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) {
                if (e.hash == h &amp;amp;&amp;amp;
                    ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　欢迎大家关注公众号： 【java解忧杂货铺】，里面会不定时发布一些技术博客；关注即可免费领取大量最新，最流行的技术教学视频：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201904/1519364-20190421234621966-854384954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201904/1519364-20190421234637254-1446890917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201904/1519364-20190421234659284-1128950389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201904/1519364-20190421234717996-1409779382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Apr 2019 15:49:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>ConcurrentHashMap这个类在java.lang.current包中，这个包中的类都是线程安全的。ConcurrentHashMap底层存储数据的结构与1.8的HashMap是一样的，都是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainple/p/10708436.html</dc:identifier>
</item>
<item>
<title>第八周助教总结 - 金玉末时</title>
<link>http://www.cnblogs.com/MS1999/p/10747813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MS1999/p/10747813.html</guid>
<description>&lt;h4 id=&quot;本周心得&quot;&gt;本周心得&lt;/h4&gt;
&lt;h5 id=&quot;助教博客链接&quot;&gt;1.助教博客链接：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/MS1999/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/MS1999/&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;本周点评的作业数量327人未提交&quot;&gt;2.本周点评的作业数量：32（7人未提交）&lt;/h5&gt;
&lt;h5 id=&quot;优秀博客&quot;&gt;优秀博客：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xqldc/p/10723960.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/xqldc/p/10723960.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/hlywzj/p/10725663.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/hlywzj/p/10725663.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/521-PENG/p/10734945.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/521-PENG/p/10734945.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这几篇作业格式清晰，完成的不错，体现了思考与探索，&lt;/p&gt;
&lt;h5 id=&quot;本周落实的改进计划和优化&quot;&gt;3.本周落实的改进计划和优化&lt;/h5&gt;
&lt;p&gt;只想对看到这篇博客的同学们说：对自己负责，老师教的已经非常好了，如有未弄懂的请及时查找资料或者向同学请求帮助，程序的世界的理念有一条——开源，思路共享，自己独立创造确实珍贵，但人不可能什么都会，总会有一些自己不擅长的地方，要根据自己的原因以及不足来进行分析，希望你们再去看一下老师发的那个关于师生关系的博客，仔细思考。&lt;/p&gt;
&lt;h5 id=&quot;下周的计划改进&quot;&gt;4.下周的计划改进&lt;/h5&gt;
&lt;p&gt;继续坚持点评，分析&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 15:49:00 +0000</pubDate>
<dc:creator>金玉末时</dc:creator>
<og:description>本周心得 1.助教博客链接： 2.本周点评的作业数量：32（7人未提交） 优秀博客： 这几篇作业格式清晰，完成的不错，体现了思考与探索， 3.本周落实的改进计划和优化 只想对看到这篇博客的同学们说：对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MS1999/p/10747813.html</dc:identifier>
</item>
<item>
<title>.NetCore&amp;Linux&amp;Docker&amp;Portainer踩坑历险记 - balahoho</title>
<link>http://www.cnblogs.com/hohoa/p/10743552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hohoa/p/10743552.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近有一个云服务器和数据库的迁移任务，踩坑爬坑无数次，觉得必须要记录一下。大家瓜子花生准备好，听我慢慢讲故事#手动笑哭#。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;故事背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公司是做电商业务的，在天猫有几家旗舰店数据量也很大。阿里有一个称为聚石塔的平台，专门给这些ISV提供各种云资源，强制绑定了一些业务，原本我们在聚石塔中有一台ECS和一台RDS部署在华东杭州节点，本月初突然收到阿里的邮件说是要整体迁移到张北节点，华东节点将会在9月底全部停止服务，并附带发了一份迁移文档，要我们尽快迁移。好在我们用到的资源不多，最初觉得迁移过程并不会太复杂，实际还是太天真了。像我这样只有一台服务器和一台数据库的用户迁移过程都谓之艰辛，对于那些有几十甚至上百实例的ISV，那真是欲哭无泪了。每天看着迁移群里大家的各种吐槽、抱怨、焦急、无可奈何，还有那几位一整天都在被艾特的阿里技术支持，说起来都是泪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是接下来制定好迁移计划，发邮件购买要用到的资源，等过了两天东西到位，就撸起袖子开干了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;忘了说了，这些东西原先是由另外一位同事负责，然而年后他就开溜了，上级指示我扛过大旗（guo）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;开胃菜&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的RDS是SQL Server 08 R2版本，阿里在迁移通知中专门提到了这个产品，而且用到了重要提示字样，大意是说微软已经对这个版本的数据库停止了安全更新，所以张北节点已经不再售卖这个版本的实例，要先在当前节点完成版本升级后再迁移。看了下他的迁移手册，觉得异常复杂和危险重重，于是果断放弃官方方案，决定在张北节点买好2016版本数据库，直接切换数据推送，后来找阿里的技术支持咨询了这个方案，也表示可以执行。当然了，我能这样做是有一个前提的，我们的这个库是只读库，用来接收阿里的数据推送然后给业务系统查询，可以理解为只是一个过渡不存储实际的业务数据，对安全性要求不高，就算丢失也能通过淘宝开放平台的API去查询。如果是业务库，那就只能老老实实的按官方文档摸着石头过河了，看群里的反馈，这道开胃菜不好吃，我也算是幸运跳过了第一个坑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;初进坑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RDS处理完毕，那就着手开始折腾服务器，这是一台Linux的机器，系统是Centos7，主要跑了3个服务：上文提到的RDS数据查询API（一个dotnetcore2.1的程序）、Rabbitmq实例和它的管理工具、Portainer，由Docker统一管理，而Docker又由Portainer来管理。按照官方文档，先在原服务器上创建镜像，经过漫长的等待（大概40分钟吧，有的人反映等了大半天最后生成失败的，心态崩…），然后把镜像复制到张北节点，然后通过镜像生成实例，按理说新机器和原机器是完全一样的，各项服务都应该运行正常，并且专门找技术支持确认了，可实际真的不是这样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚石塔的服务器只开放30001-30005这几个端口，于是尝试访问一下Portainer所在的30003端口。浏览器输入地址再回车，等了几十秒后显示超时无法访问，一脸懵逼。Ping了一下服务器IP，没毛病，又登录服务器查看docker和container的运行状态以及端口映射，都没问题，又查看端口监听和防火墙，还是正常，二脸懵逼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421012314640-614878568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查一下container的日志，提示运行正常，三脸懵逼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002054699-2120468095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的招已经用完了，没办法转向群里咨询技术支持，回复说这几个端口要走工单申请开通，WTF……老实写工单提交再到群里艾特帮忙快点处理，又陷入漫长的等待中，当时大概2点钟的样子。下午5点多工单状态更新了说正在转给技术处理请耐心等待，然后，就没有然后了接着等，到7点还是没消息决定先下班。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二天上班发现还是没有消息，又去群里艾特技术支持，几分钟后回复叫我去给ECS绑定一个安全组，照做后再次访问30003端口依然不行，长叹一口气。又尝试访问了一下webapi所在的30001端口，神奇般的成功了#手动黑人问号脸#。咨询了公司运维，教我几个命令简单排查了下，后来因为太忙没回复我了，后来又一顿百度谷歌无果，陷入僵局。心理暗自把这个锅丢给了阿里，觉得是他们哪里配置有问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002144464-1797044976.gif&quot; alt=&quot;&quot; width=&quot;204&quot; height=&quot;204&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事情不能就这样僵着啊，Portainer起不来程序不能更新，于是打算直接在宿主机上跑一下修改后的dotnetcore程序看数据库访问是否正常。按照微软文档安装对应版本的SDK：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421012205106-1129394463.png&quot; alt=&quot;&quot; width=&quot;1113&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装好后把发布文件上传到服务器，然后用dotnet命令启动了程序，一切正常。访问我的测试入口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;locahost:5000/api/values/testdb/123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到返回了数据库的测试数据，信心重拾。回过头重新折腾docker，发现docker死活起不来了，囧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421012136745-1765088399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421012114138-2097157348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421012041055-1352939901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拿着错误信息又是一顿百度谷歌，不断的照网上改配置重启系统，几个小时过去依然不行，决定卸载docker重装。于是依次执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum remove docker*&lt;span&gt;

reboot

yum install docker

docker version

systemctl start docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然而启动的时候问题依旧，又是长叹一口气。仔细回想了一下，只有yum update对系统做了大的改动，难道是这个问题么？不知不觉又到了晚上7点多，脑子懵的很决定先下班第二天接着搞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真所谓一波未平一波又起。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;再进坑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;早上到公司和微信群的小伙伴吐糟着遭遇，大家劝我重装系统，我一边发着捂脸笑哭的表情，一边默默地上聚石塔后台点了磁盘初始化，docker启动不了的问题就算翻篇了，一切从头再来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依然还是端口的问题，实在没辙了只有给阿里提工单问为什么端口不通，阿里工程师先后叫我排查了iptables、端口监听情况、清除iptables等等还是不行，最后要了我的服务器账号上去排查，在工单中看到阿里的工程师晚上11点多还在帮我排查问题，也真不容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421011924002-2062378243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;终于，在阿里后面的回复中事情迎来了转机，给了我非常大的提示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421011954772-1736180794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从中我捕捉到了2个重要信息，一个是容器的IP，一个是路由解析问题。我马上百度如何查容器的IP地址，然后试着去ping容器的IP，发现30001端口绑定的容器（172.22.0网段）正常，30003端口绑定的容器（192.168.0网段）无法访问，那么这就说明是宿主机和容器网络不通导致的问题。又查看了系统的路由表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002551009-1145893886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个路由表有个奇怪的现象，就是192.168.0这个网段指向了2个不同的网卡，分别是eth0和docker0。我知道，eth0是宿主机默认的网关，docker0是docker启动时自动创建的虚拟网关，但是还不清楚这样的配置会有什么影响，于是百度了一下Linux路由的详细介绍，得知相同的配置会有优先级的问题，又尝试着删除eth0的配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
route del -net 192.168.0.0 netmask 255.255.255.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次用公网访问30003端口，成功了！！！终于看到了熟悉的页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421010543688-287475544.png&quot; alt=&quot;&quot; width=&quot;989&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;没那么简单&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以为事情就此告一段落后面都是平坦大道，想不到问题又来了。通过docker run我新镜像后发现容器总是自动退出，于是寻找各种让容器持续运行的办法，一阵折腾没有效果，去微信群问小伙伴，问我是不是程序抛异常了，我顿时一种柳暗花明的感觉，立马查看容器日志：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker logs topapi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;果然是报错了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002727509-1653643628.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然，是说我的framework版本不对，但是我的dockerfile中确实引入的2.1版本运行时：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.1&lt;span&gt;-runtime

&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /app

&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app

&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 5000 80

&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;, &quot;DRP.API.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;退一万步说，宿主机我也已经安装过SDK，而且直接在宿主机上运行都是可以的，为什么通过docker来运行就挂了，百思不得解。只能按照提示中的信息排查是不是少装了什么组件，一阵yum install下来还是失败：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002804753-732202702.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;去广州微软.net俱乐部的微信群请教别人，两位大佬给我分析解答了一下，一位说是我的dockerfile在copy文件时漏了一些引用文件，要我重新修改dockerfile，不过经过多次调整测试依然无效，不得不采用第二位的办法，就是把运行时改为2.2版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421002818926-1356968979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改dockerfile为如下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 添加基础镜像
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.2&lt;span&gt;-aspnetcore-runtime

#容器中系统的工作空间
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app

#拷贝当前文件夹下的文件到容器中系统的工作空间
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /app

#设置Docker容器对外暴露的端口
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 5000 80&lt;span&gt;

#运行应用程序
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;, &quot;DRP.API.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;重新打包镜像，然后run起来，这次一切都是那么的自然，docker ps查看容器已经状态是up了。欣喜若狂，以为即将看到胜利的曙光，接着用浏览器打开我的测试入口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://xxx.xxx.xxx.xxxx:30001/api/values/testdb/123&quot;&gt;http://xxx.xxx.xxx.xxx:30001/api/values/testdb/123&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尴尬的报了500，心中万马奔腾….&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次学机灵了，第一时间docker logs，发现是数据库报错了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
fail: Microsoft.AspNetCore.Server.Kestrel[&lt;span&gt;13&lt;/span&gt;&lt;span&gt;]
      &lt;/span&gt;=&amp;gt; ConnectionId:0HLM4DDINAGJC =&amp;gt; RequestId:0HLM4DDINAGJC:&lt;span&gt;00000001&lt;/span&gt; RequestPath:/api/values/testdb/&lt;span&gt;123&lt;/span&gt;&lt;span&gt;
      Connection id &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0HLM4DDINAGJC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Request id &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0HLM4DDINAGJC:00000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: An unhandled exception was thrown by the application.
SqlSugar.UtilExceptions: English Message : Connection open error . A network&lt;/span&gt;-related or instance-specific error occurred &lt;span&gt;while&lt;/span&gt; establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name &lt;span&gt;is&lt;/span&gt; correct and that SQL Server &lt;span&gt;is&lt;/span&gt; configured to allow remote connections. (provider: TCP Provider, error: &lt;span&gt;40&lt;/span&gt; -&lt;span&gt; Could not open a connection to SQL Server)
Chinese Message :  连接数据库过程中发生错误，检查服务器是否正常连接字符串是否正确，实在找不到原因请先Google错误信息：A network&lt;/span&gt;-related or instance-specific error occurred &lt;span&gt;while&lt;/span&gt; establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name &lt;span&gt;is&lt;/span&gt; correct and that SQL Server &lt;span&gt;is&lt;/span&gt; configured to allow remote connections. (provider: TCP Provider, error: &lt;span&gt;40&lt;/span&gt; -&lt;span&gt; Could not open a connection to SQL Server).
   at SqlSugar.AdoProvider.GetDataReader(String sql, SugarParameter[] parameters)
   at SqlSugar.QueryableProvider`&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.GetData[TResult](KeyValuePair`&lt;span&gt;2&lt;/span&gt;&lt;span&gt; sqlObj)
   at SqlSugar.QueryableProvider`&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;._ToList[TResult]()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很明显是数据库连接不上，检查连接字符串，没毛病，再次进入僵局。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正在苦恼时，突然想起前面删掉的那条路由，尝试重启网络恢复路由：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service network restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次访问测试地址，确实成功了。可问题又进入了死循环，容器内的应用无法访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;终见天日&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过以上的种种分析后，最终把问题定在了路由这儿。既然是因为同一网段有2个网关，那么我修改一下docker的默认网段不就可以了吗？再次面向百度编程，得到两种方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种方案，创建新的的网关和路由，然后分配给docker：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service docker stop

ip addr add &lt;/span&gt;192.168.1.1/24&lt;span&gt; dev bridge0

ip link set dev bridge0 up

vim &lt;/span&gt;/etc/docker/daemon.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;加上&lt;strong&gt;&quot;bridge&quot;: &quot;bridge0&quot;&lt;/strong&gt;节点并保存退出，再重启docker：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service docker start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种方案，直接修改docker0的默认网段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service docker stop

vim &lt;/span&gt;/etc/docker/daemon.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;加上&lt;strong&gt;&quot;bip&quot;: &quot;192.168.1.1/24&quot;&lt;/strong&gt;节点并保存退出，再重启docker即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我这里采用第二种方式，修改后的路由表为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421003059054-1253214752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新访问各种服务，全部都正常运行，到此总算是拨开云雾见青天。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有个小细节不知大家是否发现，也是我当时存在的一个疑惑，就是前面有提过两个容器的网段不一样，按理说通过docker run来的容器应该都是相同的网段，为什么会这样呢？后来在折腾Portainer的时候找到了这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Portainer是一款docker管理工具，简而言之的说就是把用命令操作的东西可视化，当然功能远不止这些。Portainer中有一个Stack功能，我并不清楚这是干什么用的，只是看到旧的Portainer中的容器绑定了一个stack所以想依葫芦画瓢也搞一个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421011843513-1631052499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是拿stack的配置文件新创建一个，没想到居然报错，提示已存在相同名称的容器。我马上意识到这个特殊的容器应该是通过stack创建，我删掉已存在的容器再次创建stack，这次成功了。出于好奇，仔细分析了stack的配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421003122937-1184496978.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现里面主要是定义了镜像名、容器名、网络模式、端口映射这些，而其中vhnet这个网络配置让我很感兴趣，转而查看docker已经配置好的网关：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614524/201904/614524-20190421011809615-1558244852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到这里，一种恍然大悟的感觉，你懂的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外，从前任留下的文档里可以知道，stack有一种类似热更新的功能，修改配置文件中的镜像名后update stack就能实现对应的容器更新，不用起新的容器，这点确实很不错。更多强大的功能日后也会慢慢学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的收获&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过前面几天的折腾，我更加熟悉了docker的各种基本操作和配置，也学会了使用新的命令，像docker inspect查看容器信息、docker attach进入容器内部，也加深了在Linux上排查问题的思路理解，学到了新的操作命令。也实际使用docker在Linux上部署了一次dotnetcore的生产环境，收获颇丰。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;遗留的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;1、&lt;span&gt;    &lt;/span&gt; yum update后到底经历了什么让docker跪地不起，报错原因至今没搞明白。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;2、&lt;span&gt;   &lt;/span&gt; 为什么2.1的dotnetcore程序在2.1运行时跑不起来，换成2.2版本就可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、stack是怎么实现修改镜像后容器就能生效的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有知道的大佬还请多多指导。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表面上全篇都在讲才踩坑的事，但追根究底还是因为自己在Linux方面的知识欠缺和经验不足。还是那句话，多踩坑，会让你记忆深刻，会让你学到意想不到的东西，会让你的身体变得足够大，下次碰到坑能一脚踏过去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;故事讲完了，大家周末愉快~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>balahoho</dc:creator>
<og:description>最近有一个云服务器和数据库的迁移任务，踩坑爬坑无数次，觉得必须要记录一下。大家瓜子花生准备好，听我慢慢讲故事#手动笑哭#。 故事背景 公司是做电商业务的，在天猫有几家旗舰店数据量也很大。阿里有一个称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hohoa/p/10743552.html</dc:identifier>
</item>
<item>
<title>JavaWeb学习路线 - 霖江</title>
<link>http://www.cnblogs.com/zhlinj/p/10747744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhlinj/p/10747744.html</guid>
<description>&lt;p&gt;  Java web，是用Java技术来解决相关web互联网领域的技术综合。Web包括：web服务器和web客户端。Java在客户端的应用有Java applet，不过使用很少。Java在服务器端的应用非常的丰富，比如Servlet，JSP和第三方框架等等。java技术对Web领域的发展注入了强大的动力。（摘自搜狗百科）&lt;/p&gt;
&lt;p&gt;  Web（World Wide Web）即全球广域网，也称万维网，它是基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet查询和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网络结构。（摘自搜狗百科）&lt;/p&gt;
&lt;p&gt;JavaWeb三大组件：&lt;/p&gt;
&lt;p&gt;Servlet       Java编写的服务器端程序&lt;/p&gt;
&lt;p&gt;                   Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。&lt;/p&gt;
&lt;p&gt;                    这个过程为： &lt;/p&gt;
&lt;p&gt;                                         1.客户端发送请求至服务器端；&lt;/p&gt;
&lt;p&gt;                                        2.服务器将请求信息发送至 Servlet；&lt;/p&gt;
&lt;p&gt;                                        3.Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；&lt;/p&gt;
&lt;p&gt;                                        4.服务器将响应返回给客户端。&lt;/p&gt;
&lt;p&gt;                   接受请求  相应数据&lt;/p&gt;
&lt;p&gt;Filter          中文意思过滤器    拦截请求 对responset进行拦截检查&lt;/p&gt;
&lt;p&gt;                   Filter 不是一个servlet，它不能产生一个response，它能够在一个request到达servlet之前预处理request，也可以在response离开servlet时处理response。&lt;/p&gt;
&lt;p&gt;                   过程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;                            1.在servlet被调用之前截获；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;                            2. 在servlet被调用之前检查servlet request;&lt;/p&gt;
&lt;p&gt;                            3. 根据需要修改request头和request数据；&lt;/p&gt;
&lt;p&gt;                            4. 根据需要修改response头和response数据；&lt;/p&gt;
&lt;p&gt;                            5. 在servlet被调用之后截获.&lt;/p&gt;

&lt;p&gt;Listener        我也不知道干嘛的&lt;/p&gt;
&lt;p&gt;JavaWeb学习路线：&lt;/p&gt;
&lt;p&gt;一：入门阶段&lt;/p&gt;
&lt;p&gt;学习目标：熟悉java程序员（rukeng）&lt;/p&gt;
&lt;p&gt;1.理解JDK，JVM，JRE，安装IDEA&lt;/p&gt;
&lt;p&gt;2.java基础语法&lt;/p&gt;
&lt;p&gt;3.理解类和对象，继承、封装、多态，抽象，接口，内部类，包，线程，自动装箱与拆箱等概念&lt;/p&gt;
&lt;p&gt;4.java核心编程，文件操作，流处理，多线程操作，序列化和反序列化，异常处理&lt;/p&gt;
&lt;p&gt;5.框架底层原理，反射机制，注解，泛型，配置文件解析设计模式&lt;/p&gt;
&lt;p&gt;6.JDBC与数据库基本语法知识：JDBC规范、MySQL，Oracle，SQL Server，JDBC封装，事务管理&lt;/p&gt;
&lt;p&gt;熟记API，非常熟悉包：io、lang（核心包）、until、sql、servlet；线程、异常、反射、泛型&lt;/p&gt;
&lt;p&gt;二：提高阶段&lt;/p&gt;
&lt;p&gt;学习目标：java初级软件工程师&lt;/p&gt;
&lt;p&gt;7.前段基础：HTML、CSS、JavaScript，jQuery，AJAX&lt;/p&gt;
&lt;p&gt;8.前段框架：MUI、LaYui&lt;/p&gt;
&lt;p&gt;9.数据绑定：Vue.js&lt;/p&gt;
&lt;p&gt;三：加强阶段&lt;/p&gt;
&lt;p&gt;学习目标：Java中级软件工程师&lt;/p&gt;
&lt;p&gt;10.javaweb三大组件：Servlet、Filter、Listener，与JSP动态页面&lt;/p&gt;
&lt;p&gt;11.框架：Spring框架、SpringMVC框架、MyBatista框架，Spring Boot&lt;/p&gt;
&lt;p&gt;四：进阶阶段&lt;/p&gt;
&lt;p&gt;学习目标：java高级软件工程师&lt;/p&gt;
&lt;p&gt;12.Java Web企业级开发技术&lt;/p&gt;
&lt;p&gt;13.Java Web分布式开发技术&lt;/p&gt;
&lt;p&gt;14.Java Web开源技术与框架&lt;/p&gt;
&lt;p&gt;五：高级阶段&lt;/p&gt;
&lt;p&gt;学习目标：Java系统构架师&lt;/p&gt;

&lt;p&gt;参考资料：潘亚老师的系统图，可以去潘亚老师的博客园参观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1643882/201904/1643882-20190421232729005-1229186038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另参考自：http://www.sohu.com/a/168762156_819383      搜狐号：Java学习交流&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>霖江</dc:creator>
<og:description>Java web，是用Java技术来解决相关web互联网领域的技术综合。Web包括：web服务器和web客户端。Java在客户端的应用有Java applet，不过使用很少。Java在服务器端的应用非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhlinj/p/10747744.html</dc:identifier>
</item>
<item>
<title>网络设备配置与管理（华为）基础系列 ：VLAN故障排除和GVRP - 悲催世界一雷</title>
<link>http://www.cnblogs.com/lilywhite/p/10747731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lilywhite/p/10747731.html</guid>
<description>&lt;p&gt;一、VLAN故障排除&lt;/p&gt;
&lt;p&gt;故障排除的三步骤：故障定位 → 分析故障 → 排除故障&lt;/p&gt;
&lt;p&gt;一般情况下，网络设备配置的故障有两种排错方式&lt;/p&gt;
&lt;p&gt;A．静态排错：主要靠display查看配置信息的方式进行&lt;/p&gt;
&lt;p&gt;在相关vlan下display this或display总配置文件&lt;/p&gt;

&lt;p&gt;扩展：对VLAN传输的流量进行监控：&lt;/p&gt;
&lt;p&gt;[Huawei] vlan vlan-id&lt;/p&gt;
&lt;p&gt;[Huawei-vlan-id] statistic enable   //开启VLAN的监控&lt;/p&gt;
&lt;p&gt;[Huawei] display vlan vlan-id statistic     //查看VLAN的流量信息&lt;/p&gt;
&lt;p&gt;[Huawei] display vlan vlan-id verbose       //查看VLAN的版本信息&lt;/p&gt;

&lt;p&gt;B．使用抓包软件（如Wireshark）分析流量的数据帧&lt;/p&gt;
&lt;p&gt;这种方法可以较为快速的定位故障点，从而分析故障原因（前提是要对数据包的协议有较为清晰的认识）&lt;/p&gt;

&lt;p&gt;二、GVRP&lt;/p&gt;
&lt;p&gt;如果在一个完整的网络拓扑环境中，有大量的交换机，那么交换机内的VLAN也经常随着需求的不同需要进行调整，如果说完全要靠管理员手工配置VLAN需要大量的时间和精力。&lt;/p&gt;
&lt;p&gt;而GVRP协议可以允许在少量的交换机上手动配置VLAN（静态VLAN），并自动传递到其他的交换机，从而在这些其余交换机上可以自动创建相应的VLAN（动态VLAN）。这样既可以提高配置效率，也大大降低了出错的概率。&lt;/p&gt;
&lt;p&gt;要启用GVRP，首先要保证主交换机中已经创建静态VLAN，同时需要先启用全局的GVRP，然后再到相应的trunk接口上启用GVRP协议。&lt;/p&gt;

&lt;p&gt;操作指引：&lt;/p&gt;
&lt;p&gt;主交换机：创建VLAN→开启全局GVRP→进入trunk口启用GVRP协议&lt;/p&gt;
&lt;p&gt;次交换机：开启全局GVRP→进入交换机级联的trunk口启用GVRP协议&lt;/p&gt;

&lt;p&gt;相关指令：&lt;/p&gt;
&lt;p&gt;[Huawei] gvrp   //开启全局GVRP&lt;/p&gt;
&lt;p&gt;[Huawei] interface GigabitEthernet0/0/1&lt;/p&gt;
&lt;p&gt;[Huawei-GigabitEthernet0/0/1] port link-type trunk&lt;/p&gt;
&lt;p&gt;[Huawei-GigabitEthernet0/0/1] port trunk allow-pass vlan all&lt;/p&gt;
&lt;p&gt;（tips：在GVRP中，为方便操作，trunk设置的允许列表通常为全部）&lt;/p&gt;
&lt;p&gt;[Huawei-GigabitEthernet0/0/1] gvrp      //在trunk接口中开启GVRP&lt;/p&gt;

&lt;p&gt;在使用GVRP时，要注意的是动态产生的VLAN是无法添加端口的，还是需要手动配置VLAN的。&lt;/p&gt;
&lt;p&gt;在删除VLAN时，只有把静态VLAN全部删除才能把对应的动态VLAN真正的从网络拓扑中的所有交换机上删除。&lt;/p&gt;

&lt;p&gt;有点难理解？举一个例子：&lt;/p&gt;
&lt;p&gt;有一个简单的网络拓扑，四台交换机S1~S4，S1和S4上各自连接着终端Srv1和Srv2，Srv1和Srv2所属的VLAN都是VLAN 10。&lt;/p&gt;
&lt;p&gt;如果要实现Srv1和Srv2之间的通信，那么需要将四台交换机都需要添加VLAN，这样显得比较麻烦了。&lt;/p&gt;
&lt;p&gt;如果此时用GVRP协议，只要将S1和S4创建相应的静态VLAN，其余的级联交换机做GVRP，这样大幅度节省了时间和精力&lt;/p&gt;
&lt;p&gt;（我这里只是举了一个VLAN的例子，在实际的生产环境中，VLAN可不仅仅只有一个。）&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 15:26:00 +0000</pubDate>
<dc:creator>悲催世界一雷</dc:creator>
<og:description>一、VLAN故障排除 故障排除的三步骤：故障定位 → 分析故障 → 排除故障 一般情况下，网络设备配置的故障有两种排错方式 A．静态排错：主要靠display查看配置信息的方式进行 在相关vlan下d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lilywhite/p/10747731.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(十三) 自定义Lookup组件（Single &amp; Multiple） - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/10746559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/10746559.html</guid>
<description>&lt;p&gt;上一篇简单的介绍了自定义的Lookup单选的组件，功能为通过引用组件Attribute传递相关的sObject Name，捕捉用户输入的信息，从而实现搜索的功能。&lt;/p&gt;
&lt;p&gt;我们做项目的时候，可能要从多个表中获取数据并且选择相关的记录（单选或者多选），也可能要获取不同的变量的值，不一定是Name字段，也有可能在对某个表进行关键字搜索基础上有额外的条件过滤。此公用组件在上述的背景下进行开发，安装地址如下：&lt;a href=&quot;https://login.salesforce.com/packaging/installPackage.apexp?p0=04t0I000000f7Ts&quot; target=&quot;_blank&quot;&gt;https://login.salesforce.com/packaging/installPackage.apexp?p0=04t0I000000f7Ts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装后访问https://&amp;lt;myDomain&amp;gt;.lightning.force.com/auradocs/reference.app， 将myDomain 换成你自己的domain，然后切换到Components -&amp;gt; aura -&amp;gt; c -&amp;gt; CommonLookUp 即可看到此组件的用法以及相关Attribute的描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421222815900-1062385101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Single Choise：&lt;/strong&gt;只需要声明一个类型为CommonLookUpController.SearchResultWrapper的变量，selectedRecord赋值这个变量即可。&lt;/p&gt;
&lt;p&gt;searchObjList 代表当前搜索数据要在Account &amp;amp; Contact两个表中搜索数据， searchFieldMapping2Object代表返回的数据的值取得是Account的Name字段值以及Contact的Name字段值。attribute中还有一些default值，比如singleOrMultiple,默认为true，即单选。searchGroup默认值为 ALL FIELDS，代表SOSL进行搜索时，匹配的模式为ALL FIELDS，其他的attribute的用法，可以自行查看文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;selectedRecord&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;CommonLookUpController.SearchResultWrapper&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:CommonLookup &lt;/span&gt;&lt;span&gt;searchObjList&lt;/span&gt;&lt;span&gt;=&quot;['Account','Contact']&quot;&lt;/span&gt;&lt;span&gt; searchFieldMapping2Object&lt;/span&gt;&lt;span&gt;=&quot;{'Account':'Name','Contact':'Name'}&quot;&lt;/span&gt;&lt;span&gt; selectedRecord&lt;/span&gt;&lt;span&gt;=&quot;{!v.selectedRecord}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller.js中只需要通过这个变量获取相关的属性即可。 objId对应这条数据的ID，objName对应返回这条数据对应表的API Name，objValue返回的是这条数据要搜索的值，上面设置的searchFieldMapping2Object中field为什么，即返回的什么值，objLabel返回的是这条数据对应表的label Name。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
console.log('objId : ' + component.get('v.selectedRecord'&lt;span&gt;).objId);
console.log('objName : ' + component.get(&lt;/span&gt;'v.selectedRecord'&lt;span&gt;).objName);
console.log('objValue : ' + component.get(&lt;/span&gt;'v.selectedRecord'&lt;span&gt;).objValue);
console.log('objLabel : ' + component.get(&lt;/span&gt;'v.selectedRecord').objLabel);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 用户搜索时的UI展示，列表中左面会标记记录属于哪个object，后面是记录检索的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421230431162-706995824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 选中后输出信息，可以根据想要的变量返回不同的结果信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421230504746-385125887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multiple Choise:&lt;/strong&gt;和 single模式的区别为需要声明类型为List的变量，并设置给selectedRecordList，singleOrMultiple设置为false即可，其他用法相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;selectedRecordList&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;List&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;c:CommonLookUp searchObjList=&quot;['Account','Contact']&quot; searchFieldMapping2Object=&quot;{'Account':'Name','Contact':'Name'}&quot; selectedRecordList=&quot;{!v.selectedRecordList}&quot; singleOrMultiple=&quot;false&quot;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller.js针对list进行迭代输出展示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt; component.get('v.selectedRecordList').length;i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; selectedRecord = component.get('v.selectedRecordList'&lt;span&gt;)[i];
        console.log(selectedRecord.objId);
        console.log(selectedRecord.objName);
        console.log(selectedRecord.objValue);
        console.log(selectedRecord.objLabel);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.针对选中的不同的数据，因为可能来自于不同的对象，所以当hover时，会展示当前记录对应的object的label信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421231358460-522865693.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. 搜索时，下面的展示数据仍然按照 object label + object value模式展示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421231437179-249222248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 获取数据的变量同single 模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201904/910966-20190421231531941-1401698642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此公用组件作为第一版还有很多不成熟的地方以及没有进行特别多的测试，欢迎大家下载测试。篇中或者代码中如果有错误的地方欢迎指出，有不懂的欢迎留言。如果小伙伴们觉得关于LookUp组件有需要强化的点，欢迎留言，集思广益，使组件公用型变得更强。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 15:24:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>上一篇简单的介绍了自定义的Lookup单选的组件，功能为通过引用组件Attribute传递相关的sObject Name，捕捉用户输入的信息，从而实现搜索的功能。 我们做项目的时候，可能要从多个表中获</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/10746559.html</dc:identifier>
</item>
<item>
<title>详解单例模式 - 站在山顶的人</title>
<link>http://www.cnblogs.com/Mzcc/p/10747692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mzcc/p/10747692.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于单例模式，话不多说，即程序运行时无论New了多少次，即内存中只有一个实例对象。即对象的HasHCode一致。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单例模式的两大类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、饿汉模式（即加载时就创建对象）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-1、直接实例化饿汉模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-2、静态代码块饿汉模式（即需要加载初始化配置的时候适用）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-3、枚举方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、懒汉式（延迟加载）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-1、单线程安全下的懒汉&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-2、多线程安全下的懒汉&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　-3、静态内部类的懒汉（安全）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1、直接实例化饿汉模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
   
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton SI=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getsingleton(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SI;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　单例模式必须保证自行创建，并且内部提供一个静态变量来保存这个唯一的对象，构造器私有化，即其他类内部中无法直接New当前的单例类，还需要提供一个对外获取实例的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;当前模式在加载类的字节码的时候当前类的实例就立即会被创建&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2、&lt;/strong&gt;静态代码块饿汉模式（即需要加载初始化配置的时候适用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;&lt;span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton2 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Singleton2 SI;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Properties properties=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      
&lt;span&gt;10&lt;/span&gt;             properties.load(Singleton2.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResourceAsStream(&quot;db.properties&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             String name = properties.getProperty(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             SI=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton2(name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton2(String name){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton2 getsingleton(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SI;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　当我们需要在类创建的时候初始化参数，并且加载某些配置文件的时候可以使用 静态代码块的方式，在创建实例的时候通过构造器来完成相关参数的初始化。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　3.枚举方式的单例，自JDK1.5之后，首先枚举类和普通类的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用enum定义的枚举类默认继承了java.lang.Enum类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;枚举类的构造器只能使用private&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;枚举类的每个实例必须在枚举类中显示的列出（,分隔   ；结尾） 列出的实例系统会自动添加public static final修饰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的枚举类都定义了一个values方法，该方法可以很方便的遍历所有的枚举值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在switch表达式使用枚举类对象作为表达式，case子句可以直接使用枚举的名字，无需添加枚举类作为限定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;枚举类对象的属性不能更改，所以要用private final修饰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;枚举类对象要在构造器中被赋值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作者：weirdowang&lt;/span&gt;&lt;br/&gt;&lt;span&gt;来源：CSDN&lt;/span&gt;&lt;br/&gt;&lt;span&gt;原文：https://blog.csdn.net/weirdowang/article/details/79970673&lt;/span&gt; &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
枚举方式的单例
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; SingEnum {
    SING;
    SingEnum(){

    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; info(){
        System.out.println(&lt;/span&gt;&quot;显示&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　是不是很简洁呢？ 确实如此，单例模式下 枚举方式的单例是最简洁的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　二、懒汉模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1、&lt;strong&gt;单线程安全下的懒汉&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single2;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    懒汉模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton singleton;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){
        System.out.println(&lt;/span&gt;&quot;创建&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getSingleton(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            singleton&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }


}&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;我们可以看出无论怎么样，当前的懒汉都是在调用的时候才被加载创建的，但是它只是在单线程的情况下是安全的为什么呢？ 现在有一个需求即多个线程对这个 单例进行访问构建对象，在构建对象的时候使当前线程短暂的休眠一下&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single2;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    懒汉模式测试线程不安全
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton2 singleton;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton2(){
        System.out.println(&lt;/span&gt;&quot;创建&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton2 getSingleton() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
            singleton&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton2();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    懒汉模式下的多线程不安全
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Singleton2 singleton1 &lt;/span&gt;=&lt;span&gt; Singleton2.getSingleton();
                System.out.println(singleton1);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Singleton2 singleton2 &lt;/span&gt;=&lt;span&gt; Singleton2.getSingleton();
                    System.out.println(singleton2);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        thread.start();
        thread2.start();
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;strong&gt;&lt;span&gt;　经过测试，多线程情况下这种是不安全的 为什么呢？  第一个线程进入 进去之后， 线程休眠100ms 在此期间，第二个线程也开始进去到了创建的方法，由于当前第一个线程正在休眠，所以当前单例为null ，然后第一个线程休眠结束，创建第一个对象，此后第二个线程还在if中，也相继创建对象，此时便构造成了线程不安全的懒汉单例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2、线程安全的懒汉单例（双端检索）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single2;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
懒汉模式 双端检索，避免了多次线程等待
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton4 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton4 singleton4;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton4() {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton4 getSingleton4() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton4 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (Singleton4.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton4 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);

                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    singleton4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton4();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton4;
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用synchronized 保证当前只能有一个线程进入 ，并且在外再次进行判断 若当前的单例已经被创建过了，避免了再次加锁，直接返回&lt;/span&gt; &lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;3、静态内部类的懒汉单例：（线程安全的）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.single2;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton5 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton5(){

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; demo{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton5 SINGLETON_5=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton5();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton5 singleton5(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; demo.SINGLETON_5;
    }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;也是懒汉模式最简单的单例实现，静态内部类不会随着外部类的初始化而初始化，并且内部类具有自己的类加载器，是安全的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如上便是单例模式的六种创建方式，欢迎大牛指正，源码放到群里了  另外也欢迎各位朋友们一起学习交流， qq群：956809929&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 21 Apr 2019 15:19:00 +0000</pubDate>
<dc:creator>站在山顶的人</dc:creator>
<og:description>关于单例模式，话不多说，即程序运行时无论New了多少次，即内存中只有一个实例对象。即对象的HasHCode一致。 单例模式的两大类 1、饿汉模式（即加载时就创建对象） -1、直接实例化饿汉模式 -2、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mzcc/p/10747692.html</dc:identifier>
</item>
<item>
<title>SQL Server AlwaysOn 集群 关于主Server IP与Listener IP调换的详细测试 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10747343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10747343.html</guid>
<description>&lt;h3&gt;1. 背景&lt;/h3&gt;
&lt;p&gt;SQL Server 搭建AlwaysOn后，我们就希望程序连接时使用虚拟的侦听IP（Listener IP），而不再是主Server 的IP。如果我们有采用中间件，则可以在配置中，直接用Listener IP 替换掉 Server IP，可有时候，我们不太确定，是否有些旧程序、不太常用的程序在使用。甚至在很多公司根本就没有使用中间件，这时候去修改每个应用、APP、程序的数据库连接配置，太难了。&lt;/p&gt;
&lt;p&gt;那么有没有其它好的方案呢？有一个---调换主Server IP与Listener IP，即将Server IP与Listener IP互换。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;测试目的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为减少因使用AlwaysOn的Listener IP而必须调整现有程式的工作，考虑测试把Listener IP改成原主Server IP。&lt;/p&gt;
&lt;p&gt;对调的好处：&lt;/p&gt;
&lt;p&gt;1）减少应用、APP、程序的数据库连接配置的修改。&lt;/p&gt;
&lt;p&gt;2) 外部接口(厂商、SAP、ETL、xDS、BI、MIS, etc)不用修改；如修改，沟通成本大。&lt;/p&gt;
&lt;p&gt;3) 不用担心有老旧程序未修改为调用Listener IP。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;strong&gt;测试环境&lt;/strong&gt;&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Node1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Cluster IP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Listener IP&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;168.172.40.112&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;168.172.40.113&lt;/td&gt;
&lt;td&gt;168.172.40.114&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;168.172.40.115&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;168.172.40.117&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Primary&lt;/p&gt;
&lt;p&gt; Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;SSMS 连接登入各IP显示如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421215943858-795770654.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4. &lt;/strong&gt;&lt;strong&gt;测试步骤&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（第一部分更新主节点的&lt;/strong&gt;&lt;strong&gt;server IP&lt;/strong&gt;&lt;strong&gt;为临时&lt;/strong&gt;&lt;strong&gt;IP，即将&lt;span&gt;40.112--&amp;gt;40.118&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1 &lt;/strong&gt;通过控制面板更新主Server IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421220143717-608224849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt; 更新前为40.112&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421220304586-316330919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; 更新后为40.118&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421220414693-923134230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt;  更新后查看状态如下（更新后，短暂不可访问，AG状态resolving。约15S自动恢复正常）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421220708121-710482276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时环境调整为：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Node1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Cluster IP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Listener IP&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;168.172.40.118&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;168.172.40.113&lt;/td&gt;
&lt;td&gt;168.172.40.114&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;168.172.40.115&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;168.172.40.117&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Primary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（第二部分更新&lt;/strong&gt;&lt;strong&gt;listener IP&lt;/strong&gt;&lt;strong&gt;为原主&lt;/strong&gt;&lt;strong&gt;server IP，即将 &lt;span&gt;40.117---&amp;gt;40.112&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 打开FailOver管理器---&amp;gt;Role---&amp;gt;Resources---&amp;gt;AGName---&amp;gt;Properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221442585-979400549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 6&lt;/strong&gt;  选中地址IP，单击，使Edit栏位变成活跃状态，点击Edit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421225339760-901204073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 7&lt;/strong&gt; 弹出警告，单击Yes选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221605832-1371711262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 8&lt;/strong&gt;  修改Listener IP&lt;/p&gt;
&lt;p&gt; 修改前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221655091-1412284810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221721069-1761680596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 9&lt;/strong&gt; 修改完毕，点击OK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421225458831-453864812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 10&lt;/strong&gt; 弹出警告，单击Yes选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221845304-583951676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 11&lt;/strong&gt; 修改后可用组Stop, AG状态为Resolving。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221917717-1382478987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 12&lt;/strong&gt; 重启AG Role。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201904/780228-20190421221947662-544324640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 13  &lt;/strong&gt;listener 修改完毕（117—&amp;gt;112）&lt;/p&gt;
&lt;p&gt;此时环境调整为：&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Node1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Cluster IP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Listener IP&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;168.172.40.118&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;168.172.40.113&lt;/td&gt;
&lt;td&gt;168.172.40.114&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;168.172.40.115&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;168.172.40.112&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Primary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;（第三部分更新原主的server的 IP由临时IP调整为Listener IP，即将 &lt;span&gt;40.118---&amp;gt;40.112&lt;/span&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 14&lt;/strong&gt; 参照step 1—&amp;gt;step 5,可把原主server IP由临时IP调整为Listener IP (118--&amp;gt;117)&lt;/p&gt;
&lt;p&gt;此时环境调整为：&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Node1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Node3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Cluster IP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Listener IP&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;168.172.40.117&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;168.172.40.113&lt;/td&gt;
&lt;td&gt;168.172.40.114&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;168.172.40.115&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;168.172.40.112&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Primary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Role:Secondary&lt;/p&gt;
&lt;p&gt;Availability Mode:Asynchronous Commit&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;strong&gt;5. 总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可以成功实现调换主Server IP与Listener IP。&lt;/p&gt;
&lt;p&gt;测试环境下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更改主Server IP为temp IP时，AG自动恢复正常状态需要耗时约15秒。&lt;/li&gt;
&lt;li&gt;更改Listener IP为原主Server IP时，需要手动重启一次AG Role，耗时约3~4秒。&lt;/li&gt;
&lt;li&gt;更改temp IP为原Listener IP，AG自动恢复正常状态需要耗时约15秒。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;正式环境下，可能需时要长一些，可能需要1~2分钟，甚至更长。&lt;/p&gt;
&lt;p&gt;所以，请在周末或假期等业务线操作不繁忙的时候进行调换作业，避免出现异常时无足够的处理时间。&lt;/p&gt;
&lt;p&gt;切换完成后，建议做两次auto-failover切换（最后恢复到辅Server还是辅Server），同时请支持部门的同学配合测试程序，确保真正发生Auto-failover时不出现问题。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Apr 2019 14:47:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>1. 背景 SQL Server 搭建AlwaysOn后，我们就希望程序连接时使用虚拟的侦听IP（Listener IP），而不再是主Server 的IP。如果我们有采用中间件，则可以在配置中，直接用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10747343.html</dc:identifier>
</item>
<item>
<title>pytest进阶之html测试报告 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-report.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-report.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;　　Pytest系列已经写了几篇文章了，也不知道对多少人有帮助，总之对于我自己来说该掌握的都已经掌握了，那么今天我们再来说说pytest如何生成一个完整的html测试报告，让你在吹牛逼的路上再多一份资本！废话不多说，进入正题！（咋就莫名其妙想起这句话了呢， 估计看文章看多了，貌似挺多人用这句话过度……）&lt;/p&gt;
&lt;p&gt;使用pytest-html插件生成测试报告&lt;/p&gt;
&lt;h3&gt;pytest-html生成报告&lt;/h3&gt;
&lt;p&gt;pytest是借助pytest-html插件生成测试测试报告， 不用自己编写生成报告代码。github源码地址 &lt;a href=&quot;https://github.com/pytest-dev/pytest-html&quot; target=&quot;_blank&quot;&gt;https://github.com/pytest-dev/pytest-html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;安装&lt;/h4&gt;
&lt;p&gt;与安装python第三方库一样使用pip命令-&amp;gt;pip install pytest-html，我这边是已经安装好了的，所以你看到的输出信息可能和我的不太一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421204658157-1572892164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证安装&lt;/p&gt;
&lt;p&gt;使用pip list 可以查看是否有pytest-html，如果有表示已经安装成功&lt;/p&gt;
&lt;h4&gt;生成报告&lt;/h4&gt;
&lt;p&gt;使用命令 pytest --html=reportname.html (这里的参数是测试报告的名称，注意前面是两个横杠)我们尝试一下 ！&lt;/p&gt;
&lt;h4&gt;效果&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421211814446-894761801.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;可以看到这个报告还是挺不错的，比unittest那个报告炫了很多！每一个case都可点开查看具体的运行信息！ 好了，大家可能发现你生成的测试报告和我这个貌似有哪里不一样？是的，没错，我这里多了描述信息你那里好像不存在，先不急。&lt;/p&gt;
&lt;h4&gt;错误用例截图&lt;/h4&gt;
&lt;p&gt;通常，我们希望测试用例失败的时候能够截取一张图片，这样我们可以知道哪里出了问题或者出现问题的大概位置，方便我们调试代码或者分析软件的bug，那么又该如何在这一份报告里面插入截图呢？&lt;/p&gt;
&lt;p&gt;上篇文章我们提到了conftest.py文件，那么我们现在就可以把失败截图的代码放到这个文件里面了(为什么放在这里，我想学会的同学应该知道，不知道的看前面文章吧)，看具体代码！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pytest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; py._xmlgen &lt;span&gt;import&lt;/span&gt;&lt;span&gt; html

_driver &lt;/span&gt;=&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试失败时添加截图和测试用例描述(用例的注释信息)&lt;/span&gt;
&lt;span&gt;
@pytest.mark.hookwrapper
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pytest_runtest_makereport(item):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;当测试失败的时候，自动截图，展示到html报告中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    pytest_html &lt;/span&gt;= item.config.pluginmanager.getplugin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    outcome &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;&lt;span&gt;
    report &lt;/span&gt;=&lt;span&gt; outcome.get_result()
    extra &lt;/span&gt;= getattr(report, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;extra&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [])

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; report.when == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; report.when == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        xfail &lt;/span&gt;= hasattr(report, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wasxfail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (report.skipped &lt;span&gt;and&lt;/span&gt; xfail) &lt;span&gt;or&lt;/span&gt; (report.failed &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; xfail):
            file_name &lt;/span&gt;= report.nodeid.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            screen_img &lt;/span&gt;=&lt;span&gt; _capture_screenshot()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; file_name:
                html &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;&amp;lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
                       &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra &lt;/span&gt;=&lt;span&gt; extra

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _capture_screenshot():
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;截图保存为base64&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _driver.get_screenshot_as_base64()

@pytest.fixture(scope&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; driver():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; _driver
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------------open browser------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    _driver &lt;/span&gt;=&lt;span&gt; webdriver.Firefox()

    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; _driver
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------------close browser------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    _driver.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意这个模块&lt;span&gt;from py._xmlgen &lt;span&gt;import &lt;span&gt;html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，我们网上看到大多数是使用 from py.xml import html,我使用这个模块时会报错，所以换成现在这个模块了(估计和python版本有关系，我用的3，3估计没有这个模块了)。&lt;/p&gt;
&lt;p&gt;好了, 现在我们在来执行一下我们的测试用例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421211759015-64143472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，失败用例有了图片了，而且很清晰。我用例断言的是登录失败时的错误提示信息是否正确(为了演示，我把用例里面期望值改了)，实际提示信息是‘账号和密码错误’和‘请输入账号’，但是我们期望的是‘账号和密码错’和‘请输入账’，很明显我们的软件是存在bug的，一目了然！是不是很实用……接下来我们再来看看如何添加描述信息的。&lt;/p&gt;
&lt;h4&gt;添加描述&lt;/h4&gt;
&lt;p&gt;正常情况下，我们的报告是没有描述信息这一项的，所以我们只能通过添加代码来实现了（描述信息就是我们用例函数上方的注释信息）。通过官方的文档说明，我们知道是可以添加和删除报告的table表的&lt;/p&gt;
&lt;p&gt;我们在上面的代码 &lt;span&gt;report.extra = &lt;span&gt;extra&lt;/span&gt;&lt;/span&gt; 后面添加这样一行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
report.description = str(item.function.&lt;span&gt;__doc__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并在文件中添加这两个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@pytest.mark.optionalhook
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pytest_html_results_table_header(cells):
    cells.insert(&lt;/span&gt;1, html.th(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

@pytest.mark.optionalhook
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pytest_html_results_table_row(report, cells):
    cells.insert(&lt;/span&gt;1, html.td(report.description))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们可以试着再次运行我们的测试用例，看看报告效果应该就和我的一样了。&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;大家可以把代码写一遍然后自己试试，是否会得到我们想要的报告，其实这篇文章并没有详细讲解代码编写过程，也没有详细说明哪段代码是用来干什么的，因为这些代码就是个模板，也是通用的，所以大家保存下来即可，以后编写项目的时候直接哪里用就可以了（作为一个python程序员，终极思想就是能简化就简化，能简单写代码就简单写代码，能copy就copy，嗯，就是这样!）&lt;/p&gt;
&lt;p&gt;使用allure2生成测试报告&lt;/p&gt;
&lt;h3&gt;allure2生成报告&lt;/h3&gt;
&lt;p&gt;这个就厉害了，我本人觉得这个工具真的是超级牛逼，生成的报告也超级炫酷。实际上它是一个report框架，支持各种语言的各种测试框架，而且可以集成到jenkins上使用，虽然我还没试过，听说的哈！&lt;/p&gt;
&lt;h4&gt;1.安装allure&lt;/h4&gt;
&lt;p&gt;github上下载最新版本&lt;a href=&quot;https://github.com/allure-framework/allure2/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/allure-framework/allure2/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421220118194-2032991939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.解压&lt;/h4&gt;
&lt;p&gt;下载完后解压到我们项目根目录下，也就是需要运行pytest代码的目录下。下面是我的项目根目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421220308033-1450415464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.安装pytest-allure-adaptor插件&lt;/h4&gt;
&lt;p&gt;pip install pytest-allure-adaptor&lt;/p&gt;
&lt;h4&gt;4.生成xml格式报告&lt;/h4&gt;
&lt;p&gt;在我们需要运行用例的目录下执行 pytest -s -q --alluredir report(这是个文件夹名字，可以自己指定位置，不指定默认生成在当前目录下)&lt;/p&gt;
&lt;h4&gt;5.添加环境变量&lt;/h4&gt;
&lt;p&gt;把allure-2.10.0\bin目录添加到环境变量，当然你也可以不添加，我们添加环境变量的目的是可以在任意位置执行bin目录下allure.bat脚本&lt;/p&gt;
&lt;h4&gt;6.运行allure生成报告&lt;/h4&gt;
&lt;p&gt;前面我们已经通过这个命令pytest -s -q --alluredir report 生成了xml格式的报告，保存在了report下，接着我们执行命令allure generate &lt;span&gt;report&lt;/span&gt;/o &lt;span&gt;report&lt;/span&gt;/html，第一个report就是指定之前xml报告的目录，后面的report也可以自己指定在哪个目录生成最终的html报告，我们按下面的路径找到我们的报告，看下生成的报告效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421223253996-794820846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;效果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201904/1421063-20190421223340791-27305518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个报告看起来真的很炫酷，而且左边的菜单都可以点开，里面记录了们的用例执行的情况，好了大家试试吧！&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;主要内容&lt;/p&gt;
&lt;p&gt;1.pytest-html插件生成测试报告，及用例失败时如何截取图片添加到报告里，如何添加用例描述到报告里&lt;/p&gt;
&lt;p&gt;2.如何使用allure生成测试报告&lt;/p&gt;
&lt;p&gt;以上两种生成测试报告的方式，希望可以帮到大家，并把这些技能运用到我们实际的工作当中！&lt;/p&gt;
&lt;p&gt;ps：本人qq 281754043 qq群：878565760&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 14:44:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 Pytest系列已经写了几篇文章了，也不知道对多少人有帮助，总之对于我自己来说该掌握的都已经掌握了，那么今天我们再来说说pytest如何生成一个完整的html测试报告，让你在吹牛逼的路上再多一份</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-report.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之ArrayBlockingQueue源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ArrayBlockingQueue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ArrayBlockingQueue.html</guid>
<description>[unable to retrieve full-text content]ArrayBlockingQueue的实现方式？ ArrayBlockingQueue是否需要扩容？ ArrayBlockingQueue有什么缺点？</description>
<pubDate>Sun, 21 Apr 2019 14:40:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ArrayBlockingQueue.html</dc:identifier>
</item>
</channel>
</rss>