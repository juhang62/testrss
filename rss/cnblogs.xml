<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在 ubuntu20 上安装 docker - 高方也</title>
<link>http://www.cnblogs.com/gaofangye/p/12812486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gaofangye/p/12812486.html</guid>
<description>&lt;h2 id=&quot;更新-apt-get-源&quot;&gt;更新 apt-get 源&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装包允许-apt-get-通过-https-使用仓库&quot;&gt;安装包允许 apt-get 通过 https 使用仓库&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加-docker-官方-gpg-key&quot;&gt;添加 docker 官方 GPG key&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置-docker-稳定版仓库&quot;&gt;设置 docker 稳定版仓库&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置完毕仓库，重新更新源&quot;&gt;设置完毕仓库，重新更新源&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更新上面的源时，可能会出现如下错误&quot;&gt;更新上面的源时，可能会出现如下错误&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;获取:1 http://security.ubuntu.com/ubuntu focal-security InRelease [107 kB]                                                                                                   
忽略:2 https://download.docker.com/linux/ubuntu focal InRelease                                                                                                                          
错误:3 https://download.docker.com/linux/ubuntu focal Release                                                                                              
  404  Not Found [IP: 13.225.103.65 443]
命中:4 http://mirrors.163.com/ubuntu focal InRelease                                                                                  
命中:5 http://mirrors.163.com/ubuntu focal-updates InRelease                                                                          
命中:6 http://mirrors.163.com/ubuntu focal-backports InRelease                                                 
忽略:7 http://dl.google.com/linux/chrome/deb stable InRelease                                     
命中:8 http://dl.google.com/linux/chrome/deb stable Release                  
命中:9 http://archive.ubuntukylin.com:10006/ubuntukylin trusty InRelease
正在读取软件包列表... 完成                                                                                                                                                                                  
E: 仓库 “https://download.docker.com/linux/ubuntu focal Release” 没有 Release 文件。
N: 无法安全地用该源进行更新，所以默认禁用该源。
N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;处理方法&quot;&gt;处理方法&lt;/h2&gt;
&lt;h3 id=&quot;在-etcaptsourcelist-文件中增加如下配置&quot;&gt;在 /etc/apt/source.list 文件中增加如下配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;再次更新源&quot;&gt;再次更新源&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可能会出现如下错误&quot;&gt;可能会出现如下错误&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;获取:1 http://security.ubuntu.com/ubuntu focal-security InRelease [107 kB]                                                                                                   
获取:2 https://download.docker.com/linux/ubuntu bionic InRelease [64.4 kB]                                                                                                               
命中:3 http://mirrors.163.com/ubuntu focal InRelease                                                                                                                                     
命中:4 http://mirrors.163.com/ubuntu focal-updates InRelease                                                                          
命中:5 http://mirrors.163.com/ubuntu focal-backports InRelease                                                                      
忽略:6 http://dl.google.com/linux/chrome/deb stable InRelease                                                                       
命中:7 http://dl.google.com/linux/chrome/deb stable Release                                       
命中:8 http://archive.ubuntukylin.com:10006/ubuntukylin trusty InRelease                          
忽略:10 https://download.docker.com/linux/ubuntu focal InRelease             
获取:11 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages [11.0 kB]
错误:12 https://download.docker.com/linux/ubuntu focal Release                  
  404  Not Found [IP: 13.225.103.32 443]
正在读取软件包列表... 完成                                                                                                                                                                                  
E: 仓库 “https://download.docker.com/linux/ubuntu focal Release” 没有 Release 文件。
N: 无法安全地用该源进行更新，所以默认禁用该源。
N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可以看到的是，上面的-11-已经是成功的，12-是错误的，这个时候，我们只需要其-etcaptsourcelist-中删除掉报错对应的内容&quot;&gt;可以看到的是，上面的 11 已经是成功的，12 是错误的，这个时候，我们只需要其 /etc/apt/source.list 中删除掉报错对应的内容&lt;/h3&gt;
&lt;h2 id=&quot;再次更新源-2&quot;&gt;再次更新源&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装最新的-docker-ce&quot;&gt;安装最新的 docker-ce&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get install docker-ce
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避免每次使用-docker-命令都需要加上-sudo&quot;&gt;避免每次使用 docker 命令都需要加上 sudo&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo usermod -a -G docker $USER
or
sudo usermod -aG docker $USER
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重启系统&quot;&gt;重启系统&lt;/h2&gt;
</description>
<pubDate>Fri, 01 May 2020 00:34:00 +0000</pubDate>
<dc:creator>高方也</dc:creator>
<og:description>步骤如下 更新 apt get 源 安装包允许 apt get 通过 https 使用仓库 添加 docker 官方 GPG key 设置 docker 稳定版仓库 设置完毕仓库，重新更新源 更新上面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gaofangye/p/12812486.html</dc:identifier>
</item>
<item>
<title>Blazor WebAssembly 3.2.0 正式起飞，blazor 适合你吗？ - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12774965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12774965.html</guid>
<description>&lt;p&gt;最近blazor更新很快，今天在官方博客上发布了&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/12765062.html&quot;&gt;Blazor WebAssembly 3.2.0&lt;/a&gt; RC：&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-release-candidate-now-available/&quot;&gt;https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-release-candidate-now-available/&lt;/a&gt; ，这是最后一次预览版了，功能开发都已经完成。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200501074403141-973434682.png&quot;&gt;&lt;img width=&quot;535&quot; height=&quot;480&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200501074403828-1822534477.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.19的微软Build大会上就正式发布了，我最近也在积极的研究学习blazor，在博客和公众号发了几篇最新版本发布的文章，在评论区还是微信群，有人问我，为什么你对blazor如此热情，这些同学都在使用vue/angular/react等前端框架，blazor正好是利用WebAssembly 开发的前端框架，编程语言从js变成了c#， 我觉得如果您对你的前端技术栈感到满意，你可以继续使用现在你所用的框架继续前进，也许blazor并不适合你 ，巧的是最近vue3 也发布了beta版本，vue3 要真正普及也是需要至少一年的时间，blazor 可以充分的吸收前端技术栈的精华，为我所用，我将在文章的末尾列出一些blazor 吸收前端技术圈的成果的开源项目。&lt;/p&gt;
&lt;p&gt;blazor适用于编写内部应用程序，企业应用开发人员开发的B2B和B2C的应用程序都适合使用blazor开发，现在已经有很多企业应用开发人员接受了JavaScript，还有许多企业开发人员没有，特别是winform，wpf 等开发人员，他们特别希望能够高效的的完成开发工作，这里面有很多的开发人员都很认同Sliverlight 是他们交付Web应用程序的捷径，一朝被蛇咬，十年怕井绳，有人认为blazor 只是 Silverlight vNext。我们为什么要相信微软这次不会杀死它？这种观点可以理解，但是将blazor 的未来与Sliverlight的过去混为一谈是荒谬的。&lt;/p&gt;
&lt;p&gt;Silverlight是浏览器插件模型的牺牲品。2010年Flash是浏览器上非常流行的插件，史蒂夫-乔布斯（Steve Jobs）杀死了他，iOS设备上不支持Flash，当时Silverlight 也是如日中天，微软亲手杀死了它，拥抱了Html5这种无插件模型，相比之下，blazor是在WebAssembly标准之下的现代浏览器中运行，每个主流浏览器（IE11除外），甚至是iOS设备上的Safari 都支持blazor，这里要吐槽下微信里面的哪个浏览器貌似支持不太好。我们可以将WebAssembly视为在JavaScript运行所在的沙箱中运行的二进制编译代码，blazor 正式借助于WebAssembly 实现了将.NET 运行时运行在浏览器中。这个运行时处理 JavaScript 互操作，并提供基本服务（如垃圾回收）和更高级别的功能（布局、路由和用户界面小部件等）。换句话说，blazor使用了一个驻留在另一个虚拟机中的虚拟机，堪称《盗梦空间》级别的悖论，也是一种在浏览器中运行非 JavaScript 应用程序框架的巧妙方法。&lt;/p&gt;
&lt;p&gt;运行时使得blazor 和 WebAssembly 上运行的其他语言与众不同，MonoCLR 编译为WebAssembly。任何.NET Standard 2.1的代码都可以在上面运行，这样就可以把.NET生态的大量库带到前端开发，其他的语言只实现了直接编译为WebAssembly，blazor当前利用WebAssembly 的一个独特创新，据我所知，还没有一个类似于blazor这样的WebAssembly运行时存在。&lt;/p&gt;
&lt;p&gt;blazor 真正是一个组件模型，组件模型也很优雅，blazor的绑定模型也很容易理解。事件模型和标准的C# 一样，随着诸如DevExpress、Telerik、Radzen、Syncfusion等控件厂商提供了大量的控件，企业应用开发人员有理由开始blazor之旅。&lt;code&gt;InfoQ的一篇文章《&lt;a href=&quot;https://www.infoq.cn/article/po1Eiy9vERsOUtHEyxtg&quot;&gt;Mono 现状与未来： 从 Xamarin 到 WebAssembly、Blazor 及.NET 5&lt;/a&gt;》有助于大家理解blazor和.NET的关系。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;我这里也期望JavaScript的开发同学一起来使用这项创新的前端开发框架，人们经常说，WebAssembly 并不是用来代替 JavaScript 的。但这句话对所有革命性平台都是一样的。JavaScript 当初并不是要取代嵌入浏览器的 Java。Web 应用程序并非旨在替代桌面应用。但一旦能做到这些，它们必然会走上那条路。 在社区也出现了大量的blazor 开源项目，这项开源项目都是急需前端开发同学的参与：&lt;/code&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;开源项目 ant-design-blazor，目标是成为Ant Design官方认可的Blazor实现，并丰富Blazor生态&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/ElderJames/ant-design-blazor&quot;&gt;https://github.com/ElderJames/ant-design-blazor&lt;/a&gt;&lt;br/&gt;Demo：&lt;a href=&quot;https://ant-design-blazor.gitee.io&quot;&gt;https://ant-design-blazor.gitee.io&lt;/a&gt;&lt;br/&gt;开发文档：&lt;a href=&quot;https://github.com/ElderJames/ant-design-blazor/wiki&quot;&gt;https://github.com/ElderJames/ant-design-blazor/wiki&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap 是 Blazor基于Bootstrap ，这个UI库目前只有服务器端，客户端wasm模式等正式版出来会搞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       仓库地址：&lt;a href=&quot;https://gitee.com/LongbowEnterprise/BootstrapBlazor&quot;&gt;https://gitee.com/LongbowEnterprise/BootstrapBlazor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       演示地址：&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/%20http://blazor.sdgxgz.com&quot;&gt;blazor.sdgxgz.com&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazui  Element的blazor版本，用 .NET 写前端的 UI 框架&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       仓库地址：&lt;a href=&quot;https://github.com/wzxinchen/Blazui&quot;&gt;https://github.com/wzxinchen/Blazui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       演示地址 &lt;a href=&quot;http://blazui.com:9000&quot;&gt;http://blazui.com:9000&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazorise 是一个组件库，基于 像Bootstrap, Bulma 和Material 等CSS frameworks&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      github：&lt;a href=&quot;https://github.com/stsrki/Blazorise&quot;&gt;https://github.com/stsrki/Blazorise&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;      官网：&lt;a href=&quot;https://blazorise.com/&quot;&gt;https://blazorise.com/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Skclusive-UI Component library for Blazor using Material Design.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      github： &lt;a href=&quot;https://github.com/skclusive/Skclusive.Material.Component&quot;&gt;https://github.com/skclusive/Skclusive.Material.Component&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;      github：&lt;a href=&quot;https://github.com/SamProf/MatBlazor&quot;&gt;https://github.com/SamProf/MatBlazor&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;github的仓库： &lt;a href=&quot;https://github.com/AdrienTorris/awesome-blazor&quot;&gt;https://github.com/AdrienTorris/awesome-blazor&lt;/a&gt; 收集了更全面的blazor 和webassembly相关的资料。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 23:44:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>最近blazor更新很快，今天在官方博客上发布了Blazor WebAssembly 3.2.0 RC：https://devblogs.microsoft.com/aspnet/blazor-web</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12774965.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（十一点五）之CNN网络介绍 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12812288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12812288.html</guid>
<description>&lt;p&gt;在前面的两篇博客中，我们介绍了DNN（深度神经网络）并使用keras实现了一个简单的DNN。在这篇博客中将介绍CNN（卷积神经网络），然后在下一篇博客中将使用keras构建一个简单的CNN，对&lt;code&gt;cifar10&lt;/code&gt;数据集进行分类预测。&lt;/p&gt;
&lt;h2 id=&quot;cnn简介&quot;&gt;CNN简介&lt;/h2&gt;
&lt;p&gt;我们可以想一个例子，假如我们现在需要对人进行识别分类，根据我们人类的思维，我们肯定是比较他的👀是不是一样的，👃是不是一样大小，是不是双（or 三）下巴。换句话来说，我们的判断标准是一个可视的范围。&lt;/p&gt;
&lt;p&gt;CNN就是受到了人类视觉神经系统的启发，使用卷积核来代替人类中的视野，这样既能够降低计算量，又能够有效的保留图像的特征，同时对图片的处理更加的高效。我们可以想一想前面介绍的DNN网络，它是将一个一个的像素点进行计算的，毋庸置疑，这样必然会带来参数的膨胀，比如说cifar-10中一张32*32*3的图像，第一个隐藏层的中的单个神经元就有&lt;span class=&quot;math inline&quot;&gt;\(32 \times 32 \times 3 = 3072\)&lt;/span&gt;个权重，似乎挺小的，但是如果图片的像素再大一点，则参数会飞速猛增，同时参数增加的同时就会导致过拟合。&lt;/p&gt;
&lt;p&gt;下图是我使用DNN网络去训练cifar-10得到的结果，可以明显的看到过拟合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010630808-1216210410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而CNN就是将DNN中复杂的问题简单化（实际上更复杂，但是参数简单化了）。这里借用&lt;a href=&quot;https://easyai.tech/ai-definition/cnn/&quot;&gt;Easyai&lt;/a&gt;的几张图和几段话：&lt;/p&gt;
&lt;p&gt;在下面的场景中，有⚪是1，否则就是0，⚪的位置不同，产生的数据也就不同，但是从视觉的角度上面来说，两张图的内容是差不多的，只在于⚪的位置的不同罢了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010631031-1643187444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而 CNN 解决了这个问题，他用类似视觉的方式保留了图像的特征，当图像做翻转，旋转或者变换位置时，它也能有效的识别出来是类似的图像。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是一张来自cs231n中一张识别汽车的图，使用的是CNN网络，里面包含了CNN网络的网络层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010631384-847965261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中的CNN网络中，网络层有一下类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CONV：卷积层，进行卷积计算然后求和。&lt;/li&gt;
&lt;li&gt;Relu：激励层，激励函数为Relu&lt;/li&gt;
&lt;li&gt;POOL：池化层&lt;/li&gt;
&lt;li&gt;FC：全连接层&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以很明显的看到，CNN网络与DNN网络有相似，也有不同。在CNN网络中，使用了卷积层和池化层，最后才使用全连接层，而卷积层就是CNN的核心。但是在DNN网络中全部都是全连接层。&lt;/p&gt;
&lt;p&gt;下面将对这几层进行介绍，其中参考了YouTube上&lt;a href=&quot;https://www.youtube.com/watch?v=FmpDIaiMIeA&amp;amp;feature=youtu.be&quot;&gt;How Convolutional Neural Networks work&lt;/a&gt;这个视频。该视频有条件的建议去看一看，讲的还是蛮形象生动的。&lt;/p&gt;
&lt;p&gt;我们以识别一张照片是&lt;code&gt;X&lt;/code&gt;还是&lt;code&gt;O&lt;/code&gt;作为我们的识别目的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010631691-1041161381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们如何识别一张新的图片是&lt;code&gt;X&lt;/code&gt;还是&lt;code&gt;O&lt;/code&gt;，肯定是拿该照片与&lt;strong&gt;已有的标准&lt;code&gt;X&lt;/code&gt;和&lt;code&gt;O&lt;/code&gt;照片&lt;/strong&gt;进行对比，哪一个相似度高，则就认为新的照片是属于哪一个类别。&lt;strong&gt;对比&lt;/strong&gt;对于人类来说很简单，但是，对于计算机来说，应该怎么对比呢？&lt;/p&gt;
&lt;p&gt;计算机可以进行遍历图片的每一个像素点的像素值，然后与标准图片的像素值进行比较，但是毋庸置疑，这样肯定是不行的，比如说在下图中计算机就认为只有中间的是一样的，其它四个角都不同，因此可能会得出这张图片不是&lt;code&gt;X&lt;/code&gt;这个结论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010631918-89589828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我们肯定是希望不管在平移，旋转，还是变形的情况下，CNN模型都可以识别出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010632233-1280519225.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;so，我们将比较范围由像素点扩大到某一个范围，在CNN模型中，会比较两张图片的的各个局部，这些局部称之为特征（features）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010632465-1565415422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个feature都是一张小图，也就是更小的二维矩阵。这些特征会捕捉图片中的共同要素。以&lt;code&gt;X&lt;/code&gt;图片为例，它最重要的特征就是对角线和中间的交叉。也就是说，任何叉叉的线条或中心点应该都会符合这些特征。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010632667-1004177286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何判断一张图片中是否有相符合的特征，然后符合的特征有多少个，这里我们使用数学的方法卷积（convolution）进行操作，这个也就是CNN名字的由来。&lt;/p&gt;
&lt;h2 id=&quot;卷积层convolution-layer&quot;&gt;卷积层(Convolution Layer)&lt;/h2&gt;
&lt;p&gt;下面我还是将以识别&lt;code&gt;X&lt;/code&gt;作为例子来讲解一下如何进行进行卷积。卷积的目的是为了计算特征与图片局部的相符程度。&lt;/p&gt;
&lt;p&gt;计算的步骤如下：&lt;/p&gt;
&lt;p&gt;\[\frac{(1 \times 1) + (-1\times -1) + (-1\times -1) + (-1\times -1) + (1\times 1) + (-1\times -1)+ (-1\times -1) + (-1\times -1) + (1\times 1)}{9} = 1s \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010633442-1212686892.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将这个&lt;span class=&quot;math inline&quot;&gt;\(3 \times 3\)&lt;/span&gt;的特征矩阵沿着该图片以stide = 1（也就是每次滑动一格），可以得到一个&lt;span class=&quot;math inline&quot;&gt;\(7 \times 7\)&lt;/span&gt;的矩阵，最终得到的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010633873-500768462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很容易理解，卷积之后的结果越接近1，则相当与对应位置与特征feature越接近。分别与三个特征进行卷积的结果如下所示，得到了feature map：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010634104-828071227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里是一张来自cs231n的一张卷积示意图：&lt;/p&gt;
&lt;p&gt;不过这里与上面不同的是，它并没有取平均值，同时加上了一个偏置&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;，同时最后的结果是三个的的卷积的和。并且加上了一个padding（也就是外面那一层灰色取0的地方）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010634451-506564523.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设输入的为&lt;span class=&quot;math inline&quot;&gt;\(W_1 \times H_1 \times D_1\)&lt;/span&gt;，卷积核的大小是&lt;span class=&quot;math inline&quot;&gt;\(F \times F\)&lt;/span&gt;，卷积核的数量是&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;，padding的大小是&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，stride步为&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;，输出的矩阵的大小是&lt;span class=&quot;math inline&quot;&gt;\(W_2 \times H_2 \times D_2\)&lt;/span&gt;，则：&lt;/p&gt;
&lt;p&gt;\[W_{2}=\left(W_{1}-F+2 P\right) / S+1\\ H_{2}=\left(H_{1}-F+2 P\right) / S+1 \\ D_{2}=K \]&lt;/p&gt;
&lt;h2 id=&quot;relu激励层&quot;&gt;Relu激励层&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;整流线性单位函数&lt;/strong&gt;（Rectified Linear Unit, &lt;strong&gt;ReLU&lt;/strong&gt;）,又称&lt;strong&gt;修正线性单元&lt;/strong&gt;, 是一种人工神经网络中常用的激励函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数。数学表达式为：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}f(x)=\max (0, x)\end{equation} \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010634859-294640999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Relu激励层的工作流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010635160-1459865213.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将卷积层的输出通过激励层后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010635498-968449470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一层还是蛮简单的，可能大家会发现，在深度神经网络中，sigmoid激活函数就很少使用了，这是因为sigmoid函数太小了，在多层神经网络下会出现”梯度消失“现象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010635735-83404454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;池化（pooling）&quot;&gt;池化（Pooling）&lt;/h2&gt;
&lt;p&gt;池化层就更加的简单了，池化层可以大幅度的降低数据的维度。池化层多种，下面介绍两种简单常用的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;平均池化&lt;/strong&gt;（&lt;code&gt;average pooling&lt;/code&gt;）：计算图像区域的平均值作为该区域池化后的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大池化&lt;/strong&gt;（&lt;code&gt;max pooling&lt;/code&gt;）：选图像区域的最大值作为该区域池化后的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么池化是怎么操作的呢，下面是&lt;strong&gt;最大池化&lt;/strong&gt;进行操作的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010636047-1432043584.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;池化层也就是从一定的范围（也就是池化层的大小）中选出一个（或者计算出一个）值作为这个区域范围的代表。&lt;/p&gt;
&lt;p&gt;对所有的feature map都进行池化，最后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010636435-1860721875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为最大池化（max-pooling）保留了每一个小块内的最大值，所以它相当于保留了这一块最佳的匹配结果（因为值越接近1表示匹配越好）。这也就意味着它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。这也就能够看出，CNN能够发现图像中是否具有某种特征，而不用在意到底在哪里具有这种特征。这也就能够帮助解决之前提到的计算机逐一像素匹配的死板做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设输入的为&lt;span class=&quot;math inline&quot;&gt;\(W_1 \times H_1 \times D_1\)&lt;/span&gt;，池化层的大小是&lt;span class=&quot;math inline&quot;&gt;\(F \times F\)&lt;/span&gt;，stride步为&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;，输出的矩阵的大小是&lt;span class=&quot;math inline&quot;&gt;\(W_2 \times H_2 \times D_2\)&lt;/span&gt;，则：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{aligned} &amp;amp;W_{2}=\left(W_{1}-F\right) / S+1\\ &amp;amp;H_{2}=\left(H_{1}-F\right) / S+1\\ &amp;amp;D_{2}=D_{1} \end{aligned}\end{equation} \]&lt;/p&gt;
&lt;h2 id=&quot;结合卷积层、激励层、池化层&quot;&gt;结合卷积层、激励层、池化层&lt;/h2&gt;
&lt;p&gt;我们将前面所讲的卷积层，激励层，池化层进行结合，所得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010636689-961127816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加大网络的层数就得到了深度神经网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010636906-708902769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;全连接层fully-connected-layers&quot;&gt;全连接层(Fully connected layers)&lt;/h2&gt;
&lt;p&gt;通过前面得卷积，池化操作，我们成功得将数据进行了降维，得到降维后的数据后，我们在将其放入全连接层中，就可以得到最终得结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010637087-520706494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是以上面识别X为例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010637438-1934035574.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们称之这一层为全连接层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010637708-2059898769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然全连接层也可以有多个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010637936-1200838535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上，所有得结构我们可以表达为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010638178-582869951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时我们可以与CS231n的图片作比较，两者是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200501010638449-857969044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这一篇博客主要是介绍了每一层的功能，以及每一层工作的原理，但是并没有对其数学公式继续宁推导，如果想更多的了解CNN的前向和反向传播算法，可以去参考这一篇&lt;a href=&quot;https://www.cnblogs.com/pinard/p/6494810.html&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一篇博客中，将介绍使用CNN对cifar-10（也可能是cifar-100）进行训练预测。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
</description>
<pubDate>Thu, 30 Apr 2020 16:59:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>在前面的两篇博客中，我们介绍了DNN（深度神经网络）并使用keras实现了一个简单的DNN。在这篇博客中将介绍CNN（卷积神经网络），然后在下一篇博客中将使用keras构建一个简单的CNN，对 数据集</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12812288.html</dc:identifier>
</item>
<item>
<title>阻塞队列BlockingQueue - MXC肖某某</title>
<link>http://www.cnblogs.com/bbgs-xc/p/12811803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bbgs-xc/p/12811803.html</guid>
<description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;h3 id=&quot;队列&quot;&gt;队列&lt;/h3&gt;
&lt;p&gt;队列就可以想成是一个数组，从一头进入，一头出去，排队买饭&lt;/p&gt;
&lt;h3 id=&quot;阻塞队列-2&quot;&gt;阻塞队列&lt;/h3&gt;
&lt;p&gt;BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1405595/202004/1405595-20200430231733399-1775925894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素&lt;/p&gt;
&lt;p&gt;也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素&lt;/p&gt;
&lt;p&gt;同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增&lt;/p&gt;
&lt;h2 id=&quot;为什么要用？&quot;&gt;为什么要用？&lt;/h2&gt;
&lt;p&gt;去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞&lt;/p&gt;
&lt;p&gt;在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒&lt;/p&gt;
&lt;h3 id=&quot;为什么需要blockingqueue&quot;&gt;为什么需要BlockingQueue&lt;/h3&gt;
&lt;p&gt;好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了&lt;/p&gt;
&lt;p&gt;在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;// 你用过List集合类

// ArrayList集合类熟悉么？

// 还用过 CopyOnWriteList  和 BlockingQueue
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BlockingQueue阻塞队列是属于一个接口，底下有七个实现类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayBlockQueue：由数组结构组成的有界阻塞队列&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列
&lt;ul&gt;&lt;li&gt;有界，但是界限非常大，相当于无界，可以当成无界&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PriorityBlockQueue：支持优先级排序的无界阻塞队列&lt;/li&gt;
&lt;li&gt;DelayQueue：使用优先级队列实现的延迟无界阻塞队列&lt;/li&gt;
&lt;li&gt;SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列
&lt;ul&gt;&lt;li&gt;生产一个，消费一个，不存储元素，不消费不生产&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LinkedTransferQueue：由链表结构组成的无界阻塞队列&lt;/li&gt;
&lt;li&gt;LinkedBlockingDeque：由链表结构组成的双向阻塞队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue&lt;/p&gt;
&lt;h2 id=&quot;blockingqueue核心方法&quot;&gt;BlockingQueue核心方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1405595/202004/1405595-20200430231912810-1670124647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;抛出异常&lt;/th&gt;
&lt;th&gt;当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full 当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;特殊性&lt;/td&gt;
&lt;td&gt;插入方法，成功true，失败false 移除方法：成功返回出队列元素，队列没有就返回空&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;一直阻塞&lt;/td&gt;
&lt;td&gt;当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;超时退出&lt;/td&gt;
&lt;td&gt;当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;抛出异常组&quot;&gt;抛出异常组&lt;/h3&gt;
&lt;p&gt;但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 阻塞队列，需要填入默认值
BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(3);

System.out.println(blockingQueue.add(&quot;a&quot;));
System.out.println(blockingQueue.add(&quot;b&quot;));
System.out.println(blockingQueue.add(&quot;c&quot;));

System.out.println(blockingQueue.add(&quot;XXX&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
true
true
Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full
        at java.util.AbstractQueue.add(AbstractQueue.java:98)
        at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)
        at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 阻塞队列，需要填入默认值
BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(3);
System.out.println(blockingQueue.add(&quot;a&quot;));
System.out.println(blockingQueue.add(&quot;b&quot;));
System.out.println(blockingQueue.add(&quot;c&quot;));

System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么出现异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
true
true
a
b
c
Exception in thread &quot;main&quot; java.util.NoSuchElementException
        at java.util.AbstractQueue.remove(AbstractQueue.java:117)
        at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;布尔类型组&quot;&gt;布尔类型组&lt;/h3&gt;
&lt;p&gt;我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true&lt;/p&gt;
&lt;p&gt;同时在取的时候，如果队列已空，那么会返回null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BlockingQueue blockingQueue = new ArrayBlockingQueue(3);

System.out.println(blockingQueue.offer(&quot;a&quot;));
System.out.println(blockingQueue.offer(&quot;b&quot;));
System.out.println(blockingQueue.offer(&quot;c&quot;));
System.out.println(blockingQueue.offer(&quot;d&quot;));

System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
true
true
false
a
b
c
null
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;阻塞队列组&quot;&gt;阻塞队列组&lt;/h3&gt;
&lt;p&gt;我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒&lt;/p&gt;
&lt;p&gt;一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(3);
blockingQueue.put(&quot;a&quot;);
blockingQueue.put(&quot;b&quot;);
blockingQueue.put(&quot;c&quot;);
System.out.println(&quot;================&quot;);

blockingQueue.take();
blockingQueue.take();
blockingQueue.take();
blockingQueue.take();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞&lt;/p&gt;
&lt;h3 id=&quot;不见不散组&quot;&gt;不见不散组&lt;/h3&gt;
&lt;p&gt;offer( ) ， poll 加时间&lt;/p&gt;
&lt;p&gt;使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(3);
System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时取的时候也进行判断&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果2秒内取不出来，那么就返回null&lt;/p&gt;
&lt;h2 id=&quot;synchronousqueue&quot;&gt;SynchronousQueue&lt;/h2&gt;
&lt;p&gt;SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素&lt;/p&gt;
&lt;p&gt;下面我们测试SynchronousQueue添加元素的过程&lt;/p&gt;
&lt;p&gt;首先我们创建了两个线程，一个线程用于生产，一个线程用于消费&lt;/p&gt;
&lt;p&gt;生产的线程分别put了 A、B、C这三个字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new SynchronousQueue&amp;lt;&amp;gt;();

new Thread(() -&amp;gt; {
    try {       
        System.out.println(Thread.currentThread().getName() + &quot;\t put A &quot;);
        blockingQueue.put(&quot;A&quot;);
       
        System.out.println(Thread.currentThread().getName() + &quot;\t put B &quot;);
        blockingQueue.put(&quot;B&quot;);        
        
        System.out.println(Thread.currentThread().getName() + &quot;\t put C &quot;);
        blockingQueue.put(&quot;C&quot;);        
        
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}, &quot;t1&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        new Thread(() -&amp;gt; {
            try {

                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                blockingQueue.take();
                System.out.println(Thread.currentThread().getName() + &quot;\t take A &quot;);

                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                blockingQueue.take();
                System.out.println(Thread.currentThread().getName() + &quot;\t take B &quot;);

                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                blockingQueue.take();
                System.out.println(Thread.currentThread().getName() + &quot;\t take C &quot;);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;t2&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后结果输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1    put A 
t2       take A 

5秒后...

t1       put B 
t2       take B 

5秒后...

t1       put C 
t2       take C 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态&lt;/p&gt;
&lt;h2 id=&quot;阻塞队列的用处&quot;&gt;阻塞队列的用处&lt;/h2&gt;
&lt;h3 id=&quot;生产者消费者模式&quot;&gt;生产者消费者模式&lt;/h3&gt;
&lt;p&gt;一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮&lt;/p&gt;
&lt;p&gt;关于多线程的操作，我们需要记住下面几句&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程 操作 资源类&lt;/li&gt;
&lt;li&gt;判断 干活 通知&lt;/li&gt;
&lt;li&gt;防止虚假唤醒机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 资源类
 */
class ShareData {

    private int number = 0;

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    public void increment() throws Exception{
        // 同步代码块，加锁
        lock.lock();
        try {
            // 判断
            while(number != 0) {
                // 等待不能生产
                condition.await();
            }

            // 干活
            number++;

            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);

            // 通知 唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws Exception{
        // 同步代码块，加锁
        lock.lock();
        try {
            // 判断
            while(number == 0) {
                // 等待不能消费
                condition.await();
            }

            // 干活
            number--;

            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);

            // 通知 唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1&lt;/p&gt;
&lt;p&gt;但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 判断
while(number != 0) {
    // 等待不能生产
    condition.await();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不能使用 if判断&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 判断
if(number != 0) {
    // 等待不能生产
    condition.await();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 生产者消费者 传统版
 * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮
 */
/**
 * 线程 操作 资源类
 * 判断 干活 通知
 * 防止虚假唤醒机制
 */

/**
 * 资源类
 */
class ShareData {

    private int number = 0;

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    public void increment() throws Exception{
        // 同步代码块，加锁
        lock.lock();
        try {
            // 判断
            while(number != 0) {
                // 等待不能生产
                condition.await();
            }

            // 干活
            number++;

            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);

            // 通知 唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws Exception{
        // 同步代码块，加锁
        lock.lock();
        try {
            // 判断
            while(number == 0) {
                // 等待不能消费
                condition.await();
            }

            // 干活
            number--;

            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);

            // 通知 唤醒
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
public class ProdConsumerTraditionDemo {

    public static void main(String[] args) {

        // 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法
        ShareData shareData = new ShareData();

        // t1线程，生产
        new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 5; i++) {
                try {
                    shareData.increment();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, &quot;t1&quot;).start();

        // t2线程，消费
        new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 5; i++) {
                try {
                    shareData.decrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, &quot;t2&quot;).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后运行成功后，我们一个进行生产，一个进行消费&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1    1
t2       0
t1       1
t2       0
t1       1
t2       0
t1       1
t2       0
t1       1
t2       0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成者和消费者30&quot;&gt;生成者和消费者3.0&lt;/h2&gt;
&lt;p&gt;在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度&lt;/p&gt;
&lt;p&gt;现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 生产者消费者  阻塞队列版
 * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用
 *
 */

class MyResource {
    // 默认开启，进行生产消费
    // 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改
    private volatile boolean FLAG = true;

    // 使用原子包装类，而不用number++
    private AtomicInteger atomicInteger = new AtomicInteger();

    // 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue
    BlockingQueue&amp;lt;String&amp;gt; blockingQueue = null;

    // 而应该采用依赖注入里面的，构造注入方法传入
    public MyResource(BlockingQueue&amp;lt;String&amp;gt; blockingQueue) {
        this.blockingQueue = blockingQueue;
        // 查询出传入的class是什么
        System.out.println(blockingQueue.getClass().getName());
    }

    /**
     * 生产
     * @throws Exception
     */
    public void myProd() throws Exception{
        String data = null;
        boolean retValue;
        // 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒
        // 当FLAG为true的时候，开始生产
        while(FLAG) {
            data = atomicInteger.incrementAndGet() + &quot;&quot;;

            // 2秒存入1个data
            retValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
            if(retValue) {
                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列:&quot; + data  + &quot;成功&quot; );
            } else {
                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列:&quot; + data  + &quot;失败&quot; );
            }

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println(Thread.currentThread().getName() + &quot;\t 停止生产，表示FLAG=false，生产介绍&quot;);
    }

    /**
     * 消费
     * @throws Exception
     */
    public void myConsumer() throws Exception{
        String retValue;
        // 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒
        // 当FLAG为true的时候，开始生产
        while(FLAG) {
            // 2秒存入1个data
            retValue = blockingQueue.poll(2L, TimeUnit.SECONDS);
            if(retValue != null &amp;amp;&amp;amp; retValue != &quot;&quot;) {
                System.out.println(Thread.currentThread().getName() + &quot;\t 消费队列:&quot; + retValue  + &quot;成功&quot; );
            } else {
                FLAG = false;
                System.out.println(Thread.currentThread().getName() + &quot;\t 消费失败，队列中已为空，退出&quot; );

                // 退出消费队列
                return;
            }
        }
    }

    /**
     * 停止生产的判断
     */
    public void stop() {
        this.FLAG = false;
    }

}
public class ProdConsumerBlockingQueueDemo {

    public static void main(String[] args) {
        // 传入具体的实现类， ArrayBlockingQueue
        MyResource myResource = new MyResource(new ArrayBlockingQueue&amp;lt;String&amp;gt;(10));

        new Thread(() -&amp;gt; {
            System.out.println(Thread.currentThread().getName() + &quot;\t 生产线程启动&quot;);
            System.out.println(&quot;&quot;);
            System.out.println(&quot;&quot;);
            try {
                myResource.myProd();
                System.out.println(&quot;&quot;);
                System.out.println(&quot;&quot;);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, &quot;prod&quot;).start();


        new Thread(() -&amp;gt; {
            System.out.println(Thread.currentThread().getName() + &quot;\t 消费线程启动&quot;);

            try {
                myResource.myConsumer();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, &quot;consumer&quot;).start();

        // 5秒后，停止生产和消费
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;&quot;);
        System.out.println(&quot;&quot;);
        System.out.println(&quot;5秒中后，生产和消费线程停止，线程结束&quot;);
        myResource.stop();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.concurrent.ArrayBlockingQueue
prod     生产线程启动


consumer         消费线程启动
prod     插入队列:1成功
consumer         消费队列:1成功
prod     插入队列:2成功
consumer         消费队列:2成功
prod     插入队列:3成功
consumer         消费队列:3成功
prod     插入队列:4成功
consumer         消费队列:4成功
prod     插入队列:5成功
consumer         消费队列:5成功


5秒中后，生产和消费线程停止，线程结束
prod     停止生产，表示FLAG=false，生产介绍
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 30 Apr 2020 15:33:00 +0000</pubDate>
<dc:creator>MXC肖某某</dc:creator>
<og:description>阻塞队列 概念 队列 队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 阻塞队列 BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bbgs-xc/p/12811803.html</dc:identifier>
</item>
<item>
<title>MinIO 的分布式部署 - Mason技术记录</title>
<link>http://www.cnblogs.com/masonlee/p/12811784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masonlee/p/12811784.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;高可用分布式对象存储，MinIO 轻松实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rzaqPmpTOUJJsKISr6eF9Q&quot;&gt;上一篇文章&lt;/a&gt;介绍了使用对象存储工具 MinIO 搭建一个优雅、简单、功能完备的静态资源服务，可见其操作简单，功能完备。但由于是单节点部署，难免会出现单点故障，无法做到服务的高可用。MinIO 已经提供了分布式部署的解决方案，实现高可靠、高可用的资源存储，同样的操作简单，功能完备。本文将对 MinIO 的分布式部署进行描述，主要分以下几个方面：&lt;/p&gt;

&lt;p&gt;分布式存储，很关键的点在于数据的可靠性，即保证数据的完整，不丢失，不损坏。只有在可靠性实现的前提下，才有了追求一致性、高可用、高性能的基础。而对于在存储领域，一般对于保证数据可靠性的方法主要有两类，一类是冗余法，一类是校验法。&lt;/p&gt;
&lt;h2 id=&quot;21-冗余&quot;&gt;2.1 冗余&lt;/h2&gt;
&lt;p&gt;冗余法最简单直接，即对存储的数据进行副本备份，当数据出现丢失，损坏，即可使用备份内容进行恢复，而副本 备份的多少，决定了数据可靠性的高低。这其中会有成本的考量，副本数据越多，数据越可靠，但需要的设备就越多，成本就越高。可靠性是允许丢失其中一份数据。当前已有很多分布式系统是采用此种方式实现，如 Hadoop 的文件系统（3个副本），Redis 的集群，MySQL 的主备模式等。&lt;/p&gt;
&lt;h2 id=&quot;22-校验&quot;&gt;2.2 校验&lt;/h2&gt;
&lt;p&gt;校验法即通过校验码的数学计算的方式，对出现丢失、损坏的数据进行校验、还原。注意，这里有两个作用，一个校验，通过对数据进行校验和( checksum )进行计算，可以检查数据是否完整，有无损坏或更改，在数据传输和保存时经常用到，如 TCP 协议；二是恢复还原，通过对数据结合校验码，通过数学计算，还原丢失或损坏的数据，可以在保证数据可靠的前提下，降低冗余，如单机硬盘存储中的 RAID 技术，纠删码（Erasure Code）技术等。MinIO 采用的就是纠删码技术。&lt;/p&gt;

&lt;h2 id=&quot;31-概念理解&quot;&gt;3.1 概念理解&lt;/h2&gt;
&lt;p&gt;在部署分布式 MinIO 前，需要对下面的概念进行了解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;硬盘（Drive）：即存储数据的磁盘，在 MinIO 启动时，以参数的方式传入。&lt;/li&gt;
&lt;li&gt;组（ Set ）：即一组 Drive 的集合，分布式部署根据集群规模自动划分一个或多个 Set ，每个 Set 中的 Drive 分布在不同位置。一个对象存储在一个 Set 上。&lt;/li&gt;
&lt;li&gt;桶（Bucket）：文件对象存储的逻辑位置，对于客户端而言，就相当于一个存放文件的顶层文件夹。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;32-纠删码ec（erasure-code）&quot;&gt;3.2 纠删码EC（Erasure Code）&lt;/h2&gt;
&lt;p&gt;MinIO 使用纠删码机制来保证高可靠性，使用 highwayhash 来处理数据损坏（ Bit Rot Protection ）。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。举个最简单例子就是有两个数据(d1, d2)，用一个校验和y（&lt;code&gt;d1 + d2 = y&lt;/code&gt;）即可保证即使丢失其中一个，依然可以还原数据。如丢失 d1 ，则使用 &lt;code&gt;y - d2 = d1&lt;/code&gt; 还原，同理，d2 丢失或者y丢失，均可通过计算得出。&lt;/p&gt;
&lt;p&gt;EC 的具体应用实现中， RS（Reed-Solomen）是 EC 的一种更简单快捷的实现，可以通过矩阵运算，还原数据。MinIO 将对象拆分成N/2数据和N/2 校验块 。具体的数学矩阵运算及证明，可以参考文章《&lt;a href=&quot;https://blog.openacid.com/storage/ec-1/&quot;&gt;Erasure-Code-擦除码-1-原理篇&lt;/a&gt;》及《&lt;a href=&quot;https://blog.csdn.net/shelldon/article/details/54144730&quot;&gt;EC纠删码原理&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&quot;33-存储形式&quot;&gt;3.3 存储形式&lt;/h2&gt;
&lt;p&gt;文件对象上传到 MinIO ，会在对应的数据存储磁盘中，以 Bucket 名称为目录，文件名称为下一级目录，文件名称下是 part.1 和 xl.json，前者是编码数据块及检验块，后者是元数据文件。如有4个磁盘，当文件上传后，会有2个编码数据块，2个检验块，分别存储在4个磁盘中。如下图，&lt;code&gt;bg-01.jpg&lt;/code&gt; 是上传的文件对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/20200331-minio/store-cotent.png&quot; alt=&quot;存储结构&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;41-单节点部署多磁盘&quot;&gt;4.1 单节点部署多磁盘&lt;/h2&gt;
&lt;p&gt;在启动 MinIO 时，若传入参数是多个目录，则会以纠删码的形式运行，即具备高可靠性意义。即在一个服务器（单节点）上对，多个磁盘上运行 MinIO。&lt;/p&gt;
&lt;p&gt;运行命令也很简单，参数传入多个目录即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MINIO_ACCESS_KEY=${ACCESS_KEY} MINIO_SECRET_KEY=${SECRET_KEY} nohup ${MINIO_HOME}/minio server --address &quot;${MINIO_HOST}:${MINIO_PORT}&quot; /opt/min-data1 /opt/min-data2 /opt/min-data3 /opt/min-data4 &amp;gt; ${MINIO_LOGFILE} 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意替换命令中的变更，运行后输出信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/20200331-minio/start-ok.png&quot; alt=&quot;启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见 MinIO 会创建一个1个 set，set 中有4个 drive ，其中它会提示一个警告，提示一个节点的 set 中存在多于2个的drive，如果节点挂掉，则数据都不可用了，这与 EC 码的规则一致。&lt;/p&gt;
&lt;h2 id=&quot;42-多节点部署&quot;&gt;4.2 多节点部署&lt;/h2&gt;
&lt;h3 id=&quot;421-部署脚本&quot;&gt;4.2.1 部署脚本&lt;/h3&gt;
&lt;p&gt;为了防止单点故障，分布式存储自然是需要多节点部署，以达到高可靠和高可用的能力。MinIO 对于多节点的部署，也是在启动时通过指定有 Host 和端口的目录地址，即可实现。下面在单台机器上，通过不同的端口模拟在4台机器节点上运行，存储目录依然是 min-data1&lt;sub&gt;4，而对应的端口是9001&lt;/sub&gt;9004。脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;RUNNING_USER=root
MINIO_HOME=/opt/minio
MINIO_HOST=192.168.222.10
#accesskey and secretkey
ACCESS_KEY=minio 
SECRET_KEY=minio123

for i in {01..04}; do
    START_CMD=&quot;MINIO_ACCESS_KEY=${ACCESS_KEY} MINIO_SECRET_KEY=${SECRET_KEY} nohup ${MINIO_HOME}/minio  server --address &quot;${MINIO_HOST}:90${i}&quot; http://${MINIO_HOST}:9001/opt/min-data1 http://${MINIO_HOST}:9002/opt/min-data2 http://${MINIO_HOST}:9003/opt/min-data3 http://${MINIO_HOST}:9004/opt/min-data4 &amp;gt; ${MINIO_HOME}/minio-90${i}.log 2&amp;gt;&amp;amp;1 &amp;amp;&quot;
    su - ${RUNNING_USER} -c &quot;${START_CMD}&quot;
done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本示例中，minio 的启动命令运行了4次，相当于在四台机器节点上都分别运行一个minio实例，从而模拟四个节点。运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/20200331-minio/dis-start-log.png&quot; alt=&quot;分布式启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看进程&lt;code&gt;ps -ef |grep minio&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/20200331-minio/dis-ps.png&quot; alt=&quot;分布式进程&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;422-部署注意点&quot;&gt;4.2.2 部署注意点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;所有运行分布式 MinIO 的节点需要具有相同的访问密钥和秘密密钥才能连接。建议在执行 MINIO 服务器命令之前，将访问密钥作为环境变量，MINIO access key 和 MINIO secret key 导出到所有节点上 。&lt;/li&gt;
&lt;li&gt;Minio 创建4到16个驱动器的擦除编码集。&lt;/li&gt;
&lt;li&gt;Minio 选择最大的 EC 集大小，该集大小除以给定的驱动器总数。 例如，8个驱动器将用作一个大小为8的 EC 集，而不是两个大小为4的 EC 集 。&lt;/li&gt;
&lt;li&gt;建议所有运行分布式 MinIO 设置的节点都是同构的，即相同的操作系统、相同数量的磁盘和相同的网络互连 。&lt;/li&gt;
&lt;li&gt;运行分布式 MinIO 实例的服务器时间差不应超过15分钟。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行起来后，使用 &lt;code&gt;http://${MINIO_HOST}:9001&lt;/code&gt; 到&lt;code&gt;http://${MINIO_HOST}:9004&lt;/code&gt; 均可以访问到 MinIO 的使用界面。&lt;/p&gt;
&lt;h3 id=&quot;423-使用-nginx-负载均衡&quot;&gt;4.2.3 使用 nginx 负载均衡&lt;/h3&gt;
&lt;p&gt;前面单独对每个节点进行访问显然不合理，通过使用 nginx 代理，进行负载均衡则很有必要。简单的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;upstream http_minio {
    server 192.168.222.10:9001;
    server 192.168.222.10:9002;
    server 192.168.222.10:9003;
    server 192.168.222.10:9004;
}

server{
    listen       8888;
    server_name  192.168.222.10;

    ignore_invalid_headers off;
    client_max_body_size 0;
    proxy_buffering off;

    location / {
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-Host  $host:$server_port;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto  $http_x_forwarded_proto;

        proxy_connect_timeout 300;
        proxy_http_version 1.1;
        chunked_transfer_encoding off;
        proxy_ignore_client_abort on;

        proxy_pass http://http_minio;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中主要是 upstream 及 proxy_pass 的配置。如此，即可使用&lt;code&gt;http://${MINIO_HOST}:8888&lt;/code&gt; 进行访问。&lt;/p&gt;

&lt;p&gt;对于分布式存储，高可靠必是首要考虑的因素，MinIO 已经提供了分布式部署的解决方案，实现高可靠、高可用的资源存储。本文对可靠性的实现方法进行描述，探讨了 MinIO 的存储机制，并通过脚本模拟实践 MinIO 的分布式部署，希望对大家有帮助。&lt;/p&gt;


&lt;p&gt;我的公众号（搜索&lt;code&gt;Mason技术记录&lt;/code&gt;），获取更多技术记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/myphoto/wx/wx-public.jpg&quot; alt=&quot;mason&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 15:28:00 +0000</pubDate>
<dc:creator>Mason技术记录</dc:creator>
<og:description>高可用分布式对象存储，MinIO 轻松实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masonlee/p/12811784.html</dc:identifier>
</item>
<item>
<title>java多线程4：synchronized关键字 - 16bit</title>
<link>http://www.cnblogs.com/dslx/p/12787683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/12787683.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　java有各种各样的锁，并且每种锁的特性不同，合理场景下利用锁可以展现出非常高的效率。&lt;span&gt;synchronized内置锁就是Java的一种重量级锁，它能够解决并发编程中出现多个线程同时访问一个共享，可变的临界资源时出现的线程安全问题。让多个线程序列化访问临界资源，同一时刻，只能有一个线程访问临界资源，同步互斥，这样就保证了操作的原子性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200427165927453-1203520197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;synchronized使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同步方法块&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadDemo5 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; ++&lt;span&gt;i){
                count&lt;/span&gt;++&lt;span&gt;;
                System.out.println(&lt;/span&gt;&quot;执行的线程是=&amp;gt;&quot; + Thread.currentThread().getName() + &quot;执行结果为-&amp;gt;&quot; +&lt;span&gt; count);
            }
        }

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ThreadDemo5 threadDemo5 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo5();
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(threadDemo5,&quot;thread1&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(threadDemo5,&quot;thread2&quot;&lt;span&gt;);
        thread1.start();
        thread2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
执行的线程是=&amp;gt;thread1执行结果为-&amp;gt;1&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;2&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;3&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;4&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;5&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;6&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;7&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;8&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;9&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread1执行结果为-&amp;gt;10&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;11&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;12&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;13&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;14&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;15&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;16&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;17&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;18&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;19&lt;span&gt;
执行的线程是&lt;/span&gt;=&amp;gt;thread2执行结果为-&amp;gt;20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 同步方法块，synchronized锁的是括号里的对象，每个线程要进入代码块前必须先获取对象的的锁，才可执行。synchronized是一个隐式锁，也是jvm内置的锁，它会自动加锁和解锁，同时java的每个对象都可以作为锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通同步方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadDemo6 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        say();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; ++&lt;span&gt;i){
            count&lt;/span&gt;++&lt;span&gt;;
            System.out.println(&lt;/span&gt;&quot;现在执行的线程执行=&amp;gt;&quot; + Thread.currentThread().getName() + &quot;结果为-&amp;gt;&quot; +&lt;span&gt; count);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ThreadDemo6 threadDemo6 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo6();
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(threadDemo6,&quot;Thread-1&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(threadDemo6,&quot;Thread-2&quot;&lt;span&gt;);
        thread1.start();
        thread2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
现在执行的线程执行=&amp;gt;Thread-1结果为-&amp;gt;1&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;2&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;3&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;4&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;5&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;6&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;7&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;8&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;9&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;10&lt;br/&gt;/*停顿5秒*/&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;11&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;12&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;13&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;14&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;15&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;16&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;17&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;18&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;19&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通同步方法，通过例子可以知道他是一个对象锁，线程1未释放锁，线程2只能被动等待，改下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo6(),&quot;Thread-1&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo6(),&quot;Thread-2&quot;&lt;span&gt;);
        thread1.start();
        thread2.start();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
现在执行的线程执行=&amp;gt;Thread-2结果为-&amp;gt;1&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;2&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;3&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;4&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;5&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;6&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;7&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;8&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;9&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;10&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;1&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;2&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;3&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;4&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;5&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;6&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;7&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;8&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;9&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;10&lt;br/&gt;停顿。。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不是同一个对象锁，所以线程1和线程2不存在锁的互斥，并且不存在共享资源count变量，所以多个线程访问的必须是同一个对象，锁才会变得有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态同步方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadDemo6 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        say();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; ++&lt;span&gt;i){
            count&lt;/span&gt;++&lt;span&gt;;
            System.out.println(&lt;/span&gt;&quot;现在执行的线程执行=&amp;gt;&quot; + Thread.currentThread().getName() + &quot;结果为-&amp;gt;&quot; +&lt;span&gt; count);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo6(),&quot;Thread-1&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo6(),&quot;Thread-2&quot;&lt;span&gt;);
        thread1.start();
        thread2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
现在执行的线程执行=&amp;gt;Thread-1结果为-&amp;gt;1&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;2&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;3&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;4&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;5&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;6&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;7&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;8&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;9&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-1结果为-&amp;gt;10
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;停顿&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;11&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;12&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;13&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;14&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;15&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;16&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;17&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;18&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;19&lt;span&gt;
现在执行的线程执行&lt;/span&gt;=&amp;gt;Thread-2结果为-&amp;gt;20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使他们是不同的对象，但执行的都是一个类的方法，在执行同步静态方法时，争抢的是类锁，这也是和非静态同步方法所区别开来。因为他们是两个不同的锁，一个是对象锁，一个是类锁。所以，在代码中，一个线程可以同时抢有对象锁，类锁。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; monitor和monitorexit&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Java的互斥锁是如何的实现的，&lt;code class=&quot;language-bash hljs&quot;&gt;javap -verbose ThreadDemo3.class&lt;/code&gt; 看下字节码子令。&lt;/p&gt;
&lt;p&gt;同步代码块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430153943891-1937958587.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430153957075-1110824226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 非静态方法同步&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430155541997-2055383624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 静态方法同步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430155905332-2082251002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 同步块中monitor被占用就处于锁定状态，其他本次抢锁失败的线程将会放入Wait Set等待同步队列中进行等待，占用锁的线程执行完同步块并且释放锁后将会通知放入同步队列的的其他线程，通知他们，我释放锁了赶紧来抢吧！而相对于普通的静态同步方法和非静态同步方法，常量池汇中多了ACC_SYNCHRONIZED标记，方法调用就会去检查是不是有这个标记如果有，jvm就会要求线程在调用前先请求锁，但无论哪种实现，在实质上还是通过对象相关联的的monitor获取的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430205057774-483911882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而monitor是什么哪？它是每个对象创建之后都会在jvm内部维护一个与之对应Monitor（监视器锁）也有人叫管程反正都是一个东西，可以理解为每个对象天生都有一把看不见的锁我们叫他monitor锁，而每个线程会有一个可用的MR（Monitor Record）列表，还有一个全局可用列表，每一个被锁住的对象都会和一个MR相关联，并且对象monitor中会有一个owner字段存放占用该锁线程唯一标识，表示这个锁已经被哪个线程占用，&lt;span&gt;synchronized&lt;/span&gt;就是基于进入与退出Monitor对象实现方法与代码块同步，而监视器锁的实现哪是依赖底层操作系统Mutex lock（互斥锁)，它是一个重量级锁，每次从用户态切换到内的态的资源消耗是比较大的，也因此从jdk1.6后，java对synchronized进行了优化，从一开始的无锁状态-&amp;gt;偏向锁状态-&amp;gt;轻量级锁状态-&amp;gt;重量级锁状态，并且这个状态是不可逆的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jvm加锁过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430214727110-880942735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 对象内存结构&lt;/h3&gt;
&lt;p&gt; 上文说过每个Java对象都是天生的锁，存放在Java的对象头中，对象头包含三个区域，对象头，实例数据，补齐填充&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1333075/202004/1333075-20200430221131763-160044015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一部分是存储对象自身运行时的数据，哈希码，GC，偏向时间戳，保存对象的分代年龄，锁状态标志，偏向锁线程id，线程持有的锁，如果是数组还需要一块区域存放数组大小，class的对象指针是虚拟机通过他确定这个对象是哪个类的实例，我们平时getClass直接获取类就跟这个有关，官方称这部分为Mark Word，第二部分略过，第三部分规定对象的大小必须是8字节的整数倍，至于为什么，lz没去深究暂时不知道。我们重点关注是Mark Word的锁标志位，所以锁的状态是保存在对象头中的，至于偏向状态，篇幅有限，下节在谈。&lt;/p&gt;
&lt;h3&gt;锁的粗化和消除&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;锁的粗化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁带来性能开销是很大的，为了保证多线程的并发操作，通常会要求每个线程持有锁的时间越短越好，但如果遇到一连串对同一把锁进行请求和释放的操作，jvm会进行优化智能的把锁操作的整合成一个较大同步块，从而减少了对锁的频繁申请和释放提高性能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadDemo7 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;1111&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;222&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;333&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ThreadDemo7 threadDemo7 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo7();
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(threadDemo7);
        thread.start();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        test();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;锁的消除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们设置了同步块，在字节码中也发现了monitorenter和monitorexit，至少看上去有锁的获取和释放过程，但执行的结果与我们预测的风马牛不相及。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadDemo8 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object()){
            count&lt;/span&gt;++&lt;span&gt;;
            System.out.println(&lt;/span&gt;&quot;锁的消除...=&amp;gt;&quot;  + Thread.currentThread().getName() + &quot;值=&amp;gt;&quot; +&lt;span&gt; count);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ThreadDemo8 threadDemo8 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo8();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; ++&lt;span&gt;i){
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(threadDemo8);
            thread.start();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
锁的消除...=&amp;gt;Thread-6值=&amp;gt;4&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-4值=&amp;gt;2&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-5值=&amp;gt;4&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-0值=&amp;gt;4&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-1值=&amp;gt;6&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-2值=&amp;gt;6&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-3值=&amp;gt;7&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-9值=&amp;gt;8&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-7值=&amp;gt;9&lt;span&gt;
锁的消除...&lt;/span&gt;=&amp;gt;Thread-8值=&amp;gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为jit在编译代码时，使用了逃逸分析的技术，判断程序中的使用锁的对象是否被其他线程使用，如果只被一个线程使用，这个同步代码就不会生成synchronized锁标识的锁申请和释放的机器码，消除了锁的使用流程。所以，并不是所有的实例对象都存放在堆区，如果发生线程逃逸行为，将会存储在线程栈上。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;锁的重入和锁膨胀升级，在后期在慢慢整理。&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/axiaoboge/article/details/84335452&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/xrq730/p/4853578.html&lt;/p&gt;

</description>
<pubDate>Thu, 30 Apr 2020 15:21:00 +0000</pubDate>
<dc:creator>16bit</dc:creator>
<og:description>概述 java有各种各样的锁，并且每种锁的特性不同，合理场景下利用锁可以展现出非常高的效率。synchronized内置锁就是Java的一种重量级锁，它能够解决并发编程中出现多个线程同时访问一个共享，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dslx/p/12787683.html</dc:identifier>
</item>
<item>
<title>abp(net core)+easyui+efcore实现仓储管理系统——入库管理之十(四十六)  - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/12811725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/12811725.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;四&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;、修改与删除&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;入库单&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在Visual Studio 2017的解决方案资源管理器中，按F5运行应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在浏览器中的地址栏中输入“http://localhost:5000/”，然后输入管理员用户名进行登录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.在主界面的菜单中，选择“Business-&amp;gt;&lt;span&gt;入库&lt;/span&gt;&lt;span&gt;管理&lt;/span&gt;”菜单项，浏览器中呈现一个组织信息列表与&lt;span&gt;五&lt;/span&gt;&lt;span&gt;个按钮。如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231305924-798308475.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.然后在组织信息列表中选中一条&lt;span&gt;入库单&lt;/span&gt;&lt;span&gt;信息，然后使用鼠标点击&lt;/span&gt;“修改”按钮，对&lt;span&gt;入库单&lt;/span&gt;&lt;span&gt;进行修改。如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231316039-1155309718.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.对于&lt;span&gt;入库单&lt;/span&gt;&lt;span&gt;信息进行修改完成之后，点击&lt;/span&gt;“保存”按钮，弹出一个“您确认要&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;吗？&lt;/span&gt;”对话框。点击对话框中的“确定”按钮。&lt;span&gt;然后会出现修改入库单界面，如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231323785-459611947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.如果修改成功，会有一个“&lt;span&gt;更新&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;”的提示信息，同时更新&lt;span&gt;入库单管理&lt;/span&gt;&lt;span&gt;列表。如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231331039-186973431.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.&lt;span&gt;在&lt;/span&gt;&lt;span&gt;入库单管理&lt;/span&gt;&lt;span&gt;列表中选中一条&lt;/span&gt;&lt;span&gt;入库单信&lt;/span&gt;&lt;span&gt;息，然后使用鼠标点击&lt;/span&gt;“删除”按钮。会&lt;span&gt;弹出一个&lt;/span&gt;“您确认要删除吗？”对话框。点击对话框中的“确定”按钮。&lt;span&gt;如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231338860-1051824871.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.&lt;span&gt;如果删除成功，会有一个&lt;/span&gt;“删除成功！”的提示信息，同时更新&lt;span&gt;入库单管理&lt;/span&gt;&lt;span&gt;列表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200430231347158-646224267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 15:14:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>在之前的文章abp(net core)+easyui+efcore实现仓储管理系统——入库管理之九(四十五) 中我们已经实现了修改与删除入库单，今天来测试一下入库单的修改与删除功能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chillsrc/p/12811725.html</dc:identifier>
</item>
<item>
<title>透彻理解C++11新特性：右值引用、std::move、std::forward - KillerAery</title>
<link>http://www.cnblogs.com/KillerAery/p/12802771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KillerAery/p/12802771.html</guid>
<description>&lt;p&gt;C++11出现的右值相关语法可谓是很多C++程序员难以理解的新特性，不少人知其然而不知其所以然，面试被问到时大概就只知道可以减少开销，但是为什么减少开销、减少了多少开销、什么时候用...这些问题也不一定知道，于是我写下了这篇夹带自己理解的博文，希望它对你有所帮助。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;在介绍右值引用等概念之前，可以先来认识下浅拷贝（shallow copy）和深拷贝（deep copy）。&lt;/p&gt;
&lt;p&gt;这里举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class Vector{
    int num;
    int* a;
public:
    void ShallowCopy(Vector&amp;amp; v);
    void DeepCopy(Vector&amp;amp; v);
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;浅拷贝：按位拷贝对象，创建的新对象有着原始对象属性值的一份精确拷贝（但不包括指针指向的内存）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//浅拷贝
void Vector::ShallowCopy(Vector&amp;amp; v){
    this.num = v.num;
    this.a = v.a;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;深拷贝：拷贝所有的属性（包括属性指向的动态分配的内存）。换句话说，当对象和它所引用的对象一起拷贝时即发生深拷贝。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//深拷贝
void Vector::DeepCopy(Vector&amp;amp; v){
    this.num = v.num;
    this.a = new int[num];
    for(int i=0;i&amp;lt;num;++i){a[i]=v.a[i]}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，深拷贝的开销往往比浅拷贝大（除非没有指向动态分配内存的属性），所以我们就倾向尽可能使用浅拷贝。&lt;/p&gt;
&lt;p&gt;但是浅拷贝的有一个问题：当有指向动态分配内存的属性时，会造成多个对象共用这块动态分配内存，从而可能导致冲突。一个可行的办法是：每次做浅拷贝后，必须保证原始对象不再访问这块内存（即转移所有权），这样就保证这块内存永远只被一个对象使用。&lt;/p&gt;
&lt;p&gt;那有什么对象在被拷贝后可以保证不再访问这块内存呢？相信大家心里都有答案：临时对象。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;为了让编译器识别出临时对象，从而好做浅拷贝优化，于是C++引入了左值（lvalue）、右值（rvalue）的概念。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左值：表达式结束后依然存在的持久对象。&lt;/li&gt;
&lt;li&gt;右值：表达式结束后就不再存在的临时对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以取名左值右值，是因为在等式左边的值往往是持久存在的左值类型，在等式右边的表达式值往往是临时对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;a = ++b;
a = b+c*2;
a = func();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更直观的理解是：有变量名、可以取地址的对象都是左值，没有变量名、不可以取地址的都是右值。（因为有无变量名意味着这个对象是否在下一行代码时依然存在）&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;有了左值、右值的概念，我们就很清楚认识到右值都是些短暂存在的临时对象。&lt;/p&gt;
&lt;p&gt;于是，C++11 为了匹配这些左右值类型，引入了右值引用类型 &lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt; 。&lt;br/&gt;右值引用类型负责匹配右值，左值引用则负责匹配左值。&lt;/p&gt;
&lt;p&gt;因此刚刚的浅拷贝、深拷贝例子，我们可以无需显式调用浅拷贝或深拷贝函数，而是调用重载函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//左值引用形参=&amp;gt;匹配左值
void Vector::Copy(Vector&amp;amp; v){
    this.num = v.num;
    this.a = new int[num];
    for(int i=0;i&amp;lt;num;++i){a[i]=v.a[i]}
}

//右值引用形参=&amp;gt;匹配右值
void Vector::Copy(Vector&amp;amp;&amp;amp; temp){
    this.num = temp.num;
    this.a = temp.a;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，最标准还是编写成各种构造函数（拷贝构造、移动构造、赋值构造、移动赋值构造）：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;移动的意思是转移所有权。由于右值 &lt;strong&gt;大部分&lt;/strong&gt; 都是临时的值，临时值释放后也就不再持有属性的所有权，因此这相当于转移所有权的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//拷贝构造函数：这意味着深拷贝
Vector::Vector(Vector&amp;amp; v){
    this.num = v.num;
    this.a = new int[num];
    for(int i=0;i&amp;lt;num;++i){a[i]=v.a[i]}
}
//移动构造函数：这意味着浅拷贝
Vector::Vector(Vector&amp;amp;&amp;amp; temp){
    this.num = temp.num;
    this.a = temp.a;
    temp.a = nullptr;    //实际上Vector一般都会在析构函数来释放指向的内存，所以需赋值空地址避免释放
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然从优雅的实现深、浅拷贝这个目的开始出发，C++11的移动语义可以不止用于浅拷贝，得益于转移所有权的特性，我们还可以做其它事情，例如在右值所占有的空间临时存放一些东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;除了上面说的临时值，有些左值其实也很适合转移所有权：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void func(){
    Vector result;
    //...DoSomehing with ans
    if(xxx){ans = result;}  //现在我希望把结果提取到外部的变量a上。
    return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到result赋值给ans后就不再被使用，我们期望它调用的是移动赋值构造函数。&lt;br/&gt;但是result是一个有变量名的左值类型，因此ans = result 调用的是赋值构造函数而非移动赋值构造函数。&lt;/p&gt;
&lt;p&gt;为了将某些左值当成右值使用，C++11 提供了 &lt;strong&gt;std::move&lt;/strong&gt; 函数以用于将某些左值转成右值，以匹配右值引用类型。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这也是移动语义的由来：无论是临时值还是被强转的左值，只要遵守转移所有权的保证，都可以使用移动语义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void func(){
    Vector result;
    //...DoSomehing with ans
    if(xxx){ans = std::move(result);}   //调用的是移动赋值构造函数
    return;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h2 id=&quot;右值引用类型和右值的关系&quot;&gt;右值引用类型和右值的关系&lt;/h2&gt;
&lt;p&gt;有了上面的知识后，我们来重新审视一下右值引用类型。&lt;/p&gt;
&lt;p&gt;先看看如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void test(Vector&amp;amp; o) {std::cout &amp;lt;&amp;lt; &quot;为左值。&quot; &amp;lt;&amp;lt; std::endl;}
void test(Vector&amp;amp;&amp;amp; temp) {std::cout &amp;lt;&amp;lt; &quot;为右值。&quot; &amp;lt;&amp;lt; std::endl;}

int main(){
    Vector a;
        Vector&amp;amp;&amp;amp; b = Vector();
        //请分别回答：a、std::move(a)、b 分别是左值还是右值？
        test(a);
        test(std::move(a));
        test(b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答：a是左值，std::move(a)是右值，但b却是左值。&lt;/p&gt;
&lt;p&gt;在这里b虽然是 Vector&amp;amp;&amp;amp; 类型，但却因为有变量名（即可持久存在），被编译器认为是左值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//即使函数返还值是临时值，但返还类型是左值引用类型，因此被认为是持久存在的左值。
Vector&amp;amp; func1();
//函数返还值为右值引用类型=&amp;gt;是短暂存在的右值。
Vector&amp;amp;&amp;amp; func2();
//函数返还值为正常类型=&amp;gt;是短暂存在的右值。
Vector func3();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结论：右值引用类型只是用于匹配右值，而并非表示一个右值。因此，尽量不要声明右值引用类型的变量，而只在函数形参使用它以匹配右值。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;实际上C++ std::move的实现原理就是的强转右值引用类型并返还之，由于函数返还值类型是临时值，且返还的还是右值引用类型（非左值引用类型），因此该返还值会被判断为右值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数参数传递&quot;&gt;函数参数传递&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void func1(Vector v) {return;}
void func2(Vector &amp;amp;&amp;amp; v) {return;}

int main() {
        Vector a;
        Vector &amp;amp;b = a;
        Vector c;
        Vector d;

    //请回答：不开优化的版本下，调用以下函数分别有多少Copy Consturct、Move Construct的开销？
        func1(a);
        func1(b);
        func1(std::move(c));
        func2(std::move(d));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上在不开优化的版本下，如果实参为右值，调用func1的开销只比func2多了一次移动构造函数和析构函数。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;实参传递给形参，即形参会根据实参来构造。其结果是调用了移动构造函数；函数结束时则释放形参。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;倘若说对象的移动构造函数开销较低（例如内部仅一个指针属性），那么使用无引用类型的形参函数是更优雅的选择，而且还能接受左值引用类型或无引用的实参（尽管这两种实参都会导致一次Copy Consturct）。&lt;/p&gt;
&lt;p&gt;那我们在写一般函数形参的时候，有必要每个函数都提供关于&amp;amp;&amp;amp;形参的重载版本吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回答：一般来说是没必要的。对象的移动构造（赋值）函数开销不大时，我们可以只提供非引用类型和左值引用类型（避免Copy Construct）的重载版本，而不必编写右值引用类型的重载版本。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数返还值传递&quot;&gt;函数返还值传递&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;Vector func1() {
    Vector a;
        return a;
}

Vector func2() {
        Vector a;
        return std::move(a);
}

Vector&amp;amp;&amp;amp; func3() {
        Vector a;
        return std::move(a);
}

int main() {
    //请回答：不开优化的版本下，执行以下3行代码分别有多少Copy Consturct、Move Construct的开销？
        Vector test1 = func1();
        Vector test2 = func2();
        Vector test3 = func3();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的道理，执行这3行代码实际上都没有任何Copy Construct的开销（这其中也有NRV技术的功劳），都是只有一次Move Construct的开销。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此外一提，func3是危险的。因为局部变量释放后，函数返还值仍持有它的右值引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，这里也不建议函数返还右值引用类型，同前面传递参数类似的，移动构造开销不大的时候，直接返还非引用类型就足够了（在某些特殊场合有特别作用，例如std::move的实现）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：我们应该把编写右值引用类型相关的任务放在对象的构造、赋值函数上，而非一般函数。从源头上出发，你就会发现在编写其它代码时就会自然而然享受到了移动构造、移动赋值的优化效果。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;接下来的内容都是属于模板的部分了：万能引用、引用折叠、完美转发。这部分更加难以理解，不编写模板代码的话可以绕道了。&lt;/p&gt;
&lt;p&gt;万能引用（Universal Reference）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发生类型推导（例如模板、auto）的时候，使用T&amp;amp;&amp;amp;类型表示为万能引用，否则表示右值引用。&lt;/li&gt;
&lt;li&gt;万能引用类型的形参既能匹配任意引用类型的左值、右值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说编写模板函数时，只提供万能引用形参一个版本就可以匹配左值、右值，不必编写多个重载版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;class T&amp;gt;
void func(T&amp;amp;&amp;amp; t){
    return;
}

int main() {
    Vector a,b;
        func(a);                //OK
        func(std::move(b));     //OK
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此外需要注意的是，使用万能引用参数的函数是最贪婪的函数，容易让需要隐式转换的实参匹配到不希望的转发引用函数。例如下面代码：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;class T&amp;gt;
  void f(T&amp;amp;&amp;amp; value);

void f(int a);
//当调用f(long类型的参数)或者f(short类型的参数)，则不会匹配int版本而是匹配到万能引用的版本
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;p&gt;使用万能引用遇到的第一个问题是推导类型会出现不正确的引用类型：例如当模板参数T为Vector&amp;amp;或Vector&amp;amp;&amp;amp;，模板函数形参为T&amp;amp;&amp;amp;时，展开后变成Vector&amp;amp; &amp;amp;&amp;amp;或者Vector&amp;amp;&amp;amp; &amp;amp;&amp;amp;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;class T&amp;gt;
void func(T&amp;amp;&amp;amp; t){
    return;
}

int main(){
    func(Vector()); //模板参数T被推导为Vector&amp;amp;&amp;amp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但显然C++中是不允许对引用再进行引用的，于是为了让模板参数正确传递引用性质，C++定义了一套用于推导类型的引用折叠（Reference Collapse）规则：&lt;br/&gt;所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;引用折叠&lt;/th&gt;
&lt;th&gt;&amp;amp;&lt;/th&gt;
&lt;th&gt;&amp;amp;&amp;amp;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Example1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;func(Vector());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模板函数func的T被推导为Vector&amp;amp;&amp;amp;，形参object为T&amp;amp;&amp;amp;即展开后为Vector&amp;amp;&amp;amp; &amp;amp;&amp;amp;。由于折叠规则的存在，形参object最终被折叠推导为Vector&amp;amp;&amp;amp;类型。&lt;/p&gt;
&lt;p&gt;Example2：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;func(a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模板函数func的T在这里被推导为Vector&amp;amp;，形参object为T&amp;amp;&amp;amp;即展开后为Vector&amp;amp; &amp;amp;&amp;amp;。由于折叠规则的存在，形参object最终被推导为Vector&amp;amp;类型。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;当我们使用了万能引用时，即使可以同时匹配左值、右值，但需要转发参数给其他函数时，会丢失引用性质（形参是个左值，从而无法判断到底匹配的是个左值还是右值）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//当然我们也可以写成如下重载代码，但是这已经违背了使用万能引用的初衷（仅编写一个模板函数就可以匹配左值、右值）
template&amp;lt;class T&amp;gt;
void func(T&amp;amp; t){
    doSomething(t);
}

template&amp;lt;class T&amp;gt;
void func(T&amp;amp;&amp;amp; t){
    doSomething(std::move(t));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美转发（Perfect Forwarding）：C++11提供了完美转发函数 &lt;strong&gt;std:forward&amp;lt;T&amp;gt;&lt;/strong&gt; 。它可以在模板函数内给另一个函数传递参数时，将参数类型保持原本状态传入（如果形参推导出是右值引用则作为右值传入，如果是左值引用则作为左值传入）。&lt;/p&gt;
&lt;p&gt;于是现在我们可以这样做了:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;class T&amp;gt;
void func(T&amp;amp;&amp;amp; object){
    doSomething(std::forward&amp;lt;T&amp;gt;(object));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不借助std::forward&amp;lt;T&amp;gt;间接传入参数的话，无论object是左值引用类型，还是右值引用类型，都会被视为左值。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;std::forward&amp;lt;T&amp;gt;()的实现主要就一句return static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(形参)，实际上也是利用了折叠规则。从而接受右值引用类型时，将右值引用类型的值返还（返还值为右值）。接受左值引用类型时，将左值引用类型的值返还（返还值为左值）。&lt;/p&gt;
&lt;p&gt;而std::move&amp;lt;T&amp;gt;()的实现还需要先移除形参的所有引用性质得到无引用性质的类型（假设为T2），然后再return static_cast&amp;lt;T2&amp;amp;&amp;amp;&amp;gt;(形参)，从而保证不会发生引用折叠，而是直接作为右值引用类型的值返还（返还值为右值）。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 30 Apr 2020 14:59:00 +0000</pubDate>
<dc:creator>KillerAery</dc:creator>
<og:description>[toc] C++11出现的右值相关语法可谓是很多C++程序员难以理解的新特性，不少人知其然而不知其所以然，面试被问到时大概就只知道可以减少开销，但是为什么减少开销、减少了多少开销、什么时候用...这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/KillerAery/p/12802771.html</dc:identifier>
</item>
<item>
<title>Java中的小数运算与精度损失 - wunsiang</title>
<link>http://www.cnblogs.com/wunsiang/p/12811661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wunsiang/p/12811661.html</guid>
<description>&lt;p&gt;在阅读《阿里巴巴java开发手册》时看到了关于float做精度运算时的要求，就顺便把Java中有关浮点运算部分梳理下，做个总结。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;129.5&quot;&gt;
&lt;h2 id=&quot;float、double类型的问题&quot;&gt;float、double类型的问题&lt;/h2&gt;
&lt;p&gt;我们都知道，计算机是使用二进制存储数据的。而平常生活中，大多数情况下我们都是使用的十进制，因此计算机显示给我们看的内容大多数也是十进制的，这就使得很多时候数据需要在二进制与十进制之间进行转换。对于整数来说，两种进制可以做到一一对应。而对于小数来讲就不是这样的啦。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们先来看看十进制小数转二进制小数的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对小数点以后的数乘以2，会得到一个结果，取结果的整数部分（不是1就是0），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了。顺序取每次运算得到的整数部分，即为转换后的小数部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;演示： 
0.125 ×2=0.25 .......................0
0.25×2=0.5.............................0
0.5×2=1.0................................1
即 0.125的二进制表示为小数部分为0.001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我们可以看出，这种方法实质上就是用1/2,1/4,8/1...来组合加出我们要转换的数据值，但显然不是所有的数都能够组合出来的。如0.1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 0.1×2=0.2 .....................0

 0.2×2=0.4 ......................0

 0.4×2=0.8 .....................0

 0.8×2=1.6.......................1

 0.6×2=1.2.......................1

 0.2×2=0.4.......................0
 .....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述计算过程我们可以看出，这是个无限小数，所以在这种情况下我们的float、double只能舍去一些位。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;那为什么我们在直接给float赋值在输出时没有看到精度损失而在运算时却会出现呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确实是这样，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;float a = 0.2f;
System.out.println(a);
//输出0.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述情况我只是查了资料，好像是因为编译器会进行优化，当我们存储的数据特别接近的时候，编译器会很贴心的返回我们想看到的数值（即二进制浮点数并不能准确的表示0.1这个十进制小数，它使用了0.100000001490116119384765625来代替0.1。），至于到了运算中，就会出现精度损失较大从而看到了真相。如果这块说的不对欢迎小伙伴们在评论区指正！&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;h3 id=&quot;bigdecimal-原理&quot;&gt;BigDecimal 原理&lt;/h3&gt;
&lt;p&gt;我们一般会使用&lt;br/&gt;BigDecimal 来避免出现精度丢失问题，至于为什么BigDecimal 可以避免，而float或double不行，我们在此不详细讨论，简单来说就是&lt;strong&gt;BigDecimal 通过借助整数来表示小数的方式&lt;/strong&gt;，因为对于整数而言，二进制和十进制是完全一一对应的，用整数来表示小数，再记录下小数的位数，就可以完美的解决该问题。&lt;/p&gt;
&lt;h3 id=&quot;bigdecimal-用法&quot;&gt;BigDecimal 用法&lt;/h3&gt;
&lt;p&gt;java.math.BinInteger 类和 java.math.BigDecimal 类都是Java提供的用于高精度计算的类.其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类.&lt;/p&gt;
&lt;h4 id=&quot;bigdecimal构造方法&quot;&gt;BigDecimal构造方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;BigDecimal BigDecimal(double d); //不允许使用
BigDecimal BigDecimal(String s); //常用,推荐使用
static BigDecimal valueOf(double d); //常用,推荐使用
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值;&lt;/li&gt;
&lt;li&gt;String 构造方法是完全可预知的: 写入 new BigDecimal(&quot;0.1&quot;) 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法;&lt;/li&gt;
&lt;li&gt;静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;System.out.println(new BigDecimal(0.1));
System.out.println(BigDecimal.valueOf(0.1));
\\输出*****************************************
0.1000000000000000055511151231257827021181583404541015625
0.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bigdecimal常用操作&quot;&gt;BigDecimal常用操作&lt;/h4&gt;
&lt;p&gt;我们通过一个工具类源码来体会BigDecimal的常规用法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.util;
 
import java.math.BigDecimal;
 
/**
 * 提供精确的浮点数运算(包括加、减、乘、除、四舍五入)工具类
 */
public class ArithUtil {
 
        // 除法运算默认精度
        private static final int DEF_DIV_SCALE = 10;
 
        private ArithUtil() {
 
        }
 
        /**
         * 精确加法
         */
        public static double add(double value1, double value2) {
                BigDecimal b1 = BigDecimal.valueOf(value1);
                BigDecimal b2 = BigDecimal.valueOf(value2);
                return b1.add(b2).doubleValue();
        }
 
        /**
         * 精确减法
         */
        public static double sub(double value1, double value2) {
                BigDecimal b1 = BigDecimal.valueOf(value1);
                BigDecimal b2 = BigDecimal.valueOf(value2);
                return b1.subtract(b2).doubleValue();
        }
 
        /**
         * 精确乘法
         */
        public static double mul(double value1, double value2) {
                BigDecimal b1 = BigDecimal.valueOf(value1);
                BigDecimal b2 = BigDecimal.valueOf(value2);
                return b1.multiply(b2).doubleValue();
        }
 
        /**
         * 精确除法 使用默认精度
         */
        public static double div(double value1, double value2) throws IllegalAccessException {
                return div(value1, value2, DEF_DIV_SCALE);
        }
 
        /**
         * 精确除法
         * @param scale 精度
         */
        public static double div(double value1, double value2, int scale) throws IllegalAccessException {
                if(scale &amp;lt; 0) {
                        throw new IllegalAccessException(&quot;精确度不能小于0&quot;);
                }
                BigDecimal b1 = BigDecimal.valueOf(value1);
                BigDecimal b2 = BigDecimal.valueOf(value2);
                // return b1.divide(b2, scale).doubleValue();
                return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();
        }
 
        /**
         * 四舍五入
         * @param scale 小数点后保留几位
         */
        public static double round(double v, int scale) throws IllegalAccessException {
                return div(v, 1, scale);
        }
        
        /**
         * 比较大小
         */
        public static boolean equalTo(BigDecimal b1, BigDecimal b2) {
                if(b1 == null || b2 == null) {
                        return false;
                }
                return 0 == b1.compareTo(b2);
        }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 30 Apr 2020 14:56:00 +0000</pubDate>
<dc:creator>wunsiang</dc:creator>
<og:description>在阅读《阿里巴巴java开发手册》时看到了关于float做精度运算时的要求，就顺便把Java中有关浮点运算部分梳理下，做个总结。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wunsiang/p/12811661.html</dc:identifier>
</item>
<item>
<title>C#多线程(16)：手把手教你撸一个工作流 - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/12811429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/12811429.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面学习了很多多线程和任务的基础知识，这里要来实践一下啦。通过本篇教程，你可以写出一个简单的工作流引擎。&lt;/p&gt;
&lt;p&gt;本篇教程内容完成是基于任务的，只需要看过笔者的三篇关于异步的文章，掌握 C# 基础，即可轻松完成。&lt;/p&gt;
&lt;p&gt;由于本篇文章编写的工作流程序，主要使用任务，有些逻辑过程会比较难理解，多测试一下就好。代码主要还是 C# 基础，为什么说简单？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不包含 async 、await&lt;/li&gt;
&lt;li&gt;几乎不含包含多线程(有个读写锁)&lt;/li&gt;
&lt;li&gt;不包含表达式树&lt;/li&gt;
&lt;li&gt;几乎不含反射(有个小地方需要反射一下，但是非常简单)&lt;/li&gt;
&lt;li&gt;没有复杂的算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为是基于任务(Task)的，所以可以轻松设计组合流程，组成复杂的工作流。&lt;/p&gt;
&lt;p&gt;由于只是讲述基础，所以不会包含很多种流程控制，这里只实现一些简单的。&lt;/p&gt;
&lt;p&gt;先说明，别用到业务上。。。这个工作流非常简单，就几个功能，这个工作流是基于笔者的多线程系列文章的知识点。写这个东西是为了讲解任务操作，让读者更加深入理解任务。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/whuanle/CZGL.FLow&quot;&gt;https://github.com/whuanle/CZGL.FLow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两天忙着搬东西，今天没认真写文章，代码不明白的地方，可以到微信群找我。微信名称：痴者工良，dotnet 的群基本我都在。&lt;/p&gt;
&lt;h2 id=&quot;节点&quot;&gt;节点&lt;/h2&gt;
&lt;p&gt;在开始前，我们来设计几种流程控制的东西。&lt;/p&gt;
&lt;p&gt;将一个 步骤/流程/节点 称为 step。&lt;/p&gt;
&lt;h3 id=&quot;then&quot;&gt;Then&lt;/h3&gt;
&lt;p&gt;一个普通的节点，包含一个任务。&lt;/p&gt;
&lt;p&gt;多个 Then 节点，可以组成一条连续的工作流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202004/1315495-20200430220622058-489359544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;parallel&quot;&gt;Parallel&lt;/h3&gt;
&lt;p&gt;并行节点，可以设置多个并行节点放到 Parallel 中，以及在里面为任一个节点创建新的分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202004/1315495-20200430220652329-699283834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;schedule&quot;&gt;Schedule&lt;/h3&gt;
&lt;p&gt;定时节点，创建后会在一定时间后执行节点中的任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202004/1315495-20200430220708154-698640693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;delay&quot;&gt;Delay&lt;/h3&gt;
&lt;p&gt;让当前任务阻塞一段时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202004/1315495-20200430220841819-1384392480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;试用一下&quot;&gt;试用一下&lt;/h2&gt;
&lt;h3 id=&quot;顺序节点&quot;&gt;顺序节点&lt;/h3&gt;
&lt;p&gt;打开你的 VS ，创建项目，Nuget 引用 &lt;code&gt;CZGL.DoFlow&lt;/code&gt; ，版本 1.0.2 。&lt;/p&gt;
&lt;p&gt;创建一个类 &lt;code&gt;MyFlow1&lt;/code&gt;，继承 &lt;code&gt;IDoFlow&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class MyFlow1 : IDoFlow
    {
        public int Id =&amp;gt; 1;

        public string Name =&amp;gt; &quot;随便起个名字&quot;;

        public int Version =&amp;gt; 1;

        public IDoFlowBuilder Build(IDoFlowBuilder builder)
        {
            throw new NotImplementedException();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以创建多个工作流任务，每个工作流的 Id 必须唯一。Name 和 Version 随便填，因为这里笔者没有对这几个字段做逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDoFlowBuilder&lt;/code&gt; 是构建工作流的一个接口。&lt;/p&gt;
&lt;p&gt;我们来写一个工作流测试一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 普通节点 Then 使用方法
/// &amp;lt;/summary&amp;gt;
public class MyFlow1 : IDoFlow
{
    public int Id =&amp;gt; 1;
    public string Name =&amp;gt; &quot;test&quot;;
    public int Version =&amp;gt; 1;

    public IDoFlowBuilder Build(IDoFlowBuilder builder)
    {
        builder.StartWith(() =&amp;gt;
        {
            Console.WriteLine(&quot;工作流开始&quot;);
        }).Then(() =&amp;gt;
        {
            Console.WriteLine(&quot;下一个节点&quot;);
        }).Then(() =&amp;gt;
         {
             Console.WriteLine(&quot;最后一个节点&quot;);
         });
        return builder;
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Main 方法中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        static void Main(string[] args)
        {
            FlowCore.RegisterWorkflow&amp;lt;MyFlow1&amp;gt;();
            // FlowCore.RegisterWorkflow(new MyFlow1());
            FlowCore.Start(1);
            Console.ReadKey();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.StartWith()&lt;/code&gt; 方法开始一个工作流；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FlowCore.RegisterWorkflow&amp;lt;T&amp;gt;()&lt;/code&gt; 注册一个工作流；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FlowCore.Start();&lt;/code&gt;执行一个工作流；&lt;/p&gt;
&lt;h3 id=&quot;并行任务&quot;&gt;并行任务&lt;/h3&gt;
&lt;p&gt;其代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    /// &amp;lt;summary&amp;gt;
    /// 并行节点 Parallel 使用方法
    /// &amp;lt;/summary&amp;gt;
    public class MyFlow2 : IDoFlow
    {
        public int Id =&amp;gt; 2;
        public string Name =&amp;gt; &quot;test&quot;;
        public int Version =&amp;gt; 1;

        public IDoFlowBuilder Build(IDoFlowBuilder builder)
        {
            builder.StartWith()
                .Parallel(steps =&amp;gt;
                {
                    // 每个并行任务也可以设计后面继续执行其它任务
                    steps.Do(() =&amp;gt;
                    {
                        Console.WriteLine(&quot;并行1&quot;);
                    }).Do(() =&amp;gt;
                    {
                        Console.WriteLine(&quot;并行2&quot;);
                    });
                    steps.Do(() =&amp;gt;
                    {
                        Console.WriteLine(&quot;并行3&quot;);
                    });

                    // 并行任务设计完成后，必须调用此方法
                    // 此方法必须放在所有并行任务 .Do() 的最后
                    steps.EndParallel();

                    // 如果 .Do() 在 EndParallel() 后，那么不会等待此任务
                    steps.Do(() =&amp;gt; { Console.WriteLine(&quot;并行异步&quot;); });

                    // 开启新的分支
                    steps.StartWith()
                    .Then(() =&amp;gt;
                    {
                        Console.WriteLine(&quot;新的分支&quot; + Task.CurrentId);
                    }).Then(() =&amp;gt; { Console.WriteLine(&quot;分支2.0&quot; + Task.CurrentId); });

                }, false)
                .Then(() =&amp;gt;
                {
                    Console.WriteLine(&quot;11111111111111111 &quot;);
                });

            return builder;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Main 方法中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        static void Main(string[] args)
        {
            FlowCore.RegisterWorkflow&amp;lt;MyFlow2&amp;gt;();
            FlowCore.Start(2);
            Console.ReadKey();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上示例，可以大概了解本篇文章中我们要写的程序。&lt;/p&gt;
&lt;h2 id=&quot;编写工作流&quot;&gt;编写工作流&lt;/h2&gt;
&lt;p&gt;建立一个类库项目，名为 &lt;code&gt;DoFlow&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;建立 &lt;code&gt;Extensions&lt;/code&gt;、&lt;code&gt;Interfaces&lt;/code&gt;、&lt;code&gt;Services&lt;/code&gt; 三个目录。&lt;/p&gt;
&lt;h3 id=&quot;接口构建器&quot;&gt;接口构建器&lt;/h3&gt;
&lt;p&gt;新建 &lt;code&gt;IStepBuilder&lt;/code&gt; 接口文件到 &lt;code&gt;Interfaces&lt;/code&gt; 目录，其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

namespace DoFlow.Interfaces
{
    public interface IStepBuilder
    {
        /// &amp;lt;summary&amp;gt;
        /// 普通节点
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;stepBuilder&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepBuilder Then(Action action);

        /// &amp;lt;summary&amp;gt;
        /// 多个节点
        /// &amp;lt;para&amp;gt;默认下，需要等待所有的任务完成，这个step才算完成&amp;lt;/para&amp;gt;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;anyWait&quot;&amp;gt;任意一个任务完成即可跳转到下一个step&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepBuilder Parallel(Action&amp;lt;IStepParallel&amp;gt; action, bool anyWait = false);

        /// &amp;lt;summary&amp;gt;
        /// 节点将在某个时间间隔后执行
        /// &amp;lt;para&amp;gt;异步，不会阻塞当前工作流的运行，计划任务将在一段时间后触发&amp;lt;/para&amp;gt;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepBuilder Schedule(Action action, TimeSpan time);

        /// &amp;lt;summary&amp;gt;
        /// 阻塞一段时间
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepBuilder Delay(TimeSpan time);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;IStepParallel&lt;/code&gt; 文件到 &lt;code&gt;Interfaces&lt;/code&gt; 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

namespace DoFlow.Interfaces
{
    /// &amp;lt;summary&amp;gt;
    /// 并行任务
    ///  &amp;lt;para&amp;gt;默认情况下，只有这个节点的所有并行任务都完成后，这个节点才算完成&amp;lt;/para&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public interface IStepParallel
    {
        /// &amp;lt;summary&amp;gt;
        /// 一个并行任务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepParallel Do(Action action);

        /// &amp;lt;summary&amp;gt;
        /// 开始一个分支
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IStepBuilder StartWith(Action action = null);

        /// &amp;lt;summary&amp;gt;
        /// 必须使用此方法结束一个并行任务
        /// &amp;lt;/summary&amp;gt;
        void EndParallel();
    }

    /// &amp;lt;summary&amp;gt;
    /// 并行任务
    /// &amp;lt;para&amp;gt;任意一个任务完成后，就可以跳转到下一个 step&amp;lt;/para&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public interface IStepParallelAny : IStepParallel
    {

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;工作流构建器&quot;&gt;工作流构建器&lt;/h3&gt;
&lt;p&gt;新建 &lt;code&gt;IDoFlowBuilder&lt;/code&gt; 接口文件到 &lt;code&gt;Interfaces&lt;/code&gt; 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Threading.Tasks;

namespace DoFlow.Interfaces
{
    /// &amp;lt;summary&amp;gt;
    /// 构建工作流任务
    /// &amp;lt;/summary&amp;gt;
    public interface IDoFlowBuilder
    {
        /// &amp;lt;summary&amp;gt;
        /// 开始一个 step
        /// &amp;lt;/summary&amp;gt;
        IStepBuilder StartWith(Action action = null);
        void EndWith(Action action);

        Task ThatTask { get; }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;IDoFlow&lt;/code&gt; 接口文件到 &lt;code&gt;Interfaces&lt;/code&gt; 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace DoFlow.Interfaces
{

    /// &amp;lt;summary&amp;gt;
    /// 工作流
    /// &amp;lt;para&amp;gt;无参数传递&amp;lt;/para&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public interface IDoFlow
    {
        /// &amp;lt;summary&amp;gt;
        /// 全局唯一标识
        /// &amp;lt;/summary&amp;gt;
        int Id { get; }

        /// &amp;lt;summary&amp;gt;
        /// 标识此工作流的名称
        /// &amp;lt;/summary&amp;gt;
        string Name { get; }

        /// &amp;lt;summary&amp;gt;
        /// 标识此工作流的版本
        /// &amp;lt;/summary&amp;gt;
        int Version { get; }

        IDoFlowBuilder Build(IDoFlowBuilder builder);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;新建 &lt;code&gt;DependencyInjectionService&lt;/code&gt; 文件到 &lt;code&gt;Services&lt;/code&gt; 目录。&lt;/p&gt;
&lt;p&gt;用于实现依赖注入和解耦。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Extensions;
using Microsoft.Extensions.DependencyInjection;
using System;

namespace DoFlow.Services
{
    /// &amp;lt;summary&amp;gt;
    /// 依赖注入服务
    /// &amp;lt;/summary&amp;gt;
    public static class DependencyInjectionService
    {
        private static IServiceCollection _servicesList;
        private static IServiceProvider _services;
        static DependencyInjectionService()
        {
            IServiceCollection services = new ServiceCollection();
            _servicesList = services;
            // 注入引擎需要的服务
            InitExtension.StartInitExtension();
            var serviceProvider = services.BuildServiceProvider();
            _services = serviceProvider;
        }

        /// &amp;lt;summary&amp;gt;
        /// 添加一个注入到容器服务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TService&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;typeparam name=&quot;TImplementation&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        public static void AddService&amp;lt;TService, TImplementation&amp;gt;()
            where TService : class
            where TImplementation : class, TService
        {
            _servicesList.AddTransient&amp;lt;TService, TImplementation&amp;gt;();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取需要的服务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TIResult&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static TIResult GetService&amp;lt;TIResult&amp;gt;()
        {
            TIResult Tservice = _services.GetService&amp;lt;TIResult&amp;gt;();
            return Tservice;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个 &lt;code&gt;InitExtension&lt;/code&gt; 文件到 &lt;code&gt;Extensions&lt;/code&gt; 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;
using DoFlow.Services;

namespace DoFlow.Extensions
{
    public static class InitExtension
    {
        private static bool IsInit = false;
        public static void StartInitExtension()
        {
            if (IsInit) return;
            IsInit = true;
            DependencyInjectionService.AddService&amp;lt;IStepBuilder, StepBuilder&amp;gt;();
            DependencyInjectionService.AddService&amp;lt;IDoFlowBuilder, DoFlowBuilder&amp;gt;();
            DependencyInjectionService.AddService&amp;lt;IStepParallel, StepParallelWhenAll&amp;gt;();
            DependencyInjectionService.AddService&amp;lt;IStepParallelAny, StepParallelWhenAny&amp;gt;();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现工作流解析&quot;&gt;实现工作流解析&lt;/h3&gt;
&lt;p&gt;以下文件均在 &lt;code&gt;Services&lt;/code&gt; 目录建立。&lt;/p&gt;
&lt;p&gt;新建 &lt;code&gt;StepBuilder&lt;/code&gt; 文件，用于解析节点，构建任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;
using System;
using System.Threading.Tasks;

namespace DoFlow.Services
{

    /// &amp;lt;summary&amp;gt;
    /// 节点工作引擎
    /// &amp;lt;/summary&amp;gt;
    public class StepBuilder : IStepBuilder
    {
        private Task _task;

        /// &amp;lt;summary&amp;gt;
        /// 延迟执行
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IStepBuilder Delay(TimeSpan time)
        {
            Task.Delay(time).Wait();
            return this;
        }

        /// &amp;lt;summary&amp;gt;
        /// 并行 step
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IStepBuilder Parallel(Action&amp;lt;IStepParallel&amp;gt; action, bool anyAwait = false)
        {
            IStepParallel parallel = anyAwait ? DependencyInjectionService.GetService&amp;lt;IStepParallelAny&amp;gt;() : DependencyInjectionService.GetService&amp;lt;IStepParallel&amp;gt;();
            Task task = new Task(() =&amp;gt;
            {
                action.Invoke(parallel);
            });

            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt;
            {
                task.Start();
            });
            _task = task;
            return this;
        }

        /// &amp;lt;summary&amp;gt;
        /// 计划任务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;time&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IStepBuilder Schedule(Action action, TimeSpan time)
        {
            Task.Factory.StartNew(() =&amp;gt;
            {
                Task.Delay(time).Wait();
                action.Invoke();
            });
            return this;
        }

        /// &amp;lt;summary&amp;gt;
        /// 普通 step
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;action&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IStepBuilder Then(Action action)
        {
            Task task = new Task(action);
            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt;
            {
                task.Start();
                task.Wait();
            });
            _task = task;
            return this;
        }

        public void SetTask(Task task)
        {
            _task = task;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;StepParallel&lt;/code&gt; 文件，里面有两个类，用于实现同步任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace DoFlow.Services
{
    /// &amp;lt;summary&amp;gt;
    /// 第一层所有任务结束后才能跳转下一个 step
    /// &amp;lt;/summary&amp;gt;
    public class StepParallelWhenAll : IStepParallel
    {
        private Task _task;
        private readonly List&amp;lt;Task&amp;gt; _tasks = new List&amp;lt;Task&amp;gt;();
        public StepParallelWhenAll()
        {
            _task = new Task(() =&amp;gt; { },TaskCreationOptions.AttachedToParent);
        }
        public IStepParallel Do(Action action)
        {
            _tasks.Add(Task.Run(action));
            return this;
        }

        public void EndParallel()
        {
            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt;
            {
                Task.WhenAll(_tasks).Wait();
            });
        }

        public IStepBuilder StartWith(Action action = null)
        {
            Task task =
                action is null ? new Task(() =&amp;gt; { })
                : new Task(action);
            var _stepBuilder = DependencyInjectionService.GetService&amp;lt;IStepBuilder&amp;gt;();
            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt; { task.Start(); });

            return _stepBuilder;
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 完成任意一个任务即可跳转到下一个 step
    /// &amp;lt;/summary&amp;gt;
    public class StepParallelWhenAny : IStepParallelAny
    {
        private Task _task;
        private readonly List&amp;lt;Task&amp;gt; _tasks = new List&amp;lt;Task&amp;gt;();
        public StepParallelWhenAny()
        {
            _task = Task.Run(() =&amp;gt; { });
        }
        public IStepParallel Do(Action action)
        {
            _tasks.Add(Task.Run(action));
            return this;
        }

        public void EndParallel()
        {
            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt;
            {
                Task.WhenAny(_tasks).Wait();
            });
        }

        public IStepBuilder StartWith(Action action = null)
        {
            Task task =
                action is null ? new Task(() =&amp;gt; { })
                : new Task(action);
            var _stepBuilder = DependencyInjectionService.GetService&amp;lt;IStepBuilder&amp;gt;();
            _task.ConfigureAwait(false).GetAwaiter().OnCompleted(() =&amp;gt; { task.Start(); });

            return _stepBuilder;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;DoFlowBuilder&lt;/code&gt; 文件，用于构建工作流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;
using System;
using System.Threading.Tasks;

namespace DoFlow.Services
{
    public class DoFlowBuilder : IDoFlowBuilder
    {
        private Task _task;
        public Task ThatTask =&amp;gt; _task;

        public void EndWith(Action action)
        {
            _task.Start();
        }

        public IStepBuilder StartWith(Action action = null)
        {
            if (action is null)
                _task = new Task(() =&amp;gt; { });
            else _task = new Task(action);

            IStepBuilder _stepBuilder = DependencyInjectionService.GetService&amp;lt;IStepBuilder&amp;gt;();
            ((StepBuilder)_stepBuilder).SetTask(_task);
            return _stepBuilder;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;FlowEngine&lt;/code&gt; 文件，用于执行工作流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;

namespace DoFlow.Services
{
    /// &amp;lt;summary&amp;gt;
    /// 工作流引擎
    /// &amp;lt;/summary&amp;gt;
    public class FlowEngine
    {
        private readonly IDoFlow _flow;
        public FlowEngine(IDoFlow flow)
        {
            _flow = flow;
        }

        /// &amp;lt;summary&amp;gt;
        /// 开始一个工作流
        /// &amp;lt;/summary&amp;gt;
        public void Start()
        {
            IDoFlowBuilder builder = DependencyInjectionService.GetService&amp;lt;IDoFlowBuilder&amp;gt;();
            _flow.Build(builder).ThatTask.Start();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 &lt;code&gt;FlowCore&lt;/code&gt; 文件，用于存储和索引工作流。使用读写锁解决并发字典问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using DoFlow.Interfaces;
using System;
using System.Collections.Generic;
using System.Threading;

namespace DoFlow.Services
{
    public static class FlowCore
    {
        private static Dictionary&amp;lt;int, FlowEngine&amp;gt; flowEngines = new Dictionary&amp;lt;int, FlowEngine&amp;gt;();

        // 读写锁
        private static ReaderWriterLockSlim readerWriterLockSlim = new ReaderWriterLockSlim();

        /// &amp;lt;summary&amp;gt;
        /// 注册工作流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;flow&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static bool RegisterWorkflow(IDoFlow flow)
        {
            try
            {
                readerWriterLockSlim.EnterReadLock();
                if (flowEngines.ContainsKey(flow.Id))
                    return false;
                flowEngines.Add(flow.Id, new FlowEngine(flow));
                return true;
            }
            finally
            {
                readerWriterLockSlim.ExitReadLock();
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 注册工作流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;flow&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static bool RegisterWorkflow&amp;lt;TDoFlow&amp;gt;()
        {

            Type type = typeof(TDoFlow);
            IDoFlow flow = (IDoFlow)Activator.CreateInstance(type);
            try
            {
                readerWriterLockSlim.EnterReadLock();
                if (flowEngines.ContainsKey(flow.Id))
                    return false;
                flowEngines.Add(flow.Id, new FlowEngine(flow));
                return true;
            }
            finally
            {
                readerWriterLockSlim.ExitReadLock();
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 要启动的工作流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static bool Start(int id)
        {
            FlowEngine engine;
            // 读写锁
            try
            {
                readerWriterLockSlim.EnterUpgradeableReadLock();

                if (!flowEngines.ContainsKey(id))
                    return default;
                try
                {
                    readerWriterLockSlim.EnterWriteLock();
                    engine = flowEngines[id];
                }
                catch { return default; }
                finally
                {
                    readerWriterLockSlim.ExitWriteLock();
                }
            }
            catch { return default; }
            finally
            {
                readerWriterLockSlim.ExitUpgradeableReadLock();
            }

            engine.Start();
            return true;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样程序写完了。&lt;/p&gt;
&lt;p&gt;忙去了。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Apr 2020 14:08:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>[TOC] 前言 前面学习了很多多线程和任务的基础知识，这里要来实践一下啦。通过本篇教程，你可以写出一个简单的工作流引擎。 本篇教程内容完成是基于任务的，只需要看过笔者的三篇关于异步的文章，掌握 C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whuanle/p/12811429.html</dc:identifier>
</item>
</channel>
</rss>