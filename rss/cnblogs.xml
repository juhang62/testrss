<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[C#.NET 拾遗补漏]13：动态构建LINQ查询表达式 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/14040435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/14040435.html</guid>
<description>&lt;p&gt;最近工作中遇到一个这样的需求：在某个列表查询功能中，可以选择某个数字列（如商品单价、当天销售额、当月销售额等），再选择 &lt;code&gt;小于或等于&lt;/code&gt; 和 &lt;code&gt;大于或等于&lt;/code&gt; ，再填写一个待比较的数值，对数据进行查询过滤。&lt;/p&gt;
&lt;p&gt;如果只有一两个这样的数字列，那么使用 Entity Framework Core 可以这么写 LINQ 查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public Task&amp;lt;List&amp;lt;Product&amp;gt;&amp;gt; GetProductsAsync(string propertyToFilter, MathOperator mathOperator, decimal value)
{
    var query =  _context.Products.AsNoTracking();

    query = propertyToFilter switch
    {
        &quot;Amount1&quot; when mathOperator == MathOperator.LessThanOrEqual =&amp;gt; query.Where(x =&amp;gt; x.Amount1 &amp;lt;= value),
        &quot;Amount1&quot; when mathOperator == MathOperator.GreaterThanOrEqual =&amp;gt; query.Where(x =&amp;gt; x.Amount1 &amp;gt;= value),

        &quot;Amount2&quot; when mathOperator == MathOperator.LessThanOrEqual =&amp;gt; query.Where(x =&amp;gt; x.Amount2 &amp;lt;= value),
        &quot;Amount2&quot; when mathOperator == MathOperator.GreaterThanOrEqual =&amp;gt; query.Where(x =&amp;gt; x.Amount2 &amp;gt;= value),

        _ =&amp;gt; throw new ArgumentException($&quot;不支持 {propertyToFilter} 列作为数字列查询&quot;, nameof(propertyToFilter))
    };

    return query.ToListAsync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果固定只有一两个数字列且将来也不会再扩展，这样写简单粗暴，也没什么问题。&lt;/p&gt;
&lt;p&gt;但如果有几十个数字列，这样使用 &lt;code&gt;swith&lt;/code&gt; 模式匹配的写法就太恐怖了，代码大量重复。很自然地，我们得想办法根据属性名动态创建 &lt;code&gt;Where&lt;/code&gt; 方法的参数。它的参数类型是：&lt;code&gt;Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt;&lt;/code&gt;，是一个表达式参数。&lt;/p&gt;
&lt;p&gt;要知道如何动态创建一个类似 &lt;code&gt;Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt;&lt;/code&gt; 类型的表达式实例，就要知道如何拆解表达式树。&lt;/p&gt;
&lt;p&gt;对于本示例，以 &lt;code&gt;x =&amp;gt; x.Amount1 &amp;lt;= value&lt;/code&gt; 表达式实例为例，它的表达式树是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201125015109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们可以按照此表达式树结构来构建我们的 LINQ 表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public Task&amp;lt;List&amp;lt;Product&amp;gt;&amp;gt; GetProductsAsyncV2(string propertyToFilter, MathOperator mathOperator, decimal value)
{
    var query = _context.Products.AsNoTracking();

    var paramExp = Expression.Parameter(typeof(Product));
    var memberExp = Expression.PropertyOrField(paramExp, propertyToFilter);
    var valueExp = Expression.Constant(value);
    var compareExp = mathOperator == MathOperator.LessThanOrEqual ?
        Expression.LessThanOrEqual(memberExp, valueExp) :
        Expression.GreaterThanOrEqual(memberExp, valueExp);
    var lambda = Expression.Lambda&amp;lt;Func&amp;lt;Product, bool&amp;gt;&amp;gt;(compareExp, paramExp);

    return query.Where(lambda).ToListAsync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 &lt;code&gt;Expression.XXX&lt;/code&gt; 静态方法返回的都是一个以 &lt;code&gt;Expression&lt;/code&gt; 为基类的实例，代表一个表达式。不同的表达式又可以组成一个新的表达式，直到得到我们需要的 Lambda 表达式。这样就形成了一种树形结构，我们称为&lt;strong&gt;表达式树&lt;/strong&gt;。知道如何把一个最终的查询表达式拆解成表达式树，我们就容易动态构建此查询表达式。&lt;/p&gt;
&lt;p&gt;得到一个表达式后，我们还可以动态编译并调用该表达式，比如上面示例得到的 &lt;code&gt;lambda&lt;/code&gt; 变量，是一个&lt;code&gt;Expression&amp;lt;Func&amp;lt;Product, bool&amp;gt;&amp;gt;&lt;/code&gt; 类型，调用其 &lt;code&gt;Compile&lt;/code&gt; 方法，可以得到 &lt;code&gt;Func&amp;lt;Product, bool&amp;gt;&lt;/code&gt; 类型的委托。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;...

var toTestProduct = new Product { Amount1 = 100, Amount2 = 200 };

Func&amp;lt;Product, bool&amp;gt; func = lambda.Compile();
var result = func(toTestProduct);

Console.WriteLine($&quot;The product's {propertyToFilter} is to {mathOperator} {value}.&quot;);

// Output: The product's Amount1 is LessThanOrEqual to 150.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以通过研究 &lt;code&gt;Expression&lt;/code&gt; 类来了解更多动态构建表达式的方法。&lt;/p&gt;
&lt;p&gt;动态构建 LINQ 表达式对于不能在编译时建立查询，只能在运行时建立查询的场景很有用。但它的缺点也很明显，不易维护、不易阅读、不易调试。如果最终的表达式执行出错，很难通过调试来发现具体是构建中的那一步写错了，只能凭自己的理解和经验查找错误。所以，如非必须，一般不推荐动态构建 LINQ 查询表达式。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Nov 2020 00:55:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>最近工作中遇到一个这样的需求：在某个列表查询功能中，可以选择某个数字列（如商品单价、当天销售额、当月销售额等），再选择 小于或等于 和 大于或等于 ，再填写一个待比较的数值，对数据进行查询过滤。 如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/14040435.html</dc:identifier>
</item>
<item>
<title>感恩节新花样～瞄一眼小齐的暖心福利你能领多少？ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/14040391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/14040391.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家早呀～今天是感恩节，趁着这个节日，想和大家说点心里话。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl22c8ynk4j30s412ijz6.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020年初，我十分想写点什么。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我经历过迷茫和彷徨，也有破茧成蝶的蜕变，有些太多想和你分享。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，我在公众号上我借助文字来发现自己、观察内心，整理和升华知识体系。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在互联网上，跟陌生人表达我的成长经历或是技术理解，我有些忐忑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很幸运的是，有很多人喜欢我的文字，但也有一些不友善的评论。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的内心也随着这些反馈，跌宕起伏。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一篇文章，每一个视频，发完之后的第二天我都会早早醒来，赶紧去看评论。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时兴奋，有时沮丧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但自始至终，我都保持着初心：分享有用的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这个特殊的节日，我想真诚的对你说一句，谢谢你！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;感谢你们&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许大家不清楚坚持原创文章是一种多么大的挑战，哪怕只是一周一篇。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;始于热情，陷于好评。&lt;/strong&gt;&lt;/p&gt;
&lt;section class=&quot;imageflow-layer1&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;imageflow-layer2&quot;&gt;&lt;section class=&quot;imageflow-layer3&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl22bt3tq0j30u013zx0g.jpg&quot; class=&quot;imageflow-img&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;imageflow-layer3&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl18f90ke6j30i90k5jtc.jpg&quot; class=&quot;imageflow-img&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;imageflow-layer3&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl18g0u36aj31410u0n1w.jpg&quot; class=&quot;imageflow-img&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;imageflow-layer3&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl18m1vsq8j30u013z4c9.jpg&quot; class=&quot;imageflow-img&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p class=&quot;imageflow-caption&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&amp;lt;&amp;lt;&amp;lt; 左右滑动见更多 &amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;谢谢你们的喜欢和支持，让我有源源不断的动力写下去。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写作这件事让我认识到，&lt;strong&gt;正向反馈真的很重要&lt;/strong&gt;，我只是一个普通人，再爱的事情，没有了正向反馈，人都会放弃。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;就像追女孩子，别说半年，追 3 个月她不理你，或者忽冷忽热，你还会继续吗？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;就像上班，老板不给升职加薪，我们工作动力还会这么足吗？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;坚持一件事本身就是逆人性的过程，而让这个过程可持续的动力，就是得到正向反馈。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的正向反馈可以是物质上的，可以是情绪上的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们坚持学习，是因为知道学习能够提高自己，将来带来财富或者社会地位的提高就是正向反馈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们坚持工作，是因为知道家人需要我们，上有老下有小全指望着我们，家人的笑脸就是我们的正向反馈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我坚持写作，你们的鼓励就是我的正向反馈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以真心的感谢你们，感谢你们的陪伴和支持，你们的每句留言都是对我最大的鼓励！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;感谢他们&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，我还想感谢另外一群人。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为他们，让我的声音传播给更多的人；因为他们，我才更能耐住寂寞，笔耕不缀；因为他们，我会更快的提高文章质量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写作路上，我认识了很多作者。这个月大家可以看到我有推荐一些公众号，有些人会觉得是商业互吹，但其实他们都是我在写作路上的伙伴，他们每个人都有自己擅长的领域，相信会对你有所帮助。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，还想感谢金主的认可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我每周都会收到很多付费投放，但只发过一次。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我恰饭的原则很简单：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;一是要对大多数读者有用，这是我做公众号的初心呐；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;二是我自己认可，判断标准是&lt;strong&gt;不给我💰我是否愿意推广&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有满足了这两个条件，才是三赢的局面，否则任何一方的损伤都是我不愿意看到的。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢你们陪伴了这么久，也感谢你读到这里。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这个特殊的节日，除了优质的文章，还有两个专属的宠粉活动，来回馈我的真爱粉！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;回馈读者&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;活动一&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一年里，有很多读者问过我问题，但由于时间关系我没办法一一回复～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我是有付费咨询的，但从没公开说过，毕竟我的时间非常有限。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl18bou8xmj31o30u07k9.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大公司面试经验不足？想刷题不知如何下手？没有职场经验？想去大厂工作苦于没有好的老师指导？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;趁着年末的假期，我想和你们建立更深层次的链接。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;15分钟、价值 ¥249 元的交流，开放 10 个免费送给你！&lt;/strong&gt; 今年年底之前用完哦！选择你合适的时间，和我聊聊天，可以是技术相关的，也可以是其他你想了解的话题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;获取方式非常简单！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅需在公主号里评论过 3 次以上，或者在我的任意一个群里有过高质量的发言。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要你满足任意一点，就可以来找我和我约时间，先到先得。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;活动二&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢华章书院的大力支持赞助，给大家送出 20 本价值 ¥92 元的 Effective Java 中文版！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很久之前我在视频里就推荐过 Effective C++ 和 Java，我自己都拜读过不止一遍，可以说是帮我拿下了半个 offer！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书中的每一章都包含几个“条目”，对于 Java 平台精妙之处有独到见解，并给出了优秀的代码范例。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个条目的综合描述和解释都阐明了应该怎么做，不应该怎么做，以及为什么。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还采用了双色印刷，更便于读者阅读，在技术书里，非常罕见，足以证明这本书的地位之高！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是针对如何编写高效、设计优良的程序提出了最实用、最权威的指导方针！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抽奖方式是：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一、视频号里我留了 10 个名额&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击👇这个视频：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二、公众号里有 10 个名额&lt;/strong&gt;，其中 3 本送给我的读者群里的热心读者：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;国内群的？？没有昵称。。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl2293plz1j30rs1fgwkf.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谁让你们都这么谦虚。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咳咳，其实还因为人家回答过妹子的一个问题，嗯，&lt;strong&gt;多帮妹子肯定要奖励的！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哦对了，读者群快满了，满了之后不打算建新群，所以没进群的抓紧吧，经常会有活动福利哦～&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;好文群的 &lt;code&gt;NARCISSUS&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没啥好说的，我就是如此肤浅。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl228n3hasj30ku0h4dhd.jpg&quot; alt=&quot;&quot;/&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;自习室打卡第一名🥇 &lt;code&gt;好好学习&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gl227i4a7tj30ku0h7gn8.jpg&quot; alt=&quot;&quot;/&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;海外群的宝宝们，因为没办法包邮海外。。就不选了。。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;另外 7 位将在本文的留言中选：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家转发+留言这篇文章，选留言点赞前 3 名 + 我最喜欢最走心的 4 个留言，直接送书，谢谢一路的支持！&lt;/p&gt;
</description>
<pubDate>Thu, 26 Nov 2020 00:40:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>大家早呀～今天是感恩节，趁着这个节日，想和大家说点心里话。 2020年初，我十分想写点什么。 我经历过迷茫和彷徨，也有破茧成蝶的蜕变，有些太多想和你分享。 于是，我在公众号上我借助文字来发现自己、观察</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/14040391.html</dc:identifier>
</item>
<item>
<title>从执行上下文角度重新理解.NET(Core)的多线程编程[2]：同步上下文 - Artech</title>
<link>http://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-02.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img class=&quot;desc_img&quot; src=&quot;http://images.cnblogs.com/cnblogs_com/artech/158198/r_Dotnet.png&quot;/&gt;一般情况下，我们可以将某项操作分发给任意线程来执行，但有的操作确实对于执行的线程是有要求的，最为典型的场景就是：GUI针对UI元素的操作必须在UI主线程中执行。将指定的操作分发给指定线程进行执行的需求可以通过同步上下文（SynchronizationContext）来实现。你可能从来没有使用过SynchronizationContext，但是在基于Task的异步编程中，它却总是默默存在。今天我们就来认识一下这个SynchronizationContext对象。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;138.01283513976&quot;&gt;
&lt;p&gt;一般情况下，我们可以将某项操作分发给任意线程来执行，但有的操作确实对于执行的线程是有要求的，最为典型的场景就是：GUI针对UI元素的操作必须在UI主线程中执行。将指定的操作分发给指定线程进行执行的需求可以通过同步上下文（SynchronizationContext）来实现。你可能从来没有使用过SynchronizationContext，但是在基于Task的异步编程中，它却总是默默存在。今天我们就来认识一下这个SynchronizationContext对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、从一个GUI的例子谈起&lt;br/&gt;二、自定义一个SynchronizationContext&lt;br/&gt;三、ConfiguredTaskAwaitable方法&lt;br/&gt;四、再次回到开篇的例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GUI后台线程将UI操作分发给UI主线程进行执行时SynchronizationContext的一个非常典型的应用场景。以一个Windows Forms应用为例，我们按照如下的代码注册了窗体Form1的Load事件，事件处理器负责修改当前窗体的Text属性。由于我们使用了线程池，所以针对UI元素的操作（设置窗体的Text属性）将不会再UI主线程中执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1
{  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
    {
        ...
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Load +=&lt;span&gt; Form1_Load;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(&lt;span&gt;object&lt;/span&gt; sender, EventArgs e)=&amp;gt;ThreadPool.QueueUserWorkItem(_ =&amp;gt; Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这个Windows Forms应用启动之后，设置Form1的Text属性的那行代码将会抛出如下所示的InvalidOperationException异常，并提示“Cross-thread operation not valid: Control '' accessed from a thread other than the thread it was created on.”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072254779-1975431395.png&quot;&gt;&lt;img width=&quot;368&quot; height=&quot;132&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072255212-2106491718.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以按照如下的方式利用SynchronizationContext来解决这个问题。如代码片段所示，在利用线程池执行异步操作之前，我们调用Current静态属性得到当前的SynchronizationContext。对于GUI应用来说，这个同步上下文将于UI线程绑定在一起，我们可以利用它将指定的操作分发给UI线程来执行。具体来说，针对UI线程的分发是通过调用其Post方法来完成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1
{  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
    {
        ...
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Load +=&lt;span&gt; Form1_Load;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; syncContext =&lt;span&gt; SynchronizationContext.Current;
        ThreadPool.QueueUserWorkItem(_ &lt;/span&gt;=&amp;gt; syncContext.Post(_=&amp;gt;Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然被命名为SynchronizationContext，并且很多场景下我们利用该对象旨在异步线程中同步执行部分操作的问题（比如上面这个例子），但原则上可以利用自定义的SynchronizationContext对分发给的操作进行100%的控制。在如下的代码中，我们创建一个FixedThreadSynchronizationContext类型，它会使用一个单一固定的线程来执行分发给它的操作。FixedThreadSynchronizationContext继承自SynchronizationContext，它将分发给它的操作(体现为一个SendOrPostCallback类型的委托)置于一个队列中，并创建一个独立的线程依次提取它们并执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FixedThreadSynchronizationContext:SynchronizationContext
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentQueue&amp;lt;(SendOrPostCallback Callback, &lt;span&gt;object&lt;/span&gt; State)&amp;gt;&lt;span&gt; _workItems;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FixedThreadSynchronizationContext()
    {
        _workItems &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentQueue&amp;lt;(SendOrPostCallback Callback, &lt;span&gt;object&lt;/span&gt; State)&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(StartLoop);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FixedThreadSynchronizationContext.ThreadId:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, thread.ManagedThreadId);
        thread.Start();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartLoop()
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_workItems.TryDequeue(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; workItem))
                {
                    workItem.Callback(workItem.State);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Post(SendOrPostCallback d, &lt;span&gt;object&lt;/span&gt; state) =&amp;gt;&lt;span&gt; _workItems.Enqueue((d, state));
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(SendOrPostCallback d, &lt;span&gt;object&lt;/span&gt; state)=&amp;gt; throw new NotImplementedException();&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向SynchronizationContext分发指定的操作可以调用Post和Send方法，它们之间差异就是异步和同步的差异。FixedThreadSynchronizationContext仅仅重写了Post方法，意味着它支持异步分发，而不支持同步分发。我们采用如下的方式来使用FixedThreadSynchronizationContext。我们先创建一个FixedThreadSynchronizationContext对象，并采用线程池的方式同时执行5个异步操作。对于我们异步操作来说，我们先调用静态方法SetSynchronizationContext将创建的这个FixedThreadSynchronizationContext对象设置为当前SynchronizationContext。然后调用Post方法将指定的操作分发给当前SynchronizationContext。置于具体的操作，它会打印出当前线程池线程和当前操作执行线程的ID。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Main()
    {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
         var synchronizationContext = new FixedThreadSynchronizationContext();
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
        {
            ThreadPool.QueueUserWorkItem(_ &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                SynchronizationContext.SetSynchronizationContext(synchronizationContext);
                Invoke();
            });
        }
        Console.Read();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Invoke()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dispatchThreadId =&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            SendOrPostCallback callback &lt;/span&gt;= _ =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pooled Thread: {dispatchThreadId}; Execution Thread: {Thread.CurrentThread.ManagedThreadId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            SynchronizationContext.Current.Post(callback, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段演示程序执行之后会输出如下所示的结果，可以看出从5个线程池线程分发的5个操作均是在FixedThreadSynchronizationContext绑定的那个线程中执行的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072255604-1719750239.png&quot;&gt;&lt;img width=&quot;358&quot; height=&quot;143&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072255829-947327345.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我知道很少人会显式地使用SynchronizationContext上下文，但是正如我前面所说，在基于Task的异步编程中，SynchronizationContext上下文其实一直在发生作用。我们可以通过如下这个简单的例子来证明SynchronizationContext的存在。如代码片段所示，我们创建了一个FixedThreadSynchronizationContext对象并通过调用SetSynchronizationContext方法将其设置为当前SynchronizationContext。在调用Task.Delay方法（使用await关键字）等待100ms之后，我们打印出当前的线程ID。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Main()
    {
        SynchronizationContext.SetSynchronizationContext(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FixedThreadSynchronizationContext());
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Await Thread: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的是程序运行之后的输出结，可以看出在await Task之后的操作实际是在FixedThreadSynchronizationContext绑定的那个线程上执行的。在默认情况下，Task的调度室通过ThreadPoolTaskScheduler来完成的。顾名思义，ThreadPoolTaskScheduler会将Task体现的操作分发给线程池中可用线程来执行。但是当它在分发之前会先获取当前SynchronizationContext，并将await之后的操作分发给这个同步上下文来执行。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072256094-864283538.png&quot;&gt;&lt;img width=&quot;354&quot; height=&quot;124&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072256316-1553631611.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果不了解这个隐含的机制，我们编写的异步程序可能会导致很大的性能问题。如果多一个线程均将这个FixedThreadSynchronizationContext作为当前SynchronizationContext，意味着await Task之后的操作都将分发给一个单一线程进行同步执行，但是这往往不是我们的真实意图。其实这个问题很好解决，我们只需要调用等待Task的ConfiguredTaskAwaitable方法，并将参数设置为false显式指示后续的操作无需再当前SynchronizationContext中执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Main()
    {
        SynchronizationContext.SetSynchronizationContext(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FixedThreadSynchronizationContext());
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;)&lt;span&gt;&lt;strong&gt;.ConfigureAwait(false);&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Await Thread: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行该程序可以从输出结果看出await Task之后的操作将不会自动分发给当前的FixedThreadSynchronizationContext了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072256590-369555676.png&quot;&gt;&lt;img width=&quot;361&quot; height=&quot;125&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201126072256808-571536634.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于SynchronizationContext的存在，所以如果将开篇的例子修改成如下的形式是OK的，因为await之后的操作会通过SynchronizationContext分发到UI主线程执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1
{  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
    {
        ...
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Load +=&lt;span&gt; Form1_Load;
    }
    &lt;span&gt;private async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(object sender, EventArgs e)&lt;br/&gt;{&lt;br/&gt;await Task.Delay(1000);&lt;br/&gt;Text = &quot;Hello World&quot;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果添加了ConfigureAwait(false)方法的调用，依然会抛出上面遇到的InvalidOperationException异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1
{  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeComponent()
    {
        ...
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Load +=&lt;span&gt; Form1_Load;
    }&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;span&gt;private async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(object sender, EventArgs e)&lt;br/&gt;     {&lt;br/&gt;         await Task.Delay(1000)&lt;span&gt;&lt;strong&gt;.ConfigureAwait(false);&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;         Text = &quot;Hello World&quot;;&lt;br/&gt;     }&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-01.html&quot;&gt;从执行上下文角度重新理解.NET(Core)的多线程编程[1]：基于调用链的”参数”传递&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-02.html&quot;&gt;从执行上下文角度重新理解.NET(Core)的多线程编程[2]：同步上下文&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-03.html&quot;&gt;从执行上下文角度重新理解.NET(Core)的多线程编程[3]：安全上下文&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 26 Nov 2020 00:38:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>一般情况下，我们可以将某项操作分发给任意线程来执行，但有的操作确实对于执行的线程是有要求的，最为典型的场景就是：GUI针对UI元素的操作必须在UI主线程中执行。将指定的操作分发给指定线程进行执行的需求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/multiple-threading-via-execution-context-02.html</dc:identifier>
</item>
<item>
<title>外甥问我什么是操作系统？ - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/14040302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/14040302.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;外甥上大一了，起初我还非常担心他，担心主要有两方面的原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;从小一直是校草，长的&lt;strong&gt;太帅&lt;/strong&gt;，会不会天天谈恋爱去了&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;担心在大学没能做好自己的规划&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是经常和他视频聊天，外甥小我没几岁，我们经常以兄弟相称，聊起来自然和谐&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从我这几次和他聊天可以看出，我的担忧有些太过了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他好像从没刻意他的帅气，而是不断的充实自己的才华，篮球打得好、街舞跳的好、还去参加各种志愿者活动&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键是最近还对&lt;strong&gt;计算机&lt;/strong&gt;产生了强烈的兴趣。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唉，帅就算了，还这么认真，这年轻人不讲武德啊&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上周末打电话，竟然问我什么是操作系统？ 为什么要有操作系统？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就有了这篇文章，也准备把我外甥的计算机相关疑问全部承包了，喜欢我记得关注我 公号 &lt;strong&gt;龙跃十二&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gksl1mjkhsj31340no40o.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喜欢我几个关注我&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;什么是操作系统？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话很难有一个准确的定义去描述操作系统，看了多本关于操作系统的书中是这样说的。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;操作系统是一个运行在内核态的软件，该软件对底层各种硬件资源做了抽象和管理，并提供统一的API接口供应用程序去调用这些资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话涵盖了好几个知识点&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;操作系统是一个软件&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;操作系统软件运行在&lt;strong&gt;内核状态&lt;/strong&gt;下的软件，不在用户态下，应用开发者开发的各种系统软件都是在用户态下运行的&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;撒是用户态，撒是内核态？你很喜欢剖根问底，这个后面再说&lt;/p&gt;
&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;对各种底层&lt;strong&gt;硬件资源&lt;/strong&gt;进行了&lt;strong&gt;抽象&lt;/strong&gt;和&lt;strong&gt;管理&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象了处理器、存储器、时钟、磁盘、网络接口、外设等底层硬件资源，把各种资源都抽象为一个个的文件描述符&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设想一下，多核情况下，多个应用程序同时使用一种资源，就会造成混乱局面，此时操作系统就会扮演一个管理者去管理这些资源的使用者。&lt;/p&gt;
&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;提供统一对外访问的接口&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk9toyvqzqj30hu0bqwey.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统处在中间层，上面有各种系统应用程序、开发人员、用户，下面有各种计算机硬件资源。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么脑海中浮现了 上下为难 的表情包，哈哈哈有内味了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统&lt;strong&gt;设计者&lt;/strong&gt;和&lt;strong&gt;硬件编程&lt;/strong&gt;人员可以直接去操作硬件资源&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统设计者这不用解释了，都懂的，都在设计操作系统了，总不至于不能操作硬件资源吧&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬件编程人员这个大家可能稍微陌生点，有一类开发人员是直接对硬件进行操作的，如果是你是学习电子信息相关专业的，应该很熟悉&lt;strong&gt;烧程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大学做实验的时候龙叔就经常把写好的汇编程序或者C语言程序编译完成了直接烧到计算机硬件上，这叫&lt;strong&gt;烧程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我写的程序里面有对硬件资源进行操作，比如操作某某管脚、某个串口等等&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;strong&gt;没有操作系统也是可以直接操作计算机硬件资源&lt;/strong&gt;，也是可以跑程序的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为啥还要操作系统呢？&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;为什么要有操作系统？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面已经说了，没有操作系统是可以操作计算机硬件资源的，那为什么要有呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）最早期计算机是没有操作系统的，每次要变更一下功能，都要手动去调整硬件，费时费力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）随着电子管技术的发展，各种硬件资源可以做成通用的，此时就急切需要一个操作系统去控制这些资源，每次改功能，只需要修改输入的信号即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）提升计算机的功能性和灵活性&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;操作系统的演变&lt;/span&gt;&lt;/h3&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;串行处理&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;20世纪40-50年代，电子管技术得到了发展，诞生了第一台电子管计算机&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkhpq7fy3yj30ei09g3yw.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于零件的集成度太低，一台计算机必须用一个&lt;strong&gt;大&lt;/strong&gt;house来放置&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且这台机器当时数百万美元的标价，价格是真的贵，一般人用不起，都是一些豪横的组织才用得起&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的计算机是没有操作系统的，操作人员直接和计算机硬件交互，类似下面这样&lt;/p&gt;
&lt;img src=&quot;https://pic1.zhimg.com/0b2fe3a5785f9851ecdbf2f1e4115a41_r.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的操作在控制台上进行，控制台上有显示灯、触发器、输入输出设备&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次作业都需要有专门的的人员来操作，使用汇编语言写程序到纸片上，再穿孔成卡片，再将这些卡片交给专门的操作人员去操作，再花费时间等操作结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;计算机成本高，操作过程复杂，时间还长&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人们很自然就想到减少机器时间的浪费，于是就诞生了&lt;strong&gt;批处理系统&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;批处理系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了20世纪50年代General Motors开发了批处理系统，那时候被称为 &lt;strong&gt;监控系统&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控系统是常住在内存中的，他做的事情就是&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;加载用户程序到用户程序段&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;把控制权交给用户程序&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;读取用户程序指令交给处理器&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将处理器的执行结果输出到设备&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;用户程序完成后交回控制权&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;进行下一个循环&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkpnh70zh0j309v0a1dg1.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，监控程序主要主要完成调度功能，一批作业排队等待，处理器尽可能的被充分利用，不让他有任何空闲时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控程序很大程度上&lt;strong&gt;提高了处理器的利用率&lt;/strong&gt;，减少了处理器空闲时间&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;多道系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批处理系统已经提高了程序的利用率，但还是没最大化压榨&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控程序和用户程序需要来回&lt;strong&gt;切换&lt;/strong&gt;转换控制权，这部分时间处理器闲置&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控程序在做&lt;strong&gt;IO&lt;/strong&gt;操作时，由于IO是比较慢的，磁盘读写很慢的，此时处理器需要等待&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的利用处理器的计算性能，大佬们搞出了多道系统&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkppfk3wcpj30l60fmjs1.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多道系统就是同时加载多个用户程序，当其中一个用户程序需要&lt;strong&gt;IO等待&lt;/strong&gt;时，&lt;strong&gt;切换&lt;/strong&gt;到另一个不在等待IO的用户程序进行处理。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就很好的减少处理器资源的浪费，同时提高了程序处理的效率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多道系统会比单道系统复杂很多，比如 所有程序都在内存中，涉及到 &lt;strong&gt;内存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个用户程序需要运行处理器先运行谁？ 这涉及到 &lt;strong&gt;调度算法&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 别慌张，这些知识都会在后面的文章中讲到。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;分时系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多道系统已经解决了处理器资源&lt;strong&gt;合理且高效&lt;/strong&gt;利用问题，但是随着计算机的发展，人们对于计算机又有了新的需求 &lt;strong&gt;交互式处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机需要具备多个用户同时访问、操作和处理用户程序，此时 &lt;strong&gt;分时系统&lt;/strong&gt; 就应运而生了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：程序A是一个&lt;strong&gt;非常消耗&lt;/strong&gt;处理器资源的程序一般运行一次需要10分钟，程序B是一个简单计算程序，运行一次只需要1分钟。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多道系统里，只能是程序A处理完了才能处理B，但是这B等着着急啊&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就有了分时系统，CPU资源对用户程序是公平的，每一个用户拥有的资源是公平的&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkpvwxih2kj30i40660st.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用上下文信息，去切换CPU执行的时间，做到尽可能让每个用户都平等拥有资源&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，处理器的性能&lt;strong&gt;并没有提升&lt;/strong&gt;，反而会因为调度切换降低利用率，但是对用户来说提高了用户程序响应效率。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;分布式系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随机计算机的发展，终于到了个人电脑的出现，这时候计算机又增加了新的需求，多个计算机之间网络互连、多核利用等等&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就诞生了&lt;strong&gt;分布式系统&lt;/strong&gt;，分布式系统就是在网络的帮助下实现实时的计算和协同处理&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;操作系统的体系结构&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统是一种系统软件，在理解这个层次结构时可以结合软件设计的层次结构。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;单体系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个操作系统在内核以单一程序的方式运行&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gksikjhpq2j308p0aegm4.jpg&quot; alt=&quot;MS_DOS系统简单结构&quot;/&gt;MS_DOS系统简单结构
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期MS_DOS系统简单结构如上图所示，&lt;strong&gt;操作系统&lt;/strong&gt;和&lt;strong&gt;应用程序&lt;/strong&gt;以及&lt;strong&gt;设备驱动&lt;/strong&gt;都可以操作硬件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出来没有很好的模块划分和分离，这种方式的好处是任意调用都比较&lt;strong&gt;高效&lt;/strong&gt;，缺点是程序大并且复杂的调用会让操作系统变得&lt;strong&gt;笨拙&lt;/strong&gt;且&lt;strong&gt;难以理解&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看看早起UNIX系统结构&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gksizoyly6j30bp09774u.jpg&quot; alt=&quot;早期UNIX系统结构&quot;/&gt;早期UNIX系统结构
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到早期Unix系统结构也是&lt;strong&gt;有限的结构化&lt;/strong&gt;，主要是早期受到&lt;strong&gt;硬件限制&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期考虑操作系统设计的&lt;strong&gt;核心&lt;/strong&gt;要素是 在&lt;strong&gt;最小的空间&lt;/strong&gt;里面提供&lt;strong&gt;最多的功能&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别像互联网公司初期的系统架构，全部单体应用，所有服务在一起，随着业务复杂、并发增加&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渐渐这种单体应用的优势会&lt;strong&gt;完全被覆盖&lt;/strong&gt;，公司不得不进行架构升级&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;层次式系统&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单体结构的缺点在硬件不断发展和用户需求激增下越来越明显&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似公司规模不断增大，早期架构的一点点优势越来越敌不过缺点了，不得不进行架构升级&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;层次化结构的原则是：&lt;strong&gt;每一层只能使用下一层提供的服务&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早的层次化结构系统是Dijkstra大佬设计出来的，叫THE OS，他把整个系统分为了6层&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gksjo650m9j30ct0avq3j.jpg&quot; alt=&quot;THE OS系统&quot;/&gt;THE OS系统
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种层次化结构的显著优点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;底层和高层 甚至于每层只要按照规则 都可以分别实现，便于扩充&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;上层的错误不会影响下层，便于调试、功能的增删改&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;调用关系清楚，上层对下层的单向依赖，避免递归调用，保证了设计和实现的正确性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;可移植性非常好&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有显著的缺点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;系统中所有进程的控制转移、通信等任务都交给系统的核心去管理，代价较大&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;层次的划分和安排，要保证不出现双向依赖关系&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;微内核&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微内核体现在一个微字， 怎么样来达到这个微呢？&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;通过划分系统程序和用户程序，把所有不必要的部分移除内核，形成一个小内核&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;微内核提供最少量的进程管理、存储管理、以及通信功能&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gksknzniegj30fb0b5t9d.jpg&quot; alt=&quot;微内核结构&quot;/&gt;微内核结构
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个操作系统由两部分组成，运行在核心态的内核和运行在用户态的并且以C/S模式提供服务&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Windows NT就是以这种架构方式&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微内核的显著优点：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内核精巧&lt;/strong&gt;，内核提供核心功能 进程管理、存储管理、以及通信功能&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面向多处理机和分布式系统&lt;/strong&gt;，基于微内核的系统在内核中引入了多处理机调度和管理机制，并且引入了线程，有了线程就有了并行执行，这可不得了啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于C/S体系结构&lt;/strong&gt; 微内核的任务通信机制和消息机制采用CS模式向用户提供服务&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代操作系统的体系结构就是&lt;strong&gt;微内核&lt;/strong&gt;与&lt;strong&gt;层次式结构&lt;/strong&gt;的结合体&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本期的主要内容，基本回答了外甥的问题，也希望能解答大家的疑惑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容对大家有帮助的话，求分享、求转发、求点赞，一键三连就是对我最大的鼓励，感谢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是龙su，一个倾慕外甥帅气容颜的舅舅，一个半吊子架构师，我们下期见。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Nov 2020 00:32:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>谈谈什么是操作系统，操作系统架构体系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/14040302.html</dc:identifier>
</item>
<item>
<title>9、Spring Boot安全 - HOsystem</title>
<link>http://www.cnblogs.com/HOsystem/p/14028160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HOsystem/p/14028160.html</guid>
<description>&lt;p&gt;&lt;span&gt;  Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  WebSecurityConfigurerAdapter：自定义Security策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  AuthenticationManagerBuilder：自定义认证策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  @EnableWebSecurity：开启WebSecurity模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;应用程序的两个主要区域是&lt;/span&gt;'认证'和'授权'(或者访问控制)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  '认证'和'授权'主要区域是Spring Security 的两个目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;认证&lt;/span&gt;(Authentication),是建立一个他声明的主体的过程(一个'主体'一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  '授权'(Authorization)指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;(1).创建工程&lt;/h2&gt;
&lt;h2&gt;(2).引入SpringSecurity&lt;/h2&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;!--security--&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.springframework.boot&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;spring-boot-starter-security&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;(3).导入文件&lt;/h2&gt;
&lt;h2&gt;(4).SpringSecurity配置类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  HttpSecurity配置登陆、注销功能&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;42&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;71&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;package&lt;/strong&gt; com.hosystem.security.config;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.config.annotation.web.builders.HttpSecurity;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.config.annotation.web.builders.WebSecurity;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@EnableWebSecurity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public class&lt;/strong&gt; MySecurityConfig &lt;strong&gt;extends&lt;/strong&gt; WebSecurityConfigurerAdapter{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;//&lt;/em&gt;&lt;em&gt;定义授权规则&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;@Override&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;protected void&lt;/strong&gt; configure(HttpSecurity http) &lt;strong&gt;throws&lt;/strong&gt; Exception {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;//        super.configure(http);&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        //&lt;/em&gt;&lt;em&gt;定制请求的授权规则&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;http.authorizeRequests().antMatchers(&lt;strong&gt;&quot;/&quot;&lt;/strong&gt;).permitAll()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .antMatchers(&lt;strong&gt;&quot;/level1/**&quot;&lt;/strong&gt;).hasRole(&lt;strong&gt;&quot;VIP1&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .antMatchers(&lt;strong&gt;&quot;/level2/**&quot;&lt;/strong&gt;).hasRole(&lt;strong&gt;&quot;VIP2&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .antMatchers(&lt;strong&gt;&quot;/level3/**&quot;&lt;/strong&gt;).hasRole(&lt;strong&gt;&quot;VIP3&quot;&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;em&gt;//&lt;/em&gt;&lt;em&gt;开启自动配置登录功能&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;http.formLogin();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;em&gt;//1. /login&lt;/em&gt;&lt;em&gt;到登录页&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;//2.&lt;/em&gt; &lt;em&gt;重定向到&lt;/em&gt;&lt;em&gt;/login?error&lt;/em&gt;&lt;em&gt;表示登录失败&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;//3.&lt;/em&gt; &lt;em&gt;更多详细规定&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;//&lt;/em&gt;&lt;em&gt;定义认证规则&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;@Override&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;protected void&lt;/strong&gt; configure(AuthenticationManagerBuilder auth) &lt;strong&gt;throws&lt;/strong&gt; Exception {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;//        super.configure(auth);&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;auth.inMemoryAuthentication().passwordEncoder(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder())&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .withUser(&lt;strong&gt;&quot;tom&quot;&lt;/strong&gt;).password(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder().encode(&lt;strong&gt;&quot;123456&quot;&lt;/strong&gt;)).roles(&lt;strong&gt;&quot;VIP1&quot;&lt;/strong&gt;,&lt;strong&gt;&quot;VIP2&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .and()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .withUser(&lt;strong&gt;&quot;jack&quot;&lt;/strong&gt;).password(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder().encode(&lt;strong&gt;&quot;123456&quot;&lt;/strong&gt;)).roles(&lt;strong&gt;&quot;VIP2&quot;&lt;/strong&gt;,&lt;strong&gt;&quot;VIP3&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .and()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                .withUser(&lt;strong&gt;&quot;lucy&quot;&lt;/strong&gt;).password(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder().encode(&lt;strong&gt;&quot;123456&quot;&lt;/strong&gt;)).roles(&lt;strong&gt;&quot;VIP1&quot;&lt;/strong&gt;,&lt;strong&gt;&quot;VIP3&quot;&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;注：如果出现&lt;/span&gt;There is no PasswordEncoder mapped for the id “null”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;或者&lt;/span&gt; Encoded password does not look like bcrypt(Bad credentials)基本都是springsecurity版本的问题。只需要使用passwordEncoder(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder())替换原来的即可。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;#老版本springsecurity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;auth.inMemoryAuthentication().withUser(&lt;strong&gt;&quot;user&quot;&lt;/strong&gt;).password(&lt;strong&gt;&quot;123456&quot;&lt;/strong&gt;).roles(&lt;strong&gt;&quot;VIP1&quot;&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#新版本springsecurity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;auth.inMemoryAuthentication().passwordEncoder(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder())&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        .withUser(&lt;strong&gt;&quot;tom&quot;&lt;/strong&gt;).password(&lt;strong&gt;new&lt;/strong&gt; BCryptPasswordEncoder().encode(&lt;strong&gt;&quot;123456&quot;&lt;/strong&gt;)).roles(&lt;strong&gt;&quot;VIP1&quot;&lt;/strong&gt;,&lt;strong&gt;&quot;VIP2&quot;&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;(5).Thymeleaf提供的SpringSecurity标签支持&lt;/h2&gt;
&lt;h3&gt;[1].引入thymeleaf-extras-springsecurity5&lt;/h3&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;!--springsecurity5--&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.thymeleaf.extras&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;thymeleaf-extras-springsecurity5&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;[2].sec:authorize使用&lt;/h3&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;!DOCTYPE &lt;strong&gt;html&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;html&lt;/strong&gt; &lt;strong&gt;xmlns:&lt;/strong&gt;&lt;strong&gt;th&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;&quot;http://www.thymeleaf.org&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;strong&gt;xmlns:&lt;/strong&gt;&lt;strong&gt;sec&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;head&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;meta&lt;/strong&gt; &lt;strong&gt;http-equiv=&lt;/strong&gt;&lt;strong&gt;&quot;Content-Type&quot;&lt;/strong&gt; &lt;strong&gt;content=&lt;/strong&gt;&lt;strong&gt;&quot;text/html; charset=UTF-8&quot;&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;title&lt;/strong&gt;&amp;gt;Insert title here&amp;lt;/&lt;strong&gt;title&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/&lt;strong&gt;head&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;body&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;h1&lt;/strong&gt; &lt;strong&gt;align=&lt;/strong&gt;&lt;strong&gt;&quot;center&quot;&lt;/strong&gt;&amp;gt;欢迎光临武林秘籍管理系统&amp;lt;/&lt;strong&gt;h1&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;div&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;sec&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:authorize=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;!isAuthenticated()&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;   &lt;/em&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;h2&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;align=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;center&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;em&gt;游客您好，如果想查看武林秘籍&lt;/em&gt; &lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;th&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:href=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;@{/login}&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;em&gt;请登录&lt;/em&gt;&lt;em&gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;h2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;div&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;div&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;sec&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:authorize=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;isAuthenticated()&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;   &lt;/em&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;h2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;span&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;sec&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:authentication=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;name&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;span&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;你好，你的角色有&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;      &lt;/em&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;span&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;sec&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:authentication=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;principal.authorities&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;span&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&amp;lt;/&lt;/em&gt;&lt;strong&gt;&lt;em&gt;h2&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;   &lt;/em&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;form&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;th&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;:action=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;@{/logout}&quot;&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;method=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;post&quot;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;      &lt;/em&gt;&lt;em&gt;&amp;lt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;input&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;type=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;submit&quot;&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;value=&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;注销&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&quot;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Wed, 25 Nov 2020 17:43:00 +0000</pubDate>
<dc:creator>HOsystem</dc:creator>
<og:description>1.Spring Security简介 Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HOsystem/p/14028160.html</dc:identifier>
</item>
<item>
<title>SwiftUI：看我展示52张扑克牌，“很快啊!” - Dast1</title>
<link>http://www.cnblogs.com/Dast1/p/14040138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dast1/p/14040138.html</guid>
<description>&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;使用 SwiftUI 创建 UI 结构；&lt;/p&gt;
&lt;p&gt;使用 swift 的枚举和结构体实现数据生成，通过 viewModel 整合数据用于展示（交互暂时未做，因此不涉及 MVVM 设计模式中的数据绑定）。&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;效果图&lt;/h2&gt;
&lt;p&gt;画布实时预览 iphone 效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkvsw2rpz3j31au0u0k6l.jpg&quot; alt=&quot;截屏2020-11-20 下午6.00.37&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 iphone11 黑暗模式效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gl199t4gfgj30n01ds79k.jpg&quot; alt=&quot;Simulator Screen Shot - iPhone 11 - 2020-11-25 at 11.25.13&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 ipad air 模拟器效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkyymnzmabj30u0176n3l.jpg&quot; alt=&quot;Simulator Screen Shot - iPad Air (4th generation) - 2020-11-23 at 11.42.50&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关代码解析&quot;&gt;相关代码解析&lt;/h2&gt;
&lt;h3 id=&quot;枚举创建扑克牌号码&quot;&gt;枚举创建扑克牌号码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;//CaseIterable:当需要对枚举进行遍历时，需要遵守 CaseIterable 协议，然后对枚举的 allCases 类属性进行遍历即可
enum Rank:Int, CaseIterable {
    case ace = 1
    
    //未指定确定值的类别，默认值是“依次”加1，因此，two 的 rawValue 为2，three 的 rawValue 为 3，以此类推
    case two,three,four,five,six,seven,eight,nine,ten
    case J,Q,K
    
    //swift的枚举，可以自定义方法。写代码时，“很快啊!”
    func customDescription()-&amp;gt;String{
        switch self {
        case .ace:
            return &quot;A&quot;
        case .J:
            return &quot;J&quot;
        case .Q:
            return &quot;Q&quot;
        case .K:
            return &quot;K&quot;
        default:
            return &quot;\(self.rawValue)&quot;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;枚举创建扑克牌类型&quot;&gt;枚举创建扑克牌类型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;enum CardType: CaseIterable{
    case heart,spades,club,diamond
    
    func customDescription() -&amp;gt; String {
        switch self {
        case .heart:
            
            //command+ctrl+space,快速调出 emoji 窗口，可以搜索，&quot;很6啊!&quot;
            return &quot;♥️&quot;
        case .spades:
            return &quot;♠️&quot;
        case .club:
            return &quot;♦️&quot;
        default:
            return &quot;♣️&quot;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;viewmodel逻辑&quot;&gt;viewModel逻辑&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;struct GameVM {
    
    /// 声明为 private，符合封装的思想，通过方法初始化时，必须是类方法（static func）！如果用实例方法，创建实例时，属性还未初始化，不符合语法！
    private var model:GameM = generateGame()
    
    //数组的泛型不能直接声明为 Card 类型，会提示找不到。需要通过结构体名点出来！
    var cards: Array&amp;lt;GameM.Card&amp;gt; {
        return model.cards
    }
     
    static func generateGame()-&amp;gt;GameM{
        var lArr: Array&amp;lt;GameM.Card&amp;gt; = Array&amp;lt;GameM.Card&amp;gt;()
        
        //两个循环就创建好了数据源，&quot;很快啊!&quot;
        for type in CardType.allCases {
            for rank in Rank.allCases{
                lArr.append(GameM.Card(rank: rank, type:type))
            }
        }
        return GameM(cards: lArr)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ui实现&quot;&gt;UI实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;/// 声明式UI编程，&quot;很快啊!&quot;
struct ContentView: View {
    var viewModel: GameVM
    
    var body: some View {
        let columnNum = 4
        let rowNum = viewModel.cards.count/columnNum
        
        return
            HStack{
                ForEach(0..&amp;lt;columnNum){column in
                    VStack{
                        ForEach(0..&amp;lt;rowNum){row in
                            let index = (rowNum) * column + row
                            let card = viewModel.cards[index]
                            Card(cardM:card)
                        }
                    }
                }
            }.padding()
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Dast1Woop/FullDeckOfCards_SwiftUI&quot;&gt;FullDeckOfCards_SwiftUI&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;感受&quot;&gt;感受&lt;/h2&gt;
&lt;p&gt;swift 语法在构建数据类型时比 OC 方便太多了，枚举和结构体（值类型，copy-on-write）都很强大。&lt;/p&gt;
&lt;p&gt;非共享数据优先使用结构体，类一般只用于 viewModel，用于数据共享给多个 view。&lt;/p&gt;
&lt;p&gt;SwiftUI 使用声明式方法构建 UI，代码方面简洁了很多，一套代码，三端适用（iOS，iPadOS，macOS（M1））。而且支持实时预览，大大提高了 UI 开发效率!&lt;/p&gt;
&lt;p&gt;距离 APP 支持最低版本 iOS13 应该也不远了（微信目前最低支持 iOS11.0），iOSer 们，是时候学习一波 SwiftUI 了！随便再温习下 swift 相关语法。&lt;/p&gt;
&lt;p&gt;展望未来，iOSer 们实现需求起来，终于可以大喊：&quot;很快啊!&quot;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;自娱自乐:&lt;/p&gt;
&lt;p&gt;刚才有个朋友问我，&quot;OC老师&quot;发生什么事了，我说怎么回事，给我发了几张截图，我一看，嗷，原来是昨天，有两个年轻人，实现需求，一个用时九十多分钟，一个用时八十多分钟......&lt;/p&gt;
&lt;p&gt;但是没关系啊，我两百分多钟以后，需求也做好了。我说 Kotlin 你不讲武德，你不懂，他说 &quot;OC 老师&quot;对不起，我不懂，我乱打的，后来他说他练过三四年 Java，看来是有 bear 而来，这个年轻人不讲发德，来，骗，来，偷袭，我二十九岁+的老同志，这好吗?这不好，我劝，这位年轻人好自为之，好好反思，以后不要再犯这样的错误，小聪明啊，开发要以和为贵，要讲发德，不要搞窝里斗，谢谢朋友们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎扫描下面二维码，关注我，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gl1hdxlp38j307607674r.jpg&quot; alt=&quot;qrcode_for_gh_b4657e673349_258&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Nov 2020 17:10:00 +0000</pubDate>
<dc:creator>Dast1</dc:creator>
<og:description>思路 使用 SwiftUI 创建 UI 结构； 使用 swift 的枚举和结构体实现数据生成，通过 viewModel 整合数据用于展示（交互暂时未做，因此不涉及 MVVM 设计模式中的数据绑定）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dast1/p/14040138.html</dc:identifier>
</item>
<item>
<title>Java（8）I/O - Javalove刘志先</title>
<link>http://www.cnblogs.com/liuzhixian666/p/14040126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhixian666/p/14040126.html</guid>
<description>&lt;h2 id=&quot;一、file类&quot;&gt;一、File类&lt;/h2&gt;
&lt;h3 id=&quot;1、file类概述&quot;&gt;1、File类概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;java.io.File类&lt;/strong&gt;：一个java.io.File类的对象，表示文件和文件目录路径（就是文件夹）&lt;/li&gt;
&lt;li&gt;File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。&lt;/li&gt;
&lt;li&gt;想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005707349-645424871.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;经典应用场景：&lt;/strong&gt;File对象可以作为参数传递给流的构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、file类实例化&quot;&gt;2、File类实例化&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;构造器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;File(String pathname)&lt;/td&gt;
&lt;td&gt;由&lt;strong&gt;路径名称&lt;/strong&gt;来创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;File(String parent, String child)&lt;/td&gt;
&lt;td&gt;由&lt;strong&gt;上层目录路径+文件名&lt;/strong&gt;来创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;File(File parent, String child)&lt;/td&gt;
&lt;td&gt;由&lt;strong&gt;上层文件名+文件名&lt;/strong&gt;来创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;File(URI uri)&lt;/td&gt;
&lt;td&gt;由&lt;strong&gt;uri&lt;/strong&gt;来创建&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;3、file类常用方法&quot;&gt;3、File类常用方法&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;getAbsolutePath()&lt;/td&gt;
&lt;td&gt;获取绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getPath()&lt;/td&gt;
&lt;td&gt;获取路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getName()&lt;/td&gt;
&lt;td&gt;获取名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getParent()&lt;/td&gt;
&lt;td&gt;获取上层文件目录路径。若无，返回null&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;length()&lt;/td&gt;
&lt;td&gt;获取文件长度（即：字节数）。不能获取目录的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;lastModified()&lt;/td&gt;
&lt;td&gt;获取最后一次的修改时间，毫秒值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;下面两个是针对目录的&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public String[] list()&lt;/td&gt;
&lt;td&gt;获取指定目录下的所有文件或者文件目录的名称数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public File[] listFiles()&lt;/td&gt;
&lt;td&gt;获取指定目录下的所有文件或者文件目录的File数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;public boolean renameTo(File dest)&lt;/code&gt;：把文件重命名为指定的文件路径。（实际上就是把file1的内容复制到file2，并把file1删除）&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;file1.renameTo(file2)&lt;/code&gt;要求：file1存在，file2不存在&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;isDirectory()&lt;/td&gt;
&lt;td&gt;判断是否是文件目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isFile()&lt;/td&gt;
&lt;td&gt;判断是否是文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;exists()&lt;/td&gt;
&lt;td&gt;判断是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;canRead()&lt;/td&gt;
&lt;td&gt;判断是否可读&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;canWrite()&lt;/td&gt;
&lt;td&gt;判断是否可写&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isHidden()&lt;/td&gt;
&lt;td&gt;判断是否隐藏&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;创建和删除&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;注意事项&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public boolean createNewFile()&lt;/td&gt;
&lt;td&gt;创建文件&lt;/td&gt;
&lt;td&gt;若文件存在，则不创建，返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;public boolean mkdir()&lt;/td&gt;
&lt;td&gt;创建文件目录&lt;/td&gt;
&lt;td&gt;如果此文件目录存在，就不创建；&lt;br/&gt;如果此文件目录的上层目录不存在，也不创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;public boolean mkdirs()&lt;/td&gt;
&lt;td&gt;创建文件目录&lt;/td&gt;
&lt;td&gt;如果上层文件目录不存在，一并创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;public boolean delete()&lt;/td&gt;
&lt;td&gt;删除文件或者文件夹&lt;/td&gt;
&lt;td&gt;Java中的删除不走回收站&lt;br/&gt;要删除的文件目录内不能包含文件或文件目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;如果你创建文件或者 文件 目录没有写盘符路径 ， 那么 ，默认在项目路径下。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、io流的原理&quot;&gt;二、IO流的原理&lt;/h2&gt;
&lt;h3 id=&quot;1、io流的原理&quot;&gt;1、IO流的原理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;I/O&lt;/strong&gt;是input/output的缩写，IO技术用于&lt;strong&gt;设备之间的数据传输&lt;/strong&gt;。（如。&lt;strong&gt;读/写文件、网络通讯&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;Java程序中，数据的输入/输出操作以&lt;strong&gt;“流(stream)”&lt;/strong&gt; 的方式进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;java.io包下提供了各种“流”类和接口&lt;/strong&gt;，用以获取不同种类的数据，并通过标准的方法输入或输出数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、input和output的理解&quot;&gt;2、input和output的理解&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先对于入和出，我们是站在程序的角度来说的，&lt;strong&gt;想象自己身处程序内部。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;input：磁盘、光盘等存储设备的数据-----&amp;gt;程序、内存&lt;/li&gt;
&lt;li&gt;output：程序、内存中的数据-----&amp;gt;磁盘、光盘等存储设备&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、io流的分类&quot;&gt;三、IO流的分类&lt;/h2&gt;
&lt;h3 id=&quot;1、分类&quot;&gt;1、分类&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;√√√按&lt;strong&gt;操作的数据单位&lt;/strong&gt;不同分为：&lt;strong&gt;字节流（8bit）、字符流（16bit）&lt;/strong&gt;。字节流适合操作图片、视频等文件，字符流适合操作文本文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按数据&lt;strong&gt;流的流向&lt;/strong&gt;不同分为：&lt;strong&gt;输入流、输出流。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按&lt;strong&gt;流的角色&lt;/strong&gt;不同分为：**节点流、处理流。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;节点流：&lt;/strong&gt;直接从数据源或目的地读写数据。也叫&lt;strong&gt;文件流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005745176-1812936854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;处理流：&lt;/strong&gt;不直接连接到数据源或目的地，而是“连接”在已存 在的流（节点流或处理流）之上，通过对数据的处理为程序提 供更为强大的读写功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005756209-569026929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、图示&quot;&gt;2、图示&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005814987-631981059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、四个抽象基类&quot;&gt;3、四个抽象基类&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;抽象基类&lt;/th&gt;
&lt;th&gt;字节流&lt;/th&gt;
&lt;th&gt;字符流&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;输入流&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;输出流&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;4、io流体系&quot;&gt;4、IO流体系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005835858-212857294.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、filereader和filewriter&quot;&gt;四、FileReader和FileWriter&lt;/h2&gt;
&lt;h3 id=&quot;1、idea中单元测试方法和main下相对路径对比&quot;&gt;1、IDEA中单元测试方法和main()下相对路径对比&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;单元测试方法下的相对路径是：相较于当前module而言&lt;/li&gt;
&lt;li&gt;main()下的相对路径：相较于当前工程而言&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、使用filereader读入数据&quot;&gt;2、使用FileReader读入数据&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;最初的代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test1() throws IOException {
        //1.实例化File类,指明要操作的对象.这一步的目的是建立硬盘中的文件和Java中类的对应关系.
        File file = new File(&quot;hello1.txt&quot;);

        //2.提供具体的流.参数的作用就是帮助我们并连接上文件这个&quot;大水库&quot;
        FileReader fileReader = new FileReader(file);

        //3.用流读取到内存
        //read():返回读入的字符,是int需要转换为char.到了文件结尾返回-1
        int read = fileReader.read();
        while (read != -1) {
            System.out.print((char) read);
            read = fileReader.read();
        }

        //4.关闭流
        fileReader.close();
    }
    //整个过程结合图示去理解很合理
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;改进后的代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       /*
    优化:
        1.第三部可以在语法上的优化,但是效率其实是一样的
        2.为了保证关闭操作一定执行,使用try-catch-finally
        3.读入的文件一定要存在,否则会出现:FileNotFoundException
    */
public void test2() {

        FileReader fileReader = null;
        try {
            File file = new File(&quot;hello1.txt&quot;);

            fileReader = new FileReader(file);

            //改进1
            int read;
            while ((read = fileReader.read()) != -1){
                System.out.print((char) read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileReader != null)
                    fileReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用缓冲流改进&lt;/strong&gt;（&lt;strong&gt;这个是用的最多的&lt;/strong&gt;★★★★★）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//使用数组
char[] charBuffer = new char[5];
int len;//记录每次读入到charBuffer数组中的字符个数
while ((len = fileReader.read(charBuffer)) != -1){
    for (int i = 0; i &amp;lt; len; i++) {//这里要用len(读取的字符数)二不是数组的长度
        System.out.print(charBuffer[i]);
    }
}

//当然for循环也可以换位String的构造器来把字符串数组转换为String
String string = new String(charBuffer, 0, len);
System.out.print(string);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、使用filewriter写出数据&quot;&gt;3、使用FileWriter写出数据&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;File file = new File(&quot;hello2.txt&quot;);
FileWriter fw = new FileWriter(file);
fw.write(&quot;i have a dream!&quot;);
fw.close();
//最后用try-catch处理一下异常，上面的步骤更清晰一些
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;说明
&lt;ul&gt;&lt;li&gt;输出时，File可以不存在，不会报异常。&lt;/li&gt;
&lt;li&gt;File对应的硬盘的文件如果不存在，自动创建&lt;/li&gt;
&lt;li&gt;File对应的硬盘的文件如果存在
&lt;ul&gt;&lt;li&gt;如果流使用的构造器是FileWriter(file, false)/FileWriter(file)，对原有的文件进行覆盖&lt;/li&gt;
&lt;li&gt;如果流使用的构造器是FileWriter(file, true)，对原有的文件进行追加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4、使用filereader和filewriter复制文本文件&quot;&gt;4、使用FileReader和FileWriter复制文本文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test5() throws IOException {
        File srcFile = new File(&quot;hello2.txt&quot;);
        File destFile = new File(&quot;hello3.txt&quot;);

        FileReader fr = new FileReader(srcFile);
        FileWriter fw = new FileWriter(destFile);

        char[] charBuffer = new char[5];
        int len;
        while ((len = fr.read(charBuffer)) != -1) {
            fw.write(charBuffer, 0, len);//和用String来取是类似的★★★★★
        }

        fw.close();
        fr.close();
}
//最后用try-catch处理一下异常，上面的步骤更清晰一些
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5、使用filereader和filewriter不能处理图片的复制的测试&quot;&gt;5、使用FileReader和FileWriter不能处理图片的复制的测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当把hello.txt文本文件改为图片文件时，发现代码是可以正常运行，但是复制结果并不对，新图片打不开。&lt;/li&gt;
&lt;li&gt;这是因为，图片是用字节来存储的。用字符流来处理显然不行。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、fileinputstream和fileoutputstream&quot;&gt;五、FileInputStream和FileOutputStream&lt;/h2&gt;
&lt;h3 id=&quot;1、用fileinputstream和fileoutputstream处理文本文件会怎样？&quot;&gt;1、用FileInputStream和FileOutputStream处理文本文件会怎样？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;结论&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;输出到控制台时&lt;/strong&gt;：英文不乱码，中文可能会乱码&lt;/li&gt;
&lt;li&gt;单纯复制，而不在内存层面查看：不会乱码，是可以的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解释&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对于英文&lt;/strong&gt;，utf-8和gbk都是用一个字节（4bit位）来存一个字母，因此每个字母都是完完整整的存入byte数组，从而能完整的复制过去。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于中文&lt;/strong&gt;，utf-8中用的是三个字节来存一个汉字，那么字节数组中的数据在输出时，不确定在哪里截断，就会出现一部分字的乱码。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、确定使用字符流还是字节流&quot;&gt;2、确定使用字符流还是字节流&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对于文本文件（.txt, .java, .cpp），使用字符流&lt;/li&gt;
&lt;li&gt;对于非文本文件（.jpg, .mp3, .mp4, .avi, .doc, .ppt...），使用字节流&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、用fileinputstream和fileoutputstream复制图片&quot;&gt;3、用FileInputStream和FileOutputStream复制图片&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;同“使用FileReader和FileWriter复制文本文件”，只要
&lt;ul&gt;&lt;li&gt;使用FileInputStream和FileOutputStream&lt;/li&gt;
&lt;li&gt;把数组改为byte数组&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六、缓冲流&quot;&gt;六、缓冲流&lt;/h2&gt;
&lt;h3 id=&quot;1、缓冲流有哪些&quot;&gt;1、缓冲流有哪些&lt;/h3&gt;
&lt;p&gt;BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter&lt;/p&gt;
&lt;h3 id=&quot;2、作用&quot;&gt;2、作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提高读写速度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、原因&quot;&gt;3、原因&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在使用这些流类时，会&lt;strong&gt;创建一个内部缓冲区数组，&lt;/strong&gt;缺省使用8192个字节(8Kb)的缓冲区。&lt;/li&gt;
&lt;li&gt;当读取数据时，数据按块&lt;strong&gt;读入缓冲区&lt;/strong&gt;，其后的读操作则&lt;strong&gt;直接访问缓冲区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。&lt;/li&gt;
&lt;li&gt;向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;方法 flush()&lt;/strong&gt;可以强制将缓冲区的内容全部写入输出流。&lt;/li&gt;
&lt;li&gt;如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷 新缓冲区，关闭后不能再写出。
&lt;ul&gt;&lt;li&gt;填坑：自己写代码的时候忘记关闭流操作，导致复制的图片打不开的原因就是，没有关闭流，缓冲区内还有一部分数据没能复制过去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4、使用缓冲流复制图片&quot;&gt;4、使用缓冲流复制图片&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test() throws IOException {
        //1.创建File
        File srcFile = new File(&quot;img1.png&quot;);
        File destFile = new File(&quot;img2.png&quot;);

        //2.创建流
        //2.1创建文件流
        FileInputStream fis = new FileInputStream(srcFile);
        FileOutputStream fos = new FileOutputStream(destFile);

        //2.2创建字节流
        BufferedInputStream bis = new BufferedInputStream(fis);
        BufferedOutputStream bos = new BufferedOutputStream(fos);

        //3.复制
        byte[] bytes = new byte[10];
        int len;
        while ((len = bis.read(bytes)) != -1){
            bos.write(bytes,0,len);
        }

        //4.关闭流
        bis.close();
        bos.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关闭外层的流的同时，会自动关闭内层的流。所以只写外层的关闭操作就可以。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5、使用缓冲流复制文本文件&quot;&gt;5、使用缓冲流复制文本文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test1() throws IOException {
        //1.创建文件和流
        BufferedReader br = new BufferedReader(new FileReader(new File(&quot;hello1.txt&quot;)));
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;hello4.txt&quot;)));

//        //2.复制
//        char[] chars = new char[10];
//        int len;
//        while ((len = br.read(chars)) != -1) {
//            bw.write(chars, 0, len);
//        }


        // 复制:用String来实现★★★★★★★★★★★
        String data;//但是是不带换行的,可以用一以下两种方法实现
        while ((data = br.readLine()) != null) {
//          //方法一★★★★★★★★
//            bw.write(data + &quot;\n&quot;);
            //方法二★★★★★★★★
            bw.write(data);
            bw.newLine();
        }

        //3.关闭
        br.close();
        bw.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6、练习：统计文本每个字符出现次数&quot;&gt;6、练习：统计文本每个字符出现次数&lt;/h3&gt;
&lt;h2 id=&quot;七、转换流&quot;&gt;七、转换流&lt;/h2&gt;
&lt;h3 id=&quot;1、什么是转换流&quot;&gt;1、什么是转换流&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;转换流提供了在&lt;strong&gt;字节流和字符流之间的转换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;转换流属于&lt;strong&gt;字符流&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Java API提供了两个转换流
&lt;ul&gt;&lt;li&gt;InputStreamReader：将InputStream转换为Reader
&lt;ul&gt;&lt;li&gt;构造器一：&lt;code&gt;public InputStreamReader(InputStream in)&lt;/code&gt;默认使用utf-8字符集&lt;/li&gt;
&lt;li&gt;构造器二：&lt;code&gt;public InputSreamReader(InputStream in,String charsetName)&lt;/code&gt;可以自己选择字符集。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OutputStreamWriter：将Writer转换为OutputStream
&lt;ul&gt;&lt;li&gt;构造器和上面类似&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;字节流中的数据都是字符时，转成字符流操作更高效。&lt;/li&gt;
&lt;li&gt;很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、编码与解码&quot;&gt;2、编码与解码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;编码：字节、字节数组---&amp;gt;字符数组、字符串&lt;/li&gt;
&lt;li&gt;解码：字符数组、字符串---&amp;gt;字节、字节数组&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、字符集&quot;&gt;3、字符集&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;什么是编码表&lt;/strong&gt;：计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识 别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。 这就是编码表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见编码表&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;按照地区辅助记忆&lt;/th&gt;
&lt;th&gt;编码表&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;美国&lt;/td&gt;
&lt;td&gt;ASCII&lt;/td&gt;
&lt;td&gt;用&lt;strong&gt;一个字节的7位&lt;/strong&gt;来表示所有英文和符号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;欧洲&lt;/td&gt;
&lt;td&gt;ISO8859-1&lt;/td&gt;
&lt;td&gt;用&lt;strong&gt;一个字节的8位&lt;/strong&gt;表示所有欧洲语言的字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;中国&lt;/td&gt;
&lt;td&gt;GB2312&lt;br/&gt;GBK&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最多两个字节&lt;/strong&gt;编码所有汉字&lt;br/&gt;升级版，加入了更多的汉字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;国际通用&lt;/td&gt;
&lt;td&gt;Unicode&lt;br/&gt;UTF-8&lt;/td&gt;
&lt;td&gt;Unicode编码是对UTF-8/16的统称&lt;br/&gt;用&lt;strong&gt;1-4个字节&lt;/strong&gt;表示人类所有文字&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;4、转换流的作用示意图&quot;&gt;4、转换流的作用示意图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2031463/202011/2031463-20201126005920627-2038164186.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5、练习题&quot;&gt;5、练习题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;综合使用：将文本文件从utf-8转换为gbk编码&lt;/li&gt;
&lt;li&gt;代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
    public void test2() throws Exception {
        //1.造文件、造流
        File file1 = new File(&quot;dbcp.txt&quot;);
        File file2 = new File(&quot;dbcp_gbk.txt&quot;);

        FileInputStream fis = new FileInputStream(file1);
        FileOutputStream fos = new FileOutputStream(file2);

        InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);
        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;);

        //2.读写过程
        char[] cbuf = new char[20];
        int len;
        while((len = isr.read(cbuf)) != -1){
            osw.write(cbuf,0,len);
        }

        //3.关闭资源
        isr.close();
        osw.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八、标准输入输出流（了解）&quot;&gt;八、标准输入输出流（了解）&lt;/h2&gt;
&lt;h3 id=&quot;1、简介&quot;&gt;1、简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;标准输入流：System.in。默认输入设备是键盘。&lt;strong&gt;类型是InputStream。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;标准输出流：System.out。默认输出设备是控制台。&lt;strong&gt;类型是PrintStream，是OutputStream的子类。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2练习&quot;&gt;2.练习&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;题目：从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续 进行输入操作，直至当输入“e”或者“exit”时，退出程序。&lt;/li&gt;
&lt;li&gt;代码实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Exercise {
    public static void main(String[] args) {//idea不支持在单元测试中输入内容,所以改用main()来测试
        BufferedReader br = null;
        try {
            InputStreamReader isr = new InputStreamReader(System.in);
            br = new BufferedReader(isr);

            while (true) {
                System.out.println(&quot;请输入字符串: &quot;);
                String data = br.readLine();
                if (&quot;e&quot;.equalsIgnoreCase(data)||&quot;exit&quot;.equalsIgnoreCase(data)){
                    System.out.println(&quot;程序结束&quot;);
                    break;
                }
                String upperCase = data.toUpperCase();
                System.out.println(upperCase);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null) {
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;九、打印流（了解）&quot;&gt;九、打印流（了解）&lt;/h2&gt;
&lt;h3 id=&quot;1、打印流简介&quot;&gt;1、打印流简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;实现将&lt;strong&gt;基本数据类型&lt;/strong&gt;的数据格式转化为&lt;strong&gt;字符串&lt;/strong&gt;来&lt;strong&gt;输出&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;包含两个：&lt;strong&gt;PrintStream和PrintWriter&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;提供了一系列重载的print()和println()方法，用于多种数据类型的输出&lt;/li&gt;
&lt;li&gt;System.out返回的是PrintStream的实例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、代码演示&quot;&gt;2、代码演示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;把标准输出流(控制台输出)改成文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PrintStream ps = null; 
try {
        FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\IO\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\n' 时都会刷新输出缓冲区) 
    ps = new PrintStream(fos, true); 
    if (ps != null) {// 把标准输出流(控制台输出)改成文件 
        System.setOut(ps); 
    }

        for (int i = 0; i &amp;lt;= 255; i++) { // 输出ASCII字符
                System.out.print((char) i); 
        if (i % 50 == 0) { // 每50个数据一行 
            System.out.println(); // 换行 
        }
    } 
} catch (FileNotFoundException e) { 
    e.printStackTrace(); 
} finally {
    if (ps != null) { 
        ps.close(); 
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;十、数据流（了解）&quot;&gt;十、数据流（了解）&lt;/h2&gt;
&lt;h3 id=&quot;1、简介-2&quot;&gt;1、简介&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;引入&lt;/strong&gt;：为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据流有两个类：(用于&lt;strong&gt;读取和写出&lt;/strong&gt;基本数据类型、String类的数据，方便持久化）&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DataInputStream 和 DataOutputStream&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;DataInputStream中的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;boolean readBoolean()&lt;/p&gt;
&lt;p&gt;char readChar()&lt;/p&gt;
&lt;p&gt;double readDouble()&lt;/p&gt;
&lt;p&gt;long readLong()&lt;/p&gt;
&lt;p&gt;String readUTF()&lt;/p&gt;
&lt;p&gt;byte readByte()&lt;/p&gt;
&lt;p&gt;float readFloat()&lt;/p&gt;
&lt;p&gt;short readShort()&lt;/p&gt;
&lt;p&gt;int readInt() void&lt;/p&gt;
&lt;p&gt;readFully(byte[] b)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;DataOutputStream中的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上述的方法的read改为相应的write即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、练习&quot;&gt;2、练习&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;练习：将内存中的字符串、基本数据类型的变量写出到文件中。

    注意：处理异常的话，仍然应该使用try-catch-finally.
     */
    @Test
    public void test3() throws IOException {
        //1.
        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;));
        //2.
        dos.writeUTF(&quot;刘建辰&quot;);
        dos.flush();//刷新操作，将内存中的数据写入文件
        dos.writeInt(23);
        dos.flush();
        dos.writeBoolean(true);
        dos.flush();
        //3.
        dos.close();


    }
    /*
    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。

    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！

     */
    @Test
    public void test4() throws IOException {
        //1.
        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;));
        //2.
        String name = dis.readUTF();
        int age = dis.readInt();
        boolean isMale = dis.readBoolean();

        System.out.println(&quot;name = &quot; + name);
        System.out.println(&quot;age = &quot; + age);
        System.out.println(&quot;isMale = &quot; + isMale);

        //3.
        dis.close();

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;十一、对象流&quot;&gt;十一、对象流&lt;/h2&gt;
&lt;h3 id=&quot;1、简介-3&quot;&gt;1、简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;包含：两个类ObjectInputStream和ObjectOutputStream&lt;/li&gt;
&lt;li&gt;是：用于存储和读取基本数据类型数据或对象的处理流&lt;/li&gt;
&lt;li&gt;强大之处：可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、对象的序列化★★★★★&quot;&gt;2、对象的序列化★★★★★&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;什么是对象的序列化机制（面试题）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一方面，对象的序列化机制允许内存中的&lt;strong&gt;Java对象转换为平台无关的二进制流&lt;/strong&gt;。从而允许吧二进制流&lt;strong&gt;持久化到磁盘&lt;/strong&gt;，或，通过网络&lt;strong&gt;传给另一个网络节点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;另一方面，其他程序获取了二进制流，就可以恢复成原来的Java对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;序列化的好处&lt;/strong&gt;：可将任何实现了Serializable接 使其在保存和传输时可被还原。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、代码实现string类的对象的序列化和反序列化&quot;&gt;3、代码实现String类的对象的序列化和反序列化&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ObjectInputOutputStream {
    /*
    代码实现String类的对象的序列化和反序列化
     */

    @Test//序列化
    public void testObjectOutputStream(){
        ObjectOutputStream oos = null;
        try {
            //1.造流和文件
            oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;objectString.dat&quot;)));
            //2.写出
            oos.writeObject(new String(&quot;我爱你中国&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //3.关闭流
            try {
                if (oos != null) {
                    oos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Test
    public void testObjectInputStream(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(new File(&quot;objectString.dat&quot;)));

            Object readObject = ois.readObject();
            System.out.println(readObject);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                if (ois != null) {
                    ois.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、自定义类的序列化&quot;&gt;4、自定义类的序列化&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;要求&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;实现Serializable接口（这是一个标识接口，内部没有方法）&lt;/li&gt;
&lt;li&gt;提供一个全局常量&lt;code&gt;public static final long serialVersionUID = xxxxxxxxL;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自 动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议， 显式声明。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;还要保证类的所以属性也是可序列化的。
&lt;ul&gt;&lt;li&gt;基本数据类型是可序列化的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：ObjectOutputStream和ObjectInputStream不能序列化&lt;strong&gt;static和transient修饰&lt;/strong&gt;的成员变量
&lt;ul&gt;&lt;li&gt;因为static修饰的变量是类所有的&lt;/li&gt;
&lt;li&gt;不想序列化的就可以用transient&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5、面试题&quot;&gt;5、面试题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化， 是空方法接口，还有其它认识吗？
&lt;ul&gt;&lt;li&gt;实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后 完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机 制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创 建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里 准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必 关心字节的顺序或者其他任何细节。&lt;/li&gt;
&lt;li&gt;由于大部分作为参数的类如String、Integer等都实现了 java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更 灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;十二、randomaccessfile&quot;&gt;十二、RandomAccessFile&lt;/h2&gt;
&lt;h3 id=&quot;1、简介-4&quot;&gt;1、简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;RandomAccessFile，随机存取文件流，&lt;strong&gt;直接继承于java.lang.Object类&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;随机：&lt;/strong&gt;RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。 RandomAccessFile 类对象可以自由移动记录指针
&lt;ul&gt;&lt;li&gt;long getFilePointer()：获取文件记录指针的当前位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void seek(long pos)：将文件记录指针定位到 pos 位置（这是他的灵魂所在）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;应用场景：可以多线程断点下载同一文件再拼接起来；下载不完，下次接着下载。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存取&lt;/strong&gt;：实现了DataInput、DataOutput两个接口&lt;strong&gt;，所以这个类&lt;/strong&gt;既可以读也可以写**。
&lt;ul&gt;&lt;li&gt;可以用&lt;strong&gt;构造器里的参数&lt;/strong&gt;决定是输出流还是输入流。
&lt;ul&gt;&lt;li&gt;public RandomAccessFile(File file, String &lt;strong&gt;mode)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;public RandomAccessFile(String name, String &lt;strong&gt;mode)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;mode参数指定了访问模式
&lt;ul&gt;&lt;li&gt;r: 以只读方式打开 （常用）&lt;/li&gt;
&lt;li&gt;rw：打开以便读取和写入 （常用）&lt;/li&gt;
&lt;li&gt;rwd:打开以便读取和写入；同步文件内容的更新&lt;/li&gt;
&lt;li&gt;rws:打开以便读取和写入；同步文件内容和元数据的更新&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、用randomaccessfile类实现文本文件的复制&quot;&gt;2、用RandomAccessFile类实现文本文件的复制&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1() throws IOException {
    //用参数mode标识,让类代表输入
    RandomAccessFile r = new RandomAccessFile(new File(&quot;hello1.txt&quot;), &quot;r&quot;);
    //用参数mode标识,让类代表输出
    RandomAccessFile rw = new RandomAccessFile(new File(&quot;hello5.txt&quot;), &quot;rw&quot;);

    byte[] bytes = new byte[1024];
    int len;
    while ((len=r.read(bytes)) != -1){
        rw.write(bytes,0,len);
    }

    r.close();
    rw.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、用-randomaccessfile作为输出流时的特点&quot;&gt;3、用 RandomAccessFile作为输出流时的特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果写出到的文件不存在，就创建&lt;/li&gt;
&lt;li&gt;如果写出到的文件存在，会对原文&lt;strong&gt;从头开始进行覆盖&lt;/strong&gt;，能覆盖多少算多少。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4、如何使用-randomaccessfile对文本文件实现插入效果&quot;&gt;4、如何使用 RandomAccessFile对文本文件实现插入效果&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/*
    使用RandomAccessFile实现数据的插入效果
     */
    @Test
    public void test3() throws IOException {

        RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;);

        raf1.seek(3);//将指针调到角标为3的位置
        //保存指针3后面的所有数据到StringBuilder中
        StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());
        byte[] buffer = new byte[20];
        int len;
        while((len = raf1.read(buffer)) != -1){
            builder.append(new String(buffer,0,len)) ;
        }
        //调回指针，写入“xyz”
        raf1.seek(3);
        raf1.write(&quot;xyz&quot;.getBytes());

        //将StringBuilder中的数据写入到文件中
        raf1.write(builder.toString().getBytes());

        raf1.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;十三、第三方jar包的使用&quot;&gt;十三、第三方jar包的使用&lt;/h2&gt;
&lt;h3 id=&quot;1、为什么使用&quot;&gt;1、为什么使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第三方jar包提供了很多方便高效的API，方便我们开发中使用，实际开发中也是用这些jar包来提高工作效率，而不只是根据JDK提供的API，因为有些不够简练。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、idea中导入第三方jar包&quot;&gt;2、IDEA中导入第三方jar包&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当前module下创建名为lib或libs的directory&lt;/li&gt;
&lt;li&gt;复制第三方jar包到lib目录&lt;/li&gt;
&lt;li&gt;右键jar包，选择 add as library&lt;/li&gt;
&lt;li&gt;搞定&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、用第三方jar包实现文件复制&quot;&gt;3、用第三方jar包实现文件复制&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JarTest {
    public static void main(String[] args) throws IOException {
        File srcFile = new File(&quot;s6_IO/hello1.txt&quot;);
        File destFile = new File(&quot;s6_IO/hello6.txt&quot;);

        FileUtils.copyFile(srcFile,destFile);

    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 25 Nov 2020 17:01:00 +0000</pubDate>
<dc:creator>Javalove刘志先</dc:creator>
<og:description>一、File类 1、File类概述 java.io.File类：一个java.io.File类的对象，表示文件和文件目录路径（就是文件夹） File 能新建、删除、重命名文件和目录，但 File 不能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuzhixian666/p/14040126.html</dc:identifier>
</item>
<item>
<title>分布式监控系统之Zabbix proxy - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14039421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14039421.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_201117164641zabbix.jpg&quot; class=&quot;desc_img&quot;/&gt; 我们试想一个场景，我们要监控一个集群，这个集群有100台物理主机，每个物理主机都要监控cpu，内存，磁盘等等，一台服务器平均监控项为20个，那么100台服务器就要2000个socket连接；这意味着zabbix server要有2000个socket连接需要维持；这样一来无疑对zabbix server性能有很大的影响；为了降低zabbix server连接socket数量过大而带来的性能消耗，此时zabbix server就应该委托其他主机来代理收集数据；这个代理就是zabbix proxy；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;169.75161373612&quot;&gt;
&lt;p&gt;　　前文我们了解了zabbix 使用snmp和jmx信道采集数据的相关使用配置，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14029864.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14029864.html&lt;/a&gt;；今天我们来说zabbix proxy；&lt;/p&gt;
&lt;p&gt;　　1、zabbix proxy是什么？为什么要使用zabbix proxy?&lt;/p&gt;
&lt;p&gt;　　简单讲zabbix proxy就是zabbix server的代理服务，它能帮助zabbix server采集数据，然后再统一的发送给zabbix server ；它的功能和zabbix server 很类似，zabbix server 能做到它几乎都能做；主要作用就是代理zabbix server ；我们知道监控一个主机或者服务，通常监控项有很多，每个监控项的数据采集工作都会消耗zabbix server 一个socket；这样一来监控一个主机少则十几个socket连接，多则几十个上百个；我们试想一个场景，我们要监控一个集群，这个集群有100台物理主机，每个物理主机都要监控cpu，内存，磁盘等等，一台服务器平均监控项为20个，那么100台服务器就要2000个socket连接；这意味着zabbix server要有2000个socket连接需要维持；这样一来无疑对zabbix server性能有很大的影响；为了降低zabbix server连接socket数量过大而带来的性能消耗，此时zabbix server就应该委托其他主机来代理收集数据；这个代理就是zabbix proxy；除了以上场景，比如跨机房的场景我们也需要用zabbix proxy，每个zabbix proxy只负责采集本地同一机房里的主机的数据，然后统一发送给zabbix server；这样一来可以减少zabbix server的socket连接数量，从而降低zabbix server的压力；&lt;/p&gt;
&lt;p&gt;　　2、zabbix proxy内部组件&lt;/p&gt;
&lt;p&gt;　　zabbix proxy主要由zabbix proxy和数据库组成；它这个数据库不是永久存储采集数据的，它可以将采集的数据临时存放在数据库中，当它把对应的数据发送给zabbix server以后，本地临时存储的数据就会清除；除了缓存采集的数据意外，它还可以用来存储在zabbix server上拉取的监控配置信息；&lt;/p&gt;
&lt;p&gt;　　3、zabbix proxy 部署&lt;/p&gt;
&lt;p&gt;　　准备yum仓库文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# scp /etc/yum.repos.d/zabbix.repo node06:/etc/yum.repos.d/
zabbix.repo                                                                   100%  242   164.4KB/s   00:00    
[root@node03 ~]# scp /etc/yum.repos.d/mariadb.repo node06:/etc/yum.repos.d/
mariadb.repo                                                                  100%  129   116.6KB/s   00:00    
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装MariaDB-server&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# yum install -y  MariaDB-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# cat /etc/my.cnf.d/zabbix_proxy.cnf
[mysqld]
bind-address = 0.0.0.0
default-storage-engine = innodb
innodb_file_per_table = on
max_connections = 4096
collation-server = utf8_general_ci
character-set-server = utf8
skip_name_resolve
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动mariadb&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# /etc/init.d/mysql start
Starting MariaDB.201125 22:12:03 mysqld_safe Logging to '/var/lib/mysql/node06.test.org.err'.
201125 22:12:03 mysqld_safe Starting mysqld daemon with databases from /var/lib/mysql
 SUCCESS! 
[root@node06 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:3306                                     *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　设置root密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# mysql_secure_installation 

NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!

In order to log into MariaDB to secure it, we'll need the current
password for the root user.  If you've just installed MariaDB, and
you haven't set the root password yet, the password will be blank,
so you should just press enter here.

Enter current password for root (enter for none): 
OK, successfully used password, moving on...

Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.

Set root password? [Y/n] y
New password: 
Re-enter new password: 
Password updated successfully!
Reloading privilege tables..
 ... Success!


By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.

Remove anonymous users? [Y/n] y
 ... Success!

Normally, root should only be allowed to connect from 'localhost'.  This
ensures that someone cannot guess at the root password from the network.

Disallow root login remotely? [Y/n] y
 ... Success!

By default, MariaDB comes with a database named 'test' that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.

Remove test database and access to it? [Y/n] y
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!

Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.

Reload privilege tables now? [Y/n] y
 ... Success!

Cleaning up...

All done!  If you've completed all of the above steps, your MariaDB
installation should now be secure.

Thanks for using MariaDB!
[root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建数据库和用户授权&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# mysql -uroot -padmin123.com
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 11
Server version: 10.0.38-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt;  create database zabbix character set utf8 collate utf8_bin; 
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]&amp;gt; grant all privileges on zabbix.* to zabbix_proxy@'192.168.%.%' identified by 'admin123.com';
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装zabbix proxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# yum install -y zabbix-proxy-mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看zabbix proxy 安装的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# rpm -ql zabbix-proxy-mysql
/etc/logrotate.d/zabbix-proxy
/etc/zabbix/zabbix_proxy.conf
/usr/lib/systemd/system/zabbix-proxy.service
/usr/lib/tmpfiles.d/zabbix-proxy.conf
/usr/lib/zabbix/externalscripts
/usr/sbin/zabbix_proxy_mysql
/usr/share/doc/zabbix-proxy-mysql-4.0.26
/usr/share/doc/zabbix-proxy-mysql-4.0.26/AUTHORS
/usr/share/doc/zabbix-proxy-mysql-4.0.26/COPYING
/usr/share/doc/zabbix-proxy-mysql-4.0.26/ChangeLog
/usr/share/doc/zabbix-proxy-mysql-4.0.26/NEWS
/usr/share/doc/zabbix-proxy-mysql-4.0.26/README
/usr/share/doc/zabbix-proxy-mysql-4.0.26/schema.sql.gz
/usr/share/man/man8/zabbix_proxy.8.gz
/var/log/zabbix
/var/run/zabbix
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　导入表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# zcat /usr/share/doc/zabbix-proxy-mysql-4.0.26/schema.sql.gz |mysql -uzabbix_proxy -padmin123.com -h192.168.0.46 zabbix
[root@node06 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看对应数据库是否有表生成？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# mysql -uzabbix_proxy -padmin123.com -h192.168.0.46 zabbix -e 'show tables;' |wc -l
145
[root@node06 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：能够统计到对应表的数量，说明我们导入表的操作没有问题；&lt;/p&gt;
&lt;p&gt;　　配置zabbix proxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# grep -Ei &quot;^[a-z]&quot; /etc/zabbix/zabbix_proxy.conf
ProxyMode=0
Server=192.168.0.43
ServerPort=10051
HostnameItem=system.hostname
ListenPort=10051
LogFile=/var/log/zabbix/zabbix_proxy.log
LogFileSize=0
DebugLevel=3
PidFile=/var/run/zabbix/zabbix_proxy.pid
SocketDir=/var/run/zabbix
DBHost=192.168.0.46
DBName=zabbix
DBUser=zabbix_proxy
DBPassword=admin123.com
HeartbeatFrequency=60
ConfigFrequency=60
DataSenderFrequency=1
StartPollers=5
SNMPTrapperFile=/var/log/snmptrap/snmptrap.log
Timeout=4
ExternalScripts=/usr/lib/zabbix/externalscripts
LogSlowQueries=3000
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：主要配置zabbix server的地址以及zabbix proxy的hostname和数据库相关的几个选项以及后面的心跳频率和配置文件更新频率以及数据发送频率；其他保持默认即可；这里需要提醒下，默认情况zabbix proxy 工作为主动模式，所谓主动模式是指zabbix proxy主动到zabbix server上获取监控配置和推送采集的数据；如果需要配置为被动，这需要将ProxyMode更改为1即可；Server是配置zabbix server的地址，意思是告诉proxy到到哪里获取配置以及将采集的数据推送到哪里；后面的HeartbeatFrequency是用来指定多长时间发送一次心跳信息给zabbix server，默认是60秒；ConfigFrequency是用来指定更新监控配置信息的频率，意思是多久去zabbix server 上同步一下监控配置；默认是3600；这个可以根据实际情况更改；DataSenderFrequency是用于指定多长时间发一次数据给zabbix server，默认为1秒；&lt;/p&gt;
&lt;p&gt;　　启动zabbix proxy&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# systemctl start zabbix-proxy.service 
[root@node06 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10051                                    *:*                  
LISTEN     0      128                          *:3306                                     *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
LISTEN     0      128                         :::10051                                   :::*                  
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：zabbix proxy 默认监听在10051，启动后请确保该端口正常监听；&lt;/p&gt;
&lt;p&gt;　　安装zabbix agent用于监控zabbix proxy自身&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# yum install -y zabbix-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置zabbix agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# grep -Ei &quot;^[a-z]&quot; /etc/zabbix/zabbix_agentd.conf
PidFile=/var/run/zabbix/zabbix_agentd.pid
LogFile=/var/log/zabbix/zabbix_agentd.log
LogFileSize=0
Server=192.168.0.46
ListenPort=10050
ListenIP=0.0.0.0
ServerActive=192.168.0.46
HostnameItem=system.hostname
Include=/etc/zabbix/zabbix_agentd.d/*.conf
[root@node06 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里的配置和我们前边配置zabbix agent几乎一样，不同的是我们需要将Server指向zabbix proxy的地址和端口；如果其他agent需要用到proxy来代理，需要配置运行proxy来采集数据；这个Server的值可以是多个，分别用逗号隔开即可；同样ServerActive也应该指向zabbix proxy的地址；&lt;/p&gt;
&lt;p&gt;　　启动zabbix agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node06 ~]# systemctl start zabbix-agent.service 
[root@node06 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                          *:10051                                    *:*                  
LISTEN     0      128                          *:3306                                     *:*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
LISTEN     0      128                         :::10051                                   :::*                  
[root@node06 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在zabbix web界面配置添加zabbix proxy&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125225057718-1795762682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在administration---&amp;gt;proxIes----&amp;gt;create proxy点击进入新建proxy的页面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125232038060-54637099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里的proxy name必须和本地运行zabbix proxy服务主机名称相同；填写好proxy name以后点击添加即可；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125232301411-952248831.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加主机，使用我们刚才添加到proxy来代理采集数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125232413425-743529318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：添加主机一定要选择对应要使用的zabbix proxy；&lt;/p&gt;
&lt;p&gt;　　链接模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125232737715-533240427.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择好模板以后，最后点击add将主机添加到主机列表；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125232807526-2027681243.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在添加到主机，前边都有对应proxy的名称；过一会我们就可以看到proxy将模板上的监控数据采集后，发送给zabbix server，此时就可以看到对应的主机上的监控数据；&lt;/p&gt;
&lt;p&gt;　　验证：查看对应主机是否有监控数据？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125233045833-1269314755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到node06链接的模板监控项也陆续有数据，说明proxy采集到数据已经发送给zabbix server ;&lt;/p&gt;
&lt;p&gt;　　查看zabbix proxy状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201125233613688-501123274.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在node06.test.org这个proxy有一个host,34个item，vps为0.39；如果其他主机需要用该proxy代理采集数据，我们需要将对应的agent配置允许该proxy来采集数据；&lt;/p&gt;
&lt;p&gt;　　到此，zabbix proxy的安装，测试就完成了；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 25 Nov 2020 15:58:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了zabbix 使用snmp和jmx信道采集数据的相关使用配置，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/14029864.html；今天我们来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14039421.html</dc:identifier>
</item>
<item>
<title>架构设计：服务自动化部署和管理流程 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14039571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14039571.html</guid>
<description>&lt;p&gt;常规分布式架构系统来说，划分出十来个独立的微服务模块是很常见的，然后不同的开发人员分工几个服务块，负责日常开发和维护，微服务之间会出现版本差异也是自然的。例如用户服务需要开发版本为7.0，其他服务可能高于这个版本或者低于这个版本，所以对服务发布这块做持续集成就很有必要。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;90.230112119594&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从常规分布式架构系统来说，划分出十来个独立的微服务模块是很常见的，然后不同的开发人员分工几个服务块，负责日常开发和维护，微服务之间会出现版本差异也是自然的。例如用户服务需要开发版本为7.0，其他服务可能高于这个版本或者低于这个版本，所以对服务发布这块做持续集成就很有必要。&lt;/p&gt;
&lt;p&gt;现在比较通用的服务自动发布和管理的技术栈：Jenkins持续集成工具、Docker容器、K8S容器管理。&lt;/p&gt;

&lt;p&gt;Jenkins可以很方便的整合常用的代码仓库，例如：GitHub、SVN等，提供持续集成能力，可以把整个代码构建打包，部署做成自动管理流程，代码一经提交就会自动发布到指定环境下，极大减少非必要的工作量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202011/1691717-20201125230039645-80819908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发人员提交本地代码；&lt;/li&gt;
&lt;li&gt;代码仓库通过Hook机制通知Jenkins；&lt;/li&gt;
&lt;li&gt;Jenkins获取最新代码编译打包；&lt;/li&gt;
&lt;li&gt;生成Docker镜像文件上传到中心仓库；&lt;/li&gt;
&lt;li&gt;最终触发滚动或者灰度等发布机制；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在整个代码发布过程如果出现问题，可以快速的回滚到上个版本，需要手动处理的流程极少，作为程序员这个职业，越是工作时间长，越要善用自动化的流程。系统架构越复杂，则服务部署、数据和环境隔离、容灾、灰度、动态扩容就更是需要自动管理，上述技术体系可以很轻松的解决这些问题。&lt;/p&gt;

&lt;p&gt;Docker是作为开源的应用容器引擎，有三个核心概念，Image-镜像，Container-容器、Repository-仓库；开发人员可以通过打包应用和依赖包到一个可移植的容器中，容器是完全使用沙箱机制，相互之间不会有任何接口，然后发布到任何流行的服务器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;上述微服务模块变多，需要持续集成工具管理；同理当Docker容器变多和复杂，管理和调度也是一个问题。&lt;/p&gt;

&lt;p&gt;Kubernetes简称K8S，用做灵活和便捷管理和调度Docker容器，提供应用部署、规划、更新、维护的一种机制，让部署容器化的应用简单并且高效，支持自动化部署、大规模可伸缩、应用容器化管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202011/1691717-20201125230055347-389672370.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的部署环境架构下，Docker可以理解为Kubernetes上的一个组件，通过K8S去统一管理。&lt;/p&gt;
&lt;p&gt;这样一套服务发布和环境管理的技术体系现在非常常用，从开发的角度看，熟悉基本使用流程最好，原理逻辑不负责，但是实际操作复杂，通常由专业的运维管理，能说清楚环境的搭建思路也是面试中常见的问题。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub地址：知了一笑
https://github.com/cicadasmile/spring-cloud-base
GitEE地址：知了一笑
https://gitee.com/cicadasmile/spring-cloud-base
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 25 Nov 2020 15:12:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>常规分布式架构系统来说，划分出十来个独立的微服务模块是很常见的，然后不同的开发人员分工几个服务块，负责日常开发和维护，微服务之间会出现版本差异也是自然的。例如用户服务需要开发版本为7.0，其他服务可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14039571.html</dc:identifier>
</item>
<item>
<title>JVM(二)-内存区域之线程私有区域 - 负重前行的小牛</title>
<link>http://www.cnblogs.com/liu-yi/p/14022160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liu-yi/p/14022160.html</guid>
<description>&lt;h3&gt;概述：&lt;/h3&gt;
&lt;p&gt;　　对于从事C、C++开发的程序员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”，又是从事最基础工作的劳动人民——既拥有每个对象的“所有权”，&lt;/p&gt;
&lt;p&gt;又担负着每一个对象从开始到终结的维护职责。&lt;/p&gt;
&lt;p&gt;　　对于java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为没一个new操作去配对的free/delete（C、C++语言对对象的删除和内存释放操作），&lt;/p&gt;
&lt;p&gt;不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切看起来很美好。不过，也正是java把控制内存的权力交给了java虚拟机，一旦出现内存泄漏&lt;/p&gt;
&lt;p&gt;和内存溢出方面的问题，如果不了解虚拟机是怎么使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。&lt;/p&gt;
&lt;h3&gt;运行时数据区：&lt;/h3&gt;
&lt;p&gt;　　java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有些区域会随着&lt;/p&gt;
&lt;p&gt;虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201123232032481-412468689.png&quot; alt=&quot;&quot; width=&quot;1342&quot; height=&quot;810&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道JVM也属于一种特殊的操作系统，那这些数据区域跟我们最常用的windows哪些部分相对应呢。我们可以吧windows的CPU+缓存+主内存和JVM的执行引擎+&lt;/p&gt;
&lt;p&gt;操作数栈+（栈、堆）对应起来，这样更加利于我们去理解JVM。&lt;/p&gt;
&lt;h3&gt;虚拟机栈：&lt;/h3&gt;
&lt;p&gt;　　从上图可见，java虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会&lt;/p&gt;
&lt;p&gt;同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、&lt;strong&gt;返回地址&lt;/strong&gt;等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到&lt;/p&gt;
&lt;p&gt;出栈的过程。我们来通过一段非常简短的代码来演示虚拟机栈的作用：&lt;/p&gt;
&lt;div readability=&quot;84.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName StackTest
 * @description：
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;：liuyi
 * @Date：2020/11/23 23:45
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StackTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        A();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; A(){
        B();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; B(){
        C();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; C(){

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们运行main方法，虚拟机会开启一个线程，同时为当前线程划分一块内存区域作为当前线程的虚拟机栈。同时在执行每个方法的时候都会打包成一个栈帧。&lt;/p&gt;
&lt;p&gt;比如 main 开始运行，打包一个栈帧送入到虚拟机栈。C 方法运行完了，C 方法出栈，接着 B 方法运行完了，B 方法出栈、接着 A 方法运行完了，A 方法出栈，&lt;/p&gt;
&lt;p&gt;最后 main 方法运行完了，main 方法这个栈帧就出栈了。这个就是 Java 方法运行对虚拟机栈的一个影响。虚拟机栈就是用来存储线程运行方法中的数据的。而&lt;/p&gt;
&lt;p&gt;每一个方法对应一个栈帧。入栈过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201124204225232-1140372890.png&quot; alt=&quot;&quot; width=&quot;1551&quot; height=&quot;1452&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上图描述了整个main方法调用的入栈和出栈的过程，需要注意的是栈帧出栈之后就没了，栈帧没得GC的说法。&lt;/p&gt;
&lt;h4&gt;栈帧详解：&lt;/h4&gt;
&lt;p&gt;　　栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址)&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量表：&lt;/strong&gt;顾名思义就是局部变量的表，用于存放我们的局部变量的（方法中的变量）。首先它是一个 32 位的长度，主要存放我们的 Java 的八大基础数据&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;类型，一般 32 位就可以存放下，如果是 64 位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的 Object 对象，我们只需要存放它的一个引用地址即可。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;操作数栈：&lt;/strong&gt;存放 java 方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的 java 数据类型，所&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的。操作数栈本质上是 JVM 执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;动态连接：&lt;/strong&gt;Java 语言特性多态（后续章节细讲，需要结合 class 与执行引擎一起来讲）。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;48&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法出口：&lt;/strong&gt;正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&amp;lt;非栈帧中的&amp;gt;来确定）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来通过分析一个简单的方法来理解栈帧中各个区域是如何运作的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
/**&lt;br/&gt;* @ClassName User&lt;br/&gt;* @description：&lt;br/&gt;* @author：liuyi&lt;br/&gt;* @Date：2020/11/25 20:51&lt;br/&gt;*/&lt;br/&gt;public class User {&lt;br/&gt;public static int work(){&lt;br/&gt;int a = 2;&lt;br/&gt;int b = 3;&lt;br/&gt;int c = a*b;&lt;br/&gt;return c;&lt;br/&gt;}&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;System.out.println(work());&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　当该程序运行的时候，JVM会为其分配虚拟机栈，并生成对应的栈帧，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201125211239875-853033076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过反汇编命令查看work方法的字节码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201125212302208-830978710.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到work方法一共由10条字节码组成，我们来逐步分析。&lt;/p&gt;
&lt;p&gt;打开 https://cloud.tencent.com/developer/article/1333540查看字节码指令&lt;/p&gt;
&lt;p&gt;现来看iconst_2对应的含义，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201125214309984-956925463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以第1个字节码是将一个值为2的数字加载到操作数栈。再来看 istore_0的含义，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201125214608847-1592032698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以第2个字节码的含义就是将第一步中放入到操作数栈的数字放到局部变量表中，位置为0。所以前面两个字节码对应的java代码就是int a = 2;那么显而易见3和4两个字节码对应的&lt;/p&gt;
&lt;p&gt;就是int b = 3;到这里，大家心里肯定会有疑问，为什么不直接将值放到局部变量表呢？我们接着分析，你就明白了。&lt;/p&gt;
&lt;p&gt;　　继续来看第5和第6两个字节码：iload_0和iload_1，它们的含义是将局部变量表中位置0和1的两个数加载到操作数栈中，接着我们来看关键的第7个字节码：imul，它代表的意思&lt;/p&gt;
&lt;p&gt;是相乘，就是将操作数栈中的数字进行乘法运算，我们知道相乘是需要运算的，所以此时要交给执行引擎运算，运算完成之后再将运算的结果返回到操作数栈。所以操作数栈的作用&lt;/p&gt;
&lt;p&gt;就是为jvm高速的计算提供缓冲区。&lt;/p&gt;
&lt;p&gt;　　接着来看第8个字节码：istore_2，它的含义就是将计算的结果放入局部变量表，到这里int c = a*b;就执行完了。然后再来看第9和第10个字节码，它们的含义是将局部变量表的值再&lt;/p&gt;
&lt;p&gt;压入操作数栈，最后返回。至此，整个方法执行结束，以上就是栈帧中各个区域在方法执行中的运作流程。&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt; 虚拟机栈大小的设置：&lt;/h4&gt;
&lt;p&gt; 　　虚拟机栈的大小缺省为 1M，可用参数 –Xss 调整大小，例如-Xss256k。&lt;/p&gt;
&lt;p&gt;参数官方文档（JDK1.8）：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html。&lt;/p&gt;
&lt;div readability=&quot;53&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201124204759438-262512679.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;p&gt; 我们可以看到linux的建议配置为1M，至于windows为啥没有，博主大胆猜想可能跟微软和Oracel两家公司竞争有关吧，毕竟微软开发.net就是和java竞争的。&lt;/p&gt;
&lt;h4&gt;虚拟机栈相关的程序异常：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201124210014900-1042402108.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; OutOfMemoryError：如果java虚拟机的容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。这种情况基本很少出现，也很难模拟，这里就不演示了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;程序计数器：&lt;/h3&gt;
&lt;p&gt;　　与虚拟机栈一样，程序计数器也是线程私有的。程序计数器是一块很小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，就如上面反汇编User.class看到的一样。每一个字节码都有自己的序号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1779514/202011/1779514-20201125221915625-35383355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 如上图所示，虽然这些序号是由顺序的，但是并不一定是依次递增，如果某给字节码占用的空间很大，那么它的序号相较于前一个序号就差距更大。&lt;/p&gt;
&lt;p&gt;在java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的执行器，分支、&lt;/p&gt;
&lt;p&gt;循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。&lt;/p&gt;
&lt;p&gt;　　它还有另外一个作用，我们知道在java中可以开启成百上千个线程，但是我们一般的电脑CPU也就8个左右。java虚拟机的多线程是通过线程轮流切换、&lt;/p&gt;
&lt;p&gt;分配处理器执行时间方式来实现的，那么切换后虚拟机是怎么知道以前运行的位置，继续运行的呢？这个时候，程序计数器就起到了决定性的作用，因为&lt;/p&gt;
&lt;p&gt;程序计数器是线程独有的，所以不会相互影响，当切回到当前线程，根据程序计数器记录的序号，继续执行对应的字节码即可。&lt;/p&gt;
&lt;p&gt;　　在JVM中，只有执行java方法的时候，程序计数器才会记录正在执行的虚拟机字节码指令的地址，如果正在执行的是本地（Native）方法，这个计数器&lt;/p&gt;
&lt;p&gt;则应为空（Undefined）。但是这里会产生一个疑问，如果刚好在执行Native方法的时候线程切换了，那切回来之后该怎么找到对应的位置呢？这里，我猜测&lt;/p&gt;
&lt;p&gt;JVM可能规定了 在执行Native本地方法的时候，禁止切换当前线程（如不正确，请指正）。xianc&lt;/p&gt;
&lt;h3&gt;本地方法栈：&lt;/h3&gt;
&lt;p&gt;　　本地方法栈与虚拟机栈的作用非常相似，其区别只是虚拟机栈为java方法服务，而本地方法栈专门为Native本地方法服务。需要注意的是，HotSpot直接把&lt;/p&gt;
&lt;p&gt;本地方法栈和虚拟机栈合并了。&lt;/p&gt;
&lt;h3&gt;总结：&lt;/h3&gt;
&lt;p&gt;　　本篇文章介绍了JVM的内存区域之线程私有区域，主要介绍了虚拟机栈的各个组成部分以及java方法是怎么通过虚拟机栈来实现执行的，接着介绍了程序计数器的作用&lt;/p&gt;
&lt;p&gt;最后简述了本地方法栈。下一章，我们将要分析JVM内存区域的线程共享数据区，主要包括堆、方法区、运行时常量池以及直接内存等内容。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 25 Nov 2020 14:51:00 +0000</pubDate>
<dc:creator>负重前行的小牛</dc:creator>
<og:description>概述： 对于从事C、C++开发的程序员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”，又是从事最基础工作的劳动人民——既拥有每个对象的“所有权”， 又担负着每一个对象从开始到终结的维护职责。 对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liu-yi/p/14022160.html</dc:identifier>
</item>
</channel>
</rss>