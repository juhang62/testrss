<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WCF 服务的集合管理器的设计 - 可均可可</title>
<link>http://www.cnblogs.com/PatrickLiu/p/10346046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/10346046.html</guid>
<description>&lt;p&gt;　　　　今天是2019年2月1日，时间过得针对，马上就年底了，当前新年也离我们越来越近了。在此，我也祝福经常浏览我博客的朋友们“新年快乐、阖家欢乐”，来年有一个好彩头。在即将结束这一年之计，写今年的最后一片文章。WCF 我相信大家都使用过，每次宿主该服务的时候都要使用 ServiceHost，如果要加载多个 WCF 服务，那就需要多次 ServiceHost 实例化，而且这个过程大致都是一样的，这就有点太麻烦了。正好现在有时间，也有项目的需要，我就写了一份 WCF 服务的集合管理器，可以加载多个 WCF 服务，也可以对 WCF 的服务进行开启或者关闭的操作，使用起来还是比较方便的。这个设计已经改过多次，现在这个版本是目前最合适、最稳定的版本。&lt;/p&gt;
&lt;p&gt;　　　　说写就写，OO的三大基本原则，&lt;span&gt;&lt;strong&gt;1、面向抽象编程，不要面向实现编程；2、多组合少继承；3、哪里有变化点就封装哪里。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　这三大原则我们要死死的记在心里，融化进血液里，由此，我的做法是做接口的抽象设计，代码如下：&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;1、接口 &lt;span&gt;IWcfServiceManager&lt;/span&gt; 的设计如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; WCF 服务的实例管理器，该类型可以实现对容器内部的 WCF 服务对象进行增加、删除、查询、开启和关闭的操作。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWcfServiceManager:IDisposable
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 以指定的名称增加 WCF 服务实例，但是该服务并没有启动。
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示增加 WCF 服务成功，false 表示增加 WCF 失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; AddService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从容器对象中删除指定名称的 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示删除 WCF 服务成功，false 表示删除 WCF 服务失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; RemoveService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有的 WCF 服务实例的集合。
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回所有的 WCF 服务实例集合。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         IEnumerable&amp;lt;WcfService&amp;gt;&lt;span&gt; GetServices();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据指定的名称获取 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回和指定名称相匹配的 WCF 服务实例，如果不存在则会返回 Null 值。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         WcfService GetService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启指定名称 WCF 服务实例，此时该服务可以为客户端提供服务了。
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示成功开启 WCF 服务，false 表示开启式 WCF 服务失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; Start(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启所有的 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartAll();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 关闭指定名称的 WCF 服务实例，此时该服务就不能为客户端提供任何服务了。
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示成功关闭 WCF 服务实例，false 表示关闭 WCF 服务实例失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; Close(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 关闭所有的 WCF 服务实例，停止所有的服务。
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CloseAll();        
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据指定的名称来判断该 WCF 服务实例是否已经开启。
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示该名称的 WCF 服务实例是已经开启的，false 表示该名称的 WCF 服务实例是未开启的。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; IsStartup(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取 WCF 服务实例的个数
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　这个接口的设计就不多说了，很简单，继续我们下一步。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2、实现接口类的设计，类名是：WcfServiceManager.cs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;/strong&gt;该类型都有详细的备注信息，不用我多说了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; WCF 服务的实例管理器，该类型可以实现对容器内部的 WCF 服务对象进行增加、删除、查询、开启和关闭的操作。
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WcfServiceManager : IWcfServiceManager, IDisposable
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 私有字段
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ServiceHost&amp;gt;&lt;span&gt; _serviceHostGroup;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ServiceHost&amp;gt;&lt;span&gt; _serviceHostTemp;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] _assemblyNames;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; _disposed;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否回收完毕&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; IList&amp;lt;Assembly&amp;gt;&lt;span&gt; _assemblies;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 构造函数
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化 WcfServiceManager 类的实例
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;        
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WcfServiceManager()
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        {            
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             _serviceHostGroup = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ServiceHost&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             _serviceHostTemp = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, ServiceHost&amp;gt;&lt;span&gt;();            
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             _assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 接口方法的实现
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 以指定的名称增加 WCF 服务实例，但是该服务并没有启动。
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示增加 WCF 服务成功，false 表示增加 WCF 失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_serviceHostGroup.ContainsKey(serviceName))
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 Type serviceType =&lt;span&gt; GetServiceTypeFromAssemblies(serviceName,_assemblies);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (serviceType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     ServiceHost host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHost(serviceType);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                    _serviceHostGroup.TryAdd(serviceName, host);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从容器对象中删除指定名称的 WCF 服务实例。
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示删除 WCF 服务成功，false 表示删除 WCF 服务失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; RemoveService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_serviceHostGroup.ContainsKey(serviceName))
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 ServiceHost hostInstance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 _serviceHostGroup.TryRemove(serviceName, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; hostInstance);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (hostInstance != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; hostInstance.State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                    hostInstance.Close();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     hostInstance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有的 WCF 服务实例的集合。
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回所有的 WCF 服务实例集合。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;WcfService&amp;gt;&lt;span&gt; GetServices()
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             IList&amp;lt;WcfService&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;WcfService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_serviceHostGroup != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _serviceHostGroup.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _serviceHostGroup.Keys)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; service = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WcfService();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                     service.ServiceName =&lt;span&gt; _serviceHostGroup[key].Description.Name;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     service.State =&lt;span&gt; _serviceHostGroup[key].State;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     service.Description =&lt;span&gt; _serviceHostGroup[key].Description;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    list.Add(service);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据指定的名称获取 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回和指定名称相匹配的 WCF 服务实例，如果不存在则会返回 Null 值。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; WcfService GetService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;要查找的 WCF 服务的名称不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             WcfService service = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_serviceHostGroup.ContainsKey(serviceName))
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 service = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WcfService();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 service.ServiceName =&lt;span&gt; _serviceHostGroup[serviceName].Description.Name;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 service.State =&lt;span&gt; _serviceHostGroup[serviceName].State;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 service.Description =&lt;span&gt; _serviceHostGroup[serviceName].Description;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清空容器中所有 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearAll()
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_serviceHostGroup != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _serviceHostGroup.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CloseAll();
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                _serviceHostGroup.Clear();
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启指定名称 WCF 服务实例，此时该服务可以为客户端提供服务了。
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示成功开启 WCF 服务，false 表示开启式 WCF 服务失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Start(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; serviceHost =&lt;span&gt; _serviceHostGroup[serviceName];
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (serviceHost != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (serviceHost.State == CommunicationState.Created &amp;amp;&amp;amp; serviceHost.State !=&lt;span&gt; CommunicationState.Faulted)
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;                    serviceHost.Open();
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (serviceHost.State == CommunicationState.Closed || serviceHost.State !=&lt;span&gt; CommunicationState.Faulted)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                    ServiceHost tempHost;                    
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                     _serviceHostGroup.TryRemove(serviceName,&lt;span&gt;out&lt;/span&gt;&lt;span&gt; tempHost);
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (tempHost != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (tempHost.State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;                            tempHost.Close();
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;                         tempHost = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                     ServiceHost newhost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHost(serviceHost.Description.ServiceType);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;                    newhost.Open();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                    _serviceHostGroup.TryAdd(serviceName, newhost);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启所有的 WCF 服务实例。
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartAll()
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_serviceHostGroup != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _serviceHostGroup.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (ServiceHost host &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _serviceHostGroup.Values)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (host.State !=&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Closed)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                             ServiceHost newhost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHost(host.Description.ServiceType);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;                            newhost.Open();
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                            _serviceHostTemp.TryAdd(host.Description.ConfigurationName, newhost);
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Faulted)
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                             ServiceHost newhost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHost(host.Description.ServiceType);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;                            newhost.Open();
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;                            _serviceHostTemp.TryAdd(host.Description.ConfigurationName, newhost);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Created)
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;                            host.Open();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_serviceHostTemp != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _serviceHostTemp.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, ServiceHost&amp;gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _serviceHostTemp)
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_serviceHostGroup.ContainsKey(item.Key))
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (_serviceHostGroup[item.Key].State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;                            _serviceHostGroup[item.Key].Close();
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;                        ServiceHost tempHost;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;                         _serviceHostGroup.TryRemove(item.Key,&lt;span&gt;out&lt;/span&gt;&lt;span&gt; tempHost);
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (tempHost.State !=&lt;span&gt; CommunicationState.Closed)
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;                            tempHost.Close();
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;                             tempHost = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (item.Value.State ==&lt;span&gt; CommunicationState.Closed)
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;                            item.Value.Open();
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;                        _serviceHostGroup.TryAdd(item.Key, item.Value);
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;                _serviceHostTemp.Clear();
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; 
&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;240&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 关闭指定名称的 WCF 服务实例，此时该服务就不能为客户端提供任何服务了。
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;243&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示成功关闭 WCF 服务实例，false 表示关闭 WCF 服务实例失败。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Close(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; _serviceHostGroup[serviceName];
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (host != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; &lt;span&gt;                    host.Close();                    
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; 
&lt;span&gt;262&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 关闭所有的 WCF 服务实例，停止所有的服务。
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;265&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CloseAll()
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_serviceHostGroup != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _serviceHostGroup.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (ServiceHost host &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _serviceHostGroup.Values)
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt; &lt;span&gt;                        host.Close();
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt; &lt;span&gt;        }        
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; 
&lt;span&gt;279&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;280&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据指定的名称来判断该 WCF 服务实例是否已经开启。
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;282&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表示 WCF 服务的名称。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;283&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回布尔值，true 表示该名称的 WCF 服务实例是已经开启的，false 表示该名称的 WCF 服务实例是未开启的。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;284&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsStartup(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; _serviceHostGroup[serviceName];
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (host != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (host.State ==&lt;span&gt; CommunicationState.Opened)
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; 
&lt;span&gt;301&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;302&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重新加载所有的 WCF 服务实例，并将所有的 WCF 服务对象开启
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;304&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reload()
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CloseAll();
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ClearAll();
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Initialize();
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.StartAll();
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; 
&lt;span&gt;312&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;313&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取 WCF 服务实例的个数
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;315&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Count
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;
&lt;span&gt;318&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _serviceHostGroup.Count;
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; 
&lt;span&gt;323&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;324&lt;/span&gt; 
&lt;span&gt;325&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 定义的抽象方法
&lt;span&gt;326&lt;/span&gt; 
&lt;span&gt;327&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;328&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加载所有的 WCF 服务实例对象
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;330&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;assemblyFullNames&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;承载 WCF 服务的应用程序集的完全限定名数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;331&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Initialize(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] assemblyFullNames)
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;             _assemblyNames =&lt;span&gt; assemblyFullNames;
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;            CloseAll();
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;            ClearAll();
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; 
&lt;span&gt;337&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; currentDomainDlls =&lt;span&gt; GetAssembliesFromCurrentDomain();
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; specifiedDlls =&lt;span&gt; GetAssembliesFromSpecifiedCondition(_assemblyNames);
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; currentDomainDlls)
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;                _assemblies.Add(item);
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; specifiedDlls)
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;                _assemblies.Add(item);
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; 
&lt;span&gt;348&lt;/span&gt;             Configuration config =&lt;span&gt; ConfigurationManager.OpenExeConfiguration(Assembly.GetEntryAssembly().Location);
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt;             ServiceModelSectionGroup serviceModelGroup = config.GetSectionGroup(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system.serviceModel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ServiceModelSectionGroup;
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (serviceModelGroup != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (ServiceElement service &lt;span&gt;in&lt;/span&gt;&lt;span&gt; serviceModelGroup.Services.Services)
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.AddService(service.Name);
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;358&lt;/span&gt; 
&lt;span&gt;359&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;360&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据指定的字符串类型的程序集名称列表获取强类型的程序集列表
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;362&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回获取到的强类型的程序集列表&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;363&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IList&amp;lt;Assembly&amp;gt; GetAssembliesFromSpecifiedCondition(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] assemblyNames)
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt;             IList&amp;lt;Assembly&amp;gt; assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (assemblyNames != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; assemblyNames.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; assemblyNames)
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; assembly =&lt;span&gt; Assembly.Load(item);
&lt;/span&gt;&lt;span&gt;371&lt;/span&gt; &lt;span&gt;                    assemblies.Add(assembly);
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; assemblies;
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt; 
&lt;span&gt;377&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;378&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据当前的应用程序域获取所有必需的程序集
&lt;/span&gt;&lt;span&gt;379&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;380&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回获取到当前应用程序域内的程序集列表&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;381&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IList&amp;lt;Assembly&amp;gt;&lt;span&gt; GetAssembliesFromCurrentDomain()
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt;             IList&amp;lt;Assembly&amp;gt; assemblies = AppDomain.CurrentDomain.GetAssemblies().Where(a =&amp;gt; (!a.FullName.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase) &amp;amp;&amp;amp; (!a.FullName.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase)) &amp;amp;&amp;amp; (!a.FullName.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mscorlib&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase)) &amp;amp;&amp;amp; (!a.FullName.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vshost32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, StringComparison.OrdinalIgnoreCase)) &amp;amp;&amp;amp; (!a.FullName.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SMDiagnostics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.OrdinalIgnoreCase)))).ToList();
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; assemblies;
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;386&lt;/span&gt; 
&lt;span&gt;387&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;388&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据 WCF 服务的名称在当前程序域中或者传入的程序集中查找该服务的 Type 类型的对象
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;390&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要查找的 WCF 服务的名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;391&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;assemblies&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;承载 WCF 服务的程序集列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;392&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回WCF服务的Type类型的对象，如果没有找到相应的类型就会返回 Null 值。&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;393&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Type GetServiceTypeFromAssemblies(&lt;span&gt;string&lt;/span&gt; serviceName, IList&amp;lt;Assembly&amp;gt;&lt;span&gt; assemblies)
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(serviceName) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(serviceName))
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;397&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;要查找的 WCF 服务的名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt; 
&lt;span&gt;400&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (assemblies == &lt;span&gt;null&lt;/span&gt; || assemblies.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;待查找的程序集列表不能为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;403&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;404&lt;/span&gt; 
&lt;span&gt;405&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;406&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (assemblies != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; assemblies.Count() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; currentAssembly = assemblies.FirstOrDefault(a =&amp;gt; a.GetType(serviceName) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;410&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (currentAssembly != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentAssembly.GetType(serviceName);
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;421&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt; 
&lt;span&gt;423&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;424&lt;/span&gt; 
&lt;span&gt;425&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; IDispoable模式
&lt;span&gt;426&lt;/span&gt; 
&lt;span&gt;427&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;428&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 释放托管资源
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;430&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
&lt;/span&gt;&lt;span&gt;431&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;432&lt;/span&gt;             Dispose(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt;             GC.SuppressFinalize(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;434&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; 
&lt;span&gt;436&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;437&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 析构函数释放资源
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;439&lt;/span&gt;         ~&lt;span&gt;WcfServiceManager()
&lt;/span&gt;&lt;span&gt;440&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;441&lt;/span&gt;             Dispose(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt; 
&lt;span&gt;444&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;445&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 释放所有的托管资源和非托管资源核心方法实现
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;447&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;disposing&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否需要释放那些实现IDisposable接口的托管对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;448&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_disposed)
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;452&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经被回收，就中断执行&lt;/span&gt;
&lt;span&gt;453&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;454&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing)
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:回收托管资源，调用IDisposable的Dispose()方法就可以&lt;/span&gt;
&lt;span&gt;457&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CloseAll();
&lt;/span&gt;&lt;span&gt;458&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ClearAll();
&lt;/span&gt;&lt;span&gt;459&lt;/span&gt;                 _serviceHostGroup = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:释放非托管资源，设置对象为null&lt;/span&gt;
&lt;span&gt;462&lt;/span&gt;             _disposed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;464&lt;/span&gt; 
&lt;span&gt;465&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;466&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;strong&gt;3、真正实现的叶子结点类型设计，类型是：DefaultWcfServiceManager.cs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　该类型就是用户将要使用的类型。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; WCF 服务的实例管理器，该类型可以实现对容器内部的 WCF 服务对象进行增加、删除、查询、开启和关闭的操作。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultWcfServiceManager:WcfServiceManager, IDisposable
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 构造函数
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化 DefaultWcfServiceManager 类型的实例
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultWcfServiceManager(){ }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　主要的类型就差不多了。在这个设计过程中，还会涉及到一个辅助类型 WcfService&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;4、辅助类型 WcfService 的设计编码。很简单，直接上代码。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; WCF 服务实例的类型的定义
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WcfService
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 私有字段
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _serviceName;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CommunicationState _communicationState;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServiceDescription _serviceDescription;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 构造函数
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化 WcfService 类型的实例
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; WcfService()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        { }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 实例属性
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或者设置 WCF 服务实例的名称
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ServiceName
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _serviceName; }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value)) &amp;amp;&amp;amp; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(value)))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     _serviceName =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或者设置 WCF 的服务实例的运行状态
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CommunicationState State
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _communicationState; }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; { _communicationState =&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或者设置 WCF 服务的描述信息
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceDescription Description
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _serviceDescription; }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     _serviceDescription =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;strong&gt;5、单元测试项目代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　这是最后的代码了，有源码没有测试代码，似乎还少一点。测试代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DefaultWcfServiceManager hosts = new DefaultWcfServiceManager(&quot;ServiceInstance, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;);&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             DefaultWcfServiceManager hosts = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultWcfServiceManager();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             hosts.Initialize(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceInstance, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hosts.Initialize(&quot;ServiceInstance&quot;);&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; operation = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 operation =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StartAll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    hosts.StartAll();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经全部打开&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     hosts.Close(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceInstance.ConsoleService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleService 已经关闭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleServiceOpen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     hosts.Start(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceInstance.ConsoleService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConsoleService 已经打开&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MathServiceOpen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     hosts.Start(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceInstance.MathService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MathService 已经打开&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MathService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     hosts.Close(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceInstance.MathService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MathService 已经关闭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CloseAll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                    hosts.CloseAll();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经全部关闭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    hosts.Reload();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经全部重新打开&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; hosts.GetServices())
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + item.Description.Endpoints[&lt;span&gt;0&lt;/span&gt;].Address.Uri.ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;；状态：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; item.State.ToString());
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.Compare(operation, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　好了，就写到这里吧。要想使用 WCF ，必须的命名空间是必须要引入的 System.ServiceModel，当然这里省略了必要的配置数据了，我相信，这个不是很难。也要说明一点，我这个项目是放在类库里面的，WCF 是分为 Client 端和 Server 端的，今天只是贴出了服务器端的代码，如果有需要，在把客户端生成代理类的代码贴出来。年尾了，让不好的东西过去，让自己迎接新的明天，不忘初心，继续努力。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 07:37:00 +0000</pubDate>
<dc:creator>可均可可</dc:creator>
<og:description>今天是2019年2月1日，时间过得针对，马上就年底了，当前新年也离我们越来越近了。在此，我也祝福经常浏览我博客的朋友们“新年快乐、阖家欢乐”，来年有一个好彩头。在即将结束这一年之计，写今年的最后一片文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/10346046.html</dc:identifier>
</item>
<item>
<title>浙江信访，从统一到智能的互联网转型之路 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10346035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10346035.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont688270.i0.3fcc2c42wjAZ7C&quot;&gt;信访工作是各级党委、政府和领导干部了解民情、集中民智、维护民利、凝聚民心的一项重要工作。随着网络社会的到来，中央提出要改革信访工作制度，实行网上受理信访制度，健全及时就地解决群众合理诉求机制。截止2017年浙江省网民数量超过3600万，排列全国第5，网民渗透率高达64%。在网络深度渗透到老百姓生活模式的背景下，浙江省信访局近年来着力拓宽信访服务渠道，加快信访信息化服务的社会普及，让广大人民在公共服务方面有更多的获得感。&lt;/p&gt;
&lt;p&gt;一、转型挑战：在信访工作群体化、多样化、择机化和复杂化的背景下，如何快速响应群众服务，为群众排忧解难&lt;/p&gt;
&lt;p&gt;浙江省在信访形势总体平稳的情况下，也出现了一些矛盾上行趋势明显、群体性利益诉求增多等需要引起重视的情况，而且形式多样化、复杂化、群体化和择机化。在这样的背景下，浙江省信访局高度重视，抓住了互联网机遇，依托浙江政务服务网的总体框架，紧紧围绕“四单一网”、“最多跑一次”改革和政府数字化转型的决策部署，进行了信访工作信息化的一系列布局，重点投入资源进行网络平台的整合改造提升，建成了横向联通党政、人大、政协、司法机关，纵向贯通省、市、县、乡四级，集信、访、网、电“四位一体”的统一政务咨询投诉举报平台（以下简称“统一平台”），实现了全省统一的数据集中和资源调度，提高了整体服务效率。&lt;/p&gt;
&lt;p&gt;但在社会快速变化和改革不断深化的今天，统一平台面临着极大的挑战，需要结合技术再上一个台阶：&lt;/p&gt;
&lt;p&gt;（1）统一平台接收事项多：2018年以来，统一平台接收信、访、网、电事项总量已超过1100万，在如此巨量的压力下，能否进一步提高工作效率，缩短群众的反馈时间是一大难点；&lt;/p&gt;
&lt;p&gt;（2）人工话务座席压力大：浙江省信访局经过近几年努力，实现了12345政务服务热线整合，用一个号码响应群众诉求，但随着来电量不断增加，座席数量需要按峰值进行配置，目前全省各地已有超过1400个人工座席，这些人工话务普遍工作强度大、工作内容枯燥、重复性强（回答大量重复性标准问题，耗费大部分时间和精力）、负面情绪多（处理客户投诉，部分客户刁难，心理压力大），这些因素直接导致座席的服务质量不高；&lt;/p&gt;
&lt;p&gt;（3）APP流程复杂不便利：浙江省信访局在移动互联网广泛普及的背景下，为方便群众开通了手机APP受理群众咨询投诉举报，但群众受益的同时仍然反映手机APP中的一些咨询、投诉和举报流程过于复杂，比如咨询部门的填写让很多群众难以选择，因为大多数群众并不了解政府的组织架构和各部门服务范围，尤其在一些部门职能交叉领域，因此如何进一步简化流程，便利群众也需要通过持续优化和迭代来实现；&lt;/p&gt;
&lt;p&gt;（4）事项人工分派效率低：群众通过统一平台投诉举报的一些事项，需要根据管辖归属关系进行分派，之前主要通过人工进行分派，效率较低，再加上统一平台整合后全省信访咨询量变大，因此人工分派的低效率影响了响应和处理时间，需要想办法进行提速。&lt;/p&gt;
&lt;p&gt;（5）数据价值挖掘不深入：统一平台是以面向群众服务和接受问题为核心，是浙江政务服务的总客服，每天与群众直接接触，广泛收集、接受群众的反映信息。这些沉淀积累的数据和信息，可以直接挖掘出更高的价值，例如通过数据分析可以分类统计不同的诉求、以及社会舆情热点的变化等等，可以提供给相关领导和部门做决策分析参考。目前浙江省信访局已经建设了大数据应用系统，但智能化的分析和应用还需要继续深入，尤其是通过数据对一些事项的智能化预警和预测功能需要加强。&lt;/p&gt;
&lt;p&gt;二、创新转型：浙江省信访局互联网转型的超前发展，本质是思维模式的突破，用技术穿透传统与边界&lt;/p&gt;
&lt;p&gt;浙江省信访工作在利用互联网技术转型方面，之前早已有过探索和尝试，也经历过多头建设、统一整合、资源集中的过程，其利用互联网新技术手段进行转型创新，总体而言可以分为三个阶段：&lt;/p&gt;
&lt;p&gt;（1）2014~2015年，新技术尝试应用、全省百花齐放阶段&lt;/p&gt;
&lt;p&gt;从2014年开始，响应十八届三中全会提出的“改革信访工作制度，实现网上受理信访制度”号召，国家信访局推出国家信访信息系统（外网），浙江省信访局也于2015年初正式开通网上信访。&lt;/p&gt;
&lt;p&gt;但这个阶段是互联网尝试阶段，平台较分散，各地各部门在网上信访平台建设上投入大、入口多，除了浙江省信访局主导建设的全省网上信访平台以外，各级各部门还有许多领导信箱、门户网站、视频、QQ、短信、微信、微博等网上信访小平台，导致重复建设。特别是热线电话普遍存在难打通、难沟通、难办事等问题，光是以1和9开头的热线电话就有21条之多，加上各系统、各部门设立的投诉举报电话，总数不下上百条，数量众多老百姓根本无法记住。这个阶段总体上呈现出信访载体过多投诉乱、分头治理监督难和重复建设效率低等问题。&lt;/p&gt;
&lt;p&gt;（2）2016~2017年，统一平台数据打通、渠道整合、协同对接阶段&lt;/p&gt;
&lt;p&gt;这个阶段是浙江省信访工作互联网转型的关键阶段，浙江省信访局意识到资源的分散不利于群众服务。在省委省政府的重视下，2016年打造了全省统一平台，汇聚全省资源，全面整合信、访、网、电“四位一体”建设。将以1和9开头的各种热线电话以及各部门、各系统设立的投诉举报电话全部整合到12345热线中，实现一号受理，方便群众。&lt;/p&gt;
&lt;p&gt;同时用统一平台整合网络在线渠道，实行统一用户、统一接收、统一判重、统一流转、统一标准、统一共享。到2017年，统一平台进入协同对接、数据融合阶段，向事业单位、国有企业拓展，与省协同平台、基层治理四个平台、平安建设系统、110报警服务台等系统打通，实现协同互动。此外还为增强群众服务受理的便利性，增设了统一APP、微信、支付宝以及视频接访等新的媒介手段。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://yqfile.alicdn.com/1d7b0251de313f0d2a83e5264cbdf56398de26de.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去年国务院某专项督导组来浙江，现场提出需要了解浙江省群众反映这个方面事项总量有多少？反映最多的问题是什么？群众通过什么手段来反映？解决的怎么样？浙江省信访局通过统一平台调用数据，十分钟以后呈现出所有的需求数据，让督导组十分满意，说道：“这些数字非常有用，也让我感受到了浙江在信访信息化建设上带来的效率。”&lt;/p&gt;
&lt;p&gt;通过这个阶段的建设，统一平台已经走在了全国前列，成为全国信访工作互联网转型的标杆。表面上是技术层面的打通，深层次其实是数据治理的超前思维在引导。&lt;/p&gt;
&lt;p&gt;（3）2018年及以后，流程再造、智能应用整体规划实施阶段&lt;/p&gt;
&lt;p&gt;2018年，浙江省信访局互联网转型进入到平台智能化迭代过程中，包括打造统一标准的政务知识库、群众咨询投诉举报流程的再造和简化、智能客服系统、智能分派系统以及智能数据助手等。通过数据化和智能化，全面提升统一平台的服务和创新能力，提高群众诉求响应速度，对内对外提升辅助决策和服务的精细化颗粒度。&lt;/p&gt;
&lt;p&gt;统一平台也在不断的迭代演进升级，顺应数据和智能技术的发展趋势，完善平台框架、增强平台性能，让服务流程更加优化、服务形式更加多元、用户体验不断提升。&lt;/p&gt;
&lt;p&gt;三、合作创新：携手阿里，用智能应用解放生产力、增加用户体验、全面提升社会舆情感知和疏导能力&lt;/p&gt;
&lt;p&gt;2018年浙江省信访局携手阿里全面合作，其看中的是阿里智能技术在淘宝/天猫巨型电商平台的发展、演进过程中积累的能力以及对于电话呼叫流程智能化改造端到端的系统性思维。双方合作利用人工智能技术对统一平台进行全面优化、重构，提升服务效能和品质，实现服务的升级。&lt;/p&gt;
&lt;p&gt;（1）实现了1+N政务知识库的建设，之前统一平台实现了“六统一”（统一用户、统一标准、统一接收、统一判重、统一流转和统一共享），但政务知识库一直没有统一。而智能化的前提是统一化和标准化，因此阿里首先帮助浙江省信访局实现了政务知识库的统一和通用（全省政策法规、办事指南等）。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;2&quot; src=&quot;https://yqfile.alicdn.com/4421f3af9f18b325ddced689a6033ef09653258d.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样在全省通用政务知识库的前提下，各地市仍然保留自己的个性化政务知识库，形成1+N的框架格局，政务知识库的统一和构建可以快速提高线上业务的效率，实现真正的智能化提效。&lt;/p&gt;
&lt;p&gt;（2）简化了网上咨询投诉举报流程。之前虽然群众咨询投诉举报渠道进行了整合和统一，但在一些流程细节上群众反映有难点，针对群众咨询投诉操作的便利性方面，双方进行细致分析，最终用智能机器人直接取代群众在咨询问题时候需要填写的一系列部门、归属关系等较难的选项；同时简化投诉举报流程，群众直接写清投诉内容即可，后台机器人将对问题进行智能的识别和标记分派。通过流程的简化，群众对手机和网络使用的界面友好性明显得到了改善，便利性获得了极大的提高。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;3&quot; src=&quot;https://yqfile.alicdn.com/b167c0e90aefe5bef9064c4546eef7815bc82835.png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）打造智能客服系统，包括网上智能客服、热线智能客服、回访智能客服系统，其中电话热线智能客服又包括内呼和回访外呼。&lt;/p&gt;
&lt;p&gt;网上智能客服目前已经上线，通过智能客服机器人和统一的政务知识库，群众在使用手机或网络咨询相关问题的时候，只需要直接语音说话即可，也可录入文字，机器人自动识别语义并自动回复，不但针对性更强，而且节约了群众的时间，提高了效率。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;4&quot; src=&quot;https://yqfile.alicdn.com/b5a9c1e92f2d231a23c7063fdc63dc849fa45f12.png&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;电话热线机器人目前正在上线，将通过统一的1+N政务知识库和多轮问答，政务知识库实现热线电话的智能导航和自动回复，这在电话占全省信访总量90%的场景下更加适用，同时也将减轻全省每天几万通电话呼入量的座席话务压力。&lt;/p&gt;
&lt;p&gt;除了热线智能客服以外，回访智能客服也正在布局上线，2018年1月至8月，浙江省回访事项总量超过66万件，而目前全省主要采用人工回访的方式，投入成本大且无法满足增长需求。因此利用机器人进行电话智能回访，建设语音自动外呼智能回访系统，运用人工智能语音转文字、语义理解和语音合成等多项技术，实现自动回访，可以有效提升群众体验，降低运营成本。&lt;/p&gt;
&lt;p&gt;统一平台网上智能、热线智能智能客服机器人的上线，将真正促使平台成为群众永不打烊的咨询场所、永不下班的政府机关。&lt;/p&gt;
&lt;p&gt;（4）建设智能分派系统。统一平台整合后，针对信、访、网、电事项，之前靠人工分派给各个相对应的部门效率较低，通常要好几天。因此阿里通过智能化手段，梳理出大量高频问题，通过智能算法将公众的咨询投诉举报自动精准分流至各职能部门，缩短群众咨询投诉的处理时间，快速、有效解决公众遇到的问题。通过智能机器人和智能分流引擎，简单的咨询类问题可以实现秒回应，复杂疑难事项也可快速分派到相关部门，适用简易程序7个工作日内办结，适用普通程序在30天内办结，极大的提高了群众的满意度。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;5&quot; src=&quot;https://yqfile.alicdn.com/1ea99daeb2c20eec07d13bb9ecb4bed25024e40e.png&quot; alt=&quot;5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）建设智能数据助手，通过积累的大量数据进行实时精准分析，阿里将基于统一平台原有的数据分析能力进行迭代，提升信访局基于数据的分析和运用能力。充分利用统一平台对全省市县乡四级共1万余个机构的接入和3.2万余名工作人员的覆盖，通过这张深入到乡镇的毛细血管网络，除了日常的数据统计和分析以外，对于群众舆情变化和相对集中爆发的问题未来可以通过智能化做到提前感知、提前预警，及时输出关联数据给相关部门和领导做科学决策参考，真正做到用数据支撑浙江省政务治理。&lt;/p&gt;
&lt;p&gt;**四、组织变革：成立专项工作组和工作专班，依托智能化变革“强身健体”&lt;br/&gt;**&lt;br/&gt;浙江省信访局在智能化转型的过程中，必不可少的也在做组织架构的配套变革，一方面根据省政府数字化转型的顶层设计框架，与省编办、省大数据局等14个单位组建统一平台数字化转型项目工作组。结合与阿里的合作模式，设立工作专班，在信访局内成立由主要领导任组长的领导小组，负责组织协调和任务落实，并抽调相关人员集中办公、集中攻坚。&lt;/p&gt;
&lt;p&gt;在机制上，按照“日盯、周会、月报”要求，建立项目进展报告制度和钉钉工作群，每日梳理当日进展，每周召开例会会商，每月通报工作情况，进行统筹安排，浙江省信访局以数据和智能治理为中心的思维模式，正在依托智能化“强身健体”，全力提升组织效率和战斗力。&lt;/p&gt;
&lt;p&gt;五、治理进化：浙江省信访局的转型确立了信访领域数字化转型的新模式&lt;/p&gt;
&lt;p&gt;统一平台的智能化实际上就是利用技术实现资源匹配的效率最优化，让每一个群众背后隐藏的问题和诉求能够和政府相关部门的资源进行精准匹配，这种匹配是全流程所有环节的联动。未来的智能咨询投诉举报，无论群众是通过12345热线，还是互联网渠道接入，都会有智能路由进行导航的自动判别，根据群众问题的诉求自动判断是由智能语音机器人、在线智能机器人还是人工客服来承接，并根据在线事项的数据标签实现自动分派，做到各部门资源的精准匹配。同时针对数据进行智能分析，提前进行重大事件和问题的预测和感知，为政务治理提供科学决策参考。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont688270.i1.3fcc2c42wjAZ7C&quot;&gt;在今天互联网环境下，信访工作是党群关系的“晴雨表”和焦虑社会的“减压阀”，浙江省信访局的互联网转型，目标是建成覆盖全省的设施统一、资源共享、业务协同、服务高效的统一平台，成为“最多跑一次”改革的重要抓手，并以此作为依托，实现智能化迭代，真正利用技术实现重点在政务、核心在服务，关键在便民，确立了全国信访工作数字化转型的新模式。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont688270.i1.3fcc2c42wjAZ7C&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/688270?utm_content=g_1000040739&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 07:35:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>信访工作是各级党委、政府和领导干部了解民情、集中民智、维护民利、凝聚民心的一项重要工作。随着网络社会的到来，中央提出要改革信访工作制度，实行网上受理信访制度，健全及时就地解决群众合理诉求机制。截止20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10346035.html</dc:identifier>
</item>
<item>
<title>elastic-job-lite源码解析 - 一天不进步，就是退步</title>
<link>http://www.cnblogs.com/davidwang456/p/10346013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davidwang456/p/10346013.html</guid>
<description>&lt;p&gt;前段时间写过一遍文章&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/davidwang456/p/10329616.html&quot; target=&quot;_blank&quot;&gt;一文揭秘定时任务调度框架quartz&lt;/a&gt;&amp;gt;,有读者建议我再讲讲elastic-job这个任务调度框架，年末没有那么忙，就来学习一下elastic-job。&lt;/p&gt;
&lt;p&gt;首先一点，elastic-job基于quartz，理解quartz的运行机制有助于对elastic-job的快速理解。&lt;/p&gt;
&lt;p&gt;首先看一下elastic-job-lite的架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201902/486074-20190201143718032-1868026236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道quartz有三个重要的概念：Job,Trigger,Scheduler。那么elastic-job里面三个概念是什么体现的呢？&lt;/p&gt;
&lt;p&gt;1.Job&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201902/486074-20190201140516689-2113606949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LiteJob继承自quartz的job接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.quartz.Job;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.quartz.JobExecutionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.quartz.JobExecutionException;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Lite调度作业.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhangliang
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LiteJob &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Job {
    
    @Setter
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ElasticJob elasticJob;
    
    @Setter
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JobFacade jobFacade;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute(&lt;span&gt;final&lt;/span&gt; JobExecutionContext context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JobExecutionException {
        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;p&gt;1.1 ElasticJob实现了不同的Job类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201902/486074-20190201140932720-244105708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2.JobFacade是作业内部服务门面服务&lt;/p&gt;
&lt;p&gt;注意：elasticJob的特性在里面可以看到如：&lt;/p&gt;
&lt;p&gt;任务分片：&lt;/p&gt;
&lt;div class=&quot;row&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　　将整体任务拆解为多个子任务&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;　　可通过服务器的增减弹性伸缩任务处理能力&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;　　分布式协调，任务服务器上下线的全自动发现与处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;容错性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;row&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;　　支持定时自我故障检测与自动修复&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;　　分布式任务分片唯一性保证&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;row&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;　　支持失效转移和错过任务重触发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;任务跟踪&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;circle&quot;&gt;任务调度&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; JobFacade {
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读取作业配置.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fromCache 是否从缓存中读取
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 作业配置
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    JobRootConfiguration loadJobRootConfiguration(&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fromCache);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检查作业执行环境.
     * 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; JobExecutionEnvironmentException 作业执行环境异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; checkJobExecutionEnvironment() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JobExecutionEnvironmentException;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 如果需要失效转移, 则执行作业失效转移.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; failoverIfNecessary();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册作业启动信息.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingContexts 分片上下文
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerJobBegin(ShardingContexts shardingContexts);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册作业完成信息.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingContexts 分片上下文
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerJobCompleted(ShardingContexts shardingContexts);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取当前作业服务器的分片上下文.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 分片上下文
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ShardingContexts getShardingContexts();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置任务被错过执行的标记.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingItems 需要设置错过执行的任务分片项
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否满足misfire条件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; misfireIfRunning(Collection&amp;lt;Integer&amp;gt;&lt;span&gt; shardingItems);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清除任务被错过执行的标记.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingItems 需要清除错过执行的任务分片项
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; clearMisfire(Collection&amp;lt;Integer&amp;gt;&lt;span&gt; shardingItems);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断作业是否需要执行错过的任务.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingItems 任务分片项集合
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 作业是否需要执行错过的任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isExecuteMisfired(Collection&amp;lt;Integer&amp;gt;&lt;span&gt; shardingItems);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断作业是否符合继续运行的条件.
     * 
     * &amp;lt;p&amp;gt;如果作业停止或需要重分片或非流式处理则作业将不会继续运行.&amp;lt;/p&amp;gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 作业是否符合继续运行的条件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEligibleForJobRunning();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;判断是否需要重分片.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否需要重分片
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isNeedSharding();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 作业执行前的执行的方法.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingContexts 分片上下文
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeJobExecuted(ShardingContexts shardingContexts);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 作业执行后的执行的方法.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; shardingContexts 分片上下文
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterJobExecuted(ShardingContexts shardingContexts);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 发布执行事件.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jobExecutionEvent 作业执行事件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postJobExecutionEvent(JobExecutionEvent jobExecutionEvent);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 发布作业状态追踪事件.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; taskId 作业Id
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; state 作业执行状态
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; message 作业执行消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postJobStatusTraceEvent(String taskId, State state, String message);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.JobDetail&lt;/p&gt;
&lt;p&gt;通用的Job属性，定义在job.xsd&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:complexType &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;base&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:complexContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:extension &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;=&quot;beans:identifiedType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:all&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;listener&quot;&lt;/span&gt;&lt;span&gt; minOccurs&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; maxOccurs&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;distributed-listener&quot;&lt;/span&gt;&lt;span&gt; minOccurs&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; maxOccurs&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:all&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;class&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;job-ref&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;registry-center-ref&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; use&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;cron&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; use&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-total-count&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; use&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-item-parameters&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;job-parameter&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;monitor-execution&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;monitor-port&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;-1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;max-time-diff-seconds&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;-1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;failover&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;reconcile-interval-minutes&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:int&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;misfire&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;job-sharding-strategy-class&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;disabled&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;overwrite&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;executor-service-handler&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;io.elasticjob.lite.executor.handler.impl.DefaultExecutorServiceHandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;job-exception-handler&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;io.elasticjob.lite.executor.handler.impl.DefaultJobExceptionHandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;event-trace-rdb-data-source&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:extension&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:complexContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:complexType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中Simple类型的任务完全继承通用属性，dataflow类型的任务增加了streaming-process属性，script增加了script-command-line属性&lt;/p&gt;
&lt;p&gt;使用的解析器定义在spring.handlers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
http\://www.dangdang.com/schema/ddframe/reg=io.elasticjob.lite.spring.reg.handler.RegNamespaceHandler
http\://www.dangdang.com/schema/ddframe/job=io.elasticjob.lite.spring.job.handler.&lt;span&gt;JobNamespaceHandler&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JobNamespaceHandler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 分布式作业的命名空间处理器.
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; caohao
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JobNamespaceHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; NamespaceHandlerSupport {
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        registerBeanDefinitionParser(&lt;/span&gt;&quot;simple&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJobBeanDefinitionParser());
        registerBeanDefinitionParser(&lt;/span&gt;&quot;dataflow&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataflowJobBeanDefinitionParser());
        registerBeanDefinitionParser(&lt;/span&gt;&quot;script&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScriptJobBeanDefinitionParser());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在弹性化分布式作业执行器AbstractElasticJobExecutor.java初始化时获取配置属性，并使用对应的Handler进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; AbstractElasticJobExecutor(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; JobFacade jobFacade) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jobFacade =&lt;span&gt; jobFacade;
        jobRootConfig &lt;/span&gt;= jobFacade.loadJobRootConfiguration(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        jobName &lt;/span&gt;=&lt;span&gt; jobRootConfig.getTypeConfig().getCoreConfig().getJobName();
        executorService &lt;/span&gt;=&lt;span&gt; ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));
        jobExceptionHandler &lt;/span&gt;=&lt;span&gt; (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);
        itemErrorMessages &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), 1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3 执行作业&lt;/p&gt;
&lt;p&gt;弹性化分布式作业执行器AbstractElasticJobExecutor.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    /**
     * 执行作业.
     */
    public final void&lt;span&gt; execute() {
        try&lt;span&gt; {
            &lt;span&gt;jobFacade.checkJobExecutionEnvironment();  //1 &lt;/span&gt;
        } catch (final&lt;span&gt; JobExecutionEnvironmentException cause) {
            jobExceptionHandler.handleException(jobName, cause);
        }
        &lt;span&gt;ShardingContexts shardingContexts =&lt;/span&gt;&lt;span&gt;&lt;span&gt; jobFacade.getShardingContexts();  //2&lt;/span&gt;
        if&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
         &lt;span&gt;   jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(&quot;Job '%s' execute begin.&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;, jobName));  //3&lt;/span&gt;
        }
        if&lt;span&gt; (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) {
            if&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
                jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(
                        &quot;Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed.&quot;&lt;span&gt;, jobName, 
                        shardingContexts.getShardingItemParameters().keySet()));
            }
            return&lt;span&gt;;
        }
        try&lt;span&gt; {
            &lt;span&gt;jobFacade.beforeJobExecuted(shardingContexts);       //4&lt;/span&gt;
            //CHECKSTYLE:OFF
        } catch (final&lt;span&gt; Throwable cause) {
            //CHECKSTYLE:ON
&lt;span&gt;            jobExceptionHandler.handleException(jobName, cause);
        }
        &lt;span&gt;execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);  //5&lt;/span&gt;
        while&lt;span&gt; (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) {
            jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());
            execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);
        }
        &lt;span&gt;jobFacade.failoverIfNecessary();                           //6&lt;/span&gt;
        try&lt;span&gt; {
            &lt;span&gt;jobFacade.afterJobExecuted(shardingContexts);          //7&lt;/span&gt;
            //CHECKSTYLE:OFF
        } catch (final&lt;span&gt; Throwable cause) {
            //CHECKSTYLE:ON
&lt;span&gt;            jobExceptionHandler.handleException(jobName, cause);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.1 环境监测&lt;/p&gt;
&lt;p&gt;检查本机与注册中心的时间误差秒数是否在允许范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检查本机与注册中心的时间误差秒数是否在允许范围.
     * 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; JobExecutionEnvironmentException 本机与注册中心的时间误差秒数不在允许范围所抛出的异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkMaxTimeDiffSecondsTolerable() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JobExecutionEnvironmentException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxTimeDiffSeconds =  load(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).getMaxTimeDiffSeconds();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (-1  ==&lt;span&gt; maxTimeDiffSeconds) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeDiff = Math.abs(timeService.getCurrentMillis() -&lt;span&gt; jobNodeStorage.getRegistryCenterTime());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeDiff &amp;gt; maxTimeDiffSeconds * 1000L&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobExecutionEnvironmentException(
                    &lt;/span&gt;&quot;Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds.&quot;, timeDiff / 1000&lt;span&gt;, maxTimeDiffSeconds);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2 根据分片规则进行分片&lt;/p&gt;
&lt;p&gt;如果需要分片且当前节点为主节点, 则作业分片.&lt;/p&gt;
&lt;p&gt; 如果当前无可用节点则不分片.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 如果需要分片且当前节点为主节点, 则作业分片.
     * 
     * &amp;lt;p&amp;gt;
     * 如果当前无可用节点则不分片.
     * &amp;lt;/p&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shardingIfNecessary() {
        List&lt;/span&gt;&amp;lt;JobInstance&amp;gt; availableJobInstances =&lt;span&gt; instanceService.getAvailableJobInstances();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isNeedSharding() ||&lt;span&gt; availableJobInstances.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;leaderService.isLeaderUntilBlock()) {
            blockUntilShardingCompleted();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        waitingOtherShardingItemCompleted();
        LiteJobConfiguration liteJobConfig &lt;/span&gt;= configService.load(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; shardingTotalCount =&lt;span&gt; liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();
        log.debug(&lt;/span&gt;&quot;Job '{}' sharding begin.&quot;&lt;span&gt;, jobName);
        jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, &lt;/span&gt;&quot;&quot;&lt;span&gt;);
        resetShardingInfo(shardingTotalCount);
&lt;span&gt;        JobShardingStrategy jobShardingStrategy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= JobShardingStrategyFactory.getStrategy(liteJobConfig.getJobShardingStrategyClass());
        jobNodeStorage.executeInTransaction(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; PersistShardingInfoTransactionExecutionCallback(jobShardingStrategy.sharding(availableJobInstances, jobName, shardingTotalCount)));&lt;/span&gt;
        log.debug(&lt;/span&gt;&quot;Job '{}' sharding complete.&quot;&lt;span&gt;, jobName);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3 使用EventBus通知&lt;/p&gt;
&lt;p&gt;com.google.common.eventbus.EventBus&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Posts an event to all registered subscribers.  This method will return
   * successfully after the event has been posted to all subscribers, and
   * regardless of any exceptions thrown by subscribers.
   *
   * &amp;lt;p&amp;gt;If no subscribers have been subscribed for {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; event}'s class, and
   * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; event} is not already a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; DeadEvent}, it will be wrapped in a
   * DeadEvent and reposted.
   *
   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; event  event to post.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; post(Object event) {
    Set&lt;/span&gt;&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; dispatchTypes =&lt;span&gt; flattenHierarchy(event.getClass());

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; dispatched = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; eventType : dispatchTypes) {
      subscribersByTypeLock.readLock().lock();
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Set&lt;/span&gt;&amp;lt;EventSubscriber&amp;gt; wrappers =&lt;span&gt; subscribersByType.get(eventType);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;wrappers.isEmpty()) {
          dispatched &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (EventSubscriber wrapper : wrappers) {
            enqueueEvent(event, wrapper);
          }
        }
      } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        subscribersByTypeLock.readLock().unlock();
      }
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!dispatched &amp;amp;&amp;amp; !(event &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; DeadEvent)) {
      post(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DeadEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, event));
    }

    dispatchQueuedEvents();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.4 job预执行，监听ElasticJobListener&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; beforeJobExecuted(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; ShardingContexts shardingContexts) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ElasticJobListener each : elasticJobListeners) {
            each.beforeJobExecuted(shardingContexts);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.5 job执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute(&lt;span&gt;final&lt;/span&gt; ShardingContexts shardingContexts, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; JobExecutionEvent.ExecutionSource executionSource) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shardingContexts.getShardingItemParameters().isEmpty()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
                jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(&lt;/span&gt;&quot;Sharding item for job '%s' is empty.&quot;&lt;span&gt;, jobName));
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;span&gt;jobFacade.registerJobBegin(shardingContexts);//1&lt;/span&gt;
        String taskId &lt;/span&gt;=&lt;span&gt; shardingContexts.getTaskId();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
            jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, &lt;/span&gt;&quot;&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;span&gt;  process(shardingContexts, executionSource);//2&lt;/span&gt;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路&lt;/span&gt;
&lt;span&gt;            jobFacade.registerJobCompleted(shardingContexts);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (itemErrorMessages.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
                    jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, &lt;/span&gt;&quot;&quot;&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shardingContexts.isAllowSendJobEvent()) {
                    jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &amp;gt;&amp;gt;1.将job注册到注册中心&lt;/p&gt;
&lt;p&gt;  &amp;gt;&amp;gt;2.将各个任务分片放到线程池中执行&lt;/p&gt;
&lt;p&gt;3.6 实现转移&lt;/p&gt;
&lt;p&gt;如果需要失效转移, 则执行作业失效转移.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在主节点执行操作.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; latchNode 分布式锁使用的作业节点名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; callback 执行操作的回调
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeInLeader(&lt;span&gt;final&lt;/span&gt; String latchNode, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; LeaderExecutionCallback callback) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (LeaderLatch latch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) {
            latch.start();
            latch.await();
            callback.execute();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CHECKSTYLE:OFF&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Exception ex) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CHECKSTYLE:ON&lt;/span&gt;
&lt;span&gt;            handleException(ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.7 作业执行后处理&lt;/p&gt;
&lt;p&gt;作业执行后的执行的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterJobExecuted(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; ShardingContexts shardingContexts) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ElasticJobListener each : elasticJobListeners) {
            each.afterJobExecuted(shardingContexts);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.Trigger &lt;/p&gt;
&lt;p&gt;elasticJob默认使用Cron Trigger，在job属性里定义&lt;/p&gt;
&lt;pre&gt;
  &amp;lt;xsd:attribute name=&quot;cron&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&amp;gt;
&lt;/pre&gt;
&lt;p&gt;5.作业调度器JobScheduler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化作业.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        &lt;span&gt;LiteJobConfiguration liteJobConfigFromRegCenter &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; schedulerFacade.updateJobConfiguration(liteJobConfig);  //1&lt;/span&gt;
        JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());
&lt;span&gt;        JobScheduleController jobScheduleController &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new&lt;/span&gt;&lt;span&gt;&lt;span&gt; JobScheduleController(
                createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName()); //2
        JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);  //3&lt;/span&gt;
        schedulerFacade.registerStartUpInfo(&lt;/span&gt;!&lt;span&gt;liteJobConfigFromRegCenter.isDisabled());
        &lt;span&gt;jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());   //4&lt;/span&gt;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; JobDetail createJobDetail(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String jobClass) {
        JobDetail result &lt;/span&gt;= JobBuilder.newJob(LiteJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).withIdentity(liteJobConfig.getJobName()).build();
        result.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);
        Optional&lt;/span&gt;&amp;lt;ElasticJob&amp;gt; elasticJobInstance =&lt;span&gt; createElasticJobInstance();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (elasticJobInstance.isPresent()) {
            result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJobInstance.get());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!jobClass.equals(ScriptJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getCanonicalName())) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, Class.forName(jobClass).newInstance());
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; ReflectiveOperationException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JobConfigurationException(&quot;Elastic-Job: Job class '%s' can not initialize.&quot;&lt;span&gt;, jobClass);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Optional&amp;lt;ElasticJob&amp;gt;&lt;span&gt; createElasticJobInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Optional.absent();
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Scheduler createScheduler() {
        Scheduler result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            StdSchedulerFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory();
            factory.initialize(getBaseQuartzProperties());
            result &lt;/span&gt;=&lt;span&gt; factory.getScheduler();
            result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; SchedulerException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobSystemException(ex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Properties getBaseQuartzProperties() {
        Properties result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        result.put(&lt;/span&gt;&quot;org.quartz.threadPool.class&quot;, org.quartz.simpl.SimpleThreadPool.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
        result.put(&lt;/span&gt;&quot;org.quartz.threadPool.threadCount&quot;, &quot;1&quot;&lt;span&gt;);
        result.put(&lt;/span&gt;&quot;org.quartz.scheduler.instanceName&quot;&lt;span&gt;, liteJobConfig.getJobName());
        result.put(&lt;/span&gt;&quot;org.quartz.jobStore.misfireThreshold&quot;, &quot;1&quot;&lt;span&gt;);
        result.put(&lt;/span&gt;&quot;org.quartz.plugin.shutdownhook.class&quot;, JobShutdownHookPlugin.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
        result.put(&lt;/span&gt;&quot;org.quartz.plugin.shutdownhook.cleanShutdown&quot;&lt;span&gt;, Boolean.TRUE.toString());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.1 更新作业配置.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新作业配置.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; liteJobConfig 作业配置
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 更新后的作业配置
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LiteJobConfiguration updateJobConfiguration(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LiteJobConfiguration liteJobConfig) {
        configService.persist(liteJobConfig);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; configService.load(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.2 初始化一系列操作&lt;/p&gt;
&lt;p&gt;5.2.1 创建quartz scheduler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Scheduler createScheduler() {
        Scheduler result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            StdSchedulerFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory();
            factory.initialize(getBaseQuartzProperties());
            result &lt;/span&gt;=&lt;span&gt; factory.getScheduler();
            result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; SchedulerException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobSystemException(ex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.2.2 创建JobDetail&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; JobDetail createJobDetail(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String jobClass) {
        JobDetail result &lt;/span&gt;= JobBuilder.newJob(LiteJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).withIdentity(liteJobConfig.getJobName()).build();
        result.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);
        Optional&lt;/span&gt;&amp;lt;ElasticJob&amp;gt; elasticJobInstance =&lt;span&gt; createElasticJobInstance();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (elasticJobInstance.isPresent()) {
            result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJobInstance.get());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!jobClass.equals(ScriptJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getCanonicalName())) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, Class.forName(jobClass).newInstance());
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; ReflectiveOperationException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JobConfigurationException(&quot;Elastic-Job: Job class '%s' can not initialize.&quot;&lt;span&gt;, jobClass);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.2.3 添加作业调度控制器.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加作业调度控制器.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jobName 作业名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jobScheduleController 作业调度控制器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; regCenter 注册中心
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; registerJob(&lt;span&gt;final&lt;/span&gt; String jobName, &lt;span&gt;final&lt;/span&gt; JobScheduleController jobScheduleController, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; CoordinatorRegistryCenter regCenter) {
        schedulerMap.put(jobName, jobScheduleController);
        regCenterMap.put(jobName, regCenter);
        regCenter.addCacheData(&lt;/span&gt;&quot;/&quot; +&lt;span&gt; jobName);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.2.4 调度作业.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 调度作业.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cron CRON表达式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; scheduleJob(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String cron) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;scheduler.checkExists(jobDetail.getKey())) {
               &lt;span&gt; scheduler.scheduleJob(jobDetail, createTrigger(cron));&lt;/span&gt;
            }
            &lt;span&gt;scheduler.start();&lt;/span&gt;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; SchedulerException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobSystemException(ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.总结&lt;/p&gt;
&lt;p&gt;  &amp;gt;&amp;gt;elastic-job使用了quartz的调度机制，内部原理一致，增加了性能和可用性。&lt;/p&gt;
&lt;p&gt;  &amp;gt;&amp;gt;elastic-job使用注册中心(zookeeper)替换了quartz的jdbc数据存储方式，性能有较大提升。&lt;/p&gt;
&lt;p&gt; &amp;gt;&amp;gt; elastic-job增加了job的追踪(使用Listener)，便于monitor&lt;/p&gt;
&lt;p&gt; &amp;gt;&amp;gt;elastic-job使用了分片机制，可以将job分成多个任务项，放到不同的地方执行&lt;/p&gt;
&lt;p&gt; &amp;gt;&amp;gt;elastic-job仅支持cronTrigger，quartz支持更多的trigger实现&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 07:29:00 +0000</pubDate>
<dc:creator>一天不进步，就是退步</dc:creator>
<og:description>前段时间写过一遍文章&lt;一文揭秘定时任务调度框架quartz&gt;,有读者建议我再讲讲elastic-job这个任务调度框架，年末没有那么忙，就来学习一下elastic-job。 首先一点，el</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davidwang456/p/10346013.html</dc:identifier>
</item>
<item>
<title>反向传播算法为什么要“反向” - kangheng</title>
<link>http://www.cnblogs.com/kangheng/p/10345024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangheng/p/10345024.html</guid>
<description>&lt;p&gt;反向传播算法是深度学习的最重要的基础，这篇博客不会详细介绍这个算法的原理和细节。，如果想学习反向传播算法的原理和细节请移步到这本不错的&lt;a href=&quot;http://http//neuralnetworksanddeeplearning.com/chap2.html&quot; title=&quot;电子书&quot;&gt;资料&lt;/a&gt;。这里主要讨论反向传播算法中的一个小细节：反向传播算法为什么要“反向”？&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;在机器学习中,很多算法最后都会转化为求一个目标损失函数（loss function）的最小值。这个损失函数往往很复杂，难以求出最值的解析表达式。而梯度下降法正是为了解决这类问题。直观地说一下这个方法的思想：我们把求解损失函数最小值的过程看做“站在山坡某处去寻找山坡的最低点”。我们并不知道最低点的确切位置，“梯度下降”的策略是每次向“下坡路”的方向走一小步，经过长时间的走“下坡路”最后的停留位置也大概率在最低点附近。这个“下坡路的方向”我们选做是梯度方向的负方向，选这个方向是因为每个点的梯度负方向是在该点处函数下坡最陡的方向。至于为什么梯度负方向是函数下降最陡的方向请参考大一下的微积分教材，或者看看&lt;a href=&quot;https://betterexplained.com/articles/understanding-pythagorean-distance-and-the-gradient/&quot;&gt;这个直观的解释&lt;/a&gt;。在神经网络模型中反向传播算法的作用就是要求出这个梯度值，从而后续用梯度下降去更新模型参数。反向传播算法从模型的输出层开始，利用函数求导的链式法则，逐层从后向前求出模型梯度，那么为什么要从后向前呢？&lt;/p&gt;
&lt;h3 id=&quot;从一道编程题说起&quot;&gt;从一道编程题说起&lt;/h3&gt;
&lt;p&gt;这是leetcode 上的一道&lt;a href=&quot;https://leetcode.com/problems/triangle/&quot;&gt;编程题&lt;/a&gt; ，这道题不是很难，读者可以自己先做一做。这个问题的原理跟反向传播算法有很大的相似。&lt;br/&gt;这道题目是给出一个三角形的数组，从上到下找到一条路径使得这条路径上数字的和最小，并且路径层与层之间的节点左右需要相邻。详细的题目介绍请到&lt;a href=&quot;https://leetcode.com/problems/triangle/&quot;&gt;leetcode&lt;/a&gt;上看一看。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534176/201902/1534176-20190201145834886-689500189.png&quot;/&gt;&lt;br/&gt;图1&lt;/div&gt;
&lt;p&gt;图1中是一个具体的例子，最小和的路径如箭头所示，路径的和为11。最开始做这个题，我的想法是从上到下不断将问题分解成小问题去处理，具体来说上图的大三角形可以分解成3为顶点和4为顶点的两个小三角形，如图2所示，求出这两个子问题的最小路径，选择这两个路径和较小者加上顶点2的值就为整个问题的最小值，而对于每个分解的子问题，再故伎重演地继续分解来处理。具体的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Solution:
    def minPoint(self,triangel,i,j):
        if i == len(triangel)-1:       #最底层，递归基
            return triangel[i][j]
        else:
            return triangel[i][j] +  \   #顶点值
            min(self.minPoint(triangel,i+1,j),self.minPoint(triangel,i+1,j+1)) #子问题的较小者
    def minimumTotal(self, triangle):
        &quot;&quot;&quot;
        :type triangle: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        return self.minPoint(triangle,0,0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将以上代码提交后发现Time Limit Exceeded 的超时错误，究其原因是这种从上到下的计算方式中存在大量的重复计算，如2图所示：将一个大的问题分解成两个子问题（红蓝两个三角形）时，这两个三角形之间有交叠，即图2中的紫色圈，这些交叠部分会导致重复计算，使得计算超时。图中仅仅是一个子问题的重复计算，实际上每一次子问题的分解都有这样的重复计算，因此整个问题的重复计算量非常的大。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534176/201902/1534176-20190201145901322-1673465283.png&quot;/&gt;&lt;br/&gt;图2&lt;/div&gt;
&lt;p&gt;实际上这个问题的正确解决方法是使用动态规划算法，动态规划要解决的正是这种包含重复子问题的情况。其实现方法一般分为两种，一种是将计算过的子问题都缓存起来，当遇到了相同的问题就直接取出缓存的值，避免重复计算；另一种是方式是换一个“计算方向”（或者说计算的先后次序），使得在这个计算方向上没有重复的子问题。对于上述编程题我们的解法就是将这一算法换一个计算方向，由从上到下变换为从下到上。从最底层开始由下到上计算以当前点为顶点的“三角形”最小路径值，下层的顶点先计算，上层可以利用下层的计算结果，这就避免了重复计算。具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Solution:
    def minimumTotal(self, triangle):
        &quot;&quot;&quot;
        :type triangle: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        for i in range(len(triangle)-1)[::-1]:
            for j in range(len(triangle[i])):
                triangle[i][j] = triangle[i][j] + min(triangle[i+1][j],triangle[i+1][j+1])
        return triangle[0][0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就能够通过测试，我们看到仅仅是改变计算方向就能有效地避免重复的计算，从而加快计算速度。理解了这个算法，我们再看反向传播算法需要“反向”的原因也就觉得理所当然了。&lt;/p&gt;
&lt;h3 id=&quot;反向传播算法&quot;&gt;反向传播算法&lt;/h3&gt;
&lt;p&gt;现在来讲反向传播算法，其目的就是要求神经网络模型的输出相对于各个参数的梯度值。以图3为例子讲解，图中输入向量x经过神经网络的输出为y，模型的参数为wi和bi，在输入值x为xi时，将模型的参数看做自变量，于是所谓的求梯度就是求出所有的&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial y}{\partial wi}|_{x=xi}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial y}{\partial bi}|_{x=xi}\)&lt;/span&gt;。这些导数要怎么求能？如果我不知道反向传播算法，我应该会用如下式子的近似求导方法：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial y}{\partial x} \approx \frac{f(x+ \Delta x)-f(x)}{\Delta x} \]&lt;/span&gt;&lt;br/&gt;即要求某个参数的导数就让这个参数微变一点点，然后求出结果相对于参数变化量的比值。那么为何我们的神经网络算法没有采用这种方法求导呢？&lt;br/&gt;让我们再看一看图3的例子，现在假设输入向量经过正向传播后，现在要求出参数w1和w2的导数，按照上述方法计算时，对w1微扰后，需要重新计算红框内的节点；对w2微扰后，需要重新计算绿框内的节点。这两次计算中也有大量的“重复单元”即图中的蓝框，实际上神经网络的每一个参数的计算都包含着这样大量的重复单眼，那么神经网络规模一旦变大，这种算法的计算量一定爆炸，没有适用价值。我们再回过头去看我们的编程题，是否有一些似曾相识呢，尤其是图2和图3之间。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534176/201902/1534176-20190201104631585-2103043651.png&quot; alt=&quot;图3&quot;/&gt;&lt;br/&gt;图3&lt;/div&gt;
&lt;br/&gt;在解决上述编程题时，我们选了一条相反的计算线路解决重复计算的问题。在神经网络中，那些牛逼的大神同样选择了另一条计算方向去计算梯度，这个方向就是从后向前“反向”地计算各层参数的梯度。这里不详细讨论方向传播算法的原理了，简单来说这种方法利用了函数求导的链式法则，从输出层到输入层逐层计算模型参数的梯度值，只要模型中每个计算都能求导，那么这种方法就没问题。可以看到按照这个方向计算梯度，各个神经单元只计算了一次，没有重复计算。这个计算方向能够高效的根本原因是，在计算梯度时前面的单元是依赖后面的单元的计算，而“从后向前”的计算顺序正好“解耦”了这种依赖关系，先算后面的单元，并且记住后面单元的梯度值，计算前面单元之就能充分利用已经计算出来的结果，避免了重复计算。
&lt;h3 id=&quot;尾声&quot;&gt;尾声&lt;/h3&gt;
&lt;p&gt;我们可以看到如今人工智能领域中最重要的算法——反向传播算法其主要思想也不过是动态规划，所以这些nb的算法不见得是用了多“高级”的方法，看到了问题的本质用简单的方法也能有奇效。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 07:27:00 +0000</pubDate>
<dc:creator>kangheng</dc:creator>
<og:description>反向传播算法是深度学习的最重要的基础，这篇博客不会详细介绍这个算法的原理和细节。，如果想学习反向传播算法的原理和细节请移步到这本不错的 '资料' 。这里主要讨论反向传播算法中的一个小细节：反向传播算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangheng/p/10345024.html</dc:identifier>
</item>
<item>
<title>使用kubeadm部署Kubernetes集群 - readygood</title>
<link>http://www.cnblogs.com/readygood/p/10345858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/readygood/p/10345858.html</guid>
<description>&lt;h2&gt;　　1.&lt;span&gt;集群节点架构与各节点所需安装的服务如下图：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201902/1479216-20190201135900507-1379621514.png&quot; alt=&quot;&quot; width=&quot;862&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　2.安装环境与软件版本：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Master：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所需软件：docker-ce 17.03、kubelet1.11.1、kubeadm1.11.1、kubectl1.11.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所需镜像：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mirrorgooglecontainers/kube-proxy-amd64:v1.11.1、&lt;/span&gt;&lt;span&gt;mirrorgooglecontainers/kube-scheduler-amd64:v1.11.1、mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.1、mirrorgooglecontainers/kube-apiserver-amd64:v1.11.1、coredns/coredns:1.1.3、mirrorgooglecontainers/etcd-amd64:3.2.18、mirrorgooglecontainers/pause:3.1、registry.cn-hangzhou.aliyuncs.com/readygood/flannel:v0.10.0-amd64&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Node：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所需软件：docker-ce 17.03、kubelet1.11.1、kubeadm1.11.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所需镜像：mirrorgooglecontainers/kube-proxy-amd64:v1.11.1、mirrorgooglecontainers/pause:3.1、registry.cn-hangzhou.aliyuncs.com/readygood/flannel:v0.10.0-amd64&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;　　1.关闭Firewall和SELinux&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于kubeadm在初始化时会自动生成ipv4规则，所以尽量在部署前关闭防火墙。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　2.配置阿里云的Kubernetes镜像和Docker-ce镜像并安装&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;K8s yum源配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[k8s]
name&lt;/span&gt;=&lt;span&gt;k8s
baseurl&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/&lt;/span&gt;
gpgchecke=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgkey&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg&lt;/span&gt;
enabled=&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Docker-ce源配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; -o /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/ https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改Docker镜像默认拉取源：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt; -p /etc/&lt;span&gt;docker
vim &lt;/span&gt;/etc/docker/&lt;span&gt;daemon.json
{
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://registry.docker-cn.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;安装注意指定版本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y --setopt=obsoletes=&lt;span&gt;0&lt;/span&gt;    docker-ce-&lt;span&gt;17.03&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.ce-&lt;span&gt;1&lt;/span&gt;.el7.centos.x86_64    docker-ce-selinux-&lt;span&gt;17.03&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.ce-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.el7.centos.noarch
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; kubelet-&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; kubeadm-&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; kubectl-&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;1 -y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　3.设置内核转发规则，即要求iptables对bridge的数据进行处理，默认为0.&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/bridge/bridge-nf-call-iptables
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　4.关闭或者忽略swap，部署Kubernetes集群时尽量不要使用swap分区，Kubernetes会提示是否要关闭或者忽略，忽略方式如下：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/sysconfig/&lt;span&gt;kubelet
KUBELET_EXTRA_ARGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--fail-swap-on=false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　5.初始化Kubernetes&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
kubeadm init --kubernetes-version=&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; --pod-network-cidr=&lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt; --service-cidr=&lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;12&lt;/span&gt; --ignore-preflight-errors=Swap
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如果在初始化中出现错误可以使用 &lt;span class=&quot;cnblogs_code&quot;&gt;kubeadm reset&lt;/span&gt; 重置初始化，如果出现&quot; [kubelet-check] It seems like the kubelet isn't running or healthy. &quot;的错误，建议检查swap设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　初始化完成会出现如下提示，&lt;/span&gt;&lt;span&gt;按提示完成操作初始化便完成，最后一段数字一定要保留下来，这是加入集群必须要的认证信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Your Kubernetes master has initialized successfully!&lt;span&gt;
 
To start using your cluster, you need to run the following as a regular user:
 
  &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; -p $HOME/&lt;span&gt;.kube
  &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; -i /etc/kubernetes/admin.conf $HOME/.kube/&lt;span&gt;config
  &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; $(&lt;span&gt;id&lt;/span&gt; -u):$(&lt;span&gt;id&lt;/span&gt; -g) $HOME/.kube/&lt;span&gt;config
 
You should now deploy a pod network to the cluster.
Run &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kubectl apply -f [podnetwork].yaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; with one of the options listed at:
  https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;kubernetes.io/docs/concepts/cluster-administration/addons/&lt;/span&gt;
&lt;span&gt; 
You can now &lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt; any number of machines by running the following on each node
as root:
    kubeadm &lt;/span&gt;&lt;span&gt;join&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;:&lt;span&gt;6443&lt;/span&gt; --token 4qswp9.rxgwhn0vqp4c9npl --discovery-token-ca-cert-hash sha256:2d9bc0bd6b1eb12dcb8695f17191b243ecf3ed169d4aafaacc5c5c1272a85f07
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　6.关于运行Kubernetes所需镜像下载的问题：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于某些原因无法正常下载官方镜像，但Kubeadm只支持认证官方的镜像标签，所以必须在dockerhub上下载镜像后修改标签才能使用，可使用dockerhub或者阿里云镜像，然后修改标签名：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mirrorgooglecontainers/kube-proxy-&lt;span&gt;amd64
mirrorgooglecontainers&lt;/span&gt;/kube-apiserver-&lt;span&gt;amd64
mirrorgooglecontainers&lt;/span&gt;/kube-scheduler-&lt;span&gt;amd64
mirrorgooglecontainers&lt;/span&gt;/kube-controller-manager-&lt;span&gt;amd64
coredns&lt;/span&gt;/&lt;span&gt;coredns
mirrorgooglecontainers&lt;/span&gt;/etcd-&lt;span&gt;amd64
mirrorgooglecontainers&lt;/span&gt;/pause
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
k8s.gcr.io/kube-proxy-amd64                v1.&lt;span&gt;11.1&lt;/span&gt;             d5c25579d0ff        &lt;span&gt;8&lt;/span&gt; weeks ago         &lt;span&gt;97&lt;/span&gt;&lt;span&gt;.8MB
k8s.gcr.io&lt;/span&gt;/kube-scheduler-amd64            v1.&lt;span&gt;11.1&lt;/span&gt;             272b3a60cd68        &lt;span&gt;8&lt;/span&gt; weeks ago         &lt;span&gt;56&lt;/span&gt;&lt;span&gt;.8MB
k8s.gcr.io&lt;/span&gt;/kube-controller-manager-amd64   v1.&lt;span&gt;11.1&lt;/span&gt;             52096ee87d0e        &lt;span&gt;8&lt;/span&gt;&lt;span&gt; weeks ago         155MB
k8s.gcr.io&lt;/span&gt;/kube-apiserver-amd64            v1.&lt;span&gt;11.1&lt;/span&gt;             816332bd9d11        &lt;span&gt;8&lt;/span&gt;&lt;span&gt; weeks ago         187MB
k8s.gcr.io&lt;/span&gt;/coredns                         &lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;               b3b94275d97c        &lt;span&gt;3&lt;/span&gt; months ago        &lt;span&gt;45&lt;/span&gt;&lt;span&gt;.6MB
k8s.gcr.io&lt;/span&gt;/etcd-amd64                      &lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;              b8df3b177be2        &lt;span&gt;5&lt;/span&gt;&lt;span&gt; months ago        219MB
quay.io&lt;/span&gt;/coreos/flannel                     v0.&lt;span&gt;10.0&lt;/span&gt;-amd64       f0fad859c909        &lt;span&gt;7&lt;/span&gt; months ago        &lt;span&gt;44&lt;/span&gt;&lt;span&gt;.6MB
k8s.gcr.io&lt;/span&gt;/pause                           &lt;span&gt;3.1&lt;/span&gt;                 da86e6ba6ca1        &lt;span&gt;8&lt;/span&gt; months ago        742kB
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　7.关于flannel的安装&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在确定已经下载镜像 &lt;span class=&quot;cnblogs_code&quot;&gt;quay.io/coreos/flannel&lt;/span&gt; 后（能访问谷歌请忽略），运行下面的命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
kubectl apply -f https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 　　1.安装node所需组件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　和master一样，需要安装docker、kubeadm、kubelet，并设置开机自启，步骤参考master，这里不赘述了。下载好Node所需镜像，并重命名为k8s.gcr.io/：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mirrorgooglecontainers/kube-proxy-amd64               v1.&lt;span&gt;11.1&lt;/span&gt;             d5c25579d0ff        &lt;span&gt;6&lt;/span&gt; months ago        &lt;span&gt;97.8&lt;/span&gt;&lt;span&gt; MB
registry.cn&lt;/span&gt;-hangzhou.aliyuncs.com/readygood/flannel   v0.&lt;span&gt;10.0&lt;/span&gt;-amd64       50e7aa4dbbf8        &lt;span&gt;9&lt;/span&gt; months ago        &lt;span&gt;44.6&lt;/span&gt;&lt;span&gt; MB
registry.cn&lt;/span&gt;-hangzhou.aliyuncs.com/readygood/pause     &lt;span&gt;3.1&lt;/span&gt;                 da86e6ba6ca1        &lt;span&gt;13&lt;/span&gt; months ago       &lt;span&gt;742&lt;/span&gt; kB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;docker镜像下载完成后初始化flannel服务：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
kubectl apply -f https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　2.初始化node节点&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
kubeadm &lt;span&gt;join&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;:&lt;span&gt;6443&lt;/span&gt; --token 4qswp9.rxgwhn0vqp4c9npl --discovery-token-ca-cert-hash sha256:2d9bc0bd6b1eb12dcb8695f17191b243ecf3ed169d4aafaacc5c5c1272a85f07 --ignore-preflight-errors=Swap
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如果不关闭swap同样需要配置swap设置以及修改iptables对bridge的数据进行处理设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim /etc/sysconfig/&lt;span&gt;kubelet
KUBELET_EXTRA_ARGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--fail-swap-on=false&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;echo 1 &amp;gt; /proc/sys/net/bridge/bridge-nf-call-iptables&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;出现如下提示即初始化完成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;This node has joined the cluster:
&lt;/span&gt;*&lt;span&gt; Certificate signing request was sent to master and a response
  was received.
&lt;/span&gt;*&lt;span&gt; The Kubelet was informed of the new secure connection details.

Run &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kubectl get nodes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; on the master to see this node &lt;span&gt;join&lt;/span&gt; the cluster.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看集群状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
]# kubectl get pods -n kube-system -&lt;span&gt;o wide
NAME                             READY     STATUS    RESTARTS   AGE       IP               NODE
coredns&lt;/span&gt;-78fcdf6894-kpt2k         &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;1&lt;/span&gt;          18h       &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;       master
coredns&lt;/span&gt;-78fcdf6894-nzdkz         &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;1&lt;/span&gt;          18h       &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;0.4&lt;/span&gt;&lt;span&gt;       master
etcd&lt;/span&gt;-master                      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;3&lt;/span&gt;          16h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;   master
kube&lt;/span&gt;-apiserver-master            &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;3&lt;/span&gt;          16h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;   master
kube&lt;/span&gt;-controller-manager-master   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;3&lt;/span&gt;          16h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;   master
kube&lt;/span&gt;-flannel-ds-amd64-5gnd8      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;1&lt;/span&gt;          16h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;   master
kube&lt;/span&gt;-flannel-ds-amd64-7rtb8      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2h        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt;&lt;span&gt;   node1
kube&lt;/span&gt;-flannel-ds-amd64-qqjdv      &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2h        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt;&lt;span&gt;   node2
kube&lt;/span&gt;-proxy-kfsfj                 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2h        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt;&lt;span&gt;   node2
kube&lt;/span&gt;-proxy-lnk67                 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;0&lt;/span&gt;          2h        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt;&lt;span&gt;   node1
kube&lt;/span&gt;-proxy-v8d2q                 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;2&lt;/span&gt;          18h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;   master
kube&lt;/span&gt;-scheduler-master            &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;       Running   &lt;span&gt;2&lt;/span&gt;          16h       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;   master
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
]# kubectl get nodes -&lt;span&gt;o wide
NAME      STATUS    ROLES     AGE       VERSION   INTERNAL&lt;/span&gt;-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION          CONTAINER-&lt;span&gt;RUNTIME
master    Ready     master    18h       v1.&lt;/span&gt;&lt;span&gt;11.1&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;   &amp;lt;none&amp;gt;        CentOS Linux &lt;span&gt;7&lt;/span&gt; (Core)   &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;957&lt;/span&gt;.el7.x86_64   docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;17.3.2&lt;/span&gt;
node1     Ready     &amp;lt;none&amp;gt;    2h        v1.&lt;span&gt;11.1&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt;   &amp;lt;none&amp;gt;        CentOS Linux &lt;span&gt;7&lt;/span&gt; (Core)   &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;957&lt;/span&gt;.el7.x86_64   docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;17.3.2&lt;/span&gt;
node2     Ready     &amp;lt;none&amp;gt;    2h        v1.&lt;span&gt;11.1&lt;/span&gt;   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt;   &amp;lt;none&amp;gt;        CentOS Linux &lt;span&gt;7&lt;/span&gt; (Core)   &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;957&lt;/span&gt;.el7.x86_64   docker:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;17.3.2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　还需要特别注意的是，各Node之间的主机名不要相同，一定要修改，不然Kubeadm会识别为同一Node而无法加入。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Node2和Node3的部署和Node1相同，可以完全按照Node1的方法来部署。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 07:14:00 +0000</pubDate>
<dc:creator>readygood</dc:creator>
<og:description>一、环境架构与部署准备 1.集群节点架构与各节点所需安装的服务如下图： 2.安装环境与软件版本： Master： 所需软件：docker-ce 17.03、kubelet1.11.1、kubeadm1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/readygood/p/10345858.html</dc:identifier>
</item>
<item>
<title>SSE图像算法优化系列二十八：深度优化局部拉普拉斯金字塔滤波器。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/10344048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/10344048.html</guid>
<description>&lt;p&gt;&lt;span&gt;      基于局部拉普拉斯金字塔的Edge-aware滤波器是在2011年由Adobe 公司的研究员&lt;a href=&quot;http://people.csail.mit.edu/sparis/&quot;&gt;Sylvain Paris&lt;/a&gt;（大神级人物，写了很多文章）提出的，我在4年前曾经参考有关代码实现过这个算法，但是速度也是非常慢的，所以当时也没有继续做深入的研究，前段时间做另外一个算法时仔细的研究了下高斯和拉普拉斯金子塔的优化，因此又抽时间仔细的分析了算法的论文和代码，由于论文的理论部分还有一些我没有想清楚，因此在这里我只对研读过程中涉及的代码方面的优化做个解读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过我最终的优化，处理1920 * 1024的彩色图，在保证效果不会有明显的瑕疵的取样值的情况下，大概能获得60ms的速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先分享下参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）论文 &lt;a href=&quot;http://people.csail.mit.edu/sparis/publi/2011/siggraph/&quot; target=&quot;_blank&quot;&gt;Local Laplacian Filters: Edge-aware Image Processing with a Laplacian Pyramid&lt;/a&gt;。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）论文 &lt;a href=&quot;http://imagine.enpc.fr/~aubrym/projects/llf/&quot; target=&quot;_blank&quot;&gt;Fast Local Laplacian Filters: Theory and Applications &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（3）函数：&lt;a href=&quot;https://www.mathworks.com/help/images/ref/locallapfilt.html&quot; target=&quot;_blank&quot;&gt;matlab 2017的locallapfilt&lt;/a&gt;函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（4）插件：&lt;a href=&quot;https://forums.getpaint.net/topic/24563-laplacian-pyramid-filter-effect-plugin/&quot; target=&quot;_blank&quot;&gt;Paint.net的Laplacian pyramid filter effect （可反编译为C#代码)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  我们先看下源作者给出的一个最原始的matlab的过程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; % naive O(N ^ &lt;span&gt;2&lt;/span&gt;) version &lt;span&gt;for&lt;/span&gt;&lt;span&gt; reference
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; G = gaussian_pyramid(I);                                        %&lt;span&gt;   由输入图像I建立高斯金字塔序列
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; L = laplacian_pyramid(zeros(size(I)));                             %&lt;span&gt;   建立一个和图像I大小相匹配的空的拉普拉斯金字塔
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; lev0 = &lt;span&gt;1&lt;/span&gt;:length(L) - &lt;span&gt;1&lt;/span&gt;                                        %&lt;span&gt;    对每一层金字塔
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; y0 = &lt;span&gt;1&lt;/span&gt; : size(G{ lev0 }, &lt;span&gt;1&lt;/span&gt;)                                %&lt;span&gt;    遍历每一层金字塔的高度
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x0 = &lt;span&gt;1&lt;/span&gt; : size(G{ lev0 }, &lt;span&gt;2&lt;/span&gt;)                            %&lt;span&gt;    遍历每一层金字塔的宽度
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             g0 = G{ lev0 }(y0, x0, :);                            %&lt;span&gt;   每一层高斯金字塔的每个数据
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Iremap = r(I, g0);                                    %&lt;span&gt;   根据每个数据值，计算输入图像I对应的一个映射新图像
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Lremap = laplacian_pyramid(Iremap, lev0 + &lt;span&gt;1&lt;/span&gt;);        %&lt;span&gt;   计算这个新映射图像的拉普拉斯金子塔
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             L{ lev0 }(y0, x0, :) = Lremap{ lev0 }(y0, x0, :);   %&lt;span&gt;   填空前面建立的空的拉普拉斯金字塔对应位置的值
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; L{ end } =&lt;span&gt; G{ end };
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; R = reconstruct_laplacian_pyramid(L);                            %   根据拉普拉斯金字塔构建出结果图像&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　原文核心的关于这段代码的解释如下（为了不浪费空间，下面的图片是从原文截图，然后用PS再把短行拼接成长行的）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201901/349293-20190131215215247-118709190.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　简单的说，就是需要遍历所有高斯金字塔图像中的所有像素，根据每个像素的像素值，都由原图和某个映射函数重新计算出一个和原图一样大小的图像，然后计算该图像的拉普拉斯金字塔，如上述代码的第10行所示，注意此时的拉普拉斯金字塔只需要构建到对应的像素所在的高斯金字塔那一层就可以了，然后呢，取该像素位置所对应临时金字塔的值作为结果图像在此位置的拉普拉斯金字塔值。当所有层的像素都计算完成后，结果图的拉普拉斯金子塔就构建完成了，这个时候结果图像就可以由拉普拉斯金字塔重构出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由上述分析可见，直接实现这个过程将是非常耗时的，每一层金字塔的每一个系数都要靠构造一次拉普拉斯金字塔，如果图像宽和高都为N，则理论上说，所有的金字塔加起来是有N*N+N*N个像素的，这个时候就需要计算N*N大小图像的拉普拉斯金字塔（N*N+N*N)次，会让算法根本无法使用。在原始论文中，作者提到为了计算某个位置的拉普拉斯金字塔值，并不需要计算整体的值，而只需要取某个局部区域来计算，可以将计算的复杂度降低到O(N * Log(N))，确实如此，但是这样的过程依旧很慢很慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　在没有看&lt;a href=&quot;http://imagine.enpc.fr/~aubrym/projects/llf/&quot; target=&quot;_blank&quot;&gt;Fast Local Laplacian Filters: Theory and Applications&lt;/a&gt;论文之前，我想到的关于此方法的优化手段非常有效，因为对于常规8位图像来说，其像素的可能值只有0到255之间的256个值，因此，在上述N*N+N*N次构建拉普拉斯金字塔的过程中，最多其实只会有256种不同结果，这也就意味着我们只需要构建256次拉普拉斯金字塔就可以得到所有的结果。大概的matlab代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;G =&lt;span&gt; gaussian_pyramid(I);                                        
L &lt;/span&gt;=&lt;span&gt; laplacian_pyramid(zeros(size(I)));                             
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; M = &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;255&lt;/span&gt;&lt;span&gt;
    Iremap &lt;/span&gt;=&lt;span&gt; r(I, M);                                    
    Lremap &lt;/span&gt;= laplacian_pyramid(Iremap, length(L) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; lev0 = &lt;span&gt;1&lt;/span&gt;:length(L) - &lt;span&gt;1&lt;/span&gt;                                        
        &lt;span&gt;for&lt;/span&gt; y0 = &lt;span&gt;1&lt;/span&gt; : size(G{ lev0 }, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)                                
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x0 = &lt;span&gt;1&lt;/span&gt; : size(G{ lev0 }, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)                            
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (G{ lev0 }(y0, x0, :) =&lt;span&gt; M)                    
                    L{ lev0 }(y0, x0, :) &lt;/span&gt;=&lt;span&gt; Lremap{ lev0 }(y0, x0, :) 
                end 
            end 
        end
    end
end
L{ end } &lt;/span&gt;=&lt;span&gt; G{ end };
R &lt;/span&gt;= reconstruct_laplacian_pyramid(L);            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　结合后面将要介绍的处理方法，利用C++和SSE处理一幅1920 * 1024（2M Pixel)的灰度图，单线程大概的耗时在1200ms左右，而源作者的论文使用8核并行计算处理1M像素的图都用了4000ms多，提速了很多倍，处理效果则是一摸一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而论文&lt;a href=&quot;http://imagine.enpc.fr/~aubrym/projects/llf/&quot; target=&quot;_blank&quot;&gt;Fast Local Laplacian Filters: Theory and Applications&lt;/a&gt;则做了更多的做工，他首先分析局部拉普拉斯算法和双边滤波的关系，然后分析了这个算法慢的主要原因，最后提出了他自己的解决方案，正如上面我们的所分析的，我们只需要做256次完整的拉普拉斯分解就可以了，而根据采样定理，其实不一定要做这么多次，只要多于某个采样数值时，系统一样可以稳定的输出，而这个数值通常都要远远的小于256次，当然，我们是不太方便直接从图像中找到这个最小的取样数据的，但是经过摸索，一般来说大于12次以上效果都是不错的，这篇论文的作者提出的相关参考代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; %&lt;span&gt; INPUT
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; %&lt;span&gt; I : input greyscale image
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; %&lt;span&gt; r : a function handle to the remaping function
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; %&lt;span&gt; N : number discretisation values of the intensity
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; %&lt;span&gt; OUTPUT
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; %&lt;span&gt; F : filtered image
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; function [F]=&lt;span&gt;llf(I,sigma,fact,N)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     [height width]=&lt;span&gt;size(I);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     n_levels=ceil(log(min(height,width))-log(&lt;span&gt;2&lt;/span&gt;))+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     discretisation=linspace(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,N);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     discretisation_step=discretisation(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     input_gaussian_pyr=&lt;span&gt;gaussian_pyramid(I,n_levels);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     output_laplace_pyr=&lt;span&gt;laplacian_pyramid(I,n_levels);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     output_laplace_pyr{n_levels}=&lt;span&gt;input_gaussian_pyr{n_levels};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;discretisation
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         I_remap=fact*(I-&lt;span&gt;ref&lt;/span&gt;).*exp(-(I-&lt;span&gt;ref&lt;/span&gt;).*(I-&lt;span&gt;ref&lt;/span&gt;)./(&lt;span&gt;2&lt;/span&gt;*sigma*&lt;span&gt;sigma));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         temp_laplace_pyr=&lt;span&gt;laplacian_pyramid(I_remap,n_levels);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; level=&lt;span&gt;1&lt;/span&gt;:n_levels-&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             output_laplace_pyr{level}=output_laplace_pyr{level}+&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 (abs(input_gaussian_pyr{level}-&lt;span&gt;ref&lt;/span&gt;)&amp;lt;discretisation_step).*&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 temp_laplace_pyr{level}.*&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 (&lt;span&gt;1&lt;/span&gt;-abs(input_gaussian_pyr{level}-&lt;span&gt;ref&lt;/span&gt;)/&lt;span&gt;discretisation_step);            
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     F=reconstruct_laplacian_pyramid(output_laplace_pyr);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中第19到22行即为插值的过程，我们测试了一下对应的Matlab代码，处理1M像素的图，大概耗时在3800ms左右，我们知道matlab的代码确实只适合教学，因此，优化的余地是有很大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   在优化前，我们还是定性的说下上面过程中涉及到的reampping Function，在原始的论文中，作者提到了这个函数起到了细节和边缘调整的作用，对于高斯金字塔中的任一像素值g&lt;sub&gt;0&lt;/sub&gt;，我们设定一个参数б&lt;sub&gt;r&lt;/sub&gt; , 当原图I中的像素i的值在g&lt;sub&gt;0&lt;/sub&gt;附近时，我们认为这些点属于g&lt;sub&gt;0&lt;/sub&gt;附近的细节，而远离g&lt;sub&gt;0&lt;/sub&gt;的部分则属于边缘，对细节和边缘我们采用两个不同的处理函数r&lt;sub&gt;d&lt;/sub&gt;和r&lt;sub&gt;e，&lt;/sub&gt;一般要求r&lt;sub&gt;d&lt;/sub&gt;和r&lt;sub&gt;e&lt;/sub&gt;必须是单调递增函数，而且满足&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090000006-940024313.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;，也及时要求r&lt;sub&gt;d&lt;/sub&gt;和r&lt;sub&gt;e&lt;/sub&gt;在分界处是连续的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个典型的处理如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　      &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090143483-378248702.png&quot; alt=&quot;&quot; height=&quot;20&quot;/&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090543237-593324841.png&quot; alt=&quot;&quot; height=&quot;20&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090155612-1692956226.png&quot; alt=&quot;&quot; height=&quot;21&quot;/&gt;        else&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中在做细节处理时，论文建议的f&lt;sub&gt;d&lt;/sub&gt;和f&lt;sub&gt;e&lt;/sub&gt;如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090422288-677479839.png&quot; alt=&quot;&quot; width=&quot;90&quot;/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201090442239-1568460453.png&quot; alt=&quot;&quot; width=&quot;80&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       其对应的曲线如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　           　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201091210118-793414556.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      简单的分析下图片的直观认识吧，我们看看detail smoothing的曲线，在输入为g&lt;sub&gt;0&lt;/sub&gt;时输出为g&lt;sub&gt;0，&lt;/sub&gt;在小于g&lt;sub&gt;0&lt;/sub&gt;的б&lt;sub&gt;r&lt;/sub&gt; 范围内，输出是大于输入的，而在大于g&lt;sub&gt;0&lt;/sub&gt;的б&lt;sub&gt;r &lt;/sub&gt;范围内，输出是小于于输入的。也就是说在g&lt;sub&gt;0&lt;/sub&gt;附近的像素是朝向g&lt;sub&gt;0&lt;/sub&gt;进一步靠近的，从而使得这一块的细节都趋于一致，而在远离g&lt;sub&gt;0&lt;/sub&gt;的位置，像素未受到影响，这样在整体的表现上如果g&lt;sub&gt;0&lt;/sub&gt;在原始图像中属于某个平坦区域，则其周边的像素也慢慢往g&lt;sub&gt;0&lt;/sub&gt;靠近，如果他属于边缘，则周边的像素基本未改变，这个时候通过金字塔则可以把这种改变通过领域的关系一步一步的代入到拉普拉斯系数中，这也是所谓的局部带来的好处。在detail enhancement的增强中，则是一个相反的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      但在&lt;a href=&quot;http://imagine.enpc.fr/~aubrym/projects/llf/&quot; target=&quot;_blank&quot;&gt;Fast Local Laplacian Filters: Theory and Applications&lt;/a&gt;一文配套的代码中，我们看到作者并没有使用上述曲线来处理，而是使用了这样的一个函数： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201093447985-393764598.png&quot; alt=&quot;&quot;/&gt;  其中sigma一般取值0.15左右，f为用户调节参数，但f小于0时，起到平滑作用，大于0时，起到细节增强作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注意上述公式中的i和g&lt;sub&gt;0&lt;/sub&gt;都必须是归一化后的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下左图示出了此曲线（高斯曲线）和原始论文曲线（指数曲线）的差异，其中g&lt;sub&gt;0&lt;/sub&gt;取值为0.5。可见此曲线在整个定义域是非常光滑的，在远离g&lt;sub&gt;0&lt;/sub&gt;处并没有像原始论文那样对像素毫无影响，但影响也是非常小了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201102455999-1927937592.png&quot; alt=&quot;&quot;/&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201102632098-1603349272.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上图的右侧部分为f取不同值时的曲线分布情况，我们注意到当f=-2或者f=4时的曲线出现了异常情况，他已经不符合原始论文提出的曲线是单调递增函数的要求，此时图像也会出现一些异常情况，后续会给出这个异常的结果图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么实际上我们还有很多其他的曲线可以使用，比如有关代码里列出如下的曲线函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;%This &lt;span&gt;is&lt;/span&gt; just a toy example!&lt;span&gt;
function y&lt;/span&gt;=&lt;span&gt;remapping_function(x)
   &lt;/span&gt;% y=(x-&lt;span&gt;0.1&lt;/span&gt;).*(x&amp;gt;&lt;span&gt;0.1&lt;/span&gt;)+(x+&lt;span&gt;0.1&lt;/span&gt;).*(x&amp;lt;-&lt;span&gt;0.1&lt;/span&gt;); %&lt;span&gt;smoothing
    y&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;.*x.*(abs(x)&amp;lt;&lt;span&gt;0.1&lt;/span&gt;)+(x+&lt;span&gt;0.2&lt;/span&gt;).*(x&amp;gt;&lt;span&gt;0.1&lt;/span&gt;)+(x-&lt;span&gt;0.2&lt;/span&gt;).*(x&amp;lt;-&lt;span&gt;0.1&lt;/span&gt;); %&lt;span&gt;enhancement
end&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　实际测试也是没有问题的，也能达到类似的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   好了，下面我们来集中力量来实现上述新代码的C++优化。首先，为了较为准确的实现这个过程，我们先把图像数据转换为浮点数。但是我们可能不做归一化的处理，即浮点的范围还是控制在0和255之间。那么金字塔建立的优化过程再次不在赘述，可以参考我的相关博客。核心的优化就在第16到22行代码，我们先来处理第16行代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　I_remap=fact*(I-ref).*exp(-(I-ref).*(I-ref)./(2*sigma*sigma))；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们将他翻译为普通的C++代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;float&lt;/span&gt; Inv = &lt;span&gt;1.0f&lt;/span&gt; / &lt;span&gt;255.0f&lt;/span&gt; / &lt;span&gt;255.0f&lt;/span&gt; / (&lt;span&gt;2&lt;/span&gt; * sigma *&lt;span&gt; sigma);;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = &lt;span&gt;0&lt;/span&gt;; I &amp;lt; GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Height * GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Width; I++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; I = GaussPyramid[&lt;span&gt;0&lt;/span&gt;][I], Diff = I - &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
    GaussPyramidT[I] &lt;/span&gt;= IM_ClampF(I + f * Diff * exp(-Diff * Diff * Inv), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;  GaussPyramid[0]其实就是原始输入图像，GaussPyramidT是临时的高斯金字塔数据，IM_ClampF是个裁剪限幅函数，主要是为了让数据不产生溢出，实际测试好像不限幅也没什么大的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  这段代码是非常耗时的，第一，他是对原始图大小进行处理的，第二，exp的计算是个非常缓慢的过程，因此，我们尝试了SSE处理。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;4&lt;/span&gt;, Block = (GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Height * GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Width) /&lt;span&gt; BlockSize;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = &lt;span&gt;0&lt;/span&gt;; I &amp;lt; Block * BlockSize; I +=&lt;span&gt; BlockSize)
{
    __m128 V &lt;/span&gt;= _mm_loadu_ps(GaussPyramid[&lt;span&gt;0&lt;/span&gt;] +&lt;span&gt; I);
    __m128 Diff &lt;/span&gt;= _mm_sub_ps(V, _mm_set1_ps(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;));
    __m128 Exp &lt;/span&gt;=&lt;span&gt; _mm_fexp_ps(_mm_neg_ps(_mm_mul_ps(_mm_mul_ps(Diff, Diff), _mm_set1_ps(Inv))));
    __m128 Dst &lt;/span&gt;=&lt;span&gt; _mm_add_ps(_mm_mul_ps(_mm_mul_ps(Diff, Exp), _mm_set1_ps(f)), V);
    Dst &lt;/span&gt;= _mm_min_ps(_mm_max_ps(Dst, _mm_setzero_ps()), _mm_set1_ps(&lt;span&gt;255.0f&lt;/span&gt;&lt;span&gt;));
    _mm_storeu_ps(GaussPyramidT[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] +&lt;span&gt; I, Dst);
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = Block * BlockSize; I &amp;lt; GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Height * GaussPyramid[&lt;span&gt;0&lt;/span&gt;].Width; I++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; I = GaussPyramid[&lt;span&gt;0&lt;/span&gt;][I], Diff = I - &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
    GaussPyramidT[I] &lt;/span&gt;= IM_ClampF(I + f * Diff * exp(-Diff * Diff * Inv), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　基本上是直接翻译，其中有些函数为自定义的，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    求负数&lt;/span&gt;
&lt;span&gt;inline __m128 _mm_neg_ps(__m128 a)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_sub_ps(_mm_setzero_ps(), a);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;http://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    快速的指数运算，精度一般&lt;/span&gt;
&lt;span&gt;inline __m128 _mm_fexp_ps(__m128 x)
{
    __m128i T &lt;/span&gt;= _mm_cvtps_epi32(_mm_add_ps(_mm_mul_ps(x, _mm_set1_ps(&lt;span&gt;1512775&lt;/span&gt;)), _mm_set1_ps(&lt;span&gt;1072632447&lt;/span&gt;&lt;span&gt;)));
    __m128i TL &lt;/span&gt;=&lt;span&gt; _mm_unpacklo_epi32(_mm_setzero_si128(), T);
    __m128i TH &lt;/span&gt;=&lt;span&gt; _mm_unpackhi_epi32(_mm_setzero_si128(), T);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_movelh_ps(_mm_cvtpd_ps(_mm_castsi128_pd(TL)), _mm_cvtpd_ps(_mm_castsi128_pd(TH)));
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们测试发现，虽然使用的是精度一般版本的exp函数，但是对最终的结果影响并不大，但是速度的提升则非常明显，而所谓的Clamp处理则可以直接使用min和max函数实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着就是第18到22行代码，我们直接翻译为普通C语言如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;for&lt;/span&gt; (level = &lt;span&gt;1&lt;/span&gt;; level &amp;lt; n_levels - &lt;span&gt;1&lt;/span&gt;; level++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = &lt;span&gt;0&lt;/span&gt;; I &amp;lt; (PryamidW[level] * PryamidH[level]; I++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (abs(GaussPyramid[level][I] - &lt;span&gt;ref&lt;/span&gt;) &amp;lt; discretisation_step)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    插值计算，表示在有效的范围内&lt;/span&gt;
&lt;span&gt;        {
            LaplacePyramid[level][I] &lt;/span&gt;+= (LaplacePyramidT[level][I] * (&lt;span&gt;1&lt;/span&gt; - abs(GaussPyramid[level][I] - &lt;span&gt;ref&lt;/span&gt;) /&lt;span&gt; discretisation_step));
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　重点是处理内部的循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为内部循环里有条件判断和跳转，一般来说是不利于SSE处理的，如果要用SSE处理，其实施要点是找到某个参数，是的跳转和不跳转通过该参数能用同一个公式计算，我们观察上式，但不符合那个判断跳转时，我们可以通过把LaplacePyramidT[level][I]这个变量用0值代替，这样可保证结果不变。另外一个可以考虑的地方就是，如果存在较多的多数据同时不满足条件的情况，可以使用_mm_movemask_ps的函数来做处理，如果他返回值为0，我们可以不继续后续的处理，否则，就统一处理，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;4&lt;/span&gt;, Block = (PryamidW[level] * PryamidH[level]) /&lt;span&gt; BlockSize;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *D =&lt;span&gt; LaplacePyramid[level];
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *S =&lt;span&gt; GaussPyramid[level];
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; *T =&lt;span&gt; LaplacePyramidT[level];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = &lt;span&gt;0&lt;/span&gt;; I &amp;lt; Block * BlockSize; I +=&lt;span&gt; BlockSize)
{
    __m128 Abs &lt;/span&gt;= _mm_abs_ps(_mm_sub_ps(_mm_loadu_ps(S + I), _mm_set1_ps(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;)));
    __m128 Cmp &lt;/span&gt;=&lt;span&gt; _mm_cmplt_ps(Abs, _mm_set1_ps(Step));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_mm_movemask_ps(Cmp) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        __m128 LT &lt;/span&gt;= _mm_blendv_ps(_mm_setzero_ps(), _mm_loadu_ps(T +&lt;span&gt; I), Cmp);
        _mm_storeu_ps(D &lt;/span&gt;+ I, _mm_sub_ps(_mm_add_ps(_mm_loadu_ps(D + I), LT), _mm_mul_ps(LT, _mm_mul_ps(Abs, _mm_set1_ps(&lt;span&gt;1.0f&lt;/span&gt; /&lt;span&gt; discretisation_step)))));
    }
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = Block * BlockSize; I &amp;lt; PryamidW[level] * PryamidH[level]; I++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中用到的一些自定义函数如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    浮点数据的绝对值计算&lt;/span&gt;
&lt;span&gt;inline __m128 _mm_abs_ps(__m128 v)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0x7fffffff&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; mask = *(&lt;span&gt;float&lt;/span&gt;*)&amp;amp;&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_and_ps(v, _mm_set_ps1(mask));
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过以上优化方式，我们最终的测试结果表明针对2M大小的图像，平均处理时间稳定在145ms左右（取样数设置为12），相对原先的情况已经有了非常大的提高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在耗时组成方面，我们测试数据如下，临时的高斯-拉普拉斯金字塔的构建85ms， 映射函数耗时30ms， 填充拉普拉斯金字塔数据30ms。可见大部分时间还是用在金字塔的处理上。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;我们已经知道，整数版本的（8位或者32位的）金字塔的建立要比浮点版本快很多，特备是8位的金字塔数据，如果我们使用整数版本的效果会如何呢，我们进行了使用8位金子塔的版本进行了测试，当然，为了精度，拉普拉斯金字塔的数据部分还是需要使用singed short类型来保存，测试的效果表明，整数版本的精度也是足够的。如下图所示： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201121855775-461532675.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201121930164-83808570.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201122014126-367765589.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　  　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　浮点版本　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　8位金字塔版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　仔细对比，会有一点点的差异，但是基本上靠眼睛是区分不出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 但是，使用8位金字塔的第一个优势是建立金字塔的速度非常快，第二，函数的映射部分，我们可以使用查找表的方式快速实现（取整数结果），第三，填充拉普拉斯金字塔这一块使用相关整数处理的SSE指令，也可以一次性处理8个像素了，因此都大为加速，综合这三个优势，我们最终的优化结果做到了2M像素60ms的处理速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;a href=&quot;http://imagine.enpc.fr/~aubrym/projects/llf/&quot; target=&quot;_blank&quot;&gt;Fast Local Laplacian Filters: Theory and Applications&lt;/a&gt;一文中，作者也给出了他优化的处理速度，如下所示： &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201122832445-848456570.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可见，同比，我的速度比他的实现快了很多很多倍，当然还是没有赶上GPU的速度，但是也相差不大，比如我的速度折算到4M像素，需要120ms，他的GPU版本比如的快了2.5倍左右，但是我用的是单线程的，如果考虑多线程，还是有一定的提速空间（虽然笨算法不易多线程了）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再者，我们还是来讨论下映射函数的问题，前面讲了，快速版本的代码使用的映射函数并没有使用原始论文的版本，所以我们尝试把这个替换一下，得到的结论就是，原始版本的映射函数不适合插值使用，效果如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201133815704-843400894.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201133824529-650065854.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201134206577-104727166.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　采样数为12(б&lt;sub&gt;r&lt;/sub&gt; =0.16, alpha = 0.3)时的效果　　　　　　　　　　　　　　　  采样为32(б&lt;sub&gt;r &lt;/sub&gt;=0.16, alpha = 0.3)时的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201133830367-1319298976.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201133838592-2112728458.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　　直接实现的效果（256色阶）　　　　　　　　　　　　　　　　　　　　　　　　　带防止噪音扩大的效果&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可见这个映射函数在采样率较小时的效果是非常差的，具有明显的色块效果，而只有不进行任何下采样时效果才较为满意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而注意到上面的第四个图，可以看到在原来平坦的区域里出现很多不起眼的噪点，在原始论文里作者也注意到了这个问题，他提出了一个解决方案，即限制最小的差异的放大程度，当我们需要增强细节时（alpha &amp;lt; 1），使用一个混合公式来修正函数f&lt;sub&gt;d&lt;/sub&gt;的值。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　         &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201135602634-1542609139.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;式中的系数T值由abs(i-g&lt;sub&gt;0&lt;/sub&gt;)/бr 决定，当该值小于0.01时，为0，当大于0.02时，为1，而介于两者之间是使用一个平滑函数修正，这样做的结果就是使得在和g&lt;sub&gt;0&lt;/sub&gt;特别接近时，相关的像素不会得到修正，而噪音的引起也就是因为这些特别相近的像素经过原来的处理后会变得差异很大引起的。所以这样做就可以有效地避免该问题，一个常用的平滑函数如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inline &lt;span&gt;float&lt;/span&gt; IM_SmoothStep(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; t)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; t * t * (&lt;span&gt;3&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; t);　　　　　　　　//　　powf(t, 2.0f) * powf(t - 2, 2.0f);
}　　&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　此时的修正曲线如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201140218427-1481864021.png&quot; alt=&quot;&quot;/&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至于为什么原始论文的曲线不适合采样，我分析可能还是因为他的曲线是由两个函数组合而成的，而中间的曲线部分在采样时不能够获得足够的取样点，而造成数据丢失，而改进后的论文中的曲线是一条光滑连续的曲线，其曲率变化也非常自然，很少的取样点就可以获得较为理想的效果。同时，我们也主要到高斯曲线的映射结果似乎不存在噪音过增强的现象，而且也不需要采用类似指数映射那种处理方式来减少该问题，如果采用，反而可能会对结果图像带来光晕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们分析另外一个问题，现在我们推荐使用高斯曲线来进行数据的映射，当函数中f取值小于0时，是处于一个去燥或者说平滑图像的作用，同时还能有效地保留边缘，当f大于0时，起到了细节增强或者说锐化的作用，因此，f小于0时该滤波器的作用相当于一个保边滤波器，比如他也可以有效地用在磨皮中（f = -1左右）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201141248552-1645562381.jpg&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201141221344-1054055355.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　但是当f过分的小或者过分的大时，比如f=-2或f=4时，如上述曲线所示，此时的高斯曲线已经不是单调递增函数了，此时的图像会出现什么效果，我们做了测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201141825307-937272857.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201141846500-272215936.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201141854904-962956360.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　           原图　　　　　　　　　　　　　　　　　　　　　　　　　　　    　f = -2　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　f = 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们看看中间这幅图，可以看到天空中的云原先的白色已经变成了灰色了，但是整个图像还是处于平滑的状态，明显处于一个结果错误的状态，而后面一个图的增强程度似乎很过，但是相对于中间的部分而言要稍微合理一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　引起该结果的一个核心原因正如上述所言，映射函数出了问题，在此时的映射函数不同的两个输入，可以有相同的输出。所以在使用高斯曲线时一定要注意这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　其他细节：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在论文里还提到其他的一些细节，比如说为了提高速度，我们可以只对底层的若干层拉普拉斯金字塔做上述操作，而更高层的金字塔数据不做处理，也可以只对高层的拉普拉斯金字塔进行重构，而底层的不做处理，特别是底层的不错处理，会极大的提高速度，毕竟第二层的数据只有第一层数据的1/4了，那效果如何了，我们下面给出了一些结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143421265-224974984.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143429142-1996206145.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143436080-314434051.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 f =2, 0层金字塔不处理　　　　　　　　　　　　　　　　　　　　       　f = 4, 0层金字塔不处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可见这种修改虽能加快速度，但效果不好，虽有一定的细节增强效果，但0层的影响太强烈。在看另外一个效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143848369-1276338068.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143856933-1170898534.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201143904977-1027576323.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　                       0层不处理（f = -1）　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　0层处理（f = -1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　中间的结果是0层不处理的结果，我们惊喜的发现这个结果和&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl10_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Imageshop/p/4709710.html&quot;&gt;简单探讨可牛影像软件中具有肤质保留功能的磨皮算法及其实现细节&lt;/a&gt; 一文中的有几分的相似，我们分析认为当0层不处理时，原图的纹理就保存原始0层的拉普拉斯金字塔中，而0层以后的数据都进行了平滑的处理，这样数据在最后的叠合后就呈现了纹理保留（肤质保留）的功能，这也是所谓的巧合吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我们之前也描述几篇保边滤波器的文章，他们通常只具有保边效果，而这里的拉普拉斯滤波器确内在的可以实现保边和细节增强的作用，而且改变使用不同的映射函数还可以实现tone mapping、style transefer等较为高级的功能，不失为一个开创性的算法，我个人觉得他从传统的一些Edge-aware算法中能脱颖而出，利用最常见和简单的金字塔算法实现通用的效果，真的有点类似当然何凯明的暗通道算法一样。不过好像从作者发表该论文后，还少有作者进行进一步的算法拓展和应用，这也是比较郁闷之处啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，我们还拿这个算法和其他算法的效果做个对比，来看看这个算法的强大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145046612-1069610513.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145222452-638203941.png&quot; alt=&quot;&quot;/&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　USM锐化（半径=20，Amount =200, Threshold = 0）    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145315893-1478643228.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145516835-2011537198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　基于导向滤波的锐化（数量 = 200）　　　　　　　　　　　　　　　　　　　　　　　　　　局部金字塔滤波（采样数=12，f = 2)    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;可以看到，局部金字塔在边缘保留这一块做的特别的好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于医学图像，该算法也能很好的起到增强作用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145827553-687253662.png&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201902/349293-20190201145811668-1827192333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原始的浑浊图像经过处理后变得非常清晰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　医学图像通常有很多都是16位的，该算法对16位依然有效，只是处理过程要稍作修改即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　   Demo下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201811/349293-20181103235836001-680351219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 07:08:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<og:description>基于局部拉普拉斯金字塔的Edge-aware滤波器是在2011年由Adobe 公司的研究员Sylvain Paris（大神级人物，写了很多文章）提出的，我在4年前曾经参考有关代码实现过这个算法，但是速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/10344048.html</dc:identifier>
</item>
<item>
<title>【Python3爬虫】百度一下，坑死你？ - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/10343549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/10343549.html</guid>
<description>&lt;p&gt;&lt;span&gt;这个标题是借用的路人甲大佬的一篇文章的标题（&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GOGldeDi30PzIwGaGOD6uA&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;百度一下，坑死你&lt;/strong&gt;&lt;/a&gt;），而且这次的爬虫也是看了这篇文章后才写出来的，感兴趣的可以先看下这篇文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前段时间有篇文章《&lt;strong&gt;搜索引擎百度已死&lt;/strong&gt;》引起了很多讨论，而百度对此的回复是：&lt;strong&gt;百家号的内容在百度搜索结果中不超过10%&lt;/strong&gt;。但是这个10%是第一页的10%还是所有数据的10%，我们不得而知，但是由于很多人都只会看第一页的内容，而如果这第一页里有十分之一的内容都来自于百家号，那搜索体验恐怕不怎么好吧？然后&lt;/span&gt;&lt;span&gt;我这次写的爬虫就是把百度上面的热搜事件都搜索一下，然后把搜索结果的第一页上的标题链接提取出来，最后对这些链接进行一些简单的分析，看看百家号的内容占比能有多少。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1.页面分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先打开网页查看百度的热点事件，页面如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201901/1450803-20190131191638235-2003497575.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次我主要对今日热点、娱乐热点、体育热点进行了爬取，每个热点下面有50条热点事件，然后对每个事件进行搜索，比如第一条--马云的福字：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201901/1450803-20190131192225005-399729803.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到搜索结果的第一页上有很多标题，然后对这些标题的链接进行爬取，再保存到一个txt文件里，最后对这些数据进行分析。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.主要代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）获取真实链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些搜索结果页面上的链接都是经过加密的，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201901/1450803-20190131192708720-1311311702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们爬取得到的链接都是&lt;span class=&quot;webkit-html-attribute-value&quot;&gt;http://www.baidu.com/link?url=VfA2jxmqJdYt1U-G0wHjWIXglVEi-WCxpa8aaMCeOzkqK-c5CgYngPiJT6_-kmWE3ePTHCpgYlX5oq9SQDJgEukKCY19o26JlS1pEIgnlupbw0Ss9Ro3gQjYVuJljdxyBPfiDUJhM9ODV_0mKnrUhESJ95Az1OnB6mMScmCXiUi这种，但是我们点进去之后就能得到真实的链接https://www.baidu.com/s?tn=news&amp;amp;rtt=1&amp;amp;bsst=1&amp;amp;wd=%E9%A9%AC%E4%BA%91%E7%9A%84%E7%A6%8F%E5%AD%97&amp;amp;cl=2&amp;amp;origin=ps，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;webkit-html-attribute-value&quot;&gt;那我们要怎么得到真实的链接呢？相关代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_real_url(self, fake_url):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取真实的链接&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         res = requests.get(fake_url, headers=&lt;span&gt;self.headers)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         real_url =&lt;span&gt; res.url
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）数据处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里我总共爬取了1051条链接，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201902/1450803-20190201134931854-764485907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这样的数据是明显没有办法进行分析的，所以需要进行一下处理，比如将https://baijiahao.baidu.com/s?id=1624053575252859170&amp;amp;wfr=spider&amp;amp;for=pc变成&lt;/span&gt;&lt;span&gt;baijiahao.baidu，相关代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; href = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://baijiahao.baidu.com/s?id=1624053575252859170&amp;amp;wfr=spider&amp;amp;for=pc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; match = re.match(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(http[s]?://.+?[com,cn,net]/)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, href) 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; href =&lt;span&gt; match.group()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; href = href.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; href = href[href.index(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + 3:].rstrip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(href)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; baijiahao.baidu&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）数据分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里主要使用了&lt;/span&gt;&lt;span&gt;matplotlib绘图帮助我们分析数据。首先需要统计出各个网站出现的次数，然后进行一个排序，得到排名前十的网站，结果如下（前面是网站，后面是出现次数）：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;https://baijiahao.baidu.com/  188&lt;br/&gt;https://www.baidu.com/  114&lt;br/&gt;http://www.sohu.com/  60&lt;br/&gt;https://news.china.com/  29&lt;br/&gt;http://www.guangyuanol.cn/  27&lt;br/&gt;http://image.baidu.com/ 24&lt;br/&gt;http://3g.163.com/  20&lt;br/&gt;https://sports.qq.com/  19&lt;br/&gt;https://www.iqiyi.com/ 17&lt;br/&gt;https://baike.baidu.com/  17&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;可以看到百家号出现的次数是最多的。然后进行绘图分析，这里主要是绘图的代码，因为使用的是百分数，所以在绘图的时候会稍微麻烦一点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; plot(self, index_list, value_list):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    b = self.ax.barh(range(len(index_list)), value_list, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=0.8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加数据标签&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; rect &lt;span&gt;in&lt;/span&gt;&lt;span&gt; b:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         w =&lt;span&gt; rect.get_width()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.ax.text(w, rect.get_y() + rect.get_height() / 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(w),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                      ha=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, va=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置Y轴刻度线标签&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    self.ax.set_yticks(range(len(index_list)))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    self.ax.set_yticklabels(index_list)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置X轴刻度线&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     lst = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(i) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 20, 2&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    self.ax.set_xticklabels(lst)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     plt.subplots_adjust(left=0.25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     plt.xlabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;占比&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     plt.ylabel(&lt;span&gt;&quot;网站&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     plt.savefig(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bjh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已保存为bjh.jpg！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;由于每个事件的搜索结果都是不同的，所以在解析网页的时候可能会出错，然后就是请求频率太高了会被ban掉，而且有时候UA会被识别出来然后就被ban掉了，运行情况如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201901/1450803-20190131193949808-389165509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最后看一下绘制出来的图片：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201902/1450803-20190201142358134-1055740394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到&lt;strong&gt;百家号的内容占比达到了17%&lt;/strong&gt;，而排在第二的也是百度自家的产品，内容占比也达到了10%。当然了，由于搜索的都是百度上的热搜事件，所以得到的结果百度自家的内容会多一点，但是光百家号的内容就占了17%，是不是也太多了点呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;完整代码已上传到&lt;a href=&quot;https://github.com/TM0831/Spiders/tree/master/BaiJiaHao&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 06:47:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>一、写在前面 这个标题是借用的路人甲大佬的一篇文章的标题（百度一下，坑死你），而且这次的爬虫也是看了这篇文章后才写出来的，感兴趣的可以先看下这篇文章。 前段时间有篇文章《搜索引擎百度已死》引起了很多讨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TM0831/p/10343549.html</dc:identifier>
</item>
<item>
<title>嘿！为你的应用创建滚动日志吧？ - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/10343855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/10343855.html</guid>
<description>&lt;p&gt;　　一般作为服务端的应用，必须要有相应的日志，否则问题怎么排查呢？&lt;/p&gt;
&lt;p&gt;　　而日志怎么打印，也是一个技术活。不然java中也不会存在N多厂商争相提供日志框架了！&lt;/p&gt;
&lt;p&gt;　　而日志滚动则往往也是刚需，毕竟没人能保证日志的量及可阅读性。日志滚动实现主要有两个大方向：&lt;/p&gt;
&lt;p&gt;　　　　1.  让应用服务自行打印，打印到时也完全由应用决定！&lt;/p&gt;
&lt;p&gt;　　　　2. 借助第三方的工具进行日志打印，这种一般要借助于控制台或者agent！&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;3. 让日志框架提供日志滚动功能，自行管理日志；&lt;/span&gt;这样做有个好处就是，应用自带，无需外部处理。坏处就是要完全依赖该应用，会影响该应用的性能，且如果该应用存在bug，则功能就不敢保证了。（稍后我会以logback的日志滚动说明）&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;4. 借助第三方的工具进行日志滚动；这样做的好处是滚动功能更独立，对代码无入侵&lt;/span&gt;，即使真的有问题，大不了把它干掉也没关系；另外，第三方工具不会因为应用本身的bug而导致滚动异常，从而保证了有足够的排查依据。（稍后我会以cronolog进行讲解滚动实现）；&lt;/p&gt;

&lt;h2&gt;具体日志滚动实现&lt;/h2&gt;
&lt;p&gt;1. 使用应用打印的方式：如logback的rollingpolicy，则自带滚动日志功能！但是坑多！&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.1. 首先我们看下日志滚动的配置&lt;/span&gt;：（在 logback.xml 配置）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出到文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${log_path}/api.ln.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${log_path}/api.%d{yyyy-MM-dd_HH}.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; keep 10 days' worth of history capped at 8GB total size &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;totalSizeCap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8GB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;totalSizeCap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里配置以时间为滚动标准，每小时滚动一次！最大保留10天日志，总共大小不超过8G。我们后面来看下他的效果！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2. 看下滚动代码！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先，日志滚动会有相应的线程一直在跑（不管是应用实现还是第三方实现都是这样，否则怎么随时检测滚动时机呢）！&lt;/p&gt;
&lt;p&gt; 　　在 EventPlayer中，有个play方法，此时会决断是否是 EndEvent, 如果是的话就会调用后台线程生成！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.joran.spi.EventPlayer&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; play(List&amp;lt;SaxEvent&amp;gt;&lt;span&gt; aSaxEventList) {
        eventList &lt;/span&gt;=&lt;span&gt; aSaxEventList;
        SaxEvent se;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (currentIndex = 0; currentIndex &amp;lt; eventList.size(); currentIndex++&lt;span&gt;) {
            se &lt;/span&gt;=&lt;span&gt; eventList.get(currentIndex);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (se &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; StartEvent) {
                interpreter.startElement((StartEvent) se);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invoke fireInPlay after startElement processing&lt;/span&gt;
&lt;span&gt;                interpreter.getInterpretationContext().fireInPlay(se);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (se &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BodyEvent) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invoke fireInPlay before characters processing&lt;/span&gt;
&lt;span&gt;                interpreter.getInterpretationContext().fireInPlay(se);
                interpreter.characters((BodyEvent) se);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rollingPollicy 在此处调唤醒&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (se &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; EndEvent) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invoke fireInPlay before endElement processing&lt;/span&gt;
&lt;span&gt;                interpreter.getInterpretationContext().fireInPlay(se);
                interpreter.endElement((EndEvent) se);
            }

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，几经转换，就到了Interpreter 了，这里会做一个死循环，一直在监听！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.joran.spi.Interpreter&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; callEndAction(List&amp;lt;Action&amp;gt;&lt;span&gt; applicableActionList, String tagName) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (applicableActionList == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; logger.debug(&quot;About to call end actions on node: [&quot; + localName + &quot;]&quot;);&lt;/span&gt;
        Iterator&amp;lt;Action&amp;gt; i =&lt;span&gt; applicableActionList.iterator();

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {
            Action action &lt;/span&gt;=&lt;span&gt; i.next();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; now let us invoke the end method of the action. We catch and report
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any eventual exceptions&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                action.end(interpretationContext, tagName);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ActionException ae) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; at this point endAction, there is no point in skipping children as
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; they have been already processed&lt;/span&gt;
                cai.addError(&quot;ActionException in Action for tag [&quot; + tagName + &quot;]&quot;&lt;span&gt;, ae);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no point in setting skip&lt;/span&gt;
                cai.addError(&quot;RuntimeException in Action for tag [&quot; + tagName + &quot;]&quot;&lt;span&gt;, e);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，就会调用 RollingPolicy 的start()了，这里是 TimeBasedRollingPollicy .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.rolling.TimeBasedRollingPolicy&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set the LR for our utility object&lt;/span&gt;
        renameUtil.setContext(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; find out period from the filename pattern&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (fileNamePatternStr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            fileNamePattern &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileNamePattern(fileNamePatternStr, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);
            determineCompressionMode();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            addWarn(FNP_NOT_SET);
            addWarn(CoreConstants.SEE_FNP_NOT_SET);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(FNP_NOT_SET +&lt;span&gt; CoreConstants.SEE_FNP_NOT_SET);
        }

        compressor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Compressor(compressionMode);
        compressor.setContext(context);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wcs : without compression suffix&lt;/span&gt;
        fileNamePatternWithoutCompSuffix = &lt;span&gt;new&lt;/span&gt; FileNamePattern(Compressor.computeFileNameStrWithoutCompSuffix(fileNamePatternStr, compressionMode), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);

        addInfo(&lt;/span&gt;&quot;Will use the pattern &quot; + fileNamePatternWithoutCompSuffix + &quot; for the active file&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compressionMode ==&lt;span&gt; CompressionMode.ZIP) {
            String zipEntryFileNamePatternStr &lt;/span&gt;=&lt;span&gt; transformFileNamePattern2ZipEntry(fileNamePatternStr);
            zipEntryFileNamePattern &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileNamePattern(zipEntryFileNamePatternStr, context);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认会使用 DefaultTimeBasedFileNamingAndTriggeringPolicy 进行滚动&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (timeBasedFileNamingAndTriggeringPolicy == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            timeBasedFileNamingAndTriggeringPolicy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultTimeBasedFileNamingAndTriggeringPolicy&amp;lt;E&amp;gt;&lt;span&gt;();
        }
        timeBasedFileNamingAndTriggeringPolicy.setContext(context);
        timeBasedFileNamingAndTriggeringPolicy.setTimeBasedRollingPolicy(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        timeBasedFileNamingAndTriggeringPolicy.start();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy.isStarted()) {
            addWarn(&lt;/span&gt;&quot;Subcomponent did not start. TimeBasedRollingPolicy will not start.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the maxHistory property is given to TimeBasedRollingPolicy instead of to
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the TimeBasedFileNamingAndTriggeringPolicy. This makes it more convenient
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for the user at the cost of inconsistency here.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (maxHistory !=&lt;span&gt; UNBOUND_HISTORY) {
            archiveRemover &lt;/span&gt;=&lt;span&gt; timeBasedFileNamingAndTriggeringPolicy.getArchiveRemover();
            archiveRemover.setMaxHistory(maxHistory);
            archiveRemover.setTotalSizeCap(totalSizeCap.getSize());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cleanHistoryOnStart) {
                addInfo(&lt;/span&gt;&quot;Cleaning on start up&quot;&lt;span&gt;);
                Date now &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(timeBasedFileNamingAndTriggeringPolicy.getCurrentTime());
                cleanUpFuture &lt;/span&gt;=&lt;span&gt; archiveRemover.cleanAsynchronously(now);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isUnboundedTotalSizeCap()) {
            addWarn(&lt;/span&gt;&quot;'maxHistory' is not set, ignoring 'totalSizeCap' option with value [&quot;+totalSizeCap+&quot;]&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类start(), 设置启动标识，不允许多次调用初始化&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.start();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DefaultTimeBasedFileNamingAndTriggeringPolicy 的实现，设置类功能主要还是调用 TimeBasedFileNamingAndTriggeringPolicy 的方法，而其自身，则是处理一些异常情况,以及开启一个 Remover, 供具体的实现调用&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.start();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.isErrorFree())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(tbrp.fileNamePattern.hasIntegerTokenCOnverter()) {
            addError(&lt;/span&gt;&quot;Filename pattern [&quot;+tbrp.fileNamePattern+&quot;] contains an integer token converter, i.e. %i, INCOMPATIBLE with this configuration. Remove it.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        
        archiveRemover &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeBasedArchiveRemover(tbrp.fileNamePattern, rc);
        archiveRemover.setContext(context);
        started &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TimeBasedFileNamingAndTriggeringPolicy, 则实际处理日志的滚动逻辑了&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        DateTokenConverter&lt;/span&gt;&amp;lt;Object&amp;gt; dtc =&lt;span&gt; tbrp.fileNamePattern.getPrimaryDateTokenConverter();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dtc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;FileNamePattern [&quot; + tbrp.fileNamePattern.getPattern() + &quot;] does not contain a valid DateToken&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dtc.getTimeZone() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            rc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RollingCalendar(dtc.getDatePattern(), dtc.getTimeZone(), Locale.getDefault());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            rc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RollingCalendar(dtc.getDatePattern());
        }
        addInfo(&lt;/span&gt;&quot;The date pattern is '&quot; + dtc.getDatePattern() + &quot;' from file name pattern '&quot; + tbrp.fileNamePattern.getPattern() + &quot;'.&quot;&lt;span&gt;);
        rc.printPeriodicity(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;rc.isCollisionFree()) {
            addError(&lt;/span&gt;&quot;The date format in FileNamePattern will result in collisions in the names of archived log files.&quot;&lt;span&gt;);
            addError(CoreConstants.MORE_INFO_PREFIX &lt;/span&gt;+&lt;span&gt; COLLIDING_DATE_FORMAT_URL);
            withErrors();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        setDateInCurrentPeriod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(getCurrentTime()));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tbrp.getParentsRawFileProperty() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            File currentFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(tbrp.getParentsRawFileProperty());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentFile.exists() &amp;amp;&amp;amp;&lt;span&gt; currentFile.canRead()) {
                setDateInCurrentPeriod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(currentFile.lastModified()));
            }
        }
        addInfo(&lt;/span&gt;&quot;Setting initial period to &quot; +&lt;span&gt; dateInCurrentPeriod);
        computeNextCheck();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过如上初始化动作之后，发现并没有启动相应的轮循线程，所以这个点也是超出简单的认知了，不管怎么样，我们还要继续的！我们先来看一下 RollingFileAppender 的 append() 逻辑吧，毕竟它才是log的接入口！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.ch.qos.logback.core.rolling.RollingFileAppender, 其接入口为: UnsynchronizedAppenderBase.doAppend()
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.OutputStreamAppender&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; append(E eventObject) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isStarted()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 RollingFileAppender 实现&lt;/span&gt;
&lt;span&gt;        subAppend(eventObject);
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.ch.qos.logback.core.rolling.RollingFileAppender&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; subAppend(E event) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The roll-over check must precede actual writing. This is the
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; only correct behavior for time driven triggers.

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to synchronize on triggeringPolicy so that only one rollover
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; occurs at a time&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (triggeringPolicy) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (triggeringPolicy.isTriggeringEvent(currentlyActiveFile, event)) {
                rollover();
            }
        }

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.subAppend(event);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，rollover()就是其滚动逻辑！&lt;/p&gt;
&lt;p&gt;　　所以，看到了吧！这里的文件滚动，是依赖于外部写入的，原因是为了写入的线程安全，保证文件的完整性！&lt;/p&gt;
&lt;p&gt;　　换句话说就是，如果在滚动的这个时机，如果有外部写入，那么，文件得以滚动，否则，不会主动滚动文件！如果外部一直没日志写入，就不会存在日志滚动！&lt;/p&gt;
&lt;p&gt;　　我们先来看下滚动的条件吧: triggeringPolicy.isTriggeringEvent(currentlyActiveFile, event)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.rolling.DefaultTimeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isTriggeringEvent(File activeFile, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; E event) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; getCurrentTime();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (time &amp;gt;=&lt;span&gt; nextCheck) {
            Date dateOfElapsedPeriod &lt;/span&gt;=&lt;span&gt; dateInCurrentPeriod;
            addInfo(&lt;/span&gt;&quot;Elapsed period: &quot; +&lt;span&gt; dateOfElapsedPeriod);
            elapsedPeriodsFileName &lt;/span&gt;=&lt;span&gt; tbrp.fileNamePatternWithoutCompSuffix.convert(dateOfElapsedPeriod);
            setDateInCurrentPeriod(time);
            computeNextCheck();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上判断，即将当前时间与需要滚动的时间做对，大于滚动时间则返回 true, 并计算出下次需要滚动的时间，备用！&lt;/p&gt;
&lt;p&gt;接下来，我们看下，具体的文件滚动实现！两个主逻辑： 1. 将文件更名滚动； 2. 重新创建一个新的目标文件，以使后续可以写入！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Implemented by delegating most of the rollover work to a rolling policy.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rollover() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处lock为 ReentrantLock, 即是互斥锁，只能一个线程可访问！&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: This method needs to be synchronized because it needs exclusive
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; access while it closes and then re-opens the target file.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; make sure to close the hereto active log file! Renaming under windows
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; does not work for open files.&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.closeOutputStream();
            attemptRollover();
            attemptOpenFile();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动文件逻辑，调用设置的 policy 实现进行滚动，此处我设置的是 TimeBasedRollingPolicy&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attemptRollover() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            rollingPolicy.rollover();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RolloverFailure rf) {
            addWarn(&lt;/span&gt;&quot;RolloverFailure occurred. Deferring roll-over.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we failed to roll-over, let us not truncate and risk data loss&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.append = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.rolling.TimeBasedRollingPolicy rollover&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rollover() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RolloverFailure {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; when rollover is called the elapsed period's file has
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; been already closed. This is a working assumption of this method.&lt;/span&gt;
&lt;span&gt;
        String elapsedPeriodsFileName &lt;/span&gt;=&lt;span&gt; timeBasedFileNamingAndTriggeringPolicy.getElapsedPeriodsFileName();

        String elapsedPeriodStem &lt;/span&gt;=&lt;span&gt; FileFilterUtil.afterLastSlash(elapsedPeriodsFileName);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compressionMode ==&lt;span&gt; CompressionMode.NONE) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getParentsRawFileProperty() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                renameUtil.rename(getParentsRawFileProperty(), elapsedPeriodsFileName);
            } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else { nothing to do if CompressionMode == NONE and parentsRawFileProperty == null }&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getParentsRawFileProperty() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                compressionFuture &lt;/span&gt;=&lt;span&gt; compressor.asyncCompress(elapsedPeriodsFileName, elapsedPeriodsFileName, elapsedPeriodStem);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                compressionFuture &lt;/span&gt;=&lt;span&gt; renameRawAndAsyncCompress(elapsedPeriodsFileName, elapsedPeriodStem);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (archiveRemover != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Date now &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(timeBasedFileNamingAndTriggeringPolicy.getCurrentTime());
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cleanUpFuture =&lt;span&gt; archiveRemover.cleanAsynchronously(now);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TimeBasedRollingPolicy 的滚动方式为，重命名文件即可！即先获取外部设置的主写文件，然后根据新文件命名规则，生成一个新路径，然后重命名文件！重命名也是有些讲究的，有兴趣的同学可以查看下其重命名的实现！&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.rolling.helper.RenameUtil&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A relatively robust file renaming method which in case of failure due to
     * src and target being on different volumes, falls back onto
     * renaming by copying.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; src
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; RolloverFailure
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rename(String src, String target) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RolloverFailure {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (src.equals(target)) {
            addWarn(&lt;/span&gt;&quot;Source and target files are the same [&quot; + src + &quot;]. Skipping.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        File srcFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(src);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (srcFile.exists()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果目录不存在，会先去创建目录，所以你可以滚动到其他地方，而目录位置则不用管（权限除外）&lt;/span&gt;
            File targetFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(target);
            createMissingTargetDirsIfNecessary(targetFile);

            addInfo(&lt;/span&gt;&quot;Renaming file [&quot; + srcFile + &quot;] to [&quot; + targetFile + &quot;]&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; srcFile.renameTo(targetFile);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于直接重命名失败，则会再次尝试，如果在不同的分区，则会使用一次文件复制的方式进行一次重命名,具体做法是，先把文件copy到新地址，然后再将当前文件删除&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result) {
                addWarn(&lt;/span&gt;&quot;Failed to rename file [&quot; + srcFile + &quot;] as [&quot; + targetFile + &quot;].&quot;&lt;span&gt;);
                Boolean areOnDifferentVolumes &lt;/span&gt;=&lt;span&gt; areOnDifferentVolumes(srcFile, targetFile);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Boolean.TRUE.equals(areOnDifferentVolumes)) {
                    addWarn(&lt;/span&gt;&quot;Detected different file systems for source [&quot; + src + &quot;] and target [&quot; + target + &quot;]. Attempting rename by copying.&quot;&lt;span&gt;);
                    renameByCopying(src, target);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    addWarn(&lt;/span&gt;&quot;Please consider leaving the [file] option of &quot; + RollingFileAppender.&lt;span&gt;class&lt;/span&gt;.getSimpleName() + &quot; empty.&quot;&lt;span&gt;);
                    addWarn(&lt;/span&gt;&quot;See also &quot; +&lt;span&gt; RENAMING_ERROR_URL);
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RolloverFailure(&quot;File [&quot; + src + &quot;] does not exist.&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在做完日志重命名的滚动后，还有一个可能的工作，就是删除过期的日志！这个工作由 archiveRemover 来做，即之前在 DefaultTimeBasedFileNamingAndTriggeringPolicy 中创建的实例！ 会调用其 archiveRemover.cleanAsynchronously(now);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt;&lt;span&gt; cleanAsynchronously(Date now) {
        ArhiveRemoverRunnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArhiveRemoverRunnable(now);
        ExecutorService executorService &lt;/span&gt;=&lt;span&gt; context.getScheduledExecutorService();
        Future&lt;/span&gt;&amp;lt;?&amp;gt; future =&lt;span&gt; executorService.submit(runnable);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; future;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在做删除过期日志时，会先获取一个 ExecutorService, 进行异步删除, 而这个 ExecutorService 默认开启 8 常驻线程，进行日志处理！&lt;/p&gt;
&lt;p&gt;　　删除动作进行异步执行，从而避免影响业务执行！清理过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArhiveRemoverRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
        Date now;

        ArhiveRemoverRunnable(Date now) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.now =&lt;span&gt; now;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先清除当前文件，再根据设置的最大值，删除列表&lt;/span&gt;
&lt;span&gt;            clean(now);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (totalSizeCap != UNBOUNDED_TOTAL_SIZE_CAP &amp;amp;&amp;amp; totalSizeCap &amp;gt; 0&lt;span&gt;) {
                capTotalSize(now);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clean(Date now) {
 
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nowInMillis =&lt;span&gt; now.getTime();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for a live appender periodsElapsed is expected to be 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; periodsElapsed =&lt;span&gt; computeElapsedPeriodsSinceLastClean(nowInMillis);
        lastHeartBeat &lt;/span&gt;=&lt;span&gt; nowInMillis;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (periodsElapsed &amp;gt; 1&lt;span&gt;) {
            addInfo(&lt;/span&gt;&quot;Multiple periods, i.e. &quot; + periodsElapsed + &quot; periods, seem to have elapsed. This is expected at application start.&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; periodsElapsed; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处会根据 maxHistory 进行 -1 后清除文件，即: 只会清理 periodsElapsed 次历史日志&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; offset = getPeriodOffsetForDeletionTarget() -&lt;span&gt; i;
            Date dateOfPeriodToClean &lt;/span&gt;=&lt;span&gt; rc.getEndOfNextNthPeriod(now, offset);
            cleanPeriod(dateOfPeriodToClean);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cleanPeriod(Date dateOfPeriodToClean) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取需要删除的文件列表，然后依次删除，如果文件夹内的文件全部被删除，则将文件夹删除&lt;/span&gt;
        File[] matchingFileArray =&lt;span&gt; getFilesInPeriod(dateOfPeriodToClean);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File f : matchingFileArray) {
            addInfo(&lt;/span&gt;&quot;deleting &quot; +&lt;span&gt; f);
            f.delete();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parentClean &amp;amp;&amp;amp; matchingFileArray.length &amp;gt; 0&lt;span&gt;) {
            File parentDir &lt;/span&gt;= getParentDir(matchingFileArray[0&lt;span&gt;]);
            removeFolderIfEmpty(parentDir);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按规则匹配需要删除的文件&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; File[] getFilesInPeriod(Date dateOfPeriodToClean) {
        String filenameToDelete &lt;/span&gt;=&lt;span&gt; fileNamePattern.convert(dateOfPeriodToClean);
        File file2Delete &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filenameToDelete);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileExistsAndIsFile(file2Delete)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File[] { file2Delete };
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File[0&lt;span&gt;];
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清理历史文件逻辑，注意要想清理历史文件，就一定要设置好 totalSizeCap, 否则，不会进行自动清理！&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; capTotalSize(Date now) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; totalSize = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; totalRemoved = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; offset = 0; offset &amp;lt; maxHistory; offset++&lt;span&gt;) {
            Date date &lt;/span&gt;= rc.getEndOfNextNthPeriod(now, -&lt;span&gt;offset);
            File[] matchingFileArray &lt;/span&gt;=&lt;span&gt; getFilesInPeriod(date);
            descendingSortByLastModified(matchingFileArray);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File f : matchingFileArray) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; size =&lt;span&gt; f.length();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (totalSize + size &amp;gt;&lt;span&gt; totalSizeCap) {
                    addInfo(&lt;/span&gt;&quot;Deleting [&quot; + f + &quot;]&quot; + &quot; of size &quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileSize(size));
                    totalRemoved &lt;/span&gt;+=&lt;span&gt; size;
                    f.delete();
                }
                totalSize &lt;/span&gt;+=&lt;span&gt; size;
            }
        }
        addInfo(&lt;/span&gt;&quot;Removed  &quot; + &lt;span&gt;new&lt;/span&gt; FileSize(totalRemoved) + &quot; of files&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是一个删除过期日志的逻辑，主要有几个点：&lt;/p&gt;
&lt;p&gt;　　　　1. 只会进行清理 maxHistory 个周期的日志，即只会倒推 n 个周期内的日志；&lt;br/&gt;　　　　2. 只会清理文件大小大于 totalSizeCap 大小以后的文件；（这个文件强依赖文件列表的排序，这里的排序是根据最后修改时间来排的）&lt;br/&gt;　　　　3. maxHistory 并非最大保留天数，不要相信坑货文档，它只是一个扫描周期而已，不过这个值在上一步清理时会处理一次！&lt;/p&gt;
&lt;p&gt;还有个细节，咱们得再来看看：滚动时机，按天，按小时，按分钟？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动时机判定
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.rolling.helper.RollingCalendar&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Date getEndOfNextNthPeriod(Date now, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; periods) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; innerGetEndOfNextNthPeriod(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.periodicityType, now, periods);
    }
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Date innerGetEndOfNextNthPeriod(Calendar cal, PeriodicityType periodicityType, Date now, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numPeriods) {
        cal.setTime(now);
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (periodicityType) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_MILLISECOND:
            cal.add(Calendar.MILLISECOND, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_SECOND:
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.SECOND, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_MINUTE:
            cal.set(Calendar.SECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.MINUTE, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_HOUR:
            cal.set(Calendar.MINUTE, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.SECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.HOUR_OF_DAY, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_DAY:
            cal.set(Calendar.HOUR_OF_DAY, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MINUTE, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.SECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.DATE, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_WEEK:
            cal.set(Calendar.DAY_OF_WEEK, cal.getFirstDayOfWeek());
            cal.set(Calendar.HOUR_OF_DAY, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MINUTE, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.SECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.WEEK_OF_YEAR, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOP_OF_MONTH:
            cal.set(Calendar.DATE, &lt;/span&gt;1&lt;span&gt;);
            cal.set(Calendar.HOUR_OF_DAY, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MINUTE, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.SECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.set(Calendar.MILLISECOND, &lt;/span&gt;0&lt;span&gt;);
            cal.add(Calendar.MONTH, numPeriods);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unknown periodicity type.&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cal.getTime();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到其滚动的粒度: TOP_OF_MILLISECOND/TOP_OF_SECOND/TOP_OF_MINUTE/TOP_OF_HOUR/TOP_OF_DAY/TOP_OF_WEEK/TOP_OF_MONTH, 要说起来，粒度还是很细的哦！至于能不能真的有用，另说了！&lt;/p&gt;
&lt;p&gt;　　总结下logback的滚动方式！&lt;/p&gt;
&lt;p&gt;　　　　1. 在写入的时机进行滚动时机检查，合适则进行滚动；&lt;br/&gt;　　　　2. 同步滚动操作，保证线程安全；&lt;br/&gt;　　　　3. 使用重命名的方式进行滚动文件处理，如果失败会尝试一次不同分区的文件复制操作；&lt;br/&gt;　　　　4. 删除过期日志有两个时机，一个是判断当前周期前 n 个周期文件，如果有则删除；&lt;br/&gt;　　　　5. 对于设置了最大文件大小限制时，另外进行允许周期内的文件大小判定，超过大小后按修改时间最早删除；&lt;br/&gt;　　　　6. 触发滚动时机后，进行异步删除，一般不影响业务；&lt;/p&gt;
&lt;h4&gt;第三方工具如： 经典版 cronolog, 时尚版 logrotate（麻烦）&lt;/h4&gt;
&lt;p&gt;　　cronolog 是一个很古老的日志滚动工具了（应该已经不维护了）。它可以接收应用的输出日志，然后按照规则进行日志存储，比如按照年月日时分秒来保存文件！&lt;/p&gt;
&lt;p&gt;　　在网上其资料也已经不是很多了，很多人为了下载一个安装包也是绞尽脑汁啊！我也提供一个便捷安装包吧: 点此下载; &lt;/p&gt;
&lt;p&gt;　　其 github 项目地址: &lt;a href=&quot;https://github.com/fordmason/cronolog&quot; target=&quot;_blank&quot;&gt;https://github.com/fordmason/cronolog&lt;/a&gt; , 你完全可以自己去下载一个完全的包，自己安装！&lt;/p&gt;
&lt;p&gt;　　不过我还是要说一下其他两个安装方式:&lt;/p&gt;
&lt;p&gt;　　　　1. 直接使用 yum 源安装;(好像是要安装 epel 源) (推荐)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; cronolog -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2. 使用上面下载的包，直接解压即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar&lt;/span&gt; -zxvf cronolog-bin.&lt;span&gt;tar&lt;/span&gt;.gz -C /
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　3. 使用网上别人提供的源码安装&lt;/p&gt;

&lt;p&gt;　　说了这么多，还不是为了使用，如何与应用结合？&lt;/p&gt;
&lt;p&gt;　　其实只需要在你原来应用启动的后面再加上如下命令就可以了！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$&amp;gt; | /usr/local/sbin/cronolog -S /var/logs/ai_ln.out /var/logs/ai.%Y-%m-%d-%H.out
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完整的操作示例如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
exec nohup java -jar /www/aproj\.jar &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; | /usr/local/sbin/cronolog -S /var/logs/ai_ln.out /var/logs/ai.%Y-%m-%d-%H.out &amp;gt;&amp;gt; /dev/&lt;span&gt;null&lt;/span&gt; &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上命令是网上大部分人是这么写的，但是在某些情况下会有问题。比如我想远程启动这个服务的时候，就会一直拿不到结果！为啥？反正写成下面这个就完美了！即在 cronolog 之后，再加一个重定向输出 2&amp;gt;&amp;amp;1 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
exec nohup java -jar /www/aproj\.jar &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; | /usr/local/sbin/cronolog -S /var/logs/ai_ln.out /var/logs/ai.%Y-%m-%d-%H.out &amp;gt;&amp;gt; /dev/&lt;span&gt;null&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么，这个工具和应用自己输出日志相比，有什么好处吗？它是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;　　好处前面已经说了，对代码无侵入，控制更灵活！&lt;/p&gt;
&lt;p&gt;　　其实现原理为，接收一个标准的输入流，然后写入到相应文件即可！它不负责文件的删除，所以删除过期文件还得依赖另外的脚本！&lt;/p&gt;
&lt;p&gt;　　其主体源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
    
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Loop, waiting for data on standard input &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 
         * Read a buffer's worth of log file data, exiting on errors
         * or end of file.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        n_bytes_read &lt;/span&gt;= read(&lt;span&gt;0&lt;/span&gt;, read_buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; read_buf);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n_bytes_read == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            exit(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (errno ==&lt;span&gt; EINTR)
        {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (n_bytes_read &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            exit(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        }

        time_now &lt;/span&gt;= time(NULL) +&lt;span&gt; time_offset;
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * If the current period has finished and there is a log file
         * open, close the log file
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((time_now &amp;gt;= next_period) &amp;amp;&amp;amp; (log_fd &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
        {
            close(log_fd);
            log_fd &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 
         * If there is no log file open then open a new one.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (log_fd &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            log_fd &lt;/span&gt;=&lt;span&gt; new_log_file(template, linkname, linktype, prevlinkname,
                      periodicity, period_multiple, period_delay,
                      filename, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt; (filename), time_now, &amp;amp;&lt;span&gt;next_period);
        }

        DEBUG((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s (%d): wrote message; next period starts at %s (%d) in %d secs\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               timestamp(time_now), time_now, 
               timestamp(next_period), next_period,
               next_period &lt;/span&gt;-&lt;span&gt; time_now));

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Write out the log data to the current log file.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (write(log_fd, read_buf, n_bytes_read) !=&lt;span&gt; n_bytes_read)
        {
            perror(filename);
            exit(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大概操作就是:&lt;/p&gt;
&lt;p&gt;　　　　1. cronolog 进程开启后，会一直死循环，除非遇到错误如应用关闭等；&lt;br/&gt;　　　　2. 阻塞从标准输入读取信息，读取到后，再进行文件操作；&lt;br/&gt;　　　　3. 每次读取内容后判断是否到达需要新滚动的周期，如果到了，就把原来的文件close掉，并重新创建一个用于写的文件；&lt;br/&gt;　　　　4. 只管向打开的文件中写入缓冲内容即可；&lt;br/&gt;　　　　5. 所有读入数据是基于管道操作的，简单实用；&lt;/p&gt;
&lt;p&gt;　　看起来很简单啊！会不会有什么问题呢？应该不会吧，它可是经过时间考验的哦。越是简单的，往往越是可靠的！&lt;/p&gt;
&lt;p&gt;　　看着上面代码，有同学肯定要说了，这么简单的代码谁不会啊，自己顺手就来一个shell搞定。 且不论你的shell写得是否可靠，但是你基于 shell, 别人是基于c的，恐怕不是一个量级的哦！&lt;/p&gt;
&lt;p&gt;　　最后，还有个问题我们要处理下，那就是过期日志的清理问题？&lt;/p&gt;
&lt;p&gt;　　这个简单的脚本是不会给你做了，或者说我没有发现它有这功能；所以，只能自己写脚本清理了！一行代码搞定！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    # vim clean_log.&lt;span&gt;sh&lt;/span&gt;
        &lt;span&gt;find&lt;/span&gt; /var/logs/ai -mtime +&lt;span&gt;8&lt;/span&gt; -name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ai.*out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -exec &lt;span&gt;rm&lt;/span&gt; -&lt;span&gt;rf {} \;
    # 然后在 crontab 中加入执行时机即可，一般一天一次！
        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;  * * * &lt;span&gt;sh&lt;/span&gt; clean_log.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　搞定！&lt;/p&gt;

&lt;p&gt;　　以上，就是一些日志滚动的实现及原理解析了！是不是有一种豁然开朗的感觉？哈哈。。&lt;/p&gt;
&lt;p&gt;　　事情其实并没有想像中的难！&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 06:44:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>一般作为服务端的应用，必须要有相应的日志，否则问题怎么排查呢？ 而日志怎么打印，也是一个技术活。不然java中也不会存在N多厂商争相提供日志框架了！ 而日志滚动则往往也是刚需，毕竟没人能保证日志的量及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/10343855.html</dc:identifier>
</item>
<item>
<title>Redis高可用之集群配置（六） - LouieGuo</title>
<link>http://www.cnblogs.com/guolianyu/p/10345387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolianyu/p/10345387.html</guid>
<description>&lt;h2&gt;&lt;span&gt;0、Redis目录结构&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;      1）&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/10172688.html&quot;&gt;Redis介绍及部署在CentOS7上（一）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2）&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/10194890.html&quot;&gt;Redis指令与数据结构（二）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      3）&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/10239902.html&quot;&gt;Redis客户端连接以及持久化数据（三）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      4）&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/10239913.html&quot;&gt;Redis高可用之主从复制实践（四）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      5）&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/10249687.html&quot;&gt;Redis高可用之哨兵模式Sentinel配置与启动（五）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      6）&lt;a href=&quot;https://www.cnblogs.com/guolianyu/p/10345387.html&quot; target=&quot;_blank&quot;&gt;Redis高可用之集群配置（六）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、介绍&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;上篇文章中介绍了redis的主从复制，但是如果出从复制无法满足单节点故障问题，则需要引入集群部署。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在之前有看到过redis集群部署的三种方案，不过性能最高的还是redis官方推荐的redis-cluster，性能最高，其他两种我就不介绍了，主要介绍一下redis-cluster这种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、redis-cluster&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A、采用去中心化的思想，没有中心节点的说法，它使用hash slot方式将16348个hash slot覆盖到所有节点上，对于存储的每个key值，使用CRC16（KEY）&amp;amp;16348=slot得到他对应的hash slot，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并在访问key的时候就去找他的hash slot在哪一个节点上，然后由当前访问节点从实际被分配了这个hash slot的节点去取数据，节点之间使用轻量协议通信 减少带宽占用 性能很高，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自动实现负载均衡与高可用，自动实现failover并且支持动态扩展，官方已经玩到可以1000个节点 实现的复杂度低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B、其内部中也需要配置主从，并且内部也是采用哨兵模式，如果有半数节点发现某个异常节点，共同决定更改异常节点的状态，如果改节点是主节点，则对应的从节点自动顶替为主节点，当原先的主节点上线后，则会变为从节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果集群中的master没有slave节点，则master挂掉后整个集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C、根据官方推荐 集群部署至少要3台以上的master节点。那么接下来就开始部署吧 &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、集群部署&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、环境配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一：准备3台服务器，每台服务器运行两个redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;主机说明&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;主机IP&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;端口&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.250.129&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;7000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7001&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;192.168.250.130&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;7002&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7003&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Redis　&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.250.131&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;7004&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7005&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、在每一台服务器上我们添加一下配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别为：redis-7000.conf  redis-7001.conf  redis-7002.conf  redis-7003.conf redis-7004.conf  redis-7005.conf &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置文件内容为如下：其他的配置文件修改一下端口以及log文件、日志文件即可。其中中间部分cluster代表集群设置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;daemonize yes
port &lt;/span&gt;&lt;span&gt;7000&lt;/span&gt;&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;7000&lt;/span&gt;&lt;span&gt;.log
dir .&lt;/span&gt;/&lt;span&gt;
bind &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.129&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;

cluster&lt;/span&gt;-&lt;span&gt;enabled yes
cluster&lt;/span&gt;-config-&lt;span&gt;file nodes_7000.conf
cluster&lt;/span&gt;-node-timeout &lt;span&gt;15000&lt;/span&gt;&lt;span&gt;

appendonly yes
appendfilename aof&lt;/span&gt;-&lt;span&gt;7000&lt;/span&gt;&lt;span&gt;.aof
appendfsync everysec
no&lt;/span&gt;-appendfsync-on-&lt;span&gt;rewrite yes
auto&lt;/span&gt;-aof-rewrite-percentage &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-size 64mb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、上面文件都配置好后，即可启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201140018652-2112665514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、启动后我们就可以创建集群啦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在redis5.0后 创建集群统一使用redis-cli，之前的版本使用redis-trib.rb，但是需要安装ruby软件相对复杂,相比之前的版本5.0不需要安装额外的软件，方便。具体的可以参照redis官方网站查看&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://redis.io/topics/cluster-tutorial&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建集群命令：其中 cluster-replicas 1  代表  一个master后有几个slave，1代表为1个slave节点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;./src/redis-cli --cluster create &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.129&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.129&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.130&lt;/span&gt;:&lt;span&gt;7002&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.130&lt;/span&gt;:&lt;span&gt;7003&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.131&lt;/span&gt;:&lt;span&gt;7004&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;250.131&lt;/span&gt;:&lt;span&gt;7005&lt;/span&gt; --cluster-replicas &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等待集群创建成功，发现 7000/7002/7004为master主节点，其他的为slave。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201140807327-1025463835.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;481&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201140819086-1640967630.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、我们验证一下集群是否创建成功&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录redis客户端 ./src/redis-cli -c -p 7000， -c 参数代表连接到集群中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们先看一下主从配对情况，根据node ID匹配可以得出配比。如下：红色圈出来的为标注，大家可以看看是否有对应的ID，这样我们就区分了主从节点的关系了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201140934566-2090072128.png&quot; alt=&quot;&quot; width=&quot;1024&quot; height=&quot;108&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证数据匹配是否采用哈希槽的方式。大家可自行测试一下。发现我在7000客户端设置的数据，被分配到7002上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201141040404-399602470.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们查看一下key 为 wangjing，发现定位到了7002&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201142126206-19950376.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、我们验证一下故障转移&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们从上面可以看出7002为master，7001为其从节点。我们按照如下流程进行操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先停掉7002，发现7001转为了master节点，然后恢复7002上线，7002变为slave节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201902/651008-20190201142310478-1319896373.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;399&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么redis集群演示就到此为止吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面还涉及到 集群新增节点(包括master和slave)以及删除节点，这些操作大家自行操作吧，俗话说 师父领进门修行在个人。大家加油。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家如果有问题欢迎提问，谢谢。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;asp.net core 交流群：&lt;span&gt;787464275&lt;/span&gt; 欢迎加群交流&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果您认为这篇文章还不错或者有所收获，您可以点击右下角的&lt;span&gt;【推荐】&lt;/span&gt;按钮精神支持，因为这种支持是我继续写作，分享的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11.282505910165&quot;&gt;

&lt;p&gt;&lt;strong&gt;声明：原创博客请在转载时保留原文链接或者在文章开头加上本人博客地址，如发现错误，欢迎批评指正。凡是转载于本人的文章，不能设置打赏功能，如有特殊需求请与本人联系！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信公众号：欢迎关注                                                 QQ技术交流群： &lt;/strong&gt;欢迎加群&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201809/651008-20180909162914580-1787420461.jpg&quot; alt=&quot;&quot; width=&quot;267&quot; height=&quot;267&quot;/&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201809/651008-20180909182103726-1395406084.jpg&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;249&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 01 Feb 2019 06:33:00 +0000</pubDate>
<dc:creator>LouieGuo</dc:creator>
<og:description>0、Redis目录结构 1）Redis介绍及部署在CentOS7上（一） 2）Redis指令与数据结构（二） 3）Redis客户端连接以及持久化数据（三） 4）Redis高可用之主从复制实践（四） 5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolianyu/p/10345387.html</dc:identifier>
</item>
<item>
<title>#13    让代码变得Pythonic - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10345393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10345393.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在学习Python的过程中，肯定听说过这么一个词：Pythonic，它的意思是让你的代码很Python！&lt;/p&gt;
&lt;h3&gt;一、列表生成式&lt;/h3&gt;
&lt;p&gt;前面有一节专门讲解了Python的列表，其灵活的使用方法一定让你陶醉其中。当然，也也知道怎么初始化一个列表，比如现在要生成 [0,1,2,3,4] 这样一个列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [1]: list(range(5&lt;span&gt;))
Out[&lt;/span&gt;1]: [0, 1, 2, 3, 4]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在要将此列表的每个元素平方，要怎么办呢？&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
In [9&lt;span&gt;]: a
Out[&lt;/span&gt;9]: [0, 1, 2, 3, 4&lt;span&gt;]

In [&lt;/span&gt;10]: b =&lt;span&gt; []

In [&lt;/span&gt;11]: &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a:
    ...:     b.append(i&lt;/span&gt;**2&lt;span&gt;)
    ...:

In [&lt;/span&gt;12&lt;span&gt;]: b
Out[&lt;/span&gt;12]: [0, 1, 4, 9, 16&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 for 循环遍历每一个元素，之后将结果保存在新的列表里&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
In [13&lt;span&gt;]: a
Out[&lt;/span&gt;13]: [0, 1, 2, 3, 4&lt;span&gt;]

In [&lt;/span&gt;14]: &lt;span&gt;for&lt;/span&gt; index,i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(a):
    ...:     a[index] &lt;/span&gt;**=2&lt;span&gt;
    ...:

In [&lt;/span&gt;15&lt;span&gt;]: a
Out[&lt;/span&gt;15]: [0, 1, 4, 9, 16&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用内置函数 enumerate() 将可迭代对象返回其索引和相应的值，这种方法直接改变原有列表的元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法三：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
In [15&lt;span&gt;]: a
Out[&lt;/span&gt;15]: [0, 1, 4, 9, 16&lt;span&gt;]

In [&lt;/span&gt;16]: func = &lt;span&gt;lambda&lt;/span&gt; x:x**2&lt;span&gt;

In [&lt;/span&gt;18]: a =&lt;span&gt; map(func,a)

In [&lt;/span&gt;19&lt;span&gt;]: a
Out[&lt;/span&gt;19]: &amp;lt;map at 0x21bbb7a30b8&amp;gt;&lt;span&gt;

In [&lt;/span&gt;20]: &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a:
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
    ...:
0
&lt;/span&gt;1
16
81
256

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用内置函数 map() 也可以实现,map(函数，可迭代对象)，将可迭代对象的每一个元素传入函数并返回结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法四：使用更加Pythonic的方法：列表生成式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
In [22]: a = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;)]

In [&lt;/span&gt;23&lt;span&gt;]: a
Out[&lt;/span&gt;23]: [0, 1, 2, 3, 4&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到生成一个列表就是如此简单&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
In [24]: a = [i**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;)]

In [&lt;/span&gt;25&lt;span&gt;]: a
Out[&lt;/span&gt;25]: [0, 1, 4, 9, 16&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到列表生成式很方便，很好用，这该死的无处安放的魅力啊&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
In [26]: a = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10) &lt;span&gt;if&lt;/span&gt; i%2 ==&lt;span&gt; 0]

In [&lt;/span&gt;27&lt;span&gt;]: a
Out[&lt;/span&gt;27]: [0, 2, 4, 6, 8&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表生成式还可以加入 if 判断&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
In [28]: [p + q &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; range(3) &lt;span&gt;for&lt;/span&gt; q &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;)]
Out[&lt;/span&gt;28]: [0, 1, 2, 3, 4, 1, 2, 3, 4, 5, 2, 3, 4, 5, 6&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用两层循环实现全排列&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 0+0 0+1 0+2 0+3 0+4 0+0 1+0 1+1 1+2 1+3 1+4 2+0 2+1 2+2 2+3 2+4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、生成器&lt;/h3&gt;
&lt;p&gt;列表生成式很实用，但是有一个致命的缺点，就是不能创建大数据量的列表，数据量太大时会导致计算机内存不够用，同时，如果创建的大数据量列表被使用的元素很少的话，那么就会造成存储空间的大量浪费，那有没有一种方法，可以不提前生成列表，而是在使用列表的时候生成一个列表，换句话说就是：边循环边计算，这就是生成器—— generator。生成器在需要的时候才产生结果，不是立即产生结果，生成器效率高，节省CPU生成器只能遍历一次，是一个特殊的迭代器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.生成器表达式：&lt;/strong&gt;类似于列表生成式，只不过将方括号 [] 改变为圆括号 () &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
In [29]: l = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(8&lt;span&gt;)]

In [&lt;/span&gt;30&lt;span&gt;]: l
Out[&lt;/span&gt;30]: [0, 1, 2, 3, 4, 5, 6, 7&lt;span&gt;]

In [&lt;/span&gt;31]: g = (i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(8&lt;span&gt;))

In [&lt;/span&gt;32&lt;span&gt;]: g
Out[&lt;/span&gt;32]: &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x0000021BBBB16E08&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到 l 是列表，而 g 是一个generator&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何获得生成器的元素呢？使用next()方法可以获取一个元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [33&lt;span&gt;]: next(g)
Out[&lt;/span&gt;33&lt;span&gt;]: 0

In [&lt;/span&gt;34&lt;span&gt;]: next(g)
Out[&lt;/span&gt;34]: 1&lt;span&gt;

In [&lt;/span&gt;35&lt;span&gt;]: next(g)
Out[&lt;/span&gt;35]: 2&lt;span&gt;

In [&lt;/span&gt;36&lt;span&gt;]: next(g)
Out[&lt;/span&gt;36]: 3&lt;span&gt;

In [&lt;/span&gt;37&lt;span&gt;]: next(g)
Out[&lt;/span&gt;37]: 4&lt;span&gt;

In [&lt;/span&gt;38&lt;span&gt;]: next(g)
Out[&lt;/span&gt;38]: 5&lt;span&gt;

In [&lt;/span&gt;39&lt;span&gt;]: next(g)
Out[&lt;/span&gt;39]: 6&lt;span&gt;

In [&lt;/span&gt;40&lt;span&gt;]: next(g)
Out[&lt;/span&gt;40]: 7&lt;span&gt;

In [&lt;/span&gt;41&lt;span&gt;]: next(g)
&lt;/span&gt;---------------------------------------------------------------------------&lt;span&gt;
StopIteration                             Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-41-e734f8aca5ac&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1&lt;span&gt; next(g)

StopIteration:

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到当生成器没有元素可以取的时候，会抛出StopIteration异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到上面的代码总司不停的手动使用next()获取下一个元素，很烦~，在Python中其实不经常使用next()，而是用for循环的方法迭代生成器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
In [43]: g = (i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(8&lt;span&gt;))

In [&lt;/span&gt;45]: &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; g:
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p)
&lt;/span&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个生成器以后，基本上不会使用next()方法，而是使用for循环，迭代完成以后不会抛出StopIteration异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生成器函数：&lt;/strong&gt;将函数返回时的关键字return改为yield。函数将每次返回一个结果，之后挂起，再次调用时，继续从挂起的位置执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [46]: &lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_num():
    ...:     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    ...:     print num to screen
    ...:     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    ...:     a &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     b &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     c &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; a
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行函数可以使用 next() ，当然也不常用，for循环才是generator的真爱：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [46]: &lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_num():
    ...:     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    ...:     print num to screen
    ...:     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    ...:     a &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     b &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     c &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; a
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    ...:     &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; c
    ...:

In [&lt;/span&gt;52]: a =&lt;span&gt; print_num()

In [&lt;/span&gt;53&lt;span&gt;]: next(a)
No.&lt;/span&gt;1&lt;span&gt;
Out[&lt;/span&gt;53]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;54&lt;span&gt;]: next(a)
No.&lt;/span&gt;2&lt;span&gt;
Out[&lt;/span&gt;54]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;55&lt;span&gt;]: next(a)
No.&lt;/span&gt;3&lt;span&gt;
Out[&lt;/span&gt;55]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;56&lt;span&gt;]: next(a)
&lt;/span&gt;---------------------------------------------------------------------------&lt;span&gt;
StopIteration                             Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-56-15841f3f11d4&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1&lt;span&gt; next(a)

StopIteration:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 菲波那切数列&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Fib(max):
    n, a, b &lt;/span&gt;= 0, 0, 1
    &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
        a, b &lt;/span&gt;= b, a +&lt;span&gt; b   # 还记得这里的交换变量方法吗？
        n &lt;/span&gt;= n + 1
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;到头了！！！！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;/pre&gt;
&lt;p&gt;  In [61]: f = Fib(10)&lt;/p&gt;
&lt;p&gt;  In [62]: for p in f:&lt;br/&gt;  ...: print(p)&lt;br/&gt;  1&lt;br/&gt;  1&lt;br/&gt;  2&lt;br/&gt;  3&lt;br/&gt;  5&lt;br/&gt;  8&lt;br/&gt;  13&lt;br/&gt;  21&lt;br/&gt;  34&lt;br/&gt;  55&lt;/p&gt;

&lt;p&gt;  # for循环才是generator的真爱&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;三、迭代器&lt;/h3&gt;
&lt;p&gt;在Python中，list、string、tuple、dict都是可以使用for循环进行遍历的，现在又多了一类generator。这些可以使用for循环的对象称为可迭代对象。迭代器是用来帮助我们记录每次迭代的位置，而可迭代对象使用内置函数iter()是可以转换为迭代器的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
In [63]: a = [1,2,3]      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个新列表&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;64]: &lt;span&gt;print&lt;/span&gt;(a)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到a是列表&lt;/span&gt;
[1, 2, 3&lt;span&gt;]  

In [&lt;/span&gt;65]: i = iter(a)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将其变为迭代器&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;67]: &lt;span&gt;print&lt;/span&gt;(i)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到i为迭代器&lt;/span&gt;
&amp;lt;list_iterator object at 0x0000021BBCE00240&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取迭代器中的元素可以使用内置函数next()，但不经常使用，经常使用的是for循环：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
In [68&lt;span&gt;]: i
Out[&lt;/span&gt;68]: &amp;lt;list_iterator at 0x21bbce00240&amp;gt;&lt;span&gt;

In [&lt;/span&gt;70]: &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; i:
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(p)
&lt;/span&gt;1
2
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：对于列表、字符串、元组、字典等数据类型，在使用for循环时，在后台for语句对这些对象调用iter()函数，之后使用next()逐个访问每一个元素，直到遇到StopIteration异常，迭代结束。&lt;/p&gt;
&lt;p&gt;在Python中，可以使用 isinstance() 判断一个对象是否为可迭代对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
In [71]: &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt; Iterable   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入Iterable模块，之后会讲&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;72&lt;span&gt;]: isinstance([],Iterable)
Out[&lt;/span&gt;72&lt;span&gt;]: True

In [&lt;/span&gt;73&lt;span&gt;]: isinstance((),Iterable)
Out[&lt;/span&gt;73&lt;span&gt;]: True

In [&lt;/span&gt;74&lt;span&gt;]: isinstance({},Iterable)
Out[&lt;/span&gt;74&lt;span&gt;]: True

In [&lt;/span&gt;75]: isinstance(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,Iterable)
Out[&lt;/span&gt;75]: True
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、装饰器&lt;/h3&gt;
&lt;p&gt;装饰器是什么呢？来举个例子就明白了：有一个长发飘飘的漂亮女明星，被邀出演尼姑，肯定不会把头发剃光了吧，怎么办呢，聪明的你一定想到戴个头套就行。是的，在Python中，长发飘飘的女明星就是源代码，头套就是装饰器。转时期的本质就是在不改变函数原有代码并且不改变原有函数的调用方式的基础上给函数加上新的功能，听起来很迷人，用起来一样有趣，让你的代码一下子就提高档次了。&lt;/p&gt;
&lt;h4&gt;1.过程No.1&lt;/h4&gt;
&lt;p&gt;现在有一个 tell_name() 函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要求记录它的执行时间，对原有函数改写，这样来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     time.sleep(2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     end_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,end_time -&lt;span&gt; start_time)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; tell_name()&lt;p&gt;# 运行结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;  I am MinuteSheep&lt;br/&gt;  执行时间为： 2.001427173614502&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;2.过程No.2&lt;/h4&gt;
&lt;p&gt;现在又100个函数需要计算其执行时间，总不能改写100个函数的源代码吧，怎么办呢？还记的高阶函数吗，可以讲函数当作变量传给函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; Time(func):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用高阶函数&lt;/span&gt;
    start_time =&lt;span&gt; time.time()
    func()
    end_time &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)

Time(tell_name)   # 调用方式发生改变&lt;p&gt;# 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  I am MinuteSheep&lt;br/&gt;  执行时间为： 2.00026535987854&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;上面代码似乎实现了这个功能，也没有修改原函数的代码，但是却改变了它的调用方式，如果一个程序中有上百条调用，都要改的话还是很麻烦&lt;/p&gt;
&lt;h4&gt;3.过程No.3&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Time(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper():    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用函数的嵌套&lt;/span&gt;
        start_time =&lt;span&gt; time.time()
        func()
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


tell_name &lt;/span&gt;= Time(tell_name)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于 tell_name = wrapper&lt;/span&gt;
tell_name()                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于执行 wrapper()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码已经基本实现了这个功能，但是每次都要写两条调用语句才行，很烦&lt;/p&gt;
&lt;h4&gt;4.过程No.4&lt;/h4&gt;
&lt;p&gt;在Python中，为了克服上述问题，出现了一个叫做&lt;span&gt;语法糖&lt;/span&gt;的语句，所以装饰器又叫做语法糖，在函数定义之前使用@语法糖可增加相应的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Time(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper():    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用函数的嵌套&lt;/span&gt;
        start_time =&lt;span&gt; time.time()
        func()
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


@Time   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这就是装饰器，也叫语法糖&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am MinuteSheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;
&lt;span&gt;

tell_name()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于执行 wrapper()&lt;p&gt;# 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  I am MinuteSheep&lt;br/&gt;  执行时间为： 2.000563621520996&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;上面代码实现了一个最简单的装饰器。&lt;/p&gt;
&lt;h4&gt;5.过程No.5&lt;/h4&gt;
&lt;p&gt;但是，又有新的问题出现了，如果被装饰函数有参数怎么办，这么办：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Time(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(name):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用函数的嵌套&lt;/span&gt;
        start_time =&lt;span&gt; time.time()
        func(name)
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


@Time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,name)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;
&lt;span&gt;

tell_name(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于执行 wrapper('MS')&lt;p&gt;# 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  I am MS&lt;br/&gt;  执行时间为： 2.0003795623779297&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;看起来不错&lt;/p&gt;
&lt;h4&gt;6.过程No.6&lt;/h4&gt;
&lt;p&gt;上面代码实现了装饰有一个参数函数的功能，但是，装饰器被应用与不同的函数，谁能知道这个函数有没有参数，有几个参数，为了实现通用性，这么办：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Time(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **kwargs):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过非固定参数实现各种参数的通用装饰器&lt;/span&gt;
        start_time =&lt;span&gt; time.time()
        func(&lt;/span&gt;*args, **&lt;span&gt;kwargs)
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


@Time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;
&lt;span&gt;

@Time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a, b):
    c &lt;/span&gt;= a +&lt;span&gt; b
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)


tell_name(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
add(&lt;/span&gt;5, 6)&lt;p&gt;# 运行结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;  I am MS&lt;br/&gt;  执行时间为： 2.00108003616333&lt;br/&gt;  11&lt;br/&gt;  执行时间为： 0.0004711151123046875&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;7.过程No.7&lt;/h4&gt;
&lt;p&gt;上面的过程中装饰器没有参数，其实装饰器时可以带参数的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入time模块，这是一个时间模块，以后会讲到&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; Time(num):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用两层嵌套实现带参数的装饰器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num == 1&lt;span&gt;:
                start_time &lt;/span&gt;=&lt;span&gt; time.time()
                func(&lt;/span&gt;*args, **&lt;span&gt;kwargs)
                end_time &lt;/span&gt;=&lt;span&gt; time.time()
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行时间为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end_time -&lt;span&gt; start_time)
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; num ==&lt;span&gt; 0:
                func(&lt;/span&gt;*args, **&lt;span&gt;kwargs)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不需要计算时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator


@Time(num&lt;/span&gt;=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tell_name(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)
    time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为了体现执行时间，让程序等两秒&lt;/span&gt;
&lt;span&gt;

@Time(num&lt;/span&gt;=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a, b):
    c &lt;/span&gt;= a +&lt;span&gt; b
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)


tell_name(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
add(&lt;/span&gt;5, 6)&lt;p&gt;# 运行结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;  I am MS&lt;br/&gt;  执行时间为： 2.0000314712524414&lt;br/&gt;  11&lt;br/&gt;  不需要计算时间&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;8.过程No.8&lt;/h4&gt;
&lt;p&gt;一个函数可以使用多个装饰器，装饰器运行顺序从里到外：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@a
@b 
@c  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先运行c，再运行b，最后运行a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是装饰器99%的功能，还有一种叫做类装饰器，等记录完Python面向对象的知识后再补充，拜拜~&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 06:19:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录列表生成式、生成器、迭代器，重点分析了Python装饰器的用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10345393.html</dc:identifier>
</item>
</channel>
</rss>