<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Disconf源码分析之启动过程分析下（2） - wuxiwei</title>
<link>http://www.cnblogs.com/wxw16/p/10741202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxw16/p/10741202.html</guid>
<description>&lt;p&gt;接上文，下面是第二次扫描的XML配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;disconfMgrBean2&quot; class=&quot;com.baidu.disconf.client.DisconfMgrBeanSecond&quot;
      init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看init()方法，会调用DisconfMgr的secondScan()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected synchronized void secondScan() {
    // 上面是顺序的校验
    try {
        // 扫描回调函数
        if (scanMgr != null) {
            scanMgr.secondScan();
        }

        // 注入数据至配置实体中
        // 获取数据/注入/Watch
        if (disconfCoreMgr != null) {
            disconfCoreMgr.inject2DisconfInstance();
        }

    } catch (Exception e) {
        LOGGER.error(e.toString(), e);
    }

    isSecondInit = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scanMgr是扫描处理器，调用第二次扫描的secondScan()方法。主要处理如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将回调函数实例化并写入仓库
ScanDynamicStoreAdapter.scanUpdateCallbacks(scanModel, registry);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ScanDynamicStoreAdapter是动态扫描与Store模块的转换器。下面主要对回调函数的处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// ScanStaticModel是第一次扫描结束得到的静态配置存储的对象
public static void scanUpdateCallbacks(ScanStaticModel scanModel, Registry registry) {
    // 扫描出来
    ScanDynamicModel scanDynamicModel = analysis4DisconfUpdate(scanModel, registry);

    // 写到仓库中
    transformUpdateService(scanDynamicModel.getDisconfUpdateServiceInverseIndexMap());
    transformPipelineService(scanDynamicModel.getDisconfUpdatePipeline());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;analysis4DisconfUpdate()会将配置中和回调相关的配置扫描处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static ScanDynamicModel analysis4DisconfUpdate(ScanStaticModel scanModel, Registry registry) {

    // 配置项或文件，DisconfKey通过配置类型和名称来标记一个配置key
    Map&amp;lt;DisconfKey, List&amp;lt;IDisconfUpdate&amp;gt;&amp;gt; inverseMap = new HashMap&amp;lt;DisconfKey, List&amp;lt;IDisconfUpdate&amp;gt;&amp;gt;();

    // disconfUpdateService是第一次扫描和回调相关的配置，@DisconfUpdateService注解
    Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; disconfUpdateServiceSet = scanModel.getDisconfUpdateService();
    for (Class&amp;lt;?&amp;gt; disconfUpdateServiceClass : disconfUpdateServiceSet) {

        // 回调对应的参数
        DisconfUpdateService disconfUpdateService =
                disconfUpdateServiceClass.getAnnotation(DisconfUpdateService.class);

        // 校验是否有继承正确,是否继承IDisconfUpdate
        if (!ScanVerify.hasIDisconfUpdate(disconfUpdateServiceClass)) {
            continue;
        }

        // 获取回调接口实例
        IDisconfUpdate iDisconfUpdate = getIDisconfUpdateInstance(disconfUpdateServiceClass, registry);
        if (iDisconfUpdate == null) {
            continue;
        }

        // 主要逻辑，将DisconfKey作为key、回调接口作为list vlaue，存入到inverseMap中
        // 配置项
        processItems(inverseMap, disconfUpdateService, iDisconfUpdate);

        //
        // 配置文件
        processFiles(inverseMap, disconfUpdateService, iDisconfUpdate);

    }

    // set data，存储所有和回调相关配置结果集合
    ScanDynamicModel scanDynamicModel = new ScanDynamicModel();
    scanDynamicModel.setDisconfUpdateServiceInverseIndexMap(inverseMap);

    //
    // set update pipeline，实现iDisconfUpdatePipeline接口的处理
    //
    if (scanModel.getiDisconfUpdatePipeline() != null) {
        IDisconfUpdatePipeline iDisconfUpdatePipeline = getIDisconfUpdatePipelineInstance(scanModel
                .getiDisconfUpdatePipeline(), registry);
        if (iDisconfUpdatePipeline != null) {
            // 存储到scanDynamicModel中
            scanDynamicModel.setDisconfUpdatePipeline(iDisconfUpdatePipeline);
        }
    }

    return scanDynamicModel;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回以后，会将结果存储到Store仓库中。两种回调方式分别处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;transformUpdateService(scanDynamicModel.getDisconfUpdateServiceInverseIndexMap());
transformPipelineService(scanDynamicModel.getDisconfUpdatePipeline());&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; private static void transformUpdateService(Map&amp;lt;DisconfKey,
            List&amp;lt;IDisconfUpdate&amp;gt;&amp;gt; disconfUpdateServiceInverseIndexMap) {
    // 分别取出配置文件仓库和配置项仓库处理器
    DisconfStoreProcessor disconfStoreProcessorFile = DisconfStoreProcessorFactory.getDisconfStoreFileProcessor();
    DisconfStoreProcessor disconfStoreProcessorItem = DisconfStoreProcessorFactory.getDisconfStoreItemProcessor();
    for (DisconfKey disconfKey : disconfUpdateServiceInverseIndexMap.keySet()) {
        try {
            if (disconfKey.getDisConfigTypeEnum().equals(DisConfigTypeEnum.FILE)) {
                // 如果是文件，第一次静态扫描结束后，肯定会有对应的配置值
                if (!disconfStoreProcessorFile.hasThisConf(disconfKey.getKey())) {
                    throw new Exception();
                }
                // 存储到仓库的回调函数属性中
                disconfStoreProcessorFile.addUpdateCallbackList(disconfKey.getKey(),
                        disconfUpdateServiceInverseIndexMap
                                .get(disconfKey));

            } else if (disconfKey.getDisConfigTypeEnum().equals(DisConfigTypeEnum.ITEM)) {
                // 配置项
                if (!disconfStoreProcessorItem.hasThisConf(disconfKey.getKey())) {
                    throw new Exception();
                }
                // 存储到仓库的回调函数属性中
                disconfStoreProcessorItem.addUpdateCallbackList(disconfKey.getKey(),
                        disconfUpdateServiceInverseIndexMap
                                .get(disconfKey));
            }

        } catch (Exception e) {
            // 找不到回调对应的配置，这是用户配置 错误了
            StringBuffer sb = new StringBuffer();
            sb.append(&quot;cannot find &quot; + disconfKey + &quot;for: &quot;);
            for (IDisconfUpdate serClass : disconfUpdateServiceInverseIndexMap.get(disconfKey)) {
                sb.append(serClass.toString() + &quot;\t&quot;);
            }
            LOGGER.error(sb.toString());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于pipeline回调函数类似的处理。&lt;/p&gt;
&lt;p&gt;继续第二次扫描。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 注入数据至配置实体中
// 获取数据/注入/Watch
if (disconfCoreMgr != null) {
    disconfCoreMgr.inject2DisconfInstance();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的处理，会分别处理File和item两项，分别调用DisconfCoreProcessor实现类（和第一次扫描处理类似）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (DisconfCoreProcessor disconfCoreProcessor : disconfCoreProcessorList) {
    disconfCoreProcessor.inject2Conf();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面已File处理为例分析：&lt;/p&gt;
&lt;p&gt;inject2Conf()的处理逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object object;
try {
    object = disconfCenterFile.getObject();
    if (object == null) {
        // 从上下文获取实例
        object = registry.getFirstByType(disconfCenterFile.getCls(), false, true);
    }
} catch (Exception e) {
    LOGGER.error(e.toString());
    object = null;
}
// 注入实体中
disconfStoreProcessor.inject2Instance(object, fileName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续向下看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void inject2Instance(Object object, String fileName) {
    // 先取出配置存储对象
    DisconfCenterFile disconfCenterFile = getInstance().getConfFileMap().get(fileName);

    // 校验是否存在
    if (disconfCenterFile == null) {
        LOGGER.error(&quot;cannot find &quot; + fileName + &quot; in store....&quot;);
        return;
    }
    //
    // 非静态类
    //
    if (object != null) {
        // 设置object
        disconfCenterFile.setObject(object);
    }

    // 根据类型设置值
    //
    // 注入实体
    //
    Map&amp;lt;String, FileItemValue&amp;gt; keMap = disconfCenterFile.getKeyMaps();
    for (String fileItem : keMap.keySet()) {

        // 根据类型设置值
        try {

            //
            // 静态类
            //
            if (object == null) {

                if (keMap.get(fileItem).isStatic()) {
                    LOGGER.debug(fileItem + &quot; is a static field. &quot;);
                    keMap.get(fileItem).setValue4StaticFileItem(keMap.get(fileItem).getValue());
                }

                //
                // 非静态类
                //
            } else {

                LOGGER.debug(fileItem + &quot; is a non-static field. &quot;);

                if (keMap.get(fileItem).getValue() == null) {

                    // 如果仓库值为空，则实例 直接使用默认值
                    Object defaultValue = keMap.get(fileItem).getFieldDefaultValue(object);
                    keMap.get(fileItem).setValue(defaultValue);

                } else {

                    // 如果仓库里的值为非空，则实例使用仓库里的值
                    keMap.get(fileItem).setValue4FileItem(object, keMap.get(fileItem).getValue());
                }
            }

        } catch (Exception e) {
            LOGGER.error(&quot;inject2Instance fileName &quot; + fileName + &quot; &quot; + e.toString(), e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别对静态和非静态对象属性赋值。&lt;/p&gt;
&lt;p&gt;到这里位置第二次扫描结束了。&lt;/p&gt;
&lt;p&gt;通过两次扫描加载的数据，都是通过注解式的分布式配置方式，Disconf同时支持XML非注解式配置方式，在上篇介绍的时候，我们留下了关于XML载入的配置处理的分析，下面分析下XML非注解式配置的源码。&lt;/p&gt;
&lt;p&gt;对于非注解式配置，Disconf主要区分为properties文件和非properties文件（properties文件才支持自动reload）、是否自动载入reload到bean对象中（通过XML配置决定）。&lt;/p&gt;
&lt;p&gt;我们先分析支持自动reload。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 使用托管方式的disconf配置(无代码侵入, 配置更改会自动reload)--&amp;gt;
&amp;lt;bean id=&quot;configproperties_disconf&quot;
      class=&quot;com.baidu.disconf.client.addons.properties.ReloadablePropertiesFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;locations&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;classpath:/autoconfig.properties&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;classpath:/autoconfig2.properties&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;propertyConfigurer&quot;
      class=&quot;com.baidu.disconf.client.addons.properties.ReloadingPropertyPlaceholderConfigurer&quot;&amp;gt;
    &amp;lt;property name=&quot;ignoreResourceNotFound&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;property name=&quot;propertiesArray&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;ref bean=&quot;configproperties_disconf&quot;/&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解读上面的配置前，先了解下Spring提供的PropertyPlaceholderConfigurer类 ，它支持将properties文件中的配置项读取并在XML中通过#{}的方式读取，他的触发是因为实现了BeanFactoryPostProcessor接口，扩展了postProcessBeanFactory方法。&lt;/p&gt;
&lt;p&gt;而Disconf就是在此基础上继续扩展，ReloadingPropertyPlaceholderConfigurer继承了PropertyPlaceholderConfigurer类。&lt;/p&gt;
&lt;p&gt;首先看下ReloadablePropertiesFactoryBean类，它继承了PropertiesLoaderSupport类，入口是setLocations()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void setLocations(List&amp;lt;String&amp;gt; fileNames) {
    List&amp;lt;Resource&amp;gt; resources = new ArrayList&amp;lt;Resource&amp;gt;();
    for (String filename : fileNames) {
        // trim
        filename = filename.trim();
        String realFileName = getFileName(filename);
        //
        // register to disconf
        // 开始扫描，可以参考上文文件和配置项的扫描
        //
        DisconfMgr.getInstance().reloadableScan(realFileName);

        //
        // only properties will reload
        //
        String ext = FilenameUtils.getExtension(filename);
        if (ext.equals(&quot;properties&quot;)) {

            PathMatchingResourcePatternResolver pathMatchingResourcePatternResolver =
                    new PathMatchingResourcePatternResolver();
            try {
                Resource[] resourceList = pathMatchingResourcePatternResolver.getResources(filename);
                for (Resource resource : resourceList) {
                    resources.add(resource);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    this.locations = resources.toArray(new Resource[resources.size()]);
    lastModified = new long[locations.length];
    super.setLocations(locations);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;reloadableScan()方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void reloadableScan(String fileName) {
    if (!isFirstInit) {
        return;
    }
    if (DisClientConfig.getInstance().ENABLE_DISCONF) {
        try {
            // 判断是不是忽略同步的文件
            if (!DisClientConfig.getInstance().getIgnoreDisconfKeySet().contains(fileName)) {
                if (scanMgr != null) {
                    // 扫描配置
                    scanMgr.reloadableScan(fileName);
                }
                if (disconfCoreMgr != null) {
                    // 核心处理器处理
                    disconfCoreMgr.processFile(fileName);
                }
                LOGGER.debug(&quot;disconf reloadable file: {}&quot;, fileName);
            }
        } catch (Exception e) {
            LOGGER.error(e.toString(), e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scanMgr.reloadableScan()会执行&lt;code&gt;StaticScannerNonAnnotationFileMgrImpl.scanData2Store();&lt;/code&gt;，注意&lt;strong&gt;StaticScannerNonAnnotationFileMgrImpl&lt;/strong&gt;，在上文中，我们介绍了，扫描工具主要包括三种：文件、配置项、非注解配置。在第一次扫描的时候，非注解配置因为list为空（详细看上文），所以没有执行后面的逻辑。&lt;/p&gt;
&lt;p&gt;继续看非注解扫描工具处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void scanData2Store(String fileName) {
    // 组装仓库对象，和注解文件的不同在于，文件注解本身就是一个对象，非注解配置是一个配置文件，需要转换为对象。
    // 组装的过程，存在disconfCenterFile.setIsTaggedWithNonAnnotationFile(true);设置。
    // 在第一次扫描的时候，有提到，如果是非注解的，该属性会覆盖之前注解的仓库对象
    DisconfCenterBaseModel disconfCenterBaseModel =
                StaticScannerNonAnnotationFileMgrImpl.getDisconfCenterFile(fileName);
    // 因为非注解配置肯定文件，所以调用文件仓库处理器，后面的逻辑参考上文    DisconfStoreProcessorFactory.getDisconfStoreFileProcessor().transformScanData(disconfCenterBaseModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扫描完成以后，开始核心处理器处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 只处理某一个
 */
@Override
public void processFile(String fileName) {
    // 获取配置文件核心处理器，原理和上文一样
    DisconfCoreProcessor disconfCoreProcessorFile =
            DisconfCoreProcessorFactory.getDisconfCoreProcessorFile(watchMgr, fetcherMgr, registry);
    // 在第一次扫描的时候会调用processAllItems()处理，但是xml配置的扫描肯定是单个的，所以直接调用单个处理
    disconfCoreProcessorFile.processOneItem(fileName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再后面的处理和第一次扫描的处理是同一个方法，一個配置文件, 下载、注入到仓库、Watch 三步骤。&lt;/p&gt;
&lt;p&gt;继续XML配置解析，对于properties类型的文件，Spring的PropertyPlaceholderConfigurer类支持处理，所以最后将properties类型的文件设置到父类的locations属性中。setLocations()结束。&lt;/p&gt;
&lt;p&gt;因为ReloadablePropertiesFactoryBean继承自PropertiesFactoryBean，PropertiesFactoryBean实现了InitializingBean接口，所以在初始化的时候，会调用afterPropertiesSet()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void afterPropertiesSet() throws IOException {
    if(this.singleton) {
        this.singletonInstance = this.createProperties();
    }
}
protected Properties createProperties() throws IOException {
    return this.mergeProperties();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而ReloadablePropertiesFactoryBean重载了createProperties()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected Properties createProperties() throws IOException {
    return (Properties) createMyInstance();
}

/**
 * @throws IOException
 */
protected Object createMyInstance() throws IOException {
    // would like to uninherit from AbstractFactoryBean (but it's final!)
    if (!isSingleton()) {
        throw new RuntimeException(&quot;ReloadablePropertiesFactoryBean only works as singleton&quot;);
    }

    // set listener
    reloadableProperties = new ReloadablePropertiesImpl();
    if (preListeners != null) {
        reloadableProperties.setListeners(preListeners);
    }

    // reload
    reload(true);

    // add for monitor
    ReloadConfigurationMonitor.addReconfigurableBean((ReconfigurableBean) reloadableProperties);

    return reloadableProperties;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看ReloadablePropertiesImpl的实现，他继承自ReloadablePropertiesBase，包含了&lt;code&gt;List&amp;lt;IReloadablePropertiesListener&amp;gt; listeners&lt;/code&gt;监听列表。开始preListeners默认为null，直接执行&lt;code&gt;reload(true)&lt;/code&gt;，默认情况下reload方法通过判断配置文件的修改时间来确认是否重新加载，这里因为传参为true，所以强制&lt;code&gt;reload()&lt;/code&gt;。调用ReloadablePropertiesBase的setProperties()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 通过listener去通知 reload
 *
 * @param oldProperties
 */
protected void notifyPropertiesChanged(Properties oldProperties) {
    PropertiesReloadedEvent event = new PropertiesReloadedEvent(this, oldProperties);
    for (IReloadablePropertiesListener listener : listeners) {
        listener.propertiesReloaded(event);
    }
}

/**
 * set value 触发
 *
 * @param properties
 */
protected void setProperties(Properties properties) {
    Properties oldProperties = internalProperties;
    synchronized(this) {
        internalProperties = properties;
    }
    notifyPropertiesChanged(oldProperties);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到最后会遍历前面所说的listeners列表，如果有值的情况会调用listener的propertiesReloaded()方法去reload。IReloadablePropertiesListener接口的实现类是&lt;strong&gt;ReloadingPropertyPlaceholderConfigurer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了ReloadablePropertiesFactoryBean以后，Disconf支持两种非注解式处理，分别的Spring自带的PropertyPlaceholderConfigurer和ReloadingPropertyPlaceholderConfigurer。两者的区别是会不会自动reload。结合上面所说，如果想要自动reload，就是通过listeners列表实现。如果使用Spring自带的PropertyPlaceholderConfigurer，那么自然就不会有listener。&lt;/p&gt;
&lt;p&gt;当我们使用ReloadingPropertyPlaceholderConfigurer的作为XML配置时，因为实现了InitializingBean接口，所以会执行afterPropertiesSet()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * afterPropertiesSet
 * 将自己 添加 property listener
 */
public void afterPropertiesSet() {
    for (Properties properties : propertiesArray) {
        if (properties instanceof ReloadableProperties) {
            logger.debug(&quot;add property listener: &quot; + properties.toString());
            // addReloadablePropertiesListener执行了listeners.add()。
            ((ReloadableProperties) properties).addReloadablePropertiesListener(this);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在加载ReloadablePropertiesFactoryBean的时候，我们已经把所有的properties格式的文件放入到propertiesArray，所以都会加入到listener中，最后会调用propertiesReloaded()进行处理。&lt;/p&gt;
&lt;p&gt;至此，Disconf的启动过程分析结束。&lt;/p&gt;
&lt;p&gt;转载请注明出处。&lt;br/&gt;作者：wuxiwei&lt;br/&gt;出处：https://www.cnblogs.com/wxw16/p/10741202.html&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 07:49:00 +0000</pubDate>
<dc:creator>wuxiwei</dc:creator>
<og:description>Disconf源码学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxw16/p/10741202.html</dc:identifier>
</item>
<item>
<title>Oracle AWR报告生成和性能分析 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10741208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10741208.html</guid>
<description>&lt;h2 id=&quot;一awe报告生成步骤&quot;&gt;一、AWE报告生成步骤&lt;/h2&gt;
&lt;p&gt;对于SQL调优，局部SQL，我们可以直接使用执行计划等直接调优，而对于整个系统来说？这时候就可以用Oracle系统自带的报告对系统进行整体分析了，Oracle提供好几种性能分析的报告，比如AWR、ASH、ADDM等等&lt;br/&gt;这篇博客主要介绍AWR&lt;/p&gt;
&lt;p&gt;AWR全称Automatic Workload Repository，自动负载信息库，是Oracle 10g版本后推出的一种性能收集和分析工具，提供了一个时间段内整个系统的报表数据。通过AWR报告，可以分析指定的时间段内数据库系统的性能。&lt;/p&gt;
&lt;h3 id=&quot;工具选择&quot;&gt;1.1 工具选择&lt;/h3&gt;
&lt;p&gt;对于Oracle数据库可以使用sqlplus或者plsql developer客户端软件&lt;br/&gt;&lt;strong&gt;sqlplus 使用&lt;/strong&gt;&lt;br/&gt;可以使用sqlplus工具登录&lt;br/&gt;进入数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sqlplus / as sysdba&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;show parameter db_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用登录之后才可以使用&lt;br/&gt;&lt;strong&gt;plsql developer使用&lt;/strong&gt;&lt;br/&gt;plsql developer也可以使用，登录之后，选择文件(File)-&amp;gt;新建(New)-&amp;gt;命令窗口(Command Window)&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420122050339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动创建快照&quot;&gt;1.2 自动创建快照&lt;/h3&gt;
&lt;p&gt;开始压测后执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT ();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过dba_hist_wr_control查看当前的配置情况，当前awr为每1小时做一次数据快照，保留时间为8天。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; select * from dba_hist_wr_control;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420112723989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;修改配置，每隔30分钟收集一次，保存1天&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;execute dbms_workload_repository.modify_snapshot_settings(interval=&amp;gt;30,retention=&amp;gt;14000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭AWR自动收集&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt;exec dbms_workload_repository.modify_snapshot_settings (interval=&amp;gt;0,retention=&amp;gt;24*60);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：10g默认是自动开启awr信息收集的，会对系统有一定的影响（很小）；如果要关闭awr信息收集，只需设置interval参数为0即可。但interval设0后，AWR报告无法生成。&lt;/p&gt;
&lt;h3 id=&quot;手工创建快照&quot;&gt;1.3 手工创建快照&lt;/h3&gt;
&lt;p&gt;除了自动创建快照，也可以手工创建快照&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select dbms_workload_repository.create_snapshot() from dual;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成awr报告&quot;&gt;1.4 生成AWR报告&lt;/h3&gt;
&lt;p&gt;在sqlplus或者plsql使用命令，${ORACLE_HOME}是Oracle的安装路径&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@/${ORACLE_HOME}/.../RDBMS/ADMIN/awrrpt.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如我的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@D:/oracle/product/11.1.0/db_1/RDBMS/ADMIN/awrrpt.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sqlplus登录的可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@?/rdbms/admin/awrrpt/awrrpt.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@?/rdbms/admin/awrrpt; 本实例AWR包括：&lt;/strong&gt;&lt;br/&gt;@?/rdbms/admin/awrrpti; RAC中选择实例号&lt;br/&gt;@?/rdbms/admin/awrddrpt; AWR 比对报告&lt;br/&gt;@?/RDBMS/admin/awrgrpt; RAC全局AWR报告&lt;/p&gt;
&lt;p&gt;执行命令之后，会提示你输入一些参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) Enter value of report_type&lt;br/&gt;意思是生成报告的格式有两种，html和txt，这里选择html&lt;/li&gt;
&lt;li&gt;(2) Enter value of num_days&lt;br/&gt;收集几天的报告信息，数字，可以输入1&lt;/li&gt;
&lt;li&gt;(3) Enter value of begin_snap&lt;br/&gt;输入开始快照id，要根据日志打印的快照id范围来填&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如我实验时候，日志打印的快照id范围为：6727 ~6745&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    Listing the last day's Completed Snapshots 
 
INST_NAME    DB_NAME       SNAP_ID SNAPDAT            LV
------------ ------------ -------- ------------------ --
orcl        ORCL              6727 17 4月  2019 00:00  1
orcl        ORCL              6728 17 4月  2019 01:00  1
orcl        ORCL              6729 17 4月  2019 02:00  1
orcl        ORCL              6730 17 4月  2019 03:00  1
orcl        ORCL              6731 17 4月  2019 04:00  1
orcl        ORCL              6732 17 4月  2019 05:00  1
orcl        ORCL              6733 17 4月  2019 06:00  1
orcl        ORCL              6734 17 4月  2019 07:00  1
orcl        ORCL              6735 17 4月  2019 08:00  1
orcl        ORCL              6736 17 4月  2019 09:00  1
orcl        ORCL              6737 17 4月  2019 10:00  1
orcl        ORCL              6738 17 4月  2019 11:00  1
orcl        ORCL              6739 17 4月  2019 12:00  1
orcl        ORCL              6740 17 4月  2019 13:00  1
orcl        ORCL              6741 17 4月  2019 14:00  1
orcl        ORCL              6742 17 4月  2019 14:13  1
orcl        ORCL              6743 17 4月  2019 14:15  1
orcl        OANET            6744 17 4月  2019 14:16  1
orcl        OANET            6745 17 4月  2019 14:40  1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我随意填写：6743&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(4) Enter value of end_snap&lt;br/&gt;输入结束快照id，要根据日志打印的快照id范围来填，所以我随意填写：6745&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; @D:/oracle/product/11.1.0/db_1/RDBMS/ADMIN/awrrpt.sql
 
Current Instance
~~~~~~~~~~~~~~~~
 
      DBID DB_NAME      INST_ INST_NAME
---------- ------------ ----- ------------
4279242421 ORCL            1 orcl
rpt_options
---------
0
 
Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
Would you like an HTML report, or a plain text report?
Enter 'html' for an HTML report, or 'text' for plain text
Defaults to 'html'
Type Specified:  html
Cannot SET TRIMSPOOL
Cannot SET UNDERLINE
 
 
Instances in this Workload Repository schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
DBBID        INSTT DBB_NAME     INSTT_NAME   HOST
------------ ----- ------------ ------------ ------------
* 4279242421     1 ORCL        ORCL        zwdb
 
Using 4279242421 for database Id
Using 1 for instance number
dbid
---------
4279242421
inst_num
---------
1
inst_num
---------
1
dbid
---------
4279242421
max_snap_time
---------
17/04/2019
 
 
Specify the number of days of snapshots to choose from
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Entering the number of days (n) will result in the most recent
(n) days of snapshots being listed.  Pressing &amp;lt;return&amp;gt; without
specifying a number lists all completed snapshots.
 
 
Listing the last day's Completed Snapshots 
 
INST_NAME    DB_NAME       SNAP_ID SNAPDAT            LV
------------ ------------ -------- ------------------ --
orcl        ORCL              6727 17 4月  2019 00:00  1
orcl        ORCL              6728 17 4月  2019 01:00  1
orcl        ORCL              6729 17 4月  2019 02:00  1
orcl        ORCL              6730 17 4月  2019 03:00  1
orcl        ORCL              6731 17 4月  2019 04:00  1
orcl        ORCL              6732 17 4月  2019 05:00  1
orcl        ORCL              6733 17 4月  2019 06:00  1
orcl        ORCL              6734 17 4月  2019 07:00  1
orcl        ORCL              6735 17 4月  2019 08:00  1
orcl        ORCL              6736 17 4月  2019 09:00  1
orcl        ORCL              6737 17 4月  2019 10:00  1
orcl        ORCL              6738 17 4月  2019 11:00  1
orcl        ORCL              6739 17 4月  2019 12:00  1
orcl        ORCL              6740 17 4月  2019 13:00  1
orcl        ORCL              6741 17 4月  2019 14:00  1
orcl        ORCL              6742 17 4月  2019 14:13  1
orcl        ORCL              6743 17 4月  2019 14:15  1
orcl        OANET            6744 17 4月  2019 14:16  1
orcl        OANET            6745 17 4月  2019 14:40  1
dbid
---------
4279242421
inst_num
---------
1
max_snap_time
---------
17/04/2019
 
 
Specify the Begin and End Snapshot Ids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Begin Snapshot Id specified: 6743
 
End   Snapshot Id specified: 6745
 
bid
---------
6743
eid
---------
6745
 
inst_num
---------
1
dbid
---------
4279242421
bid
---------
6743
eid
---------
6745
Cannot SET TRIMSPOOL
Cannot SET UNDERLINE
 
Specify the Report Name
~~~~~~~~~~~~~~~~~~~~~~~
The default report file name is awrrpt_1_6743_6745.html.  To use this name,
press &amp;lt;return&amp;gt; to continue, otherwise enter an alternative.
 
Using the report name awr.html 
Started spooling to D:\Program Files\PLSQL Developer 8.0.3.1510\awr.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二awr报告分析&quot;&gt;二、AWR报告分析&lt;/h2&gt;
&lt;h3 id=&quot;awr之db-time&quot;&gt;2.1 AWR之DB Time&lt;/h3&gt;
&lt;p&gt;DB Time主要用来判断当前系统有没有相关瓶颈，是否较为频繁访问系统导致等待时间很长？然后要怎么看？一般来说，Elapsed时间乘以CPU个数如果大于DB Time，就是正常的，系统压力不大，反之就说明压力较大，例子如图，24.93*8很明显大于0.49，所以说明系统压力很小&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420140258929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;awr之load_profile&quot;&gt;2.2 AWR之load_profile&lt;/h3&gt;
&lt;p&gt;load_profile指标主要用来显示当前系统的一些指示性能的总体参数，这里介绍一些Redo_size，用来显示平均每秒的日志尺寸和平均每个事务的日志尺寸，有时候可以结合Transactions这个每秒事务数，&lt;strong&gt;分析当前事务的繁忙程度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，平均每秒的事务数Transactions非常小，说明系统压力非常小，一般来说Transactions不超过200都是正常的，或者200左右都是正常的，超过1000就是非常繁忙了，再看看平均每秒的日志尺寸是4位数的，平均每个事务的日志尺寸是5位数的，说明了系统访问不是很频繁，而单个业务是比较复杂的，如果反过来，平均每秒日志尺寸比平均每秒事务日志尺寸大很多，说明系统访问很频繁，而业务比较简单，不需要响应很久&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420144002623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;awr之efficiency-percentages&quot;&gt;2.3 AWR之efficiency percentages&lt;/h3&gt;
&lt;p&gt;efficiency percentages是一些命中率指标。Buffer Hint、Library Hint等表示SGA(System global area)的命中率；Soft Parse指标表示共享池的软解析率，如果小于90%，就说明存在未绑定变量的情况&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420150807279.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;awr之top-10-events&quot;&gt;2.4 AWR之top 10 events&lt;/h3&gt;
&lt;p&gt;Top 10 Foreground Events by Total Wait Time，等待事件是衡量数据库优化情况的重要指标，通过观察Event和%DB time两列就可以直观看出当前数据库的主要等待事件&lt;br/&gt;如图可以看出系统面试的主要是CPU被占用太多了和锁等待&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420152509653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;### 2.5 AWR之SQL Statistics&lt;br/&gt;SQL Statistics从几个维度列举了系统执行比较慢的SQL，可以点击，然后拿SQL去调优，调优SQL可以用执行计划看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190420153431822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于AWR的性能指标还有很多，本博客是看了《收获，不止SQL优化》一书的笔记，这里只简单介绍一些比较重要的指标&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 07:46:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>[TOC] 一、AWE报告生成步骤 对于SQL调优，局部SQL，我们可以直接使用执行计划等直接调优，而对于整个系统来说？这时候就可以用Oracle系统自带的报告对系统进行整体分析了，Oracle提供好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10741208.html</dc:identifier>
</item>
<item>
<title>认识Js中的二进制数据 - DanceOnBeat</title>
<link>http://www.cnblogs.com/danceonbeat/p/10741187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danceonbeat/p/10741187.html</guid>
<description>&lt;h2 id=&quot;blob&quot;&gt;Blob&lt;/h2&gt;
&lt;p&gt;在项目中涉及到要对html原生的audio组件进行样式复写，因此需要重新实现audio的一些功能，比如下载。实现一个下载大致的思路是服务端返回一段音频的二进制数据，客户端将其存放在Blob中，再通过URL.createObjectURL将其转换成blob url，最后动态创建a标签，添加download属性，模拟点击事件来实现下载。代码比较简单，我们重点来看看Blob是何方神圣。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const saveExcelFile = (blob, filename) =&amp;gt; {
    if (window.navigator.msSaveOrOpenBlob) {
      // iE下使用msSaveBlob进行导出
      navigator.msSaveBlob(blob, filename)
    } else {
      var href = window.URL.createObjectURL(blob)

      var save_link = document.createElementNS(
        'http://www.w3.org/1999/xhtml',
        'a'
      )
      save_link.href = href
      save_link.download = filename

      // 解决火狐兼容问题
      document.body.appendChild(save_link)

      var event = document.createEvent('MouseEvents')
      event.initMouseEvent(
        'click',
        true,
        false,
        window,
        0,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null
      )
      save_link.dispatchEvent(event)

      document.body.removeChild(save_link)
      // 释放blob url，可被GC回收
      window.URL.revokeObjectURL(href)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;MDN&lt;/a&gt;的介绍，我们可以知道Blob类型的对象是类似文件对象的二进制数据，它是immutable的，即数据不可变。而HTML5的File对象继承于Blob对象，并在其基础上做了些扩展，从而具备了在操作系统上操作文件的能力。我们可以利用Blob去做一些下载文件、分片上传等功能。熟悉ES6的小伙伴应该知道，ES6中有一个ArrayBuffer对象，也是用来存储二进制数据的，那它和Blob有什么区别呢？&lt;/p&gt;
&lt;h2 id=&quot;arraybuffer&quot;&gt;ArrayBuffer&lt;/h2&gt;
&lt;p&gt;根据一些资料，ArrayBuffer设计的目的与WebGL项目有关，为了满足JS与显卡或声卡等操作系统原生接口大量的、实时的数据交换。传统的文本格式是传递一个32位的整数，这导致JS与原生接口需要频繁的转换数据格式，效率较低，因此设计了ArrayBuffer用于存储、操作二进制数据。&lt;br/&gt;ArrayBuffer并不是真正的Array，而是个类数组对象。我们通过new ArrayBuffer(length)创建的ArrayBuffer的实例，仅仅代表开辟了一段连续的内存空间，length代表内存所占的字节大小。若需要对内存中的字节进行操作，则需要创建“视图”。视图分为两种：TypedArray和DataView，用于以指定的格式来读写二进制的数据。它们的区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TypedArray以指定的格式读写内存，例如：const v1 = new Int32Array(buffer)就是以32位有符号整型来创建视图，此时通过v1[0]去读或是去写都是以该格式进行的&lt;/li&gt;
&lt;li&gt;若是想以不同数据格式去读取内存的话，需要使用DataView。当我们执行const dv = new DataView(buffer)后，可以通过类似dv.getUint8(0)这样的方式，以8位无符号整型读取第一个字节；或是以dv.setInt32(1, 25)这种方式，在第二个字节写入值为25的32位有符号整型数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：对于同一段内存创建的视图都是共享该内存的，在一个视图上进行的操作会影响另一个视图的读写。具体的可参考&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/arraybuffer#TypedArray-%E8%A7%86%E5%9B%BE&quot;&gt;阮老师的教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;区别&quot;&gt;区别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ArrayBuffer可以对字节进行读写，而Blob是immutable的&lt;/li&gt;
&lt;li&gt;ArrayBuffer存储在内存当中，Blob可以存储在磁盘或者内存中。例如文件，我们平时是存在磁盘中的。而像我们上面下载的例子中，我们的blob是在内存中的，因此在createObjectURL之后需要手动调用revokeObjectURL解除对内存的引用，使得blob可以被GC回收，释放内存。&lt;/li&gt;
&lt;li&gt;ArrayBuffer可以通过“视图”来进行读写，而Blob可以通过FileReader去读，但是不能写&lt;/li&gt;
&lt;li&gt;Blob和ArrayBuffer可以互相转换。Blob转ArrayBuffer可以通过：&lt;br/&gt;&lt;code&gt;javascript const reader = new FileReader() reader.onload = function() { console.log(reader.result) } reader.readAsArrayBuffer(blob)&lt;/code&gt;&lt;br/&gt;ArrayBuffer转Blob可以通过：&lt;br/&gt;&lt;code&gt;javascript const blob = new Blob([ArrayBuffer])&lt;/code&gt;&lt;br/&gt;因此，当我们需要对字节进行操作的时候，我们应该选用ArrayBuffer，否则，我们用Blob会更加容易。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 20 Apr 2019 07:44:00 +0000</pubDate>
<dc:creator>DanceOnBeat</dc:creator>
<og:description>Blob 在项目中涉及到要对html原生的audio组件进行样式复写，因此需要重新实现audio的一些功能，比如下载。实现一个下载大致的思路是服务端返回一段音频的二进制数据，客户端将其存放在Blob中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danceonbeat/p/10741187.html</dc:identifier>
</item>
<item>
<title>由浅入深讲解责任链模式,理解Tomcat的Filter过滤器 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10741160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10741160.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文将从简单的场景引入, 逐步优化, 最后给出具体的责任链设计模式实现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;首先我们考虑这样一个场景: 论坛上用户要发帖子, 但是用户的想法是丰富多变的, 他们可能正常地发帖, 可能会在网页中浅入html代码, 可能会使用错误的表情格式, 也可能发送一些敏感信息.&lt;/li&gt;
&lt;li&gt;作为论坛的管理员必须对用户的帖子进行过滤才能显示出来, 否则论坛就经营不下去了. 现在我们考虑一种最简单处理方式.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo1 {
    public static void main(String[] args) {
        String msg = &quot;大家好 :), &amp;lt;script&amp;gt;haha&amp;lt;/script&amp;gt; 我要说超级敏感的话&quot;;//假设有一条这样的贴子
        MsgProcessor mp = new MsgProcessor();
        mp.setMsg(msg);//处理帖子
        System.out.println(mp.process());
    }
}
//帖子处理器
class MsgProcessor{
    private String msg;

    public String process(){
        //对html标签&amp;lt;&amp;gt;进行处理
        String str = msg.replace(&quot;&amp;lt;&quot;, &quot;[&quot;).replace(&quot;&amp;gt;&quot;, &quot;]&quot;);
        //对敏感字符尽心处理
        str = str.replace(&quot;敏感&quot;, &quot;正常&quot;);
        //对错误的表情格式进行处理
        str = str.replace(&quot;:)&quot;, &quot;^_^&quot;);
        return str;
    }
    //get() / set() 方法...
}
//输出结果
大家好 ^_^, [script]haha[/script] 我要说超级正常的话&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;通过上面的代码可以看到帖子处理器会对帖子进行不同的过滤, 我们可以把一种过滤方法对应为一个过滤器, 并且向上抽取出过滤器接口.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo2 {
    public static void main(String[] args) {
        String msg = &quot;大家好 :), &amp;lt;script&amp;gt;haha&amp;lt;/script&amp;gt; 我要说超级敏感的话&quot;;
        MsgProcessor mp = new MsgProcessor();
        mp.setMsg(msg);
        System.out.println(mp.process());
    }
}

class MsgProcessor{
    private String msg;
    private Filter[] filters = {new HtmlFilter(), new SensitiveFilter(), new ExpressionFilter()};
    public String process(){
        for(Filter f : filters){
            msg = f.doFilter(msg);
        }
        return msg;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
//过滤器接口
interface Filter{
    public String doFilter(String s);
}
//处理html标签
class HtmlFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;&amp;lt;&quot;, &quot;[&quot;).replace(&quot;&amp;gt;&quot;, &quot;]&quot;);
    }
}
//处理敏感词句
class SensitiveFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;敏感&quot;, &quot;正常&quot;);
    }
}
//处理表情
class ExpressionFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;:)&quot;, &quot;^_^&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;上面的代码已经具备了责任链的模型. 在帖子发送到服务器的过程中, 它将依次经过3个过滤器, 这三个过滤器就构成一条过滤器链.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e8%bf%87%e6%bb%a4%e5%99%a81.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;下面我们考虑, 如果我们要在帖子处理过程中加入新的过滤器链条, 加在原链条的末尾或中间, 该怎么办呢?&lt;/li&gt;
&lt;li&gt;消息经过过滤器链条的过程会得到处理, 我们可以把过滤器链条看成一个过滤器, 让他也实现&lt;code&gt;Filter&lt;/code&gt;接口, 那么就可以在一条过滤链中任意加入其他过滤器和过滤链了.&lt;/li&gt;
&lt;li&gt;下面的代码实现了过滤链&lt;code&gt;FilterChain&lt;/code&gt;, 用过滤链替代原来的&lt;code&gt;MsgProcessor&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo3 {
    public static void main(String[] args) {
        String msg = &quot;大家好 :), &amp;lt;script&amp;gt;haha&amp;lt;/script&amp;gt; 我要说超级敏感的话&quot;;//待处理的帖子
        FilterChain fc1 = new FilterChain();//创建一条过滤器链1
        fc1.add(new HtmlFilter())
                .add(new SensitiveFilter());//往过滤器链1中添加过滤器

        FilterChain fc2 = new FilterChain();//创建一条过滤器链2
        fc2.add(new ExpressionFilter());//往过滤器链2中添加过滤器

        fc1.add(fc2);//把过滤器链2当作过滤器添加到过滤器链1中,(过滤器链实现了Filter接口)

        msg = fc1.doFilter(msg);//使用过滤器链1对帖子进行过滤
        System.out.println(msg);
    }
}

class FilterChain implements Filter{

    private List&amp;lt;Filter&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public FilterChain add(Filter filter){
        this.list.add(filter);
        return this;
    }

    @Override
    public String doFilter(String s) {
        for(Filter f : list){
            s = f.doFilter(s);
        }
        return s;
    }
}

class HtmlFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;&amp;lt;&quot;, &quot;[&quot;).replace(&quot;&amp;gt;&quot;, &quot;]&quot;);
    }
}

class SensitiveFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;敏感&quot;, &quot;正常&quot;);
    }
}

class ExpressionFilter implements Filter{
    @Override
    public String doFilter(String s) {
        return s.replace(&quot;:)&quot;, &quot;^_^&quot;);
    }
}

interface Filter{
    public String doFilter(String s);
}&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;在继续优化之前, 我们考虑更现实的需求, 一个请求(发出一个帖子)作为数据报发送给服务器, 服务器除了需要对请求进行过滤外, 还需要给出响应, 并且可能要对响应也进行处理. 如下图所示&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e8%bf%87%e6%bb%a4%e5%99%a82.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;当一个消息(包含请求体和响应体)发往服务器时, 它将依次经过过滤器1, 2, 3. 而当处理完成后, 封装好响应发出服务器时, 它也将依次经过过滤器3, 2, 1.&lt;/li&gt;
&lt;li&gt;大家可能会觉得有点像栈结构, 但是像归像, 这一逻辑应该如何实现呢?&lt;/li&gt;
&lt;li&gt;首先我们可以让过滤器持有过滤器链的引用, 通过调用过滤器链依次执行每个过滤器. 为了能让过滤器依次执行每个过滤器, 过滤器会持有一个&lt;code&gt;index&lt;/code&gt;序号, 通过序号控制执行顺序. 至于后面对&lt;code&gt;response&lt;/code&gt;的倒序请求, 则通过方法返回实现. 这部分设计纯用文字难以讲清, 请务必看下面的代码和代码后的分析, 配图.&lt;/li&gt;
&lt;li&gt;这个部分是责任链的精髓了, 懂了这部分代码, 看Web开发中的过滤器源码就没压力了.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo4 {
    public static void main(String[] args) {
        String msg = &quot;大家好 :), &amp;lt;script&amp;gt;haha&amp;lt;/script&amp;gt; 我要说超级敏感的话&quot;;//以下三行模拟一个请求
        Request request = new Request();
        request.setRequestStr(msg);

        Response response = new Response();//响应

        FilterChain fc = new FilterChain();//过滤器链
        HtmlFilter f1 = new HtmlFilter();//创建过滤器
        SensitiveFilter f2 = new SensitiveFilter();
        ExpressionFilter f3 = new ExpressionFilter();
        fc.add(f1);//把过滤器添加到过滤器链中
        fc.add(f2);
        fc.add(f3);

        fc.doFilter(request, response, fc);//直接调用过滤器链的doFilter()方法进行处理
        System.out.println(request.getRequestStr());
    }
}

interface Filter{
    public void doFilter(Request request, Response response, FilterChain fc);
}

class FilterChain implements Filter{

    private List&amp;lt;Filter&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    private int index = 0;

    public FilterChain add(Filter filter){
        this.list.add(filter);
        return this;
    }

    @Override
    public void doFilter(Request request, Response response, FilterChain fc) {
        if(index == list.size()){
            return;//这里是逆序处理响应的关键, 当index为容器大小时, 证明对request的处理已经完成, 下面进入对response的处理.
        }
        Filter f = list.get(index);//过滤器链按index的顺序拿到filter
        index++;
        f.doFilter(request, response, fc);
    }

}

class HtmlFilter implements Filter{
    @Override
    public void doFilter(Request request, Response response, FilterChain fc) {
        request.setRequestStr(request.getRequestStr().replace(&quot;&amp;lt;&quot;, &quot;[&quot;).replace(&quot;&amp;gt;&quot;,&quot;]&quot;));
        System.out.println(&quot;在HtmlFilter中处理request&quot;);//先处理request
        fc.doFilter(request, response, fc);//调用过滤器链的doFilter方法, 让它去执行下一个Filter的doFilter方法, 处理response的代码将被挂起
        System.out.println(&quot;在HtmlFilter中处理response&quot;);
    }
}

class SensitiveFilter implements Filter{
    @Override
    public void doFilter(Request request, Response response, FilterChain fc) {
        request.setRequestStr(request.getRequestStr().replace(&quot;敏感&quot;, &quot;正常&quot;));
        System.out.println(&quot;在SensitiveFilter中处理request&quot;);
        fc.doFilter(request, response, fc);
        System.out.println(&quot;在SensitiveFilter中处理response&quot;);
    }
}

class ExpressionFilter implements Filter{
    @Override
    public void doFilter(Request request, Response response, FilterChain fc) {
        request.setRequestStr(request.getRequestStr().replace(&quot;:)&quot;, &quot;^_^&quot;));
        System.out.println(&quot;在ExpressionFilter中处理request&quot;);
        fc.doFilter(request, response, fc);
        System.out.println(&quot;在ExpressionFilter中处理response&quot;);
    }
}

class Request{
    private String requestStr;//真正的Request对象中是包含很多信息的, 这里仅用一个字符串作模拟

    public String getRequestStr() {
        return requestStr;
    }

    public void setRequestStr(String requestStr) {
        this.requestStr = requestStr;
    }
}

class Response{
    private String responseStr;

    public String getResponseStr() {
        return responseStr;
    }

    public void setResponseStr(String responseStr) {
        this.responseStr = responseStr;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;下面我描述一次整个过程, 你可以根据文字找到相应的代码进行理解.&lt;/li&gt;
&lt;li&gt;首先我们分别创建一个&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;Response&lt;/code&gt;对象. &lt;code&gt;Request&lt;/code&gt;在传入进后端时需要依次被过滤器1, 2, 3进行处理, &lt;code&gt;Response&lt;/code&gt;对象在输出时要依次被过滤器3, 2, 1处理.&lt;/li&gt;
&lt;li&gt;创建好请求和响应对象后我们创建过滤器链, 并依次加入过滤器1, 2, 3. 整个处理流程将交给过滤器链决定.&lt;/li&gt;
&lt;li&gt;接着我们调用过滤器链的&lt;code&gt;doFilter()&lt;/code&gt;方法对request对象进行处理&lt;/li&gt;
&lt;li&gt;这时过滤器链中的&lt;code&gt;index&lt;/code&gt;值为0, 通过&lt;code&gt;index&lt;/code&gt;我们找到第一个过滤器并调用它的&lt;code&gt;doFilter()&lt;/code&gt;方法, 我们观察这段代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class HtmlFilter implements Filter{
    @Override
    public void doFilter(Request request, Response response, FilterChain fc) {
        request.setRequestStr(request.getRequestStr().replace(&quot;&amp;lt;&quot;, &quot;[&quot;).replace(&quot;&amp;gt;&quot;,&quot;]&quot;));
        System.out.println(&quot;在HtmlFilter中处理request&quot;);//先处理request
        
        fc.doFilter(request, response, fc);//调用过滤器链的doFilter方法, 让它去执行下一个Filter的doFilter方法, 处理response的代码将被挂起
        
        //在返回的过程中执行response
        System.out.println(&quot;在HtmlFilter中处理response&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;进入&lt;code&gt;doFilter()&lt;/code&gt;方法后, 首先会对&lt;code&gt;request&lt;/code&gt;请求进行处理, 然后又调用了过滤器链的&lt;code&gt;doFilter()&lt;/code&gt;方法. 这就是整个责任链模式的精妙之处, 它解释了为什么要给&lt;code&gt;doFilter()&lt;/code&gt;加上一个过滤器链参数, 就是为了让每个过滤器可以调用过滤器链本身执行下一个过滤器.&lt;/li&gt;
&lt;li&gt;为什么要调用过滤器链本身? 因为当调用过滤器本身后, 程序将跳转回到过滤器链的&lt;code&gt;doFilter&lt;/code&gt;方法执行, 这时&lt;code&gt;index&lt;/code&gt;为1, 也就是拿到第二个过滤器, 然后继续处理.&lt;/li&gt;
&lt;li&gt;正是由于这个跳转, 使得过滤器中对&lt;code&gt;response&lt;/code&gt;的处理暂时无法执行, 它必须等待上面的对过滤器链的方法返回才能被执行.&lt;/li&gt;
&lt;li&gt;所以最后我们将看到&lt;code&gt;response&lt;/code&gt;响应被过滤器3, 2, 1(和请求倒序)执行.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e8%bf%87%e6%bb%a4%e5%99%a83.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;放大招了, 如果看了上面的图还是不懂, 欢迎给我留言.&lt;/li&gt;
&lt;li&gt;整个责任链模式已经从无到有展现出来了&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;相信通过上面的讲解, 你已经对整个责任链模式有了进一步的理解.&lt;/li&gt;
&lt;li&gt;下面我们通过阅读Tomcat里Filter的源码感受一下.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Filter {
    void init(FilterConfig var1) throws ServletException;
    //熟悉的doFilter(), 熟悉的3个参数request, reponse, filterChain.
    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;

    void destroy();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以看到&lt;code&gt;Filter&lt;/code&gt;接口的定义和我们的讲解的差不多, 只是多了初始化和销毁的方法.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface FilterChain {
    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;同时我们也看到它把&lt;code&gt;FilterChain&lt;/code&gt;也向上抽取成接口, 不过这里的&lt;code&gt;FilterChain&lt;/code&gt;没有实现&lt;code&gt;Filter&lt;/code&gt;接口, 也就是说我们不能把两条&lt;code&gt;FilterChain&lt;/code&gt;拼接在一起, 换个角度想Tomcat中的过滤器的可扩展性还没有我们例子中的好呢&lt;code&gt;^_^&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 20 Apr 2019 07:39:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>本文将从简单的场景引入, 逐步优化, 最后给出具体的责任链设计模式实现. 场景引入 首先我们考虑这样一个场景: 论坛上用户要发帖子, 但是用户的想法是丰富多变的, 他们可能正常地发帖, 可能会在网页中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10741160.html</dc:identifier>
</item>
<item>
<title>预测python数据分析师的工资 - Max_Lyu</title>
<link>http://www.cnblogs.com/lyuzt/p/10741049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyuzt/p/10741049.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;前两篇博客分别对拉勾中关于 python 数据分析有关的信息进行获取（&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/lyuzt/p/10636501.html&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;https://www.cnblogs.com/lyuzt/p/10636501.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）和对获取的数据进行可视化分析（&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/lyuzt/p/10643941.html&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;https://www.cnblogs.com/lyuzt/p/10643941.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），这次我们就用 sklearn 对不同学历和工作经验的 python 数据分析师做一个简单的工资预测。由于在前面两篇博客中已经了解了数据集的大概，就直接进入正题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、对薪资进行转换&lt;/h3&gt;
&lt;p&gt;　　在这之前先导入模块并读入文件，不仅有训练数据文件，还有一组自拟的测试数据文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

train_file &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;analyst.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
test_file &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件获得数据&lt;/span&gt;
train_data = pd.read_csv(train_file, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
train_data &lt;/span&gt;= train_data.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=1&lt;span&gt;)

test_data &lt;/span&gt;= pd.read_csv(test_file, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
train_data.shape, test_data.shape&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了更好地进行分析，我们要对薪资做一个预处理。由于其分布比较散乱，很多值的个数只有1。为了不造成过大的误差，根据其分布情况，可以将它分成【5k 以下、5k-10k、10k-20k、20k-30k、30k-40k、40k 以上】，为了更加方便我们分析，取每个薪资范围的中位数，并划分到我们指定的范围内。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
salarys = train_data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;薪资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].unique()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到薪资的不同值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; salary &lt;span&gt;in&lt;/span&gt;&lt;span&gt; salarys:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据'-'进行分割并去掉'k',分别将两端的值转换成整数&lt;/span&gt;
    min_sa = int(salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0][:-1&lt;span&gt;])
    max_sa &lt;/span&gt;= int(salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1][:-1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求中位数&lt;/span&gt;
    median_sa = (min_sa + max_sa) / 2
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断其值并划分到指定范围&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; median_sa &amp;lt; 5&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k以下&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt;= 5 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 10&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k-10k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt;= 10 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 20&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10k-20k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt;= 20 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 30&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20k-30k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt;= 30 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 40&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;30k-40k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        train_data.replace(salary, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;40k以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inplace=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　处理完成后，我们可以将“薪资”单独提取出来当作训练集的 label。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
y_train = train_data.pop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;薪资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二、对变量进行转换&lt;/h3&gt;
&lt;h4&gt;把category的变量转变成numerical表达式&lt;/h4&gt;
&lt;p&gt;　　由于变量都不是numerical变量，在训练的时候计算机没办法识别，因此要对它们进行转换。 当我们用numerical来表达categorical的时候，要注意，数字本身有大小的含义，所以乱用数字会给之后的模型学习带来麻烦。于是我们可以用One-Hot的方法来表达category。&lt;/p&gt;
&lt;p&gt;　　pandas自带的get_dummies方法，可以一键做到One-Hot。 这里按我的理解解释一下One-Hot：比如说data['学历要求']有'大专', '本科', '硕士', '不限'。但data['学历要求']=='本科'，则他可以用字典表示成这样{'大专': 0, '本科':1, '硕士':0, '不限':0}，用向量表示为[0, 1, 0, 0] 。&lt;/p&gt;
&lt;p&gt;　　在此之前，将测试集和训练集组合起来一起处理，稍微方便一点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
data = pd.concat((train_data, test_data), axis=&lt;span&gt;0)
dummied_data &lt;/span&gt;=&lt;span&gt; pd.get_dummies(data)
dummied_data.head()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了更好地理解 One-Hot ，把处理后的结果展示出来，得到的结果是这样的：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190420144727603-1852973881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，也可以用别的方法，比如用数字代替不同的值，这也是可以的。&lt;/p&gt;
&lt;p&gt;　　上次可视化分析的时候就已经知道数据集中不存在缺失值了，为了走一下流程并确保正确性，再次看一下是否有缺失值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dummied_data.isnull().sum().sort_values(ascending=False).head(10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　        　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190420144942530-1979126824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OK，很好，没有缺失值。这些值比较简单，不需要做那么多工作，但还是要先把训练集和测试集分开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
X_train =&lt;span&gt; dummied_data[:train_data.shape[0]].values
X_test &lt;/span&gt;= dummied_data[-test_data.shape[0]:].values
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、选择参数&lt;/h2&gt;
&lt;h4&gt;　1、DecisionTree（决策树）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DecisionTreeClassifier
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cross_val_score
features_scores &lt;/span&gt;=&lt;span&gt; []
max_features &lt;/span&gt;= [.1, .2, .3, .4, .5, .6, .7, .8, .9&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; max_feature &lt;span&gt;in&lt;/span&gt;&lt;span&gt; max_features:
    clf &lt;/span&gt;= DecisionTreeClassifier(max_features=&lt;span&gt;max_feature)
    features_score &lt;/span&gt;= cross_val_score(clf, X_train, y_train, cv=5&lt;span&gt;)
    features_scores.append(np.mean(features_score))
plt.plot(max_features, features_scores)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个过程主要是通过交叉验证获得使模型更好时的参数，交叉验证大概可以理解为，把训练集分成几部分，然后分别把他们设置为训练集和测试集，重复循环训练得到的结果取平均值。Emmm... 感觉这样讲还是有点笼统，还是上网查来得详细吧哈哈。&lt;/p&gt;
&lt;p&gt;　　然后我们得到的参数和值得关系如图所示：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190420150026259-240781519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见当 max_features = 0.2 时达到最大，大概有0.5418。&lt;/p&gt;
&lt;h4&gt;　2、ensemble（集成算法）&lt;/h4&gt;
&lt;p&gt;　　集成学习简单理解就是指采用多个分类器对数据集进行预测，从而提高整体分类器的泛化能力。这里将采用sklearn 的 AdaBoostClassifier（adaptive boosting） 通过改变训练样本的权值，学习多个分类器，并将这些分类器进行线性组合，提高泛化性能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.ensemble &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AdaBoostClassifier
n_scores &lt;/span&gt;=&lt;span&gt; []
estimator_nums &lt;/span&gt;= [5, 10, 15, 20, 25, 30, 35, 40&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; estimator_num &lt;span&gt;in&lt;/span&gt;&lt;span&gt; estimator_nums:
    clf &lt;/span&gt;= AdaBoostClassifier(n_estimators=estimator_num, base_estimator=&lt;span&gt;dtc)
    n_score &lt;/span&gt;= cross_val_score(clf, X_train, y_train, cv=5&lt;span&gt;)
    n_scores.append(np.mean(n_score))
plt.plot(estimator_nums, n_scores)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190420150415121-776544085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当 estimators=20 的时候，score最高，大概有0.544，虽然跟单个决策树的 score 的值相差不大，但总体还是有所提升。&lt;/p&gt;
&lt;h2&gt;四、建立模型&lt;/h2&gt;
&lt;p&gt;　　参数选择完毕，就可以建立模型了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
dtc = DecisionTreeClassifier(max_features=0.2&lt;span&gt;)
abc &lt;/span&gt;= AdaBoostClassifier(n_estimators=20)&lt;br/&gt;&lt;span&gt;# 训练&lt;/span&gt;&lt;br/&gt;abc.fit(X_train, y_train)&lt;br/&gt;dtc.fit(X_train, y_train)&lt;br/&gt;&lt;span&gt;# 预测&lt;/span&gt;&lt;br/&gt;y_dtc = dtc.predict(X_test)&lt;br/&gt;y_abc = abc.predict(X_test)&lt;p&gt;test_data['薪资(单个决策树)'] = y_dtc&lt;br/&gt;test_data['薪资(boosting)'] = y_abc
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　        　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190420152053354-1812124651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至于结果，总不可能预测得很完美，而且不同模型的结果也会有所不同，更何况它预测出来的结果是否符合常理还有待商榷，所以就把它当作一个小项目就好了，具体代码在这里：&lt;span&gt;&lt;a href=&quot;https://github.com/MaxLyu/Lagou_Analyze&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/MaxLyu/Lagou_Analyze&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Apr 2019 07:25:00 +0000</pubDate>
<dc:creator>Max_Lyu</dc:creator>
<og:description>前两篇博客分别对拉勾中关于 python 数据分析有关的信息进行获取（https://www.cnblogs.com/lyuzt/p/10636501.html）和对获取的数据进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyuzt/p/10741049.html</dc:identifier>
</item>
<item>
<title>Python中dunder名称的来历 - byronXIE</title>
<link>http://www.cnblogs.com/byronxie/p/10741084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byronxie/p/10741084.html</guid>
<description>&lt;blockquote readability=&quot;3.8181818181818&quot;&gt;
&lt;p&gt;版权声明：博客为作者原创，允许转载，但必须注明原文地址：&lt;a href=&quot;https://www.cnblogs.com/byronxie/p/10741084.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/byronxie/p/10741084.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Python 中，我们经常会看到被&lt;strong&gt;双下划线&lt;/strong&gt;包围的属性名和方法名，比如下面代码中的 &lt;code&gt;__future__&lt;/code&gt;, &lt;code&gt;__all__&lt;/code&gt;, &lt;code&gt;__version__&lt;/code&gt;, &lt;code&gt;__author__&lt;/code&gt;。初看还真奇怪啊，感觉别扭得很。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有比长相更别扭的，就是怎么念它们。&lt;/p&gt;
&lt;p&gt;这种风格的名字在 Python 中有很多的名字，最开始叫&lt;code&gt;魔法变量&lt;/code&gt;或&lt;code&gt;魔法函数&lt;/code&gt; (magic)。&lt;/p&gt;
&lt;p&gt;加两个下划线，这个名字就带有魔法了？&lt;/p&gt;
&lt;p&gt;相信有很多人和我一样，把&lt;code&gt;__all__&lt;/code&gt;念作&lt;code&gt;magic all&lt;/code&gt;，就好像指着一匹马，我却要说牛一样。&lt;/p&gt;
&lt;p&gt;所以后面有个人提议，把带双下划线的属性名和方法名叫&lt;code&gt;dunders&lt;/code&gt;。大家都觉得很好，就慢慢流行起来了。在 Python 的官方的 《 Python 代码样式指南》(&lt;em&gt;PEP 8 -- Style Guide for Python Code&lt;/em&gt; [1]) 中，就把双下划线的名字叫做&lt;code&gt;dunders&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;magic&lt;/code&gt;我还知道是&lt;code&gt;魔法&lt;/code&gt;。我堂堂过了英语六级的人，看到&lt;code&gt;dunders&lt;/code&gt;直接蒙圈了。有道词典一查，解释是 &lt;code&gt;1). 甘蔗渣; 2). (Dunder)人名.&lt;/code&gt;。 难道是一个叫 &lt;code&gt;Dunder&lt;/code&gt; 的人发明了双下划线命名法，为了纪念他，把带双下划线的名字都叫做 &lt;code&gt;duner&lt;/code&gt;? 双下划线命名也有一个发明人？这太扯了。&lt;/p&gt;
&lt;p&gt;后面有 bing 搜索（英文搜索， bing 比 baidu 好些， google 被墙用不了)，终于在 Python 官方的 wiki 中找到&lt;code&gt;dunders&lt;/code&gt;的真正来历了 [3]。&lt;/p&gt;
&lt;p&gt;原来 &lt;code&gt;dunder&lt;/code&gt;是 &lt;code&gt;Double UNDERscore&lt;/code&gt;（中文双下划线）的缩写，分别取&lt;code&gt;Double&lt;/code&gt;的&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;Underscore&lt;/code&gt;的&lt;code&gt;Under&lt;/code&gt;组成。这样取名后方便发音。&lt;/p&gt;
&lt;p&gt;在发明 &lt;code&gt;dunder&lt;/code&gt; 之前， &lt;code&gt;__init__&lt;/code&gt; 要念作 &lt;code&gt;double underscore init&lt;/code&gt;, 其中的&lt;code&gt;double underscore&lt;/code&gt; 有17个单词，发音是6声（嘴或舌头要变换7次动作，你可以以试试），而&lt;code&gt;dunder&lt;/code&gt; 只有6个单词，发音是2声。大大降低了手和嘴的劳动量，这个好的发明，当然举双手占成了。&lt;/p&gt;
&lt;p&gt;Python 官方 wiki 引用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Dunder (Double UNDERscore) Alias

Mark Jackson was the first to suggest dunder as a speech shorthand for double underscores (__) in a reply to a query from Pat Notz. Ned Batchelder later stressed the need for a way of pronouncing __:

An awkward thing about programming in  Python : there are lots of double underscores. [snip] My problem with the double underscore is that it's hard to say. How do you pronounce __init__? &quot;underscore underscore init underscore underscore&quot;? &quot;under under init under under&quot;? Just plain &quot;init&quot; seems to leave out something important. I have a solution: double underscore should be pronounced &quot;dunder&quot;. So __init__ is &quot;dunder init dunder&quot;, or just &quot;dunder init&quot;.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺便给有道词典提了个建议，把&lt;code&gt;dunder&lt;/code&gt;在 Python 中的解释也加到词库中。&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names&quot;&gt;Module Level Dunder Names&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://github.com/vakila/dunders&quot;&gt;Using and abusing Python 's double-underscore methods and attributes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://wiki.python.org/moin/DunderAlias&quot;&gt;Dunder (Double UNDERscore) Alias&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 07:22:00 +0000</pubDate>
<dc:creator>byronXIE</dc:creator>
<og:description>简要介绍Python中dunder名称的来历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/byronxie/p/10741084.html</dc:identifier>
</item>
<item>
<title>Android6.0 源码修改之 仿IOS添加全屏可拖拽浮窗返回按钮 - cczheng</title>
<link>http://www.cnblogs.com/cczheng-666/p/10741082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cczheng-666/p/10741082.html</guid>
<description>&lt;p&gt;之前写过屏蔽系统导航栏功能的文章，具体可看&lt;a href=&quot;https://blog.csdn.net/u012932409/article/details/83063075&quot;&gt;Android6.0 源码修改之屏蔽导航栏虚拟按键（Home和RecentAPP）/动态显示和隐藏NavigationBar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在某些特殊定制的版本中要求完全去掉导航栏，那么当用户点进一些系统自带的应用界面如设置、联系人等，就没法退出了，虽然可以在actionBar中添加back按钮，但总不能每一个app都去添加吧。所以灵机一动我们就给系统添加一个全屏可拖拽的浮窗按钮，点击的时候处理返回键的逻辑。它大概长这样(审美可能丑了点，你们可以自由发挥)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190404142711489.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;图1 最终效果图&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;通过分析之前的NavigationBar代码，发现系统是通过WindowManager添加View的方式来实现，此处我们也可以模拟这种方法来添加&lt;/li&gt;
&lt;li&gt;添加悬浮窗以后监听触摸事件，跟随手指移动重新修改view的layoutParam&lt;/li&gt;
&lt;li&gt;松手后获取当前X坐标，小于屏幕width的一半则平移归位至屏幕左边&lt;/li&gt;
&lt;li&gt;添加系统的返回按键功能&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
&lt;code&gt;private void showFloatingWindow() {
    DisplayMetrics outMetrics = new DisplayMetrics();
    mWindowManager.getDefaultDisplay().getMetrics(outMetrics);
    screenWidth = outMetrics.widthPixels;
    screenHeight = outMetrics.heightPixels;

    layoutParams = new WindowManager.LayoutParams();
    layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
    layoutParams.format = PixelFormat.RGBA_8888;
    layoutParams.gravity = Gravity.LEFT | Gravity.TOP;
    layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    layoutParams.width = 100;
    layoutParams.height = 100;
    layoutParams.x = 200;
    layoutParams.y = 200;

    button = new ImageButton(mContext);
    button.setBackground(mContext.getResources().getDrawable(R.drawable.fab_background));//系统通讯录里的蓝色圆形图标
    button.setImageResource(R.drawable.ic_sysbar_back);//系统本身的back图标
    mWindowManager.addView(button, layoutParams);
    isShowFloatingView = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单，就是通过windowManager添加一个ImageButton，宽高都是100的，位置在屏幕左上角为原点的200,200。需要注意的是因为我们是在源码里添加，而且是M的版本，所以type为WindowManager.LayoutParams.TYPE_PHONE。如果是在普通的app里注意事项可参考&lt;a href=&quot;https://blog.csdn.net/zhuchenglin830/article/details/81812747&quot;&gt;这篇&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;button.setOnTouchListener(new FloatingOnTouchListener());

private class FloatingOnTouchListener implements View.OnTouchListener {
    private int lastX;
    private int lastY;

    @Override
    public boolean onTouch(View view, MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                isDrag = false;
                lastX = (int) event.getRawX();
                lastY = (int) event.getRawY();
                break;

            case MotionEvent.ACTION_MOVE:
                isDrag = true;
                int nowX = (int) event.getRawX();
                int nowY = (int) event.getRawY();
                int movedX = nowX - lastX;
                int movedY = nowY - lastY;
                lastX = nowX;
                lastY = nowY;
                layoutParams.x = layoutParams.x + movedX;
                layoutParams.y = layoutParams.y + movedY;
                //获取当前手指移动的x和y，通过updateViewLayout方法将改变后的x和y设置给button
                mWindowManager.updateViewLayout(view, layoutParams);
                break;

            case MotionEvent.ACTION_UP:
                if (isDrag) {
                    log(&quot;lastX=&quot; + lastX + &quot;  screenWidth=&quot; + screenWidth);
                    //手指抬起时，判断是需要滑动到屏幕左边还是屏幕右边
                    if (lastX &amp;gt;= screenWidth / 2) {
                        setAnimation(view, lastX, screenWidth);
                    } else {
                        setAnimation(view, -lastX, 0);
                    }
                }
                break;
        }
        //返回true则消费事件，返回false则传递事件，此处特殊处理是为了和点击事件区分
        return isDrag || view.onTouchEvent(event);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;private void setAnimation(final View view, int fromX, int toX) {
        final ValueAnimator animator = ValueAnimator.ofInt(fromX, toX);
        if (Math.abs(fromX) &amp;lt; screenWidth / 4 || fromX &amp;gt; screenWidth * 3 / 4)
            animator.setDuration(300);
        else
            animator.setDuration(600);

        animator.setInterpolator(new LinearInterpolator());
        animator.addListener(new Animator.AnimatorListener() {
            @Override
            public void onAnimationStart(Animator animation) {}
            @Override
            public void onAnimationEnd(Animator animation) {
                log(&quot;onAnimationEnd=&quot;);
                savePreValue(layoutParams.x, layoutParams.y);
            }
            @Override
            public void onAnimationCancel(Animator animation) {}
            @Override
            public void onAnimationRepeat(Animator animation) {}
        });
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int current = (int) animator.getAnimatedValue();
                log(&quot;current=&quot; + current);

                layoutParams.x = Math.abs(current);
                mWindowManager.updateViewLayout(view, layoutParams);
            }
        });
        animator.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样是通过改变button的x和y值来达到滑动效果，只不过我只需要x平移，y为0，需要斜着滑的你们可自由发挥，为了使滑动看上去平滑，给动画添加了一个线性插值器，设置滑动时间，监听返回插值进度，这样动态设置给button。为了保存button的最终位置，添加了一个动画完成监听，并将x和y写入到SharedPreferences中保存。&lt;/p&gt;

&lt;p&gt;通过打印日志分析，系统导航栏的返回按键，发现其原理是通过KeyButtonView的触摸事件发送一个KeyEvent事件给系统来实现返回功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码位置frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy\KeyButtonView.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean onTouchEvent(MotionEvent ev) {
    final int action = ev.getAction();
    int x, y;
    if (action == MotionEvent.ACTION_DOWN) {
        mGestureAborted = false;
    }
    if (mGestureAborted) {
        return false;
    }

    switch (action) {
        case MotionEvent.ACTION_DOWN:
            //按下的时间
            mDownTime = SystemClock.uptimeMillis();
            setPressed(true);
            if (mCode != 0) {//按下事件
                sendEvent(KeyEvent.ACTION_DOWN, 0, mDownTime);
            } else {
                // Provide the same haptic feedback that the system offers for virtual keys.
                performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
            }
            removeCallbacks(mCheckLongPress);
            postDelayed(mCheckLongPress, ViewConfiguration.getLongPressTimeout());
            break;
        case MotionEvent.ACTION_MOVE:
            x = (int)ev.getX();
            y = (int)ev.getY();
            setPressed(x &amp;gt;= -mTouchSlop
                    &amp;amp;&amp;amp; x &amp;lt; getWidth() + mTouchSlop
                    &amp;amp;&amp;amp; y &amp;gt;= -mTouchSlop
                    &amp;amp;&amp;amp; y &amp;lt; getHeight() + mTouchSlop);
            break;
        case MotionEvent.ACTION_CANCEL:
            setPressed(false);
            if (mCode != 0) {
                sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
            }
            removeCallbacks(mCheckLongPress);
            break;
        case MotionEvent.ACTION_UP:
            final boolean doIt = isPressed();
            setPressed(false);
            if (mCode != 0) {
                if (doIt) {//抬起事件
                    sendEvent(KeyEvent.ACTION_UP, 0);
                    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
                    playSoundEffect(SoundEffectConstants.CLICK);
                } else {
                    sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
                }
            } else {
                // no key code, just a regular ImageView
                if (doIt) {
                    performClick();
                }
            }
            removeCallbacks(mCheckLongPress);
            break;
    }

    return true;
}

//以下为我们给button添加的点击事件
private void sendEvent(int action, int flags, long when) {
    int mCode = 4;
    Log.e(TAG, &quot;mCode=&quot;+mCode + &quot;  flags=&quot;+flags);
    final int repeatCount = (flags &amp;amp; KeyEvent.FLAG_LONG_PRESS) != 0 ? 1 : 0;
    final KeyEvent ev = new KeyEvent(when - 100, when, action, mCode, repeatCount,
            0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0,
            flags | KeyEvent.FLAG_FROM_SYSTEM | KeyEvent.FLAG_VIRTUAL_HARD_KEY,
            InputDevice.SOURCE_KEYBOARD);
    InputManager.getInstance().injectInputEvent(ev,
            InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
}

button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.e(TAG,&quot;click dragButton ...&quot;);
            final long mDownTime = SystemClock.uptimeMillis();
            //onBackPressed();
            sendEvent(KeyEvent.ACTION_DOWN, 0, mDownTime);

            new Handler().postDelayed(new Runnable() {
                @Override
                public void run() {
                    sendEvent(KeyEvent.ACTION_UP, 0, SystemClock.uptimeMillis());
                }
            }, 300);
        }
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的地方，系统返回键对应的code为4，所以mCode=4，KeyButtonView的触摸事件包含按下和抬起，所以我们只需模拟发送按下和抬起事件，可以看到抬起事件加了300ms的延时发送，这是关键不然系统不会处理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 07:21:00 +0000</pubDate>
<dc:creator>cczheng</dc:creator>
<og:description>前言 之前写过屏蔽系统导航栏功能的文章，具体可看 'Android6.0 源码修改之屏蔽导航栏虚拟按键（Home和RecentAPP）/动态显示和隐藏NavigationBar' 在某些特殊定制的版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cczheng-666/p/10741082.html</dc:identifier>
</item>
<item>
<title>LeetCode编程训练 - 合并查找(Union Find) - bangerlee</title>
<link>http://www.cnblogs.com/bangerlee/p/10741038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bangerlee/p/10741038.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Union Find算法基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Union Find算法用于处理集合的合并和查询问题，其定义了两个用于并查集的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Find&lt;/strong&gt;: 确定元素属于哪一个子集，或判断两个元素是否属于同一子集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union&lt;/strong&gt;: 将两个子集合并为一个子集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并查集是一种树形的数据结构，其可用数组或unordered_map表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/116770/201904/116770-20190420113129879-294967307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Find操作即查找元素的root，当两元素root相同时判定他们属于同一个子集；Union操作即通过修改元素的root(或修改parent)合并子集，下面两个图展示了id[6]由6修改为9的变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/116770/201904/116770-20190420113322340-1698972577.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/116770/201904/116770-20190420113755909-1048724107.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源 &lt;a href=&quot;https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Union Find算法应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Union Find可用于解决集合相关问题，如判断某元素是否属于集合、两个元素是否属同一集合、求解集合个数等，算法框架如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;261. Graph Valid Tree&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; validTree(&lt;span&gt;int&lt;/span&gt; n, vector&amp;lt;pair&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&amp;amp;&lt;span&gt; edges) {
        vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; num(n,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(auto edge:edges){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;find查看两点是否已在同一集合&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;find(num,edge.first);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y=&lt;span&gt;find(num,edge.second);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x==y) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两点已在同一集合情况下则出现环
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;union让两点加入同一集合&lt;/span&gt;
            num[x]=&lt;span&gt;y;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n-&lt;span&gt;1&lt;/span&gt;==&lt;span&gt;edges.size();
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find(vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;amp;num,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num[i]==-&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; find(num,num[i]);  //id[id[...id[i]...]]
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一些情况下为清晰和解偶会将Uinon Find实现为一个类，独立出明显的Union和Find两个操作。&lt;/p&gt;
&lt;p&gt;相关LeetCode题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/graph-valid-tree/&quot; target=&quot;_blank&quot;&gt;261. Graph Valid Tree&lt;/a&gt;  &lt;a href=&quot;https://github.com/bangerlee/LeetCode/blob/master/union%20find/Graph%20Valid%20Tree.cpp&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/friend-circles/&quot; target=&quot;_blank&quot;&gt;547. Friend Circles&lt;/a&gt;  &lt;a href=&quot;https://github.com/bangerlee/LeetCode/blob/master/union%20find/Friend%20Circles.cpp&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/&quot; target=&quot;_blank&quot;&gt;947. Most Stones Removed with Same Row or Column&lt;/a&gt;  &lt;a href=&quot;https://github.com/bangerlee/LeetCode/blob/master/union%20find/Most%20Stones%20Removed%20with%20Same%20Row%20or%20Column.cpp&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot;&gt;200. Number of Islands&lt;/a&gt;  &lt;a href=&quot;https://github.com/bangerlee/LeetCode/blob/master/union%20find/Number%20of%20Islands.cpp&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;算法优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种常用的方法用来降低并查集树形结构的高度、以减少Uinon Find算法的时间复杂度，这两种方法是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Weighting&lt;/strong&gt;(或称作Ranking): 使用多一个数组记录每个集合的size，Uinon时将size小的集合挂到size大的集合下，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/116770/201904/116770-20190420144659097-2078693978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对3、5 Uinon，因3所在集合元素size 4大于5所在集合元素size 2，将6挂到9下而不是将9挂到6下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Path compression&lt;/strong&gt;: 对一个集合下的元素直接挂到root之下，而不是挂到其parent，path compression实现很简单只需在Find中加一行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;string&lt;/span&gt; find(unordered_map&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;amp; root,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root[s]!=&lt;span&gt;s) 
            &lt;strong&gt;root[s]&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;span&gt;find(root,root[s]);
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root[s];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入path compression也能实现减少并查集树高度的效果，图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/116770/201904/116770-20190420150108083-1601829790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Weighting和Path compression两种方法可以同时使用，这样使得对N个元素进行M次Union Find操作的时间复杂度可以减少到 (M+N)lgN。因lgN随N的增长变化很小，所以整体算法时间复杂度接近于线性的时间复杂度。&lt;/p&gt;

&lt;p&gt;相关LeetCode题：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimize-malware-spread/&quot; target=&quot;_blank&quot;&gt;924. Minimize Malware Spread&lt;/a&gt;  &lt;a href=&quot;https://github.com/bangerlee/LeetCode/blob/master/union%20find/Minimize%20Malware%20Spread.cpp&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Apr 2019 07:14:00 +0000</pubDate>
<dc:creator>bangerlee</dc:creator>
<og:description>Union Find算法基础 Union Find算法用于处理集合的合并和查询问题，其定义了两个用于并查集的操作： Find: 确定元素属于哪一个子集，或判断两个元素是否属于同一子集 Union: 将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bangerlee/p/10741038.html</dc:identifier>
</item>
<item>
<title>带着新人看java虚拟机03 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10739437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10739437.html</guid>
<description>&lt;p&gt;　　分享一篇博客：https://blog.csdn.net/yfqnihao/article/details/8289363，本篇有部分参考这篇博客！！！&lt;/p&gt;
&lt;p&gt;　　还是继续说一下java虚拟机，为什么呢？因为我随意翻着别人的博客一不小心看到有关jvm的一点新的东西，挺有趣的，就按照我的理解分享一下；&lt;/p&gt;
&lt;p&gt;　　还记得以前学过一首诗，“看成岭侧成峰，远近高低各不同”，这一句诗的内在含义有的时候真的会让你猛然惊醒，进而如获至宝！的确，有的时候换一个角度看问题，你会发现不一样的世界。&lt;/p&gt;
&lt;p&gt;　　我们平常学java的时候肯定涉及到了进程，多线程的概念，但是有没有想过操作系统也有进程和线程的概念，两者有关系吗？假如我们视角放高一点，以操作系统的角度看看一个java程序的运行，又会是什么样子的呢？jvm在将字节码文件翻译成机器码之后怎么会调用cpu呢？自己调用的还是假借了谁的手呢？jvm在操作系统中到底扮演着一个什么角色呢？还有最基本的一个问题，操作系统是什么？&lt;/p&gt;
&lt;p&gt;　　下面我们就来把这些东西整个的给串一下，当然，具体的细节还要每个人自己去研究；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.简单看看操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　水平有限，不可能对操作系统理解得那么透彻，只是说说我自己的理解吧！&lt;/p&gt;
&lt;p&gt;　　一说起操作系统大家肯定既陌生又贼熟悉，为什么呢？因为我们经常使用操作系统，比如windows系列，unix系列，macos等等，我们每天一打开电脑首先就会自动启动一个操作系统，但是又有几个人真的能了解透彻操作系统呢？我们总是在操作系统中用着几个最常见的应用，qq、LOL、淘宝、360、优酷等等软件，然而我们却很少关注操作系统到底能干什么，假如没有操作系统会怎么样？&lt;/p&gt;
&lt;p&gt;　　我们现在用的所有计算机结构都是由冯•诺依曼计算机演变过来的，下面我们简单看看冯诺依曼计算机结构：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419210733517-963833404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看看，我们使用电脑基本就是用这几部分，有这几部分足够我们运行一个程序了啊！那么，我们需要操作系统干嘛呢？&lt;/p&gt;
&lt;p&gt;　　首先我们要考虑到一点，由于运算器是能识别二进制码，所以我们在输入设备中只能输入很多很多的0和1组成的代码，这样的代码简直就是一股泥石流，让人绝望，然而早期的计算机还就是这样编程的，通过我们人工的方式写很多的0和1去对那些屏幕、cpu等硬件的驱动程序（比如声音驱动、显卡驱动，再驱动程序再底层其实就是用高低电位去使得硬件发生变化）发出指令进行操作；这个时候可没有什么线程什么的，没有cpu等待时间什么的，可想而知效率感人！&lt;/p&gt;
&lt;p&gt;　　在操作系统没有出来的时候编程真的很痛苦，一般人真干不了！过了很多年之后，终于有了操作系统，操作系统本质上是一个软件，我们可以简单的把操作系统看作是对这些驱动的封装，在操作系统内部（可以叫做内核）提供了两类接口，一类是只要那些硬件驱动程序实现了这些接口，操作系统就通过这些接口使用那些硬件设备；然后另一类接口就是给我们程序员去实现的，我们只需要面向这些接口编程我们就可以间接的操作硬件！&lt;/p&gt;
&lt;p&gt;　　而我们熟悉的JVM就是实现了操作系统提供的给程序员实现的那一类接口，而JVM又向JAVA程序员提供了一些java api，我们只需要按照java api就能间接的通过jvm对操作系统进行控制，进而对驱动发指令，最后就是可以对那些硬件中的数据进行处理；&lt;/p&gt;
&lt;p&gt;　　于是我们可以看看下面这个图（暂时忽略UNIX命令和库），这个图中用户编写的应用程序可以看作是JVM，JVM可以根据操作系统提供的系统调用接口对操作系统内核发出一些指令，内核就会调用硬件的驱动程序对硬件进行一些操作，比如读取文件数据、向文件中写入数据等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419215359653-770931468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于操作系统提供了这么强大的功能，于是我们现在几乎所有的编程语言都是在操作系统的基础上进行编程，然后通过解释器这类东西将我们写的程序转化为计算机能够识别的机器码，然后调用操作系统接口，最终实现对硬件的操作。&lt;/p&gt;
&lt;p&gt;　　顺便一提，这里用户编写的应用程序我们就可以看作是QQ，优酷，酷狗音乐等等软件，如果是单核cpu，你同时打开多个应用，那么cpu会来回在多个应用切换，只是由于切换时间太短，我们感觉不到，还以为是同时运行的！就好像电影，其实电影是一张张图每隔零点几秒进行翻页，但是我们眼睛察觉不出来，还有我们鼠标移动在屏幕上移动，为什么这么流畅呢？因为我们的屏幕每隔零点几秒就刷新一次，当然我们察觉不出来。&lt;/p&gt;
&lt;p&gt; 　　现在我们看看操作系统的定义：是一组控制和管理计算机硬件和软件资源，合理对各类作业进行调度，以及方便用户的程序的集合”，是不是有点懂了，我们继续往下看！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.操作系统的内存结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以简单看看操作系统的内存结构，一般查资料我们看到的是下图这样的，我们肯定看不懂！玛德，这都是什么鬼，除了那个栈和堆其他的都不知道干嘛的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419215929249-165432056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　于是我们可以稍作修改，去掉一些不利于我们理解的东西，如下图所示，是不是就熟悉了一点了，貌似跟jvm的内存结构很像啊！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419220154013-1363541359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　我们把硬盘和操作系统的PC寄存器添加上去试试效果，下图所示！有没有似曾相识的感觉，对的，jvm跟这个几乎一模一样，这里的硬盘其实就是相当于jvm的方法区（方法区也叫做永久代，看名字就知道是可以永久保存的啊！），还有jvm中的本地方法栈不在jvm的内存结构中，原来在这里啊，其实指的就是操作系统的栈；&lt;/p&gt;
&lt;p&gt;　　操作系统的PC寄存器和jvm的PC寄存器用处差不多，是记录当前CPU运行命令的地址；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419221229136-1455409783.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.jvm在操作系统中的角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　举个简单的例子，当我们在电脑桌面上双击了QQ，那么QQ这个应用就会启动，操作系统就会创建一个进程，然后会在操作系统的堆中为这个进程开辟空间，用于存放该进程中产生的数据；&lt;/p&gt;
&lt;p&gt;　　对操作系统来说，JVM和这个QQ应用没有什么两样，一视同仁，于是我们可以得到这样的一个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419224315415-905891713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后我们再把jvm中的内存结构完善一下，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190419223824363-657253011.png&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　看到这里，我们不禁的笑了，原来jvm就是按照操作系统的样子做了一遍，假如我们站在操作系统角度看，jvm其实就是一个平常的应用；假如我们站在java字节码文件的角度看，其实jvm就相当于一个操作系统，把字节码文件放进了jvm这个虚拟操作系统的硬盘中（方法区）中，然后jvm中对方法区中的数据进行读取、创建对象等后续各种操作；&lt;/p&gt;
&lt;p&gt;　　操作系统栈和jvm栈基本一样；操作系统堆和jvm堆基本也一样，但是释放内存的方式有点差异，操作系统的堆是要程序员手动释放，而jvm的堆是靠gc自动清理；&lt;/p&gt;
&lt;p&gt;　　现在我们再百度一下看看jvm的定义，现在应该知道jvm是个什么东西了吧！哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190420140409936-1010183105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.方法区中的信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　虽然我们之前简要的说了方法区中的数据就是有关于类的基本信息，静态变量和常量池，但是说得比较笼统；&lt;/p&gt;
&lt;p&gt;　　 现在我们再回头看看jvm方法区中存的具体是什么信息：&lt;/p&gt;
&lt;p&gt;　　（1）类信息&lt;/p&gt;
&lt;p&gt;　　（2）字段信息&lt;/p&gt;
&lt;p&gt;　　（3）方法信息&lt;/p&gt;
&lt;p&gt;　　（4）常量池&lt;/p&gt;
&lt;p&gt;　　（5）静态变量&lt;/p&gt;
&lt;p&gt;　　（6）一个到Class对象的引用&lt;/p&gt;
&lt;p&gt;　　（7）一个到加载该类的类加载器的引用&lt;/p&gt;
&lt;p&gt;　　（8）方法表（有的JVM有，有的JVM没有）：这是一个数组，保存了该类在堆中创建的所有对象的实例方法的引用，但是比较耗内存，所以有的jvm设计者没有设计这个方法表；&lt;/p&gt;
&lt;p&gt;　　对应的java代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; com.wyq.test.ClassStruct &lt;span&gt;extends&lt;/span&gt; Object &lt;span&gt;implements&lt;/span&gt; Serializable {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.类信息：包括访问修饰符，全类名,父类名，实现接口等
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.对象字段信息：包括访问修饰符，类型，字段名&lt;/span&gt;
   &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.常量池：常量和一些符号引用&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONST_INT=0&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CONST_STR=&quot;CONST_STR&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.静态变量&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String static_str=&quot;static_str&quot;&lt;span&gt;;
    
 
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.方法信息：包括修饰符，方法返回值，方法名，局部变量，方法体（花括号中的内容）&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String getStatic_str ()&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ClassStruct.static_str;
 }}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以清楚的看到其实方法区中保存的就是将字节码文件中的所有信息！ 　　&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.java程序执行流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190420143258006-460442082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在我们结合操作系统的知识和上图看看我们运行一个java程序，电脑中到底是干了什么？就不考虑缓存了。。。&lt;/p&gt;
&lt;p&gt;　　1.我们在Eclpse中写完一个java源程序，必须要Ctrl+S保存一下，这个动作就是将源程序保存到电脑硬盘中；&lt;/p&gt;
&lt;p&gt;　　2.然后我们运行一个main方法，这个时候编译器就会将硬盘中的源程序读取到内存并编译成字节码文件（注意这个字节码文件不一定非要是本计算机编译的，只要是符合字节码文件格式的字节码文件都行，别人电脑传给你的肯定可以；这符合java一处编译到处运行的原则）&lt;/p&gt;
&lt;p&gt;　　3.我们运行一个main方法的同时，对操作系统来说就是新创建了一个进程，就要在操作系统的堆中申请这个进程的内存空间，我们把这块内存空间称为JVM（注意，假如运行两个java程序那么这里就会创建两个jvm的内存空间）&lt;/p&gt;
&lt;p&gt;　　4.jvm实例创建成功，就会在这个实例之中的内存空间进行分配，java栈，java堆，方法区等&lt;/p&gt;
&lt;p&gt;　　5.由于类装载子系统，会把类加载器先加载到java堆中，然后类加载器根据我们的java源程序类名去指定路径中去加载字节码文件（双亲委托机制），放入方法区中&lt;/p&gt;
&lt;p&gt;　　6.由执行引擎去执行这个字节码文件，伴随着验证、准备、解析和初始化，最终在java堆中生成了Class对象和实例化对象。&lt;/p&gt;
&lt;p&gt;　　7.假如调用本地方法（就是Native修饰的方法）就会涉及到本地方法栈（和java栈作用差不多，压栈和弹栈），在操作系统栈中压入栈帧，假如在本地方法中还调用java中的方法，这个时候在操作系统的栈中压入一个栈帧，然后下一个栈帧却到了jvm的栈中，很有趣的一个东西。&lt;/p&gt;
&lt;p&gt;　　8.我们方法调用完毕，栈中栈帧弹出，栈清理完毕；然后gc会对java堆中对象进行回收释放内存空间，然后gc还会对方法区进行清理，自此jvm中的内存空间清理完毕；&lt;/p&gt;
&lt;p&gt;　　9 操作系统堆jvm进行清理，jvm进程结束。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　由于对操作系统的理解还处于比较懵懂的状态，所以文中可能会有很多词语运用不当，很惭愧，以后肯定会抽个时间慢操作系统整个的学习一遍的，希望这一天不要来的太迟，哈哈哈&lt;/p&gt;

</description>
<pubDate>Sat, 20 Apr 2019 06:54:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>分享一篇博客：https://blog.csdn.net/yfqnihao/article/details/8289363，本篇有部分参考这篇博客！！！ 还是继续说一下java虚拟机，为什么呢？因为我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10739437.html</dc:identifier>
</item>
<item>
<title>多线程注意事项和获取子线程何时都执行完毕 - SimpleSmile_5177</title>
<link>http://www.cnblogs.com/Simple-Object/p/10740790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Simple-Object/p/10740790.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近一段时间在整公司项目里一个功能的优化，用到了多线程处理。期间也是踩了不少的坑，在这里想说下我遇到的问题和注意事项。以及怎样知道启动的那些多线程都处理完毕这些问题。&lt;/p&gt;
&lt;h2 id=&quot;实现Runnable接口类需要注意事项&quot;&gt;实现Runnable接口类需要注意事项&lt;/h2&gt;
&lt;p&gt;我这里用的多线程，是用了实现Runnable接口，这样的话，要比继承Thread类更加的灵活。毕竟类只能单继承，但可以多实现。&lt;/p&gt;
&lt;h3 id=&quot;1-事务失效&quot;&gt;1.事务失效&lt;/h3&gt;
&lt;p&gt;我实现Runnable接口的类，是处理业务的handler类，在spring配置里面是默认给这些类添加事务的。所以我当时直接在这个类里面写了业务代码。到测试的时候发现，如果业务方法里报Runtime异常，这个类里面的一些更新方法居然不回滚，直接提交了。&lt;/p&gt;
&lt;p&gt;当时也是试了很多方法，手动给这个类加事务的注解、开辟新事物，都不行。后来查阅资料，发现在Runnable实现类里，是不支持事务的。那我就新写了一个类，把主要的业务方法全放到那个类里，再测试，发现事务可以正常回滚了。&lt;/p&gt;
&lt;h3 id=&quot;2-注解无效&quot;&gt;2.注解无效&lt;/h3&gt;
&lt;p&gt;在实现Runnable接口的类里，本来想用spring提供的@Autowired注解来自动注入类呢，发现在run方法里，调用注入的类，报空指针。后来明白，实现Runnable接口的类不受spring监管，所以spring的一些注解就不能使用了。&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;1.可以参考下面这样写，可以获得你想要用的类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ApplicationContext ctx = new ApplicationContext();
ctx.getBean(你想要获取的类名.class);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.那就是在调用多线程实现类之前，在其他类里用spring的一些注解，获得你想要的类，然后通过参数方式，传到多线程实现类里面。（我是采用的这个方式。）&lt;/p&gt;
&lt;h2 id=&quot;如何知道多个线程都执行完毕了呢？&quot;&gt;如何知道多个线程都执行完毕了呢？&lt;/h2&gt;
&lt;p&gt;使用多线程，主要就是为了提高程序的运行效率。一般情况下，分配完线程，让那些线程去执行就行了，也不需要关心他们都什么时候执行完毕了。但是有些情况下，知晓那些线程都什么时候执行完毕，确实很有用。&lt;/p&gt;
&lt;p&gt;我实现的那个功能就是放在定时器里面的，知晓定时器什么时候开始，什么时候执行完毕，在完毕的时候执行一些发邮件的一些功能，是很有用的。如果是单线程，那就直接把那些方法日志啥的放到最后执行就可以了。&lt;/p&gt;
&lt;p&gt;但是开辟了多个线程，往往是多线程还在执行，主线程不等那些子线程，就先自己执行完了，这时候，放到最后执行的那些功能就不行了，因为子线程还没执行完，主线程就把最后的那些“收尾”功能给执行了，肯定不合适。&lt;/p&gt;
&lt;p&gt;thread.Join方法，可以让交替执行的线程变成顺序的执行，但这样跟单线程就没啥区别了。&lt;/p&gt;
&lt;p&gt;后来，我想了一个办法。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//线程池
private ExecutorService threadPool;
//分配线程任务
for (int i=0; i&amp;lt;5; i++) {
     threadPool.execute(new RunHandler());
}
//关闭线程池，此时执行的线程不会立刻关闭，而是线程池不再接受新的线程请求了，线程执行完会被回收掉。
threadPool.shutdown();
while(true){
    if(threadPool.isTerminated()) {//判断线程是否执行完毕，不是就休眠主线程。
        //如果子线程们都执行完毕，就会进这个判断，然后会跳出这个循环。这样就达到了主线程等待子线程们
        //都执行完了，才去执行其他的代码。
        break;
    }
    Thread.sleep(1000);//主线程睡眠1秒
}
//这里写执行完毕的日志或者最后的“收尾”功能。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个就是我目前使用的方法。当然，能实现这个功能的方法还有很多，我选的也是比较好实现容易理解，效率算是比较高的一种吧。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;以上就是我发现和解决的一些常见的问题。由于能力有限，如有错误，敬请谅解。&lt;/p&gt;
&lt;p&gt;写好一个多线程的功能，以上那些注意事项往往根本不够。最主要的是解决多线程之间的冲突，如何避免多线程操作导致变量数据的错乱和引发的数据库保存数据的异常等问题。这些是值得推敲和反复琢磨的，加锁一般能解决这些问题，但是不合理的加锁和使用的加锁方式的不同，可能会导致多线程执行起来的效率不尽人意。&lt;/p&gt;
&lt;p&gt;有时间，我会单独写一篇多线程避免冲突错误的文章，来供大家参考下。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 06:06:00 +0000</pubDate>
<dc:creator>SimpleSmile_5177</dc:creator>
<og:description>前言 最近一段时间在整公司项目里一个功能的优化，用到了多线程处理。期间也是踩了不少的坑，在这里想说下我遇到的问题和注意事项。以及怎样知道启动的那些多线程都处理完毕这些问题。 实现Runnable接口类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Simple-Object/p/10740790.html</dc:identifier>
</item>
</channel>
</rss>