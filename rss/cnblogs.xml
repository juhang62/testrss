<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解决VS2019中.net core WPF 暂时无法使用 Designer 的临时方法 - Enjoy233</title>
<link>http://www.cnblogs.com/enjoy233/p/workaround_to_use_the_designer_in_wpf_Core_App.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/workaround_to_use_the_designer_in_wpf_Core_App.html</guid>
<description>&lt;h2 id=&quot;解决-vs2019-中.net-core-wpf-暂时无法使用-designer-的临时方法&quot;&gt;解决 VS2019 中.net core WPF 暂时无法使用 Designer 的临时方法&lt;/h2&gt;
&lt;p&gt;以下方法来自于微软github开源项目WPF:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/samples/tree/master/wpf/HelloWorld-WithLinkedFiles&quot;&gt;dotnet/samples - WPF Hello World sample with linked files&lt;/a&gt;，请放心使用。&lt;/p&gt;
&lt;p&gt;此篇文章是上篇文章&lt;a href=&quot;https://www.cnblogs.com/enjoy233/p/workaround_to_use_the_designer_in_winForms_Core_App.html&quot;&gt;解决vs2019中暂时无法为.net core WinForms使用 Designer 的临时方法&lt;/a&gt;的姊妹篇，但对WPF而言实现起来比WinForms简单很多。核心思想还是借壳~&lt;/p&gt;
&lt;p&gt;目前.net core下的WPF项目中的XAML可视化设计器(Designer)尚不可用，后续的Visual Studio 2019 Update才会支持该部分的功能。不过目前我们想在vs2019中使用 Designer，有一种临时解决方法。&lt;/p&gt;
&lt;p&gt;可以使用Visual Studio来处理链接文件(Link files)的功能，并将其XAML Designer用于Classic Framework (即.net Framework的WPF项目)。&lt;/p&gt;
&lt;p&gt;具体的解决方法是在同一个 &lt;code&gt;Solution&lt;/code&gt;下创建两个项目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用于设计WPF应用程序的.NET Framework应用程序.net Framework 项目)&lt;/li&gt;
&lt;li&gt;用于运行WPF应用程序的.NET Core应用程序(.net core项目)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而两个应用程序(.net core项目和相应.net Framework 项目)都将引用相同的文件，共享一个&lt;code&gt;Assenbly Name&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;安装-vs-2019-professionalenterprise版本&quot;&gt;安装 vs 2019 professional/enterprise版本&lt;/h2&gt;
&lt;p&gt;先安装 vs 2019 professional/enterprise版本，安装好.net core 3.0 SDK，此时试着创建一个.net core下的 WPF应用，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421070501898-1958252953.png&quot; alt=&quot;1555775855179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置好相关项目名和存放路径后，会弹出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190420171534946-95714983.png&quot; alt=&quot;img2-BravoYeung&quot;/&gt;&lt;br/&gt;下一步骤，&lt;code&gt;勾选.NET core下的&quot;Use preview SDK&quot;&lt;/code&gt;会解决这个问题。&lt;/p&gt;
&lt;p&gt;当然也可使用命令行/Powershell来创建。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开命令行/Powershell&lt;/li&gt;
&lt;li&gt;使用cd命令，切换到自己平时存vs项目的路径(比如我切换到&lt;code&gt;D:\Coding&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;输入命令&lt;code&gt;dotnet new wpf -n &quot;CoreHiWPF&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421075311320-1771436693.png&quot;&gt;creating-WPF-using-CMD&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;在vs的设置里勾选.net-core下的use-preview-sdk&quot;&gt;在vs的设置里，勾选.NET core下的&quot;Use preview SDK&quot;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190420171558821-101048975.jpg&quot; alt=&quot;img3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完，重启vs才能生效。&lt;br/&gt;此时用vs打开刚才的&lt;code&gt;Solution&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;使用vs自带的模板选择其中的-.net-core-wpf-创建project-取名为corehiwpf&quot;&gt;使用vs自带的模板，选择其中的 .net core WPF 创建Project, 取名为&quot;CoreHiWPF&quot;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421070532843-2115096993.png&quot; alt=&quot;1555775855179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421070753486-885525216.png&quot; alt=&quot;1555775915106&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在刚创建的solution中使用vs自带的模板选择其中的.net-framework-wpf添加新的project取名为hiwpf&quot;&gt;在刚创建的Solution中使用vs自带的模板，选择其中的.net framework WPF添加新的project，取名为&quot;HiWPF&quot;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421070817998-687288278.png&quot; alt=&quot;1555775957478&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071006583-1450890044.png&quot; alt=&quot;1555775984667&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时Solution中的文件目录为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071024183-677468814.png&quot; alt=&quot;1555776045894&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更改-.net-core-wpf项目-corehiwpf-的assembly-name使得两个项目一致&quot;&gt;更改 .net core WPF项目 CoreHiWPF 的Assembly Name，使得两个项目一致&lt;/h2&gt;
&lt;p&gt;右键点击 .net core WPF项目 CoreHiWPF，选择最后的Properties, 然后将其Assembly Name 改为&lt;code&gt;HiWPF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071141060-1441769124.png&quot; alt=&quot;1555773128801&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着右键该项目，选&quot;Edit CoreHiWPF.csproj&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071205349-353533515.png&quot; alt=&quot;1555773253120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按下图加入如下相应代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071232979-503690815.png&quot; alt=&quot;1555773381960&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;ApplicationDefinition Include=&quot;..\HiWPF\App.xaml&quot; Link=&quot;App.xaml&quot;&amp;gt;
      &amp;lt;Generator&amp;gt;MSBuild:Compile&amp;lt;/Generator&amp;gt;
    &amp;lt;/ApplicationDefinition&amp;gt;
    &amp;lt;Compile Include=&quot;..\HiWPF\App.xaml.cs&quot; Link=&quot;App.xaml.cs&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Page Include=&quot;..\HiWPF\MainWindow.xaml&quot; Link=&quot;MainWindow.xaml&quot;&amp;gt;
      &amp;lt;Generator&amp;gt;MSBuild:Compile&amp;lt;/Generator&amp;gt;
    &amp;lt;/Page&amp;gt;
    &amp;lt;Compile Include=&quot;..\HiWPF\MainWindow.xaml.cs&quot; Link=&quot;MainWindow.xaml.cs&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;确保-.net-core-wpf项目-corehiwpf-是启动项目&quot;&gt;确保 .net core WPF项目 CoreHiWPF 是启动项目&lt;/h2&gt;
&lt;p&gt;如果.net core WPF项目 CoreHiWPF 已经高亮，就不用管了。否则，需要选中项目 CoreHiWPF ，右击后选“Set As Start up project”.&lt;/p&gt;
&lt;h2 id=&quot;试用-xaml-designer&quot;&gt;试用 XAML Designer&lt;/h2&gt;
&lt;p&gt;此时关闭所有打开的文件，双击项目`&lt;code&gt;HiWPF&lt;/code&gt;中的&lt;code&gt;MainWindow.xaml&lt;/code&gt;，就可以在XAML Designer中看到空白的WPF window了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071324774-2130419046.png&quot; alt=&quot;1555773860860&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;按需修改mainwindow.xaml和相应的.cs&quot;&gt;按需修改MainWindow.xaml和相应的.cs&lt;/h2&gt;
&lt;p&gt;接下来，我在&lt;code&gt;MainWindow.xaml&lt;/code&gt;的&lt;code&gt;Grid&lt;/code&gt;中加入了两行，一行放的是一个含有文本可换行的&lt;code&gt;Label&lt;/code&gt;，另一行是&lt;code&gt;Exit&lt;/code&gt;按钮。然后在Exit按钮上加入了&lt;code&gt;Click&lt;/code&gt;事件，在&lt;code&gt;Window&lt;/code&gt;上加入了&lt;code&gt;Loaded&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071407802-1099066571.gif&quot; alt=&quot;modify&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码改完之后，&lt;code&gt;F5&lt;/code&gt;运行，最后的界面如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190421071432825-98258046.png&quot; alt=&quot;1555774408266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目代码已推到&lt;code&gt;github&lt;/code&gt;，欢迎&lt;code&gt;Fork&lt;/code&gt;和&lt;code&gt;star&lt;/code&gt;.&lt;br/&gt;传送门: &lt;a href=&quot;https://github.com/yanglr/.netCore-WPF_Designer&quot;&gt;.netCore-WPF_Designer&lt;/a&gt; , 如果觉得自己配置起来麻烦，也可以 clone 下来自己体验一把喔~&lt;/p&gt;

&lt;p&gt;查看本人&lt;strong&gt;最近其他原创作品&lt;/strong&gt;请移步：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/samples/tree/master/wpf/HelloWorld-WithLinkedFiles&quot;&gt;dotnet/samples - WPF Hello World sample with linked files&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 23:18:00 +0000</pubDate>
<dc:creator>Enjoy233</dc:creator>
<og:description>解决 VS2019 中.net core WPF 暂时无法使用 Designer 的临时方法 [TOC] 以下方法来自于微软github开源项目WPF: 'dotnet/samples WPF Hel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/workaround_to_use_the_designer_in_wpf_Core_App.html</dc:identifier>
</item>
<item>
<title>Unity3d之-使用BMFont制作美术字体 - 子非鱼`</title>
<link>http://www.cnblogs.com/imteach/p/10743725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imteach/p/10743725.html</guid>
<description>&lt;h2&gt;一、需求&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;游戏开发中经常遇到需要以美术字（而非字库）做数字显示的情况，通常美术会提供一组包含单个数字（也会有其它字符）的图片，可能是一张整图，也可能是每个数字分开的散图。&lt;/p&gt;
&lt;p&gt;在此我以一张整图这种情况为例，来说明美术字体的具体制作流程。整图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421015721008-2123750641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt;二、准备&lt;/h2&gt;
&lt;blockquote readability=&quot;27.349819059107&quot;&gt;
&lt;p&gt;整个制作过程需要用到三样工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字体数据制作工具&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图片切割工具&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字体生成工具&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1、字体数据制作工具&lt;/h3&gt;
&lt;p&gt;字体数据制作工具名为BMFont，是一个Windows上的可执行软件，下载网址为：&lt;a href=&quot;http://www.angelcode.com/products/bmfont/&quot; target=&quot;_blank&quot;&gt;http://www.angelcode.com/products/bmfont/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421021201442-275877827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里选择下载64位运行版（单体文件，无需安装）&lt;/p&gt;
&lt;p&gt;　　可也以点这里下载：&lt;a href=&quot;https://files.cnblogs.com/files/imteach/bmfont64.zip&quot; target=&quot;_blank&quot;&gt;BMFont64.exe&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2、图片切割工具&lt;/h3&gt;
&lt;p&gt;图片切割工具是Unity中运行的一个工具类,类名为ImageSlicer，放在Editor目录下即可，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('28842252-51e1-46cb-9bc1-1f029aec95b6')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_28842252-51e1-46cb-9bc1-1f029aec95b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28842252-51e1-46cb-9bc1-1f029aec95b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('28842252-51e1-46cb-9bc1-1f029aec95b6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28842252-51e1-46cb-9bc1-1f029aec95b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* UnityVersion: 2018.3.10f1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* FileName:     ImageSlicer.cs
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Author:       TYQ
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* CreateTime:   2019/04/19 00:04:26
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Description:  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* Author：
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;* Date：2019/01/30 10:24:22 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;* Desc：图集切割器 （针对Multiple格式的图片）
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;* 操作方式：选中图片，选择编辑器的 Assets/ImageSlicer/Process to Sprites菜单
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEditor;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageSlicer
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     [MenuItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Assets/ImageSlicer/Process to Sprites&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessToSprite()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Texture2D image = Selection.activeObject &lt;span&gt;as&lt;/span&gt; Texture2D;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取旋转的对象&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; rootPath = Path.GetDirectoryName(AssetDatabase.GetAssetPath(image));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路径名称&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; path = rootPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + image.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.PNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片路径名称&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         TextureImporter texImp = AssetImporter.GetAtPath(path) &lt;span&gt;as&lt;/span&gt; TextureImporter;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图片入口&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         AssetDatabase.CreateFolder(rootPath, image.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件夹&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt; (SpriteMetaData metaData &lt;span&gt;in&lt;/span&gt; texImp.spritesheet)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历小图集&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             Texture2D myimage = &lt;span&gt;new&lt;/span&gt; Texture2D((&lt;span&gt;int&lt;/span&gt;)metaData.rect.width, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)metaData.rect.height);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;abc_0:(x:2.00, y:400.00, width:103.00, height:112.00)&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = (&lt;span&gt;int&lt;/span&gt;)metaData.rect.y; y &amp;lt; metaData.rect.y + metaData.rect.height; y++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴像素&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = (&lt;span&gt;int&lt;/span&gt;)metaData.rect.x; x &amp;lt; metaData.rect.x + metaData.rect.width; x++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     myimage.SetPixel(x - (&lt;span&gt;int&lt;/span&gt;)metaData.rect.x, y - (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)metaData.rect.y, image.GetPixel(x, y));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换纹理到EncodeToPNG兼容格式&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (myimage.format != TextureFormat.ARGB32 &amp;amp;&amp;amp; myimage.format !=&lt;span&gt; TextureFormat.RGB24)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 Texture2D newTexture = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Texture2D(myimage.width, myimage.height);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 newTexture.SetPixels(myimage.GetPixels(&lt;span&gt;0&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 myimage =&lt;span&gt; newTexture;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pngData =&lt;span&gt; myimage.EncodeToPNG();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AssetDatabase.CreateAsset(myimage, rootPath + &quot;/&quot; + image.name + &quot;/&quot; + metaData.name + &quot;.PNG&quot;);&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;             File.WriteAllBytes(rootPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + image.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + metaData.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.PNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pngData);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新资源窗口界面&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            AssetDatabase.Refresh();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ImageSlicer.cs&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;编译完成后会在Assets菜单下生成一个&lt;strong&gt;ImageSlicer/Process to Sprites&lt;/strong&gt;的菜单项，选中图片然后右键也可以看到。&lt;/p&gt;
&lt;h3&gt; 3、&lt;strong&gt;字体生成工具&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;字体生成工具也是Unity3d中一个第三方插件，名字也是BMFont（不知道和第一个软件有什么关联）。原本是NGUI中的一个字体制作工具，现被大佬剥离出来，在UGUI中也可以使用。&lt;/p&gt;
&lt;p&gt; 下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/imteach/BMFont.zip&quot; target=&quot;_blank&quot;&gt;BMFont字体生成工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 解压到Assets目录下即可，编译完成后，会在Unity编辑器上生成一个Tools/BMFont Maker菜单。&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt;三、开始制作&lt;/h2&gt;
&lt;blockquote readability=&quot;76.870233520544&quot;&gt;
&lt;h3&gt;1、切割图片&lt;/h3&gt;
&lt;p&gt;在字体数据制作软件BMFont64中，需要使用单个数字的图片，而我这个是一张包含所有数字和字母符号的整图，就需要切成单张散图。&lt;/p&gt;
&lt;p&gt;a) 把图片导入Unity，Sprite Mode选择Multiple模式，勾选Read/Write Enable选项。见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421024043367-1462741650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后点击Sprite Editor进行多图区域编辑，如下图。可以先按给定的三种方式进行划分，自己再做细微调整。注意每个字符边距不要太大，不然做成字体后显示起来就会很离散。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421024402885-1029033875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分割完成后，点击Apply保存操作。&lt;/p&gt;

&lt;p&gt;b) 选中图片右键，执行&lt;strong&gt;ImageSlicer/Process to Sprites&lt;/strong&gt;菜单，会生成一个与图片同名的目录，里边放着切割好的散图。见下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421025016329-647887132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、制作字体数据&lt;/h3&gt;
&lt;p&gt;a) 打开BMFont64软件，点击Edit下的Open Image Manager菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421025326578-1945288439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在打开的Image Manager窗口有一个&lt;strong&gt;Image&lt;/strong&gt;菜单，可以进行图片导入、编辑和删除操作。&lt;/p&gt;
&lt;p&gt;操作方式：这里以逗号字符为例，鼠标放在主窗口逗号方格的位置，右下会显示其编号，记住这个编号。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421025837892-1332394065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在Image Manager窗口中选择导入图片，选中切割成散图的逗号图片，在Icon Image弹窗的Id中填入逗号方格的编号：44，点击Ok。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421030243667-1351669124.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;176&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421030100475-1245514141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依样导入其它的图片，并填入Id值，最后的完成图如下：每个字符方格的编号，对应一个相应的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421040027494-1388174122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;b) 点击Options/Export options菜单，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421030733402-828696827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 打开导出选项窗口，这里边主要设置一个合成图片的宽和高，以及导出格式。&lt;/p&gt;
&lt;p&gt;这个软件的最后一步操作是导出字体数据，包括一个字体数据文件（.fnt格式）和一张纹理图。这个纹理图会把所有的单图又合成一张。&lt;/p&gt;
&lt;p&gt;这里的Width是指这张合成纹理的总宽度（最好比所有图片加起来的数值要大一点，因为每个数字图片合成时会有一个px的间隔），&lt;/p&gt;
&lt;p&gt;Height是单个图片的高度（最好比图片高1像素以上）。&lt;/p&gt;
&lt;p&gt;不能一次设置准确也没关系，可以点击Options/Visualize菜单预览合成效果，再微调高宽值，最终让所有图片都能刚刚显示为好。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421030858259-1513771897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导出格式格式设置为png。（如果图片有模糊可把Bit depth设置为32位试试，瞎猜的，不一定有用）&lt;/p&gt;
&lt;p&gt;合成图预览如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421031837566-1765357104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;c)  点击Options/Save bitmap font as..菜单，选择位置后进行保存操作，最终会得到两个文件（ArtNum.fnt和ArtNum_0.png），如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421032405169-308208933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字体名字可以自由定义，导出的时候，每个方格要处在选中状态（浅灰色）。&lt;/p&gt;
&lt;p&gt;关于BMFont64软件的操作，也可以参考文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/imteach/p/7477947.html&quot;&gt;Unity教程之-UGUI美术字体的制作与使用&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3、生成字体&lt;/h3&gt;
&lt;p&gt;a)将上述两个文件导入到Unity中，在资源面板中鼠标右键，选择&lt;strong&gt;Create/Material&lt;/strong&gt;和&lt;strong&gt;Create/Custom Font&lt;/strong&gt;菜单，&lt;/p&gt;
&lt;p&gt;创建一个空的材质ArtNum_mat和一个空的自定义字体ArtNum（后缀为.fontsettings，在Unity中不显示），如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421033046855-962701226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b) 点击Tools/BMFont Maker菜单，在打开的窗口中，选择相应的文件进行赋值，如下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421033549750-1160553201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后点击Create BMFont按钮，这样一个美术字体就生成了。&lt;/p&gt;
&lt;p&gt;点击字体文件，能在Inspector面板的Character Rects中看到字体的映射信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421033752033-1058879601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;c) 创建一个Text，输入一些数字字母和符号，字体选择为ArtNum，颜色选为白色，就能看到实际的效果。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201904/634826-20190421034151016-1135132740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;美术字体制作完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;后记&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;使用这种字体的一些小问题&lt;br/&gt;1、字体不会换行，超出宽度的字体将会重叠显示，需要预留出宽度。&lt;/p&gt;
&lt;p&gt;2、字体不受Font Size的影响，无法动态调整大小，如有需要，可通过设置Scale来解决。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Sat, 20 Apr 2019 19:51:00 +0000</pubDate>
<dc:creator>子非鱼`</dc:creator>
<og:description>一、需求 游戏开发中经常遇到需要以美术字（而非字库）做数字显示的情况，通常美术会提供一组包含单个数字（也会有其它字符）的图片，可能是一张整图，也可能是每个数字分开的散图。 在此我以一张整图这种情况为例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imteach/p/10743725.html</dc:identifier>
</item>
<item>
<title>Vue依赖收集引发的问题 - DanceOnBeat</title>
<link>http://www.cnblogs.com/danceonbeat/p/10743660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danceonbeat/p/10743660.html</guid>
<description>&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;在我们的项目中有一个可视化配置的模块，是通过go.js生成canvas来实现的。但是，我们发现这个模块在浏览器中经常会引起该tab页崩溃。开启chrome的任务管理器一看，进入该页面内存和cpu就会暴涨，内存经常会飙到700多M。但是我们的canvas实际的像素只有约500x500，根据一些粗略的计算，大概只占了1M的内存，这个计算过程可参考&lt;a href=&quot;https://juejin.im/post/5bdeb357e51d4536140fc7df&quot;&gt;100*100的 canvas 占多少内存&lt;/a&gt;。那么我们这700M内存是哪里来的呢？&lt;/p&gt;
&lt;h2 id=&quot;定位问题&quot;&gt;定位问题&lt;/h2&gt;
&lt;p&gt;我们可以使用chrome开发者工具来分析我们的调用栈。这边我是先通过Performance来帮助我们定位问题，它会帮我们生成一段过程中一些数据的变化，包括js堆内存、dom节点数量、动画帧等数据，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145753/201904/1145753-20190421020517435-231685581.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是切换至一个canvas画布较大的一个模块的performance分析表现，可以看到占用了472M的内存。下面折线图蓝色部分是js堆内存的变化，而Main下面黄色与紫色的矩形框就是我们的调用栈，上下两部分是按照时间一一对应的。可以看到，蓝色的折线呈高低起伏的态势，GC回收之后低点基本和高点持平，因此可以断定几乎不存在内存泄漏的问题。然后我们可以放大去看一看，内存升高的时候，js做了些什么事情，找一找规律。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145753/201904/1145753-20190421020538779-33702406.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们随机找一段内存增长的区域，可以看到在内存增长的过程中，最为频繁调用的就是Observer相关的代码。但是就这么看，我们不能够明白Observer是在干什么。此时我们可以借用Memory选项中的Allocation Sampling按照javascript function来查看内存分配，我们同样录制以上的一段操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145753/201904/1145753-20190421020553614-1020360986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们能够清楚的看到，的确是这个Observer在作怪。同时，我们可以看到这是vue的代码，点击右边的文件查看source code，就可以清楚的明白这就是vue在执行依赖收集的操作，此时会给属性添加watcher。那我们这里为什么会有如此多的属性被添加了watcher呢？看了一下代码，原来是我把go.js的一个实例挂到了vue的data选项中，放到data中的属性会被vue执行依赖收集的相关操作，而这个实例拥有非常多的嵌套属性，全部都会被添加watcher。其实，我们只是想单纯的存储一下这个实例，供我们后续调用其相关的方法，添加watcher对我们来说完全没有意义，那我们如何避免这样的问题呢？&lt;/p&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;解决问题&lt;/h2&gt;
&lt;p&gt;上网搜索了相关的解决方案，大概有如下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在data中定义的属性前面加上$，即通知vue该属性不需要被依赖收集，例如：&lt;code&gt;javascript data() { return { $goDiagram: null } }&lt;/code&gt;但是这样声明，在template中引用时会报找不到$goDiagram属性的错误，具体的原因我还没深究，有空可以研究一下。&lt;/li&gt;
&lt;li&gt;不在data中声明，直接在赋值的时候声明this.goDiagram = diagram。这同样会遇到第一种方案的问题，模板中会提示找不到goDiagram属性。&lt;/li&gt;
&lt;li&gt;不在data中声明，而是利用$options来存储goDiagram，例如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;export default {
    goDiagram: null,
    mounted() {
        this.$options.goDiagram = xxx
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这应该是比较好的一个方法，vue官方中也说明了$options用来包含自定义属性，例如我们平时引入的常量或是枚举类型，我们也不希望它们被添加无意义的watcher，因此可以通过这种方式来定义，在template中引用时只需要{{$options.xxx}}即可。这种方式唯一的缺点就是不能像data那样一眼望去就能清楚地知道你定义了什么属性。&lt;br/&gt;项目中我采用了第一种方式，经过修改后内存占用量减少到原来的1/5到1/6，可以说效果非常好，再也不会出现浏览器崩溃的情况了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过这样的一个问题，我们主要能够学习到两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何通过chrome的开发者工具，去快速地定位代码中存在的内存问题&lt;/li&gt;
&lt;li&gt;不要盲目的将属性都挂载到data选项中，一些常量我们可以采取上面提到的几种方式来定义，以此来作为一种优化手段&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 20 Apr 2019 18:04:00 +0000</pubDate>
<dc:creator>DanceOnBeat</dc:creator>
<og:description>问题背景 在我们的项目中有一个可视化配置的模块，是通过go.js生成canvas来实现的。但是，我们发现这个模块在浏览器中经常会引起该tab页崩溃。开启chrome的任务管理器一看，进入该页面内存和c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danceonbeat/p/10743660.html</dc:identifier>
</item>
<item>
<title>一键生成微信个人专属数据报告,了解你的微信社交历史 - 云外孤鸟</title>
<link>http://www.cnblogs.com/cloudbird/p/10743642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudbird/p/10743642.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;你是否想过生成一份属于你的微信个人数据报告，了解你的微信社交历史。现在，我们基于python对微信好友进行全方位数据分析，包括：昵称、性别、年龄、地区、备注名、个性签名、头像、群聊、公众号等。&lt;/p&gt;
&lt;p&gt;其中，在分析好友类型方面，主要统计出你的陌生人、星标好友、不让他看我的朋友圈的好友、不看他的朋友圈的好友数据。在分析地区方面，主要统计所有好友在全国的分布以及对好友数最多的省份进行进一步分析。在其他方面，统计出你的好友性别比例、猜出你最亲密的好友，分析你的特殊好友，找出与你所在共同群聊数最多的好友数据，对你的好友个性签名进行分析，对你的好友头像进行分析，并进一步检测出使用真人头像的好友数据。&lt;/p&gt;
&lt;p&gt;目前网上关于这方面的数据分析文章比较多，但是运行起来比较麻烦，&lt;strong&gt;而本程序的运行十分简单，只需要扫码登录一步操作即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;功能截图&quot;&gt;功能截图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example1.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example2.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example3.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example4.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example5.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example6.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example7.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example8.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example9.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shengqiangzhang/examples-of-web-crawlers/master/8.%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%91%8A(%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%A4%BE%E4%BA%A4%E5%8E%86%E5%8F%B2)/example10.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何运行&quot;&gt;如何运行&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 跳转到当前目录
cd 目录名
# 先卸载依赖库
pip uninstall -y -r requirement.txt
# 再重新安装依赖库
pip install -r requirement.txt
# 开始运行
python generate_wx_data.py&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何打包成二进制可执行文件&quot;&gt;如何打包成二进制可执行文件&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 安装pyinstaller
pip install pyinstaller
# 跳转到当前目录
cd 目录名
# 先卸载依赖库
pip uninstall -y -r requirement.txt
# 再重新安装依赖库
pip install -r requirement.txt
# 更新 setuptools
pip install --upgrade setuptools
# 开始打包
pyinstaller generate_wx_data.py&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写思路&quot;&gt;编写思路&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;首先，进行初始化，并根据不同操作系统，启用微信机器人。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 初始化所需文件夹
    init_folders()


    # 启动微信机器人，自动根据操作系统执行不同的指令
    if('Windows' in system()):
        # Windows
        bot = Bot(cache_path=True)
    elif('Darwin' in system()):
        # MacOSX
        bot = Bot(cache_path=True)
    elif('Linux' in system()):
        # Linux
        bot = Bot(console_qr=2,cache_path=True)
    else:
        # 自行确定
        print(u&quot;无法识别你的操作系统类型，请自己设置&quot;)
        exit()&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;登录完微信后，开始获取好友数据和群聊数据。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 获取所有好友
friends = bot.friends(update=False)

# 获取所有活跃群聊
groups = bot.groups()&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;共同所在群聊成员分析，依次对每个好友进行检测。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def group_common_in():

    # 获取所有活跃的群聊
    groups = bot.groups()

    # 每个好友与你相同的群聊个数
    dict_common_in = {}

    # 遍历所有好友，第0个为你自己，所以去掉
    for x in friends[1:]:
        # 依次在每个群聊中搜索
        for y in groups:
            # x在y中
            if(x in y):
                # 获取微信名称
                name = x.nick_name
                # 判断是否有备注，有的话就使用备注
                if(x.remark_name and x.remark_name != ''):
                    name = x.remark_name

                # 增加计数
                if(name in dict_common_in.keys()):
                    dict_common_in[name] += 1
                else:
                    dict_common_in[name] = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;获取微信好友头像，以便进一步分析。这里下载头像比较慢，所以采取多线程方式进行下载。在多线程中，使用队列保存我们的头像url，不同线程从队列中获取头像url，并下载到本地。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    # 创建一个队列，用于多线程下载头像，提高下载速度
    queue_head_image = Queue()

    # 将每个好友元素存入队列中
    # 如果为了方便调试，可以仅仅插入几个数据，friends[1:10]
    for user in friends:
        queue_head_image.put(user)

    # 启动10个线程下载头像
    for i in range(1, 10):
        t = Thread(target=download_head_image,args=(i,))
        t.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;download_head_image&lt;/code&gt;的具体实现为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 下载好友头像，此步骤消耗时间比较长
def download_head_image(thread_name):

    # 队列不为空的情况
    while(not queue_head_image.empty()):
        # 取出一个好友元素
        user = queue_head_image.get()

        # 下载该好友头像，并保存到指定位置，生成一个15位数的随机字符串
        random_file_name = ''.join([str(random.randint(0,9)) for x in range(15)])
        user.get_avatar(save_path='image/' + random_file_name + '.jpg')

        # 输出提示
        print(u'线程%d:正在下载微信好友头像数据，进度%d/%d，请耐心等待……' %(thread_name, len(friends)-queue_head_image.qsize(), len(friends)))&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;进行性别、地区统计，并将生产的html文件保存到本地。这里没什么难度，所以就不详细展开了。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 分析好友性别比例
def sex_ratio():

    # 初始化
    male, female, other = 0, 0, 0

    # 遍历
    for user in friends:
        if(user.sex == 1):
            male += 1
        elif(user.sex == 2):
            female += 1
        else:
            other += 1

    name_list = ['男性', '女性', '未设置']
    num_list = [male, female, other]

    pie = Pie(&quot;微信好友性别比例&quot;)
    pie.add(&quot;&quot;, name_list, num_list, is_label_show=True)
    pie.render('data/好友性别比例.html')&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;分析你认识的好友、最亲密的人以及特殊好友。以特殊好友为例，我们将好友分为星标好友(很重要的人), 不让他看我的朋友圈的好友, 不看他朋友圈的好友, 消息置顶好友, 陌生人。这里分类的依据是根据itchat中的&lt;code&gt;StarFriend&lt;/code&gt;和&lt;code&gt;ContactFlag&lt;/code&gt;而来的。根据经验可知，&lt;code&gt;StarFriend&lt;/code&gt;为1表示为星标好友，&lt;code&gt;ContactFlag&lt;/code&gt;为1和3表示好友，259和33027表示不让他看我的朋友圈，65539和65537和66051表示不看他的朋友圈，65795表示两项设置全禁止, 73731表示陌生人。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 特殊好友分析
def analyze_special_friends():

    # 星标好友(很重要的人), 不让他看我的朋友圈的好友, 不看他朋友圈的好友, 消息置顶好友, 陌生人
    star_friends, hide_my_post_friends, hide_his_post_friends, sticky_on_top_friends, stranger_friends = 0, 0, 0, 0, 0

    for user in friends:


        # 星标好友为1,为0表示非星标,不存在星标选项的为陌生人
        if('StarFriend' in (user.raw).keys()):
            if((user.raw)['StarFriend'] == 1):
                star_friends += 1
        else:
            stranger_friends += 1

        # 好友类型及权限：1和3好友，259和33027不让他看我的朋友圈，65539和65537和66051不看他的朋友圈，65795两项设置全禁止, 73731陌生人
        if((user.raw)['ContactFlag'] in [259, 33027, 65795]):
            hide_my_post_friends += 1
        if ((user.raw)['ContactFlag'] in [66051, 65537, 65539, 65795]):
            hide_his_post_friends += 1

        # 消息置顶好友为2051
        if ((user.raw)['ContactFlag'] in [2051]):
            sticky_on_top_friends += 1

        # 陌生人
        if ((user.raw)['ContactFlag'] in [73731]):
            stranger_friends += 1


    bar = Bar('特殊好友分析')
    bar.add(name='', x_axis=['星标', '不让他看我朋友圈', '不看他朋友圈', '消息置顶', '陌生人'], y_axis=[star_friends, hide_my_post_friends, hide_his_post_friends, sticky_on_top_friends, stranger_friends], legend_orient=&quot;vertical&quot;, legend_pos=&quot;left&quot;)
    bar.render('data/特殊好友分析.html')
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;对好友个性签名进行分析，并绘制出词语。这里比较复杂，首先将个性签名列表转化为字符串，调用nlp处理接口，对返回的数据进行过滤。同时，对短语进行分词，过滤，词频统计操作。最后，使用pyechart进行绘制词语图。代码中注释非常多，基本都能看懂，所以在此也无需再详细展开了。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 分析个性签名
def analyze_signature():

    # 个性签名列表
    data = []
    for user in friends:

        # 清除签名中的微信表情emoj，即&amp;lt;span class.*?&amp;lt;/span&amp;gt;
        # 使用正则查找并替换方式，user.signature为源文本，将&amp;lt;span class.*?&amp;lt;/span&amp;gt;替换成空
        new_signature = re.sub(re.compile(r&quot;&amp;lt;span class.*?&amp;lt;/span&amp;gt;&quot;, re.S), &quot;&quot;, user.signature)

        # 只保留签名为1行的数据，过滤为多行的签名
        if(len(new_signature.split('\n')) == 1):
            data.append(new_signature)

    # 将个性签名列表转为string
    data = '\n'.join(data)

    # 进行分词处理，调用接口进行分词
    # 这里不使用jieba或snownlp的原因是无法打包成exe文件或者打包后文件非常大
    postData = {'data':data, 'type':'exportword', 'arg':'', 'beforeSend':'undefined'}
    response = post('http://life.chacuo.net/convertexportword',data=postData)
    data = response.text.replace('{&quot;status&quot;:1,&quot;info&quot;:&quot;ok&quot;,&quot;data&quot;:[&quot;', '')
    # 解码
    data = data.encode('utf-8').decode('unicode_escape')

    # 将返回的分词结果json字符串转化为python对象，并做一些处理
    data = data.split(&quot;=====================================&quot;)[0]

    # 将分词结果转化为list，根据分词结果，可以知道以2个空格为分隔符
    data = data.split('  ')

    # 对分词结果数据进行去除一些无意义的词操作
    stop_words_list = [',', '，', '、', 'the', 'a', 'is', '…', '·', 'э', 'д', 'э', 'м', 'ж', 'и', 'л', 'т', 'ы', 'н', 'з', 'м', '…', '…', '…', '…', '…', '、', '.', '。', '!', '！', ':', '：', '~', '|', '▽', '`', 'ノ', '♪', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '\'', '‘', '’', '“', '”', '的', '了', '是', '你', '我', '他', '她','=', '\r', '\n', '\r\n', '\t', '以下关键词', '[', ']', '{', '}', '(', ')', '（', '）', 'span', '&amp;lt;', '&amp;gt;', 'class', 'html', '?', '就', '于', '下', '在', '吗', '嗯']
    tmp_data = []
    for word in data:
        if(word not in stop_words_list):
            tmp_data.append(word)
    data = tmp_data


    # 进行词频统计，结果存入字典signature_dict中
    signature_dict = {}
    for index, word in enumerate(data):

        print(u'正在统计好友签名数据，进度%d/%d，请耐心等待……' % (index + 1, len(data)))

        if(word in signature_dict.keys()):
            signature_dict[word] += 1
        else:
            signature_dict[word] = 1

    # 开始绘制词云
    name = [x for x in signature_dict.keys()]
    value = [x for x in signature_dict.values()]
    wordcloud = WordCloud('微信好友个性签名词云图')
    wordcloud.add(&quot;&quot;, name, value, shape='star', word_size_range=[1,100])
    wordcloud.render('data/好友个性签名词云.html')
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;拼接所有好友头像，这里使用到PIL的图像处理功能，首先对头像个数进行统计，自适应生成矩形图片。由于我们知道微信头像尺寸为640 * 640，所以处理起来就很方便了。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 拼接所有微信好友头像
def merge_head_image():
    # 拼接头像
    pics = listdir('image')  # 得到user目录下的所有文件，即各个好友头像
    numPic = len(pics)
    eachsize = int(math.sqrt(float(640 * 640) / numPic))  # 先圈定每个正方形小头像的边长，如果嫌小可以加大
    numrow = int(640 / eachsize)
    numcol = int(numPic / numrow)  # 向下取整
    toImage = Image.new('RGB', (eachsize * numrow, eachsize * numcol))  # 先生成头像集模板

    x = 0  # 小头像拼接时的左上角横坐标
    y = 0  # 小头像拼接时的左上角纵坐标

    for index, i in enumerate(pics):

        print(u'正在拼接微信好友头像数据，进度%d/%d，请耐心等待……' % (index + 1, len(pics)))

        try:
            # 打开图片
            img = Image.open('image/' + i)
        except IOError:
            print(u'Error: 没有找到文件或读取文件失败')
        else:
            # 缩小图片
            img = img.resize((eachsize, eachsize), Image.ANTIALIAS)
            # 拼接图片
            toImage.paste(img, (x * eachsize, y * eachsize))
            x += 1
            if x == numrow:
                x = 0
                y += 1

    toImage.save('data/拼接' + &quot;.jpg&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;检测使用人脸作为头像的好友数量，这里使用到opencv的人脸检测功能，使用opencv默认的模型进行检测。首先载入图片，并进行灰度处理，最后加载人脸识别模型进行检测，若检测到脸数大于0，则说明存在。同时要注意的是，对错误的头像要进行舍弃操作。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 检测使用真实人脸的好友个数
def detect_human_face():

    # 得到user目录下的所有文件名称，即各个好友头像
    pics = listdir('image')

    # 使用人脸的头像个数
    count_face_image = 0

    # 存储使用人脸的头像的文件名
    list_name_face_image = []

    # 加载人脸识别模型
    face_cascade = CascadeClassifier('model/haarcascade_frontalface_default.xml')

    for index, file_name in enumerate(pics):
        print(u'正在进行人脸识别，进度%d/%d，请耐心等待……' % (index+1, len(pics)))
        # 读取图片
        img = imread('image/' + file_name)

        # 检测图片是否读取成功，失败则跳过
        if img is None:
            continue

        # 对图片进行灰度处理
        gray = cvtColor(img, COLOR_BGR2GRAY)
        # 进行实际的人脸检测，传递参数是scaleFactor和minNeighbor,分别表示人脸检测过程中每次迭代时图
        faces = face_cascade.detectMultiScale(gray, 1.3, 5)
        if (len(faces) &amp;gt; 0):
            count_face_image += 1
            list_name_face_image.append(file_name)

    print(u'使用人脸的头像%d/%d' %(count_face_image,len(pics)))&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;所有数据统计完后，我们生产一个总的html网页文件，方便我们直接查看。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 生成一个html文件，并保存到文件file_name中
def generate_html(file_name):
    with open(file_name, 'w', encoding='utf-8') as f:
        data = '''
            &amp;lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8'&amp;gt;
            &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
            &amp;lt;title&amp;gt;一键生成微信个人专属数据报告(了解你的微信社交历史)&amp;lt;/title&amp;gt;
            &amp;lt;meta name='keywords' content='微信个人数据'&amp;gt;
            &amp;lt;meta name='description' content=''&amp;gt;
            &amp;lt;iframe name=&quot;iframe1&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/好友地区分布.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe2&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/某省好友地区分布.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe3&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/好友性别比例.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe4&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/你认识的好友比例.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe5&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/你最亲密的人.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe6&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/特殊好友分析.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe7&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/共同所在群聊分析.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe8&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/好友个性签名词云.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe9&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/微信好友头像拼接图.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
            &amp;lt;iframe name=&quot;iframe10&quot; marginwidth=0 marginheight=0 width=100% height=60% src=&quot;data/使用人脸的微信好友头像拼接图.html&quot; frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;
        '''
        f.write(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;p&gt;完整版源代码存放在&lt;a href=&quot;https://github.com/shengqiangzhang/examples-of-web-crawlers&quot;&gt;github&lt;/a&gt;上，有需要的可以下载&lt;/p&gt;
&lt;p&gt;项目持续更新，欢迎您&lt;a href=&quot;https://github.com/shengqiangzhang/examples-of-web-crawlers&quot;&gt;star本项目&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 17:41:00 +0000</pubDate>
<dc:creator>云外孤鸟</dc:creator>
<og:description>你是否想过生成一份属于你的微信个人数据报告，了解你的微信社交历史。现在，我们基于python对微信好友进行全方位数据分析，包括：昵称、性别、年龄、地区、备注名、个性签名、头像、群聊、公众号等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudbird/p/10743642.html</dc:identifier>
</item>
<item>
<title>TiDB之mac上搭建及调试技巧 - mantu</title>
<link>http://www.cnblogs.com/mantu/p/10743637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantu/p/10743637.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;由于本人最近已经成为TiDB的粉丝，所以就开始各种研究TiDB的源码，研究源码这个事情，首先就需要在自己电脑上不断的调试及修改。TiDB本身的代码是非常容易编译和调试的，但是要把PD、TiKV集群同时在本机上建立起来，还是有一点难度的。好在pingcap官方提供了docker-compose搭建集群的方式，可以快速的在个人电脑上启动一个TiDB的集群。但是，我要的不只是一个集群，我还希望在我的mac上实时编译调试TiDB服务，这个TiDB服务能够和docker-compose的集群里的PD和TiKV进行实时的通讯。我今天仔细分析了一下，最终总结出两个问题需要解决：&lt;/p&gt;
&lt;ul data-source-line=&quot;3&quot;&gt;&lt;li&gt;PD和TiKV的端口需要暴露给宿主机；&lt;/li&gt;
&lt;li&gt;宿主机上的TiDB服务需要解决docker-compose服务内部域名调用的问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-source-line=&quot;6&quot;&gt;第一个问题比较容易解决，docker本身就提供了解决方案，就是把docker内部的端口映射给宿主机，这样在宿主机上就可以直接访问这个端口。第二个问题，我还是思考了一会，最后决定使用修改本机host的方式来完成映射。&lt;/p&gt;
&lt;ul data-source-line=&quot;7&quot;&gt;&lt;li&gt;mac上需要增加的host如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;pd0
127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;pd1
127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;pd2
127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;tikv0
127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;tikv1
127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;span class=&quot;hljs-selector-class&quot;&gt;.1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;tikv2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;16&quot;&gt;大家一看也就明白了，我就是想把docker集群内部这样的api：pd0:2379，在宿主机上转换成为：127.0.0.1:2379的方式。&lt;/p&gt;
&lt;ul data-source-line=&quot;17&quot;&gt;&lt;li&gt;拉取docker-compose&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;19&quot;&gt;由于需要把docker内部的端口映射到宿主机上，因此我修改了官方的docker-compose.yml文件，大家可以直接使用我fork并修改的tidb-docker-compose项目。&lt;/p&gt;
&lt;pre data-source-line=&quot;20&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;git &lt;span class=&quot;hljs-keyword&quot;&gt;clone &lt;span class=&quot;hljs-title&quot;&gt;https://github.com/mantuliu/tidb-docker-compose.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-source-line=&quot;23&quot;&gt;&lt;li&gt;创建并启用集群&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;24&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cd tidb-docker-compose &amp;amp;&amp;amp; docker-compose pull 
docker-compose up -&lt;span class=&quot;hljs-built_in&quot;&gt;d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-source-line=&quot;28&quot;&gt;&lt;li&gt;关闭集群&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;29&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;docker-compose down
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-source-line=&quot;32&quot;&gt;&lt;li&gt;在mac上启动TiDB服务&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;34&quot;&gt;我的mac上是下面类似这样的命令：&lt;/p&gt;
&lt;pre data-source-line=&quot;35&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;./bin/tidb-server -P 4001 &lt;span class=&quot;hljs-params&quot;&gt;--status=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10081&quot;  &lt;span class=&quot;hljs-params&quot;&gt;--path=&lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1:3379,127.0.0.1:4379,127.0.0.1:5379&quot; &lt;span class=&quot;hljs-params&quot;&gt;--config=&lt;span class=&quot;hljs-string&quot;&gt;./conf/tidb.toml

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p data-source-line=&quot;40&quot;&gt;这种方式呢，感觉还是不太完美，但是确实解决了我当前的困境。提升了我目前研究TiDB源码的效率，不必再依赖于具体的集群环境，我走到哪里，都可以随时调试和研究TiDB的源码。后面如果我了解到更NB的方式，会随时分享给大家。虽然文章的标题是mac上的解决方案，但是换汤不换药，在windows平台上也是一样的，增加具体host映射即可。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 17:37:00 +0000</pubDate>
<dc:creator>mantu</dc:creator>
<og:description>由于本人最近已经成为TiDB的粉丝，所以就开始各种研究TiDB的源码，研究源码这个事情，首先就需要在自己电脑上不断的调试及修改。TiDB本身的代码是非常容易编译和调试的，但是要把PD、TiKV集群同时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantu/p/10743637.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]对象字典缓存（百万军中取敌首级） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_singlecache.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_singlecache.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netcore，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 770+）&lt;/p&gt;


&lt;p&gt;前文提到了以sql为key的数据层缓存，以及整表缓存的实体列表缓存，各自有其优缺点，适用于不同场合。&lt;/p&gt;
&lt;p&gt;当单表数据较大（10万+）时，两者就无能为力了。天空一道巨响，对象字典缓存隆重登场！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对象字典缓存：以主键为key，缓存实体对象，以满足应用层的高频单点查询需求！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;例程跑起来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421000723763-2083029259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421000754061-678619780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421000822956-1811440987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先给学生表加了100万行，再随机生成1024个编号，然后查询1000万次。速度200万qps，命中率99.99%。&lt;/p&gt;


&lt;p&gt;Student.FindByID内使用了单对象缓存：&lt;strong&gt;&lt;span&gt;Meta.SingleCache[id]&lt;/span&gt;&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;单对象缓存本质就是并行字典，因此使用方式上只需要直接索引器查找即可。&lt;/p&gt;

&lt;p&gt;在Meta.SingleCache内查找id时，如果已存在，则直接返回，否则执行委托Student.FindByKey查找对象后缓存起来。&lt;/p&gt;
&lt;p&gt;非XCode用户，也可以根据该思想设计自己的缓存。&lt;/p&gt;

&lt;p&gt;单对象缓存也有过期时间，默认10秒，过期后异步更新（老规矩，为了性能）。&lt;/p&gt;
&lt;p&gt;单对象缓存还会根据LRU定期清理缓存，此时采用最后访问时间而不是过期时间。&lt;/p&gt;

&lt;p&gt;对象缓存还有最大缓存数限制，默认10000个，超过时删除最久未访问缓存数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421001941963-1770541525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421004554814-2095588637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;因此，&lt;span&gt;&lt;strong&gt;单对象缓存特别适用于单行特点很突出且修改不多的数据，如用户表、产品表&lt;/strong&gt;&lt;/span&gt;等。&lt;/p&gt;
&lt;p&gt;即使目标表有千万级数据，单对象字典缓存仍然可以轻松的取敌首级！^_^&lt;/p&gt;


&lt;p&gt; 前面实例展示了根据ID查找缓存对象，实际应用场景，还可能会根据名称进行查找，总不能另外搞一个对象缓存吧？&lt;/p&gt;
&lt;p&gt;来自深圳的海洋饼干，既有创意的解决了这个问题，发明了从键缓存！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421003407947-1279788927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，Meta.SingleCache.GetItemWithSlaveKey(name) 实现了根据 name 查询用户。&lt;/p&gt;
&lt;p&gt;在此之前，需要手工配置查询方法，因为XCode已经无法猜测得知。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421003726506-1691993223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 使用从键缓存后，等于有两个入口（FindKey/FindSlaveKey）查询数据库，得到一个实体对象后，分别加入主键字典和从键字典，用于两个维度索引查询。&lt;/p&gt;
&lt;p&gt;因此，从键缓存需要配置根据从键查数据库的方法FindSlaveKeyMethod，同时还需要配置实体对象获取从键值的方法GetSlaveKey，因为主键查库后加入从键缓存时，需要从对象内得到从键值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190421005015524-1302909591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;所有缓存都必须有过期策略。单对象字典缓存的过期策略有以下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化。首次访问缓存时，无需阻塞，并行查询。&lt;/li&gt;
&lt;li&gt;定时过期。缓存过期后，开异步线程更新并同时返回旧数据，确保应用层性能。设置文件的 SingleCacheExpire， 默认10秒&lt;/li&gt;
&lt;li&gt;添删改过期。对实体类的添删改操作完成后，都会直接修改缓存对应项。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显然，初始化加载以后，将来访问的永远是定时更新的缓存数据，应用层可以得到非常好的性能！&lt;/p&gt;
&lt;p&gt;由于缓存的添删改过期跟实体操作绑定在一起，因此，越过实体类直接DAL执行更新操作，或者其它服务器修改数据，此时无法影响实体缓存，导致数据更新不及时。&lt;/p&gt;
&lt;p&gt;早期版本XCode缓存默认过期时间60秒，随着数据库性能提升，默认值修改为10秒，可根据实际场景设置。&lt;/p&gt;




&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 20 Apr 2019 16:58:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>前文提到了以sql为key的数据层缓存，以及整表缓存的实体列表缓存，各自有其优缺点，适用于不同场合。 当单表数据较大（10万+）时，两者就无能为力了。天空一道巨响，对象字典缓存隆重登场！ 对象字典</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_singlecache.html</dc:identifier>
</item>
<item>
<title>JdbcTemplate的一次爬坑记录 - 涅槃重生，</title>
<link>http://www.cnblogs.com/maolinjava/p/10743522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maolinjava/p/10743522.html</guid>
<description>&lt;p&gt;　　时隔三个多月，我终于想起我还有个博客，其实也不是忘了我这个博客，只是平时工作繁忙没时间去写博客，故今晚腾出时间来记录一下上次工作中遇到的一个问题，给园友们分享出来，以免入坑。&lt;/p&gt;

&lt;p&gt;　　上个星期在工作中使用JdbcTemplate执行了一个select * from table where id in (?,?,?) and name = ? 的SQL，这个SQL大家都明白什么意思吧，然后我得给这几个 &quot;?&quot; 赋值，没问题吧。可是在执行的时候给我报了一个异常：&lt;span&gt;&lt;strong&gt;java.sql.SQLException: No value specified for parameter 3     &lt;/strong&gt;&lt;/span&gt; 纳尼？这就有点奇怪了，几个意思？是因为jdbcTemplate这个对象不支持括号内的问号和括号外的问号同时出现，什么意思呢？就是说  where id in (?) 是正确的  where name  = ? 也是正确的，但是  where id in (?) and name = ? 就不支持了；需要将 &lt;span&gt;&lt;strong&gt;jdbcTemplate &lt;/strong&gt;&lt;/span&gt;对象换成 &lt;span&gt;&lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt;&lt;/span&gt; 即可，下面我会把代码贴出来，首先创建一个SpringBoot项目，将Web，MySQL，Jdbc，Lombok的依赖导入进去，然后我们开始撸代码：&lt;/p&gt;
&lt;p&gt;　　我们先来看一下数据库的数据：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201904/1305443-20190420235037818-59009643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是建表语句，有需要的同志们可以复制过去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('371080a3-fa80-4592-b14e-2765b9ba786d')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_371080a3-fa80-4592-b14e-2765b9ba786d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_371080a3-fa80-4592-b14e-2765b9ba786d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('371080a3-fa80-4592-b14e-2765b9ba786d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_371080a3-fa80-4592-b14e-2765b9ba786d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t_book` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `isbn` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `publish` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `publisher` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　实体类和表映射的RowMapper实现类的代码就不贴了，按照表字段去建一个就可以了，这一步跳过&lt;/p&gt;
&lt;p&gt;　　下面是controller和dao的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4a06c956-4dbe-4d1f-82bc-b0a900a09fc1')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_4a06c956-4dbe-4d1f-82bc-b0a900a09fc1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4a06c956-4dbe-4d1f-82bc-b0a900a09fc1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4a06c956-4dbe-4d1f-82bc-b0a900a09fc1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4a06c956-4dbe-4d1f-82bc-b0a900a09fc1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RequestMapping(&lt;/span&gt;&quot;/api/v1/book&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookRestController {

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ObjectMapper jsonMapper;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里为了方便就省略service层，直接将dao注入进来了&lt;/span&gt;
&lt;span&gt;    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BookDAO bookDAO;

    @GetMapping(&lt;/span&gt;&quot;/list&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonNode list(){
        ObjectNode respJson &lt;/span&gt;=&lt;span&gt; jsonMapper.createObjectNode();
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; idList = Arrays.asList(1, 2, 3&lt;span&gt;);
        String name &lt;/span&gt;= &quot;mybatis从入门到精通&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;TBook&amp;gt; bookList =&lt;span&gt; bookDAO.selectByDynamicParams(idList, name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; respJson.putPOJO(&quot;data&quot;&lt;span&gt;,bookList);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2fc633f2-73bb-4e8c-b2c4-b267b79376f9')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_2fc633f2-73bb-4e8c-b2c4-b267b79376f9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2fc633f2-73bb-4e8c-b2c4-b267b79376f9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2fc633f2-73bb-4e8c-b2c4-b267b79376f9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2fc633f2-73bb-4e8c-b2c4-b267b79376f9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
@Component(&quot;bookDAO&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookDAOImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookDAO {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TBook&amp;gt; selectByDynamicParams(List&amp;lt;Integer&amp;gt;&lt;span&gt; idList, String name) {
        StringBuffer sql &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        sql.append(&lt;/span&gt;&quot;select * from t_book where id in ( &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拼装？&lt;/span&gt;
        List&amp;lt;String&amp;gt; stringList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; idList.size();i++&lt;span&gt;){
            stringList.add(&lt;/span&gt;&quot;?&quot;&lt;span&gt;);
        }
        sql.append(String.join(&lt;/span&gt;&quot;,&quot;&lt;span&gt;,stringList));
        sql.append(&lt;/span&gt;&quot; ) and name = ?&quot;&lt;span&gt;);

        System.err.println(sql.toString());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; jdbcTemplate.query(sql.toString(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookMapper(),idList,name);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　好了，执行一把，看一下结果吧，访问 &lt;span&gt;&lt;strong&gt;localhost:8080/api/v1/book/list &lt;/strong&gt;&lt;/span&gt; ,控制台保如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201904/1305443-20190420235906424-160837687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看出来，SQL语句的没有问题的，那么我们尝试换一种写法，使用 &lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt; ，由于spring默认是加载jdbcTemplate的，所以NamedParameterJdbcTemplate 对象需要我们自己去配置，创建一个配置类或者直接在启动类配置也可以，启动类其实就是一个配置类，进行如下配置：&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从容器中将dataSource这个对象注入进来&lt;/span&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DataSource dataSource;

@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate namedParameterJdbcTemplate(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要构造NamedParameterJdbcTemplate对象需要依赖dataSource&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate(dataSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　dao层将NamedParameterJdbcTemplate 对象注入进来并执行SQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
@Component(&quot;bookDAO&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookDAOImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookDAO {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TBook&amp;gt; selectByDynamicParams(List&amp;lt;Integer&amp;gt;&lt;span&gt; idList, String name) {
        String sql &lt;/span&gt;= &quot;select * from t_book where id in (:idList) and name = :bookName&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 集合中的key一定要与sql中定义的参数变量相同，这里的集合里的参数不需要进行手动处理，直接将集合作为一个参数对象传进去即可&lt;/span&gt;
        Map&amp;lt;String,Object&amp;gt; params = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(2&lt;span&gt;);
        params.put(&lt;/span&gt;&quot;idList&quot;&lt;span&gt;,idList);
        params.put(&lt;/span&gt;&quot;bookName&quot;&lt;span&gt;,name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; namedParameterJdbcTemplate.query(sql,params,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookMapper());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次再执行一把看一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201904/1305443-20190421001142876-18324081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这次就执行成功了，控制台也没有报错，很舒服，我记得以前使用原生jdbc进行查询的时候当时使用的是sqlserver数据库，写了一条分页的SQL，当时也是有问号的，同样会报错，没想到spring的这个jdbc跟原生的jdbc一样坑，只能说技术这种东西学无止境呀。&lt;/p&gt;

&lt;p&gt;　　革命尚未成功，同志仍需努力！&lt;/p&gt;

</description>
<pubDate>Sat, 20 Apr 2019 16:20:00 +0000</pubDate>
<dc:creator>涅槃重生，</dc:creator>
<og:description>时隔三个多月，我终于想起我还有个博客，其实也不是忘了我这个博客，只是平时工作繁忙没时间去写博客，故今晚腾出时间来记录一下上次工作中遇到的一个问题，给园友们分享出来，以免入坑。 上个星期在工作中使用Jd</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maolinjava/p/10743522.html</dc:identifier>
</item>
<item>
<title>[译]背景：着色的物理和数学(2) - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-2.html</guid>
<description>&lt;p&gt;&lt;span&gt;[译]背景：着色的物理和数学(2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;（译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Shading》。我希望通过翻译此文，彻底理解PBR的原理。某些我实在不知道如何恰当翻译的地方，就把英文原文也放上了。）&lt;/p&gt;

&lt;p&gt;基于物理的BRDF的specular项通常都是基于微平面理论(microfacet theory)的。这一理论用于描述一般（非光学平滑的）表面的反射光。微平面理论的基础假设是，表面变化（微观几何形态）发生的数量级小于观察粒度（着色像素解析度）且大于可见光波长（因此几何光学有效而衍射等现象可以忽略）。到目前为止，微平面理论只能被用于继承single-bounce表面反射的说法；对于multiple-bounce表面反射的综合理论还是个未解的难题。&lt;/p&gt;
&lt;p&gt;既然微观几何形态被假设为远大于可见光波长，那么表面上每个点处都被视为光学平滑的。如前文所述，光学平滑的表面将光拆分为两个方向：反射方向和折射方向。&lt;/p&gt;
&lt;p&gt;表面上的每个点处，都将入射光反射到一个单独的出射方向上，出射方向依赖于微观几何形态的法线m。当求去BRDF的值时，需要输入入射光方向l和观察者方向v。这意味着，只有那些恰好法线位于m的点上才对BRDF有贡献。在Figure 22中，我们可以看到这些“正确排布”的表面点处的法线m恰好是l和v的中间。这个在l和v之间的向量被称为&lt;span&gt;半向量&lt;/span&gt;或&lt;span&gt;半角向量&lt;/span&gt;，我们用h表示它。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234911150-1175178551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234918463-1560000680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;并非所有的m=h处的点都对反射有贡献；有的被其他区域的入射光方向格挡（形成阴影），有的被从出射方向格挡（形成屏蔽），有的两者都有。微平面理论假设所有被格挡了的光都从specular项中损失掉了；现实中，由于多次表面反射，某些被格挡了的光最终会反射出来，但在微平面理论中不计入这个情形。光-表面交互的多种情形如Figure 23所示。&lt;/p&gt;
&lt;p&gt;有了这些假设（局部光学平滑，没有相互反射），BRDF的specular项可以由参考资料[1, 73]的原则推理出来。它有如下的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234927320-714171306.png&quot; alt=&quot;&quot;/&gt;(4)&lt;/p&gt;
&lt;p&gt;我们会详细讲解这里的每个小项，但首先来总评一下。D(h)是微观几何形态在半角向量h上的一个法线分布函数；换句话说，就是能够反射l到v的表面点的比例。G(l, v, h)是几何函数；它告诉我们，所有m=h的点中，没有被格挡的比例。因此，D和G函数的乘机就给出了&lt;span&gt;有效表面点&lt;/span&gt;的比例，即真正参与了反射l到v的那些点的比例。F(l, h)函数是有效表面点的菲涅耳反射率。它告诉我们每个入射光l有多大比例被反射。最后，分母4(nl)(nv)是个矫正因子，负责将量从围观几何形态的局部空间转换到全局的微表面。（译者注：我也不懂这句是什么意思）&lt;/p&gt;

&lt;p&gt;菲涅耳反射率方程计算光学平滑的表面反射光的比例（译者注：1-此值就是折射光的比例）。它的值依赖于两件事：入射角和材质的折射率。由于折射率在可见光光谱上是变化的，菲涅耳反射率显然是个光谱量——便于生产实际起见，是个RGB三元组。我们也知道每个RGB值都在[0, 1]范围内，因为一个表面不能反射低于0%或者高于100%的的入射光嘛。&lt;/p&gt;
&lt;p&gt;完整版的菲涅耳方程还是比较复杂的。退一步说（即使不复杂），所需要的材质参数（在可见光光谱上密集采样得到复数折射率）对艺术家也不方便用。但是，通过观察现实世界中材质的表现，我们可以找到一个参数更方便使用的简化版本。按此思路，我们来看一下Figure 24所示的图。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234944888-343678060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;此图选取的材质范围广泛。尽管如此，也可以看到一些它们的共同之处。在入射角为0°-45°范围内，辐射率几乎是不变的。辐射率在45°-75°之间变化得比较明显（一般是增加，但不是所有材质都增加）。最后，辐射率在75°-90°之间都迅速增长到1（对应了白色）。&lt;/p&gt;
&lt;p&gt;通过一个简单的三维场景来观察这些数值和角度的变化是有益的。暂且把微平面理论放到一边。我们看一个更简单的情形：光学平滑的金属表面的反射。这样的表面会将每个入射光反射到唯一的一个出射方向。用BRDF描述这个行为不方便（它坍缩为一个delta函数），但是有一个简单得多的方法来建模渲染它：从观察者方向采集入射光辐射率，然后用它乘以菲涅耳反射率，这就是出射光辐射率。这个方法对于能从任何方向表述入射光的光照模型都好用（光照模型将在本文后续章节介绍）。本例中，菲涅耳反射率的“入射角度”应当是表面法线n与观察者向量v之间的角度（入射方向应是v围绕n的反射向量）。Figure 25展示了这个角度（以及导致的菲涅耳反射率）在一个简单的三维场景中是如何变化的。我们可以看到绿色和黄色区域占主导地位——菲涅耳反射率在大部分可见像素上都没有改变，只在边缘上才有显著的增加。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234951543-1174246394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在微平面理论中，我们处理的不是光滑表面，而是局部光滑的微观几何体。本例中，我们关心的是各个表面点上的菲涅耳反射率。由于对BRDF有贡献的所有表面点的围观几何体的法线都是半角向量h（回忆Figure 22），显然h就应当是被用于计算菲涅耳反射率的向量。那么菲涅耳入射角度就是h和l之间的角度（用v代替l也可以，反正最后结果都是相同的）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420234957602-1871721866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Figure 26可视化展示了h和l之间的角度，方法与Figure 25可视化n和v之间的角度相同。从此图可以看到，在某些角度的光照下，黄色甚至红色区域都可能占主导地位。然而，如我们在Figure 27中所见，这是个误会；当BRDF的其他部分被计算进来后，很清楚可以看到红色区域（反射率急速增长的地方）只局限于边缘上。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235003504-49162105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;既然菲涅耳反射率在给定的三维场景中的大部分可见位置都保持着0°时的数值，我们可以把这个数值（我们将用F&lt;sub&gt;0&lt;/sub&gt;表示）看作材质的specular反射率特征。这个值有颜色的属性——它就是一个RGB值，介于0和1之间。它是光的选择性反射率的度量。（译者注：我也看不懂）因此，我们也将此值称为表面的specular颜色。&lt;/p&gt;
&lt;p&gt;F&lt;sub&gt;0&lt;/sub&gt;看起来是菲涅耳反射率的理想近似，实际上Schlick[63]给出了一个简易又足够精确的用法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235009926-35150119.png&quot; alt=&quot;&quot;/&gt;(5)&lt;/p&gt;
&lt;p&gt;这一近似公式广泛用于计算机图形学（游戏中有时使用一个基于球形高斯函数的稍微更简易的近似）。在用于微平面BRDF时，表面法线n必须被有效的微观几何体的法线h替代：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235015093-1736956519.png&quot; alt=&quot;&quot;/&gt;(6)&lt;/p&gt;
&lt;p&gt;为了找到F&lt;sub&gt;0&lt;/sub&gt;的恰当的值，观察一下现实世界的材质的F&lt;sub&gt;0&lt;/sub&gt;是有用的。这可以在Table 1找到。它给出了线性空间和gamma(sRGB)空间的值；我们建议任何不了解在线性空间着色（以及将gamma空间的数据转换到线性空间等问题）的重要性的人，参考一下相关话题的文章[30, 34, 69]。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235021348-1509793667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;查看Table 1的时候，会发现几件事。一是金属的F&lt;sub&gt;0&lt;/sub&gt;明显高于非金属。即使是铁这种相对暗淡的金属，在0°的时候都能反射超过50%的入射光。回忆一下，金属没有下表面反射，明亮的specular颜色，没有diffuse颜色，这是金属的明显的视觉特征。另一方面，钻石，这种最明亮的非金属，在0°的时候只反射17%的入射光。大多数非金属反射的量明显小于它。极少数材质的值位于20%到40%的“无人区”，这些一般是半导体或异域风情的材质，它们不太可能出现在着色产业环境中。低于2%的材质（水的F&lt;sub&gt;0&lt;/sub&gt;）也是这样。实际上，除了金属，宝石，水晶，你在实验室外能看到的基本上所有材质的F&lt;sub&gt;0&lt;/sub&gt;都在2%到5%这一窄窄的范围内。&lt;/p&gt;

&lt;p&gt;大多数表面上的微观几何体的表面点的朝向没有统一的分布。表面点中法线“向上”（朝向微观法线向量n）的比“朝一边”的多。表面朝向的统计学分布由微观几何体法线分布函数（microgeometry normal distribution function）D(m)定义。与F()不同，D()的值不限于[0, 1]——虽然必须是非负数，其值可以是任意大（表示法线朝向某个方向的表面点非常多）的。而且，D()也不是光谱学的，不是颜色，它是个标量。在微平面BRDF项，D()是为了与方向h比较，以帮助找到潜在的有效表面点（m=h的那些）的数量。这就是为什么法线分布函数D(h) 会出现在Equation 4中。&lt;/p&gt;
&lt;p&gt;函数D(h) 决定了specular高光的尺寸、亮度和形状。图形学文献中提供了几种不同的法线分布函数。很多都是高斯系列再加上某种“粗糙度”或者变量做参数，然而各向异性函数一般都有2个粗糙度参数（最近发表的一些文献中的各向同性函数也有2个参数(as do some recently published isotropic ones)[4, 10, 51]）。随着表面粗糙度降低，微观几何体的法线m围绕表面整体法线n的集中度就增长，D(m) 函数的值就可能变得很大（在m=n的极限处，其值是无限大的）。Walter et al. [73]讨论了分布函数的标准化问题，并给了几个例子；在其他文献[2, 3, 4, 10, 44, 51, 74]中有更多的例子。Reed [62]给出了法线分布函数的另一种解释（译者注：D(m) 的另一种理解方式）。&lt;/p&gt;

&lt;p&gt;几何函数G(l, v, h)表示，对于一个给定了微观几何体法线m的表面点，它能同时被 光线方向l和观察者方向v看到的概率。在微平面BRDF中，m被h代替（理由同上）。既然G()函数表示一个概率，它的值就是个标量，范围为[0, 1]。在文献[2, 3, 15, 16, 41, 44, 73]中有多种G()函数的解析表达式，它们通常是基于表面的简化模型而得的近似解决方案。G()函数没有给BRDF引入新的参数，它要么不使用参数，要么使用D()函数中的粗糙度参数。很多情形下，G()函数抵消了Equation 4中的一部分分母(nl)(nv)，用其他表达式代替了它。&lt;/p&gt;
&lt;p&gt;G()函数对于BRDF保持能量守恒是必须的——没有这一项，BRDF可能反射出比它收到的多得多的光能。微平面的BRDF推导的一个关键部分，就和(有效表面面积（从l到v反射光的表面区域）)与(全部表面面积)的比例有关。如果不计入阴影和遮蔽，那么有效面积会超过全部面积。这种能量不守恒（有时非常不守恒）明显不可能出现在客观世界（见Figure 28）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235030457-757711360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;

&lt;p&gt;微平面理论的公式相当强大和灵活，它允许通过(改变参数值（specular颜色、法线分布的粗糙度）或某些子项的形式（法线分布函数、几何函数）)给出多种不同的渲染效果。但是，有几种现象是它不能建模的（译者注：不能拿它套用的）。如果要渲染这些现象，那么对它们进行修改或扩展就是必须的。&lt;/p&gt;
&lt;p&gt;微平面模型没有考虑波动光学效应，例如衍射和干涉。这不是大问题，因为这种效果在渲染产业中不常出现。等真出现的时候，特别是技术会用来处理它们，而不是基于物理的建模技术。（译者注：“毒蛇出没之处,七步之内必有解药”——《神雕侠侣》）(“光滑表面”特性在接近可见光波长的尺寸时)或者(更大的表面特性由于在掠射角[76]的投影缩减效应下变得更小时)会导致更多的微妙的波动光学效果。已发表的针对这些效果的模型变都是彻底的波动光学模型[33, 68]，由于其太过复杂，还没有见到太多产业成果。针对这些效果的更加产业友好型的模型开发会很受期待。光学工程领域里一些有希望的模型已经开始影响到图形学文献[51]了。&lt;/p&gt;
&lt;p&gt;另外，微平面模型是基于相对受限的表面微观几何体模型和几个不明确的假设（译者注：应该是有时候靠不住的假设）。例如，法线分布函数的定义，它假设可见的微观几何体表面的朝向不随观察者方向的变化而变化。这等于假设微观几何体的高度和法线是不相关的[1]。但是，这个假设并非永远为真，这就会影响BRDF。想象一个表面，开始时，其粗糙度各处相同，然后，隆起的部分被摩擦地很光亮。从掠射角看，只有隆起的部分是可见的，这使得表面明显比在其他角度看起来更光滑。见Figure 29。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190420235044588-1288148084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近有研究表明，在某些情况下，对基础微平面模型的其他构造方式或修改可能产生更适合测试数据的结果——大多数是上文讨论的情况的组合。这些结果尚需更多的研究探索。&lt;/p&gt;
&lt;p&gt;作为表面反射的理论基础，微平面理论尽管最终可能会被代替（或者至少被扩展），目前它还是我们手上最被理解的和最成功的工具。因此，本文后续部分将专注于微平面模型。&lt;/p&gt;
&lt;p&gt;（译者注：“模型”这个词有多种理解。在“微平面模型”里，它的含义和“经济学模型”最接近。在“三维模型”里，它是另一个意思，是指*.obj，*.3ds，*.max这样的文件。）&lt;/p&gt;

&lt;p&gt;未完待续。。&lt;/p&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 15:55:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>[译]背景：着色的物理和数学(2) +BIT祝威+悄悄在此留下版了个权的信息说： （译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Sh</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-2.html</dc:identifier>
</item>
<item>
<title>编辑器开发之 Range 范围对象的学习 - 张茂</title>
<link>http://www.cnblogs.com/zhangmao/p/10739236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmao/p/10739236.html</guid>
<description>&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网上有各种富文本编辑器，微博分享等操作，这些功能非常实用，他们就是使用 range，selection 对象来实现的，这两个对象偏冷门，不涉及编辑器一般用不到，range 对象是对选区的操作，选区是鼠标在页面上按下，然后拖动选择的内容，range 对象就是对这个选区的操作；selection 是当前活动区的操作对象，selection 对象下面可以有多个 range 对象；这篇文章写的是标准的 selection和 range，小于 IE 9 的旧版本不在讨论范围内；&lt;/p&gt;
&lt;h4&gt;先来看一下 W3C 文档上的 range 对象的基本属性：&lt;/h4&gt;
&lt;p&gt;collapsed：返回一个用于判断 Range 起始位置和终止位置是否相同的布尔值。&lt;/p&gt;
&lt;p&gt;commonAncestorContainer：返回包含 startContainer 和 endContainer 的最深的节点。&lt;/p&gt;
&lt;p&gt;endContainer：返回包含 Range 终点的节点。&lt;/p&gt;
&lt;p&gt;endOffset：返回 endContainer 中表示Range终点位置的数字。&lt;/p&gt;
&lt;p&gt;startContainer：返回包含 Range 开始的节点。&lt;/p&gt;
&lt;p&gt;startOffset：返回 startContainer 中表示 Range 起始位置的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：range 的这些属性都是只读的，看下面这张图，就明白这些属性是怎么回事了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362645/201904/362645-20190420220945587-1880884342.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;collapsed 为 flase，说明起始点和终点不在同一个位置，startOffset 是从0开始的，d 的索引是2，表示鼠标按下的位置，也就是 div 元素的字符开始算的，endOffset 是 4，是从 span 标签开始算的，i 字符在 span 标签立面的索引是4；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意，他们总是从包裹&lt;strong&gt;字符的&lt;/strong&gt;节点的开始字符计算的；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;再来看下 range 的方法和解释：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setStart(node, index)：设置 Range 的起点。&lt;br/&gt;setEnd(node, index)：设置 Range 的终点。&lt;br/&gt;setStartBefore(node)：以其它节点（ Node）为基准，设置 Range 的起点。&lt;br/&gt;setStartAfter()：以其它节点为基准，设置 Range 的始点。&lt;br/&gt;setEndBefore()：以其它节点为基准，设置 Range 的终点。&lt;br/&gt;setEndAfter()：以其它节点为基准，设置 Range 的终点。&lt;br/&gt;selectNode()：设定一个包含节点和节点内容的 Range。&lt;br/&gt;selectNodeContents()：设定一个包含某个节点内容的 Range。&lt;br/&gt;collapse()：向指定端点折叠该 Range。&lt;/p&gt;
&lt;p&gt;这个解释看了之后一脸蒙圈，我的感受是讲的不清楚，还是上图，加上我们的理解更直观：&lt;/p&gt;
&lt;p&gt;setStart setEnd 方法：&lt;/p&gt;
&lt;p&gt;JS 操作:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新的 range 对象，设置 setStart setEnd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; setStartEnd() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; box = document.getElementById('box'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (document.createRange) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; range =&lt;span&gt; document.createRange();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; start = box.querySelector('p'&lt;span&gt;).firstChild;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; end = box.querySelector('span'&lt;span&gt;).firstChild;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;       range.setStart(start, 2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; p 标签的第 2 个字符&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       range.setStart(end, 3); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; span 标签的 第 3 个字符&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       console.log(range.cloneContents()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印 range 的内容&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       console.log(range); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印 range&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选区的内容和打印 range 的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362645/201904/362645-20190420233113803-1739417004.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子可以看出来，range 基本上操作任何你想选择的内容；&lt;/p&gt;
&lt;p&gt;其他的几个方法类似，都是操作 range 选区的，collapse 方法是设置折叠选区的，开始位置和结束位置相同，这么解释就清楚多了，作用是多用来设置光标的；&lt;/p&gt;
&lt;p&gt;下一篇看一下 selection 对象的基本属性和用法；&lt;/p&gt;
</description>
<pubDate>Sat, 20 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>张茂</dc:creator>
<og:description>写在前面： 网上有各种富文本编辑器，微博分享等操作，这些功能非常实用，他们就是使用 range，selection 对象来实现的，这两个对象偏冷门，不涉及编辑器一般用不到，range 对象是对选区的操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmao/p/10739236.html</dc:identifier>
</item>
<item>
<title>jaegertracing使用初探 - 菜刀诗人8888</title>
<link>http://www.cnblogs.com/chopper-poet/p/10743141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chopper-poet/p/10743141.html</guid>
<description>&lt;p&gt;&lt;span&gt;导读：有一天我们接到这样一条客诉“你们的收银软件最近特别慢，严重影响我们的收银效率，再不解决我们就不用了”，我相信大家应该都遇到过这种问题，即使现在没遇到，将来一定会遇到的，那遇到了怎么办呢？就这个话题我们今天一起来聊一聊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：分布式，链路追踪&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;靠人终究靠不住&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不知道大家是怎么处理开头提到的那种问题的呢？最简单粗暴的办法就是把相关人员集中到一个会议室里面对数据，怎么对呢？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;客户端开发人员：我查了日志，客户端的请求过程一共用了5s，请求是从几点几分几秒发起的，你们查下服务端的日志；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;交易系统开发人员：我这边是几点几分几秒收到的请求，交易系统一共花了4s多一些，其中调用支付网关花了将近4s，网关那边看下日志吧；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;网关开发人员：我这边是几点几分几秒收到的请求，网关一共花了3s多一点，大部分时间都花在了调用第三方上；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;估计大多数人最开始都是这么处理此类问题的，简单粗暴。但如果三天两头给你来这么一下子你还受得了吗？每天给你几百个上千个订单号让你对数据，你还能抽时间写代码吗?估计连带薪上厕所的时间都没了吧。最后这个问题可能传到了领导那里，领导一般喜欢要全局报表数据，你怎么给他出这个报表？是不是束手无策，突然有点想换工作了，哈哈。我们还真是接到过这种需求，一堆人在那里awk然后就没有然后了。&lt;/p&gt;
&lt;p&gt;“当一件事情成为一件常态，那意味着我们可能需要一件工具来解放自己了，靠人终究是靠不住的”，就在这种背景之下我们决定引入一个调用链追踪的工具来解放我们，也就是今天的主角jaeger。关于jaeger的说明网上很多，推荐去官网系统的了解一下 &lt;a href=&quot;https://www.jaegertracing.io/&quot; target=&quot;_blank&quot;&gt;https://www.jaegertracing.io&lt;/a&gt;，我这里只是把搭建过程和使用上的一些心得分享出来和大家一起交流。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;jaeger架构&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接引入一张官网的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420215951576-1584848313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jaeger组件介绍：&lt;/p&gt;
&lt;p&gt;jaeger-client：jaeger 的客户端，实现了opentracing协议；&lt;/p&gt;
&lt;p&gt;jaeger-agent：jaeger client的一个代理程序，client将收集到的调用链数据发给agent，然后由agent发给collector；&lt;/p&gt;
&lt;p&gt;jaeger-collector：负责接收jaeger client或者jaeger agent上报上来的调用链数据，然后做一些校验，比如时间范围是否合法等，最终会经过内部的处理存储到后端存储；&lt;/p&gt;
&lt;p&gt;jaeger-query：专门负责调用链查询的一个服务，有自己独立的UI；&lt;/p&gt;
&lt;p&gt;jaeger-ingester：中文名称“摄食者”，可用从kafka读取数据然后写到jaeger的后端存储，比如Cassandra和Elasticsearch；&lt;/p&gt;
&lt;p&gt;spark-job：基于spark的运算任务，可以计算服务的依赖关系，调用次数等；&lt;/p&gt;

&lt;p&gt;其中jaeger-collector和jaeger-query是必须的，其余的都是可选的，我们没有采用agent上报的方式，而是让客户端直接通过endpoint上报到collector。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;搭建jaeger&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为我们的应用服务都是采用容器部署的，所以我们的jaeger服务也沿用以往的风格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker启动jaeger-collector&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker run -d --rm -p 14268:14268 -p 14269:14269 -e SPAN_STORAGE_TYPE=elasticsearch -e ES_SERVER_URLS=http://10.200.46.229:9200 jaegertracing/jaeger-collector:1.11&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker启动jaeger-query&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker run -d --rm -p 16686:16686 -p 16687:16687 -e SPAN_STORAGE_TYPE=elasticsearch -e ES_SERVER_URLS=http://10.200.46.229:9200 jaegertracing/jaeger-query:1.11&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用程序接入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来就是如何让调用链条上的各端接入了，这里只需要把握一个原则就好，“尽量让接入方无感知，没有侵入性”，这里简单说下我们的接入方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端接入：客户端采用okhttp 拦截器的方式接入，使用请求头传递trace上下文，这里还可以和okhttp 的EventListener配合起来获取一些网络层面的指标，比如dns解析时间，连接发起时间等等；&lt;/li&gt;
&lt;li&gt;web程序接入：web端采用springmvc拦截器方式接入，从http请求头里面来提取trace上下文，然后基于上下文构建一个springmvc的span，记得在请求结束的时候finish奥，否则调用链数据可能会长这样：　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420223011657-1959684151.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;RPC框架如何集成：一般RPC框架都会提供一些扩展点让使用者来做一些框架集成的事情，拿dubbo来说可以采用Filter和隐示传参的方式来实现请求上下文的传递；&lt;/li&gt;
&lt;li&gt;外部调用如何集成：有一些调用是基于sdk或者httpclient调用的，这类调用我们如何植入调用链的逻辑呢？这里不得不佩服AspectJ的强大了，为了避免你少走弯路我还会推荐你去了解一下“spectj-maven-plugin”这个maven插件，什么？不是基于spring的那一堆注解就可以了吗，为什么还要引入maven来干这事。估计你还需要去了解一下运行期植入和编译器植入的相关概念以及适用场景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体你要把Span包装成什么样就靠你自由发挥了，但是不要太离谱，建议参考下这个&lt;a href=&quot;https://opentracing.io/docs/overview/spans/&quot; target=&quot;_blank&quot;&gt;https://opentracing.io/docs/overview/spans/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上线&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上线前问自己几个问题，我的拦截器写的是否健壮，抛异常了不会影响正常调用吧？是否需要评估一下数据量？别一上线把后端存储打死了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;适用jaeger-quey来检索调用链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;先选择一个service然后针对这个service做一些复杂的检索，比如针对某个标签，操作的耗时等；　&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420225206192-878620215.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;491&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;        2.如果有满足条件的数据右边会展示出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420230035286-82620815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      上面图中分别展示了两条支付的调用链路，一条成功了，一条失败了，你可能会问：jaeger是怎么判断成功失败的呢？简单来说就是通过特殊的标签，直接甩给你一篇opentracing的文档看完就懂了 &lt;a href=&quot;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&quot; target=&quot;_blank&quot;&gt;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;       3.查看调用链详情&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420230712403-1269745110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   4.查看依赖关系，以及调用次数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201904/846817-20190420230939545-1029850608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      也许你服务也搭好了，调用链数据也看到了，但就是看不到这个调用关系图，别急你去这溜达一圈就知道了&lt;a href=&quot;https://www.jaegertracing.io/docs/1.11/faq/&quot; target=&quot;_blank&quot;&gt;https://www.jaegertracing.io/docs/1.11/faq/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;      好吧，今天就到这，大周六的晚上抽一点时间来梳理一下最近的工作，还希望对各位有一点点的帮助。&lt;/p&gt;

</description>
<pubDate>Sat, 20 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>菜刀诗人8888</dc:creator>
<og:description>导读：有一天我们接到这样一条客诉“你们的收银软件最近特别慢，严重影响我们的收银效率，再不解决我们就不用了”，我相信大家应该都遇到过这种问题，即使现在没遇到，将来一定会遇到的，那遇到了怎么办呢？就这个话</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chopper-poet/p/10743141.html</dc:identifier>
</item>
</channel>
</rss>