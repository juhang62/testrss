<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Collections.synchronizedList 、CopyOnWriteArrayList、Vector介绍、源码浅析与性能对比【文末福利】 - Nauyus</title>
<link>http://www.cnblogs.com/lkxsnow/p/12247524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lkxsnow/p/12247524.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ArrayList线程安全问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，&lt;code&gt;ArrayList&lt;/code&gt;不是线程安全的，在并发场景使用&lt;code&gt;ArrayList&lt;/code&gt;可能会导致add内容为null,迭代时并发修改list内容抛&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常等问题。java类库里面提供了以下三个轮子可以实现线程安全的List，它们是&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Vector&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Collections.synchronizedList&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;CopyOnWriteArrayList&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文简要的分析了下它们线程安全的实现机制并对它们的读，写，迭代性能进行了对比。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vector&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK1.0开始，&lt;code&gt;Vector&lt;/code&gt;便存在JDK中，&lt;code&gt;Vector&lt;/code&gt;是一个线程安全的列表，底层采用数组实现。其线程安全的实现方式非常粗暴：&lt;code&gt;Vector&lt;/code&gt;大部分方法和&lt;code&gt;ArrayList&lt;/code&gt;都是相同的，只是加上了&lt;code&gt;synchronized&lt;/code&gt;关键字，这种方式严重影响效率，因此，不再推荐使用&lt;code&gt;Vector&lt;/code&gt;了。JAVA官方文档中这样描述：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;如果不需要线程安全性，推荐使用ArrayList替代Vector&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键源码如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;{
    modCount++;
    ensureCapacityHelper(elementCount + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    elementData[elementCount++] = e;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;{
    modCount++;
    ensureCapacityHelper(elementCount + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    elementData[elementCount++] = e;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; Iterator&amp;lt;E&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Itr();
}    

&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到&lt;code&gt;Vector&lt;/code&gt;通过在方法级别上加入了&lt;code&gt;synchronized&lt;/code&gt;关键字实现线程安全性。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Collections.synchronizedList&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为ArrayList不是线程安全的，JDK提供了一个&lt;code&gt;Collections.synchronizedList&lt;/code&gt;静态方法将一个非线程安全的List(并不仅限ArrayList)包装为线程安全的List。使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List list = Collections.synchronizedList(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据文档，转换包装后的list可以实现add，remove，get等操作的线程安全性，但是对于迭代操作，&lt;code&gt;Collections.synchronizedList&lt;/code&gt;并没有提供相关机制，所以迭代时需要对包装后的list（敲黑板，必须对包装后的list进行加锁，锁其他的不行）进行手动加锁，使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;List list = Collections.synchronizedList(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList());

&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (list) {
  Iterator i = list.iterator();
  &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (i.hasNext())
      foo(i.next());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个地方要注意两个地方：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;迭代操作必须加锁，可以使用&lt;code&gt;synchronized&lt;/code&gt;关键字修饰;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;synchronized持有的监视器对象必须是&lt;code&gt;synchronized (list)&lt;/code&gt;,即包装后的list,使用其他对象如&lt;code&gt;synchronized (new Object())&lt;/code&gt;会使&lt;code&gt;add&lt;/code&gt;,&lt;code&gt;remove&lt;/code&gt;等方法与迭代方法使用的锁不一致，无法实现完全的线程安全性。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过源码可知&lt;code&gt;Collections.synchronizedList&lt;/code&gt;生成了特定同步的&lt;code&gt;SynchronizedCollection&lt;/code&gt;，生成的集合每个同步操作都是持有&lt;code&gt;mutex&lt;/code&gt;这个锁，所以再进行操作时就是线程安全的集合了。关键地方已经加了注释：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;List&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;T&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (list &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; RandomAccess ?
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SynchronizedRandomAccessList&amp;lt;&amp;gt;(list) :
            &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SynchronizedList&amp;lt;&amp;gt;(list));
}

&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SynchronizedRandomAccessList&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SynchronizedList&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RandomAccess&lt;/span&gt; &lt;/span&gt;{
}


&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SynchronizedList&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SynchronizedCollection&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (mutex) {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list.get(index);}
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (mutex) {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list.set(index, element);}
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (mutex) {list.add(index, element);}
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;hljs-title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (mutex) {&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list.remove(index);}
    }   
    
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;listIterator&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list.listIterator(); 
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;是&lt;code&gt;java.util.concurrent&lt;/code&gt;包下面的一个实现线程安全的List,顾名思义， Copy~On~Write~ArrayList在进行写操作(add,remove,set等)时会进行Copy操作，可以推测出在进行写操作时&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;性能应该不会很高。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一下 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 的结构：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CopyOnWriteArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Serializable&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;hljs-number&quot;&gt;8673264195747942595L&lt;/span&gt;;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;transient&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; Object[] array;
    
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        setArray(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Object[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;底层实现为&lt;code&gt;Object[] array&lt;/code&gt;数组。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加元素：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.lock;
    lock.lock();
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        Object[] elements = getArray();
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
        newElements[len] = e;
        setArray(newElements);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
        lock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到每次添加元素时都会进行&lt;code&gt;Arrays.copyOf&lt;/code&gt;操作，代价非常昂贵。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读的时候是不需要加锁的，直接获取。删除和增加是需要加锁的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两点必须讲一下。我认为&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;这个并发组件，其实反映的是两个十分重要的分布式理念：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）读写分离&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们读取&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的时候读取的是&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;中的&lt;code&gt;Object[] array&lt;/code&gt;，但是修改的时候，操作的是一个新的&lt;code&gt;Object[] array&lt;/code&gt;，读和写操作的不是同一个对象，这就是读写分离。这种技术数据库用的非常多，在高并发下为了缓解数据库的压力，即使做了缓存也要对数据库做读写分离，读的时候使用读库，写的时候使用写库，然后读库、写库之间进行一定的同步，这样就避免同一个库上读、写的IO操作太多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）最终一致&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;来说，线程1读取集合里面的数据，未必是最新的数据。因为线程2、线程3、线程4四个线程都修改&lt;code&gt;了CopyOnWriteArrayList&lt;/code&gt;里面的数据，但是线程1拿到的还是最老的那个&lt;code&gt;Object[] array&lt;/code&gt;，新添加进去的数据并没有，所以线程1读取的内容未必准确。不过这些数据虽然对于线程1是不一致的，但是对于之后的线程一定是一致的，它们拿到的&lt;code&gt;Object[] array&lt;/code&gt;一定是三个线程都操作完毕之后的&lt;code&gt;Object array[]&lt;/code&gt;，这就是最终一致。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能对比&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的分析可知&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;code&gt;Vector&lt;/code&gt;对所有操作进行了&lt;code&gt;synchronized&lt;/code&gt;关键字修饰，性能应该比较差&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;在写操作时需要进行&lt;code&gt;copy&lt;/code&gt;操作，读性能较好，写性能较差&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;code&gt;Collections.synchronizedList&lt;/code&gt;性能较均衡，但是迭代操作并未加锁，所以需要时需要额外注意&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面写了个测试程序对三者的读，写，遍历进程了测试来验证下，测试机器信息如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;操作系统:macOS High Sierra 10.13.6
CPU:2.8 GHz Intel Core i7
内存：16 GB 2133 MHz LPDDR3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;**
 * 比较Vector，Collections.synchronizedList，CopyOnWriteArrayList读操作，写操作，遍历操作性能
 *
 * &lt;span class=&quot;hljs-meta&quot;&gt;@author&lt;/span&gt; nauyus
 * &lt;span class=&quot;hljs-meta&quot;&gt;@date&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2020&lt;/span&gt;年&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;月&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;日
 */
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ListPerformanceTest&lt;/span&gt; &lt;/span&gt;{

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; THREAD_COUNT = &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; SIZE = &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;;

    
    &lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testGet&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
        List&amp;lt;Integer&amp;gt; list = initList();
        List&amp;lt;Integer&amp;gt; copyOnWriteArrayList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CopyOnWriteArrayList&amp;lt;&amp;gt;(list);
        List&amp;lt;Integer&amp;gt; synchronizedList = Collections.synchronizedList(list);
        Vector vector = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vector(list);

        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; copyOnWriteArrayListTime = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; synchronizedListTime = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; vectorTime = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch countDownLatch = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(THREAD_COUNT);

        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {
            copyOnWriteArrayListTime += executor.submit(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; GetTestTask(copyOnWriteArrayList, countDownLatch)).get();
        }
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;CopyOnWriteArrayList get method cost time is &quot;&lt;/span&gt; + copyOnWriteArrayListTime);

        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {
            synchronizedListTime += executor.submit(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; GetTestTask(synchronizedList, countDownLatch)).get();
        }
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Collections.synchronizedList get method cost time is &quot;&lt;/span&gt; + synchronizedListTime);

        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {
            vectorTime += executor.submit(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; GetTestTask(vector, countDownLatch)).get();
        }
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;vector get method cost time is &quot;&lt;/span&gt; + vectorTime);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;initList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; SIZE; i++) {
            list.add(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random().nextInt(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;));
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list;
    }
    
    &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GetTestTask&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{
    List&amp;lt;Integer&amp;gt; list;
    CountDownLatch countDownLatch;

        GetTestTask(List&amp;lt;Integer&amp;gt; list, CountDownLatch countDownLatch) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.list = list;
            &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.countDownLatch = countDownLatch;
        }

        &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; pos = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random().nextInt(SIZE);
            &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; start = System.currentTimeMillis();
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; SIZE; i++) {
                list.get(pos);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; end = System.currentTimeMillis();
            countDownLatch.countDown();
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;) (end - start);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整版代码可以点击阅读原文或公众号内回复文章编号&lt;code&gt;010&lt;/code&gt;获取&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbecv3llv3j31ki09y76v.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到随着线程数的增加，三个类操作时间都有所增加，&lt;code&gt;Vector&lt;/code&gt;的遍历操作和&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的写操作（图片中标红的部分）性能消耗尤其严重。出乎意料的是&lt;code&gt;Vector&lt;/code&gt;的读写操作和&lt;code&gt;Collections.synchronizedList&lt;/code&gt;比起来并没有什么差别（印象中&lt;code&gt;Vector&lt;/code&gt;性能很差，实际性能差的只是遍历操作，看来还是纸上得来终觉浅，绝知此事要躬行啊），仔细分析了下代码，虽然&lt;code&gt;Vector&lt;/code&gt;使用&lt;code&gt;synchronized&lt;/code&gt;修饰方法，&lt;code&gt;Collections.synchronizedList&lt;/code&gt;使用&lt;code&gt;synchronized&lt;/code&gt;修饰语句块，但实际锁住内容并没有什么区别，性能相似也在情理之中。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的写操作与&lt;code&gt;Vector&lt;/code&gt;的遍历操作性能消耗尤其严重，不推荐使用。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;适用于读操作远远多于写操作的场景。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;读写性能可以和&lt;code&gt;Collections.synchronizedList&lt;/code&gt;比肩，但&lt;code&gt;Collections.synchronizedList&lt;/code&gt;不仅可以包装&lt;code&gt;ArrayList&lt;/code&gt;,也可以包装其他List,扩展性和兼容性更好。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/yn-huang/p/10684713.html&quot;&gt;Java集合：CopyOnWriteArrayList与SynchronizedList&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://www.hollischuang.com/archives/498&quot;&gt;SynchronizedList和Vector的区别&lt;/a&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;感谢阅读，如有收获，求&lt;code&gt;点赞&lt;/code&gt;、求&lt;code&gt;关注&lt;/code&gt;让更多人看到这篇文章，本文首发于不止于技术的技术公众号 &lt;code&gt;Nauyus&lt;/code&gt; ，欢迎识别下方二维码获取更多内容,主要分享JAVA，微服务，编程语言，架构设计，思维认知类等原创技术干货，2019年12月起开启周更模式，欢迎关注，与Nauyus一起学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gbfkbff49kj30bu0cwdl5.jpg&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;福利一：后端开发视频教程&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些年整理的几十套JAVA后端开发视频教程，包含微服务，分布式，Spring Boot,Spring Cloud,设计模式，缓存，JVM调优，MYSQL，大型分布式电商项目实战等多种内容，关注Nauyus立即回复【视频教程】无套路获取。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;福利二：面试题打包下载&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些年整理的面试题资源汇总，包含求职指南，面试技巧，微软，华为，阿里，百度等多家企业面试题汇总。 本部分还在持续整理中，可以持续关注。立即关注Nauyus回复【面试题】无套路获取。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Feb 2020 00:19:00 +0000</pubDate>
<dc:creator>Nauyus</dc:creator>
<og:description>本文简要的分析了下Collections.synchronizedList 、CopyOnWriteArrayList、Vector线程安全的实现机制并对它们的读，写，迭代性能进行了对比。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lkxsnow/p/12247524.html</dc:identifier>
</item>
<item>
<title>cmd命令行窗口和文件目录资源管理器快速切换 - YingHong</title>
<link>http://www.cnblogs.com/linyfeng/p/12247521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/12247521.html</guid>
<description>&lt;p&gt;&lt;span&gt;  本文主要描述如何在指定目录下快速打开当前路径的命令行窗口和在命令行中快速打开指定目录的资源管理器两种快捷方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、在指定目录下快速打开当前路径的命令行窗口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/774327/202002/774327-20200201080302766-2109351422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在命令行中快速打开当前目录的资源管理器。操作方法：在cmd窗口下执行：start .&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/774327/202002/774327-20200201080513208-1277945021.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、在命令行中快速打开指定文件目录的资源管理器。操作方法：在cmd窗口下执行 &lt;strong&gt;start %启动目录%。&lt;/strong&gt;更多start命令使用方式，执行start /?查看帮助。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/774327/202002/774327-20200201080701484-1206723511.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 01 Feb 2020 00:12:00 +0000</pubDate>
<dc:creator>YingHong</dc:creator>
<og:description>本文主要描述如何在指定目录下快速打开当前路径的命令行窗口和在命令行中快速打开指定目录的资源管理器两种快捷方法。1、在指定目录下快速打开当前路径的命令行窗口 2、在命令行中快速打开当前目录的资源管理器。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linyfeng/p/12247521.html</dc:identifier>
</item>
<item>
<title>《前端之路》--- 重温 Koa2 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/12247446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/12247446.html</guid>
<description>&lt;h3 id=&quot;一简单介绍&quot;&gt;一、简单介绍&lt;/h3&gt;
&lt;h4 id=&quot;快速开始-这里省略了安装的过程&quot;&gt;1.1、快速开始 （这里省略了安装的过程）&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const Koa = require('koa')
const app = new Koa()

app.use( async ( ctx ) =&amp;gt; {
  ctx.body = 'hello koa2'
})

app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;源码简单解析&quot;&gt;1.2、源码简单解析&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;源码文件主要包含了 application.js 、context.js 、request.js 、response.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;application.js 是 Koa 的入口文件封装了 ctx、request、response， 以及核心的中间件处理流程&lt;/li&gt;
&lt;li&gt;context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法&lt;/li&gt;
&lt;li&gt;request.js 处理http请求&lt;/li&gt;
&lt;li&gt;response.js 处理http响应&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;中间件的简单开发&quot;&gt;1.3、中间件的简单开发&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里主要介绍如何使用 async/await 在 koa2 中进行中间件的开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;middleware 在 koa2 中如何使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const Koa = require('koa')
const logger = require('./middleware/logger-async')

const app = new Koa()

app.use(logger())

app.use(ctx =&amp;gt; {
    ctx.body = 'hello middleware'
})

app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如何编写一个简单的 middleware 中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function log(ctx) {
    console.log( ctx.method, ctx.header.host + ctx.url )
}

module.exports = function() {
    return async function(ctx, next) {
        log(ctx)
        await next()
    }
}

// 对，就是这样，so easy&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-路由&quot;&gt;二、 路由&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;原生 JS 实现 koa 的 router&lt;/p&gt;
&lt;p&gt;经过思考🤔， 实现路由的基本原理： 通过请求进来的 url 匹配到对应的页面文件，然后通过 fs 读取对应文件的内容，并返回给 ctx.body, 那下面我们就按照这个思路来实现一下路由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
function render(page) {
    return new Promise((resolve, reject) =&amp;gt; {
        let viewUrl = `./view/${page}`;
        fs.readFile(viewUrl, 'utf8', (err, data) =&amp;gt; {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

async function route(url) {
    let view = '404.html';
    switch (url) {
        case '/':
            view = 'index.html';
            break;
        case '/index':
            view = 'index.html';
            break;
        case '/login':
            view = 'login.html';
            break;
        case '/404':
            view = '404.html';
            break;
        default:
            break;
    }
    let html = render(view);
    return html;
}

app.use(async ctx =&amp;gt; {
    let url = ctx.request.url;
    let html = await route(url);
    ctx.body = html;
});

// 当然还有 koa-router 中间件 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三请求数据&quot;&gt;三、请求数据&lt;/h3&gt;
&lt;h4 id=&quot;get-请求数据获取&quot;&gt;3.1、 GET 请求数据获取&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET 请求数据获取的方法有2中，如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;app.use(async ctx =&amp;gt; {
    let url = ctx.request.url;
    let html = await route(url);

    // 从上下文对 request 对象中获取
    let request = ctx.request;
    let req_query = request.query;
    let req_queryString = request.querystring;

    // 从 上下文中直接获取
    let ctx_query = ctx.query;
    let ctx_queryString = ctx.querystring;

    ctx.body = {
        ctx,
        request,
        url,
        req_query,
        req_queryString,
        ctx_query,
        ctx_queryString,
        html
    };
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;返回结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;url: &quot;/index?page=1&quot;
req_query: {page: &quot;1&quot;}
req_queryString: &quot;page=1&quot;
ctx_query: {page: &quot;1&quot;}
ctx_queryString: &quot;page=1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;疑惑🤔的 点： 从上线文中获取的request对象和直接通过上线文获取的参数 有什么区别？ 为什么要这么设计？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;从 Koa2 的框架设计层面 app.js 中封装了 ctx、request、response&lt;/li&gt;
&lt;li&gt;从 Koa2 的框架设计层面 ctx.js 中封装了 request、response 方法&lt;/li&gt;
&lt;li&gt;从上下文中获取和从 ctx.request 获取的参数是一样的，因为底层方法是一致的&lt;/li&gt;
&lt;li&gt;直接从上下文中获取的方式简单、快捷&lt;/li&gt;
&lt;li&gt;从上下文中的 request 对象中获取的话，会更加的明确该属性来源，不容易混淆。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象, 和这里的 ctx.query 和 ctx.request.query 是没有关系的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;post-请求数据获取&quot;&gt;3.2、 POST 请求数据获取&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;POST 请求的话，需要我们在页面mock一个表单，这样的话，可以更好的查看我们请求的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;        &amp;lt;h1&amp;gt;koa2 request post demo&amp;lt;/h1&amp;gt;
        &amp;lt;form method=&quot;POST&quot; action=&quot;/&quot;&amp;gt;
            &amp;lt;p&amp;gt;userName&amp;lt;/p&amp;gt;
            &amp;lt;input name=&quot;userName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
            &amp;lt;p&amp;gt;nickName&amp;lt;/p&amp;gt;
            &amp;lt;input name=&quot;nickName&quot; /&amp;gt;&amp;lt;br /&amp;gt;
            &amp;lt;p&amp;gt;email&amp;lt;/p&amp;gt;
            &amp;lt;input name=&quot;email&quot; /&amp;gt;&amp;lt;br /&amp;gt;
            &amp;lt;button type=&quot;submit&quot;&amp;gt;submit&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    if (ctx.method === 'GET') {
        ctx.body = html;
    } else if (ctx.url === '/' &amp;amp;&amp;amp; ctx.method === 'POST') {
        ctx.body = html + `&amp;lt;script&amp;gt; alert('提交成功！') &amp;lt;/script&amp;gt;`;
    } else {
        ctx.body = '&amp;lt;h1&amp;gt;404！！！ o(╯□╰)o&amp;lt;/h1&amp;gt;';
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;koa-bodyparser中间件&quot;&gt;3.3、 koa-bodyparser中间件&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;实际上是封装了一层 post 的数据处理方法，然后将其赋值给了 ctx.request 的 body 属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const bodyParser = require('koa-bodyparser')

// 使用ctx.body解析中间件
app.use(bodyParser())

// 处理 method 为 POST 的方法
let postData = ctx.request.body
ctx.body = postData
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四-静态资源加载&quot;&gt;四、 静态资源加载&lt;/h3&gt;
&lt;h4 id=&quot;静态资源加载源码解析&quot;&gt;4.1、静态资源加载源码解析&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    // 核心代码
│   ├── content.js # 读取请求内容
│   ├── dir.js # 读取目录内容
│   ├── file.js # 读取文件内容
│   ├── mimes.js # 文件类型列表
│   └── walk.js # 遍历目录内容
└── index.js # 启动入口文件&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;4.1.1、index.js 入口文件（对于文本类型和图片类型返回请求数据的方式是不一样的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  // 核心部分代码 - 非全部
  // 输出静态资源内容
  if ( _mime &amp;amp;&amp;amp; _mime.indexOf('image/') &amp;gt;= 0 ) {
    // 如果是图片，则用node原生res，输出二进制数据
    ctx.res.writeHead(200)
    ctx.res.write(_content, 'binary')
    ctx.res.end()
  } else {
    // 其他则输出文本
    ctx.body = _content
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;4.1.2、content.js 为读取当前请求内容 （判断当前文件请求路径是是否存在且判断是 文件夹还是文件， 如果是文件夹则读取文件内容）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 核心代码
    //判断访问地址是文件夹还是文件
    let stat = fs.statSync( reqPath )

    if( stat.isDirectory() ) {
      //如果为目录，则渲读取目录内容
      content = dir( ctx.url, reqPath )

    } else {
      // 如果请求为文件，则读取文件内容
      content = await file( reqPath )
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.1.3、dir.js 为读取目录内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    // 核心部分代码
    // 遍历读取当前目录下的文件、子目录
    let contentList = walk( reqPath )&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.1.4、 file.js 读取文件内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 核心代码，读取对应文件的内容（此处读取出来的文件内行）
function file ( filePath ) {
    let content = fs.readFileSync(filePath[, options])
    return content
}

// 这里需要注释一下 fs.readFileSync(filePath[, options]) 中的 options 分别有 encoding 和 flag 二种选项，其中如果指定了 encoding 选项，则此函数返回字符串，否则返回 buffer。 就是说默认为 buffer&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.1.5、 mimes.js 文件类型列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let mimes = {
  'css': 'text/css',
  'less': 'text/css',
  'gif': 'image/gif',
  'html': 'text/html',
  'ico': 'image/x-icon',
  'jpeg': 'image/jpeg',
  'jpg': 'image/jpeg',
  'js': 'text/javascript',
  'json': 'application/json',
  'pdf': 'application/pdf',
  'png': 'image/png',
  'svg': 'image/svg+xml',
  'swf': 'application/x-shockwave-flash',
  'tiff': 'image/tiff',
  'txt': 'text/plain',
  'wav': 'audio/x-wav',
  'wma': 'audio/x-ms-wma',
  'wmv': 'video/x-ms-wmv',
  'xml': 'text/xml'
}
// 其中除了我们常见的 text/xxx 的文本类型、还有 image/xxx 图片类型和等等等
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.1.6、 walk.js 文件类型列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 核心代码 通过遍历，得到当前文件夹内的文件夹名称、和最后的文件名称
let result = dirList.concat( fileList );
// 疑惑的点： 为什么需要把文件名称也加上呢？ 大家也可以作为一个思考&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五-koa2-使用-cookiesession&quot;&gt;五、 Koa2 使用 cookie/session&lt;/h3&gt;
&lt;h4 id=&quot;koa2-使用-cookie&quot;&gt;5.1、koa2 使用 cookie&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;简单粗暴的直接上代码吧, 里面有一些需要注意的问题点，都在注释点中了。关键点就在与 koa 本身提供了 cookie 的 set 和 get 方法，可以非常简单的获取到对应想要的，但是里面我们常见的一些设置的参数，简单看一眼，其实就非常不简单了，maxAge、expires、httpOnly、overwrite 等等，这些都是我们在使用 cookie 的时候需要注意的，安全问题，http 请求问题。每一点都值得仔细来讲讲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;app.use(async ctx =&amp;gt; {
    if (ctx.url === '/index') {
        ctx.cookies.set('cid', 'hello world', {
            domain: '127.0.0.1',
            // 写cookie所在的域名, 需要注意的是如果访问的域名和这里的 domain 不一致的化，是无法成功写入的
            path: '/index', // 写cookie所在的路径
            maxAge: 10 * 60 * 1000, // cookie有效时长
            expires: new Date('2017-02-15'), // cookie失效时间
            httpOnly: false, // 是否只用于http请求中获取
            overwrite: false // 是否允许重写
        });
        ctx.body = 'cookies is ok';
    } else {
        ctx.body = 'hello koa2';
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;koa2-使用-session&quot;&gt;5.2、koa2 使用 session&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里需要注意下，koa 本身没有提供 session 的方法，这里的例子是通过中间件来实现一些你需要的能力。这里的两种实现 session 能力的方案。这两个方案的区别就在于 存储信息的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;通过-koa-session-直接将信息存储在-内存中&quot;&gt;5.2.1、 通过 koa-session 直接将信息存储在 内存中&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用 koa-session 中间件的核心在于需要对于给出的 对应 config 配置的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const Koa = require('koa');                               // 导入Koa
const Koa_Session = require('koa-session');   // 导入koa-session     
// 配置
const session_signed_key = [&quot;some secret hurr&quot;];  // 这个是配合signed属性的签名key
const session_config = {
    key: 'koa:sess', /**  cookie的key。 (默认是 koa:sess) */
    maxAge: 4000,   /**  session 过期时间，以毫秒ms为单位计算 。*/
    autoCommit: true, /** 自动提交到响应头。(默认是 true) */
    overwrite: true, /** 是否允许重写 。(默认是 true) */
    httpOnly: true, /** 是否设置HttpOnly，如果在Cookie中设置了&quot;HttpOnly&quot;属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。  (默认 true) */
    signed: true, /** 是否签名。(默认是 true) */
    rolling: true, /** 是否每次响应时刷新Session的有效期。(默认是 false) */
    renew: false, /** 是否在Session快过期时刷新Session的有效期。(默认是 false) */
};

// 然后通过 ctx.session.logged 来判断当前用户是否登陆成功、是否在有效期内等等&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通过-koa-mysql-session-和-koa-session-minimal-将信息存储在-mysql-中&quot;&gt;5.2.2、 通过 koa-mysql-session 和 koa-session-minimal 将信息存储在 mysql 中&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// session 中间件
app.use(
    session({
        key: 'SESSION_ID',
        store: store,
        cookie: cookie
    })
);

// 数据库配置
let store = new MysqlSession({
    user: 'root',
    password: '123456',
    database: 'hellothinkjs',
    host: '127.0.0.1'
});

// 存放sessionId的cookie配置
let cookie = {
    maxAge: '', // cookie有效时长
    expires: '', // cookie失效时间
    path: '', // 写cookie所在的路径
    domain: '', // 写cookie所在的域名
    httpOnly: true, // 是否只用于http请求中获取
    overwrite: '', // 是否允许重写
    secure: '',
    sameSite: '',
    signed: ''
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六-koa2加载模板引擎&quot;&gt;六、 koa2加载模板引擎&lt;/h3&gt;
&lt;h4 id=&quot;koa2-加载模板引擎-ejs&quot;&gt;6.1、 koa2 加载模板引擎 （ejs）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里直接展示使用的 demo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;app.use(
    views(path.join(__dirname, './ejs'), {
        extension: 'ejs'
    })
);

app.use(async ctx =&amp;gt; {
    let title = 'hello 404';
    await ctx.render('404', {
        title
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.8947368421053&quot;&gt;
&lt;p&gt;另外，我们附上 &lt;a href=&quot;https://github.com/mde/ejs&quot;&gt;ejs 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;七-koa2-中简单使用-mysql-数据库&quot;&gt;七、 koa2 中简单使用 mysql 数据库&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里写了一个简单的 demo 大致的介绍了下，koa 中 mysql 的使用方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 连接数据库
const connection = mysql.createConnection({
    host: '127.0.0.1', // 数据库地址
    user: 'root', // 数据库用户
    password: '123456', // 数据库密码
    database: 'hellothinkjs' // 选中数据库
});

let title = 'hello 404';
let users = [];

connection.connect();
connection.query('SELECT * FROM think_user', async (error, results, fields) =&amp;gt; {
    if (error) throw error;
    // connected !
    console.log(results);
    users = results;
    app.use(async ctx =&amp;gt; {
        await ctx.render('404', {
            title,
            users
        });
    });
});
connection.end();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6.1884057971014&quot;&gt;
&lt;p&gt;这里需要注意一点的是： 因为网上之前找的文档中，很多关于 mysql modules 的使用方式比较古老了，不太适合新版本的 mysql 的链接和使用。 &lt;a href=&quot;https://github.com/mysqljs/mysql#introduction&quot;&gt;mysql 最新使用文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;八-koa2-中使用单元检测&quot;&gt;八、 koa2 中使用单元检测&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里的单元测试主要是正对 node 提供的API 服务来进行测试，测试框架选择： mocha（测试框架）、chai（断言库，用来判断是否满足预期结果）、supertest（用来模拟 API 请求）当然这三个库，每一个看上去都会有更多的特性，这里只是简单的介绍了一些基础自动化测试的demo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// api.js    api server  
const server = async (ctx, next) =&amp;gt; {
    let result = {
        success: true,
        data: null
    };

    if (ctx.method === 'GET') {
        if (ctx.url === '/getString.json') {
            result.data = 'this is string data';
        } else if (ctx.url === '/getNumber.json') {
            result.data = 123456;
        } else {
            result.success = false;
        }
        ctx.body = result;
        next &amp;amp;&amp;amp; next();
    } else if (ctx.method === 'POST') {
        if (ctx.url === '/postData.json') {
            result.data = 'ok';
        } else {
            result.success = false;
        }
        ctx.body = result;
        next &amp;amp;&amp;amp; next();
    } else {
        ctx.body = 'hello world';
        next &amp;amp;&amp;amp; next();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// index.test.js test server
describe('开始测试智商税了', () =&amp;gt; {
    // 测试用例
    it('测试你的智商是不是二百五', done =&amp;gt; {
        request
            .post('/postData.json')
            .expect(200)
            .end((err, res) =&amp;gt; {
                // 断言判断结果是否为object类型
                expect(res.body).to.be.an('object');
                expect(res.body.success).to.be.an('boolean');
                expect(res.body.data).to.be.an('string');
                done();
            });
    });
});

// 这里发现，我们在测试我们的借口返回数据的类型、数值、错误码等类型的时候会有非常大的帮助的。以后如果需要用起来的话，推荐使用之。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;九-node-服务端开发过程中的-开发-debug-方式&quot;&gt;九、 node 服务端开发过程中的 开发 debug 方式&lt;/h3&gt;
&lt;h4 id=&quot;vscode-进行debug&quot;&gt;9.1、vscode 进行debug&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;vscode 自带 debug 能力，这里需要花费一定时间去理解的地方是 debug 启动程序的时候，需要配置一个 launch.json 文件，这里给一个对应的 demo。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    // 使用 IntelliSense 了解相关属性。
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;启动程序&quot;,
            &quot;skipFiles&quot;: [&quot;&amp;lt;node_internals&amp;gt;/**&quot;],
            &quot;program&quot;: &quot;${workspaceFolder}/api.js&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;修改对应的 program 的 value 的文件为执行的入口文件即可。（这里推荐使用）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;chrome-浏览器进行-debug&quot;&gt;9.2、chrome 浏览器进行 debug&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过 &lt;em&gt;node --inspect index.js&lt;/em&gt; 启动服务，则可以在 chrome 浏览器控制台看到对应的 node 的小图标，点击然后就有一个对应的小弹框进行 debug 啦。试了下，也推荐吧，哈哈，看个人喜好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;十总结&quot;&gt;十、总结&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;看完整个koa2 的api，以及使用了一些特性之后，我们不难发现，koa2 相对于 express 真的要简洁很多，其核心也在于洋葱图和中间件的机制，那么能够编写中间件和从茫茫大海中找到高可用的中间件非常重要，这二点是大家未来需要注意的地方。过完年了，自己身为湖北人，因为这次肺炎没能回到老家过年，那就让自己多学习一些知识吧～ 同时也希望这次的疫情可以快速的被消灭掉～奥利给！！！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 31 Jan 2020 17:52:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>[TOC] 一、简单介绍 1.1、快速开始 （这里省略了安装的过程） 1.2、源码简单解析 源码文件主要包含了 application.js 、context.js 、request.js 、resp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/erbingbing/p/12247446.html</dc:identifier>
</item>
<item>
<title>Apache Hudi 0.5.1版本重磅发布 - ApacheHudi</title>
<link>http://www.cnblogs.com/apachehudi/p/12247396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apachehudi/p/12247396.html</guid>
<description>&lt;p&gt;历经大约3个月时间，Apache Hudi 社区终于发布了0.5.1版本，这是Apache Hudi发布的第二个Apache版本，该版本中一些关键点如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;版本升级
&lt;ul&gt;&lt;li&gt;将Spark版本从2.1.0升级到2.4.4&lt;/li&gt;
&lt;li&gt;将Avro版本从1.7.7升级到1.8.2&lt;/li&gt;
&lt;li&gt;将Parquet版本从1.8.1升级到1.10.1&lt;/li&gt;
&lt;li&gt;将Kafka版本从0.8.2.1升级到2.0.0，这是由于将spark-streaming-kafka artifact从0.8_2.11升级到0.10_2.11/2.12间接升级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;重要：Hudi 0.5.1版本需要将spark的版本升级到2.4+&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;23.14572558564&quot;&gt;&lt;li readability=&quot;6.7333333333333&quot;&gt;
&lt;p&gt;Hudi现在支持Scala 2.11和2.12，可以参考&lt;a href=&quot;https://github.com/apache/incubator-hudi#build-with-scala-212&quot;&gt;Scala 2.12构建&lt;/a&gt;来使用Scala 2.12来构建Hudi，另外， hudi-spark, hudi-utilities, hudi-spark-bundle and hudi-utilities-bundle包名现已经对应变更为 hudi-spark_{scala_version}, hudi-spark_{scala_version}, hudi-utilities_{scala_version}, hudi-spark-bundle_{scala_version}和 hudi-utilities-bundle_{scala_version}. 注意这里的scala_version为2.11或2.12。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8275862068966&quot;&gt;
&lt;p&gt;在0.5.1版本中，对于timeline元数据的操作不再使用重命名方式，这个特性在创建Hudi表时默认是打开的。对于已存在的表，这个特性默认是关闭的，在已存在表开启这个特性之前，请参考这&lt;a href=&quot;https://www.cnblogs.com/apachehudi/p/12247396.html&quot;&gt;部分&lt;/a&gt;(&lt;a href=&quot;https://hudi.apache.org/docs/deployment.html#upgrading&quot; class=&quot;uri&quot;&gt;https://hudi.apache.org/docs/deployment.html#upgrading&lt;/a&gt;)。若开启新的Hudi timeline布局方式(layout)，即避免重命名，可设置写配置项&lt;code&gt;hoodie.timeline.layout.version=1&lt;/code&gt;。当然，你也可以在CLI中使用&lt;code&gt;repair overwrite-hoodie-props&lt;/code&gt;命令来添加&lt;code&gt;hoodie.timeline.layout.version=1&lt;/code&gt;至hoodie.properties文件。注意，无论使用哪种方式，在升级Writer之前请先升级Hudi Reader(查询引擎)版本至0.5.1版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CLI支持&lt;code&gt;repair overwrite-hoodie-props&lt;/code&gt;来指定文件来重写表的hoodie.properties文件，可以使用此命令来的更新表名或者使用新的timeline布局方式。注意当写hoodie.properties文件时（毫秒），一些查询将会暂时失败，失败后重新运行即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DeltaStreamer用来指定表类型的参数从&lt;code&gt;--storage-type&lt;/code&gt;变更为了&lt;code&gt;--table-type&lt;/code&gt;，可以参考&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/Design+And+Architecture&quot;&gt;wiki&lt;/a&gt;来了解更多的最新变化的术语。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置Kafka Reset Offset策略的值变化了。枚举值从LARGEST变更为LATEST，SMALLEST变更为EARLIEST，对应DeltaStreamer中的配置项为&lt;code&gt;auto.offset.reset&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当使用spark-shell来了解Hudi时，需要提供额外的&lt;code&gt;--packages org.apache.spark:spark-avro_2.11:2.4.4&lt;/code&gt;，可以参考&lt;a href=&quot;https://hudi.apache.org/docs/quick-start-guide.html&quot;&gt;quickstart&lt;/a&gt;了解更多细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Key generator（键生成器）移动到了单独的包下&lt;code&gt;org.apache.hudi.keygen&lt;/code&gt;，如果你使用重载键生成器类（对应配置项：&lt;code&gt;hoodie.datasource.write.keygenerator.class&lt;/code&gt;），请确保类的全路径名也对应进行变更。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Hive同步工具将会为MOR注册带有_ro后缀的RO表，所以查询也请带_ro后缀，你可以使用&lt;code&gt;--skip-ro-suffix&lt;/code&gt;配置项来保持旧的表名，即同步时不添加_ro后缀。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.8253676470588&quot;&gt;
&lt;p&gt;0.5.1版本中，供presto/hive查询引擎使用的&lt;code&gt;hudi-hadoop-mr-bundle&lt;/code&gt;包shaded了avro包，以便支持real time queries（实时查询）。Hudi支持可插拔的记录合并逻辑，用户只需自定义实现&lt;a href=&quot;https://github.com/apache/incubator-hudi/blob/master/hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java&quot;&gt;HoodieRecordPayload&lt;/a&gt;。如果你使用这个特性，你需要在你的代码中relocate avro依赖，这样可以确保你代码的行为和Hudi保持一致，你可以使用如下方式来relocation。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;relocation&amp;gt;
  &amp;lt;pattern&amp;gt;org.apache.avro.&amp;lt;/pattern&amp;gt;
  &amp;lt;shadedPattern&amp;gt;org.apache.hudi.org.apache.avro.&amp;lt;/shadedPattern&amp;gt;
&amp;lt;/relocation&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.94366197183099&quot;&gt;
&lt;p&gt;DeltaStreamer更好的支持Delete，可参考&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/2020/01/15/Delete+support+in+Hudi&quot;&gt;blog&lt;/a&gt;了解更多细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.95652173913043&quot;&gt;
&lt;p&gt;DeltaStreamer支持AWS Database Migration Service(DMS) ，可参考&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/2020/01/20/Change+Capture+Using+AWS+Database+Migration+Service+and+Hudi&quot;&gt;blog&lt;/a&gt;了解更多细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;支持DynamicBloomFilter（动态布隆过滤器），默认是关闭的，可以使用索引配置项&lt;code&gt;hoodie.bloom.index.filter.type=DYNAMIC_V0&lt;/code&gt;来开启。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HDFSParquetImporter支持bulkinsert，可配置&lt;code&gt;--command&lt;/code&gt;为&lt;code&gt;bulkinsert&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持AWS WASB和 WASBS云存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1875937/202002/1875937-20200201005036306-916989543.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jan 2020 16:51:00 +0000</pubDate>
<dc:creator>ApacheHudi</dc:creator>
<og:description>历经大约3个月时间，Apache Hudi 社区终于发布了0.5.1版本，这是Apache Hudi发布的第二个Apache版本，该版本中一些关键点如下 版本升级 将Spark版本从2.1.0升级到2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/apachehudi/p/12247396.html</dc:identifier>
</item>
<item>
<title>只会前端让我很丢人 - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/12247398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/12247398.html</guid>
<description>&lt;p&gt;今天突然有一种，做前端不丢人、但是只会前端可能会很丢人的感触。&lt;br/&gt;为啥这么感慨呢！&lt;br/&gt;听我慢慢给你道来~&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;事情要从今天的年会说起。&lt;br/&gt;今天公司的技术部门一起出去年会团建。&lt;br/&gt;会上当然少不了活跃气氛的小游戏。&lt;br/&gt;其中我参加了一个猜词游戏，是我一个纯前端和一个专业的数据挖掘工程师一起上台参加。&lt;br/&gt;我的性格本来就比较腼腆、只要想到站到台上说话就会紧张。&lt;br/&gt;更别提在紧张的比赛气氛下让我上去真的面对这么多人做一个需要脑子转快点的游戏了。&lt;br/&gt;那需要多么强大的心理建设和自我催眠，才能拿出60%的心态去参加这个比赛类型的游戏呢！&lt;br/&gt;我这么想着的时候，背景音乐响起，主持人喊了我们第六组上台开始比赛。&lt;/p&gt;
&lt;p&gt;伴随着前景音乐缓缓淡出，我和那位同事被众人的目光送上舞台。&lt;br/&gt;我俩事前讲好了，他比划/描述、我猜词。&lt;br/&gt;甚至我们还拟定了一些小约定:&lt;br/&gt;比如“大佬”这个词，描述时就说“小的反义词、年轻的反义词，总的形容一个人厉害、技术特别盖！”。&lt;br/&gt;这样，即使此时有紧张心理，但也还算心理有点底气。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/202002/956663-20200201004148958-2085805540.jpg&quot; alt=&quot;人生还很漫长，该做些什么呢？&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;开始&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当我自信的拿过话筒，站在舞台上背对着大屏幕的位置时，&lt;br/&gt;我才发现，这也是我面对着台下大众的位置和方向。&lt;/p&gt;
&lt;p&gt;虽然我近视，但是我戴眼镜了！&lt;/p&gt;
&lt;p&gt;我横扫一遍，看到了无数期待的目光向我们投射而来。&lt;br/&gt;台下那一个个面庞朝向我们，一双双眼睛直直的看向我们。&lt;br/&gt;面朝观众的我当场感觉到有无数盏射光灯，刷刷刷的朝我打过来、集中到我的头顶。&lt;br/&gt;然后周围全暗淡了，只剩下我被眼光打的白亮。&lt;/p&gt;
&lt;p&gt;此时的我，脸上的那几个雀斑，应该都可以被看得无限清楚、无限清晰。&lt;br/&gt;作为人体里可成像的器官，那一双双的眼睛又让我感觉是一台台的史上最先进的高清彩色摄像机。&lt;br/&gt;我脸部肌肉哪怕有一点点的抽搐，都会被记录下来。&lt;/p&gt;
&lt;p&gt;台下的观众。他们每人还有一双双的耳朵，朝向我的左右手方向。&lt;br/&gt;不过我一会说的每一句话、每一个字，都会以光速传到他们的耳朵、并被他们照单接收。&lt;/p&gt;
&lt;p&gt;想到这里，我左手握紧右手、右手握紧话筒，拧了拧、转了转，仿佛又增加了一丝底气。&lt;br/&gt;正当我打算做一个深呼吸调整时，主持人喊了“计时开始！”，&lt;/p&gt;
&lt;p&gt;世界都安静了，我的心脏停跳了。&lt;/p&gt;
&lt;p&gt;游戏开始了~&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;经过&lt;/span&gt;&lt;/h2&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;绊倒&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;【“集市”】&lt;br/&gt;看到第一个词后，我的搭档眼前一亮、胜券在握的开始给我描述：“我们数据放在… 这里是一堆描述[数据集市]的词语”&lt;br/&gt;此时听到他前几个字，我的脑海里就一闪而过三个字：“(⊙o⊙)…我不会！”。&lt;br/&gt;于是当他描述完一遍，我思索三秒后大喊了一声“过！”。&lt;br/&gt;台下观众哄然大笑。&lt;br/&gt;此时的我还以为他们在笑我上来就”过“了一个词。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;绊倒&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;【”刷数“】&lt;br/&gt;紧接着是第二个词，我的搭档又是眼前一亮、胜券在握的开始描述：”当我们的历史数据【这里是一堆描述刷数的词语】“&lt;br/&gt;此时听到他前几个字”历史、数据…“，我的脑海里就一闪而过三个字：”我还是不会！(⊙o⊙)…“。&lt;br/&gt;于是我又大喊一声”过！“。&lt;br/&gt;台下又是一片哄然大笑。&lt;br/&gt;此时的我脸上有一次不好意思闪过。但我还能撑住、期待我们的下一个词。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;绊倒&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;【”透传“】&lt;br/&gt;这时到了第三个字，我的搭档描述到：”我们的数据从上游给到下游【这里是一堆描述透传的词语】“&lt;br/&gt;此时从”上游“、”下游“几个字里，我又判断出我不会了。感觉我被命运扼住了喉咙~&lt;br/&gt;这次我不敢喊”过“了，强撑着想让他再提示下。&lt;br/&gt;见我不说话，我的搭档又吧啦吧啦描述了些什么，我记不得了。&lt;br/&gt;我只记得台下的观众嘴角上扬，我的脸上微微发烫。&lt;br/&gt;我的搭档想要继续给我提供思路的时候，计分人员大喊，还有三十秒。&lt;/p&gt;
&lt;p&gt;我能明显感觉到，我的紧张和答不上来，有点微微拖累了同伴的心理，伴随着倒计时的逼近，他也开始紧迫起来。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;低谷&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;于是，接下来估计四个词都是专业性很强的词语，他一连喊了四个”过“之后，台下的观众又笑出了声。&lt;/p&gt;
&lt;p&gt;我想我刚笑完前边组只答对一个、我们肯定能答好几个，转脸我们不会只拿个零分下去吧，我也开始绷不住捂脸笑场了🤦‍♀️&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;回光返照&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;终于，我的搭档为我找到了我能理解的一个词：&lt;br/&gt;搭档：”假的反义词“&lt;br/&gt;我：”真“&lt;br/&gt;搭档：”臭的反义词“&lt;br/&gt;我：”香“&lt;br/&gt;”真香！“，我瞬间反应。&lt;br/&gt;这个词，我们用了不到五秒。&lt;br/&gt;我心里暗暗庆祝不用拿零分了，甚至心里如释重负。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-8&quot;&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;后来又经历了几轮猜词，最终我们一共对了三个，还有一个是“重构”。&lt;br/&gt;第三个我忘了我答对的是啥。但是都不重要了。&lt;br/&gt;除了当时答对那一秒的一丝快感和对胜利的期盼增添一分的心情外，其他都没有感受到。&lt;/p&gt;
&lt;p&gt;游戏结束。&lt;/p&gt;
&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/202002/956663-20200201004253510-217721840.jpg&quot; alt=&quot;凄惨像大雪天寒风中没有戴手套&quot;/&gt;&lt;br/&gt;&lt;h2 id=&quot;h-9&quot;&gt;&lt;span&gt;自责&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;下台后，只是深深的自责，感觉对不住我的搭档。&lt;br/&gt;他很想赢，但是我的无知与读书少拖了后腿。&lt;br/&gt;假如我懂那么一丢丢数据相关的知识点，我们今天就是全场的MVP。&lt;/p&gt;
&lt;p&gt;”真香”是一个网络流行词。&lt;br/&gt;一直以高级工程师为目标的我，答不对专业性质的词语，只能答对这种广为流传的口水词。&lt;br/&gt;我不是嫌弃词语，我是嫌弃我自己——干啥啥不行，吃啥啥不剩。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-10&quot;&gt;&lt;span&gt;自卑&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当我比赛时，正对着我坐着的、台下的那些观众，&lt;br/&gt;他们都是世界五百强上市公司里的、大部分人级别基本上都在P7,8以上的、专门做数据挖掘、数据模型、数据应用以及大数据算法的高高级资深工程师！！！&lt;br/&gt;而且在这堆人里边，还有我的领导、我领导的领导、我领导的领导的领导。&lt;br/&gt;其中，我的领导站在台下，帮我们拍照。我的大领导就在台下正对着我的桌子旁边坐着。&lt;br/&gt;我刚才“闪现撞墙”的操作，他们都看到了眼里。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-11&quot;&gt;&lt;span&gt;因为你是做前端的&lt;/span&gt;&lt;/h2&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-12&quot;&gt;&lt;span&gt;所以你不“配”&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我回到座位上，&lt;br/&gt;战友旁边另一位认识我俩的同事说：“这些词语不该你俩搭。一个做数据的，一个做前端的，说不到一起去。”&lt;br/&gt;我为了掩饰自己的尴尬和丢脸，开始和他们讨论，问刚才我没说出来的那些词都是啥。&lt;br/&gt;当我听到“集市”、“刷数”、“透传”这些词时，我懊恼的“啊”了一声。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-13&quot;&gt;&lt;span&gt;所以答不对&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们下台后的期间还有第七组人的比赛，我也没有心情看。&lt;br/&gt;只是沉浸在自己环节没有发挥好的失落心情里无法自拔。&lt;br/&gt;一阵闲聊慢慢平复心情之后，终于上了酒菜、换了环节。&lt;/p&gt;
&lt;p&gt;当大家开启瓶盖，主持人(是我们其中的同事)也下台来回到座位。&lt;br/&gt;我此时才发现我旁边的空位是留给他的。&lt;br/&gt;席间他和我碰杯喝酒的时候，他随口问了句：“你是做前端的吗？”&lt;br/&gt;我说：“是的”。&lt;/p&gt;
&lt;p&gt;是的，因为我是做前端的，所以刚才那些看似送分的题，我都没有答对。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-14&quot;&gt;&lt;span&gt;所以你不会&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;平时办公时，大家工位离得远，只是个脸熟。&lt;br/&gt;彼此不交接的话，对方是什么岗位可能也不太熟悉。&lt;br/&gt;我现在想想，他怎么知道我是前端？&lt;br/&gt;大概是我下台交话筒时，他和我领导站在一起，听到了我和领导说了一句：“我要学后端”。&lt;br/&gt;也有很大的可能是我的领导帮我跟他解释了，我是前端岗位，所以那些词都答不上来。&lt;/p&gt;
&lt;p&gt;因为到了后来敬酒环节，我的领导也替我跟全场最大的领导解释：&lt;br/&gt;之所以面对“集市、透传”这些基础简单词语，在我的搭档描述的很清楚、几乎是把百度百科的词语讲解都说出来的情况下我依旧答不上来的原因 — — 我是做前端的。&lt;/p&gt;
&lt;p&gt;并说我答不上来，他们都能理解我。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-15&quot;&gt;&lt;span&gt;近朱者，我没有赤&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;但我自己不理解自己。&lt;/p&gt;
&lt;p&gt;因为我的工位紧邻我战友他们组的工位，他们都是数据岗的同事。&lt;br/&gt;浸泡在这个氛围里，什么“集市”、“刷数”这些词语，真的我每天都会从坐在我旁边的同事嘴里听到。&lt;br/&gt;即使我是做前端的，天天听、天天这么熏陶，都没熏出来我的一丝一毫非前端知识的长进。&lt;/p&gt;
&lt;p&gt;都说熟读唐诗三百首，不会作诗也会吟。&lt;br/&gt;常听的歌没学都会唱。&lt;br/&gt;但是又有什么用呢？&lt;br/&gt;自己不上进，再好的环境都染不红你。&lt;/p&gt;
&lt;p&gt;即使是学一首歌曲，听了几百遍以后，你还要去再过几遍歌词的。&lt;br/&gt;何况是专业性的名词呢。&lt;br/&gt;只是听到这些词语，自己没有好奇心，不去了解、学习，当然还是不知道。&lt;/p&gt;
&lt;p&gt;要命的是，更因为他们都不是前端知识而不去关心、不去了解。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-16&quot;&gt;&lt;span&gt;做前端，不能只知前端&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;做前端，不能只知前端。&lt;br/&gt;因为做前端就一点也不了解后端知识真的是不应该的！&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-17&quot;&gt;&lt;span&gt;初心曾不全是前端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我现在还记得，我丢人得红着脸走到舞台下并把话筒交给我那如兄长般和蔼的领导手里时，&lt;br/&gt;我懊恼和略带意气风发的对他说了一句“我要学后端！”。&lt;/p&gt;
&lt;p&gt;是的，这句话，我17年就说过— —“我要做全栈、我要学后端”。&lt;br/&gt;今天，是2020年。期间两年，我曾经忘了自己的初心。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-18&quot;&gt;&lt;span&gt;如今腿麻了心态崩了&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;说我给前端丢人是真，&lt;br/&gt;而且我也给我的骄傲丢人了。&lt;/p&gt;
&lt;p&gt;因为从前的我，很倔强。做了很多别人理解不了的事情，比如转前端。&lt;br/&gt;并且从前的我，也很要强。自己选择的路我是跪着也要走完，比如转前端。&lt;br/&gt;但是现在应该是腿跪麻了，对什么都无所谓了。&lt;/p&gt;
&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/202002/956663-20200201003810947-1429452557.jpg&quot; alt=&quot;Something Just Like This&quot;/&gt;&lt;p&gt;有时候不想努力，会拿自己孤身一人在这宇宙中、没啥奋斗的意义为借口，来劝说自己继续赖床。&lt;br/&gt;什么都不想去学习了，心态崩了。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-19&quot;&gt;&lt;span&gt;学习要以效果为目的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这件事还让我有了一个深刻的反省。&lt;br/&gt;起初选择做前端、学技术，&lt;br/&gt;我真的有很强烈的热情和很大的好奇心。&lt;br/&gt;遇到没听过的、不会的知识点，就立马去查、去了解。&lt;/p&gt;
&lt;p&gt;后来不知道怎么消磨的，越来越懒得动。&lt;br/&gt;对于新名词、新技术，不会主动去了解、学习，甚至会有抵触心理。&lt;br/&gt;即使因为工作被迫的去学一个知识点，也是一扫而过，潦草收场。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以结果为导向，不以效果为目的。&lt;/strong&gt;&lt;br/&gt;这个bug解决了就好、项目能跑就好。&lt;br/&gt;具体bug因为啥引起的？&lt;br/&gt;项目怎么能更优化？&lt;br/&gt;有没有新技术能让开发变得更高效、让产品界面变得更炫酷、让程序更流畅？&lt;br/&gt;我都不再关心和追求……&lt;/p&gt;
&lt;p&gt;就好像，三餐一日，吃了就好。&lt;br/&gt;具体吃啥、能不能吃、吃了能不能消化，我都不在乎了。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;h-20&quot;&gt;&lt;span&gt;不能做当代祥子&lt;/span&gt;&lt;/h2&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-21&quot;&gt;&lt;span&gt;身上有祥子的影子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这几天在读老舍先生的书，&lt;br/&gt;我从《骆驼祥子》里边看到了我的影子。&lt;/p&gt;
&lt;p&gt;倒不是我的时代不好，也不是我遇到的人不好。&lt;br/&gt;相反，我的时代和我的祖国环境是目前世界上、乃至历史上最好的，&lt;br/&gt;我身边遇到的人都是好人、都是我的贵人。&lt;/p&gt;
&lt;p&gt;但是我的自甘堕落和麻木，与祥子有的一拼。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;h-22&quot;&gt;&lt;span&gt;祥子与我命运对照&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;那时候祥子想买辆自己的车。&lt;br/&gt;那时候我想从事我梦寐以求的前端岗。&lt;/p&gt;
&lt;p&gt;后来祥子遭遇战乱，车被抢了以后想靠自己的本事再攒够钱，重新买辆属于自己的车。但是从头再来太难了，祥子因为重重困难和坏蛋抢钱等种种原因没能如愿。&lt;br/&gt;后来我当了自己最喜欢的前端、相当于买上了自己最喜欢的车。可因为每天的“拉车”生活让我疲惫不堪，我渐渐迈不动脚步，不再是青壮年派的车夫。快要拉不动前端这辆车的同时，我也再不想前端这辆车歇工时，去拉后端那辆车。&lt;/p&gt;
&lt;p&gt;再后来祥子放弃了买车的心愿。&lt;br/&gt;再后来我也再提不起学习全栈的斗志。&lt;/p&gt;
&lt;p&gt;最后祥子就放弃了最开始的心愿，沦为了自己曾经最不屑的那种车夫。&lt;br/&gt;而我，我还没想好我的后来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/956663/202002/956663-20200201004419565-4142601.jpg&quot; alt=&quot;这个图的名字叫做”迷茫中“&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;这张图叫做倒着的“迷茫中”&lt;/p&gt;
&lt;h2 id=&quot;h-23&quot;&gt;&lt;span&gt;一专多长，一超多强。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过这件事，我意识到在当今时代下、作为当代IT人，做技术要涉猎广泛的重要性。&lt;/p&gt;
&lt;p&gt;今天只是个小游戏。明天是让我和他们直接对接呢？我岂不是干瞪眼！！！🙄&lt;br/&gt;哪怕不是精通，哪怕只是皮毛，但是我们也得懂人家和你交流时，他说的是啥吧！！！&lt;/p&gt;
&lt;p&gt;因为即使空调你不会创造，但至少遥控器怎么用，你得学学吧！&lt;br/&gt;不然万一哪天冻死在这冰天雪地的北京，也不会有人可怜你。&lt;br/&gt;甚至还会有人说你：“放着空调你不用，傻不傻！”&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jan 2020 16:51:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>即使空调你不会创造，但至少遥控器怎么用你得学学吧！ 不然万一哪天冻死在这冰天雪地的北京，也不会有人可怜你。甚至还会有人说你：“放着空调你不用，傻不傻！”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/padding1015/p/12247398.html</dc:identifier>
</item>
<item>
<title>Object类、常用API_2 - 平酱</title>
<link>http://www.cnblogs.com/p1ng/p/12247343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/12247343.html</guid>
<description>&lt;h2 id=&quot;主要内容&quot;&gt;主要内容&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Object类&lt;/li&gt;
&lt;li&gt;Date类&lt;/li&gt;
&lt;li&gt;DateFormat类&lt;/li&gt;
&lt;li&gt;Calendar类&lt;/li&gt;
&lt;li&gt;System类&lt;/li&gt;
&lt;li&gt;StringBuilder类&lt;/li&gt;
&lt;li&gt;包装类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;学习目标&quot;&gt;学习目标&lt;/h2&gt;
&lt;p&gt;-[ ] 能够说出Object类的特点&lt;br/&gt;-[ ] 能够重写Object类的toString方法&lt;br/&gt;-[ ] 能够重写Object类的equals方法&lt;br/&gt;-[ ] 能够使用日期类输出当前日期&lt;br/&gt;-[ ] 能够使用将日期格式化为字符串的方法&lt;br/&gt;-[ ] 能够使用将字符串转换成日期的方法&lt;br/&gt;-[ ] 能够使用System类的数组复制方法&lt;br/&gt;-[ ] 能够使用System类获取当前毫秒时刻值&lt;br/&gt;-[ ] 能够说出使用StringBuilder类可以解决的问题&lt;br/&gt;-[ ] 能够使用StringBuilder进行字符串拼接操作&lt;br/&gt;-[ ] 能够说出8种基本类型对应的包装类名称&lt;br/&gt;-[ ] 能够说出自动装箱、自动拆箱的概念&lt;br/&gt;-[ ] 能够将字符串转换为对应的基本类型&lt;br/&gt;-[ ] 能够将基本类型转换为对应的字符串&lt;/p&gt;

&lt;h2 id=&quot;概述&quot;&gt;1.1 概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。&lt;/p&gt;
&lt;p&gt;如果一个类没有特别指定父类， 那么默认则继承自Object类。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyClass /*extends Object*/ {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public String toString()&lt;/code&gt;：返回该对象的字符串表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean equals(Object obj)&lt;/code&gt;：指示其他某个对象是否与此对象“相等”。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;tostring方法&quot;&gt;1.2 toString方法&lt;/h2&gt;
&lt;h3 id=&quot;方法摘要&quot;&gt;方法摘要&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public String toString()&lt;/code&gt;：返回该对象的字符串表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。&lt;/p&gt;
&lt;p&gt;由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。&lt;/p&gt;
&lt;h3 id=&quot;覆盖重写&quot;&gt;覆盖重写&lt;/h3&gt;
&lt;p&gt;如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {  
    private String name;
    private int age;

    @Override
    public String toString() {
        return &quot;Person{&quot; + &quot;name='&quot; + name + '\'' + &quot;, age=&quot; + age + '}';
    }

    // 省略构造器与Getter Setter
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在IntelliJ IDEA中，可以点击&lt;code&gt;Code&lt;/code&gt;菜单中的&lt;code&gt;Generate...&lt;/code&gt;，也可以使用快捷键&lt;code&gt;alt+insert&lt;/code&gt;，点击&lt;code&gt;toString()&lt;/code&gt;选项。选择需要包含的成员变量并确定。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235943056-298511599.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;equals方法&quot;&gt;1.3 equals方法&lt;/h2&gt;
&lt;h3 id=&quot;方法摘要-1&quot;&gt;方法摘要&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public boolean equals(Object obj)&lt;/code&gt;：指示其他某个对象是否与此对象“相等”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。&lt;/p&gt;
&lt;h3 id=&quot;默认地址比较&quot;&gt;默认地址比较&lt;/h3&gt;
&lt;p&gt;如果没有覆盖重写equals方法，那么Object类中默认进行&lt;code&gt;==&lt;/code&gt;运算符的对象地址比较，只要不是同一个对象，结果必然为false。&lt;/p&gt;
&lt;h3 id=&quot;对象内容比较&quot;&gt;对象内容比较&lt;/h3&gt;
&lt;p&gt;如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Objects;

public class Person {   
    private String name;
    private int age;
    
    @Override
    public boolean equals(Object o) {
        // 如果对象地址一样，则认为相同
        if (this == o)
            return true;
        // 如果参数为空，或者类型信息不一样，则认为不同
        if (o == null || getClass() != o.getClass())
            return false;
        // 转换为当前类型
        Person person = (Person) o;
        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果
        return age == person.age &amp;amp;&amp;amp; Objects.equals(name, person.name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用&lt;code&gt;Code&lt;/code&gt;菜单中的&lt;code&gt;Generate…&lt;/code&gt;选项，也可以使用快捷键&lt;code&gt;alt+insert&lt;/code&gt;，并选择&lt;code&gt;equals() and hashCode()&lt;/code&gt;进行自动代码生成。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235617191-181108313.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235624213-876064851.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235630425-843057789.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tips：Object类当中的hashCode等其他方法，今后学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;objects类&quot;&gt;1.4 Objects类&lt;/h2&gt;
&lt;p&gt;在刚才IDEA自动重写equals代码中，使用到了&lt;code&gt;java.util.Objects&lt;/code&gt;类，那么这个类是什么呢？&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;JDK7&lt;/strong&gt;添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。&lt;/p&gt;
&lt;p&gt;在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static boolean equals(Object a, Object b)&lt;/code&gt;:判断两个对象是否相等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以查看一下源码，学习一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static boolean equals(Object a, Object b) {  
    return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b));  
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;date类&quot;&gt;2.1 Date类&lt;/h2&gt;
&lt;h3 id=&quot;概述-1&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.util.Date&lt;/code&gt;类 表示特定的瞬间，精确到毫秒。&lt;/p&gt;
&lt;p&gt;继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public Date()&lt;/code&gt;：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Date(long date)&lt;/code&gt;：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;

public class Demo01Date {
    public static void main(String[] args) {
        // 创建日期对象，把当前的时间
        System.out.println(new Date()); // Fri Jan 31 15:53:22 GMT+08:00 2020
        // 创建日期对象，把当前的毫秒值转成日期对象
        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 GMT+08:00 1970
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用方法&quot;&gt;常用方法&lt;/h3&gt;
&lt;p&gt;Date类中的多数方法已经过时，常用的方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public long getTime()&lt;/code&gt; 把日期对象转换成对应的时间毫秒值。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dateformat类&quot;&gt;2.2 DateFormat类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.text.DateFormat&lt;/code&gt; 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;格式化&lt;/strong&gt;：按照指定的格式，从Date对象转换为String对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解析&lt;/strong&gt;：按照指定的格式，从String对象转换为Date对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;构造方法&quot;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;由于DateFormat为抽象类，不能直接使用，所以需要常用的子类&lt;code&gt;java.text.SimpleDateFormat&lt;/code&gt;。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public SimpleDateFormat(String pattern)&lt;/code&gt;：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参数pattern是一个字符串，代表日期时间的自定义格式。&lt;/p&gt;
&lt;h3 id=&quot;格式规则&quot;&gt;格式规则&lt;/h3&gt;
&lt;p&gt;常用的格式规则为：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;年&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;月&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;日&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建SimpleDateFormat对象的代码如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.text.DateFormat;
import java.text.SimpleDateFormat;

public class Demo02SimpleDateFormat {
    public static void main(String[] args) {
        // 对应的日期格式如：2020-01-31 15:06:38
        DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    }    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用方法-1&quot;&gt;常用方法&lt;/h3&gt;
&lt;p&gt;DateFormat类的常用方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public String format(Date date)&lt;/code&gt;：将Date对象格式化为字符串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Date parse(String source)&lt;/code&gt;：将字符串解析为Date对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;format方法&quot;&gt;format方法&lt;/h4&gt;
&lt;p&gt;使用format方法的代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
 把Date对象转换成String
*/
public class Demo03DateFormatMethod {
    public static void main(String[] args) {
        Date date = new Date();
        // 创建日期格式化对象,在获取格式化对象时可以指定风格
        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
        String str = df.format(date);
        System.out.println(str); // 2020年01月31日
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;parse方法&quot;&gt;parse方法&lt;/h4&gt;
&lt;p&gt;使用parse方法的代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
 把String转换成Date对象
*/
public class Demo04DateFormatMethod {
    public static void main(String[] args) throws ParseException {
        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
        String str = &quot;2018年12月11日&quot;;
        Date date = df.parse(str);
        System.out.println(date); // Fri Jan 31 00:00:00 GMT+08:00 2020
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;练习&quot;&gt;2.3 练习&lt;/h2&gt;
&lt;p&gt;请使用日期时间相关的API，计算出一个人已经出生了多少天。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.获取当前时间对应的毫秒值&lt;/p&gt;
&lt;p&gt;2.获取自己出生日期对应的毫秒值&lt;/p&gt;
&lt;p&gt;3.两个时间相减（当前时间– 出生日期）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void function() throws Exception {
    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);
    // 获取出生日期,键盘输入
    String birthdayString = new Scanner(System.in).next();
    // 将字符串日期,转成Date对象
    // 创建SimpleDateFormat对象,写日期模式
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    // 调用方法parse,字符串转成日期对象
    Date birthdayDate = sdf.parse(birthdayString);  
    // 获取今天的日期对象
    Date todayDate = new Date();    
    // 将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;   
    if (secone &amp;lt; 0){
        System.out.println(&quot;还没出生呢&quot;);
    } else {
        System.out.println(secone/1000/60/60/24);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;calendar类&quot;&gt;2.4 Calendar类&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;日历我们都见过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235653474-1556518944.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。&lt;/p&gt;
&lt;h3 id=&quot;获取方式&quot;&gt;获取方式&lt;/h3&gt;
&lt;p&gt;Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：&lt;/p&gt;
&lt;p&gt;Calendar静态方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static Calendar getInstance()&lt;/code&gt;：使用默认时区和语言环境获得一个日历&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Calendar;

public class Demo06CalendarInit {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
    }    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用方法-2&quot;&gt;常用方法&lt;/h3&gt;
&lt;p&gt;根据Calendar类的API文档，常用方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public int get(int field)&lt;/code&gt;：返回给定日历字段的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void set(int field, int value)&lt;/code&gt;：将给定的日历字段设置为给定值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public abstract void add(int field, int amount)&lt;/code&gt;：根据日历的规则，为给定的日历字段添加或减去指定的时间量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public Date getTime()&lt;/code&gt;：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Calendar类中提供很多成员常量，代表给定的日历字段：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;年&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MONTH&lt;/td&gt;
&lt;td&gt;月（从0开始，可以+1使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DAY_OF_MONTH&lt;/td&gt;
&lt;td&gt;月中的天（几号）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HOUR&lt;/td&gt;
&lt;td&gt;时（12小时制）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;HOUR_OF_DAY&lt;/td&gt;
&lt;td&gt;时（24小时制）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MINUTE&lt;/td&gt;
&lt;td&gt;分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SECOND&lt;/td&gt;
&lt;td&gt;秒&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DAY_OF_WEEK&lt;/td&gt;
&lt;td&gt;周中的天（周几，周日为1，可以-1使用）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;getset方法&quot;&gt;get/set方法&lt;/h4&gt;
&lt;p&gt;get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：&lt;/p&gt;
&lt;p&gt;get方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Calendar;

public class CalendarUtil {
    public static void main(String[] args) {
        // 创建Calendar对象
        Calendar cal = Calendar.getInstance();
        // 设置年 
        int year = cal.get(Calendar.YEAR);
        // 设置月
        int month = cal.get(Calendar.MONTH) + 1;
        // 设置日
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月31日
    }    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;set方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Calendar;

public class Demo07CalendarMethod {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.YEAR, 2020);
        cal.set(Calendar.MONTH, 1);
        cal.set(Calendar.DAY_OF_MONTH, 31);
        // 上面三局等同于cal.set(2020,1,31);
        
        int year = cal.get(Calendar.YEAR);
        // 设置月
        int month = cal.get(Calendar.MONTH) + 1;
        // 设置日
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);

        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月31日
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;add方法&quot;&gt;add方法&lt;/h4&gt;
&lt;p&gt;add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Calendar;

public class Demo08CalendarMethod {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        int year = cal.get(Calendar.YEAR);
        // 设置月
        int month = cal.get(Calendar.MONTH) + 1;
        // 设置日
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月31日
        // 使用add方法
        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天
        cal.add(Calendar.YEAR, -3); // 减3年
        year = cal.get(Calendar.YEAR);
        // 设置月
        month = cal.get(Calendar.MONTH) + 1;
        // 设置日
        dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2017年2月2日
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gettime方法&quot;&gt;getTime方法&lt;/h4&gt;
&lt;p&gt;Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Calendar;
import java.util.Date;

public class Demo09CalendarMethod {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        Date date = cal.getTime();
        System.out.println(date); // Fri Jan 31 23:18:15 GMT+08:00 2020
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;小贴士：&lt;/p&gt;
&lt;p&gt;​ 西方星期的开始为周日，中国为周一。&lt;/p&gt;
&lt;p&gt;​ 在Calendar类中，月份的表示是以0-11代表1-12月。&lt;/p&gt;
&lt;p&gt;​ 日期是有大小关系的，时间靠后，时间越大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;java.lang.System&lt;/code&gt;类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static long currentTimeMillis()&lt;/code&gt;：返回以毫秒为单位的当前时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)&lt;/code&gt;：将数组中指定的数据拷贝到另一个数组中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;currenttimemillis方法&quot;&gt;3.1 currentTimeMillis方法&lt;/h2&gt;
&lt;p&gt;实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Date;

public class SystemDemo {
    public static void main(String[] args) {
        //获取当前时间毫秒值
        System.out.println(System.currentTimeMillis()); // 1580485508707
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;练习-1&quot;&gt;练习&lt;/h3&gt;
&lt;p&gt;验证for循环打印数字1-9999所需要使用的时间（毫秒）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SystemTest1 {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 10000; i++) {
            System.out.println(i);
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;arraycopy方法&quot;&gt;3.2 arraycopy方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)&lt;/code&gt;：将数组中指定的数据拷贝到另一个数组中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;源数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;srcPos&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;源数组索引起始位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;dest&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;目标数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;destPos&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;目标数组索引起始位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;复制元素个数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;练习-2&quot;&gt;练习&lt;/h3&gt;
&lt;p&gt;将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Demo11SystemArrayCopy {
    public static void main(String[] args) {
        int[] src = new int[]{1,2,3,4,5};
        int[] dest = new int[]{6,7,8,9,10};
        System.arraycopy( src, 0, dest, 0, 3);
        /*代码运行后：两个数组中的元素发生了变化
         src数组元素[1,2,3,4,5]
         dest数组元素[1,2,3,9,10]
        */
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;字符串拼接问题&quot;&gt;4.1 字符串拼接问题&lt;/h2&gt;
&lt;p&gt;由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StringDemo {
    public static void main(String[] args) {
        String s = &quot;Hello&quot;;
        s += &quot;World&quot;;
        System.out.println(s);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。&lt;/p&gt;
&lt;p&gt;根据这句话分析我们的代码，其实总共产生了三个字符串，即&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;、&lt;code&gt;&quot;World&quot;&lt;/code&gt;和&lt;code&gt;&quot;HelloWorld&quot;&lt;/code&gt;。引用变量s首先指向&lt;code&gt;Hello&lt;/code&gt;对象，最终指向拼接出来的新字符串对象，即&lt;code&gt;HelloWord&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235816233-957083450.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用&lt;code&gt;java.lang.StringBuilder&lt;/code&gt;类。&lt;/p&gt;
&lt;h2 id=&quot;stringbuilder概述&quot;&gt;4.2 StringBuilder概述&lt;/h2&gt;
&lt;p&gt;查阅&lt;code&gt;java.lang.StringBuilder&lt;/code&gt;的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。&lt;/p&gt;
&lt;p&gt;原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。&lt;/p&gt;
&lt;p&gt;它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200131235826752-919776019.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;构造方法-1&quot;&gt;4.3 构造方法&lt;/h2&gt;
&lt;p&gt;根据StringBuilder的API文档，常用构造方法有2个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public StringBuilder()&lt;/code&gt;：构造一个空的StringBuilder容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public StringBuilder(String str)&lt;/code&gt;：构造一个StringBuilder容器，并将字符串添加进去。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StringBuilderDemo {
    public static void main(String[] args) {
        StringBuilder sb1 = new StringBuilder();
        System.out.println(sb1); // (空白)
        // 使用带参构造
        StringBuilder sb2 = new StringBuilder(&quot;helloworld&quot;);
        System.out.println(sb2); // helloworld
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用方法-3&quot;&gt;4.4 常用方法&lt;/h2&gt;
&lt;p&gt;StringBuilder常用的方法有2个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public StringBuilder append(...)&lt;/code&gt;：添加任意类型数据的字符串形式，并返回当前对象自身。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public String toString()&lt;/code&gt;：将当前StringBuilder对象转换为String对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;append方法&quot;&gt;append方法&lt;/h3&gt;
&lt;p&gt;append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo02StringBuilder {
    public static void main(String[] args) {
        //创建对象
        StringBuilder builder = new StringBuilder();
        //public StringBuilder append(任意类型)
        StringBuilder builder2 = builder.append(&quot;hello&quot;);
        //对比一下
        System.out.println(&quot;builder:&quot;+builder);
        System.out.println(&quot;builder2:&quot;+builder2);
        System.out.println(builder == builder2); //true
        // 可以添加 任何类型
        builder.append(&quot;hello&quot;);
        builder.append(&quot;world&quot;);
        builder.append(true);
        builder.append(100);
        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。
        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下
        //链式编程
        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);
        System.out.println(&quot;builder:&quot;+builder);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;备注：StringBuilder已经覆盖重写了Object当中的toString方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;tostring方法-1&quot;&gt;toString方法&lt;/h3&gt;
&lt;p&gt;通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo16StringBuilder {
    public static void main(String[] args) {
        // 链式创建
        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);
        // 调用方法
        String str = sb.toString();
        System.out.println(str); // HelloWorldJava
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;概述-2&quot;&gt;5.1 概述&lt;/h2&gt;
&lt;p&gt;Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Integer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Character&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;装箱与拆箱&quot;&gt;5.2 装箱与拆箱&lt;/h2&gt;
&lt;p&gt;基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：&lt;/p&gt;
&lt;p&gt;用Integer与 int为例：（看懂代码即可）&lt;/p&gt;
&lt;p&gt;基本数值----&amp;gt;包装对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Integer i = new Integer(4);//使用构造函数函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包装对象----&amp;gt;基本数值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int num = i.intValue();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动装箱与自动拆箱&quot;&gt;5.3自动装箱与自动拆箱&lt;/h2&gt;
&lt;p&gt;由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本类型与字符串之间的转换&quot;&gt;5.3 基本类型与字符串之间的转换&lt;/h2&gt;
&lt;h3 id=&quot;基本类型转换为string&quot;&gt;基本类型转换为String&lt;/h3&gt;
&lt;p&gt;基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;基本类型直接与””相连接即可；如：34+&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;String转换成对应的基本类型&lt;/p&gt;
&lt;p&gt;除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static byte parseByte(String s)&lt;/code&gt;：将字符串参数转换为对应的byte基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static short parseShort(String s)&lt;/code&gt;：将字符串参数转换为对应的short基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static int parseInt(String s)&lt;/code&gt;：将字符串参数转换为对应的int基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static long parseLong(String s)&lt;/code&gt;：将字符串参数转换为对应的long基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static float parseFloat(String s)&lt;/code&gt;：将字符串参数转换为对应的float基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static double parseDouble(String s)&lt;/code&gt;：将字符串参数转换为对应的double基本类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean parseBoolean(String s)&lt;/code&gt;：将字符串参数转换为对应的boolean基本类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码使用（仅以Integer类的静态方法parseXxx为例）如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo18WrapperParse {
    public static void main(String[] args) {
        int num = Integer.parseInt(&quot;100&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出&lt;code&gt;java.lang.NumberFormatException&lt;/code&gt;异常。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 31 Jan 2020 16:00:00 +0000</pubDate>
<dc:creator>平酱</dc:creator>
<og:description>主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 学习目标 [ ] 能够说出Object类的特点 [ ] 能够重写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/12247343.html</dc:identifier>
</item>
<item>
<title>kafka概念扫盲 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/12247158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/12247158.html</guid>
<description>&lt;h3&gt;一、kafka概述&lt;/h3&gt;
&lt;h4&gt;1.1、定义&lt;/h4&gt;
&lt;p&gt;Kakfa是一个分布式的基于发布/订阅模式的消息队列（message queue），主要应用于大数据的实时处理领域&lt;/p&gt;
&lt;h4&gt;1.2、消息队列&lt;/h4&gt;
&lt;h5&gt;1.2.1、传统的消息队列&amp;amp;新式的消息队列的模式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131200711071-2090229835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;上面是传统的消息队列，比如一个用户要注册信息，当用户信息写入数据库后，后面还有一些其他流程，比如发送短信，则需要等这些流程处理完成后，在返回给用户&lt;/p&gt;
&lt;p&gt;而新式的队列是，比如一个用户注册信息，数据直接丢进数据库，就直接返回给用户成功&lt;/p&gt;
&lt;h5&gt;1.2.2、使用消息队列的好处&lt;/h5&gt;
&lt;p&gt;A、        解耦&lt;/p&gt;
&lt;p&gt;B、        可恢复性&lt;/p&gt;
&lt;p&gt;C、        缓冲&lt;/p&gt;
&lt;p&gt;D、        灵活性&amp;amp;峰值处理能力&lt;/p&gt;
&lt;p&gt;E、         异步通信&lt;/p&gt;

&lt;h5&gt;1.2.3、消息队列的模式&lt;/h5&gt;
&lt;p&gt;A、点对点模式&lt;/p&gt;
&lt;p&gt;消息生产者发送消息到消息队列中，然后消息消费者从队列中取出并且消费消息，消息被消费后，队列中不在存储。所以消息消费者不可能消费到已经被消费的消息；队列支持存在多个消费者，但是对于一个消息而言，只会 有一个消费者可以消费；如果想发给多个消费者，则需要多次发送该条消息&lt;/p&gt;
&lt;p&gt;B】发布/订阅模式（一对多，消费者消费数据之后不会清除消息）&lt;/p&gt;
&lt;p&gt;消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息，和点对点的方式不同，发布到topic的消息会被所有的订阅者消费；但是数据保留是期限的，默认是7天，因为他不是存储系统；kafka就是这种模式的；有两种方式，一种是是消费者去主动去消费（拉取）消息，而不是生产者推送消息给消费者；另外一种就是生产者主动推送消息给消费者，类似公众号&lt;/p&gt;

&lt;h4&gt;1.3、kafka的基础架构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131201324199-911025807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;kafka的基础架构主要有broker、生产者、消费者组构成，当前还包括zookeeper&lt;/p&gt;
&lt;p&gt;生产者负责发送消息&lt;/p&gt;
&lt;p&gt;broker负责缓冲消息，broker中可以创建topic，每个topic又有partition和replication的概念&lt;/p&gt;
&lt;p&gt;消费者组负责处理消息，同一个消费者组的中消费者不能消费同一个partition中的数据，消费者组主要是提高消费能力，比如之前是一个消费者消费100条数据，现在是2个消费者消费100条数据，可以提高消费能力；所以消费者组的消费者的个数要小于partition的个数，不然就会有消费者没有partition可以消费，造成资源的浪费&lt;/p&gt;
&lt;p&gt;注：但是不同的消费者组的消费者是可以消费相同的partition数据&lt;/p&gt;
&lt;p&gt;Kakfa如果要组件集群，则只需要注册到一个zk中就可以了，zk中还保留消息消费的进度或者说偏移量或者消费位置&lt;/p&gt;
&lt;p&gt;0.9版本之前偏移量存储在zk&lt;/p&gt;
&lt;p&gt;0.9版本之后偏移量存储在kafka中，kafka定义了一个系统的topic，专用用来存储偏移量的数据；&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为什么要改？主要是考虑到频繁更改偏移量，对zk&lt;/em&gt;&lt;em&gt;的压力较大，而且kafka&lt;/em&gt;&lt;em&gt;本身自己的处理也较复杂&lt;/em&gt;&lt;/p&gt;

&lt;h4&gt;1.4、kafka安装&lt;/h4&gt;
&lt;p&gt;A、Kafka的安装只需要解压安装包就可以完成安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
tar -zxvf kafka_2.11-2.1.1.tgz -C /usr/local/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;B、查看配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@es1 config]# pwd
/usr/local/kafka/config
[root@es1 config]# ll
total 84
-rw-r--r--. 1 root root  906 Feb  8  2019 connect-console-sink.properties
-rw-r--r--. 1 root root  909 Feb  8  2019 connect-console-source.properties
-rw-r--r--. 1 root root 5321 Feb  8  2019 connect-distributed.properties
-rw-r--r--. 1 root root  883 Feb  8  2019 connect-file-sink.properties
-rw-r--r--. 1 root root  881 Feb  8  2019 connect-file-source.properties
-rw-r--r--. 1 root root 1111 Feb  8  2019 connect-log4j.properties
-rw-r--r--. 1 root root 2262 Feb  8  2019 connect-standalone.properties
-rw-r--r--. 1 root root 1221 Feb  8  2019 consumer.properties
-rw-r--r--. 1 root root 4727 Feb  8  2019 log4j.properties
-rw-r--r--. 1 root root 1925 Feb  8  2019 producer.properties
-rw-r--r--. 1 root root 6865 Jan 16 22:00 server-1.properties
-rw-r--r--. 1 root root 6865 Jan 16 22:00 server-2.properties
-rw-r--r--. 1 root root 6873 Jan 16 03:57 server.properties
-rw-r--r--. 1 root root 1032 Feb  8  2019 tools-log4j.properties
-rw-r--r--. 1 root root 1169 Feb  8  2019 trogdor.conf
-rw-r--r--. 1 root root 1023 Feb  8  2019 zookeeper.properties
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;C、修改配置文件server.properties&lt;/p&gt;
&lt;p&gt;设置broker.id 这个是kafka集群区分每个节点的唯一标志符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202022282-864716521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;D、设置kafka的数据存储路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202038301-2060231790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;em&gt;注：这个目录下不能有其他非kafka的目录，不然会导致kafka集群无法启动&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;E、设置是否可以删除topic，默认情况先kafka的topic是不允许删除的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202112218-1621090775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;F、Kafka的数据保留的时间，默认是7天&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202124807-1402610220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;G、Log文件最大的大小，如果log文件超过1g会创建一个新的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202135543-407949700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202139764-976965173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;H、Kafka连接的zk的地址和连接kafka的超时时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202150105-123796508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;J、默认的partition的个数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202159541-796590646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;1.5、启动kafka&lt;/h4&gt;
&lt;p&gt;A、启动方式1，kafka只能单节点启动，所以每个kakfa节点都需要手动启动，下面的方式阻塞的方式启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202226818-205964142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;B、启动方式2，守护的方式启动，推荐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202237546-2116495156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;1.6、kafka操作&lt;/h4&gt;
&lt;p&gt;A、查看当前kafka集群已有的topic&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202255911-63325707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;em&gt;注意：这里连接的zookeeper，而不是连接的kafka&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;B、创建topic，指定分片和副本个数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202324336-1254793075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;replication-factor：副本数&lt;/p&gt;
&lt;p&gt;replication-factor：分区数&lt;/p&gt;
&lt;p&gt;Topic：主题名&lt;/p&gt;
&lt;p&gt;如果当前kafka集群只有3个broker节点，则replication-factor最大就是3了，下面的例子创建副本为4，则会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202346389-2109762545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;C、删除topic&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202415958-452312600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;D、查看topic信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202428081-1996814206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202432930-2060413505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h4&gt;1.7、启动生产者生产消息，kafka自带一个生产者和消费者的客户端&lt;/h4&gt;
&lt;p&gt;A、启动一个生产者，注意此时连的9092端口，连接的kafka集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202515885-1868235542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;B、启动一个消费者，注意此时连接的还是9092端口，在0.9版本之前连接的还是2181端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202525557-1175964702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这里我们启动2个消费者来测试一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202535809-1040162685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;注：如果不指定的消费者组的配置文件的话，默认每个消费者都属于不同的消费者组&lt;/p&gt;
&lt;p&gt;C、发送消息，可以看到每个消费者都能收到消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202548094-1296482502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202557700-1942770265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202602486-226710682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;D、Kakfa中的实际的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202623596-1169673970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131202651578-1099290287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;二、kafka架构深入&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131203824562-1714355832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;Kafka不能保证消息的全局有序，只能保证消息在partition内有序，因为消费者消费消息是在不同的partition中随机的&lt;/p&gt;
&lt;h4&gt;2.1、kafka的工作流程&lt;/h4&gt;
&lt;p&gt;Kafka中的消息是以topic进行分类的，生产者生成消息，消费者消费消息，都是面向topic的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204141140-970059672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;Topic是一个逻辑上的概念，而partition是物理上的概念&lt;/p&gt;
&lt;p&gt;每个partition又有副本的概念&lt;/p&gt;
&lt;p&gt;每个partition对应于一个log文件，该log文件中存储的就是生产者生成的数据，生产者生成的数据会不断的追加到该log的文件末端，且每条数据都有自己的offset，消费者都会实时记录自己消费到了那个offset，以便出错的时候从上次的位置继续消费，这个offset就保存在index文件中&lt;/p&gt;
&lt;p&gt;kafka的offset是分区内有序的，但是在不同分区中是无顺序的，kafka不保证数据的全局有序&lt;/p&gt;
&lt;h4&gt;2.2、kafka原理&lt;/h4&gt;
&lt;p&gt;由于生产者生产的消息会不断追加到log文件的末尾，为防止log文件过大导致数据定位效率低下，Kafka采用分片和索引的机制，将每个partition分为多个segment，每个segment对应2个文件----index文件和log文件，这2个文件位于一个相同的文件夹下，文件夹的命名规则为topic名称+分区序号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204024117-795235739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Indx和log的文件的文件名是当前这个索引是最小的数据的offset&lt;/p&gt;
&lt;p&gt;Kafka如何快速的消费数据呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204046081-2047384973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Index文件中存储的数据的索引信息，第一列是offset，第二列这这个数据所对应的log文件中的偏移量，就像我们去读文件，使用seek（）设置当前鼠标的位置一样，可以更快的找到数据&lt;/p&gt;
&lt;p&gt;如果要去消费offset为3的数据，首先通过二分法找到数据在哪个index文件中，然后在通过index中offset找到数据在log文件中的offset；这样就可以快速的定位到数据，并消费&lt;/p&gt;
&lt;p&gt;所以kakfa虽然把数据存储在磁盘中，但是他的读取速度还是非常快的&lt;/p&gt;

&lt;h3&gt;三、kafka的生产者和消费者&lt;/h3&gt;
&lt;h4&gt;3.1、kafka的生产者&lt;/h4&gt;
&lt;p&gt;Kafka的partition的分区的作用&lt;/p&gt;
&lt;p&gt;Kafka的分区的原因主要就是提供并发提高性能，因为读写是partition为单位读写的；&lt;/p&gt;
&lt;p&gt;那生产者发送消息是发送到哪个partition中呢？&lt;/p&gt;
&lt;p&gt;A、在客户端中指定partition&lt;/p&gt;
&lt;p&gt;B、轮询（推荐）消息1去p1，消息2去p2，消息3去p3，消息4去p1，消息5去p2，消息6去p3 。。。。。。。&lt;/p&gt;

&lt;h4&gt;3.2 kafka如何保证数据可靠性呢？通过ack来保证&lt;/h4&gt;
&lt;p&gt;为保证生产者发送的数据，能可靠的发送到指定的topic，topic的每个partition收到生产者发送的数据后，都需要向生产者发送ack（确认收到），如果生产者收到ack，就会进行下一轮的发送，否则重新发送数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204154404-513972939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204201782-143684413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那么kafka什么时候向生产者发送ack&lt;/p&gt;
&lt;p&gt;确保follower和leader同步完成，leader在发送ack给生产者，这样才能确保leader挂掉之后，能再follower中选举出新的leader后，数据不会丢失&lt;/p&gt;
&lt;p&gt;那多少个follower同步完成后发送ack&lt;/p&gt;
&lt;p&gt;方案1：半数已经完成同步，就发送ack&lt;/p&gt;
&lt;p&gt;方案2：全部完成同步，才发送ack（kafka采用这种方式）&lt;/p&gt;
&lt;p&gt;采用第二种方案后，设想以下场景，leader收到数据，所有的follower都开始同步数据，但是有一个follower因为某种故障，一直无法完成同步，那leader就要一直等下，直到他同步完成，才能发送ack，这样就非常影响效率，这个问题怎么解决？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204218266-1478015748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Leader维护了一个动态的ISR列表（同步副本的作用），只需要这个列表的中的follower和leader同步；当ISR中的follower完成数据的同步之后，leader就会给生产者发送ack，如果follower长时间未向leader同步数据，则该follower将被剔除ISR，这个时间阈值也是自定义的；同样leader故障后，就会从ISR中选举新的leader&lt;/p&gt;
&lt;p&gt;怎么选择ISR的节点呢？&lt;/p&gt;
&lt;p&gt;首先通信的时间要快，要和leader要可以很快的完成通信，这个时间默认是10s&lt;/p&gt;
&lt;p&gt;然后就看leader数据差距，消息条数默认是10000条（后面版本被移除）&lt;/p&gt;
&lt;p&gt;为什么移除：因为kafka发送消息是批量发送的，所以会一瞬间leader接受完成，但是follower还没有拉取，所以会频繁的踢出加入ISR，这个数据会保存到zk和内存中，所以会频繁的更新zk和内存。&lt;/p&gt;

&lt;p&gt;但是对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接受成功&lt;/p&gt;
&lt;p&gt;所以kafka为用户提供了三种可靠性级别，用户可以根据可靠性和延迟进行权衡，这个设置在kafka的生成中设置：acks参数设置&lt;/p&gt;
&lt;p&gt;A、acks为0&lt;/p&gt;
&lt;p&gt;生产者不等ack，只管往topic丢数据就可以了，这个丢数据的概率非常高&lt;/p&gt;
&lt;p&gt;B、ack为1&lt;/p&gt;
&lt;p&gt;Leader落盘后就会返回ack，会有数据丢失的现象，如果leader在同步完成后出现故障，则会出现数据丢失&lt;/p&gt;
&lt;p&gt;C、ack为-1（all）&lt;/p&gt;
&lt;p&gt;Leader和follower（ISR）落盘才会返回ack，会有数据重复现象，如果在leader已经写完成，且follower同步完成，但是在返回ack的出现故障，则会出现数据重复现象；极限情况下，这个也会有数据丢失的情况，比如follower和leader通信都很慢，所以ISR中只有一个leader节点，这个时候，leader完成落盘，就会返回ack，如果此时leader故障后，就会导致丢失数据&lt;/p&gt;

&lt;h4&gt;3.3 Kafka如何保证消费数据的一致性？通过HW来保证&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131204307789-990426704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;LEO：指每个follower的最大的offset&lt;/p&gt;
&lt;p&gt;HW（高水位）：指消费者能见到的最大的offset，LSR队列中最小的LEO，也就是说消费者只能看到1~6的数据，后面的数据看不到，也消费不了&lt;/p&gt;
&lt;p&gt;避免leader挂掉后，比如当前消费者消费8这条数据后，leader挂   了，此时比如f2成为leader，f2根本就没有9这条数据，那么消费者就会报错，所以设计了HW这个参数，只暴露最少的数据给消费者，避免上面的问题&lt;/p&gt;

&lt;h5&gt;3.3.1、HW保证数据存储的一致性&lt;/h5&gt;
&lt;p&gt;A、Follower故障&lt;/p&gt;
&lt;p&gt;Follower发生故障后会被临时提出LSR，待该follower恢复后，follower会读取本地的磁盘记录的上次的HW，并将该log文件高于HW的部分截取掉，从HW开始想leader进行同步，等该follower的LEO大于等于该Partition的hw，即follower追上leader后，就可以重新加入LSR&lt;/p&gt;
&lt;p&gt;B、Leader故障&lt;/p&gt;
&lt;p&gt;Leader发生故障后，会从ISR中选出一个新的leader，之后，为了保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于hw的部分截掉（新leader自己不会截掉），然后从新的leader同步数据&lt;/p&gt;
&lt;p&gt;注意：这个是为了保证多个副本间的数据存储的一致性，并不能保证数据不丢失或者不重复&lt;/p&gt;

&lt;h5&gt;3.3.2精准一次（幂等性），保证数据不重复&lt;/h5&gt;

&lt;p&gt;Ack设置为-1，则可以保证数据不丢失，但是会出现数据重复（at least once）&lt;/p&gt;
&lt;p&gt;Ack设置为0，则可以保证数据不重复，但是不能保证数据不丢失（at most once）&lt;/p&gt;
&lt;p&gt;但是如果鱼和熊掌兼得，该怎么办？这个时候就就引入了Exactl once（精准一次）&lt;/p&gt;

&lt;p&gt;在0.11版本后，引入幂等性解决kakfa集群内部的数据重复，在0.11版本之前，在消费者处自己做处理&lt;/p&gt;
&lt;p&gt;如果启用了幂等性，则ack默认就是-1，kafka就会为每个生产者分配一个pid，并未每条消息分配seqnumber，如果pid、partition、seqnumber三者一样，则kafka认为是重复数据，就不会落盘保存；但是如果生产者挂掉后，也会出现有数据重复的现象；所以幂等性解决在单次会话的单个分区的数据重复，但是在分区间或者跨会话的是数据重复的是无法解决的&lt;/p&gt;
&lt;h4&gt;3.4 kafka的消费者&lt;/h4&gt;
&lt;h5&gt;3.4.1 消费方式&lt;/h5&gt;
&lt;p&gt;消息队列有两种消费消息的方式，push（微信公众号）、pull（kafka），push模式很难适应消费速率不同的消费者，因为消费发送速率是由broker决定的，他的目标是尽可能以最快的的速度传递消息，但是这样很容易造成消费者来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull的方式可以消费者的消费能力以适当的速率消费消息&lt;/p&gt;
&lt;p&gt;Pull的模式不足之处是如果kafka没有数据，消费者可能会陷入死循环，一直返回空数据，针对这一点，kafka的消费者在消费数据时候回传递一个timeout参数，如果当时没有数据可供消费，消费者会等待一段时间在返回&lt;/p&gt;
&lt;h5&gt;3.4.2 分区分配策略&lt;/h5&gt;
&lt;p&gt;一个消费者组有多个消费者，一个topic有多个partition。所以必然会涉及到partition的分配问题，即确定哪个partition由哪个消费者来消费&lt;/p&gt;
&lt;p&gt;Kafka提供两种方式，一种是轮询（RountRobin）对于topic组生效，一种是（Range）对于单个topic生效&lt;/p&gt;

&lt;p&gt;轮训：前置条件是需要一个消费者里的消费者订阅的是相同的topic。不然就会出现问题；非默认的的方式&lt;/p&gt;

&lt;p&gt;同一个消费者组里的消费者不能同时消费同一个分区&lt;/p&gt;
&lt;p&gt;比如三个消费者消费一个topic的9个分区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224206816-1611451339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224236670-754044891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果一个消费者组里有2个消费者，这个消费者组里同时消费2个topic，每个topic又有三个partition&lt;/p&gt;
&lt;p&gt;首先会把2个topic当做一个主题，然后根据topic和partition做hash，然后在按照hash排序。然后轮训分配给一个消费者组中的2个消费者&lt;/p&gt;

&lt;p&gt;如果是下面这样的方式订阅的呢？&lt;/p&gt;
&lt;p&gt;比如有3个topic，每个topic有3个partition，一个消费者组中有2个消费者。消费者1订阅topic1和topic2，消费者2订阅topic2和topic3，那么这样的场景，使用轮训的方式订阅topic就会有问题&lt;/p&gt;

&lt;p&gt;如果是下面这种方式订阅呢&lt;/p&gt;
&lt;p&gt;比如有2个topic，每个topic有3个partition，一个消费者组 有2个消费者，消费者1订阅topic1，消费者2订阅topic2，这样使用轮训的方式订阅topic也会有问题&lt;/p&gt;

&lt;p&gt;所以我们一直强调，使用轮训的方式订阅topic的前提是一个消费者组中的所有消费者订阅的主题是一样的；&lt;/p&gt;
&lt;p&gt;所以轮训的方式不是kafka默认的方式&lt;/p&gt;
&lt;p&gt;Range：是按照单个topic来划分的，默认的分配方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224306794-1374740347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224336451-1072346521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Range的问题会出现消费者数据不均衡的问题&lt;/p&gt;
&lt;p&gt;比如下面的例子，一个消费者组订阅了2个topic，就会出现消费者1消费4个partition，而另外一个消费者只消费2个partition&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224710754-1842290115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;分区策略什么时候会触发呢？当消费者组里的消费者个数变化的时候，会触发分区策略调整，比如消费者里增加消费者，或者减少消费者&lt;/p&gt;
&lt;h5&gt;3.4.3 offset的维护&lt;/h5&gt;
&lt;p&gt;由于消费者在消费过程中可能会出现断电宕机等故障，消费者恢复后，需要从故障前的位置继续消费，所以消费者需要实施记录自己消费哪个offset，以便故障恢复后继续消费&lt;/p&gt;
&lt;p&gt;Offset保存的位置有2个，一个zk，一个是kafka&lt;/p&gt;
&lt;p&gt;首先看下offset保存到zk&lt;/p&gt;
&lt;p&gt;由消费者组、topic、partition三个元素确定唯一的offset&lt;/p&gt;

&lt;p&gt;所以消费者组中的某个消费者挂掉之后，或者的消费者还是可以拿到这个offset的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224738000-477198235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Controller这个节点和zk通信，同步数据，这个节点就是谁先起来，谁就先注册controller，谁就是controller。其他节点和controller信息保持同步&lt;/p&gt;

&lt;h5&gt;3.4.5、消费者组的案例&lt;/h5&gt;
&lt;p&gt;修改消费者组id&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224749279-2041794318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;启动一个消费者发送3条数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224759294-176909208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;指定消费者组启动消费者，启动三个消费者，可以看到每个消费者消费了一条数据&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224818415-756898657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224822658-948649619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224828742-1088883690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在演示下不同组可以消费同一个topic的，我们看到2个消费者的消费者都消费到同一条数据&lt;/p&gt;
&lt;p&gt;再次启动一个消费者，这个消费者属于另外一个消费者组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224838589-757581987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131224843151-1733853353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;四、Kafka的高效读写机制&lt;/h3&gt;
&lt;h4&gt;4.1、分布式部署&lt;/h4&gt;
&lt;p&gt;多节点并行操作&lt;/p&gt;

&lt;h4&gt;4.2、顺序写磁盘&lt;/h4&gt;
&lt;p&gt;Kafka的producer生产数据，要写入到log文件中，写的过程中一直追加到文件末尾，为顺序写，官网有数据表明。同样的磁盘，顺序写能到600M/S，而随机写只有100K/S。这与磁盘的机械结构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间&lt;/p&gt;
&lt;h4&gt;4.3、零复制技术&lt;/h4&gt;
&lt;p&gt;正常情况下，先把数据读到内核空间，在从内核空间把数据读到用户空间，然后在调操作系统的io接口写到内核空间，最终在写到硬盘中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131225256261-91988452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Kafka是这样做的，直接在内核空间流转io流，所以kafka的性能非常高&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1101486/202001/1101486-20200131225344212-845134306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;五、 zookeeper在kafka中的作用&lt;/h3&gt;
&lt;p&gt;Kafka集群中有一个broker会被选举为controller，负责管理集群broker的上下线，所有的topic的分区副本分配和leader选举等工作&lt;/p&gt;

</description>
<pubDate>Fri, 31 Jan 2020 14:59:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>一、kafka概述 1.1、定义 Kakfa是一个分布式的基于发布/订阅模式的消息队列（message queue），主要应用于大数据的实时处理领域 1.2、消息队列 1.2.1、传统的消息队列&amp;am</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bainianminguo/p/12247158.html</dc:identifier>
</item>
<item>
<title>新年计划与企盼 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/12247006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/12247006.html</guid>
<description>&lt;p&gt;2020年的第一个月里总想写些什么，却又苦于灵感匮乏，所以一直拖到当月最后一日，决定提笔写篇年度计划以作为开年的头一篇博文以便在新的一年伊始，理清思路，全盘规划。&lt;/p&gt;

&lt;p&gt;调整技术方向，从过去的ABC转为AAA。ABC指的是AI(人工智能)，Big Data(大数据)与Cloud(云)，AAA则是AI，Algorithm(算法)，Architecture(架构)。&lt;/p&gt;
&lt;p&gt;AI方向保持不变，个人还是看好人工智能的发展，但未来的关键是其落地能力，光是学术论文上的繁盛，并不能给人们带来实际的价值。而在应用上的实现正是工程师所熟悉和擅长的领域，这方面感觉仍大有作为。&lt;br/&gt;值得一提的是，微软现任CEO纳德拉(Nadella)在其著书(Hit Refresh)中曾提到其看中的三种技术，混合现实，人工智能及量子计算也包含了这一项，由此可见，在这一点上大家的共识还是一致的。&lt;/p&gt;
&lt;p&gt;新增的Algorithm所指的既是通用的算法，也是专门领域的算法。传统上定义计算机的程序等于数据结构+算法，所以在这一行不可避免的需要接触到它。虽然以前写业务代码的场景更多些，但在某些时候，还是需要能够迅速且正确地使用某些通用算法完成特定任务。然而，自己在这方面尚有欠缺，需要持续锤练，以趋完善。有种学习方式称为“刻意练习”，应该针对的就是这样的问题。&lt;br/&gt;同时，因为要研究AI这块，机器学习与深度学习方面的算法也是需要花时间去认真学习的。不能因为着重于工程方面的问题，而忽略了一些本质原理。除了知晓事物的How，也要明白它们的Why，这应当也是工程师所追求的自身特性(Feature)。&lt;/p&gt;
&lt;p&gt;大数据与云被移到了Architecture里面，这两块已经是现代系统的标配，无需多言，更值得关注的是作为一个整体，架构对于系统的持续保障以及成本与投入比(ROI)的影响。&lt;br/&gt;架构中所需学习的内容甚广，不仅涉及软件方面，还有硬件，网络等其它因素需要考量。除此之外领域业务知识，沟通协调能力，团队管理技巧等诸多软硬技能也不能成为过于明显的短板。它是一个必须抱有终身学习态度的方向。&lt;/p&gt;

&lt;p&gt;也曾体会到数学之美，但之前遗落其过久，重新捡回它还是需要一定时间与精力的。但又不可不为。&lt;br/&gt;数学领域同样十分广阔，与其毫无目的地乱逛，不如针对自己所需，专攻一隅。&lt;br/&gt;人工智能的数学基石在于微积分，线性代数，概率论与数理统计，所以花上一年时间在这些基础知识上应该是十分值得的。&lt;/p&gt;

&lt;p&gt;英语能力常年偏于读之上，听说与写的能力可谓稀松。虽说这样解决了阅读外文资料的问题，但当需要使用外语进行深层沟通的时候，还是有所不及。这一弊端在当前愈发明显，已经造成了不良的影响，亟待改善。&lt;br/&gt;对于AI中自然语言处理(NLP)这一领域，若是想深究其理，语言能力上的精通可谓必不可少，因此这一方面的投入也是很有价值的。&lt;/p&gt;

&lt;p&gt;沟通着重于影响力方面。多与人交流，将自己所学所知分享给他人，才能得到更多的反馈，便于自身的的改进，更重要的是可以在他人心中树立自己的影响力，以便之后更好的合作。&lt;/p&gt;

&lt;p&gt;这几年都一直在读书，因有好读书不求甚解的习惯，所以常感杂而不精。今年尝试读少书，书多读的策略，至年终看看有没有意外的收获。&lt;/p&gt;

&lt;p&gt;博客也是一直在写，但有效输出还是少了些，总结下来终还是个懒字，希望这一年可以多有产出。&lt;/p&gt;

&lt;p&gt;我所看重者无非三件事：安全，健康，教育。&lt;br/&gt;自己的健康状况常年处于不是太佳，也不是太坏的中庸境地，为了达成终身学习的愿望，还是有必要全面提升下身体素质，以便活得更久，活得更好。&lt;/p&gt;

&lt;p&gt;财务自由虽然不是我的主要追求目标，但至少不应被其过多困扰。&lt;br/&gt;始终相信足够的能力可以带来足够的经济自主，若是钱不够花了，还是自己的缘故占了大多数的因素。所以还需努力。&lt;/p&gt;

&lt;p&gt;年年岁岁花相似，岁岁年年人不同。今年与往年相比应并无大不同，但又总有些不一样的，我是如此企盼并相信着。&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jan 2020 14:55:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>前言 2020年的第一个月里总想写些什么，却又苦于灵感匮乏，所以一直拖到当月最后一日，决定提笔写篇年度计划以作为开年的头一篇博文以便在新的一年伊始，理清思路，全盘规划。 技术 调整技术方向，从过去的A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/12247006.html</dc:identifier>
</item>
<item>
<title>makefile自动依赖生成 - jakio6</title>
<link>http://www.cnblogs.com/jakio6/p/12247034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jakio6/p/12247034.html</guid>
<description>&lt;p&gt;基于make的构建环境要正确工作, 一个很重要(也很烦人)的任务是, 在makefile中正确列&lt;br/&gt;举依赖.&lt;/p&gt;
&lt;p&gt;这个文档将介绍了一个非常有用的让make自身来创建和维护这些依赖的方法.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/&quot;&gt;文章来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所有的make程序都需要知道, 某个特定的target依赖的文件有哪些, 以便确认它(target)&lt;br/&gt;会在必要的时候进行rebuild.&lt;/p&gt;
&lt;p&gt;手动更行这个清单不仅仅是让人乏味, 而且非常容易出错. 多数系统(不论大小)都偏向与&lt;br/&gt;提供自动提取这个信息的自动化工具. 传统的工具的是&lt;code&gt;makedepend&lt;/code&gt;程序, 其会读取c源代&lt;br/&gt;码, 并以可以include至makefile中的__目标-依赖__模式生成头文件清单.&lt;/p&gt;
&lt;p&gt;如果使用更加强大一点的编译器或者预处理器, 更加现代话的解决方案是让编译器或者预&lt;br/&gt;处理器来生成这个信息.&lt;/p&gt;
&lt;p&gt;这篇文章的意图不是专门讨论依赖信息获得的方式的(尽管有涉及到), 而是, 介绍一些有&lt;br/&gt;用的将这些工具的调用,输出和gnu make组合, 来确保依赖信息总是正确和最新的, 衔接越&lt;br/&gt;紧密(且越高效)越好.&lt;/p&gt;
&lt;p&gt;这些方法依赖gnu make提供的特性. 可能可以通过修改它们来在其他版本的make上应用.&lt;br/&gt;那就等你自己尝试啦. 但是, 在尽心那个尝试之前请看哈&lt;a href=&quot;http://make.mad-scientist.net/papers/rules-of-makefiles#rule1&quot;&gt;paul的makefile第一原则&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gcc方案&quot;&gt;gcc方案&lt;/h2&gt;
&lt;p&gt;如果有谁已近不耐烦了, 这是一个完整的最佳的实践方案. 这个方案需要你的编译器的支&lt;br/&gt;持: 默认你使用gcc作为编译器(或者提供了和gcc兼容的预处理选项的编译器). 如果你的&lt;br/&gt;编译器不满足这个条件, 请看另外的方案.&lt;/p&gt;
&lt;p&gt;将这个加入到你的makefile环境中,(蓝色的部分是对gnu make提供的内建内容的改动). 当&lt;br/&gt;然, 你可以却略不符合你需要的模式规则(或者添加你需要的, whatever).&lt;br/&gt;(当然我这里并没有蓝色...whatever)&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;depdir := .deps
depflags = -mt $@ -mmd -mp -mf $(depdir)/$*.d

compile.c = $(cc) $(depflags) $(cflags) $(cppflags) $(target_arch) -c

%.o : %.c
%.o : %.c $(depdir)/%.d | $(depdir)
        $(compile.c) $(output_option) $&amp;lt;

$(depdir): ; @mkdir -p $@

depfiles := $(srcs:%.c=$(depdir)/%.d)
$(depfiles):

include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意, &lt;code&gt;include&lt;/code&gt;这一行需要出现在初始, 默认target之后, 否则引入的依赖会取代你的&lt;br/&gt;默认target配置. 将这个加到makefile末尾是很好的(或者放在一个单独的makefile文件里&lt;br/&gt;并include他)&lt;/p&gt;
&lt;p&gt;还这, 这里认为srcs变量包含所有你想要跟踪依赖的源文件(不是头文件)&lt;/p&gt;
&lt;p&gt;如果你只是先要知道这些改动的意义的话, 并且考虑一些问题和对它们的解决方案, 可以(看原文,..)&lt;/p&gt;
&lt;h2 id=&quot;传统的make-depend方法&quot;&gt;传统的&lt;code&gt;make depend&lt;/code&gt;方法&lt;/h2&gt;
&lt;p&gt;一个由来已久的处理依赖生成的方式是, 在makefiles中提供一个特殊的target, 通常是&lt;br/&gt;depend, 其可以用于创建依赖信息. 这个target的命令会对xx文件调用一些依赖跟踪工具&lt;br/&gt;..生成makefile格式的依赖信息.&lt;/p&gt;
&lt;p&gt;如果你的make版本支持include, 你可以将它们(依赖输出)重定向到一个文件, 然后&lt;br/&gt;include这个文件. 如果不支持的话, 通常还需要利用shell来将依赖列表追加到makefile&lt;br/&gt;文件末尾...&lt;/p&gt;
&lt;p&gt;这样虽然很简单, 但是存在很严重的问题. 首先也是最重要的是, 依赖只在使用者明确要&lt;br/&gt;求更新的时候才更新, 如果使用者并没有经常运行&lt;code&gt;make depend&lt;/code&gt;, 依赖可能会严重果实,&lt;br/&gt;make就不能正确得rebuild target.. 因此, 我们没法说这是无缝且正确的.&lt;/p&gt;
&lt;p&gt;第二个问题是, 运行&lt;code&gt;make depend&lt;/code&gt;是不高效的, 特别是第一次. 因为它会修改makefile,&lt;br/&gt;通常需要作为一个单独的构建步骤, 也就是在每个子目录的每次make都需要额外调用一次&lt;br/&gt;之类的, 除去依赖生成工具自身的开销不说. 还有, 它会检查每个文件的依赖, 即使是没&lt;br/&gt;有改变的文件&lt;/p&gt;
&lt;p&gt;我们会看看到我们如何可以做到更好.&lt;/p&gt;
&lt;h2 id=&quot;gnu-make-include指令&quot;&gt;gnu make &lt;code&gt;include&lt;/code&gt;指令&lt;/h2&gt;
&lt;p&gt;多数版本的make都支持某种类型的include指令(实际上, &lt;code&gt;include&lt;/code&gt;是最新的posix规范中&lt;br/&gt;明确要求的).&lt;/p&gt;
&lt;p&gt;你马上就会看到为什么这个会有用, 就比如避免上面的追加依赖信息到makefile中. 而在&lt;br/&gt;gnu make的include处理中有更多有趣的能力...gnu make会尝试rebuild引入的makefile.&lt;br/&gt;如果成功rebuild, gnu make会重新执行它自己类读入新版本的makefile.&lt;/p&gt;
&lt;p&gt;这个自动重建的特性可以用于避免使用单独的&lt;code&gt;make depend&lt;/code&gt;步骤: 如果你将所有的源文件&lt;br/&gt;作为包含依赖的文件先决条件, 然后将那个文件include到你的makefile, 则它会在每次有&lt;br/&gt;源文件变动的时候重建. 这样的结果是, 依赖信息总是最新的, 使用者不需要明确运行&lt;br/&gt;&lt;code&gt;make depend&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然, 这意味每次有文件变动的时候所有的文件的依赖信息都会重新计算, 很遗憾. 我们&lt;br/&gt;还可以做得更好.&lt;/p&gt;
&lt;p&gt;关于gnu make的自动重建特性的详细信息, 可以看gnu make的用户手册中&quot;how makefiles are remade&quot;一节&lt;/p&gt;
&lt;h2 id=&quot;基本的自动依赖&quot;&gt;基本的自动依赖&lt;/h2&gt;
&lt;p&gt;gnu make的用户手册中&lt;a href=&quot;http://www.gnu.org/software/make/manual/html_node/automatic-prerequisites.html&quot;&gt;generating dependencies automatically&lt;/a&gt;&lt;br/&gt;一节中介绍了一种处理自动依赖的方式.&lt;/p&gt;
&lt;p&gt;在这个方式中, 或为每个源文件创建一个单独的依赖文件(在我们的例子中我们会使用&lt;br/&gt;basename加上&lt;code&gt;.d&lt;/code&gt;后缀作为文件). 这个文件包含了从那个源文件创建的target的一条依赖&lt;br/&gt;, 提供生成target的先决条件.&lt;/p&gt;
&lt;p&gt;这些依赖文件之后都会被makefile引入. 提供了一条描述依赖文件如何创建的隐式规则.&lt;br/&gt;总的来说, 差不多就是这样:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;srcs = foo.c bar.c ...

%.d : %.c
        $(makedepend)

include $(srcs:.c=.d)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中, 我会使用变量&lt;code&gt;$(makedepend)&lt;/code&gt;来代表你选择的用于创建依赖文件的方式.&lt;br/&gt;这个变量的一些可能的值之后会介绍.&lt;/p&gt;
&lt;p&gt;生成的依赖文件的格式是什么呢? 在这个简单的例子中, 我们需要声明对象文件和依赖文&lt;br/&gt;件都有相同的先决条件: 源文件和所有的头文件, 因此&lt;code&gt;foo.d&lt;/code&gt;文件可能会包含这个:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;foo.o foo.d: foo.c foo.h bar.h baz.h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当gnu make读取这个makefile的时候, 在进行别的事情之前, 会尝试重建引入的makefile,&lt;br/&gt;在这个例子中是后缀&lt;code&gt;.d&lt;/code&gt;的文件. 我们有一条用于构建它们的规则, 并且依赖和构建&lt;code&gt;.o&lt;/code&gt;&lt;br/&gt;文件的依赖一样. 因此, 当任何改动导致原来的target过时的时候, 也会导致&lt;code&gt;.d&lt;/code&gt;文件被&lt;br/&gt;重建.&lt;/p&gt;
&lt;p&gt;因此, 当任何源文件或者引入的文件变动的时候, make或重建&lt;code&gt;.d&lt;/code&gt;文件, 重新执行它自己&lt;br/&gt;来读入新的makefile, 然后继续构建, 这次用的是最新的, 正确的依赖列表.&lt;/p&gt;
&lt;p&gt;这里我们解决了前面的方案的两个问题. 首先, 使用者不需要做任何工作来更新依赖列表,&lt;br/&gt;make自己会完成. 第二, 只更新实际改动的文件的依赖列表, 而非目录中的所有文件.&lt;/p&gt;
&lt;p&gt;但是, 又有了三个新的问题. 首先是, 仍然不够高效, 虽然我们只重新检查了改动的文件,&lt;br/&gt;我们仍然会在有变动的时候重新执行make, 对于大的构建系统会很慢.&lt;/p&gt;
&lt;p&gt;第二个问题是仅仅是烦人: 当你新添加一个文件或者第一次构建, 不存在&lt;code&gt;.d&lt;/code&gt;文件. 当&lt;br/&gt;make试图include的时候会发现它不存在, 他会生成一个warning. 之后gnu make会继续重&lt;br/&gt;建&lt;code&gt;.d&lt;/code&gt;文件, 然后重新调用自身, 不致命, 但是烦人.&lt;/p&gt;
&lt;p&gt;第三个问题更加严重: 如果你移除或者重命名了一个先决文件(比如c的&lt;code&gt;.h&lt;/code&gt;文件), make会&lt;br/&gt;以致命错误推出, 抱怨target不存在:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make: *** no rule to make target 'bar.h', needed by 'foo.d'.  stop.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为&lt;code&gt;.d&lt;/code&gt;文件有make找不到的依赖. 没有先决文件的话没法重建&lt;code&gt;.d&lt;/code&gt;文件, 而它在重&lt;br/&gt;建&lt;code&gt;.d&lt;/code&gt;文件之前不知道它不需要这个先决条件.&lt;/p&gt;
&lt;p&gt;唯一的解决方案是手动介入并移除任何引用了缺失的文件的&lt;code&gt;.d&lt;/code&gt;文件, 通常全部移除会更&lt;br/&gt;简单, 甚至可以创建一个&lt;code&gt;clean-deps&lt;/code&gt;目标或者类似的来自动做这个(..).说来这个确实是&lt;br/&gt;够恼人的, 但是如果文件爱呢移除或者重命名不常发生, 可能就不是致命的了.&lt;/p&gt;
&lt;h2 id=&quot;高级的自动依赖&quot;&gt;高级的自动依赖&lt;/h2&gt;
&lt;p&gt;上面介绍的基础的方式是由tom tromey策划的, 他使用其作为fsf的automake工具的标准依&lt;br/&gt;赖生成方式. 我(不是我)对其进行了一些改动来让它可以用于一个更加一般化的构建环境&lt;br/&gt;中.&lt;/p&gt;
&lt;h2 id=&quot;避免重新执行make&quot;&gt;避免重新执行make&lt;/h2&gt;
&lt;p&gt;先解决上面的第一个问题: make的重新调用. 如果你想一想的话, 这个重新调用真的是没&lt;br/&gt;有必要的. 因为我们知道target的一些先决条件变动了, 我们必须重建构建target, 更新&lt;br/&gt;依赖列表也不会影响这个决定. 我们真正需要做的是确保先决条件列表在make的下次调用,&lt;br/&gt;我们再次需要决定是否是最新的时候.&lt;/p&gt;
&lt;p&gt;因为在这个构建中不需要最新的先决条件列表, 我们实际上可以完全可以避免重新调用&lt;br/&gt;make: 我们可以让先决条件列表在target重建的时候build. 换句话说, 我们可以该百纳&lt;br/&gt;target的构建规则来加入更新依赖文件的命令.&lt;/p&gt;
&lt;p&gt;在这个例子中, 我们必须非常小心, 我们没有提供规则来自动都见依赖: 如果我们提供了,&lt;br/&gt;make仍然会尝试重新构建它们并重新执行: 这不是我们想要的&lt;/p&gt;
&lt;p&gt;现在我们不关心不存在的依赖文件, 解决第二个问题(多余的warning)就非常简单了: 直接&lt;br/&gt;使用gnu make的&lt;code&gt;wildcard&lt;/code&gt;函数, 不存在的依赖文件不会导致错误&lt;/p&gt;
&lt;p&gt;看一个简单例子:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;srcs = foo.c bar.c ...

%.o : %.c
        @$(makedepend)
        $(compile.c) -o $@ $&amp;lt;

include $(wildcard $(srcs:.c=.d))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避免no-rule-to-make-target...的错误&quot;&gt;避免&quot;no rule to make target...&quot;的错误&lt;/h2&gt;
&lt;p&gt;这个要更加刁钻一些. 但是, 我们可以通过在makefile中仅仅将文件作为target来说服&lt;br/&gt;make不要fail. 如果target存在, 但是没有命令(隐式或者显式)或者先决条件, 则make总&lt;br/&gt;是认为它是最新的. 这就是正常的情况, 它会像我们期待的那样工作.&lt;/p&gt;
&lt;p&gt;在出现上述错误的例子中, target并不存在. 而根据gnu make用户手册&quot;rules without&lt;br/&gt;recipes or prerequisties&quot;:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;如果一个规则没有先决条件或者recipe, 并且规则的target是不存在的文件, 那么每次&lt;br/&gt;在它的规则运行的时候, make会认为这个target已近更新了. 这意味着所有依赖于这个&lt;br/&gt;target的target总是会执行其recipe(生成这个target的命令组)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;棒极了. 这确保了make不会丢出错误, 因为它知道如何处理那个不存在的文件, 它会确保&lt;br/&gt;任何l以爱那个target的文件rebuild, 这也是我们想要的.&lt;br/&gt;(???)&lt;/p&gt;
&lt;p&gt;因此, 我们需要做的就是, 修改这个依赖文件输出, 使得每个先决条件(源文件和头文件)&lt;br/&gt;定义为没有命令和先决条件的target. 所以makedepend脚本的输出因该生成一个内容像这&lt;br/&gt;样的&lt;code&gt;foo.d&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;foo.o: foo.c foo.h bar.h baz.h
foo.c foo.h bar.h baz.h:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此&lt;code&gt;.d&lt;/code&gt;文件包含最开始的先决条件定义, 然后添加每个源文件作为一个显式的target&lt;/p&gt;
&lt;h2 id=&quot;处理删除的依赖文件&quot;&gt;处理删除的依赖文件&lt;/h2&gt;
&lt;p&gt;这个配置还有一个问题: 如果使用者删除了一个依赖文件, 而没有更新任何源文件, make&lt;br/&gt;不会发现任何问题, 并且不会重新创建依赖文件, 直到由于其他的原因决定重新构建对应&lt;br/&gt;的对象文件. 同时, make会缺失这些target的依赖信息(比如, 修改头文件而不改动源文件&lt;br/&gt;不会导致对象文件重建)&lt;/p&gt;
&lt;p&gt;这个问题稍微有点复杂, 因为我们不想要依赖文件被看作是&quot;真正的&quot;target: 如果它们是,&lt;br/&gt;则我们使用include来引入它们, make会重建它们, 然后重新执行它自己. 这并不致命, 但&lt;br/&gt;是是多余的, 我们选择拒绝.&lt;/p&gt;
&lt;p&gt;automake的方式并没有解决则和个问题, 以前我提供了一个&quot;just don't do that&quot;的方案,&lt;br/&gt;加上将依赖文件放到一个单独的目录来使得不那么容易碰巧删除了它们.&lt;/p&gt;
&lt;p&gt;但是lukas waymann提供了一个简洁的解决方案: 将依赖文件作为target的依赖, 然后给它&lt;br/&gt;创建一个空的recipe:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;srcs = foo.c bar.c ...

%.o : %.c %.d
        @$(makedepend)
        $(compile.c) -o $@ $&amp;lt;

%.d: ;
include $(wildcard $(srcs:.c=.d))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这非常好地解决了问题: 当make检查target的时候, 他会将依赖文件爱呢看作是一个先决&lt;br/&gt;条件, 然后尝试rebuild它. 如果它存在, 什么都不会做, 因为依赖文件没有先决条件. 如&lt;br/&gt;果它不存在, 则会被标记为过时, 因为它的recipe是空的, 这会导致object target被重建&lt;br/&gt;(其重建过程中会创建一个新的依赖文件)&lt;/p&gt;
&lt;p&gt;当make试图重建引入的文件的时候, 他会找到依赖的隐式规则然后使用它. 但是, 由于规&lt;br/&gt;则并没有更新target文件, 没有引入的文件会被更新, make不会重新执行自身.&lt;/p&gt;
&lt;p&gt;上面的一个问题是, make会认为&lt;code&gt;.d&lt;/code&gt;文件是中间文件, 会删除它们. 我通过将它们定义为&lt;br/&gt;显式的target而非使用模式规则来解决:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;depfiles := $(srcs:.c=.d)
$(depfiles):
include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;输出文件置于何处&quot;&gt;输出文件置于何处&lt;/h2&gt;
&lt;p&gt;你可能不想将所有的&lt;code&gt;.d&lt;/code&gt;文件放在源文件目录下. 你很容易就可以让makefile将它们放到&lt;br/&gt;别的地方. 这是一个例子. 当然, 这里认为你以及修改了你的makedepend只来生成输出到&lt;br/&gt;这个位置, 以及知道在写入这个目录之前可能会需要创建它....:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;srcs = foo.c bar.c ...

depdir = .deps

%.o : %.c $(depdir)/%.d
        @$(makedepend)
        $(compile.c) -o $@ $&amp;lt;

depfiles := $(srcs:%.c=$(depdir)/%.d)
$(depfiles):
include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义makedepend&quot;&gt;定义makedepend&lt;/h2&gt;
&lt;p&gt;这里我会讨论一些可能的定义上面使用的makedepend变量的方式.&lt;/p&gt;
&lt;h2 id=&quot;makedepend-usrlibcpp-or-cc--e&quot;&gt;&lt;code&gt;makedepend = /usr/lib/cpp&lt;/code&gt; or &lt;code&gt;cc -e&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;最简单的生成依赖的方式是使用c预处理其. 这需要一点对预处理其输出格式的了解, 幸运&lt;br/&gt;的是多数unix预处理器都有类似我们意图需要的输出. 为了编译器错误消息和调试信息的&lt;br/&gt;编号信息, 预处理其在每次jump到一个&lt;code&gt;#include&lt;/code&gt;文件以及从中返回的时候都必须提供行&lt;br/&gt;号和文件名的信息(&lt;code&gt;__line__&lt;/code&gt;,&lt;code&gt;__file__&lt;/code&gt;). 这些输出行可以用于搞清楚引入了哪些文件.&lt;/p&gt;
&lt;p&gt;多数unix预处理其会在输出中插入这个格式的特殊行:&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;# lineno &quot;filename&quot; extra&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们关心的是&lt;code&gt;filename&lt;/code&gt;处的值. 有了这个, 我们就可以使用这个命令以我们想要的格式生成&lt;code&gt;.d&lt;/code&gt;文件..:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;makedepend = $(cpp) $(cppflags) $&amp;lt; \
         | sed -n 's,^\# *[0-9][0-9]* *&quot;\([^&quot;&amp;lt;]*\)&quot;.*,$@: \1\n\1:,p' \
         | sort -u &amp;gt; $*.d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;h2 id=&quot;编译和依赖生成一起&quot;&gt;编译和依赖生成一起&lt;/h2&gt;
&lt;p&gt;上面的一个问题是我们需要对源文件进行两次预处理: 一次是&lt;code&gt;makedepend&lt;/code&gt;命令, 一次是在编译过程中.&lt;/p&gt;
&lt;p&gt;如果你在使用gcc(或者提供了等价选项的编译器(clang)),你可以同时生成对象文件和依赖&lt;br/&gt;文件, 节省不少实践, 因为这些编译器可以以编译副作用的形式生成依赖文件. 这是一个实现示例, 从tl;dr一节中复制的:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;depdir := .deps
depflags = -mt $@ -mmd -mp -mf $(depdir)/$*.d

compile.c = $(cc) $(depflags) $(cflags) $(cppflags) $(target_arch) -c

%.o : %.c
%.o : %.c $(depdir)/%.d | $(depdir)
        $(compile.c) $(output_option) $&amp;lt;

$(depdir): ; @mkdir -p $@

depfiles := $(srcs:%.c=$(depdir)/%.d)
$(depfiles):
include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过一遍吧:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;depdir = ...&lt;/code&gt;: 将依赖文件放到一个叫做&lt;code&gt;.deps&lt;/code&gt;的子目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depflags = ...&lt;/code&gt;: gcc特定的flags, 告诉编译器生成依赖文件
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-mt $@&lt;/code&gt;: 设置在生成的依赖文件中target的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mmd&lt;/code&gt;: 编译之余, 生成依赖信息. 这个版本省去系统头文件, 如果想要系统&lt;br/&gt;头文件, 使用&lt;code&gt;-md&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mp&lt;/code&gt;: 给每个先决条件添加一个target, 比买在删除文件的时候的错误.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mf $(depdir)/$*.d&lt;/code&gt;: 将生成依赖文件&lt;code&gt;$(depdir)/$*.d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%o : %.c&lt;/code&gt;: 删除内建的从&lt;code&gt;.c&lt;/code&gt;文件构建&lt;code&gt;.o&lt;/code&gt;文件的规则, 以使用我们提供的规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;... $(depdir/%.d&lt;/code&gt;: 将生成的依赖文件声明为target的一个先决条件, 以便在它缺失的时候, rebuilt target&lt;/li&gt;
&lt;li&gt;&lt;code&gt;... | $(depdir)&lt;/code&gt;: 将依赖目录声明为. target的一个order only的先决条件,以便在需要的时候创建它.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(depdir): ; @mkdir -p $@&lt;/code&gt;: 声明一个在依赖目录不存在的时候创建它的规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depfiles := ...&lt;/code&gt;: 生成一个可能存在的所有依赖文件的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(depfiles):&lt;/code&gt;: 将所有依赖文件作为target提及, 以使得make不会在文件不存在的时候fail&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include ...&lt;/code&gt;: 引入存在的依赖文件. 使用&lt;code&gt;wildcard&lt;/code&gt;来避免因为不存在的文件而失败.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;处理特殊情况&quot;&gt;处理特殊情况&lt;/h2&gt;
&lt;p&gt;..:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果构建在某个不恰当的时间被kill了, 某个依赖文件可能会损坏. 可能会导致之后的&lt;br/&gt;调用由于语法错误而失败. 要解决这个问题必须手动删除文件&lt;/li&gt;
&lt;li&gt;眸子额情况, gcc会不恰当地设置生成的依赖文件时间戳. 使得依赖文件比对象文件更新&lt;br/&gt;. 这种情况会无限rebuild对象文件.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;depdir := .deps
depflags = -mt $@ -mmd -mp -mf $(depdir)/$*.td
postcompile = mv -f $(depdir)/$.td $(depdir)/$.d &amp;amp;&amp;amp; touch $@

compile.c = $(cc) $(depflags) $(cflags) $(cppflags) $(target_arch) -c

%.o : %.c
%.o : %.c $(depdir)/%.d | $(depdir)
        $(compile.c) $(output_option) $&amp;lt;
        $(postcompile)

$(depdir): ; @mkdir -p $@

depfiles := $(srcs:%.c=$(depdir)/%.d)
$(depfiles):
include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;object文件的放置&quot;&gt;object文件的放置&lt;/h2&gt;
&lt;p&gt;通常你也会想要将object文件放到一个单独的位置, 而不仅仅是依赖文件. 这里是一个例子:&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;objdir := obj

depdir := $(objdir)/.deps
depflags = -mt $@ -mmd -mp -mf $(depdir)/$*.d

compile.c = $(cc) $(depflags) $(cflags) $(cppflags) $(target_arch) -c

$(objdir)/%.o : %.c $(depdir)/%.d | $(depdir)
        $(compile.c) $(output_option) $&amp;lt;

$(depdir): ; @mkdir -p $@

depfiles := $(srcs:%.c=$(depdir)/%.d)
$(depfiles):
include $(wildcard $(depfiles))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.....&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jan 2020 14:31:00 +0000</pubDate>
<dc:creator>jakio6</dc:creator>
<og:description>自动依赖生成 === 基于make的构建环境要正确工作, 一个很重要(也很烦人)的任务是, 在makefile中正确列 举依赖. 这个文档将介绍了一个非常有用的让make自身来创建和维护这些依赖的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jakio6/p/12247034.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第二十章 内容控件 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12247035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12247035.html</guid>
<description>&lt;p&gt;　　内容控件(content control)是更特殊的控件类型，它们可包含并显示一块内容。从技术角度看，内容控件时可以包含单个嵌套元素的控件。与布局容器不同的是，内容控件只能包含一个子元素，而布局容器主要愿意可以包含任意多个牵头元素。&lt;/p&gt;
&lt;p&gt;　　正如前面所介绍，所有WPF布局容器都继承自抽象类Panel，该类提供了对包含多个元素的支持。类似地，所有内容控件都继承自抽象类ContentControl。下图显示了ContentControl类的层次结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131154933372-2115470971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;  图 ContentControl类的层次结构&lt;/p&gt;
&lt;p&gt;　　如上图所示，几个常见的控件实际上都是内容控件，包括Label控件以及ToolTip控件。此外，所有类型的按钮都是内容控件，包括众所周知的Button控件、RadioButton控件以及CheckBox控件。还有几个更特殊的内容控件，如ScrollViewer控件（可使用该控件创建能够滚动的面板）和UserControl类（该类允许重用一组自定义控件）。用于在应用程序中表示每个窗口的Window类本身也是内容控件。&lt;/p&gt;
&lt;p&gt;　　最后，还有继承自HeaderedContentControl类的内容控件子集。这些控件同时具有内容区域和标题区域两部分，标题区域用于显示一些标题。这些控件包括GroupBox控件、TabItem控件(位于TabControl控件中的一页)以及Expander控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Content属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　与Panel类提供Children集合来保存嵌套的元素不同，Control类添加了Content属性，该属性只接受单一对象。Content属性支持任何类型的对象，但可将该属性支持的对象分为两大类，针对每一类进行不同的处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;strong&gt;未继承自UIElement类的对象&lt;/strong&gt;：内容控件调用这些控件的ToString()方法获取文本，然后显示该文本&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;继承自UIElement类的对象&lt;/strong&gt;：这些对象（包括所有可视化元素，它们是WPF的组成部分）使用UIElement.OnRender()方法在内容控件的内部进行显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　为理解Content属性的工作原理，考虑简单的按钮。到目前位置，所看到的所有包含按钮的示例都简单地提供了一个字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Text Button&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该字符串被设置为按钮的内容，并在按钮上显示该内容。然而，可通过在按钮上放置任何其他元素来获取更有趣的内容。例如，可使用Image类在按钮上放置一幅图像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;=&quot;happyface.jpg&quot;&lt;/span&gt;&lt;span&gt; Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　还可在布局容器（如StackPanel面板）中组合文本和图像：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Image and Text Button&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;=&quot;happyface.jpg&quot;&lt;/span&gt;&lt;span&gt; Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Courtesy of the StackPanel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果希望创建一个真正意义上的极具特色的按钮，甚至可在该按钮中放置其他内容控件，如文本框和按钮（还可以在这些元素内部继续嵌套元素）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; HorizontalContentAlignment&lt;/span&gt;&lt;span&gt;=&quot;Stretch&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Type something here:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Stretch&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Text box in a button&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的XAML显示如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131161726792-729589153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　这与窗口使用的内容模型相同。与Button类相似，Window类也只能包含单一嵌套元素，可以是一块文本、一个任意对象或一个元素。&lt;/p&gt;
&lt;p&gt;　　除Content属性外，ContentControl类没有添加多少其他属性。它包含HasContent属性，如果在控件中有内容，该属性返回true。还有ContentTemplate属性，通过该属性可以创建一个模板，用于高速控件如何显示他无法识别的对象。使用ContentTemplate模板，可更加只能地显示非继承自UIElement的对象。不是仅调用ToString()方法获取字符串，而是可以使用各种属性值，将它们布置到更复杂的标记中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、对齐方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在前面介绍布局中，在FrameworkElement基类中定义的HorizontalAlignment和VerticalAlignment属性，在容器中对齐不同的控件。然而，一旦控件包含了内容，就需要考虑另一个组织级别。需要决定内容控件中额内容如何和边框对齐，这是通过使用HorizontalContentAlignment和VerticalContentAlignment属性实现的。&lt;/p&gt;
&lt;p&gt;　　HorizontalContentAlignment和VerticalContentAlignment属性与HorizontalAlignment和VerticalAlignment属性支持相同的值。这意味着可将内容对象到控件的任意边缘(使用Top、Bottom、Left或Right值)，可以居中(使用Center值)，也可以拉伸内容使其充满可用空间（使用Stretch值）。这些设置直接应用于嵌套的内容元素，但你可以使用多层嵌套创建复杂布局。例如，如果在Label元素中嵌套StackPanel面板，Label.HorizontalContentAlignment属性决定了StackPanel面板被放置在Label控件中的何处，但StackPanel面板及其子艺元素的对齐方式和尺寸选项则会决定其余的布局。&lt;/p&gt;
&lt;p&gt;　　在布局章节中，学习了Margin属性，通过该属性可在相邻元素之间添加空间。内容控件使用和Margin属性互补的Padding属性，该属性在控件边缘和内容边缘之间插入空间。比较下面两个按钮，观察他们之间的区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Absolutely No Padding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Padding&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Well Padded&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于没有内边距(padding)的按钮（默认），其文本和按钮边缘拥挤到一起。每条边都具有3个单位内边距的按钮则具有更合理的空白空间。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131163245599-1778635867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;三、WPF内容原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　现在，可能会怀疑WPF内容模型设计得这么复杂是否值得。毕竟，可选择在按钮上放置一幅图像，但是未必需要将图像嵌入到其他控件或整个布局面板中。然而，有几个非常重要的原因促进了观念转变。&lt;/p&gt;
&lt;p&gt;　　在前面示例中，包含一个简单的图像按钮，在Button控件中放置了一个Image元素。这种方法不是非常理想，因为位图不是分辨率无关的。在高DPI显示器上，位图显示可能会变模糊，因为WPF必须通过插值添加更多的像素，以确保图像保持正确的大小。更完善的WPF节目应避免使用位图，而应当使用矢量图像的组合来创建自定义绘图按钮以及其他图像修饰。&lt;/p&gt;
&lt;p&gt;　　这种方式可与内容控件模型很好地集成在一起。因为Button类是内容控件，所以可以自由地使用一幅固定的位图对其进行填充——相反，可以包含其他内容。例如，可使用System.Windows.Shapes名称空间中的类，在按钮中绘制一幅矢量图像。下面的示例创建了一个具有两个菱形的按钮。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Polygon &lt;/span&gt;&lt;span&gt;Points&lt;/span&gt;&lt;span&gt;=&quot;100,25 125,0 200,25 125,50&quot;&lt;/span&gt;&lt;span&gt; Fill&lt;/span&gt;&lt;span&gt;=&quot;LightSteelBlue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Polygon&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Polygon &lt;/span&gt;&lt;span&gt;Points&lt;/span&gt;&lt;span&gt;=&quot;100,25 75,0 0,25 75,50&quot;&lt;/span&gt;&lt;span&gt; Fill&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Polygon&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131165158220-1428147559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　显然，在这个示例中使用嵌套的内容模型比为Button类添加额外的属性以支持不同类型的内容更简单。嵌套内容典型不仅更灵活，还允许Button类提供更简单的接口。因为所有内容控件都支持以相同的方式嵌套内容，所以不必为多个类添加不同的内容属性。&lt;/p&gt;
&lt;p&gt;　　实际上，使用嵌套内容模型需要进行折中。它简化了元素的类模型，因为不需要使用额外的继承层次，以便为支持不同类型的内容添加属性。然而，需要使用稍复杂的对象模型——元素可以由其他嵌套的元素构成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在所有内容控件中，最简单的是Label控件。与其他任意内容控件类似，Label控件接受希望放入其中的单一内容。但不同的是Label控件支持记忆符(mnemonics)——本质上，记忆符是能够为链接的控件设置焦点的快捷键。&lt;/p&gt;
&lt;p&gt;　　为支持此功能，Label控件添加了Target属性。为了设置Target属性，需要使用指向另一个控件的绑定表达式。下面是必须遵循的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=txtA}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Choose _A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;txtA&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=txtB}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Choose _B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;txtB&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　标签文本中的下划线指示快捷键（如果确实需要在标签中显示下划线，必须添加两个下划线）。所有记忆符都使用Alt键和已经确定的快捷键工作。例如在该例中，如果用户按下了Alt+A组合键，第一个标签会将焦点传递给链接的控件，即txtA。同样，如果按下了Alt+B组合键，会将焦点传递给txtB文本框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131190507694-186935717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　快捷键字符通常是隐藏的，直到用户按下了Alt键，这时它们才显示为具有下划线的字母。但是这一行为取决于系统设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、按钮&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WPF提供了三种类型的按钮控件：熟悉的Button控件、CheckBox控件和RadioButton控件。所有这些控件都是继承自ButtonBase类的内容控件。&lt;/p&gt;
&lt;p&gt;　　ButtonBase类增加了几个成员。定义了Click事件并添加了对命令的支持，从而允许为更高层的应用程序任务触发按钮。最后，ButtonBase类添加了ClickMode属性，该属性决定何时引发Click事件以响应鼠标动作。默认值时ClickMode.Release,这意味着当单击和释放鼠标键时引发Click事件。然而，也可选择当鼠标第一次按下时引发Click事件(ClickMode.Press)。更奇特的是，只要将鼠标移动到按钮上并在按钮上悬停一会儿旧会引发Click事件(ClickMode.Hover)。&lt;/p&gt;



&lt;p&gt; 　　1、Button控件&lt;/p&gt;
&lt;p&gt;　　Button类表示一直使用的Windows下压按钮。它添加了两个可些属性：IsCancel和IsDefault。&lt;/p&gt;
&lt;p&gt;　　如果将IsCancel属性设置为true，按钮就成为窗口的取消按钮。在当前窗口的任何位置如果按下Esc键，就会触发该按钮。&lt;/p&gt;
&lt;p&gt;　　如果将IsDefault属性设置为true，按钮就成为默认按钮（也就是接受按钮）。其行为取决于焦点在窗口中的当前位置。如果焦点位于某个非按钮控件上(如TextBox控件、RadioButton控件和CheckBox控件等），默认按钮具有蓝色阴影，几乎像是具有焦点。如果按下Enter键，就会触发默认按钮。但如果焦点位于另一个按钮控件上，当前有焦点的按钮即具有蓝色阴影，而且按下Enter键会触发当前按钮而不是默认按钮。&lt;/p&gt;
&lt;p&gt;　　许多用户依赖与这些快捷方式(特别是使用Esc键关闭不需要的对话框)，所以花一些时间在创建的每个窗口中定义这些细节是有意义的。仍需为取消按钮和默认按钮编写事件处理代码，因为WPF没有提供这一行为。&lt;/p&gt;
&lt;p&gt;　　某些情况下，将窗口中的同一个按钮既设置为取消按钮，又设置为默认按钮也是有意义的。一个例子是About对话框中的OK按钮。不过，窗口中只能有一个取消按钮和一个默认按钮。如果指定多个取消按钮，按下Esc键将把焦点移到下一个默认按钮，而不是触发它。如果设置多个默认按钮，按下Enter键后的行为更混乱。如果焦点在某个非按钮控件上，按下Enter键会把焦点移到下一个默认按钮。如果焦点位于一个Button控件上，按下Enter键就会触发该Button控件。&lt;/p&gt;
&lt;p&gt;　　2、ToggleButton控件和RepeatButton控件&lt;/p&gt;
&lt;p&gt;　　除Button类之外，还有三个类继承自ButtonBase类。这些类包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　GridViewColumnHeader类，当使用基于网络的ListView控件是，该类表示一例可以单击的标题。&lt;/li&gt;
&lt;li&gt;　　RepeatButton类，只要按钮保持按下状态，该类就不断地触发Click事件。对于普通按钮，用户每次单击只触发一个Click事件。&lt;/li&gt;
&lt;li&gt;　　ToggleButton类，该类表示具有两个状态(按下状态和未按下状态）的按钮。当单击ToggleButton按钮时，它会保持按下状态，直到再次单击该按钮以释放它为止。这有时称为“粘贴单击”(sticky click)行为。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　RepeatButton和ToggleButton类都是在System.Windows.Controls.Primitives名称空间中定义的，这表明他们通常不单独使用。相反，它们通常通过组合来构建更复杂的控件，或通过继承扩展其功能。例如，RepeatButton类常用语构建高级的ScrollBar控件(最终，甚至ScrollBar控件都是高级的ScrollViewer控件的一部分）。RepeatButton类使滚动条两端的箭头按钮具有它们所特有的行为——只要按住箭头按钮不释放就会一直滚动。类似地，ToggleButton控件通常用于派生出更有用的CheckBox类和RadioButton类，后面将介绍这两个类。&lt;/p&gt;
&lt;p&gt;　　然而，RepeatButton类和ToggleButton类都不是抽象类，所以可在用户界面中直接使用他们。ToggleButton控件在工具栏中非常有用，后面介绍工具栏的时候进行详细介绍。&lt;/p&gt;
&lt;p&gt;　　3、CheckBox控件&lt;/p&gt;
&lt;p&gt;　　CheckBox控件和RadioButton控件是不同类型的按钮。它们继承自ToggleButton类，这意味着用户可切换它们的开关状态，即他们的“开关”行为。对于CheckBox控件，切换到控件的“开”状态，意味着在其中放置复选标记。&lt;/p&gt;
&lt;p&gt;　　CheckBox类没有添加任何成员，所以CheckBox类的基本接口是在ToggleButton类中定义的。最重要的是，ToggleButton类添加了IsChecked属性。IsChecked属性是可空的Boolean类型，这意味着该属性可以设置为true、false或null。显然，true表示选中的复选框，而false表示空的复选框。null值使用起来较为棘手——表示不确定状态，显示为具有阴影的复选框。不确定状态通常用于表示尚未设置的值。或存在一些差异的区域。例如，在文本应用程序中通常有用于加粗文本字体的复选框，并且如果当前选择的文本既包含粗体文本又包含正常文本，这时可将复选框设置为null，表示一种不确定状态。&lt;/p&gt;
&lt;p&gt;　　为在WPF标记中指定null值，需要使用null标记扩展，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CheckBox &lt;/span&gt;&lt;span&gt;IsChecked&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:null}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A check box in indeterminate state&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CheckBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了IsChecked属性外，ToggleButton类还添加了IsThreeState属性，该属性决定了用户是否能将复选框设置为不确定状态。如果IsThreeState属性被设置为false（默认值），单击复选框时，其状态会在选中和未选中两种状态之间切换,并且这时只能通过代码将复选框设置为不确定状态。如果IsThreeState属性被设置为true，单击复选框时，就会在所有可能的三种状态之间循环切换。&lt;/p&gt;
&lt;p&gt;　　ToggleButton类还定义了当复选框进入特定状态时会触发的三个事件：Checked、UnChecked和Indeterminate。大多数情况下，可以很容易地通过处理继承自ButtonBase类的Click事件，将这一逻辑合并为单个事件处理程序。无论何时改变按钮的状态都会触发Click事件。&lt;/p&gt;
&lt;p&gt;　　4、RadioButton控件&lt;/p&gt;
&lt;p&gt;　　RadioButton类也继承自ToggleButton类，并使用相同的IsChecked属性和相同的Checked、Unchecked以及Indeterminate事件。此外，RadioButton类还增加了GroupName属性，该属性用于控制如何对单选按钮进行分组。&lt;/p&gt;
&lt;p&gt;　　单选按钮通常由他们的容器进行分组。这意味着，如果在StackPanel面板中放置三个单选按钮，那么这三个单选按钮就形成了一个组，而且只要选择这三个单选按钮中的一个。另一方面，如果在两个独立的StackPanel控件中放置一组单选按钮，就有了两组相互独立的单选按钮。&lt;/p&gt;
&lt;p&gt;　　可以使用GroupName属性覆盖这一默认行为。可使用该属性在同一个容器中创建多个组，或将包含在多个容器中的单选按钮创建为一组。对于这两种情况，技巧很简单——只需为所有属于同一组的单选按钮提供相同的组名即可。&lt;/p&gt;
&lt;p&gt;　　分析下面的这个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GroupBox &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;0,10,0,0&quot;&lt;/span&gt;&lt;span&gt; GroupName&lt;/span&gt;&lt;span&gt;=&quot;Group2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GroupBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GroupBox &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RadioButton &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;0,10,0,0&quot;&lt;/span&gt;&lt;span&gt; GroupName&lt;/span&gt;&lt;span&gt;=&quot;Group2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Group 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RadioButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GroupBox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个示例中有两个包含单选按钮的容器，但有三组单选按钮。每个分组框底部的最后一个单选按钮属于第三组。这个示例中的设计有些令人困惑，但有些情况下，可能希望以微妙的方式从包中分离出一个特定的单选按钮，而又不会导致该按钮离开原来的分组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、工具提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WPF为工具提示（当在一些感兴趣的内容上悬停鼠标时，就会弹出的那些臭名昭著的黄色方框）提供了一个灵活模型。因为在WPF中工具栏提示的是内容控件，所以可在工具提示中放置任何可视化元素。还可改变各种时间设置来控制工具提示的显示和隐藏速度。&lt;/p&gt;
&lt;p&gt;　　直接使用ToolTip类不是显示工具提示的最简单方式。相反，可为元素简单地设置ToolTip属性。ToolTip属性是在FrameworkElement类中定义的，所以所有能放到WPF窗口上的元素都可以使用该元素。&lt;/p&gt;
&lt;p&gt;　　例如，下面的按钮具有基本的工具提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;ToolTip&lt;/span&gt;&lt;span&gt;=&quot;This is my tooltip&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;I have a tooltip&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当在该按钮上悬停鼠标时，就会在熟悉的黄色方框中显示“This is my tooltip &quot;文本。&lt;/p&gt;
&lt;p&gt;　　如果希望提供更复杂的工具提示内容，如组合的嵌套元素，就需要将ToolTip属性分为单独的元素。下面的示例使用更复杂的嵌套内容设置按钮的ToolTip属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToolTip  &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;Image and text&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;=&quot;happyface.jpg&quot;&lt;/span&gt;&lt;span&gt; Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;Image and text&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;I have a fancy tooltip&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、设置ToolTip对象的属性&lt;/p&gt;
&lt;p&gt;　　ToolTip是内容控件，因此可调整它的标准属性，如Background属性(从而不再是黄色的方框)、Padding属性以及Font属性。还可以修改在ToolTip类中蒂尼工艺的成员（如下表所示）。这些属性中的大部分都用于帮助将工具提示放到所期望的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131213537426-515515484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　下面的标记使用ToolTip属性创建了一个工具提示，该工具提示窗口没有阴影效果，但使用了透明的红色背景，从而可透过该工具提示看到底层的窗口和控件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToolTip &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;#60AA4030&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;
                 HasDropShadow&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;Image and text&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;=&quot;happyface.jpg&quot;&lt;/span&gt;&lt;span&gt; Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;Image and text&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.ToolTip&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;I have a fancy tooltip&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大多数情况下，使用标准的工具提示位置便足以满足要求了，这是工具提示窗口位于当前鼠标位置。然而，ToolTip的各种属性提供了更多的选择。下面列出一些可用于放置工具提示的策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;strong&gt;根据鼠标的当前位置&lt;/strong&gt;。这是标准的行为，该行为依赖于将Placement属性设置为Mouse。工具提示框的左上角和包围鼠标指针的不可见”边界框“的左下角对齐。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;根据悬停鼠标的元素的位置&lt;/strong&gt;。根据希望使用的元素边缘，将Placement属性设置为Left、Right、Top、Bottom或Center。工具提示框的左上角与边缘对齐。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;根据另一个元素（或窗口）的位置&lt;/strong&gt;。使用将工具提示和当前元素对齐的相同方式设置Placement属性（使用Left、Right、Top、Bottom或Center值）。然后通过设置PlacementTarget属性选择元素。请记住，需要使用”{绑定元素名=名称}“语法来确定想要使用的元素。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;使用偏移&lt;/strong&gt;。使用上述任意一种策略，并何止HorizontalOffset和VerticalOffset属性来添加一定的额外空间。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;使用绝对坐标&lt;/strong&gt;。将Placement属性设置为Absolute，并使用HorizontalOffset和VerticalOffset属性（或使用PlacementRectangle属性）在工具提示和窗口左上角之间设置一些空间。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;使用运行时的计算结果&lt;/strong&gt;。将Placement属性设置为Custom。设置CustomPopupPlacementCallback属性指向一个已经创建的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　2、设置ToolTipService属性&lt;/p&gt;
&lt;p&gt;　　有有几个工具提示属性不能通过ToolTip类的属性进行配置。在这种情况下，需要使用另一个类，即ToolTipService类。使用ToolTipService类可以配置显示工具提示的相关延迟时间。ToolTipService类的所有属性都是附加属性，所以可在控件标签中直接设置它们。&lt;/p&gt;
&lt;p&gt;　　ToolTipService类定义了许多与ToolTip相同的属性，从而当处理只有文本的工具提示时可使用更简单的语法。不是天津嵌套的ToolTip元素，可使用特性设置所有内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;ToolTip&lt;/span&gt;&lt;span&gt;=&quot;This is my tooltip&quot;&lt;/span&gt;&lt;span&gt; ToolTipService.Placement&lt;/span&gt;&lt;span&gt;=&quot;Bottom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;I have a tooltip&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下表列出了ToolTipService类的属性。ToolTipService类还提供了两个路由事件：ToolTipOpening和ToolTipClosing。可响应这些事件，使用即时内容填充工具提示，或重写工具提示的工作方式。例如，如果在这个两个事件中设置已经处理过的标志，将不再自动显示或隐藏工具提示。反而，需要通过设置IsOpen属性来手动显示和隐藏工具提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202001/263728-20200131222755091-858048432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　3、Popup控件&lt;/p&gt;
&lt;p&gt;　　Popup控件在许多方面与ToolTip控件相同，尽管他们之间没有相互继承的关系。与ToolTip类似，Popup也只能包含单一内容，该单一内容包含任何WPF元素（该内容存储在Popup.Child属性中，而不想ToolTip内容那样存储在ToolTip.Content属性中）。另外，与ToolTip控件一样，Popup控件也延伸出窗口的边界。最后，可使用相同的布局属性放置Popup控件，并且可使用相同的IsOpen属性显示或隐藏Popup控件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Popup控件和ToolTip控件之间的区别更重要。这些区别包括：&lt;/li&gt;
&lt;li&gt;　　Popup控件永远不会自动显示。为显示Popup控件，必须设置IsO喷属性。&lt;/li&gt;
&lt;li&gt;　　默认情况下，Popup.StaysOpen属性被设置为true，并且Popup控件会一直显示，知道明确地将IsOpen属性设置为false为止。如果将Popup.StaysOpen属性设置为false，那么当用户在其他地方单击鼠标时，Popup控件将消失。&lt;/li&gt;
&lt;li&gt;　　Popup控件提供了PopupAnimation属性，当把IsOpen属性设置为true时，通过该属性可控制Popup控制进入视野的方式。可以选择None(默认值)、Fade（弹出窗口的透明度逐渐增加）、Scroll（如果空间允许，弹出窗口将从窗口的左上角滑入）以及Slide（如果空间允许，弹出窗口将从上向下滑进其位置）。为使用这些动画中的任意一个，还必须将AllowsTransparency属性设置为true。&lt;/li&gt;
&lt;li&gt;　　Popup控件可接受焦点。因此，可在其内部放置于用户交互的控件，如按钮，该功能是使用Popup控件的主要原因之一。&lt;/li&gt;
&lt;li&gt;　　Popup控件在System.Windows.Controls.Primitive名称空间中定义，因为它的最常见用法是用作更复杂控件的构件。在外观修饰方面可发现Popup控件和其他控件的区别很大。特别是，如果希望看到内容，就必须设置Background属性，因为Popup控件不会从包含它的窗口继承背景设置，而且你需要自行添加边框（对于这个目的，Border元素的效果堪称完美）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　因为必须手动显示Popup控件，所以可能完全通过代码创建。但也可以可以使用XAML标记定义Popup控件——但务必包含Name属性，从而可以使用代码操作该控件。&lt;/p&gt;
&lt;p&gt;　　简单示例如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d1ae82aa-7613-4de3-9c99-83b35586f514')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d1ae82aa-7613-4de3-9c99-83b35586f514&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d1ae82aa-7613-4de3-9c99-83b35586f514&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d1ae82aa-7613-4de3-9c99-83b35586f514',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d1ae82aa-7613-4de3-9c99-83b35586f514&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;Controls.PopupTest&quot;&lt;/span&gt;&lt;span&gt;
        xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
        xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
        Title&lt;/span&gt;&lt;span&gt;=&quot;PopupTest&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;TextWrapping&lt;/span&gt;&lt;span&gt;=&quot;Wrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;You can use a Popup to provide a link for
      a specific &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Run &lt;/span&gt;&lt;span&gt;TextDecorations&lt;/span&gt;&lt;span&gt;=&quot;Underline&quot;&lt;/span&gt;&lt;span&gt;  
        MouseEnter&lt;/span&gt;&lt;span&gt;=&quot;run_MouseEnter&quot;&lt;/span&gt; 
                      &lt;span&gt;&amp;gt;&lt;/span&gt;term&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; of interest.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Popup &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;popLink&quot;&lt;/span&gt;&lt;span&gt; StaysOpen&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; Placement&lt;/span&gt;&lt;span&gt;=&quot;Mouse&quot;&lt;/span&gt;&lt;span&gt; MaxWidth&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
             PopupAnimation&lt;/span&gt;&lt;span&gt;=&quot;Slide&quot;&lt;/span&gt;&lt;span&gt; AllowsTransparency &lt;/span&gt;&lt;span&gt;= &quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;Beige&quot;&lt;/span&gt;&lt;span&gt; BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;  TextWrapping&lt;/span&gt;&lt;span&gt;=&quot;Wrap&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            For more information, see
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Hyperlink &lt;/span&gt;&lt;span&gt;NavigateUri&lt;/span&gt;&lt;span&gt;=&quot;http://en.wikipedia.org/wiki/Term&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;lnk_Click&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Wikipedia&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Hyperlink&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Popup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;XAML&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5a74745c-d896-4eda-9ce8-a916ca955745')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5a74745c-d896-4eda-9ce8-a916ca955745&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5a74745c-d896-4eda-9ce8-a916ca955745&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5a74745c-d896-4eda-9ce8-a916ca955745',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5a74745c-d896-4eda-9ce8-a916ca955745&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Controls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media.Imaging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Shapes;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Controls
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; PopupTest.xaml 的交互逻辑
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PopupTest : Window
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PopupTest()
        {
            InitializeComponent();
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run_MouseEnter(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
        {
            popLink.IsOpen &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lnk_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            Process.Start(((Hyperlink)sender).NavigateUri.ToString());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CS&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 31 Jan 2020 14:30:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>内容控件(content control)是更特殊的控件类型，它们可包含并显示一块内容。从技术角度看，内容控件时可以包含单个嵌套元素的控件。与布局容器不同的是，内容控件只能包含一个子元素，而布局容器主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12247035.html</dc:identifier>
</item>
</channel>
</rss>