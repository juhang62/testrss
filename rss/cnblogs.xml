<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【NET CORE微服务一条龙应用】应用部署 - 天翔者</title>
<link>http://www.cnblogs.com/tianxiangzhe/p/10365178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianxiangzhe/p/10365178.html</guid>
<description>&lt;p&gt;系列目录：&lt;a href=&quot;https://www.cnblogs.com/tianxiangzhe/p/10212337.html&quot; target=&quot;_blank&quot;&gt;【NET CORE微服务一条龙应用】开始篇与目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本章主要介绍&lt;a href=&quot;https://github.com/q315523275/FamilyBucket&quot; target=&quot;_blank&quot;&gt;https://github.com/q315523275/FamilyBucket&lt;/a&gt;上微服务一条龙应用，在实际使用中的应用部署，以原始方式部署非docker&lt;/p&gt;
&lt;p&gt;部署应用主要包括：&lt;/p&gt;
&lt;p&gt;1、网关应用部署&lt;/p&gt;
&lt;p&gt;2、授权认证应用部署&lt;/p&gt;
&lt;p&gt;3、配置中心查询服务端应用部署&lt;/p&gt;
&lt;p&gt;4、综合管理应用部署&lt;/p&gt;
&lt;p&gt;5、后台运行应用部署&lt;/p&gt;
&lt;p&gt;6、数据初始化&lt;/p&gt;

&lt;p&gt;应用所需运行环境，相关技术点不做介绍&lt;/p&gt;
&lt;p&gt;1、net core 2.2/2.1&lt;/p&gt;
&lt;p&gt;2、mysql&lt;/p&gt;
&lt;p&gt;3、rabbitmq&lt;/p&gt;
&lt;p&gt;4、consul(非必须)&lt;/p&gt;
&lt;p&gt;5、redis&lt;/p&gt;
&lt;p&gt;6、zookeeper(非必须)&lt;/p&gt;
&lt;p&gt;7、pm2(非必需)&lt;/p&gt;

&lt;p&gt;数据库脚本地址（&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/blob/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/init_mysql.sql&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;），初始化数据其中包括：&lt;/p&gt;
&lt;p&gt;接口资源数据(综合管理应用)、网关默认配置与路由、配置中心默认开发配置、综合管理菜单数据、默认用户角色权限&lt;/p&gt;
&lt;p&gt;数据初始化后，部分需要更新数据如下：&lt;/p&gt;
&lt;p&gt;网关路由表tb_apigateway_reroute默认4条配置下游地址更新&lt;/p&gt;
&lt;p&gt;配置信息数据表tb_appconfig_dev，默认redis、网关地址、Consul、RabbitMq、权限数据库地址&lt;/p&gt;

&lt;p&gt;项目源码地址(&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/src/ApiGateway/Bucket.ApiGateway&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;1、由于未使用配置中心，所以appsettings.json需配置对应信息&lt;/p&gt;
&lt;p&gt;2、hosting.json为配置绑定Url&lt;/p&gt;
&lt;p&gt;3、pm2.json为pm2配置，start.sh为Linux命令&lt;/p&gt;
&lt;p&gt;4、发布应用程序然后上传至linux环境，如果安装有pm2可直接pm2 start pm2.json，如果未安装可直接nohup dotnet xxx.dll &amp;amp;进行项目启动&lt;/p&gt;

&lt;p&gt;项目源码地址(&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Authentication&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;1、使用配置中心，appsettings.json配置应用对应独有信息&lt;/p&gt;
&lt;p&gt;2、libSkiaSharp.so必须上传至应用根目录&lt;/p&gt;
&lt;p&gt;3、其他操作为网关部署4&lt;/p&gt;

&lt;p&gt;其他应用部署于登陆项目基本一致，整体发布顺序如下：&lt;/p&gt;
&lt;p&gt;1、部署配置中心配置查询客户端（&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.ConfigServer&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;），更新网关的配置应用路由数据库信息&lt;/p&gt;
&lt;p&gt;2、部署网关应用&lt;/p&gt;
&lt;p&gt;3、部署登陆授权应用，更新网关的登陆应用路由数据库信息&lt;/p&gt;
&lt;p&gt;4、部署综合管理应用（开启了角色接口权限验证）（&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.Platform&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;），更新网关的管理平台应用路由数据库信息&lt;/p&gt;
&lt;p&gt;5、部署默认后台应用（&lt;a href=&quot;https://github.com/q315523275/FamilyBucket/tree/master/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/Pinzhi.BackgroundTasks&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;至此一个基础的应用就已经搭建起来了，如果不需要使用服务发现可以在Startup中屏蔽app.UseConsulRegisterService(Configuration);&lt;/p&gt;

&lt;p&gt;综合管理使用的是vue进行的开发，可能需要一点基础，github &lt;a href=&quot;https://github.com/q315523275/FamilyBucket-UI&quot; target=&quot;_blank&quot;&gt;https://github.com/q315523275/FamilyBucket-UI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、config/index.js目录文件，更改baseApi为网关url&lt;/p&gt;
&lt;p&gt;2、可以本地npm run dev进行本地运行&lt;/p&gt;
&lt;p&gt;3、发布静态文件放到服务器上运行即可&lt;/p&gt;
&lt;p&gt;管理首页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/627749/201902/627749-20190212145548996-1990606251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 07:37:00 +0000</pubDate>
<dc:creator>天翔者</dc:creator>
<og:description>简介 系列目录：【NET CORE微服务一条龙应用】开始篇与目录 本章主要介绍https://github.com/q315523275/FamilyBucket上微服务一条龙应用，在实际使用中的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianxiangzhe/p/10365178.html</dc:identifier>
</item>
<item>
<title>读懂 Gradle 的 DSL - sw926</title>
<link>http://www.cnblogs.com/sw926/p/10365370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sw926/p/10365370.html</guid>
<description>&lt;p&gt;现在 Android 开发免不了要和 Gradle 打交道，所有的 Android 开发肯定都知道这么在 &lt;code&gt;build.gradle&lt;/code&gt; 中添加依赖，或者添加配置批量打包，但是真正理解这些脚本的人恐怕很少。其实 Gradle 的 &lt;code&gt;build.gradle&lt;/code&gt; 可以说是一个代码文件，熟悉 Java 的人理解起来很简单的，之所以不愿意去涉及，主要感觉没有必要去研究。要能看懂 &lt;code&gt;build.gradle&lt;/code&gt;，除了要了解 Groovy 的语法，还要了解 Gradle 的构建流程，要研究还是要花一些时间的，所以这篇文章可以让一个 Java 程序员在一个小时内看懂 Gradle 的脚本。&lt;/p&gt;
&lt;h2 id=&quot;gradle-简单介绍&quot;&gt;Gradle 简单介绍&lt;/h2&gt;
&lt;p&gt;Gradle 构建由 Project 和 Task 组成，Project 保存项目的属性，例如 name，版本号，代码文件位置。Task 也是 Project 的一部分，但是它是可执行的任务，我们最常使用的 &lt;code&gt;build&lt;/code&gt; 就是一个 Task，Task 可以依赖于另外一个 Task，一个 Task 在执行的时候，它依赖的 Task 会先执行。这样，当我们 build 的时候，这个 Task 可能依赖很多的 Task，比如代码检查、注解处理，这样一层层的依赖，最终通过 build Task 全部执行。&lt;/p&gt;
&lt;h2 id=&quot;gradle-和-groovy&quot;&gt;Gradle 和 Groovy&lt;/h2&gt;
&lt;p&gt;Gradle 和 Groovy 这两个名字很容易让人产生混淆，这里先解释一下，Groovy 是一门编程语言，和 Java 一样。Gradle 和一个自动化构建工具，其他知名的构建工具还有 Maven 和 Ant。什么自动化构建工具？用 Android 来举例，打包一个 Apk 文件要做很多工作，代码预处理，lint代码检查、处理资源、编译 Java 文件等等，使用自动化构建工具，一个命令就可以生成 Apk 了。&lt;/p&gt;
&lt;p&gt;Gradle 的 DSL 目前支持两种语言的格式，Groovy 和 Kotlin，Kotlin 格式的 DSL 是在 5.0 引入的，相比 Groovy，Kotlin 使用的人数更多，也更好理解，在这儿主要介绍 Groovy 格式的 DSL。&lt;/p&gt;
&lt;p&gt;介绍一下什么是 DSL，DSL 是 &lt;code&gt;Domain Specific Language&lt;/code&gt; 的缩写，既领域专用语言。Gradle 的 DSL 专门用于配置项目的构建，不能做其他工作，而像 Java 、C/C++ 这些就属于通用语言，可以做任何工作。&lt;/p&gt;
&lt;p&gt;我们还要理解什么是脚本文件。在写代码 Java 代码时，程序是从 &lt;code&gt;main()&lt;/code&gt; 函数开始执行的，只有在 &lt;code&gt;main()&lt;/code&gt; 中调用的代码才会执行。但是脚本文件不一样，只要在文件内写的代码都会执行，&lt;code&gt;Groovy&lt;/code&gt; 是支持脚本文件的，我们配置好 Groovy 的开发环境，新建一个文件 &lt;code&gt;test.groovy&lt;/code&gt;，输入以下内容：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;String hello = &quot;Hello World!&quot;
println(hello)

println(&quot;The End&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;groovy test.groovy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;Hello World!
The End&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然没有 &lt;code&gt;main&lt;/code&gt; 函数，但是里面的代码都执行了。很明显，&lt;code&gt;build.gradle&lt;/code&gt; 就是一个 Groovy 的脚本文件，里面就是 Groovy 代码，里面添加的所有代码都会运行，我们可以试验以下，随便打开一个 Gradle 格式的项目，在 &lt;code&gt;build.gradle&lt;/code&gt; 最下面添加一些 Java 代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String hello = &quot;Hello World!&quot;
System.out.println(hello)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;./gradlew -q # -q 是不输出额外的信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会看到输出了 &lt;code&gt;Hellow World&lt;/code&gt;，说明我们添加的代码被执行了，那么为什么可以在 &lt;code&gt;build.gradle&lt;/code&gt; 里面写 Java 代码呢？这是因为 Groovy 是支持 Java 的语法的，在 Groovy 文件写 Java 代码是完全没有问题的。&lt;/p&gt;
&lt;h2 id=&quot;build.gradle-的执行方式&quot;&gt;&lt;code&gt;build.gradle&lt;/code&gt; 的执行方式&lt;/h2&gt;
&lt;p&gt;现在总结一下，&lt;code&gt;build.gradle&lt;/code&gt; 就是一个 Groovy 格式脚本文件，里面是 Groovy 或者 Java 代码，构建的时候会顺序执行，但是打开 &lt;code&gt;build.gradle&lt;/code&gt;，可能还是一头雾水，一个个字符和大括号组成的东西到底是什么鬼？我们来看一下最长使用的 &lt;code&gt;dependencies&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    implementation 'com.google.guava:guava:26.0-jre'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;implementation&lt;/code&gt; 也可以这样写：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;implementation('com.google.guava:guava:26.0-jre')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;implementation&lt;/code&gt; 其实就是一个函数，在 Groovy 中，函数调用可以使用空格加参数的形式调用，例如&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;void foo(String params1, int param2) {
    println(&quot;param1 = $params1, param2 = $param2&quot;)
}

foo &quot;aaa&quot;, 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;implementation 'com.google.guava:guava:26.0-jre'&lt;/code&gt; 就是调用了 &lt;code&gt;implementation&lt;/code&gt; 函数添加了一个依赖。以此类推，&lt;code&gt;dependencies&lt;/code&gt; 也是一个函数，在 &lt;code&gt;IDEA&lt;/code&gt; 中，我们可以直接 &lt;code&gt;Ctrl&lt;/code&gt; 加鼠标左键点击进去看它的声明：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Project extends Comparable&amp;lt;Project&amp;gt;, ExtensionAware, PluginAware {
    // ...
    void dependencies(Closure configureClosure);
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到 &lt;code&gt;dependencies&lt;/code&gt; 是 &lt;code&gt;Project&lt;/code&gt; 一个方法，为什么可以在 &lt;code&gt;build.gradle&lt;/code&gt; 调用 &lt;code&gt;Project&lt;/code&gt; 的方法呢，官方文档里面有相关的介绍。一个 Gradle 项目一般有一个 &lt;code&gt;settings.gradle&lt;/code&gt; 文件和一个 &lt;code&gt;build.gradle&lt;/code&gt; 文件，&lt;code&gt;settings.gradle&lt;/code&gt; 用来配置目录结构，子工程就是在 &lt;code&gt;settings.gradle&lt;/code&gt; 里面配置，&lt;code&gt;Project&lt;/code&gt; 和 &lt;code&gt;build.gradle&lt;/code&gt; 是一一对应的关系，Gradle 的构建流程如下：&lt;/p&gt;
&lt;p&gt;1、生成一个 &lt;code&gt;Settings&lt;/code&gt; 对象，执行 &lt;code&gt;settings.gradle&lt;/code&gt; 对这个对象进行配置&lt;br/&gt;2、使用 &lt;code&gt;Settings&lt;/code&gt; 对象生成工程结构，创建 &lt;code&gt;Project&lt;/code&gt; 对象&lt;br/&gt;3、对所有 &lt;code&gt;Project&lt;/code&gt; 执行对应的 &lt;code&gt;build.gradle&lt;/code&gt; 进行配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build.gradle&lt;/code&gt; 就是对 &lt;code&gt;Project&lt;/code&gt; 的操作，例如，在 &lt;code&gt;build.gradle&lt;/code&gt; 中输入以下代码&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;println &quot;project name is ${this.name}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为： &lt;code&gt;project name is java_demo&lt;/code&gt;，&lt;code&gt;java_demo&lt;/code&gt; 就是我们的 project name，我们可以认为对 &lt;code&gt;this&lt;/code&gt; 的操作就是对 &lt;code&gt;project&lt;/code&gt; 的操作。&lt;/p&gt;
&lt;p&gt;Groovy 也是有语法糖的，类的属性可以直接使用名字，例如 &lt;code&gt;Project&lt;/code&gt; 的有两个函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Object getVersion();
void setVersion(Object version);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这就说明 &lt;code&gt;Project&lt;/code&gt; 有一个 &lt;code&gt;version&lt;/code&gt; 属性，在 &lt;code&gt;build.gradle&lt;/code&gt; 中我们可以这样来使用：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;version = &quot;1.0&quot; // 赋值，调用 setVersion()
println version // 读取，调用 getVersion()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Project&lt;/code&gt; 中没有 &lt;code&gt;getter&lt;/code&gt; 方法的属性是不能赋值的，例如 &lt;code&gt;name&lt;/code&gt;，我们可以输出 &lt;code&gt;name&lt;/code&gt; 的值，但是 &lt;code&gt;name = &quot;demo&quot;&lt;/code&gt; 是错误的。&lt;/p&gt;
&lt;p&gt;所以，在 &lt;code&gt;build.gradle&lt;/code&gt; 中的代码就是修改 &lt;code&gt;Project&lt;/code&gt;，方式就是修改属性或者调用相关的方法，&lt;code&gt;plugins&lt;/code&gt; 方法是添加插件，&lt;code&gt;repositories&lt;/code&gt; 方法是添加代码仓库，&lt;/p&gt;
&lt;h2 id=&quot;groovy-闭包&quot;&gt;Groovy 闭包&lt;/h2&gt;
&lt;p&gt;闭包可以认为是可以执行的代码块，Groovy 中闭包的声明和执行方式如下：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;Closure closure = { String item -&amp;gt;
    println(item)
}

closure(&quot;Hello&quot;) // 执行&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和 Lambda 表达式很像，但是 Groovy 的闭包可以先声明，然后设置代理来执行，例如我们声明一个闭包：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;Closure closure = {
    sayHello()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个闭包里面执行了 &lt;code&gt;sayHello()&lt;/code&gt; 函数，但是我们没有在任何地方声明这个函数，在 Java 中，这是个编译错误，但是 Groovy 是允许的，完整的执行的例子如下：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;Closure closure = {
    sayHello()
}
class Foo {
    void sayHello() {
        println(&quot;Hello!!!&quot;)
    }
}
def foo = new Foo()

closure.delegate = foo
closure()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello!!! &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们为闭包设置了一个代理 &lt;code&gt;delegate&lt;/code&gt;，只要这个代理有 &lt;code&gt;sayHello()&lt;/code&gt; 方法，代码就能执行，这就是为什么我们查看 &lt;code&gt;Project&lt;/code&gt; 的源码，里面很多函数参数类型都是 &lt;code&gt;Closure&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void repositories(Closure configureClosure);
void dependencies(Closure configureClosure);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;repositories&lt;/code&gt; 在 &lt;code&gt;build.gradle&lt;/code&gt; 中是这样调用的：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过 IDE 进入 &lt;code&gt;jcenter()&lt;/code&gt; 的声明，进入的是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RepositoryHandler extends ArtifactRepositoryContainer {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于没看过源码，我也只能猜，我猜 &lt;code&gt;repositories&lt;/code&gt; 这个闭包的 &lt;code&gt;delegate&lt;/code&gt; 是一个 &lt;code&gt;RepositoryHandler&lt;/code&gt;，通过执行 &lt;code&gt;RepositoryHandler&lt;/code&gt; 的方法，为工程添加 &lt;code&gt;Repository&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;plugin&quot;&gt;Plugin&lt;/h2&gt;
&lt;p&gt;来看我们使用最多的 &lt;code&gt;dependencies&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    implementation 'com.google.guava:guava:26.0-jre'

    implementation('com.google.guava:guava:26.0-jre')

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Java 和 Android 项目中 &lt;code&gt;implementation&lt;/code&gt; 是一定会用到的，但是一个 Gradle Basic 项目是没有 &lt;code&gt;implementation&lt;/code&gt; 的，实际上，在 &lt;code&gt;dependencies&lt;/code&gt; 是不能直接添加任何依赖的。&lt;/p&gt;
&lt;p&gt;这里我们有说一下 Gradle 怎么解决依赖。&lt;/p&gt;
&lt;p&gt;Gradle 空白项目没有编译 Java 项目的能力，但是它能从仓库下载依赖的库并且配置到 &lt;code&gt;Project&lt;/code&gt; 中。在我们编译 Java 项目的时候，一个配置是不够的，至少要有个测试版，正式版，两个版本依赖的库可能是不一样的，两个版本部分代码也是不一样的，那么我们怎么区分呢？在 Gradle 中，是通过 &lt;code&gt;configurations&lt;/code&gt;，也就是配置，每个配置可以单独的添加依赖，在编译的时候，也就是执行某个 Task 的时候，通过读取配置中的依赖来添加 &lt;code&gt;classpath&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;repositories {
    mavenCentral()
}

configurations {
    test
    release
}

dependencies {
    test 'org.apache.commons:commons-lang3:3.0'
    release 'org.slf4j:slf4j-log4j12:1.7.2'
}



task buildTest {
    doLast {
        println configurations.test.name
        println configurations.test.asPath
    }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;./gradlew buildTest -q&lt;/code&gt;，输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test
/Users/xxx/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-lang3/3.0/8873bd0bb5cb9ee37f1b04578eb7e26fcdd44cb0/commons-lang3-3.0.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在 &lt;code&gt;buildTest&lt;/code&gt; 这个 Task 中进行编译工作的话，我们就可以直接读取 &lt;code&gt;configurations.test&lt;/code&gt; 的路径设置为 &lt;code&gt;classpath&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;implementation&lt;/code&gt; 就是通过添加了一个 &lt;code&gt;implementation&lt;/code&gt; 配置来实现的。这个配置是通过：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building an application
    id 'application'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加的，我们通过 &lt;code&gt;plugins&lt;/code&gt; 可以给 &lt;code&gt;Project&lt;/code&gt; 添加属性，Tasks，配置，例如我们写一个最简单的插件：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;package com.demo

import org.gradle.api.Plugin
import org.gradle.api.Project

class DemoPlugin implements Plugin&amp;lt;Project&amp;gt; {
    void apply(Project project) {

        project.task(&quot;hello&quot;) {
            doLast {
                println &quot;Hello World&quot;
            }
        }

        project.configurations {
            demoCompile
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个插件为 &lt;code&gt;Project&lt;/code&gt; 添加了一个 Task，添加了一个配置，我们将这个文件 &lt;code&gt;DemoPlugin.groovy&lt;/code&gt; 放在项目根目录下的 &lt;code&gt;buildSrc/src/main/groovy/demo/&lt;/code&gt; 下，就可以在 &lt;code&gt;build.gradle&lt;/code&gt; 中直接使用了：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;apply plugin: com.demo.DemoPlugin&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;buildscript&quot;&gt;buildscript&lt;/h2&gt;
&lt;p&gt;对于 &lt;code&gt;buildscript&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {
    repositories {
        mavenCentral()
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.0'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的作用是为构建脚本提供依赖，例如我们在项目中使用了 Android 的 Plugin，这个 Plugin 的要从哪找下载？这就需要在 buildscript 中指定。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 07:28:00 +0000</pubDate>
<dc:creator>sw926</dc:creator>
<og:description>现在 Android 开发免不了要和 Gradle 打交道，所有的 Android 开发肯定都知道这么在 中添加依赖，或者添加配置批量打包，但是真正理解这些脚本的人恐怕很少。其实 Gradle 的 可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sw926/p/10365370.html</dc:identifier>
</item>
<item>
<title>我的Lambda的学习笔记 - JYRoy</title>
<link>http://www.cnblogs.com/jyroy/p/10363536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyroy/p/10363536.html</guid>
<description>&lt;h2&gt;前述&lt;/h2&gt;
&lt;p&gt;　　Lambda表达式是 Java 8 的新特性。许多语言都有 Lambda 的特性。&lt;/p&gt;
&lt;p&gt;　　因此使用的 Java 环境一定要 8 以上的环境。&lt;/p&gt;

&lt;h2&gt;Lambda&lt;/h2&gt;
&lt;p&gt;　　到底什么是 Lambda 表达式呢？&lt;/p&gt;
&lt;p&gt;　　　　Lambda 表达式，也可称为闭包。Lambda 允许把函数作为一个方法的参数直接传递到方法中去。可以让我们不用费神去给函数起名。但是 Lambda 也只适合于简单的函数，对于复杂的函数，写成 Lambda 的形式反而会让人更加看不懂。&lt;/p&gt;

&lt;h2&gt;实例&lt;/h2&gt;
&lt;p&gt;　　接下来用一个实例慢慢导入 Lambda，要完成的是一个&lt;span&gt;判断Person的id是否大于90的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先创建一个Person类，包含 id 属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; person;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Person类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     @SuppressWarnings(&quot;unused&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;普通方法&lt;/h3&gt;
&lt;p&gt;　　用普通方法，在 for 循环中通过 if 进行条件判断 if(person.id&amp;gt;90) &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; normal;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lambda.Check;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt; Random();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机生成100个数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 Lambda 筛选出大于90的数据&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        judge(lists);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; judge(List&amp;lt;Person&amp;gt;&lt;span&gt; lists) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(person.id&amp;gt;90) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否大于90&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201902/1378215-20190211170023887-2101242535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;匿名类方法&lt;/h3&gt;
&lt;p&gt;　　创建一个匿名类，通过匿名类来实现这个判断 id 大于90的功能。&lt;/p&gt;
&lt;p&gt;　　首先提供匿名类需要的接口，用于创建一个判断的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; anonymity;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PersonCheck {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过匿名类实现接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 匿名类的方式 筛选出大于90的数据&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; PersonCheck personCheck = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonCheck() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现之后，就可以在judge函数中调用personCheck实例的test函数进行处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; anonymity;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lambda.Check;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  * 匿名类方式
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 匿名类的方式 筛选出大于90的数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         PersonCheck personCheck = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonCheck() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        judge(lists, personCheck);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; judge(List&amp;lt;Person&amp;gt;&lt;span&gt; lists, PersonCheck personCheck) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201902/1378215-20190211210003835-42531844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Lambda方式&lt;/h3&gt;
&lt;p&gt;　　接下来就是Lambda方式了&lt;/p&gt;
&lt;p&gt;　　先上 Lambda表达式的写法，运行过程序之后再做总结&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; person-&amp;gt;person.id&amp;gt;90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这便是一个Lambda表达式的形式，先记住这个形式，这个形式就是判断 person.id&amp;gt;90。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; lambda;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anonymity.PersonCheck;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Lambda表达式
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 Lambda 筛选出大于90的数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         filter(lists, person -&amp;gt; person.id &amp;gt; 90&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; filter(List&amp;lt;Person&amp;gt;&lt;span&gt; lists, PersonCheck personCheck) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果　&lt;/p&gt;
&lt;p&gt;　　实现了同样的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201902/1378215-20190211211953164-485084461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　上面的程序中使用了 Lambda表达式，完成了判断的功能，而且相比匿名类的写法要简单非常多，使用 Lambda 表达式可以使代码变的更加简洁紧凑。&lt;/p&gt;
&lt;p&gt; 　　Lambda 表达式的语法格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; (parameters) -&amp;gt;&lt;span&gt; expression
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;或
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; (parameters) -&amp;gt;{ statements; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是lambda表达式的重要特征:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可选类型声明：&lt;/strong&gt;不需要声明参数类型，编译器可以统一识别参数值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的参数圆括号：&lt;/strong&gt;一个参数无需定义圆括号，但多个参数需要定义圆括号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的大括号：&lt;/strong&gt;如果主体包含了一个语句，就不需要使用大括号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的返回关键字：&lt;/strong&gt;如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 不需要参数,返回值为 5  &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; () -&amp;gt; 5  
&lt;span&gt; 3&lt;/span&gt;   
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 接收一个参数(数字类型),返回其2倍的值  &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; x -&amp;gt; 2 *&lt;span&gt; x  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 接受2个参数(数字),并返回他们的差值  &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; (x, y) -&amp;gt;&lt;span&gt; x – y  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 接收2个int型整数,返回他们的和  &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y) -&amp;gt; x +&lt;span&gt; y  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; (String s) -&amp;gt; System.out.print(s)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　现在就可以解释上面的实例中的 Lambda表达式 的含义&lt;/p&gt;
&lt;pre&gt;
　　person-&amp;gt;person.id&amp;gt;90&lt;br/&gt;&lt;span&gt;　&lt;br/&gt;　&lt;/span&gt;即接收一个person参数，并返回大于person.id&amp;gt;90的数据&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;Lambda方法引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　方法引用&lt;/strong&gt;是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。　　&lt;/p&gt;
&lt;p&gt;　　可以看作是lambda的一种快捷写法，显式的指定方法的名称更具可读性。格式：目标引用+分隔符::+方法，例如，Dog::getAge就是引用了Dog类中定义的方法getAge。&lt;/p&gt;
&lt;p&gt;　　注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号&quot;::&quot;。&lt;/p&gt;

&lt;p&gt;　　Lambda方法引用包含一下四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;静态方法引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象方法引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;类成员方&lt;/strong&gt;法引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造方法引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;静态方法引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;首先需要有一个静态方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90 &amp;amp;&amp;amp; person.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Lambda表达式中调用这个静态方法，因为是静态方法可以不用创建对象，所以直接用类名进行调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; judge(lists, person -&amp;gt; TestLambda.test(person));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　利用方法引用调用静态方法的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; judge(lists, TestLambda::test);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主程序为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; references;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anonymity.PersonCheck;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Lambda表达式
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 Lambda 筛选出大于90的数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         judge(lists, person -&amp;gt; person.id &amp;lt; 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在Lambda表达式中使用静态方法 &lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         judge(lists, person -&amp;gt;&lt;span&gt; TestLambda.test(person));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接使用静态方法&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        judge(lists, TestLambda::test);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90 &amp;amp;&amp;amp; person.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; judge(List&amp;lt;Person&amp;gt;&lt;span&gt; lists, PersonCheck personCheck) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;对象方法引用&lt;/h3&gt;
&lt;p&gt;　　和静态方法相似，，但是在传递方法的时候，因为不是静态方法，所以必须要利用对象进行传送&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; references;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anonymity.PersonCheck;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Lambda表达式
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用引用对象方法&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         TestLambda testLambda = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestLambda();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        judge(lists, testLambda::test2);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test2(Person person) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90 &amp;amp;&amp;amp; person.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; judge(List&amp;lt;Person&amp;gt;&lt;span&gt; lists, PersonCheck personCheck) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;类成员方法引用&lt;/h3&gt;
&lt;p&gt;　　Person类要添加一个成员方法，才能够进行成员方法的引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test3() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id&amp;gt;90 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Lambda表达式中使用 test3方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; judge(lists, person -&amp;gt; person.test3());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　利用方法引用的写法为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; judge(lists,  Person::test3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主程序为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; references;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; anonymity.PersonCheck;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Lambda表达式
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用类成员方法&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         judge(lists, person -&amp;gt;&lt;span&gt; person.test3());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可改写为&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        judge(lists,  Person::test3);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Person person) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90 &amp;amp;&amp;amp; person.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test2(Person person) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; person.id&amp;gt;90 &amp;amp;&amp;amp; person.id&amp;lt;95&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     
&lt;span&gt;43&lt;/span&gt;     @SuppressWarnings(&quot;rawtypes&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; judge(List&amp;lt;Person&amp;gt;&lt;span&gt; lists, PersonCheck personCheck) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;构造方法引用&lt;/h3&gt;
&lt;p&gt;　　需要有返回一个对象的方法&lt;/p&gt;
&lt;p&gt;　　构造方法引用形式为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ArrayList::&lt;span&gt;new&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Person::&lt;span&gt;new&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; lambda;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Supplier;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Supplier&amp;lt;List&amp;gt; s = &lt;span&gt;new&lt;/span&gt; Supplier&amp;lt;List&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; List get() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用构造器&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     List list3 = getList(ArrayList::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List getList(Supplier&amp;lt;List&amp;gt;&lt;span&gt; s){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.get();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 聚合操作&lt;/h2&gt;
&lt;h3&gt;引入实例&lt;/h3&gt;
&lt;p&gt;　　在上面的程序中，遍历输出数据利用的是for循环的方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(personCheck.test(person)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        System.out.println(person);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以利用聚合操作来进行数据的输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;lists
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    .stream()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     .filter(person -&amp;gt; person.id&amp;gt;95&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     .forEach(person -&amp;gt; System.out.println(person.id));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主程序为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; normal;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lambda.Check;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; person.Person;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }        
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;使用传统方式----&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person person:lists) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(person.id&amp;gt;90&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                System.out.println(person);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot;聚合操作方式&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        lists
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             .filter(person -&amp;gt; person.id&amp;gt;95&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             .forEach(person -&amp;gt;&lt;span&gt; System.out.println(person.id));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201902/1378215-20190212120546948-414050185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Stream和管道&lt;/h3&gt;
&lt;p&gt;　　我们对应上面的代码，可以看出，聚合操作分为三步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;生成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作、变换（可以多次）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消耗（只有一次）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　当然我们还要知道stream和管道的概念&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;　　&lt;strong&gt;Stream&lt;/strong&gt;：Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。&lt;/span&gt;Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到，前面处理的结果。&lt;strong&gt;注意&lt;/strong&gt;：这个Stream和I/O中的InputStream,OutputStream是不一样的概念。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;　　&lt;strong&gt;管道：&lt;/strong&gt;指的是一系列的聚合操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;　　管道又分3个部分：管道源、中间操作、结束操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　&lt;strong&gt;管道源&lt;/strong&gt;：在这个例子里，源是一个List，可以用 .stream() 方法切换成管道源。但是数组没有stream() 方法，需要用 Arrays.stream(hs) 或者 Stream.of(hs)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; lambda;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; charactor.Hero;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAggregate {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         List&amp;lt;Hero&amp;gt; heros = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Hero&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             heros.add(&lt;span&gt;new&lt;/span&gt; Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;管道源是集合&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        .stream()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         .forEach(h-&amp;gt;&lt;span&gt;System.out.println(h.name));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;管道源是数组&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Hero hs[] = heros.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Hero[heros.size()]);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        Arrays.stream(hs)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         .forEach(h-&amp;gt;&lt;span&gt;System.out.println(h.name));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　&lt;strong&gt;中间操作&lt;/strong&gt;： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;中间操作比较多，主要分两类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;对元素进行筛选 和 转换为其他形式的流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　　　对元素进行筛选：&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　filter 匹配&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　distinct 去除重复(根据equals判断)&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　sorted 自然排序&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　sorted(Comparator&amp;lt;T&amp;gt;) 指定排序&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　limit 保留&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　skip 忽略&lt;br/&gt;&lt;span class=&quot;strong&quot;&gt;　　　　　    转换为其他形式的流&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　mapToDouble 转换为double的流&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;　　　　　　　　map 转换为任意类型的流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; lambda;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; charactor.Hero;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAggregate {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         List&amp;lt;Hero&amp;gt; heros = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Hero&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             heros.add(&lt;span&gt;new&lt;/span&gt; Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;制造一个重复数据&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         heros.add(heros.get(0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;初始化集合后的数据 (最后一个数据重复)：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        System.out.println(heros);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;满足条件hp&amp;gt;100&amp;amp;&amp;amp;damage&amp;lt;50的数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             .filter(h-&amp;gt;h.hp&amp;gt;100&amp;amp;&amp;amp;h.damage&amp;lt;50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;          
&lt;span&gt;28&lt;/span&gt;         System.out.println(&quot;去除重复的数据，去除标准是看equals&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            .distinct()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         System.out.println(&quot;按照血量排序&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             .sorted((h1,h2)-&amp;gt;h1.hp&amp;gt;=h2.hp?1:-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;          
&lt;span&gt;39&lt;/span&gt;         System.out.println(&quot;保留3个&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             .limit(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;          
&lt;span&gt;45&lt;/span&gt;         System.out.println(&quot;忽略前3个&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             .skip(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;          
&lt;span&gt;51&lt;/span&gt;         System.out.println(&quot;转换为double的Stream&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            .mapToDouble(Hero::getHp)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.println(h));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;          
&lt;span&gt;57&lt;/span&gt;         System.out.println(&quot;转换任意类型的Stream&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             .map((h)-&amp;gt; h.name + &quot; - &quot; + h.hp + &quot; - &quot; +&lt;span&gt; h.damage)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.println(h));
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;          
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;结束操作&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　常见结束操作如下：&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　forEach() 遍历每个元素&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　toArray() 转换为数组&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　min(Comparator&amp;lt;T&amp;gt;) 取最小的元素&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　max(Comparator&amp;lt;T&amp;gt;) 取最大的元素&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　count() 总数&lt;br/&gt;&lt;span class=&quot;tab&quot;&gt;&lt;span class=&quot;strong&quot;&gt;　　　　findFirst() 第一个元素&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; lambda;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.omg.Messaging.SYNC_WITH_TRANSPORT;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; charactor.Hero;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAggregate {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         List&amp;lt;Hero&amp;gt; heros = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Hero&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             heros.add(&lt;span&gt;new&lt;/span&gt; Hero(&quot;hero &quot; + i, r.nextInt(1000), r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;遍历集合中的每个数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             .forEach(h-&amp;gt;&lt;span&gt;System.out.print(h));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot;返回一个数组&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         Object[] hs=&lt;span&gt; heros
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            .toArray();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        System.out.println(Arrays.toString(hs));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;返回伤害最低的那个英雄&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         Hero minDamageHero =
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        heros
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             .min((h1,h2)-&amp;gt;h1.damage-&lt;span&gt;h2.damage)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            .get();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        System.out.print(minDamageHero);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         System.out.println(&quot;返回伤害最高的那个英雄&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         Hero mxnDamageHero =
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                heros
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                .stream()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 .max((h1,h2)-&amp;gt;h1.damage-&lt;span&gt;h2.damage)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                .get();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        System.out.print(mxnDamageHero);      
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt;         System.out.println(&quot;流中数据的总数&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; count =&lt;span&gt; heros
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                .stream()
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                .count();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        System.out.println(count);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         System.out.println(&quot;第一个英雄&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         Hero firstHero =
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                heros
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                .stream()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                .findFirst()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                .get();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        System.out.println(firstHero);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;编程实例&lt;/h3&gt;
&lt;p&gt;　　首选准备100个Person对象，id都是随机数。&lt;br/&gt;　　分别用传统方式和聚合操作的方式，把id第三高的名称和id打印出来&lt;/p&gt;
&lt;p&gt;　　Person.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; aggregation;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TestLambda.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; aggregation;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Comparator;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lambda.Check;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLambda {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;unchecked&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random(); 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         List&amp;lt;Person&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Person&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;100;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             lists.add(&lt;span&gt;new&lt;/span&gt; Person(&quot;Person&quot;+i, r.nextInt(100&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }        
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;使用传统方式----&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Comparator&amp;lt;Person&amp;gt; c = &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person p1, Person p2) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; p1.id &amp;gt;= p2.id ? 1 : -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        Collections.sort(lists, c);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         System.out.println(lists.get(2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;聚合操作方式----&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         Person p =&lt;span&gt; lists
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            .stream()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             .sorted((person1, person2) -&amp;gt; person1.id&amp;gt;=person2.id?1:-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             .skip(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            .findFirst()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            .get();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        System.out.println(p);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201902/1378215-20190212145636651-493958890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




</description>
<pubDate>Tue, 12 Feb 2019 07:20:00 +0000</pubDate>
<dc:creator>JYRoy</dc:creator>
<og:description>前述 Lambda表达式是 Java 8 的新特性。许多语言都有 Lambda 的特性。 因此使用的 Java 环境一定要 8 以上的环境。 Lambda 到底什么是 Lambda 表达式呢？ Lam</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyroy/p/10363536.html</dc:identifier>
</item>
<item>
<title>wireshark 抓包过滤器使用 - 老夏家的云</title>
<link>http://www.cnblogs.com/laoxiajiadeyun/p/10365073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoxiajiadeyun/p/10365073.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;整理自陈鑫杰老师的wireshark教程课&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;wireshark-抓包过滤器&quot;&gt;wireshark 抓包过滤器&lt;/h2&gt;
&lt;p&gt;过滤器分为抓包过滤器和显示过滤器，抓包过滤器会将不满足过滤条件的包丢弃，只保留满足条件的包，而显示过滤器则是对已抓取的包做过滤，过滤出满足条件的包。&lt;/p&gt;
&lt;p&gt;显示过滤器可以保留全部的报数据，方便后期做流量分析，而抓包过滤器保留的数据有限，后期分析有局限性。&lt;/p&gt;
&lt;h3 id=&quot;一抓包过滤器&quot;&gt;一、抓包过滤器&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;wireshark抓包是基于其内部的libpcap/wincap库&lt;/p&gt;
&lt;p&gt;打开软件时直接在filter栏输入过滤规则即可，如下以wireshark2.6举例&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Capture --&amp;gt; Options&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/20190212%20wireshark%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E5%99%A8/1549952345994.png?x-oss-process=style/shuiyin&quot; alt=&quot;1549952345994&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/20190212%20wireshark%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E5%99%A8/1549952300718.png?x-oss-process=style/shuiyin&quot; alt=&quot;1549952300718&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用的是BFP语法（Berkeley Packet Filter），一共四个元素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型（Type）
&lt;ul&gt;&lt;li&gt;host、net、port&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方向（Dir）
&lt;/li&gt;
&lt;li&gt;协议（Proto）
&lt;ul&gt;&lt;li&gt;ether、ip、tcp、udp、http、ftp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逻辑运算符
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 与&lt;/li&gt;
&lt;li&gt;&lt;code&gt;||&lt;/code&gt; 或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; 非&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抓取源地址为192.168.1.1，目的端口为80的流量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src host 192.168.1.1 &amp;amp;&amp;amp; dst port 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抓取192.168.1.1和192.168.1.2的流量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;host 192.168.1.1 || host 192.168.1.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要抓取广播包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! broadcast&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过滤mac地址&quot;&gt;过滤mac地址：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ether host 00:88:ca:86:f8:0d
ether src host 00:88:ca:86:f8:0d
ether dst host 00:88:ca:86:f8:0d&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过滤ip地址&quot;&gt;过滤IP地址：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;host 192.168.1.1
src host 192.168.1.1
dst host 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过滤端口&quot;&gt;过滤端口：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;port 80
!port 80
dst port 80
src port 80&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过滤协议&quot;&gt;过滤协议：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;arp
icmp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合逻辑符号综合过滤&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;host 192.168.1.1 &amp;amp;&amp;amp; port 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二显示过滤器&quot;&gt;二、显示过滤器&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;使用显示过滤器需先用软件进行抓包，然后在软件filter栏输入过滤规则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/20190212%20wireshark%E6%8A%93%E5%8C%85%E8%BF%87%E6%BB%A4%E5%99%A8/1549952508341.png?x-oss-process=style/shuiyin&quot; alt=&quot;1549952508341&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;比较符&quot;&gt;比较符：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 等于&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt; 不等于&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 大于&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 小于&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; 大于等于&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 小于等于&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;逻辑操作符&quot;&gt;逻辑操作符：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;and 两个条件同时满足&lt;/li&gt;
&lt;li&gt;or 其中一个条件被满足&lt;/li&gt;
&lt;li&gt;xor 有且仅有一个条件被满足&lt;/li&gt;
&lt;li&gt;not 没有条件被满足&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ip地址&quot;&gt;ip地址：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;ip.addr ip地址&lt;/li&gt;
&lt;li&gt;ip.src 源ip&lt;/li&gt;
&lt;li&gt;ip.dst 目标ip&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;端口过滤&quot;&gt;端口过滤：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;tcp.port&lt;/li&gt;
&lt;li&gt;tcp.srcport&lt;/li&gt;
&lt;li&gt;tcp.dstport&lt;/li&gt;
&lt;li&gt;tcp.flags.syn 过滤包含tcp的syn请求的包&lt;/li&gt;
&lt;li&gt;tcp.flags.ack 过滤包含tcp的ack应答的包&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;协议过滤&quot;&gt;协议过滤：&lt;/h4&gt;
&lt;p&gt;arp、ip、icmp、udp、tcp、bootp、dns等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过滤IP地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip.addr == 192.168.1.1   过滤该地址的包
ip.src == 172.16.1.1  过滤源地址为该地址的包&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tcp.port == 80 过滤tcp中端口号为80的包
tcp.flags.syn == 1 过滤syn请求为1的包&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合逻辑符综合过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip.src == 192.168.1.1 and ip.dst == 172.16.1.1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Feb 2019 06:40:00 +0000</pubDate>
<dc:creator>老夏家的云</dc:creator>
<og:description>整理自陈鑫杰老师的wireshark教程课 [TOC] wireshark 抓包过滤器 过滤器分为抓包过滤器和显示过滤器，抓包过滤器会将不满足过滤条件的包丢弃，只保留满足条件的包，而显示过滤器则是对已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoxiajiadeyun/p/10365073.html</dc:identifier>
</item>
<item>
<title>node.js微信小程序配置消息推送 - 一步一步向上爬</title>
<link>http://www.cnblogs.com/z937741304/p/10364874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z937741304/p/10364874.html</guid>
<description>&lt;p&gt;　　在开发微信小程序时，有一个消息推送，它的解释是这样的。&lt;/p&gt;
&lt;p&gt;　　消息推送具体的内容是下面的这个网址   https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html，他介绍的也还可以，就是我这里换成了node代码。&lt;/p&gt;
&lt;h4&gt;　　消息推送&lt;strong&gt;　&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　启用并设置消息推送配置后，用户发给小程序的消息以及开发者需要的事件推送，都将被微信转发至该服务器地址中。&lt;/p&gt;

&lt;p&gt;　　在微信小程序的首页开发里面，开发设置中，微信的官网中，介绍的也还可以，php代码写的差不多也能了解什么意思，但是其中没有告诉我们要把echostr这个参数在接口中返回出来，所以导致我测试了半天都是那个Token验证失败。&lt;/p&gt;
&lt;p&gt;　　写一下学习记录吧，方便后来的人遇到同样的问题，也方便自己以后查阅。&lt;/p&gt;
&lt;div readability=&quot;40.5&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1250927/201902/1250927-20190212140150306-797578374.png&quot; alt=&quot;&quot; width=&quot;1108&quot; height=&quot;864&quot;/&gt;

&lt;p&gt;　　这个里面的url服务器地址就是自己的地址（上面那个是我随便写的），后面接上自己的接口，比如我的就是 /token，当你点击提交的时候，会发现在服务器中会有如下的get请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1250927/201902/1250927-20190212135328805-1506899728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　避免有些人看不清楚上面的我在这里再用代码重新写一下上面的东西。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
GET /checkPushMsg?signature=db6e0c25b7743d8dd7ebfda1db6c742a762a2f37&amp;amp;echostr=1712804002525306855&amp;amp;timestamp=1549949926&amp;amp;nonce=982754662 200 1.321 ms - 46
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　其中的各个参数微信官网中介绍的也非常的详细。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1250927/201902/1250927-20190212140217632-676334419.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;411&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将token、timestamp、nonce三个参数进行字典序排序&lt;/li&gt;
&lt;li&gt;将三个参数字符串拼接成一个字符串进行sha1加密&lt;/li&gt;
&lt;li&gt;开发者获得加密后的字符串可与signature对比，标识该请求来源于微信&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　验证URL有效性成功后即接入生效，成为开发者。&lt;/p&gt;
&lt;p&gt;　　检验signature的node.js示例代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  验证服务器推送url地址
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  开发者提交信息后，微信服务器将发送GET请求到填写的服务器URL上，GET请求携带参数如下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     @params signature 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数，nonce参数
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     @params timestamp    时间戳
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     @params nonce    随机数
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     @params echostr    随机字符串
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; exports.check_push = (req, res) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  console.log(req.query);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   let signature =&lt;span&gt; req.query.signature,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       timestamp =&lt;span&gt; req.query.timestamp,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       nonce =&lt;span&gt; req.query.nonce,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       echostr =&lt;span&gt; req.query.echostr;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   let a = crypto.createHash('sha1').update([pushToken, timestamp, nonce].sort().join('')).digest('hex'&lt;span&gt;);  // 这里的pushToken就是在上面的那里配置的Token
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(a ==&lt;span&gt; signature){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果验证成功则原封不动的返回&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    res.send(echostr);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    res.send({
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       status: 400&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       data: &quot;check msg error&quot;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中遇到的两个问题，上面已经说了，这里再说一下这两个问题。&lt;/p&gt;
&lt;p&gt;　　其中一个是把 token、timestamp、nonce三个参数进行字典序排序，当时想自己写一个方法，写了好久发现有点难受，所以在网上找了一些东西，发现那个 数组的sort方法不传递参数就是那个 默认字符编码排序，所以就非常简单了，加密直接用到crypto模块&lt;/p&gt;
&lt;p&gt;　　另外一个就是微信都没有告诉我们要把那个echostr返回出去，虽然他的意思就是那个意思。。 这样就可以配置成功了。&lt;/p&gt;
&lt;p&gt;　　如果你同样遇到了这个问题，看了我的文章解决了，我会非常高兴。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 12 Feb 2019 06:06:00 +0000</pubDate>
<dc:creator>一步一步向上爬</dc:creator>
<og:description>在开发微信小程序时，有一个消息推送，它的解释是这样的。 消息推送具体的内容是下面的这个网址 https://developers.weixin.qq.com/miniprogram/dev/frame</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z937741304/p/10364874.html</dc:identifier>
</item>
<item>
<title>关于实现今天到一年中任意一天两者之间的天数差的计算 - 大王从来不巡山</title>
<link>http://www.cnblogs.com/wangwenhao072093/p/10364697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangwenhao072093/p/10364697.html</guid>
<description>&lt;p&gt;昨天的某时某刻突发奇想，想用自己现阶段所学的python知识来制作一个小程序。大致功能为：开机时像某安全软件一样，弹出窗口，窗口上能提示你，“距xxxx年xx月xx日还有多少天”。&lt;/p&gt;
&lt;p&gt;        在开始前，因为涉及到日期的计算（如标题所说），首先我想到了标准库中的datetime模块，该模块有个today（）函数能返回今天的日期（格式：xxxx-xx-xx），将函数返回的日期转换成字符串后，日期就成了一个长度为10的字符串，对字符串进行切片后分别转换为整型数，就可得到year，month，day参数，具体代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; date
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_date():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     today_date =&lt;span&gt; date.today()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     str_t_d =&lt;span&gt; str(today_date)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     year = int(str_t_d[:4&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     month = int(str_t_d[5:7&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     day = int(str_t_d[-2&lt;span&gt;:])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; year, month, day
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用get_date（）后会返回元组（year， month， day）&lt;/p&gt;
&lt;p&gt;下一步开始计算天数差了，因为考虑到对于每一年来说，每个月份天数除了2月以外都是固定的，2月天数的变化关系受到年份影响，因此需要判断闰年或平年，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; is29days(year=&lt;span&gt;get_date()[0]):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; year % 100 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; year % 400 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             months[1] = 29
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; year % 4 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         months[1] = 29
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; months
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上述代码中，将一年的十二个月对应天数按顺序放在列表months中，这个列表中二月对应的天数为28天，即默认为平年，用 if-elif-else语句判断是否为闰年，是就改变months[1]的值为29，返回新的months列表，否返回默认列表，在调用is29days（）时将返回月份列表&lt;/p&gt;
&lt;p&gt;         有了月份列表，就可也计算了，假定，给定一个日期：3月6日，今天的日期：get_date()[1] 月get_date()[2](今天日期为2月12日，没错我是今天写的)日，利用两个日期的月份对months列表切片，结合列表索引值将其与月份对应，如果当月为2月，则对应的months列表索引值为2-1=1!!!，切片为：months[2-1 ： 3]，这样列表中就包含了2月，3月两个月，用sum计算切片后的列表元素和后，减去两头的天数后就可以得到3月6日与2月12日之间相差的天数了，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; count_days(num_month=3, d_day=6&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; num_month &amp;lt; get_date()[1] &lt;span&gt;and&lt;/span&gt; d_day &amp;lt; get_date()[2&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在上一月的情况&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         month = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         year = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         x_day = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg, month, year, x_day
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; num_month == get_date()[1] &lt;span&gt;and&lt;/span&gt; d_day &amp;lt; get_date()[2&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在当月前些天的情况&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         month = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         year = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         x_day = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg, month, year, x_day
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         months = is29days()[get_date()[1]-1&lt;span&gt;:num_month]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         x_day =&lt;span&gt; d_day
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         year =&lt;span&gt; get_date()[0]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         month =&lt;span&gt; num_month
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         days = sum(months) - get_date()[2] - months[-1] +&lt;span&gt; x_day
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%3s天&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; days
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; msg, month, year, x_day
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到会有选择的日期在当日日期之前的情况，加入判断语句，调用count_days（）后返回元组（msg,  month,  year,  x_day），（若不传递实参 ，则默认实参为num_month=3, d_day=6）&lt;/p&gt;
&lt;p&gt;现在就完成了天数差的计算，但开头所讲我们还需一个能弹出窗口（GUI界面），鉴于我仅仅接触过 tkinter 所以我使用了它，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; deadline =&lt;span&gt; Tk()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; deadline.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeadLine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; deadline.geometry(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;220x300+1678+732&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; label = Label(deadline, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;距%4s年%2s月%2s日还有&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (count_days()[2], count_days()[1], count_days()[3]&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; label.grid(row=0, columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; label_1 = Label(deadline, justify=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, text=&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Don`t waste time any more !
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&quot; So do you want to take a
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;leap of faith，or become an
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;old man，filled with regret
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;waiting to die alone? &quot;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; label_1.grid(row=2, columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; display = Listbox(deadline, font=100, width=5, height=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; display.insert(END, count_days(&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; display.grid(row=1, columnspan=2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; button_2 = Button(deadline, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Exit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;deadline.destroy)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; button_2.grid(columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; deadline.mainloop()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596704/201902/1596704-20190212122547679-628392324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好像差不多了啊&lt;/p&gt;
&lt;p&gt;        然后开始将其封装成一个.exe的文件，在这里使用第三方库PyInstaller，因为不是python自带的需要自己安装，安装完成后，在控制台输入命令pyinstaller -F -w filename.py，这里需要注意如果不是在filename.py文件所在的目录下打开的控制台，是需要给定路径的，同时F 大写，w小写，如果不加上-w选项，在运行程序时会弹出控制器界面，同时py文件名不能用汉字，否则会报错，完成后在当前目录下，会有一个dist文件件，打开会发现一个filename.exe文件，大功告成!!&lt;/p&gt;
&lt;p&gt;还没完，我想每天打开电脑都能看到上图的GUI界面，就像某安全软件在屏幕右下角弹出界面一样（好像安全软件都弹），上网查了一下，找到一个方法，如下&lt;/p&gt;
&lt;p&gt;https://jingyan.baidu.com/article/54b6b9c0d103662d593b474e.html&lt;/p&gt;
&lt;p&gt;完整的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Date: 2019/2/12&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; date
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_date():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     today_date =&lt;span&gt; date.today()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     str_t_d =&lt;span&gt; str(today_date)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     year = int(str_t_d[:4&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     month = int(str_t_d[5:7&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     day = int(str_t_d[-2&lt;span&gt;:])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; year, month, day
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; is29days(year=&lt;span&gt;get_date()[0]):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; year % 100 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; year % 400 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             months[1] = 29
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; year % 4 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         months[1] = 29
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; months
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; count_days(num_month=3, d_day=6&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; num_month &amp;lt; get_date()[1] &lt;span&gt;and&lt;/span&gt; d_day &amp;lt; get_date()[2&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在上一月的情况&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         month = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         year = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         x_day = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg, month, year, x_day
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; num_month == get_date()[1] &lt;span&gt;and&lt;/span&gt; d_day &amp;lt; get_date()[2&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在当月前些天的情况&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         month = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         year = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         x_day = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg, month, year, x_day
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         months = is29days()[get_date()[1]-1&lt;span&gt;:num_month]
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         x_day =&lt;span&gt; d_day
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         year =&lt;span&gt; get_date()[0]
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         month =&lt;span&gt; num_month
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         days = sum(months) - get_date()[2] - months[-1] +&lt;span&gt; x_day
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         msg = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%3s天&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; days
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg, month, year, x_day
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; deadline =&lt;span&gt; Tk()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; deadline.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeadLine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; deadline.geometry(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;220x300+1678+732&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; label = Label(deadline, text=
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;距%4s年%2s月%2s日还有&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (count_days()[2], count_days()[1], count_days()[3&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; label.grid(row=0, columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; label_1 = Label(deadline, justify=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, text=&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;Don`t waste time any more !
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;&quot; So do you want to take a
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;leap of faith，or become an
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;old man，filled with regret
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;waiting to die alone? &quot;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; label_1.grid(row=2, columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; display = Listbox(deadline, font=100, width=5, height=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;display.insert(END, count_days()[0])
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; display.grid(row=1, columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; button_2 = Button(deadline, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Exit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;deadline.destroy)
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; button_2.grid(columnspan=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; deadline.mainloop()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;写在最后：&lt;/p&gt;
&lt;p&gt;　　上述代码只是实现了最简单的情况，我想以此为基础制作一个能计算任意两个日期天数差的程序，一步一步来,day day up，Come on ,code newbie!&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 05:06:00 +0000</pubDate>
<dc:creator>大王从来不巡山</dc:creator>
<og:description>昨天的某时某刻突发奇想，想用自己现阶段所学的python知识来制作一个小程序。大致功能为：开机时像某安全软件一样，弹出窗口，窗口上能提示你，“距xxxx年xx月xx日还有多少天”。 在开始前，因为涉及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangwenhao072093/p/10364697.html</dc:identifier>
</item>
<item>
<title>产品化机器学习的一些思考 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10364560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10364560.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：腾讯技术工程官方号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“如果说互联网是优化信息的存储和传输方式，提升生产要素之间的运行效率；人工智能便是对各个生产要素的升级。”&lt;/p&gt;
&lt;p&gt;本人初入职场便从事TOB相关工作，参与了tbds等大数据平台的产品建设，近两年逐渐接触人工智能；目前主要负责TI-ONE机器学习平台，结合自己工作经验，在这里分享一些关于ML产品的思考和实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工智能产品类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台-强调赋能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基础支撑/基础平台-通用的ML技术平台，实现常用的算法,形成通用机器学习平台（Spark/TensorFlow等），对外提供API、SDK等，为业务赋能。这类平台聚焦性能、开发效率和预测准确度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用-融入场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;突出场景闭环，如利用人脸识别、自然语言处理(NLP)等技术构建新的交互体验和用户场景。&lt;/p&gt;
&lt;p&gt;目前市面上看到的人工智能产品都属于弱人工智能的范畴，它们通常专注于某一特定领域，有一定规则边界，是达成既定目标的工具；各个领域的初级岗位最有可能被这类人工智能替代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工智能产品流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让人工智能产品能够运转起来的前提，首先需要寻找和积累大数据，大数据是机器学习平台必需的燃料，有足够大的燃料，平台所跑出的模型精确率会越高。&lt;/p&gt;
&lt;p&gt;通常我们会通过中间件工具（KAFKA/tube）进行流转，将数据运输到HDFS等存储平台，包括文本、图片、语音等数据，并对其做数据清洗，特征处理等，便于加载到接下来的神经网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法、训练模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;训练出一个有效的模型的前提，需要数据和算法两者的双管齐下；从计算模型的角度，我们通过所获取并清洗好的一组数据，配置好算法相关的关键参数来构建模型的运行，从而形成了一定的反馈路径，来达到预期的输出结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/170434/onpejn8e2.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过数据的灌输，建立起输入-处理-输出(IPO)的关系，加载到神经网络的训练中，学习数据中的规律并产生一个最能契合这些数据的函数表达式。在训练过程中，不断去试错和纠正，去推进模型更为精准的路上。对模型准确度有足够信心，便可把训练完成后的模型部署上去，去预测喂养新数据后的结果是什么。例输入的是人脸图片，那么输出结果便是人脸识别结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当模型精确度足够高后，便可上线服务，实际运用到我们的系统中。典型的例子是电商系统中基于用户/物品的推荐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工智能产品经理的思考点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.明确产品的定位，找到产品能发挥价值的地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在做TI-ONE初期，我们的目标是做一个通用／易用性高的机器学习平台，让方便业务接入平台。用户无需关注机器学习的运行细节，如底层用什么计算框架、用多少计算资源、应该怎样配置参数等，将注意力重点放在核心业务，同时也可以享受机器学习带来的便利。&lt;/p&gt;
&lt;p&gt;我们把TI-ONE设定为一个拖拽式建模工具而不是类似于jupyter的交互式工具，虽然jupyter有很好的拓展性，但为了降低机器学习使用门槛和释放用户大量写代码的时间和精力，增加受众面，我们选择了把特征处理、算法以模块化的方式来设计，让用户在拖拽组件中，快速完成模型的搭建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/170434/p0ean2qgxz.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在产品化机器学习的时候，发现大部分工作不是在研究复杂的公式理论，而是如何让用户在使用机器学习的过程中更顺畅，让不同步骤之间的流程如数据的准备、算法参数的填写、模型的训练／测试／筛选／部署等，能够无缝衔接。举个例子，规划及组织平台所需要的数据、用什么方式和工具来统一数据的上传、对数据的接入是否需要提供预览；如何帮助用户获得高质量的数据集，为提炼优质模型提供保障、如何高效率低成本地为数据打标签、把数据价值最大化，这些都是产品经理需要重点耗费精力的地方。&lt;/p&gt;
&lt;p&gt;在此引用谷歌大脑高级科学家Martin Zinkevich的一句话“To make great products：do machine learninglike the great engineer you are, not like the great machine learning expert youaren’t”把工程效率提升到极致了，用户才能真正享受到算法带来的便利。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.产品形态的把握&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于人工智能产品经理，所需的技能SET，不仅包括原型能力、功能逻辑、信息路径、UI设计，算法模型、数据训练等产品背后抽象的逻辑也同样重要。&lt;/p&gt;
&lt;p&gt;比如立项一个人工智能产品，我们不能很宽泛地定位要做一个机器写作，这个需求的范围太大，会让后续功能的开发不好收敛。产品经理需要尽量参与到算法开发，了解算法的每个步骤，对涉及的环节有个清晰的概念，并在此基础上寻找和评估是否有产品化的可能性。&lt;/p&gt;
&lt;p&gt;再比如我们要做新闻主题分类，首先需要利用网页抓取去各个网站的新闻，一般情况下，新闻网站都会分好类，可以直接记为标签。这个过程是否便可以做成一个产品化的成果。&lt;/p&gt;
&lt;p&gt;过去的互联网产品，可能我们偏向埋头于体验、需求，不太关注技术环节；而在AI产品领域，我们必须要深入技术运转流程，才能提升我们做出一个优秀AI产品的可能性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.了解用户指标背后的含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在评估TI-ONE产品用户数据指标时，UV/PV/月活/新增用户数等都是我们会去关注的数据指标。但若只关注实际数值，不去深究背后数据增长原因的话，有时会陷入一定的盲区。比如之前查看产品的统计指标，用户数和日均执行任务数都是一个稳定增长的趋势，但在用户调研中，深入了解了这些在平台上跑的任务，发现有一部分任务大家只用来做调度，并没有去使用平台上的算法模块，刨根问底了这部分用户才知道，因为我们平台上的算法库是黑盒子，出了问题不好定位，不如自己写代码查原因。通过这次对指标的剖析，我们也考虑将目前提供的算法进行开源和引入自定义算法模块，去补充我们对这块功能设计的短板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.纵向的业务理解能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人工智能产品往往跟某一垂直行业紧紧挂钩，去解决某一具体问题；这是要求人工智能产品经理去深入整个业务流程的链条，熟悉每一个涉及到的用户场景；并且在场景中，提炼出用户最迫切需求并优化需求点，实现产品的变现。&lt;/p&gt;
&lt;p&gt;很多不同行业、领域的人工智能产品其实背后所用到的技术逻辑都大同小异，如人脸识别技术，在安防市场，因人脸难以复制的特性，它代替了门禁卡。在公安领域，警察可以通过人脸识别，在各大重点区域，关口进行人脸的抓拍、识别，对可疑人物的信息可实时推送到警务终端，大大提升破案效率。在银行领域，人脸识别可以支持远程办理业务，刷脸开户，通过它查验身份信息，可免去需求亲自去网点办理的麻烦。&lt;/p&gt;
&lt;p&gt;技术是相通，但不同场景的侧重点会有所不同，产品形态也会有所差异；在银行领域，人证比对设备需求会比较强。在公安领域更强调的是后台动态人脸识别系统的使用。&lt;/p&gt;
&lt;p&gt;人工智能产品经理需要对业务场景进行反复验证、迭代，从而去判断结果概率是否能达到用户的标准，依照这些判断去做不同的投入策略。因此，了解算法的基本原理和落地的业务场景尤为重要，可以有一个相对清晰的技术框架，并且懂得在技术允许实现的范围内，规划出最优方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.关联信息的能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做人工智能产品需要我们加深对机器学习相关技术和应用的理解。理解好机器学习的基本逻辑，数学是其背后的原理，如微积分、概率论、线性代数都是机器学习的基础。而这些数学概念和模型往往是抽象、非直观的。&lt;/p&gt;
&lt;p&gt;当试着去理顺这些相对复杂的逻辑，可以尝试关联信息的方法，在不熟悉与熟悉的知识之前建立连接，从个人的经验中，去寻找能够与所有要理解信息类比的部分，把枯燥难懂的知识点，与实际生活的例子相结合。&lt;/p&gt;
&lt;p&gt;比如说我要学习线性回归，关于线性回归，提供的数学解释是假设自变量与因变量是线性关系,利用最小二乘法拟合自变量权重的一种分析方法。若单是看这段解释的话，会不太容易让人理解线性回归是在描述什么；试着去联想生活中的经验会帮助理解线性回归的概念。针对线性回归这个概念，可以通过房价波动和驱动因素来做联想，假设我们有1000条关于深圳房子的综合数据，每条数据作为一个样本，内含信贷价格、常住人口/户籍人口、工作人口/常住人口、小学生在校人数这些数据看作特征变量，房价为目标变量。线性回归解释的便是这些特征变量对房价波动的影响度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.降本提效是推动人工智能发展的最强动力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人工智能技术价值的实现，最终需要落地商业化、为行业带来价值和形成真实有效规模化的刚需来体现。目前大部分人工智能公司在做的是单一的人工智能驱动产品，如自动驾驶汽车算法、零售领域的刷脸支付、医疗领域的人工智能影像分析。所有员工工作中的任务自动化比例将提升，一部分劳动力也会被人工智能所替代。冲击较大的工种为人工客服、流水线工人、银行柜台职员等。&lt;/p&gt;
&lt;p&gt;还有一种AI公司，不是去用某种人工智能的能力去替代某一工种的工作，而是完全重塑整个行业的的劳动力配置，比如阿里的无人酒店，从接待到打扫的服务员全都是机器人，他们没有雇佣人类员工，去利用算法取代某种类型的工种；随着低本、高效和优质的服务模式逐渐铺开并且占领市场，高昂的人力成本可能会导致对手们重新调整公司对劳动力配置。&lt;/p&gt;
&lt;p&gt;根据来自普华永道的数据：“预计到2030年，AI将能为世界经济贡献15.7万亿美元，这相当于目前印度加中国的生产总值总和，中国公司在其中将起到非常重要和关键的作用。”相信不久的将来，会有越来越多的行业和人工智能结合在一起。如何去挖掘行业的切入点、利用AI去重塑应用场景，为实体行业提升运行效率、甚至颠覆当前的传统的商业模式，提供一套可行的AI解决方案是AI产品经理需要掌握的核心技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当有了一定积累，面对工作就会得心应手，使人的行为处于一个稳定的水平，慢慢有了自己的舒适区，时间久了会不愿离开这样的状态。但若一直沉浸在一个自己非常熟悉的领域，难免被固化了行为，不过是日复一日发挥着一个螺丝钉的功效。&lt;/p&gt;
&lt;p&gt;切换到AI领域发现，这是个一旦不保持自己技能SET更新状态便会被淘汰的领域，包括在一个项目组内的算法、开发童鞋，也是每天不断在学习，了解当前最前沿的知识。&lt;/p&gt;
&lt;p&gt;世界总是不断前进变化和充满着不确定性，保持着自己所积累的技能和可预见/突破的挑战的平衡，逐步爬坡，穿透自己的高墙，才能拥有人生更多的可能性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 03:56:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：腾讯技术工程官方号 “如果说互联网是优化信息的存储和传输方式，提升生产要素之间的运行效率；人工智能便是对各个生产要素的升级。” 本人初入职场便从事TOB相关工作，参与了tbd</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10364560.html</dc:identifier>
</item>
<item>
<title>一步步走进Sql中的事务及事务隔离级别 - 刷书小将</title>
<link>http://www.cnblogs.com/zh1996/p/10361793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh1996/p/10361793.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 1.事务定义&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;事务是按照逻辑执行的一组任务序列，这一组任务序列要么都执行，要么都不执行。&lt;/p&gt;
&lt;p&gt;事务是优先基于会话配置的的（session），其次是基于全局配置的（global）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.事务的提交和回滚&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;提交commited，即一组任务序列，正常执行后，提交给数据库。&lt;/p&gt;
&lt;p&gt;回滚rollback，即一组任务序列中，无论哪一个任务环节出现异常，都会把所有的任务序列全部恢复到原始状态。&lt;/p&gt;
&lt;p&gt;事务的提交可以分为手动提交和自动提交。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.查看和设置提交方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;session和global中都有变量autocommit，&lt;/p&gt;
&lt;p&gt;autocommit为1的时候自动提交，&lt;/p&gt;
&lt;p&gt;autocommit为0的时候手动提交。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@@session&lt;/span&gt;.autocommit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212093110059-622941481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查看全局配置中的默认提交方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@@global&lt;/span&gt;.autocommit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212093225730-152066337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关闭当前会话的自动提交，改为手动提交。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@@session&lt;/span&gt;.autocommit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212093430086-1206463524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 4.创建数据库，测试提交方式。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设计一个简单的数据库，往数据库中加一个表格。&lt;/p&gt;
&lt;p&gt;表格中分别是，id（自增），用户名，用户余额。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; transdemo;

&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; users;

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; users (
  uid &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) AUTO_INCREMENT,
  uname &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;money&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (uid)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;插入一条数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; users &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhanghao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mysql自增字段（id）插入时，用null即可。&lt;/p&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190211125058024-1213545972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自动提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212094449416-1878694561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 手动提交：&lt;/p&gt;
&lt;p&gt; 为了测试手动提交，打开另外一个命令窗口并连接mysql，即开启了另外一个&lt;span&gt;&lt;strong&gt;会话窗口B（Windows PowerShell）&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这是原本的会话窗口A（Windows PowerShell）&lt;/strong&gt;&lt;/span&gt;，关闭自动提交，改为手动提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212095439249-659700867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时A中会话看似一切正常。&lt;/p&gt;

&lt;p&gt;在B中，再次读取users表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212095556309-480579713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题出来了，zhanghao用户的money还是900，表格数据并没有被更新。&lt;/p&gt;

&lt;p&gt;此时，我们在&lt;span&gt;&lt;strong&gt;A会话（原本会话）&lt;/strong&gt;&lt;/span&gt;中，提交commit；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212095816853-336186403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时，我们在&lt;strong&gt;&lt;span&gt;B会话（新开的会话窗口）&lt;/span&gt;&lt;/strong&gt;再次查询，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212095950681-293166777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据被更新。&lt;/p&gt;

&lt;p&gt;总结：自动提交时，无需commit即可自动更新改变数据；手动提交时，必须要commit，才能更新改变数据库中的数据。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.事务隔离级别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;事务中的隔离级别共有四种：&lt;/p&gt;
&lt;p&gt;1.读未提交 read uncommited&lt;/p&gt;
&lt;p&gt;2.读已提交 read commited&lt;/p&gt;
&lt;p&gt;3.可重复读 repeatable read&lt;/p&gt;
&lt;p&gt;4.串行化 serializable&lt;/p&gt;


&lt;p&gt;首先查看当前会话的事务隔离级别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@@session&lt;/span&gt;&lt;span&gt;.transaction_isolation;


&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 8.0以下版本&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; select @@session.tx_isolation;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212085152582-1632186457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 再看一下全局的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@@global&lt;/span&gt;&lt;span&gt;.transaction_isolation;


&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 8.0以下版本&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; select @@global.tx_isolation;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212085455990-463588431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从上面测试可以看出，mysql的事务隔离级别，默认是repeatable-read，即可重复读。&lt;/p&gt;

&lt;p&gt;我们可以修改mysql的事务隔离级别，仍然基于当前会话（session）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将当前会话的事务隔离级别设置为 : read uncommitted，即读未提交&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt; session &lt;span&gt;transaction&lt;/span&gt; &lt;span&gt;isolation&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; &lt;span&gt;read&lt;/span&gt; &lt;span&gt;uncommitted&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 查看当前会话的事务隔离级别&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@@session&lt;/span&gt;.transaction_isolation;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212085827578-764506249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 此时，事务的隔离级别变为的&lt;strong&gt;&lt;span&gt;read uncommitted&lt;/span&gt;&lt;/strong&gt;即读未提交。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.1 读未提交&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两个连接窗口AB（Windows PowerShell），测试读未提交。&lt;/p&gt;
&lt;p&gt;按上文方法，将A连接设置为读未提交。B连接不设置隔离级别，采用默认。&lt;/p&gt;
&lt;p&gt;首先在B连接中，开始事务，并将zhanghao用户的money减100。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212101409265-611325386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，在事务中，可以正常的显示zhanghao的money为900，成功被减去100。&lt;/p&gt;
&lt;p&gt;但是在数据库中查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212101523210-1251348010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zhanghao的money仍为1000。&lt;/p&gt;
&lt;p&gt;这也不奇怪，因为B连接的事务并没有被提交。&lt;/p&gt;
&lt;p&gt;但是，在B连接中的事务没有提交，数据库users表中zhanghao的money为1000的时候，&lt;/p&gt;
&lt;p&gt;在A会话窗口中（&lt;span&gt;&lt;strong&gt;已被设置为读未提交&lt;/strong&gt;&lt;/span&gt;），开始事务并读取zhanghao的money时，却读到了未提交的900。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212101731141-1666936676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这就是读未提交。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;导致的问题：脏读。即另外一个事务尚未提交的时候（数据库中的数据没被改变的时候），在A窗口事务中，已经读到了未提交的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2 读已提交&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;仍然开始两个Windows PowerShell窗口分别连接mysql，实现两个会话。&lt;/p&gt;
&lt;p&gt;首先在A窗口中，设置事务隔离级别为读已提交。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; session &lt;span&gt;transaction&lt;/span&gt; &lt;span&gt;isolation&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; &lt;span&gt;read&lt;/span&gt; &lt;span&gt;committed&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212102346314-828452817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;B窗口采用默认的隔离级别，不做任何改动即可。&lt;/p&gt;

&lt;p&gt;数据库初始值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212102656642-1629401675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在B窗口中，开启事务，并把money减去100，不提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103002871-1049511161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后，在A窗口中，开始事务并查询users表，不提交&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103102117-444610608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后，在B窗口中，提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103144542-360941831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后，在A窗口中，再次查询users表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103235442-1080675433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本次流程A窗口的完整运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103317650-1772189996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次查询的时候，由于B窗口的update未提交，所以为money1000，&lt;/p&gt;
&lt;p&gt;B窗口提交之后，A窗口再次查询的时候，money变为了900。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这就是读已提交。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;导致的问题：不可重复读。从上图可以明显看出，在一个事务中，两次读到的结果不相同。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.3 可重复读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;仍然开始两个Windows PowerShell窗口分别连接mysql，实现两个会话。&lt;/p&gt;
&lt;p&gt;首先在A窗口中，设置事务隔离级别为可重复读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212103949050-998770423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;B窗口采用默认的隔离级别，不做任何改动即可。&lt;/p&gt;

&lt;p&gt;数据库初始值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212102656642-1629401675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先在B窗口中，开启事务。并将zhanghao的money减去100，不提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212104408424-81130717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后，在A窗口中，开启事务并查看users表，不提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212104506397-1912880183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后B窗口提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212104533413-2041039497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后再次在A窗口中查看users表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212104600647-1703696654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 发现，两次查询的结果，是一致的。即使B窗口已经将money改为900并提交，&lt;/p&gt;
&lt;p&gt;但是在A窗口的一个事务中，两次查询结果是一致的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212104708156-1167722645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就是可重复读，即在一个事务中，重复读数据时不会变的。&lt;/p&gt;
&lt;p&gt;但是这就完美了吗？&lt;/p&gt;

&lt;p&gt;此时A窗口仍未提交，B窗口已提交。&lt;/p&gt;
&lt;p&gt;在B窗口，再次开启一个事务，并且添加一条用户，lisi，500。&lt;/p&gt;
&lt;p&gt;此时，A窗口再次查询users表时，诡异的多了一条lisi的数据，&lt;/p&gt;
&lt;p&gt;也就是像魅影一样的出现了，这就是幻读。&lt;/p&gt;
&lt;p&gt;mysql8中，已经对幻读增加了防范措施，低版本mysql仍存在幻读问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可重复读导致的问题：幻读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.4 串行化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同上，开启A、B两个Windows PowerShell窗口连接mysql，&lt;/p&gt;
&lt;p&gt;在AB窗口中，都设置事务隔离方式为串行化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; session &lt;span&gt;transaction&lt;/span&gt; &lt;span&gt;isolation&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; seriable;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212111258744-758141183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先在A窗口中开启事务，并查询users表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212112840893-104529591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;然后再B窗口中开启事务，并将zhanghao的money减去100，却发现窗口卡住了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212113045639-325080399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回到A窗口，提交事务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212113107024-54309980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时B窗口，更新操作顺利完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190212113135144-894897333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就是串行化，&lt;/p&gt;
&lt;p&gt;即当A连接中的事务访问一个表的时候，&lt;/p&gt;
&lt;p&gt;B连接中的事务想要修改表中的数据，&lt;/p&gt;
&lt;p&gt;B连接就会卡住，等待A连接中的事务提交或回滚后，才继续执行B连接中的修改事务。&lt;/p&gt;
&lt;p&gt;即谁先执行的事务，必须等这个事务执行完，才能执行另一个事务。&lt;/p&gt;
&lt;p&gt;缺点：性能非常低。&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 03:56:00 +0000</pubDate>
<dc:creator>刷书小将</dc:creator>
<og:description>1.事务定义 事务是按照逻辑执行的一组任务序列，这一组任务序列要么都执行，要么都不执行。 事务是优先基于会话配置的的（session），其次是基于全局配置的（global）。 2.事务的提交和回滚 提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zh1996/p/10361793.html</dc:identifier>
</item>
<item>
<title>Docker学习笔记1  -- 刚入手docker时的几个命令 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/learn-docker-note1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/learn-docker-note1.html</guid>
<description>&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;docker 是命令二进制文件&lt;/li&gt;
&lt;li&gt;run 运行一个容器&lt;/li&gt;
&lt;li&gt;ubuntu:15.10 镜像名称，通过是名字加版本号&lt;/li&gt;
&lt;li&gt;后面是容器里执行的任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;交互式，进入镜像内部&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; docker run -i -t ubuntu:15.10 /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-t:在新容器内指定一个伪终端或终端。&lt;/li&gt;
&lt;li&gt;-i:允许你对容器内的标准输入 (STDIN) 进行交互。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;后台运行&quot;&gt;后台运行&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
6e42dee957d59d818d0d21bbf0ff8b2bc84d1006baa2696e81f33e023d3e2c04

# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
6e42dee957d5        ubuntu:15.10        &quot;/bin/sh -c 'while t…&quot;   2 seconds ago       Up 1 second                             sad_villani

# docker logs 6e42dee957d5
hello world
hello world
hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;停止运行&quot;&gt;停止运行&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# docker stop  6e42dee957d5
6e42dee957d5&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;
&lt;h3 id=&quot;载入镜像&quot;&gt;载入镜像&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; docker pull training/webapp &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行应用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker run -d -P training/webapp python app.py

# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
c99a63cd5cb3        training/webapp     &quot;python app.py&quot;     4 seconds ago       Up 3 seconds        0.0.0.0:32769-&amp;gt;5000/tcp   jovial_elion

# curl localhost:32769
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-d:让容器在后台运行。&lt;/li&gt;
&lt;li&gt;-P:将容器内部使用的网络端口映射到我们使用的主机上。本地端口是32769，映射内部端口5000.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;指定端口映射&quot;&gt;指定端口映射&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@bigdata-base-001 ~]# docker run -d -p 5000:5000 training/webapp python app.py
458bb7a6520a46e74137032770f846a5faf9afb43b6ba324667d4b1936566ea0
[root@bigdata-base-001 ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                     NAMES
458bb7a6520a        training/webapp     &quot;python app.py&quot;     4 seconds ago        Up 3 seconds        0.0.0.0:5000-&amp;gt;5000/tcp    wizardly_babbage
c99a63cd5cb3        training/webapp     &quot;python app.py&quot;     About a minute ago   Up About a minute   0.0.0.0:32769-&amp;gt;5000/tcp   jovial_elion
[root@bigdata-base-001 ~]# curl localhost:5000
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现运行两个应用，但对应本地不同的端口&lt;/p&gt;
&lt;h3 id=&quot;查看日志&quot;&gt;查看日志&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# docker logs 458bb7a6520a
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
172.17.0.1 - - [03/Jan/2019 14:13:38] &quot;GET / HTTP/1.1&quot; 200 -&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tail日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker logs -f 458bb7a6520a
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
172.17.0.1 - - [03/Jan/2019 14:13:38] &quot;GET / HTTP/1.1&quot; 200 -

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看应用的进程&quot;&gt;查看应用的进程&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# docker top 458bb7a6520a
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                14801               14765               0                   22:13               ?                   00:00:00            python app.py&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;登入镜像内部&quot;&gt;登入镜像内部&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker exec  -it 458bb7a6520a /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;移除容器&quot;&gt;移除容器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker rm c99a63cd5cb3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看最近一次创建的容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker ps -l
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                            PORTS               NAMES
458bb7a6520a        training/webapp     &quot;python app.py&quot;     20 minutes ago      Exited (137) About a minute ago                       wizardly_babbage&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;镜像&quot;&gt;镜像&lt;/h2&gt;
&lt;h3 id=&quot;查看本地镜像&quot;&gt;查看本地镜像&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker images           
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB
php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker pull ubuntu:13.10&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查找镜像&quot;&gt;查找镜像&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker search httpd&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更新镜像&quot;&gt;更新镜像&lt;/h3&gt;
&lt;p&gt;首先进入镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -t -i ubuntu:15.10 /bin/bash
root@e218edb10161:/# apt-get update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新后，提交副本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2
sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-m:提交的描述信息&lt;/li&gt;
&lt;li&gt;-a:指定镜像作者&lt;/li&gt;
&lt;li&gt;e218edb10161：容器ID&lt;/li&gt;
&lt;li&gt;runoob/ubuntu:v2:指定要创建的目标镜像名&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h3&gt;
&lt;p&gt;使用docker build通过Dockerfile构建镜像。&lt;/p&gt;
&lt;p&gt;一个示例Dockerfile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &amp;gt;/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker build -t runoob/centos:6.7 .
Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&amp;amp;gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0c92299c6f03
Step 3 : RUN /bin/echo 'root:123456' |chpasswd
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-t ：指定要创建的目标镜像名&lt;/li&gt;
&lt;li&gt;. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# docker images | grep run
runoob/centos                                              6.7                 b9f70b080d42        12 seconds ago      191MB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用镜像来创建容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker run -t -i runoob/centos:6.7  /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置镜像标签&quot;&gt;设置镜像标签&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# docker tag b9f70b080d42  runoob/centos:dev

# docker images | grep run                  
runoob/centos                                              6.7                 b9f70b080d42        3 minutes ago       191MB
runoob/centos                                              dev                 b9f70b080d42        3 minutes ago       191MB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;镜像标签可以理解为版本号。比如我们项目demo的版本是1.5.1，那么标签可以是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 构建一个镜像，名称是ryan/demo, tag是1.5.1
docker build -t ryan/demo:1.5.1 .

-- 因为这个镜像是最新的，将指针latest 指向这个
docker tag ryan/demo:1.5.1  latest

-- 对于版本1来说，这也是最新的
docker tag ryan/demo:1.5.1  1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，tag可以有多个对应的是同一个镜像。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 03:44:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<og:description>[TOC] Hello World docker 是命令二进制文件 run 运行一个容器 ubuntu:15.10 镜像名称，通过是名字加版本号 后面是容器里执行的任务 交互式，进入镜像内部 t:在新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/learn-docker-note1.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Sleuth 之Greenwich版本全攻略 - 方志朋的专栏</title>
<link>http://www.cnblogs.com/forezp/p/10364435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forezp/p/10364435.html</guid>
<description>&lt;p&gt;微服务架构是一个分布式架构，微服务系统按业务划分服务单元，一个微服务系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性较高，如果出现了错误和异常，很难去定位。主要体现在一个请求可能需要调用很多个服务，而内部服务的调用复杂性决定了问题难以定位。所以在微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，出了问题能够快速定位的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2279594-879c58ddc68661d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在微服务系统中，一个来自用户的请求先到达前端A（如前端界面），然后通过远程调用，到达系统的中间件B、C（如负载均衡、网关等），最后到达后端服务D、E，后端经过一系列的业务逻辑计算，最后将数据返回给用户。对于这样一个请求，经历了这么多个服务，怎么样将它的请求过程用数据记录下来呢？这就需要用到服务链路追踪。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-sleuth&quot;&gt;Spring Cloud Sleuth&lt;/h2&gt;
&lt;p&gt;Spring Cloud Sleuth 为服务之间调用提供链路追踪。通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外 Sleuth 可以帮助我们：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;耗时分析: 通过 Sleuth 可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;&lt;/li&gt;
&lt;li&gt;可视化错误: 对于程序未捕捉的异常，可以通过集成 Zipkin 服务界面上看到;&lt;/li&gt;
&lt;li&gt;链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Google开源了Dapper链路追踪组件，并在2010年发表了论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这篇论文是业内实现链路追踪的标杆和理论基础，具有很高的参考价值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2279594-61847a9a93b89480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Sleuth采用了Google的开源项目Dapper的专业术语。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Span：基本工作单元，发送一个远程调度任务就会产生一个Span，Span是用一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的。Span还包含了其他的信息，例如摘要、时间戳事件、Span的ID以及进程ID。&lt;/li&gt;
&lt;li&gt;Trace：由一系列Span组成的，呈树状结构。请求一个微服务系统的API接口，这个API接口需要调用多个微服务单元，调用每个微服务单元都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。&lt;/li&gt;
&lt;li&gt;Annotation：用于记录一个事件，一些核心注解用于定义一个请求的开始和结束，这些注解如下。
&lt;ul&gt;&lt;li&gt;cs-Client Sent：客户端发送一个请求，这个注解描述了Span的开始。&lt;/li&gt;
&lt;li&gt;sr-Server Received：服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳，便可得到网络传输的时间。&lt;/li&gt;
&lt;li&gt;ss-Server Sent：服务端发送响应，该注解表明请求处理的完成（当请求返回客户端），用ss的时间戳减去sr时间戳，便可以得到服务器请求的时间。&lt;/li&gt;
&lt;li&gt;cr-Client Received：客户端接收响应，此时Span结束，如果cr的时间戳减去cs时间戳，便可以得到整个请求所消耗的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Cloud Sleuth 也为我们提供了一套完整的链路解决方案,Spring Cloud Sleuth 可以结合 Zipkin，将信息发送到 Zipkin，利用 Zipkin 的存储来存储链路信息，利用 Zipkin UI 来展示数据。&lt;/p&gt;
&lt;h2 id=&quot;zipkin&quot;&gt;Zipkin&lt;/h2&gt;
&lt;p&gt;Zipkin是一种分布式链路追踪系统。 它有助于收集解决微服务架构中的延迟问题所需的时序数据。 它管理这些数据的收集和查找。 Zipkin的设计基于Google Dapper论文。&lt;/p&gt;
&lt;p&gt;跟踪器存在于应用程序中，记录请求调用的时间和元数据。跟踪器使用库，它们的使用对用户是无感知的。例如，Web服务器会在收到请求时和发送响应时会记录相应的时间和一些元数据。一次完整链路请求所收集的数据被称为Span。&lt;/p&gt;
&lt;p&gt;我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它也提供了方便的 UI 组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。&lt;br/&gt;Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。接下来的测试为方便直接采用 In-Memory 方式进行存储，生产推荐 Elasticsearch.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2279594-ae5a6baa5d8367d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为 Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。&lt;/li&gt;
&lt;li&gt;Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。&lt;/li&gt;
&lt;li&gt;RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。&lt;/li&gt;
&lt;li&gt;Web UI：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;案例实战&quot;&gt;案例实战&lt;/h2&gt;
&lt;p&gt;在本案例一共有三个应用，分别为注册中心，eureka-server、eureka-client、eureka-client-feign，三个应用的基本信息如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eureka-server&lt;/td&gt;
&lt;td&gt;8761&lt;/td&gt;
&lt;td&gt;注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;eureka-client&lt;/td&gt;
&lt;td&gt;8763&lt;/td&gt;
&lt;td&gt;服务提供者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eureka-client-feign&lt;/td&gt;
&lt;td&gt;8765&lt;/td&gt;
&lt;td&gt;服务消费者&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中eureka-server 应用为注册中心，其他两个应用向它注册。eureka-client为服务提供者，提供了一个RESTAPI,eureka-client-feign为服务消费者，通过Feign Client向服务提供者消费服务。&lt;/p&gt;
&lt;p&gt;在之前的文章已经讲述了如何如何搭建服务注册中心，在这里就省略这一部分内容。服务提供者提供一个REST接口，服务消费者通过FeignClient消费服务。&lt;/p&gt;
&lt;h3 id=&quot;服务提供者&quot;&gt;服务提供者&lt;/h3&gt;
&lt;p&gt;eureka-client服务提供者，对外提供一个RESTAPI，并向服务注册中心注册，这部分内容，不再讲述，见源码。需要在工程的pom文件加上sleuth的起步依赖和zipkin的起步依赖，代码如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在工程的配置文件application.yml需要做以下的配置：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;spring:
  sleuth:
    web:
      client:
        enabled: true
    sampler:
      probability: 1.0 # 将采样比例设置为 1.0，也就是全部都需要。默认是 0.1
  zipkin:
    base-url: http://localhost:9411/ # 指定了 Zipkin 服务器的地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中spring.sleuth.web.client.enable为true设置的是web开启sleuth功能;spring.sleuth.sampler.probability可以设置为小数，最大值为1.0，当设置为1.0时就是链路数据100%收集到zipkin-server，当设置为0.1时，即10%概率收集链路数据;spring.zipkin.base-url设置zipkin-server的地址。&lt;/p&gt;
&lt;p&gt;对外提供一个Api，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@RestController
public class HiController {

    @Value(&quot;${server.port}&quot;)
    String port;
    @GetMapping(&quot;/hi&quot;)
    public String home(@RequestParam String name) {
        return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务消费者&quot;&gt;服务消费者&lt;/h3&gt;
&lt;p&gt;服务消费者通过FeignClient消费服务提供者提供的服务。同服务提供者一样，需要在工程的pom文件加上sleuth的起步依赖和zipkin的起步依赖，另外也需要在配置文件application.yml做相关的配置，具体同服务提供者。&lt;/p&gt;
&lt;p&gt;服务消费者通过feignClient进行服务消费，feignclient代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@FeignClient(value = &quot;eureka-client&quot;,configuration = FeignConfig.class)
public interface EurekaClientFeign {

    @GetMapping(value = &quot;/hi&quot;)
    String sayHiFromClientEureka(@RequestParam(value = &quot;name&quot;) String name);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;servcie层代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class HiService {

    @Autowired
    EurekaClientFeign eurekaClientFeign;

 
    public String sayHi(String name){
        return  eurekaClientFeign.sayHiFromClientEureka(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HiController {
    @Autowired
    HiService hiService;

    @GetMapping(&quot;/hi&quot;)
    public String sayHi(@RequestParam( defaultValue = &quot;forezp&quot;,required = false)String name){
        return hiService.sayHi(name);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码对外暴露一个API，通过FeignClient的方式调用eureka-client的服务。&lt;/p&gt;
&lt;h3 id=&quot;zipkin-server&quot;&gt;zipkin-server&lt;/h3&gt;
&lt;p&gt;在Spring Cloud D版本，zipkin-server通过引入依赖的方式构建工程，自从E版本之后，这一方式改变了，采用官方的jar形式启动，所以需要通过下载官方的jar来启动，也通过以下命令一键启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的第一行命令会从zipkin官网下载官方的jar包。&lt;br/&gt;如果是window系统，建议使用gitbash执行上面的命令。&lt;/p&gt;
&lt;p&gt;如果用 Docker 的话，使用以下命令：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;
docker run -d -p 9411:9411 openzipkin/zipkin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过java -jar zipkin.jar的方式启动之后，在浏览器上访问lcoalhost:9411，显示的界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-6d6194ed00e48f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;链路数据验证&quot;&gt;链路数据验证&lt;/h3&gt;
&lt;p&gt;依次启动eureka-server，eureka-client,eureka-client-feign的三个应用，等所有应用启动完成后，在浏览器上访问http://localhost:8765/hi（如果报错，是服务与发现需要一定的时间，耐心等待几十秒），访问成功后，再次在浏览器上访问zipkin-server的页面，显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-9dc1532ba0830ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出每次请求所消耗的时间，以及一些span的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-db03d2f63a51773e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出具体的服务依赖关系，eureka-feign-client依赖了eureka-client。&lt;/p&gt;
&lt;h3 id=&quot;使用rabbitmq进行链路数据收集&quot;&gt;使用rabbitmq进行链路数据收集&lt;/h3&gt;
&lt;p&gt;在上面的案例中使用的http请求的方式将链路数据发送给zipkin-server，其实还可以使用rabbitmq的方式进行服务的消费。使用rabbitmq需要安装rabbitmq程序，下载地址http://www.rabbitmq.com/。&lt;/p&gt;
&lt;p&gt;下载完成后，需要eureka-client和eureka-client-feign的起步依赖加上rabbitmq的依赖，依赖如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-stream-binder-rabbit&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在配置文件上需要配置rabbitmq的配置，配置信息如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;spring:
  rabbitmq:
    host: localhost
    username: guest
    password: guest
    port: 5672
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外需要把spring.zipkin.base-url去掉。&lt;/p&gt;
&lt;p&gt;在上面2个工程中，rabbitmq通过发送链路数据，那么zipkin-server是怎么样知道rabbitmq的地址呢，怎么监听收到的链路数据呢？这需要在程序启动的时候，通过环境变量的形式到环境中，然后zikin-server从环境变量中读取。&lt;br/&gt;可配置的属性如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.addresses&lt;/td&gt;
&lt;td&gt;RABBIT_ADDRESSES&lt;/td&gt;
&lt;td&gt;用逗号分隔的 RabbitMQ 地址列表，例如localhost:5672,localhost:5673&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.password&lt;/td&gt;
&lt;td&gt;RABBIT_PASSWORD&lt;/td&gt;
&lt;td&gt;连接到 RabbitMQ 时使用的密码，默认为 guest&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.username&lt;/td&gt;
&lt;td&gt;RABBIT_USER&lt;/td&gt;
&lt;td&gt;连接到 RabbitMQ 时使用的用户名，默认为guest&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.virtual-host&lt;/td&gt;
&lt;td&gt;RABBIT_VIRTUAL_HOST&lt;/td&gt;
&lt;td&gt;使用的 RabbitMQ virtual host，默认为 /&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.use-ssl&lt;/td&gt;
&lt;td&gt;RABBIT_USE_SSL&lt;/td&gt;
&lt;td&gt;设置为true则用 SSL 的方式与 RabbitMQ 建立链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.concurrency&lt;/td&gt;
&lt;td&gt;RABBIT_CONCURRENCY&lt;/td&gt;
&lt;td&gt;并发消费者数量，默认为1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.connection-timeout&lt;/td&gt;
&lt;td&gt;RABBIT_CONNECTION_TIMEOUT&lt;/td&gt;
&lt;td&gt;建立连接时的超时时间，默认为 60000毫秒，即 1 分钟&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.collector.rabbitmq.queue&lt;/td&gt;
&lt;td&gt;RABBIT_QUEUE&lt;/td&gt;
&lt;td&gt;从中获取 span 信息的队列，默认为 zipkin&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;比如，通过以下命令启动：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;RABBIT_ADDRESSES=localhost java -jar zipkin.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的命令等同于一下的命令：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;java -jar zipkin.jar --zipkin.collector.rabbitmq.addressed=localhost
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用上面的2条命令中的任何一种方式重新启动zipkin-server程序，并重新启动eureka-client、eureka-server、eureka-client-feign，动完成后在浏览器上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，就可以看到通过Http方式发送链路数据一样的接口。&lt;/p&gt;
&lt;h3 id=&quot;自定义tag&quot;&gt;自定义Tag&lt;/h3&gt;
&lt;p&gt;在页面上可以查看每个请求的traceId，每个trace又包含若干的span，每个span又包含了很多的tag，自定义tag可以通过Tracer这个类来自定义。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@Autowired
Tracer tracer;

 @GetMapping(&quot;/hi&quot;)
    public String home(@RequestParam String name) {
        tracer.currentSpan().tag(&quot;name&quot;,&quot;forezp&quot;);
        return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将链路数据存储在mysql数据库中&quot;&gt;将链路数据存储在Mysql数据库中&lt;/h3&gt;
&lt;p&gt;上面的例子是将链路数据存在内存中，只要zipkin-server重启之后，之前的链路数据全部查找不到了，zipkin是支持将链路数据存储在mysql、cassandra、elasticsearch中的。&lt;br/&gt;现在讲解如何将链路数据存储在Mysql数据库中。&lt;br/&gt;首先需要初始化zikin存储在Mysql的数据的scheme，可以在这里查看https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql，具体如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;CREATE TABLE IF NOT EXISTS zipkin_spans (
  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
  `trace_id` BIGINT NOT NULL,
  `id` BIGINT NOT NULL,
  `name` VARCHAR(255) NOT NULL,
  `parent_id` BIGINT,
  `debug` BIT(1),
  `start_ts` BIGINT COMMENT 'Span.timestamp(): epoch micros used for endTs query and to implement TTL',
  `duration` BIGINT COMMENT 'Span.duration(): micros used for minDuration and maxDuration query'
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;

ALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT 'ignore insert on duplicate';
ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT 'for joining with zipkin_annotations';
ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTracesByIds';
ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT 'for getTraces and getSpanNames';
ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT 'for getTraces ordering and range';

CREATE TABLE IF NOT EXISTS zipkin_annotations (
  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
  `trace_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.trace_id',
  `span_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.id',
  `a_key` VARCHAR(255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1',
  `a_value` BLOB COMMENT 'BinaryAnnotation.value(), which must be smaller than 64KB',
  `a_type` INT NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation',
  `a_timestamp` BIGINT COMMENT 'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp',
  `endpoint_ipv4` INT COMMENT 'Null when Binary/Annotation.endpoint is null',
  `endpoint_ipv6` BINARY(16) COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address',
  `endpoint_port` SMALLINT COMMENT 'Null when Binary/Annotation.endpoint is null',
  `endpoint_service_name` VARCHAR(255) COMMENT 'Null when Binary/Annotation.endpoint is null'
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;

ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT 'Ignore insert on duplicate';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT 'for joining with zipkin_spans';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTraces/ByIds';
ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT 'for getTraces and getServiceNames';
ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT 'for dependencies job';

CREATE TABLE IF NOT EXISTS zipkin_dependencies (
  `day` DATE NOT NULL,
  `parent` VARCHAR(255) NOT NULL,
  `child` VARCHAR(255) NOT NULL,
  `call_count` BIGINT,
  `error_count` BIGINT
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;

ALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在数据库中初始化上面的脚本之后，需要做的就是zipkin-server如何连接数据库。zipkin如何连数据库同连接rabbitmq一样。zipkin连接数据库的属性所对应的环境变量如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;zipkin.torage.type&lt;/td&gt;
&lt;td&gt;STORAGE_TYPE&lt;/td&gt;
&lt;td&gt;默认的为mem，即为内存，其他可支持的为cassandra、cassandra3、elasticsearch、mysql&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zipkin.torage.mysql.host&lt;/td&gt;
&lt;td&gt;MYSQL_HOST&lt;/td&gt;
&lt;td&gt;数据库的host，默认localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zipkin.torage.mysql.port&lt;/td&gt;
&lt;td&gt;MYSQL_TCP_PORT&lt;/td&gt;
&lt;td&gt;数据库的端口，默认3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.mysql.username&lt;/td&gt;
&lt;td&gt;MYSQL_USER&lt;/td&gt;
&lt;td&gt;连接数据库的用户名，默认为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.mysql.password&lt;/td&gt;
&lt;td&gt;MYSQL_PASS&lt;/td&gt;
&lt;td&gt;连接数据库的密码，默认为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zipkin.torage.mysql.db&lt;/td&gt;
&lt;td&gt;MYSQL_DB&lt;/td&gt;
&lt;td&gt;zipkin使用的数据库名，默认是zipkin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.mysql.max-active&lt;/td&gt;
&lt;td&gt;MYSQL_MAX_CONNECTIONS&lt;/td&gt;
&lt;td&gt;最大连接数，默认是10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;STORAGE_TYPE=mysql MYSQL_HOST=localhost MYSQL_TCP_PORT=3306 MYSQL_USER=root MYSQL_PASS=123456 MYSQL_DB=zipkin java -jar zipkin.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等同于以下的命令&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;java -jar zipkin.jar --zipkin.torage.type=mysql --zipkin.torage.mysql.host=localhost --zipkin.torage.mysql.port=3306 --zipkin.torage.mysql.username=root --zipkin.torage.mysql.password=123456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上面的命令启动zipkin.jar工程，然后再浏览数上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，可以看到链路数据。这时去数据库查看数据，也是可以看到存储在数据库的链路数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-2bf04cf2f988be53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;微信截图_20190129154520.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时重启应用zipkin.jar，再次在浏览器上访问http://localhost:9411/zipkin/，仍然可以得到之前的结果，证明链路数据存储在数据库中，而不是内存中。&lt;/p&gt;
&lt;h3 id=&quot;将链路数据存在在elasticsearch中&quot;&gt;将链路数据存在在Elasticsearch中&lt;/h3&gt;
&lt;p&gt;zipkin-server支持将链路数据存储在ElasticSearch中。读者需要自行安装ElasticSearch和Kibana，下载地址为https://www. elastic.co/products/elasticsearch。安装完成后启动，其中ElasticSearch的默认端口号为9200，Kibana的默认端口号为5601。&lt;/p&gt;
&lt;p&gt;同理，zipkin连接elasticsearch也是从环境变量中读取的，elasticsearch相关的环境变量和对应的属性如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.hosts&lt;/td&gt;
&lt;td&gt;ES_HOSTS&lt;/td&gt;
&lt;td&gt;ES_HOSTS，默认为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.pipeline&lt;/td&gt;
&lt;td&gt;ES_PIPELINE&lt;/td&gt;
&lt;td&gt;ES_PIPELINE，默认为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.max-requests&lt;/td&gt;
&lt;td&gt;ES_MAX_REQUESTS&lt;/td&gt;
&lt;td&gt;ES_MAX_REQUESTS，默认为64&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.timeout&lt;/td&gt;
&lt;td&gt;ES_TIMEOUT&lt;/td&gt;
&lt;td&gt;ES_TIMEOUT，默认为10s&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.index&lt;/td&gt;
&lt;td&gt;ES_INDEX&lt;/td&gt;
&lt;td&gt;ES_INDEX，默认是zipkin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.date-separator&lt;/td&gt;
&lt;td&gt;ES_DATE_SEPARATOR&lt;/td&gt;
&lt;td&gt;ES_DATE_SEPARATOR，默认为“-”&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.index-shards&lt;/td&gt;
&lt;td&gt;ES_INDEX_SHARDS&lt;/td&gt;
&lt;td&gt;ES_INDEX_SHARDS，默认是5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.index-replicas&lt;/td&gt;
&lt;td&gt;ES_INDEX_REPLICAS&lt;/td&gt;
&lt;td&gt;ES_INDEX_REPLICAS，默认是1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.username&lt;/td&gt;
&lt;td&gt;ES_USERNAME&lt;/td&gt;
&lt;td&gt;ES的用户名，默认为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zipkin.torage.elasticsearch.password&lt;/td&gt;
&lt;td&gt;ES_PASSWORD&lt;/td&gt;
&lt;td&gt;ES的密码，默认是为空&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;采用以下命令启动zipkin-server:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;
STORAGE_TYPE=elasticsearch ES_HOSTS=http://localhost:9200 ES_INDEX=zipkin java -jar zipkin.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;java -jar zipkin.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=http://localhost:9200 --ES_INDEX=zipkin 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;java -jar zipkin.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=http://localhost:9200 --ES_INDEX=zipkin &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;java -jar zipkin.jar --zipkin.torage.type=elasticsearch --zipkin.torage.elasticsearch.hosts=http://localhost:9200 --zipkin.torage.elasticsearch.index=zipkin 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动完成后，然后在浏览数上访问http://localhost:8765/hi，再访问http://localhost:9411/zipkin/，可以看到链路数据。这时链路数据存储在ElasticSearch。&lt;/p&gt;
&lt;h3 id=&quot;在zipkin上展示链路数据&quot;&gt;在zipkin上展示链路数据&lt;/h3&gt;
&lt;p&gt;链路数据存储在ElasticSearch中，ElasticSearch可以和Kibana结合，将链路数据展示在Kibana上。安装完成Kibana后启动，Kibana默认会向本地端口为9200的ElasticSearch读取数据。Kibana默认的端口为5601，访问Kibana的主页http://localhost:5601，其界面如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-a5d8dd5808ea4c77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图的界面中，单击“Management”按钮，然后单击“Add New”，添加一个index。我们将在上节ElasticSearch中写入链路数据的index配置为“zipkin”，那么在界面填写为“zipkin-*”，单击“Create”按钮，界面如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-7773e3a0585784b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完成index后，单击“Discover”，就可以在界面上展示链路数据了，展示界面如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2279594-5e3c149a4c36cc33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片3.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;https://zipkin.io/&lt;/p&gt;
&lt;p&gt;https://github.com/spring-cloud/spring-cloud-sleuth&lt;/p&gt;
&lt;p&gt;https://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.1.0.RELEASE/single/spring-cloud-sleuth.html&lt;/p&gt;
&lt;p&gt;https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml&lt;/p&gt;
&lt;p&gt;https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql&lt;/p&gt;
&lt;p&gt;https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/&lt;/p&gt;
&lt;p&gt;https://segmentfault.com/a/1190000015697673&lt;/p&gt;
&lt;p&gt;elatstic 版本为2.6.x，下载地址：https://www.elastic.co/downloads/past-releases&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/JreeyQi/p/9336692.html&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 03:26:00 +0000</pubDate>
<dc:creator>方志朋的专栏</dc:creator>
<og:description>微服务架构是一个分布式架构，微服务系统按业务划分服务单元，一个微服务系统往往有很多个服务单元。由于服务单元数量众多，业务的复杂性较高，如果出现了错误和异常，很难去定位。主要体现在一个请求可能需要调用很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forezp/p/10364435.html</dc:identifier>
</item>
</channel>
</rss>