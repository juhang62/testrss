<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【马三北漂记】之终章 - 马三小伙儿</title>
<link>http://www.cnblogs.com/msxh/p/11511043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/msxh/p/11511043.html</guid>
<description>&lt;h2&gt;一、引子&lt;/h2&gt;
&lt;p&gt;　　8月初，公司猝不及防的业务线调整让马三萌生了逃离北京的想法，在诸多朋友的一番帮助和马三自己的努力之下，还算比较幸运地拿到了魔都的一家心仪的公司的Offer。今天就要离京了，此刻的我，突然想写点什么，想为近3年的北漂之路留下些文字。&lt;/p&gt;
&lt;h2&gt;二、正文&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;北京！北京！&lt;/strong&gt;最后还是要跟她说再见啦，那个我沉默着拼搏了三年的地方。没有跌宕起伏，也没有惊险刺激……有的只是周末可以走出出租屋晒晒太阳，看看天空中虚无缥缈的薄云，再听听夹裹在高楼大厦间的风声。&lt;br/&gt;　　我时常麻木地伫立在西二旗十字路口的一隅，静静地窥探着一路的车水马龙，如同这个城市里无数个麻木的漂泊旅人一般，普通得仿佛雾霾里的一粒尘埃。&lt;br/&gt;　　有时候我会很羡慕那些刚到北京的人，一如我第一次来北京一样，带着满满的新鲜感与好奇感，贪婪地扑进北京城的怀抱。&lt;br/&gt;　　北京城就像这封闭、拥挤的地铁车厢一般，总有人欢喜着上了车也总有人落寞地下去；总有人开心地坐着也总有人痛苦地站着，总有人寻觅到光明也总有人畏缩在黑暗中。有人在中途就下车了，有人坚持到了终点站，更多的人则是选择换乘了别的线路。&lt;br/&gt;　　离开北京的这天凉风习习，没有倾盆大雨，没有骄阳似火。北京的初秋从来都没有这般让人舒服，就像刚来的时候，借住在东哥的小房子里那样一般的舒坦、安心。&lt;br/&gt;　　每一段故事似乎都会有遗憾，我开始后悔没有去真正看一次升国旗，我开始念叨为何嫌远而没有去八达岭爬过长城，我开始自责为何没有再多跟三五好友叙叙旧，我开始想念北京动物园里俏皮可爱的小动物，我开始埋怨自己为何没有驻足脚步留意北京每个街道的与众不同……&lt;br/&gt;　　&lt;strong&gt;别了，我的大北京：一座最好的城市，一座最坏的城市，北京！北京！&lt;/strong&gt;&lt;br/&gt;　　最后送给自己和各位朋友一句离别赠言：&lt;strong&gt;梦想并不会因为你身处何地而改变，只要你想，任何地方都可以~&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;三、题外话&lt;/h2&gt;
&lt;p&gt;　　文章篇幅很短，只是徘徊在候机大厅有感而发，记录了一些临时的想法，文字上如有不周之处，还望各位海涵~&lt;/p&gt;
&lt;p&gt;　　PS：各位读者，《马三北漂记》终于要在第三季和大家说再见了，感谢各位看官老爷们长久以来的一路陪伴。&lt;/p&gt;
&lt;p&gt;　　不久之后大家将会迎来崭新故事《马小三勇闯上海滩》，这将会是一条全新的故事线，各位敬请期待叭~&lt;/p&gt;



&lt;p&gt;如果觉得本篇博客对您有帮助，可以扫码小小地鼓励下马三，马三会写出更多的好文章，支持微信和支付宝哟！&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/798142/201807/798142-20180728152859302-1956272137.png&quot; alt=&quot;&quot; width=&quot;193&quot; height=&quot;264&quot;/&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/798142/201807/798142-20180728152846340-593077989.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;

&lt;p&gt;作者：马三小伙儿&lt;br/&gt;出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 【马三北漂记】之终章&quot; href=&quot;https://www.cnblogs.com/msxh/p/11511043.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/msxh/p/11511043.html&lt;/a&gt; &lt;br/&gt;请尊重别人的劳动成果，让分享成为一种美德，欢迎转载。另外，文章在表述和代码方面如有不妥之处，欢迎批评指正。留下你的脚印，欢迎评论！&lt;/p&gt;
</description>
<pubDate>Tue, 17 Sep 2019 00:27:00 +0000</pubDate>
<dc:creator>马三小伙儿</dc:creator>
<og:description>一、引子 8月初，公司猝不及防的业务线调整让马三萌生了逃离北京的想法，在诸多朋友的一番帮助和马三自己的努力之下，还算比较幸运地拿到了魔都的一家心仪的公司的Offer。今天就要离京了，此刻的我，突然想写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/msxh/p/11511043.html</dc:identifier>
</item>
<item>
<title>可见性有序性，Happens-before来搞定 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11531389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11531389.html</guid>
<description>[unable to retrieve full-text content]写在前面 上一篇文章 &quot;并发 Bug 之源有三，请睁大眼睛看清它们&quot; 谈到了 三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug 为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题 编译器/处理器 优化 ( Java代码在编译后会变成 Java 字节码, </description>
<pubDate>Tue, 17 Sep 2019 00:14:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11531389.html</dc:identifier>
</item>
<item>
<title>golang开发:类库篇(五)go测试工具goconvey的使用 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/11531328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/11531328.html</guid>
<description>&lt;h3 id=&quot;为什么要使用goconvey测试程序&quot;&gt;为什么要使用goconvey测试程序&lt;/h3&gt;
&lt;p&gt;goconvey 集成go test，go test 无缝接入。管理运行测试用例，而且提供了丰富的函数断言、非常友好的WEB界面，直观的查看测试结果。&lt;br/&gt;如果没有goconvey的话，编写一个测试结果，首先运行被测试函数，然后判断被测试函数的运行结果，各种if判断，各种输出提示信息，而且回归测试也比较麻烦。但是如果使用了goconvey这些都就变得无比的简单。&lt;br/&gt;还是看些使用代码比较简单明了。&lt;/p&gt;
&lt;h3 id=&quot;怎么使用goconvey测试程序&quot;&gt;怎么使用goconvey测试程序&lt;/h3&gt;
&lt;p&gt;第一步当然是安装goconvey&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go get github.com/smartystreets/goconvey&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下被测试的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type Student struct {
    Num int
    Name string

    Chinaese int
    English int
    Math int
}

func NewStudent(num int, name string) (*Student,error) {
    if num &amp;lt; 1 || len(name) &amp;lt; 1 {
        return nil,fmt.Errorf(&quot;num name empty&quot;)
    }
    stu := new(Student)
    stu.Num = num
    stu.Name = name
    return stu,nil
}

func (this *Student) GetAve() (int,error) {
    score := this.Chinaese + this.English + this.Math
    if score == 0 {
        return 0,fmt.Errorf(&quot;score is 0&quot;)
    }
    return score/3,nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要看下goconvey的测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;testing&quot;
    . &quot;github.com/smartystreets/goconvey/convey&quot;
)

func TestNew(t *testing.T) {
    Convey(&quot;start test new&quot;, t, func() {
        stu,err := NewStudent(0,&quot;&quot;)
        Convey(&quot;have error&quot;, func() {
            So(err, ShouldBeError)
        })
        Convey(&quot;stu is nil&quot;, func() {
            So(stu, ShouldBeNil)
        })
    })
}

func TestScore(t *testing.T) {
    stu,_ := NewStudent(1,&quot;test&quot;)
    Convey(&quot;if error&quot;, t, func() {
        _,err := stu.GetAve()
        Convey(&quot;have error&quot;, func() {
            So(err, ShouldBeError)
        })
    })

    Convey(&quot;normal&quot;, t, func() {
        stu.Math = 60
        stu.Chinaese = 70
        stu.English = 80
        score,err := stu.GetAve()
        Convey(&quot;have error&quot;, func() {
            So(err, ShouldBeError)
        })
        Convey(&quot;score &amp;gt; 60&quot;, func() {
            So(score, ShouldBeGreaterThan, 60)
        })
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入到test代码目录，执行 go test&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;=== RUN   TestNew

  start test new
    have error ✔
    stu is nil ✔


2 total assertions

--- PASS: TestNew (0.00s)
=== RUN   TestScore

  if error
    have error ✔


3 total assertions


  normal
    have error ✘
    score &amp;gt; 60 ✔


Failures:

  * /data/www/go/src/test/student_test.go
  Line 35:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实命令行显示的是有颜色标识的。期望出现的结果都会打上对勾，如果期望出现而没有出现的都会打上叉。&lt;br/&gt;还有更好玩的WEB界面。进入的test代码的目录，然后执行 goconvey 会打开一个WEB界面，更加友好的标识出了测试的结果，测试了多少次，有几个通过，几个失败，一目了然。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190824222653169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaWZlaXhpYW5nMjgzNQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;其实使用特别简单&lt;br/&gt;引入类库,启动Convey函数，剩下的就是调用So各种断言各种比较&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;testing&quot;
    . &quot;github.com/smartystreets/goconvey/convey&quot;
)
Convey(&quot;desc&quot;, t, func() {
So(var, function）
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本平常开发中的比较函数基本都有，看下比较的函数列表，看着貌似都涵盖了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Convey(&quot;Equality assertions should be accessible&quot;, t, func() {
        thing1a := thing{a: &quot;asdf&quot;}
        thing1b := thing{a: &quot;asdf&quot;}
        thing2 := thing{a: &quot;qwer&quot;}

        So(1, ShouldEqual, 1)
        So(1, ShouldNotEqual, 2)
        So(1, ShouldAlmostEqual, 1.000000000000001)
        So(1, ShouldNotAlmostEqual, 2, 0.5)
        So(thing1a, ShouldResemble, thing1b)
        So(thing1a, ShouldNotResemble, thing2)
        So(&amp;amp;thing1a, ShouldPointTo, &amp;amp;thing1a)
        So(&amp;amp;thing1a, ShouldNotPointTo, &amp;amp;thing1b)
        So(nil, ShouldBeNil)
        So(1, ShouldNotBeNil)
        So(true, ShouldBeTrue)
        So(false, ShouldBeFalse)
        So(0, ShouldBeZeroValue)
        So(1, ShouldNotBeZeroValue)
    })

    Convey(&quot;Numeric comparison assertions should be accessible&quot;, t, func() {
        So(1, ShouldBeGreaterThan, 0)
        So(1, ShouldBeGreaterThanOrEqualTo, 1)
        So(1, ShouldBeLessThan, 2)
        So(1, ShouldBeLessThanOrEqualTo, 1)
        So(1, ShouldBeBetween, 0, 2)
        So(1, ShouldNotBeBetween, 2, 4)
        So(1, ShouldBeBetweenOrEqual, 1, 2)
        So(1, ShouldNotBeBetweenOrEqual, 2, 4)
    })

    Convey(&quot;Container assertions should be accessible&quot;, t, func() {
        So([]int{1, 2, 3}, ShouldContain, 2)
        So([]int{1, 2, 3}, ShouldNotContain, 4)
        So(map[int]int{1: 1, 2: 2, 3: 3}, ShouldContainKey, 2)
        So(map[int]int{1: 1, 2: 2, 3: 3}, ShouldNotContainKey, 4)
        So(1, ShouldBeIn, []int{1, 2, 3})
        So(4, ShouldNotBeIn, []int{1, 2, 3})
        So([]int{}, ShouldBeEmpty)
        So([]int{1}, ShouldNotBeEmpty)
        So([]int{1, 2}, ShouldHaveLength, 2)
    })

    Convey(&quot;String assertions should be accessible&quot;, t, func() {
        So(&quot;asdf&quot;, ShouldStartWith, &quot;a&quot;)
        So(&quot;asdf&quot;, ShouldNotStartWith, &quot;z&quot;)
        So(&quot;asdf&quot;, ShouldEndWith, &quot;df&quot;)
        So(&quot;asdf&quot;, ShouldNotEndWith, &quot;as&quot;)
        So(&quot;&quot;, ShouldBeBlank)
        So(&quot;asdf&quot;, ShouldNotBeBlank)
        So(&quot;asdf&quot;, ShouldContainSubstring, &quot;sd&quot;)
        So(&quot;asdf&quot;, ShouldNotContainSubstring, &quot;af&quot;)
    })

    Convey(&quot;Panic recovery assertions should be accessible&quot;, t, func() {
        So(panics, ShouldPanic)
        So(func() {}, ShouldNotPanic)
        So(panics, ShouldPanicWith, &quot;Goofy Gophers!&quot;)
        So(panics, ShouldNotPanicWith, &quot;Guileless Gophers!&quot;)
    })

    Convey(&quot;Type-checking assertions should be accessible&quot;, t, func() {

        // NOTE: Values or pointers may be checked.  If a value is passed,
        // it will be cast as a pointer to the value to avoid cases where
        // the struct being tested takes pointer receivers. Go allows values
        // or pointers to be passed as receivers on methods with a value
        // receiver, but only pointers on methods with pointer receivers.
        // See:
        // http://golang.org/doc/effective_go.html#pointers_vs_values
        // http://golang.org/doc/effective_go.html#blank_implements
        // http://blog.golang.org/laws-of-reflection

        So(1, ShouldHaveSameTypeAs, 0)
        So(1, ShouldNotHaveSameTypeAs, &quot;1&quot;)

        So(bytes.NewBufferString(&quot;&quot;), ShouldImplement, (*io.Reader)(nil))
        So(&quot;string&quot;, ShouldNotImplement, (*io.Reader)(nil))
    })

    Convey(&quot;Time assertions should be accessible&quot;, t, func() {
        january1, _ := time.Parse(timeLayout, &quot;2013-01-01 00:00&quot;)
        january2, _ := time.Parse(timeLayout, &quot;2013-01-02 00:00&quot;)
        january3, _ := time.Parse(timeLayout, &quot;2013-01-03 00:00&quot;)
        january4, _ := time.Parse(timeLayout, &quot;2013-01-04 00:00&quot;)
        january5, _ := time.Parse(timeLayout, &quot;2013-01-05 00:00&quot;)
        oneDay, _ := time.ParseDuration(&quot;24h0m0s&quot;)

        So(january1, ShouldHappenBefore, january4)
        So(january1, ShouldHappenOnOrBefore, january1)
        So(january2, ShouldHappenAfter, january1)
        So(january2, ShouldHappenOnOrAfter, january2)
        So(january3, ShouldHappenBetween, january2, january5)
        So(january3, ShouldHappenOnOrBetween, january3, january5)
        So(january1, ShouldNotHappenOnOrBetween, january2, january5)
        So(january2, ShouldHappenWithin, oneDay, january3)
        So(january5, ShouldNotHappenWithin, oneDay, january1)
        So([]time.Time{january1, january2}, ShouldBeChronological)
    })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别实用的一个测试类库，养成写完代码使用goconvey做测试的好习惯，也顺便覆盖下使用方法和案例，定能让开发事半功倍，减少Bug率。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Sep 2019 23:18:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>为什么要使用goconvey测试程序 goconvey 集成go test，go test 无缝接入。管理运行测试用例，而且提供了丰富的函数断言、非常友好的WEB界面，直观的查看测试结果。 如果没有g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/11531328.html</dc:identifier>
</item>
<item>
<title>Java多线程（十三）：线程池 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/11525301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/11525301.html</guid>
<description>&lt;h2 id=&quot;线程池类结构&quot;&gt;线程池类结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201909/1201453-20190916133239607-472634123.png&quot;/&gt;&lt;br/&gt;1.Executor是顶级接口，有一个execute方法。&lt;br/&gt;2.ExecutorService接口提供了管理线程的方法。&lt;br/&gt;3.AbstractExecutorService管理普通线程，SchedulerExecutorService管理定时任务。&lt;/p&gt;
&lt;p&gt;简单的示例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread46 {
    public static void main(String[] args)
    {
        long startTime = System.currentTimeMillis();
        final List&amp;lt;Integer&amp;gt; l = new LinkedList&amp;lt;Integer&amp;gt;();
        ThreadPoolExecutor tp = new ThreadPoolExecutor(100, 100, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(20000));
        final Random random = new Random();
        for (int i = 0; i &amp;lt; 20000; i++)
        {
            tp.execute(new Runnable()
            {
                public void run()
                {
                    l.add(random.nextInt());
                }
            });
        }
        tp.shutdown();
        try
        {
            tp.awaitTermination(1, TimeUnit.DAYS);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
        System.out.println(System.currentTimeMillis() - startTime);
        System.out.println(l.size());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre class=&quot;graph&quot;&gt;
&lt;code&gt;52
19919&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;threadpoolexecutor七个参数&quot;&gt;ThreadPoolExecutor七个参数&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.corePoolSize&lt;br/&gt;线程池当前可以存在的线程数量&lt;br/&gt;2.maximumPoolSize&lt;br/&gt;线程池允许的最大线程数量&lt;br/&gt;3.keepAliveTime&lt;br/&gt;当线程数量比corePoolSize大时才会起作用，终止前的空余线程等待的最长时间。&lt;br/&gt;4.unit&lt;br/&gt;keepAliveTime的时间单位&lt;br/&gt;5.workQueue&lt;br/&gt;存储未被执行的任务&lt;br/&gt;6.threadFactory&lt;br/&gt;executor创建新线程时使用的工厂&lt;br/&gt;7.handler&lt;br/&gt;当执行被阻塞时使用handler&lt;/p&gt;
&lt;h2 id=&quot;corepoolsize与maximumpoolsize的关系&quot;&gt;corePoolSize与maximumPoolSize的关系&lt;/h2&gt;
&lt;p&gt;1.池中线程数小于corePoolSize，新任务都不排队而是直接添加新线程。&lt;br/&gt;2.池中线程数大于等于corePoolSize，workQueue未满，将新任务加入workQueue而不是添加新线程。&lt;br/&gt;3.池中线程数大于等于corePoolSize，workQueue已满，但是线程数小于maximumPoolSize，添加新的线程来处理被添加的任务。&lt;br/&gt;4.池中线程数大于等于corePoolSize，workQueue已满，并且线程数大于等于maximumPoolSize，新任务被拒绝，使用handler处理被拒绝的任务。&lt;/p&gt;
&lt;h2 id=&quot;executors&quot;&gt;Executors&lt;/h2&gt;
&lt;h3 id=&quot;newsinglethreadexecutos-单线程线程池&quot;&gt;1.newSingleThreadExecutos() 单线程线程池&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                    threadFactory));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来新任务就排队，workQueue采用了无界队列LinkedBlockingQueue&lt;br/&gt;示例代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread47{
    static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();

    public static void main(String[] args) {
        for(int i =0;i&amp;lt;10;i++) {
            final int index = i;
            singleThreadExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(index);
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre class=&quot;graph&quot;&gt;
&lt;code&gt;0
1
2
3
4
5
6
7
8
9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;newfixedthreadpoolint-nthreads-固定大小线程池&quot;&gt;2.newFixedThreadPool(int nThreads) 固定大小线程池&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;固定大小线程池和单线程线程池类似，可以手动指定线程数量&lt;br/&gt;示例代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread48 {
    public static void main(String[] args) {
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i &amp;lt; 10; i++) {
            final int index = i;

            fixedThreadPool.execute(new Runnable() {

                @Override
                public void run() {
                    try {
                        System.out.println(index);
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre class=&quot;graph&quot;&gt;
&lt;code&gt;0
1
2
3
4
5
6
8
7
9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;newcachedthreadpool-无界线程池&quot;&gt;3.newCachedThreadPool() 无界线程池&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有多少任务来直接执行，线程池最大数量Integer.MAX_VALUE,60s自动回收空闲线程。&lt;br/&gt;示例代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread49 {
    public static void main(String[] args) {
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        for (int i = 0; i &amp;lt; 10; i++) {
            final int index = i;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            cachedThreadPool.execute(new Runnable() {

                @Override
                public void run() {
                    System.out.println(index);
                }
            });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;0
1
2
3
4
5
6
7
8
9&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 16 Sep 2019 17:00:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>线程池类结构 1.Executor是顶级接口，有一个execute方法。 2.ExecutorService接口提供了管理线程的方法。 3.AbstractExecutorService管理普通线程，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Java-Starter/p/11525301.html</dc:identifier>
</item>
<item>
<title>Django-开放静态资源-获取请求携带的数据-pychram连接数据库-修改Django默认数据库-DjangoORM操作--表管理-记录管理-01 - suwanbin</title>
<link>http://www.cnblogs.com/suwanbin/p/11531211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suwanbin/p/11531211.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;django项目就类似于一所大学，各个app 就相当于二级学院&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以登录功能为例走一个django项目（今日内容 引子）&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;你可能会发现，在我们目前的 django 项目中的 html 模板中链入的 css 、js （这里只服务器本地的，CDN等除外）明明路径是对的，请求得到的却是 404 资源不存在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要配置静态文件才能获取静态资源&quot;&gt;为什么要配置静态文件才能获取静态资源&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;用户可以访问的资源，都在 url 中&lt;/p&gt;
&lt;p&gt;​ 只有 url 中开设（配置）相关的资源你才能访问到（不然就可以根据路径把网站源码都拿过去了）&lt;/p&gt;
&lt;p&gt;​ 后端资源一般都需要手动指定是否需要暴露给用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置完之后也只有输入完整的文件路径才能访问到&lt;/strong&gt;（也相对是一种保护措施）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于前端已经写好了的文件，我们只是拿过来使用，那么这些文件都可以称之为 “&lt;strong&gt;静态文件&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;html文件默认全部放在 templates 文件夹下（并且，如果是命令行创建的项目，并不会自带 templates 文件夹，自己创建的就需要去配置文件里配置）&lt;/p&gt;
&lt;h2 id=&quot;常见的静态文件种类&quot;&gt;常见的静态文件种类&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;css&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;js&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iamge (图片)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;bootstrap、fontawesome等前端框架，已经写好了的&lt;/p&gt;
&lt;p&gt;​ bootstrap-3.3.7-dist，bootstrap 是依赖于 jquery的，所以在导bootstrap 之前要先导入 jquery&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何配置来开启访问权限&quot;&gt;如何配置来开启访问权限&lt;/h2&gt;
&lt;p&gt;默认的 django 项目 是没有 static 这个文件的，需要自己&lt;strong&gt;手动创建 static 文件夹，然后需要去 settings.py 文件配置&lt;/strong&gt; static 静态资源相关&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# ... 差不多在 settings.py 文件的最下面
STATIC_URL = '/static/'  # 接口前缀（跟请求路径相关）
# 只要你想访问静态文件中的资源，路径就必须以 /static/ 开头
# STATIC_URL = '/xxx/'  # 引用静态文件资源的地方要改成 /xxx/....

# 下面这个是要手动配置的，手动将所有的静态资源文件暴露给用户
STATICFILES_DIRS = [  # 跟实际文件的查找位置相关
    # 这里可以配置很多个，就类似于操作系统环境变量的查找，依次去文件夹里找
    os.path.join(BASE_DIR, &quot;static&quot;),  # 真正的文件夹路径
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建完 static文件夹后，一般还会再在里面手动创建三个文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;css 放当前网站所有的 样式 文件（自己写的）&lt;/li&gt;
&lt;li&gt;js 放当前网站所有的 js 文件（自己写的）&lt;/li&gt;
&lt;li&gt;image 放当前网站所有的 图片 文件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;禁用浏览器缓存&quot;&gt;禁用浏览器缓存&lt;/h2&gt;
&lt;p&gt;写 django 项目最好禁用掉浏览器缓存，不然可能写的代码页面上缓存看不到效果、变化（资源加载地址等等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917003958703-1651555297.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004020149-2011148123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要开着 F12开发者工具查看&lt;/strong&gt; &lt;code&gt;*****&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004036903-453488059.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;django的自动重启机制热启动&quot;&gt;django的自动重启机制（热启动）&lt;/h2&gt;
&lt;p&gt;实时监测文件代码变化，只要有变化，就会自动重启，可能代码还没有写完就会自动报错（如果有语法错误可能不会自动重启，遇到逻辑错误就会重启）&lt;/p&gt;
&lt;h2 id=&quot;静态文件接口动态解析&quot;&gt;静态文件接口动态解析&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你的产品经理要让你上1000个静态资源的前缀改了，再改回来，总之就是改来改去，怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;这个一般是结合 static 静态文件配置来用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用静态文件接口动态解析&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;...html代码（这一块一般在 head 标签里引用）
{% load static %}  &amp;lt;-- 开启静态文件接口动态解析 --&amp;gt;

&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'bootstrap-3.3.7-dist/css/bootstrap.min.css' %}&quot;&amp;gt;
&amp;lt;script src=&quot;{% static 'bootstrap-3.3.7-dist/js/bootstrap.min.js' %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
...html代码&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;利用-form-表单默认的-get-请求携带&quot;&gt;利用 form 表单默认的 get 请求携带&lt;/h2&gt;
&lt;p&gt;form 表单提交方式默认是 &lt;strong&gt;get 请求&lt;/strong&gt;，携带数据的方式是 &lt;strong&gt;url 问号后面跟数据&lt;/strong&gt;（浏览器地址栏直接拼接也是一样的，本质都是发送一个请求过去，数据都封装成了请求的数据格式）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?username=jason&amp;amp;password=123&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;form-表单改用-post-请求提交数据&quot;&gt;form 表单改用 post 请求提交数据&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;把html模版中 form 表单的 method 改成 post（method=‘post’）&lt;/li&gt;
&lt;li&gt;去 settings.py 里 把 CSRF 这个中间件禁用掉&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004057571-140842784.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾action提交地址的三种写法&quot;&gt;回顾：action提交地址的三种写法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;不写的情况下 默认往当前地址提交(url)&lt;/li&gt;
&lt;li&gt;还可以写后缀/index/ (django项目常用这种)&lt;/li&gt;
&lt;li&gt;还可以写全路径&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码区分请求方式&quot;&gt;代码区分请求方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;request.method&lt;/code&gt; 能够获取前端请求方式（并且是全大写的字符串 POST、GET）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test_request_way(request):
    print(request.method, type(request.method))
    # GET &amp;lt;class 'str'&amp;gt;  # 直接浏览器敲 http://127.0.0.1:8000/test_request_way/ 的方绘制
    return HttpResponse('alallala')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;推荐写法&quot;&gt;推荐写法&lt;/h3&gt;
&lt;p&gt;可以根据这个来判断请求方式，对于不同的请求方式作出不同的处理&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def del_user(request):
    if request. method == 'POST':
        # post 请求的逻辑处理
        return HttpResponse('这是一个 POST 请求！')
    # get 请求的逻辑处理（如果是 post，上面就已经return 了，不会执行到这里）
    return HttpResponse('这是一个 GET 请求！')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;WSGI帮忙封装了 request 等，也经过了 Django后端，才有了request 这个对象（请求相关内容 全在 environ 里面）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004125293-1327893516.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GET、POST&lt;/p&gt;
&lt;h2 id=&quot;request.post&quot;&gt;request.POST&lt;/h2&gt;
&lt;p&gt;获取前端表单 POST 提交的所有数据（就类似于一个大字典）&lt;/p&gt;
&lt;h3 id=&quot;取数据&quot;&gt;取数据&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.POST.get('username')  # 虽然value是一一个列表但是默认只取列表最后一个元素
password = request.POST['password']  # ---&amp;gt;强烈不建议你使用中括号的形式取值，不存在会直接报错

# 如果想直接把列表全部拿出来 --&amp;gt;  request.POST.getlist('hobby')  # 获取用户爱好、下拉框的选项&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004137406-1510648046.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;request.get&quot;&gt;request.GET&lt;/h2&gt;
&lt;p&gt;获取前端 GET 提交的所有数据（就类似于一个大字典）&lt;/p&gt;
&lt;h3 id=&quot;取数据-1&quot;&gt;取数据&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.GET.get('username')  # 虽然value是一一个列表但是默认只取列表最后一个元素
# 如果没有 get 请求携带的数据，就是一个空字典

password = request.GET['password']  #  ---&amp;gt;强烈不建议你使用中括号的形式取值，不存在会直接报错

# 如果想直接把列表全部拿出来 --&amp;gt;  request.GET.getlist('hobby')  # 获取用户爱好、下拉框的选项&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004150701-1136352641.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作安装插件&quot;&gt;准备工作，安装插件&lt;/h2&gt;
&lt;p&gt;然后&lt;strong&gt;安装一下插件（ downloads...）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004204803-1822924054.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置连接信息&quot;&gt;配置连接信息&lt;/h2&gt;
&lt;p&gt;一定要注意选择那个 MySQL for 5.1（mysql 版本不高的时候），就两个选项反正不行换一个试试嘛&lt;/p&gt;
&lt;p&gt;不然 Test Connection 可能会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004221664-1407896069.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;图形页面基本操作&quot;&gt;图形页面基本操作&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不是重点，鼠标悬浮上去都有提示，自己看吧。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;过滤多余的字符编码之类的&quot;&gt;过滤多余的字符编码之类的？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004242134-284212240.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;不显示数据表&quot;&gt;不显示数据表？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004255312-673105448.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;django 默认使用的是自带的 sqlite 数据库（一种小型的做测试用的数据库）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要让 django 项目应用其他数据库（mysql），需要做如下两步配置&lt;/p&gt;
&lt;h2 id=&quot;在-settings.py-里面配置数据库连接信息&quot;&gt;在 settings.py 里面配置数据库连接信息&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;配置的时候 key 必须&lt;strong&gt;全大写&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;... 省略一堆 配置信息

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 直接把原来的 sqlite3 改成 mysql
        # mysql 相关配置信息
        'HOST': '127.0.0.1',
        'PORT': 3306,
        'USER': 'root',
        'PASSWORD': '000000',
        'NAME': 'day51',  # 数据库名
        'CHARSET': 'utf8'
    }
}

... 其他配置信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指定数据库软件&quot;&gt;指定数据库“软件”？&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;项目名下&lt;/strong&gt;的 &lt;code&gt;__init__.py&lt;/code&gt; 文件&lt;strong&gt;或者是应用名文件下&lt;/strong&gt;的 &lt;code&gt;__init__.py&lt;/code&gt; 文件下加入一段代码（指定使用的数据库&lt;strong&gt;软件？&lt;/strong&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;django 默认用 MySQLdb 连数据库的（需要自己引入，MySQLdb 比较老了，兼容性也不太好，所以要自己指定）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pymysql

pymysql.install_as_MySQLdb()  # 把 pymysql 装成 MySQLdb 或者 取别名成 MySQLdb ?
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5.5090909090909&quot;&gt;
&lt;p&gt;跟之前 &lt;a href=&quot;https://www.cnblogs.com/suwanbin/p/11417062.html&quot;&gt;手撸ORM&lt;/a&gt; 核心思路一样，只不过这个更加强大而已（强大不知道多少倍去了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;关系映射：
    表                   ---&amp;gt; 类
    一条条记录            ---&amp;gt; 对象
    字段对应的值          ---&amp;gt; 对象的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在models.py-里创表模型类&quot;&gt;在models.py 里创表模型类&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;django 会默认给你的表创建一个名为 id 的主键字段，所以可以不写这个 id 主键&lt;/p&gt;
&lt;p&gt;​ 但如果不是名为 id (是 s_id) 那还是得自己写，一旦你已经指定了主键字段 那么 django 就不会主动再给你创建了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CharField 必须指定 max_length 参数，不指定会报错&lt;/li&gt;
&lt;li&gt;字段修改的注意点（下面有展开介绍）&lt;/li&gt;
&lt;li&gt;其他注意点 ...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;app01/models.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.db import models


# Create your models here.
class User(models.Model):
    # 将id字段设置为User表主键字段  在django orm中 你可以不写主键字典  django会默认给你的表创建一个名为id的主键字段
    # id = models.AutoField(primary_key=True)  # 一旦你自己指定了主键字段 那么django就不会自动再帮你创建了
    username = models.CharField(max_length=32)  # username varchar(32)   CharField必须要指定max_length参数
    # password = models.IntegerField()  # password int
    password = models.CharField(max_length=64)

    # addr = models.CharField(max_length=32,default='China')  # default该字段默认值
    # age = models.IntegerField(null=True)  # 该字段允许为空

    def __str__(self):  # 重写了对象的 __str__ 方法，这样后面打印对象的时候就是这个字符串了
        return '我是user表中的对象:%s' % self.username
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建表修改表--数据库迁移命令同步到数据库&quot;&gt;创建表、修改表--数据库迁移命令（同步到数据库）&lt;/h2&gt;
&lt;h3 id=&quot;python3-manage.py-makemigrations-记录数据库迁移&quot;&gt;&lt;code&gt;python3 manage.py makemigrations&lt;/code&gt; 记录数据库迁移&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;仅仅是在 migrations 文件夹中 记录数据库的修改，并不会直接操作数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 在当前 app 的 migration 文件夹下会多出一个 .py 文件（记录数据库更改）&lt;/p&gt;
&lt;h3 id=&quot;python3-manage.py-migrate-将数据库修改记录migrations-中的记录真正同步到数据库&quot;&gt;&lt;code&gt;python3 manage.py migrate&lt;/code&gt; 将数据库修改记录（migrations 中的记录）&lt;strong&gt;真正同步到数据库&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​ 要等一会儿（第一次执行数据库迁移（还是同步啊？没试）命令会自动创建一堆表（django需要依赖的表），后续就是更新多出来的这几张表的记录了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004312716-1168588645.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简便写法&quot;&gt;简便写法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004334383-720261871.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里写会有提示，但&lt;strong&gt;还是要会自己完整写， 万一面试让手写呢？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;makemigrations-记录数据库迁移&quot;&gt;&lt;code&gt;makemigrations&lt;/code&gt; 记录数据库迁移&lt;/h3&gt;
&lt;p&gt;会产生类似如下的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;app01/migrations/0008_auto_20190916_2358.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# Generated by Django 1.11.11 on 2019-09-16 23:58
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('app01', '0007_remove_user_addr'),
    ]

    operations = [
        migrations.AlterField(
            model_name='user',
            name='password',
            field=models.IntegerField(),
        ),
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首次创建表时（写模型类时）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;app01/migrations/0001_initial.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
# Generated by Django 1.11.11 on 2019-09-16 04:29
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username', models.CharField(max_length=32)),
                ('password', models.IntegerField()),
            ],
        ),
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;migrate-同步到数据库&quot;&gt;&lt;code&gt;migrate&lt;/code&gt; 同步到数据库&lt;/h3&gt;
&lt;p&gt;新增或者更新新出的那些 表的记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004348234-184434480.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;只要动了models 中跟&lt;strong&gt;数据库相关的代码&lt;/strong&gt;，就&lt;strong&gt;必须重新执行&lt;/strong&gt;上面的两条命令，缺一不可&lt;/p&gt;
&lt;h3 id=&quot;特殊点--表名会自动加上模块的前缀&quot;&gt;特殊点--表名会自动加上模块的前缀&lt;/h3&gt;
&lt;p&gt;自动加前缀，可以方便协同开发，解耦合，合在一起就行了（那大家都创 app01 呢？）&lt;/p&gt;
&lt;h2 id=&quot;表字段的增删改&quot;&gt;表字段的增删改&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;改完后必须执行数据库迁移的那两条命令&lt;/p&gt;
&lt;p&gt;而且&lt;strong&gt;一般也不会让你去动表结构&lt;/strong&gt;，表是在开发之前就要定下来的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;增加表字段&quot;&gt;增加表字段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当表里已经有记录时&lt;/strong&gt;，后续还要想添加字段，需要&lt;u&gt;指定默认值 或者 允许新增字段为空&lt;/u&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1.给新增的字段设置默认值
    addr = models.CharField(max_length=32,default='China')  # default该字段默认值

2.给新增的字段设置成可以为空
    age = models.IntegerField(null=True)  # 该字段允许为空&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当没有记录 或者 表还未被创建时&lt;/strong&gt;，则不会有上述问题&lt;/p&gt;
&lt;h3 id=&quot;删除表字段&quot;&gt;删除表字段&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;直接在表模型类里 加注释 / 删除&lt;/li&gt;
&lt;li&gt;重新执行两条命令即可&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;强调！：执行完之后，表中该字段所对应的所有数据全部清空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ ---》 没事儿别瞎注释！或者删除（这不仅仅是python代码，还牵连着&lt;strong&gt;数据库&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;并且一般也不会真正意义上的删除（除非设计不合理）&lt;/p&gt;
&lt;h3 id=&quot;改字段&quot;&gt;改字段&lt;/h3&gt;
&lt;p&gt;结合新增字段和删除字段（小推测，未实践）&lt;/p&gt;
&lt;h2 id=&quot;数据的增删改查orm&quot;&gt;数据的增删改查（ORM）&lt;/h2&gt;
&lt;p&gt;导入 models 里面的表&lt;/p&gt;
&lt;p&gt;查数据（跟前面手动封装的一样）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from app01 import models  # ORM操作需要使用 models 类中的名字&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查记录&quot;&gt;查记录&lt;/h3&gt;
&lt;h4 id=&quot;get拿到一个对象对象没有会报错不推荐&quot;&gt;get（拿到一个对象，对象没有会报错，不推荐）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.get(username=username, 条件2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;f:/markdown_images/day052-Django-02/1568616896305.png&quot; alt=&quot;1568616896305&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;filter拿到列表可以放多个参数条件&quot;&gt;filter（拿到列表，可以放多个参数(条件)）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.filter(username=username, password=password, 条件3)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的是一个列表（QuerySet），里面放的才是一个个的对象&lt;/p&gt;
&lt;p&gt;当查询条件不存在时，&lt;strong&gt;不会报错，只会返回一个空列表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;filter 括号内支持写多个参数，并且&lt;strong&gt;参数之间是 and 关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(res.query)&lt;/code&gt; 可以&lt;strong&gt;打印查询语句&lt;/strong&gt;（只有 &lt;strong&gt;QuerySet 对象才可以直接查看内部对应的 sql 语句&lt;/strong&gt;） &lt;em&gt;orm 暂时做个了解，后面有详解&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;QuerySet 对象你可以把它当成列表操作，索引也可以用索引取，但是不推荐这么做（ QuerySet 只支持整数&lt;u&gt;索引，不支持负数&lt;/u&gt;） 还支持&lt;u&gt;切片操作（也不支持负数&lt;/u&gt;，切出来的结果还是一个 QuerySet 对象）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;QuerySet 封装的方法（个别）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ ..... filter().first() 拿列表中的第一个对象&lt;/p&gt;
&lt;p&gt;​ 空列表不会报错&lt;/p&gt;
&lt;p&gt;不推荐你使用索引取值，一旦没有任何数据，再索引取值会报错，但是如果用 &lt;code&gt;.first()&lt;/code&gt; 虽然内部也是按索引取值，但是没有数据， 也不会报错，返回的是None&lt;/p&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.filter(username=username).first()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;少了 .first() 会报这个错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004407406-354798874.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;all-拿到所有的&quot;&gt;all （拿到所有的）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.all()&lt;/code&gt; 直接拿到 User 表模型类的所有数据，结果是列表套对象&lt;/p&gt;
&lt;h3 id=&quot;增加记录&quot;&gt;增加记录&lt;/h3&gt;
&lt;p&gt;新增对象的两种方式&lt;/p&gt;
&lt;h4 id=&quot;create-方法&quot;&gt;create 方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.create(username=username, password=password)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;create方法能够新增数据并且有一个返回值&lt;br/&gt;返回值就是新增的数据对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;实例化对象调用-.save&quot;&gt;实例化对象调用 .save()&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;...省略一堆代码

user_obj = models.User(username=username, password=password)
user_obj.save()

...省略一堆代码&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除记录&quot;&gt;删除记录&lt;/h3&gt;
&lt;h4 id=&quot;models.user.objects.filter条件.delete&quot;&gt;models.User.objects.filter(条件).delete()&lt;/h4&gt;
&lt;p&gt;html中利用 a 标签的 href 把参数发过去（加一个删除功能）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.filter(条件).delete()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004507321-356817650.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新记录&quot;&gt;更新记录&lt;/h3&gt;
&lt;p&gt;无论是什么请求，request.GET 都能拿到 url 里携带的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1725797/201909/1725797-20190917004524341-1022833183.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总体思路&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;先传过来id

获取记录 重定向到页面让用户修改
获取用户提交过来的新信息，更新数据，重定向到列表页&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;filter条件.updateusernameusername-passwordpassword-批量更新&quot;&gt;.filter(条件).update(username=username, password=password) 批量更新&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;models.User.objects.filter(id=edit_id).update(username=username,password=password)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;.filter 拿到的是一个列表，所以 &lt;code&gt;.filter&lt;/code&gt; 的操作 都是批量操作（如果 .filter 结果列表中有多个数据，那么会一次性全部修改，就类似于 for循环一个个修改）&lt;/p&gt;
&lt;h4 id=&quot;直接-对象.改属性-.save保存&quot;&gt;直接 对象.改属性 .save保存&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;edit_obj.username = username
edit_obj.password = password
edit_obj.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不推荐！&lt;/strong&gt;--&amp;gt; 会从头到尾将所有的字段修改一遍（遍历身上的属性），效率极低&lt;/p&gt;
&lt;h3 id=&quot;用户信息增删改查&quot;&gt;用户信息增删改查&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;先通过 orm 展示所有的数据到前端
    all() 拿所有数据
    模板语法 for 循环

添加新增按钮，能够实现用户的新增操作
    利用 a 标签的 href 直接触发后端的逻辑

添加编辑、删除按钮
    编辑
    删除
        利用 get 请求携带参数的特点，在url的后面跟上对应数据的id值
        request.GET.get()
        
        如果是编辑
            重新渲染一个页面，将编辑对象传递到前端，让用户修改
        如果是删除
            直接利用 filter(条件).delete()
        重定向定位不同的页面&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;与orm相关的代码实现&quot;&gt;与ORM相关的代码实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;app01/views.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.shortcuts import render, HttpResponse, redirect
from app01 import models


# Create your views here.
def login(request):
    # 视图函数针对不同的请求方式 应该有不同的处理逻辑
    # if request.method == 'GET':
    #     print('收到了')
    #     print(request.method)  # 能够获取前端请求方式 并且是全大写的字符串
    #     print(type(request.method))
    #     return render(request,'login.html')
    # elif request.method == 'POST':
    #     # 获取用户输入 做相应的逻辑判断
    #     return HttpResponse(&quot;拿到了 老弟&quot;)
    if request.method == 'POST':
        print(request.POST)  # 获取前端post请求提交过来的数据  就把它当成一个大字典即可
        # &amp;lt;QueryDict: {'username': ['jason', 'zekai'], 'password': ['123']}&amp;gt;
        username = request.POST.get('username')  # 默认取列表最后一个元素
        # password = request.POST['password']  # 不推荐 使用
        password = request.POST.get('password')
        # hobby = request.POST.getlist('hobby')
        # print(username,password,hobby)
        # print(type(username),type(password),type(hobby))
        # 利用orm从数据库获取数据  校验
        # 1.查询数据
        # 1.1 get()
        # user_obj = models.User.objects.get(username=username)  # select * from user where username='jason'
        # &quot;&quot;&quot;
        # get方法 能够直接拿到数据对象本身 但是 当查询条件不存在的时候 会直接报错  所有不推荐使用
        # &quot;&quot;&quot;
        # print(user_obj)
        # print(user_obj.username)
        # print(user_obj.password)
        # 1.2 filter()
        # res = models.User.objects.filter(username=username,password=password)
        &quot;&quot;&quot;
        filter查询出来的结果是一个&quot;列表 列表内放的才是一个个的数据对象本身&quot;
        当查询条件不存在的时候 不会报错 只会返回一个空列表
        filter括号内 支持写多个参数  并且参数与参数之间是and的关系
        &quot;&quot;&quot;
        # print(res.query)  # 只有querySet对象才可以直接点query查看年内部对应的sql语句
        # 1.filter拿到的结果就是一个querySet对象(你现在只需要知道filter拿到的结果就能够点query查看sql语句)
        &quot;&quot;&quot;
        SELECT `app01_user`.`id`, `app01_user`.`username`, `app01_user`.`password` 
        FROM `app01_user` 
        WHERE (`app01_user`.`username` = jason AND `app01_user`.`password` = 123)
        
        &quot;&quot;&quot;
        # print(res)
        # user_obj = res[0:2]
        &quot;&quot;&quot;
        querySet对象 你可以吧它当做列表操作 取值也可以通过索引取(querySet只支持正数索引 不支持负数) 还支持切片操作(切出来的结果还是一个querySet对象)
        但是不推荐你这么做
        &quot;&quot;&quot;
        user_obj = models.User.objects.filter(username=username).first()  # 拿列表中第一个数据对象
        &quot;&quot;&quot;
        不推荐你使用索引取值 原因在于一旦没有任何数据 再索引取值会报错
        但是如果用first虽然内部也是按照索引取值  但是没有数据 也不会报错 返回的是None
        &quot;&quot;&quot;
        # print(user_obj,user_obj.username,user_obj.password)
        if user_obj:
            if user_obj.password == password:
                return redirect('http://www.xiaohuar.com')

        return HttpResponse('用户不存在 ')
    print(request.GET)  # 如果没有get请求携带的数据  就是一个空字典
    print(request.GET.get('username'))
    print(request.GET.getlist('hobby'))
    return render(request, 'login.html')


&quot;&quot;&quot;
http://127.0.0.1:8000/static/bootstrap-3.3.7-dist/css/bootstrap.min.css
&quot;&quot;&quot;


def reg(request):
    if request.method == 'POST':
        username = request.POST.get(&quot;username&quot;)
        password = request.POST.get('password')
        # orm插入数据
        # 1.create()
        # res = models.User.objects.create(username=username,password=password)  # insert into user(username,password) values(username,password)
        # &quot;&quot;&quot;
        # create方法能够新增数据 并且有一个返回值
        # 返回值就是新增的数据对象本身
        # &quot;&quot;&quot;
        # print(res)
        # print(res.username)
        # print(res.password)
        # 2.利用对象
        user_obj = models.User(username=username, password=password)
        user_obj.save()
    return render(request, 'reg.html')


def user_list(request):
    # 将user表中的数据全部查出
    data = models.User.objects.all()  # select * from user
    &quot;&quot;&quot;
    拿到的也是一个querySet对象 
    &quot;&quot;&quot;
    print(data.query)
    return render(request, 'userlist.html', {'user_list': data})


def del_user(request):
    # 根据用户想要删除的数据的id值 取数据库中删除数据
    # 获取到id值
    delete_id = request.GET.get('id')
    # 拿着id去数据库中删除
    models.User.objects.filter(id=delete_id).delete()  # delete from user where id = delete_id;
    return redirect('/userlist/')


def update_user(request):
    # 编辑 是基于已经存在了的数据 进行一个修改
    # 逻辑:获取用户想要修改的数据的主键值  然后去数据库修改数据
    edit_id = request.GET.get('id')
    # 给用户将数据查出来 展示到页面上 让用户自己修改
    edit_obj = models.User.objects.filter(id=edit_id).first()
    # 将编辑对象传递给前端页面

    if request.method == 'POST':
        # 不要关系思维 post请求中也是获取get请求携带的参数
        username = request.POST.get('username')
        password = request.POST.get('password')
        # 更新数据
        # 方式1:
        # models.User.objects.filter(id=edit_id).update(username=username,password=password)
        # update user set username = username,password = password where id = edit_id
        &quot;&quot;&quot;
        filter拿到是一个列表   filter操作其实都是批量操作
        如果filter结果列表中有多个数据 那么会一次性全部修改 
        类似于for循环一个个修改
        
        &quot;&quot;&quot;
        # 方式二(不推荐使用)
        edit_obj.username = username
        edit_obj.password = password
        edit_obj.save()
        &quot;&quot;&quot;
        第二种方式会从头到尾将所有的字段全部修改一遍  效率极低
        &quot;&quot;&quot;
        return redirect('/userlist/')
    return render(request, 'update_user.html', {&quot;edit_obj&quot;: edit_obj})


def test_request_way(request):
    print(request.method, type(request.method))
    # GET &amp;lt;class 'str'&amp;gt;
    return HttpResponse('alallala')
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;--&amp;gt; 暨 django 目录结构再解读&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为了防止后期搞混，不知道代码往哪写，所以最好还是把，每个文件写在哪的搞清楚（app 里面还是项目同名文件夹下？）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;app文件下的&quot;&gt;app文件下的&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;views.py 视图函数/类 一般都是分应用（某个方面）来对应功能（视图函数）的
models.py 数据库模型类，一般还会给模型类加上app的前缀（django设计的是可以分开开发，最后合并，故这里这样做能保证数据表名不重复（那app名字一样呢...））&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目同名文件下的&quot;&gt;项目同名文件下的&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;urls.py 路由配置
settings.py django暴露给用户可以配置的配置信息，这里包含了 app 注册、templates 路径配置、static 静态资源路径配置等&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;app-和-项目同名目录-都可以放的&quot;&gt;app 和 项目同名目录 都可以放的&lt;/h2&gt;
&lt;p&gt;单独拎出来可能记得更深点吧&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__init__.py 前面指定数据库软件的
    import pymysql
    pymysql.install_as_MySQLdb()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目根目录的&quot;&gt;项目根目录的&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;static  静态资源文件夹，要记得改配置（settings.py、html引入的时候用static文件路径动态解析）

templates  模版文件夹，要记得配置（settings.py）

大多通过 manage.py 执行 django 的命令
    --&amp;gt; 这个文件专门用来读取命令行命令，并作出处理&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 16 Sep 2019 16:46:00 +0000</pubDate>
<dc:creator>suwanbin</dc:creator>
<og:description>[TOC] django项目就类似于一所大学，各个app 就相当于二级学院 以登录功能为例走一个django项目（今日内容 引子） 关于静态资源访问 你可能会发现，在我们目前的 django 项目中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suwanbin/p/11531211.html</dc:identifier>
</item>
<item>
<title>人工智能-智能创意平台架构成长之路(四)-丰富多彩的banner图生成解密第一部分--如何做出阿里鹿班一样的banner图 - 张永清</title>
<link>http://www.cnblogs.com/laoqing/p/11530988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoqing/p/11530988.html</guid>
<description>&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11326132.html&quot;&gt;人工智能-智能创意平台架构成长之路(一)--长篇开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11327403.html&quot;&gt;人工智能-智能创意平台架构成长之路(二)--大数据架构篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11364435.html&quot;&gt;人工智能-智能创意平台架构成长之路(三)--机器学习算法工程服务化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11530988.html&quot;&gt;人工智能-智能创意平台架构成长之路(四)-丰富多彩的banner图生成解密第一部分（对标阿里鹿班的设计）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(成长之路序列会包含多篇，笔者作为这个平台的技术经理兼架构，充分讲述其中的迭代心酸之路以及中间遇到的问题和解决方案)&lt;/p&gt;
&lt;p&gt;声明：文章不涉及公司内部技术资料的外泄，涉及的图片都是重画的简易架构图，主要通过架构的演进，讲述分享技术的迭代之路和过程，进行技术交流和探讨。&lt;/p&gt;
&lt;p&gt;我们接着&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11364435.html&quot;&gt;人工智能-智能创意平台架构成长之路(三)--机器学习算法工程服务化&lt;/a&gt;  继续&lt;/p&gt;
&lt;p&gt;我们之前讲了很多都是平台架构的主体设计，应用架构设计以及技术架构的设计，那么现在我们就来分享一下丰富多彩的banner图是怎么生成出来的。&lt;/p&gt;
&lt;p&gt;banner图的生成我们也是不断的进行迭代和优化，这块是最核心的部分，也是最难的部分。我们首先来分享一下我们第一轮中banner图是如何生成出来的。&lt;/p&gt;
&lt;p&gt;一、素材的生成&lt;/p&gt;
&lt;p&gt;banner的生成肯定离不开素材，素材种类很多。&lt;/p&gt;
&lt;p&gt;我们对素材先进行了归类，素材我们分为&lt;/p&gt;
&lt;p&gt;1、psd模板（就是用photoshop设计出来的文件，保存出来后，就是一个psd后缀的文件，这个是我们的核心），并且psd 在photoshop中设计时，也都进行了分层定义（psd里面分多层进行设计的，每一层代表一个图层），方便后面对psd进行解析入库，后面我会分享psd&lt;/p&gt;
&lt;p&gt;解析的代码，早期在阿里的鹿班中，也有psd这么个东西。用户可以自己上传psd（在阿里的鹿班中）。这个一般是设计师来进行设计。&lt;/p&gt;
&lt;p&gt;2、商品图库，商品图库主要是通过维护和爬取的商品图，爬取的商品图我们会进行白底图/透明图检测，然后会分类入库，对于非白底图非透明图的，我们会用算法进行智能抠图，合格的商品图会进入到商品图库中&lt;/p&gt;
&lt;p&gt;3、蒙层库、装饰库等这些都是后面用来对banner进行装饰，会使得banner更加好看。&lt;/p&gt;
&lt;p&gt;4、字体库，这个无用多说，里面都是一些生成banner常用的字体。&lt;/p&gt;
&lt;p&gt;5、爆炸贴一般是一些用来打促销语的素材，比如双11等&lt;/p&gt;
&lt;p&gt;6、文案库里面维护的常用的文案，我们也会通过算法自动来生成文案，在生成banenr的时候。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1200756/201909/1200756-20190916230011731-1426595361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;二、丰富多彩的banner的生成过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1200756/201909/1200756-20190916231005300-1310974399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1、我们允许用户上传自己的商品图，然后我们可以自动对用户的商品进行抠图（对于需要抠图的部分）&lt;/p&gt;
&lt;p&gt;2、用户在选择banner的尺寸后，我们会根据一定的算法去获取可以适用于该尺寸的psd模板&lt;/p&gt;
&lt;p&gt;3、banner在合成的过程中，我们会经历商品图主色提取，然后根据主色去拉取可以适用的素材&lt;/p&gt;
&lt;p&gt;4、获取到素材后，我们会按照每一个图层的主色进行搭配组合，确定哪些组合是符合要求的。&lt;/p&gt;
&lt;p&gt;5、对于背景图，我们会自动进行色系的拓展&lt;/p&gt;
&lt;p&gt;6、文案用户可以选择我们的优秀文案，也可以不选择文案，我们自动给用户适配文案或者自动按照算法生成文案（前提是用户需要告诉我们他们预计需要的风格）&lt;/p&gt;
&lt;p&gt;7、我们使用了opencv来进行来进行图层的拼装，拓展，Opencv在我们第一轮banner的生成中用的非常多。拼装时，图层的顺序在psd中已经有的。  但是大小我们是会自动去适配计算的（不是直接对图片进行拉伸，因为这样肯定会变形）&lt;/p&gt;
&lt;p&gt;8、图片主色的提取，我们都是基于Opencv来做的。&lt;/p&gt;
&lt;p&gt;出来的大致效果就是这样的&lt;/p&gt;
&lt;p&gt;（作者的原创文章，转载须注明出处。原创文章归作者所有，欢迎转载，但是保留版权。对于转载了博主的原创文章，不标注出处的，作者将依法追究版权，请尊重作者的成果。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoqing/p/11530988.html&quot;&gt;人工智能-智能创意平台架构成长之路(四)-丰富多彩的banner图生成解密第一部分（对标阿里鹿班的设计）&lt;/a&gt; 地址：&lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=11530988&quot;&gt;https://i.cnblogs.com/EditPosts.aspx?postid=11530988&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1200756/201908/1200756-20190816165830313-1638701706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、第一轮迭代后的问题分享&lt;/p&gt;
&lt;p&gt;1、部分出来的banner图 布局并不美观，尤其是文案字数的多少，文案的太长可能会需要被截取，不然会影响布局，太多文字可能放不下，或者放下了，字体可能过下，显得不美观。&lt;/p&gt;
&lt;p&gt;2、多行文案的行距问题如何适配进行布局显得最美观&lt;/p&gt;
&lt;p&gt;3、合成出来的效果和原始psd的效果有时候偏差较多。&lt;/p&gt;
&lt;p&gt;这些都是我们后面需要解决的问题。&lt;/p&gt;
&lt;p&gt;四、psd的解析&lt;/p&gt;
&lt;p&gt;psd的解析通过Python和java 都可以实现，以及一些主色提取逻辑，详细组合逻辑，这个后续会分享&lt;/p&gt;
&lt;p&gt;未完待续..........&lt;/p&gt;

</description>
<pubDate>Mon, 16 Sep 2019 15:26:00 +0000</pubDate>
<dc:creator>张永清</dc:creator>
<og:description>人工智能-智能创意平台架构成长之路(一)--长篇开篇 人工智能-智能创意平台架构成长之路(二)--大数据架构篇 人工智能-智能创意平台架构成长之路(三)--机器学习算法工程服务化 人工智能-智能创意平</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/laoqing/p/11530988.html</dc:identifier>
</item>
<item>
<title>让人迷茫的三十岁，从专业技能、行业知识和软实力的人才三角谈起 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/11530864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/11530864.html</guid>
<description>&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;--------我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;\n我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;36:0&amp;quot;],[20,&amp;quot;这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery-block&amp;quot;:&amp;quot;https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail&amp;quot;},&amp;quot;29:1|30:0|3:\&amp;quot;1280\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|7:1|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;242\&amp;quot;|ori-width:\&amp;quot;323\&amp;quot;&amp;quot;],[20,&amp;quot;（手画的） &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1&amp;quot;],[20,&amp;quot;到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;508\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;461\&amp;quot;|ori-width:\&amp;quot;508\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;专业技能&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。 &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;TDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;行业知识&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;软实力&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;总结&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。 &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;\n我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;36:0&amp;quot;],[20,&amp;quot;这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery-block&amp;quot;:&amp;quot;https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail&amp;quot;},&amp;quot;29:1|30:0|3:\&amp;quot;1280\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|7:1|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;242\&amp;quot;|ori-width:\&amp;quot;323\&amp;quot;&amp;quot;],[20,&amp;quot;（手画的） &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1&amp;quot;],[20,&amp;quot;到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;508\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;461\&amp;quot;|ori-width:\&amp;quot;508\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;专业技能&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。 &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;TDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;行业知识&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;软实力&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;总结&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:1|heading:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。 &amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;text-indent:\&amp;quot;1\&amp;quot;&amp;quot;]]&quot;&gt;&lt;img src=&quot;https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail&quot; alt=&quot;&quot; width=&quot;1280&quot; height=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-20597952 ql-align-center&quot; align=&quot;center&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;（手画的）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-center ql-text-indent-1 ql-long-20597952&quot; align=&quot;center&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;&lt;img src=&quot;https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;一、专业技能&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　TDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;二、行业知识&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;三、软实力&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　我把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;四、总结&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;　　无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;---&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;本文版权归原作者和博客园共同拥有。作品采用知识共享署名-非商业性使用-相同方式共享4.0 国际许可协议进行许可。&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201909/191302-20190916230719364-1226790302.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;      本文来自： 溪源 | 长沙.NET技术社区。阅读更多精彩好文，欢迎关注长沙.NET技术社区公众号【DotNET技术圈】。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Sep 2019 15:06:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一、背景 一、背景 这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/11530864.html</dc:identifier>
</item>
<item>
<title>Elasticsearch(7) --- 复合查询 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11529107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11529107.html</guid>
<description>[unable to retrieve full-text content]Elasticsearch(7) 复合查询 复合查询有 ： (布尔查询)、 (提高查询)、 （固定分数查询）、 (最佳匹配查询）、 (函数查询）。 一、bool query(布尔查询) 1、概念 可以理解成通过 将较小的查询组合成较大的查询。 Bool查询语法有以下特点 1. 子查询可以任意顺序出现</description>
<pubDate>Mon, 16 Sep 2019 14:51:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11529107.html</dc:identifier>
</item>
<item>
<title>SpringCloud（三）Ribbon与Feign - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/11530737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/11530737.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上一篇使用了Eureka与Ribbon组件做了最简单的的服务注册与发现，我们知道Eureka是实现服务治理中心的组件，但是上一篇Eureka没有实现集群，这样没有保证到Eureka Server的高可用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;理论上来讲，因为服务消费者本地缓存了服务提供者的地址，即使Eureka Server宕机，也不会影响服务之间的调用，但是一旦新服务上线，已经在缓存在本地的服务提供者不可用了，服务消费者也无法知道，所以保证Eureka Server的高可用还是很有必要的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那我们先来搭建一个Eureka的集群&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一、Eureka集群配置&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;要做集群，我们想到肯定是增加一台服务器，那怎么让服务器之间产生关系，先让他们相互注册，在修改之前，我们为了区分服务器名称，先修改下hosts文件,增加下面一段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0.0.1  eureka1.com 
127.0.0.1  eureka2.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后修改下之前spring-cloud-learn-eureka 项目的配置文件，主要修改的是注册的地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-eureka

server:
  port: 8761
eureka:
  instance:
    hostname: eureka1.com
  client:
    #表示是否将自己注册到Eureka Server，默认为true。
    registerWithEureka: false
    #表示是否从Eureka Server获取注册信息，默认为true。
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://eureka2.com:8762/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们启动此项目，并同时启动服务提供者spring-cloud-learn-provider-dept，这里其实跟之前都没什么区别，服务顺利的注册进去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190916222924088-1586131094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们修改spring-cloud-learn-eureka的配置，即再启动一个eureka server ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-eureka

server:
  port: 8762
eureka:
  instance:
    hostname: eureka2.com
  client:
    #表示是否将自己注册到Eureka Server，默认为true。
    registerWithEureka: false
    #表示是否从Eureka Server获取注册信息，默认为true。
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://eureka1.com:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这是启动的第二台服务器，注册到了第一台服务器中，启动项目，这个时候我们访问：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;http://eureka2.com:8762/&quot;&gt;http://eureka2.com:8762/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190916223032397-599073965.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这个时候我们发现，第二台服务也注册进来了，是因为这两个Eureka服务器互相同步信息，这样就已经完成集群了。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接着实现，这个时候我们停掉eureka1服务，那eureka2中依然有服务，这说明挂掉一台服务器注册服务仍然可用，那我们在想想，如果我们重启服务提供者spring-cloud-learn-provider-dept会发生什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;启动的时候，我们可以看到控制台是会报错误的，因为在spring-cloud-learn-provider-dept我们只向eureka1进行了注册，那此时eureka1停掉之后找不到注册地址，就会报错，但是只是刷新&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://eureka2.com:8762/&quot;&gt;http://eureka2.com:8762/&lt;/a&gt;&lt;span&gt;，我们发现此时服务提供者依然存在，这个是因为的自我保护机制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;如果我们重启eureka2服务，那这个时候就会发现此时spring-cloud-learn-provider-dept 就没有了，这个也很好理解，在启动时两个服务会互相同步消息，而这个时候服务提供者未注册到eureka1，那eureka2启动也是没有效果的，为了解决这个问题，那就让服务提供者分别向两台eureka服务器进行注册：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-provider-dept

server:
  port: 8763

eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka1.com:8761/eureka/,http://eureka2.com:8762/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;二、Eureka与ZooKeeper的比较&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Eureka与ZooKeeper的主要区别在CAP原则的选择上，CAP原则是指的是在一个分布式系统中，&lt;span&gt;&lt;strong&gt;Consistency（一致性）&lt;/strong&gt;&lt;span&gt;、 &lt;span&gt;&lt;strong&gt;Availability（可用性）&lt;/strong&gt;&lt;span&gt;、&lt;span&gt;&lt;strong&gt;Partition tolerance（分区容错性）&lt;/strong&gt;&lt;span&gt;，三者不可兼得（我们常说的鱼和熊掌不可兼得）。CAP 原则也是 NoSQL 数据库的基石。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一致性（Consistency，C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可用性（Availability，A）：在一个分布式系统的集群中一部分节点故障后，该集群是否还能够正常响应客户端的读写请求。（对数据更新具备高可用性）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;分区容错性（Partition tolerance，P）：大多数的分布式系统都分布在多个子网络中，而每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。在一个分布式系统中一般分区容错是无法避免的，因此可以认为 CAP 中的 P 总是成立的。CAP 理论告诉我们，在 C 和 A 之间是无法同时做到。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个时候&lt;span&gt;&lt;strong&gt;Eureka&lt;/strong&gt;&lt;span&gt;选择了 &lt;span&gt;&lt;strong&gt;AP&lt;/strong&gt;&lt;span&gt;，在刚刚的集群配置中,Eureka Server 采用的是Peer to Peer 对等通信。这是一种去中心化的架构（参看：微服务与微服务架构思想与原则），无 master/slave 之分，每一个 Peer 都是对等的。在这种架构风格中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。每个节点都可被视为其他节点的副本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在集群环境中如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点上，当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会在节点间进行复制（replicate To Peer）操作，将请求复制到该 Eureka Server 当前所知的其它所有节点中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当一个新的 Eureka Server 节点启动后，会首先尝试从邻近节点获取所有注册列表信息，并完成初始化。Eureka Server 通过 getEurekaServiceUrls() 方法获取所有的节点，并且会通过心跳契约的方式定期更新。默认情况下，如果 Eureka Server 在一定时间内没有接收到某个服务实例的心跳（默认周期为30秒），Eureka Server 将会注销该实例（默认为90秒，如果某个 eureka.instance.lease-expiration-duration-in-seconds 进行自定义配置）。当 Eureka Server 节点在短时间内丢失过多的心跳时，那么这个节点就会进入自我保护模式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;与 Eureka 有所不同，Zookeeper 在设计时就紧遵CP原则，即任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是 Zookeeper 不能保证每次服务请求都是可达的。从 Zookeeper 的实际应用情况来看，在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了），那么将无法处理该请求。所以说，Zookeeper 不能保证服务可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当然，在大多数分布式环境中，尤其是涉及到数据存储的场景，数据一致性应该是首先被保证的，这也是 Zookeeper 设计紧遵CP原则的另一个原因。但是对于服务发现来说，情况就不太一样了，针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。因为对于服务消费者来说，能消费才是最重要的，消费者虽然拿到可能不正确的服务实例信息后尝试消费一下，也要胜过因为无法获取实例信息而不去消费，导致系统异常要好。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;三、Ribbon介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Ribbon是负责客户端负载均衡的工具，与Nginx的作用类似，负载均衡应该大部分开发都是知道的，不清楚的百度学习一波。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;Ribbon的配置在上一篇中已经给出，实现也是非常的简单，主要看几种负载均衡算法：&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;策略名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;策略描述&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;实现说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18.5&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;BestAvailableRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;选择一个最小的并发请求的server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;AvailabilityFilteringRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;WeightedResponseTimeRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;RetryRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;对选定的负载均衡策略机上重试机制。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;RoundRobinRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;roundRobin方式轮询选择server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;轮询index，选择index对应位置的server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;RandomRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;随机选择一个server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;在index上随机，选择index对应位置的server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;ZoneAvoidanceRule&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;复合判断server所在区域的性能和server的可用性选择server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当想要修改负载均衡的策略时，直接返回IRule实现即可，例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule myRule(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomRule();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;四、Feign&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，并和 Eureka 结合，默认实现了负载均衡的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Feign旨在使编写Java Http客户端变得更容易。前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;来实践感受下：跟之前一样再创建一个项目spring-cloud-learn-consumer-dept-feign,并新建pom.xml文件，手动添加到maven中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-consumer-dept-feign&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-openfeign&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建启动类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerDeptFeignApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConsumerDeptFeignApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.yml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-consumer-dept-feign

server:
  port: 8765

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在就是调用服务的操作，添加一个部门服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@FeignClient(value = &quot;spring-cloud-learn-provider-dept&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DeptService {

    @RequestMapping(value &lt;/span&gt;= &quot;hi&quot;, method =&lt;span&gt; RequestMethod.GET)
    String sayHi(@RequestParam(value &lt;/span&gt;= &quot;message&quot;&lt;span&gt;) String message);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里添加的@FeignClient的注解里面的value属性就是调用服务的名称，而里面的方法的写法与WebMVC的写法很类似，相当于调用服务的方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;然后再创建一个controller，，然后创建方法调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeptController {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptService deptService;

    @RequestMapping(value &lt;/span&gt;= &quot;hi&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHi(@RequestParam String message) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptService.sayHi(message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这个时候编码已经完成，我们只需要启动之前项目中的spring-cloud-learn-eureka与spring-cloud-learn-provider-dept，然后再启动本项目，访问地址：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://localhost:8765/hi?message=HelloFeign&quot;&gt;http://localhost:8765/hi?message=HelloFeign&lt;/a&gt;&lt;span&gt;，这个时候服务就已经生效了：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190916223514003-940927258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;这样就已经完成Feign组件的使用，非常的简单， Feign通过接口的方法调用Rest服务（之前是Ribbon+RestTemplate），该请求发送给Eureka服务器，通过Feign直接找到服务接口，由于在进行服务调用的时候融合了Ribbon技术，所以也支持负载均衡作用。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Sep 2019 14:50:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>上一篇使用了Eureka与Ribbon组件做了最简单的的服务注册与发现，我们知道Eureka是实现服务治理中心的组件，但是上一篇Eureka没有实现集群，这样没有保证到Eureka Server的高可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/11530737.html</dc:identifier>
</item>
<item>
<title>Posix共享内存 - 原野追逐</title>
<link>http://www.cnblogs.com/songhe364826110/p/11530732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songhe364826110/p/11530732.html</guid>
<description>[unable to retrieve full-text content][TOC] 1. 概述 共享内存是可用IPC机制中最快的，一旦共享内存区映射到共享它的进程地址空间： 进程间的数据传递就不再执行需进入内核的系统调用 各个进程向共享内存读写数据往往需要某种形式的同步 这些进程间的同步通常使用Posix有名信号量或无名信号量 对比下面两张图所展示的例子： 不使用共享内</description>
<pubDate>Mon, 16 Sep 2019 14:39:00 +0000</pubDate>
<dc:creator>原野追逐</dc:creator>
<dc:identifier>https://www.cnblogs.com/songhe364826110/p/11530732.html</dc:identifier>
</item>
</channel>
</rss>