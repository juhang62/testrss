<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Web-Security-Learning - hu1ge(micr067)</title>
<link>http://www.cnblogs.com/micr067/p/12945735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/micr067/p/12945735.html</guid>
<description>&lt;h2&gt;sql注入&lt;/h2&gt;
&lt;h3&gt;MySql&lt;/h3&gt;
&lt;h3&gt;MSSQL&lt;/h3&gt;
&lt;h3&gt;PostgreSQL&lt;/h3&gt;
&lt;h3&gt;MongoDB&lt;/h3&gt;
&lt;h3&gt;技巧&lt;/h3&gt;
&lt;h3&gt;工具&lt;/h3&gt;
&lt;h2&gt;XSS&lt;/h2&gt;
&lt;h2&gt;CSRF&lt;/h2&gt;
&lt;h2&gt;其他前端安全&lt;/h2&gt;
&lt;h2&gt;SSRF&lt;/h2&gt;
&lt;h2&gt;XXE&lt;/h2&gt;
&lt;h2&gt;JSONP注入&lt;/h2&gt;
&lt;h2&gt;SSTI&lt;/h2&gt;
&lt;h2&gt;代码执行 / 命令执行&lt;/h2&gt;
&lt;h2&gt;文件包含&lt;/h2&gt;
&lt;h2&gt;文件上传 / 解析漏洞&lt;/h2&gt;
&lt;h2&gt;逻辑漏洞&lt;/h2&gt;
&lt;h2&gt;其他漏洞&lt;/h2&gt;
&lt;h3&gt;RPO(relative path overwrite)&lt;/h3&gt;
&lt;h3&gt;Web Cache&lt;/h3&gt;
&lt;h3&gt;redis&lt;/h3&gt;
&lt;h2&gt;PHP相关&lt;/h2&gt;
&lt;h3&gt;弱类型&lt;/h3&gt;
&lt;h3&gt;随机数问题&lt;/h3&gt;
&lt;h3&gt;伪协议&lt;/h3&gt;
&lt;h3&gt;序列化&lt;/h3&gt;
&lt;h3&gt;php mail header injection&lt;/h3&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;h3&gt;php代码审计&lt;/h3&gt;
&lt;h2&gt;java-Web&lt;/h2&gt;
&lt;h3&gt;反序列&lt;/h3&gt;
&lt;h3&gt;Struct2&lt;/h3&gt;
&lt;h3&gt;java-Web代码审计&lt;/h3&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;h2&gt;python-Web&lt;/h2&gt;
&lt;h2&gt;Node-js&lt;/h2&gt;
&lt;h2&gt;WAF相关&lt;/h2&gt;

&lt;h2&gt;Course&lt;/h2&gt;
&lt;h2&gt;信息收集&lt;/h2&gt;
&lt;h2&gt;渗透&lt;/h2&gt;
&lt;h2&gt;渗透实战&lt;/h2&gt;
&lt;h2&gt;提权&lt;/h2&gt;
&lt;h2&gt;渗透技巧&lt;/h2&gt;
&lt;h2&gt;运维&lt;/h2&gt;
&lt;h2&gt;DDOS&lt;/h2&gt;

&lt;h2&gt;技巧总结&lt;/h2&gt;



&lt;p&gt;文章作者:chybeta&lt;/p&gt;
&lt;p&gt;最近更新日期为：2018/10/31。&lt;br/&gt;项目地址： &lt;a href=&quot;https://github.com/CHYbeta/Web-Security-Learning&quot;&gt;https://github.com/CHYbeta/Web-Security-Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同步更新于： &lt;a href=&quot;https://chybeta.github.io/2017/08/19/Web-Security-Learning/&quot; rel=&quot;nofollow&quot;&gt;chybeta: Web-Security-Learning&lt;/a&gt;&lt;br/&gt;许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。&lt;/p&gt;
</description>
<pubDate>Sun, 24 May 2020 00:27:00 +0000</pubDate>
<dc:creator>hu1ge(micr067)</dc:creator>
<og:description>Web Security sql注入 MySql MySQL False 注入及技巧总结 MySQL 注入攻击与防御 sql注入学习总结 SQL注入防御与绕过的几种姿势 MySQL偏门技巧 mysql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/micr067/p/12945735.html</dc:identifier>
</item>
<item>
<title>去重函数unique，sort，erase的应用 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/12945726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/12945726.html</guid>
<description>&lt;p&gt;&lt;strong&gt;std::unique&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一.总述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　unique函数属于STL中比较常用函数，它的功能是元素去重。即”删除”序列中所有相邻的重复元素(只保留一个)。此处的删除，并不&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是真的删除，而是指重复元素的位置被不重复的元素给占领了。由于它”删除”的是相邻的重复元素，所以在使用unique函数之前，一般都&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会将目标序列进行排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能：对有序的容器重新排列，将第一次出现的元素从前往后排，其他重复出现的元素依次排在后面&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;二.函数原型&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;unique函数的函数原型如下：1.只有两个参数，且参数类型都是迭代器：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;has&quot; name=&quot;code&quot;&gt;
&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;iterator &lt;span class=&quot;hljs-title&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(iterator it_1,iterator it_2)&lt;/span&gt;&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这种类型的unique函数是我们最常用的形式。其中这两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有序的容器：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;table-box&quot;&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;unique处理过的容器：&lt;/p&gt;
&lt;div class=&quot;table-box&quot;&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;unique&lt;/td&gt;
&lt;td&gt;迭代器指向的地址&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;三、去重函数&lt;code&gt;unique&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;头文件：&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;unique&lt;/code&gt;的作用就是&lt;code&gt;&quot;去除&quot;&lt;/code&gt;数组中重复的元素，unique去重的过程是将重复的元素移到容器的后面去，实际上这种说法并不正确，应该是把不重复的元素移到前面来：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;has&quot; name=&quot;code&quot;&gt;
&lt;/pre&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; };&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = unique(a, a + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) - a;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i++)&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;可以看见最后三个元素是：&lt;code&gt;5 8 9&lt;/code&gt;，而重复的数字是&lt;code&gt;1 5 7&lt;/code&gt;，所以网上这种说法：“unique去重的过程是将重复的元素移到容器的后面去”&lt;code&gt;是不对的&lt;/code&gt;。 &lt;br/&gt;上面的&lt;code&gt;n&lt;/code&gt;返回的是&lt;code&gt;7&lt;/code&gt;，它就是：&lt;code&gt;最后一个不重复数字的下标&lt;/code&gt;。 &lt;br/&gt;所以，把上面的&lt;code&gt;for&lt;/code&gt;循环改成：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;has&quot; name=&quot;code&quot;&gt;
&lt;/pre&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;strong&gt;让&lt;code&gt;i &amp;lt; n&lt;/code&gt;就是只输出前面不重复的数字，这样就实现的去重的效果。&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;四、去重函数&lt;code&gt;unique&lt;/code&gt;与排序函数&lt;code&gt;sort&lt;/code&gt;结合&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;  如果先&lt;code&gt;去重&lt;/code&gt;再&lt;code&gt;排序&lt;/code&gt;那么结果就是：去重毫无作用。因为&lt;code&gt;去重&lt;/code&gt;再&lt;code&gt;排序&lt;/code&gt;排序时会把重复的数字又放在了一起，所以要先&lt;code&gt;排序&lt;/code&gt;再&lt;code&gt;去重&lt;/code&gt;。这点应该好理解，这里就提一下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先&lt;code&gt;排序&lt;/code&gt;再&lt;code&gt;去重&lt;/code&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;has&quot; name=&quot;code&quot;&gt;
&lt;/pre&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;algorithm&amp;gt; //sort(), unique()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;functional&amp;gt; //less&amp;lt;int&amp;gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; };&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;sort( a, a + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, less&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;() ); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = unique(a, a + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) - a; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;于是就得到了想要的结果：&lt;code&gt;先把数字排序，再&lt;/code&gt;&lt;code&gt;去掉重复数字。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;五，以上便是去重应用于数组的情况：接下来看一下字符串的情况：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;uniqe()函数是去掉重复的字符。是指两个字符连续出现就只留下一个，其余的就删除。例如:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; string s(&quot;hello,world&quot;);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; string::iterator iterEnd=unique(s.begin(),s.end());     //返回出现重复元素的迭代器位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这代码执行后，s的值为helo,worldd. 只消除连续出现的同样的字符。重点是不连续的不消除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unique函数通常和erase函数一起使用，来达到删除重复元素的目的。(注：此处的删除是真正的删除，即从容器中去除重复的元素，容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;的长度也发生了变换；而单纯的使用unique函数的话，容器的长度并没有发生变化，只是元素的位置发生了变化)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一个就是unqiue()函数删除重复的字符后，字符串长度不变，所以如果字符串删除字符后，后面按照之前的值填上。 所以就是helo,worldd，而不是helo,world；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以就会有一个函数erase()函数存在的必要性了。它可以删除字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s.erase(iterEnd,s.end());      //删除掉重复元素；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行后s的值就是我们想要的helo,world.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果想要只留下一个字符l，只能先排序！！！！让他们挨在一块。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sort()函数是排序字符串字符。 即如果是akjsc,排序后为acjks.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以一般用unique函数的时候都会用到erase(). sort()用到也也比较多。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;六，总结：&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;has&quot; name=&quot;code&quot;&gt;
&lt;/pre&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;algorithm&amp;gt; //sort(), unique()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;functional&amp;gt; //less&amp;lt;int&amp;gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;sjscncmkzmxkz&quot;&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;sort(str.begin(), str.end()); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;::iterator itend = unique(str.begin(), str.end()); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;str.erase(itend, str.end()); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt; };&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;sort(a, a + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, less&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;()); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = unique(a, a + &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) - a; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n1 = distance(a, unique(a, a + n)); &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n1; i++) &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;; &lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;/ol&gt;

</description>
<pubDate>Sun, 24 May 2020 00:21:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>std::unique 一.总述 unique函数属于STL中比较常用函数，它的功能是元素去重。即”删除”序列中所有相邻的重复元素(只保留一个)。此处的删除，并不 是真的删除，而是指重复元素的位置被不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/12945726.html</dc:identifier>
</item>
<item>
<title>CSS实现漂亮的小水球效果 - 星空天宇</title>
<link>http://www.cnblogs.com/AlexanderZhao/p/12945716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AlexanderZhao/p/12945716.html</guid>
<description>&lt;p&gt;先看效果图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020052407513395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdrb25ndGlhbnl1emhhbw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
                &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
                &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
                &amp;lt;title&amp;gt;小水球&amp;lt;/title&amp;gt;
                &amp;lt;style&amp;gt;
                        *{
                                margin:0;
                                padding: 0;
                        }
                        body{
                                height: 100vh;
                                background: linear-gradient(rgb(95,95,250) 10%,rgb(3,3,110));
                        }
                        
                        .main,.wave{
                                width:200px;
                                height:200px;
                                border-radius: 50%;
                                position: absolute;
                                left: 50%;
                                top:50%;
                                transform: translate(-50%,-50%);
                        }
                        .main{
                                border:3px solid darkturquoise;
                                padding: 10px;
                        }
                        .wave{
                                background: darkturquoise;
                                overflow: hidden;
                        }
                        .wave::before{
                                content: &quot;水球&quot;;
                                position: absolute;
                                left: 50%;
                                top: 0px;
                                color: darkturquoise;
                                z-index: 99;
                                transform: translate(-50%,30px);
                                text-transform: uppercase;
                        }
                        .wave::after{
                                content: &quot;&quot;;
                                width: 300px;
                                height: 300px;
                                background: rgba(255,255,255,0.8);
                                position: absolute;
                                left: 50%;
                                top: 0;
                                transform: translate(-50%,-60%);
                                border-radius: 40%;
                                animation: wave 5s linear infinite;
                        }
                        
                        @keyframes wave{
                                100%{
                                        transform: translate(-50%,-60%) rotate(360deg);
                                }
                        }
                &amp;lt;/style&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body&amp;gt;
                &amp;lt;div class=&quot;main&quot;&amp;gt;
                        &amp;lt;div class=&quot;wave&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
        &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.2931034482759&quot;&gt;
&lt;p&gt;参考视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1nV411d7Q2&quot;&gt;https://www.bilibili.com/video/BV1nV411d7Q2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 24 May 2020 00:02:00 +0000</pubDate>
<dc:creator>星空天宇</dc:creator>
<og:description>先看效果图： 代码： 参考视频：https://www.bilibili.com/video/BV1nV411d7Q2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AlexanderZhao/p/12945716.html</dc:identifier>
</item>
<item>
<title>【万字图文-原创】 | 学会Java中的线程池，这一篇也许就够了！ - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12945703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12945703.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/799093/202005/799093-20200524082508581-233911575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;碎碎念&quot;&gt;碎碎念&lt;/h3&gt;
&lt;p&gt;关于JDK源码相关的文章这已经是第四篇了，原创不易，粉丝从几十人到昨天的&lt;code&gt;666&lt;/code&gt;人，真的很感谢之前帮我转发文章的一些朋友们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074813784-1672563259.png&quot; alt=&quot;关注人数.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从16年开始写技术文章，到现在博客园已经发表了&lt;code&gt;222&lt;/code&gt;篇文章，大多数都是原创，共有800多粉丝，基本上每个月都会有文章的产出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074814647-1466626520.png&quot; alt=&quot;博客园信息.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074814914-841821671.png&quot; alt=&quot;博客园文章月份记录.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾这几年以来写作的心路历程，一直都是偷偷的写，偷偷的发，害怕被人知道，怕被人骂文章写的太水（之前心理太脆弱了，哈哈）。后面和cxuan聊过后，他建议我给他投稿试试，于是就有了那一篇的万字的&lt;code&gt;AQS&lt;/code&gt;文章。&lt;/p&gt;
&lt;p&gt;最近也有好多读者加到我的微信，问一些文章中的问题，我也都会认真解答，看到有人阅读我的文章并有所收获，我真的挺欣慰，这就是写作的动力吧。&lt;/p&gt;
&lt;p&gt;帮助别人的同时也是在帮助自己，自己学的技术和理解的内容都是有局限性的。通过写文章结识到了很多朋友，听听别人的分析和见解，我也能学到很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074815435-1011230728.png&quot; alt=&quot;答疑.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次看到博客中有人留言都很激动，也会第一时间去回复。感谢下面的公众号大佬们之前无私的帮助，大家也可以关注一下他们，都是很&lt;code&gt;nice&lt;/code&gt;的大佬：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java建设者、Java团长、程序猿石头、码象全栈、Java3y、JAVA小咖秀、Bella的技术轮子、石杉的架构笔记、武培轩、程序通事&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java中的线程池已经不是什么神秘的技术了，相信在看的读者在项目中也都有使用过。关于线程池的文章也是数不胜数，我们站在巨人的肩膀上来再次梳理一下。&lt;/p&gt;
&lt;p&gt;本文还是保持原有的风格，图文解析，尽量做到多画图！全文共20000+字，建议收藏后细细品读，阅读期间搭配源码食用效果更佳！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读完此文你将学到：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中常用参数有哪些？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中线程池状态和线程数量如何存储的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;有哪些状态，状态之间流转是什么样子的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;任务处理策略？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;常用的拒绝策略有哪些？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Executors&lt;/code&gt;工具类提供的线程池有哪些？有哪些缺陷？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;核心线程池中线程预热功能？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中创建的线程如何被复用的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中关闭线程池的方法&lt;code&gt;shutdown&lt;/code&gt;与&lt;code&gt;shutdownNow&lt;/code&gt;的区别？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中存在的一些扩展点？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;支持动态调整核心线程数、最大线程数、队列长度等一些列参数吗？怎么操作？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;本文源码基于JDK1.8&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池基本概念&quot;&gt;线程池基本概念&lt;/h3&gt;
&lt;p&gt;线程池是一种池化思想的产物，如同我们数据库有连接池、Java中的常量池。线程池可以帮助我们管理线程、复用线程，减少线程频繁新建、销毁等带来的开销。&lt;/p&gt;
&lt;p&gt;在Java中是通过&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类来创建一个线程池的，一般我们建议项目中自己去定义线程池，不推荐使用&lt;code&gt;JDK&lt;/code&gt;提供的工具类&lt;code&gt;Executors&lt;/code&gt;去构建线程池。&lt;/p&gt;
&lt;p&gt;查看&lt;strong&gt;阿里巴巴开发手册&lt;/strong&gt;中也有对线程池的一些建议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;【强制】&lt;/code&gt;创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;正例：&lt;/code&gt;自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给&lt;code&gt;whatFeaturOfGroup&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserThreadFactory implements ThreadFactory {

        private final String namePrefix;
        private final AtomicInteger nextId = new AtomicInteger(1);

        UserThreadFactory(String whatFeaturOfGroup) {
                namePrefix = &quot;From UserThreadFactory's &quot; + whatFeaturOfGroup + &quot;-Worker-&quot;;
        }

        @Override
        public Thread newThread(Runnable task) {
                String name = namePrefix + nextId.getAndIncrement();
                Thread thread = new Thread(null, task, name, 0, false);
                System.out.println(thread.getName());
                return thread;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;【强制】&lt;/code&gt;线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。&lt;br/&gt;如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;【强制】&lt;/code&gt;线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这&lt;br/&gt;样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：Executors 返回的线程池对象的弊端如下：&lt;br/&gt;1） FixedThreadPool 和 SingleThreadPool：&lt;br/&gt;允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;br/&gt;2） CachedThreadPool：&lt;br/&gt;允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程池使用示例&quot;&gt;线程池使用示例&lt;/h3&gt;
&lt;p&gt;下面是一个自定义的线程池，这是之前公司在用的一个线程池，修改其中部分属性和备注做脱敏处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyThreadPool {
        static final Logger LOGGER = LoggerFactory.getLogger(MyThreadPool.class);

        private static final int DEFAULT_MAX_CONCURRENT = Runtime.getRuntime().availableProcessors() * 2;

        private static final String THREAD_POOL_NAME = &quot;MyThreadPool-%d&quot;;

        private static final ThreadFactory FACTORY = new BasicThreadFactory.Builder().namingPattern(THREAD_POOL_NAME)
                        .daemon(true).build();

        private static final int DEFAULT_SIZE = 500;

        private static final long DEFAULT_KEEP_ALIVE = 60L;

        private static ExecutorService executor;

        private static BlockingQueue&amp;lt;Runnable&amp;gt; executeQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(DEFAULT_SIZE);

        static {
                try {
                        executor = new ThreadPoolExecutor(DEFAULT_MAX_CONCURRENT, DEFAULT_MAX_CONCURRENT + 2, DEFAULT_KEEP_ALIVE,
                                        TimeUnit.SECONDS, executeQueue, FACTORY);

                        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
                                @Override
                                public void run() {
                                        LOGGER.info(&quot;MyThreadPool shutting down.&quot;);
                                        executor.shutdown();

                                        try {
                                                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
                                                        LOGGER.error(&quot;MyThreadPool shutdown immediately due to wait timeout.&quot;);
                                                        executor.shutdownNow();
                                                }
                                        } catch (InterruptedException e) {
                                                LOGGER.error(&quot;MyThreadPool shutdown interrupted.&quot;);
                                                executor.shutdownNow();
                                        }

                                        LOGGER.info(&quot;MyThreadPool shutdown complete.&quot;);
                                }
                        }));
                } catch (Exception e) {
                        LOGGER.error(&quot;MyThreadPool init error.&quot;, e);
                        throw new ExceptionInInitializerError(e);
                }
        }

        private MyThreadPool() {
        }

        public static boolean execute(Runnable task) {

                try {
                        executor.execute(task);
                } catch (RejectedExecutionException e) {
                        LOGGER.error(&quot;Task executing was rejected.&quot;, e);
                        return false;
                }

                return true;
        }

        public static &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submitTask(Callable&amp;lt;T&amp;gt; task) {

                try {
                        return executor.submit(task);
                } catch (RejectedExecutionException e) {
                        LOGGER.error(&quot;Task executing was rejected.&quot;, e);
                        throw new UnsupportedOperationException(&quot;Unable to submit the task, rejected.&quot;, e);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要就是使用调用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数来构造一个线程池，指定自定义的&lt;code&gt;ThreadFactory&lt;/code&gt;，里面包含我们自己线程池的&lt;code&gt;poolName&lt;/code&gt;等信息。重写里面的&lt;code&gt;execute()&lt;/code&gt;和&lt;code&gt;submitTask()&lt;/code&gt;方法。 添加了系统关闭时的钩子函数&lt;code&gt;shutDownHook()&lt;/code&gt;，在里面调用线程池的&lt;code&gt;shutdown()&lt;/code&gt;方法，使得系统在退出(&lt;strong&gt;使用ctrl c或者kill -15 pid&lt;/strong&gt;)时能够优雅的关闭线程池。&lt;/p&gt;
&lt;p&gt;如果有看不懂的小伙伴也没有关系，后面会详细分析&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中的源码，相信看完后面的代码再回头来看这个用例 就完全是小菜一碟了。&lt;/p&gt;
&lt;h3 id=&quot;线程池实现原理&quot;&gt;线程池实现原理&lt;/h3&gt;
&lt;p&gt;通过上面的示例代码，我们需要知道创建线程池时几个重要的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;corePoolSize&lt;/code&gt;: 线程池核心线程数量&lt;br/&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;: 线程池最大线程数量&lt;br/&gt;&lt;code&gt;workQueue&lt;/code&gt;: 线程池中阻塞队列，一般指定队列大小&lt;/p&gt;
&lt;p&gt;线程池中数据模型可以简化成下图所示，其中&lt;code&gt;Thread&lt;/code&gt;应该是添加的一个个&lt;code&gt;Worker&lt;/code&gt;，这里标注的&lt;code&gt;Thread&lt;/code&gt;是为了方便理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074815882-63321464.png&quot; alt=&quot;线程池中数据模型.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程池中提交一个任务具体执行流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816113-1232911533.png&quot; alt=&quot;执行流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交任务时，比较当前线程池中线程数量和核心线程数的大小，根据比较结果走不同的任务处理策略，这个下面会有详细说明。&lt;/p&gt;
&lt;p&gt;线程池中核心方法调用链路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816269-1324483823.png&quot; alt=&quot;方法调用链路.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;theadpoolexecutor源码初探&quot;&gt;TheadPoolExecutor源码初探&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TheadPoolExecutor&lt;/code&gt;中常用属性和方法较多，我们可以先分析下这些，然后一步步往下深入，常用属性和方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816413-168325255.png&quot; alt=&quot;线程池常见属性和方法.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {

        private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        private static final int COUNT_BITS = Integer.SIZE - 3;
        private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

        private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
        private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
        private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
        private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
        private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

        private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
        private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
        private static int ctlOf(int rs, int wc) { return rs | wc; }

        private static boolean runStateLessThan(int c, int s) {
        return c &amp;lt; s;
    }

    private static boolean runStateAtLeast(int c, int s) {
        return c &amp;gt;= s;
    }

    private static boolean isRunning(int c) {
        return c &amp;lt; SHUTDOWN;
    }

    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    private boolean compareAndDecrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect - 1);
    }

     private void decrementWorkerCount() {
        do {} while (! compareAndDecrementWorkerCount(ctl.get()));
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                Executors.defaultThreadFactory(), defaultHandler);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;ctl&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;ctl&lt;/code&gt;代表当前线程池状态和线程池线程数量的结合体，高3位标识当前线程池运行状态，后29位标识线程数量。ctlOf方法就是rs(线程池运行状态)和wc(线程数量)按位或操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;COUNT_BITS&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;COUNT_BITS = Integer.SIZE - 3 = 29，在ctl中，低29位用于存放当前线程池中线程的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;CAPACITY&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CAPACITY = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;br/&gt;我们来计算一下：&lt;br/&gt;1 &amp;lt;&amp;lt; 29 = 0010 0000 0000 0000 0000 0000 0000 0000&lt;br/&gt;(1 &amp;lt;&amp;lt; 29) - 1 = 0001 1111 1111 1111 1111 1111 1111 1111&lt;br/&gt;这个属性是用来线程池能装载线程的最大数量，也可以用来做一些位运算操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;线程池几种状态&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;RUNNING：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。&lt;br/&gt;(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;SHUTDOWN:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。&lt;br/&gt;(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&amp;gt; SHUTDOWN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;STOP：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。&lt;br/&gt;(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&amp;gt; STOP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIDYING：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;(1) 状态说明：当所有的任务已终止，ctl记录的&quot;任务数量&quot;为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。&lt;br/&gt;(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&amp;gt; TIDYING。&lt;br/&gt;当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&amp;gt; TIDYING&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TERMINATED：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。&lt;br/&gt;(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&amp;gt; TERMINATED&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;状态的变化流转：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816572-2061701085.png&quot; alt=&quot;线程池的状态流转.png&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;runStateOf()&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;计算线程池运行状态的，就是计算ctl前三位的数值。`unStateOf() = c &amp;amp; ~CAPACITY，CAPACITY = 0001 1111 1111 1111 1111 1111 1111 1111，那么~CAPACITY = 1110 0000 0000 0000 0000 0000 0000 0000，它与任何数按位与的话都是只看这个数前三位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;workerCountOf()&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;计算线程池的线程数量，就是看ctl的后29位，workerCountOf() = c &amp;amp; CAPACITY， CAPACITY = 0001 1111 1111 1111 1111 1111 1111 1111与任何数按位与，就是看这个数的后29位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;ctlOf(int rs, int wt)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在获取当前线程池ctl的时候会用到，在后面源码中会有很多地方调用, 传递的参数rs代表线程池状态，wt代表当前线程次线程(worker)的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;runStateLessThan(int c, int s)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;return c &amp;lt; s，c一般传递的是当前线程池的ctl值。比较当前线程池ctl所表示的状态是否小于某个状态s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;runStateAtLeast(int c, int s)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;return c &amp;gt;= s，c一般传递的是当前线程池的ctl值。比较当前线程池ctl所表示的状态，是否大于等于某个状态s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;isRunning(int c)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;c &amp;lt; SHUTDOWN， 判断当前线程池是否是RUNNING状态，因为只有RUNNING的值小于SHUTDOWN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;compareAndIncrementWorkerCount()/compareAndDecrementWorkerCount()&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用CAS方式 让ctl值分别加一减一 ，成功返回true, 失败返回false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;decrementWorkerCount()&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;将ctl值减一，这个方法用了do...while循环，直到成功为止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;completedTaskCount&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;记录线程池所完成任务总数 ，当worker退出时会将 worker完成的任务累积到completedTaskCount&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;Worker&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;线程池内部类，继承自AQS且实现Runnable接口。Worker内部有一个Thread thread是worker内部封装的工作线程。Runnable firstTask用来接收用户提交的任务数据。在初始化Worker时候会设置state为-1(初始化状态)，通过threadFactory创建一个线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;15&quot;&gt;&lt;li&gt;ThreadPoolExecutor初始化参数&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;corePoolSize: 核心线程数限制&lt;br/&gt;maximumPoolSize: 最大线程限制&lt;br/&gt;keepAliveTime: 非核心的空闲线程等待新任务的时间 unit: 时间单位。配合allowCoreThreadTimeOut也会清理核心线程池中的线程。&lt;br/&gt;workQueue: 任务队列，最好选用有界队列，指定队列长度&lt;br/&gt;threadFactory: 线程工厂，最好自定义线程工厂，可以自定义每个线程的名称&lt;br/&gt;handler: 拒绝策略，默认是AbortPolicy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;execute源码分析&quot;&gt;execute()源码分析&lt;/h3&gt;
&lt;p&gt;当有任务提交到线程池时，就会直接调用&lt;code&gt;ThreadPoolExecutor.execute()&lt;/code&gt;方法，执行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816733-172366465.png&quot; alt=&quot;执行流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从流程图可看，添加任务会有三个分支判断，源码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.ThreadPoolExecutor.execute()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt;在这里代表线程池&lt;code&gt;ctl&lt;/code&gt;的值，包含工作任务数量以及线程池的状态，上面有解释过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着看下面几个分支代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支一：&lt;/strong&gt; &lt;code&gt;if (workerCountOf(c) &amp;lt; corePoolSize)&lt;/code&gt; ，条件成立表示当前线程数量小于核心线程数，此次提交任务，直接创建一个新的&lt;code&gt;worker&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (workerCountOf(c) &amp;lt; corePoolSize) {
    if (addWorker(command, true))
        return;
    c = ctl.get();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果线程数小于核心线程数，执行&lt;code&gt;addWorker&lt;/code&gt;操作，这个后面会讲这个方法的细节，如果添加成功则直接返回，失败后会重新计算&lt;code&gt;ctl&lt;/code&gt;的值，然后执行分支二。&lt;/p&gt;
&lt;p&gt;针对&lt;code&gt;addWorker()&lt;/code&gt;执行失败的情况，有以下几种可能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存在并发情况，&lt;code&gt;execute()&lt;/code&gt;方法是可能有多个线程同时调用的，当多个线程同时&lt;strong&gt;workerCountOf(c) &amp;lt; corePoolSize&lt;/strong&gt;成立后，就会向线程池中创建&lt;code&gt;worker&lt;/code&gt;，这个时候线程池的核心线程数可能已经达到，在&lt;code&gt;addWorker&lt;/code&gt;中还会再次判断，所以会有任务添加失败。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816965-1628045832.png&quot; alt=&quot;addWorker()失败场景一.png&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;当前线程池状态发生改变，例如线程A执行&lt;code&gt;addWorker()&lt;/code&gt;方法时，线程B修改线程池状态，导致线程池不是&lt;code&gt;RUNNING&lt;/code&gt;状态，此时线程A执行&lt;code&gt;addWorker()&lt;/code&gt;就有可能失败。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074817186-1280882923.png&quot; alt=&quot;addWorker()失败场景二.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支二：&lt;/strong&gt; &lt;code&gt;if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过分支一流程的分析，我们可以知道执行到这个分支说明**当前线程数量已经达到&lt;code&gt;corePoolSize&lt;/code&gt;或者&lt;code&gt;addWorker()&lt;/code&gt;执行失败，我们先看看分支二执行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074817433-1242540246.png&quot; alt=&quot;超过核心线程数往队列中添加任务流程图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先判断当前线程池是否处于&lt;code&gt;RUNNING&lt;/code&gt;状态，如果是则尝试将&lt;code&gt;task&lt;/code&gt;放入到&lt;code&gt;workQueue&lt;/code&gt;中，&lt;code&gt;workQueue&lt;/code&gt;是我们在初始化&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;时传入进来的阻塞队列。&lt;/p&gt;
&lt;p&gt;如果当前任务成功添加到阻塞队列中，再次获取&lt;code&gt;ctl&lt;/code&gt;赋值给&lt;code&gt;recheck&lt;/code&gt;变量，然后执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (!isRunning(recheck) &amp;amp;&amp;amp; remove(command))
    reject(command);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次判断当前线程池是否为&lt;code&gt;RUNNINT&lt;/code&gt;状态，如果不是则说明提交任务到队列之后，线程池状态被其他线程给修改了，比如调用&lt;code&gt;shutdown()/shutdownNow()&lt;/code&gt;等。这种情况就需要把刚刚提交到队列中的的任务删除掉。&lt;/p&gt;
&lt;p&gt;再看下remove()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean remove(Runnable task) {
    boolean removed = workQueue.remove(task);
    tryTerminate();
    return removed;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果任务提交到队列之后，线程池中的线程还未将这个任务消费，那么就可以&lt;code&gt;remove&lt;/code&gt;成功，调用&lt;code&gt;reject()&lt;/code&gt;方法来执行拒绝策略。&lt;br/&gt;如果在改变线程池状态之前，队列中的数据已经被消费了，此时&lt;code&gt;remove()&lt;/code&gt;就会失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074817591-175039698.png&quot; alt=&quot;移除队列中Task任务.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着走&lt;code&gt;else if&lt;/code&gt;中的逻辑:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;else if (workerCountOf(recheck) == 0)
    addWorker(null, false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走这个&lt;code&gt;else if&lt;/code&gt;逻辑有两种可能，线程池是&lt;code&gt;RUNNING&lt;/code&gt;状态或者线程池状态被改变且&lt;code&gt;workQueue&lt;/code&gt;中添加的任务已经被消费导致&lt;code&gt;remove()&lt;/code&gt;失败。&lt;br/&gt;如果是&lt;code&gt;RUNNING&lt;/code&gt;状态，线程池中的线程数量是0，此时&lt;code&gt;workQueue&lt;/code&gt;中还有待执行的任务，就需要新增一个&lt;code&gt;worker&lt;/code&gt;(&lt;code&gt;addWorker&lt;/code&gt;里面会有创建线程的操作)，继续消费&lt;code&gt;workqueue&lt;/code&gt;中的任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074817741-1692595423.png&quot; alt=&quot;添加新任务.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要注意一下&lt;code&gt;addWorker(null, false)&lt;/code&gt;，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到&lt;code&gt;workQueue&lt;/code&gt;中了，所以&lt;code&gt;worker&lt;/code&gt;在执行的时候，会直接从&lt;code&gt;workQueue&lt;/code&gt;中获取任务。在&lt;code&gt;workerCountOf(recheck) == 0&lt;/code&gt;时执行&lt;code&gt;addWorker(null, false)&lt;/code&gt;也是为了保证线程池在&lt;code&gt;RUNNING&lt;/code&gt;状态下必须要有一个线程来执行任务，可以理解为一种担保兜底机制。&lt;/p&gt;
&lt;p&gt;至于线程池中线程为何可以为0？这个如果我们设置了&lt;code&gt;allowCoreThreadTimeOut=true&lt;/code&gt;，那么核心线程也是允许被回收的，后面&lt;code&gt;getTask()&lt;/code&gt;中代码有提及。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支三：&lt;/strong&gt; &lt;code&gt;else if (!addWorker(command, false)) {}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过分支一和分之二的分析，进入这个分支的前置条件：线程数超过核心线程数且&lt;code&gt;workQueue&lt;/code&gt;中数据已满。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;else if (!addWorker(command, false))&lt;/code&gt;，执行添加&lt;code&gt;worker&lt;/code&gt;操作，如果执行失败就直接走&lt;code&gt;reject()&lt;/code&gt;拒绝策略。这里添加失败可能是线程数已经超过了&lt;code&gt;maximumPoolSize&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074817923-142803787.png&quot; alt=&quot;分支三执行流程.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;addworker源码分析&quot;&gt;addWorker()源码分析&lt;/h3&gt;
&lt;p&gt;上面分析提交任务的方法&lt;code&gt;execute()&lt;/code&gt;时多次用到&lt;code&gt;addWorker&lt;/code&gt;方法，接收任务后将任务添加到&lt;code&gt;Worker&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt;是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中的内部类，继承自&lt;code&gt;AQS&lt;/code&gt;且实现了&lt;code&gt;Runnable&lt;/code&gt;接口。 类中包含&lt;code&gt;Thread thread&lt;/code&gt;，它是&lt;code&gt;worker&lt;/code&gt;内部封装的工作线程，还有&lt;code&gt;firstTask&lt;/code&gt;属性，它是一个可执行的&lt;code&gt;Runnable&lt;/code&gt;对象。在&lt;code&gt;Worker&lt;/code&gt;的构造函数中，使用线程工厂创建了一个线程，当&lt;code&gt;thread&lt;/code&gt;启动的时候，会以&lt;code&gt;worker.run()&lt;/code&gt;为入口启动线程，这里会直接调用到&lt;code&gt;runWorker()&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final class Worker extends AbstractQueuedSynchronizer implements Runnable{

    private static final long serialVersionUID = 6138294804551838833L;

    final Thread thread;
    Runnable firstTask;
    volatile long completedTasks;

    Worker(Runnable firstTask) {
        setState(-1);
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
        runWorker(this);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074818173-295957714.png&quot; alt=&quot;添加Worker.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里再回头看下&lt;strong&gt;addWorker(Runnable firstTask, boolean core)&lt;/strong&gt; 方法，这个方法主要是添加一个&lt;code&gt;Worker&lt;/code&gt;到线程池中并执行，&lt;code&gt;firstTask&lt;/code&gt;参数用于指定新增的线程执行的第一个任务，&lt;code&gt;core&lt;/code&gt;参数为true表示在新增线程时会判断当前活动线程数是否少于&lt;code&gt;corePoolSize&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt;表示在新增线程时会判断当前活动线程数是否少于&lt;code&gt;maximumPoolSize&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addWorker方法整体执行流程图如下：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074818370-725948824.png&quot; alt=&quot;addWorker流程图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看下源码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.ThreadPoolExecutor.addWorker()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; !(rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; !workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc &amp;gt;= CAPACITY || wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());

                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是有两层&lt;code&gt;for&lt;/code&gt;循环，外层循环主要是判断线程池的状态，如果状态不合法就直接返回&lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;只有两种情况属于合法状态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;RUNNING&lt;/code&gt;状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHUTDOWN&lt;/code&gt;状态时，队列中还有未处理的任务，且提交的任务为空。&lt;code&gt;SHUTDOWN&lt;/code&gt;含义就是不再接收新任务，可以继续处理阻塞队列的任务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二层循环是通过&lt;code&gt;CAS&lt;/code&gt;操作更新&lt;code&gt;workCount&lt;/code&gt;数量，如果更新成功则往线程池中中添加线程，这个所谓的线程池就是一个&lt;code&gt;HashSet&lt;/code&gt;数组。添加失败时判断失败原因，&lt;code&gt;CAS&lt;/code&gt;失败有两种原因：线程池状态被改变或者并发情况修改线程池中&lt;code&gt;workCount&lt;/code&gt;数量，这两种情况都会导致&lt;code&gt;ctl&lt;/code&gt;值被修改。如果是第二种原因导致的失败，继续自旋更新&lt;code&gt;workCount&lt;/code&gt;数量。&lt;/p&gt;
&lt;p&gt;接着继续分析循环内部的实现，先看看第一层循环：&lt;code&gt;c&lt;/code&gt;代表线程池&lt;code&gt;ctl&lt;/code&gt;值，&lt;code&gt;rs&lt;/code&gt;代表线程池运行状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; !(rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; !workQueue.isEmpty()))
    return false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;条件一：&lt;/strong&gt;&lt;code&gt;rs &amp;gt;= SHUTDOWN&lt;/code&gt; 成立, 说明当前线程池状态不是&lt;code&gt;RUNNING&lt;/code&gt;状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件二：&lt;/strong&gt; &lt;code&gt;!(rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; ! workQueue.isEmpty())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们之前提到过，创建任务有两种情况：&lt;br/&gt;1）&lt;code&gt;RUNNING&lt;/code&gt;状态可以提交任务，&lt;br/&gt;2）&lt;code&gt;SHUTDOWN&lt;/code&gt;状态下如果传递的任务是空且阻塞队列中还有任务未处理的情况才是允许创建任务继续处理的，因为阻塞队列中的任务仍然需要继续处理。&lt;/p&gt;
&lt;p&gt;上面的条件一和条件二就是处理&lt;code&gt;SHUTDOWN&lt;/code&gt;状态下任务创建操作的判断。&lt;/p&gt;
&lt;p&gt;接着分析第二层循环，先是判断线程池&lt;code&gt;workCount&lt;/code&gt;数量是否大于可创建的最大值，或者是否超过了核心线程数/最大线程数，如果是则直接返回，&lt;code&gt;addWorker()&lt;/code&gt;操作失败。&lt;/p&gt;
&lt;p&gt;接着使用&lt;code&gt;compareAndIncrementWorkerCount(c)&lt;/code&gt;将线程池中&lt;code&gt;workCount+1&lt;/code&gt;，这里使用的是&lt;code&gt;CAS&lt;/code&gt;操作，如果成功则直接跳出最外层循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (;;) {
    int wc = workerCountOf(c);
    if (wc &amp;gt;= CAPACITY || wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
        return false;
    if (compareAndIncrementWorkerCount(c))
        break retry;
    c = ctl.get();
    if (runStateOf(c) != rs)
        continue retry;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;CAS&lt;/code&gt;失败，说明此时有竞争，会重新获取&lt;code&gt;ctl&lt;/code&gt;的值，判断竞争失败的原因是添加&lt;code&gt;workCount&lt;/code&gt;数量还是修改线程池状态导致的，如果线程池状态未发生改变，就继续循环尝试&lt;code&gt;CAS&lt;/code&gt;增加&lt;code&gt;workCount&lt;/code&gt;数量，接着看循环结束后逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean workerStarted = false;
boolean workerAdded = false;
Worker w = null;
try {
    w = new Worker(firstTask);
    final Thread t = w.thread;
    if (t != null) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            int rs = runStateOf(ctl.get());

            if (rs &amp;lt; SHUTDOWN ||
                (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                if (t.isAlive())
                    throw new IllegalThreadStateException();
                workers.add(w);
                int s = workers.size();
                if (s &amp;gt; largestPoolSize)
                    largestPoolSize = s;
                workerAdded = true;
            }
        } finally {
            mainLock.unlock();
        }
        if (workerAdded) {
            t.start();
            workerStarted = true;
        }
    }
} finally {
    if (!workerStarted)
        addWorkerFailed(w);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;workerStarted&lt;/code&gt;代表&lt;code&gt;worker&lt;/code&gt;是否已经启动，&lt;code&gt;workerAdded&lt;/code&gt;代表创建的&lt;code&gt;worker&lt;/code&gt;是否添加到池子中，这里所谓的池子就是全局定义的一个&lt;code&gt;HashSet&lt;/code&gt;结构的&lt;code&gt;workers&lt;/code&gt;变量。&lt;/p&gt;
&lt;p&gt;接着根据传递的&lt;code&gt;firstTask&lt;/code&gt;来构建一个&lt;code&gt;Worker&lt;/code&gt;，在&lt;code&gt;Worker&lt;/code&gt;的构造方法中也会通过&lt;code&gt;ThreadFactory&lt;/code&gt;创建一个线程，这里判断&lt;code&gt;t != null&lt;/code&gt;是因为用户可以自定义&lt;code&gt;ThreadFactory&lt;/code&gt;，如果这里用户不是创建线程而是直接返回&lt;code&gt;null&lt;/code&gt;则会出现一些问题，所以需要判断一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;w = new Worker(firstTask);
final Thread t = w.thread;

if (t != null) {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在往池子中添加&lt;code&gt;Worker&lt;/code&gt;的时候，是需要先加锁的，因为针对全局的&lt;code&gt;workers&lt;/code&gt;操作并不是线程安全的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final ReentrantLock mainLock = this.mainLock;
mainLock.lock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续看下面代码，&lt;code&gt;rs&lt;/code&gt;代表当前线程池的状态，这里还是判断线程池的状态，如果&lt;code&gt;rs &amp;lt; SHUTDOWN&lt;/code&gt;代表线程池状态是&lt;code&gt;RUNNING&lt;/code&gt;状态，此时可以直接操作。&lt;br/&gt;如果是&lt;code&gt;SHUTDOWN&lt;/code&gt;状态，需要满足&lt;code&gt;firstTask == null&lt;/code&gt;才可以继续操作。因为在&lt;code&gt;SHUTDOWN&lt;/code&gt;状态时不会再添加新的任务，但还是可以继续处理&lt;code&gt;workQueue&lt;/code&gt;中的任务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;t.isAlive()&lt;/code&gt; 当线程&lt;code&gt;start&lt;/code&gt;后，线程&lt;code&gt;isAlive&lt;/code&gt;会返回&lt;code&gt;true&lt;/code&gt;，这里还是防止自定义的&lt;code&gt;ThreadFactory&lt;/code&gt;创建线程返回给外部之前，将线程&lt;code&gt;start&lt;/code&gt;了，由此可见&lt;code&gt;Doug lea&lt;/code&gt;考虑问题真的很全面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int rs = runStateOf(ctl.get());
if (rs &amp;lt; SHUTDOWN ||
    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
    if (t.isAlive())
        throw new IllegalThreadStateException();
    workers.add(w);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着将创建的&lt;code&gt;Worker&lt;/code&gt;添加到&lt;code&gt;workers&lt;/code&gt;集合中，设置&lt;code&gt;largestPoolSize&lt;/code&gt;，这个属性是线程池生命周期内线程数最大值，一般是做统计数据用的。 最后修改&lt;code&gt;workerAdded = true&lt;/code&gt;，代表当前提交的任务所创建的&lt;code&gt;Worker&lt;/code&gt;已经添加到池子中了。&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;worker&lt;/code&gt;成功后，调用线程的&lt;code&gt;start()&lt;/code&gt;方法启动线程，因为&lt;code&gt;Worker&lt;/code&gt;中重写了&lt;code&gt;run()&lt;/code&gt;方法，最后会执行&lt;code&gt;Worker.run()&lt;/code&gt;。最后设置&lt;code&gt;workerStarted = true&lt;/code&gt;后释放全局锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int rs = runStateOf(ctl.get());
if (rs &amp;lt; SHUTDOWN || (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
        
        workers.add(w);
        int s = workers.size();
        if (s &amp;gt; largestPoolSize)
        largestPoolSize = s;
        
    orkerAdded = true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里再回头看看&lt;code&gt;workerAdded = false&lt;/code&gt;的情形，如果线程池在&lt;code&gt;lock&lt;/code&gt;之前，状态发生了变化，导致添加失败。此时&lt;code&gt;workerAdded&lt;/code&gt;也会为&lt;code&gt;false&lt;/code&gt;，最后执行&lt;code&gt;addWorkerFailed(work)&lt;/code&gt;操作，这个方法是将&lt;code&gt;Work&lt;/code&gt;从&lt;code&gt;workers&lt;/code&gt;中移除掉，然后将&lt;code&gt;workCount&lt;/code&gt;数量减一，最后执行&lt;code&gt;tryTerminate(&lt;/code&gt;)来尝试关闭线程池，这个方法后面会细说。&lt;/p&gt;
&lt;h3 id=&quot;runworker源码分析&quot;&gt;runWorker()源码分析&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;Worker&lt;/code&gt;类中的&lt;code&gt;run&lt;/code&gt;方法调用了&lt;code&gt;runWorker&lt;/code&gt;来执行任务。上面&lt;code&gt;addWorker()&lt;/code&gt;方法正常的执行逻辑会创建一个&lt;code&gt;Worker&lt;/code&gt;，然后启动&lt;code&gt;Worker&lt;/code&gt;中的线程，这里其实就会执行到&lt;code&gt;runWorker&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074818539-106423672.png&quot; alt=&quot;方法调用关系.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runWorker&lt;/code&gt;的执行逻辑很简单，启动一个线程，执行当前传递的&lt;code&gt;task&lt;/code&gt;任务，执行完后又不断的从&lt;code&gt;workQueue&lt;/code&gt;中获取任务继续执行，如果当前&lt;code&gt;workCount&lt;/code&gt;数量小于核心线程数且队列中没有了任务，当前线程会被阻塞，这个就是&lt;code&gt;getTask()&lt;/code&gt;的逻辑，一会会讲到。&lt;/p&gt;
&lt;p&gt;如果当前线程数大于核心线程数且队列中没有任务，就会返回&lt;code&gt;null&lt;/code&gt;，在&lt;code&gt;runWorker&lt;/code&gt;这边退出循环，回收多余的&lt;code&gt;worker&lt;/code&gt;数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074818707-1437554613.png&quot; alt=&quot;runWorker流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;amp;&amp;amp; runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;w.unlock()&lt;/code&gt;是为了初始化当前&lt;code&gt;Work&lt;/code&gt;中&lt;code&gt;state==0&lt;/code&gt;，然后设置独占线程为&lt;code&gt;null&lt;/code&gt;，因为在&lt;code&gt;shutDown()&lt;/code&gt;方法中会尝试获取&lt;code&gt;Worker&lt;/code&gt;中的锁，如果获取成功代表当前线程没有被加锁处于空闲状态，给当前线程一个中断信号。所以这里在执行线程任务的时候需要加锁，防止调用&lt;code&gt;shutDown()&lt;/code&gt;的时候给当前&lt;code&gt;worker&lt;/code&gt;线程一个中断信号。&lt;/p&gt;
&lt;p&gt;判断&lt;code&gt;task&lt;/code&gt;是否为空，如果是一个空任务，那么就去&lt;code&gt;workQueue&lt;/code&gt;中获取任务，如果两者都为空就会退出循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while (task != null || (task = getTask()) != null) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最核心的就是调用&lt;code&gt;task.run()&lt;/code&gt;启动当前任务，这里面还有两个可扩展的方法，分别是&lt;strong&gt;beforeExecute()/afterExecute()&lt;/strong&gt;，我们可以在任务执行前和执行后分别自定义一些操作，其中&lt;code&gt;afterExecute()&lt;/code&gt;可以接收到任务抛出的异常信息，方便我们做后续处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while (task != null || (task = getTask()) != null) {
    try {
        beforeExecute(wt, task);
        Throwable thrown = null;
        try {
            task.run();
        } catch (RuntimeException x) {
            thrown = x; throw x;
        } catch (Error x) {
            thrown = x; throw x;
        } catch (Throwable x) {
            thrown = x; throw new Error(x);
        } finally {
            afterExecute(task, thrown);
        }
    } finally {
        task = null;
        w.completedTasks++;
        w.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果退出循环，说明&lt;code&gt;getTask()&lt;/code&gt;方法返回&lt;code&gt;null&lt;/code&gt;。会执行到&lt;code&gt;finally&lt;/code&gt;中的&lt;code&gt;processWorkerExit(w, completedAbruptly)&lt;/code&gt;方法，此方法是用来清理线程池中添加的&lt;code&gt;work&lt;/code&gt;数据，&lt;code&gt;completedAbruptly=true&lt;/code&gt;代表是异常情况下退出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try {
    while (task != null || (task = getTask()) != null) {
        
    }
    completedAbruptly = false;
} finally {
    processWorkerExit(w, completedAbruptly);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runWorker()&lt;/code&gt;中只是启动了当前线程工作，还需要源源不断通过&lt;code&gt;getTask()&lt;/code&gt;方法从&lt;code&gt;workQueue&lt;/code&gt;来获取任务执行。在&lt;code&gt;workQueue&lt;/code&gt;没有任务的时候，根据线程池&lt;code&gt;workCount&lt;/code&gt;和核心线程数的对比结果来使用&lt;code&gt;processWorkerExit()&lt;/code&gt;执行清理工作。&lt;/p&gt;
&lt;h3 id=&quot;gettask源码分析&quot;&gt;getTask()源码分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getTask&lt;/code&gt;方法用于从阻塞队列中获取任务，如果当前线程小于核心线程，那么当阻塞队列中没有任务时就会阻塞，反之会等待&lt;code&gt;keepAliveTime&lt;/code&gt;后返回。&lt;/p&gt;
&lt;p&gt;这个就是&lt;code&gt;keepAliveTime&lt;/code&gt;的使用含义：非核心的空闲线程等待新任务的时间，当然如果这里设置了&lt;code&gt;allowCoreThreadTimeOut=true&lt;/code&gt;也会回收核心线程。&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Runnable getTask() {
    boolean timedOut = false;

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里核心代码就是从&lt;code&gt;workQueue&lt;/code&gt;中取任务，采用&lt;code&gt;poll&lt;/code&gt;还是&lt;code&gt;take&lt;/code&gt;取决于&lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt;和线程数量，&lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt;在构造&lt;code&gt;ThreadLocalExecutor&lt;/code&gt;后设置的，默认为false。如果设置为&lt;code&gt;true&lt;/code&gt;则代表核心线程数下的线程也是可以被回收的。如果使用&lt;code&gt;take&lt;/code&gt;则表明&lt;code&gt;workQueue&lt;/code&gt;中没有任务当前线程就会被阻塞挂起，直到有了新的任务才会被唤醒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074818893-1909400254.png&quot; alt=&quot;workQueue数据取出流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里扩展下阻塞队列的部分方法的含义，这里主要是看&lt;code&gt;poll()&lt;/code&gt;和&lt;code&gt;take()&lt;/code&gt;的使用区别：&lt;br/&gt;&lt;strong&gt;阻塞队列插入方法：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;boolean add&lt;/strong&gt;(E e)：队列没有满，则插入数据并返回true；队列满时，抛出异常 java.lang.IllegalStateException: Queue full。&lt;br/&gt;&lt;strong&gt;boolean offer&lt;/strong&gt;(E e)：队列没有满，则插入数据并返回true；队列满时，返回false。&lt;br/&gt;&lt;strong&gt;void put&lt;/strong&gt;(E e)：队列没有满，则插入数据；队列满时，阻塞调用此方法线程，直到队列有空闲空间时此线程进入就绪状态。&lt;br/&gt;&lt;strong&gt;boolean offer&lt;/strong&gt;(E e, long timeout, TimeUnit unit)：队列没有满，插入数据并返回true；队列满时，阻塞调用此方法线程，若指定等待的时间内还不能往队列中插入数据，返回false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;阻塞队列移除(获取)方法：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;E remove()&lt;/strong&gt;：队列非空，则以FIFO原则移除数据，并返回该数据的值；队列为空，抛出异常 java.util.NoSuchElementException。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;E poll()：&lt;/strong&gt; 队列非空，移除数据，并返回该数据的值；队列为空，返回null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;E take()：&lt;/strong&gt; 队列非空，移除数据，并返回该数据的值；队列为空，阻塞调用此方法线程，直到队列为非空时此线程进入就绪状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;E poll&lt;/strong&gt;(long timeout, TimeUnit unit)：队列非空，移除数据，并返回该数据的值；队列为空，阻塞调用此方法线程，若指定等待的时间内队列都没有数据可取，返回null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;阻塞队列检查方法：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;E element()：&lt;/strong&gt; 队列非空，则返回队首元素；队列为空，抛出异常 java.util.NoSuchElementException。&lt;br/&gt;&lt;strong&gt;E peek()：&lt;/strong&gt; 队列非空，则返回队首元素；队列为空，返回null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;processworkerexit源码分析&quot;&gt;processWorkerExit()源码分析&lt;/h3&gt;
&lt;p&gt;此方法的含义是清理当前线程，从线程池中移除掉刚刚添加的&lt;code&gt;worker&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074819120-395517420.png&quot; alt=&quot;processWorkerExit执行前置条件.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;processWorkerExit()&lt;/code&gt;代表在&lt;code&gt;runWorker()&lt;/code&gt;线程跳出了当前循环，一般有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;task.run()&lt;/code&gt;内部抛出异常，直接结束循环，然后执行&lt;code&gt;processWorkerExit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getTask()&lt;/code&gt;返回为空，代表线程数量大于核心数量且&lt;code&gt;workQueue&lt;/code&gt;中没有任务，此时需要执行&lt;code&gt;processWorkerExit()&lt;/code&gt;来清理多余的&lt;code&gt;Worker&lt;/code&gt;对象&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly)、
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks;
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    tryTerminate();

    int c = ctl.get();
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) &amp;gt;= min)
                return;
        }
        addWorker(null, false);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对于线程池&lt;code&gt;workers&lt;/code&gt;的操作都会进行加锁处理，然后将当前&lt;code&gt;Worker&lt;/code&gt;从池子中移除，累加当前线程池完成的任务总数&lt;code&gt;completedTaskCount&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着调用&lt;code&gt;tryTerminate()&lt;/code&gt;尝试关闭线程池，这个方法后面有详细说明。&lt;/p&gt;
&lt;p&gt;接着判断&lt;code&gt;if (runStateLessThan(c, STOP)) {}&lt;/code&gt;，含义是当前线程池状态小于&lt;code&gt;STOP&lt;/code&gt;，即当前线程池状态当前线程池状态为 &lt;code&gt;RUNNING&lt;/code&gt; 或 &lt;code&gt;SHUTDOWN&lt;/code&gt;，判断当前线程是否是正常退出。如果当前线程是正常退出，那么&lt;code&gt;completedAbruptly=false&lt;/code&gt;，接着判断线程池中是否还拥有足够多的的线程，因为异常退出可能导致线程池中线程数量不足，此时就要执行&lt;code&gt;addWorker()&lt;/code&gt;为线程池添加新的&lt;code&gt;worker&lt;/code&gt;数据，看下面的详细分析：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行最后的addWorke()有三种可能：&lt;/strong&gt;&lt;br/&gt;1）当前线程在执行&lt;code&gt;task&lt;/code&gt;时 发生异常，这里一定要创建一个新&lt;code&gt;worker&lt;/code&gt;顶上去。&lt;br/&gt;2）如果&lt;code&gt;!workQueue.isEmpty()&lt;/code&gt;说明任务队列中还有任务，这种情况下最起码要留一个线程，因为当前状态为 &lt;strong&gt;RUNNING || SHUTDOWN&lt;/strong&gt;这是前提条件。&lt;br/&gt;3）&lt;strong&gt;当前线程数量 &amp;lt; corePoolSize&lt;/strong&gt;值，此时会创建线程，维护线程池数量在&lt;code&gt;corePoolSize&lt;/code&gt;个水平。&lt;/p&gt;
&lt;h3 id=&quot;tryterminate源码分析&quot;&gt;tryTerminate()源码分析&lt;/h3&gt;
&lt;p&gt;上面移除&lt;code&gt;Worker&lt;/code&gt;的方法中有一个&lt;code&gt;tryTerminate()&lt;/code&gt;方法的调用，这个方法是根据线程池状态尝试关闭线程池。&lt;/p&gt;
&lt;p&gt;执行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074819267-437237109.png&quot; alt=&quot;tryTerminate()流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty()))
            return;
        if (workerCountOf(c) != 0) {
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    terminated();
                } finally {
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是判断线程池状态：&lt;br/&gt;条件一：isRunning(c) 成立，直接返回就行，线程池很正常！&lt;br/&gt;条件二：runStateAtLeast(c, TIDYING) 说明 已经有其它线程 在执行 TIDYING -&amp;gt; TERMINATED状态了,当前线程直接回去。&lt;br/&gt;条件三：(runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty())&lt;br/&gt;SHUTDOWN特殊情况，如果是这种情况，直接回去。得等队列中的任务处理完毕后，再转化状态。&lt;/p&gt;
&lt;p&gt;接着执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (workerCountOf(c) != 0) {
    interruptIdleWorkers(ONLY_ONE);
    return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走到这个逻辑，说明&lt;strong&gt;线程池状态 &amp;gt;= STOP或者线程池状态为&lt;code&gt;SHUTDOWN&lt;/code&gt;且队列已经空了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前线程池中的线程数量 &amp;gt; 0，调用&lt;code&gt;interruptIdleWorkers()&lt;/code&gt;中断一个空闲线程，然后返回。我们来分析下，在&lt;code&gt;getTask()&lt;/code&gt;返回为空时会执行退出逻辑&lt;code&gt;processWorkerExit()&lt;/code&gt;，这里就会调用&lt;code&gt;tryTerminate()&lt;/code&gt;方法尝试关闭线程池。&lt;/p&gt;
&lt;p&gt;如果此时线程池状态满足&lt;strong&gt;线程池状态 &amp;gt;= STOP或者线程池状态为&lt;code&gt;SHUTDOWN&lt;/code&gt;且队列已经空了&lt;/strong&gt;，如果此时线程池中线程数不为0，就会中断一个空闲线程。&lt;br/&gt;为什么这里只中断一个线程呢？这里的设计思想是，如果线程数量特别多的话，只有一个线程去做唤醒空闲&lt;code&gt;worker&lt;/code&gt;的任务可能会比较吃力，所以，就给了每个 被唤醒的&lt;code&gt;worker&lt;/code&gt;线程 ，在真正退出之前协助 唤醒一个空闲线程的任务，提供吞吐量的一种常用手段。&lt;/p&gt;
&lt;p&gt;我们顺便看下&lt;code&gt;interruptIdleWorkers()&lt;/code&gt;源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遍历&lt;code&gt;workers&lt;/code&gt;，如果线程是空闲状态&lt;strong&gt;(空闲状态：queue.take()和queue.poll()返回空)&lt;/strong&gt;，则给其一个中断信号，如果是处于&lt;code&gt;workQueue&lt;/code&gt;阻塞的线程，会被唤醒，唤醒后，进入下一次自旋时，可能会&lt;code&gt;return null&lt;/code&gt;执行退出相关的逻辑，接着又会调用&lt;code&gt;processWorkerExit()-&amp;gt;tryTerminate()&lt;/code&gt;，回到上面场景，当前线程退出的时候还是会继续唤醒下一个空现线程。&lt;/p&gt;
&lt;p&gt;接着往下看&lt;code&gt;tryTerminate&lt;/code&gt;的剩余逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final ReentrantLock mainLock = this.mainLock;
mainLock.lock();
try {
    if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
        try {
            terminated();
        } finally {
            ctl.set(ctlOf(TERMINATED, 0));
            termination.signalAll();
        }
        return;
    }
} finally {
    mainLock.unlock();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行到这里的线程是谁？&lt;br/&gt;&lt;code&gt;workerCountOf(c) == 0&lt;/code&gt; 时，会来到这里。&lt;br/&gt;最后一个退出的线程。 在 （线程池状态 &amp;gt;= STOP || 线程池状态为 SHUTDOWN 且 队列已经空了）&lt;br/&gt;线程唤醒后，都会执行退出逻辑，退出过程中 会 先将 workerCount计数 -1 =&amp;gt; ctl -1。&lt;br/&gt;调用&lt;code&gt;tryTerminate&lt;/code&gt; 方法之前，已经减过了，所以0时，表示这是最后一个退出的线程了。&lt;/p&gt;
&lt;p&gt;获取全局锁，进行加锁操作，通过&lt;code&gt;CAS&lt;/code&gt;设置线程池状态为&lt;code&gt;TIDYING&lt;/code&gt;状态，设置成功则执行&lt;code&gt;terminated()&lt;/code&gt;方法，这也是一个自定义扩展的方法，当线程池中止的时候会调用此方法。&lt;/p&gt;
&lt;p&gt;最后设置线程池状态为&lt;code&gt;TERMINATED&lt;/code&gt;状态，唤醒调用&lt;code&gt;awaitTermination()&lt;/code&gt;方法的线程。&lt;/p&gt;
&lt;h3 id=&quot;awaittermination源码分析&quot;&gt;awaitTermination()源码分析&lt;/h3&gt;
&lt;p&gt;该方法是判断线程池状态是否达到&lt;code&gt;TERMINATED&lt;/code&gt;，如果达到了则直接返回&lt;code&gt;true&lt;/code&gt;，没有达到则会&lt;code&gt;await&lt;/code&gt;挂起当前线程指定的时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (;;) {
            if (runStateAtLeast(ctl.get(), TERMINATED))
                return true;
            if (nanos &amp;lt;= 0)
                return false;
            nanos = termination.awaitNanos(nanos);
        }
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在每次执行&lt;code&gt;tryTerminate()&lt;/code&gt;后会唤醒所有被&lt;code&gt;await&lt;/code&gt;的线程，继续判断线程池状态。&lt;/p&gt;
&lt;h3 id=&quot;shutdownshutdownnow源码分析&quot;&gt;shutDown()/shutDownNow()源码分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;shutDown&lt;/code&gt;和&lt;code&gt;shutDown()&lt;/code&gt;方法都是直接改变线程池状态的方法，一般我们在系统关闭之前会调用此方法优雅的关闭线程池。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        interruptIdleWorkers();
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

public List&amp;lt;Runnable&amp;gt; shutdownNow() {
    List&amp;lt;Runnable&amp;gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt;和&lt;code&gt;shutdownNow&lt;/code&gt;方法调用差不多，只是&lt;code&gt;shutdown&lt;/code&gt;是将线程池状态设置为&lt;code&gt;SHUTDOWN&lt;/code&gt;，&lt;code&gt;shutdownNow&lt;/code&gt;是将线程池状态设置为&lt;code&gt;STOP&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;shutdownNow&lt;/code&gt;会返回所有未处理的&lt;code&gt;task&lt;/code&gt;集合。&lt;/p&gt;
&lt;p&gt;来看看它们共同调用的一些方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void advanceRunState(int targetState) {
    for (;;) {
        int c = ctl.get();
        if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
            break;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法是设置线程池状态为指定状态，&lt;code&gt;runStateAtLeast(c, targetState)&lt;/code&gt;，判断当前线程池&lt;code&gt;ctl&lt;/code&gt;值，如果小于&lt;code&gt;targetState&lt;/code&gt;则会往后执行。&lt;br/&gt;&lt;strong&gt;ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))&lt;/strong&gt;，通过&lt;code&gt;CAS&lt;/code&gt;指令，修改&lt;code&gt;ctl&lt;/code&gt;中线程池状态为传入的&lt;code&gt;targetState&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;interruptIdleWorkers&lt;/code&gt;含义是为空闲的线程设置中断标识，这里要清楚&lt;code&gt;worker&lt;/code&gt;什么时候空闲？我们在上面讲解&lt;code&gt;runWorker()&lt;/code&gt;方法时，执行&lt;code&gt;task.run()&lt;/code&gt;之前，要针对&lt;code&gt;Worker&lt;/code&gt;对象加锁，设置&lt;code&gt;Worker&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;值为1，防止运行的&lt;code&gt;worker&lt;/code&gt;被添加中断标识。接着执行&lt;code&gt;getTask()&lt;/code&gt;方法，获取阻塞队列中的任务，如果是&lt;code&gt;queue.take()&lt;/code&gt;则会阻塞挂起当前线程，释放锁，此时线程处于空闲状态。如果是&lt;code&gt;queue.pool()&lt;/code&gt;返回为空，&lt;code&gt;runWorker()&lt;/code&gt;会释放锁，此时线程也是空闲状态。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;interrupt()&lt;/code&gt;后处于&lt;code&gt;queue&lt;/code&gt;阻塞的线程，会被唤醒，唤醒后，进入下一次自旋判断线程池状态是否改变，如果改变可能直接返回空，这里具体参看&lt;code&gt;runWorker()&lt;/code&gt;和&lt;code&gt;getTask()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onShutdown()&lt;/code&gt;也是一个扩展方法，需要子类去重写，这里代表当线程池关闭后需要做的事情。&lt;code&gt;drainQueue()&lt;/code&gt;方法是获取&lt;code&gt;workQueue&lt;/code&gt;中现有的的任务列表。&lt;/p&gt;
&lt;h3 id=&quot;问题回顾&quot;&gt;问题回顾&lt;/h3&gt;
&lt;ol readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中常用参数有哪些？&lt;br/&gt;上面介绍过了，参见的参数是指ThreadPoolExecutor的构造参数，一般面试的时候都会先问这个，要解释每个参数的含义及作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中线程池状态和线程数量如何存储的？&lt;br/&gt;通过AtomicInteger类型的变量ctl来存储，前3位代表线程池状态，后29位代表线程池中线程数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;有哪些状态，状态之间流转是什么样子的？&lt;br/&gt;RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816572-2061701085.png&quot; alt=&quot;线程池的状态流转.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;任务处理策略？&lt;br/&gt;这个问题就是考察&lt;code&gt;execute()&lt;/code&gt;的执行过程，只要看过源码就不会有问题。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074816113-1232911533.png&quot; alt=&quot;执行流程.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;常用的拒绝策略有哪些？&lt;br/&gt;策略处理该任务，线程池提供了4种策略：&lt;br/&gt;1）AbortPolicy：直接抛出异常，默认策略&lt;br/&gt;2）CallerRunsPolicy：用调用者所在的线程来执行任务&lt;br/&gt;3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务&lt;br/&gt;4）DiscardPolicy：直接丢弃任务&lt;br/&gt;当然线程池是支持自定义拒绝策略的，需要实现RejectedExecutionHandler接口中rejectedExecution()方法即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;Executors&lt;/code&gt;工具类提供的线程池有哪些？有哪些缺陷？&lt;br/&gt;1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;br/&gt;2） CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;br/&gt;所以阿里巴巴也建议我们要自定义线程池核心线程数以及阻塞队列的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;核心线程池中线程预热功能？&lt;br/&gt;在创建线程池后，可以使用prestartAllCoreThreads()来预热核心线程池。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int prestartAllCoreThreads() {
    int n = 0;
    while (addWorker(null, true))
        ++n;
    return n;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中创建的线程如何被复用的？&lt;br/&gt;这个主要是看runWorker()和getTask()两个方法的执行流程，当执行任务时调用runWorker()方法，执行完成后会继续从workQueue中获取任务继续执行，已达到线程复用的效果，当然这里还有一些细节，可以回头看看上面的源码解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中关闭线程池的方法&lt;code&gt;shutdown&lt;/code&gt;与&lt;code&gt;shutdownNow&lt;/code&gt;的区别？&lt;br/&gt;最大的区别就是shutdown()会将线程池状态变为SHUTDOWN，此时新任务不能被提交，workQueue中还存有的任务可以继续执行，同时会像线程池中空闲的状态发出中断信号。&lt;br/&gt;shutdownNow()方法是将线程池的状态设置为STOP，此时新任务不能被提交，线程池中所有线程都会收到中断的信号。如果线程处于wait状态，那么中断状态会被清除，同时抛出InterruptedException。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中存在的一些扩展点？&lt;br/&gt;钩子方法：&lt;br/&gt;1）beforeExecute()/afterExecute()：runWorker()中线程执行前和执行后会调用的钩子方法&lt;br/&gt;2）terminated：线程池的状态从TIDYING状态流转为TERMINATED状态时terminated方法会被调用的钩子方法。&lt;br/&gt;3）onShutdown：当我们执行shutdown()方法时预留的钩子方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;支持动态调整核心线程数、最大线程数、队列长度等一些列参数吗？怎么操作？&lt;br/&gt;运行期间可动态调整参数的方法：&lt;br/&gt;1）setCorePoolSize()：动态调整线程池核心线程数&lt;br/&gt;2）setMaximumPoolSize()：动态调整线程池最大线程数&lt;br/&gt;3）setKeepAliveTime(): 空闲线程存活时间，如果设置了allowsCoreThreadTimeOut=true，核心线程也会被回收，默认只回收非核心线程&lt;br/&gt;4）allowsCoreThreadTimeOut()：是否允许回收核心线程，如果是true，在getTask()方法中，获取workQueue就采用workQueue.poll(keepAliveTime)，如果超过等待时间就会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这篇线程池源码覆盖到了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中大部分代码，我相信认真阅读完后肯定会对线程池有更深刻的理解。如有疑问或者建议可关注公众号给我私信，我都会一一为大家解答。&lt;/p&gt;
&lt;p&gt;另外推荐一个我的up主朋友，他自己录制了好多学习视频并分享在B站上了，大家有时间可以看一下(PS:非恰饭非利益相关,良心推荐)：&lt;a href=&quot;https://space.bilibili.com/457326371&quot;&gt;小刘讲源码-B站UP主&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202005/799093-20200524074819905-744340834.png&quot; alt=&quot;原创干货分享.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 23:48:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>碎碎念 关于JDK源码相关的文章这已经是第四篇了，原创不易，粉丝从几十人到昨天的 人，真的很感谢之前帮我转发文章的一些朋友们。 从16年开始写技术文章，到现在博客园已经发表了 篇文章，大多数都是原创，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12945703.html</dc:identifier>
</item>
<item>
<title>计算机组成原理 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/12896053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/12896053.html</guid>
<description>&lt;h2 id=&quot;计算机发展史（四个阶段）&quot;&gt;计算机发展史（四个阶段）&lt;/h2&gt;
&lt;h3 id=&quot;第一阶段（19461957）：电子管计算机&quot;&gt;第一阶段（1946~1957）：电子管计算机&lt;/h3&gt;
&lt;p&gt;  世界上第一台计算机叫埃尼阿克(ENIAC)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200515152842804-1442177330.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  第二次世界大战是电子管计算机产生的催化剂（英国为了解密德国海军的密文），在第二次世界大战中，战争使用了飞机和火箭，打得准需要计算设计参数，设计参数需要几千次运算才能计算出来，在没有计算机之前 ，这些都需要人工手动去计算，埃尼阿克的计算速度大约是手工计算的20万倍。&lt;/p&gt;&lt;p&gt;  埃尼阿克(ENIAC)由18000多个电子管，运行耗电量达150千瓦，重量达30吨，占地1500平方英尺。由此可见，第一阶段的电子管计算机，集成度小，空间占用大，功耗高，运行速度慢，操作复杂，更换程序需要接线。&lt;/p&gt;
&lt;h3 id=&quot;第二阶段（19571964）：晶体管计算机&quot;&gt;第二阶段（1957~1964）：晶体管计算机&lt;/h3&gt;
&lt;p&gt;  贝尔实验室的三个科学家发明了晶体管，第一台晶体管计算机产生于麻省理工大学的林肯实验室。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200515153332293-1539746731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三阶段（19641980）：集成电路计算机&quot;&gt;第三阶段（1964~1980）：集成电路计算机&lt;/h3&gt;
&lt;p&gt;  德州仪器的工程师发明了集成电路(IC)，后面就有了集成电路计算机，集成电路计算机让计算机具备进入千家万户的条件。因为集成电路使计算机变得更小，功耗变得更低，计算速度变得更快。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200515153816072-775934291.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  关于集成电路计算机，IBM当时主要推出了两款计算机，使用量比较大，分别是7094和1401，但这两款计算机的主打功能不同，而且相互无法兼容，公司也不愿意投入两组人力，于时后来IBM推出了兼容的产品System/360，这也是操作系统的雏形。&lt;/p&gt;
&lt;h3 id=&quot;第四阶段（1980至今）：超大规模集成电路计算机&quot;&gt;第四阶段（1980~至今）：超大规模集成电路计算机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200515154251145-1330897804.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  超大规模集成电路，一个芯片上集成了上百万的晶体管，这样使超大规模集成电路计算机速度更快，价格更低，体积更小，更能被大众所接受，而且用途丰富，可以用作文本处理，表格处理，高交互的由于与应用等。&lt;/p&gt;
&lt;h2 id=&quot;计算机的分类&quot;&gt;计算机的分类&lt;/h2&gt;
&lt;h3 id=&quot;超级计算机&quot;&gt;超级计算机&lt;/h3&gt;
&lt;p&gt;  功能最强、运算速度最快、存储容量最大的计算机，多用于国家高科技领域和尖端技术研究。&lt;/p&gt;&lt;p&gt;  运算速度单位是TFlop/s，1TFlob/s=每秒一万亿次浮点数计算&lt;/p&gt;
&lt;h3 id=&quot;大型计算机&quot;&gt;大型计算机&lt;/h3&gt;
&lt;p&gt;  大型计算机又称大型机、大型主机、主机等；具有高性能，可处理大数据与复杂的运算；在大型机市场领域，IBM占据着很大的份额。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200515161512619-2005853951.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  去&quot;IOE&quot;行动，&quot;IOE&quot;是分别指IBM，Oracle，EMC，去&quot;IOE&quot;是阿里巴巴提出的概念，代表了高维护费用的存储系统，不够灵活，伸缩性弱。阿里巴巴在2008年提出去“IOE”行动，在2009年成立了阿里云。&lt;/p&gt;
&lt;h3 id=&quot;迷你计算机（服务器）&quot;&gt;迷你计算机（服务器）&lt;/h3&gt;
&lt;p&gt;  迷你计算机也称为小型机，即普通服务器，不需要特殊的空调场所，具备不错的算力，可以完成较复杂的运算。普通的服务器已经替代了传统的大型机，成为大规模企业计算的中枢。&lt;/p&gt;
&lt;h3 id=&quot;工作站&quot;&gt;工作站&lt;/h3&gt;
&lt;p&gt;  高端的通用微型计算机，提供比个人计算机更强大的性能，类似于普通台式电脑，体积较大，但性能较强。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518093349715-365884057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;微型计算机&quot;&gt;微型计算机&lt;/h3&gt;
&lt;p&gt;  微型计算机又称为个人计算机，是最普通的一类计算机。麻雀虽小，五脏俱全，从构成的体质上来讲，个人计算机与前面的分类的无异。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518093456563-573942672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;计算机的体系与结构&quot;&gt;计算机的体系与结构&lt;/h2&gt;
&lt;h3 id=&quot;冯诺依曼体系&quot;&gt;冯诺依曼体系&lt;/h3&gt;
&lt;p&gt;  冯诺依曼体系：将程序指令和数据一起存储的计算机设计概念结构。在冯诺依曼体系出现前，早期的计算机仅含固定用途程序，如改变程序就需要更改结构，重新设计电路，也就是不能先打会儿游戏然后再写会儿代码，这样就很影响我们的使用体验，所以就提出将程序存储起来，并设计成通用电路，即存储程序指令，设计通用电路。&lt;/p&gt;&lt;p&gt;  冯诺依曼体系提出：计算机必须有一个存储器、有一个控制器、有一个计算器、有输入设备和输出设备。这样就能够把需要的程序和数据送至计算机中（输入设备），能够长期记忆程序、数据、中间结果及最终运算结果的能力（存储器），能够具备算术、逻辑运算和数据传送等数据加工处理的能力（运算器、控制器），能够按照要求将处理结果输出给用户（输出设备）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518100037915-520738348.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  由于CPU处理数据的速度要远快于存储器的存储速度，所以CPU和存储器的分开会造成芬诺伊曼瓶颈，也就是CPU和存储器之间的速率问题无法调和。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518100309828-787927447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;现代计算机的结构&quot;&gt;现代计算机的结构&lt;/h3&gt;
&lt;p&gt;  现代计算机在冯诺曼体系结构基础上进行修改，解决CPU与存储设备之间的性能差异问题。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518100800974-851829423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;计算机的层次与编程语言&quot;&gt;计算机的层次与编程语言&lt;/h2&gt;
&lt;h3 id=&quot;程序翻译与程序解释&quot;&gt;程序翻译与程序解释&lt;/h3&gt;
&lt;p&gt;  我们将人类语言变为计算机能看懂的语言，需要进行语言之间的转换。程序翻译就是将较为高级的计算机语言L1转为较为低级的计算机语言L0（编译器），L0就是计算机实际执行的语言。程序解释就是把较为高级的语言L1，作为用L0语言实现的一个程序的输入，然后得到较为低级计算机语言L0。&lt;/p&gt;&lt;p&gt;程序翻译与程序解释的对比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算机实际执行的指令都是L0&lt;/li&gt;
&lt;li&gt;翻译过程生成新的L0程序，解释过程不生成新的L0程序&lt;/li&gt;
&lt;li&gt;解释过程由L0编写解释器去执行L1程序&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;  程序翻译的常见语言：C/C++, Object-C, Golang; 程序解释的常见语言：Python, Php, JavaScript。而Java和C#是属于翻译加解释性语言，Java程序转为JVM字节码的过程是程序翻译，由JVM字节码变成机器码的过程是程序解释。&lt;/p&gt;
&lt;h3 id=&quot;计算机的层次&quot;&gt;计算机的层次&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200518112250694-1114408992.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;硬件逻辑层：门、触发器等逻辑电路组成，属于电子工程领域。&lt;br/&gt;微程序机器层：编程语言是微指令集，微指令所组成的微程序直接交由硬件执行。&lt;br/&gt;传统机器层：编程语言是CPU指令集（机器指令），编程语言和硬件直接相关，不同架构的CPU使用不同的指令集。一条机器指令对应一个微程序，一个微程序对应一组机器指令。&lt;br/&gt;&lt;span&gt;操作系统层：向上提供了简易的操作界面，向下对接了指令系统，管理硬件资源，操作系统层是硬件和软件之间的适配层。&lt;/span&gt;&lt;br/&gt;汇编语言层：编程语言是汇编语言，汇编语言可以&lt;span&gt;翻译&lt;/span&gt;成可直接执行的机器语言，完成翻译过程的程序就叫汇编器。&lt;br/&gt;高级语言层：编程语言为广大程序员所接受的高级语言，高级语言的种类非常多，有几百种，常见的高级语言有C/C++、Java、Python、Golang等。&lt;br/&gt;应用层：满足计算机针对某种用途而专门设计，例如常见的办公软件Excel,Word,PPT等。&lt;/p&gt;
&lt;h2 id=&quot;计算机的字符与编码集&quot;&gt;计算机的字符与编码集&lt;/h2&gt;
&lt;p&gt;  使用7个bits就可以完全表示ASCII码，包含95个可打印字符，33个不可打印字符（包括控制字符），即 33+95=128=2&lt;sup&gt;7&lt;/sup&gt;，但是这个ASCII码在很多应用和很多国家中的符号都无法表示，例如数学符号：“&lt;span class=&quot;math inline&quot;&gt;\(\div\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\neq\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\geq\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\approx\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;”。所以在第一次对ASCII码进行扩充时，7bits=&amp;gt; 8bits，在可拓展的ASCII码中，包含了常见的运算符，带音标的欧洲字符，和其他常用符、表格等。&lt;/p&gt;&lt;p&gt;  字符编码集的国际化：由于欧洲、中亚、东亚、拉丁美洲国家的语言多样性，造成语言体系不一样，不以有限字符组合的语言，尤其是中国、韩国、日本的语言最为复杂。国标2312（GB2312）：《信息交换用汉字编码字符集-基本集》是中文编码集，一共收录了7445个字符，包括6763个汉字和682个其他符号。Unicode(统一码、万国码、单一码)定义了世界通用的符号集，UTF-*实现了编码，UTF-8以字节为单位对Unicode进行编码。Unicode是兼容全球的字符集。&lt;/p&gt;
&lt;h2 id=&quot;计算机的总线与io设备&quot;&gt;计算机的总线与IO设备&lt;/h2&gt;
&lt;h3 id=&quot;计算机的总线&quot;&gt;计算机的总线&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是总线？&lt;/strong&gt;&lt;br/&gt;  总线提供了对外的接口，不同设备可以通过USB（Universal Serial Bus）接口进行连接，连接的标准，促使外围设备接口的统一。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200519155529105-680019491.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  当我们的输入设备向计算机中输入信息，要求计算机给出指定输出时，这时需要IO总线来进行总线连接。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总线的分类？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;片内总线：芯片内部的总线，寄存器与寄存器之间，寄存器与控制器、运算器之间。片内总线是高集成度芯片内部的信息传输线。&lt;/li&gt;
&lt;li&gt;系统总线：CPU、主内存、IO设备、各组件之间的信息传输线
&lt;ul&gt;&lt;li&gt;数据总线：双向传输各个部件的数据信息，数据总线的位数（总线宽度）是数据总线的重要参数，一般与CPU位数相同（32位、64位）&lt;/li&gt;
&lt;li&gt;地址总线：指定源数据或目的数据在内存中的地址，地址总线的位数与存储单元有关。若地址总线位数=n，寻址范围：0~2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;控制总线：控制总线是用来发出各种控制信号的传输线，控制信号经由控制总线从一个组件发给另外一个组件，控制总线可以监视不同组件之间的状态（就绪/未就绪）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;总线的仲裁&lt;/strong&gt;：为了解决总线使用权的冲突问题&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总线的仲裁方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链式查询：好处：电路复杂度低，仲裁方式简单；坏处：优先级低的设备难以获得总线的使用权，对电路故障敏感。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200519164108924-1963349559.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;计时器定时查询&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200519164314542-1634086741.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;独立请求
&lt;ul&gt;&lt;li&gt;每个设备均有总线独立连接仲裁器&lt;/li&gt;
&lt;li&gt;设备可单独向仲裁器发送请求和接受请求&lt;/li&gt;
&lt;li&gt;当同时收到多个请求信号，仲裁器有权按优先级分配使用权&lt;/li&gt;
&lt;li&gt;好处：响应速度快，优先顺序可动态改变，设备连线多，总线控制复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常见的io设备&quot;&gt;常见的IO设备&lt;/h3&gt;
&lt;p&gt;  常见的输入设备：分为字符输入设备和图像输入设备。字符输入设备就如键盘，图像输入设备如鼠标、数位板、扫描仪等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200519165414268-199197982.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  常见的输出设备：显示器、打印机、投影仪&lt;/p&gt;&lt;p&gt;  输入输出接口的通用设计：我们需要考虑如何向设备发送数据？如何读取数据？该设备有没被占用？设备是否已经启动？设备是否已经连接？等等还有其他问题，基于对输入输出设备接口通用设计的考虑，至少应该有以下几部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据线
&lt;ul&gt;&lt;li&gt;是I/O设备与主机之间进行数据交换的传送线&lt;/li&gt;
&lt;li&gt;单向传输数据线&lt;/li&gt;
&lt;li&gt;双向传输数据线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;状态线
&lt;ul&gt;&lt;li&gt;IO设备状态向主机报告的信号线&lt;/li&gt;
&lt;li&gt;查询设备是否已经正常连接并就绪&lt;/li&gt;
&lt;li&gt;查询设备是否已经被占用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令线
&lt;ul&gt;&lt;li&gt;CPU向设备发送命令的信号线&lt;/li&gt;
&lt;li&gt;发送读写信号&lt;/li&gt;
&lt;li&gt;发送启动停止信号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设备选择线
&lt;ul&gt;&lt;li&gt;主机选择I/O设备进行操作的信号线&lt;/li&gt;
&lt;li&gt;对连在总线上的设备进行选择&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算机的存储器&quot;&gt;计算机的存储器&lt;/h2&gt;
&lt;p&gt;存储器的分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按存储介质分：
&lt;ul&gt;&lt;li&gt;半导体存储器：例如内存、U盘、固态硬盘&lt;/li&gt;
&lt;li&gt;磁存储器：例如磁带、磁盘等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;按存取方式分类：
&lt;ul&gt;&lt;li&gt;随机存储器（RAM）：随机读取，与位置无关&lt;/li&gt;
&lt;li&gt;串行存储器：与位置有关，按顺序查找&lt;/li&gt;
&lt;li&gt;只读存储器（ROM）：只读不写，BIOS就是存储在只读存储器中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;存储器的层次：&lt;br/&gt;  对于存储器，我们希望它读写速度快，存储容量大，而价格最好低一些。存储器的层次结构如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200521163107643-503731794.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  缓存：指的就是CPU中的寄存器以及高速缓存；主存：计算机中的内存；辅存：计算机的外部存储设备，比如磁盘、U盘、移动硬盘等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200521163646807-921562408.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;缓存-主存层次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原理：局部性原理，局部性原理就是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋集于在一个较小的连续区域中。&lt;/li&gt;
&lt;li&gt;实现：在CPU与主存之间增加一层速度快（容量小）的Cache&lt;/li&gt;
&lt;li&gt;目的：&lt;span&gt;解决主存速度不足的问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;主存-辅存层次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原理：局部性原理&lt;/li&gt;
&lt;li&gt;实现：主存之外增加辅助存储器（磁盘，SD卡，U盘等）&lt;/li&gt;
&lt;li&gt;目的：&lt;span&gt;解决主存容量不足的问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;  计算机突然断电，内存数据就会丢失，但是计算机断电，磁盘数据不会丢失。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主存储器——内存
&lt;ul&gt;&lt;li&gt;RAM（随机存取存储器 ：Random Access Memory）&lt;/li&gt;
&lt;li&gt;RAM通过&lt;span&gt;电容&lt;/span&gt;存储数据，必须隔一段时间刷新一次&lt;/li&gt;
&lt;li&gt;如果断电，那么一段时间后将丢失所有数据&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200521165713071-147182474.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;对于32位系统，计算机内存最大为 2&lt;sup&gt;32&lt;/sup&gt; = 4&lt;sup&gt;30&lt;/sup&gt; = 4GB，对于64为系统，计算机内存最大为 2&lt;sup&gt;64&lt;/sup&gt; = 2&lt;sup&gt;34&lt;/sup&gt; x 2&lt;sup&gt;30&lt;/sup&gt; = 2&lt;sup&gt;34&lt;/sup&gt;GB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辅助存储器——磁盘
&lt;ul&gt;&lt;li&gt;表面是可磁化的硬磁特性材料&lt;/li&gt;
&lt;li&gt;移动磁头径向运动读取磁道信息&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200521170338917-1253978303.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;计算机的辅助存储器常用算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;先来先服务算法&lt;/li&gt;
&lt;li&gt;最短寻道时间优先
&lt;ul&gt;&lt;li&gt;与磁头当前位置有关&lt;/li&gt;
&lt;li&gt;优先访问离磁头最近的磁道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;扫描算法（电梯算法）&lt;/li&gt;
&lt;li&gt;循环扫描算法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算机的高速缓存&quot;&gt;计算机的高速缓存&lt;/h2&gt;
&lt;h3 id=&quot;高速缓存的工作原理&quot;&gt;高速缓存的工作原理&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;&lt;span&gt;字&lt;/span&gt;&lt;/strong&gt;：是指存放在一个存储单元中的二进制代码组合&lt;br/&gt;  &lt;strong&gt;&lt;span&gt;字块&lt;/span&gt;&lt;/strong&gt;：存储在连续的存储单元中而被看作是一个单元的一组字节&lt;br/&gt;  一个字快有32位，一个字快共B个字，主存中共M个字块，则主存总字数=B*M，主存总容量(bits)=B*M*32。字的地址包含两部分：前m位指定字快的地址，后b位指定字在字快中的地址。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200522111951957-248737695.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;span&gt;例子：假设主存用户空间容量位4G，字快大小为4M，字长为32位，则对于字地址中的快地址m和块内地址b的位数，至少应该是多少？&lt;/span&gt;&lt;br/&gt;  由于1G=1024M，所以4G=4096M，由于字快大小为4M，所以字快数为：&lt;span class=&quot;math inline&quot;&gt;\(4096\div4=1024\)&lt;/span&gt;，所以字快地址m=&lt;span class=&quot;math inline&quot;&gt;\(\log_2 1024=10\)&lt;/span&gt;，块内字数为&lt;span class=&quot;math inline&quot;&gt;\(4M\div32bit=1048576bit\)&lt;/span&gt;，块内地址b=&lt;span class=&quot;math inline&quot;&gt;\(\log_2 1048576=20\)&lt;/span&gt;，所以快地址m的位数至少为10，块内地址b的位数最少为20。&lt;/p&gt;&lt;p&gt;  我们已经知道在CPU与主存之间存在高速缓存，当CPU需要的数据在缓存里时，则CPU直接从高度缓存中读取数据即可，不需要去访问主存，但当CPU需要的数据不在缓存里时，则需要去主存拿。由于CPU的处理速度远远快于主存的读取速度和数据传输速度，所以这样会导致CPU空转来等待数据传输，造成资源上的浪费。所以我们尽可能的让CPU去高速缓存中读取数据，因此我们需要一个量化指标，这个量化指标就是&lt;span&gt;命中率&lt;/span&gt;。命中率是衡量缓存的重要性能指标，理论上CPU每次都能从高速缓存中读取数据的时候，命中率为1。假设访问主存次数为&lt;span class=&quot;math inline&quot;&gt;\(N_m\)&lt;/span&gt;，访问Cache次数为：&lt;span class=&quot;math inline&quot;&gt;\(N_c\)&lt;/span&gt;，则命中率h为：&lt;span class=&quot;math inline&quot;&gt;\(h=\frac{N_c}{N_c+N_m}\)&lt;/span&gt;。现在来看看访问效率e，假设访问主存时间为&lt;span class=&quot;math inline&quot;&gt;\(t_m\)&lt;/span&gt;，访问缓存时间为&lt;span class=&quot;math inline&quot;&gt;\(t_c\)&lt;/span&gt;，则访问Cache-主存系统的平均时间为：&lt;span class=&quot;math inline&quot;&gt;\(t_a=ht_c+(1-h)t_m\)&lt;/span&gt;，则访问效率e为：&lt;span class=&quot;math inline&quot;&gt;\(e=\frac{t_c}{t_a}=\frac{t_c}{ht_c+(1-h)t_m}\)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例子：假设CPU在执行某段程序时，共访问了Cache命中2000次，访问主存50次，已知Cache的存取时间为50ns，主存的存取时间为200ns，求Cache-主存系统中的命中率、访问效率和平均访问时间。&lt;/span&gt;&lt;br/&gt;    命中率：&lt;span class=&quot;math inline&quot;&gt;\(h=\frac{N_c}{N_c+N_m}=\frac{2000}{2000+50}=0.97\)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    访问效率：&lt;span class=&quot;math inline&quot;&gt;\(e=\frac{t_c}{t_a}=\frac{t_c}{ht_c+(1-h)t_m}=\frac{50}{0.97\ast50+(1-0.97)200}=0.917=91.7\%\)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    平均访问时间：&lt;span class=&quot;math inline&quot;&gt;\(0.97\ast50+(1-0.97)200=54.5ns\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;高速缓存的替换策略&quot;&gt;高速缓存的替换策略&lt;/h3&gt;
&lt;p&gt;  由于高速缓存的运行需要良好的缓存替换策略。什么是缓存替换策略呢？就是当高速缓存中没有数据时，需要从主存中载入所需要的数据。高速缓存中常见的替换策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随机算法&lt;/li&gt;
&lt;li&gt;先进先出算法（FIFO）&lt;/li&gt;
&lt;li&gt;最不经常使用算法（LFU）
&lt;ul&gt;&lt;li&gt;优先淘汰最不经常使用的字快&lt;/li&gt;
&lt;li&gt;需要额外的空间记录字快的使用频率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最近最少使用算法（LRU）
&lt;ul&gt;&lt;li&gt;优先淘汰一段时间内没有使用的字快&lt;/li&gt;
&lt;li&gt;有多种实现方法，一般使用双向链表&lt;/li&gt;
&lt;li&gt;把当前访问节点置于链表前面（保证链表头部节点是经常使用的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算机的指令系统&quot;&gt;计算机的指令系统&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;机器指令的形式&lt;br/&gt;  机器指令主要有两部分组成：操作码、地址码。地址码直接给出操作数和操作数的地址，分三地址指令、二地址指令和一地址指令，最后还有零地址指令，零地址指令在机器指令中没有地址码，用来进行空操作、停机操作、中断返回操作等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200522174700761-1861243175.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;机器指令的操作类型：
&lt;ul&gt;&lt;li&gt;数据传输：在寄存器之间、寄存器与存储单元、存储单元之间传送；还可以进行数据独写、交换地址数据、清零置一等操作。&lt;/li&gt;
&lt;li&gt;算术逻辑操作：操作数之间的加减乘除运算；操作数的与或非等逻辑运算&lt;/li&gt;
&lt;li&gt;移位操作：数据左移（乘2）、数据右移（除2）；完成数据在算术逻辑单元的必要操作。&lt;/li&gt;
&lt;li&gt;控制指令：主要有等待指令、停机指令、空操作指令、中断指令等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;机器指令的寻址方式
&lt;ul&gt;&lt;li&gt;指令寻址：顺序寻址；跳跃寻址&lt;/li&gt;
&lt;li&gt;数据寻址：
&lt;ul&gt;&lt;li&gt;立即寻址：指令直接获得操作数，无需访问存储器&lt;/li&gt;
&lt;li&gt;直接寻址：直接给出操作数在主存中的地址，寻找操作数简单，无需计算数据地址&lt;/li&gt;
&lt;li&gt;间接寻址：指令地址码给出的是操作数地址的地址，需要访问一次或多次主存来获取操作数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;寻址方式&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;立即寻址&lt;/td&gt;
&lt;td&gt;速度块&lt;/td&gt;
&lt;td&gt;地址码位数限制操作数表示范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;直接寻址&lt;/td&gt;
&lt;td&gt;寻找操作数简单&lt;/td&gt;
&lt;td&gt;地址码位数限制操作数表示范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;间接寻址&lt;/td&gt;
&lt;td&gt;操作数寻址范围大&lt;/td&gt;
&lt;td&gt;速度较慢&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;计算机的控制器&quot;&gt;计算机的控制器&lt;/h2&gt;
&lt;p&gt;控制器是协调和控制计算机运行的，计算机的控制器主要组成部分如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序计数器：程序计数器用来存储下一条指令的地址；循环从程序计数器中拿出指令；当指令被拿出时，指向下一条指令&lt;/li&gt;
&lt;li&gt;时序发生器：电气工程领域，用于发送时序脉冲；CPU根据不同的时序脉冲有节奏的进行工作&lt;/li&gt;
&lt;li&gt;指令译码器：指令译码器是控制器主要部件之一，计算机指令由操作码和地址码组成，翻译操作码对应的操作以及控制传输地址码对应的数据&lt;/li&gt;
&lt;li&gt;各种寄存器
&lt;ul&gt;&lt;li&gt;指令寄存器：指令寄存器也是控制器的主要部件之一，从主存或高速缓存读取计算机指令&lt;/li&gt;
&lt;li&gt;主存地址寄存器：保存当前CPU正要访问的内存单元的地址&lt;/li&gt;
&lt;li&gt;主存数据寄存器：保存当前CPU正要读或写的内存数据&lt;/li&gt;
&lt;li&gt;通用寄存器：用于暂时存放或传送数据和指令，可保存ALU的运算中间结果，容量比一般的专用寄存器要大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总线&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算机的运算器&quot;&gt;计算机的运算器&lt;/h2&gt;
&lt;p&gt;运算器是用来进行数据加工运算的，主要组成部分如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据缓冲器：分为输入缓冲和输出缓冲，输入缓冲暂时存放外设送过来的数据；输出缓冲暂时存放送往外设的数据&lt;/li&gt;
&lt;li&gt;ALU：算术逻辑单元，是运算器的主要组成，常见的位运算（左右移、与或非等），算数运算（加减乘除等）&lt;/li&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;状态字寄存器：存放运算状态（条件码、进位、溢出、结果正负等）；存放运算控制信息（调试跟踪标记位、允许中断位等）&lt;/li&gt;
&lt;li&gt;总线&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算篇&quot;&gt;计算篇&lt;/h2&gt;
&lt;h3 id=&quot;进制概述&quot;&gt;进制概述&lt;/h3&gt;
&lt;p&gt;  进制是一种计数方式，亦称为进位计数法或位值计数法，用有限种数字符号来表示无线的数值，使用的数字符号的数目称为这种进位制的基数或底数。例如n=10[0-9]称为十进制；还有例如玛雅文明的玛雅数字，因努伊特的因努伊特数字使用的就是二十进制；像时间、坐标、角度等量化数据使用的就是六十进制。但我们使用的计算机喜欢二进制，但是使用二进制表达太长了，使用大进制可以解决这个问题，计算机常用的大进制有八进制、十六进制。因为八进制和十六进制都满足2的n次方要求。例如1024分别使用二进制、八进制、十六进制表示为：1024 = 0b1000000000 = oO2000 = ox400&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制的运算基础&quot;&gt;二进制的运算基础&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.整数十进制和二进制的互相转换&lt;/span&gt;&lt;br/&gt;  (整数)十进制转换二进制：重复相除法。例子：十进制数101转为二进制：如下&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重复除以2&lt;/th&gt;
&lt;th&gt;得商&lt;/th&gt;
&lt;th&gt;取余数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;101/2&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;50/2&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;25/2&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;12/2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6/2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3/2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1/2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  最后，倒着取余数，所以101的二进制表示是：1100101。二进制转为十进制使用的是按权展开法：&lt;span class=&quot;math inline&quot;&gt;\(1100101 = 1 \times 2^6 + 1 \times 2^5 + 0 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 +0 \times 2^1 + 1 \times 2^0 = 101\)&lt;/span&gt;&lt;br/&gt;  再举一个例子：十进制数237转为二进制，如下&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重复除以2&lt;/th&gt;
&lt;th&gt;得商&lt;/th&gt;
&lt;th&gt;取余数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;237/2&lt;/td&gt;
&lt;td&gt;118&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;118/2&lt;/td&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;59/2&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;29/2&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;14/2&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7/2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3/2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1/2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  最后倒着取数，所以237的二进制表示是：11101101。使用按权展开法把二进制转为十进制：&lt;span class=&quot;math inline&quot;&gt;\(11101101 = 1 \times 2^7 + 1 \times 2^6 + 1 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 1 \times 2^2 +0 \times 2^1 + 1 \times 2^0 = 237\)&lt;/span&gt;&lt;br/&gt;  二进制转为十进制：按权展开法的的计算公式如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(N = d_{n-1}d_{n-2}...d_1d_0 = d_{n-1}r^{n-1} + d_{n-2}r^{n-2} + d_1r +d_0\)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.小数十进制和二进制的互相转换&lt;/span&gt;&lt;br/&gt;  如果这个十进制是小数，则使用重复相乘法。例如 &lt;span class=&quot;math inline&quot;&gt;\(\frac{25}{32}\)&lt;/span&gt;转为二进制，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;重复乘以2&lt;/th&gt;
&lt;th&gt;得积&lt;/th&gt;
&lt;th&gt;取整&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{25}{32} \times 2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{25}{16} = 1+\frac{9}{16}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{9}{16} \times 2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{9}{8} = 1+\frac{1}{8}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{8} \times 2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{4} = 0+\frac{1}{4}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{4} \times 2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2} = 0+\frac{1}{2}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2} \times 2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1 = 1+0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  最后顺着取整数：&lt;span class=&quot;math inline&quot;&gt;\(\frac{25}{32}\)&lt;/span&gt;的二进制表示为：0.11001。现在再使用按权展开法把二进制转为十进制数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(N = 0.11001 = 1 \times 2^{-1} + 1 \times 2^{-2} + 0 \times 2^{-3} + 0 \times 2^{-4} + 1 \times 2^{-5} = 0.78125 = \frac{25}{32}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;有符号数和无符号数&quot;&gt;有符号数和无符号数&lt;/h3&gt;
&lt;p&gt;  正的237使用二进制表示为：+237 = 011101101 ，负的237使用二进制表示为：-237 = 111101101，在计算机中，使用0表示正数，使用1表示负数。但计算机是怎么判断它是数字位还是符号位的呢？这就需要使用原码表示法了，在原码表示法中，使用0表示正数，使用1表示负数，规定符号位位于数值的第一位，表达简单明了，是我们最容易理解的表示法。0有两种表示法：00或10，在使用原码进行运算时，会非常复杂，特别是两个操作符号不同的时候，我们需要进行判断两个操作数得绝对值大小，使用绝对值大的数减去绝对值小的数，对于符号值，以绝对值大的为准。因此我们希望找不到不同符号操作数运算更加简单得方法，也就是可以使用正数来代替负数，使用加法操作来代替减法操作，从而消除减法。于是出现了二进制的补码表示法，补码的定义如下：&lt;/p&gt;
&lt;p&gt;\[x = \begin{cases} x &amp;amp; 2^{n} &amp;gt; x \geq 0 \\ 2^{n+1} + x &amp;amp; 0 &amp;gt; x \geq -2^n \end{cases} \]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：x=-13，计算x的二进制原码和补码&lt;/span&gt;&lt;br/&gt;原码：x=1,1101&lt;/p&gt;
&lt;p&gt;补码：&lt;span class=&quot;math inline&quot;&gt;\(2^{n+1} + x = 2^{4+1} - 13 = 100000 - 1101 = 10011\)&lt;/span&gt;,这里的最高位1是符号位&lt;br/&gt;补码：x = 1,0011&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：x=-7，计算x的二进制原码和补码&lt;/span&gt;&lt;br/&gt;原码：x=1,0111&lt;br/&gt;补码：&lt;span class=&quot;math inline&quot;&gt;\(2^{n+1} + x = 2^{4+1} - 7 = 100000 - 0111 = 1 1001\)&lt;/span&gt;,这里的最高位1是符号位&lt;br/&gt;补码：x = 1,1001&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例3：x=-1，计算x的二进制原码和补码&lt;/span&gt;&lt;br/&gt;原码：x=1,0001&lt;br/&gt;补码：&lt;span class=&quot;math inline&quot;&gt;\(2^{n+1} + x = 2^{4+1} - 1 = 100000 - 0001 = 1 1111\)&lt;/span&gt;,这里的最高位1是符号位&lt;br/&gt;补码：x = 1,1111&lt;/p&gt;&lt;p&gt;  我们引入补码的初衷是由于减法运算复杂，希望找到使用正数代替负数的方法，使用加法代替减法操作，从而消除减法，但是通过上面例子可以看到，补码的引入，并没有实现校除减法的目的。于是就提出了反码，反码的目的是找出原码和补码之间的规律，消除转换过程中的减法，反码的定义如下：&lt;/p&gt;
&lt;p&gt;\[x = \begin{cases} x &amp;amp; 2^{n} &amp;gt; x \geq 0 \\ (2^{n+1} - 1) + x &amp;amp; 0 &amp;gt; x \geq -2^n \end{cases} \]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：x=-13，计算x的二进制原码和反码&lt;/span&gt;&lt;br/&gt;原码：x=1,1101&lt;br/&gt;补码：&lt;span class=&quot;math inline&quot;&gt;\((2^{n+1} - 1) + x = （2^{4+1} -1） - 13 = 011111 - 1101 = 10010\)&lt;/span&gt;,这里的最高位1是符号位&lt;br/&gt;补码：x = 1,0010&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：x=-7，计算x的二进制原码和反码&lt;/span&gt;&lt;br/&gt;原码：x=1,0111&lt;br/&gt;补码：&lt;span class=&quot;math inline&quot;&gt;\((2^{n+1} - 1) + x = （2^{4+1} -1） - 7 = 011111 - 0111 = 11000\)&lt;/span&gt;,这里的最高位1是符号位&lt;br/&gt;补码：x = 1,1000&lt;br/&gt;我们可以根据反码补码的定义进行计算，找一找三者的关系：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;十进制&lt;/th&gt;
&lt;th&gt;原码&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;th&gt;反码&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;0,1101&lt;/td&gt;
&lt;td&gt;0,1101&lt;/td&gt;
&lt;td&gt;0,1101&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-13&lt;/td&gt;
&lt;td&gt;1,1101&lt;/td&gt;
&lt;td&gt;1,0011&lt;/td&gt;
&lt;td&gt;1,0010&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-7&lt;/td&gt;
&lt;td&gt;1,0111&lt;/td&gt;
&lt;td&gt;1,1001&lt;/td&gt;
&lt;td&gt;1,1000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;1,0001&lt;/td&gt;
&lt;td&gt;1,1111&lt;/td&gt;
&lt;td&gt;1,1110&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  根据这个表格中数据，我们可以发现正数原码、补码、反码的值都是一样的；负数的反码等于原码除符号位外都按位取反，负数的补码等于反码+1。同样的，小数的二进制也满足这个规律，二进制小数的补码定义如下：&lt;/p&gt;
&lt;p&gt;\[x = \begin{cases} x &amp;amp; 1 &amp;gt; x \geq 0 \\ 2 + x &amp;amp; 0 &amp;gt; x \geq -1 \end{cases} \]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：&lt;span class=&quot;math inline&quot;&gt;\(x=\frac{9}{16}\)&lt;/span&gt;，计算x的二进制原码、反码和补码&lt;/span&gt;&lt;br/&gt;原码：x=0,0.1001 反码：x=0,0.1001 补码：x=0,0.1001&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：&lt;span class=&quot;math inline&quot;&gt;\(x=-\frac{11}{32}\)&lt;/span&gt;，计算x的二进制原码、反码和补码&lt;/span&gt;&lt;br/&gt;原码：x=1,0.01011 反码：x=1,1.10100 补码：x=1,1.10101&lt;/p&gt;
&lt;h3 id=&quot;定点数与浮点数&quot;&gt;定点数与浮点数&lt;/h3&gt;
&lt;p&gt;  定点数的表示方法：纯小数的小数点放在符号位与数值位之间，纯整数的小数点放在数值位末尾，我们的定点数的保存需要乘以比例因子。&lt;br/&gt;定点数的纯小数表示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;符号位&lt;/th&gt;
&lt;th&gt;数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0.1011&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-0.1011&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;定点数的纯整数表示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;符号位&lt;/th&gt;
&lt;th&gt;数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-1011&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于计算机处理的很大程度上不是纯小数或纯整数，如果数据范围很大，定点数就难以表达。&lt;/p&gt;&lt;p&gt;  浮点数的表示格式：使用科学计数法表示浮点数，&lt;span class=&quot;math inline&quot;&gt;\(123450000000 = 1.2345 \times 10^11\)&lt;/span&gt;，1.2345是尾数，10是基数，11是阶码。浮点数的表示格式为：&lt;span class=&quot;math inline&quot;&gt;\(N = S \times r^j\)&lt;/span&gt;，S代表尾数，r代表基数，j表示阶码，尾数规定使用纯小数。例子如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(N = S \times r^j\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(11.0101 = 0.110101 \times 2^10\)&lt;/span&gt;，这里都是二进制表示，阶码10对应十进制数为2&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(11.0101 = 0.0110101 \times 2^11\)&lt;/span&gt;，这里都是二进制表示，阶码11对应十进制数为3&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位（8位）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;110101&lt;span&gt;00&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0110101&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  浮点数的表示范围：假设阶码值取m位，尾数值取n位，&lt;span class=&quot;math inline&quot;&gt;\(N = S \times r^j\)&lt;/span&gt;，阶码能够表示的最大值为：&lt;span class=&quot;math inline&quot;&gt;\(2^m-1\)&lt;/span&gt;，阶码表示范围为：&lt;span class=&quot;math inline&quot;&gt;\([-(2^m-1),2^m-1]\)&lt;/span&gt;；尾数能够表示的最大值为：&lt;span class=&quot;math inline&quot;&gt;\(1 - 2^{-n}\)&lt;/span&gt;，尾数能够表示的最小值为：&lt;span class=&quot;math inline&quot;&gt;\(2^{-n}\)&lt;/span&gt;，尾数表示的范围为：&lt;span class=&quot;math inline&quot;&gt;\([-(1 - 2^{-n}),-2^{-n}]\)&lt;/span&gt;  &lt;span class=&quot;math inline&quot;&gt;\([2^{-n},1-2^{-n}]\)&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200523115751527-1671352017.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;单精度浮点数：使用4字节、32位来表示浮点数（float）&lt;br/&gt;双精度浮点数：使用8字节、64位来表示浮点数（double）&lt;br/&gt;浮点数的规格化：尾数规定使用纯小数，尾数最高位必须是1.&lt;/p&gt;&lt;p&gt;&lt;span&gt;例1：设浮点数的长度为16位，阶码为5位，尾数为是11位，将十进制数&lt;span class=&quot;math inline&quot;&gt;\(\frac{13}{128}\)&lt;/span&gt;表示为二进制浮点数&lt;/span&gt;&lt;br/&gt;  由于正数的原码=反码=补码：&lt;span class=&quot;math inline&quot;&gt;\(x = 0.0001101000\)&lt;/span&gt;，浮点数的规格化：&lt;span class=&quot;math inline&quot;&gt;\(x = 0.1101000 * 2^{-11}\)&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1101000000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;例2：设浮点数的长度为16位，阶码为5位，尾数为是11位，将十进制数&lt;span class=&quot;math inline&quot;&gt;\(-54\)&lt;/span&gt;表示为二进制浮点数&lt;/span&gt;&lt;br/&gt;  原码：&lt;span class=&quot;math inline&quot;&gt;\(x = 1,110110\)&lt;/span&gt;，浮点数的规格化：&lt;span class=&quot;math inline&quot;&gt;\(x = -0.110110 * 2^{-110}\)&lt;/span&gt;，由于尾数为110110 0000，则尾数反码为：001001 1111，尾数补码为：001010 0000&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;001010 0000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;定点数与浮点数的对比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定点数与浮点数位数相同时，浮点数表示的范围更大&lt;/li&gt;
&lt;li&gt;当浮点数尾数为规格化数时，浮点数的精度更高&lt;/li&gt;
&lt;li&gt;浮点数运算包含阶码和位数，浮点数的运算更为复杂&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;总结：浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数；浮点数在数的运算规则、运算速度、硬件成本等方面不如定点数。&lt;/p&gt;
&lt;h3 id=&quot;定点数的加减法运算&quot;&gt;定点数的加减法运算&lt;/h3&gt;
&lt;p&gt;整数加法：A[补] + B[补] = [A+B][补](mod&lt;span class=&quot;math inline&quot;&gt;\(2^{n+1}\)&lt;/span&gt;)&lt;br/&gt;小数加法：A[补] + B[补] = [A+B][补](mod2)&lt;br/&gt;注意：定点数的加减法运算，数值位与符号位一同运算，并将符号位产生的进位自然丢掉&lt;br/&gt;&lt;span&gt;例1：A=-110010，B=001101，求A+B&lt;/span&gt;&lt;br/&gt;  A[补] = 1,001110，B[补] = B[原] = 0,001101，A[补] + B[补] = (A+B)[补] = 1,011011，则A + B = -100101&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：A=-0.1010010，B=0.0110100，求A+B&lt;/span&gt;&lt;br/&gt;  A[补] = 1,1.0101110，B[补] = B[原] = 0.0110100，A[补] + B[补] = (A+B)[补] = 1,1.1100010，则A + B = -0.0011110&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例3：A=-10010000，B=-11010000，求A+B&lt;/span&gt;&lt;br/&gt;  A[补] = 1,01110000，B[补] = 1,00110000，A[补] + B[补] = (A+B)[补] = 0,10100000，则A + B = 10100000，将结果转为十进制表示是160。我们可以把A和B转为十进制进行运算：A=-144，B=-208，A+B=-352，我们会发现二进制的计算结果是错误的。这是由于我们在计算时，对符号位的进位自然丢掉了，这是就发生了溢出，那我们如何来判断溢出呢？双符号位判断法：单符号位表示变成双符号位：0=&amp;gt;00，1=&amp;gt;11，双符号位产生的进位丢弃，结果的双符号位不同则表示溢出。&lt;br/&gt;整数减法：A[补] - B[补] = A + (-B)[补](mod&lt;span class=&quot;math inline&quot;&gt;\(2^{n+1}\)&lt;/span&gt;)&lt;br/&gt;小数减法：A[补] - B[补] = A + (-B)[补](mod2)&lt;br/&gt;-B[补]等于B[补]连同符号位按位取反，末位加一&lt;/p&gt;
&lt;h3 id=&quot;浮点数的加减法运算&quot;&gt;浮点数的加减法运算&lt;/h3&gt;
&lt;p&gt;  运算过程：对阶-&amp;gt;尾数求和-&amp;gt;尾数规格化-&amp;gt;舍入-&amp;gt;溢出判断&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x = 0.1101 \times 2^{01}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(y = (-0.1010) \times s^{11}\)&lt;/span&gt;&lt;br/&gt;对阶：浮点数尾数运算简单，浮点数位数实际小数位与阶码有关，阶码按小阶看齐大阶的原则。对阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对阶后：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x = 0.001101 \times 2^{11}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(y = (-0.1010) \times s^{11}\)&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0011&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0011(01)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;舍去01，在进行尾数求和，x[原]=00.0011，x[补]=00.0011，y[原]=11.1010，y[补]=11.0110，S=（x+y）[补]=11.1001&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;尾数规格化：对补码进行规格化需要判断两种情况：S&amp;gt;0和S&amp;lt;0，S[补] = 00.1xxxxxxx(S&amp;gt;0)，S[补] = 11.0xxxxxxx(S&amp;lt;0),符号位与最高位不一致，如果不满足此格式，则需要进行左移，同时阶码相应变化，以满足规格变化。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;S = (x + y)[补] = 11.1001 = 11.&lt;span&gt;(1)&lt;/span&gt;001&lt;span&gt;0(左移)&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶码符号位&lt;/th&gt;
&lt;th&gt;阶码数值位&lt;/th&gt;
&lt;th&gt;尾数符号位&lt;/th&gt;
&lt;th&gt;尾数数值位&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;S=(x+y)[补]=11.0010    (x+y)[原]=-0.1110    &lt;span class=&quot;math inline&quot;&gt;\(x+y=-0.1110\times2^{10}\)&lt;/span&gt;&lt;br/&gt;  尾数规格化一般情况下都是左移，双符号位不一致得情况下需要右移（定点运算得溢出情况），右移的话需要进行舍入操作，舍入就是指“0舍1入”法（二进制得四舍五入），S[补]=10.10110111，由于双符号位不一致，所以需要进行右移操作，S[补] = &lt;span&gt;1&lt;/span&gt;1.01011011&lt;span&gt;1&lt;/span&gt;，同时阶码需要加1。对于定点数运算来说，双符号位不一致为溢出，对于浮点数运算来说，浮点数尾数双符号位不一致不算溢出，因为尾数符号可以进行右规，浮点数运算主要通过阶码得双符号位判断是否溢出，如果规格化后，阶码双符号位不一致，则认为是溢出。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200523204156381-1181755684.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 23:43:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>计算机发展史（四个阶段） 第一阶段（1946~1957）：电子管计算机 世界上第一台计算机叫埃尼阿克(ENIAC) 第二次世界大战是电子管计算机产生的催化剂（英国为了解密德国海军的密文），在第二次世界</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/12896053.html</dc:identifier>
</item>
<item>
<title>带你学够浪：Go语言基础系列 - 8分钟学基础语法 - 柠檬橙1024</title>
<link>http://www.cnblogs.com/NanoDragon/p/12945374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NanoDragon/p/12945374.html</guid>
<description>&lt;p&gt;Hurry up , Let's go ! 对于一般的语言使用者来说 ，20% 的语言特性就能够满足 80% 的使用需求，剩下在使用中掌握。 基于这一理论，Go 基础系列的文章不会刻意追求面面俱到，但该有知识点都会覆盖，目的是带你快跑赶上 Golang 这趟新车。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;259.5&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;文章每周持续更新，原创不易，「三连」让更多人看到是对我最大的肯定。可以微信搜索公众号「 后端技术学堂 」第一时间阅读（一般比博客早更新一到两篇）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一般的语言使用者来说 ，20% 的语言特性就能够满足 80% 的使用需求，剩下在使用中掌握。&lt;/p&gt;
&lt;p&gt;基于这一理论，Go 基础系列的文章不会刻意追求面面俱到，但该有知识点都会覆盖，目的是带你快跑赶上 Golang 这趟新车。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hurry up , Let's go !&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个好消息一个坏消息一个潜规则&quot;&gt;一个好消息一个坏消息一个潜规则&lt;/h2&gt;
&lt;p&gt;Go 的语法类似 C 语言，你是从 C/C++ 语言过来的话学习成本很低，其他语言过来甚至没有编程基础也没关系，这门语言入门很轻松。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好消息&lt;/strong&gt;是你的键盘得救了，在 Go 的世界里不用在每个语句后面加分号了，C 和C++ 程序员听了喜大普奔，键盘不那么容易磨损了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;坏消息&lt;/strong&gt;带给习惯花括号换行的朋友，在 Go 中第一个花括号 &lt;code&gt;{&lt;/code&gt; 不能换行写，必须写在同一行，否则编译不过！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;潜规则&lt;/strong&gt;是任何在 Go 中定义的变量必须使用，如果定义了变量不使用，编译不过！&lt;/p&gt;
&lt;p&gt;怎么样？是不是感觉到满满的霸道总裁味道？&lt;/p&gt;
&lt;p&gt;其实约束多了，程序员自由发挥的空间变少，出错的概率也会大大降低，Google 的大佬们怕你犯错，操碎了心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/70b0412d-147a-4e03-827e-c5c0bccae2e4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;包&quot;&gt;包&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;Go 语言程序都由包构成，类似其他语言中的模块概念，主程序都从 main 包开始运行。&lt;/p&gt;
&lt;p&gt;所以一个程序开头是下面的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在程序中也可以导入其他包，这样就可以使用其他包定义的函数或变量。&lt;/p&gt;
&lt;h3 id=&quot;导入&quot;&gt;导入&lt;/h3&gt;
&lt;p&gt;导入包语法有多种姿势。&lt;/p&gt;
&lt;h4 id=&quot;导入姿势一：单独导入&quot;&gt;导入姿势一：单独导入&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;import os  // 导入 os 包
import fmt /* 导入 fmt 包*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;fmt 包&lt;/strong&gt;：包内有格式化 IO 函数，类似 C 中的 &lt;code&gt;stdio.h&lt;/code&gt; 和 C++ 中的 &lt;code&gt;iostream&lt;/code&gt; ，初学者必备，导它！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;os 包&lt;/strong&gt; ：中实现了一些 操作系统函数，不依赖平台的接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，关于注释，如你所见，完全就是 C 语言里的注释形式，&lt;/strong&gt;&lt;code&gt;//&lt;/code&gt; 或 &lt;code&gt;/**/&lt;/code&gt; 都是允许的。&lt;/p&gt;
&lt;h4 id=&quot;导入姿势二：分组导入&quot;&gt;导入姿势二：分组导入&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;import (
        &quot;fmt&quot;
        &quot;os&quot;
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以把需要的包，用括号放在一起导入。&lt;/p&gt;
&lt;h4 id=&quot;导入姿势三：指定别名导入&quot;&gt;导入姿势三：指定别名导入&lt;/h4&gt;
&lt;p&gt;可以在导入的时候指定导入包的别名，这样在调用包函数的时候，可以直接使用包别名。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;import f &quot;fmt&quot; // 用别名f 代替 fmt
f.Println(&quot;go go go&quot;) // 用 f 代替了 fmt 调用 Println 函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;包导出名称约定&quot;&gt;包导出名称约定&lt;/h3&gt;
&lt;p&gt;包中定义的函数或变量，如果是大写字母开头，那么它就是可以导出的，外部使用包的用户可以访问到，类似 C++ 中的 &lt;code&gt;public&lt;/code&gt; 标识。相反，小写字母开头的名字外部无法使用，使用会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 如下，Println 和 Getenv 都是大写的名字
fmt.Println(os.Getenv(&quot;GOPATH&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本类型&quot;&gt;基本类型&lt;/h2&gt;
&lt;h4 id=&quot;内置类型&quot;&gt;内置类型&lt;/h4&gt;
&lt;p&gt;Go 语言内建的数据类型有下面这些，其实基本上看类型名字，就差不多能知道是什么类型了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;平常用的最多的类型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt; 代表整型，在 32 位系统上通常为 32 位，在 64 位系统上则为 64 位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 字符串类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bool&lt;/code&gt; 布尔类型，分 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 两种值。&lt;/p&gt;
&lt;h4 id=&quot;创建类型&quot;&gt;创建类型&lt;/h4&gt;
&lt;p&gt;下面的语法创建一个新的类型，类似C++中的typedef语法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type 新类型名字 底层类型&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type ProgramType string  // 定义新类型 ProgramType
var t1 ProgramType = &quot;Golang&quot;
var t2 ProgramType = &quot;C++&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过Go中创建的新类型即使底层类型是一致的也不能相互操作，&lt;strong&gt;这样起到很好的类型隔离作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如下面的代码，虽然&lt;code&gt;ProgramType&lt;/code&gt; 和 &lt;code&gt;CompanyType&lt;/code&gt; 都是 &lt;code&gt;string&lt;/code&gt; 类型，但是不能相互操作，下面举例说明:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type ProgramType string  // 定义新类型 ProgramType
type CompanyType string  // 定义新类型 ProgramType
var t2, t2 ProgramType = &quot;Golang&quot;, &quot;C++&quot;
var c1, c2 CompanyType = &quot;Google&quot;, &quot;Tencent&quot;
fmt.Println(t1+t2)       // 同类型相加合法
fmt.Println(t1+c1)              // 不同类型相加非法
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;类型转换&quot;&gt;类型转换&lt;/h4&gt;
&lt;p&gt;不像 C 中有隐式类型转换，&lt;strong&gt;在 Go 中 不同类型的项之间赋值时需要显式转换，否则编译会报错&lt;/strong&gt;！语法上，相对于 C 语言的强制转换语法换了下括号的位置，Go 语法如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;T(v) // 把值 v 转换为类型 T
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var varint int = 66
var varf float32 = float32(varint)  // int 转换 float32
fmt.Printf(&quot;%T %v %T %v \n&quot;, varint, varint, varf, varf) // %T输出值的类型  %v输出值
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;
&lt;h3 id=&quot;声明&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;Go 里面的变量声明其实和 C 语言差不多，唯一的区别是把变量类型放在在变量名字后面，另外多了一个 &lt;code&gt;var&lt;/code&gt; 关键字标识。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar int // 声明了一个 int 类型的 imVar 变量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以多个同类型变量一起声明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar1, imVar2, imVar3 int // 一口气声明了三个 int 类型的变量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，多个不同类型的变量声明分组一起声明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var (
           i int
    b bool
    s string
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;h4 id=&quot;未初始化&quot;&gt;未初始化&lt;/h4&gt;
&lt;p&gt;未初始化的对象会被赋予&lt;strong&gt;零值&lt;/strong&gt;，也就是默认值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数值类型初始值 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔类型初始值 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串为初始值 &lt;code&gt;&quot;&quot;&lt;/code&gt;（空字符串）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;普通初始化&quot;&gt;普通初始化&lt;/h4&gt;
&lt;p&gt;可以声明之后单个初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar int
imVar = 6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以声明和初始化一步到位&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar0 int = 7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以批量声明加初始化一步到位&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar4, imVar5 int = 4, 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多个不同类型的变量声明和初始化可以分组同时进行，像下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var (
    i int    = 1
    b bool   = false
    s string = &quot;golang&quot;
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;偷懒初始化&quot;&gt;偷懒初始化&lt;/h4&gt;
&lt;h5 id=&quot;类型自动推导&quot;&gt;类型自动推导&lt;/h5&gt;
&lt;p&gt;如果初始化式右边的值是已存在确定类型的值，可以偷懒省略变量类型，聪明的 Go 会自动推导类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var imVar4, imVar5 = 4, 5  // 省略了左边的 int 类型，自动推导imVar4, imVar5是int类型
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;&quot;/&gt;
&lt;h5 id=&quot;简短初始化&quot;&gt;简短初始化&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;在函数内部&lt;/strong&gt;，可以使用简短赋值语句&lt;code&gt;:=&lt;/code&gt;来代替 &lt;code&gt;var&lt;/code&gt; 关键字&lt;strong&gt;声明并初始化&lt;/strong&gt;变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;imVar6, imVar7 := 8, 9  // 声明并初始化了 imVar6, imVar7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常量&quot;&gt;常量&lt;/h2&gt;
&lt;p&gt;常量用 &lt;code&gt;const&lt;/code&gt; 关键字声明，并且声明之后必须紧接着赋值，常量可以是字符、字符串、布尔值或数值 ，注意：&lt;strong&gt;常量不能用 &lt;code&gt;:=&lt;/code&gt; 语法声明&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;const imCnt int = 1 // 带类型的常量定义
const imCnt1 = 1    // 省略类型的常量定义，自动推导类型
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go 语言内建下面几种常量&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;true false iota nil // 内建常量
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;h3 id=&quot;声明-2&quot;&gt;声明&lt;/h3&gt;
&lt;p&gt;函数用关键字 &lt;code&gt;func&lt;/code&gt; 来声明，带参数列表，把返回值类型放在最后，下面定义了一个简单的乘法函数，带两个整型参数，返回值也是整型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func mult(i int, j int) int {
        return i * j
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当函数参数类型相同时，可以只写最后一个参数的类型，下面这样简写也是可以的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func mult(i, j int) int {
        return i * j
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;返回值&quot;&gt;返回值&lt;/h3&gt;
&lt;h4 id=&quot;多返回值&quot;&gt;多返回值&lt;/h4&gt;
&lt;p&gt;函数返回值可以是一个，也可以是多个，下面的函数就返回了 &lt;code&gt;i&lt;/code&gt; 的平凡和 &lt;code&gt;j&lt;/code&gt; 的平方两个返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func more(i, j int) (int, int) {
        return i * i, j * j
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;返回值命名&quot;&gt;返回值命名&lt;/h4&gt;
&lt;p&gt;前面例子只指定了返回值类型，可以指定返回值名称，这样更加便于理解，同时，指定的名称可在函数内使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func retName(i, j int) (x, y int) {
        x = i * i
        y = j * j
        return x, y // 可用 return 代替，表示返回所有已命名的返回值。
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过本文的学习，我们掌握了 Golang 中的几个基础概念和用法：包、基本数据类型、变量、常量、函数。这些语法基础是Golang 的下层建筑，万丈高楼平地起，本节为后续学习打下了基础。&lt;/p&gt;
&lt;p&gt;感谢各位的阅读，文章的目的是分享对知识的理解，技术类文章我都会反复求证以求最大程度保证准确性，若文中出现明显纰漏也欢迎指出，我们一起在探讨中学习.&lt;/p&gt;
&lt;p&gt;今天的技术分享就到这里，我们下期再见。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;原创不易，不想被白票，如果在我这有收获，就动动手指「点赞」和「转发」是对我持续创作的最大支持。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以微信搜索公众号「 后端技术学堂 」回复「资料」「1024」有我给你准备的各种编程学习资料。文章每周持续更新，我们下期见！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 23 May 2020 16:58:00 +0000</pubDate>
<dc:creator>柠檬橙1024</dc:creator>
<og:description>Hurry up , Let's go ! 对于一般的语言使用者来说 ，20% 的语言特性就能够满足 80% 的使用需求，剩下在使用中掌握。 基于这一理论，Go 基础系列的文章不会刻意追求面面俱到，但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NanoDragon/p/12945374.html</dc:identifier>
</item>
<item>
<title>软链接 vs. 硬链接 - JF Zhu</title>
<link>http://www.cnblogs.com/jfzhu/p/12945358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/12945358.html</guid>
<description>&lt;p&gt;&lt;strong&gt;​链接大家都用过，比如 Windows 中的快捷方式就是一种链接，可是 Linux 里又分硬链接和软链接，它们表示什么意思，又有什么区别呢，本文来给大家做一个解释。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Inode 索引节点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;要想理解硬链接和软链接的区别，首先要明白什么是 Inode。Inode 是 Index node，索引节点的意思。每个文件都有一个 inode，里边保存着文件的元数据（meta data），包括：inode 号、文件大小、文件所有者、文件权限、文件类型、创建时间、硬链接数等等，除了文件名以外的所有文件信息都存储在这里。它是文件或者目录在一个文件系统中的唯一标识。&lt;/p&gt;

&lt;p&gt;查看一个文件的 inode，可以用 stat 命令，或者 ls -i 选项来查看。下面分别用这两个命令来查看一个文件 myfile.txt 的 inode 号为 102171635&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004251910-682880486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;和元数据相对应的是用户数据（user data），或者也叫文件数据块（data block），文件的真实内容是存储在这里边的。我们通过一个文件名可以查到它对应的 inode，再通过 inode 去查看文件的内容。它们之间的关系可以用下面这张图来表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004305527-255818490.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;硬链接 Hard Links&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;当多个文件名指向同一个 inode 时，这种链接就被称为硬链接。比如像下面的这种情况，我们为原始文件 myfile.txt 创建了两个链接，hardlink1 和 hardlink2，它们都指向同一个 inode，所以它们都是硬链接。从图中可以看出，硬链接指向的文件内容其实就是原始文件的内容，所以硬链接的作用之一就是可以节省服务器的磁盘空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004338669-12701438.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;

&lt;p&gt;硬链接的另外一个作用就是可以防止文件被“误删”。因为 inode 会记录文件硬链接的次数，只有当硬链接等于 0 的时候，才会把存储着文件内容的数据块删除，所以比如我不小心把 myfile.txt 文件删除了，但是 inode 发现还有另外两个硬链接在，所以不会删除掉数据块，通过两个硬链接我们还是可以读取到文件内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004401933-548617882.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p&gt;硬链接可以通过 &lt;em&gt;ln [选项] [源文件] [链接文件] &lt;/em&gt;命令来创建，不过要注意硬链接只能对已经存在的文件进行创建，并且不能够跨文件系统。下面举一个例子来看一下硬链接和源文件的 inode号是否相同，以及删除掉源文件，是否还可以通过硬链接打开原文件。&lt;/p&gt;

&lt;p&gt;首先创建一个文件 myfile.txt，然后分别给它创建两个硬链接 hardlink1 和 hardlink2。通过 ls -li 命令查看它们的 inode 号，发现相同，所以验证了我们所说的，硬链接和原文件指向同一个 inode 。另外从长列表中，我们还可以看到 inode 记录的硬链接次数（包括源文件自己），一共是3次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004441069-1547269367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来删除掉文件 myfile.txt，通过 ls -li 命令再看一下，发现 inode 记录的链接次数变成了 2，通过硬链接我们还是可以读取原来的文件内容，说明文件内容数据块并没有被删除，只有当硬链接次数变为 0 的时候，文件内容才会真正被删掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004448846-192336994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们对硬链接的特点进行一下总结：&lt;/p&gt;
&lt;p&gt;1） 硬链接文件都有相同的 inode 和 数据块&lt;/p&gt;
&lt;p&gt;2） 删除掉一个硬链接文件，并不会影响 inode 号相同的其他文件，只有当 inode 记录的链接次数为 0 时，数据块才会被真正删除&lt;/p&gt;
&lt;p&gt;3） 硬链接只能对已有文件进行创建&lt;/p&gt;
&lt;p&gt;4） 硬链接不能跨文件系统创建&lt;/p&gt;
&lt;p&gt;5） 普通用户不能对目录进行硬链接创建&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;软链接 Soft Links&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;软链接也被称为符号链接（symbolic link）。Linux 中的软链接和 Windows 的快捷方式非常相似。与硬链接的不同之处在于：&lt;/p&gt;
&lt;p&gt;1） 它的 inode 与原文件不同&lt;/p&gt;
&lt;p&gt;2） 它的数据块存储的是原文件的路径&lt;/p&gt;

&lt;p&gt;我们用下面这张图来进行一下说明，我们为 myfile.txt 创建了一个软链接 softlink。可以看出，它的 inode 和 myfile.txt 的 inode 是两个完全不同的索引节点，myfile.txt 的数据块记录的是文件的内容，而软链接的数据块记录的是它指向文件的路径。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004508564-1835175585.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;

&lt;p&gt;软链接的作用之一也是方便文件的管理，比如原文件的路径比较复杂，我们可以在简单的路径下创建一个软链接，这样比较方便用户访问。但是和硬链接不同的是，一旦原文件被删除，那么软链接就成了一个“死链接”，指向了一个不存在的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004537866-1938937433.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;


&lt;p&gt;软链接可以用命令 &lt;em&gt;ln -s [源文件名或目录] [软链接文件名]&lt;/em&gt; 来进行创建。和硬链接不同之处在于，对不存在的文件也可以创建软链接，可以跨文件系统，对文件或者目录都可以创建软链接。&lt;/p&gt;

&lt;p&gt;举一个例子，比如我们为 myfile.txt 创建一个软链接 softlink。通过 ls -li 命令查看，发现 inode 号完全不同，并且 myfile.txt 的链接次数还是 1，并没有增加，说明这里的链接次数是指硬链接，通过软链接我们可以读取源文件的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004555927-2028580366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;删除原文件，软链接变成了“死链接”，通过它再去读取原来的文件内容，系统已经提示文件不存在了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004602970-1885013949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过上面的实验验证，软链接的特点如下：&lt;/p&gt;
&lt;p&gt;1） 软链接和其所指向的文件具有不同的 inode，并且其数据块存储的内容为其所指向文件的路径&lt;/p&gt;
&lt;p&gt;2） 创建软链接，其指向文件的硬链接次数不会增加&lt;/p&gt;
&lt;p&gt;3） 删除软链接并不影响原文件，但删掉原文件，软链接会成为一个“死”链接&lt;/p&gt;
&lt;p&gt;4） 软链接可以指向文件，也可以指向目录&lt;/p&gt;
&lt;p&gt;5） 软链接可以指向不存在的文件或目录&lt;/p&gt;
&lt;p&gt;6） 软链接可以跨文件系统创建&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;不管用软链接还是硬链接，都不会将原来的文件复制一份，都只是占用了磁盘较小的空间，但它们的原理还是完全不一样的。本文从 inode 的角度切入，对软链接和硬链接进行了解释。感兴趣的同学可以对 inode 结构体再做进一步研究，这样能够帮助我们更好的理解 Linux 的工作原理。&lt;/p&gt;


&lt;p&gt;相关阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12940175.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux 目录详解》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12928138.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《虚拟机安装 Linux 最完整攻略》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12907248.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Xshell 与 Xftp 的安装与使用》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12895692.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux，Unix，GNU 到底有什么样的渊源？》&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200524004801963-511238290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;- The End -&lt;/p&gt;

</description>
<pubDate>Sat, 23 May 2020 16:49:00 +0000</pubDate>
<dc:creator>JF Zhu</dc:creator>
<og:description>​链接大家都用过，比如 Windows 中的快捷方式就是一种链接，可是 Linux 里又分硬链接和软链接，它们表示什么意思，又有什么区别呢，本文来给大家做一个解释。 Inode 索引节点 要想理解硬链</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/12945358.html</dc:identifier>
</item>
<item>
<title>【面试考】【入门】决策树算法ID3，C4.5和CART - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/12945292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/12945292.html</guid>
<description>&lt;p&gt;关于决策树的purity的计算方法可以参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/PythonLearner/p/12940067.html&quot;&gt;决策树purity/基尼系数/信息增益 Decision Trees&lt;/a&gt;&lt;br/&gt;如果有不懂得可以私信我，我给你讲。&lt;/p&gt;
&lt;h2 id=&quot;id3&quot;&gt;ID3&lt;/h2&gt;
&lt;p&gt;用下面的例子来理解这个算法：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下图为我们的训练集。总共有14个训练样本，每个样本中有4个关于天气的属性，这些属性都是标称值。输出结果只有2个类别，玩(yes)或者不玩(no)：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200523231032370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTA3NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先先计算整个数据集的熵Entropy：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为整个数据集只有两个类别，他们的分布概率分别是&lt;span class=&quot;math inline&quot;&gt;\(\frac{9}{14}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\frac{5}{14}\)&lt;/span&gt;，所以根据Entropy是：&lt;span class=&quot;math inline&quot;&gt;\(Entropy(S)=-(\frac{9}{14}*log_2(\frac{9}{14})+\frac{5}{14}*log_2(\frac{5}{14}))=0.94\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们要考虑根据哪一个属性进行分裂，假设根据Outlook属性进行分裂，我们可以发现Outlook中有三个值，分别是：Sun,Rain,Overcast，分别计算他们的熵：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Entropy(S_{sun})=-(\frac{2}{5}*log_2(\frac{2}{5})+\frac{3}{5}*log_2(\frac{3}{5}))=0.971\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Entropy(S_{overcast})=-(\frac{4}{4}*log_2(\frac{4}{4})+\frac{0}{4}*log_2(\frac{0}{4}))=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Entropy(S_{rain})=-(\frac{3}{5}*log_2(\frac{3}{5})+\frac{2}{5}*log_2(\frac{2}{5}))=0.971\)&lt;/span&gt;&lt;br/&gt;计算完三个Entropy后，来计算信息增益Information Gain：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(IG(S,Outlook)=Entropy(S)-(\frac{5}{14}*Entropy(S_{sun})+\frac{5}{14}*Entropy(S_{overcast})+\frac{5}{14}*Entropy(S_{rain}))=0.246\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用同样的道理，我们可以求出来剩下的几个特征的信息增益：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(IG(S,Wind)=0.048\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(IG(S,Temperature)=0.0289\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(IG(S,Humidity)=0.1515\)&lt;/span&gt;&lt;br/&gt;因为outlook这个作为划分的话，可以得到最大的信息增益，所以我们就用这个属性作为决策树的根节点，把数据集分成3个子集，然后再在每一个子集中重复上面的步骤，就会得到下面这样的决策树：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202005232327138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTA3NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;id3的缺点&quot;&gt;ID3的缺点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果样本中存在一个特征，这个特征中所有值都不相同（比方说是连续值的特征），这样可以想想的出假设用这个特征作为划分，那么信息增益一定是非常大的，因为所有的划分中都只会包含一个样本；对于具有很多值的属性它是非常敏感的，例如，如果我们数据集中的某个属性值对不同的样本基本上是不相同的，甚至更极端点，对于每个样本都是唯一的，如果我们用这个属性来划分数据集，它会得到很大的信息增益，但是，这样的结果并不是我们想要的。&lt;/li&gt;
&lt;li&gt;ID3不能处理连续值属性；&lt;/li&gt;
&lt;li&gt;ID3算法不能处理具有缺失值的样本；&lt;/li&gt;
&lt;li&gt;非常容易过拟合。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;c45&quot;&gt;C4.5&lt;/h2&gt;
&lt;p&gt;对于有很多值得特征，ID3是非常敏感的，而C4.5用增益率Gain ratio解决了这个问题，先定义内在价值Intrinsic Value：&lt;/p&gt;
&lt;p&gt;\[IV(S,a)=-\sum_{v\in values(a)}{\frac{|x\in S|value(x,a)=v|}{|S|}*log_2(\frac{|x\in S|value(x,a)=v|}{|S|})} \]&lt;/p&gt;
&lt;p&gt;这个公式怎么理解呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;S就是数据集样本，&lt;span class=&quot;math inline&quot;&gt;\(|S|\)&lt;/span&gt;就是样本数量；&lt;/li&gt;
&lt;li&gt;a是某一个特征，比方说Outlook或者是Wind,然后&lt;span class=&quot;math inline&quot;&gt;\(v\in values(a)\)&lt;/span&gt;就是v就是a这个特征中的某一个值；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|x\in S|value(x,a)=v|\)&lt;/span&gt;这个就是某一个特征a是v的样本数量；&lt;br/&gt;然后决策树之前使用信息增益Information Gain来作为分裂特征的选择，现在使用增益率IG rate：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[IGR(S,a)=\frac{IG(S,a)}{IV(S,a)} \]&lt;/p&gt;
&lt;p&gt;可想而知，如果存在一个特征，比方说一个学生的学号（每一个学生的学号都不相同），如果用ID3选择学号进行分裂，那么一定可以达到非常大的信息增益，但是其实这是无意义过拟合的行为。使用C4.5的话，我们要计算IGR，这个学号的特征的内在价值IV是非常大的，所以IGR并不会很大，所以模型就不会选择学号进行分裂。&lt;/p&gt;
&lt;p&gt;此外。&lt;strong&gt;C4.5可以处理连续值得划分&lt;/strong&gt;，下面，我举例说明一下它的解决方式。假设训练集中每个样本的某个属性为：{65, 70, 70, 70, 75, 78, 80, 80, 80, 85, 90, 90, 95, 96}。现在我们要计算这个属性的信息增益。我们首先要移除重复的值并对剩下的值进行排序：{65, 70, 75, 78, 80, 85, 90, 95, 96}。接着，我们分别求用每个数字拆分的信息增益（比如用65做拆分：用≤65和&amp;gt;65≤65和&amp;gt;65做拆分，其它数字同理），然后找出使信息增益获得最大的拆分值。因此，C4.5算法很好地解决了不能处理具有连续值属性的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C4.5如何处理缺失值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是训练数据中出现了缺失数据，那么就会考虑这个缺失数据所有可能的值。比方说一开始的数据库中，D1的Outlook变成了缺失值，那么D1的Outlook就会有&lt;span class=&quot;math inline&quot;&gt;\(\frac{4}{13}\)&lt;/span&gt;的概率是Sun，有&lt;span class=&quot;math inline&quot;&gt;\(\frac{4}{13}\)&lt;/span&gt;的概率是Overcast，有&lt;span class=&quot;math inline&quot;&gt;\(\frac{5}{13}\)&lt;/span&gt;的概率是Rain，然后其实也可以理解为这个样本就会变成3个样本，这三个样本有着不同的权重。&lt;/li&gt;
&lt;li&gt;如果是在预测数据中出现了缺失数据，那么同样的，认为这个数据的这个缺失数据可能是任何可能的值，这个概率就是看决策树中Outlook划分的子集的样本数量。这个地方可能有点难懂，不理解的可以看这个博文：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/leaf_zizi/article/details/83503167&quot;&gt;机器学习笔记（7）——C4.5决策树中的缺失值处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;C4.5对决策树的剪枝处理&lt;/strong&gt;：&lt;br/&gt;有两种剪枝处理方法，一个是预剪枝，一个是后剪枝，两者都是比较验证集精度，区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预剪枝：从上到下进行剪枝，如果精度没有提升，那么就剪掉，这个处理在训练模型的过程中进行；&lt;/li&gt;
&lt;li&gt;后剪枝：从下到上进行剪枝，如果剪掉精度可以提升，就剪掉，这个处理过程是在模型训练结束之后再进行的。&lt;br/&gt;通常来说后者会比前者保留更多的分支，欠拟合的风险小，但是训练时间的开销会大一些。&lt;br/&gt;更具体地内容推荐这篇博文，讲的清晰易懂(没有必要看懂这个博文中的Python实现过程，毕竟现在sklearn库中都封装好了)：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/leaf_zizi/article/details/83380081&quot;&gt;机器学习笔记（6）——C4.5决策树中的剪枝处理和Python实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;cart&quot;&gt;CART&lt;/h2&gt;
&lt;p&gt;分类回归树Classification and Regression Trees与C4.5的算法是非常相似的，并且CART支持预测回归任务。并且CART构建的是二叉树。&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 16:19:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>关于决策树的purity的计算方法可以参考： &amp;quot;决策树purity/基尼系数/信息增益 Decision Trees&amp;quot; 如果有不懂得可以私信我，我给你讲。 ID3 用下面的例子来理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/12945292.html</dc:identifier>
</item>
<item>
<title>JAVA设计模式之原型模式（prototype） - 引路的风</title>
<link>http://www.cnblogs.com/sx-bj-srr/p/prototype.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sx-bj-srr/p/prototype.html</guid>
<description>&lt;p&gt;原型模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原型模式又叫克隆模式&lt;/li&gt;
&lt;li&gt;Java自带克隆模式&lt;/li&gt;
&lt;li&gt;实现克隆模式必须实现Cloneable&lt;/li&gt;
&lt;li&gt;接口，如果不实现会发生java.lang.CloneNotSupportedException异常&lt;/li&gt;
&lt;li&gt;当某个类的属性已经设定好需要创建很多相同属性值的对象的时候使用clone模式非常方便&lt;/li&gt;
&lt;li&gt;使用clone模式不见得比传统的new方式性能高&lt;/li&gt;
&lt;li&gt;浅克隆和深克隆&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先看下面的代码，没有实现Cloneable接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * （原型模式）克隆模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Appler &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;implements Cloneable&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String clor;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringBuilder descr;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Appler(String clor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clor =&lt;span&gt; clor;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Appler{&quot; +
                &quot;clor='&quot; + clor + '\'' +
                &quot;, weight=&quot; + weight +
                &quot;, volume=&quot; + volume +
                &quot;, descr=&quot; + descr +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; T {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {

        Appler appler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Appler(&quot;yellow&quot;&lt;span&gt;);

        Appler appler1 &lt;/span&gt;=&lt;span&gt; (Appler) appler.clone();

        System.out.println(appler1);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017429/202005/2017429-20200523230148449-1027163856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;浅拷贝：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * （原型模式）克隆模式
 *  浅拷贝
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Appler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String clor;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Location loc;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Appler(String clor,&lt;span&gt;int&lt;/span&gt; weight,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume,Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clor =&lt;span&gt; clor;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getClor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setClor(String clor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clor =&lt;span&gt; clor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getWeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getVolume() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location getLoc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoc(Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loc = (Locaton) loc.clone();&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Appler{&quot; +
                &quot;clor='&quot; + clor + '\'' +
                &quot;, weight=&quot; + weight +
                &quot;, volume=&quot; + volume +
                &quot;, loc=&quot; + loc +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Location {
    String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Locaton{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试代码
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; T {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Appler(&quot;yellow&quot;,1,1,&lt;span&gt;new&lt;/span&gt; Location(&quot;洛川&quot;&lt;span&gt;));
        Appler appler1 &lt;/span&gt;=&lt;span&gt; (Appler) appler.clone();
        appler.setClor(&lt;/span&gt;&quot;red&quot;&lt;span&gt;);
        appler.getLoc().name &lt;/span&gt;= &quot;宝鸡&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;appler1 = &quot;+&lt;span&gt;appler1);
        System.out.println(&lt;/span&gt;&quot;appler = &quot;+&lt;span&gt;appler);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017429/202005/2017429-20200523230608112-663268797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从结果发现，当改变appler 的颜色还有location的值后，拷贝的apper1对象的颜色未发生改变但是location发生了改变。&lt;/p&gt;
&lt;p&gt;这就是浅拷贝，引用对象无法保证拷贝之后完全独立只是拷贝了地址但是地址指向的对象是共享的，&lt;/p&gt;
&lt;p&gt;虽然String类型也是引用类型但是共享常量池所以不会有这个问题。&lt;/p&gt;
&lt;p&gt;那么如何让引用类型拷贝之后独立呢？&lt;/p&gt;
&lt;p&gt;那么就要使用深拷贝请看如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * （原型模式）克隆模式
 *  浅拷贝
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Appler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String clor;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Location loc;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Appler(String clor,&lt;span&gt;int&lt;/span&gt; weight,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume,Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clor =&lt;span&gt; clor;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getClor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setClor(String clor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clor =&lt;span&gt; clor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getWeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getVolume() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location getLoc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoc(Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= (Appler)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        appler.loc &lt;/span&gt;=&lt;span&gt; (Location) loc.clone();;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; appler;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Appler{&quot; +
                &quot;clor='&quot; + clor + '\'' +
                &quot;, weight=&quot; + weight +
                &quot;, volume=&quot; + volume +
                &quot;, loc=&quot; + loc +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Location &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable{
    String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Locaton{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试代码
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; T {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Appler(&quot;yellow&quot;,1,1,&lt;span&gt;new&lt;/span&gt; Location(&quot;洛川&quot;&lt;span&gt;));
        Appler appler1 &lt;/span&gt;=&lt;span&gt; (Appler) appler.clone();
        appler.setClor(&lt;/span&gt;&quot;red&quot;&lt;span&gt;);
        appler.getLoc().name &lt;/span&gt;= &quot;宝鸡&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;appler1 = &quot;+&lt;span&gt;appler1);
        System.out.println(&lt;/span&gt;&quot;appler = &quot;+&lt;span&gt;appler);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017429/202005/2017429-20200523231601386-1192547289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;从结果发现，当改变appler 的颜色还有location的值后，拷贝的apper1对象的颜色未发生改变location也发生了改变。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 上面说到String类型的拷贝不存在浅拷贝的问题，那么StringBuilder或者StringBuffer呢，鉴于篇幅这里使用StringBuilder来举例&lt;/p&gt;
&lt;p&gt;请看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * （原型模式）克隆模式
 *  浅拷贝
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Appler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String color;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Location loc;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder getDesc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(StringBuilder desc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; StringBuilder desc = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;好吃&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Appler(String color,&lt;span&gt;int&lt;/span&gt; weight,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume,Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getClor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setColor(String color) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getWeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getVolume() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location getLoc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoc(Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= (Appler)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        appler.loc &lt;/span&gt;=&lt;span&gt; (Location) loc.clone();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; appler;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Appler{&quot; +
                &quot;color='&quot; + color + '\'' +
                &quot;, weight=&quot; + weight +
                &quot;, volume=&quot; + volume +
                &quot;, loc=&quot; + loc +
                &quot;, desc=&quot; + desc +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Location &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable{
    String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Locaton{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试代码
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; T {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Appler(&quot;yellow&quot;,1,1,&lt;span&gt;new&lt;/span&gt; Location(&quot;洛川&quot;&lt;span&gt;));
        Appler appler1 &lt;/span&gt;=&lt;span&gt; (Appler) appler.clone();
        appler.getDesc().append(&lt;/span&gt;&quot;得不得了&quot;&lt;span&gt;);
        appler.getLoc().name &lt;/span&gt;= &quot;宝鸡&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;appler1 = &quot;+&lt;span&gt;appler1);
        System.out.println(&lt;/span&gt;&quot;appler = &quot;+&lt;span&gt;appler);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017429/202005/2017429-20200523234746217-1414967229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这是是后你会发现当appler的desc值发生改变之后，apper1的值也发生改变了，说明StringBuilder的拷贝方式为浅拷贝，那么如何实现深拷贝呢&lt;/p&gt;
&lt;p&gt;请看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * （原型模式）克隆模式
 *  浅拷贝
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Appler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String color;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Location loc;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder getDesc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(StringBuilder desc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; StringBuilder desc = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;好吃&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Appler(String color,&lt;span&gt;int&lt;/span&gt; weight,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume,Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getClor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setColor(String color) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getWeight() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getVolume() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.volume =&lt;span&gt; volume;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location getLoc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loc;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoc(Location loc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loc =&lt;span&gt; loc;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= (Appler)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        appler.loc &lt;/span&gt;=&lt;span&gt; (Location) loc.clone();
        appler.desc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.desc);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; appler;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Appler{&quot; +
                &quot;color='&quot; + color + '\'' +
                &quot;, weight=&quot; + weight +
                &quot;, volume=&quot; + volume +
                &quot;, loc=&quot; + loc +
                &quot;, desc=&quot; + desc +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Location &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable{
    String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Location(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Locaton{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.srr.dp.clone;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试代码
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; T {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        Appler appler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Appler(&quot;yellow&quot;,1,1,&lt;span&gt;new&lt;/span&gt; Location(&quot;洛川&quot;&lt;span&gt;));
        Appler appler1 &lt;/span&gt;=&lt;span&gt; (Appler) appler.clone();
        appler.getDesc().append(&lt;/span&gt;&quot;得不得了&quot;&lt;span&gt;);
        appler.getLoc().name &lt;/span&gt;= &quot;宝鸡&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;appler1 = &quot;+&lt;span&gt;appler1);
        System.out.println(&lt;/span&gt;&quot;appler = &quot;+&lt;span&gt;appler);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2017429/202005/2017429-20200523235019235-524687076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是是后你会发现当appler的desc值发生改变之后，apper1的值并没有发生改变。&lt;/p&gt;
&lt;p&gt;写到这里原型模式就介绍完了。&lt;/p&gt;
&lt;p&gt;原创不易，请多多支持！&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 15:52:00 +0000</pubDate>
<dc:creator>引路的风</dc:creator>
<og:description>原型模式： 原型模式又叫克隆模式 Java自带克隆模式 实现克隆模式必须实现Cloneable 接口，如果不实现会发生java.lang.CloneNotSupportedException异常 当某</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sx-bj-srr/p/prototype.html</dc:identifier>
</item>
<item>
<title>DQN（Deep Q-learning）入门教程（零）之教程介绍 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12945133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12945133.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;DQN入门系列地址:&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/category/1770037.html&quot;&gt;https://www.cnblogs.com/xiaohuiduan/category/1770037.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来呢，在上一个系列&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/category/1661541.html&quot;&gt;数据挖掘入门系列&lt;/a&gt;博客中，我是准备写数据挖掘的教程，然后不知怎么滴，博客越写越偏，写到了神经网络，深度学习去了。在我写完数据挖掘博客之后，我又不知道在哪里（YouTube or B站杀我）看到了有人使用CNN网络玩飞翔的小鸟（Flappy Bird）的游戏，当时我觉得，emm，竟然使用CNN就可以玩游戏，有意思，可以一试，然后发现，要用到DQN，再然后，又发现其是强化学习的知识，然后，就入坑了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200523233128146-20699018.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;别人的学习流程是强化学习——&amp;gt;Q-learning——&amp;gt;DQN——&amp;gt;🐦Fly，我学习流程TM是 🐦Fly——&amp;gt;CNN——&amp;gt;DQN——&amp;gt;Q-learning——&amp;gt;强化学习&lt;/p&gt;
&lt;p&gt;当然，本教程还是会按照&quot;强化学习——&amp;gt;Q-learning——&amp;gt;DQN——&amp;gt;🐦Fly&quot;的流程来，不然反着来谁受得了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200523233128417-544859334.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于为什么教程名叫做&lt;strong&gt;DQN入门教程&lt;/strong&gt;而不是强化学习入门博客，是因为该系列侧重点不是强化学习，而是DQN。因此，一切的目标都是朝着DQN向前。&lt;/p&gt;
&lt;h2 id=&quot;教程目标&quot;&gt;教程目标&lt;/h2&gt;
&lt;p&gt;该系列博客仍然定位为入门博客，因此不会涉及详细对强化学习的各个方面都进行介绍，但是不会影响从&lt;strong&gt;入门到入土&lt;/strong&gt;的连贯性。至于为什么定位为入门博客：1. 博主自己也是刚学，并且也不是系统性的学习（因为要准备考研，没有时间），所以自己的知识面也不够。 2. 实际上只要我们能够入门，知道什么是强化学习，什么是DQN，能够自己写一个DQN的模型，然后得到结果就🆗了。至于更深入的内容，都入门了，还不能够自己修炼吗？同样，这也是我的学习方法：先知道能够做什么，然后做出来（并不是简单的copy代码，还是需要知道为什么这样做），然后再深入的来了解怎么做，怎么做的更好。&lt;/p&gt;
&lt;p&gt;该教程涉及的内容如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强化学习简介&lt;/li&gt;
&lt;li&gt;马尔科夫决策过程&lt;/li&gt;
&lt;li&gt;Q-learing算法&lt;/li&gt;
&lt;li&gt;DQN&lt;/li&gt;
&lt;li&gt;Nature DQN&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终会完成2个有意思的小项目：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MountainCar-v0&lt;/p&gt;
&lt;p&gt;通过DQN训练之后，小车能够自动移动到旗帜的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200523233128791-524239119.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Flappy Bird&lt;/p&gt;
&lt;p&gt;通过DQN训练之后，小鸟能够自动玩游戏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200523233129863-1610539931.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果有任何问题，欢迎mail我。&lt;/p&gt;
</description>
<pubDate>Sat, 23 May 2020 15:32:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>简介 DQN入门系列地址: &amp;quot;https://www.cnblogs.com/xiaohuiduan/category/1770037.html&amp;quot; 本来呢，在上一个系列 &amp;quot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12945133.html</dc:identifier>
</item>
</channel>
</rss>