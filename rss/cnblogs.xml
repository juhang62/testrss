<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>消息通讯之关于消息队列MQ必须了解的相关概念 - jimisun</title>
<link>http://www.cnblogs.com/jimisun/p/10102425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimisun/p/10102425.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;系统通讯方式有哪些&quot;&gt;系统通讯方式有哪些?&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;RPC调用&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RPC 全称 Remote Procedure Call——远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通讯协议层面&lt;/td&gt;
&lt;td&gt;基于 HTTP 协议的 RPC；基于二进制协议的 RPC；基于 TCP 协议的 RPC&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;是否跨平台&lt;/td&gt;
&lt;td&gt;单语言 RPC，如 RMI, Remoting；跨平台 RPC，如 google protobuffer, restful json，http XML。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;调用过程&lt;/td&gt;
&lt;td&gt;同步通信RPC和异步通信RPC&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;消息队列”是在消息的传输过程中保存消息的容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;消息队列的应用场景&quot;&gt;消息队列的应用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;异步处理&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，在需要的时候进行处理;例如用户注册的时候发送验证邮件可以通过异步处理的方式在另外一个线程内完成发送邮件操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;解耦&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在应用开发过程中随着需求的增加各个模块进行过度耦合,各模块之间形成相互调用的关系,我们可以利用消息队列形成中间层进行解耦.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;流量削峰&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在应用某一时段会发生大流量的请求,例如双十一会造成大量请求数据库,数据库很快就会形成瓶颈.我们可将数据请求持久化在消息队列中,进行逐步处理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;日志收集&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在项目开发和运维的心中日志是一个很重要的部分,如果尽可能全面而又有效的收集日志进行分析是一个势在必得的任务,我们可以使用消息队列来构建统一日志处理平台.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;事务最终一致&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在行业中使用消息队列来保证一个事务的最终一致性也是常见分布式事务的解决方案.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;消息队列通讯模型&quot;&gt;消息队列通讯模型&lt;/h2&gt;
&lt;p&gt;一个最基本的消息队列应该具有消息发送者,消息处理中心,消息消费者三个功能.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201812/1218060-20181211152325940-1104249917.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在MQ中消息队列主要有两种通讯模型分别是PTP点对点和Pub/Sub发布订阅&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20150817113531436&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20150817113626248&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的消息协议&quot;&gt;常见的消息协议&lt;/h2&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;消息协议是指用于实现消息队列功能时双方通信的一个约定, 例如 如何区分客户端是生产消息还是消费消息? 客户端向消息处理中心发送&lt;code&gt;&quot;发送: I am a Javaer&quot;&lt;/code&gt;字符串,那么我们根据xxx约定字符中包含&lt;code&gt;发送&lt;/code&gt;的代表生产消息,那么我们就可以知道该客户端要发送消息内容是&lt;code&gt;&quot; I am a Javaer&quot;&lt;/code&gt;,常见的消息协议有AMQP,MQTT,STOMP,XMPP等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;amqp&quot;&gt;AMQP&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.amqp.org/&quot;&gt;AMQP&lt;/a&gt;即Advanced Message Queuing Protocol，高级消息队列协议，是面向消息中间件设计的应用层协议的一个开放标准。 它的主要特点是面向消息、队列、路由(包括点对点和发布/订阅)]、可靠性和安全。&lt;/p&gt;
&lt;p&gt;AMQP允许来自不同供应商的消息生产者和消费者实现真正的互操作扩展，就如同SMTP、HTTP、FTP等协议采用的方式一样。而此前对于消息中间件的标准化努力则集中在API层面上(比如JMS)，且没有提供互操作性的途径。不同于JMS的仅仅定义API，AMQP是一个线路级的协议——它描述了通过网络传输的字节流的数据格式。因此，遵从这个协议的任何语言编写的工具均可以操作AMQP消息。&lt;/p&gt;
&lt;p&gt;AMQP模型图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.frognew.com/images/2012/06/amqp-model.jpg&quot; alt=&quot;AMQP&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Exchange即交换器，用来接收Producer发布的消息，并通过设定的路由规则将消息路由给服务器中的Queue。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Binding即绑定器，可以理解为路由规则。它的作用就是把Exchange和Queue按照路由规则绑定起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Binding Key即绑定关键字，Exchange视自身类型来决定Binding的路由行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Routing Key即消息的路由关键字，Exchange根据这个关键字决定如何路由某条消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mqtt&quot;&gt;MQTT&lt;/h3&gt;
&lt;p&gt;MQTT 最初由 IBM 于上世纪 90 年代晚期发明和开发。它最初的用途是将石油管道上的传感器与卫星相链接。顾名思义，它是一种支持在各方之间异步通信的消息协议。异步消息协议在空间和时间上将消息发送者与接收者分离，因此可以在不可靠的网络环境中进行扩展。虽然叫做消息队列遥测传输，但它与消息队列毫无关系，而是使用了一个发布和订阅的模型。在 2014 年末，它正式成为了一种 OASIS 开放标准，而且在一些流行的编程语言中受到支持（通过使用多种开源实现）。&lt;/p&gt;
&lt;p&gt;MQTT模型图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/iot/iot-mqtt-why-good-for-iot/image1.png&quot; alt=&quot;ä½¿ç¨ MQTT ä&amp;quot;£çãæ°æ®å­å¨åç®¡çæ§å¶å°åå¸åè®¢éä¼ æå¨æ°æ®æ¶æ¯çæµç¨å¾&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;atomp&quot;&gt;ATOMP&lt;/h3&gt;
&lt;p&gt;STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互。由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。其中最流行的STOMP消息代理是Apache ActiveMQ。&lt;/p&gt;
&lt;p&gt;ATOMP模型图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201812/1218060-20181211152352552-1423639910.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jms&quot;&gt;JMS&lt;/h3&gt;
&lt;p&gt;注意: JMS不是消息队列协议的一种，更不是消息队列产品!&lt;/p&gt;
&lt;p&gt;注意: JMS不是消息队列协议的一种，更不是消息队列产品!&lt;/p&gt;
&lt;p&gt;注意: JMS不是消息队列协议的一种，更不是消息队列产品!&lt;/p&gt;
&lt;p&gt;关于JMS你需要了解一点有趣的历史.&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;消息队列（Message Queue）起源于一位来自 MIT 的硬件设计教育工作者 Vivek Ranadivé 设想了一种通用软件总线，就像主板上的总线那样，供其他应用程序接入。Vivek在1983年成立了 Teknekron，高盛等公司作为第一批用户再金融交易中采用了 Teknekron的软件，同时还诞生了第一代消息队列软件：Teknekron 的 The Information Bus（TIB）。&lt;/p&gt;
&lt;p&gt;Teknekron 的 TIB 允许应用开发者建立一系列规则去描述消息内容，只要消息按照这些规则发布出去，任何消费者应用都可以订阅感兴趣的内容，信息的生产者和消费者完全解耦，并且可以再传输过程中灵活混合。这个特性引起了电信特别是新闻机构的注意。1994年路透社收购了 Teknekron 。&lt;/p&gt;
&lt;p&gt;由于消息队列再金融交易中应用的反响，BIM 在1990年也开始研发自己的消息队列软件（BIM MQ），并且逐步演化成 WebSphere MQ 并统治着商业消息队列平台市场。同时微软开发了Microsoft Message Queue（MSMQ）。然而这些商业MQ问题在供应商壁垒，各个厂商的 MQ 之间无法互通。为了解决这个问题，Java Message Service（JMS）在2001年诞生了，试图通过提供公共 Java API的方式隐藏MQ各个供应商提供的实际接口，从而跨越壁垒和解决互通问题，但是由于使用单独的标准化接口来胶合众多不同的接口使应用程序反而变得更加脆弱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了解决各个MQ在各个生产商之间的通讯问题，Java Message Service（JMS）在2001年诞生了，试图通过提供公共 Java API的方式隐藏MQ各个供应商提供的实际接口.&lt;code&gt;是Java面向消息中间件的一套规范的Java API接口.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在JMS诞生之前大多数产品都支持点对点和发布/订阅两种方式的通讯模型.所以JMS就将这两种消息模型抽象成两类规范,由MQ厂商选择实现. &lt;code&gt;所以我们可以使用JMS的Java API在Java语言上操作具体的MQ产品.&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;下一章节我们开始进入正式学习MQ消息通讯具体相关产品了,定个小目标,写个简单的MQ&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 07:36:00 +0000</pubDate>
<dc:creator>jimisun</dc:creator>
<og:description>[TOC] 系统通讯方式有哪些? RPC调用 RPC 全称 Remote Procedure Call——远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的方式。 |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimisun/p/10102425.html</dc:identifier>
</item>
<item>
<title>Java 多线程（六）之Java内存模型 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/10102546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/10102546.html</guid>
<description>&lt;p&gt;在并发编程中， 需要处理两个关键问题： 线程之间如何通信及线程之间如何同步&lt;/p&gt;
&lt;p&gt;通信指的是线程之间是以何种机制来交换信息， 在命令式编程中， 线程之间的通信机制有两种：共享内存和消息传递。在共享内存的模型中， 线程之间共享程序的公共状态， 通过读写内存中的公共状态进行隐式通信。在消息传递的并发模型中， 线程之间没有公共状态， 线程之间必须通过发送消息显示的进行通信。&lt;/p&gt;
&lt;p&gt;同步指的是程序中用于控制不同线程之间操作发生相对顺序的机制。在共享内存的并发模型里， 同步是显示进行的。 程序员必须显示的指定某个方法或某段代码需要在线程之间互斥。&lt;/p&gt;
&lt;p&gt;Java 采用的是共享内存模型， Java线程之间的通信总是隐式的进行， 整个通信过程对程序员完全透明。&lt;/p&gt;

&lt;h2 id=&quot;cpu-和-主存&quot;&gt;2.1 CPU 和 主存&lt;/h2&gt;
&lt;p&gt;在计算机中， 所有的计算操作都是由 CPU 的寄存器来完成的。 CPU 指令的执行过程需要涉及数据的读取和写入操作。 CPU 通常能访问的都是计算机的主内存(通常是 RAM)。&lt;/p&gt;
&lt;p&gt;随着制造工艺等的飞速发展， CPU 不断的发展。 但主存的发展却没有多大的突破， 因此， 差距就越来越大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234238197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;CPU和RAM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此， 一种新类型的更快的内存-缓存，就出现了（速度越快越贵），用来弥补两者之间的差距。&lt;/p&gt;
&lt;h2 id=&quot;cpu-cache&quot;&gt;2.2 CPU Cache&lt;/h2&gt;
&lt;p&gt;目前， CPU缓存模型如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234259770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;CPU内存模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;越靠近CPU， 速度越快。 其速度差异如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121023431489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;内存和缓存的速度差异&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CPU Cache 由多个 CPU Line 构成， CPU Line 被认为是最小的缓存单位。&lt;/p&gt;
&lt;h2 id=&quot;cpu如何通过-cache-与-主内存交互&quot;&gt;2.3 CPU如何通过 Cache 与 主内存交互&lt;/h2&gt;
&lt;p&gt;既然有了 CPU Cache， CPU 就不直接跟内存进行交互了。 在程序运行的过程中， 会将运算所需要的数据从主内存复制到 CPU Cache 中， 这样就可以直接对 CPU Cache 进行读取和写入， 当运算结束之后， 在将结果刷新到主内存中。&lt;/p&gt;
&lt;p&gt;通过以上的方式， CPU的吞吐能力得到极大的提高。有了 CPU Cache 之后， 整体的 CPU 和 主内存的交换架构大致如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234357280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;多核CPU和主内存的交换架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该架构中， 每个CPU的 CPU Cache 是自己本地的， 别的CPU无法访问。&lt;/p&gt;
&lt;h2 id=&quot;cpu-缓存一致性问题&quot;&gt;2.4 CPU 缓存一致性问题&lt;/h2&gt;
&lt;p&gt;就如同我们在自己的程序中使用缓存时一样， CPU 引入了缓存， 提高了访问速度， 但也带来了缓存一致性的问题。&lt;/p&gt;
&lt;p&gt;举例&lt;/p&gt;
&lt;p&gt;对于 i++ 这个操作， 需要以下几个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取主内存值 i 到 CPU Cache 中&lt;/li&gt;
&lt;li&gt;对 i 进行自增操作&lt;/li&gt;
&lt;li&gt;将结果写回 CPU Cache 中&lt;/li&gt;
&lt;li&gt;将数据刷新到缓存中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在单线程的情况下， 该操作是没有任何问题的。 但是在多线程的情况下， 变量 i 会在多个线程的本地内存中都存在副本， 如果两个线程都执行以上操作， 读取到的值刚开始都为 0， 那么在进行两次自增操作之后， 主存中的值仍然为 1。 这就是缓存一致性问题。&lt;/p&gt;
&lt;p&gt;为了解决该问题， 聪明的前人发明了两种方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过总线加锁的方式&lt;/li&gt;
&lt;li&gt;通过缓存一致性协议&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总线加锁效率太低， 现在都使用的是缓存一致性协议。&lt;/p&gt;
&lt;p&gt;最出名的就是传说中的 MESI(Modify, Exclusive, Shared, Invalid) 协议。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Modify&lt;/strong&gt;：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exclusive&lt;/strong&gt;：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared&lt;/strong&gt;：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Invalid&lt;/strong&gt;：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MESI 协议为每个 CPU Line 提供状态， 并根据不同状态的操作做出不同的响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234436717.png&quot; alt=&quot;CacheLine&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 MESI 协议中， 有如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Local Read（LR）：读本地cache中的数据&lt;/li&gt;
&lt;li&gt;Local Write（LW）：将数据写到本地cache&lt;/li&gt;
&lt;li&gt;Remote Read（RR）：其他核心发生read&lt;/li&gt;
&lt;li&gt;Remote Write（RW）：其他核心发生write&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234455386.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;MESI&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;java内存模型jmm-1&quot;&gt;3.1 Java内存模型(JMM)&lt;/h2&gt;
&lt;p&gt;Java 虚拟机规范提供了一种Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异， 以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018121023451896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;JMM&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从架构上看， 跟之前提到的物理硬件内存模型有很大的相似度， 但是差别挺大。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主内存： 所有的变量都存储在主内存中（类似于物理硬件的主内存， 不过该内存只是虚拟机内存的一部分）&lt;/li&gt;
&lt;li&gt;工作内存： 工作内存中保存了被该线程用到的变量的主内存副本拷贝（取决于虚拟机的实现， 可能复制的只是对象的引用， 对象的某个字段等）， 线程对变量的操作（读写等）都必须在工作内存中运行， 而不能直接读写主内存中的变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不同的线程之间无法访问对方工作内存中的变量， 线程之间变量的传递必须通过主内存进行&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;内存间交互操作&quot;&gt;3.2 内存间交互操作&lt;/h2&gt;
&lt;p&gt;变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存， 由以下8种原子操作来完成。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;lock: 作用于主内存变量， 它把一个变量标识为一条线程独占的状态&lt;/li&gt;
&lt;li&gt;unlock: 作用于主内存的变量， 它把一个处于加锁的变量释放出来， 释放后的变量才可以被其他线程锁定&lt;/li&gt;
&lt;li&gt;read: 作用于主内存变量， 它把一个变量的值从主内存传输到线程的工作内存， 一般随后的 load 操作&lt;/li&gt;
&lt;li&gt;load: 作用于工作内存的变量， 它把 read 操作从主内存宏得到的值写入工作内存的变量副本中&lt;/li&gt;
&lt;li&gt;use: 作用于工作内存的变量， 把工作内存的变量传递给执行引擎， 每当虚拟机遇到一个需要使用到变量值的字节码指令时就会执行该操作&lt;/li&gt;
&lt;li&gt;assign: 作用于工作区内存的变量， 它把执行引擎接收到的值赋值给工作内存的变量， 当虚拟机遇到给一个给变量赋值的指令时就会执行这个操作&lt;/li&gt;
&lt;li&gt;store: 作用于工作内存变量， 把工作内存中变量的值传送到主内存中， 以便随后的 write 操作&lt;/li&gt;
&lt;li&gt;write: 作用于主内存变量， 它把 store 操作从工作内存中得到的变量值放入主内存变量中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Java模型还对这些操作进行了更加细致的限定， 加上 volatile 的一些特殊规定， 就可以确定 Java 程序中哪些内存访问操作在并发下是安全的。&lt;/p&gt;
&lt;h2 id=&quot;重排序&quot;&gt;3.3 重排序&lt;/h2&gt;
&lt;p&gt;重排序是编译器和处理器为了优化程序性能而对指令序列进行重重排序的一种手段。重排序的目的是在不改变程序执行结果的情况下， 尽可能提高并行度。 有以下几种重排序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编译器优化的重排序。 在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
&lt;li&gt;指令级并行的重排序。现在处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。 如果不存在数据依赖性， 处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
&lt;li&gt;内存系统的重排序。 由于处理器使用缓存和读写缓冲区， 这使得记载和存储操作看上去可能是乱序执行的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从源代码到最终实际执行的指令序列， 经历的3种重排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234616196.png&quot; alt=&quot;源代码到最终执行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1属于编译器重排序， 2和3属于处理器重排序。&lt;/p&gt;
&lt;h3 id=&quot;数据依赖性&quot;&gt;3.3.1 数据依赖性&lt;/h3&gt;
&lt;p&gt;如果两个操作访问同一个变量， 且这两个操作中有一个为写操作， 此时这两个操作之间就存在数据依赖性&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;写后读&lt;/td&gt;
&lt;td&gt;a=1;&lt;br/&gt;b=a;&lt;/td&gt;
&lt;td&gt;写一个变量之后， 在读这个位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;写后写&lt;/td&gt;
&lt;td&gt;a=1;&lt;br/&gt;a=2;&lt;/td&gt;
&lt;td&gt;写一个变量之后， 再写一个变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;读后写&lt;/td&gt;
&lt;td&gt;a=b;&lt;br/&gt;b=1;&lt;/td&gt;
&lt;td&gt;读一个变量之后， 再写这个变量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果对以上的操作并行重排序， 则会改变程序执行的结果。因此， 编译器和处理器在重排序时， 会遵循数据依赖性， 编译器和处理器不会改变存在数据依赖性的两个操作的执行顺序。&lt;/p&gt;
&lt;p&gt;此处说的仅仅是单线程的数据依赖性， 多线程的不考虑。&lt;/p&gt;
&lt;h3 id=&quot;as-if-serial&quot;&gt;3.3.2 as-if-serial&lt;/h3&gt;
&lt;p&gt;即不管程序怎么重排序， （单线程）程序的执行结果不能被改变。 编译器、runtime和处理器必须遵循 as-if-serial 语义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;double pi=3.14;         // A
double r=1.0;           // B
double area = pi*r*r;   // C    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此代码中， A和B都跟C存在数据依赖性， 但是 A 和 B 之间没有依赖性。 因此， C 不能被排到 A或B 之前。 但对 A 和 B， 这两者可以随意排序。&lt;/p&gt;
&lt;h3 id=&quot;程序顺序规则&quot;&gt;3.3.3 程序顺序规则&lt;/h3&gt;
&lt;p&gt;在以上圆形面积的计算中， 有如下三个 happens-before 关系&lt;/p&gt;
&lt;p&gt;1) A happens-before B&lt;br/&gt;2) B happens-before C&lt;br/&gt;3) A happens-before C&lt;/p&gt;
&lt;p&gt;其中第三条是根据前面两条传递性推倒出来的。&lt;/p&gt;
&lt;p&gt;A happens-before B 并不是要求 A 一定要在 B 之前执行， 而是要求A的执行结果对B可见。 但这里的A的执行结果不需要对B可见， 在这种情况下， JMM 会认为这种重排序是合法的， JMM 允许此类重排序。&lt;/p&gt;
&lt;h2 id=&quot;happens-before原则&quot;&gt;3.4 happens-before原则&lt;/h2&gt;
&lt;p&gt;happens-before 是用来阐述操作之间的可见性。 即在JMM中， 如果一个操作执行的结果需要对另一个操作可见， 则这两个操作之间必须存在 happens-before 关系。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210234643129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;happens-before&quot;/&gt;&lt;/p&gt;
&lt;p&gt;happens-before 规则&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序顺序规则（单线程）： 一个线程中的每个操作， happens-before 于该线程中的后续操作。&lt;/li&gt;
&lt;li&gt;监视器规则： 对一个锁的解锁， happens-before 于对该锁的加锁&lt;/li&gt;
&lt;li&gt;volatile规则：对一个 volatile 域的写， happens-before 于随后对这个域的读&lt;/li&gt;
&lt;li&gt;传递性： 如果 A happens-before B， 且 B happens-before C， 则 A happens-before C。&lt;/li&gt;
&lt;li&gt;线程启动规则： 如果线程A执行操作ThreadB.start()（线程B启动）， 那么A线程的 Thread.start() 操作 happens-before 于线程B的任意操作。&lt;/li&gt;
&lt;li&gt;线程终止规则: 如果线程 A 执行操作 ThreadB.join() 并成功返回， 那么编程B中的任意操作 happens-before 于线程A从ThreadB.join()操作成功返回。&lt;/li&gt;
&lt;li&gt;程序中断规则： 对线程interrupt()的方法的调用 happens-before 于被中断线程代码检测到中断事件的发生。&lt;/li&gt;
&lt;li&gt;对象终结规则： 一个对象的初始化完成， happens-before 于发生它的 finalize() 方法的开始。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;原子性可见性和有序性&quot;&gt;3.4 原子性、可见性和有序性&lt;/h2&gt;
&lt;p&gt;JMM 是围绕着在并发过程中如何处理原子性、可见性和有序性这个三个特征来建立的。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;3.4.1 原子性&lt;/h3&gt;
&lt;p&gt;Java 中对以上的八种操作是原子性的。 对应起来就是对基本数据类型的读取/赋值操作都是原子性的， 引用类型的读取和赋值也是如此。&lt;/p&gt;
&lt;p&gt;举几个例子&lt;/p&gt;
&lt;p&gt;赋值操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该操作需要使用 assign 操作， 可能需要 store 和 write 操作。 这些过程都是原子操作。&lt;/p&gt;
&lt;p&gt;可有通过&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;synchronized关键字&lt;/li&gt;
&lt;li&gt;JUC所提供的显式锁Lock&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;来实现原子性&lt;/p&gt;
&lt;h3 id=&quot;可见性&quot;&gt;3.4.1 可见性&lt;/h3&gt;
&lt;p&gt;指的是一个线程中修改了共享变量， 其他的线程就能够&lt;strong&gt;立即&lt;/strong&gt;知道这个修改。 JMM 可以通过以下三种方式来保证可见性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;volatile关键字&lt;/li&gt;
&lt;li&gt;synchronized关键字&lt;/li&gt;
&lt;li&gt;JUC所提供的显式锁Lock&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;有序性&quot;&gt;3.4.2 有序性&lt;/h3&gt;
&lt;p&gt;Java 中天然的有序性可以概括总结为一句话：如果本线程内观察， 所有的操作都是有序的； 如果在一个线程内观察另一个线程， 所有的操作都是无序的。 前半句指的是 as-if-serial 语义， 后半句指的是“指令重排”和“线程内存与主内存同步延迟”的线程。&lt;/p&gt;
&lt;p&gt;有序性的保证：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;volatile: 禁止指令重排&lt;/li&gt;
&lt;li&gt;synchronized： 一个变量再同一时刻， 只允许一条线程对其进行 lock 操作。&lt;/li&gt;
&lt;li&gt;Lock: 同 synchronized&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 11 Dec 2018 07:35:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>1. 并发编程的两个问题 在并发编程中， 需要处理两个关键问题： 线程之间如何通信及线程之间如何同步 通信指的是线程之间是以何种机制来交换信息， 在命令式编程中， 线程之间的通信机制有两种：共享内存和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/10102546.html</dc:identifier>
</item>
<item>
<title>命令模式 Command 行为型 设计模式（十八） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10102153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10102153.html</guid>
<description>&lt;p&gt;命令模式（Command）&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144854718-459409006.png&quot;&gt;&lt;img title=&quot;image_5c0f5d4c_1248&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144855115-1853511670.png&quot; alt=&quot;image_5c0f5d4c_1248&quot; width=&quot;581&quot; height=&quot;331&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;请分析上图中这条命令的涉及到的角色以及执行过程，一种可能的理解方式是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及角色为：大狗子和大狗子他妈&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;过程为：大狗子他妈角色 &lt;span&gt;&lt;strong&gt;调用&lt;/strong&gt;&lt;/span&gt; 大狗子的“回家吃饭”方法&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.origin;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigDog {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; goHomeForDinner() {
System.out.println(&lt;/span&gt;&quot;回家吃饭&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.origin;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigDogMother {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
BigDog bigDog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDog();
bigDog.goHomeForDinner();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;BigDog类拥有回家吃饭方法goHomeForDinner&lt;/p&gt;
&lt;p&gt;BigDogMother作为客户端调用BigDog的回家吃饭方法，完成了“大狗子回家吃饭”这个请求&lt;/p&gt;
&lt;p&gt;上面的示例中，&lt;span&gt;&lt;strong&gt;通过对命令执行者的方法调用，完成了命令的下发，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;命令调用者与命令执行者之间是紧密耦合的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们&lt;span&gt;&lt;strong&gt;是否可以考虑换一种思维方式，将“你妈喊你回家吃饭”这一命令封装成为一个对象？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不再是大狗子他妈调用大狗子的回家吃饭方法&lt;/p&gt;
&lt;p&gt;而是大狗子他妈下发了一个命令，命令的内容是“大狗子回家吃饭”&lt;/p&gt;
&lt;p&gt;接下来是命令的执行&lt;/p&gt;
&lt;p&gt;这样的话，“命令”就不再是一种方法调用了，在大狗子妈和大狗子之间多了一个环节---“命令”&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;看下代码演变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BigDog 没有变化&lt;/p&gt;
&lt;p&gt;新增加了命令类Command  使用对象的接受者BigDog 进行初始化&lt;/p&gt;
&lt;p&gt;命令的execute方法内部调用接受者BigDog的方法&lt;/p&gt;
&lt;p&gt;BigDogMother中下发了三个命令&lt;/p&gt;
&lt;p&gt;然后逐个执行这三个命令&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.origin;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigDog {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; goHomeForDinner() {
System.out.println(&lt;/span&gt;&quot;回家吃饭&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.origin;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Command {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDog bigDog;
Command(BigDog bigDog) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bigDog =&lt;span&gt; bigDog;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
bigDog.goHomeForDinner();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.origin;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BigDogMother {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
BigDog bigDog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDog();
Command command1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Command(bigDog);
Command command2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Command(bigDog);
Command command3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Command(bigDog);

command1.execute();
command2.execute();
command3.execute();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面的代码示例中看到，通过对“请求”也就是“方法调用”的封装，将请求转变成了一个个的命令对象 &lt;/p&gt;
&lt;p&gt;命令对象本身内部封装了一个命令的执行者&lt;/p&gt;
&lt;p&gt;好处是：命令可以进行保存传递了，命令发出者与命令执行者之间完成了解耦，命令发出者甚至不知道具体的执行者到底是谁&lt;/p&gt;
&lt;p&gt;而且执行的过程也更加清晰了&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将一个请求封装为一个对象，从而使可用不同的请求对客户进行参数化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对请求排队或者记录请求日志，以及支持可撤销的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;别名 行为Action或者事物Transaction&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令模式就是将方法调用这种命令行为或者说请求 进一步的抽象，封装为一个对象&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面的“大狗子你妈喊你回家吃饭”的例子只是展示了对于“命令”的一个封装。只是命令模式的一部分。&lt;/p&gt;
&lt;p&gt;下面看下命令模式完整的结构&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144855386-10019274.png&quot;&gt;&lt;img title=&quot;image_5c0f5d4c_60a2&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144855624-1023765543.png&quot; alt=&quot;image_5c0f5d4c_60a2&quot; width=&quot;586&quot; height=&quot;260&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令角色Command&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;声明了一个给所有具体命令类的抽象接口&lt;/p&gt;
&lt;p&gt;做为抽象角色，通常是接口或者实现类&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;具体命令角色ConcreteCommand&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;定义一个接受者和行为之间的弱耦合关系，实现execute（）方法&lt;br/&gt;负责调用命令接受者的响相应操作&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;请求者角色Invoker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;负责调用命令对象执行命令，相关的方法叫做行动action方法&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接受者角色Receiver&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;负责具体实施和执行一个请求，任何一个类都可以成为接收者&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Command角色封装了命令接收者并且内部的执行方法调用命令接收者的方法&lt;/p&gt;
&lt;p&gt;也就是一般形如：&lt;/p&gt;
&lt;p&gt;Command（Receiver receiver）{&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;execute（）{&lt;/p&gt;
&lt;p&gt;receiver.action（）；&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;而Invoker角色接收Command，调用Command的execute方法&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过将“命令”这一行为抽象封装，命令的执行不再是请求者调用被请求者的方法这种强关联 ，而是可以进行分离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分离后，这一命令就可以像普通的对象一样进行参数传递等&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结构代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;command角色&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Command {
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ConcreateCommand角色&lt;br/&gt;内部拥有命令接收者，内部拥有execute方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreateCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Command {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Receiver receiver;
ConcreateCommand(Receiver receiver) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.receiver =&lt;span&gt; receiver;
}
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
receiver.action();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;

&lt;p&gt;Receiver命令接收者，实际执行命令的角色&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Receiver {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; action(){
  System.out.println(&lt;/span&gt;&quot;command receiver do sth....&quot;&lt;span&gt;);
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;命令请求角色Invoker 用于处理命令，调用命令角色执行命令&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Invoker {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command command;
Invoker(Command command){
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.command =&lt;span&gt; command;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; action(){
command.execute();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;客户端角色&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
Receiver receiver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Receiver();
Command command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcreateCommand(receiver);
Invoker invoker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invoker(command);
invoker.action();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144855889-326401063.png&quot;&gt;&lt;img title=&quot;image_5c0f5d4c_13f0&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144856064-695074527.png&quot; alt=&quot;image_5c0f5d4c_13f0&quot; width=&quot;548&quot; height=&quot;90&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;在客户端角色的测试代码中，我们创建了一个命令，指定了接收者（实际执行者）&lt;/p&gt;
&lt;p&gt;然后将命令传递给命令请求调用者&lt;/p&gt;
&lt;p&gt;虽然最终命令的接收者为receiver，但是很明显如果这个Command是作为参数传递进来的&lt;/p&gt;
&lt;p&gt;Client照样能够运行，他只需要借助于Invoker执行命令即可&lt;/p&gt;

&lt;p&gt;&lt;span&gt;命令模式关键在于：引入命令类对方法调用这一行为进行封装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令类使的命令发送者与接收者解耦，命令请求者通过命令类来执行命令接收者的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而不在是直接请求命名接收者&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;假设电视机只有三个操作：开机open 关机close和换台change channel。&lt;/p&gt;
&lt;p&gt;用户通过遥控器对电视机进行操作。&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;电视机本身是命令接收者 Receiver&lt;/p&gt;
&lt;p&gt;遥控器是请求者角色Invoker&lt;/p&gt;
&lt;p&gt;用户是客户端角色Client&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;需要将用户通过遥控器下发命令的行为抽象为命令类Command&lt;/p&gt;
&lt;p&gt;Command有开机命令 关机命令和换台命令&lt;/p&gt;
&lt;p&gt;命令的执行需要借助于命令接收者&lt;/p&gt;
&lt;p&gt;Invoker 调用Command的开机命令 关机命令和换台命令&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;电视类  Tv&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tv {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOn(){
System.out.println(&lt;/span&gt;&quot;打开电视&quot;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOff(){
System.out.println(&lt;/span&gt;&quot;关闭电视&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeChannel(){
System.out.println(&lt;/span&gt;&quot;换台了&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Command接口&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Command {
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;三个具体的命令类&lt;/p&gt;
&lt;p&gt;内部都保留着执行者，execute方法调用他们的对应方法&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OpenCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Command {
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Tv myTv;
 
OpenCommand(Tv myTv) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myTv =&lt;span&gt; myTv;
}
 
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
myTv.turnOn();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CloseCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Command {
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Tv myTv;
 
CloseCommand(Tv myTv) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myTv =&lt;span&gt; myTv;
}
 
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
myTv.turnOff();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChangeChannelCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Command {
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Tv myTv;
 
ChangeChannelCommand(Tv myTv) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myTv =&lt;span&gt; myTv;
}
 
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
myTv.changeChannel();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;遥控器Controller&lt;/p&gt;
&lt;p&gt;拥有三个命令&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Command openCommand = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Command closeCommand = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Command changeChannelCommand = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Controller(Command on， Command off， Command change) {
openCommand &lt;/span&gt;=&lt;span&gt; on;
closeCommand &lt;/span&gt;=&lt;span&gt; off;
changeChannelCommand &lt;/span&gt;=&lt;span&gt; change;
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOn() {
openCommand.execute();
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOff() {
closeCommand.execute();
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeChannel() {
changeChannelCommand.execute();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;用户类User &lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command.tv;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
Tv myTv &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tv();
OpenCommand openCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenCommand(myTv);
CloseCommand closeCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CloseCommand(myTv);
ChangeChannelCommand changeChannelCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChangeChannelCommand(myTv);
Controller controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Controller(openCommand， closeCommand， changeChannelCommand);
controller.turnOn();
controller.turnOff();
controller.changeChannel();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144856321-1739112525.png&quot;&gt;&lt;img title=&quot;image_5c0f5d4c_25a0&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144856542-1594201771.png&quot; alt=&quot;image_5c0f5d4c_25a0&quot; width=&quot;519&quot; height=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上示例将电视机的三种功能开机、关机、换台 抽象为三种命令&lt;/p&gt;
&lt;p&gt;一个遥控器在初始化之后，就可以拥有开机、关机、换台的功能，但是却完全不知道底层的实际工作的电视。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;命令请求记录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一旦将“发起请求”这一行为进行抽象封装为命令对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么“命令”也就具有了一般对象的基本特性，比如，作为参数传递&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;比如使用容器存放进行存放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如定义一个ArrayList  用于保存命令&lt;/p&gt;
&lt;p&gt;ArrayList&amp;lt;Command&amp;gt; commands = new ArrayList&amp;lt;Command&amp;gt;();&lt;/p&gt;
&lt;p&gt;这就形成了一个队列&lt;/p&gt;
&lt;p&gt;你可以动态的向队列中增加命令，也可以从队列中移除命令&lt;/p&gt;
&lt;p&gt;你还可以将这个队列保存起来，批处理的执行或者定时每天的去执行&lt;/p&gt;
&lt;p&gt;你还可以将这些命令请求持久化到文件中，因为这些命令、请求 也不过就是一个个的对象而已&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;请求命令队列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;既然可以使用容器存放命令对象，我们可以实现一个命令队列，对命令进行批处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;新增加一个CommandQueue类，内部使用ArrayList存储命令&lt;/p&gt;
&lt;p&gt;execute（）方法，将内部的请求命令队列全部执行&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandQueue {
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;Command&amp;gt; commands = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Command&amp;gt;&lt;span&gt;();
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCommand(Command command) {
commands.add(command);
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeCommand(Command command) {
commands.remove(command);
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行队列内所有命令&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object command : commands) {
((Command) command).execute();
}
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;同时调整Invoker角色，使之可以获得请求命令队列，并且执行命令请求队列的方法&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; command;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Invoker {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command command;
Invoker(Command command) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.command =&lt;span&gt; command;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; action() {
command.execute();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增加命令队列&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CommandQueue commandQueue;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Invoker(CommandQueue commandQueue) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commandQueue =&lt;span&gt; commandQueue;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
* 新增加队列批处理方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; batchAction() {
commandQueue.execute();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面的示意代码可以看得出来，&lt;span&gt;&lt;strong&gt;请求队列的关键就是命令类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一旦创建了命令类，就解除了命令请求者与命令接收者之间耦合，&lt;/span&gt;&lt;span&gt;就可以把命令当做一个普通对象进行处理，调用他们的execute（）执行方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;所谓请求队列不就是使用容器把命令对象保存起来，然后调用他们的execute方法嘛&lt;/p&gt;
&lt;p&gt;所以说，&lt;span&gt;命令请求的对象化，可以实现对请求排队或者记录请求日志的目的，就是命令对象的队列&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h4&gt;&lt;span&gt;宏命令&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;计算机科学里的宏（Macro)，是一种批量批处理的称谓&lt;/p&gt;
&lt;p&gt;一旦请求命令&quot;对象化&quot;，就可以进行保存&lt;/p&gt;
&lt;p&gt;上面的请求队列就是如此，保存起来就可以实现批处理的功能，这就是命令模式的宏命令&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;撤销操作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在上面的例子中，我们没有涉及到撤销操作&lt;/p&gt;
&lt;p&gt;命令模式如何完成“撤销”这一行为呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令是对于请求这一行为的封装抽象，每种ConcreteCommand都对应者接收者一种具体的行为方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以想要能够有撤销的行为，命令接收者（最终的执行者）必然需要有这样一个功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果Receiver提供了一个rollback方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就是说如果一个receiver有两个方法，action（）和rollback（）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当执行action方法后，调用rollback可以将操作进行回滚&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么，我们就可以给Command增加一个方法，recover（） 用于调用receiver 的rollback方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这样一个命令对象就有了两种行为，执行execute和恢复recover&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我们在每次的命令执行后，将所有的 执行过的 命令保存起来&lt;/p&gt;
&lt;p&gt;当需要回滚时，只需要逐个（或者按照执行的相反顺序）执行命令对象的recover方法即可&lt;/p&gt;
&lt;p&gt;这就很自然的完成了命令的撤销行为，而且还可以批量进行撤销&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令模式的撤销操作依赖于命令接收者本身的撤销行为，如果命令接收者本身不具备此类方法显然没办法撤销&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另外就是依赖对执行过的命令的记录&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;对于“大狗子你妈喊你回家吃饭”的例子，我想你也会觉得大狗子妈直接调用大狗子的方法就好了&lt;/p&gt;
&lt;p&gt;脱裤子放屁，抽象出来一个命令对象有什么用呢？&lt;/p&gt;

&lt;p&gt;对于简单的方法调用，个人也认为是自找麻烦&lt;/p&gt;
&lt;p&gt;命令模式是有其使用场景以及特点的，并不是说不分青红皂白的将请求处理都转换为命令对象&lt;/p&gt;

&lt;p&gt;到底什么情况需要使用命令模式？&lt;/p&gt;
&lt;p&gt;通过上面的分析，如果你&lt;span&gt;&lt;strong&gt;希望将请求进行排队处理，或者请求日志的记录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么你就很可能需要命令模式，只有将请求转换为命令对象，这些行为才更易于实现&lt;/p&gt;

&lt;p&gt;如果系统&lt;span&gt;&lt;strong&gt;希望支持撤销操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;span&gt;&lt;strong&gt;请求的对象化&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;可以方便的将命令的执行过程记录下来&lt;/strong&gt;&lt;/span&gt;，就下来之后，就形成了“操作记录”&lt;/p&gt;
&lt;p&gt;拥有了操作记录，如果有撤销方法，就能够执行回滚撤销&lt;/p&gt;

&lt;p&gt;如果希望&lt;span&gt;&lt;strong&gt;命令能够被保存起来组成宏命令，重复执行&lt;/strong&gt;&lt;/span&gt;或者定时执行等，就可以使用命令模式&lt;/p&gt;

&lt;p&gt;如果希望将&lt;span&gt;&lt;strong&gt;请求的调用者和请求的执行者进行解耦&lt;/strong&gt;&lt;/span&gt;，使得请求的调用者和执行者并不直接接触&lt;/p&gt;
&lt;p&gt;命令对象封装了命令的接收者，请求者只关注命令对象，根本不知道命令的接收者&lt;/p&gt;

&lt;p&gt;如果希望&lt;span&gt;&lt;strong&gt;请求具有更长的生命周期&lt;/strong&gt;&lt;/span&gt;，普通方法调用，命令发出者和命令执行者具有同样的生命周期&lt;/p&gt;
&lt;p&gt;命令模式下，命令对象封装了请求，完成了命令发出者与命令接收者的解耦&lt;/p&gt;
&lt;p&gt;命令对象创建后，只依赖命令接收者的执行，只要命令接收者存在，就仍旧可以执行，但是命令发出者可以消亡&lt;/p&gt;

&lt;p&gt;总之命令模式的特点以及解决的问题，也正是他适用的场景&lt;/p&gt;
&lt;p&gt;这一点在其他模式上也一样&lt;/p&gt;
&lt;p&gt;特点以及解决的问题，也正是他适用的场景，适用场景也正是它能解决的问题&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;命令模式中对于场景中命令的提取，始终要注意它的核心“&lt;span&gt;&lt;strong&gt;对接收者行为的命令抽象&lt;/strong&gt;&lt;/span&gt;”&lt;/p&gt;
&lt;p&gt;比如，电视作为命令接收者，开机，关机，换台是他自身固有的方法属性，你的命令也就只能是与之对应的开机、关机、换台&lt;/p&gt;
&lt;p&gt;你不能打游戏，即使你能打游戏，电视也不会让你打游戏&lt;/p&gt;
&lt;p&gt;这是具体的命令对象ConcreteCommand的设计思路&lt;/p&gt;

&lt;p&gt;Command提供抽象的execute方法，所有的命令都是这个方法&lt;/p&gt;
&lt;p&gt;调用者只需要执行Command的execute方法即可，不关注到底是什么命令，命令接收者是谁&lt;/p&gt;
&lt;p&gt;如果命令的接收者有撤销的功能，命令对象就可以也同样支持撤销操作&lt;/p&gt;
&lt;p&gt;关于如何抽取命令只需要记住:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令模式中的命令对象是请求的封装，请求基本就是方法调用，方法调用就是需要方法的执行者，也就是命令的接收者有对应行为的方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;请求者和接收者通过命令对象进行解耦，降低了系统的耦合度&lt;/p&gt;
&lt;p&gt;命令的请求者Invoker与命令的接收者Receiver通过中间的Command进行连接，Command中的协议都是execute方法&lt;/p&gt;
&lt;p&gt;所以，如果新增加命令，命令的请求者Invoker完全不需要做任何更改，他仍旧是接收一个Command，然后调用他的execute方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;具有良好的扩展性，满足开闭原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144856832-784520869.png&quot;&gt;&lt;img title=&quot;image_5c0f5d4c_5994&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181211144857111-527070319.png&quot; alt=&quot;image_5c0f5d4c_5994&quot; width=&quot;626&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;回到刚才说的，具体的命令对象ConcreteCommand的设计思路&lt;/p&gt;
&lt;p&gt;需要与命令接收者的行为进行对应&lt;/p&gt;
&lt;p&gt;也就是&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对每一个对请求接收者的调&lt;/span&gt;&lt;span&gt;用操作，都需要设计一个具体命令类，&lt;/span&gt;可能会出现大量的命令类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有一句话说得好，“杀鸡焉用宰牛刀”，所以使用命令模式一定要注意场景&lt;/p&gt;
&lt;p&gt;以免被别人说脱裤子放屁，为了用设计模式而用设计模式....&lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 07:03:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>命令模式是行为型设计模式，本文对命令模式Command进行了简单介绍，深入的分析了命令模式的意图，以及演化逻辑，并且给出了命令模式的Java版示例，理解命令模式有利于理解面向对象的编程思想，一切皆是对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10102153.html</dc:identifier>
</item>
<item>
<title>airflow 文档学习(二) - 概念 - INVOKERrrrrrr~</title>
<link>http://www.cnblogs.com/ZhangShY/p/10102210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhangShY/p/10102210.html</guid>
<description>&lt;h3 id=&quot;dags&quot;&gt;1.1 DAGs&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有向无环图&lt;/p&gt;&lt;p&gt;反映所涉及的task的依赖关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：搜索dag的时候，airflow只会关注同事包含&quot;DAG&quot;和&quot;airflow&quot;字样的py文件&lt;/p&gt;
&lt;h3 id=&quot;scope&quot;&gt;1.2 scope&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;airflow将加载任何可以从DAG file中import的DAG对象，但是它们必须出现在globals()中，例如下面的文件，只有tag_1会被加载，tag_2只会出现在本地scope中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;dag_1 = DAG('this_dag_will_be_discovered')
def my_function():
dag_2 = DAG('but_this_dag_will_not')
my_function()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;default-arguments&quot;&gt;1.3 Default Arguments&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果一个字典default_args被传给一个DAGs，它将会将其运用到所有的它的operator中。这使得复用default_args变得非常的方便&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;context-manager&quot;&gt;1.4 Context Manager&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dags可以被当做一个管理器，去自动的分配新的operators给dag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;operators&quot;&gt;1.5 Operators&lt;/h3&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;dags描述的是怎么去跑一个工作流，operators决定实际做什么。&lt;/p&gt;&lt;p&gt;一个operator描述了在一个工作流中的单个task。operators经常但不总是原子的，这意味着他们可以独立存在而不需要去和别的operator分享资源。DAG将确保operators以正确的顺序运行，在这些依赖之外，operator通常是独立运行的，甚至他们肯能运行在不同的机器上。&lt;/p&gt;&lt;p&gt;这是个非常微妙的关键点：事实上，如果两个operator需要去共享一些信息，就像文件名或者一些小的数据，你应该去考虑将他们合并到一个operator中，如果上述情况确实是无法避免的，airflow有operator的交叉通信（xcom）在文档中有描述。&lt;/p&gt;&lt;p&gt;并且airflow提供了非常多的通用operator：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;BashOperator 
PythonOperator 
EmailOperator
SimpleHttpOperator 等等&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dag-assignment&quot;&gt;1.6 DAG Assignment&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;operator不用立马被分配给一个dag，但是，一旦operator被分配给了一个dag，它将无法被转移或者是取消分配。dag的分配在operator被创建之后可以被非常明确的完成，通过延期分配或者从其他operator推断的方式&lt;/p&gt;&lt;p&gt;例如下面的方式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;dag = DAG('my_dag', start_date=datetime(2016, 1, 1))
# sets the DAG explicitly
explicit_op = DummyOperator(task_id='op1', dag=dag)
# deferred DAG assignment
deferred_op = DummyOperator(task_id='op2')
deferred_op.dag = dag
# inferred DAG assignment (linked operators must be in the same DAG)
inferred_op = DummyOperator(task_id='op3')
inferred_op.set_upstream(deferred_op)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bitshift-composition&quot;&gt;1.7 Bitshift Composition&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在以前，operator的关系描述是通过set_upstream()和set_downstream()方法，在1.8 之后可以通过&amp;lt;&amp;lt;和&amp;gt;&amp;gt;代替依赖方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;tasks&quot;&gt;1.8 Tasks&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当一个operator被实例化之后，它就被称为是一个task。实例化在调用抽象operator时定义了具体的值，同时，参数化之后的task会称为dag的一个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;task-instances&quot;&gt;1.9 Task Instances&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;一个task实例代表一个task的特定运行，其特征在于dag、任务、和时间点的组合。&lt;/p&gt;&lt;p&gt;它拥有运行状态：running、success、failed、skipped、up for retry等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;workflows&quot;&gt;1.10 Workflows&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过组合dags和operators，你会创建TaskInstances，你可以创建复杂的工作流。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;hooks&quot;&gt;2.1 Hooks&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Hooks是连接一些平台和数据库的接口，类似于 Hive, S3, MySQL, Postgres, HDFS, Pig。hooks尽可能的实现了通用接口，并且充当operator。还需要使用airflow.models.Connection 模型来检索主机名和身份认证信息，hooks将身份认证信息和代码放在管道之外，集中在元数据库中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;pools&quot;&gt;2.2 pools&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一些系统会因为太多的进程不堪重负，airflow的pool可以被用作限制任意的task的运行。task可以在创建时通过参数指定存在的pool名称。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;aggregate_db_message_job = BashOperator(
task_id='aggregate_db_message_job',
execution_timeout=timedelta(hours=3),
pool='ep_data_pipeline_db_msg_agg',
bash_command=aggregate_db_message_job_cmd,
dag=dag)
aggregate_db_message_job.set_upstream(wait_for_empty_queue)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;pool中可以使用priority_weight参数去定义他的在队列中的权重，并且决定哪个task先行执行。&lt;/p&gt;&lt;p&gt;当容量被撑满时，task将会放入计划执行，一旦有容量，可运行的task和他们的状态将会被在前端展示，当插槽空闲，队列中的task将会基于权重进行排序执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;connections&quot;&gt;2.3 Connections&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;外部系统的connection信息被存储在airflow的元数据库中，airflow的管道可以很简单地引用被集中管理的conn_id,无需另外进行操作。&lt;/p&gt;&lt;p&gt;当许多的connections被定义在同一个conn_id下，在这种情况下，当hooks使用get_connection方法时，airflow将随机选择一个connection，当重试时允许一些基本的负载均衡和容错。&lt;/p&gt;&lt;p&gt;一些hooks有默认的conn_id，当operators使用这个hook时不需要一个明确的conn_id。例如：PostgresHook的默认conn_id是postgres_default&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;queues&quot;&gt;2.4 Queues&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;当我们使用CeleryExecutor时，被塞入celery队列的task是可以被规定的，队列是BaseOperator的属性，所以任何task可以被分配到任何的队列中，而默认的队列环境是在配置文件的celery下的default_queue中配置的。&lt;/p&gt;&lt;p&gt;workers可以监听一个或多个队列中的task，当一个worker启动的时候（使用airflow worker命令），一个以逗号分隔的对列名可以被指定(airflow worker -q spark)，这个worker将只会选择那些被连接到指定对列的task。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;xcoms&quot;&gt;2.5 XComs&lt;/h3&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;XComs使得tasks可以交换信息，允许更加细微的控制形式和分享状态。XComs原则上定义成key、value和timestamp，但是也可以跟踪一些属性，例如创建XCom的task/DAG。&lt;/p&gt;&lt;p&gt;XComs可以被pushed或者pulled，当一个task发送一个xcom，这个xcom是普遍可获得的。task可以被发送通过使用方法xcom_push()，此外，当一个task返回一个值时（不管是operators的execute()方法还是PythonOperators的python_callable方法），一个包含着返回值的xcom会自动发送。&lt;/p&gt;&lt;p&gt;tasks调用xcom_pull()去接受xcoms，可选择的根据key、task_ids、dag_id进行过滤。默认的，xcom_pull()在获得值时会根据keys自动筛选执行方法。&lt;/p&gt;&lt;p&gt;如果xcom_pull被传了一个task_id，则对应task最近一次的xcom值会被返回，如果一组task_ids传过去，会返回一组对应的xcom值&lt;/p&gt;&lt;p&gt;也可以直接在模板中获取xcom，例如：SELECT * FROM {{ task_instance.xcom_pull(task_ids='foo', key='table_name') }}&lt;/p&gt;&lt;p&gt;值得注意的是，xcom与variable非常相似，但它是专门用于任务之间的通信而不是全局设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;variables&quot;&gt;2.6 Variables&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;variables是一种传统的方式去存储和取回任意的内容或者是key-value形式的airflow的设置，它可以在前端界面、代码或者cli中进行增删改查的操作，当你定义管道代码，就可非常方便的使用，例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from airflow.models import Variable
foo = Variable.get(&quot;foo&quot;)
bar = Variable.get(&quot;bar&quot;, deserialize_json=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你可以使用variables在一个jinjia模板中：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;echo {{ var.value.&amp;lt;variable_name&amp;gt; }}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;branching&quot;&gt;2.7 Branching&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;有时候你需要你的工作流进行分支，或者是根据任意上游发生的条件走某条路。这其中一种实现方法就是使用BranchPythonOperator&lt;/p&gt;&lt;p&gt;BranchPythonOperator和PythonOperator十分相似，除了python会期望一个python_callable去返回一个task_id，返回的task_id跳过所有其他路径，python的返回函数的task_id必须直接引用BranchPythonOperator任务下游的任务。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，在BranchPythonOperator中使用depend_on_past = True下游的任务在逻辑上是不合理的，因为跳过状态总是导致依赖于过去成功的块任务。如果非要这样的话可以中间建立一个虚拟任务进行过度。&lt;/p&gt;
&lt;h3 id=&quot;subdags&quot;&gt;2.8 SubDAGs&lt;/h3&gt;
&lt;h3 id=&quot;slas&quot;&gt;2.9 SLAs&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;记录失败的过错的sla任务列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;trigger-rules&quot;&gt;2.10 Trigger Rules&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;虽然正常的工作流行为是在所有的直接上游任务成功之后触发的，但是airflow允许更为复杂的依赖项。&lt;/p&gt;&lt;p&gt;所有的operators有一个trigger_rule，用来定义生成的任务被触发的规则，trigger_rule的默认参数是all_success，以下为别的参数解释：&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;all_success: (default) 所有的父级任务成功
all_failed: 所有的父级任务失败，或者上游状态为失败
all_done: 所有的父级任务执行完成
one_failed: 至少一个失败，并且不会等待所有任务执行完成
one_success: 至少一个成功，并且不会等待所有任务执行完成
dummy: 依赖只是为了展示，随意触发&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这些可以与depends_on_past结合使用，当设置为true时，如果任务的先前计划未成功，则不会触发&lt;/p&gt;
&lt;h3 id=&quot;latest-run-only&quot;&gt;2.11 Latest Run Only&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;标准工作流行为涉及为特定日期/时间范围内运行的一系列任务，但是，某些工作流执行的任务与运行时间无关，但是需要按计划运行，就像标准的cron作业一样，在这些情况下，暂停期间错过的回填运行作业会浪费cpu周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;zombies-undeads&quot;&gt;2.12 Zombies &amp;amp; Undeads&lt;/h3&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;僵尸任务的特点是没有心跳（由工作定期发出）和数据库中的运行状态，当工作节点无法访问数据库的时候，airflow进程在外部被终止或者节点重启的时候，他们可能会发生。僵尸查杀由调度程序的进程定期执行。&lt;/p&gt;&lt;p&gt;undead进程的特点是存在进程和匹配的心跳，但是airflow不知道此任务在数据库中运行。这种不匹配通常在数据库状态发生改变的时候发生，最有可能是通过删除UI中的任务实例视图中的行，指示任务验证其作为心跳例程的一部分的状态，并在确定他们处于这种不死的状态时终止自身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;cluster-policy&quot;&gt;2.13 Cluster Policy&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你本地airflow设置文件可以定义一个策略功能，该功能可以根据其他任务或DAG属性改变其任务属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;documentation-notes&quot;&gt;2.14 Documentation &amp;amp; Notes&lt;/h3&gt;
&lt;h3 id=&quot;jinja-templating&quot;&gt;2.15 Jinja Templating&lt;/h3&gt;
</description>
<pubDate>Tue, 11 Dec 2018 06:57:00 +0000</pubDate>
<dc:creator>INVOKERrrrrrr~</dc:creator>
<og:description>1. 核心功能 1.1 DAGs 有向无环图 反映所涉及的task的依赖关系 注：搜索dag的时候，airflow只会关注同事包含</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhangShY/p/10102210.html</dc:identifier>
</item>
<item>
<title>从Java小白到收获BAT等offer，分享我这两年的经验和感悟 - How_2_Play_Life</title>
<link>http://www.cnblogs.com/xll1025/p/10102179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10102179.html</guid>
<description>&lt;p&gt;点击关注并置顶，江湖要事早提醒&lt;/p&gt;


&lt;p&gt;点击关注并指定，江湖要事早知道&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;我&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常想，人生最有趣莫过于前路未知。于是我常常羡慕那些个“金梁古温”笔下随遇而安、随性而为、随缘而爱的浪子们。比如陆小凤，比如叶开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XHh0SksQZPMl9GQ4JyBU8ywiapbJsBOhluQJicClazxyTfuSLx2qvwm4pSyaI6HwS8or2RM5sO8SRzqUele8fn9Q/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我写过很多篇秋招总结，这篇文章应该是最后一篇总结，当然也是最完整，最详细的一篇总结。秋招是我人生中一段宝贵的经历，不仅是我研究生生涯交出的一份答卷，也是未来职业生涯的开端。仅以此文，献给自己，以及各位在求职路上的，或者是已经经历过校招的朋友们。不忘初心，方得始终。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在下本是跨专业渣考研的985渣硕一枚，经历研究生两年的学习积累，有幸于2019秋季招聘中拿到几个公司的研发岗offer，包括百度，阿里，腾讯，今日头条，网易，华为等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;（在秋招末期，有幸又拿到了滴滴和亚马逊的offer，那时已经11月份了，所以之前的文章里都没有提到过）&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一路走来也遇到很多困难，也踩了很多坑，同时我自己也探索了很多的学习方法，总结了很多心得体会，并且，我对校园招聘也做了一些研究和相应的准备。在今年的秋季招聘结束以后，我也决定把这些东西全部都写成文字，做成专题，以便分享给更多未来将要参加校招的同学。&lt;/p&gt;

&lt;p&gt;大学时期的迷茫与坚定&lt;/p&gt;
&lt;p&gt;我的本科专业是电子信息工程，基本没有接触过计算机专业的课程，只学过c语言，然后在大三的时候接触过java，Android，以及前端开发。这时候我只是一个刚刚入门的菜鸟，还不知道软件开发的水有多深，抱着试一试的态度去应聘了很多公司。结果可想而知，连简历筛选都没有通过。&lt;/p&gt;
&lt;p&gt;当年我对游戏开发很有兴趣，特别是对网易游戏情有独钟，但是当我看到网易游戏研发工程师的招聘要求时，我只能望而却步，因为它要求学历至少是985的硕士。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也因为这个契机，我在大三的暑假开始准备考研，花了一个月的时间深思熟虑之后，选择了华科作为我的目标院校。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是，2016年的下半年，我成为了“两耳不闻窗外事，一心只读圣贤书”的考研党，回想起来那确实是玩命学习的半年时间，每天稳定泡在图书馆8个小时以上，有时候学到宿舍都能学到晚上12点，那时候感觉自己完全变了一个人似的，可能当一个人为了某个目标而努力时，真的会变得不一样。最终我顺利地考上了，令我意外的是，成绩还挺不错。&lt;/p&gt;

&lt;p&gt;对于即将读研的同学来说，一般有两件事很重要，一件事是选择导师，一件事是选择方向。&lt;/p&gt;
&lt;p&gt;我在刚读研的时候最头疼的也是这两件事情。首先说明一下，我读的是专硕，所以实验室一般不搞科研，有部分导师会带项目，&lt;strong&gt;由于我不打算在实验室做项目（因为我更希望去大公司里锻炼几年），所以我当时本着想要找实习的想法选择了导师，事实证明我的选择还是很正确的，我在研二有大段时间去参加实习，让我在大厂里有足够的时间去锻炼和学习。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而选择方向这件事，我倒是折腾了好久。研一期间我做的最多的事情就是看书了，当时自己的方向还不明确，所以找了很多书来看。当别人都在专研数据挖掘和机器学习时，我还在各种方向之间摇摆不定。&lt;/p&gt;
&lt;p&gt;我在读研之前想做游戏开发和Android开发，但我以前也学过Java Web开发。于是我在网上了解对应方向的资讯，发现游戏研发的就业面比较窄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，我综合公司的岗位情况，个人兴趣，以及我之前的学习经历等因素，选定了Java开发方向。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是，我在学校的实训项目中选择了Java Web项目，从此也真正意义上地踏上了Java的学习之路。&lt;/p&gt;

&lt;p&gt;尽管我的入学成绩是全学院的top3，但是，我发现，作为非科班出身的我，和很多科班同学相比，还是有一定差距的。&lt;/p&gt;
&lt;p&gt;大部分同学本科都上过计算机专业的相关课程，比如计算机网络，操作系统，数据结构等等，而我以前连听都没听过，除此之外，他们一般都会几段比较完整的项目经验，至少在Java Web方面已经算是比较熟悉了。而我在当时，只学了数据结构，另外接触过一些Java基础，有一部分项目经验，基本上就是入门水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是我痛定思痛，决定好好弥补我的不足，平时一有空就去图书馆找些书来看，不论是操作系统，计算机网络，还是数据库等本科课程，我都会找一些对应的书籍来看，当时不太清楚其实有些课程其实不需要特地去补，以至于我连计算机组成原理，编译原理，软件测试等方面的书都特地找来看，现在想想也是挺逗比的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于我们上的课比较水，所以上课时间反而变成了我自学基础课程的大好时光了。所以我平时上课的时候都会带两三本书，一到两周内看完一本，虽然可能吸收的不是特别好，但是对当时的我来说还是有很大帮助的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除&lt;/strong&gt;&lt;strong&gt;此之外，有时候我还会偷偷去旁听有一些本科生的课程，这也是因为我在自学一些课程的时候遇到了困难，比如《操作系统》，《数据库原理》等等。于是我花时间研究了一下本科生的课表，趁着自己没课的时候赶紧去旁听课程。有时候感觉自己在课堂中显得非常突兀，尴尬地想要逃跑，但总算是坚持地听完了一门数据库的课程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外，我还在各种视频网站上看网课，比亦或是看中国MOOC的计算机基础课程，里面的操作系统，数据库等课程也让我印象深刻。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就这样，每天我都把自己的时间填满，愣是在研一上学期看了好几本书，当时书的版本现在有的记不清了，主要是计算机网络，操作系统，计算机组成原理，另外还有软件工程，软件测试，设计模式，等书籍。就这样，我靠着这段时间的坚持把计算机基础课程补上来了一些。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时间来到研一下半页，这时候我刚刚结束了学校的Java Web的项目实训课程，在做这个项目期间，我发现自己暴露出了很多问题，技术实践能力不足，Java基础不扎实。这件事情也给我自己敲响了警钟，因为我计划在春招期间找一份大厂的实习，但是目前看来我的水平还远远不够。&lt;/p&gt;
&lt;p&gt;压力之下，只有努力一条出路。于是，从那时候起，我开始了“留守“实验室的学习生活。为什么要在实验室学习，一是因为学习气氛好，二是因为平时大家也可以互相交流问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每天早上9点到实验室打开电脑，晚上9点背电脑回寝室。大部分时间我会花在看书上，这段时间主要看的都是Java相关的书籍，借鉴的是江南白衣大佬的“Java后端书架”，比如《深入理解JVM虚拟机》，《Java并发编程艺术》，《深入分析Java Web技术内幕》，《深入剖析Spring源码》等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一部分时间我会用来看一些技术博客，我主要是根据面经上的知识点按图索骥，找到对应讲解该知识点的文章，那时候主要还是通过搜索引擎来找文章，当然有时候看到一些重点难点也会自己写一些博客。不过这个时期并不是我大量写博客的阶段，主要还是看一些讲解面试知识点的技术博客为主。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除此之外在面试前几天我会花时间去看这家公司的面经，搞懂每一个面经上的知识点，并且记录在我的笔记上，光是面经相关的笔记我就记了100多篇，这样的学习习惯我一直坚持到了秋招，确保每个面试知识点都能被我记住，消化，直至完全理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;慢慢的，笔记越来越多，我参加面试的公司也越来越多，于是我开始不断完善自己的简历，总结自己的面试技巧，选择合适的网申时机。&lt;strong&gt;从头到尾&lt;/strong&gt;&lt;strong&gt;我大概花了3个月的时间在找实习上，期间大大小小参加了20多次面试，我也从一开始面试一问三不知的菜鸟，逐渐变成了面霸，到复习末期，我对Java常见面试知识点已经了然于胸，同时也越来越自信，不管面什么大厂都不慌不忙。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样的日子持续了好几个月，所谓世上无难事，只怕有心人。到最后，实验室里每个人都拿到了心仪的实习offer。&lt;/p&gt;

&lt;p&gt;踏出学校大门，我的实习之路才刚刚开始。8个月左右的实习时间，说长也长，说短也短。但经历过这段实习之后，我才明白了很多事情。&lt;/p&gt;
&lt;p&gt;在猪场实习的日子里，我第一次了解大公司的开发流程，亲自参与项目代码的开发，我的导师会和我提需求，会指导我怎么做得更好。在这里的成长无疑是非常快速的，但我很快意识到我的问题所在，不熟悉部门技术栈，对很多Java Web的技术原理都不太熟悉，这段时间我意识到了自己的知识深度和广度都可能都有待提高。&lt;/p&gt;
&lt;p&gt;不过由于家里的一些事情。我提前离职了，所以在猪场呆的时间很短，以致于我没来得及搞懂部门项目的技术架构就走了，这也让我在离开以后感觉很遗憾，所以我下定决心在下个实习单位要好好做。&lt;/p&gt;
&lt;p&gt;离开猪场后我来到了熊厂。部门给我提的需求不算太难，大部分都是一些CURD的工作，但是这次很快就意识到了问题所在，就是我不太熟悉部门的整体技术栈，所以在需要借鉴别人代码时偶尔会看不懂。后来部门又给了新的重构需求，此时的我开始焦虑起来，是不是应该做出一些改变呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终于，我找到了新的目标，我要搞懂部门的项目架构，了解相关技术栈（我们部门做的是私有云），一开始，我会请教我的导师，尽量去了解项目的架构设计，除此之外，我还会利用一些时间去看其他同事负责的代码，并且通过一些文档和PPT去了解这些代码的功能和意义。结合代码和文档，再加上和同时的交流，我对部门项目的架构逐渐熟悉起来，为了更好地理解每一块代码的作用，我还为一些模块的代码写了注释。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，光看代码和文档还不能解决所有问题，因为这个项目的重点难点不在Web应用，而是在底层技术，这个项目中包含了两套架构，分别是一套OpenStack集群和一套docker集群。为了学习这两块内容，我先是看了很多博客，然后在平台上跑虚拟机和容器来做实践，最后又看了这方面的一些书籍，主要是《OpenStack设计与实现》，《docker技术入门实战》。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是这还不够，虚拟化技术与Linux内核息息相关，又需要学习者对操作系统和计算网络非常熟悉，我自知这些内容我学得还不够深入，于是我花大量时间看这方面的书，当时也遇到了几本确实不错的书，分别是《深入理解计算机系统》，《计算机网络：自顶向下方法》，还有一本没来得及看完的《Linux内核设计与实现》。虽然以后不一定会作云计算方向的开发，但是学完这些东西我还是非常开心的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到后来，我工位上的书越来越多，我对部门的技术栈也越来越熟悉，有时候我还会去听公司内各个团队组织的技术分享，有空的时候看看内网的技术课程，真正地实现了自己在技术广度上的拓展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有时候我觉得，实习生活是会骗人的，你佩戴着和正式员工一样的工牌，和他们做着类似的事情，会让你觉得你的水平已经和他们差不多了，但事实上是，在转正之前，你和他们还差得远，所以不要停下自己前进的脚步，抓紧时间学习吧，把握好你在公司里的机会，合理利用公司给你提供的资源。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;研究生期间我有一件事情一直在坚持，那就是做笔记和写博客。&lt;/p&gt;
&lt;p&gt;做笔记，就是记录学习中大大小小的事情，可能是面试问题，可能是一周的学习计划，也可能知识一个知识点，总归都是值得记录的东西，对我来说，就是一种积累。而对于博客，我从一开始只用于记录项目，到后来做转载，再到后来写原创，整理系列文章，则更像是一种沉淀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是在春招刚刚结束的这段时间，我发现一个问题，之前学过的东西忘记了很多，特别是那些理解的不够深的知识点，总是特别容易忘记。另外我发现，虽然我在笔记中记录了很多的知识点和面试题，但是往往我只看过一次，不会再去看第二次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这也意味着，虽然记录的内容很多，但是真正消化吸收的内容很少，脑子里充斥着总是那些零碎的知识点和面试问题，对于完整的知识体系知之甚少。这些问题在春招期间也不断地暴露出来，让我思考了很久。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对如此窘境，我想做出改变，趁着现在时间充裕，我想要为这些内容做一次减法，并且借此机会，推翻自己原有的知识体系，重建新的知识框架。简单说来，就是重新开始学习Java后端，这次我要用一种更高效的方式，避免走之前走的弯路，要用最高效，最合理的方式去复习。由于我之前已经有基础，所以我对完成这一目标有信心，相应地我也为此做出了明确且详细的学习计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我打算用几个关键词来形容这三个月的秋招复习。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“具体可靠的学习计划”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在三个月的时间里，我首先按照Java后端路线图安排好复习计划，每个知识点都会对应安排一段时间，比如我可能花一天时间复习“Java反射”，两天时间复习“设计模式”，一周的时间用于复习&quot;JVM虚拟机”。我一般会在月初做好整个月的计划，然后根据进度做一些微调，但是基本上我都可以跟上进度，并且是在复习到位的前提下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以我觉得，对于秋招这一场苦战，指定计划尤为重要，一旦计划定下来，战略目标清晰，对应的战术制定也会变得清晰，执行力也会随之变强。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“写博客整合知识点”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至于复习方法，我主要通过看高质量博客，并且结合代码实践的方式巩固这部分知识点，比如今天学习“concurrenthashmap”，我会去找两三篇比较好的博客先看看，主要是源码解读方面的，然后我会把它们进行整合，如果有遗漏的知识点我会再进行补充，有时候我还会自己去看看JDK源码，以便更好地理解博客内容，完成知识整合之后，我就会对应地整理出一篇博客出来，发在我的个人博客上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外，当我完成了一整个专题的复习之后，我会把这些文章整理成一个专题，比如上面说的“concurrenthashmap”，实际上属于Java并发包，所以我会专门做一个博客专栏，用来完成Java并发系列的文章专题。&lt;strong&gt;对于每一个文章专题，我都会先理清这个专题一共有哪些内容，然后再开始整理。比如对于Java并发包，我会先写Java多线程基础的文章，再写JMM内存模型的文章，接着一步步着手写Java线程池，阻塞队列，工具类，原子类等等。这样一来这部分内容就复习完毕了，写系列文章的好处就在于，我可以从头到尾理清脉络，并且对于每一部分的知识点都做了比较好的总结。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于博客的选择，我吸取了之前的教训，宁愿花半小时看一篇高质量文章，也不花10分钟看5篇烂文章。深度阅读的好处，就是可以让这部分内容更好地融入你脑内的知识体系，而不是像其他快餐文章一样转瞬即逝。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“做项目巩固实践能力”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于之前在实习期间参加的项目都比较大，我接触的模块也比较单一，没有对整体项目有一个很好的把握，所以我决定趁这段时间再巩固一下我的项目实践能力，这里的能力主要是指的是对项目架构的把握能力，以及对业务开发的熟练度，当然也包括对各种常用后端技术的熟悉程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我花了大概一个月的时间完成了两个项目的开发，当然主要也是模仿两个开源项目做了，这两个项目都使用SpringBoot快速开发，并且用到一些常用的后端技术比如redis，云存储，以及一些常见Web框架，除此之外还涉及到了solr，爬虫等技术。虽然项目不算很难，但是我在这段时间里很快地熟悉了完整项目开发的流程，并且每天做迭代，通过Git来跟进版本，每个版本都会写清所做的内容，这也让我对项目的架构非常熟悉。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目之余，我也找一些常用的后端组件来跑一跑demo，以便让我对这些技术有一个直观的了解，比如面试常问的dubbo，zookeeper，消息队列等组件。这些尝试也让我在理解它们的原理时更加得心应手了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“坚持刷题，注重方法”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法题是秋招笔试面试中的重头戏，每个研发同学都免不了经历算法题的摧残，对我这么一个非科班同学来说，更是让人头大。正因为如此，我放弃了刷大量LeetCode题目的方法，选择了更加行之有效的刷题方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先我重新刷了一遍剑指offer，并且对每道题目进行总结，尽量保证每一道题都可以记在脑子里，众所周知剑指offer中的题是面试时非常喜欢考的，所以先搞定这部分题目是最为关键的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搞定剑指offer之后，当然还要刷LeetCode了，LeetCode题目这么多，怎么选择呢，我没有按照tag刷，也没有按照顺序刷，而是参考当时一个大佬的LeetCode刷题指南来进行刷题的，他把每个类型的题目都做了归纳，每部分只放一些比较经典的题目。所以我前后大概刷了100多道LeetCode的题目，并且在第二遍刷题复习的时候，我也对这些题目做了一份总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了上面两个经典题库，我还着重刷了大厂的历年真题，这部分我主要是通过牛客网的历年真题题库来完成刷题的。说实话，真题是非常重要的，因为公司出的题目不像平时的那些算法题，可能会出得非常奇葩，所以你如果不提前适应的话会比较吃亏。完成这部分题目之后，我对算法题的复习也基本告一段落了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我完成所有内容的复习时，提前批已经开始了。终于要上战场了，因为战前准备比较充分，所以我对秋招还是比较乐观的，但事实上，秋招不仅是攻坚战，而且是持久战，要笑到最后，确实也不是那么容易的事情。&lt;/p&gt;

&lt;p&gt;前面提到我在秋招前完成了知识体系重建，那在这里我也想跟大家分享一下我当时大致的知识体系构成。就跟我前面说的一样，我选择重新再学一遍Java后端相关的技术内容，因为我知道大致的学习方向，并且有一定的基础，所以看很多文章变得更加得心应手，写文章和做总结也更加有底气了。&lt;/p&gt;
&lt;p&gt;首先在Java基础方面，我写了20多篇原创博客，主要是对Java核心技术的解析，比如“Java反射”，“Java序列化和反序列化”，“Java异常体系”等等。&lt;/p&gt;
&lt;p&gt;在Java集合类方面，我原创了部分文章，另外整合了一些比较好的技术文章，其中最主要的就是关于hashmap的文章，当时我整合的文章几乎没有遗漏任何一个知识点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java并发编程方面，我主要参考了并发编程网以及一些优质博客的文章，先搞懂了Java并发原理，再一步步学习JUC并发包的组件，其中重点看了chm，并发工具类以及阻塞队列等JDK源码的解析文章，除此之外，我还会在IDE中跑JUC相关的emo，毕竟这方面的内容非常需要实践。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java网络编程方面，我先从最基础的socket入手，再讲到NIO,AIO，并且加入了几篇对Linux IO模型解析的文章，让整个知识体系更加完整（因为NIO是基于Linux Epoll实现的），接着我又加入了对Netty的探讨，以及Tomcat中对NIO的应用，可以说是把Java网络编程一些比较重要的部分都囊括进来了。&lt;strong&gt;为了更好理解这部分内容，我也在网上参考了很多客户端和服务端通信的demo，最后我分别用Socket，NIO,AIO以及Netty把C/S 通信的demo都写了一遍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JVM虚拟机方面，我则按照《深入理解JVM虚拟机》这本书的行文脉络进行文章的整理。&lt;strong&gt;在搞定JVM基本原理以后，我着重了解了JVM调优和实践中常遇到的问题，并且整理了常用的JVM调优工具，场景问题以及调优实践的案例，这也是因为面试中对JVM调优实践越来越重视了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JavaWeb方面，我从Java Web相关技术的发展入手，一步步了解了每种技术存在的意义，比如JSP，Servlet，JDBC，Spring等等，然后对每种技术进行了比较全面的了解，并且着重地看了Spring和SpringMVC的源码分析文章，另外一方面，我花了很多时间去研究Tomcat的工作原理。除此之外，JavaWeb项目中常用的maven，日志组件，甚至是单测试组件，也纳入了我的系列文章里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数据库和缓存方面，我主要学习了MySQL和Redis这两种最常用的数据库。对于Mysql，我从简单的sql开始了解，然后开始了解sql优化，MySQL的存储引擎和索引，事务及锁，还有更复杂的主从复制，分库分表等内容。对于Redis，我也是从简单的api入手，然后去了解每一种数据结构的底层实现原理，接着尝试去学习Redis的持久化方式，以及作为缓存常需要考虑的技术点，当然，也包括Redis的分布式锁实现，以及它的分布式集群方案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一部分就是分布式相关的理论和技术了，这个也是困扰我很久的一块内容，我主要把这块内容分为两个部分，分别是分布式理论和分布式技术，理论方面，我先了解CAP,BASE等基本知识，然后开始学习一致性协议和算法，接着探讨分布式事务。&lt;strong&gt;对于分布式技术，涉及的东西就更多了，例如分布式session，负载均衡，分布式锁等内容，这些知识点我都会用一到两篇文章去总结，对于分布式缓存，消息队列，以及分布式服务等内容，我会花比较多的时间去全面学习，然后总结出一个系列的文章出来。&lt;/strong&gt;当然，对于这些技术的学习主要还是停留在理论方面，在自己的项目中能用到的比较少。&lt;/p&gt;
&lt;p&gt;至此，我的知识体系基本构建完成，这也是我在秋招中能够成功闯过那么多面试的原因。&lt;/p&gt;

&lt;p&gt;不管前期做了多少准备，到秋招的时候也不能掉以轻心，从七月底第一次面试到9月基本佛系，中间经历了大大小小的面试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在完成知识体系重建以后，我把重点转向了另外几件事，一是完善和熟悉我的简历，以便在面试中能够比较好地发挥，二是持续刷题，保持对算法题和笔试真题的手感和熟练度，三则是看面经查缺补漏，我一直认为看面经是很重要的一项复习内容。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就这样，我一边继续复习，以便开始了一场接一场的面试接力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;起初，我面了几家小公司练手，接着阿里的提前批接踵而至，我战战兢兢地参加了阿里中间件部门的面试，面难难度还算适中，一共四轮面试，当时我的表现也还不错，问题基本都答上来了。面完不到一周以后我就收到了通过的消息，当时还有点懵。没想到第一个offer这么快就来了。&lt;/p&gt;
&lt;p&gt;这段时间内，蚂蚁金服的两个部门也给了我面试机会，我都参加了它们的面试，并且顺利地拿到了其中一个部门的offer。由于我对蚂蚁这边的业务比较感兴趣，最终选择了蚂蚁金服的offer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里提前批的胜利确实是意外之喜，但也大大地鼓舞了我，于是我又参加了百度和腾讯的提前批面试，由于百度的提前批不走流程，一共有四个部门面试了我，每个部门都有2到3轮面试，总计约为12次面试，到后来我已经快晕了，看到百度的电话就害怕，由于面试次数太多，有时候发挥确实也不是很好，我也没有特别在意，只当是在锻炼自己了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百度的面试难度每个部门不一样，但是每次面试必写算法题，一写算法题，时间至少就是一个小时以上，每次面试完都有一种身体被掏空的感觉。&lt;/p&gt;
&lt;p&gt;经历了百度面试的摧残以后，我手写算法的速度也变快了，很多坑也被我填上了。接下来面对腾讯的面试，我也是既激动又担心，腾讯的面试难度比较大，对于操作系统和网络的知识喜欢深挖，问的东西也很有深度，面完前三面以后，第四面拖了3周才进行。当时三面面试官对我的评价比较好，也让我信心爆棚了好久。&lt;/p&gt;
&lt;p&gt;在等待腾讯终面的期间，我参加了今日头条的面试，当时有幸拿到了一个白金码，免去笔试，事实证明白金码作用真的很大。头条的面试难度和腾讯差不多，三轮面试，同样需要写各种算法，由于是视频面试，我可以清楚地看到，头条的面试官真的非常高冷啊。面完头条我的第一感觉就是应该挂了吧。没想到最后还是给了offer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结束这几家大厂的面试之后，我觉得我的秋招已经接近尾声了，不过由于之前投的比较多，所以我又面了几家大公司，如网易，华为，快手等。到9月上旬的时候，我接连收到了bat和头条，网易的意向书，阿里最早，腾讯最晚，每收到一封意向书我都很开心，没想到最后我真的可以集齐bat等大厂的offer。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9月以后，除了偶尔和同学做几场大厂的笔试，我基本就佛系了。直到后来一些外企例如亚马逊，大摩开始笔试面试，我才又重新回到了状态。&lt;/p&gt;
&lt;p&gt;截止目前，我基本上把该拒绝的offer都拒绝了，综合各方面因素的考虑，最后应该会签阿里，原因是部门是我自己喜欢的，同时给的评级也比较高。虽然腾讯也给了sp，但是最后还是忍痛割爱啦。至于百度和头条，给的offer并不是很令人满意，所以就没有考虑了。&lt;/p&gt;
&lt;p&gt;至此，我的秋招之旅总算圆满结束。&lt;/p&gt;

&lt;p&gt;具体的面经都比较长，这里大概介绍一下面试的情况，具体的面经请大家关注我的公众号并回复“面经”即可查看。&lt;/p&gt;

&lt;p&gt;1 阿里面经  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=9ec90620478b35d63a4a971a2222095d&amp;amp;chksm=f9e5b29dce923b8b2b080151e4b6b78373ee3f3e6f75b69252fc00b1a009d85c6f96944ed6e6&amp;amp;scene=21#wechat_redirect&quot;&gt;阿里中间件研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483861&amp;amp;idx=1&amp;amp;sn=34317917908fdb778f16fa9dd557908b&amp;amp;chksm=f9e5b284ce923b922446fb5431b84094dec03ee4688da9c8de1f025d80eac715cbd9740e8464&amp;amp;scene=21#wechat_redirect&quot;&gt;蚂蚁金服研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是研发工程师，直接找蚂蚁金服的大佬进行内推。&lt;/p&gt;
&lt;p&gt;我参与了阿里巴巴中间件部门的提前批面试，一共经历了四次面试，拿到了口头offer。&lt;/p&gt;
&lt;p&gt;然后我也参加了蚂蚁金服中间件部门的面试，经历了三次面试，但是没有走流程，所以面试中止了。&lt;/p&gt;
&lt;p&gt;最后我走的是蚂蚁金服财富事业群的流程，经历了四次面试，包括一次交叉面，最终拿到了蚂蚁金服的意向书，评级为A。&lt;/p&gt;
&lt;p&gt;阿里的面试体验还是比较好的，至少不要求手写算法，但是非常注重Java基础，中间件部门还会特别安排Java基础笔试。&lt;/p&gt;

&lt;p&gt;2 腾讯面经  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483849&amp;amp;idx=1&amp;amp;sn=f81fd42954589fb2deaf128026ddd856&amp;amp;chksm=f9e5b298ce923b8ef02ae36f7e9029fef0ddb7d5ae456dfa9d64c0073bebaacfb78fac4c8035&amp;amp;scene=21#wechat_redirect&quot;&gt;腾讯研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是后台开发工程师，我没有选择意向事业群。&lt;/p&gt;
&lt;p&gt;SNG的部门捞了我的简历，开始了面试，他们的技术栈主要是Java，所以比较有的聊。&lt;/p&gt;
&lt;p&gt;一共经历了四次技术面试和一次HR面试，目前正在等待结果。&lt;/p&gt;
&lt;p&gt;腾讯的面试一如既往地注重考查网络和操作系统，并且喜欢问Linux底层的一些知识，在这方面我还是有很多不足的。&lt;/p&gt;

&lt;p&gt;3 百度面经  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483857&amp;amp;idx=1&amp;amp;sn=214b0f93db93407a7ac5a5149778cbad&amp;amp;chksm=f9e5b280ce923b96fcd535b2ef639fee2de78f12aa961d525b21760b11a3b95c0879113c2944&amp;amp;scene=21#wechat_redirect&quot;&gt;百度研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483866&amp;amp;idx=1&amp;amp;sn=88dc80fef6ad6aa3a4221862f3630a90&amp;amp;chksm=f9e5b28bce923b9d4defc91ed30d8bbe650d7215966f9fb776fe5b244eae527bcd24b1941204&amp;amp;scene=21#wechat_redirect&quot;&gt;百度研发面经整合版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是研发工程师岗位，部门包括百度智能云的三个分部门以及大搜索部门。&lt;/p&gt;
&lt;p&gt;百度的提前批面试不走流程，所以可以同时面试好多个部门，所以我参加百度面试的次数大概有12次左右，最终应该是拿了两个部门的offer。&lt;/p&gt;
&lt;p&gt;百度的面试风格非常统一，每次面试基本都要到电脑上写算法，所以那段时间写算法写的头皮发麻。&lt;/p&gt;

&lt;p&gt;4 网易面经  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483875&amp;amp;idx=1&amp;amp;sn=fa9eaedd9cc3da172ad71d360c46a054&amp;amp;chksm=f9e5b2b2ce923ba443b91d56b24486d22b15bea16a4788e5ed3421906e84f8edd9ee10b2b306&amp;amp;scene=21#wechat_redirect&quot;&gt;网易研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面试部门是网易云音乐，岗位是Java开发工程师。&lt;/p&gt;
&lt;p&gt;网易是唯一一家我去外地面试的公司，也是我最早去实习的老东家。&lt;/p&gt;
&lt;p&gt;一共三轮面试，耗时一个下午。&lt;/p&gt;
&lt;p&gt;网易的面试比我想象中的要难，面试官会问的问题都比较深，并且会让你写一些结合实践的代码。&lt;/p&gt;

&lt;p&gt;5 头条面经  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247483869&amp;amp;idx=1&amp;amp;sn=eedb7aebcb90cf3d4fe2450ef2d99947&amp;amp;chksm=f9e5b28cce923b9a9b0852a1c998ec014eb1aeb0442916c9028da276be8db0b2934c92292961&amp;amp;scene=21#wechat_redirect&quot;&gt;今日头条研发面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;岗位是后台研发工程师，地点选择了上海。&lt;/p&gt;
&lt;p&gt;我参加的是字节跳动的内推面试，当时找了一个牛友要到了白金码，再次感谢这位头条大佬。&lt;/p&gt;
&lt;p&gt;然后就开始了一下午的视频面试，一共三轮技术面试，每一轮都要写代码，问问题的风格有点像腾讯，也喜欢问一些底层知识，让我有点懵逼。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更多面经请点击阅读原文进行查看。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;提前批的笔试其实不是很多，我参加了网易，网易游戏，拼多多等公司的笔试，应该都是低分飘过。&lt;/p&gt;

&lt;p&gt;我的算法基础比较一般，读研之前0基础，所以这方面学的比较艰辛，分享一些我的笔试准备经验。&lt;/p&gt;

&lt;p&gt;1 打好数据结构和算法基础&lt;/p&gt;
&lt;p&gt;2 先易后难，看一些基础的算法书籍，比如《图结算法》，《啊哈算法》等等。&lt;/p&gt;
&lt;p&gt;3 剑指offer刷起来，两到三遍，做到胸有成竹&lt;/p&gt;
&lt;p&gt;4 LeetCode刷个200题左右，记得二刷，做好总结。&lt;/p&gt;
&lt;p&gt;5 到牛客网做公司的历年真题，熟悉题型，保持手感。&lt;/p&gt;

&lt;p&gt;剑指offer指南和LeetCode刷题指南可以在我的博客里找到。 &lt;/p&gt;

&lt;p&gt;其中LeetCode指南是参考@CyC2018大佬的文章。&lt;/p&gt;


&lt;p&gt;面试主要考的还是你的基础知识，需要你对Java后端技术栈有一个全局上的把握，具体说起来就太多了，具体复习方案可以参考文章后面的内容。&lt;/p&gt;

&lt;p&gt;我个人也总结了一些面试方面的经验，主要是一些技巧。&lt;/p&gt;

&lt;p&gt;1 做好自我介绍和项目总结，把握你发言的主动权&lt;/p&gt;
&lt;p&gt;2 搞清楚简历上的技术点，兵来将挡水来土掩&lt;/p&gt;
&lt;p&gt;3 注意分点答题，思路清晰，也更容易讲清楚原理。&lt;/p&gt;
&lt;p&gt;4 压力面下保持冷静，不要回怼面试官&lt;/p&gt;
&lt;p&gt;5 HR面试注意常用技巧，可以提前准备。&lt;/p&gt;

&lt;p&gt;Java后端技术专栏&lt;/p&gt;
&lt;p&gt;对于校园招聘来说，最重要的还是基础知识。下面的博客专栏出自我的技术博客 https://blog.csdn.net/a724888    &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;这些专栏中有一些文章是我自己原创的，也有一些文章是转载自技术大牛的，基本都是是我在学习Java后端的两年时间内陆续完成的。&lt;/p&gt;
&lt;p&gt;总的来说算是比较全面了，做后端方向的同学可以参考一下。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;深入浅出Java核心技术    &lt;/p&gt;

&lt;p&gt;本专栏主要介绍Java基础，并且会结合实现原理以及具体实例来讲解。同时还介绍了Java集合类，设计模式以及Java8的相关知识。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;深入理解JVM虚拟机    &lt;/p&gt;

&lt;p&gt;带你走进JVM的世界，整合高质量文章以阐述虚拟机的原理及相关技术，让开发者更好地了解Java的底层运行原理以及相应的调优方法。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;Java并发指南    &lt;/p&gt;

&lt;p&gt;本专栏主要介绍Java并发编程相关的基本原理以及进阶知识。主要包括Java多线程基础，Java并发编程基本原理以及JUC并发包的使用和源码解析。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;Java网络编程与NIO    &lt;/p&gt;

&lt;p&gt;Java网络编程一直是很重要的一部分内容，其中涉及了socket的使用，以及Java网络编程的IO模型，譬如BIO,NIO,AIO，当然也包括Linux的网络编程模型。&lt;/p&gt;

&lt;p&gt;了解这部分知识对于理解网络编程有很多帮助。另外还补充了两个涉及NIO的重要技术：Tomcat和Netty。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;JavaWeb技术世界    &lt;/p&gt;

&lt;p&gt;从这里开始打开去往JavaWeb世界的大门。什么是J2EE，什么是JavaWeb，以及这个生态中常用的一些技术：Maven，Spring，Tomcat，Junit，log4j等等。&lt;/p&gt;

&lt;p&gt;我们不仅要了解怎么使用它们，更要去了解它们为什么出现，其中一些技术的实现原理是什么。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;Spring与SpringMVC源码解析    &lt;/p&gt;

&lt;p&gt;本专栏主要讲解Spring和SpringMVC的实现原理。&lt;/p&gt;

&lt;p&gt;Spring是最流行的Java框架之一。&lt;/p&gt;

&lt;p&gt;本专栏文章主要包括IOC的实现原理分析，AOP的实现原理分析，事务的实现源码分析等，当然也有SpringMVC的源码解析文章。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;重新学习MySQL与Redis    &lt;/p&gt;

&lt;p&gt;本专栏介绍MySQL的基本知识，比如基本架构，存储引擎，索引原理，主从复制，事务等内容。当然也会讲解一些和sql语句优化有关的知识。&lt;/p&gt;

&lt;p&gt;同时本专栏里也介绍了Redis的基本实现原理，包括数据结构，主从复制，集群方案，分布式锁等实现。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;分布式系统理论与实践    &lt;/p&gt;

&lt;p&gt;本专栏介绍分布式的基本理论和相关技术，比如CAP和BASE理论，一致性算法，以及ZooKeeper这类的分布式协调服务。&lt;/p&gt;

&lt;p&gt;在分布式实践方面，我们会讲到负载均衡，缓存，分布式事务，分布式锁，以及Dubbo这样的微服务，也包括消息队列，数据库中间件等等。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;后端开技术杂谈    &lt;/p&gt;

&lt;p&gt;本专栏涵盖了大后端的众多技术文章，当你在Java后端方面有一定基础以后，再多了解一些相关技术总是有好处的。&lt;/p&gt;

&lt;p&gt;除了Java后端的文章以外，还会涉及Hadoop生态，云计算技术，搜索引擎，甚至包括一些数据挖掘和AI的文章。&lt;/p&gt;
&lt;p&gt;总的来说选取了一些不错的基础类文章，能让你对大后端有一个更直观的认识。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;Java工程师必备书单&lt;/p&gt;

&lt;p&gt;我之前专门写了一篇文章介绍了Java工程师的书单，可以这里重点列举一些好书，推荐给大家。&lt;/p&gt;


&lt;p&gt;完整内容可以参考这篇文章：&lt;/p&gt;

&lt;p&gt;《计算机网络：自顶向下》这本从应用层讲到物理层，感觉这种方式学起来更轻松。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《图解算法》《啊哈算法》&lt;/p&gt;
&lt;p&gt;这两部书籍非常适合学习算法的入门，前者主要用图解的形式覆盖了大部分常用算法，包括dp，贪心等等，可以作为入门书，后者则把很多常用算法都进行了实现，包括搜索，图，树等一些比较高级的常用算法。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《剑指offer》这本书还是要强烈推荐的，毕竟是面试题经常参考的书籍，当然最好有前面基本的铺垫再看，可能收获更大，这本书在面试之前一般都要嚼烂。如果想看Java版本的代码，可以到我的Github仓库中查看。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《Java编程思想》这本书也是被誉为Java神书的存在了，但是对新手不友好，适合有些基础再看，当然要选择性地看。我当时大概只看了1/3&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《Java核心技术卷一》&lt;/p&gt;
&lt;p&gt;这本书还是比较适合入门的，当然，这种厚皮书要看完还是很有难度的，不过比起上面那本要简单一些&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《深入理解JVM虚拟机》    &lt;/p&gt;
&lt;p&gt;这本书是Java开发者必须看的书，很多jvm的文章都是提取这本书的内容。JVM是Java虚拟机，赋予了Java程序生命，所以好好看看把，我自己就已经看了三遍了。    &lt;/p&gt;


&lt;p&gt;《Java并发编程艺术》&lt;/p&gt;
&lt;p&gt;这本书是国内作者写的Java并发书籍，比上面那一本更简单易懂，适合作为并发编程的入门书籍，当然，学习并发原理之前，还是先把Java的多线程搞懂吧。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《深入JavaWeb技术内幕》    &lt;/p&gt;
&lt;p&gt;这本书是Java Web的集大成之作，涵盖了大部分Java Web开发的知识点，不过一本书显然无法把所有细节都讲完，但是作为Java Web的入门或者进阶书籍来看的话还是很不错的。   &lt;/p&gt;


&lt;p&gt;《Redis设计与实现》&lt;/p&gt;
&lt;p&gt;该书全面而完整地讲解了 Redis 的内部运行机制,对 Redis 的大多数单机功能以及所有多机功能的实现原理进行了介绍。这本书把Redis的基本原理讲的一清二楚，包括数据结构，持久化，集群等内容，有空应该看看。&lt;/p&gt;


&lt;p&gt;《大型网站技术架构》    &lt;/p&gt;
&lt;p&gt;这本淘宝系技术指南还是非常值得推崇的，可以说是把大型网站的现代架构进行了一次简单的总结，内容涵盖了各方面，主要讲的是概念，很适合没接触过架构的同学入门。看完以后你会觉得后端技术原来这么博大精深。    &lt;/p&gt;

&lt;p&gt;《分布式服务框架原理与实践》&lt;/p&gt;
&lt;p&gt;上面那本书讲的是分布式架构的实践，而这本书更专注于分布式服务的原理讲解和对应实践，很好地讲述了分布式服务的基本概念，相关技术，以及解决方案等，对于想要学习分布式服务框架的同学来说是本好书。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;p&gt;说起分布式系统，我们需要了解它的原理，相关理论及技术，这本书也是从这个角度出发，讲解了分布式系统的一些常用概念，并且带出了分布式一哥zookeeper，可以说是想学分布式技术的同学必看的书籍。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;《大数据技术原理与应用》&lt;/p&gt;
&lt;p&gt;作为大数据方面的一本教材，厦大教授写的这本书还是非常赞的，从最基础的原理方面讲解了Hadoop的生态系统，并且把每个组件的原理都讲得比较清楚，另外也加入了spark，storm等内容，可以说是大数据入门非常好的一本书了。&lt;/p&gt;


&lt;p&gt;1 江南白衣&lt;/p&gt;

&lt;p&gt;这位大大绝对是我的Java启蒙导师，他推荐的Java后端书架让我受益匪浅。    &lt;/p&gt;

&lt;p&gt;2 码农翻身    &lt;/p&gt;

&lt;p&gt;刘欣，一位工作15年的IBM架构师，用最浅显易懂的文章讲解技术的那些事，力荐，他的文章帮我解决了很多困惑。    &lt;/p&gt;

&lt;p&gt;3 CoolShell&lt;/p&gt;

&lt;p&gt;陈皓老师的博客相信大家都看过，干货很多，酷壳应该算是国内最有影响力的个人博客了。&lt;/p&gt;

&lt;p&gt;4 廖雪峰&lt;/p&gt;

&lt;p&gt;学习Git和Python，看它的博客就够了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 HollisChuang&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阿里一位研发大佬的博客，主要分享Java技术文章，内容还不错。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    &lt;/p&gt;
&lt;p&gt;6 梁桂钊&lt;/p&gt;

&lt;p&gt;阿里另一位研发大佬，博客里的后端技术文章非常丰富。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7 chenssy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这位大佬分享的Java技术文章也很多，并且有很多基础方面的文章，新手可以多看看。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;8 Java Doop&lt;/p&gt;

&lt;p&gt;一位魔都Java开发者的技术博客，里面有一些不错的讲解源码的文章，数量不是很多，但是质量都挺不错的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;学习资源分享&lt;/p&gt;

&lt;p&gt;学习Java后端两年的时间里，接触过很多的资料，网站和课程，也走了不少弯路，所以这里也总结一些比较好的资源推荐给大家。&lt;/p&gt;


&lt;p&gt;0 CSDN和博客园，主流的技术交流平台，虽然广告越打越多了，但是还是有很多不错的博文的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;1 importnew 专注Java学习资源分享，适合Java初学者。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;2 并发编程网，主要分享Java相关进阶内容，适合Java提高。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;3 推酷 一个不错的技术分享社区。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;4 segmentfault，有点像国内的Stack Overflow，适合交流代码问题的地方。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;5 掘金，一个很有极客范的技术社区，强推，有很多技术大牛分享优质文章。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;6 开发者头条，一个整合优质技术博客的社区，里面基本上都是精选的高质量博文，适合技术学习提升。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;7 v2ex，一个极客社区，除了交流技术以外还会有很多和程序员生活相关的话题分享。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;8 知乎&lt;/p&gt;
&lt;p&gt;这个就不必多说了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;9 简书&lt;/p&gt;
&lt;p&gt;简书上有些技术文章也很不错，有空大家也可以去看看。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;p&gt;10 Github&lt;/p&gt;
&lt;p&gt;有一些GitHub的项目还是非常不错的，其中也有仓库会分享技术文章。&lt;/p&gt;

&lt;p&gt;秋招结束以后，我就把主要精力花在做这个公众号上了。当然，剩下要处理的事情还有很多，毕业论文，毕业旅行，还有工作前的知识储备等等。果然，人的一生需要不断的修行，刚刚闯过了一关又马上要迎接下一轮挑战，你不能停下脚步，毕竟大家都在往前走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;希望还在求职路上的各位少侠好好加油，在未来也能够顺利地拿到自己想要的offer！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文中涉及到的几个链接我汇总在这里，方便大家查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、CSDN技术博客：blog.csdn.net/a724888（Java后端技术站点，整理很多Java后端技术文章，推荐Java方向的同学看看）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、知乎：www.zhihu.com/people/h2pl（知乎活跃用户，希望未来能成为大V）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、牛客网：www.nowcoder.com/profile/3539721（牛客网活跃粉，分享过一些面经和心得）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、GitHub：https://github.com/h2pl（用于自己做项目，以及刷剑指offer、LeetCode、历年笔试题）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当然，记得要关注一下公众号【程序员江湖】，有很多校招和学习干货在这里等你发掘，特别是正在准备校园招聘的各位同学，一定不要错过了哈。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XHh0SksQZPN3n6EH5yAfZtDse8NMYWLeF7N5wO16yk6myj8jSiacA3rBQzYr3V1iaRJOfjXk8wS5E21fxcjTtYXA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-type=&quot;jpeg&quot; data-w=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;p data-css=&quot;color:#ff7827;font-size:18px;margin:0px;padding:0px 10px&quot;&gt;往期精彩回顾&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XHh0SksQZPN3n6EH5yAfZtDse8NMYWLersxMoqq15libPETcBNQfotw8w97jvtO4fmsNPWldCibXzXB5DYMtkVvQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-type=&quot;jpeg&quot; data-w=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247484406&amp;amp;idx=1&amp;amp;sn=815f86b3517ae0f200c9169fa7d20a26&amp;amp;chksm=f9e5b0a7ce9239b1d190e3188dfb44e72750cdf8465a8eafe0f059aae49126f7bfec06076d6e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;限时免费 | 程序员校招指南（BAT校招老司机出品）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247484181&amp;amp;idx=1&amp;amp;sn=8095b84728bae8df57f9a08445fb4875&amp;amp;chksm=f9e5b044ce923952e3923da2a9bfbdcee06264dcb64a6f955742107394cedb0c4fbe0fec4237&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;从零基础到拿到网易Java实习offer，我做对了哪些事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247484463&amp;amp;idx=1&amp;amp;sn=6d3056823970b1f3b0b6fe4e99290eb0&amp;amp;chksm=f9e5b77ece923e68308cd3f6e34fbc83c03c6e9df21cb1393b4cf786245fc6add4743e760c09&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;校招前几个月，如何高效地进行复习？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247484486&amp;amp;idx=1&amp;amp;sn=c84460e12e82fdcf1157c6dd0375c6e6&amp;amp;chksm=f9e5b717ce923e0190cc4baf3bcfea83794d261fa3f56159916a1c0c9d42d7b6178273cfd3a1&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;刷完500道BAT面试题，我能去面试大厂了吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMDc5MTYxNA==&amp;amp;mid=2247484285&amp;amp;idx=1&amp;amp;sn=6e1217e12038017ab9e911d221d06359&amp;amp;chksm=f9e5b02cce92393a55406d3daa568e7e9b81b514cb510ad7cd0ed8b9930c68a919e1ecb4504c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2017春招实习面试回顾：从面试连跪到收割offer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XHh0SksQZPPC4gR8FiayqQzoiaiaMrT7LDTolWkgFOa8BibEf41Bp9LuZeW83amu9WIGaCXLvFH1u0Zqjkl1lUopXw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　分享你最关心的技术、求职、学习和成长那些事&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 06:52:00 +0000</pubDate>
<dc:creator>How_2_Play_Life</dc:creator>
<og:description>点击关注并置顶，江湖要事早提醒 点击关注并指定，江湖要事早知道 我 常想，人生最有趣莫过于前路未知。于是我常常羡慕那些个“金梁古温”笔下随遇而安、随性而为、随缘而爱的浪子们。比如陆小凤，比如叶开。 写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10102179.html</dc:identifier>
</item>
<item>
<title>(2/24) 快速上手一个webpack的demo - 吴封斌技术博客</title>
<link>http://www.cnblogs.com/wfaceboss/p/10101235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfaceboss/p/10101235.html</guid>
<description>&lt;p&gt;写在前面：该部分的安装都是基于windows系统的，且此处的webpack的版本为：3.6.0。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.安装webpack&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1 安装方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用win+R打开运行对话框，输入cmd进入命令行模式。然后找到你想开始项目的地方，输入下方代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir webpack3&lt;br/&gt;cd webpack3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一句是建立一个文件夹，第二句是进入这个文件夹。这个文件夹就是我们的项目文件目录了，文件夹建立好后，可以通过下面命令安装webpack。&lt;/p&gt;
&lt;p&gt;需要注意的是,你在执行下一步时必须安装node，可以通过 node -v来查看node安装情况和版本，如果没有安装，要先安装node才可以继续进行。&lt;a href=&quot;https://www.cnblogs.com/zhouyu2017/p/6485265.html&quot; target=&quot;_blank&quot;&gt;戳此查看安装node.js&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局安装---主要命令行需要&lt;/span&gt;
npm install -g webpack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你这时安装失败了（出现了报错信息），一般有三种可能：&lt;/p&gt;
&lt;ul readability=&quot;-0.9465811965812&quot;&gt;&lt;li&gt;检查你node的版本号，如果版本号过低，升级为最新版本。&lt;/li&gt;
&lt;li&gt;网络问题，可以考虑使用cnpm来安装（这个是淘宝实时更新的镜像）,具体可以登录cnpm的官方网站学习&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;http://npm.taobao.org/。&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;权限问题，在Liux、Mac安装是需要权限，如果你是Windows系统，主要要使用以管理员方式安装。
&lt;p&gt;&lt;span&gt;解决方法： windows  使用win+x,选择命令提示符（管理员），在里面运行命令就好了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.2 项目目录的安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局安装完成后，我们还要进行一个项目目录的安装。在用npm安装前，我们先要进行一下初始化，初始化的主要目的是生成package.json文件（包含了各种模块信息..）&lt;/p&gt;
&lt;p&gt;a.初始化&lt;/p&gt;
&lt;p&gt;在命令行输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm  init -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-y:表示package.json中的信息按默认配置即可。&lt;/p&gt;
&lt;p&gt;b.项目目录的安装&lt;/p&gt;
&lt;p&gt;输入下面命令进行项目目录的安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
//开发环境需要&lt;br/&gt;npm install --save-dev webpack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的参数–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发环境：在开发时需要的环境，这里指在开发时需要依赖的包。&lt;/li&gt;
&lt;li&gt;生产环境：程序开发完成，开始运行后的环境，这里指要使项目运行，所需要的依赖包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;--save-dev:意思是将模块安装到该项目目录下，并在package文件的devDependencies节点写入依赖。&lt;/p&gt;
&lt;p&gt;到此我们的webpack就安装好了，如果我们想查看一下当前安装的webpack版本，我们可以输入以下命令进行查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
webpack  -v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我现在的版本是3.6.0版本，看到了版本号说明安装成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181211120208712-34893983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.项目结构建立&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1 建立文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在根目录下建立两个文件夹，分别是src文件夹和dist文件夹：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;src文件夹：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。&lt;/li&gt;
&lt;li&gt;dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也可以理解成src是源码文件,用于开发环境，dist是我们编译打包好的文件，用于生产环境；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 编写程序文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件夹建立好后，我们在dist文件下手动建立一个index.html文件，并写入下面的代码。&lt;/p&gt;
&lt;p&gt;/dist/index.html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;webpack study&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;title&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;./bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里引入了一个JavaScript的bundle.js文件。这个文件现在还没有，这是用webpack执行打包命令后生产的文件。我们的index.html写好后，接下来在src文件夹下建立entery.js的文件，用于编写我们的JavaScript代码，也是我们的入口文件。&lt;/p&gt;
&lt;p&gt;src/entery.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
document.getElementById('title').innerHTML='Hello Webpack';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.3 使用webpack打包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在webstorm终端中执行下面命令行，即可完成本次打包。使用方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
webpack {entry file} {destination &lt;span&gt;for&lt;/span&gt; bundled file}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;{entery file}:入口文件的路径，本文中就是src/entery.js的路径；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;{destination for bundled file}:填写打包后存放的路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注意：在命令行中是不需要写{ }的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本次使用的命令行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
webpack src/entry.js  dist/bundle.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终结果为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181211143450281-671597647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4 安装live-server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;live-server是一个具有实时重载功能的小型开发服务器。用它来热加载HTML / JavaScript / CSS文件，但不能用于部署最终的网站系统.&lt;/p&gt;
&lt;p&gt;能给进行到该步，说明node.js是已经安装了的。现在我们全局安装live-server（node.js和npm的依赖）,在webstorm终端进行即可，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g live-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-g：表示全局安装。&lt;/p&gt;
&lt;p&gt;安装成功后，我们在webstorm终端，cd到dist目录下，执行live-server（开启服务器）会自动打开浏览器并执行并渲染dist目录下的index.html文件，命令分别如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
live-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181211144834630-1868972790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181211160004762-115469448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;命令执行成功后，会在dist目录下出现bundle.js文件，这时我们的结果就在浏览器渲染了，网页中显示出了Hello webpack的信息。&lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 06:52:00 +0000</pubDate>
<dc:creator>吴封斌技术博客</dc:creator>
<og:description>写在前面：该部分的安装都是基于windows系统的，且此处的webpack的版本为：3.6.0。 1.安装webpack 1.1 安装方法： 用win+R打开运行对话框，输入cmd进入命令行模式。然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfaceboss/p/10101235.html</dc:identifier>
</item>
<item>
<title>C# 创建、更改Excel命名区域（NamedRange） - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10102185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10102185.html</guid>
<description>&lt;p&gt;创建命名区域是指给选定的某个单元格或多个单元格区域设置名称，目的是方便我们在文件中的其他地方对该单元格区域进行引用能够简化公式引用或者方便数据管理。下面记录了具体的C#示例代码。这里创建命名区域分为了2种情况，分别对应不同的添加方法以及命名区域的引用范围，即：&lt;/p&gt;
&lt;p&gt;1. 全局命名区域（方法：workbook.NameRanges.Add() ）&lt;/p&gt;
&lt;p&gt;2. 局部命名区域（方法：sheet.Names.Add () ）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时&lt;/strong&gt;，对于Excel表格中已有的命名区域，可通过方法进行修改或者删除，包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更改区域名称&lt;/li&gt;
&lt;li&gt;隐藏指定命名区域名称&lt;/li&gt;
&lt;li&gt;删除指定命名区域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;a href=&quot;https://www.e-iceblue.cn/Introduce/Free-Spire-XLS-NET.html&quot; target=&quot;_blank&quot;&gt;Free Spire.XLS for .NET&lt;/a&gt;(免费版)&lt;/p&gt;
&lt;p&gt;注：下载Free Spire.XLS后解压安装，在编辑代码时，注意在程序中添加引用Spire.Xls.dll（如下图）,dll文件在安装路径下的Bin文件夹中获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201812/706090-20181211142041054-1914178961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;【示例1】创建Excel命名区域&lt;/h2&gt;
&lt;p&gt;步骤 1：加载文档，获取工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Workbook类的实例，加载文档&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第1张工作表&lt;/span&gt;
Worksheet sheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2：创建命名区域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义第一个全局命名区域&lt;/span&gt;
INamedRange NamedRange1 = workbook.NameRanges.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第1批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法定义的命名区域，引用时可适用于整个工作簿
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange NamedRange1 = sheet.Names.Add(&quot;第1批次入库量&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法定义的命名区域，引用时仅适用于命名区域所在工作表&lt;/span&gt;
NamedRange1.RefersToRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G3:G7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义第二个全局命名区域&lt;/span&gt;
INamedRange NamedRange2 = workbook.NameRanges.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第2批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange NamedRange2 = sheet.Names.Add(&quot;第2批次入库量&quot;);&lt;/span&gt;
NamedRange2.RefersToRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G8:G12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3： 在公式中引用命名区域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定单元格写入文本&lt;/span&gt;
sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;入库量合计&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在公式中引用命名区域&lt;/span&gt;
sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Formula = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=SUM(第1批次入库量,第2批次入库量)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ExcelVersion.Version2013);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201812/706090-20181211142947462-1829758720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;全部代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_6aa24c7f-d421-413e-93cd-346268d5d118&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6aa24c7f-d421-413e-93cd-346268d5d118&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6aa24c7f-d421-413e-93cd-346268d5d118&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Core;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CreateNamedRange_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Workbook实例&lt;/span&gt;
            Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载Excel文件&lt;/span&gt;
            workbook.LoadFromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第1张工作表&lt;/span&gt;
            Worksheet sheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义第一个全局命名区域&lt;/span&gt;
            INamedRange NamedRange1 = workbook.NameRanges.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第1批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法定义的命名区域，引用时可适用于整个工作簿
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange NamedRange1 = sheet.Names.Add(&quot;第1批次入库量&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法定义的命名区域，引用时仅适用于命名区域所在工作表&lt;/span&gt;
            NamedRange1.RefersToRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G3:G7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义第二个全局命名区域&lt;/span&gt;
            INamedRange NamedRange2 = workbook.NameRanges.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第2批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange NamedRange2 = sheet.Names.Add(&quot;第2批次入库量&quot;);&lt;/span&gt;
            NamedRange2.RefersToRange = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G8:G12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定单元格写入文本&lt;/span&gt;
            sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;入库量合计&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在公式中引用命名区域&lt;/span&gt;
            sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Formula = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=SUM(第1批次入库量,第2批次入库量)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;【示例2】更改Excel命名区域&lt;/h2&gt;
&lt;p&gt;步骤 1：加载文档，获取工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档，加载测试文件&lt;/span&gt;
Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
wb.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一张工作表&lt;/span&gt;
Worksheet sheet = wb.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2：修改命名区域名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表格中的指定命名区域&lt;/span&gt;
INamedRange namedRange = wb.NameRanges.GetByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第1批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适用于全局命名区域(整个工作簿)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange namedRange = sheet.Names.GetByName(&quot;第2批次入库量&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适用于局部命名区域（指定工作表）

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改指定命名区域的名称&lt;/span&gt;
namedRange.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newrange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
namedRange.RefersToRange &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;].Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G3:G7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namedRange.RefersToRange = sheet.Range[&quot;G3:G7&quot;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：设置命名区域名称隐藏/显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
namedRange = wb.NameRanges.GetByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第2批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
namedRange.Visible &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：删除命名区域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wb.NameRanges.Remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RangeName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheet.Names.Remove(&quot;RangeName&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newresult.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FileFormat.Version2010);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201812/706090-20181211144531452-445578003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201812/706090-20181211144553670-775022876.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;全部代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_539d8a15-73b8-4546-a55b-49c8c7a03eb9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_539d8a15-73b8-4546-a55b-49c8c7a03eb9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_539d8a15-73b8-4546-a55b-49c8c7a03eb9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls.Core;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ModifyNameRange_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档，加载测试文件&lt;/span&gt;
            Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            wb.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一张工作表&lt;/span&gt;
            Worksheet sheet = wb.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表格中的指定命名区域&lt;/span&gt;
            INamedRange namedRange = wb.NameRanges.GetByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第1批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适用于全局命名区域(整个工作簿)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;INamedRange namedRange = sheet.Names.GetByName(&quot;第2批次入库量&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适用于局部命名区域（指定工作表）

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改指定命名区域的名称&lt;/span&gt;
            namedRange.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newrange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            namedRange.RefersToRange &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;].Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G3:G7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;namedRange.RefersToRange = sheet.Range[&quot;G3:G7&quot;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定命名区域，并设置区域名称隐藏&lt;/span&gt;
            namedRange = wb.NameRanges.GetByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第2批次入库量&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            namedRange.Visible &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除文档中的指定命名区域的名称&lt;/span&gt;
            wb.NameRanges.Remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RangeName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sheet.Names.Remove(&quot;RangeName&quot;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
            wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newresult.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Version2010);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newresult.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;（本文完）&lt;/p&gt;
&lt;p&gt;如需转载，请注明出处！&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 06:52:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>创建命名区域是指给选定的某个单元格或多个单元格区域设置名称，目的是方便我们在文件中的其他地方对该单元格区域进行引用能够简化公式引用或者方便数据管理。下面记录了具体的C#示例代码。这里创建命名区域分为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10102185.html</dc:identifier>
</item>
<item>
<title>基于Java实现红黑树的基本操作 - rainple</title>
<link>http://www.cnblogs.com/rainple/p/9983786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/9983786.html</guid>
<description>&lt;p&gt;　　首先，在阅读文章之前，我希望读者对二叉树有一定的了解，因为红黑树的本质就是一颗二叉树。所以本篇博客中不在将二叉树的增删查的基本操作了，需要了解的同学可以到我之前写的一篇关于二叉树基本操作的博客：&lt;a href=&quot;https://www.cnblogs.com/rainple/p/9970760.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/rainple/p/9970760.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　有随机数节点组成的二叉树的平均高度为log&lt;sub&gt;n&lt;/sub&gt;，所以正常情况下二叉树查找的时间复杂度为O(log&lt;sub&gt;n&lt;/sub&gt;)。但是，根据二叉树的特性，在最坏的情况下，比如存储的是一个有序的数据的话，那么所以的数据都会形成一条链，此时二叉树的深度为n，时间复杂度为O(n)。红黑树就是为了解决这个问题的，它能够保证在任何情况下树的深度都保持在log&lt;sub&gt;n&lt;/sub&gt;左右，红黑树通过一下约束来完成这个特性：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1、每个节点不是红色就是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、根节点为黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、每个叶子节点都是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、每个红色节点的子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、任意节点，到其任意叶节点的所有路径都包含相同的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　结构如下图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210142649440-501846573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　红黑树的基本操作包括删除和添加。在删除或者添加一个节点的时候就有可能打破原有的红黑树维持的平衡，那么就需要通过着色和旋转的方式来使红黑树重新达到平衡。着色是非常简单的，直接将节点的颜色改变就可以了，多以要理解红黑树，就必须需要懂得如何进行旋转，旋转又分为左旋和右转，两个操作相反的，所以理解了一个旋转的操作就很容易理解另一个旋转了。&lt;/p&gt;
&lt;p&gt;　　左旋：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210144039248-1626248407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如图所示，红色节点为旋转支点，支点往左子树移动即为左旋。左旋之后我们可以看到原支点的位置被原支点的右子节点代替，新支点的左子节点变为了原来为父节点的原支点，新支点的左子节点变为原支点的右子节点，因此左旋操作总共右3个节点，以为旋转前的结构举例，分别为红色节点（原支点），黄色节点（新支点）和L节点。Java代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 左旋
     * @param e 支点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; leftRotate(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点的右子节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; right =&lt;span&gt; e.right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点右子节点的左子节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; rightOfLeft =&lt;span&gt; right.left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新旧支点的替换&lt;/span&gt;
        right.parent =&lt;span&gt; e.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            root &lt;/span&gt;=&lt;span&gt; right;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e ==&lt;span&gt; e.parent.left)
                e.parent.left &lt;/span&gt;=&lt;span&gt; right;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                e.parent.right &lt;/span&gt;=&lt;span&gt; right;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原支点变为新支点的左节点&lt;/span&gt;
        right.left =&lt;span&gt; e;
        e.parent &lt;/span&gt;=&lt;span&gt; right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新支点的左节点变为就支点的右节点&lt;/span&gt;
        e.right =&lt;span&gt; rightOfLeft;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rightOfLeft != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            rightOfLeft.parent &lt;/span&gt;=&lt;span&gt; e;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为在红黑树中每个节点都有一个指针指向自己的父节点，父节点也有指针指向子节点，因为在改动一个节点的时候都需要分别改动当前节点和父节点的指向，结合左旋的示意图，用Java代码实现起来就不会很困难了。&lt;/p&gt;

&lt;p&gt;　　右旋&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210150419344-108855772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　右旋操作和左旋相反的，两者互反。依然是红色作为旋转支点，右旋后黄色节点代替了红色节点原来的位置，黄色节点的右节点旋转后变为红色节点的左节点。Java 代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 右旋
     * @param e 旋转支点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rightRotate(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原支点的左节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; left =&lt;span&gt; e.left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原支点的左节点的右节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; leftOfRight =&lt;span&gt; left.right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新旧支点的替换&lt;/span&gt;
        left.parent =&lt;span&gt; e.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.parent == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点的父节点为根节点的情况&lt;/span&gt;
            root =&lt;span&gt; left;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非跟节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e ==&lt;span&gt; e.parent.left)
                e.parent.left &lt;/span&gt;=&lt;span&gt; left;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                e.parent.right &lt;/span&gt;=&lt;span&gt; left;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原支点变为新支点的右节点&lt;/span&gt;
        left.right =&lt;span&gt; e;
        e.parent &lt;/span&gt;=&lt;span&gt; left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新支点未旋转前的右节点变为转换后的原支点的左节点&lt;/span&gt;
        e.left =&lt;span&gt; leftOfRight;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (leftOfRight != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            leftOfRight.parent &lt;/span&gt;=&lt;span&gt; e;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　添加节点&lt;/p&gt;
&lt;p&gt;　　首先，在进入主题之前我们再来回顾一下红黑树的5个特点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1、每个节点不是红色就是黑色。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、根节点为黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、每个叶子节点都是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、每个红色节点的子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、任意节点，到其任意叶节点的所有路径都包含相同的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　红黑树插入节点与二叉树是一致的，所以每次添加节点肯定是添加到叶子节点上，具体步骤如下：&lt;/p&gt;
&lt;p&gt; 　　第一步：将新节点插入到红黑树中。&lt;/p&gt;
&lt;p&gt;　　第二步：将新节点设置为红色。这里为什么需要设置成红色呢？主要是为了满足特性5，这样在插入节点后就少解决了一个冲突，也就少一点麻烦。插入完成后，我们来看一下还有那些特性是有可能发生冲突的，特性1每个节点不是红色就是黑色的，这明显没有冲突，特性2根节点为黑色，当插入节点为根节点的时候就会有冲突了，这种就很简单了，直接将根节点着色为黑色即可。特性3每个叶子节点都是黑色，这个明显没有冲突。特性4每个红色节点的子节点都是黑色的，这个特性就有可能会冲突，因为在插入新节点的时候我们无法确定新节点的父节点的颜色是黑色的还是红色，如果新节点的父节为黑色，那么就不会有冲突，否则就会违背了特性4。特性5任意节点，到其任意子节点的所有路径都包含相同的黑色节点，因为我们插入的新节点被着色为红色，所以并不会影响到每个路径的黑色节点的数量，因此也不会有冲突。综上所诉，那么在插入新节点的时候，只有特性4有可能发生冲突。&lt;/p&gt;
&lt;p&gt;　　第三步：平衡红黑树，使之成为新的红黑树。&lt;/p&gt;
&lt;p&gt;　　根据第二部得到的结论，我们可以知道只有情况是需要解决冲突的，那就是新节点的父节点为红色的时候违背了特性4。接下来我们将要讨论这个问题，因为在新插入一个节点之前是一颗已经平衡了的红黑树，因此根据特新4，新节点的祖父节点必定为黑色。根据这种情况，我们又可以分为以下四种情况：&lt;/p&gt;
&lt;p&gt;　　情况1：新节点为左节点，叔叔节点为红色；&lt;/p&gt;
&lt;p&gt;　　情况2：新节点为左节点，叔叔节点为黑色；&lt;/p&gt;
&lt;p&gt;　　情况3：新节点为右节点，叔叔节点为红色；&lt;/p&gt;
&lt;p&gt;　　情况4：新节点为右节点，叔叔节点为黑色；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210160618963-759165828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　情况1和情况3的情况是一样的，所以我们可以将这两种情况看作是一种情况，这个情况我们稍后再讨论，然后看一下情况2和情况4，通过左旋就可以转换成情况2。&lt;/p&gt;
&lt;p&gt;　　综上所述，我们可以归结为3中情况：&lt;/p&gt;
&lt;p&gt;　　情况1：叔叔节点是红色节点；&lt;/p&gt;
&lt;p&gt;　　情况2：叔叔节点是黑色节点，新节点为右节点；&lt;/p&gt;
&lt;p&gt;　　情况3：叔叔节点是黑色节点，新节点为左节点；&lt;/p&gt;
&lt;p&gt;　　上面我也有提到，当插入新节点时肯定是属于第一种情况的，然后2、3由1转换而来，在此之前我希望你之前已经了解过递归的原理和思想，把局部看作整体的思想，因为这将有助于下面讨论的理解。下面我们将要继续分析这三种情况，情况1这种情况处理起来比比较简单，只需要将祖父节点变为红色节点，父节点和叔叔节点变为黑色即可，这仅仅只是当整个红黑树只有这几个节点的时候是可以了，但事实并非如此，这仅仅只是达到了局部平衡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210170759723-806606786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图，我们看到已经达到了局部的平衡，但是，我们还会有其他的情况，那就是祖父节点有可能也会有父节点。那么又会有两种情况，1是祖父节点的父节点可能是黑色的，2是可能是红色的，如果黑色那么整个红黑树就达到平衡了。不知道大家根觉到了没有，这两种情况是不是跟新插入一个节点的情况是一致的，是不是又回到了插入新节点的问题了？于是我将局部收到影响的部分画出来，如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210172611490-1312710083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图a就是将情况1从新着色后的部分受影响的节点，当然只是其中的一种情况，此时我们将已经平衡的部分去掉就变成的图b的情况，这种情况是不是很熟悉呢？我们的祖父节点当成新节点，是不是相当于上面讨论的情况1呢？不过与上面讨论的情况不同的是，这里3中可能情况都可能出现，因为叔叔节点有可能为红色或黑色。所以这时候才有可能出现真正的三种情况：&lt;/p&gt;
&lt;p&gt;　　情况1：叔叔节点是红色节点；&lt;/p&gt;
&lt;p&gt;　　情况2：叔叔节点是黑色节点，新节点为右节点；&lt;/p&gt;
&lt;p&gt;　　情况3：叔叔节点是黑色节点，新节点为左节点；&lt;/p&gt;
&lt;p&gt;　　如果为情况1的话，我们一层一层的往上平衡就可以了，当祖父节点为根节点的时候，我们直接将根节点着色为黑色即可，因为祖父节点的两个子节点都是黑色的，所以变为黑色后仍然是平衡的。接下来我们来讨论下情况2和3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210223320449-841633561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　很明显的，这两种情况的右节点多出了一个黑色节点，这种情况是在情况1向上着色的时候造成的，即祖父节点由黑色节点变为了红色节点。情况2以父节点为支点左旋，然后将父节点和新节点互换可以得到情况3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210175508563-1229872471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　情况3进行的操作是，首先将父节点着色为黑色，祖父节点着色为红色，然后以祖父为支点进行右旋&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210232028039-1550412310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　情况3旋转结束后整棵红黑也已经重新恢复平衡了。单从部分其实并看不出已经平衡了，我们可以将三个情况连起来就可以看到了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181210231608064-323437792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中都是以n节点为参考点的，其余无关的节点就不标出来了。n节点即为插入节点，但是除了第一次操作n节点为真正的新节点，此后的操作所指的n节点只是有助于我们的理解把他当成新节点。当然，这只是其中的一种情况，其他其他的情况可以通过不断向上旋转或着色，最终也会达到这种情况或者顶部是p节点为根节点的时候，第二种情况直接将根节点着色为黑色即可。&lt;/p&gt;
&lt;p&gt;　　总结：&lt;/p&gt;
&lt;p&gt;　　回顾一下红黑树的5个特性：&lt;/p&gt;
&lt;p&gt;　　1、节点不是红色就是黑色。&lt;/p&gt;
&lt;p&gt;　　2、根节点为黑色。&lt;/p&gt;
&lt;p&gt;　　3、叶子节点为黑色。&lt;/p&gt;
&lt;p&gt;　　4、每个红色节点其子节点必须是黑色节点。&lt;/p&gt;
&lt;p&gt;　　5、任意节点到到其任意的子节点的所有路径的黑色节点的数量相等。&lt;/p&gt;
&lt;p&gt;　　在插入新节点的时候很显然，不会违背1和3，如果插入的是根节点直接将根节点着色为黑色即可，这种情况可以忽略不计，所以插入节点时可能会违背了4和5，又因为插入的是红色节点因此5也不会违背，最后在插入新节点的时候我们只需要关注特性4就可以了。当父节点为红色的时候跟4有冲突，所以我们接下来讨论的就是这种情况。我们知道，在插入新节点之前整颗红黑树是平衡的，因此可以得出一个结论就是祖父节点肯定肯定是黑色的。我们现在只关注相关的节点即可，目前，我们知道了祖父的节点为黑色，父节点为红色，但是叔叔节点的颜色不知道，新节点的位置也不能确定，所以有2x2中情况，当叔叔节点为红色的时候，两种情况的处理方式是一致的，所以最后我们可以总结为3中情况：&lt;/p&gt;
&lt;p&gt;　　1、叔叔节点为红色&lt;/p&gt;
&lt;p&gt;　　2、新节点为右节点，叔叔节点为黑色&lt;/p&gt;
&lt;p&gt;　　3、新节点为左节点，叔叔节点为黑色&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;步骤&lt;/td&gt;
&lt;td&gt;示意图&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;情况1&lt;/td&gt;
&lt;td&gt;叔叔节点为红色&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;1、父节点设为黑色&lt;/p&gt;
&lt;p&gt;2、叔叔节点设为黑色&lt;/p&gt;
&lt;p&gt;3、祖父节点设为红色&lt;/p&gt;
&lt;p&gt;4、把祖父节点设置为新节点（当前节点）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211094814784-395228034.png&quot; alt=&quot;&quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;情况2&lt;/td&gt;
&lt;td&gt;新节点为右节点，叔叔节点为黑色&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;1、以父节点为支点左旋&lt;/p&gt;
&lt;p&gt;2、父节点和新节点互换位置&lt;/p&gt;
&lt;p&gt;3、把父节点设为当前节点&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211095330399-909895389.png&quot; alt=&quot;&quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;情况3&lt;/td&gt;
&lt;td&gt;新节点为左节点，叔叔节点为黑色&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;1、父节点设为黑色&lt;/p&gt;
&lt;p&gt;2、祖父节点设为红色&lt;/p&gt;
&lt;p&gt;3、以祖父节点为支点右旋&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211095227745-1852792402.png&quot; alt=&quot;&quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td&gt;整合&lt;/td&gt;
&lt;td colspan=&quot;3&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211095524116-901842526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　树a就是表中的情况1，通过着色后直接转换成了情况3，情况3进行着色旋转后达到了平衡，当树b中的叔叔节点为红色的时候与树a一致，循环调用树a的处理方式，直至达到树b的情况或者树a中的祖父节点到达了根节点，这时候将祖父节点设为黑色即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211101553561-259136128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种情况就是由情况1转情况2再转情况3，由情况3重新着色旋转后达到平衡。&lt;/p&gt;
&lt;p&gt;　　需要注意的是：不是每次插入节点都会出现3中情况，有可能只出现了2和3，或者只出现了3一种情况。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　上面是讨论左子树的问题，因为红黑色具有堆成性，因此在处理右子树的时候与处理左子树相反即可。Java代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 插入新节点后平衡红黑树
     * @param e 新节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixAfterInsertion(Entry&amp;lt;K, V&amp;gt;&lt;span&gt; e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新插入节点设置为红色&lt;/span&gt;
&lt;span&gt;        setRed(e);
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p,g,u;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点和祖父节点和叔叔节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; current = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新节点&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 这里通过循环不断向上平衡
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((p = parentOf(current)) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(p)){
            g &lt;/span&gt;= parentOf(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; g.left){
                u &lt;/span&gt;=&lt;span&gt; g.right;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况1：叔叔节点为红色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (u != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(u)){
                    setBlack(p);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为黑色&lt;/span&gt;
                    setBlack(u);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;叔叔节点设为黑色&lt;/span&gt;
                    setRed(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点设为红色&lt;/span&gt;
                    current = g;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把祖父节点设为当前节点
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续向上平衡&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2：当前节点为右节点，叔叔节点为黑色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; p.right){
                    leftRotate(p);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点为支点左旋&lt;/span&gt;
                    Entry&amp;lt;K,V&amp;gt; tmp =&lt;span&gt; p;
                    p &lt;/span&gt;= current;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点和当前节点互换&lt;/span&gt;
                    current = tmp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为当前节点&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3：当前节点为左节点，叔叔节点为黑色&lt;/span&gt;
                setBlack(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为黑色&lt;/span&gt;
                setRed(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点设为红色&lt;/span&gt;
                rightRotate(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点为支点右旋&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相反的操作&lt;/span&gt;
                u =&lt;span&gt; g.left;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (u != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(u)){
                    setBlack(p);
                    setBlack(u);
                    setRed(g);
                    current &lt;/span&gt;=&lt;span&gt; g;
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; p.left){
                    rightRotate(p);
                    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; tmp =&lt;span&gt; p;
                    p &lt;/span&gt;=&lt;span&gt; current;
                    current &lt;/span&gt;=&lt;span&gt; tmp;
                }
                setBlack(p);
                setRed(g);
                leftRotate(g);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后将根节点设置为红色&lt;/span&gt;
&lt;span&gt;        setBlack(root);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　删除节点&lt;/p&gt;
&lt;p&gt;　　在二叉树分析一文中已经说过，删除一个节点的时候有3中情况：&lt;/p&gt;
&lt;p&gt;　　1、删除节点没有子节点&lt;/p&gt;
&lt;p&gt;　　2、删除节点只有一个子节点&lt;/p&gt;
&lt;p&gt;　　3、删除节点有两个子节点&lt;/p&gt;
&lt;p&gt;　　首先，我们逐个来分析每种情况删除节点后对整颗红黑树的平衡性的影响。在删除节点时候红黑树的特性1，2，3肯定不会违背，所以只需要考虑特性4，5即可。&lt;/p&gt;
&lt;p&gt;　　对于情况1，肯定不会违背特性4，如果删除节点为红色，那么对整颗红黑树的平衡性都不会影响，如果是黑色则违背了特性5，我们先将这种情况记录下来，稍后再进一步讨论。&lt;/p&gt;
&lt;p&gt;　　对于情况2，有可能删除的是左子树或右子树，暂且不讨论。如果删除的节点为红色，不影响平衡性，如果删除的是黑色，那么肯定会和特性5有冲突，当删除节点的父节点为红色，子节点为红色是也和特性4有冲突。&lt;/p&gt;
&lt;p&gt;　　对于情况3，其实最后删除的是它的替代节点，根据替代节点的特点，最终其实是回到了1这种情况或者情况2。&lt;/p&gt;
&lt;p&gt;　　总结上面的3种情况可得到一个结论，只有删除节点为黑色时才会破坏红黑树原来的平衡，因在删除节点之前红黑树是出于平衡状态的，删除之后很明显的其兄弟节点分支必然比删除节点的分支多了一个黑色的节点，因此我们只需要改变兄弟节点的颜色即可，我们只讨论左节点，右节点对称。&lt;/p&gt;

&lt;p&gt;　　一、删除节点的兄弟节点是红色&lt;/p&gt;
&lt;p&gt;　　将兄弟节点设为黑色，父节点设为红色，以父节点为支点左旋转，然后将父节点的右节点放到兄弟节点上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211141916258-127107746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　二、兄弟节点是黑色的，兄弟的两个子节点也都是黑色的&lt;/p&gt;
&lt;p&gt;　　兄弟节点设为红色，把父节点设置为新的删除节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211142503486-883455185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　三、兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点是黑色&lt;/p&gt;
&lt;p&gt;　　将兄弟节点的左子节点设为黑色，兄弟节点设为红色，以兄弟节点为支点右旋，把父节点的右节点设置为兄弟节点&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211143232678-1558665166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　四、&lt;span&gt;兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　把兄弟节点的设为父节点的颜色，父节点设为黑色，父节点的右节点设为黑色，父节点为支点左旋&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211143753578-327713294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　删除的Java代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; delEntry;
        delEntry &lt;/span&gt;=&lt;span&gt; getEntry(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt; delEntry.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; delEntry.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                root &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.left ==&lt;span&gt; delEntry){
                    p.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    p.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.right == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有左节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; lc =&lt;span&gt; delEntry.left;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                lc.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                root &lt;/span&gt;=&lt;span&gt; lc;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry ==&lt;span&gt; p.left){
                    p.left &lt;/span&gt;=&lt;span&gt; lc;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    p.right &lt;/span&gt;=&lt;span&gt; lc;
                }
                lc.parent &lt;/span&gt;=&lt;span&gt; p;
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.left == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有右节点&lt;/span&gt;
                Entry&amp;lt;K,V&amp;gt; rc =&lt;span&gt; delEntry.right;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                rc.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                root &lt;/span&gt;=&lt;span&gt; rc;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry ==&lt;span&gt; p.left)
                    p.left &lt;/span&gt;=&lt;span&gt; rc;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    p.right &lt;/span&gt;=&lt;span&gt; rc;
                rc.parent &lt;/span&gt;=&lt;span&gt; p;
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有两个节点,找到后继节点，将值赋给删除节点，然后将后继节点删除掉即可&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; successor = successor(delEntry);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到后继节点&lt;/span&gt;
            boolean color =&lt;span&gt; successor.color;
            V old &lt;/span&gt;=&lt;span&gt; delEntry.value;
            delEntry.value &lt;/span&gt;=&lt;span&gt; successor.value;
            delEntry.key &lt;/span&gt;=&lt;span&gt; successor.key;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.right == successor){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继节点为右子节点，&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (successor.right != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点有右子节点&lt;/span&gt;
                    delEntry.right =&lt;span&gt; successor.right;
                    successor.right.parent &lt;/span&gt;=&lt;span&gt; delEntry;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点没有子节点&lt;/span&gt;
                    delEntry.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                successor.parent.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (color ==&lt;span&gt; BLACK)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fixUpAfterRemove(child,parent);&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
        }
        V old &lt;/span&gt;=&lt;span&gt; delEntry.value;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.color == BLACK)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除为黑色时，需要重新平衡树&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (delEntry.right != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点的子节点只有右节点&lt;/span&gt;
&lt;span&gt;                fixUpAfterRemove(delEntry.right,delEntry.parent);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.left != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点只有左节点&lt;/span&gt;
&lt;span&gt;                fixUpAfterRemove(delEntry.left,delEntry.parent);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                fixUpAfterRemove(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,delEntry.parent);
        delEntry.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        delEntry.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        delEntry.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K, V&amp;gt;&lt;span&gt; getEntry(Object key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K, V&amp;gt; delEntry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K, V&amp;gt; current =&lt;span&gt; root;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            Comparable&lt;/span&gt;&amp;lt;K&amp;gt; k = (Comparable&amp;lt;K&amp;gt;&lt;span&gt;) key;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                ret &lt;/span&gt;=&lt;span&gt; k.compareTo(current.key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    delEntry &lt;/span&gt;=&lt;span&gt; current;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (;current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;){
                ret &lt;/span&gt;=&lt;span&gt; comparator.compare(current.key, (K) key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    delEntry &lt;/span&gt;=&lt;span&gt; current;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delEntry;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node表示待修正的节点，即后继节点的子节点（因为后继节点被挪到删除节点的位置去了）&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixUpAfterRemove(Entry&amp;lt;K, V&amp;gt; node,Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; other;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((node == &lt;span&gt;null&lt;/span&gt; || isBlack(node)) &amp;amp;&amp;amp; (node !=&lt;span&gt; root)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parent.left == node) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node是左子节点，下面else与这里的刚好相反&lt;/span&gt;
                other = parent.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node的兄弟节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(isRed(other)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;case1: node的兄弟节点other是红色的&lt;/span&gt;
&lt;span&gt;                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other &lt;/span&gt;=&lt;span&gt; parent.right;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case2: node的兄弟节点other是黑色的，且other的两个子节点也都是黑色的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;((other.left == &lt;span&gt;null&lt;/span&gt; || isBlack(other.left)) &amp;amp;&amp;amp;&lt;span&gt;
                        (other.right &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right))) {
                    setRed(other);
                    node &lt;/span&gt;=&lt;span&gt; parent;
                    parent &lt;/span&gt;=&lt;span&gt; parentOf(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case3: node的兄弟节点other是黑色的，且other的左子节点是红色，右子节点是黑色&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(other.right == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right)) {
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other &lt;/span&gt;=&lt;span&gt; parent.right;
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case4: node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色&lt;/span&gt;
&lt;span&gt;                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与上面的对称&lt;/span&gt;
                other =&lt;span&gt; parent.left;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRed(other)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 1: node的兄弟other是红色的&lt;/span&gt;
&lt;span&gt;                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other &lt;/span&gt;=&lt;span&gt; parent.left;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((other.left==&lt;span&gt;null&lt;/span&gt; || isBlack(other.left)) &amp;amp;&amp;amp;&lt;span&gt;
                        (other.right&lt;/span&gt;==&lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right))) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 2: node的兄弟other是黑色，且other的俩个子节点都是黑色的&lt;/span&gt;
&lt;span&gt;                    setRed(other);
                    node &lt;/span&gt;=&lt;span&gt; parent;
                    parent &lt;/span&gt;=&lt;span&gt; parentOf(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (other.left==&lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.left)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 3: node的兄弟other是黑色的，并且other的左子节点是红色，右子节点为黑色。&lt;/span&gt;
&lt;span&gt;                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other &lt;/span&gt;=&lt;span&gt; parent.left;
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 4: node的兄弟other是黑色的；并且other的左子节点是红色的，右子节点任意颜色&lt;/span&gt;
&lt;span&gt;                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            setBlack(node);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K, V&amp;gt; successor(Entry&amp;lt;K, V&amp;gt;&lt;span&gt; delEntry) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; r = delEntry.right;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;assert r != null;&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (r.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            r &lt;/span&gt;=&lt;span&gt; r.left;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　完整的代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;119&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyTreeMap&amp;lt;K,V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final boolean BLACK = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final boolean RED = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; root;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final Comparator&amp;lt;K&amp;gt;&lt;span&gt; comparator;
    MyTreeMap(){
        comparator &lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyTreeMap(Comparator comparator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key,V value){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            root &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(key,value,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            size&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; current =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key = null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Comparable&lt;/span&gt;&amp;lt;K&amp;gt; k = (Comparable&amp;lt;K&amp;gt;&lt;span&gt;) key;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    p &lt;/span&gt;=&lt;span&gt;current;
                    ret &lt;/span&gt;=&lt;span&gt; k.compareTo(current.key);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        current &lt;/span&gt;=&lt;span&gt; current.left;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        current &lt;/span&gt;=&lt;span&gt; current.right;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        current.value &lt;/span&gt;=&lt;span&gt; value;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current.value;
                    }
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    p &lt;/span&gt;=&lt;span&gt; current;
                    ret &lt;/span&gt;=&lt;span&gt; comparator.compare(key,current.key);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        current &lt;/span&gt;=&lt;span&gt; current.left;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        current &lt;/span&gt;=&lt;span&gt; current.right;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        current.value &lt;/span&gt;=&lt;span&gt; value;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
                    }
                }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(key,value,p);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                p.left &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                p.right &lt;/span&gt;=&lt;span&gt; e;
            size&lt;/span&gt;++&lt;span&gt;;
            fixAfterInsertion(e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 插入新节点后平衡红黑树
     * @param e 新节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixAfterInsertion(Entry&amp;lt;K, V&amp;gt;&lt;span&gt; e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新插入节点设置为红色&lt;/span&gt;
&lt;span&gt;        setRed(e);
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p,g,u;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点和祖父节点和叔叔节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; current = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新节点&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 这里通过循环不断向上平衡
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((p = parentOf(current)) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(p)){
            g &lt;/span&gt;= parentOf(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; g.left){
                u &lt;/span&gt;=&lt;span&gt; g.right;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况1：叔叔节点为红色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (u != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(u)){
                    setBlack(p);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为黑色&lt;/span&gt;
                    setBlack(u);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;叔叔节点设为黑色&lt;/span&gt;
                    setRed(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点设为红色&lt;/span&gt;
                    current = g;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把祖父节点设为当前节点
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续向上平衡&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2：当前节点为右节点，叔叔节点为黑色&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; p.right){
                    leftRotate(p);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点为支点左旋&lt;/span&gt;
                    Entry&amp;lt;K,V&amp;gt; tmp =&lt;span&gt; p;
                    p &lt;/span&gt;= current;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点和当前节点互换&lt;/span&gt;
                    current = tmp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为当前节点&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3：当前节点为左节点，叔叔节点为黑色&lt;/span&gt;
                setBlack(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点设为黑色&lt;/span&gt;
                setRed(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点设为红色&lt;/span&gt;
                rightRotate(g);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;祖父节点为支点右旋&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相反的操作&lt;/span&gt;
                u =&lt;span&gt; g.left;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (u != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; isRed(u)){
                    setBlack(p);
                    setBlack(u);
                    setRed(g);
                    current &lt;/span&gt;=&lt;span&gt; g;
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; p.left){
                    rightRotate(p);
                    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; tmp =&lt;span&gt; p;
                    p &lt;/span&gt;=&lt;span&gt; current;
                    current &lt;/span&gt;=&lt;span&gt; tmp;
                }
                setBlack(p);
                setRed(g);
                leftRotate(g);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后将根节点设置为红色&lt;/span&gt;
&lt;span&gt;        setBlack(root);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean containsKey(Object key){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getEntry(key) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet(){
        Set&lt;/span&gt;&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(size + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        entries(root,list);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; entries(Entry&amp;lt;K,V&amp;gt; e,Set&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; list){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            entries(e.left,list);
            list.add(e);
            entries(e.right,list);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean containsValue(V v){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values().contains(v);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key){
        Entry&lt;/span&gt;&amp;lt;K, V&amp;gt; entry =&lt;span&gt; getEntry(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; entry == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setColor(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e,boolean color){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) e.color =&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRed(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        setColor(e,RED);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBlack(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        setColor(e,BLACK);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setParent(Entry&amp;lt;K,V&amp;gt; e,Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) e.parent =&lt;span&gt; p;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean isBlack(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; colorOf(e) ==&lt;span&gt; BLACK;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean isRed(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !&lt;span&gt;isBlack(e);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; parentOf(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.parent;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean colorOf(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; BLACK : e.color;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 右旋
     * @param e 旋转支点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rightRotate(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原支点的左节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; left =&lt;span&gt; e.left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原支点的左节点的右节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; leftOfRight =&lt;span&gt; left.right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新旧支点的替换&lt;/span&gt;
        left.parent =&lt;span&gt; e.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.parent == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点的父节点为根节点的情况&lt;/span&gt;
            root =&lt;span&gt; left;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非跟节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e ==&lt;span&gt; e.parent.left)
                e.parent.left &lt;/span&gt;=&lt;span&gt; left;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                e.parent.right &lt;/span&gt;=&lt;span&gt; left;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原支点变为新支点的右节点&lt;/span&gt;
        left.right =&lt;span&gt; e;
        e.parent &lt;/span&gt;=&lt;span&gt; left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新支点未旋转前的右节点变为转换后的原支点的左节点&lt;/span&gt;
        e.left =&lt;span&gt; leftOfRight;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (leftOfRight != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            leftOfRight.parent &lt;/span&gt;=&lt;span&gt; e;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 左旋
     * @param e 支点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; leftRotate(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点的右子节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; right =&lt;span&gt; e.right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支点右子节点的左子节点&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; rightOfLeft =&lt;span&gt; right.left;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新旧支点的替换&lt;/span&gt;
        right.parent =&lt;span&gt; e.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            root &lt;/span&gt;=&lt;span&gt; right;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e ==&lt;span&gt; e.parent.left)
                e.parent.left &lt;/span&gt;=&lt;span&gt; right;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                e.parent.right &lt;/span&gt;=&lt;span&gt; right;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原支点变为新支点的左节点&lt;/span&gt;
        right.left =&lt;span&gt; e;
        e.parent &lt;/span&gt;=&lt;span&gt; right;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新支点的左节点变为就支点的右节点&lt;/span&gt;
        e.right =&lt;span&gt; rightOfLeft;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rightOfLeft != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            rightOfLeft.parent &lt;/span&gt;=&lt;span&gt; e;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDeep(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deep(root);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; deep(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; deep = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftDeep =&lt;span&gt; deep(e.left);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightDeep =&lt;span&gt; deep(e.right);
            deep &lt;/span&gt;= leftDeep &amp;gt; rightDeep ? leftDeep + &lt;span&gt;1&lt;/span&gt; : rightDeep + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deep;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; delEntry;
        delEntry &lt;/span&gt;=&lt;span&gt; getEntry(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt; delEntry.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; delEntry.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                root &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.left ==&lt;span&gt; delEntry){
                    p.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    p.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.right == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有左节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; lc =&lt;span&gt; delEntry.left;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                lc.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                root &lt;/span&gt;=&lt;span&gt; lc;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry ==&lt;span&gt; p.left){
                    p.left &lt;/span&gt;=&lt;span&gt; lc;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    p.right &lt;/span&gt;=&lt;span&gt; lc;
                }
                lc.parent &lt;/span&gt;=&lt;span&gt; p;
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.left == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有右节点&lt;/span&gt;
                Entry&amp;lt;K,V&amp;gt; rc =&lt;span&gt; delEntry.right;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                rc.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                root &lt;/span&gt;=&lt;span&gt; rc;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry ==&lt;span&gt; p.left)
                    p.left &lt;/span&gt;=&lt;span&gt; rc;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    p.right &lt;/span&gt;=&lt;span&gt; rc;
                rc.parent &lt;/span&gt;=&lt;span&gt; p;
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有两个节点,找到后继节点，将值赋给删除节点，然后将后继节点删除掉即可&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; successor = successor(delEntry);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到后继节点&lt;/span&gt;
            boolean color =&lt;span&gt; successor.color;
            V old &lt;/span&gt;=&lt;span&gt; delEntry.value;
            delEntry.value &lt;/span&gt;=&lt;span&gt; successor.value;
            delEntry.key &lt;/span&gt;=&lt;span&gt; successor.key;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.right == successor){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继节点为右子节点，&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (successor.right != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点有右子节点&lt;/span&gt;
                    delEntry.right =&lt;span&gt; successor.right;
                    successor.right.parent &lt;/span&gt;=&lt;span&gt; delEntry;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点没有子节点&lt;/span&gt;
                    delEntry.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                successor.parent.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (color ==&lt;span&gt; BLACK)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fixUpAfterRemove(child,parent);&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
        }
        V old &lt;/span&gt;=&lt;span&gt; delEntry.value;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delEntry.color == BLACK)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除为黑色时，需要重新平衡树&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (delEntry.right != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点的子节点只有右节点&lt;/span&gt;
&lt;span&gt;                fixUpAfterRemove(delEntry.right,delEntry.parent);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (delEntry.left != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点只有左节点&lt;/span&gt;
&lt;span&gt;                fixUpAfterRemove(delEntry.left,delEntry.parent);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                fixUpAfterRemove(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,delEntry.parent);
        delEntry.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        delEntry.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        delEntry.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K, V&amp;gt;&lt;span&gt; getEntry(Object key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K, V&amp;gt; delEntry = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Entry&lt;/span&gt;&amp;lt;K, V&amp;gt; current =&lt;span&gt; root;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            Comparable&lt;/span&gt;&amp;lt;K&amp;gt; k = (Comparable&amp;lt;K&amp;gt;&lt;span&gt;) key;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                ret &lt;/span&gt;=&lt;span&gt; k.compareTo(current.key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    delEntry &lt;/span&gt;=&lt;span&gt; current;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (;current != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;){
                ret &lt;/span&gt;=&lt;span&gt; comparator.compare(current.key, (K) key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    current &lt;/span&gt;=&lt;span&gt; current.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    delEntry &lt;/span&gt;=&lt;span&gt; current;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delEntry;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node表示待修正的节点，即后继节点的子节点（因为后继节点被挪到删除节点的位置去了）&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixUpAfterRemove(Entry&amp;lt;K, V&amp;gt; node,Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; other;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((node == &lt;span&gt;null&lt;/span&gt; || isBlack(node)) &amp;amp;&amp;amp; (node !=&lt;span&gt; root)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parent.left == node) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node是左子节点，下面else与这里的刚好相反&lt;/span&gt;
                other = parent.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node的兄弟节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(isRed(other)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;case1: node的兄弟节点other是红色的&lt;/span&gt;
&lt;span&gt;                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other &lt;/span&gt;=&lt;span&gt; parent.right;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case2: node的兄弟节点other是黑色的，且other的两个子节点也都是黑色的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;((other.left == &lt;span&gt;null&lt;/span&gt; || isBlack(other.left)) &amp;amp;&amp;amp;&lt;span&gt;
                        (other.right &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right))) {
                    setRed(other);
                    node &lt;/span&gt;=&lt;span&gt; parent;
                    parent &lt;/span&gt;=&lt;span&gt; parentOf(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case3: node的兄弟节点other是黑色的，且other的左子节点是红色，右子节点是黑色&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(other.right == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right)) {
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other &lt;/span&gt;=&lt;span&gt; parent.right;
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case4: node的兄弟节点other是黑色的，且other的右子节点是红色，左子节点任意颜色&lt;/span&gt;
&lt;span&gt;                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与上面的对称&lt;/span&gt;
                other =&lt;span&gt; parent.left;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRed(other)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 1: node的兄弟other是红色的&lt;/span&gt;
&lt;span&gt;                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other &lt;/span&gt;=&lt;span&gt; parent.left;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((other.left==&lt;span&gt;null&lt;/span&gt; || isBlack(other.left)) &amp;amp;&amp;amp;&lt;span&gt;
                        (other.right&lt;/span&gt;==&lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.right))) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 2: node的兄弟other是黑色，且other的俩个子节点都是黑色的&lt;/span&gt;
&lt;span&gt;                    setRed(other);
                    node &lt;/span&gt;=&lt;span&gt; parent;
                    parent &lt;/span&gt;=&lt;span&gt; parentOf(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (other.left==&lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isBlack(other.left)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 3: node的兄弟other是黑色的，并且other的左子节点是红色，右子节点为黑色。&lt;/span&gt;
&lt;span&gt;                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other &lt;/span&gt;=&lt;span&gt; parent.left;
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Case 4: node的兄弟other是黑色的；并且other的左子节点是红色的，右子节点任意颜色&lt;/span&gt;
&lt;span&gt;                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            setBlack(node);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K, V&amp;gt; successor(Entry&amp;lt;K, V&amp;gt;&lt;span&gt; delEntry) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; r = delEntry.right;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;assert r != null;&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (r.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            r &lt;/span&gt;=&lt;span&gt; r.left;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    }

    List&lt;/span&gt;&amp;lt;V&amp;gt;&lt;span&gt; values(){
        List&lt;/span&gt;&amp;lt;V&amp;gt; &lt;span&gt;set&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(size+&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        midIterator(root,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; midIterator(Entry&amp;lt;K,V&amp;gt; e, List&amp;lt;V&amp;gt;&lt;span&gt; values){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            midIterator(e.left,values);
            values.add(e.value);
            midIterator(e.right,values);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear(){
        clear(root);
        root &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            clear(node.left);
            node.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            clear(node.right);
            node.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size(){&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;}

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; K key;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V value;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; left;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; right;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean color =&lt;span&gt; BLACK;
        Entry(K key,V value,Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; K getKey() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　到此，红黑树的添加删除操作已经全部讲完了，如果文中有什么错误或不懂得地方，随时欢迎大家指出讨论。大家也可以关注公众号：【Java解忧杂货铺】，里面会不定时得发布一些技术干活，和学习视频。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201812/1519364-20181211144820150-959934393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 06:50:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>首先，在阅读文章之前，我希望读者对二叉树有一定的了解，因为红黑树的本质就是一颗二叉树。所以本篇博客中不在将二叉树的增删查的基本操作了，需要了解的同学可以到我之前写的一篇关于二叉树基本操作的博客：htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainple/p/9983786.html</dc:identifier>
</item>
<item>
<title>Quartz.Net进阶之四：CronTrigger 详述 - 可均可可</title>
<link>http://www.cnblogs.com/PatrickLiu/p/10101964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/10101964.html</guid>
<description>&lt;p&gt;        　　以前都是将所有的内容放在一篇文章里，就会导致文章很长，对于学习的人来说，有时候这也是一个障碍。所以，以后我的写作习惯，我就会把我写的文章缩短，但是内容不会少，内容更集中。这样，学习起来也不会很累，很容易看完，也能记得住，不用记得那么多不相关的东西，学习效率也会越高。好了，开始今天的学习计划吧，今天我们要介绍的对象就是 CronTrigger。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;一、CronTrigger 对象概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        如果您需要一个基于类似日历的概念而不是基于SimpleTrigger的指定确切间隔来重复的触发执行作业计划，那么CronTrigger通常比SimpleTrigger更有用。&lt;br/&gt;        &lt;br/&gt;        使用CronTrigger，您可以指定诸如“每个星期五中午”或“每个工作日早上9:30”，甚至“每个星期一、星期三和星期五上午9:00至10:00之间的每5分钟”的触发时间表。&lt;br/&gt;        即便如此，像SimpleTrigger一样，CronTrigger也有一个startTime属性，用于指定计划何时生效，以及一个（可选的）endTime属性，用于指定何时停止计划。&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;&lt;span&gt; 二、Cron表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        Cron-Expressions用于配置CronTrigger的实例。 Cron-Expressions是实际上由七个子表达式组成的字符串，用于描述计划的各个细节。 这些子表达式用空格分隔，表示：&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;1.Seconds&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;        1.Minutes&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                1.Hours&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                1.Day-of-Month&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                1.Month&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                1.Day-of-Week&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                1.Year (optional field)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        完整的cron表达式的一个例子是字符串“0 0 12？ * WED“ - 表示”每周三中午12点“。&lt;/p&gt;&lt;p&gt;        单个子表达式可以包含范围和/或列表。例如，前一个示例（读作“WED”）中的星期日字段可以用“MON-FRI”、“MON,WED,FRI”甚至“MON-WED,SAT”替换。&lt;/p&gt;&lt;p&gt;        通配符（''字符）可用于表示该字段的“每个”可能值。 因此，前一个例子的“月”字段中的''字符仅表示“每个月”。 周日字段中的'*'显然意味着“一周中的每一天”。&lt;/p&gt;&lt;p&gt;        所有字段都有一组可以指定的有效值。这些值应该是相当明显的，比如数字0到59表示秒和分钟，数值0到23表示小时。每月的日期可以是0-31的任何值，但您需要注意一个月内的天数！月份可以指定为0到11之间的值，或者使用字符串JAN、FEB、MAR、APR、MAY、JUN、JUL、AUG、SEP、OCT、NOV和DEC。星期几可以指定为1到7之间的值（1 =星期日）或使用字符串SUN，MON，TUE，WED，THU，FRI和SAT。&lt;/p&gt;&lt;p&gt;        '/'字符可用于指定值的增量。 例如，如果在“分钟”字段中输入“0/15”，则表示“每隔15分钟，从零分钟开始”。 如果您在“分钟”字段中使用“3/20”，则表示“每小时每20分钟一次，从第3分钟开始” - 或者换句话说，它与在“分钟”中指定“3,23,43”相同。&lt;/p&gt;&lt;p&gt;        “？”字符允许用于日期和星期字段。 它用于指定“无特定值”。 当您需要在两个字段之一中指定某些内容而不是另一个字段时，这非常有用。 请参阅下面的示例（和CronTrigger API文档）以获得说明。&lt;/p&gt;&lt;p&gt;        “L”字符允许用于日期和星期字段。 这个字符是“last”的简写，但它在两个字段的中具有不同的含义。 例如，日期字段中的“L”值表示“月份的最后一天” -  1月31日，非闰年2月28日。 如果在星期字段中单独使用，则仅表示“7”或“SAT”。如果在星期字段中在另一个值后使用了“L”，则表示“该月的最后一个xxx日” - 例如“6L”或“FRIL”均表示“该月的最后一个星期五”。 使用“L”选项时，重要的是不要指定列表或值范围，因为您得到的结果并不是你想要的。&lt;/p&gt;&lt;p&gt;        'W'用于指定最接近给定日期的工作日（周一至周五）。 例如，如果您指定“15W”作为日期字段的值，则含义为：“最接近的工作日到该月的15日”。&lt;/p&gt;&lt;p&gt;        ‘#’这个词是用来指定这个月的“第n个”XXX工作日。例如，星期几字段中的“6#3”或“FRI#3”的值表示“本月的第三个星期五”。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;三、示例 Cron 表达式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        以下是表达式及其含义的更多示例 - 您可以在CronTrigger的API文档中找到更多&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;CronTrigger示例1  - 用于创建触发器的表达式，该触发器每5分钟触发一次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            &quot;0 0/5 * * * ?&quot;&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;CronTrigger示例2  - 用于创建触发器的表达式，该触发器在每分钟10秒后（即上午10:00:10，上午10:05:10等）每5分钟触发一次。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            &quot;10 0/5 * * * ?&quot;&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;CronTrigger示例3  - 用于创建触发器的表达式，该触发器在每周三和周五的10：30,11：30,12：30和13:30触发。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            &quot;0 30 10-13 ? * WED,FRI&quot;&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;CronTrigger示例4  - 用于创建触发器的表达式，该触发器在每个月的5日和20日上午8点到上午10点之间每半小时触发一次。 请注意，触发器不会在上午10:00，即8：00,8：30,9：00和9:30触发&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;            &quot;0 0/30 8-9 5,20 * ?&quot;&lt;/p&gt;&lt;p&gt;        请注意，某些计划要求过于复杂，无法通过单个触发器表达 - 例如“上午9:00至上午10:00之间每隔5分钟，下午1:00至晚上10:00之间每20分钟”。 此方案中的解决方案是创建两个触发器，并注册它们以运行相同的作业。&lt;br/&gt;        &lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;四、建立CronTriggers&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        CronTrigger实例是使用TriggerBuilder（用于触发器的主要属性）和WithCronSchedule扩展方法（用于特定于CronTrigger的属性）构建的。&lt;/p&gt;&lt;p&gt;        您还可以使用CronScheduleBuilder的静态方法来创建计划。&lt;/p&gt;&lt;p&gt;        &lt;strong&gt;建立一个触发器，每天上午8点到下午5点之间每隔一分钟触发一次：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 .WithCronSchedule(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 0/2 8-17 * * ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 .ForJob(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myJob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 .Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        &lt;strong&gt;构建一个触发器，每天上午10:42触发：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; we use CronScheduleBuilder's static helper methods here&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 .WithSchedule(CronScheduleBuilder.DailyAtHourAndMinute(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                .ForJob(myJobKey)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                .Build();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            或者
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 .WithCronSchedule(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 42 10 * * ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 .ForJob(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myJob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 .Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        &lt;strong&gt;构建一个触发器，该触发器将在星期三上午10点42分在TimeZone中触发，而不是系统的默认值：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                .WithSchedule(CronScheduleBuilder
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     .WeeklyOnDayAndHourAndMinute(DayOfWeek.Wednesday, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     .InTimeZone(TimeZoneInfo.FindSystemTimeZoneById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Central America Standard Time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                .ForJob(myJobKey)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                .Build();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            或者
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 .WithCronSchedule(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 42 10 ? * WED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x =&amp;gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     .InTimeZone(TimeZoneInfo.FindSystemTimeZoneById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Central America Standard Time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                .ForJob(myJobKey)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 .Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt;五、CronTrigger Misfire 说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        以下说明可用于告知Quartz当CronTrigger发生失效时它应该做什么。 （在本教程的“更多关于触发器”部分中介绍了失效情况）。 这些指令以常量定义（并且API文档具有对其行为的描述）。 说明包括：&lt;/p&gt;&lt;p&gt;            &lt;br/&gt;            MisfireInstruction.IgnoreMisfirePolicy&lt;/p&gt;&lt;p&gt;            MisfireInstruction.CronTrigger.DoNothing&lt;/p&gt;&lt;p&gt;            MisfireInstruction.CronTrigger.FireOnceNow&lt;/p&gt;&lt;p&gt;        所有触发器都可以使用MisfireInstrution.SmartPolicy指令，该指令也是所有触发器类型的默认指令。 CronTrigger将“smart policy”指令解释为MisfireInstruction.CronTrigger.FireOnceNow。 CronTrigger.UpdateAfterMisfire（）方法的API文档解释了此行为的确切详细信息。&lt;/p&gt;&lt;p&gt;        在构建CronTriggers时，您将失效指令指定为cron调度的一部分（通过WithCronSchedule扩展方法）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             trigger =&lt;span&gt; TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 .WithCronSchedule(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 0/2 8-17 * * ?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x =&amp;gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                    .WithMisfireHandlingInstructionFireAndProceed())
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 .ForJob(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myJob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 .Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   &lt;span&gt;&lt;strong&gt; 六、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        　　今天要写的内容差不多了，由于个人的翻译水平有限，可能存在不正确的地方，为了让大家可以看到原文，这样可以有个更好的理解，我也把原地址贴出来。原文地址如下：&lt;a href=&quot;https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html&quot; target=&quot;_blank&quot;&gt;https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;        不忘初心，继续努力。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 06:22:00 +0000</pubDate>
<dc:creator>可均可可</dc:creator>
<og:description>以前都是将所有的内容放在一篇文章里，就会导致文章很长，对于学习的人来说，有时候这也是一个障碍。所以，以后我的写作习惯，我就会把我写的文章缩短，但是内容不会少，内容更集中。这样，学习起来也不会很累，很容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/10101964.html</dc:identifier>
</item>
<item>
<title>从壹开始微服务 [ DDD ] 之终篇 ║当事件溯源  遇上 粉丝活动 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/10093444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/10093444.html</guid>
<description>&lt;p&gt;哈喽~大家好，时间过的真快，关于DDD领域驱动设计的讲解基本就差不多了，本来想着周四再开一篇，感觉没有太多的内容了，剩下的一个就是验证的问题，就和之前的JWT很类似，就不打开一个章节了，而且这个也不是领域驱动设计范畴之内的，下一个系列 Ids 的讲解中，可能会穿插着讲一讲，然后到时候正好一起完善了。&lt;/p&gt;
&lt;p&gt;虽然是完结了，不过心里还是不是很开森呀，通过小伙伴的反馈，然后我也咨询了官方的建议，好像这个DDD领域驱动设计系列，并没有得到很多的支持，影响力完全比不过第一个系列《&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9495618.html&quot; target=&quot;_blank&quot;&gt;从壹开始前后端分离&lt;/a&gt;》，原因可能是，我也没有在项目中真正的使用过DDD的原因吧，也或许是写的比较生硬，主要我也一直在研究，不过我这里一定要说一下，还是要多看看的，不一定要看我讲的，可以看看书也行，或者看看别人的博客，DDD领域驱动设计思想真的很不错，然后还夹带着CQRS命令查询职责分离、Bus总线思想、EDA事件驱动思想、ES事件溯源思想（今天要说到的）、消息队列等等这些以前没有接触到的思想设计，也为微服务打下了一定的基础，如果没有这些基础，你是很难理解为什么要使用微服务的，这里我们就先来回顾一下这些天我们都说了什么内容吧：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a id=&quot;post_title_link_9806335&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9806335.html&quot;&gt;我们第一次开始讨论DDD领域驱动设的概念已经我的个人计划书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9832684&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9832684.html&quot;&gt;DDD入门 &amp;amp; 项目整体的第一次搭建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9845573&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9845573.html&quot;&gt;领域、子域、限界上下文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9872450&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9872450.html&quot;&gt;又一次讨论了DDD设计思想的重大意义 以及使用EFCore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9888502&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9888502.html&quot;&gt;实体 与 值对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9916785&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9916785.html&quot;&gt;聚合 与 聚合根&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9931304&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9931304.html&quot;&gt;第一次把项目跑通，然后也简单说了下 &lt;strong&gt;CQRS&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_9962759&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9962759.html&quot;&gt;剪不断理还乱的 值对象和Dto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9984740.html&quot;&gt;明白领域验证&lt;strong&gt; &lt;code&gt;FluentValidator&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_10000662&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/10000662.html&quot;&gt;命令总线 &lt;strong&gt;Bus&lt;/strong&gt; 分发（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;post_title_link_10059878&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/10059878.html&quot;&gt;事件驱动 &lt;strong&gt;EDA&lt;/strong&gt; 详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算上今天的内容，正好是十二篇，也是我的比较喜欢的一个数字（之前在文章中说到过这个原因，这里就不多说了），也是很辛苦写了这么多，希望有时间有精力的时候，还是要多看看的，多品品思想，这样我们就不会一直问一些虚无缥缈的问题了，虽然我现在是越学的多，越不会的多😂。&lt;/p&gt;
&lt;p&gt;可能你也发现了今天的题目有些不一样，因为我之前说过，要在圣诞节简单搞个小活动，既然说了，就不能食言，不过目前我写了十六万字了，就一个小伙伴给了我&lt;strong&gt;一块钱&lt;/strong&gt;红包😂，好失败，所以我就简单来个小福利吧，因为这个系列的名字就是Christ3D，当时就是想着在圣诞节前能说完，还可以，紧赶慢赶的说完了，我就想着一个给粉丝一个小小小福利：&lt;/p&gt;
&lt;blockquote readability=&quot;8.5394736842105&quot;&gt;
&lt;p&gt;&lt;span&gt;具体的参与形式看文章末尾：&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/10093444.html#autoid-7-0-0&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、免费给送三本书，可能是《&lt;a href=&quot;http://product.dangdang.com/23439300.html&quot; target=&quot;_blank&quot;&gt;实现领域驱动设计&lt;/a&gt;》这本书，或者《&lt;a href=&quot;http://product.dangdang.com/23981385.html&quot; target=&quot;_blank&quot;&gt;领域驱动设计 软件核心复杂性应对之道&lt;/a&gt;》；&lt;/p&gt;
&lt;p&gt;2、本来想抽十位粉丝，送精装的圣诞节苹果，但是考虑食品安全问题就算了，直接到时候发红包吧（时间地点保密，提示：为了老粉丝）；&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;言归正传，今天的重点还是要好好的说说新知识——事件溯（su）源，Event Source，也有人翻译事件采购，或者是事件回溯，或者直接就是ES，其实都是一个意思，要是下次你发现这几个词语的时候，都是指的事件溯源，其实事件溯源已经有一只脚迈进了微服务的大家族了，甚至可以说已经在微服务的一员了，他配合着事件总线EventBus、消息队列等，在微服务的工作中起着一定的作用。当然今天只是简单的入门讲解，要是想打开真正的微服务的大门，就需要大家自己去探索，当然，我也会继续跟进这个讲解，下一个系列 Ids ，其实也是微服务的一个分支，慢慢来，希望大家多捧场啦！&lt;/p&gt;
&lt;p&gt;马上开始今天的讲解，还是一天一问吧，希望大家带着这个问题通读本文，自己能想到合适的答案：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、你认为事件存储 EventStore 和 日志记录的区别是什么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;span&gt;这里要给大家再强调两点&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;1、CQRS、EDA和ES这些其实已经不在DDD设计的范围之内，只不过这些技术都是一起使用的，多个技术的相互结合使用，才能发挥很大的作用，所以说本系列教程是&lt;br/&gt;DDD+CQRS+EDA+ES的结合体，以后被别人问到的时候，可别说时间溯源就是领域驱动设计的一部分哟。&lt;/p&gt;
&lt;p&gt;2、事件溯源不是一两句能说清的，这篇文章只是一个启蒙的作用，等大家从事微服务工作的时候，就知道它深层次的意义了，切不可和平时的 CURD 项目生搬硬套做比较。&lt;/p&gt;



&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211102324677-491969308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（我写的十二篇文章中的知识点，这里基本都有了，也算是一个圆满了，集齐七颗啦😀）&lt;/p&gt;



&lt;p&gt;时间溯源其实很好理解，首先从字面上的理解：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;事件就是 Event，溯是一个动词，可以理解为追溯，回溯的意思，源代表原始、源头的意思，合起来表示一个事件追踪源的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1、理解事件溯源的概念&lt;/h3&gt;
&lt;p&gt;我们知道，一个对象从创建开始到消亡会经历很多阶段，同样也会经历很多个事件，现在我们在设计的时候，都是在每次对象参与完一个业务动作后，把它最新的状态持久化保存到数据库中，也就是说我们的数据库中的数据是反映了对象的当前最新的状态。当然我们也是一直这么使用的（面向对象编程）。然而事件溯源则相反，它不是保存对象的最新状态，而是保存这个对象所经历的每个事件，所有的由对象产生的事件会按照时间先后顺序有序的存放在数据库中——这个就是事件存储 &lt;span&gt;Event Store&lt;/span&gt;，然后我们一一取出来做处理就是事件溯源 &lt;span&gt;Event Source&lt;/span&gt;。可以看出，事件溯源的这种做法是更符合事实观的，因为它完整的描述了对象的整个生命周期过程中所经历的所有事件。&lt;/p&gt;

&lt;p&gt;你一定会问，为什么记录事件，就是更符合客观事实呢，为什么会这么说呢？别慌，听我继续往下说。&lt;/p&gt;

&lt;div readability=&quot;77&quot;&gt;
&lt;h3&gt;2、事件溯源的执行过程&lt;/h3&gt;
&lt;p&gt;这个时候你仔细想一想，我们在和&lt;strong&gt;领域专家&lt;/strong&gt;（默认他们不懂技术）讨论&lt;strong&gt;用户下单&lt;/strong&gt;流程的时候，专家一定会说：客户首先选择一个商品，然后添加到购物车，确认无误下单，接着用户支付，支付成功后，就给用户发货。而我们呢，我们作为一个开发人员，和领域专家讨论的时候，自然而然的也是这么思考的，对不对！（你肯定在讨论需求的时候用的不是数据库的思维！），只不过我们后期开发的时候，拘泥于&lt;strong&gt;技术和数据优先&lt;/strong&gt;的思维，不得不转向&lt;strong&gt;CURD&lt;/strong&gt;的道路了，当然这个没有什么错误，我只是说明一点，事件存储真的离我们不远。&lt;/p&gt;
&lt;p&gt;那我们平时是怎么做的呢，这里说一个特别简单的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211105349571-1679476895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个特别简单的流程中我们可以看到，平时我们都是直接操作的 Order 这个领域聚合根，一直在修改模型状态，这个看似正常的操作下，有一些问题，是我们建立在每一步都正常执行的情况下，不过一般总会出现一些问题，特别是分布式的环境中。&lt;/p&gt;
&lt;p&gt;然而，事件溯源与上述的情况恰好相反，它并不关心当前状态，而是关注持续不断的变化事件。&lt;/p&gt;
&lt;p&gt;举个例子，假设我们有一个“购物车”，我们可以创建购物车，往里面添加商品或移除商品，然后结账。&lt;/p&gt;
&lt;p&gt;购物车的生命周期可以包含如下一系列事件：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;创建购物车&lt;/p&gt;
&lt;p&gt;往购物车里添加商品&lt;/p&gt;
&lt;p&gt;再次往购物车里添加商品&lt;/p&gt;
&lt;p&gt;从购物车里移除商品&lt;/p&gt;
&lt;p&gt;结账&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些就是一个购物车的生命周期，包含了一系列事件。这就是事件溯源，非常简单吧？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211001057691-550946368.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;几乎所有的流程都可以被看成一系列事件。在与领域专家交谈时，他们不会提及“表”和“连接”，他们会将流程描述成一系列事件以及可以应用在这些事件上的规则。&lt;/p&gt;
&lt;h3&gt;3、事件溯源是如何更新实时状态的&lt;/h3&gt;
&lt;p&gt;那么，事件到底如何影响一个领域对象的状态的呢？很简单，当我们在触发某个领域对象的某个行为时，该领域对象会先产生一个事件，然后该对象自己响应该事件并更新其自己的状态，同时我们还会持久化在该对象上所发生的每一个事件；这样当我们要重新得到该对象的最新状态时，只要先创建一个空的对象，然后将和该对象相关的所有事件按照事件发生先后顺序从先到后再全部应用一遍即可还原得到该对象的最新状态，这个过程就是所谓的事件溯源。&lt;/p&gt;

&lt;div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181210184618733-980676636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;p&gt;事件溯源不是万能的，不过它可以在某一些领域发挥很大的作用，这个在以后的微服务设计中，会更能体现出来，那我们就简单说两点：&lt;/p&gt;
&lt;h3&gt;1、传统应用中出现的某些问题&lt;/h3&gt;
&lt;h4&gt;从业务的角度&lt;/h4&gt;
&lt;p&gt;传统的应用中，数据库里存的是Domain Model的实例的当前状态，比如&lt;strong&gt;某个储户银行账户的存款数&lt;/strong&gt;，通常是一个数字.如果考虑到如下的三个情形,我们可能付出的代价比较大：&lt;/p&gt;
&lt;p&gt;１) 老规则：问题跟踪&lt;/p&gt;
&lt;p&gt;如果某个储户的账户出现问题，那么我们只有从大到PB的日志中去分析用户的账户数据是如何出错的，而且我们在做日志的时候，不可能所有的都考虑到，就算是把全部数据都保存，时间都记下来，操作者都备份，那ATM机信息呢？（可能不恰当，只是说明我们总有想不到的地方），但如果一旦日志不够详细，找出问题根源基本只能靠猜了。&lt;/p&gt;
&lt;p&gt;２) 新需求：趋势分析&lt;/p&gt;
&lt;p&gt;历史数据的作用在于分析未来的趋势，如果仅仅从浩如烟海的日志中寻找规律，我们还得单独写逻辑，对日志进行建模，清洗，其实我们已经能接受，日志就是用来记录异常信息的，这个时候我们就很崩溃了。&lt;/p&gt;
&lt;p&gt;３) 更奇葩：事务回滚&lt;/p&gt;
&lt;p&gt;在介绍事务修正模式中，我们讲到某个步骤发生错误，之前的各个节点可以自己独立地完成回滚，回滚的依据就是记录的操作步骤及相关参数，根据这些有用信息就可以每个节点自行回滚到原始状态，并且在失败的时候可以retry&lt;/p&gt;
&lt;p&gt;可见存储对于Domain Model 的各个事件还是非常有用的,尤其是对于复杂的系统，这也就是我们今天要讨论的事件溯源模式.&lt;/p&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;h4&gt;从技术角度&lt;/h4&gt;
&lt;p&gt;大多数的应用都和数据打交道，最常见的打交道方式就是将用户在使用过程中的数据最终状态同步到数据库中。例如，在传统的增删改查（CURD）模式中，一个典型的数据过程就是从数据库中读出数据，修改完后再把修改后的数据更新到数据库中——通常来说，在这个更新过程这张数据表是被锁住的。&lt;/p&gt;
&lt;p&gt;这种传统的增删改查（CURD）方式存在一些局限性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事实上执行这种直接依赖数据库的增删改查（CRUD）开销会影响系统的性能和响应性，不利于系统的可伸缩性。&lt;/li&gt;
&lt;li&gt;在一个存在多个用户并发操作的领域中，因为多个用户也许会同时操作同一张表，所以数据更新造成的冲突更加可能发生。&lt;/li&gt;
&lt;li&gt;除非系统额外有一个可以记录所有业务细节的日志系统以实现审查机制，否则所有的历史都会丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;h5&gt; &lt;/h5&gt;
&lt;p&gt;这是一个大问题。在以表作为驱动的系统里，你只保存了系统的当前状态，你根本就无法知道系统是如何达到当前状态的。如果我问你“这个用户修改了几次邮件地址”，你有办法回答吗？或者我再问“有多少人把一件商品添加到购物车里，然后又移除掉，直到一个月之后才买了那件商品”，你就更没法回答了。你存储数据的方式丢掉了很多有用的业务信息！&lt;/p&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;h3&gt;2、我们有哪些理由使用Event Sourcing（&lt;strong&gt;优点&lt;/strong&gt;）&lt;/h3&gt;
&lt;p&gt;尽管它是一个简单的模式，但使用它有很多优点：&lt;/p&gt;

&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;事件日志具有很高的商业价值;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;它在DDD和事件驱动架构下运行得非常好。&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;调试用应用程序状态中所有变更的来源;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;它允许您重放失败的事件;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;易于调试，您可以将目标实体的所有事件复制到您的机器并调试每个事件，以了解应用程序如何达到特定状态（忽略从生产环境复制数据的安全隐患）;&lt;/p&gt;
&lt;p class=&quot;_mce_tagged_br&quot;&gt;允许您使用追溯事件模式重建/修复您的状态。&lt;/p&gt;
&lt;p&gt;许多作者还将优先级作为时间查询的能力，但我认为查询多个后续事件不是一项简单的任务。因此，我通常认为时间查询是快照模式的一个优点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div readability=&quot;35&quot;&gt;
&lt;p class=&quot;indent&quot;&gt;有许多理由使用Event Sourcing，当你浏览Greg Young的系列文章和谈话你会发现下面要点：&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;1. 它不是一个新概念，真实世界中许多领域都很像它，看看你的银行账户状态，比如储蓄卡，它打印出一笔笔进出明细和当前余额，这一笔笔代表了领域事件。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;2.通过重播事件，我们能够得到对象的任何时刻状态(这里应该用正确术语：聚合aggregate)，比如储蓄卡每笔记录的当前余额代表你这个账户聚合对象的某刻时刻的状态，这可能会极大地帮助我们理解领域知识，当前状态是怎么来，因为什么改变？方便调试关键问题的错误&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;3.领域中当前状态和存储数据库中的数据没有任何耦合，而传统上我们都是将应用状态存储到数据库中，比如储蓄卡当前余额100元存储到数据库中，现在我们存储导致余额的进出事件了，存款了多少钱，取&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;款了多少钱，这一笔笔领域事件都会记录在数据库中。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;4.Append-only追加模型存储这些事件，易于扩展，这样我们无论读写都有很好地性能，读取能够转为查询优化，也可以转为写优化（因为没有读，写得很快），读写分离。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;5除了可以存储用户意图数据，也就是操作事件，事件存储顺序能够用来分析用户正在做什么，通往大数据。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;6.我们能避免了对象与关系数据库的不匹配。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;7.审计日志是免费的，一次审计日志所有变化，因为没有状态改变，只有事件。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt; 
&lt;p&gt;这样不会浪费时间吗？&lt;/p&gt;
&lt;p&gt;一点也不。一般来说，要执行约束，只需要获得事件的一个很小子集。通过简单的数据库查询就可以获得有用的历史事件，在加载完这些事件后重放它们，把它们“投射”出来，以此构建你的数据集。这样的操作其实是很快的，因为你使用的是本地的处理器，而不是执行一系列SQL查询（跨域网络的调用要比本地操作慢得多，至少会相差两个数量等级）。&lt;/p&gt;
&lt;p&gt;你可以在后台构建数据集，然后把中间结果保存在数据库里。这样，用户就可以在很短的时间内查询到这些数据。&lt;/p&gt;

&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;image-block&quot; readability=&quot;15&quot;&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、事件溯源存在的一些问题（缺点）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;事件采集的缺点&amp;quot;,&amp;quot;27:\&amp;quot;30\&amp;quot;|8:1&amp;quot;]]&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 下面是一些困难：&lt;br/&gt;1.定义事件是一件艺术，需要熟悉的领域建模，DDD领域驱动设计是关键。&lt;br/&gt;2.需要软件和硬件支持事件采购，在以后几年，你会看到这个领域的很多解决方案。&lt;br/&gt;3.这方面是新生事物，可指导的经验太少。&lt;br/&gt;4.限制与真正成熟的DDD/ES技能。&lt;/p&gt;&lt;p&gt;其他带来的问题还有：&lt;br/&gt;1.需要超级大的存储消耗。云存储解决。&lt;br/&gt;2.比较慢也不是问题，因为我们优化优化IO来实现快照和持久。并利用基于事件的天然“推”性质，我们可以得到立即失效缓存。简而言之，能够过后有多个插入，需要这种多个的技术解决方案。&lt;br/&gt;3.脆弱（丢失失过去的一个事件将导致整个流腐败）不是一个问题，因为你可以决定自己的SLA水平去（通过复制和冗余）。使用Git的方法，可以可靠地检测在任何一个副本的腐败事件包括SHA1签名针对它的内容和以前的事件签名计算。&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;image-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;image-block&quot;&gt;4、什么时候使用这种模式&lt;/h3&gt;
&lt;p&gt;这种模式在以下几种场景中是最理想的解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当你想获得数据的“意图”，“目的”或者“原因”的时候。 例如，一个客户的实体改变可能用一系列的类似于”搬家“，”注销账户“或者”死亡“等事件类型。&lt;/li&gt;
&lt;li&gt;并发更新数据时候非常需要减少或者完全避免冲突的时候。&lt;/li&gt;
&lt;li&gt;当你需要保存已经发生的事件，并且能够重播他们来还原到某个状态、使用这些事件去回滚系统的某些变化或者仅仅是历史或者审查记录的时候。例如 ，当一个任务包括几个步骤，你可能需要执行一个撤销更新的操作然后重播过去的每个步骤来回到稳定的状态。&lt;/li&gt;
&lt;li&gt;当使用事件是一些应用程序的某些操作的天然属性，并且需要很少的额外扩展或者实施的时候。&lt;/li&gt;
&lt;li&gt;当你需要把插入，更新数据和需要执行这些操作的应用程序解耦开的时候。用这种模式可以提高UI的性能，或者把这些事件分发给其他的监听者，比如有些应用程序或系统，它们在一些事件发生的时候必须做出一些反应。例如，将一个工资系统和一个报销系统结合起来，这样的话当报销系统更新一个事件给事件数据库，数据库对此做出的相应事件就可以被报销系统和工资系统共享。&lt;/li&gt;
&lt;li&gt;当要求变更或者——当和CQRS配合使用的时候——你需要适配一个读的模型或者视图来显示数据，而你想要更灵活地改变物化视图的格式和实体数据的时候。&lt;/li&gt;
&lt;li&gt;当和CQRS配合使用的时候，并且当一个读模型被更新时能接受数据的最终一致性问题，或者说从一系列的事件序列中生成实体对性能的影响可以被接受。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种模式在以下几种场景中可能并不适用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小而简单的，业务逻辑简单或者根本没有业务逻辑，或者领域概念的，一般传统的增删改查（CURD）就能实现功能的业务领域，或者系统。&lt;/li&gt;
&lt;li&gt;需要实时一致和实时更新数据的系统。&lt;/li&gt;
&lt;li&gt;不需要审查，历史和回滚的系统。&lt;/li&gt;
&lt;li&gt;并发更新数据可能性非常小的系统。例如，只增加数据不更新数据的系统。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div readability=&quot;39&quot;&gt;
&lt;h3 class=&quot;indent&quot;&gt;5、ES 和 CQRS 的关系&lt;/h3&gt;
&lt;p&gt;CQRS与事件溯源有着相辅相成的关系。CQRS允许事件溯源作为领域的数据存储机制。然而，使用事件溯源的一个最大的缺点是，你无法向你的系统提出类似“请告诉我所有名字为Greg的用户”这样的问题，这是由于事件溯源无法提供对象的当前状态而引起的。CQRS唯一支持的查询就是：GetById - 通过ID来获得某个聚合。下图为基于CQRS/ES的应用系统结构：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211001345031-1444198719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CQRS经常和事件溯源模式结合使用&lt;/p&gt;
&lt;p&gt;基于CQRS的系统使用分离的读和写模型，每一个都对应相应的任务并且一般储存在不同的数据库中。当和事件溯源模式一起使用的时候，一系列的事件存储相当于“写”模型，是所有信息的可信赖来源（authoritative source ）。基于CQRS的系统的读模型提供了数据的物化视图，经常是一种高度格式化的视图形式。这些视图对应相应的界面并且展示了应用程序的需求，帮助最大化展示和查询效率。&lt;/p&gt;
&lt;p&gt;使用一系列的事件当作“写”而不是某一个时间点的数据，避免了更新的冲突并且最大化性能和系统的伸缩性，这些事件可以被异步地产生被用来展示数据的物化视图。&lt;/p&gt;
&lt;p&gt;因为事件数据库是所有信息的可信赖来源，当系统改进的时候，有可能删除物化视图并且展示所有过去的时间来产生一个新的数据，或者当读模型必须改变的时候。物化视图是一个长久的数据缓存。&lt;/p&gt;
&lt;p&gt;当将CQRS和事件溯源模式结合起来的时候，考虑以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于任何的读写分离储存的系统，这些系统基于事件溯源模式都是“最终一致”的。因此在事件产生和数据存储之间会有一些延迟。&lt;/li&gt;
&lt;li&gt;这种模式会造成一些额外的复杂度，因为代码必须要能够初始化和处理事件，然后组合或者更新相应的读写模型需要视图或者对象。这种复杂度会对让系统的实现变得有些困难，需要重新学习一些概念和一个不同的设计系统的方式。然而事件溯源可以让为领域建模，让重建视图或者对象更加容易。&lt;/li&gt;
&lt;li&gt;生成物化视图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CQRS最核心的概念是Command、Event，“将数据(Data)看做是事实(Fact)。每个事实都是过去的痕迹，虽然这种过去可以遗忘，但却无法改变。” 这一思想直接发展了Event Source，即将这些事件的发生过程记录下来，使得我们可以追溯业务流程。CQRS对设计者的影响，是将领域逻辑，尤其是业务流程，皆看做是一种领域对象状态迁移的过程。这一点与REST将HTTP应用协议看做是应用状态迁移的引擎，有着异曲同工之妙。&lt;/p&gt;


&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;1、必须自己实现事务的统一commit和rollback：这个是无论哪一种方式，都必须面对的问题。完全逃不掉。在DDD中有一个叫&lt;code&gt;Saga&lt;/code&gt;的概念，专门用于统理这种复杂交互业务的，CQRS/ES架构下，由于本身就是最终一致性，所以都实现了&lt;code&gt;Saga&lt;/code&gt;，可以使用该机制来做微服务下的transaction治理。&lt;/p&gt;


&lt;p&gt;2、请求幂等：请求发送后，由于各种原因，未能收到正确响应，而被请求端已经正确执行了操作。如果这时重发请求，则会造成重复操作。&lt;br/&gt;CQRS/ES架构下通过AggregateRootId、Version、CommandId三种标识来识别相同command，目前的开源框架都实现了幂等支持。&lt;/p&gt;


&lt;p&gt;3、并发：单点上，CQRS/ES中按事件的先来后到严格执行，内存中&lt;code&gt;Aggregate&lt;/code&gt;的状态由单一线程原子操作进行改变。&lt;br/&gt;多节点上，通过EventStore的broker机制，毫秒级将事件复制到其他节点，保证同步性，同时支持版本回退。(Eventuate)&lt;/p&gt;
&lt;/blockquote&gt;

 &lt;/div&gt;


&lt;p&gt;大家请注意，下边的这一个流程，就和我们平时开发的顺序是一样的，比如先建立模型，然后仓储层，然后应用服务层，最后是调用的过程，东西虽然很多，但是很简单，慢慢看都能看懂。&lt;/p&gt;
&lt;p&gt;同时也复习下我们DDD领域驱动设计是如何搭建环境的，正好在最后一篇和第一篇遥相呼应。&lt;/p&gt;
&lt;h3&gt;1、创建事件存储模型 StoredEvent : Event&lt;/h3&gt;
&lt;p&gt; 那既然说到了事件溯源，我们就需要首先把事件存储下来，那存下来之前，首先要进行建模：&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;在核心应用层 Christ3D.Domain.Core 的 Events文件夹下，新建 Message.cs 用来获取我们事件请求的类型：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Events
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 抽象类Message，用来获取我们事件执行过程中的类名
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 然后并且添加聚合根
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Message : IRequest
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MessageType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid AggregateId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Message()
        {
            MessageType &lt;/span&gt;=&lt;span&gt; GetType().Name;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同时在该文件夹下，新建 存储事件 模型StoredEvent.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StoredEvent : Event
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造方式实例化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;theEvent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;user&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; StoredEvent(Event theEvent, &lt;span&gt;string&lt;/span&gt; data, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; user)
        {
            Id &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
            AggregateId &lt;/span&gt;=&lt;span&gt; theEvent.AggregateId;
            MessageType &lt;/span&gt;=&lt;span&gt; theEvent.MessageType;
            Data &lt;/span&gt;=&lt;span&gt; data;
            User &lt;/span&gt;=&lt;span&gt; user;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了EFCore能正确CodeFirst&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; StoredEvent() { }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件存储Id&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储的数据&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; User { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211120819734-497349055.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;h3&gt;2、定义事件存储上下文 EventStoreSQLContext &lt;/h3&gt;
&lt;p&gt; 定义好了模型，那我们接下来就是要建立数据库上下文了：&lt;/p&gt;
&lt;p&gt;1、首先在基础设施数据层 Christ3D.Infrastruct.Data 下的 Mappings文件夹下，建立事件存储Map模型 StoredEventMap.cs&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Infra.Data.Mappings
{    
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件存储模型Map
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StoredEventMap : IEntityTypeConfiguration&amp;lt;StoredEvent&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(EntityTypeBuilder&amp;lt;StoredEvent&amp;gt;&lt;span&gt; builder)
        {
            builder.Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.Timestamp)
                .HasColumnName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreationDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            builder.Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.MessageType)
                .HasColumnName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasColumnType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar(100)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、然后再上下文文件夹 Context 下，新建事件存储Sql上下文 EventStoreSQLContext.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Infra.Data.Context
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件存储数据库上下文，继承 DbContext
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventStoreSQLContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件存储模型&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;StoredEvent&amp;gt; StoredEvent { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StoredEventMap());

            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取链接字符串&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用默认的sql数据库连接&lt;/span&gt;
            optionsBuilder.UseSqlServer(config.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211124516596-719193185.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;h3&gt;3、持久化事件仓储 EventStoreSQLRepository : IEventStoreRepository&lt;/h3&gt;
&lt;p&gt;上边咱们定义了用于持久化事件模型的上下文，那么现在我们就需要设计仓储操作类了&lt;/p&gt;
&lt;p&gt;1、在 基础设施数据层中的 Repository 文件夹下，定义事件存储仓储接口  IEventStoreRepository.cs&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Infra.Data.Repository.EventSourcing
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件存储仓储接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承IDisposable ，可手动回收
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventStoreRepository : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Store(StoredEvent theEvent);
        IList&lt;/span&gt;&amp;lt;StoredEvent&amp;gt;&lt;span&gt; All(Guid aggregateId);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、然后对上边的接口进行实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Infra.Data.Repository.EventSourcing
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件仓储数据库仓储实现类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventStoreSQLRepository : IEventStoreRepository
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入事件存储数据库上下文&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; EventStoreSQLContext _context;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventStoreSQLRepository(EventStoreSQLContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据聚合id 获取全部的事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这个聚合是指领域模型的聚合根模型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;aggregateId&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 聚合根id 比如：订单模型id&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IList&amp;lt;StoredEvent&amp;gt;&lt;span&gt; All(Guid aggregateId)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;from&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt; _context.StoredEvent &lt;span&gt;where&lt;/span&gt; e.AggregateId == aggregateId &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e).ToList();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将命令事件持久化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;theEvent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Store(StoredEvent theEvent)
        {
            _context.StoredEvent.Add(theEvent);
            _context.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 手动回收
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _context.Dispose();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211124544123-1456685954.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;这个时候，我们的事件存储模型、上下文和仓储层已经建立好了，也就是说我们可以对我们的事件模型进行持久化了，接下来就是在建立服务了，用来调用仓储的服务，就好像我们的应用服务层的概念。&lt;/p&gt;
&lt;/div&gt;

&lt;h3&gt;4、建立事件存储服务 SqlEventStoreService: IEventStoreService&lt;/h3&gt;
&lt;p&gt; 建完了基础设施层，那我们接下来就需要建立服务层了，并对其进行调用：&lt;br/&gt;1、还是在核心领域层中的Events文件夹下，建立接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Events
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 领域存储服务接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventStoreService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将命令模型进行保存
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 泛型：Event命令模型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;theEvent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; Save&amp;lt;T&amp;gt;(T theEvent) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Event;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211131215575-597055114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、然后再来实现该接口&lt;/p&gt;
&lt;p&gt;在应用层 Christ3D.Application 中，新建 EventSourcing 文件夹，用来对我们的事件存储进行溯源，然后新建 事件存储服务类 SqlEventStoreService.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Infra.Data.EventSourcing
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件存储服务类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlEventStoreService : IEventStoreService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入我们的仓储接口&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IEventStoreRepository _eventStoreRepository;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlEventStoreService(IEventStoreRepository eventStoreRepository)
        {
            _eventStoreRepository &lt;/span&gt;=&lt;span&gt; eventStoreRepository;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存事件模型统一方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;theEvent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Save&amp;lt;T&amp;gt;(T theEvent) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Event
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对事件模型序列化&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; serializedData =&lt;span&gt; JsonConvert.SerializeObject(theEvent);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; storedEvent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StoredEvent(
                theEvent,
                serializedData,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Laozhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            _eventStoreRepository.Store(storedEvent);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211132720493-1909430378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个时候你会问了，那我们现在都写好了，在哪里使用呢，欸？！聪明，既然是事件存储，那就是在事件保存的时候，进行存储，请往下看。&lt;/p&gt;

&lt;h3&gt;5、在总线中发布事件的同时，对事件保存 Task RaiseEvent&amp;lt;T&amp;gt;&lt;/h3&gt;
&lt;p&gt; 在我们的总线实现类 InMemoryBus.cs 下的引发事件方法中，将我们的事件都保存下来（除了领域通知，这个错误通知不需要保存）：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引发事件的实现方法
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;泛型 继承 Event：INotification&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;event&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;事件模型，比如StudentRegisteredEvent&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt; Task RaiseEvent&amp;lt;T&amp;gt;(T @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Event
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除了领域通知以外的事件都保存下来&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; (!@event.MessageType.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DomainNotification&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
         _eventStoreService&lt;/span&gt;?&lt;span&gt;.Save(@event);

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MediatR中介者模式中的第二种方法，发布/订阅模式&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mediator.Publish(@event);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;




&lt;p&gt; DDD领域驱动设计就到这里到一段落了，江湖很远，话不多说，咱们下一系列再见！&lt;/p&gt;



&lt;p&gt;关于活动的原因文章开头已经说的很清楚了，这里就直接说规则吧（活动截止日期：2018年12月12日 13点37分）：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里是三个问题，大家仔细思考&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、聚合根是什么？或者说是什么数据结构？（言之成理即可）

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、我的项目中，有几条总线，分别是？

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、我的项目中，在使用领域通知处理器之前，我是用什么不当的临时方法来处理验证错误信息的？（提示：在自定义视图组件中）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;1、请仔细思考上边这三个问题，并在评论区留言，格式是：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211113404654-969302919.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;为了公平，每个人只有一次评论的机会，且不能先占楼再修改内容，我这里会有修改记录，所以请一次性写好正确答案（违规直接作废）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 这两个名额已经到了，为了信息公证，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;1、初久，真是姓名：韩**，手机号：183******12；青岛。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;2、破雨伞，真实姓名：伍**，手机号：159******17；武汉。

&lt;/div&gt;

&lt;p&gt;3、从发布文章开始，24小时内，评论&lt;strong&gt;被点赞最多&lt;/strong&gt;的那一个人，可以获奖，奖品同上。&lt;/p&gt;
&lt;p&gt;如果没有一个人被点赞，就根据时间顺序的第三个正确答案。&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181211113726910-1778799597.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/ChristDDD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/ChristDDD&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 05:38:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>回首 哈喽~大家好，时间过的真快，关于DDD领域驱动设计的讲解基本就差不多了，本来想着周四再开一篇，感觉没有太多的内容了，剩下的一个就是验证的问题，就和之前的JWT很类似，就不打开一个章节了，而且这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/10093444.html</dc:identifier>
</item>
</channel>
</rss>