<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>什么是软件开发？ - ExperDot</title>
<link>http://www.cnblogs.com/experdot/p/10961830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/experdot/p/10961830.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　有人问我：“什么是软件开发？”。回答这个问题前，我们需要先理解什么是软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一、软件定义&lt;/h2&gt;
&lt;p&gt;　　关于软件，一些优秀的人已经给出了简单易懂的定义，举个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;8.2188679245283&quot;&gt;
&lt;p&gt;　　软件是计算机系统的一部分，它适配各种不同用途的机器。例如，通过同一台计算机但不同的软件，我们可以玩游戏、计算缴税、写信或者写书，以及获得约会邀请的答复。&lt;/p&gt;
&lt;p&gt;—— &lt;a href=&quot;https://baike.baidu.com/item/Gerald%20M.%20Weinberg/6766440&quot; target=&quot;_blank&quot;&gt;杰拉尔德·温伯格&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这句话是作者解释给他的朋友的，他的朋友是一名电脑小白。&lt;/p&gt;
&lt;p&gt;　　有了上述定义，什么是软件开发也就显而易见。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　软件开发研究如何让运行在计算机里的不同系统解决人们在现实中遇到的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　我们经常见到这样的句式，试图一句话就把事情讲得面面俱到。&lt;/p&gt;
&lt;p&gt;　　让我们简化一下。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　软件开发研究如何让计算机解决问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　目前看起来不错。&lt;/p&gt;
&lt;p&gt;　　倘若你听过“一切问题都是人的问题”这句话，并且愿意相信它，那我们就可以接着简化。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　软件开发解决人的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这个定义充满了敷衍的味道。如果你敢向你的女友这么解释，她大抵会提到“你是不不爱我了”之类的话题。&lt;/p&gt;
&lt;p&gt;　　回到正题，它好在足够笼统，把所有的细节归纳为“人的问题”，一言以蔽之，至少不会有多大偏差。&lt;/p&gt;
&lt;p&gt;　　关于什么是“人的问题”，我们无法一一列举。但通过下面的例子，也许可以窥探到一些奥秘：早在 1995 年，有人便觉得软件开发要解决的问题陷入了困境。&lt;/p&gt;
&lt;blockquote readability=&quot;6.974358974359&quot;&gt;
&lt;p&gt;　　我们遇到了前所未有的困难，不知道在做出电子表格（Excel）后，计算机还可以用来做什么。&lt;/p&gt;
&lt;p&gt;—— &lt;a href=&quot;https://baike.baidu.com/item/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E8%A5%BF%E8%92%99%E5%B0%BC/8973244?fr=aladdin&quot; target=&quot;_blank&quot;&gt;查尔斯·西蒙尼&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　从今天来看，这个观点颇失谦逊，软件行业从来没有止步于表格处理程序。当然，我们不是要批判什么，它是用来引出以下软件开发的三点特性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　“人的问题”不可预料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　世界在改变，人的需求也是一直变化的，我们不知道下一步会发生什么。值得一提的是，有时我们甚至不知道过去发生了什么。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　“人的问题”具有延续性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　在 1977 年，人们开始用电子表格处理数据。在今天的办公自动化领域，电子表格仍具有着不可替代的作用。这是值得庆幸的，总有些问题和解决方案会持续很长一段时间。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　“人的问题”具有复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　尽管软件技术在当今的 IT 领域开花结果，人们探索出了各种各样的成型解决方案，但开发者和开发团队依旧面对着复杂的开发环境。&lt;/p&gt;
&lt;p&gt;       复杂性足够我们花费一整节的内容来阐述它，欢迎阅读下一节。&lt;/p&gt;
&lt;h2&gt; 二、软件复杂性&lt;/h2&gt;
&lt;p&gt;　　 随手翻开一本介绍软件工程的书，你都会看到它会提及复杂性。软件复杂性的本质是，现实世界是无比复杂的。至于现实为什么是复杂的，不在本文讨论的范畴。本文更关心的问题是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　是什么让软件变复杂的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　我们在上文提到“软件是运行在计算机里的系统”，这里直接给出系统的一般定义：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　系统是对世界的一种观点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　你可能一时无法接受这个它。&lt;/p&gt;
&lt;p&gt;　　换种说法，系统是对世界的一种抽象。&lt;/p&gt;
&lt;p&gt;　　抽象意味着要从繁复的具象世界里剥丝抽茧，不同的抽象就会产生不同的系统。&lt;/p&gt;
&lt;p&gt;　　观点或者说抽象可以简单也可以复杂。&lt;/p&gt;
&lt;p&gt;　　一个软件从无到有，越来越复杂，根本原因就在于特性不断增加和改变，不同角度会产生不同的观点。&lt;/p&gt;
&lt;p&gt;　　举个食品行业的例子。&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;　　一家公司以独家配方生产一种食品，每个季度的销售额上涨 10%。&lt;/p&gt;
&lt;p&gt;　　管理层希望业绩进一步提高，具体到研究部门，目标是调制出更好吃的配方。&lt;/p&gt;
&lt;p&gt;　　研究团队计划每个月只改动一点点，一年过去了，不断地有顾客投诉食品不再是原来的味道了。&lt;/p&gt;
&lt;p&gt;　　公司董事决定开会。&lt;/p&gt;
&lt;p&gt;　　“我们生产的食品更好吃了吗？”&lt;/p&gt;
&lt;p&gt;　　“当然，我们的销售额增长达到了 30%。”&lt;/p&gt;
&lt;p&gt;　　“但是我们的顾客不这样说。”&lt;/p&gt;
&lt;p&gt;　　“他们只是不愿意改变！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　再举个例子，打开你的手机，各类软件源源不断地弹出新闻资讯类消息。大部分软件工具成熟以后，不再愿意仅做好它的本职工作，当你使用一个小众 APP 时，你可以亲眼见证它从小而美到臃肿不堪的历程。&lt;/p&gt;
&lt;p&gt;　　这是复杂性的一面，面对它，我们唯一能够做的就是“不要多余的特性”，它有个经典表述：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　不要过早的考虑优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　回到上面的故事，也许那家公司什么也不做，销售额同样会上涨。&lt;/p&gt;
&lt;p&gt;　　你可以能会质疑“说的轻巧，我们总不能什么都不做？”&lt;/p&gt;
&lt;p&gt;　　回答它，涉及到我们做出决定时绕不开的一个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　你愿意付出什么样的代价？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　付出什么，就要准备好得到什么。你愿意付出多少薪资雇佣员工，你愿意增加多少特性，你愿意采用什么样的解决方案，你愿意为这个 Bug 留出多少工作量。&lt;/p&gt;
&lt;p&gt;　　拿出什么样的筹码，是真实摆在我们眼前的问题。&lt;/p&gt;
&lt;h2&gt; 四、什么是软件开发&lt;/h2&gt;
&lt;p&gt;　　现在，我们可以正式回答这个问题了。&lt;/p&gt;
&lt;p&gt;　　首先，“预料”对方真正的目的是什么？&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;　　1. 对方只是随口一问。&lt;/p&gt;
&lt;p&gt;　　2. 对方想打探你的薪资，然后向你介绍相亲对象。&lt;/p&gt;
&lt;p&gt;　　3. 对方对软件行业这个话题感兴趣，并想深入了解更多。&lt;/p&gt;
&lt;p&gt;　　4. 其他可能性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　对于醉翁之意不在酒，你翻开和老妈的微信聊天记录，阅读一番《不得不看，职场新老手都有用的一百条话术！》，基本可以应付了。&lt;/p&gt;
&lt;p&gt;        至于第三种情况，先给他来个含辞模糊的定义，比如&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　软件开发通过设计、编码、测试以及持续地维护解决人的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　一般地，对方发现自己听得云里雾里后，就会识趣的停止这个话题。但也有可能，尤其是碰到其他领域的工程师时，会引出更为具体的问题。&lt;/p&gt;
&lt;p&gt;　　不幸的是，有时候问题根本就不存在，正如下面的寥寥数语，它会让你所有准备好的说辞付之流水。　　&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;　　“工作忙吗？”&lt;/p&gt;
&lt;p&gt;　　“还行。”&lt;/p&gt;
&lt;p&gt;　　“每天都干啥？”&lt;/p&gt;
&lt;p&gt;　　“主要是写代码。”&lt;/p&gt;
&lt;p&gt;　　“不懂，听说挺累的。”&lt;/p&gt;
&lt;p&gt;　　“有时候是累，工作不都这样么。”&lt;/p&gt;
&lt;p&gt;　　“嘿，说的也是。”&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 18 Jun 2019 00:31:00 +0000</pubDate>
<dc:creator>ExperDot</dc:creator>
<og:description>有人问我：“什么是软件开发？”。回答这个问题前，我们需要先理解什么是软件。 一、软件定义 关于软件，一些优秀的人已经给出了简单易懂的定义，举个例子： 软件是计算机系统的一部分，它适配各种不同用途的机器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/experdot/p/10961830.html</dc:identifier>
</item>
<item>
<title>再一次生产 CPU 高负载排查实践 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11043109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11043109.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c34d2973a58018.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前几日早上打开邮箱收到一封监控报警邮件：某某 ip 服务器 CPU 负载较高，请研发尽快排查解决，发送时间正好是凌晨。&lt;/p&gt;
&lt;p&gt;其实早在去年我也处理过类似的问题，并记录下来：&lt;a href=&quot;https://crossoverjie.top/2018/12/17/troubleshoot/cpu-percent-100/&quot;&gt;《一次生产 CPU 100% 排查优化实践》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过本次问题产生的原因却和上次不太一样，大家可以接着往下看。&lt;/p&gt;

&lt;p&gt;收到邮件后我马上登陆那台服务器，看了下案发现场还在（负载依然很高）。&lt;/p&gt;
&lt;p&gt;于是我便利用这类问题的排查套路定位一遍。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;首先利用 &lt;code&gt;top -c&lt;/code&gt; 将系统资源使用情况实时显示出来 （&lt;code&gt;-c&lt;/code&gt; 参数可以完整显示命令）。&lt;/p&gt;
&lt;p&gt;接着输入&lt;code&gt;大写 P&lt;/code&gt; 将应用按照 &lt;code&gt;CPU&lt;/code&gt; 使用率排序，第一个就是使用率最高的程序。&lt;/p&gt;
&lt;p&gt;果不其然就是我们的一个 &lt;code&gt;Java&lt;/code&gt; 应用。&lt;/p&gt;
&lt;p&gt;这个应用简单来说就是定时跑一些报表使的，每天凌晨会触发任务调度，正常情况下几个小时就会运行完毕。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;常规操作第二步自然是得知道这个应用中最耗 &lt;code&gt;CPU&lt;/code&gt; 的线程到底再干嘛。&lt;/p&gt;
&lt;p&gt;利用 &lt;code&gt;top -Hp pid&lt;/code&gt; 然后输入 &lt;code&gt;P&lt;/code&gt; 依然可以按照 &lt;code&gt;CPU&lt;/code&gt; 使用率将线程排序。&lt;/p&gt;
&lt;p&gt;这时我们只需要记住线程的 ID 将其转换为 16 进制存储起来，通过 &lt;code&gt;jstack pid &amp;gt;pid.log&lt;/code&gt; 生成日志文件，利用刚才保存的 16 进制进程 &lt;code&gt;ID&lt;/code&gt; 去这个线程快照中搜索即可知道消耗 &lt;code&gt;CPU&lt;/code&gt; 的线程在干啥了。&lt;/p&gt;
&lt;p&gt;如果你嫌麻烦，我也强烈推荐阿里开源的问题定位神器 &lt;code&gt;arthas&lt;/code&gt; 来定位问题。&lt;/p&gt;
&lt;p&gt;比如上述操作便可精简为一个命令 &lt;code&gt;thread -n 3&lt;/code&gt; 即可将最忙碌的三个线程快照打印出来，非常高效。&lt;/p&gt;
&lt;blockquote readability=&quot;3.9285714285714&quot;&gt;
&lt;p&gt;更多关于 arthas 使用教程请参考&lt;a href=&quot;https://alibaba.github.io/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于之前忘记截图了，这里我直接得出结论吧：&lt;/p&gt;
&lt;p&gt;最忙绿的线程是一个 &lt;code&gt;GC&lt;/code&gt; 线程，也就意味着它在忙着做垃圾回收。&lt;/p&gt;
&lt;h2 id=&quot;gc-查看&quot;&gt;GC 查看&lt;/h2&gt;
&lt;p&gt;排查到这里，有经验的老司机一定会想到：多半是应用内存使用有问题导致的。&lt;/p&gt;
&lt;p&gt;于是我通过 &lt;code&gt;jstat -gcutil pid 200 50&lt;/code&gt; 将内存使用、gc 回收状况打印出来（每隔 200ms 打印 50次）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c3505157663161.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以得到以下几个信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 区和 &lt;code&gt;old&lt;/code&gt; 区都快占满了，可见内存回收是有问题的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fgc&lt;/code&gt; 回收频次很高，10s 之内发生了 8 次回收（&lt;code&gt;(866493-866485)/ (200 *5)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;持续的时间较长，fgc 已经发生了 8W 多次。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;内存分析&quot;&gt;内存分析&lt;/h2&gt;
&lt;p&gt;既然是初步定位是内存问题，所以还是得拿一份内存快照分析才能最终定位到问题。&lt;/p&gt;
&lt;p&gt;通过命令 &lt;code&gt;jmap -dump:live,format=b,file=dump.hprof pid&lt;/code&gt; 可以导出一份快照文件。&lt;/p&gt;
&lt;p&gt;这时就得借助 &lt;code&gt;MAT&lt;/code&gt; 这类的分析工具出马了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c351bb18f94417.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这张图其实很明显可以看出，在内存中存在一个非常大的字符串，而这个字符串正好是被这个定时任务的线程引用着。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c3533538b39583.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概算了一下这个字符串所占的内存为 258m 左右，就一个字符串来说已经是非常大的对象了。&lt;/p&gt;
&lt;p&gt;那这个字符串是咋产生的呢？&lt;/p&gt;
&lt;p&gt;其实看上图中的引用关系及字符串的内容不难看出这是一个 &lt;code&gt;insert&lt;/code&gt; 的 &lt;code&gt;SQL&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;这时不得不赞叹 &lt;code&gt;MAT&lt;/code&gt; 这个工具，他还能帮你预测出这个内存快照可能出现问题地方同时给出线程快照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c353d3d2114320.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c3546d13811049.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终通过这个线程快照找到了具体的业务代码：&lt;/p&gt;
&lt;p&gt;他调用一个写入数据库的方法，而这个方法会拼接一个 &lt;code&gt;insert&lt;/code&gt; 语句，其中的 &lt;code&gt;values&lt;/code&gt; 是循环拼接生成，大概如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;java.util.List&quot;&amp;gt;
        insert into xx (files)
        values
        &amp;lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&amp;gt;
            xxx
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以一旦这个 list 非常大时，这个拼接的 SQL 语句也会很长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/18/5d07c35504bf848706.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过刚才的内存分析其实可以看出这个 &lt;code&gt;List&lt;/code&gt; 也是非常大的，也就导致了最终的这个 &lt;code&gt;insert&lt;/code&gt; 语句占用的内存巨大。&lt;/p&gt;

&lt;p&gt;既然找到问题原因那就好解决了，有两个方向：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制源头 &lt;code&gt;List&lt;/code&gt; 的大小，这个 &lt;code&gt;List&lt;/code&gt; 也是从某张表中获取的数据，可以分页获取；这样后续的 &lt;code&gt;insert&lt;/code&gt; 语句就会减小。&lt;/li&gt;
&lt;li&gt;控制批量写入数据的大小，其实本质还是要把这个拼接的 &lt;code&gt;SQL&lt;/code&gt; 长度降下来。&lt;/li&gt;
&lt;li&gt;整个的写入效率需要重新评估。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次问题从分析到解决花的时间并不长，也还比较典型，其中的过程再总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先定位消耗 &lt;code&gt;CPU&lt;/code&gt; 进程。&lt;/li&gt;
&lt;li&gt;再定位消耗 &lt;code&gt;CPU&lt;/code&gt; 的具体线程。&lt;/li&gt;
&lt;li&gt;内存问题 &lt;code&gt;dump&lt;/code&gt; 出快照进行分析。&lt;/li&gt;
&lt;li&gt;得出结论，调整代码，测试结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后愿大家都别接到生产告警。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 00:18:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前几日早上打开邮箱收到一封监控报警邮件：某某 ip 服务器 CPU 负载较高，请研发尽快排查解决，发送时间正好是凌晨。 其实早在去年我也处理过类似的问题，并记录下来：《一次生产 CPU 100%</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11043109.html</dc:identifier>
</item>
<item>
<title>kubectl技巧之查看资源列表,资源版本和资源schema配置 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11043285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11043285.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在kubernetes里,pod,service,rs,rc,deploy,resource等对象都需要使用yaml文件来创建,很多时候我们都是参照照官方示例或者一些第三方示例来编写yaml文件以创建对象.虽然这些示例很有典型性和代表性,能够满足我们大部分时候的需求,然而这往往还是不够的,根据项目不同,实际配置可能远比官方提供的demo配置复杂的多,这就要求我们除了掌握常用的配置外,还需要对其它配置有所了解.如果有一个文档能够速查某一对象的所有配置,不但方便我们学习不同的配置,也可以做为一个小手册以便我们记不起来某些配置时可以速查.&lt;/p&gt;
&lt;p&gt;下面我们介绍一些小技巧来快速查看kubernetes api&lt;/p&gt;

&lt;p&gt;可以通过命令&lt;code&gt;kubectl api-resources&lt;/code&gt;来查看所有api资源&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl api-resources
NAME                              SHORTNAMES   APIGROUP                       NAMESPACED   KIND
bindings                                                                      true         Binding
componentstatuses                 cs                                          false        ComponentStatus
configmaps                        cm                                          true         ConfigMap
endpoints                         ep                                          true         Endpoints
events                            ev                                          true         Event
limitranges                       limits                                      true         LimitRange
namespaces                        ns                                          false        Namespace
nodes                             no                                          false        Node
persistentvolumeclaims            pvc                                         true         PersistentVolumeClaim
persistentvolumes                 pv                                          false        PersistentVolume
pods                              po                                          true         Pod
podtemplates                                                                  true         PodTemplate
replicationcontrollers            rc                                          true         ReplicationController
resourcequotas                    quota                                       true         ResourceQuota
secrets                                                                       true         Secret
serviceaccounts                   sa                                          true         ServiceAccount
services                          svc                                         true         Service
mutatingwebhookconfigurations                  admissionregistration.k8s.io   false        MutatingWebhookConfiguration
validatingwebhookconfigurations                admissionregistration.k8s.io   false        ValidatingWebhookConfiguration
customresourcedefinitions         crd,crds     apiextensions.k8s.io           false        CustomResourceDefinition
apiservices                                    apiregistration.k8s.io         false        APIService
controllerrevisions                            apps                           true         ControllerRevision
daemonsets                        ds           apps                           true         DaemonSet
deployments                       deploy       apps                           true         Deployment
replicasets                       rs           apps                           true         ReplicaSet
statefulsets                      sts          apps                           true         StatefulSet
tokenreviews                                   authentication.k8s.io          false        TokenReview
localsubjectaccessreviews                      authorization.k8s.io           true         LocalSubjectAccessReview
selfsubjectaccessreviews                       authorization.k8s.io           false        SelfSubjectAccessReview
selfsubjectrulesreviews                        authorization.k8s.io           false        SelfSubjectRulesReview
subjectaccessreviews                           authorization.k8s.io           false        SubjectAccessReview
horizontalpodautoscalers          hpa          autoscaling                    true         HorizontalPodAutoscaler
cronjobs                          cj           batch                          true         CronJob
jobs                                           batch                          true         Job
certificatesigningrequests        csr          certificates.k8s.io            false        CertificateSigningRequest
leases                                         coordination.k8s.io            true         Lease
events                            ev           events.k8s.io                  true         Event
daemonsets                        ds           extensions                     true         DaemonSet
deployments                       deploy       extensions                     true         Deployment
ingresses                         ing          extensions                     true         Ingress
networkpolicies                   netpol       extensions                     true         NetworkPolicy
podsecuritypolicies               psp          extensions                     false        PodSecurityPolicy
replicasets                       rs           extensions                     true         ReplicaSet
networkpolicies                   netpol       networking.k8s.io              true         NetworkPolicy
poddisruptionbudgets              pdb          policy                         true         PodDisruptionBudget
podsecuritypolicies               psp          policy                         false        PodSecurityPolicy
clusterrolebindings                            rbac.authorization.k8s.io      false        ClusterRoleBinding
clusterroles                                   rbac.authorization.k8s.io      false        ClusterRole
rolebindings                                   rbac.authorization.k8s.io      true         RoleBinding
roles                                          rbac.authorization.k8s.io      true         Role
priorityclasses                   pc           scheduling.k8s.io              false        PriorityClass
storageclasses                    sc           storage.k8s.io                 false        StorageClass
volumeattachments                              storage.k8s.io                 false        VolumeAttachment
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了可以看到资源的对象名称外,还可以看到对象的别名,这时候我们再看到别人的命令如&lt;code&gt;kubectl get no&lt;/code&gt;这样费解的命令时就可以知道它实际上代表的是&lt;code&gt;kubectl get nodes&lt;/code&gt;命令&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;查看api的版本,很多yaml配置里都需要指定配置的资源版本,我们经常看到v1,beta1,beta2这样的配置,到底某个资源的最新版本是什么呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实,可以通过&lt;code&gt;kubectl api-versions&lt;/code&gt;来查看api的版本&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl api-versions
admissionregistration.k8s.io/v1beta1
apiextensions.k8s.io/v1beta1
apiregistration.k8s.io/v1
apiregistration.k8s.io/v1beta1
apps/v1
apps/v1beta1
apps/v1beta2
authentication.k8s.io/v1
authentication.k8s.io/v1beta1
authorization.k8s.io/v1
authorization.k8s.io/v1beta1
autoscaling/v1
autoscaling/v2beta1
autoscaling/v2beta2
batch/v1
batch/v1beta1
certificates.k8s.io/v1beta1
coordination.k8s.io/v1beta1
events.k8s.io/v1beta1
extensions/v1beta1
networking.k8s.io/v1
policy/v1beta1
rbac.authorization.k8s.io/v1
rbac.authorization.k8s.io/v1beta1
scheduling.k8s.io/v1beta1
storage.k8s.io/v1
storage.k8s.io/v1beta1
v1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上只是整体概况,很多时候我们还想要看到某个api下面都有哪些配置,某一荐配置的含义等,下面罗列一些常用的api范例和一些查看api的技巧&lt;/p&gt;
&lt;h2 id=&quot;常见范例&quot;&gt;常见范例&lt;/h2&gt;
&lt;h2 id=&quot;通过kubectl-explain查看api字段&quot;&gt;通过kubectl explain查看api字段&lt;/h2&gt;
&lt;p&gt;1) 通过&lt;code&gt;kubectl explain &amp;lt;资源名对象名&amp;gt;&lt;/code&gt;查看资源对象拥有的字段&lt;/p&gt;
&lt;p&gt;前面说过,可以通过&lt;code&gt;kubectl api-resources&lt;/code&gt;来查看资源名称,如果想要查看某个资源的字段,可以通过&lt;code&gt;kubectl explain &amp;lt;资源名对象名&amp;gt;&lt;/code&gt;来查点它都有哪些字段&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl explain pod
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion   &amp;lt;string&amp;gt;
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#resources

   kind &amp;lt;string&amp;gt;
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds

   metadata     &amp;lt;Object&amp;gt;
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata

   spec &amp;lt;Object&amp;gt;
     Specification of the desired behavior of the pod. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status

   status       &amp;lt;Object&amp;gt;
     Most recently observed status of the pod. This data may not be up to date.
     Populated by the system. Read-only. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status

[centos@k8s-master ~]$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上Description是对资源对象的简要描述,&lt;code&gt;Fields&lt;/code&gt;则是对所有字段的描述&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;列出所有api字段&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;通过以上我们能感觉到,以上好像并没有罗列出所有的api字段,实际上以上列出的仅是一级字段,一级字段可能还包含二级的,三级的字段,想要罗列出所有的字段,可以加上&lt;code&gt;--recursive&lt;/code&gt;来列出所有可能的字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl explain svc --recursive
KIND:     Service
VERSION:  v1

DESCRIPTION:
     Service is a named abstraction of software service (for example, mysql)
     consisting of local port (for example 3306) that the proxy listens on, and
     the selector that determines which pods will answer requests sent through
     the proxy.

FIELDS:
   apiVersion   &amp;lt;string&amp;gt;
   kind &amp;lt;string&amp;gt;
   metadata     &amp;lt;Object&amp;gt;
      annotations       &amp;lt;map[string]string&amp;gt;
      clusterName       &amp;lt;string&amp;gt;
      creationTimestamp &amp;lt;string&amp;gt;
      deletionGracePeriodSeconds        &amp;lt;integer&amp;gt;
      deletionTimestamp &amp;lt;string&amp;gt;
      finalizers        &amp;lt;[]string&amp;gt;
      generateName      &amp;lt;string&amp;gt;
      generation        &amp;lt;integer&amp;gt;
      initializers      &amp;lt;Object&amp;gt;
         pending        &amp;lt;[]Object&amp;gt;
            name        &amp;lt;string&amp;gt;
         result &amp;lt;Object&amp;gt;
            apiVersion  &amp;lt;string&amp;gt;
            code        &amp;lt;integer&amp;gt;
            details     &amp;lt;Object&amp;gt;
               causes   &amp;lt;[]Object&amp;gt;
                  field &amp;lt;string&amp;gt;
                  message       &amp;lt;string&amp;gt;
                  reason        &amp;lt;string&amp;gt;
               group    &amp;lt;string&amp;gt;
               kind     &amp;lt;string&amp;gt;
               name     &amp;lt;string&amp;gt;
               retryAfterSeconds        &amp;lt;integer&amp;gt;
               uid      &amp;lt;string&amp;gt;
            kind        &amp;lt;string&amp;gt;
            message     &amp;lt;string&amp;gt;
            metadata    &amp;lt;Object&amp;gt;
               continue &amp;lt;string&amp;gt;
               resourceVersion  &amp;lt;string&amp;gt;
               selfLink &amp;lt;string&amp;gt;
            reason      &amp;lt;string&amp;gt;
            status      &amp;lt;string&amp;gt;
      labels    &amp;lt;map[string]string&amp;gt;
      name      &amp;lt;string&amp;gt;
      namespace &amp;lt;string&amp;gt;
      ownerReferences   &amp;lt;[]Object&amp;gt;
         apiVersion     &amp;lt;string&amp;gt;
         blockOwnerDeletion     &amp;lt;boolean&amp;gt;
         controller     &amp;lt;boolean&amp;gt;
         kind   &amp;lt;string&amp;gt;
         name   &amp;lt;string&amp;gt;
         uid    &amp;lt;string&amp;gt;
      resourceVersion   &amp;lt;string&amp;gt;
      selfLink  &amp;lt;string&amp;gt;
      uid       &amp;lt;string&amp;gt;
   spec &amp;lt;Object&amp;gt;
      clusterIP &amp;lt;string&amp;gt;
      externalIPs       &amp;lt;[]string&amp;gt;
      externalName      &amp;lt;string&amp;gt;
      externalTrafficPolicy     &amp;lt;string&amp;gt;
      healthCheckNodePort       &amp;lt;integer&amp;gt;
      loadBalancerIP    &amp;lt;string&amp;gt;
      loadBalancerSourceRanges  &amp;lt;[]string&amp;gt;
      ports     &amp;lt;[]Object&amp;gt;
         name   &amp;lt;string&amp;gt;
         nodePort       &amp;lt;integer&amp;gt;
         port   &amp;lt;integer&amp;gt;
         protocol       &amp;lt;string&amp;gt;
         targetPort     &amp;lt;string&amp;gt;
      publishNotReadyAddresses  &amp;lt;boolean&amp;gt;
      selector  &amp;lt;map[string]string&amp;gt;
      sessionAffinity   &amp;lt;string&amp;gt;
      sessionAffinityConfig     &amp;lt;Object&amp;gt;
         clientIP       &amp;lt;Object&amp;gt;
            timeoutSeconds      &amp;lt;integer&amp;gt;
      type      &amp;lt;string&amp;gt;
   status       &amp;lt;Object&amp;gt;
      loadBalancer      &amp;lt;Object&amp;gt;
         ingress        &amp;lt;[]Object&amp;gt;
            hostname    &amp;lt;string&amp;gt;
            ip  &amp;lt;string&amp;gt;
[centos@k8s-master ~]$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上输出的内容是经过格式化了的,我们可以根据缩进很容易看到某一个字段从属于关系&lt;/p&gt;
&lt;h3 id=&quot;查看具体字段&quot;&gt;查看具体字段&lt;/h3&gt;
&lt;p&gt;通过上面&lt;code&gt;kubectl explain service --recursive&lt;/code&gt;可以看到所有的api名称,但是以上仅仅是罗列了所有的api名称,如果想要知道某一个api名称的详细信息,则可以通过&lt;code&gt;kubectl explain &amp;lt;资源对象名称.api名称&amp;gt;&lt;/code&gt;的方式来查看,比如以下示例可以查看到&lt;code&gt;service&lt;/code&gt;下的&lt;code&gt;spec&lt;/code&gt;下的&lt;code&gt;ports&lt;/code&gt;字段的信息&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl explain svc.spec.ports
KIND:     Service
VERSION:  v1

RESOURCE: ports &amp;lt;[]Object&amp;gt;

DESCRIPTION:
     The list of ports that are exposed by this service. More info:
     https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies

     ServicePort contains information on service's port.

FIELDS:
   name &amp;lt;string&amp;gt;
     The name of this port within the service. This must be a DNS_LABEL. All
     ports within a ServiceSpec must have unique names. This maps to the 'Name'
     field in EndpointPort objects. Optional if only one ServicePort is defined
     on this service.

   nodePort     &amp;lt;integer&amp;gt;
     The port on each node on which this service is exposed when type=NodePort
     or LoadBalancer. Usually assigned by the system. If specified, it will be
     allocated to the service if unused or else creation of the service will
     fail. Default is to auto-allocate a port if the ServiceType of this Service
     requires one. More info:
     https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport

   port &amp;lt;integer&amp;gt; -required-
     The port that will be exposed by this service.

   protocol     &amp;lt;string&amp;gt;
     The IP protocol for this port. Supports &quot;TCP&quot;, &quot;UDP&quot;, and &quot;SCTP&quot;. Default
     is TCP.

   targetPort   &amp;lt;string&amp;gt;
     Number or name of the port to access on the pods targeted by the service.
     Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If
     this is a string, it will be looked up as a named port in the target Pod's
     container ports. If this is not specified, the value of the 'port' field is
     used (an identity map). This field is ignored for services with
     clusterIP=None, and should be omitted or set equal to the 'port' field.
     More info:
     https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Jun 2019 00:07:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 在kubernetes里,pod,service,rs,rc,deploy,resource等对象都需要使用yaml文件来创建,很多时候我们都是参照照官方示例或者一些第三方示例来编写ya</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11043285.html</dc:identifier>
</item>
<item>
<title>用番茄工作法提升工作效率 （二）用番茄钟实现劳逸结合（简单到不可相信） - siwei718</title>
<link>http://www.cnblogs.com/siweihz/p/11043251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siweihz/p/11043251.html</guid>
<description>&lt;p&gt;一、缘起&lt;/p&gt;
&lt;p&gt;上一篇“&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/siweihz/p/11038407.html&quot;&gt;用番茄工作法提升工作效率 （一）关于任务清单（含工具代码分享）&lt;/a&gt;”，介绍了我通过C#实现的一个桌面工作任务清单。&lt;/p&gt;
&lt;p&gt;该工具通过将“当天”的工作任务分解为工作项，按照紧迫和重要程度，放入不同的列表中实现任务管理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于已经完成的工作项，或者本周需要完成的工作项未作说明。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;二、简单原理&lt;/p&gt;
&lt;p&gt;大家从小学、初中、高中一路走来，我们知道每节课45分钟（小学每节课时间可能稍微不同），然后休息10分钟。&lt;/p&gt;
&lt;p&gt;这就是番茄工作法的一个应用。&lt;/p&gt;
&lt;p&gt;同样，我们在工作中也可以采用“工作”、“休息”，“工作”、“休息”......，每工作一定的时间，起来休息然后继续工作。&lt;/p&gt;
&lt;p&gt;在工作的过程中，尽量保持专注，不接受打扰。&lt;/p&gt;
&lt;p&gt;工作的时间因人而异，一般30分钟比较合适（这需要将复杂工作内容，分解为适当规模的工作项）；然后休息10分钟，可以起来运动、喝水、去洗手间等...&lt;/p&gt;
&lt;p&gt;三、工具和方法&lt;/p&gt;
&lt;p&gt;工具非常简单，就是“番茄钟”，可以用手机上的时钟。&lt;/p&gt;
&lt;p&gt;我用的是Win10系统，在搜索框中输入“闹钟”，点击“闹钟和时钟”即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190618063513226-795927678.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190618063654027-1231037700.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;482&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 切换到“计时器”，选择右下角的“+号”，输入“番茄工作法-工作”，时间修改到30分钟。&lt;/p&gt;
&lt;p&gt;同样的方法，建立“番茄工作法-休息”，选择5分钟。&lt;/p&gt;
&lt;p&gt;在我们开始一项工作的时候，点击开始，时间到了会提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190618064042732-312940800.png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在我们起身休息的时候，点击“番茄工作法-休息”，时间到了就回来继续工作。&lt;/p&gt;
&lt;p&gt;四、可能存在的问题&lt;/p&gt;
&lt;p&gt;1. 如果一个工作项未完成，这时该休息，还是继续工作？&lt;/p&gt;
&lt;p&gt;    未完成，说明工作项分解的粒度不够，建议休息。&lt;/p&gt;
&lt;p&gt; 2. 工作未完成，时间到了，是不是反而打扰了工作，影响了效率？&lt;/p&gt;
&lt;p&gt;   休息为了更好的工作，长期看会提示效率。&lt;/p&gt;
&lt;p&gt;3. 该方法有效吗？&lt;/p&gt;
&lt;p&gt;    尝试一两次，效果并不明显。&lt;/p&gt;
&lt;p&gt;    就像java开发，工具从eclipse转到idea，开始的时候工作效率反而是下降的。&lt;/p&gt;
&lt;p&gt;    等到用顺手，变成习惯，才会提升效率。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Jun 2019 23:26:00 +0000</pubDate>
<dc:creator>siwei718</dc:creator>
<og:description>一、缘起 上一篇“用番茄工作法提升工作效率 （一）关于任务清单（含工具代码分享）”，介绍了我通过C#实现的一个桌面工作任务清单。 该工具通过将“当天”的工作任务分解为工作项，按照紧迫和重要程度，放入不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/siweihz/p/11043251.html</dc:identifier>
</item>
<item>
<title>一个理想主义的程序员 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11043257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11043257.html</guid>
<description>&lt;h3 id=&quot;h01&quot;&gt;01、&lt;/h3&gt;
&lt;p&gt;9 年前，我从象牙塔里走出来，正式踏入社会，懵懵懂懂地在一家日企开始了职业生涯。那时候，技术功底非常差，因为在学校的时候每天就一副吊儿郎当的样子，编程自然也没有好好学。&lt;/p&gt;
&lt;p&gt;和我同一时间入职的新人有 19 个，大家都怀着一颗敬畏的心，因为生怕自己被淘汰出局。毕竟是实习期，如果工作表现不符合预期的话，是直接被辞退的，没有任何补偿。&lt;/p&gt;
&lt;p&gt;所以在签正式的劳务合同之前，每天都紧张兮兮的。记得有一次，领导说我笔试的成绩非常差，可能会被辞退，晚上躺着宿舍的床上辗转反侧，想着第二天被辞退后茫然不知所措的样子，那叫一个沮丧啊。&lt;/p&gt;
&lt;p&gt;惊险的是，领导认为我笔试差，是因为没有看到我答在背面的答案——还是领导的领导当着我的面提醒了领导，那一幕至今记忆犹新。&lt;/p&gt;
&lt;p&gt;初入社会的我，性格内向、沉默寡言，操着一口只有自己才能听得懂的“普通话”，之所以能留存到最后（我们那批人被辞退了 10 个），靠的就是——日渐过硬的技术。&lt;/p&gt;
&lt;p&gt;其实，&lt;strong&gt;程序员这行业，入门是比较难的，需要你十足的勇气，和被 bug 无数次吞噬后仍然不折不挠的坚持&lt;/strong&gt;。一旦你入了门，还肯花时间去读理论知识，敲代码实战的话，成长是肉眼可见的——我就感觉实习的那一个月，进步神速。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、&lt;/h3&gt;
&lt;p&gt;兢兢业业工作了两年半后，我被提升为一名 Team Leader，负责技术攻坚、新人培训，以及代码 Review。&lt;/p&gt;
&lt;p&gt;Team Leader 恐怕是一个最小的管理职位了，但毕竟是一个管理职位啊。你得参加各种会议，写各种培训资料，这都好应付，难应付的是，你得向领导汇报成员的工作表现，以及要和成员“打成一片，鼻青脸肿”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做管理前，你所有的重心就只有代码&lt;/strong&gt;，你把代码写得完善了、优雅了，再把难点攻破了，bug 解决了，就能赢得领导的信赖，就能拿到匹配的薪资。&lt;/p&gt;
&lt;p&gt;但做管理后，就不太一样了。与人打交道是一件很复杂、很耗时间和精力的事，还有可能会出力不讨好。&lt;/p&gt;
&lt;p&gt;为什么这么说呢？&lt;/p&gt;
&lt;p&gt;每次聚会上，你得带领小伙伴们去给领导敬酒啊、奉承啊——这是一件极其难为情的事！很多程序员不喜欢这一套，我也不喜欢，但总有人喜欢你这样做。&lt;/p&gt;
&lt;p&gt;你不去做的话，某些领导可能就要给你上上课，教育一下了，批评你不通情达理，不知道人情世故，以后要多学着点，最后不忘加上一句：“不然的话，你的上升空间就很有限了。”&lt;/p&gt;
&lt;p&gt;这可比单纯做技术难多了——不能纯粹地做一名理想主义的程序员，这不是我的初衷。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;03、&lt;/h3&gt;
&lt;p&gt;5 年前，我回到了洛阳，在一家迷你型的公司做开发——没有人需要你管理，唯一需要管理的就只有自己。&lt;/p&gt;
&lt;p&gt;所以，我的重心又回到了代码上，人也变得轻松了起来。&lt;/p&gt;
&lt;p&gt;我每天有了大把的时间去钻研技术，甚至还能够在 ITeye、CSDN 上写博客，甭管开始的时候写得有多差，总会时不时有读者留言说：“谢谢博主啊，你的分享解决了我的问题。”&lt;/p&gt;
&lt;p&gt;那时候，也没有“知识付费”的概念，单纯就是为了分享，把自己在技术上遇到的坑、填的坑像记流水账一样记下来——这种状态让我内心非常地踏实。&lt;/p&gt;
&lt;p&gt;一般情况下，工作了三五年的程序员，都会面临一种选择，要不要转型做管理呢？&lt;/p&gt;
&lt;p&gt;个人拙见是，有机会的话就尝试做——技而优则仕嘛。毕竟做了管理就能够拿到更多的话语权，有了话语权就能够做更多的事，也就是所谓的大展宏图。&lt;/p&gt;
&lt;p&gt;崇尚技术的程序员可能会比较崇拜比尔·盖茨，因为盖茨的技术功底有目共睹。创办微软赋予了他更多的权力，也就有了创造神话的可能性——个人电脑真的“飞入了寻常百姓家”。&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;假如不适合管理岗的话，还是要尽早退出，不要陷入办公室政治斗争的泥沼中&lt;/strong&gt;。大丈夫要能屈能伸嘛，安心做技术、做开源，没准会开辟一片新的天地。&lt;/p&gt;
&lt;p&gt;借此机会，厚着脸皮再吹嘘一下自己。你看我，回洛阳之前，还是一名“富有权力”的 Team Leader；回洛阳之后，丧失了继续在管理岗上晋升的机会，但真的开辟了一片新的天地。&lt;/p&gt;
&lt;p&gt;首先，出版了一本技术书籍，把积累的经验和知识分享给了初学者，还能顺便挣点版税。&lt;/p&gt;
&lt;p&gt;其次，靠着不断地分享原创文章，在互联网上积攒了一些名气，读者乐于和我交流；更多的机会也随着而来——再光明正大地声明一下，有项目做不完的甲方，请过来找我。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、&lt;/h3&gt;
&lt;p&gt;我生于八九年，算是赶上了八零后的末班车。八零后成长的三十多年，是我们国家疯狂造富的三十多年，经济增长的速度能维持在 10% 左右，是绝对的奇迹。&lt;/p&gt;
&lt;p&gt;经济之所以如此迅猛地发展，一方面是因为我们的起点低，另一方面在于我们对未来的乐观主义——我们不断地拥抱世界，拿来的同时默默地努力着、奋斗着、改善着。&lt;/p&gt;
&lt;p&gt;我们程序员是幸运的，赶上了经济发展的浪潮。并且互联网的世界是开放的、包容的，所以我们不必深谙人事、逼迫自己陷入办公室政治的泥沼中也能体面的生存。&lt;/p&gt;
&lt;p&gt;可能有人会说，“35 岁是程序员的年龄天花板，你能写多长时间的代码，要未雨绸缪”。但我想表达的是，&lt;strong&gt;作为一名正儿八经的程序员，我想做一名纯粹的理想主义者，每天敲敲代码，活在程序的世界里&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;到底理想主义的程序员是什么样子呢？&lt;/p&gt;
&lt;p&gt;他首先是一个单纯快乐的手艺人，其次有着天真烂漫的好奇心，最后还乐于分享。他不想被管理，也不太想去管理别人，一旦需求来了，他就会立马全情投入，直到交付一个至善的产品。&lt;/p&gt;
&lt;p&gt;那怎样才能做一名理想主义的程序员呢？&lt;/p&gt;
&lt;p&gt;1）保持专注，别总去想卖个肉夹馍发点额外的财。&lt;/p&gt;
&lt;p&gt;2）善于思考，面对一个 bug 的时候，不急躁，不慌张，能够从容地思考 bug 背后发生的原因。&lt;/p&gt;
&lt;p&gt;3）富有自我驱动力，哪怕刚入职的时候工资很低，依然能够全身心地投入，不被外界因素干扰，直到把自己锤炼成不可或缺。&lt;/p&gt;
&lt;p&gt;4）不找借口，敢于承担责任。&lt;/p&gt;
&lt;p&gt;5）善于管理时间，人这一辈子，最缺的不是金钱，而是时间。&lt;/p&gt;
&lt;p&gt;那程序员的理想到底应该是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我希望未来有一天，因为我的代码，让这个世界上的一些人生活的更便利，感觉到一点点幸福或愉悦。不管这些人多还是少。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 17 Jun 2019 23:10:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、 9 年前，我从象牙塔里走出来，正式踏入社会，懵懵懂懂地在一家日企开始了职业生涯。那时候，技术功底非常差，因为在学校的时候每天就一副吊儿郎当的样子，编程自然也没有好好学。 和我同一时间入职的新人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11043257.html</dc:identifier>
</item>
<item>
<title>重写类加载器，实现简单的热替换 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11028613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11028613.html</guid>
<description>&lt;p&gt;我这边的测试路径为：/home/test， MyClassLoader.java已经编译&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost test]# &lt;span&gt;pwd&lt;/span&gt;
/home/&lt;span&gt;test
[root@localhost test]# ll MyClassLoader.&lt;/span&gt;*
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1175&lt;/span&gt; Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; MyClassLoader.class
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1242&lt;/span&gt; Jun &lt;span&gt;13&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; MyClassLoader.java
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我的工程2 的代码放在另一个目录下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost test-reload]# &lt;span&gt;pwd&lt;/span&gt;
/home/test/test-&lt;span&gt;reload
[root@localhost test&lt;/span&gt;-&lt;span&gt;reload]# ll
total &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1464&lt;/span&gt; Jun &lt;span&gt;15&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt;&lt;span&gt; MyClassLoader.class
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1458&lt;/span&gt; Jun &lt;span&gt;15&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt;&lt;span&gt; MyClassLoader.java
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;511&lt;/span&gt; Jun &lt;span&gt;15&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt; ReloadMainTest$&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.class
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1531&lt;/span&gt; Jun &lt;span&gt;15&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt;&lt;span&gt; ReloadMainTest.class
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1218&lt;/span&gt; Jun &lt;span&gt;15&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;52&lt;/span&gt; ReloadMainTest.java
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行 java ReloadMainTest，启动测试类，就会每个3s，执行 TestSample 的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615190831461-1679773831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时，我们在另一个窗口中，去修改 TestSample.java，并重新编译之：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615191008373-1822503141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时，我们切回原窗口，可以发现输出发生了变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615191119724-667727114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、测试进阶&lt;/h2&gt;
&lt;p&gt;这里要介绍一个工具，阿里开源的arthas。 （&lt;a href=&quot;https://alibaba.github.io/arthas/en/install-detail.html&quot; target=&quot;_blank&quot;&gt;https://alibaba.github.io/arthas/en/install-detail.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;这款工具，功能很强，下图是其简单介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615191501247-1953347190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里，我打算使用其 类搜索功能，通过搜索  TestSample 类，来查看该类是从哪个类加载器加载而来，使用方式极其简单，直接java 启动 arthas，然后选择要attach的java 应用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@localhost test]# &lt;span&gt;java -jar arthas-&lt;/span&gt;&lt;span&gt;&lt;span&gt;boot.jar&lt;/span&gt; 
[INFO] arthas&lt;/span&gt;-boot version: &lt;span&gt;3.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[INFO] Found existing java process, please choose one and hit RETURN.
&lt;/span&gt;* [&lt;span&gt;1&lt;/span&gt;]: &lt;span&gt;10100&lt;/span&gt;&lt;span&gt; org.apache.catalina.startup.Bootstrap
  [&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]: &lt;span&gt;25517&lt;/span&gt;&lt;span&gt; ReloadMainTest
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[INFO] arthas home: &lt;/span&gt;/root/.arthas/lib/&lt;span&gt;3.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;arthas
[INFO] Try to attach process &lt;/span&gt;&lt;span&gt;25517&lt;/span&gt;&lt;span&gt;
[INFO] Attach process &lt;/span&gt;&lt;span&gt;25517&lt;/span&gt;&lt;span&gt; success.
[INFO] arthas&lt;/span&gt;-client connect &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;3658&lt;/span&gt;&lt;span&gt;
  ,&lt;/span&gt;---.  ,------. ,--------.,--.  ,--.  ,---.   ,---&lt;span&gt;.                           
 &lt;/span&gt;/  O  \ |  .--. &lt;span&gt;''&lt;/span&gt;--.  .--&lt;span&gt;'&lt;/span&gt;&lt;span&gt;|  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;--&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  | /  O  \ &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   .-&lt;span&gt;'&lt;/span&gt;                          
|  .-.  ||  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   |  |   |  .--.  ||  .-.  |`.  `-.                          &lt;/span&gt;
|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;    |                         &lt;/span&gt;
`--&lt;span&gt;'&lt;/span&gt;&lt;span&gt; `--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;`--&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;--&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   `--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   `--&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  `--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;`--&lt;span&gt;'&lt;/span&gt;&lt;span&gt; `--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;`-----&lt;span&gt;'&lt;/span&gt;                          
&lt;span&gt;                                                                                

wiki      https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alibaba.github.io/arthas                                      &lt;/span&gt;
tutorials https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alibaba.github.io/arthas/arthas-tutorials                     &lt;/span&gt;
version   &lt;span&gt;3.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                                                                 
pid       &lt;/span&gt;&lt;span&gt;25517&lt;/span&gt;                                                                 
&lt;span&gt;time&lt;/span&gt;      &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们搜索下TestSample类，（直接输入：sc -df TestSample）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615191931754-465144672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;是不是看到类加载器了，但这只是我截了一部分的图而已，这个命令会把 当前java进程中所有的匹配这个类的都搜出来。我们看看到底搜出来多少：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615192127650-850141441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里显示了，一共有9行，也就是说，在我们的定时器线程的不断运行下，每隔3s就用一个新的类加载器去加载 TestSample，目前java 进程中，已经有9个 TestSample 类了。&lt;/p&gt;
&lt;p&gt;多个同名类，（但不同类加载器），会不会有问题？按理说应该不会，因为假设另一个类B引用该类，那么类B默认就会用它自己的类加载器来加载该类，按理说，是加载不到的，直接就报错了。（存疑。。。）&lt;/p&gt;

&lt;p&gt;说回来（实在是编不下去了。。），这里我们的 ReloadMainTest，都是 把一个classloader 用完即弃，包括 该classloader 加载的类，以及用加载的类new出来的对象，都是在一个方法内，属于局部变量，跑完一次循环，就没人持有他们的引用了。&lt;/p&gt;
&lt;p&gt;但是，为什么我们还看到有9个类存在呢？ 这个主要还是因为，class 相关的数据都是存放在 永久代，永久代平时一般不进行垃圾回收，所以我们才能看到那些废弃类的尸体。我们可以试试调用垃圾回收，通过jmap就可以触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost test]# jmap -dump:live,format=b,&lt;span&gt;file&lt;/span&gt;=heap23.bin  &lt;span&gt;25517&lt;/span&gt;&lt;span&gt;
Dumping heap to &lt;/span&gt;/home/test/&lt;span&gt;heap23.bin ...
Heap dump &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时再看类的数量，是不是变了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615193317190-1220377642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这篇简单介绍了如何进行类的热替换。这里的热替换，建立在这样的基础上：我们加载了新的class，然后new了对象，调用了对象的方法后，整个过程就结束了，没涉及到和其他类的交互。正因为如此，新生成的对象没有被任何地方引用，所以可以进行垃圾回收；对象被回收后，perm区的class对象也就可以进行回收了，于是，classloader也没被任何地方引用，也可以进行回收，所以最后的那个测试才能出现上述的结果（即：jmap触发full gc后，TestSample的数量变回1）。&lt;/p&gt;
&lt;p&gt;客观来说，暂时还没发现在真实环境里能发挥出什么作用，但是作为学习案例，是够了的。为什么在真实环境没用（比如 java web项目），在这类项目中，应用被打成一个war包（jar包的spring boot方式还没研究内部的类加载器结构，不能乱说），应用的WEB-INF下的classes和lib目录下的 jar 包，都是由同一个类加载器（也就是webappclassloader）加载。如果要替换的话，只能整个 webappclassloader 全部换掉才可能。能不能单独换一个类呢，我感觉是不行的，假设 ControllerA 里面引用了 AService，AServiceImpl实现AService，你说我现在想换掉 AServiceImpl，假设我们重新用自定义的类加载器 去某个位置加载 了新的 AServiceImpl ，那么我们要怎么才能让 AService 引用到这个新的 实现类呢？ 且不说这二者由不同的类加载器加载，其次，还得把之前的旧的实现的被别处引用的地方给换掉。。。想想还是很不好搞。。。&lt;/p&gt;
&lt;p&gt;这里预告一下，下一篇会是一个黑科技，尤其是对java web、java 后台开发人员而言，主要是给后台程序开个后门，执行我们的任意代码，在程序不重启的情况下进行调试、全局参数查看、方法执行等，给同事们演示了一下，效果还是很不错的。&lt;/p&gt;


</description>
<pubDate>Mon, 17 Jun 2019 15:49:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>一、前言 关于类加载器，前面写了三篇，这篇是第四篇。 实战分析Tomcat的类加载器结构（使用Eclipse MAT验证） 还是Tomcat，关于类加载器的趣味实验 了不得，我可能发现了Jar 包冲突</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11028613.html</dc:identifier>
</item>
<item>
<title>Java核心技术梳理-IO - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/11042873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/11042873.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IO（输入/输出），输入是指允许程序读取外部数据（包括来自磁盘、光盘等存储设备的数据）、用户输入数据。输出是指允许程序记录运行状态，将程序数据输出到磁盘、光盘等存储设备中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;IO的主要内容包括输入、输出两种IO流，这两种流中又分为字节流和字符流，字节流是以字节为单位来处理输入、输出流，而字符流是以字符为单位来处理输入、输出流。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;File 类&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;File 类是用来操作文件和目录的，File能创建、删除、重命名文件和目录，File不能访问文件内容本身，File 类可以通过文件路径字符串来创建对象，创建完对象之后有很多方法来操作文件和目录：&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.1 构造方法&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;File(String pathname)：根据一个路径得到File对象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;File(String parent, String child):根据一个目录和一个子文件/目录得到File对象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;2.2 创建方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在当前路径来创建一个File对象&lt;/span&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;1.txt&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件&lt;/span&gt;
&lt;span&gt;System.out.println(file.createNewFile());
File file2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;temp&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对象对应的目录&lt;/span&gt;
System.out.println(file2.mkdir());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.3 重命名和删除功能&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把文件重命名为指定的文件路径&lt;/span&gt;
file2.renameTo(&lt;span&gt;new&lt;/span&gt; File(&quot;temp2&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除文件或者文件夹&lt;/span&gt;
file2.delete();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;注：重命名中如果路径名相同，就是改名，如果路径名不同，就是改名并剪切。删除不走回收站，要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹。&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.4 判断功能&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断文件或目录是否存在&lt;/span&gt;
&lt;span&gt;System.out.println(file.exists());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是文件&lt;/span&gt;
&lt;span&gt;System.out.println(file.isFile());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是目录&lt;/span&gt;
&lt;span&gt;System.out.println(file.isDirectory());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否为绝对路径&lt;/span&gt;
&lt;span&gt;System.out.println(file.isAbsolute());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件或目录是否可读&lt;/span&gt;
&lt;span&gt;System.out.println(file.canRead());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件或目录是否可写&lt;/span&gt;
System.out.println(file.canWrite());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.5 获取功能&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件内容长度&lt;/span&gt;
&lt;span&gt;System.out.println(file.length());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件或目录名&lt;/span&gt;
&lt;span&gt;System.out.println(file.getName());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件或目录相对路径&lt;/span&gt;
&lt;span&gt;System.out.println(file.getPath());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件或目录绝对路径&lt;/span&gt;
&lt;span&gt;System.out.println(file.getAbsolutePath());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取上一级路径&lt;/span&gt;
&lt;span&gt;System.out.println(file.getAbsoluteFile().getParent());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前目录的子目录或文件的名称&lt;/span&gt;
String[] list =&lt;span&gt; file1.list();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String fileName : list) {
    System.out.println(fileName);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前目录的子目录或文件，返回的是File数组&lt;/span&gt;
File[] files =&lt;span&gt; file1.listFiles();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回系统的所有根路径&lt;/span&gt;
File[] listRoots =&lt;span&gt; File.listRoots();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File root : listRoots) {
    System.out.println(root);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;IO 流&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;实现输入/输出的基础是IO流，Java把不同的源之间的数据交互抽象表达为流，通过流的方式允许Java程序使用相同的方式来访问不同的数据源。用于操作流的类都在IO包中。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 流的分类&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照不同的分类方式，流也可以分为不同类型&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;输入流和输出流：根据流向来分，可以分为输入流与输出流&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字节流和字符流：这两种流用法几乎完全一样，区别在于所操作的数据单元不一样，字节流操作的数据单元是8位的字节，而字符流是16位的字符。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.2 InputStream与Reader&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;InputStream和Reader是所有输入流的抽象基类，这是输入流的模板，InputStream中有三个方法&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read() ：从输入流读取单个字节，返回所读取的字节数据。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(byte b[])：从输入流中最多读取b.length个字节的数据，并将其存储在数组b中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(byte b[], int off, int len)：从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入的位置是从off中开始。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Reader中也有三个方法&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read() ：从输入流读取单个字节，返回所读取的字节数据。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(char cbuf[])：从输入流中最多读取cbuf.length个字符的数据，并将其存储在数组cbuf中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;int read(byte cbuf[], int off, int len)：从输入流中最多读取len个字节的数据，并将其存储在数组cbuf中，放入的位置是从off中开始。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;两个类的方法基本相同，用法相同，只是操作单位不一样&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;InputStream inputStream = new FileInputStream(&quot;StreamTest.java&quot;);&lt;br/&gt;byte[] bytes = new byte[1024];&lt;br/&gt;int hasRead = 0;&lt;br/&gt;while ((hasRead = inputStream.read(bytes)) &amp;gt; 0) {&lt;br/&gt;System.out.println(new String(bytes, 0, hasRead));&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;inputStream.close();&lt;/p&gt;
&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.3 OutputStream与Writer&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;OutputStream与Writer是所有输出流的抽象基类，是输出流模板，OutputStream有三个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(int b)：指定字节输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(byte b[])：将指定字节数组输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(byte b[], int off, int len)：将指定字节数组从off位置到len长度输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Writer中也有三个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(int b)：指定字符输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(char buf[])：将指定字节数组输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(char cubf[], int off, int len)：将指定字节数组从off位置到len长度输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;由于Writer是以字符为单位进行操作，那可以使用String 来代替，于是有另外的方法&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void write(String str)：将str字符串输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;void write(String str, int off, int len)：将str从off位置开始长度为len输出到流中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FileWriter fileWriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;test.txt&quot;&lt;span&gt;);
fileWriter.write(&lt;/span&gt;&quot;日照香炉生紫烟\r\n&quot;&lt;span&gt;);
fileWriter.write(&lt;/span&gt;&quot;遥看瀑布挂前川\r\n&quot;&lt;span&gt;);
fileWriter.write(&lt;/span&gt;&quot;飞流直下三千尺\r\n&quot;&lt;span&gt;);
fileWriter.write(&lt;/span&gt;&quot;遥看瀑布挂前川\r\n&quot;&lt;span&gt;);
fileWriter.close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注：操作流时一定要记得关闭流，因为打开的IO资源不属于内存资源，垃圾回收无法回收。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;输入/输出流体系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;Java的输入输出流提供了40多个类，要全部都记住很困难也没有必要，我们可以按照功能进行下分类，其实是非常有规律的&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span md-focus&quot;&gt;分类&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;字节输入流&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;字节输出流&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;字符输入流&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;字符输出流&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;抽象基类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;InputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;OutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;Reader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;Writer&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;访问文件&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FileInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FileOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FileReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FileWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;访问数组&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;ByteArrayOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;CharArrayReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;CharArrayWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;访问管道&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PipedInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PipedOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PipedReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PipedWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;访问字符串&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;StringReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;StringWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;缓冲流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;BufferedInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;BufferedOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;BufferedReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;BufferedWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;转换流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;InputStreamReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;OutputStreamWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;对象流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;ObjectOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;过滤流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FilterInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FilterOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FilterReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;FilterWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;打印流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PrintStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PrintWriter&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;退回输入流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PushbackInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;PushbackReader&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;特殊流&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;DataInputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;DataOutputStream&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一般如果输入/输出的内容是文本内容，应该考虑使用字符流，如果输入/输出内容是二进制内容，则应该考虑使用字节流。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.1 转换流&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;体系中提供了两个转换流，实现将字节流转换成字符流，InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流，System.in代表标准输入，这个标准输入是字节输入流，但是键盘输入的都是文本内容，这个时候我们可以InputStreamReader转换成字符输入流，普通的Reader读取内容不方便，我们可以使用BufferedReader一次读取一行数据，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先将System.in转换成Reader 对象&lt;/span&gt;
InputStreamReader inputStreamReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再将Reader包装成BufferedReader&lt;/span&gt;
BufferedReader bufferedReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(inputStreamReader);
String line &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = bufferedReader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (line.equals(&quot;exit&quot;&lt;span&gt;)) {
        System.exit(&lt;/span&gt;1&lt;span&gt;);
    }
    System.out.println(&lt;/span&gt;&quot;输入的内容是：&quot; +&lt;span&gt; line);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BufferedReader具有缓冲功能，在没有读到换行符则阻塞，读到换行符再继续。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.2 推回输入流&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;推回输入流PushbackInputStream和PushbackReader中都提供了如下方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void unread(int b) ：将一个字节/字符推回到推回缓冲区，从而允许重复读取刚刚读取的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void unread(byte[] b/char[] b, int off, int len) ：将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区，从而允许重复读取刚刚读取的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;void unread(byte[] b/char[])：将一个字节/字符数组内容推回到推回缓冲区，从而允许重复读取刚刚读取的内容。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这两个推回流都带有一个推回缓冲区，当调用unread()方法时，系统将会把指定的内容推回到该缓冲区，而当每次调用read方法时会优先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有read()所需的数组时才会从原输入流中读取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建PushbackReader对象，指定推回缓冲区的长度为64&lt;/span&gt;
PushbackReader pushbackReader = &lt;span&gt;new&lt;/span&gt; PushbackReader(&lt;span&gt;new&lt;/span&gt; FileReader(&quot;StreamTest.java&quot;), 64&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[32&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用以保存上次读取的字符串内容&lt;/span&gt;
String lastContent = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环读取文件内容&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; ((hasRead = pushbackReader.read(buf)) &amp;gt; 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将读取的内容转换成字符串&lt;/span&gt;
    String content = &lt;span&gt;new&lt;/span&gt; String(buf, 0&lt;span&gt;, hasRead);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetIndex = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((targetIndex = (lastContent + content).indexOf(&quot;new PushbackReader&quot;)) &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将本次内容和上次的内容一起推回缓冲区&lt;/span&gt;
        pushbackReader.unread((lastContent +&lt;span&gt; content).toCharArray());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新定义一个长度为targetIndex的char数组&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (targetIndex &amp;gt; 32&lt;span&gt;) {
            buf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[targetIndex];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次读取指定长度的内容&lt;/span&gt;
        pushbackReader.read(buf, 0&lt;span&gt;, targetIndex);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印读取的内容&lt;/span&gt;
        System.out.print(&lt;span&gt;new&lt;/span&gt; String(buf, 0&lt;span&gt;, targetIndex));
        System.exit(&lt;/span&gt;0&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印上次读取的内容&lt;/span&gt;
&lt;span&gt;        System.out.print(lastContent);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将本次内容设为上次读取的内容&lt;/span&gt;
        lastContent =&lt;span&gt; content;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;五、RandomAccessFile&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RandomAccessFile是Java输入/输出流体系中最丰富的文件内容访问类，提供了众多的方法来访问文件内容，既可读取文件内容，也可以向文件输出数据，RandomAccessFile可以自由访问文件的任意位置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RandomAccessFile包含一个记录指针，用以标识当前读和写的位置，当创建新对象时，指针位置在0处，而当读/写了N个字节后，指针就会向后移动N个字节，并且RandomAccessFile可以自动的移动该指针位置，当然我们也可以直接的获取指针的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RandomAccessFile有两个构造函数：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RandomAccessFile(File file, String mode)：使用File文件，指定文件本身 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;RandomAccessFile(String name, String mode)：使用文件名称，指定文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其中还有一个参数mode（访问模式），访问模式有4个值：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;r:以只读方式打开文件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;rw:以读、写方式打开文件，如果文件不存在，则创建&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;rws:以读、写方式打开文件，并要求对文件的内容或者元数据的每个更新都同步写入到底层存储设备&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;rwd:以读、写方式打开文件，并要求对文件的内容的每个更新都同步写入到底层存储设备&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
RandomAccessFile raf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;StreamTest.java&quot;, &quot;r&quot;&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;文件指针的初始位置：&quot; +&lt;span&gt; raf.getFilePointer());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动指针位置&lt;/span&gt;
raf.seek(300&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hasRead = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((hasRead = raf.read(buf)) &amp;gt; 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取数据&lt;/span&gt;
    System.out.println(&lt;span&gt;new&lt;/span&gt; String(buf, 0&lt;span&gt;, hasRead));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;追加内容&lt;/span&gt;
RandomAccessFile randomAccessFile=&lt;span&gt;new&lt;/span&gt; RandomAccessFile(&quot;out.txt&quot;,&quot;rw&quot;&lt;span&gt;);
randomAccessFile.setLength(randomAccessFile.length());
randomAccessFile.write(&lt;/span&gt;&quot;追加的内容！\r\n&quot;.getBytes());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;六、对象序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对象序列化机制是允许把内存中的java对象转换成平台无关的二进制流，这样我们可以将这二进制流保存在磁盘上或者通过网络将起传输到另一个网络节点，其他程序获取到此二进制流后，可以将其恢复成原来的java对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;要使一个对象是可序列化的，只需要继承Serializable或者Externalizable接口，无需实现任何方法。所有可能在网络上传输的对象的类都应该是可序列化的，如我们JavaWeb中的输入参数及返回结果。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;6.1 使用对象流实现序列化&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们使用一个对象流来实现序列化对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先建一个对象类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        System.out.println(&lt;/span&gt;&quot;有参数的构造器&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列化对象与反序列化对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建输出流&lt;/span&gt;
ObjectOutputStream objectOutputStream = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;object.txt&quot;&lt;span&gt;));
Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;, 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将person写入文件中&lt;/span&gt;
&lt;span&gt;objectOutputStream.writeObject(person);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建输入流&lt;/span&gt;
ObjectInputStream objectInputStream = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;object.txt&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出数据&lt;/span&gt;
    Person p =&lt;span&gt; (Person) objectInputStream.readObject();
    System.out.println(p);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
    e.printStackTrace();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;反序列化读取的仅仅是Java对象的数据，而不java类，因此反序列化时必须提供对象所属类的class文件，在反序列化对象时没有调用有参数的构造器，说明反序列化时不需要通过构造器来初始化Java对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果一个类中包含了引用类型，那么引用类型也必须是可序列化的，否则该类也是不可序列化的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;如果我们不希望某个变量被序列化，比如敏感信息，那需要使用transient来修饰此变量即可。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;七、NIO&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上面学习的IO都是阻塞式的，而且是底层都是通过字节的移动来处理的，这样明显效率不高，于是后面新增了NIO来进行改进，这些类都放在java.nio包中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;新IO 是将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件中的内容，相当于虚拟内存概念，这种方式比传统的IO快很多。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;新IO的两大核心对象是Channel（通道）与Buffer（缓冲），Channel与传统的InputStream、OutputStream最大的区别在于提供了一个map（）方法，这个方法是将一块数据映射到内存中，这样新IO就是面向块进行处理；Buffer本质是一个数组，可以看做一个容器，发送到Channel中的所有对象都必须首先放在Buffer中，读取数据也是从Buffer中读取。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;7.1 Buffer&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;Buffer是一个抽象类，最常用的子类是ByteChannel和CharBuffer，Buffer类都没有提供构造器，都是通过XXXBuffer allocate(int capacity) 来得到对象，如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CharBuffer allocate = CharBuffer.allocate(8);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Buffer有三个重要概念：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;容量（capacity）：缓冲区的容量，表示该buffer的最大数据容量，即最多可存储多少数据，创建后不可改变。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;界限（limit）：位于limit后的数据既不可以读，也不可以写。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;位置（position）：用于指明下一个可以被读出或写入的缓冲区位置索引，类似IO中的指针。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201906/1113901-20190617233703806-754636552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Buffer的主要作用是装入数据，然后输出，当创建buffer时，position在0位置，limit在capacity,当添加数据时，position向后移动。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当Buffer装好数据时，调用flip（）方法，这个方法将limit设置为position,position设置为0，也就是说不能继续输入，这就给输出数据做好准备了，而当输出数据结束后，调用clear（）方法，这是将position设置为0,limit设置为capacity,这样就为装入数据做好了准备。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;除了上面的几个概念，Buffer还有两个重要方法，即put()与get()方法，就是存储与读取数据方法，在存储和读取数据时，分为相对和绝对两种：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相对：从Buffer的position位置开始读取或者写入数据，这时候会改变position的数值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;绝对：根据索引读取或写入数据，这个时候不会影响position的数值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建buffer&lt;/span&gt;
CharBuffer buffer = CharBuffer.allocate(10&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;capacity: &quot; +&lt;span&gt; buffer.capacity());
System.out.println(&lt;/span&gt;&quot;limit:&quot; +&lt;span&gt; buffer.limit());
System.out.println(&lt;/span&gt;&quot;position:&quot; +&lt;span&gt; buffer.position());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入数据&lt;/span&gt;
buffer.put('a'&lt;span&gt;);
buffer.put(&lt;/span&gt;'b'&lt;span&gt;);
buffer.put(&lt;/span&gt;'c'&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;加入元素后，position:&quot; +&lt;span&gt; buffer.position());
buffer.flip();
System.out.println(&lt;/span&gt;&quot;执行flip后，limit：&quot; +&lt;span&gt; buffer.limit());
System.out.println(&lt;/span&gt;&quot;position:&quot; +&lt;span&gt; buffer.position());
System.out.println(&lt;/span&gt;&quot;取出一个数据，&quot; +&lt;span&gt; buffer.get());
System.out.println(&lt;/span&gt;&quot;取出数据后，position：&quot; +&lt;span&gt; buffer.position());
buffer.clear();
System.out.println(&lt;/span&gt;&quot;执行clear后，limit：&quot; +&lt;span&gt; buffer.limit());
System.out.println(&lt;/span&gt;&quot;,position:&quot; +&lt;span&gt; buffer.position());
System.out.println(&lt;/span&gt;&quot;执行clear后缓冲区未被清空：&quot; + buffer.get(2&lt;span&gt;));
System.out.println(&lt;/span&gt;&quot;绝对读取后，position不会改变：&quot; + buffer.position());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;7.2 Channel&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Channel类似传统流对象，主要区别在于Channel可以将指定文件的部分或者全部直接映射成Buffer，程序不能直接对Channel中的数据进行读写，只能通过Channel来进行数据读写。我们用FileChannel来看看如何使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(&quot;StreamTest.java&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入流创建FileChannel&lt;/span&gt;
FileChannel inChannel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file).getChannel();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以文件输出流创建FileChannel，控制输出&lt;/span&gt;
FileChannel outChannel = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;a.txt&quot;&lt;span&gt;).getChannel();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将FileChannel映射成ByteBuffer，&lt;/span&gt;
MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0&lt;span&gt;, file.length());
Charset charset &lt;/span&gt;= Charset.forName(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数据&lt;/span&gt;
&lt;span&gt;outChannel.write(buffer);
buffer.clear();
CharsetDecoder charsetDecoder &lt;/span&gt;=&lt;span&gt; charset.newDecoder();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换成CharBuffer进行输出&lt;/span&gt;
CharBuffer charBuffer =&lt;span&gt; charsetDecoder.decode(buffer);
System.out.println(charBuffer);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;7.3 字符集与Charset&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们知道，在计算机底层文件都是二进制文件，都是字节码，那为什么我们还能看到字符，这里面涉及编码和解码两个概念，简单讲，将字符转换成二进制为编码，而将二进制转成字符为解码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Java默认使用Unicode字符集（字符集是指二进制序列与字符之间的对应关系），但很多操作系统不使用Unicode字符集，这样就会出错，我们要根据实际情况来使用对应的字符集。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;Charset包含了创建解码器和编码器的方法，还提供了获取Charset所支持字符集的方法，我们可以通过Charset的forName（）获取对象，通过对象获取到CharsetEncoder和CharsetDecoder对象，再通过此对象进行字符序列与字节序列的转换。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
SortedMap&amp;lt;String, Charset&amp;gt; stringCharsetSortedMap =&lt;span&gt; Charset.availableCharsets();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String name:stringCharsetSortedMap.keySet()){
    System.out.println(name);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建简体中文对应的Charset&lt;/span&gt;
Charset cn = Charset.forName(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对应的编码器及解码器&lt;/span&gt;
CharsetEncoder cnEncoder =&lt;span&gt; cn.newEncoder();
CharsetDecoder cnDecoder &lt;/span&gt;=&lt;span&gt; cn.newDecoder();
CharBuffer buff &lt;/span&gt;= CharBuffer.allocate(8&lt;span&gt;);
buff.put(&lt;/span&gt;'李'&lt;span&gt;);
buff.put(&lt;/span&gt;'白'&lt;span&gt;);
buff.flip();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将buff的字符转成字节序列&lt;/span&gt;
ByteBuffer bbuff =&lt;span&gt; cnEncoder.encode(buff);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;bbuff.capacity() ; i++&lt;span&gt;) {
    System.out.print(bbuff.get(i)&lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将bbuff的数据解码成字符&lt;/span&gt;
System.out.println(&quot;\n&quot;+cnDecoder.decode(bbuff));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;7.4 Path、Paths、Files&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;早期的Java只提供了File类来访问文件系统，功能比较有限且性能不高，后面又提供了Path接口，Path代表一个平台无关路径，并提供了Paths与Files两个工具类，提供了大量的方法来操作文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Path path = Paths.get(&quot;.&quot;&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;path包含的文件数量：&quot; +&lt;span&gt; path.getNameCount());
System.out.println(&lt;/span&gt;&quot;path的根路径：&quot; +&lt;span&gt; path.getRoot());
Path path1 &lt;/span&gt;=&lt;span&gt; path.toAbsolutePath();
System.out.println(&lt;/span&gt;&quot;path的绝对路径：&quot; +&lt;span&gt; path1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个String构建路径&lt;/span&gt;
Path path2 = Paths.get(&quot;G:&quot;, &quot;test&quot;, &quot;codes&quot;&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;path2的路径：&quot; +&lt;span&gt; path2);

System.out.println(&lt;/span&gt;&quot;StreamTest.java是否为隐藏文件:&quot; + Files.isHidden(Paths.get(&quot;StreamTest.java&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一次性读取所有行&lt;/span&gt;
List&amp;lt;String&amp;gt; allLines = Files.readAllLines(Paths.get(&quot;StreamTest.java&quot;), Charset.forName(&quot;gbk&quot;&lt;span&gt;));
System.out.println(allLines);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取大小&lt;/span&gt;
System.out.println(&quot;StreamTest.java文件大小：&quot; + Files.size(Paths.get(&quot;StreamTest.java&quot;&lt;span&gt;)));
List&lt;/span&gt;&amp;lt;String&amp;gt; poem = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
poem.add(&lt;/span&gt;&quot;问君能有几多愁&quot;&lt;span&gt;);
poem.add(&lt;/span&gt;&quot;恰似一江春水向东流&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一次性写入数据&lt;/span&gt;
Files.write(Paths.get(&quot;poem.txt&quot;), poem, Charset.forName(&quot;gbk&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到Paths与Files非常的强大，提供了很多方法供我们使用，在之前这些方法我们自己写的话比较麻烦，更多的方法可以自己去看API。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;7.5 文件属性&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;java.nio.file.attribute包下提供了大量的属性工具类，提供了很方便的方法去获取文件的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
BasicFileAttributeView baseView = Files.getFileAttributeView(Paths.get(&quot;poem.txt&quot;), BasicFileAttributeView.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
BasicFileAttributes basicFileAttributes &lt;/span&gt;=&lt;span&gt; baseView.readAttributes();
System.out.println(&lt;/span&gt;&quot;创建时间：&quot; +&lt;span&gt; basicFileAttributes.creationTime().toMillis());
System.out.println(&lt;/span&gt;&quot;最后更新时间：&quot; + basicFileAttributes.lastModifiedTime().toMillis());
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 17 Jun 2019 15:45:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 IO（输入/输出），输入是指允许程序读取外部数据（包括来自磁盘、光盘等存储设备的数据）、用户输入数据。输出是指允许程序记录运行状态，将程序数据输出到磁盘、光盘等存储设备中。 IO的主要内容包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/11042873.html</dc:identifier>
</item>
<item>
<title>高仿富途牛牛-组件化(二)-磁力吸附 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11042704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11042704.html</guid>
<description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;我们讲述了组件化的一些基础东西，并有了一个基本的雏形，使用过富途牛牛的同学应该对其中的gif图比较熟悉了。虽然效果糙了一点儿，但是该有的基础功能是已经有了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具栏页签拖拽&lt;/li&gt;
&lt;li&gt;工具栏之间页签拖拽&lt;/li&gt;
&lt;li&gt;小工具&lt;/li&gt;
&lt;li&gt;多页签架构&lt;/li&gt;
&lt;li&gt;小窗口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述几个功能在上一篇文章中都已经有了，今天我们来讲述下第二个关键功能--&lt;strong&gt;磁力吸附&lt;/strong&gt;和一些其他小功能&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;磁力吸附，顾名思义就是说窗口移动时，快要接近另一个窗口边缘时，会有一种磁性，把正在拖拽的窗口直接吸过去，效果图如下图所示。&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1482844/o_magentic_2.gif&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;h2 id=&quot;三磁力吸附&quot;&gt;三、磁力吸附&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;文章最后，我列出了工程中所有的类，并做了每个类的功能说明。&lt;/p&gt;
&lt;p&gt;本篇文章的工程代码在上一版本的基础上进行了一些优化，代码的结构也更加的清晰，阅读起来更容易，主要是增加了磁力吸附和一些同步功能。&lt;/p&gt;
&lt;p&gt;下面来思考下磁力吸附这个功能。&lt;/p&gt;
&lt;p&gt;首先我们来考虑下磁力吸附，什么是磁力吸附，明白我们自己的需求是什么样子的？&lt;/p&gt;
&lt;p&gt;磁力表现出来可能像下面这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不同子窗口之间希望进行磁力吸附，也就是说窗口移动时，可以被吸附到邻近的窗口边框上&lt;/li&gt;
&lt;li&gt;不同页签之间不需要关联&lt;/li&gt;
&lt;li&gt;鼠标不能移动到subPanel之外&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;别名：被拖拽窗口（A）、吸附窗口（B）、事件处理（C）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了清晰的需求之后，我们下面就来考虑怎么实现我们的需求，既然要做到小窗口之间进行吸附，想一想，这个事件处理不管写到A窗口还是B窗口都不是那么合适。那么可想而知，除过被拖拽的窗口A和将要的吸附窗口B之外，必然需要引入一个第三者C，进行事件处理，他不一定是一个窗口，主要是要能代理A和B的事件，并且进行各种处理即可。&lt;/p&gt;
&lt;p&gt;有了第三者C之后，接下来我们在第三者C中去处理A的移动事件，循环去判断是否和其中某个窗口满足了吸附条件。一旦满足吸附条件，我们就触发吸附后操作&lt;/p&gt;
&lt;p&gt;处理吸附事件时，可能像下面这样&lt;/p&gt;
&lt;p&gt;假设我们有10个窗口，分别是A1、A2、A3、A4...A9、A10等&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当我们拖拽A1窗口时，其他窗口都是吸附窗口（B）&lt;/li&gt;
&lt;li&gt;当我们拖拽A2窗口时，A1和其他窗口都是吸附窗口（B）&lt;/li&gt;
&lt;li&gt;同理，当我们拖拽其他An窗口时，除过An的窗口都是吸附窗口（B）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当要引入第三者窗口时，我们可能需要思考如下几个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;怎么样引入第三者事件处理类呢？&lt;/li&gt;
&lt;li&gt;他是怎么初始化的？&lt;/li&gt;
&lt;li&gt;他的作用范围？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;思考如上3个问题，怎么去解决他们！我第一时间就想到了Qt中提供的QButtonGroup类，这个类的作用是用于管理其中的按钮，在他里边包含的按钮不允许有两个同时选中。&lt;/strong&gt; 是不是很相似，也是管理一堆相同的控件，但是他们中，其中一个控件的操作会对其他所有的控件产生相同的效果。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;strong&gt;我们可以新增一个SmallGroup类，专门负责处理移动的窗口和其他窗口之间的事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类可能就像这边这样！他提供了新增一个小窗口和移除一个小窗口的接口，添加进来的小窗口我们都可以进行磁力吸附管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SmallGroup : public QObject
{
public:
    SmallGroup(QObject * object = nullptr);
    ~SmallGroup(){}

public:
    void AddSmall(SmallWidget *);
    void RemoveSmall(SmallWidget *);

    void MagneticEnable(bool);

    void LimitCursor(bool);//限制鼠标移动范围
    void MoveStart(SmallWidget *, const QPoint &amp;amp;);//开始移动 
    void MovingDistance(SmallWidget *, const QPoint &amp;amp;);//距离开始移动时的偏差距离

protected:
    virtual bool eventFilter(QObject *, QEvent *) override;

private:
    QPoint MagneticPos(SmallWidget *, const QRect &amp;amp;);

private:
    bool m_bMagnetic;
    QPoint m_startPos;
    QVector&amp;lt;SmallWidget *&amp;gt; m_smallVec;
    SmallWidget * m_pMoveWidget;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类的思路不难，只是里边有一些比较繁杂的实现，这里我主要说3点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;限制鼠标区域&lt;/li&gt;
&lt;li&gt;修正窗口可以移动的区域&lt;/li&gt;
&lt;li&gt;获取最邻近的可被吸附的窗口&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;限制鼠标区域&quot;&gt;1、限制鼠标区域&lt;/h3&gt;
&lt;p&gt;限制鼠标可移动区域的接口上边已经列出来来了，根据参数动态的去限制鼠标移动区域，或者不限制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LimitCursor(bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当进行拖拽小窗口时，我们需要限制鼠标不能移除subPanel，如果不理解subPanel是什么东西，需要仔细去阅读下上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;限制鼠标移动区域的代码如下所示，主要是使用了ClipCursor这个win32接口，代码比较简单，这里就不做详细说明了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SmallGroup::LimitCursor(bool limit)
{
#ifdef Q_OS_WIN
    if (limit)
    {
        if (QWidget * subPanel = dynamic_cast&amp;lt;QWidget *&amp;gt;(parent()))
        {
            QRect q_rect = subPanel-&amp;gt;geometry();
            QPoint g_pos = subPanel-&amp;gt;mapToGlobal(QPoint(0, 0));

            CRect w_rect;
            w_rect.left = g_pos.x();
            w_rect.top = g_pos.y();
            w_rect.right = g_pos.x() + q_rect.width();
            w_rect.bottom = g_pos.y() + q_rect.height();

            ClipCursor(&amp;amp;w_rect);
        }
    }
    else
    {
        ClipCursor(nullptr);
    }
#endif 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修正窗口可以移动的区域&quot;&gt;2、修正窗口可以移动的区域&lt;/h3&gt;
&lt;p&gt;看到这个标题是不是有点儿蒙圈，其实这个也很简单，这里主要说明的是，我们移动小窗口时，小窗口不能移出subPanel，也就是说当subPanel显示时，其中的小窗口都可以全部显示出来，或者被其他小窗口遮挡。&lt;/p&gt;
&lt;p&gt;当然了，这个也是需要根据需求来定的，我最开始做的就是4个边都不能出subPanel，但是后来发现，富途牛牛的代码是只有顶部不能出去。因此代码里我注释了3个if修正操作，大家可以根据自家的需求进行修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QRect CorrentRect(const QRect &amp;amp; rect, const QRect &amp;amp; subPanel)
{
    QRect correntRect = rect;
    //if (correntRect.left() &amp;lt; subPanel.left())
    //{
    //  correntRect.moveLeft(subPanel.left());
    //}
    if (correntRect.top() &amp;lt; subPanel.top())
    {
        correntRect.moveTop(subPanel.top());
    }
    //if (correntRect.right() &amp;gt; subPanel.right())
    //{
    //  correntRect.moveRight(subPanel.right());
    //}
    //if (correntRect.bottom() &amp;gt; subPanel.bottom())
    //{
    //  correntRect.moveBottom(subPanel.bottom());
    //}

    return correntRect;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取最邻近的可被吸附的窗口&quot;&gt;3、获取最邻近的可被吸附的窗口&lt;/h3&gt;
&lt;p&gt;磁力吸附最复杂的地方可能就是这个功能了，当我们移动一个窗口时，我们需要判断各种情况，然后去修正我们的位置。&lt;/p&gt;
&lt;p&gt;划重点1：&lt;strong&gt;磁力吸附是说当我们靠近某个小窗口边框时，我们拖拽的窗口可以被吸附过去，但是需要特别注意，我们实际移动的距离根本没有到达那么多，因此，当我们鼠标稍微往远移动一下，窗口应该像被弹开一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;划重点2：&lt;strong&gt;要实现重点1，那么我们在移动窗口时，就需要有一定的技巧，需要记录小窗口开始移动的位置，和当前移动的距离。根据移动后的距离判断是否可以被吸附，如果被吸附了，那么我们直接把窗口移动多一点(或者少一点)距离，达到吸附的位置，但是实际上这个时候，我们鼠标移动的距离并不等于我们实际移动的距离，这样是为了当我们鼠标在次偏移时，我们可以继续去判断是否满足吸附条件，如果不满足则按实际的移动距离。这样就达到了被弹开的视觉效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上边的描述可能理解起来会比较费劲，这里我在用公式说明下，理解不了就多看几遍吧&lt;/p&gt;
&lt;p&gt;startMovePos：开始移动时，鼠标按下的位置&lt;br/&gt;offsetPos：鼠标当前位置距离开始移动时的位置之间的距离&lt;br/&gt;truthPos：按照鼠标位移，将要移动到的位置。&lt;br/&gt;movePos:窗口将要被移动到的位置。磁力吸附后，会在truthPos上有所偏差&lt;/p&gt;
&lt;p&gt;如上四个变量所示，当我们移动窗口时，可能会产生以下几个情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;没有磁力吸附，直接移动到truthPos&lt;/li&gt;
&lt;li&gt;有磁力吸附，移动到被吸附的窗口边框跟前（会产生一个便宜值value，被吸过去了）&lt;/li&gt;
&lt;li&gt;上一次有磁力吸附，本次不满足处理吸附，直接移动到truthPos，产生弹开的感觉。因为之前被吸附了，有一个偏移值value。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;磁力吸附需要处理4个方向的事件，这里我们只讲下左侧吸附，其他情况类似，这里不做介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下代码所示，就是处理吸附位置时的主流程，代码里我只保留了处理做边框吸附的，其他边框代码已删，逻辑都差不多。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QPoint SmallGroup::MagneticPos(SmallWidget * widget, const QRect &amp;amp; rect)
{
    QPoint pos(rect.topLeft());

    if (QWidget * subPanel = dynamic_cast&amp;lt;QWidget *&amp;gt;(parent()))
    {
        QRect panelRect = subPanel-&amp;gt;rect();

        QRect correntRect = CorrentRect(rect, panelRect);
        if (m_bMagnetic == false)
        {
            return correntRect.topLeft();
        }

        //修改位置后的ps  更准确
        pos = correntRect.topLeft();

        QVector&amp;lt;SmallWidget *&amp;gt; smallWidgets = m_smallVec;
        smallWidgets.removeOne(widget);

        int distance = 0;
        //左边框与subPanel左测比较
        if (CanMagneticPanel(ME_LEFT, rect.left(), panelRect, distance))
        {
            pos.setX(panelRect.left());
        }
        else 
        {
            //左边框与其他窗口右边框比较
            if (CanMagneticSmall(ME_LEFT, rect.left(), smallWidgets, distance))
            {
                pos.setX(distance);
            }
        }
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;左侧吸附具体分两个情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移动窗口A和subPanel之间的吸附&lt;/li&gt;
&lt;li&gt;移动窗口A的左边框和被吸附窗口B的右边框之间的吸附&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;aa窗口和subpanel面板之间的吸附&quot;&gt;a、A窗口和subPanel面板之间的吸附&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;吸附规则时：A窗口左边框吸附subPanel面板的左边框，同理其他边框都是一样&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool CanMagneticPanel(MagneticEdge edge, int s, const QRect &amp;amp; subPanel, int &amp;amp; distance)
{
    int value;
    switch (edge)
    {
    case ME_LEFT:
        value = subPanel.left();
        break;
    case ME_TOP:
        value = subPanel.top();
        break;
    case ME_RIGHT:
        value = subPanel.right();
        break;
    case ME_BOTTOM:
        value = subPanel.bottom();
        break;
    default:
        break;
    }
    distance = qFabs(s - value);
    if (distance &amp;lt;= MagneticDistance)
    {
        return true;
    }

    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ba窗口的左边框和被吸附窗口b的右边框之间的吸附&quot;&gt;b、A窗口的左边框和被吸附窗口B的右边框之间的吸附&lt;/h4&gt;
&lt;p&gt;循环判断其他可被吸附的窗口，找到一个距离最近可悲吸附的窗口，然后进行位置修正。当函数返回为真时，distance就是最后要被修复的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是，如果有多个满足吸附的窗口边框，我们需要找到一个距离最近的窗口进行修复，也就是说呗吸附的窗口边框和我们正在拖拽的窗口边框距离最近。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同于和subPanel之间的吸附规则，子窗口之间的吸附规则是，A窗口的左边框会吸附B窗口的右边框；A窗口的顶边框会吸附B窗口的低边框，规则是不是很清晰了，刚好是反的。左对右、顶对低、右对左和低对顶&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool CanMagneticSmall(MagneticEdge edge, int moving, const QVector&amp;lt;SmallWidget *&amp;gt; &amp;amp; allWidget, int &amp;amp; distance)
{
    distance = 10000;
    bool result = false;
    int minDistance = 10000;
    //根据edge的值  动态去获取窗口的边
    //例如：edge为ME_LEFT时 需要获取其他窗口的ME_RIGHT  去对比
    for each (SmallWidget  * widget in allWidget)
    {
        int otherValue = -1; 
        switch (edge)
        {
        case ME_LEFT:
            otherValue = widget-&amp;gt;geometry().right() + 2;
            break;
        case ME_TOP:
            otherValue = widget-&amp;gt;geometry().bottom() + 2;
            break;
        case ME_RIGHT:
            otherValue = widget-&amp;gt;geometry().left() - 1;
            break;
        case ME_BOTTOM:
            otherValue = widget-&amp;gt;geometry().top() - 1;
            break;
        default:
            break;
        }
        if (otherValue != -1)
        {
            int tmp = qFabs(moving - otherValue);
            if (minDistance &amp;gt; tmp)
            {
                minDistance = tmp;

                if (minDistance &amp;lt;= MagneticDistance)
                {
                    result = true;
                    distance = otherValue;
                }
            }
        }
    }

    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四其他&quot;&gt;四、其他&lt;/h2&gt;
&lt;p&gt;工具箱窗口和工具栏工具按钮联动，按理说这个功能属于比较常见的功能，但是这里我也想拿出来跟大家分享下，这里我主要是借助了QAction这个类，把工具栏种的按钮QToolButton和工具箱窗口进行了绑定，这样不需要过多的信号餐同步，我们就可以很简单的实现功能联动&lt;/p&gt;
&lt;p&gt;以前的时候我都是使用信号槽进行同步的，后来才发现这个比较取巧的办法，不是多么高端，主要是可以让代码更清晰。当有越来越多的复杂业务时，QAction的联动同步优势就出来了。&lt;/p&gt;
&lt;p&gt;下面是QToolButton和工具箱同步状态的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//工具箱，关闭时，同步工具栏按钮状态
void ToolBoxDialog::BindAction(QAction * act)
{
    connect(m_pToolBoxAct, &amp;amp;QAction::triggered, act, &amp;amp;QAction::setChecked, Qt::UniqueConnection);
}

connect(m_pTitle, &amp;amp;ToolBoxTitle::CloseWindow, this, [this](){
        m_pToolBoxAct-&amp;gt;triggered(false);
        setVisible(false);
    });
    
//点击工具栏按钮时，打开工具箱
void TemplateLayout::ShowToolBox(bool visible)
{
    if (m_pToolBox == nullptr)
    {
        m_pToolBox = new ToolBoxDialog(this);
        m_pToolBox-&amp;gt;BindAction(m_pToolBar-&amp;gt;GetToolBoxButton());
        connect(m_pToolBox, &amp;amp;ToolBoxDialog::SubWindowClicked, m_pPanel, &amp;amp;ContentPanel::CreateSubWindow);
    }

    if (visible)
    {
        m_pToolBox-&amp;gt;show();
    }
    else
    {
        m_pToolBox-&amp;gt;hide();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五相关文章&quot;&gt;五、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上的内容，基本上就是本篇文章的内容所有内容啦！磁力吸附功能基本完成，希望可以帮到大家。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;转载声明：本站文章无特别说明，皆为原创，版权所有，转载请注明：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Mon, 17 Jun 2019 14:51:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 一、概述 上一篇文章 '高仿富途牛牛 组件化(一) 支持页签拖拽、增删、小工具' 我们讲述了组件化的一些基础东西，并有了一个基本的雏形，使用过富途牛牛的同学应该对其中的gif图比较熟悉了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11042704.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合Swagger和Actuator - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/11042674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/11042674.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要介绍的是SpringBoot整合Swagger(API文档生成框架)和SpringBoot整合Actuator(项目监控)使用教程。&lt;/p&gt;
&lt;h2 id=&quot;springboot整合swagger&quot;&gt;SpringBoot整合Swagger&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;swagger-介绍&quot;&gt;Swagger 介绍&lt;/h3&gt;
&lt;p&gt;Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。&lt;/li&gt;
&lt;li&gt;Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。&lt;/li&gt;
&lt;li&gt;Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;swagger优缺点&quot;&gt;Swagger优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;易用性好，Swagger UI提供很好的API接口的UI界面，可以很方面的进行API接口的调用。&lt;/li&gt;
&lt;li&gt;时效性和可维护性好，API文档随着代码变更而变更。 Swagger是根据注解来生成文API档的，我们可以在变更代码的时候顺便更改相应的注解即可。&lt;/li&gt;
&lt;li&gt;易于测试，可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;重复利用性差，因为Swagger毕竟是网页打开，在进行接口测试的时候很多参数无法进行保存，因此不易于重复利用。&lt;/li&gt;
&lt;li&gt;复杂的场景不易模拟，比如使用token鉴权的，可能每次都需要先模拟登录，再来进行接口调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过上述的这些缺点其实也无伤大雅，可以配合&lt;a href=&quot;https://blog.csdn.net/qazwsxpcm/article/details/70578600&quot;&gt;Postman&lt;/a&gt;来一起使用！&lt;br/&gt;Postman可以保存参数并持久化生成文件，也可以在Header中保存Token信息，也可以动态的生成数字签名等等。&lt;br/&gt;如果有兴趣的话，可以看看我之前写的这篇文章。&lt;br/&gt;地址: &lt;a href=&quot;https://blog.csdn.net/qazwsxpcm/article/details/70578600&quot;&gt;Postman使用教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;swagger-相关地址&quot;&gt;Swagger 相关地址&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Swagger官网：http://swagger.io&lt;/li&gt;
&lt;li&gt;Swagger的GitHub地址：https://github.com/swagger-api&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：1.5.9.RELEASE&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
        &amp;lt;!-- swagger RESTful API --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; Swagger的jar包既可原生的 Swagger的架包，也可以选择maven仓库SpringBoot已经整合好的Swagger的架包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt;的文件的配置和一般的SpringBoot项目一样即可。&lt;/p&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;SpringBoot使用Swagger其实很简单，只需要在启动的时候添加&lt;code&gt;@EnableSwagger2&lt;/code&gt;注解开启，然后再使用&lt;code&gt;@Bean&lt;/code&gt;注解初始化一些相应的配置即可，比如编辑Swagger UI界面的信息，指定Swagger负责扫描的package等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swagger代码配置如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Configuration
    @EnableSwagger2
    public class Swagger2 {
    
        @Bean
        public Docket createRestApi() {
            return new Docket(DocumentationType.SWAGGER_2)
                    .apiInfo(apiInfo())
                    .select()
                    .apis(RequestHandlerSelectors.basePackage(&quot;com.pancm&quot;))
                    .paths(PathSelectors.any())
                    .build();
        }
    
        private ApiInfo apiInfo() {
            return new ApiInfoBuilder()
                    .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)
                    .description(&quot;测试&quot;)
                    .termsOfServiceUrl(&quot;http://www.panchengming.com/&quot;)
                    .contact(&quot;xuwujing&quot;)
                    .version(&quot;1.0&quot;)
                    .build();
        }
    
    }

    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为Swagger主要是用于生成API文档，因此这里我们可以直接编写控制层的相关代码，忽略掉Service层和Dao层相关的代码编写。这里我们首先编写一个实体类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又是万能的用户表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

    public class User {
        
         private Long id;
    
         private String name;
         
        
         private Integer age;
         
        //getter 和 setter 略
        
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Controller 控制层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swagger主要的使用就是在控制层这块，它是通过一些注解来为接口提供API文档。下述的代码中主要使用的注解为这两个&lt;code&gt;@ApiOperation&lt;/code&gt;和 &lt;code&gt;@ApiImplicitParam&lt;/code&gt;这两个，&lt;code&gt;@ApiOperation&lt;/code&gt;注解来给API增加说明并通过&lt;code&gt;@ApiImplicitParams&lt;/code&gt;注解来给参数增加说明，其中 &lt;code&gt;value&lt;/code&gt; 是标题,&lt;code&gt;notes&lt;/code&gt;是详细说明。&lt;/p&gt;
&lt;p&gt;下列是Swagger的一些注解说明，更详细的可以查看官方的wiki文档。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Api：将类标记为Swagger资源。&lt;/li&gt;
&lt;li&gt;@ApiImplicitParam：表示API操作中的单个参数。&lt;/li&gt;
&lt;li&gt;@ApiImplicitParams：一个包装器，允许列出多个ApiImplicitParam对象。&lt;/li&gt;
&lt;li&gt;@ApiModel：提供有关Swagger模型的其他信息，比如描述POJO对象。&lt;/li&gt;
&lt;li&gt;@ApiModelProperty： 添加和操作模型属性的数据。&lt;/li&gt;
&lt;li&gt;@ApiOperation： 描述针对特定路径的操作或通常是HTTP方法。&lt;/li&gt;
&lt;li&gt;@ApiParam： 为操作参数添加其他元数据。&lt;/li&gt;
&lt;li&gt;@ApiResponse： 描述操作的可能响应。&lt;/li&gt;
&lt;li&gt;@ApiResponses： 一个包装器，允许列出多个ApiResponse对象。&lt;/li&gt;
&lt;li&gt;@Authorization： 声明要在资源或操作上使用的授权方案。&lt;/li&gt;
&lt;li&gt;@AuthorizationScope： 描述OAuth2授权范围。&lt;/li&gt;
&lt;li&gt;@ResponseHeader： 表示可以作为响应的一部分提供的标头。&lt;/li&gt;
&lt;li&gt;@ApiProperty： 描述POJO对象中的属性值。&lt;/li&gt;
&lt;li&gt;@ApiError ： 接口错误所返回的信息&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官方wiki文档地址:&lt;br/&gt;https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations&lt;/p&gt;
&lt;p&gt;控制层代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @RestController
    @RequestMapping(value = &quot;/api&quot;)
    public class UserRestController {
        
        private  final Logger logger = LoggerFactory.getLogger(this.getClass());
        
    
        @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)
        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
        @PostMapping(&quot;/user&quot;)
        public boolean insert(@RequestBody User user) {
            logger.info(&quot;开始新增用户信息！请求参数:{}&quot;,user);
            return true;
        }
        
        @ApiOperation(value=&quot;更新用户&quot;, notes=&quot;根据User对象更新用户&quot;)
        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
        @PutMapping(&quot;/user&quot;)
        public boolean update(@RequestBody User user) {
            logger.info(&quot;开始更新用户信息！请求参数:{}&quot;,user);
            return true;
        }
        
        @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据User对象删除用户&quot;)
        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
        @DeleteMapping(&quot;/user&quot;)
        public boolean delete(@RequestBody User user)  {
            logger.info(&quot;开始删除用户信息！请求参数:{}&quot;,user);
            return true;
        }
        
    
        @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;根据User对象查询用户信息&quot;)
        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
        @GetMapping(&quot;/user&quot;)
        public User findByUser(User user) {
            logger.info(&quot;开始查询用户列表，请求参数:{}&quot;,user);
            User user2 =new User();
            user2.setId(1L);
            user2.setAge(18);
            user2.setName(&quot;xuwujing&quot;);
            return user2;
        }
        
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App 入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和普通的SpringBoot项目基本一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @SpringBootApplication
    public class SwaggerApplication  {
    
        private static final Logger logger = LoggerFactory.getLogger(SwaggerApplication.class);
    
        public static void main(String[] args) {
            SpringApplication.run(SwaggerApplication.class, args);
            logger.info(&quot;Swagger程序启动成功!&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;我们成功启动该程序之后，在浏览器上输入:&lt;code&gt;http://localhost:8183/swagger-ui.html&lt;/code&gt;, 就可以看到Swagger的界面了。&lt;/p&gt;
&lt;p&gt;界面的示例图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201906/1138196-20190617223957556-977978988.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于Swagger的操作主要是在界面操作，因此用图片会更加有说服力。&lt;/p&gt;
&lt;p&gt;使用GET请求测试示例图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201906/1138196-20190617224007078-1571428531.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;springboot整合actuator&quot;&gt;SpringBoot整合Actuator&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;actuator介绍&quot;&gt;Actuator介绍&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从本质上讲，Actuator为我们的应用程序带来了生产就绪功能。通过这种依赖关系监控我们的应用程序，收集指标，了解流量或数据库的状态变得微不足道。这个库的主要好处是我们可以获得生产级工具，而无需自己实际实现这些功能。Actuator主要用于公开有关正在运行的应用程序的运行信息 - 运行状况，指标，信息，转储，env等。它使用HTTP端点或JMX bean来使我们能够与它进行交互。一旦这个依赖关系在类路径上，就可以开箱即用几个端点。与大多数Spring模块一样，我们可以通过多种方式轻松配置或扩展它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;Actuator的1.x版本和2.x版本差别很大，本文介绍的是1.x版本。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Actuator现在与技术无关，而在1.x中，它与MVC相关联，因此与Servlet API相关联。&lt;br/&gt;在2.x中，Actuator定义了它的模型，可插拔和可扩展，而不依赖于MVC。因此，通过这个新模型，我们可以利用MVC和WebFlux作为底层Web技术。&lt;br/&gt;此外，可以通过实施正确的适配器来添加即将到来的技术。&lt;br/&gt;最后，JMX仍然支持在没有任何其他代码的情况下公开端点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的说明参考Actuator官网。&lt;/p&gt;
&lt;p&gt;官网地址:&lt;br/&gt;https://www.baeldung.com/spring-boot-actuators&lt;/p&gt;
&lt;h3 id=&quot;开发准备-1&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：1.5.9.RELEASE&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是application.yml的文件配置，这里的配置主要是指定监控的端口和路径以及关闭安全认证等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;application.yml:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8181 
management:
  security:
    enabled: false 
  port: 8888 
  context-path: /monitor
 
endpoints:
  shutdown:
    enabled: true
    
info:
  app:
   name:springboot-actuator
   version:1.0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码编写-1&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;其实这块不需要代码的编写，因为它只需要你在项目中添加了该依赖并进行配置之后即可使用。这里我们在创建一个普通的SpringBoot项目并且添加了Actuator的相关依赖，然后通过调用Actuator提供的一些接口就可以得知相关的信息。&lt;br/&gt;这些接口的一些说明如下:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1./autoconfig 可以得到配置生效信息&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;/configprops 可以得到属性的内容和默认值&lt;/li&gt;
&lt;li&gt;/beans 可 以得到bean的别名、类型、是否单例、类的地址、依赖等信息&lt;/li&gt;
&lt;li&gt;/dump 可 以得到线程名、线程ID、线程的状态、是否等待锁资源等信息&lt;/li&gt;
&lt;li&gt;/env 可以得到环境变量、JVM 属性、命令行参数、项目使用的jar包等信息&lt;br/&gt;5.1 /sun.boot.library.path 可以得到JDK安装路径&lt;/li&gt;
&lt;li&gt;/health 可以得到磁盘检测和数据库检测等信息&lt;/li&gt;
&lt;li&gt;/mappings 可以得到全部的URI路径，以及它们和控制器的映射关系&lt;/li&gt;
&lt;li&gt;/metrics 可以得到JVM内容使用、GC情况、类加载信息&lt;br/&gt;8.1 /gc.* 可以得到GC相关信息&lt;br/&gt;8.2 /mem.* 可以得到内存信息 ...&lt;/li&gt;
&lt;li&gt;/info 可以得到自定义的配置信息&lt;/li&gt;
&lt;li&gt;/shutdown 可以进行关闭程序 post请求&lt;/li&gt;
&lt;li&gt;/trace 可以得到所Web请求的详细信息&lt;br/&gt;12 ....&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;更多的相关配置说明可以查看官方文档！&lt;br/&gt;如果通过通过接口信息返回的数据进行查看不够清晰明了的话，可以结合SpringCloud Hystrix-Dashboard进行转换图表查看。&lt;br/&gt;具体使用可以参考： &lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/10446126.html&quot;&gt;SpringCloud学习系列之三----- 断路器(Hystrix)和断路器监控(Dashboard)&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;功能测试-1&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;我们成功启动该程序之后，便来进行测试。&lt;/p&gt;
&lt;p&gt;首先查看启动日志，会发现启动了两个端口，一个是springboot项目自身的端口，还有一个Actuator监控的端口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201906/1138196-20190617224102388-1101199298.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对外提供的Actuator主要是可以帮助我们获取一些程序以及一些环境的相关信息。&lt;/p&gt;
&lt;p&gt;比如获取程序健康状态。&lt;br/&gt;在浏览器输入:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8888/monitor/health&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即可查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201906/1138196-20190617224039644-753811639.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然也可以自定一些程序信息，比如定义程序版本。&lt;/p&gt;
&lt;p&gt;在浏览器输入:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8888/monitor/info&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201906/1138196-20190617224112819-299842204.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;SpringBoot整合Swagger的项目工程地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-swagger&lt;/p&gt;
&lt;p&gt;SpringBoot整合Actuator的项目工程地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-actuator&lt;/p&gt;
&lt;p&gt;SpringBoot整个集合的地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study&lt;/p&gt;
&lt;h3 id=&quot;springboot整合系列的文章&quot;&gt;SpringBoot整合系列的文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuwujing/category/1145997.html&quot;&gt;SpringBoot系列博客:&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 17 Jun 2019 14:42:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇文章主要介绍的是SpringBoot整合Swagger(API文档生成框架)和SpringBoot整合Actuator(项目监控)使用教程。 SpringBoot整合Swagger 说明：如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/11042674.html</dc:identifier>
</item>
<item>
<title>【nodejs原理&amp;源码赏析（7）】【译】Node.js中的事件循环，定时器和process.nextTick - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/11042623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/11042623.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190617222832660-1114108851.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;http://www.github.com/dashnowords/blogs&quot; class=&quot;uri&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8.7524366471735&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你常年游走于&lt;strong&gt;Nodejs中文网&lt;/strong&gt;，可能已经错过了官方网站上的第一手资料，&lt;strong&gt;Nodejs中文网&lt;/strong&gt;并没有翻译这些非常高质量的核心文章，只提供了中文版的API文档（已经很不容易了，没有任何黑它的意思，我也是中文网的受益者），它们涵盖了Node.js中从核心概念到相关工具等等非常重要的知识，下面是博文的目录，你知道该怎么做了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190617222843418-1636055486.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;event-loop-是什么&quot;&gt;Event Loop 是什么？&lt;/h2&gt;
&lt;p&gt;事件循环是&lt;code&gt;Node.js&lt;/code&gt;能够实现非阻塞I/O的基础，尽管JavaScript应用是单线程运行的，但是它可以将操作向下传递到系统内核去执行。&lt;/p&gt;
&lt;p&gt;大多数现代系统内核都是支持多线程的，它们可以同时在后台处理多个操作。当其中任何一个任务完成后，内核会通知&lt;code&gt;Node.js&lt;/code&gt;，这样它就可以把对应的回调函数添加进&lt;strong&gt;poll&lt;/strong&gt;队列，回调函数最终就能够被执行，后文中我们还会进行更详细的解释。&lt;/p&gt;
&lt;h2 id=&quot;event-loop-基本解释&quot;&gt;Event Loop 基本解释&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;Node.js&lt;/code&gt;开始运行时，它就会初始化&lt;code&gt;Event Loop&lt;/code&gt;，然后处理脚本文件（或者在&lt;code&gt;REPL&lt;/code&gt;（&lt;strong&gt;read-eval-print-loop&lt;/strong&gt;）环境中执行，本文不做深入探讨）中的异步API调用，定时器，或&lt;code&gt;process.nextTick&lt;/code&gt;方法调用，然后就会开始处理事件循环（Event Loop）。&lt;/p&gt;
&lt;p&gt;下图展示了事件循环的各个阶段(每一个盒子被称为事件循环中一个“阶段”)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190617222855398-1716041334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个阶段都维护了一个先进先出的待执行回调函数队列，尽管每一个阶段都有自己独特的处理方式，但总体来说，当事件循环进入一个具体的阶段时，它将处理与这个阶段有关的所有操作，然后执行这个阶段对应队列中的回调函数直到队列为空，或者达到了该阶段允许运行函数的数量的最大值，当满足任何一个条件时，事件循环都会进入下一个阶段，以此类推。&lt;/p&gt;
&lt;p&gt;因为任何阶段相关的操作都可能导致更多的待执行操作产生，而新事件会被内核添加进&lt;strong&gt;poll&lt;/strong&gt;队列中，当&lt;strong&gt;poll&lt;/strong&gt;队列中的回调函数被执行时允许继续向当前阶段的&lt;strong&gt;poll&lt;/strong&gt;队列中添加新的回调函数，于是长时间运行的回调函数可能就会导致事件循环在&lt;strong&gt;poll&lt;/strong&gt;阶段停留时间过长，你可以在后文的&lt;code&gt;timers&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;章节查看更多的内容。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;提示：Windows和Unix/Linux在实现上有细小的差别，但并不影响本文的演示，不同的系统可能会存在7-8个阶段，但是最终要的阶段上图中已经展示了，这些是Node.js实际会使用到的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事件循环阶段概览&quot;&gt;事件循环阶段概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;timers&lt;/code&gt;-本阶段执行通过&lt;code&gt;setTimeout( )&lt;/code&gt;和&lt;code&gt;setInterval( )&lt;/code&gt;添加的已经到时的计划任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pending callbacks&lt;/code&gt;-将一些I/O回调函数延迟到下一循环执行（这里不是很确定）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idle,prepare&lt;/code&gt;-内部使用的阶段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll&lt;/code&gt;-检查新的I/O事件；执行相关I/O的回调（除了“close回调”，“定时器回调”和&lt;code&gt;setImmediate( )&lt;/code&gt;添加的回调外几乎所有其他回调函数）；node有可能会在这里产生阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check&lt;/code&gt;-执行&lt;code&gt;setImmediate( )&lt;/code&gt;添加的回调函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close callbacks&lt;/code&gt;-用于关闭功能的回调函数，例如&lt;code&gt;socket.on('close',......)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在每轮事件周期之间，&lt;code&gt;Node.js&lt;/code&gt;会检查是否有处于等待中的异步I/O或定时器，如果没有的话就会关闭当前程序。&lt;/p&gt;
&lt;h2 id=&quot;事件循环细节&quot;&gt;事件循环细节&lt;/h2&gt;
&lt;h3 id=&quot;timers&quot;&gt;timers&lt;/h3&gt;
&lt;p&gt;一个timer会明确一个时间点，回调函数会在时间超过这个时间点后被执行，而不是开发者希望的精确时间。一旦定时器时间过期，回调函数就会尽可能早地被调度执行，然而操作系统的调度方式和其他的回调函数都有可能会导致某个定时器回调函数被延迟。&lt;/p&gt;
&lt;p&gt;提示：技术上来说,poll阶段控制着timers如何被执行。&lt;/p&gt;
&lt;p&gt;下面的示例中，你使用了一个100ms后过期的定时器，接着花费了95ms使用异步文件读取API异步读取了某个文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const fs = require('fs');
function someAsyncOperation(callback){
    //Assume this takes 95ms to complete
    fs.readFile('/path/to/file',callback);
}

const timeoutScheduled = Date.now();

setTimeout(()=&amp;gt;{
    const delay = Date.now() - timeoutScheduled;
    
    console.log(`${delay}ms have passed since I was scheduled`);
},100);

// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() =&amp;gt; {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback &amp;lt; 10) {
    // do nothing
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当事件循环进入poll阶段时，它的待执行队列是空的（&lt;code&gt;fs.readFile( )&lt;/code&gt;还没有完成），所以它将等待一定时间（当前时间距离最快到期的定时器到期时间之间的差值）。95ms过去后，&lt;code&gt;fs.readFile( )&lt;/code&gt;完成了文件读取，并花费了10ms将回调函数添加进poll的执行队列是它被执行。当回调函数执行完毕后，队列中没有更多的回调函数了，事件循环就会再次检查下一个待触发的timer是否已经到期，如果是，则事件循环就会绕回timers阶段去执行到期timer的回调函数。在这个示例中，你会看到timer从设置定时器到回调函数被触发一共花费了105ms.&lt;/p&gt;
&lt;p&gt;注意：为了避免在poll阶段阻塞事件循环，&lt;code&gt;libuv&lt;/code&gt;(Node.js底层用于实现事件循环和异步特性的C语言库)设置了一个硬上限值（该值会根据系统不同而有变化），使得poll阶段只能将有限数量的回调函数添加进poll队列。&lt;/p&gt;
&lt;h3 id=&quot;pending-callbacks&quot;&gt;pending callbacks&lt;/h3&gt;
&lt;p&gt;这个阶段会执行一些系统操作的回调函数，例如一些TCP的错误。比如一个TCP的socket对象尝试连接另一个socket时收到了&lt;code&gt;ECONNREFUSED&lt;/code&gt;，一些Linux系统会希望汇报这类错误，这类回调函数就会被添加在pending callbacks阶段的待执行队列中。&lt;/p&gt;
&lt;h3 id=&quot;poll阶段&quot;&gt;poll阶段&lt;/h3&gt;
&lt;p&gt;poll阶段有两个主要的功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算需要阻塞的时长，以便可以将完成的I/O添加进待执行队列&lt;/li&gt;
&lt;li&gt;执行poll队列中产生的事件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当事件循环进入poll阶段且此时并没有待执行的timer时，会按照下述逻辑来判断：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果poll队列不为空，事件循环会以同步的方式逐个迭代执行队列中的回调函数直到队列耗尽，或到达系统设置的处理事件数量限制。&lt;/li&gt;
&lt;li&gt;如果poll队列为空，则按照下述逻辑继续判断：
&lt;ul&gt;&lt;li&gt;如果脚本中使用&lt;code&gt;setImmediate( )&lt;/code&gt;方法添加了回调函数，事件循环就会结束poll阶段，并进入check阶段来执行这些添加的回调函数。&lt;/li&gt;
&lt;li&gt;如果没有使用&lt;code&gt;setimmediate( )&lt;/code&gt;添加的回调，事件循环就会等待其他回调函数被添加进队列并立即执行添加的函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一旦poll队列为空，事件循环就会检查是否有已经到期的timers定时器，如果有一个或多个定时器到期，事件循环就会回到timers阶段来执行这些定时器的回调函数。&lt;/p&gt;
&lt;h3 id=&quot;check&quot;&gt;check&lt;/h3&gt;
&lt;p&gt;这个阶段允许开发者在poll阶段结束后立即执行一些回调函数。如果poll阶段出现闲置或者脚本中使用&lt;code&gt;setImmediate( )&lt;/code&gt;添加了回调函数，事件循环事件循环就会主动进入check阶段而不会停下来等待。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setImmediate( )&lt;/code&gt;实际上是一个运行在独立阶段的特殊定时器。它通过调用&lt;code&gt;libuv&lt;/code&gt;提供的API添加那些希望在poll阶段完成以后执行的回调函数。&lt;/p&gt;
&lt;p&gt;通常，随着代码的执行，事件循环最终会到达poll阶段，它会在这里等待incoming connection,request等请求事件。然而，如果一个回调函数被&lt;code&gt;setImmediate( )&lt;/code&gt;添加时poll阶段处于空闲状态，它就会结束并进入check阶段而不是继续等待poll事件。&lt;/p&gt;
&lt;h3 id=&quot;close-callbacks&quot;&gt;close callbacks&lt;/h3&gt;
&lt;p&gt;如果一个socket或者句柄被突然关闭(比如调用&lt;code&gt;socket.destroy( )&lt;/code&gt;)，&lt;code&gt;close&lt;/code&gt;事件就会在这个阶段被发出。否则（其他形式触发的关闭）事件将会通过&lt;code&gt;process.nextTick( )&lt;/code&gt;来发送。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setImmediate( )&lt;/code&gt;和&lt;code&gt;setTimeout( )&lt;/code&gt;非常相似，但是表现却不相同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;setImmediate( )&lt;/code&gt;被设计来在当前poll阶段完成后执行一些脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout( )&lt;/code&gt;会把一个脚本添加为一定时间过去后才执行的“待执行任务”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种定时器被执行的顺序依赖于调用定时器的上下文。如果都是在主模块中调用，定时器就会与process的性能相关（这也意味着它可能被同一个机器上的其他应用影响）。&lt;/p&gt;
&lt;p&gt;例如下面的脚本中，如果我们一个不包含I/O周期的程序，他们的执行次序因为受到主线程性能的影响所以无法确定：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//timeout_vs_immediate.js
setTimeout(()=&amp;gt;{
    console.log('timeout');
},0);

setImmediate(()=&amp;gt;{
    console.log('immediate');
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，如果将这它们的调用时机放入I/O周期中，immediate回调函数就会率先被执行：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// timeout_vs_immediate.js
const fs = require('fs');

fs.readFile(__filename,()=&amp;gt;{
    setTimeout(()=&amp;gt;{
        console.log('timeout');
    },0);
    setImmediate(()=&amp;gt;{
        console.log('immediate');
    })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;setImmediate( )&lt;/code&gt;的主要优势在于在I/O回调函数中调用时，不论程序中有多少timers，它添加的回调函数总是比其他timers更早执行。&lt;/p&gt;
&lt;h2 id=&quot;proess.nexttick&quot;&gt;proess.nextTick( )&lt;/h2&gt;
&lt;h3 id=&quot;理解-process.nexttick&quot;&gt;理解 process.nextTick()&lt;/h3&gt;
&lt;p&gt;你可能已经注意到尽管同样作为异步API的一部分，&lt;code&gt;process.nextTick( )&lt;/code&gt;并没有展示在上面的图表中，因为技术层面来讲它并不是事件循环中的一部分。&lt;code&gt;nextTickQueue&lt;/code&gt;队列将会在当前操作执行完后立即执行，无论当前处于事件循环的哪个阶段，这里所说的操作是指底层的C/C++句柄到待执行JavaScript代码的过渡(这句怪怪的，不知道怎么翻译，原文是 an operation is defined as a transition from the underlying C/C++ handler, and handling the JavaScript that needs to be executed)。&lt;/p&gt;
&lt;p&gt;再来看上面的图表，任何时候当你在某个阶段调用&lt;code&gt;process.nextTick( )&lt;/code&gt;，所有传入的回调函数都会在event loop继续之前先被解析执行。这可能会造成非常严重的影响，因为它允许你阻塞通过递归调用&lt;code&gt;process.nextTick( )&lt;/code&gt;而使得事件循环产生阻塞，是它无法到达poll阶段。&lt;/p&gt;
&lt;h3 id=&quot;为什么会允许这种情况存在&quot;&gt;为什么会允许这种情况存在？&lt;/h3&gt;
&lt;p&gt;为什么这种匪夷所思的情况要被包含在Node.js中呢？一部分是由于Node.js的设计哲学决定的，Node.js中认为API无论是否有必要，都应该异步执行，例如下面的代码示例片段：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function apiCall(arg, callback) {
    if(typeof arg !== 'string')
        return process.nextTick(callback, new TypeError('argument should be string'));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例对参数进行了检查，如果参数类型是错误的，它就会将这个错误传递给回调函数。这个API允许&lt;code&gt;process.nextTick&lt;/code&gt;获取添加在callback之后的其他参数，并支持以冒泡的方式将其作为callback调用时传入的参数，这样你就不必通过函数嵌套来实现了。&lt;/p&gt;
&lt;p&gt;这里我们做的事情是允许剩余的代码执行完毕后再传递一个错误给用户。通过使用&lt;code&gt;process.nextTick( )&lt;/code&gt;就可以确保&lt;code&gt;apiCall( )&lt;/code&gt;方法总是在剩余的代码执行完和事件循环继续进行这两个时间点之间来执行回调函数。为了达到这个目的，JS调动栈就会允许立刻执行一些回调函数并允许用户在其中递归触发调用&lt;code&gt;process.nextTick( )&lt;/code&gt;，但是却不会造成爆栈（超过JavaScript引擎设置的调用栈最大容量）。&lt;/p&gt;
&lt;p&gt;这种设计哲学可能会导致一些潜在的情况。例如下面的示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let bar;

// this has an asynchronous signature, but calls callback synchronously
function someAsyncApiCall(callback){callback();}

// the callback is called before `someAsyncApiCall` completes
someAsyncApiCall(()=&amp;gt;{
    console.log('bar',bar);
});

bar = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户定义的&lt;code&gt;someAsyncApiCall( )&lt;/code&gt;虽然从注释上看是异步的，但实际上是一个同步执行的函数。当它被调用时，回调函数和&lt;code&gt;someAsyncApiCall( )&lt;/code&gt;实际上处于事件循环的同一个阶段，这里并没有任何实质上的异步行为，结果就是，回调函数尝试获取&lt;code&gt;bar&lt;/code&gt;这个标识符的值尽管作用域中并没有为这个变量赋值，因为脚本剩余的部分并没有执行完毕。&lt;/p&gt;
&lt;p&gt;如果将回调函数替换为&lt;code&gt;process.nextTick( )&lt;/code&gt;的形式，脚本中剩余的代码就可以执行完毕，这就使得变量和函数的初始化语句可以优先于传入的回调函数而被执行，这样做的另一个好处是它不会推动事件循环前进。这就使得用户可以在事件循环继续进行之前对一些可能的告警或者错误进行处理。比如下面的例子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let bar;

function someAsyncApiCall(callback) {
    process.nextTick(callback);
}

someAsyncApiCall(()=&amp;gt;{
   console.log('bar',bar); 
});

bar = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真实的场景中你会看到像下面这样的使用方式：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const server = net.createServer(()=&amp;gt;{}).listen(8080);

server.on('listening',()=&amp;gt;{});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当端口号传入后，就会立刻被绑定。所以&lt;code&gt;listening&lt;/code&gt;回调就会立即被执行，问题是&lt;code&gt;.on('listening')&lt;/code&gt;这个回调的设置看起来并没有执行到。&lt;/p&gt;
&lt;p&gt;这里实际上&lt;code&gt;listening&lt;/code&gt;事件的发送就是被&lt;code&gt;nextTick( )&lt;/code&gt;添加到待执行队列中的，这样后面的同步代码就可以执行完毕，这样的机制使得用户可以在后文设置更多的事件监听器。&lt;/p&gt;
&lt;h3 id=&quot;process.nexttick-对比setimmediate&quot;&gt;process.nextTick( )对比setImmediate( )&lt;/h3&gt;
&lt;p&gt;这两个方法的命名令很多开发者感到迷惑。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;process.nextTick( )&lt;/code&gt;会在事件循环的同一个阶段立刻触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate( )&lt;/code&gt;会在下一轮事件循环触发或者说事件循环的&lt;code&gt;tick&lt;/code&gt;时触发&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事实上它们实际做的事情和它们的命名应该交换一下。&lt;code&gt;process.nextTick( )&lt;/code&gt;比&lt;code&gt;setTimeout( )&lt;/code&gt;添加的回调要更早触发，但这种历史问题是很难去修正的，它会导致一大批npm包无法正常运作。每天还有大量的新的模块发布，这就意味着每过一天都有可能引发更多的破坏，尽管它们会造成混淆，但只能将错就错了。&lt;/p&gt;
&lt;p&gt;我们推荐开发者在开发中坚持使用&lt;code&gt;setImmediate( )&lt;/code&gt;，因为它的执行时机相对更容易推测（另外它也使得代码可以兼容更多的环境例如浏览器JS）。&lt;/p&gt;
&lt;h3 id=&quot;为什么使用process.nexttick&quot;&gt;为什么使用process.nextTick()&lt;/h3&gt;
&lt;p&gt;两个最主要的理由是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它允许用户优先处理错误，清理任何后续阶段不再使用的资源，或者在事件循环继续进行之前尝试重新发送请求。&lt;/li&gt;
&lt;li&gt;有时也需要在调用栈并不为空时去执行一些回调函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如下面的示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const server = net.createServer();
server.on('connection',conn=&amp;gt;{});

server.listen(8000);
server.on('listening',()=&amp;gt;{});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设想&lt;code&gt;listen()&lt;/code&gt;在事件循环开始时先执行，但是&lt;code&gt;listening&lt;/code&gt;事件的监听函数由&lt;code&gt;setImmediate()&lt;/code&gt;来添加。除非传入&lt;code&gt;hostname&lt;/code&gt;,否则端口不会被绑定。对于事件循环来说，它一定会到达poll阶段，如果此时已经有connection连接，那么connection事件就会在poll阶段被发出，但&lt;code&gt;listening&lt;/code&gt;事件要等到check阶段能够被发出。&lt;/p&gt;
&lt;p&gt;另一个示例是执行一个构造函数，它继承了&lt;code&gt;EventEmitter&lt;/code&gt;并且希望在构造函数中触发一个事件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);
  this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () =&amp;gt; {
  console.log('an event occurred!');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你不能在构造函数中立刻就触发这个事件，因为脚本还没有执行到位这个事件添加监听函数的那一句。所以，在构造函数内部你需要使用&lt;code&gt;process.nextTick( )&lt;/code&gt;来设置事件发送的语句，才可以保证事件触发时，监听器已经被注册，示例如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);

  // use nextTick to emit the event once a handler is assigned
  process.nextTick(() =&amp;gt; {
    this.emit('event');
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () =&amp;gt; {
  console.log('an event occurred!');
});&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Jun 2019 14:29:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashnowords/p/11042623.html</dc:identifier>
</item>
</channel>
</rss>