<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Springboot 系列（九）使用 Spring JDBC 和 Druid 数据源监控 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10435635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10435635.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26371673/53475209-5d8ec600-3aaa-11e9-84c4-0d02f8127e4f.png&quot; alt=&quot;监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为一名 Java 开发者，相信对 JDBC（Java Data Base Connectivity）是不会陌生的，JDBC作为 Java 基础内容，它提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。下面演示下 Springboot 中如何使用 JDBC 操作，并配置使用 Druid 连接池，体验 Druid 对数据库操作强大的监控和扩展功能。Alibaba-Durid 官方手册&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot;&gt;点这里&lt;/a&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库准备&quot;&gt;1. 数据库准备&lt;/h2&gt;
&lt;p&gt;使用mysql数据库创建数据库 springboot，并在库中新建数据表 user 并新增两条信息。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `age` int(11) DEFAULT NULL,
  `birthday` datetime DEFAULT NULL,
  `password` varchar(32) NOT NULL,
  `skills` varchar(255) DEFAULT NULL,
  `username` varchar(32) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

# 新增数据
INSERT INTO `springboot`.`user`(`id`, `age`, `birthday`, `password`, `skills`, `username`) VALUES (1, 17, '2019-01-12 21:02:30', '123', 'Go', 'Darcy');
INSERT INTO `springboot`.`user`(`id`, `age`, `birthday`, `password`, `skills`, `username`) VALUES (3, 23, '2019-01-01 00:11:22', '456', 'Java', 'Chris');&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;2. 添加依赖&lt;/h2&gt;
&lt;p&gt;新建一个 Springboot项目，这里不说。添加依赖如下。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- spring jdbc 操作模版 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- springboot web开发 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- mysql 数据库连接 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 引入druid数据源 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置数据源信息&quot;&gt;3. 配置数据源信息&lt;/h2&gt;
&lt;p&gt;常规的 JDBC 配置不需要配置这么多内容，这里因为使用了 Druid 连接池，所以配置了 Druid 部分。对自动配置不理解的可以查看系列文章&lt;a href=&quot;https://www.codingme.net/2019/01/springboot/springboot02-config/#4-%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BD%BF%E7%94%A8&quot;&gt;Springboot 系列（二）Spring Boot 配置文件&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  datasource:
    username: root
    password: 123
    url: jdbc:mysql://127.0.0.1:3306/springboot?characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
    filters: stat
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完毕之后，配置信息还不能绑定到 Druid数据源中，还需要新建一个配置类绑定数据源和配置信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * &amp;lt;p&amp;gt;
 * Druid 数据源配置
 *
 * @Author niujinpeng
 * @Date 2019/1/14 22:20
 */
@Configuration
public class DruidConfig {
    /**
     * 配置绑定
     * @return
     */
    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    public DruidDataSource druid() {
        return new DruidDataSource();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，数据源已经配置完毕，编写测试方法测试 druid 连接池是否生效。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootDataJdbcApplicationTests {
    @Autowired
    DataSource dataSource;
    /**
     * 测试JDBC数据源
     * @throws SQLException
     */
    @Test
    public void contextLoads() throws SQLException {
        System.out.println(dataSource.getClass());
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行看到 contextLoads 输出信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class com.alibaba.druid.pool.DruidDataSource
Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
2019-02-27 14:14:56.144  INFO 12860 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited
com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@3e104d4b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出日志中的 com.alibaba.druid 说明 Druid 已经生效。&lt;/p&gt;
&lt;h2 id=&quot;使用-spring-jdbc&quot;&gt;4. 使用 Spring-JDBC&lt;/h2&gt;
&lt;p&gt;传统的 JDBC 使用中，需要编写大量代码，从构造 PreparedStatement 到查询不胜其烦。面对这样的开发痛点，Spring 封装了 Spring-jdbc. 让我们使用 JdbcTemplate 即可轻松的操作数据库。Spring-jdbc 的详细使用不是这篇文章重点，只简单演示下是否生效。&lt;br/&gt;编写控制器，查询一个 user 信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class JdbcController {
    @Autowired
    JdbcTemplate jdbcTemplate;
    @ResponseBody
    @GetMapping(&quot;/query&quot;)
    public Map&amp;lt;String, Object&amp;gt; map() {
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = jdbcTemplate.queryForList(&quot;select * FROM user&quot;);
        return list.get(0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动spring 项目，请求 /query 接口得到正常响应。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
&quot;id&quot;: 1,
&quot;age&quot;: 17,
&quot;birthday&quot;: &quot;2019-01-12T13:02:30.000+0000&quot;,
&quot;password&quot;: &quot;123&quot;,
&quot;skills&quot;: &quot;Go&quot;,
&quot;username&quot;: &quot;Darcy&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见 Spring-JDBC 已经从数据库中取出了数据信息。&lt;/p&gt;
&lt;h2 id=&quot;使用-druid-监控&quot;&gt;5. 使用 Druid 监控&lt;/h2&gt;
&lt;p&gt;如果使用 Druid 连接池却不使用监控功能，那么就有点暴殄天物了。下面开始配置 Druid 的 SQL 监控功能。在上面写的 DruidConfig 配置类中增加配置 Druid 的 Servlet 和 Filter.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Druid的servlet
     * @return
     */
    @Bean
    public ServletRegistrationBean statViewServlet() {
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet());
        Map&amp;lt;String, String&amp;gt; initParams = new HashMap&amp;lt;&amp;gt;();
        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;, &quot;123&quot;);
        initParams.put(&quot;allow&quot;,&quot;127.0.0.1&quot;);
        bean.setInitParameters(initParams);
        bean.setUrlMappings(Arrays.asList(&quot;/druid/*&quot;));
        return bean;
    }
    @Bean
    public FilterRegistrationBean webStatFilter() {
        FilterRegistrationBean&amp;lt;WebStatFilter&amp;gt; bean = new FilterRegistrationBean&amp;lt;&amp;gt;(new WebStatFilter());
        HashMap&amp;lt;String, String&amp;gt; initParams = new HashMap&amp;lt;&amp;gt;();
        initParams.put(&quot;exclusions&quot;, &quot;/css,/druid/*&quot;);
        bean.setInitParameters(initParams);
        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        return bean;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置了 Druid 监控访问路径为 &lt;code&gt;/druid&lt;/code&gt;、登录用户是 &lt;code&gt;admin&lt;/code&gt;、登录密码是&lt;code&gt;123&lt;/code&gt;、允许访问的IP是&lt;code&gt;127.0.0.1&lt;/code&gt; 本机、不需要监控的请求是 &lt;code&gt;/css&lt;/code&gt; 和 &lt;code&gt;/druid&lt;/code&gt; 开头的请求。&lt;/p&gt;
&lt;p&gt;重新启动项目，访问测试 &lt;code&gt;/query&lt;/code&gt;，然后访问 &lt;code&gt;/durid&lt;/code&gt; 登录页。&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26371673/53473086-74321e80-3aa4-11e9-83b1-9bdcd1313fb2.png&quot; alt=&quot;Druid 登录页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录后可以看到 SQL 监控信息和 URL 监控等信息。&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26371673/53474904-777bd900-3aa9-11e9-86f3-7ee3bab9aa66.png&quot; alt=&quot;SQL 监控&quot;/&gt;&lt;br/&gt;URL 监控。&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26371673/53474934-8c586c80-3aa9-11e9-94d1-8ff0540285fd.png&quot; alt=&quot;URL 监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章代码已经上传到 GitHub &lt;a href=&quot;https://github.com/niumoo/springboot/tree/master/springboot-data-jdbc&quot;&gt;Spring Boot jdb&lt;/a&gt;。&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;6.1218181818182&quot;&gt;
&lt;div readability=&quot;7.5345454545455&quot;&gt;本文作者：&lt;strong&gt;雪漫士兵&lt;/strong&gt;&lt;br/&gt;我的微信：wn8398&lt;br/&gt;原文出处：&lt;a href=&quot;https://www.codingme.net&quot;&gt;www.codingme.net&lt;/a&gt; 
&lt;p&gt;本片文章是博主原创文章，欢迎转载，转载时在明显位置注明原文链接即可。&lt;/p&gt;
&lt;strong&gt;如果觉得这篇内容有趣好玩有帮助，不妨关注公众号点个好看推荐。&lt;/strong&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 27 Feb 2019 16:52:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>前言 作为一名 Java 开发者，相信对 JDBC（Java Data Base Connectivity）是不会陌生的，JDBC作为 Java 基础内容，它提供了一种基准，据此可以构建更高级的工具和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10435635.html</dc:identifier>
</item>
<item>
<title>目标检测综述 - FANG_YANG</title>
<link>http://www.cnblogs.com/fydeblog/p/10447875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fydeblog/p/10447875.html</guid>
<description>&lt;p&gt;这篇综述是我统计信号处理的作业，在这里分享一下，将介绍计算机视觉中的目标检测任务，论述自深度学习以来目标检测的常见方法，着重讲yolo算法，并且将yolo算法与其他的one-stage以及two-stage方法进行比较。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;1.介绍&lt;/li&gt;
&lt;li&gt;2.YOLO
&lt;ul&gt;&lt;li&gt;2.1 YOLOv1&lt;/li&gt;
&lt;li&gt;2.2 YOLOv2&lt;/li&gt;
&lt;li&gt;2.3 YOLOv3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.其他方法
&lt;ul&gt;&lt;li&gt;RCNN&lt;/li&gt;
&lt;li&gt;FastRCNN&lt;/li&gt;
&lt;li&gt;FasterRCNN&lt;/li&gt;
&lt;li&gt;SSD&lt;/li&gt;
&lt;li&gt;RetinaNet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4.实验结果比较&lt;/li&gt;
&lt;li&gt;5.总结&lt;/li&gt;
&lt;li&gt;参考文献&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;strong&gt;1. 介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;目标检测在现实中的应用很广泛，我们需要检测数字图像中的物体位置以及类别，它需要我们构建一个模型，模型的输入一张图片，模型的输出需要圈出图片中所有物体的位置以及物体所属的类别，见图1。在深度学习浪潮到来之前，目标检测精度的进步十分缓慢，靠传统依靠手工特征的方法来提高精度已是相当困难的事。而ImageNet分类大赛出现的卷积神经网络（CNN）——AlexNet[1]所展现的强大性能，吸引着学者们将CNN迁移到了其他的任务，这也包括着目标检测任务，近年来，出现了很多目标检测的方法，这里将介绍YOLO[2]-[4]，RCNN[5]-[7]，SSD[8]，RetinaNet[9]系列的方法，其中YOLO，SSD，RetinaNet都是one-stage方法，原始RCNN事multi-stage方法，它的延伸FastRCNN以及FasterRCNN则是two-stage方法。RCNN系列方法是先生成候选框，然后根据候选框来进行坐标回归预测，而YOLO，SSD，RetinaNet则是直接进行回归生成坐标回归，没有经过候选框这一步。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/sc1epxnsftdjg7sqlbzwnnka/image_1d4noisuk14qjqsf1g38ei71abg9.png&quot; alt=&quot;image_1d4noisuk14qjqsf1g38ei71abg9.png-156.8kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图1 目标检测[12]&lt;/center&gt;
&lt;h2 id=&quot;yolo&quot;&gt;&lt;strong&gt;2.YOLO&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这一节将开始详细地叙述YOLO三部曲，先介绍YOLOv1，更好更简单地了解YOLO的原理和思想，然后分别介绍YOLOv2以及YOLOv3，看看这两个模型是使用那些技巧来提升性能。&lt;/p&gt;
&lt;h3 id=&quot;yolov1&quot;&gt;&lt;strong&gt;2.1 YOLOv1&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;流程&lt;/strong&gt;：首先YOLOv1会把图像看成一个sxs的栅格，这里的s是等于7，每个栅格预测2个bounding boxes以及栅格含有对象的置信度，同时每个栅格还是预测栅格所属的对象类别，然后通过一些处理方式得到最后的结果，这个处理方式后面会讲到。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/t9xrh5b9z8otwtk9qssf5k1n/image_1d4nolgng12b54l1b7r1unpfuam.png&quot; alt=&quot;image_1d4nolgng12b54l1b7r1unpfuam.png-92.7kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图2 YOLOv1流程&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;架构&lt;/strong&gt;：然后，我们来看看YOLOv1的架构，YOLOv1由24层卷积层，4个最大池化层和2个全连接层组成，常规操作，我们关注最后的输出是7x7x30，这里是7x7代表输入图像的7x7栅格，一一对应，30的前十个代表2个bounding boxes的坐标以及对象的置信度，后20个代表VOC数据集的20个类别。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/kjitri1fzcqkgm7luc39qvba/image_1d4nonqca1f9m12b81bltbrhu5113.png&quot; alt=&quot;image_1d4nonqca1f9m12b81bltbrhu5113.png-43.8kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图3 YOLOv1架构&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;标签定义&lt;/strong&gt;：YOLOv1是一个监督式的网络，有监督那就有标签，来看看标签是怎样定义，首先看狗，它被一个框框起来了，这个框就是真实的标签，框对应的中心在哪个栅格，就代表当前栅格是狗所在的栅格，这个栅格里就会记录狗的标签信息，自行车和小车和狗类似。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/h26halz0i5kk30b5f7rna5ae/image_1d4nopn041ofn1qk61rhb17rc142r1g.png&quot; alt=&quot;image_1d4nopn041ofn1qk61rhb17rc142r1g.png-91kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图4 标签定义&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;：首先，这个λ是bounding box坐标损失的权重，外层求和是多少个栅格，内层求和是每个栅格的B个Boxes，这个像一的符号，它代表当前box中是否含有真实标签对象，坐标预测我们只计算有对象的栅格，其他的栅格不进行计算，这个Ci代表当前栅格含有对象的概率，不光要计算含有对象的，也要计算没有含有对象的，最后的类别，只计算含有对象的栅格，没有包含对象的不考虑。根据这个损失进行反向传播，一步步优化YOLOv1模型。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/keemy8gzwolare2esu9gtwke/image_1d4nor6ltvot1eu6f3p130k1vt81t.png&quot; alt=&quot;image_1d4nor6ltvot1eu6f3p130k1vt81t.png-31.2kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图5 损失函数&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;交并比&lt;/strong&gt;（&lt;strong&gt;IOU&lt;/strong&gt;）: 这是一个评价两个bounding box相互重合程度的指标，这个指标等于两个bounding box的交集面积除以它们并集的面积。当两个bounding box没有任何交集时，IoU为0，即IoU的最小取值，当两个bounding box完全重合时，IoU为1，即IoU的最大取值，所以IoU的取值范围是[0,1]。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/ir3kimuky0vcjxbqnqgfho45/image_1d4not4kl1pfmpv11biviek1o8g2a.png&quot; alt=&quot;image_1d4not4kl1pfmpv11biviek1o8g2a.png-12.3kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图6 交并比&lt;a href=&quot;http://static.zybuluo.com/fangyang970206/l1j83jpj300q7m664p9clxvr/image_1d4npb34o1va719vd10fhc1f1cfi55.png&quot;&gt;13&lt;/a&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;推断&lt;/strong&gt;：给定一张图，运行YOLO后，总共有98个bounding box输出出来，可以通过非极大值抑制算法得到最后可靠的结果。大致分两步，第一步根据阈值去除那些置信度低的bounding box，然后进入一个循环，首先挑选出最大置信度的bounding box作为预测输出，然后去除那些与这个最大置信度的bounding box的IoU超过0.5的bounding box，因为我们可以看到一个对象有很多bounding box，它们很多是相交的，这样一个对象的bounding box就确定好了，然后，我们再进入循环，找出下一个对象的bounding box，最后直到没有剩余的bounding box，循环结束。&lt;/p&gt;
&lt;h3 id=&quot;yolov2&quot;&gt;&lt;strong&gt;2.2 YOLOv2&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从三个方面开始介绍YOLOv2，Better，Faster，Stronger。&lt;br/&gt;&lt;strong&gt;Better&lt;/strong&gt;：批归一化，高分辨分类器，锚盒，维度聚类，细粒度特征以及多尺度训练。&lt;/p&gt;
&lt;p&gt;批归一化[14]（Batch Normalization）的效果则是将数据分布映射到相对紧凑的分布，让网络可以更快以及更好地学习，避免过拟合，使用批归一化这一操作提升了2%mAP。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/m6hn7v4i6dtew7jvs53fxexe/image_1d4np0rls1n5ro8j974j5cijr2n.png&quot; alt=&quot;image_1d4np0rls1n5ro8j974j5cijr2n.png-30.3kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图7 批归一化&lt;/center&gt;
&lt;p&gt;YOLOv2采用了高分辨率的分类器，在YOLOv1中，将在imagenet预训练好的网络迁移到目标检测网络中，而训练imagenet数据集的输入的大小和目标检测网络的输入尺寸是不一致的，这意味目标检测网络需要同时取学习目标检测而且还要去适应新的分辨率输入，所以YOLOv2使用目标检测输入的分辨率微调了分类网络，然后迁移到目标检测网络中去，这样，目标检测网络就可以专攻学习目标检测了，通过这一技巧，使mAP上升了4%。&lt;br/&gt;在YOLOv1中，最后是使用全连接层来生成bounding box的坐标，然而使用全连接的缺点在于丢失了特征图的空间信息，造成定位不准，作者借鉴了Faster Rcnn中锚框的思想，利用锚框直接在卷积特征图滑窗采样，因为卷积不需要Reshape，所以很好的保留的空间信息，最终使特征图的每个特征点和原图的每个栅格一一对应。另外，与YOLOv1不同的是，YOLOv2是预测的是坐标相对于栅格左顶点的偏移量，通过变换公式得到最后的预测坐标。既然锚框是手动精选的先验框，设想能否一开始就选择了更好的、更有代表性的先验Boxes维度，那么网络就应该更容易学到准确的预测位置。所以作者通过K-means聚类算法将数据集中的ground truth进行了聚类。最后对模型复杂度和召回率的平衡，选择5个聚类中心，挑选了5个最具代表性的bounding box。一起提升了5%mAP。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/tkkp27t66hszpkh40i0xfq2l/image_1d4np38ah16idu3bs6q109q1i3534.png&quot; alt=&quot;image_1d4np38ah16idu3bs6q109q1i3534.png-408.4kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/lhc1iwiay3d34smf462dw2jk/image_1d4np3jdl1e3e19nn1gadio51jqj3h.png&quot; alt=&quot;image_1d4np3jdl1e3e19nn1gadio51jqj3h.png-26kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图10 锚盒K-means聚类&lt;/center&gt;
&lt;p&gt;细粒度特征对于检测小物体是有很大的影响，随着图像尺寸的一步步缩小，图片中的某些小物体的特征是会由于特征图的不断缩小而发生信息丢失，作者通过引入了一个Passthrough Layer，把浅层特征图连接到深层特征图，也就是图中这个26x26x512的特征图通过隔行隔列采样，变换成13x13x2048的特征图，然后和13x13x1024的特征图进行按通道concat，通过这一操作，可以使mAP提升一个百分点。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/k76fdab8ss6ykmolr4uqlplg/image_1d4np5mcj1qej158b14rss29nfh3u.png&quot; alt=&quot;image_1d4np5mcj1qej158b14rss29nfh3u.png-34kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图11 细粒度特征的引入[16]&lt;/center&gt;
&lt;p&gt;然后使为了让YOLOv2对不同尺寸图片的具有鲁棒性，引入了多尺寸的训练，每10batch，选择新的图像尺寸对网络进行训练，最后使精度提升了2个百分点。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/cbiu20sa0fysibax5f478qn6/image_1d4np7bbe2sh1caq6i8atq1ssk4b.png&quot; alt=&quot;image_1d4np7bbe2sh1caq6i8atq1ssk4b.png-52.7kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图12 多尺度训练&lt;/center&gt;
&lt;p&gt;通过一系列的改进，YOLOv2相比于YOLOv1，一下子提高了15个点。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/5jkt29inar6dyrwam4mn0qhw/image_1d4np9pp89k28l999m1ils1lbh4o.png&quot; alt=&quot;image_1d4np9pp89k28l999m1ils1lbh4o.png-44.2kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图13 better总览图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;Faster&lt;/strong&gt;：YOLOv2简化了网络，只使用了19卷积层和5个池化层（Darknet-19），不仅通过一系列的改进使精度高了，速度方面依然比YOLOv1还要快。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/l1j83jpj300q7m664p9clxvr/image_1d4npb34o1va719vd10fhc1f1cfi55.png&quot; alt=&quot;image_1d4npb34o1va719vd10fhc1f1cfi55.png-76.9kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图14 YOLOv2&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;Stronger&lt;/strong&gt;：强大之处体现在YOLO9000，YOLO9000是在YOLOv2的基础上提出的一种可以检测超过9000个类别的模型，其主要贡献点在于提出了一种分类和检测的联合训练策略。对于检测数据集，可以用来学习预测物体的边界框、置信度以及为物体分类，而对于分类数据集可以仅用来学习分类，但是其可以大大扩充模型所能检测的物体种类。但是遇到的一个问题是两个数据集的类别不是完全互斥的，比如ImageNet光狗的品种就有100多种，它们与COCO数据集中狗的类别产生冲突，两者是包含关系，针对这一问题，作者提出了一种层级分类方法，主要思路是根据各个类别之间的从属关系建立一种树结构，也就是WordTree。&lt;/p&gt;
&lt;p&gt;论文中给出了COCO数据集和ImageNet数据集联合生成的树结构，蓝色的是COCO数据集的类别，橘色的是imageNet的类别，图15给出一个例子，比如imagenet有这两种不同类型的小猎狗，它们输入小猎狗这一分支，也属于猎狗分支，还属于COCO数据集中狗这一分支，还属于犬类这一分支。这就是wordtree的构造形式。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/fd1f40244f28ivsxy37y22jk/image_1d4npcklt10kd3uegje1qga197v5i.png&quot; alt=&quot;image_1d4npcklt10kd3uegje1qga197v5i.png-99.7kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图15 COCO与ImageNet联合生成的wordtree&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/8if55rglc171i2azjg75aji1/image_1d4npdn7j16pddfk4c93dm1b865v.png&quot; alt=&quot;image_1d4npdn7j16pddfk4c93dm1b865v.png-15.6kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图16 wordtree例子&lt;/center&gt;
&lt;p&gt;每个节点的子节点都属于同一子类，所以可以对它们分类型进行softmax处理。这样就解决了原始分类的冲突问题。在训练时，如果是检测样本，按照YOLOv2的loss计算误差，而对于分类样本，只计算分类误差。在预测时，YOLOv2给出的置信度是根结点的置信度 ，同时会给出边界框位置以及一个树状概率图。在这个概率图中找到概率最高的路径，当达到某一个阈值时停止，就用当前节点表示预测的类别。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/oo15ana2va0ulrlkq5ywc4jv/image_1d4npfj8o1m4u1864bhu1vmu12ka6c.png&quot; alt=&quot;image_1d4npfj8o1m4u1864bhu1vmu12ka6c.png-46.1kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图17 wordtree的softmax处理&lt;/center&gt;
&lt;h3 id=&quot;yolov3&quot;&gt;&lt;strong&gt;2.3 YOLOv3&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;YOLOv3给出的是一个科技报告，在保持实时性的基础上，对YOLOv2进行了几点改进，主要有三点：采用逻辑回归预测置信度和进行分类，从三个尺度上预测b-box的坐标以及特征提取器发生变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑回归的使用&lt;/strong&gt;：在YOLOv2中，每个cell是直接通过网络回归预测b-box坐标和置信度的，YOLOv3则将置信度和坐标分开预测，坐标预测还是通过网络进行预测，而置信度则是单独通过逻辑回归进行预测。在分类上，没有使用softmax多分类，作者也指出softmax最终对性能也没有提升，而且softmax假设是每个box只有一个类，这对迁移到更大有多种类别标签的数据集是没有好处的，所以作者使用多个逻辑回归来预测分类，使用二元交叉熵计算分类损失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征提取器&lt;/strong&gt;：YOLOv3重新训练了一个新的特征提取器——DarkNet-53，使用了残差网络，相比最先进的特征提取器，性能相当，但浮点数运算更少，速度更快，下采样没有使用池化操作，而是通过卷积步长来实现。图18是DarkNet-53的结构图。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/h45pl1uplqh9ay02l2oqxsmy/image_1d4npi4p4ph580nbvs13orcpr6p.png&quot; alt=&quot;image_1d4npi4p4ph580nbvs13orcpr6p.png-95kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图18 DarkNet-53结构图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;多尺度预测坐标&lt;/strong&gt;：作者借由FPN的思想，引用中间层的输出与后层输出进行融合，进行三个尺度预测，每个尺度的每个cell预测3个坐标，以上面为例，下采样32倍，最后一起的输出是8x8x1024，通过卷积层和逻辑回归得到8x8x255（255=3x（5+80），5是坐标加置信度，80是coco类别），这就是第一个尺度的预测输出，第二个尺度是8x8x1024通过上采样与卷积通过缩放变成16x16x512，然后与上一个stage的16x16x512进行concat，然后通过相似的方式生成16x16x255，类似的操作得到，得到32x32x255。&lt;/p&gt;
&lt;h2 id=&quot;其他方法&quot;&gt;&lt;strong&gt;3.其他方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;R-CNN&lt;/strong&gt;：将深度学习应用到目标检测的开创性工作之一，处理过程如图19所示，具体有四步，第一步是使用选择性搜索对输入图像提取不同尺寸不同形状大小的候选区域，第二步是选取一个预训练好的深度学习分类模型，将输出层截取掉，将候选区域形变为网络输入需要的固定形状，得到每个候选区域的特征图。第三步是将特征图与类别标签联合，通过多个SVM分类器来进行分类。第四步是将特征图与位置标签联合，通过线性回归模型预测真实边界框。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/5fkvrnqbfmdtr9l0r8qmwfuv/image_1d4nplcds8in19l6jpkrhh1l6n76.png&quot; alt=&quot;image_1d4nplcds8in19l6jpkrhh1l6n76.png-88.9kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图19 R-CNN流程图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;FastRCNN&lt;/strong&gt;：RCNN是很慢的，每个候选区域都要通过前向传播，许多候选区域是相互重叠的，FastRCNN还是通过选择性搜索得到候选框，但FastRCNN是将输入图像直接通过预训练模型，将候选框映射到特征图中进行提取感兴趣区域，然后不同大小的区域通过RoI Pooling层得到相同大小的特征向量，最后通过两个全连接层得到类别和边界框的预测。具体如下图20所示。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/mkbd20chvao2lw0tzz6bylb7/image_1d4npmf3q13cs17oj1ucc1t2o16747j.png&quot; alt=&quot;image_1d4npmf3q13cs17oj1ucc1t2o16747j.png-109.7kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图19 FastRCNN流程图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;FasterRCNN&lt;/strong&gt;：FastRCNN需要通过选择性搜索得到许多候选框，才能得到较准确的精度，FasterRCNN针对这一问题，提出将选择性搜索替换成区域候选网络（RPN），通过网络自动学习提取好的候选区域，从而可以减少候选区域的数目，提高速度并保证了精度。具体做法是将特征提取的网络输出通过一个填充为1的3x3的卷积层变换为通道为512的特征图，这样特征图的每个单元都有512维的特征向量，以每个单元为中心，生成9个不同的锚盒（3个大小，3个不同高宽比）并标注它们，使用单元的特征向量预测锚框的二元类别（foreground-background）以及位置坐标，最后使用非极大值抑制去除相似重复的目标边界框。RPN的大致流程如图20所示。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/6meqan1alnlwsiy2tfbcqwb4/image_1d4nporjg11hlm2u1kaf1q5e3m780.png&quot; alt=&quot;image_1d4nporjg11hlm2u1kaf1q5e3m780.png-55.4kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图20 RPN流程图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;SSD&lt;/strong&gt;：SSD全称是单发多框检测，它的具体流程如图21所示。首先还是通过截断全连接层的VGG网络提取特征，得到Conv6特征图，其中VGG中间层Conv4_3的特征图后面会用到，然后将Conv特征图不断地减半，得到了5个不同大小的特征图，这样，分别在Conv4_3的特征图以及这5个特征图生成锚盒，预测类别与边界框，方法与FasterRCNN类似，对于宽高大的特征图，感受野小，锚框多，适合检测小的物体，而对于宽高小的特征图，感受野大，锚框少，则适合检测大的物体，所以SSD还是一种多尺度的目标检测网络。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/7vqejijrofebtlnhgdv8898g/image_1d4npq75g1mv611fh1tjq1bti1d5o8d.png&quot; alt=&quot;image_1d4npq75g1mv611fh1tjq1bti1d5o8d.png-47.5kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图21 SSD流程图&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;RetinaNet&lt;/strong&gt;：上面介绍了one-stage的检测器（SSD，YOLO）以及two-stage的检测器（RCNN系列），但往往two-stage的检测器性能要强于one-stage，但速度要慢，RetinaNet这篇文章就指出one-stage性能差的一个重要原因是由b-box的foreground-background类别不平衡问题引起的。Two-stage方法会筛选b-box（RPN减少了background的数目）并且训练过程会设置foreground-background的比例，类别不平衡的问题要轻许多，而one-stage的方法则是直接回归最后的边界框预测，对于一个二分类器来讲，某一个类别数目过大，会导致分类器偏向数目大的类别（也就是忽略了重要有物体的foreground，偏向图像的背景），这个问题会导致目标检测的精度很低。针对这一问题，这篇文章提出了Focal Loss，通过简单的loss函数改变，来解决类别不平衡的问题。公式如图22所示。由标准的交叉熵损失修改而成。α_t和γ参数减少了好分类的样本的损失，并让分类器更集中解决更困难样本。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/f4p60b1f17mvka3f7gtzgicg/image_1d4nprnso1fv61d231usk2ctl5c8q.png&quot; alt=&quot;image_1d4nprnso1fv61d231usk2ctl5c8q.png-6.2kB&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;图22 Focal loss&lt;/center&gt;
&lt;h2 id=&quot;实验结果比较&quot;&gt;&lt;strong&gt;4.实验结果比较&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;目标检测算法一般是在VOC[10]和COCO[11]数据集中进行测试的，下表1给出上述算法在这两个数据集中的测试结果。限于篇幅，还有很多方法没有讲，特别是更先进的two-stage算法，同时期的two-stage 方法是要比one-stage方法在性能上是要强的，这里只介绍最基本的two-stage方法。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;表1 VOC2007与COCO test-dev的测试结果&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://static.zybuluo.com/fangyang970206/0vot3j7wkk694a17epaz42rx/image_1d4npvd8vt7c1p7l1het1u30tgt97.png&quot; alt=&quot;image_1d4npvd8vt7c1p7l1het1u30tgt97.png-103.1kB&quot;/&gt;&lt;/center&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;strong&gt;5.总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对于目标检测这一任务而言，如果更关注性能指标，则可以参考two-stage系列的方法，而如果更关注实时性的要求，则可以关注one-stage的方法，这篇报告特别讲述了one-stage的YOLO算法，YOLO是以实时性为基础的快速目标检测算法，这种方法很快，也有许多工作，面向GPU和CPU实时性的目标检测算法都有人做出来，YOLO的含义也很有意思，YOLO——you only look once，其实还有一种说法，you only live once，别犹豫了，用起来吧。&lt;/p&gt;
&lt;p&gt;如有发现错误，还请指出，十分感谢！转载请注明本文地址，谢谢！&lt;/p&gt;
&lt;center&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/h2&gt;
&lt;/center&gt;
&lt;p&gt;[1] Krizhevsky A , Sutskever I , Hinton G . ImageNet Classification with Deep Convolutional Neural Networks[J]. Advances in neural information processing systems, 2012, 25(2).&lt;br/&gt;[2] Redmon J , Divvala S , Girshick R , et al. You Only Look Once: Unified, Real-Time Object Detection[J]. 2015.&lt;br/&gt;[3] Redmon J , Farhadi A . [IEEE 2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - Honolulu, HI (2017.7.21-2017.7.26)] 2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - YOLO9000: Better, Faster, Stronger[C]// IEEE Conference on Computer Vision &amp;amp; Pattern Recognition. IEEE, 2017:6517-6525.&lt;br/&gt;[4] Redmon, J., and Farhadi, A.: 2016, arXiv e-prints, arXiv:1612.08242.&lt;br/&gt;[5] Girshick R , Donahue J , Darrell T , et al. Region-Based Convolutional Networks for Accurate Object Detection and Segmentation[J]. IEEE Transactions on Pattern Analysis &amp;amp; Machine Intelligence, 2015, 38(1):142-158.&lt;br/&gt;[6] Girshick R . Fast R-CNN[J]. Computer Science, 2015.&lt;br/&gt;[7] Ren S , He K , Girshick R , et al. Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks[J]. 2015.&lt;br/&gt;[8] Liu W , Anguelov D , Erhan D , et al. SSD: Single Shot MultiBox Detector[J]. 2015.&lt;br/&gt;[9] Lin T Y , Goyal P , Girshick R , et al. Focal Loss for Dense Object Detection[J]. IEEE Transactions on Pattern Analysis &amp;amp; Machine Intelligence, 2017, PP(99):2999-3007.&lt;br/&gt;[10] Everingham M , Eslami S M A , Van Gool L , et al. ThePascalVisual Object Classes Challenge: A Retrospective[J]. International Journal of Computer Vision, 2015, 111(1):98-136.&lt;br/&gt;[11] Lin T Y , Maire M , Belongie S , et al. Microsoft COCO: Common Objects in Context[J]. 2014.&lt;br/&gt;[12] &lt;a href=&quot;http://cs231n.stanford.edu/slides/2018/cs231n_2018_lecture11.pdf&quot; class=&quot;uri&quot;&gt;http://cs231n.stanford.edu/slides/2018/cs231n_2018_lecture11.pdf&lt;/a&gt;&lt;br/&gt;[13] &lt;a href=&quot;https://blog.csdn.net/iamoldpan/article/details/78799857&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/iamoldpan/article/details/78799857&lt;/a&gt;&lt;br/&gt;[14] Ioffe S , Szegedy C . Batch normalization: accelerating deep network training by reducing internal covariate shift[C]// International Conference on International Conference on Machine Learning. JMLR.org, 2015.&lt;br/&gt;[15] &lt;a href=&quot;https://towardsdatascience.com/training-object-detection-yolov2-from-scratch-using-cyclic-learning-rates-b3364f7e4755&quot; class=&quot;uri&quot;&gt;https://towardsdatascience.com/training-object-detection-yolov2-from-scratch-using-cyclic-learning-rates-b3364f7e4755&lt;/a&gt;&lt;br/&gt;[16] &lt;a href=&quot;http://ethereon.github.io/netscope/#/gist/d08a41711e48cf111e330827b1279c31&quot; class=&quot;uri&quot;&gt;http://ethereon.github.io/netscope/#/gist/d08a41711e48cf111e330827b1279c31&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 16:11:00 +0000</pubDate>
<dc:creator>FANG_YANG</dc:creator>
<og:description>这篇博客将介绍自深度学习以来目标检测的常见方法（YOLO，RCNN，SSD，RetinaNet），重点讲YOLO算法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fydeblog/p/10447875.html</dc:identifier>
</item>
<item>
<title>Perl IO：文件锁 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10447881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10447881.html</guid>
<description>&lt;h2 id=&quot;文件锁&quot;&gt;文件锁&lt;/h2&gt;
&lt;p&gt;当多个进程或多个程序都想要修同一个文件的时候，如果不加控制，多进程或多程序将可能导致文件更新的丢失。&lt;/p&gt;
&lt;p&gt;例如进程1和进程2都要写入数据到a.txt中，进程1获取到了文件句柄，进程2也获取到了文件句柄，然后进程1写入一段数据，进程2写入一段数据，进程1关闭文件句柄，会将数据flush到文件中，进程2也关闭文件句柄，也将flush到文件中，于是进程1的数据被进程2保存的数据覆盖了。&lt;/p&gt;
&lt;p&gt;所以，多进程修改同一文件的时候，需要协调每个进程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保证文件在同一时间只能被一个进程修改，只有进程1修改完成之后，进程2才能获得修改权&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;进程1获得了修改权，就不允许进程2去读取这个文件的数据，因为进程2可能读取出来的数据是进程1修改前的过期数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种协调方式可以通过文件锁来实现。文件锁分两种，独占锁(写锁)和共享锁(读锁)。当进程想要修改文件的时候，申请独占锁(写锁)，当进程想要读取文件数据的时候，申请共享锁(读锁)。&lt;/p&gt;
&lt;p&gt;独占锁和独占锁、独占锁和共享锁都是互斥的。只要进程1持有了独占锁，进程2想要申请独占锁或共享锁都将失败(阻塞)，也就保证了这一时刻只有进程1能修改文件，只有当进程1释放了独占锁，进程2才能继续申请到独占锁或共享锁。但是共享锁和共享锁是可以共存的，这代表的是两个进程都只是要去读取数据，并不互相冲突。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        独占锁       共享锁
独占锁     ×           ×
共享锁     ×           √&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件锁flock和lockf&quot;&gt;文件锁：flock和lockf&lt;/h2&gt;
&lt;p&gt;Linux上的文件锁类型主要有两种：flock和lockf。后者是fcntl系统调用的一个封装。它们之间有些区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flock来自BSD，而fcntl或lockf来自POSIX，所以lockf或fcntl实现的锁也称为POSIX锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;flock只能对整个文件加锁，而fcntl或lockf可以对文件中的部分加锁，即粒度更细的记录锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;flock的锁是劝告锁，lockf或fcntl可以实现强制锁。所谓劝告锁，是指只有多进程双方都遵纪守法地使用flock锁才有意义，某进程使用flock，但另一进程不使用flock，则flock锁对另一进程完全无限制&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flock锁是附加在(关联在)文件描述符上的&lt;/strong&gt;，而lockf是关联在文件实体上的。本文后面将详细分析flock锁在文件描述符上的现象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Perl中主要使用flock来实现文件锁，也是本文的主要内容。&lt;/p&gt;
&lt;h2 id=&quot;perl的flock&quot;&gt;Perl的flock&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;flock FILEHANDLE, flags;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;flock两个参数，第一个是文件句柄，第二个是锁标志。&lt;/p&gt;
&lt;p&gt;锁标志有4种，有数值格式的1、2、8、4，在导入Fcntl模块的&lt;code&gt;:flock&lt;/code&gt;后，也支持字符格式的&lt;code&gt;LOCK_SH&lt;/code&gt;、&lt;code&gt;LOCK_EX&lt;/code&gt;、&lt;code&gt;LOCK_UN&lt;/code&gt;、&lt;code&gt;LOCK_NB&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;字符格式      数值格式      意义
-----------------------------------
LOCK_SH        1        申请共享锁
LOCK_EX        2        申请独占锁
LOCK_UN        8        释放锁
LOCK_NB        4        非阻塞模式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;独占锁和独占锁、独占锁和共享锁是冲突的。所以，当进程1持有独占锁时，进程2想要申请独占锁或共享锁默认将被阻塞。如果使用了非阻塞模式，那么本该阻塞的过程将立即返回，而不是阻塞等待其它进程释放锁。非阻塞模式可以结合共享锁或独占锁使用。所以，有下面几种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use Fcntl qw(:flock);

flock $fh, LOCK_SH;    # 申请共享锁
flock $fh, LOCK_EX;    # 申请独占锁
flock $fh, LOCK_UN;    # 释放锁
flock $fh, LOCK_SH | LOCK_NB;  # 以非阻塞的方式申请共享锁
flock $fh, LOCK_EX | LOCK_NB;  # 以非阻塞的方式申请独占锁&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flock在操作成功时返回true，否则返回false&lt;/strong&gt;。例如，在申请锁的时候，无论是否使用了非阻塞模式，只要没申请到锁就返回false，否则返回true，而在释放锁的时候，成功释放则返回true。&lt;/p&gt;
&lt;p&gt;例如，两个程序(不是单程序内的两个进程，这种情况后面分析)同时运行，其中一个程序写a.txt文件，另一个程序读a.txt文件，但要保证先写完再读。&lt;/p&gt;
&lt;p&gt;程序1的代码内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings;
use Fcntl qw(:flock);

open my $fh, '&amp;gt;', &quot;a.txt&quot;
    or die &quot;open failed: $!&quot;;

flock $fh, LOCK_EX;
print $fh, &quot;Hello World1\n&quot;;
print $fh, &quot;Hello World2\n&quot;;
print $fh, &quot;Hello World3\n&quot;;

flock $fh, LOCK_UN;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序2的代码内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings;
use Fcntl qw(:flock);

open my $fh, '&amp;lt;', &quot;a.txt&quot;
    or die &quot;open failed: $!&quot;;

# 非阻塞的方式每秒申请一次共享锁
# 只要没申请成功就返回false
until(flock $fh, LOCK_SH | LOCK_NB){
    print &quot;waiting for lock released\n&quot;;
    sleep 1;
}
while(&amp;lt;$fh&amp;gt;){
    print &quot;readed: $_&quot;;
}

flock $fh, LOCK_UN;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;fork文件句柄文件描述符和锁的关系&quot;&gt;fork、文件句柄、文件描述符和锁的关系&lt;/h2&gt;
&lt;p&gt;在开始之前，先看看在Perl中的fork、文件句柄、文件描述符、flock之间的结论。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件句柄是指向文件描述符的，文件描述符是指向实体文件的(假如是实体文件的描述符的话)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;fork只会复制文件句柄，不会复制文件描述符，而是通过复制的不同文件句柄指向同一个文件描述符而实现文件描述符共享&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通过引用计数的方式来计算某个文件描述符上文件句柄的数量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;close()一次表示引用数减1，直到所有文件句柄都关闭了即引用数为0时，文件描述符才被关闭&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;flock是附在文件描述符上的，不是文件句柄也不是实体文件上的&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;flock是进程级别的，不适用于在多线程中使用它来锁互斥&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;所以fork后的父子进程在共享文件描述符的同时也会共享flock锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flock $fh, LOCK_UN&lt;/code&gt;会直接释放文件描述符上的锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;当文件描述符被关闭时，文件描述符上的锁也会自动释放。所以使用close()去释放锁的时候，必须要保证所有文件句柄都被关闭才能关闭文件描述符从而释放锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;flock（包括加锁和解锁）或close()都会自动flush IO Buffer，保证多进程间获取锁时数据同步&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只要持有了某个文件描述符上的锁，在这把锁释放之前，自己可以随意更换锁的类型，例如多次flock从EX锁变成SH锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201902/733013-20190227160356706-258328288.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是正式介绍和解释。&lt;/p&gt;
&lt;p&gt;在C或操作系统上的fork会复制(dup)文件描述符，使得父子进程对同一文件使用不同文件描述符。但&lt;strong&gt;Perl的fork只会复制文件句柄而不会复制文件描述符，父子进程的不同文件句柄会共享同一个文件描述符，并使用引用计数的方式来统计有多少个文件句柄在使用这个文件描述符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;之所以复制文件句柄是因为文件句柄在Perl中是一种变量类型，在不同作用域内是互相独立的。而文件描述符对Perl来说相对更底层一些，属于操作系统的数据资源，对Perl来说是属于可以共享的数据。&lt;/p&gt;
&lt;p&gt;也就是说，如果只fork了一次，那么父子进程的两个文件句柄都共享同一个文件描述符，都指向这个文件描述符，这个文件描述符上的引用计数为2。当父进程close关闭了该文件描述符上的一个文件句柄，子进程需要也关闭一次才是真的关闭这个文件描述符。&lt;/p&gt;
&lt;p&gt;不仅如此，由于文件描述符是共享的，&lt;strong&gt;导致加在文件描述符上的锁(比如flock锁)在父子进程上看上去也是共享的。尽管只在父子某一个进程上加一把锁，但这两个进程都将持有这把锁。如果想要释放这个文件描述符上的锁，直接unlock(&lt;code&gt;flock $fh, LOCK_UN&lt;/code&gt;)或关闭文件描述符即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是注意，&lt;strong&gt;close()关闭的只是文件描述符上的一个文件句柄引用，在文件描述符真的被关闭之前(即所有文件句柄都被关掉)，锁会一直存在于描述符上&lt;/strong&gt;。所以，很多时候使用close去释放时的操作(之所以使用close而非unlock类操作，是因为unlock存在race condition，多个进程可能会在释放锁的同时抢到那个文件的锁)，可能需要在多个进程中都执行，而使用unlock类的操作只需在父子中的任何一进程中即可释放锁。&lt;/p&gt;
&lt;p&gt;例如，分析下面的代码中父进程三处加独占锁位置(1)、(2)、(3)对子进程中加共享锁的影响。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use Fcntl qw(:flock);

open my $fh, &quot;&amp;gt;&quot;, &quot;a.log&quot;;
# (1) flock $fh, LOCK_EX;

# 这里开始fork子进程
my $pid = fork;
# (3) flock $fh, LOCK_EX;

unless($pid){
    # 子进程
    # flock $fh, LOCK_SH;
}

# 父进程
# (2) flock $fh, LOCK_EX;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先分析父进程在(3)处加锁对子进程的影响。(3)是在fork后且进入子进程代码段之前运行的，也就是说父子进程都执行了一次flock加独占锁，显然只有一个进程能够加锁。&lt;strong&gt;但无论是谁加锁了，这个描述符上的锁对另一个进程都是共享的，也就是两个进程都持有EX锁，这似乎违背了我们对独占锁的独占性常识，但并没有，因为实际上文件描述符上只有一个锁，只不过这个锁被两个进程中的文件句柄持有了。因为子进程也持有EX锁，自己可以直接申请SH锁实现自己的锁切换&lt;/strong&gt;，如果父进程这时还没有关闭文件句柄或解锁，它也将持有SH锁。&lt;/p&gt;
&lt;p&gt;再看父进程中加在(1)或(2)处的独占锁，他们其实是等价的，因为在有了子进程后，无论在哪里加锁，锁(文件描述符)都是共享的，引用计数都会是2。这时子进程要获取共享锁是完全无需阻塞的，因为它自己就持有了独占锁。&lt;/p&gt;
&lt;p&gt;也就是说，上面无论是在(1)、(2)还是(3)处加锁，在子进程中都能随意无阻塞换锁，因为子进程在换锁前已经持有了这个文件描述符上的锁。&lt;/p&gt;
&lt;p&gt;那么上面的示例中，&lt;strong&gt;如何让子进程申请互斥锁的时候被阻塞？只需在子进程中打开这个文件的新文件句柄即可，它会创建一个新的文件描述符，在两个文件描述符上申请锁时会检查锁的互斥性&lt;/strong&gt;。但是必须记住，&lt;strong&gt;要让子进程能成功申请到互斥锁，必须在父进程中unlock或者在父子进程中都close()，往往我们会忘记在子进程中也关闭文件句柄而导致文件描述符继续存在，其上的锁也继续保留，从而导致子进程在该文件描述符上持有的锁阻塞了自己去申请其它描述符的锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，下面在子进程中打开了新的&lt;code&gt;$fh1&lt;/code&gt;，且父子进程都使用close()来保证文件描述符的关闭、锁的释放。当然，也可以直接在父或子进程中使用一次&lt;code&gt;flock $fh, LOCK_UN&lt;/code&gt;来直接释放锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use Fcntl qw(:flock);

open my $fh, &quot;&amp;gt;&quot;, &quot;a.log&quot;;
# (1) flock $fh, LOCK_EX;

# 这里开始fork子进程
my $pid = fork;
# (3) flock $fh, LOCK_EX;

unless($pid){
    # 子进程
    open $fh1, &quot;&amp;gt;&quot;, &quot;a.log&quot;;
    close $fh;     # close(1)
    # flock $fh1, LOCK_SH;
}

# 父进程
# (2) flock $fh, LOCK_EX;
close $fh;         # close(2)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Feb 2019 15:59:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>文件锁 当多个进程或多个程序都想要修同一个文件的时候，如果不加控制，多进程或多程序将可能导致文件更新的丢失。 例如进程1和进程2都要写入数据到a.txt中，进程1获取到了文件句柄，进程2也获取到了文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10447881.html</dc:identifier>
</item>
<item>
<title>设置定点数学属性 - MATLAB基于模型的设计</title>
<link>http://www.cnblogs.com/52geek/p/10447850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52geek/p/10447850.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;您可以使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;fimath&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;对象控制赋值，加法，减法和乘法的定点数学属性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;可以使用&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;将&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fixedpoint/ref/fimath.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;fimath&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;对象附加到&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;fi&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;您可以使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;从&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fixedpoint/ref/setfimath.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;网络&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;对象中删除&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fixedpoint/ref/fi.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;fimath&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;155.85628742515&quot;&gt;
&lt;h3 id=&quot;d120e12249&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;设置和删除不动点数学属性&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-1&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;使用通过&lt;/span&gt;&lt;span&gt;状语从句：&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fixedpoint/ref/fimath.html&quot; target=&quot;_blank&quot;&gt; &lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt; &lt;/a&gt;&lt;span&gt;&lt;span&gt;删除函数&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; ，可以将定点操作与全局和本地&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;fimath&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;设置隔离开来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;您还可以从没有附加到输出&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;变量的函数返回。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;这使您可以对定点数学设置进行本地控制，而不会干扰其他函数中的设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;matlab代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; y = user_written_sum（u）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
        'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;，&lt;/span&gt;... 
        'SumWordLength'&lt;span&gt;， 32）;&lt;/span&gt;&lt;span&gt;
    u = setfimath（u，F）;&lt;/span&gt;&lt;span&gt;
    y = fi（0，true，32，get（u，&lt;/span&gt;'FractionLength'&lt;span&gt;），F）;
    &lt;/span&gt;％算法
    为&lt;span&gt; I = 1：长度（U）&lt;/span&gt;&lt;span&gt;
        y（:) = y + u（i）;&lt;/span&gt;
    结束
    ％清理&lt;span&gt;
    y = removefimath（y）;&lt;/span&gt;
结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;输出没有附加的fimath&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;当你运行代码时，&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;控制函数内的算术，但返回值没有附加&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;这是由于在函数&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;了 setfimath&lt;/span&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = fi（1：10，true，16,11）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; y = user_written_sum（u）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;y =&lt;/span&gt;&lt;span&gt;
    55&lt;/span&gt;&lt;span&gt;
          DataTypeMode：定点：二进制点&lt;/span&gt;缩放&lt;span&gt;
            签名：签名&lt;/span&gt;&lt;span&gt;
            WordLength：32&lt;/span&gt;&lt;span&gt;
        分数长度：11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;生成的c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有matlab编码器软件，则可以使用以下命令生成c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = fi（1：10，true，16,11）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; codegen user_written_sum &lt;/span&gt;-args  {u}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;定点数学，但变量中包含的基础数据不会更改，因此生成的c代码不会生成任何数据副本。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;int32_T user_written_sum（const int16_T u [10]）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  int32_T y;&lt;/span&gt;&lt;span&gt;
  int32_T i;&lt;/span&gt;&lt;span&gt;
  /* 建立 */&lt;/span&gt;&lt;span&gt;
  y = 0;&lt;/span&gt;&lt;span&gt;
  / *算法* /&lt;/span&gt;&lt;span&gt;
  for（i = 0; i &amp;lt;10; i ++）{&lt;/span&gt;&lt;span&gt;
    y + = u [i];&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;&lt;span&gt;
  /* 清理 */&lt;/span&gt;&lt;span&gt;
  回归y;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12320&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;不匹配的菲马特&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-2&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;当您对&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fi&lt;/code&gt;&lt;span&gt;对象进行操作时，它们&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;属性必须相等，否则您会收到错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; A = fi（pi，&lt;/span&gt;'ProductMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; B = fi（2，&lt;/span&gt;'ProductMode'&lt;span&gt;，&lt;/span&gt;'SpecifyPrecision'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; C = A * B.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;使用embedded.fi/mtimes时出错&lt;/span&gt;&lt;span&gt;
两个操作数的embedded.fimath必须相等。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;若要避免此错误，可以从表达式中的一个变量中删除&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;在本例中，表达式在上下文的中从&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;中删除&lt;/span&gt;&lt;/span&gt;&lt;span&gt;fimath&lt;/span&gt;&lt;span&gt;&lt;span&gt;，而不修改&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;B&lt;/code&gt;&lt;span&gt;&lt;span&gt;本身，并使用附加到&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;B&lt;/code&gt;&lt;span&gt;&lt;span&gt;计算产品&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; C = A * removefimath（B）
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;                6.283203125&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;           DataTypeMode：定点：二进制点缩放&lt;/span&gt;&lt;span&gt;
             签名：签名&lt;/span&gt;&lt;span&gt;
             WordLength：32&lt;/span&gt;&lt;span&gt;
         分数长度：26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;         RoundingMethod：最近的&lt;/span&gt;&lt;span&gt;
         溢出动作：饱和&lt;/span&gt;&lt;span&gt;
            ProductMode：KeepLSB&lt;/span&gt;&lt;span&gt;
      ProductWordLength：32&lt;/span&gt;&lt;span&gt;
                SumMode：FullPrecision&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12367&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;在临时变量上更改himath&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-3&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有没有附加&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;的变量，但您想要控制特定的操作，则可以在表达式的上下文中附加&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;，而无需修改变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;例如，产品是用&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;F&lt;/code&gt;&lt;span&gt;&lt;span&gt;定义的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;计算的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; F = fimath（&lt;/span&gt;'ProductMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;，&lt;/span&gt;'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; A = fi（pi）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; B = fi（2）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; C = A * setfimath（B，F）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;           DataTypeMode：定点：二进制点缩放&lt;/span&gt;&lt;span&gt;
             签名：签名&lt;/span&gt;&lt;span&gt;
             WordLength：32&lt;/span&gt;&lt;span&gt;
         分数长度：26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;         RoundingMethod：地板&lt;/span&gt;&lt;span&gt;
         OverflowAction：Wrap&lt;/span&gt;&lt;span&gt;
            ProductMode：KeepLSB&lt;/span&gt;&lt;span&gt;
      ProductWordLength：32&lt;/span&gt;&lt;span&gt;
                SumMode：FullPrecision&lt;/span&gt;&lt;span&gt;
       MaxSumWordLength：128&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;请注意，变量&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;B&lt;/code&gt;&lt;span&gt;不会更改。&lt;/span&gt;&lt;/p&gt;



&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;           DataTypeMode：定点：二进制点缩放&lt;/span&gt;&lt;span&gt;
             签名：签名&lt;/span&gt;&lt;span&gt;
             WordLength：16&lt;/span&gt;&lt;span&gt;
         分数长度：13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12411&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;消除循环中的fimath冲突&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-4&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;您可以计算产品和总和，使用dsp的累加器与地板舍入和包装溢出相匹配，并在输出上使用最近的舍入和饱和溢出。&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;为了避免不匹配的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;fimath&lt;/span&gt;&lt;span&gt;&lt;span&gt;错误，可以在与其他变量一起计算时删除输出变量上的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;matlab代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;在本例中，产品为32位，累加器为40位，使最小位与地板舍入和包装溢出，就像c的本机整数规则一样。&lt;/span&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;输出使用最近的舍入和饱和溢出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; [y，z] = setfimath_removefimath_in_a_loop（b，a，x，z）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F_floor = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;... 
           'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
           'ProductMode'&lt;span&gt;，&lt;/span&gt;' KeepLSB'&lt;span&gt;，&lt;/span&gt;... 
           'ProductWordLength'&lt;span&gt;，32，&lt;/span&gt;... 
           'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;，&lt;/span&gt;...... 
           'SumWordLength'&lt;span&gt;，40）;&lt;/span&gt;&lt;span&gt;
    F_nearest = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'最近'&lt;span&gt;，&lt;/span&gt;...... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;）;
    &lt;/span&gt;％设置此函数的本地fimath&lt;span&gt;
    b = setfimath（b，F_floor）;&lt;/span&gt;&lt;span&gt;
    a = setfimath（a，F_floor）;&lt;/span&gt;&lt;span&gt;
    x = setfimath（x，F_floor）;&lt;/span&gt;&lt;span&gt;
    z = setfimath（z，F_floor）;&lt;/span&gt;
    ％使用最近的舍入创建y&lt;span&gt;
    y = coder.nullcopy（fi（zeros（size（x）），true，16,14，F_nearest））;&lt;/span&gt;
    ％算法
    为&lt;span&gt;长度（X）：J = 1
         &lt;/span&gt;％最近分配成Y&lt;span&gt;
        y（j）= b（1）* x（j）+ z（1）;&lt;/span&gt;
        ％删除y与其他fimaths的fimath冲突&lt;span&gt;
        z（1）=（b（2）* x（j）+ z（2）） -  a（2）* removefimath（y（j））;&lt;/span&gt;&lt;span&gt;
        z（2）= b（3）* x（j） -  a（3）* removefimath（y（j））;&lt;/span&gt;
    结束
    ％清理：从输出中删除fimath&lt;span&gt;
    y = removefimath（y）;&lt;/span&gt;&lt;span&gt;
    z = removefimath（z）;&lt;/span&gt;
结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;代码生成说明&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有matlab编码器软件，则可以使用以下命令生成具有指定硬件特征的c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;N = 256;&lt;/span&gt;&lt;span&gt;
t = 1：N;&lt;/span&gt;&lt;span&gt;
xstep = [ones（N / 2,1）;  -  ones（N / 2,1）];&lt;/span&gt;&lt;span&gt;
num = [0.0299545822080925 0.0599091644161849 0.0299545822080925];&lt;/span&gt;&lt;span&gt;
den = [1 -1.4542435862515900 0.5740619150839550];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;b = fi（num，true，16）;&lt;/span&gt;&lt;span&gt;
a = fi（den，true，16）;&lt;/span&gt;&lt;span&gt;
x = fi（xstep，true，16,15）;&lt;/span&gt;&lt;span&gt;
zi = fi（零（2,1），真，16,14）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;B = coder.Constant（b）;&lt;/span&gt;&lt;span&gt;
A = coder.Constant（a）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;config_obj = coder.config（&lt;/span&gt;'lib'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
config_obj.GenerateReport = true;&lt;/span&gt;&lt;span&gt;
config_obj.LaunchReport = true;&lt;/span&gt;&lt;span&gt;
config_obj.TargetLang = &lt;/span&gt;'C'&lt;span&gt; ;&lt;/span&gt;&lt;span&gt;
config_obj.GenerateComments = true;&lt;/span&gt;&lt;span&gt;
config_obj.GenCodeOnly = true;&lt;/span&gt;&lt;span&gt;
config_obj.HardwareImplementation.ProdBitPerChar = 8;&lt;/span&gt;&lt;span&gt;
config_obj.HardwareImplementation.ProdBitPerShort = 16;&lt;/span&gt;&lt;span&gt;
config_obj.HardwareImplementation.ProdBitPerInt = 32;&lt;/span&gt;&lt;span&gt;
config_obj.HardwareImplementation.ProdBitPerLong = 40;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;代码生成&lt;/span&gt;-config  config_obj  setfimath_removefimath_in_a_loop  -args  {B，A，X，滋}  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;生成的c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;定点数学，但变量中包含的基础数据不会更改，因此生成的c代码不会生成任何数据副本。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;void setfimath_removefimath_in_a_loop（const int16_T x [256]，int16_T z [2]，&lt;/span&gt;&lt;span&gt;
  int16_T y [256]）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  int32_T j;&lt;/span&gt;&lt;span&gt;
  int40_T i0;&lt;/span&gt;&lt;span&gt;
  int16_T b_y;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  /* 建立 */&lt;/span&gt;&lt;span&gt;
  / *设置此函数的本地fimath * /&lt;/span&gt;&lt;span&gt;
  / *用最近的舍入创建y * /&lt;/span&gt;&lt;span&gt;
  / *算法* /&lt;/span&gt;&lt;span&gt;
  for（j = 0; j &amp;lt;256; j ++）{&lt;/span&gt;&lt;span&gt;
    / *最近的分配到y * /&lt;/span&gt;&lt;span&gt;
    i0 = 15705 * x [j] +（（int40_T）z [0] &amp;lt;&amp;lt; 20）;&lt;/span&gt;&lt;span&gt;
    b_y =（int16_T）（（int32_T）（i0 &amp;gt;&amp;gt; 20）+（（i0＆524288L）！= 0L））;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;    / *删除y与其他fimaths的fimath冲突* /&lt;/span&gt;&lt;span&gt;
    z [0] =（int16_T）（（（31410 * x [j] +（（int40_T）z [1] &amp;lt;&amp;lt; 20）） - （（int40_T）（ -  23826&lt;/span&gt;&lt;span&gt;
      * b_y）&amp;lt;&amp;lt; 6））&amp;gt;&amp;gt; 20）;&lt;/span&gt;&lt;span&gt;
    z [1] =（int16_T）（（15705 * x [j]  - （（int40_T）（9405 * b_y）&amp;lt;&amp;lt; 6））&amp;gt;&amp;gt; 20）;&lt;/span&gt;&lt;span&gt;
    y [j] = b_y;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  / *清理：从输出中删除fimath * /&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12468&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;多态性代码&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-5&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;您可以编写matlab代码，这些代码可用于浮点和定点类型，使用setfimath &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; y = user_written_function（u）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;...... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
        'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
    u = setfimath（u，F）;&lt;/span&gt;
    ％算法&lt;span&gt;
    y = u + u;&lt;/span&gt;
    ％ 清理&lt;span&gt;
    y = removefimath（y）;&lt;/span&gt;
结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;定点输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;当使用定点输入调用该函数时，&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt; &lt;code class=&quot;literal&quot;&gt;F&lt;/code&gt;&lt;span&gt;&lt;span&gt;将用于算术，并且输出没有附加&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = fi（pi / 8，true，16,15，&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Convergent'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; y = user_written_function（u）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;             0.785400390625&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;           DataTypeMode：定点：二进制点缩放&lt;/span&gt;&lt;span&gt;
             签名：签名&lt;/span&gt;&lt;span&gt;
             WordLength：32&lt;/span&gt;&lt;span&gt;
         分数长度：15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;为固定点生成c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有matlab编码器软件，则可以使用以下命令生成c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = fi（pi / 8，true，16,15，&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Convergent'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; codegen user_written_function &lt;/span&gt;-args  {u}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;定点数学，但变量中包含的基础数据不会更改，因此生成的c代码不会生成任何数据副本。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;int32_T user_written_function（int16_T u）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  /* 建立 */&lt;/span&gt;&lt;span&gt;
  / *算法* /&lt;/span&gt;&lt;span&gt;
  /* 清理 */&lt;/span&gt;&lt;span&gt;
  回报你+你;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;双输入&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;由于&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;状语从句：&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;的英文浮点类型的传递，&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;user_written_function&lt;/code&gt;&lt;span&gt;示例也适用于浮点类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; y = user_written_function（u）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;...... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
        'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;）;&lt;/span&gt;&lt;span&gt;
    u = setfimath（u，F）;&lt;/span&gt;
    ％算法&lt;span&gt;
    y = u + u;&lt;/span&gt;
    ％ 清理&lt;span&gt;
    y = removefimath（y）;&lt;/span&gt;
结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;为双精度生成的c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;当使用浮点输入编译时，您将获得以下生成的c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; codegen user_written_function &lt;/span&gt;-args  {0}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;real_T user_written_function（real_T u）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  回报你+你;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;其中&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;real_T&lt;/code&gt;&lt;span&gt;&lt;span&gt;类型被定义为&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;double&lt;/code&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;typedef double real_T;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12561&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;更多多态代码&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-6&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;编写此函数时，可以将输出创建为与输入的类型相同，因此浮点和定点都可以与输入一起使用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; y = user_written_sum_polymorphic（u）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
        'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;，&lt;/span&gt;... 
        'SumWordLength'&lt;span&gt;， 32）;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;     u = setfimath（u，F）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;     如果是isfi（你）&lt;/span&gt;&lt;span&gt;
         y = fi（0，true，32，get（u，'FractionLength'），F）;&lt;/span&gt;&lt;span&gt;
     其他&lt;/span&gt;&lt;span&gt;
         y =零（1,1，class（u））;&lt;/span&gt;&lt;span&gt;
     结束&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;     ％算法&lt;/span&gt;&lt;span&gt;
     对于i = 1：长度（u）&lt;/span&gt;&lt;span&gt;
         y（:) = y + u（i）;&lt;/span&gt;&lt;span&gt;
     结束&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;     ％ 清理&lt;/span&gt;&lt;span&gt;
     y = removefimath（y）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;固定点生成的c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有matlab编码器软件，则可以使用以下命令生成定点c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = fi（1：10，true，16,11）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; codegen user_written_sum_polymorphic &lt;/span&gt;-args  {u}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;removefimath&lt;/code&gt;&lt;span&gt;定点数学，但变量中包含的基础数据不会更改，因此生成的c代码不会生成任何数据副本。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;int32_T user_written_sum_polymorphic（const int16_T u [10]）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  int32_T y;&lt;/span&gt;&lt;span&gt;
  int32_T i;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  /* 建立 */&lt;/span&gt;&lt;span&gt;
  y = 0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  / *算法* /&lt;/span&gt;&lt;span&gt;
  for（i = 0; i &amp;lt;10; i ++）{&lt;/span&gt;&lt;span&gt;
    y + = u [i];&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  /* 清理 */&lt;/span&gt;&lt;span&gt;
  回归y;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot; lang=&quot;zh-CHS&quot;&gt;生成的浮点c代码&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;如果您有matlab编码器软件，则可以使用以下命令生成浮点c代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = 1:10;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; codegen user_written_sum_polymorphic &lt;/span&gt;-args  {u}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;real_T user_written_sum_polymorphic（const real_T u [10]）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  real_T y;&lt;/span&gt;&lt;span&gt;
  int32_T i;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  /* 建立 */&lt;/span&gt;&lt;span&gt;
  y = 0.0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  / *算法* /&lt;/span&gt;&lt;span&gt;
  for（i = 0; i &amp;lt;10; i ++）{&lt;/span&gt;&lt;span&gt;
    y + = u [i];&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;  /* 清理 */&lt;/span&gt;&lt;span&gt;
  回归y;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;其中&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;real_T&lt;/code&gt;&lt;span&gt;&lt;span&gt;类型被定义为&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;double&lt;/code&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;typedef double real_T;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;d120e12632&quot; class=&quot;title&quot;&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;整数类型上的setimath&lt;/span&gt;&lt;span id=&quot;fi_setfimath_removefimath_example-7&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;&lt;span&gt;按照既定的模式处理内置整数（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fi&lt;/code&gt;&lt;span&gt;&lt;span&gt;对象），&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;setfimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;将整数输入转换为具有附加&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;&lt;span&gt;的等效&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fi&lt;/code&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt; u = int8（5）;&lt;/span&gt;&lt;span&gt;
&amp;gt;&amp;gt; codegen user_written_u_plus_u &lt;/span&gt;-args  {u}  -config：lib  -launchreport
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
function&lt;span&gt; y = user_written_u_plus_u（u）
     &lt;/span&gt;％Setup&lt;span&gt; 
    F = fimath（&lt;/span&gt;'RoundingMethod'&lt;span&gt;，&lt;/span&gt;'Floor'&lt;span&gt;，&lt;/span&gt;... 
        'OverflowAction'&lt;span&gt;，&lt;/span&gt;'Wrap'&lt;span&gt;，&lt;/span&gt;... 
        'SumMode'&lt;span&gt;，&lt;/span&gt;'KeepLSB'&lt;span&gt;，&lt;/span&gt;... 
        'SumWordLength'&lt;span&gt;， 32）;&lt;/span&gt;&lt;span&gt;
    u = setfimath（u，F）;&lt;/span&gt;
    ％算法&lt;span&gt;
    y = u + u;&lt;/span&gt;
    ％ 清理&lt;span&gt;
    y = removefimath（y）;&lt;/span&gt;
结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p lang=&quot;zh-CHS&quot;&gt;&lt;span&gt;类型输出由&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;fimath&lt;/code&gt;&lt;span&gt;指定为32位。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
&lt;span&gt;int32_T user_written_u_plus_u（int8_T u）&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;
  /* 建立 */&lt;/span&gt;&lt;span&gt;
  / *算法* /&lt;/span&gt;&lt;span&gt;
  /* 清理 */&lt;/span&gt;&lt;span&gt;
  回报你+你;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 27 Feb 2019 15:50:00 +0000</pubDate>
<dc:creator>MATLAB基于模型的设计</dc:creator>
<og:description>此示例演示如何在matlab®代码中设置固定点数学属性。 您可以使用 fimath 对象控制赋值，加法，减法和乘法的定点数学属性。可以使用fimath将fimath对象附</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52geek/p/10447850.html</dc:identifier>
</item>
<item>
<title>开发谷歌浏览器插件会上瘾，搞了一个JSONViewer，一个页面格式化多条JSON，提升工作效率 - oppoic</title>
<link>http://www.cnblogs.com/oppoic/p/10444012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oppoic/p/10444012.html</guid>
<description>&lt;p&gt;最近写了一个谷歌浏览器插件（Chrome extension），拿出来分享下，希望能提升大家的工作效率。&lt;/p&gt;

&lt;p&gt;先说痛点：日常开发中，经常需要不停的把接口输出的JSON拷贝到在线JSON格式化页面进行校验、查看和对比等操作，但是现在主流的在线JSON格式化网站都只支持单个操作，如果想同时查看多条JSON，那么就得开多个浏览器标签页，效率非常底下。比如这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227162735068-1970999540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想看另一条JSON必须切换标签页，重复的操作一两次还可以，久而久之就无法忍受了。如果能把这些JSON都在一个页面上格式化就好了。&lt;/p&gt;

&lt;p&gt;一个页面格式化多条JSON，那就是从本来的一个操作区域变成多个操作区域。首先想到的是拷贝下别人的代码，初始化对象的时候多初始化几个，这样就一个变多个了。于是找到国内某搜索排名靠前的JSON格式化网站来研究。看看他们的js&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152203396-349272007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了后非常疑惑，js为什么要写成这样？这个_0x6eb0对象里的元素为什么都转成了16进制的，刚开始还想着挨个转回来看看到底是什么，突然想到Chrome已经拿到了这个对象，打印一下就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152221995-1439166554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里才明白了，就是不让你舒服的看源码。不过这个js还好，想拿来用的话恢复和修改的难度不大，看看另一个js&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152237189-935189415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1万多行混淆的代码，变量名都替换成了短的，想看某个变量怎么定义的、方法在哪里调用过，搜索都没办法搜索，基本放弃了。&lt;/p&gt;

&lt;p&gt;既然国内的JSON格式化网站没法抄了，就到国外找找，Google上搜索JSON Formatter，前几个网站界面都不一样，但是用的都是&lt;a href=&quot;https://github.com/josdejong/jsoneditor&quot; target=&quot;_blank&quot;&gt;JSONEditor&lt;/a&gt;这个编辑器。JSONEditor的简介是：&quot;A web-based tool to view, edit, format, and validate JSON&quot;，看来能满足需求了，看下这个编辑器的效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152333738-61398298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下对应的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;dist/jsoneditor.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;dist/jsoneditor.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #container &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 600px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; container &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; options &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
            mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            onError: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err) {
                alert(err.toString());
            }
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; editor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONEditor(container, options);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常简洁，这个editor还自带json格式化、压缩和去除转义的功能，无需自己实现。为了方便布局，用下Bootstrap的栅栏模式，看看多个editor在一起的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152423183-1125379445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的代码是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d35c5535-b583-4e61-99b0-546a5958dd76')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_d35c5535-b583-4e61-99b0-546a5958dd76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d35c5535-b583-4e61-99b0-546a5958dd76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d35c5535-b583-4e61-99b0-546a5958dd76',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d35c5535-b583-4e61-99b0-546a5958dd76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;dist/jsoneditor.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;dist/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;dist/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;dist/jsoneditor.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;dist/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-xs-12 col-sm-6 col-md-6 col-lg-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-xs-12 col-sm-6 col-md-6 col-lg-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; container1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;container1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; container2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;container2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; options &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
            mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            onError: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err) {
                alert(err.toString());
            }
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; editor1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONEditor(container1, options);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; editor2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONEditor(container2, options);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; wHeight &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(window).height();
        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container1,#container2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(wHeight);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;到这里又该疑惑了：一个页面到底放几个editor合适。最终决定根据浏览器窗口宽度动态控制个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMaxBoxCount() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; screenWidth =&lt;span&gt; $(window).width();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maxBoxCount = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (screenWidth &amp;lt; 1024&lt;span&gt;) {
        maxBoxCount &lt;/span&gt;= 1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (screenWidth &amp;gt;= 1024 &amp;amp;&amp;amp; screenWidth &amp;lt; 1920) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1080p&lt;/span&gt;
        maxBoxCount = 2&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (screenWidth &amp;gt;= 1920 &amp;amp;&amp;amp; screenWidth &amp;lt; 2560) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2k&lt;/span&gt;
        maxBoxCount = 3&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (screenWidth &amp;gt;= 2560 &amp;amp;&amp;amp; screenWidth &amp;lt; 3840) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4k&lt;/span&gt;
        maxBoxCount = 4&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (screenWidth &amp;gt;= 3840 &amp;amp;&amp;amp; screenWidth &amp;lt; 5120) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5k&lt;/span&gt;
        maxBoxCount = 5&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (screenWidth &amp;gt;= 5120) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5k+&lt;/span&gt;
        maxBoxCount = 6&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxBoxCount;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果用户的显示器是5k的，那么放6个editor，一个页面同时显示6段JSON，基本够用了。如果不够再开一个标签页，就是12个了。&lt;br/&gt;当然也不强制必须开几个，允许关掉editor为剩下的editor获取更大的显示宽度。这里需要注意的就是：单页应用不停的关闭和增加editor对象必须要考虑销毁，否则越来越卡。JSONEditor提供了JSONEditor.destroy()方法，文档里是这样描述destroy方法的：&quot;Destroy the editor. Clean up DOM, event listeners, and web workers.&quot;。&lt;/p&gt;
&lt;p&gt;调用destroy方法之前必须得有editor对象，所以初始化的时候就给存起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; jsonEditorArr =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cnr = $(&quot;[data-tgt='container']&quot;&lt;span&gt;);
$.each(cnr, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i, v) {
    editor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONEditor(v, jsonEditorOptions);
    jsonEditorArr.push(editor);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后每次删除和增加editor都必须维护这个jsonEditorArr数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; idx = $(&lt;span&gt;this&lt;/span&gt;).parents(&quot;.mainBox&quot;&lt;span&gt;).next().index();
jsonEditorArr.splice(idx, &lt;/span&gt;0, editor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加&lt;/span&gt;
&lt;span&gt;
jsonEditorArr[idx].destroy();
jsonEditorArr.splice(idx, &lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此功能就差不多了，继续为这个插件加一些常用功能&lt;/p&gt;
&lt;h3&gt;1.复制&lt;/h3&gt;
&lt;p&gt;复制editor里的JSON到剪切板，再去别的地方粘贴出来结构不乱。使用的是&lt;a href=&quot;https://github.com/lgarron/clipboard-polyfill&quot; target=&quot;_blank&quot;&gt;clipboard-polyfill&lt;/a&gt;这个库，不需要初始化和销毁对象等操作，直接调用api无脑copy即可，省事省心。示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
clipboard.writeText(jsonCopy).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'ok'&lt;span&gt;);
}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err) {
    console.log(err);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.粘贴&lt;/h3&gt;
&lt;p&gt;别的地方复制的JSON，到这里不需要右键然后粘贴了，直接点粘贴按钮即可，每次操作省一次鼠标右击。同样借助了&lt;a href=&quot;https://github.com/lgarron/clipboard-polyfill&quot; target=&quot;_blank&quot;&gt;clipboard-polyfill&lt;/a&gt;这个库。示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
clipboard.readText().then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
    console.log(&lt;/span&gt;'剪切板里的内容是：'+&lt;span&gt;result);
}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err) {
    console.log(err);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.下载&lt;/h3&gt;
&lt;p&gt;保存JSON到本地，省的复制全部，然后到本地新建txt粘贴保存了。使用了&lt;a href=&quot;https://github.com/eligrey/FileSaver.js&quot; target=&quot;_blank&quot;&gt;FileSaver.js&lt;/a&gt;，示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; blob = &lt;span&gt;new&lt;/span&gt; Blob([jsonData], { type: &quot;text/plain;charset=utf-8&quot;&lt;span&gt; });
saveAs(blob, &lt;/span&gt;&quot;jsonviewer.txt&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，功能就都完成了，来看看最终的效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401362/201902/401362-20190227152709979-1862839443.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/twbs/bootstrap&quot; target=&quot;_blank&quot;&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ajaxorg/ace&quot; target=&quot;_blank&quot;&gt;ace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/josdejong/jsoneditor&quot; target=&quot;_blank&quot;&gt;jsoneditor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lgarron/clipboard-polyfill&quot; target=&quot;_blank&quot;&gt;clipboard-polyfill&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eligrey/FileSaver.js&quot; target=&quot;_blank&quot;&gt;FileSaver.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CodeSeven/toastr&quot; target=&quot;_blank&quot;&gt;toastr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用到了如上库，感谢无私分享&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/oppoic/JSONViewer/&quot; target=&quot;_blank&quot;&gt;https://github.com/oppoic/JSONViewer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chrome web store：&lt;a href=&quot;https://chrome.google.com/webstore/detail/jsonviewer/khbdpaabobknhhlpglenglkkhdmkfnca&quot; target=&quot;_blank&quot;&gt;https://chrome.google.com/webstore/detail/jsonviewer/khbdpaabobknhhlpglenglkkhdmkfnca&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;crx文件：&lt;a href=&quot;https://github.com/oppoic/JSONViewer/raw/master/crx/JSONViewer.crx&quot; target=&quot;_blank&quot;&gt;https://github.com/oppoic/JSONViewer/raw/master/crx/JSONViewer.crx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）crx文件安装方式：打开Chrome浏览器 - 更多工具 - 扩展程序，把crx文件拖进来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）GitHub源码安装方式：下载源码，打开Chrome浏览器 - 更多工具 - 扩展程序，打开“开发者模式” - 加载已解压的扩展程序 - 选择源码的src目录 - 确定&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本插件完全是前端实现，可以双击html页面运行，也可以发布到服务器上。做成谷歌浏览器插件完全是为了方便：每次需要格式化JSON就点谷歌浏览器右上角的插件图标即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要运行HTML页面的到源码包里找这个文件：JSONViewer\test\jsonviewer-test2.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文地址：https://www.cnblogs.com/oppoic/p/10444012.html，如果觉得不错，请不吝点个赞并到Github上Star本项目，谢谢！&lt;/p&gt;

</description>
<pubDate>Wed, 27 Feb 2019 15:31:00 +0000</pubDate>
<dc:creator>oppoic</dc:creator>
<og:description>最近写了一个谷歌浏览器插件（Chrome extension），拿出来分享下，希望能提升大家的工作效率。 一、背景 先说痛点：日常开发中，经常需要不停的把接口输出的JSON拷贝到在线JSON格式化页面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oppoic/p/10444012.html</dc:identifier>
</item>
<item>
<title>《HelloGitHub》第 35 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/10447747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/10447747.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231140849-504751060.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;c-项目&quot;&gt;C# 项目&lt;/h4&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/skoruba/IdentityServer4.Admin&quot;&gt;IdentityServer4.Admin&lt;/a&gt;：免费开源的 IdentityServer4 与 Asp.Net Core Identity 管理器。IdentityServer4 官方的管理器是收费的，该项目很好的替代了官方管理器，可以方便的管理使用 IdentityServer4 所搭建的认证服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231200092-2028738234.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;c-项目-1&quot;&gt;C++ 项目&lt;/h4&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/FLIF-hub/FLIF&quot;&gt;FLIF&lt;/a&gt;：免费、新颖的无损图像格式。压缩比方面优于 PNG、lossless WebP、lossless BPG、lossless JPEG2000 等格式&lt;/p&gt;
&lt;h4 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h4&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/ovh/cds&quot;&gt;cds&lt;/a&gt;：企业级开源持续集成系统。支持横向扩展、自带 UI、常用的持续集成构建等功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231212145-1368944155.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://github.com/skanehira/docui&quot;&gt;docui&lt;/a&gt;：终端 Docker 管理工具，自带一个终端界面。使用该工具可以方便的通过界面管理 docker 不用再记那些命令。安装命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Homebrew
$ brew tap skanehira/docui
$ brew install docui

# go get
$ go get -d github.com/skanehira/docui
$ cd $GOPATH/src/github.com/skanehira/docui
$ GO111MODULE=on go install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231244159-106204784.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://github.com/chenjiandongx/go-echarts&quot;&gt;go-echarts&lt;/a&gt;：Golang 代码生成对应的 echarts 可视化图表。实例代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// example.go
package main

import (
    &quot;log&quot;
    &quot;math/rand&quot;
    &quot;os&quot;
    &quot;time&quot;

    &quot;github.com/chenjiandongx/go-echarts/charts&quot;
)

var nameItems = []string{&quot;衬衫&quot;, &quot;牛仔裤&quot;, &quot;运动裤&quot;, &quot;袜子&quot;, &quot;冲锋衣&quot;, &quot;羊毛衫&quot;}
var seed = rand.NewSource(time.Now().UnixNano())

func randInt() []int {
    cnt := len(nameItems)
    r := make([]int, 0)
    for i := 0; i &amp;lt; cnt; i++ {
        r = append(r, int(seed.Int63()) % 50)
    }
    return r
}

func main() {
    bar := charts.NewBar()
    bar.SetGlobalOptions(charts.TitleOpts{Title: &quot;Bar-示例图&quot;}, charts.ToolboxOpts{Show: true})
    bar.AddXAxis(nameItems).
        AddYAxis(&quot;商家A&quot;, randInt()).
        AddYAxis(&quot;商家B&quot;, randInt())
    f, err := os.Create(&quot;bar.html&quot;)
    if err != nil {
        log.Println(err)
    }
    bar.Render(f)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231301824-683344203.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://github.com/eranyanay/1m-go-websockets&quot;&gt;1m-go-websockets&lt;/a&gt;：该项目演示了如何用 Go 编写一个可以提供超过一百万个 websockets 连接、运行内存小于 1GB 的服务器。&lt;code&gt;setup.sh&lt;/code&gt; 是用来创建 websocket 客户端的，&lt;code&gt;destroy.sh&lt;/code&gt; 则用来销毁客户端&lt;/p&gt;
&lt;h4 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h4&gt;
&lt;p&gt;7、&lt;a href=&quot;https://github.com/dyc87112/SpringBoot-Learning&quot;&gt;SpringBoot-Learning&lt;/a&gt;：Spring Boot 教程&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://github.com/ruibaby/halo&quot;&gt;halo&lt;/a&gt;：Java 博客系统。在层出不穷的博客系统中，很难看到使用 Java 编写的简洁优雅的博客系统。该项目还具备着轻快且功能强大的特点，这些特性使它从众多 Java 博客系统脱颖而出。安装命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装 Halo
$ yum install -y wget &amp;amp;&amp;amp; wget -O halo-cli.sh https://git.io/fxHqp &amp;amp;&amp;amp; bash halo-cli.sh -i
# 更新 Halo
$ bash halo-cli.sh -u&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231317853-678345874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://github.com/TommyLemon/APIJSON&quot;&gt;APIJSON&lt;/a&gt;：快速开发 API 服务的框架。为简单的增删改查、复杂的查询、简单的事务操作提供了完全自动化的 API。大部分 HTTP 请求后端再也不用写接口了，也不用写文档了，适合中小型前后端分离的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231329136-905106154.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://github.com/teeyog/IQL&quot;&gt;IQL&lt;/a&gt;：基于 SparkSQL 实现了一套即席查询服务，具有如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优雅的交互方式，支持多种 datasource/sink、多数据源混算&lt;/li&gt;
&lt;li&gt;Spark 常驻服务，基于 zookeeper 的引擎自动发现&lt;/li&gt;
&lt;li&gt;多 session 模式实现并行查询&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231345093-1508464906.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h4&gt;
&lt;p&gt;11、&lt;a href=&quot;https://github.com/huangjianke/Gitter&quot;&gt;Gitter&lt;/a&gt;：GitHub 的小程序客户端。UI 设计漂亮，可作为小程序和 GitHub 结合的实战项目学习&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231353255-6810224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://github.com/agalwood/Motrix&quot;&gt;Motrix&lt;/a&gt;：桌面下载工具，支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源。界面简洁易用，采用 Vue + VueX + Element 的技术架构适合学习桌面应用开发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231404773-1620178162.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://github.com/ccampbell/rainbow&quot;&gt;rainbow&lt;/a&gt;：体积小、易于使用、支持各种编程语言的语法高亮插件。该项目原理是通过正则过滤关键字，然后进行高亮。代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// JS关键字判断
Rainbow.extend('javascript', [

    /**
     * matches $. or $(
     */
    {
        name: 'selector',
        pattern: /\$(?=\.|\()/g
    },
    {
        name: 'support',
        pattern: /\b(window|document)\b/g
    }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;14、&lt;a href=&quot;https://github.com/chartjs/Chart.js&quot;&gt;Chart.js&lt;/a&gt;：基于 canvas 的可视化库。可用于构建简单的 H5 图表，满足基本的日常可视化需求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231414648-1265396844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://github.com/vueComponent/ant-design-vue&quot;&gt;ant-design-vue&lt;/a&gt;：Ant Design 的 Vue 实现，该项目已经得到 &lt;a href=&quot;https://vue.ant.design/docs/vue/introduce-cn/&quot;&gt;Ant Design 官方&lt;/a&gt;认可&lt;/p&gt;
&lt;h4 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h4&gt;
&lt;p&gt;16、&lt;a href=&quot;https://github.com/lefex/iWeChat&quot;&gt;iWeChat&lt;/a&gt;：还原、探索微信 APP 的项目。通过该项目借鉴、学习微信客户端开发的相关设计与技术，也可以学到如何分析一个第三方 APP 的方法&lt;/p&gt;
&lt;h4 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h4&gt;
&lt;p&gt;17、&lt;a href=&quot;https://github.com/openspug/spug&quot;&gt;spug&lt;/a&gt;：使用 Python+Vue 实现的开源运维平台，前后端分离方便二次开发。该项目基于 Docker 镜像发布部署，方便安装和升级。支持运维常见功能：主机管理、任务计划管理、发布部署、监控告警等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231427470-1442488064.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://github.com/howie6879/ruia&quot;&gt;ruia&lt;/a&gt;：基于 asyncio 和 aiohttp 的 Python3 异步爬虫框架。它具有容易上手、非阻塞、扩展性强等特点，实例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from ruia import TextField, Item, Spider

class HackerNewsItem(Item):
    target_item = TextField(css_select='tr.athing')
    title = TextField(css_select='a.storylink')


class HackerNewsSpider(Spider):
    start_urls = ['https://news.ycombinator.com/news?p=1']

    async def parse(self, response):
        async for item in HackerNewsItem.get_items(html=response.html):
            yield item

if __name__ == '__main__':
    HackerNewsSpider.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231436024-1304417562.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;
&lt;p&gt;19、&lt;a href=&quot;https://github.com/devhubapp/devhub&quot;&gt;devhub&lt;/a&gt;：支持 Android、iOS、Web、Desktop 的 GitHub 管理通知客户端。能够帮你方便地接收、查看、管理 GitHub 消息、动态等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231444446-3905486.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;20、&lt;a href=&quot;https://github.com/neovim/neovim&quot;&gt;neovim&lt;/a&gt;：致力于改善 Vim 的维护、可扩展性等方面的编辑器。它功能强大、项目开发活跃、社区活跃，“新一代”的 Vim&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231452599-1322936485.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;21、&lt;a href=&quot;https://github.com/Micropoor/Micro8&quot;&gt;Micro8&lt;/a&gt;：浸淫渗透攻击的老鸟所写，内容一线深入浅出，主要是 Windows 系统场景。对于初中级安全从业人员、乙方安全测试、甲方安全自检、网络安全爱好者等提高都有很大的帮助&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://github.com/24OI/OI-WIKI&quot;&gt;OI-WIKI&lt;/a&gt;：免费、开放、持续更新的编程竞赛相关知识教程。包含竞赛的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速、深入地学习编程竞赛相关知识&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://github.com/mbinary/USTC-CS-Courses-Resource&quot;&gt;USTC-CS-Courses-Resource&lt;/a&gt;：该仓库收录中国科学技术大学众多课程资源。包括电子版教材、参考书、讲义、试卷、学习心得、习题解答等。以计算机学院课程为主，也包含公选课、自由选修等其他课程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201902/759200-20190227231502795-1459171351.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h4&gt;
&lt;p&gt;24、&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS&quot;&gt;You-Dont-Know-JS&lt;/a&gt;：（英文）深入探讨 JavaScript 语言核心机制的书籍，适用于深入学习 JS。该书已出版，但在线阅读免费&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://github.com/d2l-ai/d2l-zh&quot;&gt;d2l-zh&lt;/a&gt;：《Dive into Deep Learning 》翻译版，即《动手学深度学习》。&lt;a href=&quot;http://zh.d2l.ai/&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://github.com/3dgen/cppwasm-book&quot;&gt;cppwasm-book&lt;/a&gt;：《C/C++ 面向 WebAssembly 编程》，&lt;a href=&quot;https://3dgen.cn/cppwasm-book/&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;机器学习&quot;&gt;机器学习&lt;/h4&gt;
&lt;p&gt;27、&lt;a href=&quot;https://github.com/openai/gpt-2&quot;&gt;gpt-2&lt;/a&gt;：OpenAI 发布的 15 亿参数量通用语言模型 GPT-2，迄今最大模型！展示了一种构建语言处理系统的潜在方式，即根据自然发生的演示学习执行任务。实例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;export PYTHONIOENCODING=UTF-8
python3 src/generate_unconditional_samples.py | tee samples
python3 src/generate_unconditional_samples.py --top_k 40 --temperature 0.7 | tee samples
python3 src/interactive_conditional_samples.py --top_k 40&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;28、&lt;a href=&quot;https://github.com/kmario23/deep-learning-drizzle&quot;&gt;deep-learning-drizzle&lt;/a&gt;：世界计算机名校的深度学习、强化学习、机器学习、计算机视觉、自然语言处理等方面的公开课&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://github.com/stanfordnlp/stanfordnlp&quot;&gt;stanfordnlp&lt;/a&gt;：适用于多种人类语言的 Stanford NLP 官方 Python 库。包含用于运行 CoNLL 2018 共享任务的最新完全神经管道以及访问 Java Stanford CoreNLP 服务器的软件包。实例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import stanfordnlp
stanfordnlp.download('en')   # This downloads the English models for the neural pipeline
nlp = stanfordnlp.Pipeline() # This sets up a default neural pipeline in English
doc = nlp(&quot;Barack Obama was born in Hawaii.  He was elected president in 2008.&quot;)
doc.sentences[0].print_dependencies()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;30、&lt;a href=&quot;https://github.com/taki0112/Tensorflow-Cookbook&quot;&gt;Tensorflow-Cookbook&lt;/a&gt;：易学易用的 Tensorflow 教程&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;换种方式阅读&quot;&gt;换种方式阅读&lt;/h2&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;如果你发现了好玩、有意义的开源项目 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;点击这里&lt;/a&gt; 分享你觉得有意思的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，请注明出处和作者，同时保留声明。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 15:16:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>《HelloGitHub》第 35 期 兴趣是最好的老师， HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向 编程新手 、 热爱编程 、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xueweihan/p/10447747.html</dc:identifier>
</item>
<item>
<title>1.开始学习ASP.NET MVC - 灰太狼的梦想</title>
<link>http://www.cnblogs.com/caofangsheng/p/10440900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caofangsheng/p/10440900.html</guid>
<description>&lt;p&gt;&lt;span&gt;        Hello,大家好! 好久没有开始记录博客了，是时候开始分享一下了，这个系列主要为零基础的同学，量身打造的。废话不多说，我们开干！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;        什么是ASP.NET MVC&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MVC(Model-View-Controller)--[模型--视图--控制器]，是一种设计模式，它将一个应用程序拆分成下面三个主要的组件：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Model(模型)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;View（视图）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Controller（控制器）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;ASP.NET MVC框架提供了相对ASP.NET Web Forms创建Web应用程序的另外一种选择。ASP.NET MVC框架是一个轻量级的，高度可测试的Web框架，它和Web Form 一样，集成在现有的ASP.NET特性中，例如：母版页，Membership授权验证。ASP.NET MVC 框架定义在&lt;strong&gt;System.Web.Mvc&lt;/strong&gt;程序集中，提供了对HTML、JavaScript和CSS的完全控制权。对于大型开发团队来说，推荐使用ASP.NET MVC进行团队开发协作。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;         &lt;span&gt;MVC设计模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201902/745221-20190226224330734-1411714120.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;      &lt;span&gt;基于MVC模式的Web应用程序的优点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ASP.NET MVC框架有以下优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过将应用程序拆分为Model、View、Controller，对复杂性易于管理；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不使用ViewState或者服务器端的控件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对HTML、JavaScript和CSS拥有完全控制权；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更好的支持测试驱动开发【Test-Driven Development（TDD）】；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非常适合对应用程序有着高度控制需求的Web设计人员；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;默认支持FaceBook和谷歌的授权验证；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过使用多个Areas，可以很容易管理大型应用程序；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;    ASP.NET MVC 引用了哪些命名空间&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;System.Web.Mvc&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;System.Web.Mvc命名空间中，包含支持MVC模式的类和接口。这个命名空间包含：控制器类、控制器工厂类、ActionResult类、视图、分布视图以及模型绑定类等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;System.Web.Mvc.Ajax&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;包含在ASP.NET MVC应用程序中支持的Ajax脚本，这个命名空间包含支持Ajax脚本和Ajax选项的设置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;System.Web.Mvc.Async&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;包含在ASP.NET MVC应用程序中支持异步操作的类和接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;System.Web.Mvc.Html&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;包含在ASP.NET MVC 应用程序中渲染HTML控件的类。这个命名空间包含支持表单（forms）、输入控件(input controls)、超链接(links)、分布视图（partial views）以及验证的类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;   ASP.NET MVC 和ASP.NET Web Forms的不同点&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;&lt;strong&gt;ASP.NET Web Forms&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ASP.NET MVC&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr align=&quot;center&quot; readability=&quot;11&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;Web Forms使用Code behind技术，将页面分成两部分&lt;/p&gt;
&lt;p&gt;【.aspx文件(用来呈现视图)，.aspx.cs或者aspx.vb(用来编码）】&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;ASP.NET MVC web应用程序是一个&lt;/p&gt;
&lt;p&gt;设计模式，它将应用程序划分成三个部分:&lt;/p&gt;
&lt;p&gt;模型、视图、控制器。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ASP.NET Web Forms有服务器端控件&lt;/td&gt;
&lt;td&gt;ASP.NET MVC 有HTML帮助类&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; readability=&quot;6&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;ASP.NET Web Forms支持ViewState&lt;/p&gt;
&lt;p&gt;用于在客户端进行状态管理。&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ASP.NET MVC不支持ViewState&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;ASP.NET Web Forms模型遵循一个&lt;/p&gt;
&lt;p&gt;页面的生命周期。&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;没有像Web Forms那样的页面生命&lt;/p&gt;
&lt;p&gt;周期，在ASP.NET MVC模型中，请求周期很简单.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; readability=&quot;5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;在许多情况下，对HTML，JavaScript和&lt;/p&gt;
&lt;p&gt;CSS的控制有限。&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;对HTML，JavaScript和CSS完全控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; readability=&quot;6&quot;&gt;&lt;td&gt;它适用于小型团队开发。&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;ASP.NET MVC 是在大型应用程序中，&lt;/p&gt;
&lt;p&gt;各个团队协作开发中推荐的框架&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;   &lt;span&gt;ASP.NET MVC应用程序解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一个ASP.NET MVC 应用程序被划分到三个文件夹中：Model、View、Controller，当然我们还有其他文件夹用来放置脚本文件，以及App_Start文件夹等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201902/745221-20190227212617568-608745013.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Model【模型】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型是用来存放由LINQ to SQL创建的类或者EF创建的类，又或者是存放WCF服务的引用，又或者是其他。最终我们只是使用这个模型，在视图中呈现数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.View 【视图】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视图文件夹用于存放特定控制器对应的视图页或者局部页，通常View文件夹会包含一个Shared文件夹，在Shared文件夹中，我们可以存放可以在任何控制器中使用的页面或者用户控件。来自控制器的每个请求，同样会检查Shared文件夹中页面的扩展名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Controller【控制器】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器就是用来存放业务逻辑类，每一个控制器类都是&lt;strong&gt;System.Web.Mvc.Controller&lt;/strong&gt;类的子类。控制器类仅仅是包含一些方法，用来返回一个视图、分布视图、Content、Json数据以及其他的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Actions 【方法】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Actions是一类拥有特别返回值类型的方法，用来编码以完成特定的任务，它同样也向用户返回一些东西【例如：视图页面，分布视图页面(用户控件)】。每一个Action都可以处理两种类型的Http请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.【HttpGet】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HttpGet标识的方法，用于处理直接来自用户的操作，我们还可以这样说：HttpGet用于处理第一次请求这个方法的时候。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.【HttpPost】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HttpPost标识的方法，是在客户端已经存在视图页面的时候，用户点击HTML表单中的提交按钮的时候被调用的。点击按钮的时候，同样返回了所有在表单中的控件值，这些值在&lt;strong&gt;FormCollection&lt;/strong&gt;类型的对象中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个Action方法，可能有多种返回值类型。我们可以返回多种类型的返回值给用户，但是大多数的时候，还是使用&lt;strong&gt;ActionResult&lt;/strong&gt;，因为它是其他类型的父类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ActionResult是一个抽象类，它有多种子类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201902/745221-20190227215543340-1970430798.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;ASP.NET MVC中的Areas &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从ASP.NET MVC 2.0开始，微软提供了一个新的特性：Areas。Areas仅仅是用来划分或者分离大型应用程序为多个或者单独的MVC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201902/745221-20190227215933554-909714312.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当你向项目中添加一个Area的时候，一个为Area定义的路由，就在AreaRegistration文件中定义了。路由基于请求的URL向Area发送请求。为了注册Area的路由，在Global.asax文件中写入注册代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;AreaRegistration.RegistrAllAreas();&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;    MVC应用程序请求的生命周期&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在MVC应用程序中，没有像ASP.NET Web Forms那样的页面生命周期，但是我们有MVC请求的生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201902/745221-20190227221113844-64977459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在MVC应用程序中，当用户通过浏览器发送一个请求的时候，就会被IIS处理，这个请求的URL就像下面这样：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://主机名/控制器名称/Action方法名/ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的请求图中，我仅仅只是描述了两种类型的用户请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.第一种请求是：返回一个视图，没有对模型数据进行请求。这个时候是用户发送一个请求，被MVC处理程序处理，然后直接到到控制器，然后调用控制器的某个HttpGet特性标识的方法中，然后返回一个ViewResult实例，然后找到相应的视图页面，视图引擎就渲染视图页面，呈现给用户HTML页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.第二种请求类型是，用户请求一个View+data模式，也就是说用户发送一个请求，被MVC处理程序处理，然后找到控制器中相应的HttpGet特性标识的方法。如果这个方法返回:一个带有Model对象的ViewResult,那么它就会先去请求Model类，然后返回一个带有ModelObject的 ViewResult，然后我们就可以在视图中进行绑定呈现了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有两种类型的模型视图绑定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;strong&gt;Dynamic Banding&lt;/strong&gt; 【动态绑定】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态绑定是当我们向ViewResult传递一个对象的时候，用于返回视图的时候，却没有在视图中定义对象的类型，这个时候，我们还是可以使用对象属性赋值，但是这时候是没有Visual Studio智能提示,我们写的动态语句，只有在运行的时候，才看的到效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. &lt;strong&gt;Strong typed binding&lt;/strong&gt;【强类型绑定】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;强类型绑定是当我们向ViewResult传递对象，用于返回视图的时候，就已经在页面中定义了对象的类型，然后我们就可以在页面中安全的使用对象了，这个时候是有智能提示的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;View Engines 【视图引擎】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视图引擎主要是用于向浏览器呈现HTML页面，视图引擎模板有不同的语法实现，当前主流的是Razor，此外还有ASPX。当然ASP.NET同样支持一些第三方的视图引擎，例如：Spark、NHaml.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ASPX&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ASPX 是最早的ASP.NET MVC 应用程序视图引擎，语法类型ASP.NET Web Forms。我们使用“&amp;lt;%:%&amp;gt;”来写一些服务端的代码，视图文件的扩展名和ASP.NET也一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. .aspx: .aspx是视图页面的扩展名，和ASP.NET Web Forms一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. .ascx: .ascx是分布视图的扩展名，类似ASP.NET Web Forms中的用户控件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. .master: .master扩展名的文件就是母版页和ASP.NET Web Forms中母版页一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Razor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Razor视图引擎是更高级的视图引擎，是从MVC中第一次出来的，Razor视图引擎使用“@”符号代替&quot;&amp;lt;%:%&amp;gt;&quot;,并且Razor不需要你明确的去关闭代码块。视图引擎在运行的时候，智能的判断什么哪里呈现标签元素，哪里是代码块。 　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Razor视图引擎是MVC 3.0 、MVC 4.0以及MVC 5.0中的默认视图引擎，对于C#/VB来说，我们有两种页面的扩展名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C#语言对应的是：.cshtml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VB语言对应的是：.vbhtml&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;到此为止，我们从零开始系列学习MVC的第一篇就结束了，大家有什么疑问，欢迎留言评论。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 15:05:00 +0000</pubDate>
<dc:creator>灰太狼的梦想</dc:creator>
<og:description>Hello,大家好! 好久没有开始记录博客了，是时候开始分享一下了，这个系列主要为零基础的同学，量身打造的。废话不多说，我们开干！ 什么是ASP.NET MVC MVC(Model-View-Cont</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caofangsheng/p/10440900.html</dc:identifier>
</item>
<item>
<title>Redis的复制是如何实现的？ - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10447491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10447491.html</guid>
<description>&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;　　关系数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有的读请求，Redis采用了同样方法来实现自己的复制特性。&lt;/p&gt;
&lt;p&gt;　　简单总结起来就是：&lt;strong&gt;在接收到主服务器发送的数据初始副本之后，客户端每次主服务器进行写命令时，从服务器都会实时地得到更新。部署好主从服务器之后，客户端可以向任意的从服务器发送读请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　&lt;strong&gt;本文主要介绍Redis实现数据同步复制简单过程、新旧版本之间的对比、复制的实现、以及一些需要注意的细节，但不会涉及Redis源码解释。只对基本流程及功能进行详细描述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　主要参考资料《Redis实战》与《Redis设计与实现》（有需要的同学可以私信或者评论）&lt;/p&gt;
&lt;/blockquote&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　&lt;strong&gt;Redis 2.8以前采用的复制都为旧版复制，主要使用SYNC命令同步复制&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，SYNC存在很大的缺陷严重消耗主服务器的资源以及大量的网络连接资源。&lt;span&gt;&lt;strong&gt;Redis 2.8之后采用PSYNC命令替代SYNC&lt;/strong&gt;&lt;/span&gt;，解决完善这些缺陷，但在介绍新版复制功能之前，必须先介绍旧版复制过程，这样才能更好地形成对比。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;　　1、复制功能的两种模式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　同时复制过程分为同步sync与命令传播（command propagate），两个过程配合执行才能实现Redis复制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;1）&lt;strong&gt;同步操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　通过从服务器发送到SYNC命令给主服务器--------&amp;gt;主服务器生成&lt;/strong&gt;RDB文件&lt;/span&gt;并发送给从服务器，同时发送保存所有写命令给从服务器------&amp;gt;从服务器清空之前数据并执行解释RDB文件-------&amp;gt;保持数据一致（还需要命令传播过程才能保持一致）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227094621560-1540901918.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;175&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      　　 &lt;span&gt;2）命令传播操作&lt;/span&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　主服务器的数据库状态被修改（主服务器执行写命令，修改数据库），导致主从服务器数据库不一致时，通过发送让主从服务器不一致的命令（主服务器接收到的新写命令）给从服务器并执行，让主从服务器的数据库重新回到一致状态。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　比如初次同步完成后，主从服务器数据库中都已经存在k1-k5的键，处于数据一致的状态&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227110136449-1103762794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　之后，主服务器客户端发送DEL删除命令，删除k3键，导致主从服务器数据不一致&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227110303630-300325546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　为了让主从服务器数据再次回到一致状态，主服务器向从服务器发送DEL命令，紧接着从服务器接收并执行。即可回到一致状态&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227110414601-735189526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、配置选项前提&lt;/h3&gt;

&lt;p&gt;　　　　1）主从复制的前提不用多说，就是先正确配置redis主从服务器，主要通过slaveof ip port选项配置或者SLAVEOF 命令。&lt;/p&gt;
&lt;p&gt;　　　　2）保证主服务器的RDB+AOF配置正确，特别是RDB中dbfilename选项与AOF中的dir选项，两个文件路径对于Redis是可写的&lt;/p&gt;

&lt;h3&gt;　　3、主从复制过程&lt;/h3&gt;
&lt;p&gt;　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190226234128427-1737096033.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　文字简单总结描述：&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）slave会建立和master的连接，然后发送sync命令；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;2）master都会启动一个后台进程执行BGSAVE命令，将数据快快照保存到文件中，同时master主进程会开始收集新的写命令并缓存起来；、&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;3）后台进程完成写文件后，master发送文件给slave，slave将文件保存到磁盘上，然后加载到内存恢复数据库快照到slave上。\&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;4）紧接着master就会把缓存命令转发给slave，后续的master收到的写命令也通过跟slave连接发送给slave；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;5）如果master同时接收到多个slave发来的同步连接请求，只会启动一个进程来写数据库镜像，然后发送给所有slave。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　也可以参考以下表，&lt;span&gt;&lt;strong&gt;其中步骤1-4可以认为是sync同步操作，而步骤5即为命令传播模式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190226232920117-1794108092.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;301&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;　　　　　　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　1）&lt;span&gt;&lt;strong&gt;从服务器在同步时，会清空所有数据&lt;/strong&gt;&lt;/span&gt;，服务器在与主服务器进行初连接时，数据库中的所有数据都将丢失，替换成主服务器发送的数据。&lt;/p&gt;
&lt;p&gt;　　　　2）&lt;span&gt;&lt;strong&gt;Redis不支持主主复制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;span&gt;3）&lt;/span&gt;&lt;strong&gt;主从复制不会阻塞master（不会阻塞master处理客户端请求），相反slave在初次同步数据时会阻塞不能处理客户端请求。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　4）当多个从服务器尝试连接同一个主服务器的时候，就会出现以下两种情况：&lt;/p&gt;
&lt;p&gt;                　　一是：步骤3还未执行，所有从服务器都会接收到相同的快照文件和相同缓冲区写命令。&lt;/p&gt;
&lt;p&gt;                　　二是：步骤3正在执行或者已经执行完毕，当主服务器与较早的从服务器完成以上全部步骤之后，主服务器会新连接的从服务器重新依次执行1-5步骤。&lt;/p&gt;
&lt;p&gt;                　&lt;span&gt;&lt;strong&gt;在大部分情况下，Redis会尽可能去减少复制所需要的工作，但是从服务器连接的时机不凑巧的话，只好多做一些外额外工作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;5）&lt;strong&gt;&lt;span&gt;多个从服务器连接主服务器时候，同步数据可能会占用很大一部分的带宽，可能会导致其他请求难以到达主服务器。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;4、SYNC命令的缺陷&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;主要是主从服务器断线后重复制，即处于命令传播阶段的主从服务器由于网络断开，从服务器一直尝试连接主服务器连接成功后，继续复制主服务器。如下过程在主从服务器断开后重新连接期间，主服务器继续执行三个SET命令，导致从服务器连接后发送L SYNC命令，重新进行了“全量”复制过程，RDB文件中包含k1-k10089全部的键。&lt;/p&gt;
&lt;p&gt;　　　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227105756266-1625308850.png&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;631&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　其中可以明显看出重新连接主服务器之后，&lt;span&gt;&lt;strong&gt;SYNC命令创建包含k1-k10089的RDB文件。而事实上只需要再同步断线后的k10087-k10089即可。SYNC的“全同步”对于从服务来说是不必要的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           SYNC命令非常消耗资源，原因有三点：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;1）主服务器执行BGSAVE命令生成RDB文件，这个生成过程会大量消耗主服务器资源（CPU、内存和磁盘I/O资源）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　2）主服务器需要将自己生成的RBD文件发送给从从服务器，这个发送操作会消耗主从服务器大量的网络资源（带宽与流量）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　3）接收到RDB文件你的从服务器需要载入RDB文件，载入期间从服务器会因为阻塞而导致没办法处理命令请求。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　为了解决旧版本中断线情况下SYNC低效问题，在Redis 2.8之后使用PSYNC命令代替SYNC命令执行复制同步操作，自然PSYNC具备完整重同步和部分重同步模式&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; &lt;span&gt;   1）完整重同步：跟旧版复制基本是一致的，可以理解为“全量”复制。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       2）部分重同步：在命令传播阶段，断线重复制只需要发送主服务器在断开期间执行的写命给从服务器即可，可以理解为“增量”复制。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　断开连接后发送+CONTINUE回复，表示使用PSYNC部分重同步，只需要同步k10087-10089即可，不需要生成RDB文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227113400493-175707994.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　相关流程图如下：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227113340836-826434957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　&lt;span&gt;　Redis不管是旧版还是新版，复制的实现都可以分为七个步骤，流程图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227214144009-1683915756.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1、设置主服务的地址与端口&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        &lt;span&gt;&lt;strong&gt;当客户端向从服务器发送一下命令时或者在配置文件中配置slaveof选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
127.0.0.1:12345&amp;gt; SLAVEOF 127.0.0.1 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际上复制工作是在OK返回之后进行。&lt;/p&gt;
&lt;h2&gt;2、&lt;strong&gt;建立套接字连接&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        &lt;span&gt;&lt;strong&gt;从服务器根据设置的套接字创建连向主服务器的套接字连接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215353821-1315228578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       &lt;span&gt;&lt;strong&gt;主服务器接收从服务器的套接字连接之后，为该套接字创建响应的客户端状态，并将此时的从服务器看做是主服务器的客户端，也就是该从服务器同时具备服务器与客户端两个身份。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215358755-1847844895.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、&lt;strong&gt;发送PING&lt;/strong&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送PING命令。PING命令主要有两种作用：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1） 虽然建立了套接字连接，但是还未使用过，通过发送PING命令检查套接字的读写状态是否正常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2） 通过发送PING命令检查主服务器能否正常处理命令请求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从服务器在发送PING命令之后将遇到以下三种情况的其中一种：&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　1） 主服务器向从服务器返回一个回复，但是从服务器却不能在规定的会时间（timeout）内读取命令回复的内容，则表示当前主从服务器之间的网络状态连接不佳，不能基础执行复制工作的后续步骤，这时从服务器会断开套接字连接重新创建。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2） 主服务器向从服务器返回一个错误，那么表示主服务器暂时没有办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤，这时从服务器会断开套接字连接重新创建。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3） 如果从服务器读取到“PONG”回复，那么表示主从服务器之间网络连接正常，并且主服务器可以处理从服务器发送的命令请求。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215659697-160862776.png&quot; alt=&quot;&quot; width=&quot;451&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;4、身份验证&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;       从服务器接收到主服务器返回的“PONG”回复，接下来就需要考虑身份验证的事。&lt;/p&gt;
&lt;p&gt;       如果从服务器设置了masterauth选项，那么进行身份验证&lt;/p&gt;
&lt;p&gt;       如果从服务器没有设置masterauth选项，那么不进行身份验证&lt;/p&gt;
&lt;p&gt;　　从服务器在身份验证的时候可能遇到三种情况&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　1） 主服务没有设置requirepass选项，并且从服务器也没有设置masterquth选项，那么主服务器继续执行从服务器命令，完成复制工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2） 如果从服务器通过AUTH命令发送的密码与主服务器中requirepass密码相同，那么主服务器将继续执行从服务器发送的命令，复制工作继续，与此相反，密码不一致，则会返回invalid password错误&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3） 如果从服务器没有设置masterauth选项，而主服务器设置了requirepass选项，那么主服务器将返回一个NOAUTH错误。反之没有设设置masterauth选项，而设置了requirepass选项，那么会返回no password is set错误。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215902279-299162514.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;483&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;5、发送端口信息&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;&lt;span&gt; &lt;strong&gt;在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port &amp;lt;port&amp;gt;，向主服务器发送从服务器的监听端口号。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215926355-186863757.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6、&lt;strong&gt;同步&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        就是上述所指的同步操作，&lt;span&gt;&lt;strong&gt;从服务器向主服务器发送PSYNC命令，执行同步操作，值得注意的是只有从服务器是主服务器的客户端，但是执行同步操作之后，主服务器也会成为从服务器的客户端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                               &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190227215931465-172241826.png&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;7、&lt;strong&gt;命令传播&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;   　主从服务器就会进入命令传播阶段，主服务器只要将自己执行的写命令发送给从服务器，而从服务器只要一直执行并接收主服务器发来的写命令（上述已经介绍过，这里不过多介绍）&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;c:/Users/Administrator/Desktop/copy.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 14:27:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 关系数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有的读请求，Redis采用了同样方法来实现自己的复制特性。 简单总结起来就是：在接收到主服务器发送的数据初始副本之后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10447491.html</dc:identifier>
</item>
<item>
<title>程序员的自我修养系列（一）：聊聊专业和业余 - 敏捷的水</title>
<link>http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26781/201902/26781-20190227205359947-1328389872.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;理解专业和业余的区别，异常重要，会让我们进步非常快，不会让我们浪费如此珍贵的人生。&lt;/p&gt;
&lt;p&gt;毕业工作很多年，如果让我说一个感受很深的体会的就是 专业 和 业余 的区别，我想很多人都能理解这两个词的字面意思，但是要想有深刻的感受，却是不易。&lt;/p&gt;
&lt;p&gt;就比如我们看很多体育比赛，觉得人家没啥，就拿大家经常骂的国足来说，很多人老觉得自己踢球也还可以，还不如自己上去踢，那是因为这些人没亲眼见过人家的系统训练，现场观球很多时候业余人员也不太容易看一个人踢得如何，大部分主持人说的头头有道，估计最差的足球教练都不相信他们的胡扯，20年前，还是陕西国力的时候，我就看到一个陕西国力替补球员见球迷的时候，现场颠球跟玩一样，当然不是说颠球好就球踢得好。还有人说，女足水平太厉害了，国足踢不过女足，那都是超业余得看法，国足要是踢女足得话，完全是大学生欺负小学生，职业化水平差距太大了。&lt;/p&gt;

&lt;p&gt;我拿我自己经历的几件事来说一下：&lt;/p&gt;
&lt;p&gt;第一个例子：我们每年公司都举行一次乒乓球比赛，而且我们公司放了个乒乓球桌，大家还经常练一练，我们有一个瑞典的客户在我们这边待了半年，他不太会打球，所以我们公司乒乓球前10里都不太可能有他的影子，去年10月份，那个客户说他哥哥要来西安玩，说他哥哥小的时候训练过几个月，我们根本没当回事，但是结果是把我们虐的一塌糊涂，我们全公司的连发球都接不住。（下面就是他在发球)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26781/201902/26781-20190227205423405-1757880295.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，从这件事上充分说明被专业训练过几个月的人轻轻松松秒杀野路子打几十年的人。如果跟着业余的人做事，一定是误人子弟，一辈子不会有长进的。&lt;/p&gt;
&lt;p&gt;第二个例子，我有一个外国客户，现在在Google, 合作了很多年，现在我们成了非常好的朋友，人非常帅气， 相信我的很多同事都知道，8年前他们给客户的报价是我们这边均价5倍左右，刚开始我一直认为是外国人对中国程序员的歧视，所以认为我们就应该低，直到有一次他和我一起编码解决一个项目问题，他做事的质量和效率让我震惊，有一个小的东西要做，当时让我们一个还算高级的程序员做，我们这个高级程序员评估了2个礼拜，我们这个程序员第二天才刚搭建好环境，估计他觉得慢了，不好意思说，就说他们的客户希望这几天就要要，他说我们来不及了，然后晚上我俩吃完饭，喝完酒，他说Jack, 我们去酒店一起试试做做这个小项目吧，然后我们就拿了两瓶啤酒，一起写这个项目，几个小时之后，我们高级程序员需要2个礼拜的东西，几个小时边喝酒边完成了，然后我被深深的震撼了，我要说人家效率是我们的10倍一点不夸张，人家的报价才是我们的5倍，人家还觉得我们占便宜了呢？ 是我们很差吗？不是的，我自己很多时候也是一些程序员3，4倍的效率（我没说写代码厉害，我大部分时间都没有做无用功)，但是报价连2倍都不到。&lt;/p&gt;
&lt;p&gt;为什么有那么大的差距呢？我想说是因为专业的程度，除了写代码的速度，做事的方式，找问题，解决问题的方法等等就是有那么大的差距，很多人代码出问题的时候，需要把程序跑起来，设置断点，一个个试，人家早就用单元测试自动发现问题了, 这些人还一直沉醉在自己的这个状态中，使用Google的能力，我实在自叹不如。&lt;/p&gt;
&lt;p&gt;第三个例子，我见到了另一个国外的程序员，有幸他要在我们这里待半年，让我们两家成为了好朋友，刚和我们团队一起工作的时候，有很多我们会的东西他不会，我们还觉得有点优势，我还给他讲一些东西，很多时候讨论的时候，我们还能占一些主导，但是半年后，几乎没有我们会的他不会了，又过了两年，人家就可以自己写框架了，最近他自己成立了个个人咨询公司，正在服务一个客户，报价已经是我们目前这边报价的3倍了，如果说人家为何成长的为何如此之快，我还是要说人家用的是专业的训练方法。而我们还在到处找免费的东西，天天在网上看业余的人士胡扯。&lt;/p&gt;
&lt;p&gt;从上面你就可以看到，专业的训练用更少的时间达到了效果，然后在收入上有了很大的区别。&lt;/p&gt;

&lt;p&gt;我们都知道中国制造很厉害，但是很多核心技术，很多软的东西都提不起来，电脑操作系统不管是Windows, Linux和MacOS都是别人的，手机操作系统Android和iOS同样是别人的。我相信我们做不出这些东西，不是我们不够聪明，是因为除了我们总想找条捷径，不愿投入以外，还有很多人缺乏对专业的东西的敬畏，就拿BATJ（百度、阿里巴巴、腾讯、京东)，以及一些国内IT的一些大公司来说，微软、Google、苹果等这些公司离了他们几乎没多大影响，但是BATJ没有微软、Google、苹果等产品还真不行。&lt;/p&gt;
&lt;p&gt;为什么差别如此之大，就是对专业的态度上，我们弄不弄就说自己是第一，弄不弄就是乔布斯的接班人，任何行业不了解的时候，一定要向专业的人学习，对这个行业以及行业的前辈要有基本的敬畏。那些说：“没吃过猪肉，还没见过猪走吗？” 显然就是胡说，你没吃过猪肉，你怎么知道是什么味道呢？&lt;/p&gt;
&lt;p&gt;不相信专业的人，通常过度自负，觉得什么东西都可以完全自己搞，最后要么跟守株待兔一样，要么像瞎猫一样，举几个涉及到工作、学习、子女教育、生病等例子：&lt;/p&gt;
&lt;p&gt;工作，就拿我所在的软件行业，一些客户，你报个价格，他觉得这么简单这么贵？我自己回去找几个人来搞，这就是不敬重权威，觉得这东西就像去超市买个东西一样，刚毕业那几年，很多企业搞ERP，就是自己随便找几个人就觉得可以搞定，最后ERP变成了 （咦？哦？屁？)&lt;/p&gt;
&lt;p&gt;学习一样，很多人觉得自学能力强，我承认靠刻苦的自学，肯定也可以不错，因为有很多人根本就不学习，但是要更好，要做到行业里的前20%, 想成为大师，如果我们相信专业，我们就需要向专业人士学习，比如和专业人士一起工作， 购买专业人士的教程，买书也是向专业人士学习，可惜很多人不愿意花几十块钱，宁愿花几十天在网上瞎找资料，更可笑的还在用百度查技术资料。&lt;/p&gt;
&lt;p&gt;子女教育，很多人认为也是很简单的事，大师的书也不看，老师的话也不听、比自己牛的人观点也不停、自己也不成长， 我说的难听一点，那些觉得教育小孩儿自己无师自通的，也就是自己小孩儿幼儿园的水平，只是因为多活了几年，能比小孩儿多听懂几句话而已，如果你孩子将来还可以，那并不是你教育多成功，而是他后天付出了巨大的努力并且不能像父母一样的见识，另外，尤其很多孩子的父母的父母，一弄就说你不也长大了吗？我想说，现在都啥年代了，活着，像猪一样的活着，早都不是一个问题了。子女教育是个大话题，以后也是我想重点聊的，子女教育向来不是一个人的事，就算我和你自己说的很有道理，保持学习，也不一定我们的子女一定可以成功，但是可以保证的是，比我们不学习教育出来的孩子更成功，我为啥认为认识到专业性很重要，也是因为我也一样之前没认识到，吃了很大的亏，子女教育我就是小学生。&lt;/p&gt;
&lt;p&gt;生病治疗，我们很多人不相信专业，吃了很大的亏，很多人盲目相信一些所谓的“中医”，生病不吃药或者弄些所谓的安慰剂来吃，不相信专业的科学，我们要相信，大学医学院，实验室，那么多医药企业的研发团队，不太可能某个人没有经过正规训练的，就随随便便能治疗各种疑难杂症，我觉得相信这些的人，就等于相信科学家，个大学医学院精心挑选的人，医药研发团队的是傻逼，相信大街上有一个巨大的低垂的果实没有一个人看见，碰巧让他看见了。 所以，不管是谁生病，相信我，去医院找专业的医生是唯一正确的选择，自己网上瞎看，瞎琢磨，这药不能吃，那药不能吃，最终都会耽误事。&lt;/p&gt;
&lt;p&gt;坏了的钟表，一天时间也能对两次，所以做事情要学会衡量是不是这次是瞎猫碰到了死耗子。&lt;/p&gt;
&lt;p&gt;做为程序员，我们要想成为高级程序员，光有个漂亮女朋友是不够的，做出来的东西很专业，才是我们的基本修养。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Feb 2019 13:21:00 +0000</pubDate>
<dc:creator>敏捷的水</dc:creator>
<og:description>毕业工作很多年，如果让我说一个感受很深的体会的就是 专业 和 业余 的区别，我想很多人都能理解这两个词的字面意思，但是要想有深刻的感受，却是不易。 就比如我们看很多体育比赛，觉得人家没啥，就拿大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnblogsfans/p/programmer_self_cultivation.html</dc:identifier>
</item>
<item>
<title>PHPStorm中对nodejs项目进行单元测试 - 悠悠i</title>
<link>http://www.cnblogs.com/youyoui/p/10446784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyoui/p/10446784.html</guid>
<description>&lt;h2 id=&quot;安装必要的包&quot;&gt;安装必要的包&lt;/h2&gt;
&lt;p&gt;nodejs的单元测试最常用的是使用&lt;code&gt;mocha&lt;/code&gt;包。首先确保你本地安装&lt;code&gt;nodejs&lt;/code&gt;，之后按照&lt;code&gt;mocha&lt;/code&gt;包。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install mocha -g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后还需要安装相关的断言工具，Node.js中常用的断言库有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;assert: TDD风格&lt;/li&gt;
&lt;li&gt;should: BDD风格&lt;/li&gt;
&lt;li&gt;expect: BDD风格&lt;/li&gt;
&lt;li&gt;chai: BDD/TDD风格&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;code&gt;npm install&lt;/code&gt;安装这些断言库其中之一即可。&lt;/p&gt;
&lt;h2 id=&quot;phpstorm配置nodejs单元测试环境&quot;&gt;PHPStorm配置nodejs单元测试环境&lt;/h2&gt;
&lt;p&gt;在PHPStorm中选择菜单：Run -&amp;gt; Edit Configurations，点击右上角添加&lt;code&gt;mocha&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/818185/201902/818185-20190227204541126-1498352934.png&quot; alt=&quot;PHPStorm配置nodejs单元测试环境&quot;/&gt;&lt;br/&gt;分别填写下面几项，关于&lt;code&gt;mocha&lt;/code&gt;单元测试可以参考官网：&lt;a href=&quot;https://mochajs.org/&quot; class=&quot;uri&quot;&gt;https://mochajs.org/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name: 随便一个运行配置的名称，如MochaTest&lt;/li&gt;
&lt;li&gt;Working directory: 当前项目目录&lt;/li&gt;
&lt;li&gt;Mocha package: Mocha安装包的目录，node_modules\mocha&lt;/li&gt;
&lt;li&gt;User interface: 测试类型，这里选择TDD（对应&lt;code&gt;assert&lt;/code&gt;库）&lt;/li&gt;
&lt;li&gt;Test directory: 这一项可以选择测试目录或文件
&lt;ul&gt;&lt;li&gt;All in directory: 整个目录都进行测试&lt;/li&gt;
&lt;li&gt;File patterns: 某种模式的文件，可以填正则表达式&lt;/li&gt;
&lt;li&gt;Test file: 某个特定的测试文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;填写完成并且没有报错后点击OK。&lt;/p&gt;
&lt;h2 id=&quot;nodejs进行单元测试&quot;&gt;Nodejs进行单元测试&lt;/h2&gt;
&lt;p&gt;这里我们选择&lt;code&gt;assert&lt;/code&gt;库，TDD模式进行单元测试。在上面选定的&lt;code&gt;Test directory&lt;/code&gt;目录下新建一个测试文件&lt;code&gt;test.js&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const assert = require('assert');

// 测试Array类型的方法
suite('Array', function() {
    // 测试 indexOf方法
    suite('#indexOf()', function() {
        // 测试用例
        test('should return -1 when not present', function() {
            assert.equal(-1, [1, 2, 3].indexOf(4));
        });
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击选择Mocha运行，在PHPStorm下面的输出框中有测试的结果，绿色表示通过，红色表示失败。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/818185/201902/818185-20190227204701282-890273847.png&quot; alt=&quot;PHPStorm配置nodejs单元测试环境&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;assert断言函数&quot;&gt;assert断言函数&lt;/h2&gt;
&lt;p&gt;下面列举&lt;code&gt;assert&lt;/code&gt;库中常用的断言函数，详情可参考官网：&lt;a href=&quot;https://www.npmjs.com/package/assert&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/package/assert&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;assert.fail(actual, expected, message, operator)&lt;/li&gt;
&lt;li&gt;assert(value, message), assert.ok(value, [message])&lt;/li&gt;
&lt;li&gt;assert.equal(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.notEqual(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.deepEqual(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.notDeepEqual(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.strictEqual(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.notStrictEqual(actual, expected, [message])&lt;/li&gt;
&lt;li&gt;assert.throws(block, [error], [message])&lt;/li&gt;
&lt;li&gt;assert.doesNotThrow(block, [message])&lt;/li&gt;
&lt;li&gt;assert.ifError(value)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中的参数说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value: 实际值&lt;/li&gt;
&lt;li&gt;actual: 实际值&lt;/li&gt;
&lt;li&gt;expected: 期望值&lt;/li&gt;
&lt;li&gt;block: 语句块&lt;/li&gt;
&lt;li&gt;message: 附加信息&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;几种常见的测试风格代码举例&quot;&gt;几种常见的测试风格代码举例&lt;/h2&gt;
&lt;h3 id=&quot;bdd&quot;&gt;BDD&lt;/h3&gt;
&lt;p&gt;BDD提供的接口有：describe(), context(), it(), specify(), before(), after(), beforeEach(), and afterEach().&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;describe('Array', function() {
  before(function() {
    // ...
  });

  describe('#indexOf()', function() {
    context('when not present', function() {
      it('should not throw an error', function() {
        (function() {
          [1, 2, 3].indexOf(4);
        }.should.not.throw());
      });
      it('should return -1', function() {
        [1, 2, 3].indexOf(4).should.equal(-1);
      });
    });
    context('when present', function() {
      it('should return the index where the element first appears in the array', function() {
        [1, 2, 3].indexOf(3).should.equal(2);
      });
    });
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tdd&quot;&gt;TDD&lt;/h3&gt;
&lt;p&gt;提供的接口有： suite(), test(), suiteSetup(), suiteTeardown(), setup(), and teardown():&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;suite('Array', function() {
  setup(function() {
    // ...
  });

  suite('#indexOf()', function() {
    test('should return -1 when not present', function() {
      assert.equal(-1, [1, 2, 3].indexOf(4));
    });
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;qunit&quot;&gt;QUNIT&lt;/h3&gt;
&lt;p&gt;和TDD类似，使用suite()和test()标记测试永烈，包含的接口有：before(), after(), beforeEach(), and afterEach()。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function ok(expr, msg) {
  if (!expr) throw new Error(msg);
}

suite('Array');

test('#length', function() {
  var arr = [1, 2, 3];
  ok(arr.length == 3);
});

test('#indexOf()', function() {
  var arr = [1, 2, 3];
  ok(arr.indexOf(1) == 0);
  ok(arr.indexOf(2) == 1);
  ok(arr.indexOf(3) == 2);
});

suite('String');

test('#length', function() {
  ok('foo'.length == 3);
});&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Feb 2019 12:47:00 +0000</pubDate>
<dc:creator>悠悠i</dc:creator>
<og:description>安装必要的包 nodejs的单元测试最常用的是使用 包。首先确保你本地安装 ，之后按照 包。 然后还需要安装相关的断言工具，Node.js中常用的断言库有： assert: TDD风格 should:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youyoui/p/10446784.html</dc:identifier>
</item>
</channel>
</rss>