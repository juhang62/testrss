<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java9第四篇-Reactive Stream API响应式编程 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13829758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13829758.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201017082037398-1036489849.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右。&lt;/p&gt;
&lt;p&gt;Java 9的 Reactive Streams是对异步流式编程的一种实现。它基于异步发布和订阅模型，具有非阻塞“背压”数据处理的特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-blocking Back Pressure(非阻塞背压)：它是一种机制，让发布订阅模型中的订阅者避免接收大量数据（超出其处理能力），订阅者可以异步通知发布者降低或提升数据生产发布的速率。它是响应式编程实现效果的核心特点！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、java9-reactive-stream-api&quot;&gt;一、Java9 Reactive Stream API&lt;/h2&gt;
&lt;p&gt;Java 9提供了一组定义响应式流编程的接口。所有这些接口都作为静态内部接口定义在&lt;code&gt;java.util.concurrent.Flow&lt;/code&gt;类里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201017082037804-454643360.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是Java 响应式编程中的一些重要角色和概念，先简单理解一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布者（Publisher）是潜在的无限数量的有序数据元素的生产者。 它根据收到的需求(subscription)向当前订阅者发布一定数量的数据元素。&lt;/li&gt;
&lt;li&gt;订阅者（Subscriber）从发布者那里订阅并接收数据元素。与发布者建立订阅关系后，发布者向订阅者发送订阅令牌（subscription），订阅者可以根据自己的处理能力请求发布者发布数据元素的数量。&lt;/li&gt;
&lt;li&gt;订阅令牌（subscription）表示订阅者与发布者之间建立的订阅关系。 当建立订阅关系后，发布者将其传递给订阅者。 订阅者使用订阅令牌与发布者进行交互，例如请求数据元素的数量或取消订阅。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、java响应式编程四大接口&quot;&gt;二、Java响应式编程四大接口&lt;/h2&gt;
&lt;h3 id=&quot;21subscriber-interface（订阅者订阅接口）&quot;&gt;2.1.Subscriber Interface（订阅者订阅接口）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public static interface Subscriber&amp;lt;T&amp;gt; {
    public void onSubscribe(Subscription subscription);
    public void onNext(T item);
    public void onError(Throwable throwable);
    public void onComplete();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;onSubscribe：在发布者接受订阅者的订阅动作之后，发布任何的订阅消息之前被调用。新创建的&lt;code&gt;Subscription&lt;/code&gt;订阅令牌对象通过此方法传递给订阅者。&lt;/li&gt;
&lt;li&gt;onNext：下一个待处理的数据项的处理函数&lt;/li&gt;
&lt;li&gt;onError：在发布者或订阅遇到不可恢复的错误时调用&lt;/li&gt;
&lt;li&gt;onComplete：当没有订阅者调用（包括onNext()方法）发生时调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;22subscription-interface-（订阅令牌接口）&quot;&gt;2.2.Subscription Interface （订阅令牌接口）&lt;/h3&gt;
&lt;p&gt;订阅令牌对象通过&lt;code&gt;Subscriber.onSubscribe()&lt;/code&gt;方法传递&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static interface Subscription {
    public void request(long n);
    public void cancel();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;request(long n)&lt;/code&gt;是无阻塞背压概念背后的关键方法。订阅者使用它来请求n个以上的消费项目。这样，订阅者控制了它当前能够接收多少个数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cancel()&lt;/code&gt;由订阅者主动来取消其订阅，取消后将不会在接收到任何数据消息。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23publisher-interface发布者接口&quot;&gt;2.3.Publisher Interface(发布者接口)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public static interface Publisher&amp;lt;T&amp;gt; {
    public void subscribe(Subscriber&amp;lt;? super T&amp;gt; subscriber);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用该方法，建立订阅者Subscriber与发布者Publisher之间的消息订阅关系。&lt;/p&gt;
&lt;h3 id=&quot;24processor-interface（处理器接口）&quot;&gt;2.4.Processor Interface（处理器接口）&lt;/h3&gt;
&lt;p&gt;处理者Processor 可以同时充当订阅者和发布者，起到转换发布者——订阅者管道中的元素的作用。用于将发布者T类型的数据元素，接收并转换为类型R的数据并发布。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static interface Processor&amp;lt;T,R&amp;gt; extends Subscriber&amp;lt;T&amp;gt;, Publisher&amp;lt;R&amp;gt; {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、实战案例&quot;&gt;二、实战案例&lt;/h2&gt;
&lt;p&gt;现在我们要去实现上面的四个接口来完成响应式编程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Subscription Interface订阅令牌接口通常不需要我们自己编程去实现，我们只需要在知道request()方法和cancle()方法含义即可。&lt;/li&gt;
&lt;li&gt;Publisher Interface发布者接口，Java 9 已经默认为我们提供了实现SubmissionPublisher，该实现类除了实现Publisher接口的方法外，提供了一个方法叫做&lt;code&gt;submit()&lt;/code&gt;来完成消息数据的发送。&lt;/li&gt;
&lt;li&gt;Subscriber Interface订阅者接口，通常需要我们自己去实现。因为在数据订阅接收之后，不同的业务有不同的处理逻辑。&lt;/li&gt;
&lt;li&gt;Processor实际上是 Publisher Interface和Subscriber Interface的集合体，有需要数据类型转换及数据处理的需求才去实现这个接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的例子实现的式字符串的数据消息订阅处理&lt;/p&gt;
&lt;h3 id=&quot;实现订阅者subscriber-interface&quot;&gt;实现订阅者Subscriber Interface&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.Flow;

public class MySubscriber implements Flow.Subscriber&amp;lt;String&amp;gt; {

  private Flow.Subscription subscription;  //订阅令牌

  @Override
  public void onSubscribe(Flow.Subscription subscription) {
      System.out.println(&quot;订阅关系建立onSubscribe: &quot; + subscription);
      this.subscription = subscription;
      subscription.request(2);
  }

  @Override
  public void onNext(String item) {
      System.out.println(&quot;item: &quot; + item);
      // 一个消息处理完成之后，可以继续调用subscription.request(n);向发布者要求数据发送
      //subscription.request(n);
  }

  @Override
  public void onError(Throwable throwable) {
      System.out.println(&quot;onError: &quot; + throwable);
  }

  @Override
  public void onComplete() {
      System.out.println(&quot;onComplete&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;submissionpublisher消息发布者&quot;&gt;SubmissionPublisher消息发布者&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;

public class SubmissionPublisherExample {
  public static void main(String[] args) throws InterruptedException {
      ExecutorService executor = Executors.newFixedThreadPool(1);
      SubmissionPublisher&amp;lt;String&amp;gt; sb = new SubmissionPublisher&amp;lt;&amp;gt;(executor, Flow.defaultBufferSize());
      sb.subscribe(new MySubscriber());   //建立订阅关系，可以有多个订阅者
      sb.submit(&quot;数据 1&quot;);  //发送消息1
      sb.submit(&quot;数据 2&quot;); //发送消息2
      sb.submit(&quot;数据 3&quot;); //发送消息3

      executor.shutdown();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;订阅关系建立
onSubscribe: java.util.concurrent.SubmissionPublisher$BufferedSubscription@27e81a39
item: 数据 1
item: 数据 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意：即使发布者submit了3条数据，MySubscriber也仅收到了2条数据进行了处理。是因为我们在&lt;code&gt;MySubscriber#onSubscribe()&lt;/code&gt;方法中使用了&lt;code&gt;subscription.request(2);&lt;/code&gt;。这就是“背压”的响应式编程效果，我有能力处理多少数据，就会通知消息发布者给多少数据。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 00:21:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13829758.html</dc:identifier>
</item>
<item>
<title>[论文阅读]阿里DIN深度兴趣网络之总体解读 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13796470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13796470.html</guid>
<description>&lt;p&gt;Deep Interest Network（DIN）是阿里妈妈精准定向检索及基础算法团队在2017年6月提出的。其针对电子商务领域（e-commerce industry）的CTR预估，重点在于充分利用/挖掘用户历史行为数据中的信息。本系列文章会解读论文以及源码，顺便梳理一些深度学习相关概念和TensorFlow的实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;434.33511663286&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Deep Interest Network（DIN）是阿里妈妈精准定向检索及基础算法团队在2017年6月提出的。其针对电子商务领域（e-commerce industry）的CTR预估，重点在于充分利用/挖掘用户历史行为数据中的信息。&lt;/p&gt;
&lt;p&gt;本系列文章会解读论文以及源码，顺便梳理一些深度学习相关概念和TensorFlow的实现。&lt;/p&gt;
&lt;p&gt;本文是系列第一篇 ：论文解读。参考了大量文章，衷心感谢各位的分享，具体请参见文末链接。&lt;/p&gt;
&lt;h2 id=&quot;0x01-论文概要&quot;&gt;0x01 论文概要&lt;/h2&gt;
&lt;h3 id=&quot;11-概括&quot;&gt;1.1 概括&lt;/h3&gt;
&lt;p&gt;Deep Interest Network（DIN）是阿里妈妈精准定向检索及基础算法团队在2017年6月提出的。其针对电子商务领域（e-commerce industry）的CTR预估，重点在于充分利用/挖掘用户历史行为数据中的信息。&lt;/p&gt;
&lt;p&gt;DIN通过引入attention机制，针对不同的广告构造不同的用户抽象表示，从而实现了在数据维度一定的情况下，更精准地捕捉用户当前的兴趣。&lt;/p&gt;
&lt;p&gt;核心思想是 ：用户的兴趣是多元化的（&lt;strong&gt;diversity&lt;/strong&gt;），并且对于特定的广告，用户不同的兴趣会产生不同的影响（&lt;strong&gt;local activation&lt;/strong&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;12-文章信息&quot;&gt;1.2 文章信息&lt;/h3&gt;
&lt;h3 id=&quot;13-核心观点&quot;&gt;1.3 核心观点&lt;/h3&gt;
&lt;p&gt;文章介绍了现有的点击率 （CTR） 预估模型大都满足相同的模式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先将大量的稀疏类别特征 （Categorical Features） 通过 Embedding 技术映射到低维空间；&lt;/li&gt;
&lt;li&gt;再将这些特征的低维表达按照特征的类别进行组合与变换 （文中采用 in a group-wise manner 来描述），以形成固定长度的向量（比如常用的 sum pooling / mean pooling）；&lt;/li&gt;
&lt;li&gt;最后将这些向量 concatenate 起来输入到一个 MLP （Multi-Layer Perceptron）中，从而学习这些特征间的非线性关系；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个模式存在一个问题。比如在电商场景下，用户兴趣可以使用用户的历史行为来描述 （比如用户访问过的商品，店铺或者类目），然而如果按照现有的处理模式，&lt;u&gt;对于不同的候选广告，用户的兴趣始终被映射为同一个固定长度的向量来表示&lt;/u&gt;，这极大的限制了模型的表达能力，毕竟用户的兴趣是多样的。&lt;/p&gt;
&lt;p&gt;Embedding&amp;amp;MLP模型的瓶颈就是表达用户多样的兴趣，&lt;u&gt;维度受限的用户表示向量将成为表达用户多样化兴趣的瓶颈&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，论文中提出了 DIN 网络。对于不同的候选广告，考虑该广告和用户历史行为的相关性，以便自适应地学习用户兴趣的特征表达。具体来说，文章介绍了 local activation unit 模块，其&lt;u&gt;基于 Attention 机制，对用户历史行为进行加权来表示用户兴趣，其中权重参数是通过候选广告和历史行为交互来进行学习的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;另外，本文还介绍了 Mini-batch Aware Regularization 与 Dice 激活函数两种技术，以帮助训练大型的网络。&lt;/p&gt;
&lt;h3 id=&quot;14-名词解释&quot;&gt;1.4 名词解释&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Diversity：&lt;/strong&gt;&lt;br/&gt;&lt;u&gt;用户在访问电商网站时会对多种商品都感兴趣。也就是用户的兴趣非常的广泛&lt;/u&gt;。比如一个年轻的母亲，从她的历史行为中，我们可以看到她的兴趣非常广泛：羊毛衫、手提袋、耳环、童装、运动装等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Local Activation：&lt;/strong&gt;&lt;br/&gt;&lt;u&gt;用户是否会点击推荐给他的商品，仅仅取决于历史行为数据中的一小部分，而不是全部&lt;/u&gt;。历史行为中部分数据主导是否会点击候选广告。比如一个爱游泳的人，他之前购买过travel book、ice cream、potato chips、swimming cap。当前给他推荐的商品（或者说是广告Ad）是goggle（护目镜）。那么他是否会点击这次广告，跟他之前是否购买过薯片、书籍、冰激凌一丁点关系也没有！而是与他之前购买过游泳帽有关系。也就是说在这一次CTR预估中，部分历史数据（swimming cap）起了决定作用，而其他的基本没啥用。&lt;/p&gt;
&lt;h2 id=&quot;0x02-解读思路&quot;&gt;0x02 解读思路&lt;/h2&gt;
&lt;p&gt;本节主要摘录：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53110408&quot;&gt;用NumPy手工打造 Wide &amp;amp; Deep&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;21-memorization-和-generalization&quot;&gt;2.1 Memorization 和 Generalization&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;推荐系统的主要挑战之一，是同时解决Memorization和Generalization&lt;/u&gt;。Memorization根据历史行为数据，推荐通常和用户已有行为的物品直接相关的物品。而Generalization会学习新的特征组合，提高推荐物品的多样性。 DeepFM 中 Wide &amp;amp; Deep 分别对应 Memorization &amp;amp; Generalization。&lt;/p&gt;
&lt;h4 id=&quot;211-memorization&quot;&gt;2.1.1 Memorization&lt;/h4&gt;
&lt;p&gt;面对拥有大规模离散sparse特征的CTR预估问题时，将特征进行非线性转换，然后再使用线性模型是在业界非常普遍的做法，最流行的即「LR+特征叉乘」。&lt;u&gt;Memorization 通过一系列&lt;strong&gt;人工的特征叉乘（cross-product）&lt;/strong&gt;来构造这些非线性特征，捕捉sparse特征之间的高阶相关性，即 “记忆” 历史数据中曾共同出现过的特征对&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;特征1——专业: {计算机、人文、其他}，

特征2——下载过音乐《消愁》:{是、否}，
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个特征one-hot后的特征维度分别为3维与2维，对应的叉乘结果是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;特征3——专业☓下载过音乐《消愁》: {计算机∧是，计算机∧否，人文∧是，人文∧否，其他∧是，其他∧否}。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;典型代表是LR模型，使用大量的原始sparse特征和&lt;strong&gt;叉乘特征&lt;/strong&gt;作为输入，很多原始的dense特征通常也会被分桶离散化构造为sparse特征。这种做法的优点是模型可解释高，实现快速高效，特征重要度易于分析，在工业界已被证明是很有效的。&lt;/p&gt;
&lt;p&gt;Memorization的缺点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要更多的人工设计；&lt;/li&gt;
&lt;li&gt;可能出现过拟合。可以这样理解：如果将所有特征叉乘起来，那么几乎相当于纯粹记住每个训练样本，这个极端情况是最细粒度的叉乘，我们可以通过构造更粗粒度的特征叉乘来增强泛化性；&lt;/li&gt;
&lt;li&gt;无法捕捉训练数据中未曾出现过的特征对。例如上面的例子中，如果每个专业的人都没有下载过《消愁》，那么这两个特征共同出现的频次是0，模型训练后的对应权重也将是0；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;212-generalization&quot;&gt;2.1.2 Generalization&lt;/h4&gt;
&lt;p&gt;Generalization 为sparse特征学习低维的dense embeddings 来捕获特征相关性，学习到的embeddings 本身带有一定的语义信息。可以联想到NLP中的词向量，不同词的词向量有相关性，因此Generalization是基于相关性之间的传递。这类模型的代表是DNN和FM。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Generalization的优点是更少的人工参与，对历史上没有出现的特征组合有更好的泛化性&lt;/u&gt; 。&lt;/p&gt;
&lt;p&gt;在推荐系统中，当user-item matrix非常稀疏时，例如有和独特爱好的users以及很小众的items，NN很难为users和items学习到有效的embedding。这种情况下，大部分user-item应该是没有关联的，但dense embedding 的方法还是可以得到对所有 user-item pair 的非零预测，因此&lt;em&gt;导致 over-generalize并推荐不怎么相关的物品&lt;/em&gt;。此时Memorization就展示了优势，它可以“记住”这些特殊的特征组合。&lt;/p&gt;
&lt;h3 id=&quot;22-发展脉络&quot;&gt;2.2 发展脉络&lt;/h3&gt;
&lt;p&gt;各种NN与FM看似繁杂，实际上，只要把握住它们的发展脉络，即&lt;strong&gt;“如何兼顾记忆与扩展”、“如何处理高维、稀疏的类别特征”、“如何实现特征交叉”&lt;/strong&gt;，你就会发现各种高大上的新算法不过是沿着这条脉络，在某个枝叉上的修补。这样一来，各种NN与FM，在你脑中，就不再是一个个独立的缩写，而能够编织成网，融会贯通。&lt;/p&gt;
&lt;p&gt;相比于实数型特征，&lt;strong&gt;稀疏的类别/ID类特征，才是推荐、搜索领域的“一等公民”&lt;/strong&gt;，被研究得更多。即使有一些实数值特征，比如历史曝光次数、点击次数、CTR之类的，也往往通过bucket的方式，变成categorical特征，才喂进模型。&lt;/p&gt;
&lt;p&gt;但是，稀疏的categorical/ID类特征，也有着&lt;strong&gt;单个特征表达能力弱、特征组合爆炸、分布不均匀导致受训程度不均匀&lt;/strong&gt;的缺点。为此，一系列的新技术被开发出来。&lt;/p&gt;
&lt;p&gt;单个categorical/ID特征表达能力是极弱的，因此必须做特征交叉，以增强categorical特征的表达能力。而围绕着如何做特征交叉，衍生出各种算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度神经网络（DNN）&lt;/strong&gt;先将categorical/id特征通过embedding映射成稠密向量，再喂入DNN，让DNN自动学习到这些特征之间的&lt;strong&gt;深层交叉&lt;/strong&gt;，以增强扩展能力。&lt;/p&gt;
&lt;h2 id=&quot;0x03-dnn&quot;&gt;0x03 DNN&lt;/h2&gt;
&lt;h3 id=&quot;31-深度模型思路&quot;&gt;3.1 深度模型思路&lt;/h3&gt;
&lt;p&gt;准确的CTR预估需要精细化权衡用户、广告主、平台三方利益。经过多年的技术更新迭代与发展，CTR预估技术经历了从 LR/FM 到 融合模型（RF/GBDT/XGBoost） 到 深度CTR预估模型（FNN/PNN/WDL/DeepFM/DIN）的过程，而贯穿其中的主线是&lt;strong&gt;如何让模型自动地进行组合特征的挖掘？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Wide&amp;amp;Deep、DeepFM：采用高阶和低阶特征的联合来提高模型的表达能力；&lt;/li&gt;
&lt;li&gt;PNN：在MLP之前引入一个乘积层（内积和外积），强调了特征Embedding向量之间的交叉方式，让模型更容易捕获特征的交叉信息；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也可以看看阿里思路的出发点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们第一考虑到的是降维，在降维的基础上，进一步考虑特征的组合。所以DNN很自然进入了我们的考虑范围。再考虑的是如果把用户行为序列建模起来，我们希望是用户打开手淘后，先在有好货点了一个商品，再在猜你希望点了一个商品，最后进入搜索后会受到之前的行为的影响，当然有很多类似的方法可以间接实现这样的想法。但直接建模的话，LR这类的模型，很难有能力来支持这类特征，所以很容易就想到了RNN模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;32-dnn模型&quot;&gt;3.2 DNN模型&lt;/h3&gt;
&lt;p&gt;DNN模型大多遵从 &lt;strong&gt;Embedding + MLP&lt;/strong&gt;这一基础网络架构，即将原始高维的不同的离散特征映射为固定长度的低维embedding向量，并将embedding向量作为多个全连接层的输入，拟合高阶的非线性关系，最后通过Sigmoid等手段将输出值归一到0~1，表示点击概率。相比于传统的LR、GBDT、FM等模型，这类DNN的模型能减少大量的人工构造特征过程，并且能学习特征之间的非线性关系。&lt;/p&gt;
&lt;p&gt;通常流程是:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Sparse Features -&amp;gt; Embedding Vector -&amp;gt; pooling layer -&amp;gt; MLPs -&amp;gt; Sigmoid -&amp;gt; Output  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-工作机制&quot;&gt;3.3 工作机制&lt;/h3&gt;
&lt;p&gt;下图的 Base Model, 是现有的大多数 CTR 模型采用的模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201011102721490-1806968429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红蓝粉三色节点分别表示商品 ID （Goods ID）, 店铺 ID （Shop ID）, 类目 ID （Cate ID） 三种稀疏特征, 其他的输入特征, 使用白色节点表示 （比如左边的用户特征, 比如用户 ID; 还有右边的上下文特征, 比如广告位之类的特征）. 注意 Goods 1 ~ Goods N 用来描述用户的历史行为. 候选广告 Candidate Ad 本身也是商品, 也具有 Goods / Shop / Cate ID 三种特征.&lt;/p&gt;
&lt;p&gt;自底向上观测 Base Model 的工作机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一模块：特征表示。
&lt;ul&gt;&lt;li&gt;可将特征大致分为四类：user profile、user behavior、ad 以及 context 部分。&lt;/li&gt;
&lt;li&gt;将广告设为目标。&lt;/li&gt;
&lt;li&gt;每一类特征包含多个field，用户信息包含性别、年龄等等；用户行为包含用户访问过的物品编号；广告包含广告id，商店id等；上下文包含设计类型id，时间等等。&lt;/li&gt;
&lt;li&gt;有的特征可以被编码成one-hot表示，例如女性可以被编码成[0,1]。有的特征可以进行 multi-hot 编码，与 one-hot 编码不同，multi-hot 编码中，一个向量可能存在多个 1。&lt;/li&gt;
&lt;li&gt;在CTR序列模型中，值得注意的是每个字段都包含一个行为列表，每个行为对应一个one-hot向量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二模块：嵌入层。
&lt;ul&gt;&lt;li&gt;学习特征的低维向量表示，将维数较大的稀疏特征矩阵转换成低维稠密特征矩阵。&lt;/li&gt;
&lt;li&gt;每一个field都有一个独立的 embedding matrix。&lt;/li&gt;
&lt;li&gt;值得注意的是，由于每个用户的历史行为数据各不相同，因此 e 的列数是不确定的。相应地也就不能直接与其他field的嵌入向量首尾相接 作为MLP层的输入。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三模块：pooling层。
&lt;ul&gt;&lt;li&gt;由于不同的用户有不同个数的行为数据，导致embedding矩阵的向量大小不一致，而全连接层只能处理固定维度的数据，因此利用Pooling Layer得到一个固定长度的向量。&lt;/li&gt;
&lt;li&gt;本层对 e 进行sum pooling，即将一个类别的embedding向量输入进池化操作，转化为&lt;u&gt;一个固定长度的向量&lt;/u&gt;，解决维度不定的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四模块：链接层。
&lt;ul&gt;&lt;li&gt;经过embedding layer和pooling layer后，原始稀疏特征被转换成多个固定长度的用户兴趣的抽象表示向量。&lt;/li&gt;
&lt;li&gt;然后利用concat layer聚合抽象表示向量，输出该用户兴趣的唯一抽象表示向量；作为 MLP 层的输入 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第五模块：MLP 层，将concat layer输出的抽象表示向量作为MLP的输入，自动学习数据之间的高阶交叉特征。&lt;/li&gt;
&lt;li&gt;损失函数 ：基于深度学习的CTR模型广泛使用的损失函数是 负对数似然函数（the negative log-likelihood function）Loglos，使用标签作为目标项来监督整体的预测。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;34-模型特点&quot;&gt;3.4 模型特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过神经网络可以拟合高阶的非线性关系, 同时减少了人工特征的工作量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;u&gt;表示用户的兴趣多样性有限制&lt;/u&gt; （这是最大的瓶颈） 。在对用户历史行为数据进行处理时, 每个用户的历史点击个数是不相等的, 包含了许多兴趣信息，如何对用户多种多样的兴趣建模？我们要把它们编码成一个固定长的向量（这个向量就是用户表示，是用户兴趣的代表），需要做pooling （sum or average）, 会损失信息。比如：
&lt;ul&gt;&lt;li&gt;K维向量，最多只能表达K个独立的兴趣，而用户的兴趣可能不止K；&lt;/li&gt;
&lt;li&gt;K的大小会对计算量产生明显影响，一般用大的K效果会更好，即扩展向量的维度，但这样会增加学习的参数和在有限的数据中有过拟合的风险；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;u&gt;没有考虑用户与广告之间的关系&lt;/u&gt;。在电子商务领域中，用户的历史行为数据（User Behavior Data）中包含大量的用户兴趣信息，之前的研究并没有针对Behavior data&lt;strong&gt;特殊的结构（Diversity + Local Activation）&lt;/strong&gt;进行建模。比如 对于同一个用户, 如果候选广告 （Candidate Ad） 发生了变化, 用户的兴趣却依然是同一个向量来表达, 显然这限制了模型的表达能力, 毕竟用户的兴趣是丰富的/变化的。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;忽略隐式特征的挖掘和表示&lt;/u&gt;。DNN模型直接将用户的行为视作用户的兴趣。行为是兴趣的载体，能反映兴趣，但若直接用行为表示兴趣则略有不妥。因为，行为是序列化产生的，如果像大部分现有的模型那样直接采用行为即兴趣的做法，会忽略行为之间的依赖关系。此外，当前时刻的兴趣往往直接导致了下一行为的发生。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;忽略兴趣的变化&lt;/u&gt;。如之前所讲，用户的兴趣是不断变化的。例如用户对衣服的喜好，会随季节、时尚风潮以及个人品味的变化而变化，呈现一种连续的变迁趋势。但在淘宝平台中，用户的兴趣是丰富多样的，且每个兴趣的演变基本互不影响。此外，影响最终行为的仅仅是与目标商品相关的兴趣。&lt;/li&gt;
&lt;li&gt;不必将某个用户所有的兴趣【用户的历史购买记录】全部压缩到向量中，因为只有用户部分的兴趣会影响当前行为（对候选广告点击或不点击）。例如，一位女游泳运动员会点击推荐的护目镜，这主要是由于购买了泳衣而不是上周购物清单中的鞋子。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x04-din&quot;&gt;0x04 DIN&lt;/h2&gt;
&lt;p&gt;针对DNN模型的问题，阿里提出了DIN模型。其核心思想：用户的兴趣是多元化的（&lt;strong&gt;diversity&lt;/strong&gt;），并且对于特定的广告，用户不同的兴趣会产生不同的影响（&lt;strong&gt;local activation&lt;/strong&gt;）。&lt;u&gt;DIN同时对Diversity和Local Activation进行建模&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;DIN 不会通过使用同一向量来表达所有用户的不同兴趣，而是通过考虑&lt;strong&gt;历史行为的相关性&lt;/strong&gt;来自适应地计算用户兴趣的表示向量（对于给定的广告）。 &lt;strong&gt;该表示向量随不同广告而变化&lt;/strong&gt;。DIN 通过考虑【给定的候选广告】和【用户的历史行为】的相关性，来计算用户兴趣的表示向量。具体来说就是通过引入局部激活单元，通过软搜索历史行为的相关部分来关注相关的用户兴趣，并采用加权和来获得有关候选广告的用户兴趣的表示。与候选广告相关性较高的行为会获得较高的激活权重，并支配着用户兴趣。该表示向量在不同广告上有所不同，大大提高了模型的表达能力。&lt;/p&gt;
&lt;h3 id=&quot;41-创新&quot;&gt;4.1 创新&lt;/h3&gt;
&lt;p&gt;Deep Interest NetWork有以下几点创新：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;针对Diversity：&lt;/strong&gt; 针对用户广泛的兴趣，DIN用&lt;em&gt;an interest distribution&lt;/em&gt;去表示，即用 Pooling（weighted sum）对Diversity建模（对用户多种多样的兴趣建模）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对Local Activation&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;DNN 直接求sum或average损失了很多信息。所以 DIN 稍加改进，&lt;u&gt;利用attention机制实现 Local Activation，从用户历史行为中动态学习用户兴趣的embedding向量，针对不同的广告构造不同的用户抽象表示&lt;/u&gt;，从而实现了在数据维度一定的情况下，更精准地捕捉用户当前的兴趣。&lt;/li&gt;
&lt;li&gt;对用户历史行为进行了不同的加权处理，针对不同的广告，不同的 behavior id 赋予不同的权重，&lt;u&gt;这个权重是由当前behavior id和候选广告共同决定的&lt;/u&gt;，这就是Attention机制。即针对当前候选Ad，去局部的激活（&lt;em&gt;Local Activate&lt;/em&gt;）相关的历史兴趣信息。&lt;/li&gt;
&lt;li&gt;与当前候选Ad相关性越高的历史行为，会获得越高的&lt;em&gt;attention score&lt;/em&gt;，从而会主导这一次预测。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CTR中&lt;strong&gt;特征稀疏而且维度高&lt;/strong&gt;，通常利用L1、L2、Dropout等手段防止过拟合。由于传统L2正则计算的是全部参数，CTR预估场景的模型参数往往数以亿计。DIN提出了一种正则化方法，在每次小批量迭代中，给与不同频次的特征不同的正则权重；&lt;/li&gt;
&lt;li&gt;由于传统的&lt;strong&gt;激活函数&lt;/strong&gt;，如Relu在输入小于0时输出为0，将导致许多网络节点的迭代速度变慢。PRelu虽然加快了迭代速度，但是其分割点默认为0，实际上分割点应该由数据决定。因此，DIN提出了一种数据动态自适应激活函数Dice。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;针对大规模稀疏数据的模型训练：&lt;/strong&gt;当DNN深度比较深（参数非常多），输入又非常稀疏的时候，很容易过拟合。DIN提出&lt;strong&gt;Adaptive regularizaion&lt;/strong&gt;来防止过拟合，效果显著。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;42-架构&quot;&gt;4.2 架构&lt;/h3&gt;
&lt;p&gt;DIN架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201011102743714-602910802.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DIN同时对Diversity和Local Activation进行建模，具体体现如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201011102800065-294142691.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们逐一看看系统的各个部分。&lt;/p&gt;
&lt;h2 id=&quot;0x05-特征&quot;&gt;0x05 特征&lt;/h2&gt;
&lt;h3 id=&quot;51-特征分类&quot;&gt;5.1 特征分类&lt;/h3&gt;
&lt;p&gt;论文中作者把阿里的展示广告系统特征分为四大类。&lt;/p&gt;
&lt;p&gt;1）用户画像特征；&lt;/p&gt;
&lt;p&gt;2）用户行为特征，即用户点击过的商品，各个用户行为长度不同；&lt;/p&gt;
&lt;p&gt;3）待曝光的广告，广告其实也是商品；&lt;/p&gt;
&lt;p&gt;4）上下文特征；&lt;/p&gt;
&lt;p&gt;每个特征类别包括多个特征域（feature field），例如：用户画像特征包括性别，年龄段等；用户行为特征，包括用户点击过的商品，商品的类别，以及所属的商铺等；Context包括时间。&lt;/p&gt;
&lt;h3 id=&quot;52-输入特点&quot;&gt;5.2 输入特点&lt;/h3&gt;
&lt;p&gt;CTR中输入普遍存在的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高纬度&lt;/li&gt;
&lt;li&gt;非常稀疏&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有一些特征域是单值特征，不同的特征值之间是互斥的，例如性别只可能属于男或者女，可以转化为one-hot表示；&lt;/p&gt;
&lt;p&gt;有一些特征域是多值离散特征，例如&lt;u&gt;用户行为特征&lt;/u&gt;，用户可能点击过多个商品，构成一个商品点击序列，只能用multi-hot编码表示。与 one-hot 编码不同，multi-hot 编码中，一个向量可能存在多个 1，比如：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;用户在YouTube上看的视频和搜索过的视频。无论是看过的还是搜索过的，都不止一个，但是相对于所有的视频来说，看过和搜索过的数量都太小了（非常稀疏）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在电子商务上的例子就是：用户购买过的good_id有多个，购买过的shop_id也有多个，而这也直接导致了每个用户的历史行为id长度是不同的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;53-特征处理&quot;&gt;5.3 特征处理&lt;/h3&gt;
&lt;p&gt;DNN 并&lt;strong&gt;没有进行特征组合/交叉特征&lt;/strong&gt;。而是通过DNN去学习特征间的交互信息。&lt;/p&gt;
&lt;p&gt;对于单值特征处理比较简单，对于多值特征的处理稍微麻烦些。多值特征导致了每个用户的样本长度都是不同的。如何解决这个问题？通过 &lt;code&gt;Embedding -&amp;gt; Pooling + Attention&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x06-embedding&quot;&gt;0x06 Embedding&lt;/h2&gt;
&lt;p&gt;深度学习在推荐、搜索领域的运用，是围绕着稀疏的ID类特征所展开的，其主要方法就是Embedding。&lt;u&gt;变ID类特征的“精确匹配”为“模糊查找”，以增强扩展。即将高维、稀疏categorical/id类特征通过embedding映射成一个低维、稠密向量&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;61-特点&quot;&gt;6.1 特点&lt;/h3&gt;
&lt;p&gt;Embedding层特点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;深度学习在推荐系统中的应用，比如各种NN，各种FM 都是以embedding为基础的；&lt;/li&gt;
&lt;li&gt;高维、稀疏的categorical/id类特征是推荐系统中的一等公民；&lt;/li&gt;
&lt;li&gt;在Embedding层中，每一个特征域都对应着一个Embedding矩阵；&lt;/li&gt;
&lt;li&gt;embedding的作用是将原来高维、稀疏的categorical/id类特征的“精确匹配”，变为向量之间的“模糊查找”，从而提高了可扩展性；&lt;/li&gt;
&lt;li&gt;推荐系统中的Embedding与NLP中的Embedding也有不同。
&lt;ul&gt;&lt;li&gt;NLP中，一句话的一个位置上只有一个词，所以Embedding往往变成了：从Embedding矩阵抽取与词对应的行上的行向量；&lt;/li&gt;
&lt;li&gt;推荐系统中，一个Field下往往有多个Feature，Embedding是将多个Feature Embedding合并成一个向量，即所谓的&lt;strong&gt;Pooling&lt;/strong&gt;。比如某个App Field下的Feature有&quot;微信:0.9，微博:0.5，淘宝:0.3&quot;，所以得到&lt;code&gt;Embedding = 0.9 * 微信向量 + 0.5 * 微博向量 + 0.3 * 淘宝向量&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;62-变长特征&quot;&gt;6.2 变长特征&lt;/h3&gt;
&lt;p&gt;MLP只能接受固定长度的输入，但是每个用户在一段时间内的商品点击序列长度可能会不同，属于变长特征，那么该如何处理这样的变长特征？&lt;/p&gt;
&lt;p&gt;一般来说是由 Pooling 层来处理，下面就让我们看看Pooling层。&lt;/p&gt;
&lt;h2 id=&quot;0x07-pooling-层&quot;&gt;0x07 Pooling 层&lt;/h2&gt;
&lt;p&gt;Pooling的作用是把embedding向量转化为&lt;u&gt;一个固定长度的向量&lt;/u&gt;，解决维度不定的问题。&lt;/p&gt;
&lt;h3 id=&quot;71-pooling作用&quot;&gt;7.1 Pooling作用&lt;/h3&gt;
&lt;p&gt;用户有多个兴趣爱好，这导致两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表达用户兴趣时，用户的&lt;strong&gt;历史行为往往涉及多个categorical/id特征&lt;/strong&gt;，比如点击过的多个商品、看过的多个视频、输入过的多个搜索词，这就涉及了多个good_id，shop_id。&lt;/li&gt;
&lt;li&gt;不同的用户有不同数量的历史行为，即multi-hot行为特征的向量会导致所产生的embedding向量列表的长度不同，而&lt;u&gt;全连接需要固定长度的输入&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了降低纬度并使得商品店铺间的算术运算有意义，我们先对id特征进行Embedding嵌入。&lt;/p&gt;
&lt;p&gt;那么如何对用户多种多样的兴趣建模？我们把这些id特征embedding之后的多个低维向量（embedding向量列表），“合并”成一个向量，作为用户兴趣的表示。&lt;/p&gt;
&lt;p&gt;因为全连接需要固定长度的输入，所以我们需要“合并”成一个&lt;u&gt;固定长度&lt;/u&gt;向量，这样才能喂入DNN。&lt;/p&gt;
&lt;p&gt;这个“合并”就是所谓&lt;strong&gt;Pooling&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;72-实现方式&quot;&gt;7.2 实现方式&lt;/h3&gt;
&lt;p&gt;围绕着这个Pooling过程，各家有各家的高招：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Youtube DNN这篇论文中，Youtube的做法最简单、直观，就是将用户看过的视频embedding向量、搜索过的关键词embedding向量，做一个&lt;strong&gt;简单的平均&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Neural Factorization Machine中，将n个(n=特征数)k维向量压缩成一个k维向量，取名为bi-interaction pooling。既完成pooling，也实现了特征间的二阶交叉。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DIN用各embedding向量的加权平均实现了pooling，而”权重”由attention机制计算得到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于深度学习的文本分类，同样面临着如何将一段话中的多个词向量压缩成一个向量来表示这段话的问题。常用的方法，就是将多个词向量喂入RNN，最后一个时刻RNN的输出向量就代表了多个词向量的“合并”结果&lt;/strong&gt;。显然，DIEN则借鉴了这一思路，并且改造了GRU的构造，利用attention score来控制门。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;73-dnn&quot;&gt;7.3 DNN&lt;/h3&gt;
&lt;p&gt;DNN base模型采用pooling的方式，一般有两种方法，&lt;strong&gt;求和池化&lt;/strong&gt;（sum pooling，各个对应元素进行累加）和&lt;strong&gt;平均池化&lt;/strong&gt;（average pooling，各个对应元素求平均）。然后将所有向量连接在一起（concatenate），以获得实例的总体表示向量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;求和就是对多个商品的embedding，在每个对应的维度上做求和。例如，点击序列有10个商品，那么就有10个商品的embedding，假设商品的embedding维度是16，那么分别在第1到16维上，对10个值求和。&lt;/li&gt;
&lt;li&gt;平均就是对多个embedding，在每个对应的维度上求平均。不管用户点击过多少个商品，经过pooling之后，得到的最终表示向量embedding和每个商品的embedding维度都是相同的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;base模型对于任何要预测的candidate，不管这个candidate是衣服，电子产品等，用户的表示向量都是确定的、不变的，对于任何candidate都无差别对待。&lt;/p&gt;
&lt;h3 id=&quot;74-din&quot;&gt;7.4 DIN&lt;/h3&gt;
&lt;p&gt;回到阿里的展示广告系统，如架构图所示，每个商品有3个特征域，包括商品自身，商品类别，商品所属的商铺。对于每个商品来说，3个特征embedding拼接之后才是商品的表示向量。&lt;/p&gt;
&lt;p&gt;对商品序列做pooling，架构图中采用的是求和的方式，pooling之后得到用户行为序列的表示向量。然后再和其他的特征embedding做拼接，作为MLP的输入。&lt;/p&gt;
&lt;p&gt;MLP输入端的整个embedding向量，除了candidate的embedding部分，其余的embedding部分可以视为用户的表示向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201011102859098-1345216596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细的研究下Base Model中Pooling Layer就会发现，Pooling操作损失了很多信息。&lt;/p&gt;
&lt;p&gt;所以DIN 使用 Pooling（weighted sum）对Diversity建模，因为&lt;u&gt;直接sum体现不出差异多样性，加权可以&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;即DIN用各embedding向量的加权平均实现了pooling，而”权重”由attention机制计算得到&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x08-attention机制&quot;&gt;0x08 Attention机制&lt;/h2&gt;
&lt;p&gt;&lt;u&gt;Attention机制简单的理解就是，针对不同的广告，用户历史行为与该广告的权重是不同的。&lt;/u&gt;假设用户有ABC三个历史行为，对于广告D，那么ABC的权重可能是0.8、0.1、0.1；对于广告E，那么ABC的权重可能是0.3、0.6、0.1。这里的权重，就是Attention机制即架构图中的Activation Unit所需要学习的。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;DIN模型其实就是在DNN基础上加了attention&lt;/u&gt;。通过Attention来实现Pooling，使用户兴趣的向量表示，&lt;u&gt;根据候选物料的不同而不同&lt;/u&gt;，实现&lt;strong&gt;用户兴趣的“千物千面”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模型的目标：基于用户历史行为，充分挖掘用户兴趣和候选广告之间的关系。用户是否点击某个广告往往是基于他之前的部分兴趣，这是应用Attention机制的基础。因为无论是用户兴趣行为，还是候选广告都会被映射到&lt;strong&gt;Embedding空间&lt;/strong&gt;中。所以他们两者的关系，是在Embedding空间中学习的。&lt;/p&gt;
&lt;h3 id=&quot;81-问题&quot;&gt;8.1 问题&lt;/h3&gt;
&lt;p&gt;DIN的attention机制部分是&lt;u&gt;&lt;strong&gt;为了&lt;/strong&gt;用一个 fix length 的 vector 刻画用户面对不同的商品展现出不同的兴趣&lt;/u&gt;，这个点看起来很简单，但是实际比较困难。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传统DNN模型为了得到一个固定长度的Embedding Vector表示，原来的做法是在&lt;code&gt;Embedding Layer&lt;/code&gt;后面增加一个&lt;code&gt;Pooling Layer&lt;/code&gt;。Pooling可以用sum或average。最终得到一个固定长度的&lt;code&gt;Embedding Vector&lt;/code&gt;，是用户兴趣的一个抽象表示，常被称作&lt;code&gt;User Representation&lt;/code&gt;。缺点是会损失一些信息。&lt;/li&gt;
&lt;li&gt;用户Embedding Vector的维度为k，它最多表示k个相互独立的兴趣爱好。但是用户的兴趣爱好远远不止k个，怎么办？&lt;/li&gt;
&lt;li&gt;传统DNN模型在&lt;code&gt;Embedding Layer -&amp;gt; Pooling Layer&lt;/code&gt;得到用户兴趣表示的时候，也没有考虑用户与广告之间的关系，即不同广告之间的权重是一致的。这样传统的预估方法在一个user面对不同商品（广告）时用一个同样的vector来表达这个user。如果在这种情况下要想表达多样的兴趣，最简单的方案是增加user vector的维度，然而这会带来overfitting和计算压力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以DIN用类似attention的机制试图解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;82-注意力机制&quot;&gt;8.2 注意力机制&lt;/h3&gt;
&lt;p&gt;注意力机制顾名思义，就是模型在预测的时候，对用户不同行为的注意力是不一样的，“相关”的行为历史看重一些，“不相关”的历史甚至可以忽略。&lt;u&gt;即对于不同的特征有不同的权重，这样某些特征就会主导这一次的预测，就好像模型对某些特征pay attention&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这样的思想反应到模型中也是直观的。比如在视频推荐模型中，DIN可以通过增加用户的历史行为feature：用户观看的近20个show_id，近20个video_id，然后使用attention网络，最后与其它非历史行为feature在MLP中汇合。&lt;/p&gt;
&lt;p&gt;DIN利用attention机制去更好的建模局部激活。在得到用户兴趣表示时赋予不同的历史行为不同的权重，即通过&lt;code&gt;Embedding Layer -&amp;gt; Pooling Layer+attention&lt;/code&gt;实现局部激活。从最终反向训练的角度来看，就是根据当前的候选广告，来反向的激活用户历史的兴趣爱好，赋予不同历史行为不同的权重。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;DIN给出的方案是：不再用一个点来表示用户兴趣，而是通过用一个在不同时刻不一样的分布表示&lt;/u&gt;：分布可以是多峰的，可以表达每个人有多个兴趣。一个峰就表示一个兴趣，峰值的大小表示兴趣强度。那么针对不同的候选广告，用户的兴趣强度是不同的，也就是说随着候选广告的变化，用户的兴趣强度不断在变化。 &lt;u&gt;因为用户兴趣是一个多峰的函数，这样即使在低维空间，也可以获得几乎无限强的表达能力&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;换句话说：&lt;strong&gt;假定用户兴趣表示的Embedding Vector是Vu，候选广告的是Va，那么Vu是Va的函数。&lt;/strong&gt; 也就是说，同意用户针对不同的广告有不同的用户兴趣表示（嵌入向量不同）。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vi表示behavior id i的嵌入向量，比如good_id,shop_id等。&lt;/li&gt;
&lt;li&gt;Vu是所有behavior ids的加权和，表示的是用户兴趣。&lt;/li&gt;
&lt;li&gt;候选广告影响着每个behavior id的权重，也就是Local Activation。&lt;/li&gt;
&lt;li&gt;权重表示的是：每一个behavior id针对当前的候选广告Va，对总的用户兴趣表示的Embedding Vector的贡献大小。在实际实现中，权重用激活函数Dice的输出来表示，输入是Vi和Va。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;83-实现&quot;&gt;8.3 实现&lt;/h3&gt;
&lt;p&gt;DIN中并不能直接用attention机制。因为对于不同的候选广告，用户兴趣表示（embedding vector）应该是不同的。&lt;/p&gt;
&lt;p&gt;Local Activation Unit 借鉴了NMT（Neural Machine Translation）中的attention机制，实现了自己的Attention机制。 Local Activation学习候选广告和用户历史行为的关系，并给出候选广告和各个历史行为的相关性程度 （即权重参数），再对历史行为序列进行加权求和，最终得到用户兴趣的特征表达。也就是说用户针对不同的广告表现出不同的兴趣表示，即使历史兴趣行为相同，但是各个行为的权重不同。&lt;/p&gt;
&lt;p&gt;DIN 在pooling的时候，与candidate相关的商品权重大一些，与candidate不相关的商品权重小一些，&lt;strong&gt;这就是一种Attention的思想&lt;/strong&gt;。将candidate与点击序列中的每个商品发生交互来计算attention分数。具体计算输入包括商品和candidate的embedding向量，以及两者的外积。对于不同的candidate，得到的用户表示向量也不同，具有更大的灵活性。&lt;/p&gt;
&lt;p&gt;DIN中，对于候选广告， 根据local activation unit计算出的用户兴趣向量为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201011102820956-991496330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ei 表示用户U历史行为序列embedding向量，比如good_id,shop_id等，长度为H；&lt;/li&gt;
&lt;li&gt;Vu 表示用户所有行为embedding向量的加权和，表示用户的兴趣；&lt;/li&gt;
&lt;li&gt;Va 表示广告 A 的mbedding 向量;&lt;/li&gt;
&lt;li&gt;wj 表示ej的权重；&lt;/li&gt;
&lt;li&gt;权重表示的是：每一个behavior id针对当前的候选广告Va，对总的用户兴趣表示的Embedding Vector的贡献大小。&lt;/li&gt;
&lt;li&gt;在实现中，权重wj 用函数去拟合，通过Activation Unit计算得出，用激活函数Dice的输出来表示，表示为g(Vi,Va)，输入是Vi和Va；&lt;/li&gt;
&lt;li&gt;候选广告影响着每个behavior id的权重，也就是Local Activation；&lt;/li&gt;
&lt;li&gt;a （ . ） 表示一个feed-forward network，其输出作为local activation的权值，与用户向量相乘；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这种计算方式下，最终的用户 U 的兴趣向量会根据不同的广告 A 而变化。这就是 “&lt;strong&gt;用户兴趣的千物千面&lt;/strong&gt;”。比如，一个用户之前买过奶粉与泳衣，当展示给她泳镜时，显然更会唤起她买过的泳衣的记忆；而当展示给她尿不湿时，显然更唤起她买过的奶粉的记忆。&lt;/p&gt;
&lt;p&gt;DIN attention机制中，用户兴趣向量 Vu 是历史上接触过的item embedding向量的加权平均，而第 i 个历史 item 的权重 Wi 由该历史 item 的 embedding 向量 Vi 与候选物料的 embedding 向量 Va 共同决定（函数g）。可见同一个用户当面对不同候选物料时，其兴趣向量也不相同，从而实现了“千物千面”。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;DIN与base model的主要区别就在于激活单元上，这个结构通过计算广告的embedding与用户表现的embedding之间的相似度得到对应的权重，后对表现序列进行权重求和，取得了不俗的表现&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;84-归一化&quot;&gt;8.4 归一化&lt;/h3&gt;
&lt;p&gt;一般来说，做attention的时候，需要对所有的分数通过softmax做归一化，这样做有两个好处，一是保证权重非负，二是保证权重之和为1。&lt;/p&gt;
&lt;p&gt;但是在DIN的论文中强调，不对点击序列的attention分数做归一化，直接将分数与对应商品的embedding向量做加权和，目的在于保留用户的兴趣强度。例如，用户的点击序列中90%是衣服，10%是电子产品，有一件T恤和一部手机需要预测CTR，那么T恤会激活大部分的用户行为，使得根据T恤计算出来的用户行为向量在数值上更大。&lt;/p&gt;
&lt;h2 id=&quot;0x09-评价指标&quot;&gt;0x09 评价指标&lt;/h2&gt;
&lt;p&gt;评价标准是阿里自己提出的GAUC。并且实践证明了GAUC相比于AUC更加稳定、可靠。&lt;/p&gt;
&lt;p&gt;AUC表示正样本得分比负样本得分高的概率。在CTR实际应用场景中，CTR预测常被用于对每个用户候选广告的排序。但是不同用户之间存在差异：有些用户天生就是点击率高。以往的评价指标对样本不区分用户地进行AUC的计算。论文采用的GAUC实现了用户级别的AUC计算，&lt;strong&gt;在单个用户AUC的基础上，按照点击次数或展示次数进行加权平均，消除了用户偏差对模型的影响&lt;/strong&gt;，更准确的描述了模型的表现效果。&lt;/p&gt;
&lt;h2 id=&quot;0x10-adaptive-regularization&quot;&gt;0x10 Adaptive Regularization&lt;/h2&gt;
&lt;p&gt;由于深度模型比较复杂，输入又非常稀疏，导致参数非常多，非常容易过拟合。&lt;/p&gt;
&lt;p&gt;CTR中输入稀疏而且维度高，已有的L1 L2 Dropout防止过拟合的办法，论文中尝试后效果都不是很好。用户数据符合 长尾定律&lt;code&gt;long-tail law&lt;/code&gt;，也就是说很多的feature id只出现了几次，而一小部分feature id出现很多次。这在训练过程中增加了很多噪声，并且加重了过拟合。&lt;/p&gt;
&lt;p&gt;对于这个问题一个简单的处理办法就是：人工的去掉出现次数比较少的feature id。缺点是：损失的信息不好评估；阈值的设定非常的粗糙。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DIN给出的解决方案是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;针对feature id出现的频率，来自适应的调整他们正则化的强度；&lt;/li&gt;
&lt;li&gt;对于出现频率高的，给与较小的正则化强度；&lt;/li&gt;
&lt;li&gt;对于出现频率低的，给予较大的正则化强度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对L2正则化的改进，在进行SGD优化的时候，每个mini-batch都只会输入部分训练数据，反向传播只针对部分非零特征参数进行训练，添加上L2之后，需要对整个网络的参数包括所有特征的embedding向量进行训练，这个计算量非常大且不可接受。论文中提出，在每个mini-batch中只对该batch的特征embedding参数进行L2正则化。&lt;/p&gt;
&lt;h2 id=&quot;0x11-总结&quot;&gt;0x11 总结&lt;/h2&gt;
&lt;p&gt;对论文总结如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户有多个兴趣爱好，访问了多个good_id，shop_id。为了降低纬度并使得商品店铺间的算术运算有意义，我们先对其进行Embedding嵌入。那么我们如何对用户多种多样的兴趣建模那？使用&lt;strong&gt;Pooling对Embedding Vector求和或者求平均&lt;/strong&gt;。同时这也解决了不同用户输入长度不同的问题，得到了一个固定长度的向量。这个向量就是用户表示，是用户兴趣的代表。&lt;/li&gt;
&lt;li&gt;但是，直接求sum或average损失了很多信息。所以稍加改进，针对不同的behavior id赋予不同的权重，这个权重是由当前behavior id和候选广告共同决定的。这就是Attention机制，实现了Local Activation。&lt;/li&gt;
&lt;li&gt;DIN使用&lt;em&gt;activation unit&lt;/em&gt;来捕获local activation的特征，使用&lt;em&gt;weighted sum pooling&lt;/em&gt;来捕获diversity结构。&lt;/li&gt;
&lt;li&gt;在模型学习优化上，DIN提出了&lt;em&gt;Dice激活函数&lt;/em&gt;、&lt;em&gt;自适应正则&lt;/em&gt; ，显著的提升了模型性能与收敛速度。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53110408&quot;&gt;用NumPy手工打造 Wide &amp;amp; Deep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47293765&quot;&gt;看Google如何实现Wide &amp;amp; Deep模型(1)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46247835&quot;&gt;看Youtube怎么利用深度学习做推荐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54838663&quot;&gt;也评Deep Interest Evolution Network&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78365283&quot;&gt;从DIN到DIEN看阿里CTR算法的进化脉络&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/aa8102980/article/details/102374473/&quot;&gt;第七章 人工智能，7.6 DNN在搜索场景中的应用(作者：仁重)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/John159151/article/details/91377508&quot;&gt;#Paper Reading# Deep Interest Network for Click-Through Rate Prediction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/79060b8db1eb&quot;&gt;【paper reading】Deep Interest Evolution Network for Click-Through Rate Prediction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54838663&quot;&gt;也评Deep Interest Evolution Network&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ybjlucky/article/details/87888255&quot;&gt;论文阅读：《Deep Interest Evolution Network for Click-Through Rate Prediction》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/134170462&quot;&gt;【论文笔记】Deep Interest Evolution Network(AAAI 2019)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/srdlaplace/article/details/89464050&quot;&gt;【读书笔记】Deep Interest Evolution Network for Click-Through Rate Prediction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/f53af7312e18&quot;&gt;DIN(Deep Interest Network):核心思想+源码阅读注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010352603/article/details/80590152&quot;&gt;计算广告CTR预估系列(五)--阿里Deep Interest Network理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yz930618/article/details/85003101&quot;&gt;CTR预估之Deep Interest NetWork模型原理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32085405&quot;&gt;人人都能看懂的LSTM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1639105801622260740&quot;&gt;从动图中理解 RNN，LSTM 和 GRU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41753033/article/details/95937154&quot;&gt;台大李宏毅机器学习(一)——RNN&amp;amp;LSTM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av9770190/?p=25&quot;&gt;李宏毅机器学习(2016)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6742d10b89a8&quot;&gt;推荐系统遇上深度学习(二十四)--深度兴趣进化网络DIEN原理及实战！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012193416/article/details/86301899&quot;&gt;from google.protobuf.pyext import _message，使用tensorflow出现 ImportError: DLL load failed&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Eric_1993/article/details/107882557&quot;&gt;DIN 深度兴趣网络介绍以及源码浅析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Dby_freedom/article/details/85936263&quot;&gt;CTR预估 论文精读(八)--Deep Interest Network for Click-Through Rate Prediction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_35564813/article/details/90714056&quot;&gt;阿里CTR预估三部曲(1)：Deep Interest Network for Click-Through Rate Prediction简析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_35564813/article/details/90723139&quot;&gt;阿里CTR预估三部曲(2)：Deep Interest Evolution Network for Click-Through Rate Prediction简析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/132da6864d40&quot;&gt;Deep Interest Network解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://running-bad-ai.github.io/2018/08/02/DIN/&quot;&gt;深度兴趣网络(DIN,Deep Interest Network)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gaoborl/article/details/86644044&quot;&gt;DIN论文官方实现解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_15443203/article/details/104684745&quot;&gt;阿里DIN源码之如何建模用户序列(1)：base方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/112044156&quot;&gt;阿里DIN源码之如何建模用户序列(2)：DIN以及特征工程看法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/133467437&quot;&gt;阿里深度兴趣网络(DIN)论文翻译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6742d10b89a8&quot;&gt;推荐系统遇上深度学习(二十四)--深度兴趣进化网络DIEN原理及实战！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/73b6f5d00f46&quot;&gt;推荐系统遇上深度学习(十八)--探秘阿里之深度兴趣网络(DIN)浅析及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Blank_spaces/article/details/106485534&quot;&gt;【论文导读】2018阿里CTR预估模型---DIN(深度兴趣网络)，后附TF2.0复现代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Blank_spaces/article/details/107194648&quot;&gt;【论文导读】2019阿里CTR预估模型---DIEN(深度兴趣演化网络)&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 17 Oct 2020 00:17:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Deep Interest Network（DIN）是阿里妈妈精准定向检索及基础算法团队在2017年6月提出的。其针对电子商务领域（e-commerce industry）的CTR预估，重点在于充分利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13796470.html</dc:identifier>
</item>
<item>
<title>这次让面试官非常满意：手撕深拷贝[15行] - bigname22</title>
<link>http://www.cnblogs.com/bigname/p/13829611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigname/p/13829611.html</guid>
<description>&lt;center&gt;&lt;span&gt;这次让面试官非常满意：手撕深拷贝&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;span&gt;-------------人工分割线-------------&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;浅拷贝这里不做介绍了，深拷贝的实现要点，除了一定要深！还要能兼容各种类型，如函数，正则、Date等等。&lt;br/&gt;其实日常业务开发中，Json.parse(Json.stringfy(obj))已经能够解决90%左右的克隆需求。还有Object.assign() Object.create()都能满足一定的克隆需求。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但上班拧螺丝，面试造航母的精神不容小觑！本着专研精神去看待怎么才能写个牛逼、各种场合都能通用的克隆方式？我做了不少功课。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在思考如何实现深拷贝之前，首先得弄明白：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如何遍历对象？&lt;a href=&quot;https://blog.csdn.net/bigname22/article/details/109064660&quot;&gt;点这可以传送&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何判断数据类型？&lt;a href=&quot;https://blog.csdn.net/bigname22/article/details/109089398&quot;&gt;点这可以传送&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何创建对象？【由于懒没写】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何克隆函数，正则、Date对象？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何解决循环引用问题？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实现思路：&quot;&gt;&lt;span&gt;实现思路：&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用递归实现嵌套对象的遍历&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;增加WeakMap来缓存已经创建的克隆对象解决循环引用问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;区分不同数据类型的处理方式，增加通用类型集合来存储通用类型，方便日后拓展&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;直接上代码：&quot;&gt;&lt;span&gt;直接上代码：&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;待克隆对象&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;let obj = {
        newDate: new Date('2020-10-11 12:00:01'),
        null: null,
        string: 'string',
        num: 23,
        nan: NaN,
        func: function () {console.log('function')},
        arr: [1,2,3],
        reg: /ABC\-001/,
        regObj: new RegExp(/ABC/),
        object: {
            c: {
                a: 1
            }
        },
    };
    obj.loop = obj; // 循环引用

    let sup = {
        name: 'super',
        show: function () {
            console.log('show')
        }
    }
    let objectSup = {
        objectSupName: 'objectSupName',
        objectSupShow: function () {
            console.log('objectSupShow')
        }
    }
    Object.setPrototypeOf(obj, sup); // 根对象设置原型对象
    Object.setPrototypeOf(obj.object, objectSup); // 子对象设置原型对象
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;核心代码&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;         // 使用WeakMap是便于回收
    function deepClone(obj, cacheCurr = new WeakMap()) {
        // 如果该对象已经创建好，则从缓存中获取直接返回
        if (cacheCurr.has(obj)) return cacheCurr.get(obj);
        // 通用的类型集合，方便后面统一处理:new obj.constructor(obj),所以该集合一定是要能够这样创建的才能放进来
        const types = ['RegExp', 'Date', 'Set', 'Map', 'WeakMap', 'WeakSet'];
        // 获取当前对象类型
        let objDataType = Object.prototype.toString.call(obj).slice(8, -1);
        // 对比当前类型是否在通用类型中，在则统一处理克隆。【较通用的处理方式】
        if(types.includes(objDataType)) return new obj.constructor(obj);
        // 创建克隆对象
        let cloneObj = objDataType === 'Array' ? [] : {};
        // 继承原型
        if(obj) Object.setPrototypeOf(cloneObj,Object.getPrototypeOf(obj));
        // 普通引用类型及非引用类型克隆，Reflect.ownKeys能够获取自身所有属性【非枚举也可】
        for(let key of Reflect.ownKeys(obj)) {
            let value = obj[key];
            let valueType = Object.prototype.toString.call(value).slice(8, -1);
            // 引用类型处理
            if(valueType === 'Object' || valueType === 'Array' || types.includes(valueType)) {
                // 对引用类型进行递归进入当前级的下一级进行遍历
                cloneObj[key] = deepClone(value, cacheCurr);
                // 记录已创建引用
                cacheCurr.set(obj, cloneObj);
            } else { // 非引用类型处理
                cloneObj[key] = value;
            }
        }
        return cloneObj;
    }
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;代码注释感觉都写的很清楚了。写完这篇文章就可以安心的来一把无限火力了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;测试过挺多数据结构的都完美通过。如果有发现问题的同学帮忙指出来。感激不尽&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Oct 2020 19:03:00 +0000</pubDate>
<dc:creator>bigname22</dc:creator>
<og:description>这次让面试官非常满意：手撕深拷贝 人工分割线 浅拷贝这里不做介绍了，深拷贝的实现要点，除了一定要深！还要能兼容各种类型，如函数，正则、Date等等。 其实日常业务开发中，Json.parse(Json</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigname/p/13829611.html</dc:identifier>
</item>
<item>
<title>MySQL数据库规范 (设计规范+开发规范+操作规范) - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/13796453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/13796453.html</guid>
<description>&lt;h2&gt;I 文档定义&lt;/h2&gt;
&lt;h3&gt;1.1 编写目的&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      为了在软件生命周期内规范数据库相关的需求分析、设计、开发、测试、运维工作，便于不同团队之间的沟通协调，以及在相关规范上达成共识，提升相关环节的工作效率和系统的可维护性。同时好的规范，在执行的时候可以培养出好的习惯，好的习惯是软件质量的保证。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.2  适用范围 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;       本文档适用于开发、测试、QA及运维团队成员。 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;II . 命名设计规范&lt;/h2&gt;
&lt;h3&gt;2.1 总则&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）所有命名采用26个英文小写字母和0－9这十个自然数，加上下划线_组成。不能出现其他字符（注释除外）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）对象名尽量短，长度不超过30个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）对象名字尽量描述实体的内容，由英文单词、单词组合或单词缩写组成，不以数字和_开头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）命名中禁止使用SQL保留字。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2 库名&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;库名与应用名称尽量一致，统一小写，以下划线分割。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3 表名&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;表名必须使用小写字母或数字，以下划线分割，禁止出现数字开头，禁止两个下划线中间只出现数字。如果表名仅有一个单词，那么建议不使用缩写，而是用完整的单词。同一模块的表尽可能使用相同的前缀，表名称尽可能表达含义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据表 &amp;lt;模块标识&amp;gt;_&amp;lt;表标识&amp;gt;  例如： order_header , order_detail&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编码表 base_&amp;lt;模块标识&amp;gt;_&amp;lt;表标识&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;日志表 log_&amp;lt;模块标识&amp;gt;_&amp;lt;表标识&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.4 字段名 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1） 能表达字段功能的英文单词或单词缩写，一般不超过三个英文单词，以下划线分割。布尔类型的字段以“is_”作为前缀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 各表之间意义相同的字段应同名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3） 系统中所有属于内码的字段（仅用于表示唯一性和程序内部用到的标识性字段），名称取为：&amp;lt;表标识&amp;gt;_id。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4） 系统中属于是业务范围内的编号的字段，其代表一定的业务信息，这样的字段建议命名为&amp;lt;业务标识&amp;gt;_code，其数据类型为VARCHAR，该字段需加唯一索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5） 字段名不要与表名重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6） 不要在列的名称中包含数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7） 每个字段添加字段说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8） 数据库字段名的修改代价很大，所以字段名称需要慎重考虑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9） 统一命名字段：create_by、create_time、modify_by、modify_time、disabled&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.5 索引名 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;A. 非唯一索引必须按照“idx_&amp;lt;构成索引的字段名&amp;gt;”进行命名 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：在age上添加索引idx_age&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B. 唯一索引必须按照“uidx_&amp;lt;构成索引的字段名&amp;gt;”进行命名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：uidx_cardid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. 组合索引建议包含所有字段名，过长的字段名可以采⽤缩写形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：idx_age_name&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.6 视图命名 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;v_&amp;lt;模块标识&amp;gt;_&amp;lt;视图标识&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.7 存储过程命名 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;usp_&amp;lt;模块标识&amp;gt;_&amp;lt;存储过程标识&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.8 函数命名 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ufn_&amp;lt;模块标识&amp;gt;_&amp;lt;函数标识&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;III 数据库设计规范 &lt;/h2&gt;
&lt;h3&gt;3.1 表设计原则&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1） 表的存储引擎建议是InnoDB存储引擎,InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）同一个DB中的表，其存储引擎、字符集应保持统一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 数据表创建、变更具备说明文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   数据表创建、变更时必须提供数据表设计文档: 包含表及字段详细说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3） 规范化与反规范化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          规范化的优点是减少了数据冗余，节约了存储空间，相应逻辑和物理的I/O次数减少，同时加快了增、删、改的速度。但是一个完全规范化的设计并不总能生成最优的性能，因为对数据库查询通常需要更多的连接操作，从而影响到查询的速度，而且范式越高性能就会越差。出于性能和方便管理的考虑，原则上表设计应满足第三范式。有时为了提高某些查询或应用的性能而可以破坏规范规则，即反规范化。数据应当按两种类别进行组织：频繁访问的数据和频繁修改的数据。对于频繁访问但是不频繁修改的数据，内部设计应当物理不规范化。对于频繁修改但并不频繁访问的数据，内部设计应当物理规范化。比较复杂的方法是将规范化的表作为逻辑数据库设计的基础，然后再根据整个应用系统的需要，物理地非规范化数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）临时库表必须以 _tmp_ 为前缀并以日期为后缀，备份表必须以 _bak_ 为前缀并以日期 为后缀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）尽量控制单表数据量的大小，建议控制在 600 万以内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         大表在查询性能和结构修改、备份、恢复等运维方面存在很多弊端。可以用历史数据归档，分库分表、选择其它类型数据库等手段来控制数据量大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）数据表分类说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  根据应用的实际需要和特点，可以将数据表进行如下分类： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. 基本数据表：描述业务实体的基本信息。例如：人员基本信息、单位基本信息等。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B. 标准编码表：描述属性的列表值。例如：职称、民族、状态等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. 业务数据表：记录业务发生的过程和结果。例如：人员调动登记、变更通知单等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D. 系统信息表：存放与系统操作、业务控制有关的参数。例如：用户信息、权限、用户配置信息等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E. 统计数据表：存放业务数据统计值。例如：通知单统计、人员类别统计等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F. 临时处理表：存放业务处理过程中的中间结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;G. 其他类型表：存放应用层的日志、消息记录等。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 字段设计原则 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）完善的字段说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         涉及数据字段新增、变更，必须提供字段说明，需要及时更新字段注释。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;选择符合存储需要的最小的数据类型&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          一般来说，应该使用能正确存储和表示数据的最小类型。如果不确定需要什么数据类型，则选择不会超出范围的最小类型。&lt;/span&gt;&lt;span&gt;选择更简单的数据类型。例如，整数类型的比较其代价小于字符类型的比较，因为字符集和排序规则使字符比较更复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）合理的字段默认值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         字段尽可能有默认值，字符型的默认值为一个空字符串，数字型的默认为数值0。 尽可能把字段定义为NOT NULL。对于字段能否NULL，应该在SQL建表脚本中明确指明，不应使用缺省。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）所有布尔类型字段数据类型是unsigned tinyint，数值0表示为假；数值1表示为真（根据表的字段意义：比如Disabled = 1表示 Disabled 值为真，可以表示数据被逻辑删除）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）&lt;/span&gt;避免使用 ENUM 类型&lt;/p&gt;
&lt;p&gt;          ENUM 类型的 ORDER BY 操作效率低，需要额外操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）MySQL最大行大小不能超过64KB（65535字节），所以一个表中的字段不要太多，理论上建议不要超过30个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）如果存储的字符串长度几乎相等，推荐使用CHAR定长字符串类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）VARCHAR是可变长字符串，不预先分配存储空间，长度不要超过2000，如果存储长度大于此值，定义字段类型为text或blob，独立出来一张表，用主键来对应，避免影响其他字段索引效率。TEXT 和 BLOB 的主要差别是 BLOB 能够保存&lt;code&gt;二进制数据&lt;/code&gt;；而 TEXT 只能保存&lt;code&gt;字符数据。在程序设计时，&lt;/code&gt;&lt;/span&gt;&lt;span&gt;尽可能不使用TEXT、BLOB类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）区分使用DATETIME和TIMESTAMP，两者都可用来表示YYYY-MM-DD HH:MM:SS类型的日期。两种都保存日期和时间信息，毫秒部分最高精确度都是6位数。建议使用TIMESTAMP(3)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. TIMESTAMP占用4字节，DATETIME占用8字节，当保存毫秒部分时两者都使用额外的空间 （1-3 字节）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B. TIMESTAMP的取值范围比DATETIME小得多，不适合存放比较久远的日期。TIMESTAMP只能存储从 '1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999' 之间的时间。而DATETIME允许存储从 '1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999' 之间的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. TIMESTAMP的插入和查询受时区的影响。如果记录的日期需要让不同时区的人使用，最好使用 TIMESTAMP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）根据实际需要选择能够满足应用的最小存储的日期类型。如果应用只需记录“年份”，那么用1个字节的YEAR类型完全可以满足，而不需要用4个字节来存储的DATE类型。这样不仅可以节约存储，还可以提高表的操作效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11）小数类型为decimal，禁止使用float和double。因为float和double在存储的时候，存在精度损失问题，这是浮点数特有的问题。因此在精度要求比较高的应用中（比如货币）要使用定点数而不是浮点数来保存数据。浮点数指的就是含有小数的值，浮点数插入到指定列中超过指定精度后，浮点数会四舍五入，MySQL 中的浮点数指的就是&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;float&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;double&lt;/code&gt;，定点数指的是&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;decimal&lt;/code&gt;，定点数能够更加精确的保存和显示数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（12）字段允许适当冗余，以提高性能，但是必须考虑数据完整性。冗余字段应遵循：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. 不是频繁修改的字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B. 不是varchar超长字段，更不能是text字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. 需要维护冗余字段的数据完整性。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.3 主键设计原则 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）一定要有显式的主键。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）针对InnoDB，在无特殊需求的情况下，建议使用与业务无关的自增ID作为主键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）自增字段做主键时，字段类型必须是bigint 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）不推荐使用联合主键。由于InnoDB索引的数据结构都是B+tree，对包含联合主键的表做大量写入，会导致InnoDB为了维持B+tree而移动大量数据，降低性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）禁止外键。对性能损耗特别大，一般的做法是，在业务层设计专门的逻辑或解决方案来保证数据的一致性，以最终一致的时差来换取即使访问的性能问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.4 索引设计原则 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）不允许存在和主键重复的索引。主键其实就是一个非空的唯一索引，所以再在该字段上添加一个索引完全是多此一举。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。唯一索引的值是唯一的，可以更快速地通过该索引确定某条记录。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，必然有脏数据产生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）考虑索引列值的分布。评估某一栏位是否值得建索引，是根据选择性(符合条件笔数/总笔数)*100%来判断，选择性越低代表越值得，惯用的百分比界线是20%。如果某个数据列用于记录性别（只有&quot;M&quot;和&quot;F&quot;两种值），并且值出现的几率几乎相等，那么无论搜索哪个值都可能得到一半的数据行，在这种情况下索引的用处就不大。因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）为经常需要排序、分组和关联的字段建立索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）为常作为查询条件的字段建立索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）&lt;/span&gt;&lt;span&gt;使用短索引，不要索引大字段。如果对varchar字段进行索引，必须指定一个前缀长度，尽量使用&lt;code&gt;前缀索引，&lt;/code&gt;没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 使用前缀索引，对列的某几个字符进行索引，可以提高检索效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）合理创建联合索引，(a，b，c) 相当于 (a) 、(a，b) 、(a，b，c)，区分度最高的列在最左边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）合理使用覆盖索引减少IO，避免排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）不要过度使用索引，单个表上的索引数量建议不要超过5个 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）删除不再使用或者很少使用的索引。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.5 数据库里不建议存放业务日志&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;业务日志的写入量比较大，影响mysql的性能，建议存放到非关系型数据库中。 &lt;/span&gt; &lt;/p&gt;
&lt;h2&gt;IV  SQL设计规范&lt;/h2&gt;
&lt;h3&gt;4.1 &lt;span class=&quot;Apple-converted-space&quot;&gt;避免数据类型的隐式转换&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;例如：SQL中的字符串类型数据应该统一使用单引号。特别对纯数字的字符串，必须用单引号，否则会导致隐式转换而引起性能问题或索引失效问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2 避免复杂SQL &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于非常复杂的SQL，特别是有多层嵌套，带子句或相关子查询的，应该先考虑是否设计不当引起的。对于一些复杂SQL可以考虑使用程序实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.3 批量插入&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用INSERT语句一定要给出插入值的字段列表，这样即使表加了字段也不会影响现有系统的运行。对于小批量插入，可以将多条记录合并为同一个SQL，使用INSERT INTO tablename (col1,col2,...) VALUES (value1, value2,...),(value1, value2,...),...; 插入多条数据只有一次提交，效率明显提高。对于大批量插入和文件的导入导出，避免使用insert .... select和create table…select的形式，可能会阻止对源表的并发更新，如果查询比较复杂，会造成严重的性能问题。推荐使用select...into outfile和load data infile的组合来实现，采用这种方式MySQL不会给source_tab 加锁，还可以大大缩短数据的导出导入时间。但是，由于这种方式存在一定的安全隐患，所以如果需要使用这种方式，必须提交DBA审批，审批通过以后才可执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.4 数据更新&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;推荐使用主键更新，其它维度条件的更新操作会造成页锁。对多个表进行关联update操作风险较大，尤其是当执行计划出现错误时，可导致多个表同时被锁住，应该尽量避免。&lt;/span&gt;&lt;span&gt;不带条件的update会导致全表操作，耗时较长，如有此需求，请联系DBA评估、操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.5 避免使用TRUNCATE TABLE&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;TRUNCATE TABLE 比 DELETE速度快，且使用的系统和事务日志资源较少，也可以直接释放磁盘空间，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在代码中使用此语句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TRUNCATE TABLE在功能上与不带where子句的delete语句相同。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.6 避免使用SELECT *&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果不必要取出所有数据，不要用 * 来代替，应给出字段列表。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.7 使用索引做条件查询count(*)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;innodb引擎在统计方面和myisam是不同的，Myisam内置了一个计数器，所以在使用 select count(*) from table 的时候，直接可以从计数器中取出数据。而innodb必须全表扫描一次方能得到总的数量。每执行一次扫描一次，代价非常高。需要进行count(*)统计表记录总数时，加上secondary index扫描条件，可以加快扫描速度。例如：SELECT COUNT(*) FROM sbtest1 WHERE id&amp;gt;=0;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.8 避免IN子句&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用 IN 或 NOT IN 子句时，特别是当子句中有多个值且表数据较多时，速度会明显下降。可以采用连接查询或外连接查询来提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.9 避免不必要的排序&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;不必要的数据排序大大的降低系统性能。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：在使用group by col的时候，mysql会默认order by col ,在只需要分组不需要排序的情况下，可以使用GROUP BY col ORDER BY NULL提升执行效率，仅仅对col列分组，而不排序。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.10 合理利用最左索引&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;组合索引的生效原则是：从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用。对于组合索引，注意索引的使用顺序，where子句中将最左索引放在第一列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：（a,b,c） 三个列上加了联合索引（是联合索引，不是在每个列上单独加索引）where a=3 and b=45 and c=5 .... 这种三个索引顺序使用中间没有断点，全部发挥作用 where a=3 and c=5... 这种情况下b就是断点，a发挥了效果，c没有效果where b=3 and c=4... 这种情况下a就是断点，在a后面的索引都没有发挥作用，这种写法联合索引没有发挥任何效果where b=45 and a=3 and c=5 .... 这个跟第一个一样，全部发挥作用，abc只要用上了就行，跟写的顺序无关 。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.11 多表连接&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;做多表操作时，应该给每个表取一个别名，每个表字段都应该标明其所属哪个表。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为关联操作的字段建立索引，并使用统一数据类型，不同数据类型做关联时，MySQL会进行隐式转换，导致无法用到索引，开销较大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多表连接个数建议不超过3个。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.12 避免在where后的索引字段上使用函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在where后的索引字段上使用函数会导致索引失效，严重情况下会拖慢整个数据库实例的速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SELECT orderid&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FROM order_detail&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;WHERE from_unixtime(create_time)&amp;gt;'2017-12-04 12:00:00';&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样使用函数会导致查询条件不使用索引，使查询性能下降。应改为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SELECT orderid&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FROM order_detail&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;WHERE create_time&amp;gt;unix_timestamp('2017-12-04 12:00:00');&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;4.13 尽量不要做’%’前缀模糊查询&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;col like “abc%” 能用上索引，而&lt;/span&gt;&lt;span&gt;col like “%abc”不能用上索引&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.14 使用UNION ALL代替UNION&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;UNION合并两个或多个SELECT语句的结果集，并消去表中任何重复行。而UNION ALL不会消除重复行。从效率上说，UNION ALL要比UNION快很多，所以如果可以确认合并的多个结果集中不包含重复数据时，建议使用UNION ALL。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.15 尽量避免OR操作&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通常情况下，如果条件中有or，即使其中有条件带索引也不会使用，所以除非每个列都建立了索引，否则不建议使用OR。在多列OR中，建议用UNION ALL替换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;select f_crm_id from d_dbname1.t_tbname1 where f_xxx_id = 926067&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;and (f_mobile ='1234567891' or f_phone ='1234567891' )；&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应改为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;select f_crm_id from d_dbname1.t_tbname1 where f_xxx_id = 926067&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;and f_mobile ='1234567891'&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;UNION ALL&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;select f_crm_id from d_dbname1.t_tbname1 where f_xxx_id = 926067&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;and f_phone ='1234567891'&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同字段or可改成 in，如 f_id=1 or f_id=100 --&amp;gt; f_id in (1,100)。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.16 MySQL 在否定条件中不能使用索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;例如，where 条件里面有&amp;lt;&amp;gt;、not in 、not exists的时候，即便是在这些判断字段上加有索引，也不会起作用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.7 MySQL 在JOIN中连接字段类型如果不一致，则不能使用索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;但是例外就是char和varchar如果在定义表的时候，长度一致，就可以利用索引JOIN，反正不行。例如，char(20)和varchar(20)可以利用索引，char(20)和varchar(25)则不行，不管varchar里面实际存储的值是多长。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.18 如果两个字段列的字符集不同，不推荐JOIN&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;字符集不同的列，索引失效，容易引起慢查询故障。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;V 完整性设计规范&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;采用数据库系统实现数据的完整性，这不但包括通过标准化实现的完整性而且还包括数据的功能性。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.1 主键约束&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;每个表要求有主健，主健字段或组合字段必须满足非空属性和唯一性要求。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.2 NULL值&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）由于NULL值在参加任何运算时，结果均为NULL，所以尽可能把字段定义为NOT NULL。对于所有声明为NOT NULL的字段，必须显式指定默认值。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）不要使用count(列名)或者count(常量)来替代 count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟null和非null无关。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  说明：count(*)会统计值为null的行，而count(列名)不会统计此列为null的行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）count(distinct col)计算该列除null之外不重复的行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  注意：count(distinct col1, col2)，如果其中一列全为null，那么即使另一列有不同的值，也返回0。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）当某一列的值全为null，count(col)的返回结果为0，但sum(col)的返回结果为null，因此使用sum()时需要注意NPE问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 例如，可以使用ISNULL()来判断是否为NULL值，来避免sum的NPE问题： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; SELECT IF(ISNULL(SUM(g)), 0, SUM(g)) FROM table;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）NULL与任何值的直接比较都为null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NULL&amp;lt;&amp;gt;NULL的返回结果是NULL，而不是false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NULL=NULL的返回结果是NULL，而不是true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NULL&amp;lt;&amp;gt;1的返回结果是NULL，而不是true。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.3 视图使用原则&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了在应用程序和数据库之间提供一层抽象，可以为应用程序建立视图而不必直接访问表。使用试图可以简化操作，不用关注表结构的定义，可以把经常使用的数据集合定义成视图；屏蔽了表结构变化对用户的影响， 表增加列对视图没有影响，具有一定的独立性。此外，用户对视图不可以随意的更改和删除，可以保证数据的安全性。&lt;/span&gt;&lt;span&gt;视图是虚拟的数据库表，在使用时要遵循以下原则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. 尽可能减少使用视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B. 视图中如果嵌套使用视图，级数不要超过3级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. 由于视图中只能固定条件或没有条件，所以对于数据量较大或随时间的推移逐渐增多的表，不宜使用视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D. 除特殊需要，避免类似SELECT * FROM [Table Name] 而没有检索条件的视图 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E. 视图中尽量避免出现数据排序的SQL语句。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;VI 安全性设计规范&lt;/h2&gt;
&lt;h3&gt;6.1 数据库账号使用规范&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;严格管理程序的专用账号，禁止用户使用此账号进行数据操作。 请使用开发人员专用只读账号进行数据查询。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.2 用户与权限&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为不同用户设定允许的权限，管理和使用权限分离。确定每个用户对数据库表的操作权限，如查询、新增、更新等。每个用户拥有刚好能够完成任务的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;严格把控好管理权限，只将管理权限赋予管理员。&lt;/span&gt;&lt;span&gt;禁止有super权限的应用程序账号存在。&lt;/span&gt;&lt;span&gt;禁止有DDL、DCL权限的应用程序账号存在。 &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.3 用户密码管理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;用户帐号的密码必须进行加密处理，确保在任何地方查询都不会出现密码的明文。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;VII 开发行为规范&lt;/h2&gt;
&lt;h3&gt;7.1 总则&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1） 业务部门推广活动或上线新功能，必须提前通知DBA，并留出必要时间以便DBA完成压力评估和扩容 ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 单表多次alter操作必须合并一次操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;要给表t增加一个字段aa,同时给已有的字段bb建立索引，通常的做法分为两步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;alter table t add column aa varchar(10);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后增加索引:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;alter table t add index idx_bb(bb); &lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确的做法是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;alter table t add column aa varchar(10),add index idx_bb(bb);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3） 怀疑有性能瓶颈的SQL及早提交DBA调优，避免上线出现性能问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4） 批量更新数据，必须通知DBA进行审核，并在执行过程中观察服务及主从延迟；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5） 重要业务库的变更，须告知DBA重要等级、是否数据备份和执行时间要求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6） 避免在业务高峰期批量更新、查询数据库；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7） 提交线上建表改表需求，必须详细注明涉及到的所有SQL语句，便于DBA进行审核和优化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8） 所有DDL和DML语句必须要在运维平台上提交申请，禁止口头或通过聊天工具传送需求； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9） 不要在MySQL数据库中存放业务逻辑&lt;em&gt;，&lt;/em&gt;&lt;/span&gt;&lt;span&gt;如果把业务逻辑放到数据库中,将会影响横向发展和上线测试。建议把业务逻辑提前，放到前端或中间逻辑层，数据库仅作为存储层，实现逻辑与存储的分离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10） 出现业务部门人为误操作导致数据丢失，需要恢复数据的，必须第一时间通知DBA，并提供准确时间地点、误操作语句等重要线索；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11） 业务部门程序出现BUG等影响数据库服务的问题，必须及时通知DBA，便于维护服务稳定； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（12） 重要项目的数据库方案选型和设计必须提前通知DBA参与。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;7.2 避免使用触发器&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MySQL中触发器是行触发的，每次增加、修改或者删除记录都会触发进行处理，编写过于复杂的触发器或者增加过多的触发器对记录的插入、更新、删除操作会有比较严重的影响，因此不要将应用的处理逻辑过多地依赖于触发器来处理。&lt;/span&gt;&lt;span&gt;触发器的功能通常可以用其他方式实现，确实需要采用触发器，请联系DBA进行确认。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;7.3 避免使用存储过程和函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在数据库服务器上进行大量的复杂运算会占用服务器的CPU，造成数据库服务器的压力，影响数据库的正常使用，所以应尽量将这些运算操作分摊到应用服务器上执行。此外，存储过程难以调试和扩展，数据库扩展能力远远不如应用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;7.4 避免使用视图&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;视图可能导致执行计划错乱，影响SQL运行效率。对视图的修改，数据库必须把它转化为对基本表的信息修改，不便于维护。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;VIII 其他规范&lt;/h2&gt;
&lt;h3&gt;8.1 编制文档&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对所有的命名规范、限制、数据字典、存储过程、函数都要编制文档。数据库文档化会大大减少犯错的机会，对开发、支持和跟踪修改非常有用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;8.2 维护计划规范&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1） 数据归档设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据业务功能，做最小限度保留，将数据备份至归档库，系统功能兼容访问历史数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 数据归档删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要物理删除不需要归档的数据，直接由DBA排作业自动物理删除。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Oct 2020 16:33:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>I 文档定义 1.1 编写目的 为了在软件生命周期内规范数据库相关的需求分析、设计、开发、测试、运维工作，便于不同团队之间的沟通协调，以及在相关规范上达成共识，提升相关环节的工作效率和系统的可维护性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuliuzai/p/13796453.html</dc:identifier>
</item>
<item>
<title>python算法常用技巧与内置库 - 落阳呀</title>
<link>http://www.cnblogs.com/hsluoyang/p/13829464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hsluoyang/p/13829464.html</guid>
<description>&lt;p&gt;近些年随着python的越来越火，python也渐渐成为了很多程序员的喜爱。许多程序员已经开始使用python作为第一语言来刷题。&lt;/p&gt;
&lt;p&gt;最近我在用python刷题的时候想去找点python的刷题常用库api和刷题技巧来看看。类似于C++的STL库文档一样，但是很可惜并没有找到，于是决定结合自己的刷题经验和上网搜索做一份文档出来，供自己和大家观看查阅。&lt;/p&gt;
&lt;h2 id=&quot;1输入输出&quot;&gt;1.输入输出:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1 第一行给定两个值n,m，用空格分割，第一个n决定接下来有n行的输入，m决定每一行有多少个数字，m个数字均用空格分隔.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决办法：python的input函数接收到的输入默认都是字符串，所以我们使用 &lt;strong&gt;字符串切割&lt;/strong&gt;、&lt;strong&gt;强制类型转换&lt;/strong&gt;、&lt;strong&gt;列表生成器&lt;/strong&gt;就可以完美解决输入问题。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;# 接收两个值，使用n,m分别接收列表中的两个值
n, m  = [int(x) for x in input().split()]

# 构造输入列表的列表
num_list = []

for i in range(n):
        # python可以不用在意m的值，将所有数值接收进来然后使用len判断长度
        tmp_list = [int(x) for x in input().split()]
        num_list.append(tmp_list)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，若是用逗号(,)分隔的话，split函数中传入相同的值就行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 输出一行数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于python的print函数默认利用换行作为结束符，所以我们需要将它修改成我们需要的间隔，代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;for i in range(10):
        print(i, end=' ')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;end是print函数中的一个参数，决定输出的结束字符，这里修改成空格代表输出一行数字，用空格间隔，其它字符可以自行修改。&lt;/p&gt;
&lt;h2 id=&quot;2空列表生成，字符串修改，列表遍历&quot;&gt;2.空列表生成，字符串修改，列表遍历&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt; 代码编写过程中，有时候会需要一个带有长度的，有初始值的空列表，生成方式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;# 1. 用乘法生成一个初始值为False的长度为100的一维列表
visited = [False] * 100

# 2. 利用列表生成器生成一个n*m的二维的初始值为0的列表
visited = [[0 for i in range(m)] for j in range(n)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2&lt;/strong&gt; 在python当中字符串是无法原地修改的，如果每次修改都生成一个新字符串，那么对修改次数很多且字符串很当的情况，开销是很大的。所以&lt;strong&gt;一般是把字符串转为列表进行修改最后再转回来&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;string = 'I love to eat chicken'
# 将字符串转换成列表
string_list = list(string)

# .......对字符串列表进行修改
# Code

# 将字符串列表重新拼接成字符串
#string = ''.join(string_list)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.3&lt;/strong&gt; python中列表遍历有许多种不同的方式，最直接的办法是直接对列表进行迭代遍历，但是因为我们往往是基于索引对数组进行操作且需要修改数组的值，所以更推荐用以下代码中的第二三中办法:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;num_list = [i for i in range(10)]

# 1. 直接迭代列表
for item in num_list:
        # Code
        pass

# 2. 通过索引进行迭代
for i in range(len(num_list)):
        print(num_list[i])

# 3. 通过enumerate函数进行迭代
for index, value in enumerate(num_list):
        # index为当前元素的索引，value为当前元素的值
        print(index, value)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-collections库的使用&quot;&gt;3. collections库的使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.1 deque队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;deque 是python中的队列（FIFO先进先出），队列在进行队首弹出的时候会比list要快。&lt;/p&gt;
&lt;p&gt;尤其在使用BFS（深度优先搜索）的时候，队列是必须要使用到的。部分deque使用代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

# 初始化一个最大长度为3的队列
d = deque([1,2,3], maxlen=3)

# 因为初始化队列最大长度为3，再添加元素会把队头元素挤出
d.append(4)

# 初始化一个不限制长度的队列
d = deque()

# 添加元素到队尾部
d.append(1)
d.append(2)
d.append(3)

# 将队首的元素弹出返回
print(d.popleft())

# 弹出队尾元素并返回值
print(d.pop())

# 在队首插入元素
d.appendleft(0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2 Counter计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Counter&lt;/code&gt; 是一个计数器，可以对一个序列计数，计算序列中某个元素出现的数量。&lt;/p&gt;
&lt;p&gt;以下是示例代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;import collections

# 一共有三种初始方法
# 1. 传入一个序列
print(collections.Counter(['a', 'b', 'c', 'a', 'b', 'b']))
# 2.传入一个字典
print(collections.Counter({'a':2, 'b':3, 'c':1}))
# 3.直接利用=传参
print(collections.Counter(a=2, b=3, c=1))

# 也可以无参数构造，利用update函数更新
c = collections.Counter()
print('Initial :', c)
# Initial: Counter()


c.update('abcdaab')
print('Sequence:', c)
# Sequence: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})


c.update({'a':1, 'd':5})
print('Dict:', c)
# Dict: Counter({'d': 6, 'a': 4, 'b': 2, 'c': 1})

# 可以通过访问字典的访问方式访问Counter对象
for letter in 'abcde':
    print('%s : %d' % (letter, c[letter]))

# elements()方法可以返回一个包含所有Counter数据的迭代器
c = collections.Counter('extremely')
c['z'] = 0
print(list(c.elements()))
# ['e', 'e', 'e', 'm', 'l', 'r', 't', 'y', 'x']

# most_common()返回前n个最多的数据
c=collections.Counter('aassdddffff')
for letter, count in c.most_common(2):
    print('%s: %d' % (letter, count))
# f: 4
# d: 3

# Counter对象可以进行加减交并，直接使用运算符 +、-、&amp;amp;、|
# +会将两个字典中相同字符的出现次数相加，-会给出第一个Counter相对于第二个的差集。交集给出两个计数器当中都有的元素，且计数被赋值为较小的那个，并集为两个计数器的元素出现最多的那个。

c1 = collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])
c2 = collections.Counter('alphabet')

print ('C1:', c1)
print ('C2:', c2)

print ('\nCombined counts:')
print (c1 + c2)

print ('\nSubtraction:')
print (c1 - c2)

print ('\nIntersection (taking positive minimums):')
print (c1 &amp;amp; c2)

print ('\nUnion (taking maximums):')
print (c1 | c2)

# 以下为输出：
C1: Counter({'b': 3, 'a': 2, 'c': 1})
C2: Counter({'a': 2, 'l': 1, 'p': 1, 'h': 1, 'b': 1, 'e': 1, 't': 1})

Combined counts:
Counter({'a': 4, 'b': 4, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})

Subtraction:
Counter({'b': 2, 'c': 1})

Intersection (taking positive minimums):
Counter({'a': 2, 'b': 1})

Union (taking maximums):
Counter({'b': 3, 'a': 2, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.3 defaultdict——带有默认值的字典&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下创建的字典dict是不含有默认值的，即若是字典中不包含a这个key，调用dct{a}的话就会报错。&lt;/p&gt;
&lt;p&gt;在进行算法设计和数据结构设计的时候我们希望任意给定一个key都能从字典中取出值来，哪怕只是一个默认值，这个时候我们就需要用到&lt;code&gt;defaultdict&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如在用字典表示图中一个节点的相连节点的时候，我们希望将这个节点作为一个key，然后与它相连的节点组成一个列表作为它的value，这个时候我们就可以使用defaultdict(list)来创建一个默认值为列表的字典。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;# list的默认值为空列表
list_dict = collections.defaultdict(list)
# int的默认值为0
int_dict = collections.defaultdict(int)

print(list_dict['a'])
print(int_dict['a'])

# 输出：[]
# 输出：0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.4 小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;collection中常被用来写算法和数据结构的就是这几个，其它比如排序字典和命名元组很少会用上。&lt;/p&gt;
&lt;h2 id=&quot;4排序&quot;&gt;4.排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;4.1 对列表排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对列表排序有两种方法，一种是使用列表内置的sort函数，sort函数直接在列表原地修改，无返回值，可以通过参数key自定义比较的key和比较函数。&lt;/p&gt;
&lt;p&gt;第二种就是使用python的sorted函数，这个函数自由度比较高，可以自己设定比较函数和比较的key，返回一个新的列表。&lt;/p&gt;
&lt;p&gt;如果需要自定义比较的函数，需要从库&lt;code&gt;functools&lt;/code&gt;导入函数&lt;code&gt;cmp_to_key&lt;/code&gt;函数，将比较函数转为key，使用代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;def custom_sort(x,y):
    if x&amp;gt;y:
        # 返回-1代表需要排在前面
        return -1
    if x&amp;lt;y:
        # 返回1代表需要排在后面
        return 1
    return 0


lst = [i for i in range(10, -1, -1)]
print(lst)

lst.sort()
print(lst)

print(sorted(lst, key=cmp_to_key(custom_sort)))

# 输出如下：
# [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.2 对字典/元组列表排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若是需要对字典（将字典利用&lt;code&gt;item&lt;/code&gt;函数转化成元组列表）或者元组列表这种每一个item有两个值的序列进行排序，这个时候就需要利用sorted函数中的key来决定取哪个值排序。代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;# 利用字符串创建计数器字典
d = dict(collections.Counter('Hello World'))
print(d)
# 排序
print(sorted(d.items(), key=lambda x: x[1], reverse=True))

# 输出如下：
# {'H': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'W': 1, 'r': 1, 'd': 1}
# [('l', 3), ('o', 2), ('H', 1), ('e', 1), (' ', 1), ('W', 1), ('r', 1), ('d', 1)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5排列组合&quot;&gt;5.排列组合&lt;/h2&gt;
&lt;p&gt;python内置的模块itertools中集成了一些与迭代有关的函数，其中就有排列组合函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1 排列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;排列函数&lt;code&gt;permutations&lt;/code&gt;接收一个列表，返回这个列表内所有元素的全排列列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations
print(list(permutations([1,2,3])))

# 输出如下：
# [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.2 组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组合函数&lt;code&gt;combinations&lt;/code&gt;接收两个参数，第一个为一个需要进行组合的列表，第二个参数为一个正整数，代表从列表中抽取多少个元素进行组合，返回一个组合列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations
print(list(combinations([1,2,3],2)))

# 输出如下：
# [(1, 2), (1, 3), (2, 3)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6小技巧&quot;&gt;6.小技巧&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;6.1 在python中分了可变类型和不可变类型，当函数传参的时候：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若是不可变类型如字符串，则传递参数的时候会深拷贝一份，在新的数据上修改并不改变原数据&lt;/li&gt;
&lt;li&gt;若是可变类型如列表，则传递参数的时候传递的是引用，属于浅拷贝，在函数中对新列表进行操作会影响到原来的列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若是确实需要传递可变类型进入函数，则可以在函数内部第一行进行一次深拷贝如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;def test(num_list:list):
        # 进行深拷贝
        num_list = num_list[:]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.2 当删除列表中的元素的时候，列表后面的元素会自动往前移动，导致出错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，列表为&lt;code&gt;[1,2,3,4,5,6]&lt;/code&gt;，想要删除列表中的偶数，如果直接找到一个偶数然后利用其索引删除，如下代码所示（错误示范），那么很抱歉，出问题了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;# 此处为错误示范！！！！！！！！
lst = [1, 2, 3, 4, 5, 6]
for i in range(len(lst)):
    if lst[i] % 2 == 0:
        lst.pop(i)

print(lst)

# 上面这段代码没有输出，因为报索引越界错误了。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码才是正确示范：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python3&quot;&gt;lst = [1, 2, 3, 4, 5, 6]
lst = [i for i in lst if i % 2 != 0]

print(lst)

# 输出如下：
# [1, 3, 5]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是需要更复杂的筛选手段，可以在&lt;code&gt;if i%2 !=0&lt;/code&gt;那里更改成一个函数判断，函数内部就实现筛选方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.3 访问字典元素要使用get方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前文说过，普通的dict字典是没有默认值的，所以这个时候如果直接利用中括号放置key来查找value的话是有可能会报错的。&lt;/p&gt;
&lt;p&gt;那么为了避免这种情况，在利用字典的key来取value的时候，需要利用字典的&lt;code&gt;get&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;函数的第一个参数为key，第二个参数为可选（默认为None），当字典中找不到传入的key的时候，会返回第二个参数所赋的值。&lt;/p&gt;
&lt;h2 id=&quot;7小结&quot;&gt;7.小结&lt;/h2&gt;
&lt;p&gt;以上是本人在使用python刷题的时候作的一些总结，若有不到位的地方请指出。&lt;/p&gt;
&lt;p&gt;本文旨在为自己做一个文档，同时也为大家提供一些便利。&lt;/p&gt;
&lt;p&gt;关注我的公众号【程序小员】，收货一大波福利知识。&lt;/p&gt;
&lt;p&gt;我是落阳，谢谢你的到访。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Oct 2020 16:01:00 +0000</pubDate>
<dc:creator>落阳呀</dc:creator>
<og:description>python算法常用技巧与内置库 近些年随着python的越来越火，python也渐渐成为了很多程序员的喜爱。许多程序员已经开始使用python作为第一语言来刷题。 最近我在用python刷题的时候想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hsluoyang/p/13829464.html</dc:identifier>
</item>
<item>
<title>Android HandlerThread 详解 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/13828497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/13828497.html</guid>
<description>&lt;div readability=&quot;19.5&quot;&gt;

&lt;p&gt;&lt;strong&gt;HandlerThread&lt;/strong&gt; 相信大家都比较熟悉了，从名字上看是一个带有 Handler 消息循环机制的一个线程，比一般的线程多了消息循环的机制，可以说是 Handler + Thread 的结合，从源码上看也是如此的设计，一般情况下如果需要子线程和主线程之间相互交互，可以用 HandlerThread 来设计，这比单纯的 Thread 要方便，而且更容易管理，因为大家都知道Thread 的生命周期在一些情况下是不可控制的，比如直接 new Thread().start() 这种方式在项目中是不推荐使用的，实际上 Android 的源码中也有很多地方用到了 HandlerThread，下面我将分析一下 HandlerThread 用法以及源码解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例对象，参数为线程名字&lt;/span&gt;
HandlerThread handlerThread = &lt;span&gt;new&lt;/span&gt; HandlerThread(&quot;handlerThread&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;handlerThread.start();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数为 HandlerThread 内部的一个 looper&lt;/span&gt;
    Handler handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(handlerThread.getLooper()) {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(Message msg) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.handleMessage(msg);
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这个使用的顺序是不能更改的！！！，因为如果不先让子线程 start 起来，那么创建主线程的 handler 的参数 getLooper 是获取不到的，这一点可以看源码就清楚。&lt;/p&gt;

这里模拟在子线程下载东西，然后和主线程之间进行通信。主线程知道了下载开始和下载结束的时间，也就能及时改变界面 UI。&lt;/div&gt;
&lt;div readability=&quot;41&quot;&gt;首先是 &lt;code&gt;DownloadThread &lt;/code&gt;类，继承于 &lt;code&gt;HandlerThread&lt;/code&gt;，用于下载。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DownloadThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HandlerThread{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAG = &quot;DownloadThread&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TYPE_START = 2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知主线程任务开始&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TYPE_FINISHED = 3;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知主线程任务结束&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; Handler mUIHandler;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程的Handler&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DownloadThread(String name) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * 执行初始化任务
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onLooperPrepared() {
        Log.e(TAG, &lt;/span&gt;&quot;onLooperPrepared: 1.Download线程开始准备&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onLooperPrepared();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入主线程Handler&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUIHandler(Handler UIhandler) {
        mUIHandler &lt;/span&gt;=&lt;span&gt; UIhandler;
        Log.e(TAG, &lt;/span&gt;&quot;setUIHandler: 2.主线程的handler传入到Download线程&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Download线程开始下载&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startDownload() {
        Log.e(TAG, &lt;/span&gt;&quot;startDownload: 3.通知主线程,此时Download线程开始下载&quot;&lt;span&gt;);
        mUIHandler.sendEmptyMessage(TYPE_START);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟下载&lt;/span&gt;
        Log.e(TAG, &quot;startDownload: 5.Download线程下载中...&quot;&lt;span&gt;);
        SystemClock.sleep(&lt;/span&gt;2000&lt;span&gt;);

        Log.e(TAG, &lt;/span&gt;&quot;startDownload: 6.通知主线程,此时Download线程下载完成&quot;&lt;span&gt;);
        mUIHandler.sendEmptyMessage(TYPE_FINISHED);
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是 &lt;code&gt;MainActivity &lt;/code&gt;部分，UI 和处理消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAG = &quot;MainActivity&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DownloadThread mHandlerThread;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Handler mUIhandler;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程的Handler&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化，参数为线程的名字&lt;/span&gt;
        mHandlerThread = &lt;span&gt;new&lt;/span&gt; DownloadThread(&quot;mHandlerThread&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用start方法启动线程&lt;/span&gt;
&lt;span&gt;        mHandlerThread.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化Handler，传递mHandlerThread内部的一个looper&lt;/span&gt;
        mUIhandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(mHandlerThread.getLooper()) {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(Message msg) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断mHandlerThread里传来的msg，根据msg进行主页面的UI更改&lt;/span&gt;
                &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (msg.what) {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DownloadThread.TYPE_START:
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是在这里更改UI哦，只是说在这个时间，你可以去做更改UI这件事情，改UI还是得在主线程。&lt;/span&gt;
                        Log.e(TAG, &quot;4.主线程知道Download线程开始下载了...这时候可以更改主界面UI&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DownloadThread.TYPE_FINISHED:
                        Log.e(TAG, &lt;/span&gt;&quot;7.主线程知道Download线程下载完成了...这时候可以更改主界面UI，收工&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.handleMessage(msg);
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程注入主线程的mUIhandler，可以在子线程执行任务的时候，随时发送消息回来主线程&lt;/span&gt;
&lt;span&gt;        mHandlerThread.setUIHandler(mUIhandler);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程开始下载&lt;/span&gt;
&lt;span&gt;        mHandlerThread.startDownload();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有2种退出方式&lt;/span&gt;
&lt;span&gt;        mHandlerThread.quit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mHandlerThread.quitSafely(); 需要API&amp;gt;=18&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDestroy();
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行的Log日志如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181012195520923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzQxODI0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt; &lt;/p&gt;

&lt;p class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;先来看下构造函数相关的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;int&lt;/span&gt; mPriority;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;优先级&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; mTid = -1&lt;span&gt;;
    Looper mLooper;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自带的Looper&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; @Nullable Handler mHandler;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HandlerThread(String name) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        mPriority &lt;/span&gt;=&lt;span&gt; Process.THREAD_PRIORITY_DEFAULT;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a HandlerThread.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; priority The priority to run the thread at. The value supplied must be from 
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; android.os.Process} and not from java.lang.Thread.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HandlerThread(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; priority) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        mPriority &lt;/span&gt;=&lt;span&gt; priority;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;p&gt;这里有两个构造方法，一个 &lt;code&gt;HandlerThread(String name)&lt;/code&gt;，一个 &lt;code&gt;HandlerThread(String name, int priority)&lt;/code&gt;，我们可以自己设定线程的名字以及优先级。注意！是 Process 里的优先级而不是Thread 的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Call back method that can be explicitly overridden if needed to execute some
     * setup before Looper loops.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onLooperPrepared() {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        mTid &lt;/span&gt;=&lt;span&gt; Process.myTid();
        Looper.prepare();
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            mLooper &lt;/span&gt;=&lt;span&gt; Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid &lt;/span&gt;= -1&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;34&quot;&gt;
&lt;p&gt;这里面有一个方法 onLooperPrepared()，在实际中，我们可以重写这个方法做一些初始化的操作，这个 run() 是重点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;run &lt;/code&gt;方法中首先获取线程 &lt;code&gt;id&lt;/code&gt;,然后就调用了 &lt;code&gt;Looper.prepare &lt;/code&gt;方法创建一个 &lt;code&gt;Looper,&lt;/code&gt;接着调用了 &lt;code&gt;Looper.myLooper &lt;/code&gt;方法获取到了当前线程的 &lt;code&gt;Looper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着通过 &lt;code&gt;notifyAll &lt;/code&gt;通知等带唤醒，这里的等待是在 &lt;code&gt;HandlerThread &lt;/code&gt;的 &lt;code&gt;getLooper &lt;/code&gt;方法里调用的 &lt;code&gt;wait &lt;/code&gt;方法，&lt;code&gt;getLooper &lt;/code&gt;方法是为了获取该 &lt;code&gt;HandlerThread &lt;/code&gt;中的 &lt;code&gt;Looper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果在没调用 &lt;code&gt;HandlerThread &lt;/code&gt;的 &lt;code&gt;start &lt;/code&gt;方法开启线程前就调用 &lt;code&gt;getLooper &lt;/code&gt;方法就通过 &lt;code&gt;wait &lt;/code&gt;方法暂时先进入等待，等到 &lt;code&gt;run &lt;/code&gt;方法运行后再进行唤醒。唤醒之后 &lt;code&gt;run &lt;/code&gt;方法中继续设置了构造函数中传入的优先级，接着调用了&lt;code&gt;onLooperPrepared &lt;/code&gt;方法，该方法是个空实现，该方法是为了在 &lt;code&gt;Looper &lt;/code&gt;开启轮询之前如果要进行某些设置，可以复写该方法。&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;Looper.loop&lt;/code&gt;开启轮询。退出的时候，将 mTid  = -1；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Looper getLooper() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAlive()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the thread has been started, wait until the looper has been created.&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (isAlive() &amp;amp;&amp;amp; mLooper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    wait();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mLooper;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个方法是获取当前的 Looper，可以看到如果没有获取的时候就一直等待直到获取，而前面也提到了获取到了就唤醒了所有的线程，看来这是线程的等待-唤醒机制应用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Handler getThreadHandler() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(getLooper());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mHandler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是获取 HandlerThread 绑定的 Looper 线程的 Handler &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; quit() {
        Looper looper &lt;/span&gt;=&lt;span&gt; getLooper();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (looper != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            looper.quit();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    
    
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; quitSafely() {
        Looper looper &lt;/span&gt;=&lt;span&gt; getLooper();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (looper != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            looper.quitSafely();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这两个方法去退出线程的 Looper 循环，那么这两个方法有什么区别呢,实际上都是调用了 MessageQueue 的 quit() 方法，源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; quit(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; safe) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mQuitAllowed) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Main thread not allowed to quit.&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mQuitting) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            mQuitting &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (safe) {
                removeAllFutureMessagesLocked();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                removeAllMessagesLocked();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We can assume mPtr != 0 because mQuitting was previously false.&lt;/span&gt;
&lt;span&gt;            nativeWake(mPtr);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;可以看到: 当我们调用 quit 方法的时候，实际上执行了 MessageQueue 中的 removeAllMessagesLocked 方法，该方法的作用是把 MessageQueue 消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过 sendMessageDelayed 或通过 postDelayed 等方法发送的需要延迟执行的消息，只要不是立即执行的消息都是延迟消息）还是非延迟消息。&lt;/p&gt;
&lt;p&gt;而 quitSafely 方法时，实际上执行了 MessageQueue 中的 removeAllFutureMessagesLocked 方法，通过名字就可以看出，该方法只会清空 MessageQueue 消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让 Handler 去处理，quitSafely 相比于 quit 方法安全之处在于清空消息之前会派发所有的非延迟消息,一句话，就是清除未来需要执行的消息。&lt;/p&gt;
&lt;p&gt;这两个方法有一个共同的特点就是：Looper 不再接收新的消息了,消息循环就此结束，此时通过 Handler 发送的消息也不会在放入消息杜队列了，因为消息队列已经退出了。应用这2个方法的时候需要注意的是：quit 方法从 API 1 就开始存在了，比较早，而 quitSafely 直到 API 18 才添加进来.&lt;/p&gt;
&lt;/div&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果经常要开启线程，接着又是销毁线程，这是很耗性能的，&lt;code&gt;HandlerThread &lt;/code&gt;很好的解决了这个问题；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;HandlerThread &lt;/code&gt;由于异步操作是放在 &lt;code&gt;Handler &lt;/code&gt;的消息队列中的，所以是串行的，但只适合并发量较少的耗时操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 16 Oct 2020 15:45:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概述 HandlerThread 相信大家都比较熟悉了，从名字上看是一个带有 Handler 消息循环机制的一个线程，比一般的线程多了消息循环的机制，可以说是 Handler + Thread 的结合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/13828497.html</dc:identifier>
</item>
<item>
<title>Redis 字典结构细谈 - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13827793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13827793.html</guid>
<description>&lt;p&gt;Redis 字典底层基于哈希表实现。&lt;/p&gt;
&lt;h2&gt;一、&lt;span&gt;哈希表结构&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、dictht&lt;span&gt;：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;typedef struct dictht {&lt;/p&gt;
&lt;p&gt;  dictEntry **table; //&lt;span&gt;哈希表数组，存储具体的键值对元素，对象类型&lt;/span&gt; &lt;span&gt;dictEntry&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  unsigned long size; //&lt;span&gt;哈希表容量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  unsigned long sizemask; //&lt;span&gt;哈希表大小掩码，计算索引使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  unsigned long used; //&lt;span&gt;已使用容量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;} dictht&lt;/p&gt;
&lt;h3&gt;2、示例数据：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016171330753-108589340.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;309&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、&lt;span&gt;哈希表节点&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、dictEntry&lt;span&gt;：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;typedef struct dictEntry {&lt;/p&gt;
&lt;p&gt;  void *key; //&lt;span&gt;键值对&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  union{  //&lt;span&gt;键值对&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;三种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    void *val;&lt;/p&gt;
&lt;p&gt;    uint64_tu64;&lt;/p&gt;
&lt;p&gt;    int64_ts64;&lt;/p&gt;
&lt;p&gt;  } v;&lt;/p&gt;
&lt;p&gt;  struct dictEntry *next;  //&lt;span&gt;下一个节点指针&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;} dictEntry;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;next &lt;span&gt;为指向下一个节点的指针，是我们熟悉的链表节点结构，单向链表，用于处理键哈希冲突问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同哈希值的键的键值对会以链表的形式存在同一位置。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、示例数据：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016231508237-829339722.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;353&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、&lt;/span&gt;Redis 字典&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、dict&lt;span&gt;：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;typedef struct dict{&lt;/p&gt;
&lt;p&gt;  dictType *type; //&lt;span&gt;类型特定函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  void *privdata; //&lt;span&gt;私有数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  dictht ht[2]; //&lt;span&gt;哈希表数组，类型为&lt;/span&gt;&lt;span&gt;dictht&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ht[0]&lt;/span&gt;&lt;span&gt;为实际存储数据使用，&lt;/span&gt;&lt;span&gt;ht[1]&lt;/span&gt; &lt;span&gt;为&lt;/span&gt;&lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;时使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  int rehashidx; //rehash&lt;span&gt;进度标志，&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; &lt;span&gt;代表当前不在&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;} dict&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、示例数据：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016171554653-727067598.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;503&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、&lt;span&gt;添加元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;向字典中添加元素主要涉及一下几步操作：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、&lt;span&gt;计算键值对键的哈希值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;hash&lt;span&gt;：&lt;/span&gt;&lt;span&gt;dict-&amp;gt;type-&amp;gt;hashFunction(key)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;dictType&lt;span&gt;内部的哈希函数得到键哈希值&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、&lt;span&gt;计算需要放入的位置索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;index&lt;span&gt;：&lt;/span&gt;&lt;span&gt;hash&amp;amp;dict-&amp;gt;ht[0].sizemask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用上一步计算得到的哈希值与哈希表的&lt;/span&gt;sizemask&lt;span&gt;属性进行与操作得到需要放入的位置索引值&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、&lt;span&gt;键冲突解决&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;没有完美的哈希函数，&lt;/span&gt;&lt;span&gt;哈希冲突往往无法避免，当多个键被所引导同一个位置时，这种现象，我们称之为键冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决间冲突，&lt;/span&gt;Redis &lt;span&gt;采用链地址法，也即将冲突的键值对组成一条链条放到同一个哈希位置上。上面第二节我们介绍过&lt;/span&gt; &lt;span&gt;dictEntry&lt;/span&gt;&lt;span&gt;的结构，其中包含一个指向另一个节点的指针&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要说明的一点是，冲突节点插入时，是插入到链表的头部，这样只需要执行操作一次操作即可，也即时间复杂度为&lt;/span&gt;O(1)&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图：（&lt;/span&gt;k2&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;）与（&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;）发生冲突，直接将（&lt;/span&gt;k2&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;插入到链表头部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016231608728-458311171.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;414&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、rehash&lt;/h2&gt;
&lt;p&gt;rehash&lt;span&gt;过程是在重新规划哈希表占用空间时发生的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负载因子&lt;/span&gt; load_factor&lt;span&gt;：已保存节点数量（&lt;/span&gt;&lt;span&gt;dict.ht[0].used&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;哈希表容量&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;dict.ht[0].size&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负载因子用以表名当前哈希表的使用状态，它需要保持在一个合理的范围，以保障资源的最优利用。通常需要适时的对哈希表进行扩展或者收缩来对负载因子进行维护，而这个过程，我们称之为&lt;/span&gt; rehash&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里涉及到一个问题，就是什么时候需要进行伸缩维护？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、&lt;span&gt;扩展时机：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当前无&lt;/span&gt;bgsave&lt;span&gt;及&lt;/span&gt;&lt;span&gt;bgrewriteaop&lt;/span&gt;&lt;span&gt;操作，&lt;/span&gt;&lt;span&gt;load_factor &amp;gt;= 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前&lt;/span&gt;&lt;span&gt;存在&lt;/span&gt;bgsave&lt;span&gt;及&lt;/span&gt;&lt;span&gt;bgrewriteaop&lt;/span&gt;&lt;span&gt;操作，&lt;/span&gt;&lt;span&gt;load_factor &amp;gt;=&lt;/span&gt; 5&lt;/p&gt;
&lt;p&gt;Redis&lt;span&gt;服务器通过&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;子进程形式执行&lt;/span&gt;bgsave&lt;span&gt;及&lt;/span&gt;&lt;span&gt;bgrewriteaop&lt;/span&gt;&lt;span&gt;操作，此时整个服务的资源耗费较大，为了避免可能发生的&lt;/span&gt;rehash&lt;span&gt;带来额外的资源压力，此期间，服务器会调高触发执行扩展操作的负载因子界限。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、&lt;span&gt;收缩时机：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;load_factor &amp;lt; 0.1&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、rehash &lt;span&gt;基本操作：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;a) 为&lt;/span&gt;dict.ht[1]&lt;span&gt;分配&lt;/span&gt;&lt;span&gt;空间：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空间大小计算如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展：最小&lt;/span&gt;n&lt;span&gt;满足&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;sup&gt;n&lt;/sup&gt; &amp;gt;= dict.ht[0].used * 2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收缩：&lt;/span&gt;&lt;span&gt;最小&lt;/span&gt;n&lt;span&gt;满足&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;sup&gt;n&lt;/sup&gt; &amp;gt;= dict.ht[0].used&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;ht[0].used = 3&lt;span&gt;，假定无&lt;/span&gt;&lt;span&gt;bg&lt;/span&gt;&lt;span&gt;相关任务，则&lt;/span&gt;&lt;span&gt;h[1]&lt;/span&gt;&lt;span&gt;大小需要计算：&lt;/span&gt;2&lt;sup&gt;n&lt;/sup&gt; &amp;gt;= 3 * 2 = 6&lt;/p&gt;
&lt;p&gt;n = 3&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ht[1].size =&lt;/span&gt; 2&lt;sup&gt;3&lt;/sup&gt; = 8&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016231709177-1977842781.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;654&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b) rehash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;dict.ht[0] &lt;span&gt;中的元素，依据&lt;/span&gt;dict.ht[1]&lt;span&gt;特性（&lt;/span&gt;sizemask&lt;span&gt;）重新计算索引值，并放置到&lt;/span&gt;dict.ht[1]&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016231811553-42881286.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;827&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) &lt;span&gt;当所有元素迁移完毕，释放&lt;/span&gt;dict.ht[0]&lt;span&gt;，并将&lt;/span&gt;dict.ht[1]&lt;span&gt;设置为&lt;/span&gt;dict.ht[0]&lt;span&gt;，重新在&lt;/span&gt;dict.ht[1]&lt;span&gt;上创建空的哈希表。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202010/603942-20201016232021682-1719061208.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;824&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、&lt;span&gt;渐进式&lt;/span&gt;rehash&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所谓渐进式，是针对大数据量字典数据。直接一次性的执行&lt;/span&gt;rehash&lt;span&gt;会导致服务资源的集中占用，影响正常的服务响应。因此需要进行分而治之。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里会用到上面我们介绍的&lt;/span&gt;dict&lt;span&gt;字典结构中的&lt;/span&gt; &lt;span&gt;rehashidx&lt;/span&gt;&lt;span&gt;属性，用以标识当前&lt;/span&gt;&lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;进度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先将&lt;/span&gt;rehashidx&lt;span&gt;置&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，标示&lt;/span&gt;&lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;开始，每次&lt;/span&gt;&lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;一个元素，&lt;/span&gt;&lt;span&gt;rehashidx&lt;/span&gt;&lt;span&gt;值增加&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，当最终所有元素&lt;/span&gt;&lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;完成，将&lt;/span&gt;&lt;span&gt;rehashidx&lt;/span&gt;&lt;span&gt;置&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要说明下&lt;/span&gt;rehash&lt;span&gt;中对正常的服务请求的处理：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、&lt;span&gt;删除、查找、更新：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;会涉及到两个哈希表（&lt;/span&gt;ht[0]&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ht[1]&lt;/span&gt;&lt;span&gt;）操作，如查找元素，首先尝试在&lt;/span&gt;&lt;span&gt;ht[0]&lt;/span&gt;&lt;span&gt;上查找，找不到，则继续在&lt;/span&gt;&lt;span&gt;h[1]&lt;/span&gt;&lt;span&gt;上查找。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、&lt;span&gt;添加&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;添加元素只会在&lt;/span&gt;h[1]&lt;span&gt;上操作，&lt;/span&gt;&lt;span&gt;h[0]&lt;/span&gt;&lt;span&gt;上只减不增。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Oct 2020 15:30:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>Redis 字典底层基于哈希表实现。 一、哈希表结构 1、dictht： typedef struct dictht { dictEntry **table; //哈希表数组，存储具体的键值对元素，对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/13827793.html</dc:identifier>
</item>
<item>
<title>Mysql索引（一篇就够le） - 一寸HUI</title>
<link>http://www.cnblogs.com/zsql/p/13808417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zsql/p/13808417.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　我想很多人对mysql的认知可能就是CRUD（代表创建(Create)、更新(Update)、读取(Retrieve)和删除(Delete)操作），也不敢说自己会用和熟悉mysql，当然我就是其中一个，虽然知道mysql有很多东西，但是一直都没有深入的了解和掌握，最近想着好好的把Mysql原理学习下，这篇就是开胃菜吧，以后的慢慢道来。本篇文章内容主是&lt;strong&gt;基于mysql的InnoDB存储引擎&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Mysql索引介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)，而不是在select的字段中，实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.1、索引的类别&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先去官网文档看看支持的索引类型，索引的实现方式如下图所示：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&lt;/a&gt;（官网）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201013142145162-80980408.png&quot; alt=&quot;&quot; width=&quot;973&quot; height=&quot;940&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  由于本文是基于mysql的InnoDB存储引擎，索引我们主要看第一个表格，其他的表格可以自行的观看，都不难，从表格我们可以看出来，InnoDB存储引擎索引只支持BTREE类型的索引，索引的类别有Primary Key，Unique，Key，FULLTEXT和SPATIAL。当然也有其他的分法，按照索引列的数量分为单列索引和组合索引。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Primary Key（聚集索引）&lt;/strong&gt;：InnoDB存储引擎的表会存在主键（唯一非null），如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，否则InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id用来作为聚集索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;单列索引&lt;/strong&gt;：单列索引即一个索引只包含单个列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;组合索引&lt;/strong&gt;：组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时&lt;strong&gt;遵循最左前缀集合&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Unique（唯一索引）&lt;/strong&gt;：索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Key（普通索引）&lt;/strong&gt;：是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;FULLTEXT（全文索引）&lt;/strong&gt;：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;SPATIAL（空间索引）&lt;/strong&gt;：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列必须声明为NOT NULL&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这里在说一下组合索引的遵循最左前缀原则：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;order by使用索引最左前缀
&lt;/span&gt;-&lt;span&gt; order by a
&lt;/span&gt;-&lt;span&gt; order by a,b
&lt;/span&gt;-&lt;span&gt; order by a,b,c
&lt;/span&gt;-&lt;span&gt; order by a desc, b desc, c desc 

如果where使用索引的最左前缀定义为常量，则order by能使用索引
&lt;/span&gt;- where a=&lt;span&gt;const order by b,c
&lt;/span&gt;- where a=const and b=&lt;span&gt;const order by c
&lt;/span&gt;- where a=const and b &amp;gt;&lt;span&gt; const order by b,c

不能使用索引进行排序
&lt;/span&gt;- order by a , b desc ,c desc  --&lt;span&gt;排序不一致
&lt;/span&gt;- where d=const order by b,c   --&lt;span&gt;a丢失
&lt;/span&gt;- where a=const order by c     --&lt;span&gt;b丢失
&lt;/span&gt;- where a=const order by b,d   --&lt;span&gt;d不是索引的一部分
&lt;/span&gt;- where a &lt;span&gt;in&lt;/span&gt;(...) order by b,c --a属于范围查询&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建一个简单的表：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE my_test (
  `&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL AUTO_INCREMENT,
  `username` varchar(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `sex` varchar(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `address` varchar(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `birthday` datetime NOT NULL,
  `user_num` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) unique,
  PRIMARY KEY (`&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;`),
  index(username)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;show index from my_test;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201013152351112-945765542.png&quot; alt=&quot;&quot; width=&quot;982&quot; height=&quot;69&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  明明在建表的时候只创建了一个索引，查询出来的有三个，其实&lt;strong&gt;主键，唯一约束列，外键&lt;/strong&gt;这些都自动会生成索引，至于外键大家可以去尝试下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上表格中各个列的说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;table #表名称
non_unique  #如果索引不能包括重复词，为0，如果可以，则为1
key_name  #索引的名称
seq_in_index #索引中的列序号
column_name  #列名称
collation  #列以什么方式存储在索引中，在mysql中，有值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;（升序）或者NULL（无分类）
cardinality  #索引在唯一值的数据的估值，通过运行analyze table xxx_table;或者 myisamchk &lt;/span&gt;-&lt;span&gt;a 可以更新，技术根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没必要是精确的，基数越大，当进行联合所饮食，mysql使用该索引的机会越大。myisam中，该值是准确的，INNODB中该值数据是估算的，存在偏差
sub_part  #如果列只是部分的编入索引 则为被编入索引的字符的数目，如果整列被编入索引，则为NULL
packed  #指示关键词如何被压缩，如果没有被压缩，则为NULL
NULL   #如果列含有NULL，则含有YES，如果没有，则该列为NO
index_type  #用过的索引方法（BTREE,FULLTEXT,HASH,RTREE）
comment  #备注
index_comment  #为索引创建时提供了一个注释属性的索引的任何评论&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1.2、索引的创建原则&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;索引并非越多越好，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改的同时，索引也会进行调整和更新&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在WHERE子句中的列，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;二、索引的管理和使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.1、制造实验数据&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里的实验数据采用的是一个github的一个开源项目，具体的操作流程查看：&lt;a href=&quot;https://github.com/wuda0112/mysql-tester&quot;&gt;https://github.com/wuda0112/mysql-tester&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据制造完成后会有四个数据库：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014115907106-1189722124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   数据可以根据参数进行生成，很简单，根据步骤来就好了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2、explain使用说明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用实验数据我们进行explain的查询：explain SELECT store_id , count(1) from foundation_item.item  group by store_id limit 10;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014134811024-2084802065.png&quot; alt=&quot;&quot; width=&quot;970&quot; height=&quot;42&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   EXPLAIN语句的基本语法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;explain &lt;span&gt;select&lt;/span&gt; select_option&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;select_options是SELECT语句的查询选项，包括FROMWHERE子句等&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;: SELECT识别符。这是SELECT的查询序列号,表示查询中执行select子句或操作表的顺序,id相同，执行顺序从上到下,id不同，id值越大执行优先级越高
select_type：表示SELECT语句的类型。它可以是以下几种取值：
    SIMPLE:表示简单查询，其中不包括连接查询和子查询；
    PRIMARY:表示主查询，或者是最外层的查询语句，最外层查询为PRIMARY，也就是最后加载的就是PRIMARY；
    UNION:表示连接查询的第2个或后面的查询语句， 不依赖于外部查询的结果集
    DEPENDENT UNION:连接查询中的第2个或后面的SELECT语句，依赖于外面的查询；
    UNION RESULT:连接查询的结果；
    SUBQUERY:子查询中的第1个SELECT语句；不依赖于外部查询的结果集
    DEPENDENT SUBQUERY:子查询中的第1个SELECT，依赖于外面的查询；
    DERIVED:导出表的SELECT（FROM子句的子查询）,MySQL会递归执行这些子查询，把结果放在临时表里。
    DEPENDENT DERIVED:派生表依赖于另一个表
    MATERIALIZED:物化子查询
    UNCACHEABLE SUBQUERY:子查询，其结果无法缓存，必须针对外部查询的每一行重新进行评估
    UNCACHEABLE UNION:UNION中的第二个或随后的 &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; 查询，属于不可缓存的子查询
table:表示查询的表
partitions:查询将从中匹配记录的分区。该值适用NULL于未分区的表
type:表示表的连接类型
    system:该表是仅有一行的系统表。这是const连接类型的一个特例
    const: 数据表最多只有一个匹配行，它将在查询开始时被读取，并在余下的查询优化中作为常量对待。const表查询速度很快，因为只读取一次,const用于使用常数值比较PRIMARY KEY或UNIQUE索引的所有部分的场合。
    eq_ref:对于每个来自前面的表的行组合，从该表中读取一行,可以用于使用&lt;/span&gt;=&lt;span&gt;运算符进行比较的索引列 。比较值可以是常量，也可以是使用在此表之前读取的表中列的表达式
    ref:对于来自前面的表的任意行组合，将从该表中读取所有匹配的行，ref可以用于使用“＝”或“＜＝＞”操作符的带索引的列。
    fulltext:使用FULLTEXT 索引执行联接
    ref_or_null:这种连接类型类似于ref，但是除了MySQL还会额外搜索包含NULL值的行。此联接类型优化最常用于解析子查询
    index_merge:此联接类型指示使用索引合并优化。在这种情况下，key输出行中的列包含使用的索引列表，并key_len包含使用的索引 的最长键部分的列表
    unique_subquery:类型替换 以下形式的eq_ref某些 IN子查询,unique_subquery 只是一个索引查找函数，它完全替代了子查询以提高效率。
    index_subquery:连接类型类似于 unique_subquery。它代替IN子查询,但只适合子查询中的非唯一索引
    range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。当使用＝、＜＞、＞、＞＝、＜、＜＝、IS NULL、＜＝＞、BETWEEN或者IN操作符用常量比较关键字列时，类型为range
    index:该index联接类型是一样的 ALL，只是索引树被扫描。这发生两种方式：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;、如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，Extra列显示为 Using index，&lt;span&gt;2&lt;/span&gt;&lt;span&gt;、使用对索引的读取执行全表扫描，以按索引顺序查找数据行。 Uses index没有出现在 Extra列中。
    ALL:对于前面的表的任意行组合进行完整的表扫描    
possible_keys:指出MySQL能使用哪个索引在该表中找到行。若该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看它是否引用某些列或适合索引的列来提高查询性能。如果是这样，可以创建适合的索引来提高查询的性能。
kye:表示查询实际使用的索引，如果没有选择索引，该列的值是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX
key_len：表示MySQL选择的索引字段按字节计算的长度，若键是NULL，则长度为NULL。注意，通过key_len值可以确定MySQL将实际使用一个多列索引中的几个字段
ref：表示使用哪个列或常数与索引一起来查询记录。
rows：显示MySQL在表中进行查询时必须检查的行数。
Extra：表示MySQL在处理查询时的详细信息&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更详细说明见官网：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/explain-output.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/explain-output.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3、创建索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创建索引的语法（如下都是默认的innodb存储引擎）：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE [UNIQUE | FULLTEXT |&lt;span&gt; SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (key_part,...)
    [index_option]
    [algorithm_option &lt;/span&gt;|&lt;span&gt; lock_option] ...

key_part: {col_name [(length)] &lt;/span&gt;| (&lt;span&gt;expr&lt;/span&gt;)} [ASC |&lt;span&gt; DESC]

index_option: {
    KEY_BLOCK_SIZE [&lt;/span&gt;=&lt;span&gt;] value
  &lt;/span&gt;|&lt;span&gt; index_type
  &lt;/span&gt;|&lt;span&gt; WITH PARSER parser_name
  &lt;/span&gt;| COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  | {VISIBLE |&lt;span&gt; INVISIBLE}
  &lt;/span&gt;| ENGINE_ATTRIBUTE [=] &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
  | SECONDARY_ENGINE_ATTRIBUTE [=] &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

index_type:
    USING {BTREE &lt;/span&gt;|&lt;span&gt; HASH}
algorithm_option:
    ALGORITHM [&lt;/span&gt;=] {DEFAULT | INPLACE |&lt;span&gt; COPY}
lock_option:
    LOCK [&lt;/span&gt;=] {DEFAULT | NONE | SHARED | EXCLUSIVE}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以在创建的表的时候建立索引，也可以对创建好的表建立索引。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3.1、基于创建表时建立索引&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;CREATE TABLE创建表时，除了可以定义列的数据类型，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、创建普通索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.`user2` (
  `&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL AUTO_INCREMENT,
  `username` varchar(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `sex` varchar(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `address` varchar(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `birthday` datetime NOT NULL,
  PRIMARY KEY (`&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;`),
  index idx1(username)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;show index from test.`user2`;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014173317804-1874744950.png&quot; alt=&quot;&quot; width=&quot;983&quot; height=&quot;44&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt; 2、创建唯一索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.`user2` (
  `&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL AUTO_INCREMENT,
  `username` varchar(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `sex` varchar(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `address` varchar(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `birthday` datetime NOT NULL,
  `score_num` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL UNIQUE,
  PRIMARY KEY (`&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;`),
  unique index idx1(username)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;show index from test.`user2`;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014173652524-598003520.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;62&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   前面两个索引都是通过主键和唯一约束自动创建的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、创建组合索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：最左前缀原则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.`user2` (
  `&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL AUTO_INCREMENT,
  `username` varchar(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `sex` varchar(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `address` varchar(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `birthday` datetime NOT NULL,
  `score_num` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL UNIQUE,
  PRIMARY KEY (`&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;`),
  index idx1(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;,score_num,username)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014174159751-747608697.png&quot; alt=&quot;&quot; width=&quot;976&quot; height=&quot;84&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt; 4、创建全文索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FULLTEXT全文索引可以用于全文搜索，并且只为CHAR、VARCHAR和TEXT列创建索引。索引总是对整个列进行，不支持局部（前缀）索引&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.`user2` (
  `&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL AUTO_INCREMENT,
  `username` varchar(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `sex` varchar(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `address` varchar(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;) DEFAULT NULL,
  `birthday` datetime NOT NULL,
  `score_num` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;&lt;span&gt;) NOT NULL UNIQUE,
  PRIMARY KEY (`&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;`),
  fulltext index idx1(username)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014174615933-913498203.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;60&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、创建空间索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;create table test.test(
    position geometry not &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    spatial index idx1(position)
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;show index from test.test;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014174943946-169967325.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;38&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt; 6、创建前缀索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.t1 (
  col1 VARCHAR(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
  col2 VARCHAR(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
  INDEX (col1, col2(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;))
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014192737946-1486191239.png&quot; alt=&quot;&quot; width=&quot;974&quot; height=&quot;45&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  前缀索引的目的主要是减少字符串作为索引占用的空间，提高查询速度&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3.2、基于已创建好的表创建索引&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在已经存在的表中创建索引，可以使用ALTER TABLE语句或者CREATE INDEX语句创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、使用ALTER TABLE语句创建索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...) [ASC|DESC]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、使用CREATE INDEX创建索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON  table_name (col_name[length],...) [ASC|DESC]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.4、删除索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、使用ALTER TABLE删除索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE table_name DROP INDEX index_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE test.t1 (
  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT primary key,
  col1 VARCHAR(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
  col2 VARCHAR(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
  INDEX (col1, col2(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;))
);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014194900066-334451758.png&quot; alt=&quot;&quot; width=&quot;979&quot; height=&quot;60&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; alter table test.t1 drop index col1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;alter table test.t1 drop index PRIMARY;  #会报错：添加AUTO_INCREMENT约束字段的唯一索引不能被删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201014201722810-1292728715.png&quot; alt=&quot;&quot; width=&quot;984&quot; height=&quot;31&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt; 2、使用DROP INDEX语句删除索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP INDEX index_name ON table_name;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.5、聚集索引和二级索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、聚集索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、二级索引（辅助索引）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于辅助索引（Secondary Index），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.6、覆盖索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE TABLE `item` (
  `item_id` bigint(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) unsigned NOT NULL AUTO_INCREMENT,
  `store_id` bigint(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;) unsigned NOT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;所属店铺ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `type` tinyint(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;) unsigned NOT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品类型 . 不同类型的商品, 保存到各自不同的表中. 参考 https://learnwoo.com/woocommerce-different-product-types/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `state` tinyint(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;) unsigned NOT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `create_user_id` bigint(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) unsigned NOT NULL,
  `last_modify_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `last_modify_user_id` bigint(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) unsigned NOT NULL,
  `is_deleted` bigint(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;) unsigned NOT NULL DEFAULT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  PRIMARY KEY (`item_id`),
  KEY `fk_store_id` (`store_id`)
) ENGINE&lt;/span&gt;=InnoDB AUTO_INCREMENT=&lt;span&gt;332604631475558863&lt;/span&gt; DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;代表所有的物品，之前有把用户ID放进来，表示该物品所属的用户，但是考虑到如果有子账号的情况，物品难道属于这个子账号所属的用户吗？而且记录了创建人用户ID，考虑这两个因素，因此不设置用户ID列&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看：explain select store_id,create_time from item where store_id &amp;gt; 332604504321036698 ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015113435486-2071531099.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;43&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; 这里使用了全表扫描，没有走索引，然后我们把查询语句改为：explain select store_id from item where store_id &amp;gt; 332604504321036698 ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015113618355-718715004.png&quot; alt=&quot;&quot; width=&quot;995&quot; height=&quot;45&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;这样就变成了范围查询，走索引，因为索引中包含了需要查询的全部值，所以不需要再查询聚集索引，减少磁盘IO，这样就可以提高速度。 &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.7、Multi-Range Read优化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Multi-Range Read优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO-bound类型的SQL查询语句可带来性能极大的提升。Multi-RangeRead优化可适用于range，ref，eq_ref类型的查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Multi-Range Read的好处：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;减少缓冲池中页被替换的次数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;批量处理对键值的查询操作&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;MRR的工作方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将缓存中的键值根据RowID进行排序。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根据RowID的排序顺序来访问实际的数据文件。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实验：采用前面2.1节导入的数据：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;explain select *  from foundation_item.item where store_id &amp;gt; 332604504249736122 and store_id  &amp;lt; 332604504249736201;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015135437869-854850140.png&quot; alt=&quot;&quot; width=&quot;993&quot; height=&quot;44&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;MySQL5.6版本开始支持Multi-Range Read（MRR）优化，通过参数 optimizer_switch 的标记来控制是否使用MRR，当设置mrr=on时，表示启用MRR优化。mrr_cost_based 表示是否通过 cost base的方式来启用MRR.如果选择&lt;strong&gt;mrr=on,mrr_cost_based=off,&lt;/strong&gt;则表示总是开启MRR优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如设置：set optimizer_switch='mrr=on,mrr_cost_based=on';然后我们继续查看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;explain select *  from foundation_item.item where store_id &amp;gt; 332604504249736122 and store_id  &amp;lt; 332604504249736201;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015135804461-494531498.png&quot; alt=&quot;&quot; width=&quot;981&quot; height=&quot;46&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; 如上：MRR优化关闭后没有启动了&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.8、Index Condition Pushdown（ICP）优化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能，优化支持range、ref、eq_ref、ref_or_null类型的查询，选择Index Condition Pushdown优化时，可在执行计划的列Extra看到Using index condition提示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实验：数据来源于2.1生成的数据：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们创建一个组合索引：create index idx_email_id_address_state on foundation_commons.email (state,address,email_id);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;explain SELECT * from foundation_commons.email where state =0 and address like '%D%' and email_id &amp;gt;='332604504249734136' ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015141818023-1547832835.png&quot; alt=&quot;&quot; width=&quot;968&quot; height=&quot;42&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; 以上实验只是为了显示这样的现象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、当sql需要全表访问时，ICP的优化策略可用于range, ref, eq_ref, ref_or_null类型的访问数据方法 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 支持InnoDB和MyISAM表。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. ICP只能用于二级索引，不能用于主索引。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、索引实现的原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;innodb存储的索引是基于B+树实现的，从1.1节中的表格可以看出，不支持hash的实现方式。首先来了解下B+树的特点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;B+树的特征：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;B+树的优势：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;单一节点存储更多的元素，使得查询的IO次数更少。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有查询都要查找到叶子节点，查询性能稳定。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有叶子节点形成有序链表，便于范围查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。先来看一个B+树，其高度为2，每页可存放4条记录，扇出（fan out）为5，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015145501879-2119089010.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;184&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;索引的设计思考：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;索引是一种存储方式，最相关的硬件就是磁盘，索引磁盘的性能会直接影响到数据库的查询效率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;磁盘的性能和读写的顺序有关，普通磁盘顺序读写比随机读写快很多，所以尽量避免随机读写。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据都是以行为单位一行一行的存储的，每一行都包括了所有的列，多行可以连续存储。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每一行数据中，一般都有一个键，其他的列可以称为值，可以理解为键值对。innodb必须有唯一非空的主键，就是默认的键。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在键值对中，键值可以排序，还可以组合键值。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;索引的设计：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;磁盘空间会划分为许多个大小相等的块或者页，一个页中可以存储多行数据，这样就可以符合磁盘的顺序读写，这样一次IO就可以读取很多数据到内存，可以减少磁盘IO。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在一个页内，所有的数据可能会经常变动，并且大小也是相对固定的，所以内部通过链表或者数组管理。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个键值可以排序，所以在一个块内的所有数据也可以是有序的，这样通过二分法查找可以很快的在一个页内找到指定键对应的数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个页设计好之后，可以把页作为B+树的节点，通过页来承载数据，通过B+数来组织不同页之间的关系&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;B+树的特点是在内节点存储键来提高搜索的性能，所以很自然的，内节点用来存储数据行的键，叶子节点存储所有数据行，可以很好的提升性能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接下来在结合&lt;strong&gt;2.5节的聚集索引和二级索引&lt;/strong&gt;来说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015171949560-153896122.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;327&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　上图所示的是一个深度为2的B+树，也是我们所称的索引，这里假设页有随机唯一的编号，根页号为20。这里只有一个内节点（根节点），其他的都是叶子节点，也是数据节点，对于内节点来说，存有key和pageno的指针信息，对于叶子节点来说，只存有完整的数据。对于聚集索引，data部分存有除主键外的其他列的组合，如果是二级索引，则这里存放就是这行记录对应主键的组合，用于&lt;strong&gt;回表&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最左边的MIN为了很好的组织树形结构的指针，和其他的内节点一样，主要用来标记它是最小记录Min，还有就是一个pageno指针指向下层最左边的Min记录，其他节点的Min记录用于判断搜索是否到了边界。每个页都有页头页尾用来管理和标记页面的状态，页面中的数据是如何存储，有没有空闲的空间，以什么样的顺序存储等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上图中所有的叶子节点从左到右都是从小到大的顺序以双向链表的方式存储的，所以当我们需要遍历全部的数据，只需要通过B+树找到最小的位置，然后通过遍历链表则可以查询到所有的数据，还有就是10,16,25这三条记录在内节点和叶子节点均存在，这既是B+数的特点，叶子节点会存有所有的key和值。而内节点只存储了key，不存储其他的数据，只有用来索引。叶子节点除了第一条记录会有上一层重复的存储，其他数据不会有这样的现象，所以浪费的空间也不大，由于每一个页的大小是固定的（16k），在内节点上只存储key，不存储其他数据，一个页就可以存储更多的key，这样检索也能减少磁盘的IO，由于页存储Key增多，这样就可以使得B+树的深度减少，这样也可以减少磁盘的IO，提高查询性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如一个三层的B+数，每一个页能存1000个key，所以第二层就有1000*（1+1000）个key，第三层就可以有1000*1001*1001=1002001000（十亿级别），一个简单的三层B+数据就可以存十亿级别的数据，很强大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面说到的“&lt;strong&gt;回表&lt;/strong&gt;”其实就是在使用二级索引进行搜索时，因为二级索引只保存了部分列的数据，如果需要获取键值不包括的列的数据时，需要通过二级索引的指针（书签：用于指向聚集索引的指针）来找到聚集索引的全部数据，然后返回需要查询的列的值。如果使用二级索引不能找到需要的值（需要回表），称为非覆盖索引，否则为2.6节介绍的覆盖索引。非覆盖索引需要回表，增加IO，所以性能会差一些。所以可以根据业务需求创建组合索引来避免回表。但是也要权衡索引带来的利是否大于弊。所以在统计行总数的时候可以通过二级索引来统计，这样速度会快一些。大概图形如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202010/1271254-20201015173224572-917065723.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;436&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 　　这里附带的说一些不能走索引的情况，但是不多说，因为优化这个东西太多，后期准备写一两篇优化的文章，所以这里只是提一下，走索引的强大；&lt;/span&gt;&lt;span&gt;虽然可能创建了很多索引，很多情况都不走索引，比如：like '%query_name%' ，where端使用or条件连接，where端使用函数等，在group by和order by使用的时候要注意组合索引的最左前缀原则。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《InnoDB存储引擎（第2版）》&lt;/p&gt;
&lt;p&gt;《mysql运维内参》&lt;/p&gt;
&lt;p&gt;《mysql8入门到精通》&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_26222859/article/details/80631121&lt;br/&gt;https://zhuanlan.zhihu.com/p/29118331&lt;/p&gt;

</description>
<pubDate>Fri, 16 Oct 2020 14:59:00 +0000</pubDate>
<dc:creator>一寸HUI</dc:creator>
<og:description>我想很多人对mysql的认知可能就是CRUD（代表创建(Create)、更新(Update)、读取(Retrieve)和删除(Delete)操作），也不敢说自己会用和熟悉mysql，当然我就是其中一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zsql/p/13808417.html</dc:identifier>
</item>
<item>
<title>Python中列表、元组、字典、集合与字符串，相关函数，持续更新中…… - JomBarry</title>
<link>http://www.cnblogs.com/jombarry/p/13828974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jombarry/p/13828974.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇博客为博主第一次学 Python 所做的笔记（希望读者能够少点浮躁，认真阅读，平心静气学习！）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;列表、元组和字符串共同属性：
&lt;ul&gt;&lt;li&gt;属于有序序列，其中的元素有严格的先后顺序&lt;/li&gt;
&lt;li&gt;都支持双向索引，索引范围 [ -L, L-1 ] ，L -- 表示列表、元组和字符串的长度（分正向索引和反向索引）。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;正向索引&lt;/strong&gt;：0 表示第 1 个元素，1 表示第 2 个元素，2 表示第 3 个元素...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向索引&lt;/strong&gt;：-1 表示最后 1 个元素，-2 表示倒数第 2 个元素，-3 表示倒数第 3 个元素...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;放在一对方括号中，相邻元素之间使用逗号分隔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;同一个列表元素的数据类型可以各不相同。&lt;/li&gt;
&lt;li&gt;列表包含：
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;整数&lt;/strong&gt;、&lt;strong&gt;浮点数&lt;/strong&gt;、&lt;strong&gt;复数&lt;/strong&gt;、&lt;strong&gt;字符串&lt;/strong&gt; 等 基本类型元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列表&lt;/strong&gt;、&lt;strong&gt;元组&lt;/strong&gt;、&lt;strong&gt;字典&lt;/strong&gt;、&lt;strong&gt;集合&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt; 或 &lt;strong&gt;其他任意对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建列表：&quot;&gt;创建列表：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用方括号直接创建&lt;/li&gt;
&lt;li&gt;list() 函数把元组、range 对象、字符串、字典、集合，以及 map 对象、zip 对象、enumerate 对象或其他类似对象 &lt;strong&gt;转换&lt;/strong&gt; 为列表。&lt;/li&gt;
&lt;li&gt;内置函数（ sorted() ）、标准库函数（ random.sample() ）或扩展函数（ jieba.lcut() ）也会返回列表&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;函数：&quot;&gt;函数：&lt;/h2&gt;
&lt;h4 id=&quot;1-访问元素：&quot;&gt;1. 访问元素：&lt;/h4&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;9&quot;&gt;用户可以使用整数作为下标来随机访问其中任意位置上的元素
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = list(range())
# data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(data[1])
# 结果 1
print(data[-1])
# 结果 9
……
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;如果指定的下标不在有效范围内，代码会抛出异常提示下表越界&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2-其他常用方法：&quot;&gt;2. 其他常用方法：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;lst&lt;/strong&gt; - 表示列表对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;lst.append(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将 x 追加至列表 lst 的尾部，不影响列表中已有元素的位置，也不影响列表在内存中的起始地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;lst.insert(index, x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在列表 lst 的 index 位置处插入 x，该位置之后的所有元素自动向后移动，索引加 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;extend(L)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将列表 L 中所有元素追加至列表 lst 的尾部，不影响 lst 列表中已有元素的位置，也不影响 lst 列表在内存中的起始地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;pop([index])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除并返回列表 lst 中下标为 index 的元素，该位置后面的所有元素自动向前移动，索引减 1。index 默认为 -1，表示删除并返回列表中最后一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;remove(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在列表 lst 中删除第一个值为 x 的元素，被删除元素位置之后的所有元素自动向前移动，索引减 1；如果列表中不存在 x 则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;count(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回 x 在列表 lst 中的出现次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;index(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回列表 lst 中第一个值为 x 的元素的索引，若不存在值为 x 的元素则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;sort( key = None , reverse = False)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对列表 lst 的所有元素进行原地逆序，首尾交换&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;3-推导式：&quot;&gt;3. 推导式：&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用 &lt;strong&gt;非常简洁&lt;/strong&gt; 的方式对列表或其他可迭代对象的元素进行遍历、过滤或再次计算，快速生成满足特定需求的新列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 格式：
[expression for expr1 in sequence1 if condition
                        for expr2 in sequence2 if condition2
                        for expr3 in sequence3 if condition3
                        ...
                        for exprN in sequenceN if conditionN
]

# 例子：
data = [num for num in range(20) if num%2==1]
# 等价于 =&amp;gt;
data = []
for num in range(20):
        if num%2 == 1:
                data.append(num)
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;创建元组：&quot;&gt;创建元组：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;用圆括号放若干元素创建元组（如果只有一个元素，则需要多加一个逗号 &lt;code&gt;(3,)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;tuple()&lt;/code&gt; 函数把 &lt;strong&gt;列表&lt;/strong&gt;、&lt;strong&gt;字典&lt;/strong&gt;、&lt;strong&gt;集合&lt;/strong&gt;、&lt;strong&gt;字符串&lt;/strong&gt; 以及 &lt;strong&gt;range 对象&lt;/strong&gt;、&lt;strong&gt;map 对象&lt;/strong&gt;、&lt;strong&gt;zip 对象&lt;/strong&gt; 或 &lt;strong&gt;其他类似对象&lt;/strong&gt;转换为元组&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;元组的好处（与列表对比）：&quot;&gt;元组的好处（与列表对比）：&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;元组&lt;/th&gt;
&lt;th&gt;列表&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;修改元素值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不能直接修改&lt;/td&gt;
&lt;td&gt;可以修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;访问速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;开销&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;不安全&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;是否可以用作字典的键&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;是否可以作为集合的元素&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;属于容器对象，其中包含若干元素，每个元素包含 “键” 和 “值” 两部分，之间使用冒号分隔，表示一种对应关系。&lt;/li&gt;
&lt;li&gt;不同元素之间使用逗号分隔，所有元素放在一对大括号中。&lt;/li&gt;
&lt;li&gt;“键”，可以是 Python 中任意不可变数据，例如整数、复数、字符串、元组等类型；不能是列表、集合、字典或其他可变类型，包含列表等可变数据的元组也不能作为字典的 “键”&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;函数：-2&quot;&gt;函数：&lt;/h2&gt;
&lt;h4 id=&quot;1-访问：&quot;&gt;1. 访问：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 初始化
data = dict(name = &quot;张三&quot;， age = 8, sex = 'M')
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;把 “键” 最为下标可以返回对应的 “值”（不存在的话会抛出异常）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(data('name'))
# 结果：张三
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;get()&lt;/code&gt; 方法获取指定的 “键” 对应的 “值”（不存在返回空值或指定的值）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(data.get('age'))
# 结果：18
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;支持元素迭代
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;可以将其转换为列表或元组
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(list(data))
# 结果：['name', 'age', 'sex']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;可以使用 for 循环遍历其中的元素，默认情况下是遍历字典中的 “键”
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for key, value in data.items():
        print(key, value, sep='\t')
# 结果：name 张三
# 结果：age 18
# 结果：sex M
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;遍历字典元素，必须使用字典对象的 &lt;code&gt;items()&lt;/code&gt; 方法明确说明
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(list(data.items()))
# 结果：[('name', '张三'), ('age', '18'), ('sex', 'M')]
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;遍历字典的 “值”，则必须使用字典对象的 &lt;code&gt;values()&lt;/code&gt; 方法明确说明
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(list(data.values()))
# 结果：['张三', '18', 'M']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2-修改：&quot;&gt;2. 修改：&lt;/h4&gt;
&lt;p&gt;当以指定 “键” 为下标为字典元素赋值时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若该 “键” 存在，表示修改该 “键” 对应的值：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;soct = {'IP': '127.0.0.1', 'port': 80}
soct['port'] = 8080
print(soct)
# 结果：{'IP': '127.0.0.1', 'port': 8080}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;若 “键” 不存在，表示添加一个新元素：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;soct = {'IP': '127.0.0.1', 'port': 80}
soct['protocol'] = 'TCP'
print(soct)
# 结果：{'IP': '127.0.0.1', 'port': 80, 'protocol': 'TCP'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-添加：&quot;&gt;3. 添加：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;update()&lt;/code&gt; 方法可以将另一个字典的元素一次性全部添加到当前字典中，如果两个字典中存在相同的 “键”，则以另一个字典中的 “值” 为准对当前字典进行更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;sock = {'IP': '127.0.0.1', 'port': 80}
sock.update({'IP': '192.168.9.62', 'protocol': 'TCP'})
print(sock)
# {'IP': '192.168.9.62', 'protocol': 'TCP', 'port': 80}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-删除：&quot;&gt;4. 删除：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;sock = {'IP': '192.168.9.62', 'port': 80, 'protocol': 'TCP'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pop()&lt;/code&gt; 方法可以删除指定 “键” 对应的元素，同时返回对应的 “值”。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(sock.pop('IP'))
# 结果：192.168.9.62
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;popitem()&lt;/code&gt; 方法用于删除并返回一个包含两个元素的元组，其中的两个元素分别是字典元素的 “键” 和 “值”。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(sock.popitem())
# 结果：('protocol', 'TCP')
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;del&lt;/code&gt; 删除指定的 “键” 对应的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;del sock['port']
print(sock)
# 结果：{'IP': '192.168.9.62', 'protocol': 'TCP'}
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;无序、可变的容器对象，所有元素放在一对大括号中，元素之间使用逗号分隔，同一个集合内的每个元素都是唯一的，不允许重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;0-创建：&quot;&gt;0. 创建：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;所有元素放在一对大括号中，创建集合&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = {30, 40, 50}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;set()&lt;/code&gt; 函数将列表、元组、字符串、range 对象等其他可迭代对象转换为集合。&lt;/li&gt;
&lt;li&gt;使用集合推导式生成特定的集合，如果原来的数据中存在重复元素，在转换为集合的时候重复的元素只保留一个，自动除去重复元素。&lt;/li&gt;
&lt;li&gt;如果原序列或迭代对象中有可变类型的数据，则无法转换成为集合，抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集合内数据要求：
&lt;ul&gt;&lt;li&gt;集合中只能包含数字、字符串、元组等不可变类型的数据&lt;/li&gt;
&lt;li&gt;不包含列表、字典、集合等可变类型的数据，包含列表等可变类型数据的元组也不能作为集合的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;元素是无序的，元素储存顺序和添加顺序并不一致。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;1-访问：-2&quot;&gt;1. 访问：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;集合不支持使用下标直接访问特定位置上的元素，也不支持使用 &lt;code&gt;random&lt;/code&gt; 中的 &lt;code&gt;choice()&lt;/code&gt; 函数从集合中随机选取元素&lt;/li&gt;
&lt;li&gt;支持使用 &lt;code&gt;random&lt;/code&gt; 模块中的 &lt;code&gt;sample()&lt;/code&gt; 函数随机选取部分元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2-修改：-2&quot;&gt;2. 修改：&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加新元素，如果存在则忽略该操作，不会抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法用户合并另一个集合中的元素到另一个集合中，并自动除去重复元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = {30, 40, 50}
data.add(20)
print(data)
# 结果：{40, 50, 20, 30}

data = {30, 40, 50}
data.update({40, 60})
print(data)
# 结果：{50, 40, 60, 30}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-删除：&quot;&gt;3. 删除：&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pop()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来随机删除并返回集合中的一个元素，如果集合为空则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于删除集合中的指定元素，如果指定元素不存在则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于从集合中删除一个指定元素，若指定的元素不在集合中则直接忽略该操作。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = {30, 40, 50}
data.remove(30)
print(data)
# 结果：{40, 50}

data = {30, 40, 50}
data.discard(30)
print(data)
# 结果：{40, 50}

data = {30, 40, 50}
data.pop()
print(data)
# 结果：{50, 30}
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;字符串属于不可变对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-编码与解码&quot;&gt;1. 编码与解码&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用指定的编码格式把字符串编码为字符串，默认使用 UTF-8 编码格式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用指定的编码格式把字节串解码为字符串，默认使用 UTF-8 编码格式。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;2-将数据格式转化为特定格式的字符串&quot;&gt;2. 将数据格式转化为特定格式的字符串&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于把数据格式转化为特定格式的字符串，该方法通过格式字符串进行调用。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;常用的格式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;b（二进制格式）&lt;/li&gt;
&lt;li&gt;c（把整数转换成 Unicode 字符）&lt;/li&gt;
&lt;li&gt;d（十进制格式）&lt;/li&gt;
&lt;li&gt;o（八进制格式）&lt;/li&gt;
&lt;li&gt;x（小写十六进制格式）&lt;/li&gt;
&lt;li&gt;X（大写十六进制格式）&lt;/li&gt;
&lt;li&gt;e/E（科学计数法格式）&lt;/li&gt;
&lt;li&gt;f/F（固定长度的浮点数格式）&lt;/li&gt;
&lt;li&gt;%（使用固定长度浮点数显示百分数）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 保留4位小数
# 0 表示参数下标，对应第一个参数
print('{0:.4f}'.format(10/3))
# 结果：3.3333
print('{0:.2%}'.format(1/3))
# 结果：33.33%

# 格式化为百分数字符串，总宽度为10，保留2位小数，&amp;gt; 表示右对齐
print('{0:&amp;gt;10.2%}'.format(1/3))
# 结果：    33.33%

# 逗号表示在数字字符串中插入逗号作为千分符，#x表示格式化为十六进制数
print(&quot;{0:,} in hex is: {0:#x}, in oct is {0:#o}&quot;.format(5555555))
# 结果：5,555,555 in hex is: 0x54c563, in oct is 0O25142543

# 可以先格式化下标为 1 的参数，再格式化下标为 0 的参数
print(&quot;{1} in hex is: {1: #x}, {0} in oct is {0:o}&quot;.format(6666, 66666))
# 结果：66666 in hex is: 0x1046a, 6666 in oct is 15012

# _表示在数字中插入下划线来为千分符
print('{0:_}, {0:#_x}'.format(10000000))
# 结果：10_000_000, 0x98_9680
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-单个字符串在字符串中的相关函数&quot;&gt;3. 单个字符串在字符串中的相关函数&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回一个字符串在当前字符串中 &lt;strong&gt;首次出现&lt;/strong&gt; 的位置，如果当前字符串中不存在此字符串，则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;rindex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回一个字符串在当前字符串中 &lt;strong&gt;最后一次&lt;/strong&gt; 出现的位置，如果当前字符串中不存在此字符串，则抛出异常。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法用来返回一个字符串在当前字符串中 &lt;strong&gt;出现的次数&lt;/strong&gt;，如果当前字符串中不存在此字符串，则返回 0。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;4-字符串的编辑修改&quot;&gt;4. 字符串的编辑修改&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来替换字符串中指定字符或子字符串的所有重复出现，每次只能替换一个字符或一个字符串，把指定的字符串参数作为一个整体对待，类似与 Word、WPS、记事本、写字板等文本编辑器的'全部替换'功能。该方法返回一个新字符串，并不修改原字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;maketrans()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来生成字符串映射表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于把数据格式转化为特定格式的字符串，该方法通过格式字符串进行调用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;translate()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用来根据映射表中定义的对应关系转换字符串并替换其中的字符。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = &quot;python 是一门非常棒的编程语言。&quot;
print(text.replace('棒', '优雅').replace('编程', '程序设计'))
# 结果：python 是一门非常优雅的程序设计语言。

table = ''.maketrans('0123456789', '零壹贰叁肆伍陆柒捌玖')
print('Tel:30647359'.translate(table))
# 结果：Tel:叁零陆肆柒叁伍玖
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-字符串进行排版&quot;&gt;5. 字符串进行排版&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ljust()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;居左&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;rjust()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;居右&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;center()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;居中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print('居左'.ljust(20)+'结束')
# 结果：居左                         结束
print('居右'.rjust(20, '#'))
# 结果：####################居右
print('居中'.center(20, '='))
# 结果：==========居中==========
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6-自定义分隔符对字符串分隔&quot;&gt;6. 自定义分隔符对字符串分隔&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不指定默认为空格、换行符和制表符等空白字符）作为分隔符对原字符串进行分隔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从左向右&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;rsplit()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从右向左&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用指定的字符串作为连接符对可迭代对象中的若干字符串进行连接。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = 'Beautiful is better than ugly.'
print(text.split())
# 结果：['Beautiful', 'is', 'better', 'than', 'ugly.']

print(text.split(maxsplit=1))
# 结果：['Beautiful', 'is better than ugly.']

print('1,2,3,4'.split(','))
# 结果：['1', '2', '3', '4']

print(','.join(['1', '2', '3', '4']))
# 结果：1,2,3,4

print(':'.join(map(str, range(1, 5))))
# 结果：1:2:3:4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7-大小写转换&quot;&gt;7. 大小写转换&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;lower()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符串中的英文字母全部转换为 &lt;strong&gt;小写&lt;/strong&gt; 字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;upper()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符串中的英文字母全部转换为 &lt;strong&gt;大小&lt;/strong&gt; 字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;capitalize()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每个 &lt;strong&gt;句子&lt;/strong&gt; 的 &lt;strong&gt;第一个字母&lt;/strong&gt; 转换为 &lt;strong&gt;大写&lt;/strong&gt; 字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;title()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每个 &lt;strong&gt;单词&lt;/strong&gt; 的 &lt;strong&gt;第一个&lt;/strong&gt; 字母转换为 &lt;strong&gt;大写&lt;/strong&gt; 字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;swapcase()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;小写&lt;/strong&gt; 字母转换为 &lt;strong&gt;大写&lt;/strong&gt; 字母并把 &lt;strong&gt;大写&lt;/strong&gt; 字母转换为 &lt;strong&gt;小写&lt;/strong&gt; 字母&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = 'Explicit is better than implicit.'
print(text.lower())
# 结果：explicit is better than implicit.

print(text.upper())
# 结果：EXPLICIT IS BETTER THAN IMPLICIT.

print(text.capitalize())
# 结果：Explicit is better than implicit.

print(text.title())
# 结果：Explicit Is Better Than Implicit.

print(text.swapcase())
# 结果：eXPLICIT iS bETTER tHAN iMPLICIT.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;8-判断字符串开始与结束单词&quot;&gt;8. 判断字符串开始与结束单词&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试字符串是否以指定的一个或几个字符串（放在元组中）开始或结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;startswith()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;endswith()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;结束&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = 'Simple is better than complex.'
print(text.startswith('simple'))
# 结果：False

print(text.startswith('Simple'))
# 结果：True

print(text.endswith(('.', '!', '?')))
# 结果：True
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;9-删除字符串指定字符&quot;&gt;9. 删除字符串指定字符&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;删除字符串两侧、右侧和左侧的空白字符或指定的字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;strip()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;两侧&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;rstrip()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右侧&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;lstrip()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左侧&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = '     ======test===#####     '
print(text.strip())
# 结果：======test===#####

print(text.strip('=# '))
# 结果：test
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 16 Oct 2020 14:02:00 +0000</pubDate>
<dc:creator>JomBarry</dc:creator>
<og:description>本篇博客为博主第一次学 Python 所做的笔记（希望读者能够少点浮躁，认真阅读，平心静气学习！） 补充： 列表、元组和字符串共同属性： 属于有序序列，其中的元素有严格的先后顺序 都支持双向索引，索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jombarry/p/13828974.html</dc:identifier>
</item>
<item>
<title>对位运算与逻辑电路统一性的浅显理解(入门) - explorerxx</title>
<link>http://www.cnblogs.com/mikuo/p/13825706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mikuo/p/13825706.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;（题目我大概是随便编的，感觉叫这个比较能概括我总结的主题）&lt;/p&gt;
&lt;p&gt;在学OI的过程中，我一开始完全不懂位运算，后来经过一些题目的记忆，也是能够记下来算术运算符它们的效果和作用，但是总是忘记每个运算符具体的效果，比如或运算与运算之类。&lt;/p&gt;
&lt;p&gt;今天无意间翻开物理书，看到逻辑电路那一节，里面的与，或不就是算术位运算的效果吗？我突然感到自己是个弱智，先前都是在死记硬背(数学课讲逻辑的时候也有与和或，当时没有联想到按位运算，只是想到了对于条件且(&amp;amp;&amp;amp;)和条件(||)的类比)&lt;/p&gt;
&lt;p&gt;（我死记硬背的方法——在便笺里放着小口诀）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016115332404-1786974182.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我打算改变我憨批一般的死记硬背，从更基本的逻辑电路出发来记忆和理解各个位运算的效果。&lt;/p&gt;
&lt;p&gt;将数学语言上的逻辑，计算机上的逻辑(程序语言)，电路上的逻辑(其实也是计算机底层的逻辑吧)统一起来，让自己更清晰。&lt;/p&gt;
&lt;p&gt;而众所周知，计算机位运算中有 “与” “或”“非”“异或”四种算术位运算，下面将分别分析和统一它们。&lt;/p&gt;
&lt;p&gt;##事先备注，下文的表述中在数学上只是逻辑语言，用于一种描述或进行推论；而表现在计算机中，这些逻辑运用都是二进制下按位运算，也就是对二进制数的每一位都进行这样的逻辑运算；物理上就是逻辑门的关系，(当然还存在“与非”“或非”等等，本文只讲述与c++位运算有关内容,这些并无直接对应，但可以通过组合实现)。它们只是在逻辑上统一，具有相同的逻辑关系，并非含义等同。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;基本介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;与&lt;/strong&gt; : 　&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　　　符号:&lt;/h4&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;数学&lt;/strong&gt;： &lt;strong&gt;∧   &lt;/strong&gt;          （这个不是^（次方或者异或符号）,是逻辑与）&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;计算机(c++)（其实是按位与) &lt;/strong&gt;   : and    &amp;amp;   （整条语句为“&amp;amp;&amp;amp;”）&lt;/p&gt;
&lt;h4&gt;　　　　具体描述 :&lt;/h4&gt;
&lt;p&gt;　　　　              &lt;strong&gt;都为真才为真 ，或者说 输入都为1(true) 才输出 1(true) ，再或者说 条件都为1(true) 结论才为1(true)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　对于c++来说，使用第二条来记录比较具象(就是我便笺上写的)。&lt;/p&gt;
&lt;p&gt;　　　　              物理上的逻辑(开关串联):&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016123127015-2044783929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　              我们规定开关关闭(断路)则表示条件(逻辑再者说输入)为0(假)，开关开启(通路)则表示条件(逻辑再者说输入)为1(真)，&lt;/p&gt;
&lt;p&gt;       　　               两者都为1的时候，两者都为0(0&amp;amp;0)，灯泡的状态为不亮，即表现为0(假)；同时，开关一开一关(0&amp;amp;1)，&lt;/p&gt;
&lt;p&gt;　　　　　　　　显然灯泡也不会亮，即表现为0(假);只有二者均为1(1&amp;amp;1)的时候，灯泡才会亮，即表现为1(真)；&lt;/p&gt;
&lt;h4&gt;　　　　运算表达式：&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学&lt;/strong&gt;(其实数学这里“与”其实是“逻辑且(逻辑与)”吧，对应在程序里是&amp;amp;&amp;amp;而不是按位与的&amp;amp;，但它们在逻辑上是并通的):　&lt;/p&gt;
&lt;p&gt;　　　　　　        如果条件p为假，条件q为假，那么   p∧q=假;&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果条件 p为真，q为假或者p为假，q为真 ，那么p∧q=假;&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果p，q都为真，那么p∧q=真&lt;/p&gt;
&lt;p&gt;　　　　　　　　抽象点(有定义，乘法为与，&quot;＋&quot;表逻辑或，条件加“&lt;strong&gt; '&lt;/strong&gt; ”为非): &lt;/p&gt;
&lt;p&gt;　　　　　　　　F=AB (AB都为1，F才为1)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;计算机(&lt;/strong&gt;二进制按位运算&lt;strong&gt;):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　         &lt;/strong&gt;0&amp;amp;0=0；1&amp;amp;0=0；0&amp;amp;1=0；1&amp;amp;1=1；&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;物理：这咋表达？这个只能用图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;逻辑上的统一就是：都为真才得到真&lt;/strong&gt;（&lt;span&gt;这不还是那句话？——但是我们多了个物理含义！是不是更好记了？&lt;/span&gt;）&lt;span&gt;&lt;br/&gt;&lt;/span&gt;　　　　　　  　　　　　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;或:  　　&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　　　符号:&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学:  ∨ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　计算机(c++): &lt;/strong&gt;or  |  （对于整条语句来说是“||”）&lt;/p&gt;
&lt;h4&gt;　　　　具体描述：&lt;/h4&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;只要有一个为真就是真，都为假时才是假；或者说输入有一个为1(true)就是1(true)，都为0(false)才是假；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　再或者说，条件有一个为1(true)结论就为1(true),条件均为0(false)结论才为0(false)。&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　对于c++来说，仍然是第二条。&lt;/p&gt;
&lt;p&gt;　　　　　　　　物理上的逻辑(开关并联):&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016162856593-815924979.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　同样的，开关通路(开)则表示1，断路(关)则表示0。如图&lt;/p&gt;
&lt;p&gt;　　　　　　　　两者都为1(开)的时候(1|1)，则为1，任意一者为1(1|0)的时候也为1，即这两种情况灯是亮的；&lt;/p&gt;
&lt;p&gt;　　　　　　　　而只有两者都为0(0|0)的时候才为0，即灯是不亮的；&lt;/p&gt;
&lt;h4&gt;　　　　运算表达式：　　　　　　   &lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学&lt;/strong&gt;(同逻辑与，数学的含义实际类似于“||”)：&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果条件p,q至少有一个为真，则p∨q=真。&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果条件都为假，则p∨q=假。&lt;/p&gt;
&lt;p&gt;　　　　　　　　抽象点(有定义，乘法为与，&quot;＋&quot;表逻辑或，条件加“&lt;strong&gt; '&lt;/strong&gt; ”为非): &lt;/p&gt;
&lt;p&gt;　　　　　　　　F=A+B     (AB只要有一个为1，F就不为0)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;计算机&lt;/strong&gt;(二进制按位运算)：&lt;/p&gt;
&lt;p&gt;　　　　　　　　1|1=1；0|1=1；1|0=1;0|0=0; &lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;物理：并联开关一个为开则干路上的灯为亮，都关了才不亮。　&lt;/span&gt;　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;逻辑上的统一就是:都为假才是假&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;非： 　　　&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　　　符号：  　　&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学:    &lt;/strong&gt;¬&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;计算机(c++):&lt;/strong&gt;　~ (对于整条语句来说是“!”，不过在c++的条件语句里，二者都可以作用于一个判断语句的真假，但对数字按位取反要用~)　&lt;/p&gt;
&lt;p&gt; 　　　 &lt;strong&gt;具体描述:　&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;是真则为假，是假则为真。输入为输出相反。条件与结论相反。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　c++同样为第二条。&lt;/p&gt;
&lt;p&gt;　　　　　　　　物理上的逻辑(开关串联，与灯泡并联):&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016184636325-1594306513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　　　　　　　同上，很显然的就是，开关打开(通路)时灯泡不亮(被短路了)  (!1)，即为0，开关关闭(断路)时灯泡亮(!0)，即为1。&lt;/p&gt;
&lt;h4&gt;　　　运算表达式：&lt;/h4&gt;
&lt;p&gt;　　　　　&lt;strong&gt;数学：&lt;/strong&gt;   若p为真，则¬p为假&lt;/p&gt;
&lt;p&gt;　　　　　　　　　若p为假，则¬p为真&lt;/p&gt;
&lt;p&gt;　　　　　　　　　抽象点(有定义，乘法为与，&quot;＋&quot;表逻辑或，条件加“&lt;strong&gt; '&lt;/strong&gt; ”为非): &lt;/p&gt;
&lt;p&gt;　　　　　　　　　F=A'&lt;/p&gt;
&lt;p&gt;　　　　　&lt;strong&gt;计算机(二进制按位运算):&lt;/strong&gt;　这个比较特殊，因为如果要按位非的话，也就是按位取反&lt;/p&gt;
&lt;p&gt;　　　　　　　　由于计算机内一个数字变量类型的最高为(比如int的第32位)符号位，按位取反则对从32到1所有取反&lt;/p&gt;
&lt;p&gt;　　　　　　　　所以说~1=-2，~0=-1。但是&lt;/p&gt;
&lt;p&gt;　　　　　　　　!0=1    !1=0      &lt;/p&gt;
&lt;p&gt;　　　　　　　　实际上除了!0之外的所有数进行!操作，都是0&lt;/p&gt;
&lt;p&gt;　　　　　　　　&quot;!&quot;只是逆转真假罢了，一个数只有是0的时候才是假，所以只有0的时候进行&quot;!&quot;才是真，于是造成了这样的结果。&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;物理:开开关灯就灭，关开关等就亮&lt;br/&gt;&lt;/span&gt;　　　　　&lt;strong&gt;统一的逻辑就是:是真则为假，是假则为真&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt; 　　　　符号：   &lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学:  &lt;/strong&gt;  ⊕&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;计算机(c++): &lt;/strong&gt;xor   ^ &lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;具体描述:&lt;/strong&gt;　　 &lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;相同则为假，相异则为真。输入都为0或1则为假，输入为一0一1则为真。条件都真或者都假结论就假，条件一真一假才为真。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　c++同样为第二条。&lt;/p&gt;
&lt;p&gt;　　　　　　　　物理上的逻辑(不好用语言描述图了，口胡一下:非电路和另一开关构造与电路，再交换开关复制成或电路):&lt;/p&gt;
&lt;p&gt;　　　　　　　　图一(严格按照数学表达式)：&lt;/p&gt;
&lt;p&gt;　　　　　　，　　 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016193711530-568855887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　　　　　　　令上下的并联开关为k1，可以理解为同一个开关，二者操作同时，表达同时同等，k2理解为另一个开关，二者同时同等。&lt;/p&gt;
&lt;p&gt;　　　　　　　　当k1打开，k2关闭的时候(1^0)，上路的灯可以亮，当k2打开，k1关闭的时候(0^1)，下路的灯可以亮。&lt;/p&gt;
&lt;p&gt; 　　　　　　　  当k1，k2都关闭(0^0)或者都打开(1^1)的时候，两个路的灯都不可以亮。&lt;/p&gt;
&lt;p&gt;　　　　　　　　总的表示就是开关状态相同则不亮，开关状态不同则亮。&lt;/p&gt;
&lt;p&gt;　　　　　　　　图2(与非电路串或电路，并借此分析异或的条件与结论的关系):&lt;/p&gt;
&lt;p&gt;　　　　　　　　 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1898520/202010/1898520-20201016194755470-1450297321.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　如图。还是两个k1同步,两个k2同步。（下面的叙述较长，于是我以插入代码的形式压缩了起来）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_2b006760-5397-402b-bc99-fe9bbcf42134&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_2b006760-5397-402b-bc99-fe9bbcf42134&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b006760-5397-402b-bc99-fe9bbcf42134&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
左边这团电路是&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与非电路&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;，与非电路即先与再非的电路，当&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表达为假的时候总表达为真，反之为假。
右边的或电路和灯是串的，所以逻辑就是单纯的或。

如果只有左电路，开关都打开灯一定不亮，灯不亮时开关一定都打开(开关是通路,灯被短路)，二者互为充要条件。
放在整个电路中，虽然灯不亮时开关不一定都打开，但开关都打开时灯一定不亮(被短路)，

所以开关都打开是灯不亮的充分不必要条件，灯不亮是开关都打开的必要不充分条件。

如果只有右电路，开关都关闭灯一定不亮，灯不亮时开关一定都关闭(灯被断路)，二者互为充要条件。
放在整个电路中，虽然灯不亮时开关不一定都关闭，但开关都关闭时灯一定不亮，

所以开关都关闭时灯不亮的充分不必要条件，灯不亮是开关都关闭的必要不充分条件。

以上分析可知，开关都开或者都闭的时候(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;^0或者1^&lt;span&gt;1&lt;/span&gt;)，灯一定不亮(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)。灯不亮的时候一定是开关都开或都关的时候。
也就是说，开关状态一致和灯的不亮，互为充要条件,既然它们互为充要，如果画成韦恩图，二者等价。

到这里可以用数学的逻辑推出来开关不一致对应的是灯亮：

    很明显开关状态不一致是和开关状态一致是相反的说法，没有交集，所以说它对开关的不亮是既不充分也不必要条件。
    因为开关如果分成一致(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;)或不一致(&lt;span&gt;1&lt;/span&gt;)只有0/&lt;span&gt;1两个状态，灯泡的亮与不亮也只有两个状态，所以说灯亮的时候一定和开关状态不一致时等价的。
    也就是说开关状态不一致的时候，灯一定是亮的。
　 具体来说，开关状态不一致的时候，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;与非电路&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;为真(&lt;span&gt;1&lt;/span&gt;)，而或电路也为真(&lt;span&gt;1&lt;/span&gt;)，二者又是与的关系，都为真(&lt;span&gt;1&lt;/span&gt;) 则表达为真(&lt;span&gt;1&lt;/span&gt;)，所以说灯泡就是亮的，为真(&lt;span&gt;1&lt;/span&gt;)。    
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　其实个人觉得两个图都比较好记，图一的优点在于完全对应数学表达，图二的优点在于不在乎k1，k2的交换，只要左右电路分别有对k1，k2就行。&lt;/p&gt;
&lt;h4&gt;　　　　运算表达式：　 &lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;数学：&lt;/strong&gt;条件p和条件q一真一假,则　p ⊕ q=真　&lt;/p&gt;
&lt;p&gt;　　　　　　　　    条件p和条件q都为真或者都为假，则p ⊕ q =假&lt;/p&gt;
&lt;p&gt;　　　　　　　　　抽象点(有定义，乘法为与，&quot;＋&quot;表逻辑或，条件加“&lt;strong&gt; '&lt;/strong&gt; ”为非): &lt;/p&gt;
&lt;p&gt;　　　　　　　　　F=AB'+A'B（完全对应图1,图二相当于 F=(AB)'(A+B),两式结果相同）&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;计算机(c++): &lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;　　　　　　　　   0^0=0;1^1=0;0^1=1;1^0=1;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　&lt;strong&gt;统一的逻辑就是：同则为0，异则为1&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;　　　写下来花了两三个小时，尽管已经查阅资料尽量保证语言的严谨性，但总怕难免有我误解的地方。&lt;/p&gt;
&lt;p&gt;　　　不过大的错误应该没有，或许会有小地方术语说错的，不过不影响物理图数学公式和c++逻辑上的统一性。&lt;/p&gt;
&lt;p&gt;　　　写完之后感觉自己受益良多，强化加深了自己在逻辑运算和位运算方面的理解，甚至包括一些c++语法上的理解。&lt;/p&gt;
&lt;p&gt;　　　同时我再也不会忘了这些算术运算符在c++的效果了。&lt;/p&gt;
&lt;p&gt;　　　到此结束!&lt;/p&gt;
&lt;p&gt;　　　希望看到的人也能有收获，同时欢迎各位提出建议，批评指正。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Fri, 16 Oct 2020 12:41:00 +0000</pubDate>
<dc:creator>explorerxx</dc:creator>
<og:description>前言 （题目我大概是随便编的，感觉叫这个比较能概括我总结的主题） 在学OI的过程中，我一开始完全不懂位运算，后来经过一些题目的记忆，也是能够记下来算术运算符它们的效果和作用，但是总是忘记每个运算符具体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mikuo/p/13825706.html</dc:identifier>
</item>
</channel>
</rss>