<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpEL + AOP实现注解的动态赋值 - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/11890384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/11890384.html</guid>
<description>&lt;h2 id=&quot;一自定义注解&quot;&gt;一、自定义注解&lt;/h2&gt;
&lt;p&gt;先聊聊这个需求，我需要根据用户的权限对数据进行一些处理，但是痛点在哪里呢？用户的权限是在请求的时候知道的，我怎么把用户的权限传递给处理规则呢？想了以下几种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Mybatis 拦截器：如果你的权限参数可以渗透到 Dao 层，那么这是最好的处理方式，直接在 Dao 层数据返回的时候，根据权限做数据处理。&lt;/li&gt;
&lt;li&gt;Dubbo 过滤器：如果 Dao 层没办法实现的话，只好考虑在 service 层做数据处理了。&lt;/li&gt;
&lt;li&gt;ResponseBodyAdvice ：要是 service 层也没办法做到，只能在访问层数据返回的时候，根据权限做数据处理。（以下介绍的正是这种方式）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么现在有个难点就是：我怎么把 request 的权限参数传递到 response 中呢？当然可以在 Spring 拦截器中处理，但是我不想把这段代码侵入到完整的鉴权逻辑中。突然想到，我能不能像 spring-data-redis 中 @Cacheable 一样，利用注解和 SpEL 表达式动态的传递权限参数呢？然后在 ResponseBodyAdvice 读取这个注解的权限参数，进而对数据进行处理。&lt;/p&gt;
&lt;p&gt;首先，我们需要有个自定义注解，它有两个参数：key 表示 SpEL 表达式；userType 表示权限参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ResponseSensitiveOverride {

    /**
     * SPEL 表达式
     *
     * @return
     */
    String key() default &quot;&quot;;

    /**
     * 1：主账号、2：子账号
     */
    int userType() default 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，把这个注解放在路由地址上，key 写入获取权限参数的 SpEL 表达式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @ResponseSensitiveOverride(key = &quot;#driverPageParam.getUserType()&quot;)
    @RequestMapping(value = &quot;/queryPage&quot;, method = RequestMethod.POST)
    public ResponseData&amp;lt;PageVo&amp;lt;AdminDriverVo&amp;gt;&amp;gt; queryPage(@RequestBody AdminDriverPageParam driverPageParam) {
        return driverService.queryPageAdmin(driverPageParam);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二spel-aop-注解赋值&quot;&gt;二、SpEl + AOP 注解赋值&lt;/h2&gt;
&lt;p&gt;现在 SpEL 表达式是有了，怎么把 SpEL 表达式的结果赋值给注解的 userType 参数呢？这就需要用 &lt;a href=&quot;https://www.cnblogs.com/jmcui/p/8031259.html&quot;&gt;Spring AOP&lt;/a&gt; 、&lt;a href=&quot;https://www.cnblogs.com/jmcui/p/9650710.html&quot;&gt;Java 反射&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/jmcui/p/10324902.html&quot;&gt;动态代理&lt;/a&gt; 的知识。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Component
public class SensitiveAspect {

    private SpelExpressionParser spelParser = new SpelExpressionParser();

    /**
     * 返回通知
     */    
    @AfterReturning(&quot;@annotation(com.yungu.swift.base.model.annotation.ResponseSensitiveOverride) &amp;amp;&amp;amp; @annotation(sensitiveOverride)&quot;)
    public void doAfter(JoinPoint joinPoint, ResponseSensitiveOverride sensitiveOverride) throws Exception {
        //获取方法的参数名和参数值
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        List&amp;lt;String&amp;gt; paramNameList = Arrays.asList(methodSignature.getParameterNames());
        List&amp;lt;Object&amp;gt; paramList = Arrays.asList(joinPoint.getArgs());

        //将方法的参数名和参数值一一对应的放入上下文中
        EvaluationContext ctx = new StandardEvaluationContext();
        for (int i = 0; i &amp;lt; paramNameList.size(); i++) {
            ctx.setVariable(paramNameList.get(i), paramList.get(i));
        }

        // 解析SpEL表达式获取结果
        String value = spelParser.parseExpression(sensitiveOverride.key()).getValue(ctx).toString();
        //获取 sensitiveOverride 这个代理实例所持有的 InvocationHandler
        InvocationHandler invocationHandler = Proxy.getInvocationHandler(sensitiveOverride);
        // 获取 invocationHandler 的 memberValues 字段
        Field hField = invocationHandler.getClass().getDeclaredField(&quot;memberValues&quot;);
        // 因为这个字段是 private final 修饰，所以要打开权限
        hField.setAccessible(true);
        // 获取 memberValues
        Map memberValues = (Map) hField.get(invocationHandler);
        // 修改 value 属性值
        memberValues.put(&quot;userType&quot;, Integer.parseInt(value));

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，我们就实现了为注解动态赋值。&lt;/p&gt;
&lt;h2 id=&quot;三responsebodyadvice-处理数据&quot;&gt;三、ResponseBodyAdvice 处理数据&lt;/h2&gt;
&lt;p&gt;现在要做的事情就是在 ResponseBody 数据返回前，对数据进行拦截，然后读取注解上的权限参数，从而对数据进行处理，这里使用的是 SpringMVC 的 ResponseBodyAdvice 来实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@RestControllerAdvice
@Order(-1)
public class ResponseBodyAdvice implements org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice {

    private static final ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;() {
        @Override
        protected Integer initialValue() {
            return SysUserDto.USER_TYPE_PRIMARY;
        }
    };

    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        if (returnType.hasMethodAnnotation(ResponseSensitiveOverride.class)) {
            ResponseSensitiveOverride sensitiveOverride = returnType.getMethodAnnotation(ResponseSensitiveOverride.class);
            threadLocal.set(sensitiveOverride.userType());
            return true;
        }
        return false;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        if (body != null &amp;amp;&amp;amp; SysUserDto.USER_TYPE_SUB.equals(threadLocal.get())) {
            // 业务处理
        }
        return body;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题外话，其实我最后还是摈弃了这个方案，选择了 Dubbo 过滤器的处理方式，为什么呢？因为在做数据导出的时候，这种方式没办法对二进制流进行处理呀！汗~ 但是该方案毕竟耗费了我一个下午的心血，还是在此记录一下，可能有它更好的适用场景！&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:47:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>一、自定义注解 先聊聊这个需求，我需要根据用户的权限对数据进行一些处理，但是痛点在哪里呢？用户的权限是在请求的时候知道的，我怎么把用户的权限传递给处理规则呢？想了以下几种方案： 1. Mybatis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jmcui/p/11890384.html</dc:identifier>
</item>
<item>
<title>碎片化的时代，如何学习 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11895483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11895483.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191120084410946-1409173595.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天周末，和大家聊聊学习这件事情。&lt;/p&gt;
&lt;p&gt;在如今这个社会，我们的时间被各类 APP 撕的粉碎。&lt;/p&gt;
&lt;p&gt;刷知乎、刷微博、刷朋友圈；&lt;/p&gt;
&lt;p&gt;看论坛、看博客、看公号；&lt;/p&gt;
&lt;p&gt;等等形形色色的信息和知识获取方式一个都不错过。&lt;/p&gt;
&lt;p&gt;貌似学了很多，但是却感觉没什么用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要解决上面这些问题，首先要分清楚一点，什么是信息，什么是知识。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那什么是信息呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你一切听到的、看到的，都是信息，比如微博上的明星出轨、微信中的表情大战、抖音上的段子视频。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那什么是知识呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就是指那些被验证过的、正确的、被人们相信的概念、规律、方法论。&lt;/p&gt;
&lt;p&gt;概念是什么很好理解，我们上学的时候做的最多的一件事情就是背概念。&lt;/p&gt;
&lt;p&gt;规律是事物背后的运行法则，例如当市场上某一种货物供应量减少后，就会导致价格的上升。&lt;/p&gt;
&lt;p&gt;方法论俗称【套路】，解决某一类问题的时候，有效的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息有真假，有时效，而知识有积累、有迭代。我们要学习的是知识，而不是信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;时间复利&quot;&gt;时间复利&lt;/h2&gt;
&lt;p&gt;再说一个概念，&lt;strong&gt;复利&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个大家都应该知道，比较多的应该是在银行存钱或者是购买理财产品的时候，比如下图的银行复利增长曲线：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191120084411361-1308758930.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者是下面这个公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.01^365 = 37.8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随公式还附赠一句鸡汤：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一个人每天都能进步 1%，一年之后他的能力会提升 38 倍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话虽然听起来很鸡汤，但是却想不到有什么问题，对吧？&lt;/p&gt;
&lt;p&gt;反过来想一下这句话的前提，一个人都想要每天都能进步 1% ，这可能么？当然排除一些极端情况，对于看到我文章的大多数人来说，这是一件不可能的事情。&lt;/p&gt;
&lt;p&gt;每天会形形色色的事情去阻止我们进步这 1% ，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;今天上班被领导批了，心情不好，不想学习了&lt;/li&gt;
&lt;li&gt;今天工作太忙了，下班后时间都比较晚了，想要休息了&lt;/li&gt;
&lt;li&gt;今天和朋友一起出去玩了，玩的很开心&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等，然后我们看到身边优秀的人的时候：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;看到他们随随便便就考试考出来好成绩&lt;/li&gt;
&lt;li&gt;看到他们随手写的文章就是网络爆文&lt;/li&gt;
&lt;li&gt;看到他们对于某一项技术非常精通的时候&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是不是会有一种无力感，好像他们平时和我们一样，该吃吃该喝喝该玩玩，但是人家就是很厉害的样子。&lt;/p&gt;
&lt;p&gt;于是，就产生了强烈的焦虑感，要学习，要提高自己，开始看更多的信息，关注更多的学习圈子，焦虑感加重，负向循环开始了。&lt;/p&gt;
&lt;p&gt;但是，如果你肯相信&lt;strong&gt;时间复利&lt;/strong&gt;的效应，就不会焦虑。&lt;/p&gt;
&lt;p&gt;Why？&lt;/p&gt;
&lt;p&gt;你现在看到身边的人的成绩，看到他轻轻松松做到的事情，即使你拼尽全力也不可能做到。&lt;/p&gt;
&lt;p&gt;从一开始你就错了，他们已经完成了自己的原始积累，他们已经到达了这件事情的&lt;strong&gt;复利拐点&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;什么是复利拐点？&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191120084411513-929666988.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中这个小人站的位置就是复利拐点，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一个人到达复利拐点（图中小人站的地方），那他的收益，会急剧增长，可能比之前所有时间的收益总和还要多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的收益可以是钱，是能力，是认知。&lt;/p&gt;
&lt;h2 id=&quot;知识&quot;&gt;知识&lt;/h2&gt;
&lt;p&gt;上面我们介绍了如何区分信息和知识，这里再分享一个个人理解，有效知识。&lt;/p&gt;
&lt;p&gt;判断一个知识是否有效，就要看这个知识和你之前的已有的知识是否能产生联系。&lt;/p&gt;
&lt;p&gt;如果可以产生联系，那么你对这个新的知识理解速度会非常的快。&lt;/p&gt;
&lt;p&gt;就好比编程语言，小编的本职工作是一名 Java 软件工程师，但是当小编去学习 Python 的相关基础知识的时候，速度是非常快的，用旁人的视角看起来就好像小编的学习效率非常的高效。&lt;/p&gt;
&lt;p&gt;当然，我们不可能只学习和自己已有知识相关方向的知识，可能会接触一些完全陌生的领域，那么这个时候如何还能保持效率较高的学习？&lt;/p&gt;
&lt;p&gt;在进入一个新的领域的时候，所有的知识都是一个点一个点的，好像是散落在沙子里的石头，中间是毫无关联的，这个时间段的学习是非常痛苦的，小编一般称为原始积累阶段。&lt;/p&gt;
&lt;p&gt;很多人在原始积累的阶段因为过程过于痛苦，就慢慢的放弃了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191120084411658-738825776.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在痛苦的原始积累阶段，很多时候看不到尽头，之前的学习感觉都学过，但是仔细一想，又好像什么都没学。&lt;/p&gt;
&lt;p&gt;这时，我们可以借助工具去加强知识之间的关联和加深自己的记忆——思维导图。&lt;/p&gt;
&lt;p&gt;这个工具小编也经常在用的，比如很多人可能都见过我的公众号上小编自己整理的 Java 进阶相关的思维导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191120084411842-959050844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当学习一个新的领域的时候，每当一些基础的概念能产生联系的时候，就可以去画这么一张思维导图，思维导图能让我们更清晰直观的理解不同的事物之间的内在联系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;长时间的原始积累太过痛苦怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是所有人都会遇到的问题，做一件事情，尤其是学习，当我们无法取得一些成果的时候，对兴趣和自信的打击都会非常的大。&lt;/p&gt;
&lt;p&gt;首先在做这件事情之前，你需要为自己找到足够开始这件事情的理由，也就是要有强大的内驱力。&lt;/p&gt;
&lt;p&gt;就好比考研这件事情，如果是身边的人要考，所以你也要考，那么我觉得你到底要不要考研这件事情值得再思考一下。&lt;/p&gt;
&lt;p&gt;但如果是说你想通过考研，来改变自己的人生轨迹，想要获得更高的起点，那么，我觉得这个事儿十有八九你是能坚持下去的。&lt;/p&gt;
&lt;p&gt;好比学习 Python ，好像身边的人都在学，那我也要了解一下，和那种我想要学 Python 来换一份工作，摆脱目前的工作状态，获取更高的薪水。&lt;/p&gt;
&lt;p&gt;大家可能看着没什么感觉，但是想一想，自己的人生中，到底有没有过坚持某一件事情，并最终获得了一个还不错的结果，最后收获的这份快感，是不是无与伦比的。&lt;/p&gt;
&lt;p&gt;当然，除了强大的内驱力以外，小编还可以友情提供一点小技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取阶段性的正向反馈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一件事情需要耗费较长的时间，那么再大的内驱力也可能会被时间的流逝给磨平了。&lt;/p&gt;
&lt;p&gt;静静思考下放弃的原因，没有获得成就感。&lt;/p&gt;
&lt;p&gt;还是拿考研举例子，一般考研需要准备大半年到一年左右的时间，很多人都坚持不过半年时间就放弃掉了，为什么，因为他们看不到成效，看不到曙光。但是高三的高考很多人还是能坚持下来的，为什么？&lt;/p&gt;
&lt;p&gt;因为高三有月考啊，每次月考完，都能准确的知道自己的水平提升了多少，自己一个月的努力是没有白费的，自己一个月的努力是真真实实的化成了卷子上的分数。&lt;/p&gt;
&lt;p&gt;所以，做一件需要长时间奋战的事情，最好能提前为自己设定一些阶段性的成果检验方式。&lt;/p&gt;
&lt;h2 id=&quot;时间管理&quot;&gt;时间管理&lt;/h2&gt;
&lt;p&gt;时间管理是一个绕不开的话题，这里小编其实也没资格谈这件事情，因为小编本身的时间管理也做的并不好，小编也是人，加完班也会感觉到累，回到家也会只想着休息，人非圣贤，对吧。&lt;/p&gt;
&lt;p&gt;还是分享一些经验吧。&lt;/p&gt;
&lt;p&gt;尝试将自己一天做的事情和耗费的时间列一个表格出来（小编之前列举过，时间有些久远，找不到了，这里就不放图了）。&lt;/p&gt;
&lt;p&gt;当这个表格列出来以后，不管多么自律的人，肯定会发现，一天之中，有相当部分的时间是被浪费掉的，比如刷朋友圈，刷抖音，刷微博。&lt;/p&gt;
&lt;p&gt;在生活中，肯定会经常性的出现这样事情。&lt;/p&gt;
&lt;p&gt;“再玩5分钟手机就睡觉！”&lt;/p&gt;
&lt;p&gt;结果12点了还在玩手机。&lt;/p&gt;
&lt;p&gt;周末早晨起来，“先玩一局游戏，在做xxx”。&lt;/p&gt;
&lt;p&gt;结果就是玩到了下午。&lt;/p&gt;
&lt;p&gt;相信我，那些堕落的人，并不是一开始就想堕落的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;他们只是在被生活中形形色色的诱惑给诱惑到了，因为现在的社会，各个 APP 在掏空了心思去抢占用户的留存时长，它们费劲心力的去讨好用户，让用户用最简单最不需要付出的方式去获得这种毫无意义的低成本的快乐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，开始记录自己的时间，是做时间管理的第一步。&lt;/p&gt;
&lt;p&gt;当然，并不是要我们完全的放弃娱乐时间，这不可能，人不是机器，不可能是只要有电，就能工作，人也是需要休息的，记录时间只是为了让我们在面临选择的时候，做出正确的选择。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;第一次写这种长篇内容分享，有内容不当的地方请各位同学海涵。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>今天周末，和大家聊聊学习这件事情。 在如今这个社会，我们的时间被各类 APP 撕的粉碎。 刷知乎、刷微博、刷朋友圈； 看论坛、看博客、看公号； 等等形形色色的信息和知识获取方式一个都不错过。 貌似学了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11895483.html</dc:identifier>
</item>
<item>
<title>Asciinema文章勘误及Web端使用介绍 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/11895454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/11895454.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欠下的债迟早是要还的，查文档，重验证，出结果，不误导&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文章勘误&quot;&gt;文章勘误&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/oqZqGiQ3uNrNuT-nGrh9lg&quot;&gt;Asciinema：你的所有操作都将被录制&lt;/a&gt;中有两个地方表述有错误或瑕疵，这里更正一下&lt;/p&gt;
&lt;p&gt;第一个地方为录制时的参数&lt;code&gt;--stdin&lt;/code&gt;，参数的意思是启用标准输入录制，原文中说看不到效果，可能官方还未支持，实际上官方已经支持了，且查看录制文件内容时可以看到区别，以下两个对比的例子来说明&lt;/p&gt;
&lt;p&gt;例一：执行下方的命令进行录制，录制开始之后执行ssh命令输入密码连接另一台主机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;asciinema rec ops-coffee.cast&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;asciinema cat&lt;/code&gt;命令查看执行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# asciinema cat ops-coffee.cast 
root@onlinegame:~# ssh root@192.168.106.192 ls ops-coffee.cn
root@192.168.106.192's password: 
ops-coffee.cn
root@onlinegame:~# exit
exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印录制的文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat ops-coffee.cast 
{&quot;version&quot;: 2, &quot;width&quot;: 237, &quot;height&quot;: 55, &quot;timestamp&quot;: 1574060513, &quot;env&quot;: {&quot;SHELL&quot;: &quot;/bin/bash&quot;, &quot;TERM&quot;: &quot;linux&quot;}}
[0.012221, &quot;o&quot;, &quot;root@onlinegame:~# &quot;]
[0.607184, &quot;o&quot;, &quot;exit&quot;]
[1.07092, &quot;o&quot;, &quot;\b\b\b\bssh root@192.168.106.192 ls ops-coffee.cn&quot;]
[1.703405, &quot;o&quot;, &quot;\r\n&quot;]
[1.762974, &quot;o&quot;, &quot;root@192.168.106.192's password: &quot;]
[4.550759, &quot;o&quot;, &quot;\r\n&quot;]
[4.558138, &quot;o&quot;, &quot;ops-coffee.cn\r\n&quot;]
[4.559187, &quot;o&quot;, &quot;root@onlinegame:~# &quot;]
[5.182817, &quot;o&quot;, &quot;e&quot;]
[5.582643, &quot;o&quot;, &quot;x&quot;]
[5.838648, &quot;o&quot;, &quot;i&quot;]
[6.03067, &quot;o&quot;, &quot;t&quot;]
[6.759346, &quot;o&quot;, &quot;\r\nexit\r\n&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例二：执行同样的命令，加上&lt;code&gt;--stdin&lt;/code&gt;参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;asciinema rec --stdin ops-coffee.1.cast&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;asciinema cat&lt;/code&gt;命令查看执行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# asciinema cat ops-coffee.1.cast 
root@onlinegame:~# ssh root@192.168.106.192 ls ops-coffee.cn
root@192.168.106.192's password: 
ops-coffee.cn
root@onlinegame:~# exit
exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次再看录制文件的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat ops-coffee.1.cast
{&quot;version&quot;: 2, &quot;width&quot;: 237, &quot;height&quot;: 55, &quot;timestamp&quot;: 1574060808, &quot;env&quot;: {&quot;SHELL&quot;: &quot;/bin/bash&quot;, &quot;TERM&quot;: &quot;linux&quot;}}
[0.01012, &quot;o&quot;, &quot;root@onlinegame:~# &quot;]
[1.654752, &quot;i&quot;, &quot;\u001b[A&quot;]
[1.654971, &quot;o&quot;, &quot;exit&quot;]
[2.014568, &quot;i&quot;, &quot;\u001b[A&quot;]
[2.014727, &quot;o&quot;, &quot;\b\b\b\bssh root@192.168.106.192 ls ops-coffee.cn&quot;]
[3.7185, &quot;i&quot;, &quot;\r&quot;]
[3.719167, &quot;o&quot;, &quot;\r\n&quot;]
[3.781231, &quot;o&quot;, &quot;root@192.168.106.192's password: &quot;]
[5.198467, &quot;i&quot;, &quot;s&quot;]
[5.542343, &quot;i&quot;, &quot;m&quot;]
[5.774451, &quot;i&quot;, &quot;i&quot;]
[5.85435, &quot;i&quot;, &quot;l&quot;]
[5.990628, &quot;i&quot;, &quot;e&quot;]
[6.342587, &quot;i&quot;, &quot;\r&quot;]
[6.342817, &quot;o&quot;, &quot;\r\n&quot;]
[6.351245, &quot;o&quot;, &quot;ops-coffee.cn\r\n&quot;]
[6.351475, &quot;o&quot;, &quot;root@onlinegame:~# &quot;]
[7.182384, &quot;i&quot;, &quot;e&quot;]
[7.182585, &quot;o&quot;, &quot;e&quot;]
[7.461976, &quot;i&quot;, &quot;x&quot;]
[7.462183, &quot;o&quot;, &quot;x&quot;]
[7.543019, &quot;i&quot;, &quot;i&quot;]
[7.543306, &quot;o&quot;, &quot;i&quot;]
[7.686868, &quot;i&quot;, &quot;t&quot;]
[7.68703, &quot;o&quot;, &quot;t&quot;]
[7.87045, &quot;i&quot;, &quot;\r&quot;]
[7.871348, &quot;o&quot;, &quot;\r\nexit\r\n&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现在实际执行命令完全一致的情况下，录像文件与上一个没有加&lt;code&gt;--stdin&lt;/code&gt;时的不一样，其中就多了输入密码的记录&lt;code&gt;smile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;且在asciinema文件IO流信息的第二个字段不仅有了&lt;code&gt;o&lt;/code&gt;，还有&lt;code&gt;i&lt;/code&gt;的出现，上一篇文章讲到&lt;code&gt;o&lt;/code&gt;是一个固定字符串不知道作用，经过深入查询确认，IO信息流的第二个字段就是固定string字符串，且只会是&lt;code&gt;i&lt;/code&gt;或&lt;code&gt;o&lt;/code&gt;之间的一种，分别表示&lt;code&gt;stdin&lt;/code&gt;标准输入或&lt;code&gt;stdout&lt;/code&gt;标准输出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--stdin&lt;/code&gt;的效果无论是通过&lt;code&gt;asciinema play&lt;/code&gt;命令播放或是&lt;code&gt;asciinema cat&lt;/code&gt;命令查看都是无法察觉的，在实现WebSSH录像回放时又对录像文件进行了深入研究，最终发现问题，这里查漏补缺，予以更正，对于之前的错误，深表歉意&lt;/p&gt;
&lt;h2 id=&quot;web端使用&quot;&gt;Web端使用&lt;/h2&gt;
&lt;p&gt;asciinema录制文件在web端播放是通过&lt;code&gt;asciinema-player&lt;/code&gt;组件来实现的，使用也是非常的简单&lt;/p&gt;
&lt;p&gt;分别引入css和js文件，添加一个&lt;code&gt;asciinema-player&lt;/code&gt;的标签即可播放标签内文件的录像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  ...
  &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/asciinema-player.css&quot; /&amp;gt;
  ...
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  ...
  &amp;lt;asciinema-player src=&quot;/ops-coffee.cast&quot;&amp;gt;&amp;lt;/asciinema-player&amp;gt;
  ...
  &amp;lt;script src=&quot;/asciinema-player.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;asciinema-player标签内可以添加如下一些属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cols：&lt;/strong&gt; 播放终端的列数，默认为80，如果cast文件的header头有设置&lt;code&gt;width&lt;/code&gt;，这里无需设置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rows：&lt;/strong&gt; 播放终端的行数，默认为24，如果cast文件的header头有设置&lt;code&gt;height&lt;/code&gt;，这里无需设置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;autoplay：&lt;/strong&gt; 是否自动开始播放，默认不会自动播放&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;preload：&lt;/strong&gt; 预加载，如果你想为录像配音，这里可以预加载声音&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;loop：&lt;/strong&gt; 是否循环播放，默认不循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;start-at：&lt;/strong&gt; 从哪个地方开始播放，可以是&lt;code&gt;123&lt;/code&gt;这样的秒数或者是&lt;code&gt;1:06&lt;/code&gt;这样的时间点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;speed：&lt;/strong&gt; 播放的速度，类似于play命令播放时的&lt;code&gt;-s&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;idle-time-limit：&lt;/strong&gt; 最大空闲秒数，类似于play命令播放时的&lt;code&gt;-i&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;poster：&lt;/strong&gt; 播放之前的预览，可以是&lt;code&gt;npt:1:06&lt;/code&gt;这样给定时间点的画面，也可以是&lt;code&gt;data:text/plain,ops-coffee.cn&lt;/code&gt;这样给定的文字，其中文字支持ANSI编码，例如可以给文字加上颜色&lt;code&gt;data:text/plain,\x1b[1;32mops-coffee.cn\x1b[1;0m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;font-size：&lt;/strong&gt; 文字大小，可以是&lt;code&gt;small&lt;/code&gt;、&lt;code&gt;medium&lt;/code&gt;、&lt;code&gt;big&lt;/code&gt;或者直接是&lt;code&gt;14px&lt;/code&gt;这样的css样式大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;theme：&lt;/strong&gt; 终端颜色主题，默认是&lt;code&gt;asciinema&lt;/code&gt;，也提供有&lt;code&gt;tango&lt;/code&gt;、&lt;code&gt;solarized-dark&lt;/code&gt;、&lt;code&gt;solarized-light&lt;/code&gt;或者&lt;code&gt;monokai&lt;/code&gt;可选择，当然你也可以自定义主题&lt;/p&gt;
&lt;p&gt;还有几个参数&lt;strong&gt;title&lt;/strong&gt;、&lt;strong&gt;author&lt;/strong&gt;、&lt;strong&gt;author-url&lt;/strong&gt;、&lt;strong&gt;author-img-url&lt;/strong&gt;分别表示了录像的标题、作者、作者的主页、作者的头像，这些配置会在全屏观看录像时显示在标题栏中，像下边这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20191118.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后使用以下参数设置asciinema-player，看看播放的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;asciinema-player id=&quot;play&quot; 
    title=&quot;WebSSH Record&quot; 
    author=&quot;ops-coffee.cn&quot; 
    author-url=&quot;https://ops-coffee.cn&quot; 
    author-img-url=&quot;/static/img/logo.png&quot; 
    src=&quot;/static/record/ops-coffee.cast&quot; 
    speed=&quot;3&quot; idle-time-limit=&quot;2&quot; 
    poster=&quot;data:text/plain,\x1b[1;32m2019-11-18 16:26:18\x1b[1;0m用户\x1b[1;32madmin\x1b[1;0m连接主机\x1b[1;32m192.168.106.101:22\x1b[1;0m的录像记录&quot;&amp;gt;
&amp;lt;/asciinema-player&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;播放效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20191118.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时asciinema-player播放时还支持以下快捷键的使用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;space&lt;/code&gt; 空格，播放或暂停&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; 全屏播放，可以看到title等设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;←&lt;/code&gt; / &lt;code&gt;→&lt;/code&gt; 快进或快退，每次5秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0，1，6 ... 9&lt;/code&gt; 跳转到录像的0%，10%，60% ... 90%&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;gt;&lt;/code&gt; 增加或降低播放速度，play的&lt;code&gt;-s&lt;/code&gt;参数&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.png&quot; alt=&quot;扫码关注公众号查看更多实用文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章推荐阅读：&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:22:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>欠下的债迟早是要还的，查文档，重验证，出结果，不误导 文章勘误 在上一篇文章 'Asciinema：你的所有操作都将被录制' 中有两个地方表述有错误或瑕疵，这里更正一下 第一个地方为录制时的参数 ，参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/11895454.html</dc:identifier>
</item>
<item>
<title>Head First设计模式——命令模式 - Spring2Sun</title>
<link>http://www.cnblogs.com/SunSpring/p/11894963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunSpring/p/11894963.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;命令模式我们平常可能会经常使用，如果我们不了解命令模式的结构和定义那么在使用的时候也不会将它对号入座。&lt;/p&gt;
&lt;p&gt;举个例子：在winform开发的时候我们常常要用同一个界面来进行文件的下载，但是并不是所有地方都用同一个下载逻辑处理文件，然后下载界面却可以是同一个界面。&lt;/p&gt;
&lt;p&gt;为了以后复用下载界面（下载显示，进度条等）我们常常将下载执行操作定义成一个接口，在具体使用的时候实现接口，将具体执行对象设置到下载界面。当下载按钮被按下的时候，就调用设置的具体执行对象（接收者）来执行下载的处理。&lt;/p&gt;
&lt;p&gt;那接下来我们就看下命令模式的具体细节和实现，再回头想想我们平时什么时候不经意就使用到了命令模式，这样以后交流使用专业的术语不仅能装还能用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1、遥控器应用场景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HeadFirst设计模式一书中以遥控器为例实现命令模式，以餐馆点餐讲解命令模式的对象和结构。为了逻辑清晰我们不混合两种讲解方式，只以遥控器为例讲解。&lt;/p&gt;
&lt;p&gt;现在需求是有一个遥控器，遥控器上面有控制各种电器的开关，而开关的执行控制电器是由各个厂家开发的设备(对象)插入到对应开关位置的卡槽里面，基于这些条件我们来实现遥控器系统。&lt;/p&gt;
&lt;p&gt;简单粗暴的解决方案可以对开关做一个标识，当某个开关被按下时根据开关类型进行if判断。形如 if slot1==Light ,then light.on(), else if slot1==Tv then tv.on() 这种代码将出现一堆，对于以后增加减少开关或者更换开关都是比较糟糕的。而对于设计遥控器类来说我们应该让遥控器代码尽量保持简单，而不用去关心具体厂商类怎么执行。所以我们应该将执行封装在一个命令对象里中，那么我们就试着一步步实现遥控器。&lt;/p&gt;
&lt;p&gt;　　首先我们为命令对象定义一个统一的接。&lt;/p&gt;
&lt;p&gt;　　接口只有一个简单的execute执行命令方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public interface Command
    {
        //执行命令的方法
        public void execute();
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们实现一个打开电灯的命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class Light
    {
        public void on() {
            Console.WriteLine(&quot;打开电灯&quot;);
        }

        public void off()
        {
            Console.WriteLine(&quot;关闭电灯&quot;);
        }
    }

    public class LightOnCommand : Command
    {
        Light light;

        public LightOnCommand(Light light)
        {
            this.light = light;
        }
        public void execute()
        {
            light.on();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了简单我们假设遥控器只有一个开关，实现遥控器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class SimpleRemoteControl
    {
        //卡槽
        Command slot;

        public void setCommand(Command command)
        {
            slot = command;
        }

        //按下开关
        public void ButtonWasPressed() {
            slot.execute();
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
     static void Main(string[] args)
        {
            SimpleRemoteControl remoteControl = new SimpleRemoteControl();
            //厂商提供的电灯类，命令的接收者
            Light light = new Light();

            //我们封装的命令对象，设置接收者
            LightOnCommand lightOnCommand = new LightOnCommand(light);

            //设置遥控器开关对应的命令对象
            remoteControl.setCommand(lightOnCommand);
            remoteControl.ButtonWasPressed();
            Console.ReadKey();
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/993045/201911/993045-20191120011334930-1469719782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2、命令模式、类图&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的例子我们已经使用了命令模式来实现一个简单的遥控器，再回顾【前言】我们说的界面下载文件按钮操作是不是就是一个典型的可以使用命令模式的应用场景。&lt;/p&gt;
&lt;p&gt;只是有一点我们可能不会有什么其他厂商设计好的执行类，我们也许直接就在继承接口的命令对象中实现execute的逻辑，而不用再调用其他接收者执行。&lt;/p&gt;
&lt;p&gt;这就是“聪明”命令对象，上面我们实现的是“傻瓜”命令对象。这个稍后再说，我们先看命令模式定义和画出类图。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令模式：将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持撤销的操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993045/201911/993045-20191120013321529-1296789051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3、完成多开关遥控器和撤销操作&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;假设遥控器现在有五个开关。我们已经有简单遥控器的经验，那么其他4个开关我们也将对应的命令对象设置上去就行了。定义两个数组用来记录开关对应的命令对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class RemoteControl
    {
        Command[] onCommands;
        Command[] offCommands;
        public RemoteControl()
        {
            onCommands = new Command[5];
            offCommands = new Command[5];
            Command noCommand = new NoCommand();
            for (int i = 0; i &amp;lt; 5; i++)
            {
                onCommands[i] = noCommand;
                offCommands[i] = noCommand;
            }
        }
        public void setCommand(int slot,Command commandOn, Command commandOff)
        {
            onCommands[slot] = commandOn;
            offCommands[slot] = commandOff;
        }

        //按下开关
        public void OnButtonWasPressed(int slot)
        {
            onCommands[slot].execute();
        }
        //关闭开关
        public void OffButtonWasPressed(int slot)
        {
            offCommands[slot].execute();
        }

        //打印出数组命令对象
        public override string ToString() {
            var sb = new StringBuilder(&quot;\n------------Remote Control-----------\n&quot;);
            for (int i = 0; i &amp;lt; onCommands.Length; i++)
            {
                sb.Append($&quot;[slot{i}] {onCommands[i].GetType()}\t{offCommands[i].GetType()} \n&quot;);
            }
            return sb.ToString();
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在遥控器中我们定义了一个Nocommand类，是为了对遥控器对应的开关初始化命令对象，避免为空报错或者消除开关调用命令对象时检查对象是否为空的判断。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
     public void OnButtonWasPressed(int slot)
        {
            if(onCommand[slot]!=null))
                onCommands[slot].execute();
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在许多设计模式中我们都能看到这种初始值或者空对象的使用。甚至有时候，空对象本身也被视为一种设计模式。(感觉这样代码比较优雅O(∩_∩)O)&lt;/p&gt;
&lt;p&gt;遥控器完成了，我们还有做一项工作，就是撤销操作。&lt;/p&gt;
&lt;p&gt;撤销操作我们同样在命令接口里面定义一个undo 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public interface Command
    {
        //执行命令的方法
        public void execute();
        //撤销命令方法
        public void undo();
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们让LightOnCommand实现undo方法，添加LightOffCommand命令对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class LightOnCommand : Command
    {
        Light light;

        public LightOnCommand(Light light)
        {
            this.light = light;
        }
        public void execute()
        {
            light.on();
        }
        public void undo() {
            light.off();
        }
    }


    class LightOffCommand : Command
    {
        Light light;

        public LightOffCommand(Light light)
        {
            this.light = light;
        }
        public void execute()
        {
            light.off();
        }

        public void undo()
        {
            light.on();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 遥控器里面添加撤销按钮操作UndoButtonWasPressed并用undoCommand属性存储上一次操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class RemoteControl
    {
        Command[] onCommands;
        Command[] offCommands;
        Command undoCommand;
        public RemoteControl()
        {
            onCommands = new Command[5];
            offCommands = new Command[5];
            Command noCommand = new NoCommand();
            for (int i = 0; i &amp;lt; 5; i++)
            {
                onCommands[i] = noCommand;
                offCommands[i] = noCommand;
            }
        }
        public void setCommand(int slot,Command commandOn, Command commandOff)
        {
            onCommands[slot] = commandOn;
            offCommands[slot] = commandOff;
        }

        //按下开关
        public void OnButtonWasPressed(int slot)
        {
            onCommands[slot].execute();
            undoCommand = onCommands[slot];
        }
        //关闭开关
        public void OffButtonWasPressed(int slot)
        {
            offCommands[slot].execute();
            undoCommand = offCommands[slot];
        }

        public void UndoButtonWasPressed() {
            undoCommand.undo();
        }
        //打印出数组命令对象
        public override string ToString() {
            var sb = new StringBuilder(&quot;\n------------Remote Control-----------\n&quot;);
            for (int i = 0; i &amp;lt; onCommands.Length; i++)
            {
                sb.Append($&quot;[slot{i}] {onCommands[i].GetType()}\t{offCommands[i].GetType()} \n&quot;);
            }
            return sb.ToString();
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993045/201911/993045-20191120023850710-1317501895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4、补充总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;①命令模式的接收者不一定要存在，之前提到过“聪明”和“傻瓜”命令对象，如果以“聪明”命令对象设计，调用者和接收者之间解耦程度比不上“傻瓜”命令对象，但是我们在使用比较简单的时候仍然可以使用“聪明”命令对象设计。&lt;/p&gt;
&lt;p&gt;②撤销例子我们只做了返回最后一次操作，如果要撤销许多次我们可以对操作记录进行保存到堆栈，不管什么时候撤销，我们都可以从堆栈中取出最上层命令对象执行撤销操作。&lt;/p&gt;
&lt;p&gt;命令模式常被用于队列请求，日志请求。当队列按照顺序取到存放的命令对象后调用执行方法就行了而不用去管具体执行什么。&lt;/p&gt;
&lt;p&gt;日志请求在某些场合可以用来将所有动作记录在日志中，并能在系统死机后通过日志记录进行恢复到之前的状态（撤销）。对于更高级的的应用而言，这些技巧可以应用到事务（transaction）处理中。&lt;/p&gt;
&lt;p&gt; 通过简单到更进一步的实现讲解了命令模式和一些灵活点和需要注意的点，有什么理解不到位的欢迎指正。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:13:00 +0000</pubDate>
<dc:creator>Spring2Sun</dc:creator>
<og:description>前言：命令模式我们平常可能会经常使用，如果我们不了解命令模式的结构和定义那么在使用的时候也不会将它对号入座。 举个例子：在winform开发的时候我们常常要用同一个界面来进行文件的下载，但是并不是所有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SunSpring/p/11894963.html</dc:identifier>
</item>
<item>
<title>【从今天开始好好学数据结构04】程序员你心中就没点“树”吗？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11895445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11895445.html</guid>
<description>&lt;p&gt;前面我们讲的都是线性表结构，栈、队列等等。今天我们讲一种非线性表结构，树。树这种数据结构比线性表的数据结构要复杂得多，内容也比较多，首先我们先从树（Tree）开始讲起。&lt;br/&gt;@&lt;/p&gt;
&lt;h2 id=&quot;树tree&quot;&gt;树(Tree)&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;树型结构是一种非线性结构，它的数据元素之间呈现分支、分层的特点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;树的定义&quot;&gt;1.树的定义&lt;/h6&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;树(Tree)是由n(n≥0)个结点构成的有限集合T，当n=0时T称为空树；否则，在任一非空树T中：&lt;br/&gt;(1)有且仅有一个特定的结点，它没有前驱结点，称其为根(Root)结点；&lt;br/&gt;(2)剩下的结点可分为m(m≥0)个互不相交的子集T1，T2，…，Tm，其中每个子集本身又是一棵树，并称其为根的子树(Subtree)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;strong&gt;树的定义具有递归性&lt;/strong&gt;，即“树中还有树”。树的递归定义揭示出了树的固有特性&lt;/p&gt;
&lt;h6 id=&quot;什么是树结构&quot;&gt;2.什么是树结构&lt;/h6&gt;
&lt;p&gt;什么是“树”？再好的定义，都没有图解来的直观。所以我在图中画了几棵“树”。你来看看，这些“树”都有什么特征？&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f562b80906?w=1728&amp;amp;h=567&amp;amp;f=png&amp;amp;s=86024&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;你有没有发现，“树”这种数据结构真的很像我们现实生活中的“树”&lt;/p&gt;
&lt;h6 id=&quot;为什么使用树结构&quot;&gt;3.为什么使用树结构&lt;/h6&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在有序数组中，可以快速找到特定的值，但是想在有序数组中插入一个新的数据项，就必须首先找出新数据项插入的位置，然后将比新数据项大的数据项向后移动一位，来给新的数据项腾出空间，删除同理，这样移动很费时。显而易见，如果要做很多的插入和删除操作和删除操作，就不该选用有序数组。另一方面，链表中可以快速添加和删除某个数据项，但是在链表中查找数据项可不容易，必须从头开始访问链表的每一个数据项，直到找到该数据项为止，这个过程很慢。 &lt;span&gt;树这种数据结构，既能像链表那样快速的插入和删除，又能想有序数组那样快速查找&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;树的常用术语&quot;&gt;4.树的常用术语&lt;/h6&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;结点——包含一个数据元素和若干指向其子树的分支&lt;br/&gt;度——结点拥有的子树个数&lt;br/&gt;树的度——该树中结点的最大度数&lt;br/&gt;叶子——度为零的结点&lt;br/&gt;分支结点（非终端结点）——度不为零的结点&lt;br/&gt;孩子和双亲——结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲&lt;br/&gt;兄弟——同一个双亲的孩子&lt;br/&gt;祖先和子孙——从根到该结点所经分支上的所有结点。相应地，以某一结点为根的子树中的任一结点称为该结点的子孙。&lt;br/&gt;结点的层次——结点的层次从根开始定义，根结点的层次为1，其孩子结点的层次为2，……&lt;br/&gt;堂兄弟——双亲在同一层的结点&lt;br/&gt;树的深度——树中结点的最大层次&lt;br/&gt;有序树和无序树——如果将树中每个结点的各子树看成是从左到右有次序的(即位置不能互换)，则称该树为有序树；否则称为无序树。&lt;br/&gt;森林——m(m≥0)棵互不相交的树的有限集合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f562cde6f3?w=1920&amp;amp;h=1042&amp;amp;f=png&amp;amp;s=324770&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;到这里，树就讲的差不多了，接下来讲讲二叉树（Binary Tree）&lt;/p&gt;
&lt;h2 id=&quot;二叉树binary-tree&quot;&gt;二叉树(Binary Tree）&lt;/h2&gt;
&lt;p&gt;树结构多种多样，不过我们最常用还是二叉树，我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。&lt;/p&gt;
&lt;h6 id=&quot;二叉树的定义和特点&quot;&gt;1．二叉树的定义和特点&lt;/h6&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;二叉树的定义：&lt;br/&gt;二叉树(Binary Tree)是n(n≥0)个结点的有限集合BT，它或者是空集，或者由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树组成 。&lt;br/&gt;————————————&lt;br/&gt;二叉树的特点：&lt;br/&gt;每个结点至多有二棵子树(即不存在度大于2的结点)；二叉树的子树有左、右之分，且其次序不能任意颠倒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;几种特殊形式的二叉树&quot;&gt;2．几种特殊形式的二叉树&lt;/h6&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、&lt;span&gt;满二叉树&lt;/span&gt;：&lt;br/&gt;定义：深度为k且有2k-1个结点的二叉树，称为满二叉树。&lt;br/&gt;特点：每一层上的结点数都是最大结点数&lt;br/&gt;2、&lt;span&gt;完全二叉树&lt;/span&gt;：&lt;br/&gt;定义：&lt;br/&gt;深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树&lt;br/&gt;特点:&lt;br/&gt;特点一 : 叶子结点只可能在层次最大的两层上出现;&lt;br/&gt;特点二 : 对任一结点，若其右分支下子孙的最大层次为l，则其左分支下子孙的最大层次必为l 或l+1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;建议看图对应文字综合理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f562740615?w=1870&amp;amp;h=869&amp;amp;f=png&amp;amp;s=292612&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码创建二叉树&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;首先，创建一个节点Node类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 节（结）点类 
 */
public class Node {
    //节点的权
    int value;
    //左儿子（左节点）
    Node leftNode;
    //右儿子（右节点）
    Node rightNode;
    //构造函数，初始化的时候就给二叉树赋上权值
    public Node(int value) {
        this.value=value;
    }
    
    //设置左儿子（左节点）
    public void setLeftNode(Node leftNode) {
        this.leftNode = leftNode;
    }
    //设置右儿子（右节点）
    public void setRightNode(Node rightNode) {
        this.rightNode = rightNode;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着创建一个二叉树BinaryTree 类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 二叉树Class
 */
public class BinaryTree {
    //根节点root
    Node root;
    
    //设置根节点
    public void setRoot(Node root) {
        this.root = root;
    }
    
    //获取根节点
    public Node getRoot() {
        return root;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后创建TestBinaryTree 类（该类主要是main方法用来测试）来创建一个二叉树&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
public class TestBinaryTree {

    public static void main(String[] args) {
        //创建一颗树
        BinaryTree binTree = new BinaryTree();
        //创建一个根节点
        Node root = new Node(1);
        //把根节点赋给树
        binTree.setRoot(root);
        //创建一个左节点
        Node rootL = new Node(2);
        //把新创建的节点设置为根节点的子节点
        root.setLeftNode(rootL);
        //创建一个右节点
        Node rootR = new Node(3);
        //把新创建的节点设置为根节点的子节点
        root.setRightNode(rootR);
        //为第二层的左节点创建两个子节点
        rootL.setLeftNode(new Node(4));
        rootL.setRightNode(new Node(5));
        //为第二层的右节点创建两个子节点
        rootR.setLeftNode(new Node(6));
        rootR.setRightNode(new Node(7));
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下面将会讲的遍历、查找节点、删除节点都将围绕这三个类开展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不难看出创建好的二叉树如下（画的不好，还望各位见谅）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f562c60b0d?w=1145&amp;amp;h=534&amp;amp;f=png&amp;amp;s=45665&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;二叉树的两种存储方式&quot;&gt;3．二叉树的两种存储方式&lt;/h6&gt;
&lt;p&gt;二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间，所以链式存储更合适。&lt;/p&gt;
&lt;p&gt;我们先来看比较简单、直观的&lt;strong&gt;链式存储法&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f562d13ce8?w=862&amp;amp;h=544&amp;amp;f=png&amp;amp;s=108317&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;接着是基于&lt;strong&gt;数组的顺序存储法&lt;/strong&gt;（该例子是一棵完全二叉树）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f58b742c94?w=836&amp;amp;h=440&amp;amp;f=png&amp;amp;s=74107&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;上面例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为0的存储位置。如果是非完全二叉树，则会浪费比较多的数组存储空间，如下。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f5918e7f7b?w=818&amp;amp;h=417&amp;amp;f=png&amp;amp;s=75489&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f601b18466?w=972&amp;amp;h=499&amp;amp;f=png&amp;amp;s=110850&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;还记得堆和堆排序吗，堆其实就是一种完全二叉树，最常用的存储方式就是数组。&lt;/p&gt;
&lt;h6 id=&quot;二叉树的遍历&quot;&gt;4．二叉树的遍历&lt;/h6&gt;
&lt;p&gt;前面我讲了二叉树的基本定义和存储方法，现在我们来看二叉树中&lt;strong&gt;非常重要的操作&lt;/strong&gt;，二叉树的遍历。这也是非常常见的面试题。&lt;/p&gt;
&lt;p&gt;经典遍历的方法有三种，&lt;strong&gt;前序遍历&lt;/strong&gt;、&lt;strong&gt;中序遍历&lt;/strong&gt;和&lt;strong&gt;后序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。&lt;/p&gt;
&lt;p&gt;中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。&lt;/p&gt;
&lt;p&gt;后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f777f11a8f?w=1141&amp;amp;h=342&amp;amp;f=png&amp;amp;s=212255&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;我想，睿智的你已经想到了二叉树的前、中、后序遍历就是一个&lt;span&gt;递归的过程&lt;/span&gt;&lt;/strong&gt;。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。&lt;/p&gt;
&lt;p&gt;在之前创建好的二叉树代码之上，我们来使用这三种方法遍历一下~&lt;/p&gt;
&lt;p&gt;依旧是在Node节点类上添加方法：可以看出遍历方法都是用的&lt;span&gt;&lt;strong&gt;递归思想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 节（结）点类 
 */
public class Node {
//===================================开始 遍历========================================
    //前序遍历
    public void frontShow() {
        //先遍历当前节点的内容
        System.out.println(value);
        //左节点
        if(leftNode!=null) {
            leftNode.frontShow();
        }
        //右节点
        if(rightNode!=null) {
            rightNode.frontShow();
        }
    }

    //中序遍历
    public void midShow() {
        //左子节点
        if(leftNode!=null) {
            leftNode.midShow();
        }
        //当前节点
        System.out.println(value);
        //右子节点
        if(rightNode!=null) {
            rightNode.midShow();
        }
    }

    //后序遍历
    public void afterShow() {
        //左子节点
        if(leftNode!=null) {
            leftNode.afterShow();
        }
        //右子节点
        if(rightNode!=null) {
            rightNode.afterShow();
        }
        //当前节点
        System.out.println(value);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后依旧是在二叉树BinaryTree 类上添加方法，并且添加的方法调用Node类中的遍历方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 二叉树Class
 */
public class BinaryTree {

    public void frontShow() {
        if(root!=null) {
            //调用节点类Node中的前序遍历frontShow（）方法
            root.frontShow();
        }
    }

    public void midShow() {
        if(root!=null) {
            //调用节点类Node中的中序遍历midShow()方法
            root.midShow();
        }
    }

    public void afterShow() {
        if(root!=null) {
            //调用节点类Node中的后序遍历afterShow()方法
            root.afterShow();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依旧是在TestBinaryTree类中测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;

public class TestBinaryTree {

    public static void main(String[] args) {
        //前序遍历树
        binTree.frontShow();
        System.out.println(&quot;===============&quot;);
        //中序遍历
        binTree.midShow();
        System.out.println(&quot;===============&quot;);
        //后序遍历
        binTree.afterShow();
        System.out.println(&quot;===============&quot;);
        //前序查找
        Node result = binTree.frontSearch(5);
        System.out.println(result);
        
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果递归理解的不是很透，我可以分享一个学习的小方法：我建议各位可以这样&lt;strong&gt;断点调试&lt;/strong&gt;，一步一步调，思维跟上，仔细推敲每一步的运行&lt;span&gt;&lt;strong&gt;相信我，你会重新认识到递归&lt;/strong&gt;&lt;/span&gt;！（像下面这样贴个图再一步一步断点思维更加清晰）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f601c140cd?w=1862&amp;amp;h=976&amp;amp;f=png&amp;amp;s=220973&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;贴一下我断点对递归的分析，希望对你有一定的帮助~&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f60226e08b?w=1920&amp;amp;h=931&amp;amp;f=png&amp;amp;s=368560&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;二叉树遍历的&lt;strong&gt;递归实现&lt;/strong&gt;思路自然、简单，易于理解，但执行&lt;strong&gt;效率较低&lt;/strong&gt;。为了提高程序的执行效率，可以显式的设置栈，写出相应的&lt;strong&gt;非递归遍历算法&lt;/strong&gt;。非递归的遍历算法可以根据递归算法的执行过程写出。至于代码可以尝试去写一写，这也是一种提升！具体的非递归算法主要流程图贴在下面了：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e861f601dc7314?w=951&amp;amp;h=607&amp;amp;f=png&amp;amp;s=39329&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;二叉树遍历算法分析：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;二叉树遍历算法中的基本操作是访问根结点，不论按哪种次序遍历，都要访问所有的结点，对含n个结点的二叉树，其时间复杂度均为O（n）。所需辅助空间为遍历过程中所需的栈空间，最多等于二叉树的深度k乘以每个结点所需空间数，最坏情况下树的深度为结点的个数n，因此，其空间复杂度也为O(n)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;二叉树中节点的查找与删除&quot;&gt;5．二叉树中节点的查找与删除&lt;/h6&gt;
&lt;p&gt;刚才讲到二叉树的三种金典遍历放法，那么节点的查找同样是可以效仿的，分别叫做前序查找、中序查找以及后序查找，下面代码只以前序查找为例，三者查找方法思路类似~&lt;/p&gt;
&lt;p&gt;至于删除节点，有三种情况：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、如果删除的是根节点，那么二叉树就完全被删了&lt;br/&gt;2、如果删除的是双亲节点，那么该双亲节点以及他下面的所有子节点所构成的子树将被删除&lt;br/&gt;3、如果删除的是叶子节点，那么就直接删除该叶子节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，我把完整的三个类给贴出来（包含创建、遍历、查找、删除）&lt;/p&gt;
&lt;p&gt;依旧是Node节点类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 节（结）点类 
 */
public class Node {
    //节点的权
    int value;
    //左儿子
    Node leftNode;
    //右儿子
    Node rightNode;
    //构造函数，初始化的时候就给二叉树赋上权值
    public Node(int value) {
        this.value=value;
    }
    
    //设置左儿子
    public void setLeftNode(Node leftNode) {
        this.leftNode = leftNode;
    }
    //设置右儿子
    public void setRightNode(Node rightNode) {
        this.rightNode = rightNode;
    }
    
    //前序遍历
    public void frontShow() {
        //先遍历当前节点的内容
        System.out.println(value);
        //左节点
        if(leftNode!=null) {
            leftNode.frontShow();
        }
        //右节点
        if(rightNode!=null) {
            rightNode.frontShow();
        }
    }

    //中序遍历
    public void midShow() {
        //左子节点
        if(leftNode!=null) {
            leftNode.midShow();
        }
        //当前节点
        System.out.println(value);
        //右子节点
        if(rightNode!=null) {
            rightNode.midShow();
        }
    }

    //后序遍历
    public void afterShow() {
        //左子节点
        if(leftNode!=null) {
            leftNode.afterShow();
        }
        //右子节点
        if(rightNode!=null) {
            rightNode.afterShow();
        }
        //当前节点
        System.out.println(value);
    }

    //前序查找
    public Node frontSearch(int i) {
        Node target=null;
        //对比当前节点的值
        if(this.value==i) {
            return this;
        //当前节点的值不是要查找的节点
        }else {
            //查找左儿子
            if(leftNode!=null) {
                //有可能可以查到，也可以查不到，查不到的话，target还是一个null
                target = leftNode.frontSearch(i);
            }
            //如果不为空，说明在左儿子中已经找到
            if(target!=null) {
                return target;
            }
            //查找右儿子
            if(rightNode!=null) {
                target=rightNode.frontSearch(i);
            }
        }
        return target;
    }
    
    //删除一个子树
    public void delete(int i) {
        Node parent = this;
        //判断左儿子
        if(parent.leftNode!=null&amp;amp;&amp;amp;parent.leftNode.value==i) {
            parent.leftNode=null;
            return;
        }
        //判断右儿子
        if(parent.rightNode!=null&amp;amp;&amp;amp;parent.rightNode.value==i) {
            parent.rightNode=null;
            return;
        }
        
        //递归检查并删除左儿子
        parent=leftNode;
        if(parent!=null) {
            parent.delete(i);
        }
        
        //递归检查并删除右儿子
        parent=rightNode;
        if(parent!=null) {
            parent.delete(i);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依旧是BinaryTree 二叉树类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;
/*
 * 二叉树Class
 */
public class BinaryTree {
    //根节点root
    Node root;
    
    //设置根节点
    public void setRoot(Node root) {
        this.root = root;
    }
    
    //获取根节点
    public Node getRoot() {
        return root;
    }

    public void frontShow() {
        if(root!=null) {
            //调用节点类Node中的前序遍历frontShow（）方法
            root.frontShow();
        }
    }

    public void midShow() {
        if(root!=null) {
            //调用节点类Node中的中序遍历midShow()方法
            root.midShow();
        }
    }

    public void afterShow() {
        if(root!=null) {
            //调用节点类Node中的后序遍历afterShow()方法
            root.afterShow();
        }
    }
    //查找节点i
    public Node frontSearch(int i) {
        return root.frontSearch(i);
    }
    //删除节点i
    public void delete(int i) {
        if(root.value==i) {
            root=null;
        }else {
            root.delete(i);
        }
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依旧是TestBinaryTree测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package demo5;

public class TestBinaryTree {

    public static void main(String[] args) {
        //创建一颗树
        BinaryTree binTree = new BinaryTree();
        //创建一个根节点
        Node root = new Node(1);
        //把根节点赋给树
        binTree.setRoot(root);
        //创建一个左节点
        Node rootL = new Node(2);
        //把新创建的节点设置为根节点的子节点
        root.setLeftNode(rootL);
        //创建一个右节点
        Node rootR = new Node(3);
        //把新创建的节点设置为根节点的子节点
        root.setRightNode(rootR);
        //为第二层的左节点创建两个子节点
        rootL.setLeftNode(new Node(4));
        rootL.setRightNode(new Node(5));
        //为第二层的右节点创建两个子节点
        rootR.setLeftNode(new Node(6));
        rootR.setRightNode(new Node(7));
        //前序遍历树
        binTree.frontShow();
        System.out.println(&quot;===============&quot;);
        //中序遍历
        binTree.midShow();
        System.out.println(&quot;===============&quot;);
        //后序遍历
        binTree.afterShow();
        System.out.println(&quot;===============&quot;);
        //前序查找
        Node result = binTree.frontSearch(5);
        System.out.println(result);
        
        System.out.println(&quot;===============&quot;);
        //删除一个子树
        binTree.delete(4);
        binTree.frontShow();
        
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，总结一下，我们学了一种非线性表数据结构，树。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度等。我们平时最常用的树就是二叉树。&lt;strong&gt;二叉树的每个节点最多有两个子节点&lt;/strong&gt;，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。&lt;strong&gt;满二叉树又是完全二叉树的一种特殊情况&lt;/strong&gt;。二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里&lt;strong&gt;非常重要的操作&lt;/strong&gt;就是&lt;span&gt;前、中、后序遍历操作&lt;/span&gt;，遍历的时间复杂度是O(n)，你需要理解并能用递归代码来实现。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果本文章对你有帮助，哪怕是一点点，请点个赞呗，谢谢~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...说好了来了就是盆友喔...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/14/16e67b4d30ba473e?w=430&amp;amp;h=430&amp;amp;f=png&amp;amp;s=94196&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:07:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前面我们讲的都是线性表结构，栈、队列等等。今天我们讲一种非线性表结构，树。树这种数据结构比线性表的数据结构要复杂得多，内容也比较多，首先我们先从树（Tree）开始讲起。 @[toc] 树(Tree)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11895445.html</dc:identifier>
</item>
<item>
<title>你不知道的JS系列【1】- 什么是作用域 - Peerless1029</title>
<link>http://www.cnblogs.com/peerless1029/p/11894829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/11894829.html</guid>
<description>&lt;p&gt;  几乎所有的编程语言都能够储存变量，并且能在之后对这个变量值进行访问或修改，正是储存和访问变量的能力将&lt;strong&gt;状态&lt;/strong&gt;带给了程序，那么，这些变量储存在哪里呢？程序需要时又是如何找到他们？这些问题说明需要一套设计良好的规则来储存变量，并且之后可以方便的找到这些变量，这套规则被称为&lt;strong&gt;作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;了解编译原理&quot;&gt;1、了解编译原理&lt;/h2&gt;
&lt;p&gt;  尽管将JS归类为“动态”或“解释执行”脚本语言，但事实上它是一门编译语言。但是与传统编译语言不同的是，它不是提前编译的，编译结果也不能在分布式系统中进行移植。JS引擎进行编译的步骤与传统的语言非常相似，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分词/词法分析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元。例如，考虑程序 &lt;code&gt;var a = 2;&lt;/code&gt;。这段程序通常会被分解成 为下面这些词法单元：&lt;code&gt;var、a、=、2 、;&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;解析/语法分析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。&lt;code&gt;var a = 2;&lt;/code&gt;的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AST转换为可执行代码的过程称被称为代码生成,简单来说就是有某种方法可以将 &lt;code&gt;var a = 2;&lt;/code&gt;的AST转化为一组机器指 令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191120004936023-352928885.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS引擎比传统的编译语言编译器复杂很多，在语法分析和代码生成阶段有特定的步骤来对性能进行优化，大部分情况下编译发生在代码之前的前几微秒，在讨论作用域背后，js引擎用了各种办法来保证性能最佳。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;:我们平时在写JS代码的时候，一个语句结尾要加分号（;）,便于JS编译器编译。&lt;/p&gt;
&lt;h2 id=&quot;理解作用域&quot;&gt;2、理解作用域&lt;/h2&gt;
&lt;p&gt;  我们先了解JS编译过程中几个名词，JS引擎，编译器，作用域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.名词介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JS引擎&lt;/strong&gt;：从头到尾负责整个JS程序编译过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译器&lt;/strong&gt;：负责语法分析及代码生成等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS引擎&lt;/strong&gt;：负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.2.变量赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;var a=2;&lt;/code&gt;这段代码，我们认为这就是申明一个为变量a且初始值为2，实际上，JS引擎认为这里有两个完全不同的申明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。&lt;/p&gt;
&lt;p&gt;处理过程分为两步：&lt;/p&gt;
&lt;p&gt;1.遇到&lt;code&gt;var a&lt;/code&gt;，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。&lt;/p&gt;
&lt;p&gt;2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理&lt;code&gt;a = 2&lt;/code&gt;这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果引擎最终找到a变量，就会将2赋值给它。否则就抛出异常。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;声明提前(hoist)-JS引擎在创建变量时，会将该变量提升到当前作用域的最前面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3.LHS查询&amp;amp;RHS查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器在编译过程中的第二步生成了代码，引擎在执行时，会通过查找变量a来判断它是否已经声明过。当变量出现在赋值操作的左侧时进行LHS查询，当变量出现在右侧时进行RHS查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(a); //对a的引用时RHS引用，这里没有对a赋予任何值，需要查找a的值。

a=2; //对a的引用是LHS引用，因为这里不关心a的值等于多少，只想为 =2 这个赋值操作找到一个目标(变量a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“去找到XX变量的值，谁是赋值操作的源头（RHS）”。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;作用域嵌套&quot;&gt;3、作用域嵌套&lt;/h2&gt;
&lt;p&gt;  作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。&lt;/p&gt;
&lt;p&gt;参考以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var name='peer';
function sayHello(){
  alert('hello '+ name)
}
sayHello();
// 对name的RHS引用无法在函数sayHello完成，但是可以在上一级作用域中完成。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把作用域比喻成一个建筑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191120004927751-164747275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;LHS和RHS引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;  作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。LHS和RHS查询都会在当前执行作用域中开始，如果有需要就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止。不成功的RHS 引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），掌握这些基本作用域知识能使我们更深入理解JS引擎的编译过程来编写更高性能的代码。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料:&lt;br/&gt;《你不知道的JavaScript》&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 00:03:00 +0000</pubDate>
<dc:creator>Peerless1029</dc:creator>
<og:description>&amp;emsp;&amp;emsp;几乎所有的编程语言都能够储存变量，并且能在之后对这个变量值进行访问或修改，正是储存和访问变量的能力将 状态 带给了程序，那么，这些变量储存在哪里呢？程序需要时又是如何找到他们？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peerless1029/p/11894829.html</dc:identifier>
</item>
<item>
<title>并发编程-深入浅出AQS - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/11895430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/11895430.html</guid>
<description>&lt;p&gt;AQS是并发编程中非常重要的概念，它是juc包下的许多并发工具类，如CountdownLatch，CyclicBarrier，Semaphore 和锁, 如ReentrantLock， ReaderWriterLock的实现基础，提供了一个基于int状态码和队列来实现的并发框架。本文将对AQS框架的几个重要组成进行简要介绍，读完本文你将get到以下几个点：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AQS进行并发控制的机制是什么&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AQS独占和共享模式是如何实现的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同步队列和条件等待队列的区别，和数据出入队原则&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一aqs基本概念&quot;&gt;一，AQS基本概念&lt;/h2&gt;
&lt;p&gt;AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。&lt;/p&gt;
&lt;p&gt;队列可分为两种，一种是同步队列，是程序执行入口出处的等待队列；而另一种则是条件等待队列，队列中的元素是在程序执行时在某个条件上发生等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191120074737824-1565157266.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;独占or共享模式&quot;&gt;1.1 独占or共享模式&lt;/h3&gt;
&lt;p&gt;AQS支持两种获取同步状态的模式既独占式和共享式。顾名思义，独占式模式同一时刻只允许一个线程获取同步状态，而共享模式则允许多个线程同时获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191120074751169-2047884612.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步队列&quot;&gt;1.2 同步队列&lt;/h3&gt;
&lt;p&gt;当一个线程尝试获取同步状态失败时，同步器会将这个线程以及等待状态等信息构造成一个节点加入到等待队列中，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试重复获取同步队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191120074810182-964753122.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;条件队列&quot;&gt;1.3 条件队列&lt;/h3&gt;
&lt;p&gt;AQS内部类ConditionObject来实现的条件队列，当一个线程获取到同步状态，但是却通过Condition调用了await相关的方法时，会将该线程封装成Node节点并加入到条件队列中，它的结构和同步队列相同。&lt;/p&gt;
&lt;h2 id=&quot;二独占or共享模式&quot;&gt;二，独占or共享模式&lt;/h2&gt;
&lt;p&gt;AQS框架中，通过维护一个int类型的状态，来进行并发控制，线程通常通过修改此状态信息来表明当前线程持有此同步状态。AQS则是通过保存修改状态线程的引用来实现独占和共享模式的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 获取同步状态
 */
public final void acquire(int arg) {
    //尝试获取同步状态， 如果尝试获取到同步状态失败，则加入到同步队列中
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
/**
 * 尝试获取同步状态【子类中实现】，因为aqs基于模板模式，仅提供基于状态和同步队列的实 
 * 现思路，具体的实现由子类决定
 */
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 如果当前状态值为0，并且等待队列中没有元素，执行修改状态值操作
        if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
            compareAndSetState(0, acquires)) {
            // 修改状态值成功，记录当前持有同步状态的线程信息
            setExclusiveOwnerThread(current);
            return true;
        }
        // 如果当前线程已经持有同步状态，继续修改同步状态【重入锁实现原理】
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &amp;lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

/**
 * 根据传入的模式以及当前线程信息创建一个队列的节点并加入到同步队列尾部
 */
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
/**
 * 同步队列中节点，尝试获取同步状态
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        // 自旋(死循环)
        for (;;) {
            // 只有当前节点的前驱节点是头节点时才会尝试执行获取同步状态操作
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;独占式是如何控制得？&lt;/p&gt;
&lt;p&gt;当修改状态信息成功后，如果执行的是独占式操作，AQS的具体实现类中会保存当前线程的信息来声明同步状态已被当前线程占用，此时其他线程再尝试获取同步状态会返回false。&lt;/p&gt;
&lt;h2 id=&quot;三同步队列&quot;&gt;三，同步队列&lt;/h2&gt;
&lt;h3 id=&quot;队列中保存那些信息&quot;&gt;3.1 队列中保存那些信息？&lt;/h3&gt;
&lt;p&gt;同步队列节点中主要保存着线程的信息以及模式(共享or独占)。&lt;/p&gt;
&lt;h3 id=&quot;何时执行入队操作&quot;&gt;3.2 何时执行入队操作？&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 获取同步状态
 */
public final void acquire(int arg) {
    //尝试获取同步状态， 如果尝试获取到同步状态失败，则加入到同步队列中
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复用上文中的代码，不难看出再获取同步状态失败后，会执行入队操作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191120075014771-1892938449.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;何时执行出队操作&quot;&gt;3.3 何时执行出队操作？&lt;/h3&gt;
&lt;p&gt;当线程获取同步状态失败时，会被封装成Node节点加入到等待队列中，此时所有节点都回进入自旋过程，首先判断自己prev是否时头节点，如果是则尝试获取同步状态。&lt;br/&gt;被阻塞线程的唤醒主要以靠前驱节点的出队或阻塞线程被中断来实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 同步队列中节点，尝试获取同步状态
 * 
 * 1. 当一个线程获取到同步状态时，会将当前线程构造程Node并设置为头节点
 * 2. 并将原始的head节点设置为null，以便于垃圾回收
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四条件等待队列&quot;&gt;四，条件等待队列&lt;/h2&gt;
&lt;p&gt;条件变量（ConidtionObject）是AQS中的一个内部类，用来实现同步队列机制。同步队列复用了等待队列中Node节点，所以同步队列到等待队列中不需要进行额外的转换。&lt;/p&gt;
&lt;h3 id=&quot;什么时候执行入队操作&quot;&gt;4.1 什么时候执行入队操作？&lt;/h3&gt;
&lt;p&gt;当线程获取到同步状态，但是在临界区中调用了await()方法，此时该线程会被加入到对应的条件队列汇总。&lt;br/&gt;ps: 临界区，加锁和释放锁之间的代码区域&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * ConditionObject中的await方法，调用后使得当前执行线程加入条件等待队列
 */
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    // -----省略代码------
}
/**
 * 添加等待线程
 */
private Node addConditionWaiter() {
    Node t = lastWaiter;
    // -----省略代码------
    // 将当前线程构造程条件队列节点，并加入到队列中
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;什么时候执行出队操作&quot;&gt;4.2 什么时候执行出队操作？&lt;/h3&gt;
&lt;p&gt;当对应的Conditioni调用signial/signalAll()方法时回选择从条件队列中出队列，同步队列是通过自旋的方式获取同步状态，而条件队列中的节点则通过通知的方式出队。条件队列中的节点被唤醒后会加入到入口等待队列中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 唤醒当前条件等到队列中的所有等待线程
 */
public final void signalAll() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignalAll(first);
}
/**
 * 遍历队列，将元素从条件队列 加入到 同步队列
 */
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}
final boolean transferForSignal(Node node) {
    // -----省略代码------
    // 执行入队操作，将node添加到同步队列中
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五，总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;使用Node实现的FIFO队列，可以用于构建锁或者其他同步装置的基础框架&lt;/li&gt;
&lt;li&gt;利用一个int类型的属性表示状态&lt;/li&gt;
&lt;li&gt;使用模板方法模式，子类可以通过继承它来管理状态实现各种并发工具&lt;/li&gt;
&lt;li&gt;可以同时实现独占和共享模式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文对AQS的基本原理进行的简要的描述，对于子类的公平性和非公平行实现，中断，队列中节点的等待状态，cas等操作没有进行探讨，感兴趣的小伙伴可以进行源码阅读或者查阅相关资料。&lt;/p&gt;
&lt;h2 id=&quot;六qa&quot;&gt;六，Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;Question1： 在java中通常使用synchronized来实现方法同步，AQS中通过CAS保证了修改同步状态的一致性问题，那么对比synchronized，cas有什么优势不同与优势呢？你还知道其他无锁并发的策略吗？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mycookies.cn&quot;&gt;笔者的个人博客网站&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 23:52:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>AQS是并发编程中非常重要的概念，它是juc包下的许多并发工具类，如CountdownLatch，CyclicBarrier，Semaphore 和锁, 如ReentrantLock， ReaderW</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/11895430.html</dc:identifier>
</item>
<item>
<title>SpringSecurity系列之自定义登录验证成功与失败的结果处理 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11895429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11895429.html</guid>
<description>&lt;h2 id=&quot;一需要自定义登录结果的场景&quot;&gt;一、需要自定义登录结果的场景&lt;/h2&gt;
&lt;p&gt;在我之前的文章中，做过登录验证流程的源码解析。其中比较重要的就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当我们登录成功的时候，是由AuthenticationSuccessHandler进行登录结果处理，默认跳转到defaultSuccessUrl配置的路径对应的资源页面（一般是首页index.html）。&lt;/li&gt;
&lt;li&gt;当我们登录失败的时候，是由AuthenticationfailureHandler进行登录结果处理，默认跳转到failureUrl配置的路径对应的资源页面（一般是登录页login.html）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是在web应用开发过程中需求是千变万化的，有时需要我们针对登录结果做个性化处理，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们希望不同的人登陆之后，看到不同的首页&lt;/li&gt;
&lt;li&gt;我们应用是前后端分离的，验证响应结果是JSON格式数据，而不是页面跳转&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上的这些情况，使用Spring Security作为安全框架的时候，都需要我们使用本节学到的知识进行自定义的登录验证结果处理。&lt;/p&gt;
&lt;h2 id=&quot;二自定义登陆成功的结果处理&quot;&gt;二、自定义登陆成功的结果处理&lt;/h2&gt;
&lt;p&gt;为了满足上面的需求，我们该如何去做呢？下面一小节我们来说明一下。AuthenticationSuccessHandler接口是Security提供的认证成功处理器接口，我们只需要去实现它即可。但是通常来说，我们不会直接去实现AuthenticationSuccessHandler接口，而是继承SavedRequestAwareAuthenticationSuccessHandler 类，这个类会记住用户上一次请求的资源路径，比如：用户请求books.html，没有登陆所以被拦截到了登录页，当你万成登陆之后会自动跳转到books.html，而不是主页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyAuthenticationSuccessHandler 
                        extends SavedRequestAwareAuthenticationSuccessHandler {

    //在application配置文件中配置登陆的类型是JSON数据响应还是做页面响应
    @Value(&quot;${spring.security.logintype}&quot;)
    private String loginType;

    private  static ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, 
                                        HttpServletResponse response, 
                                        Authentication authentication) 
                                        throws ServletException, IOException {

        if (loginType.equalsIgnoreCase(&quot;JSON&quot;)) {
            response.setContentType(&quot;application/json;charset=UTF-8&quot;);
            response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.success()));
        } else {
            // 会帮我们跳转到上一次请求的页面上
            super.onAuthenticationSuccess(request, response, authentication);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在上面的自定义登陆成功处理中，既适应JSON前后端分离的应用登录结果处理，也适用于模板页面跳转应用的登录结果处理&lt;/li&gt;
&lt;li&gt;ObjectMapper 是Spring Boot默认集成的JSON数据处理类库Jackson中的类。&lt;/li&gt;
&lt;li&gt;AjaxResponse是一个自定义的通用的JSON数据接口响应类。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三自定义登录失败的结果处理&quot;&gt;三、自定义登录失败的结果处理&lt;/h2&gt;
&lt;p&gt;这里我们同样没有直接实现AuthenticationFailureHandler接口，而是继承SimpleUrlAuthenticationFailureHandler 类。该类中默认实现了登录验证失败的跳转逻辑，即登陆失败之后回到登录页面。我们可以利用这一点简化我们的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

    //在application配置文件中配置登陆的类型是JSON数据响应还是做页面响应
    @Value(&quot;${spring.security.logintype}&quot;)
    private String loginType;

    private  static ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void onAuthenticationFailure(HttpServletRequest request,
                                        HttpServletResponse response, 
                                        AuthenticationException exception) 
                                        throws IOException, ServletException {

        if (loginType.equalsIgnoreCase(&quot;JSON&quot;)) {
            response.setContentType(&quot;application/json;charset=UTF-8&quot;);
            response.getWriter().write(
                    objectMapper.writeValueAsString(
                            AjaxResponse.error(
                                    new CustomException(
                                        CustomExceptionType.USER_INPUT_ERROR,
                                        &quot;用户名或密码存在错误，请检查后再次登录&quot;))));
        } else {
            response.setContentType(&quot;text/html;charset=UTF-8&quot;);
            super.onAuthenticationFailure(request, response, exception);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在上面的自定义登陆失败处理中，既适应JSON前后端分离的应用登录失败结果处理，也适用于模板页面跳转应用的登录失败结果处理&lt;/li&gt;
&lt;li&gt;登陆失败之后，将默认跳转到默认的failureUrl，即登录界面。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四配置securityconfig&quot;&gt;四、配置SecurityConfig&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Resource
    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;

    @Resource
    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;

   @Override
   protected void configure(HttpSecurity http) throws Exception {
       http.csrf().disable() //禁用跨站csrf攻击防御，后面的章节会专门讲解
           .formLogin()
           .successHandler(myAuthenticationSuccessHandler)
           .failureHandler(myAuthenticationFailureHandler)
           .defaultSuccessUrl(&quot;/index&quot;)//登录认证成功后默认转跳的路径
           .failureUrl(&quot;/login.html&quot;) //登录认证是被跳转页面
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.83292978208232&quot;&gt;&lt;li&gt;将自定义的AuthenticationSuccessHandler和AuthenticationFailureHandler注入到Spring Security配置类中&lt;/li&gt;
&lt;li&gt;使用fromlogin模式，配置successHandler和failureHandler。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并且配置defaultSuccessUrl和failureUrl&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;博主最近新写了一本书：&lt;a href=&quot;http://springboot.zimug.com&quot;&gt;《手摸手教您学习SpringBoot系列-16章97节》&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.82758620689655&quot;&gt;
&lt;p&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 19 Nov 2019 23:50:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、需要自定义登录结果的场景 在我之前的文章中，做过登录验证流程的源码解析。其中比较重要的就是 当我们登录成功的时候，是由AuthenticationSuccessHandler进行登录结果处理，默认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11895429.html</dc:identifier>
</item>
<item>
<title>Spring Boot Actuator监控使用详解 - 程序新视界</title>
<link>http://www.cnblogs.com/secbro/p/11895418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secbro/p/11895418.html</guid>
<description>&lt;p&gt;在企业级应用中，学习了如何进行SpringBoot应用的功能开发，以及如何写单元测试、集成测试等还是不够的。在实际的软件开发中还需要：应用程序的监控和管理。SpringBoot的Actuator模块实现了应用的监控与管理。&lt;/p&gt;
&lt;h2 id=&quot;actuator简介&quot;&gt;Actuator简介&lt;/h2&gt;
&lt;p&gt;生产系统中，往往需要对系统实际运行的情况（例如cpu、io、disk、db、业务功能等指标）进行监控运维。在SpringBoot项目中Actuator模块提供了众多HTTP接口端点（Endpoint），来提供应用程序运行时的内部状态信息。&lt;/p&gt;
&lt;p&gt;Actuator模块提供了一个监控和管理生产环境的模块，可以使用http、jmx、ssh、telnet等来管理和监控应用。包括应用的审计（Auditing）、健康（health）状态信息、数据采集（metrics gathering）统计等监控运维的功能。同时，提供了可以扩展 Actuator端点（Endpoint）自定义监控指标。这些指标都是以JSON接口数据的方式呈现。&lt;/p&gt;
&lt;h2 id=&quot;actuator的使用&quot;&gt;Actuator的使用&lt;/h2&gt;
&lt;p&gt;使用Spring Boot Actuator需要加入如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;actuator并没有默认集成在自动配置中，而在作为独立的项目来呈现的。当引入了上面的依赖，默认会引入actuator相关的两个项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-actuator-autoconfigure&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中spring-boot-actuator为功能实现，spring-boot-actuator-autoconfigure为自动配置。&lt;/p&gt;
&lt;p&gt;需要注意：因SpringBoot Actuator会暴露服务的详细信息，为了保障安全性，建议添加安全控制的相关依赖spring-boot-starter-security，这样在访问应用监控端点时，都需要输入验证信息。所需依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于security的使用我们在此不进行展开，可在application文件中配置相应的访问密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  security:
    user:
      name: admin
      password: admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下面的内容中为了方便，我们暂时不引入security。&lt;/p&gt;
&lt;p&gt;经过以上步骤的操作，启动SpringBoot项目，actuator便自动集成配置了，可通过：http://localhost:8080/actuator 访问，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/actuator&quot;,
            &quot;templated&quot;: false
        },
        &quot;health&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/actuator/health&quot;,
            &quot;templated&quot;: false
        },
        &quot;health-component&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/actuator/health/{component}&quot;,
            &quot;templated&quot;: true
        },
        &quot;health-component-instance&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/actuator/health/{component}/{instance}&quot;,
            &quot;templated&quot;: true
        },
        &quot;info&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/actuator/info&quot;,
            &quot;templated&quot;: false
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认支持的链接有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/actuator
/actuator/health
/health/{component}/{instance}
/health/{component}
/actuator/info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在application配置文件中配置开启更多的监控信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;management:
  endpoints:
    web:
      exposure:
        include: '*'
#      base-path: /monitor
  endpoint:
    health:
      show-details: always
    shutdown:
      enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;management.endpoints.web.exposure.include='*'，代表开启全部监控，也可仅配置需要开启的监控，如： management.endpoints.web.exposure.include=beans,trace。&lt;/li&gt;
&lt;li&gt;management.endpoint.health.show-details=always，health endpoint开启显示全部细节。默认情况下/actuator/health是公开的，但不显示细节。&lt;/li&gt;
&lt;li&gt;management.endpoints.web.base-path=/monitor，启用指定的url地址访问根路径，默认路径为/actuator/*，开启则访问路径变为/monitor/*。&lt;/li&gt;
&lt;li&gt;management.endpoint.shutdown.enabled=true，启用接口关闭SpringBoot。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;监控信息如果需要跨越调用，可通过CORS配置来支持，默认处于禁用状态。设置management.endpoints.web.cors.allowed-origins属性后开启。&lt;/p&gt;
&lt;p&gt;比如允许来自https://www.choupangxia.com 域的GET和POST调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;management:
  endpoints:
    web:
      cors:
        allowed-origins: https://www.choupangxia.com
        allowed-methods: GET,POST&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rest接口&quot;&gt;REST接口&lt;/h2&gt;
&lt;p&gt;Spring Boot Actuator提供了非常丰富的监控接口，可以通过这些接口了解应用程序运行时的内部状况。Actuator也支持用户自定义添加端点，可以根据实际应用，定义一些比较关心的指标，在运行期进行监控。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/auditevents&lt;/td&gt;
&lt;td&gt;显示当前应用程序的审计事件信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/beans&lt;/td&gt;
&lt;td&gt;显示一个应用中所有Spring Beans的完整列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/conditions&lt;/td&gt;
&lt;td&gt;显示配置类和自动配置类(configuration and auto-configuration classes)的状态及它们被应用或未被应用的原因。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/configprops&lt;/td&gt;
&lt;td&gt;显示一个所有@ConfigurationProperties的集合列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/env&lt;/td&gt;
&lt;td&gt;显示来自Spring的ConfigurableEnvironment的属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/flyway&lt;/td&gt;
&lt;td&gt;显示数据库迁移路径，如果有的话。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/health&lt;/td&gt;
&lt;td&gt;显示应用的健康信息（当使用一个未认证连接访问时显示一个简单的’status’，使用认证连接访问则显示全部信息详情）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/info&lt;/td&gt;
&lt;td&gt;显示任意的应用信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/liquibase&lt;/td&gt;
&lt;td&gt;展示任何Liquibase数据库迁移路径，如果有的话&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/metrics&lt;/td&gt;
&lt;td&gt;展示当前应用的metrics信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/mappings&lt;/td&gt;
&lt;td&gt;显示一个所有@RequestMapping路径的集合列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/scheduledtasks&lt;/td&gt;
&lt;td&gt;显示应用程序中的计划任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/sessions&lt;/td&gt;
&lt;td&gt;允许从Spring会话支持的会话存储中检索和删除(retrieval and deletion)用户会话。使用Spring Session对反应性Web应用程序的支持时不可用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;/shutdown&lt;/td&gt;
&lt;td&gt;允许应用以优雅的方式关闭（默认情况下不启用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/threaddump&lt;/td&gt;
&lt;td&gt;执行一个线程dump&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果使用web应用(Spring MVC, Spring WebFlux, 或者 Jersey)，还可以使用以下接口：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/heapdump&lt;/td&gt;
&lt;td&gt;返回一个GZip压缩的hprof堆dump文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/jolokia&lt;/td&gt;
&lt;td&gt;通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/logfile&lt;/td&gt;
&lt;td&gt;返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/prometheus&lt;/td&gt;
&lt;td&gt;以可以被Prometheus服务器抓取的格式显示metrics信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;接口详解&quot;&gt;接口详解&lt;/h2&gt;
&lt;p&gt;health主要用来检查应用的运行状态，这是使用频次最高的监控点。通常使用此接口显示应用实例的运行状态，以及应用不“健康”的原因，比如数据库连接、磁盘空间不够等。&lt;/p&gt;
&lt;p&gt;默认情况下health的状态是开放的，访问：http://localhost:8080/actuator/health 即可看到应用的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;status&quot; : &quot;UP&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置状态码顺序：setStatusOrder(Status.DOWN,Status.OUT_OF_SERVICE, Status.UP, Status.UNKNOWN)。&lt;br/&gt;过滤掉不能识别的状态码。如果无任何状态码，整个SpringBoot应用的状态是UNKNOWN。将所有收集到的状态码排序。返回有序状态码序列中的第一个状态码，作为整个SpringBoot应用的状态。&lt;/p&gt;
&lt;p&gt;Health通过合并几个健康指数检查应用的健康情况。SpringBoot Actuator会自动配置以下内容：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CassandraHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Cassandra数据库是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CouchbaseHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Couchbase群集是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DiskSpaceHealthIndicator&lt;/td&gt;
&lt;td&gt;检查磁盘空间不足。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;DataSourceHealthIndicator&lt;/td&gt;
&lt;td&gt;检查是否可以建立连接DataSource。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ElasticsearchHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Elasticsearch集群是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;InfluxDbHealthIndicator&lt;/td&gt;
&lt;td&gt;检查InfluxDB服务器是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;JmsHealthIndicator&lt;/td&gt;
&lt;td&gt;检查JMS代理是否启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MailHealthIndicator&lt;/td&gt;
&lt;td&gt;检查邮件服务器是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MongoHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Mongo数据库是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Neo4jHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Neo4j服务器是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RabbitHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Rabbit服务器是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RedisHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Redis服务器是否启动。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SolrHealthIndicator&lt;/td&gt;
&lt;td&gt;检查Solr服务器是否已启动。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以通过设置 management.health.defaults.enabled属性来全部禁用。&lt;/p&gt;
&lt;h2 id=&quot;原生端点&quot;&gt;原生端点&lt;/h2&gt;
&lt;p&gt;原生端点分为三大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与Spring Boot应用密切相关的配置类信息。&lt;/li&gt;
&lt;li&gt;度量指标类：获取应用程序运行过程中用于监控的度量指标，比如：内存信息、线程池信息、HTTP请求统计等。&lt;/li&gt;
&lt;li&gt;操作控制类：提供了对应用的关闭等操作类功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;应用配置类&quot;&gt;应用配置类&lt;/h2&gt;
&lt;p&gt;/conditions：该端点用来获取应用的自动化配置报告，其中包括所有自动化配置的候选项。同时还列出了每个候选项自动化配置的各个先决条件是否满足。该端点可以帮助我们方便的找到一些自动化配置为什么没有生效的具体原因。&lt;/p&gt;
&lt;p&gt;该报告内容将自动化配置内容分为两部分：positiveMatches中返回的是条件匹配成功的自动化配置和negativeMatches中返回的是条件匹配不成功的自动化配置。&lt;/p&gt;
&lt;p&gt;部分代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;contexts&quot;: {
        &quot;application&quot;: {
            &quot;positiveMatches&quot;: {
                &quot;MsgAutoConfiguration&quot;: [
                    {
                        &quot;condition&quot;: &quot;OnClassCondition&quot;,
                        &quot;message&quot;: &quot;@ConditionalOnClass found required class 'com.secbro2.msg.MsgService'&quot;
                    }
                ],
                &quot;MsgAutoConfiguration#msgService&quot;: [
                    {
                        &quot;condition&quot;: &quot;OnPropertyCondition&quot;,
                        &quot;message&quot;: &quot;@ConditionalOnProperty (msg.enabled=true) matched&quot;
                    },
                    {
                        &quot;condition&quot;: &quot;OnBeanCondition&quot;,
                        &quot;message&quot;: &quot;@ConditionalOnMissingBean (types: com.secbro2.msg.MsgService; SearchStrategy: all) did not find any beans&quot;
                    }
                ],&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/info：就是在配置文件中配置的以info开头的信息，如配置为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info:
  app:
    name: spring-boot-actuator
    version: 1.0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;app&quot;:{
    &quot;name&quot;:&quot;spring-boot-actuator&quot;,
    &quot;version&quot;:&quot;1.0.0&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;info中配置的参数也可以通过符号*@*包围的属性值来自pom.xml文件中的元素节点。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info:
    build:
        artifact: @project.artifactId@
        name: @project.name@
        description: @project.description@
        ersion: @project.version@&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;build&quot;: {
        &quot;artifact&quot;: &quot;spring-learn&quot;,
        &quot;name&quot;: &quot;spring-learn&quot;,
        &quot;description&quot;: &quot;Demo project for Spring Boot&quot;,
        &quot;ersion&quot;: &quot;0.0.1-SNAPSHOT&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/beans：该端点用来获取应用上下文中创建的所有Bean。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;contexts&quot;: {
        &quot;application&quot;: {
            &quot;beans&quot;: {
                &quot;endpointCachingOperationInvokerAdvisor&quot;: {
                    &quot;aliases&quot;: [],
                    &quot;scope&quot;: &quot;singleton&quot;,
                    &quot;type&quot;: &quot;org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvokerAdvisor&quot;,
                    &quot;resource&quot;: &quot;class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/EndpointAutoConfiguration.class]&quot;,
                    &quot;dependencies&quot;: [&quot;environment&quot;]
                },
                &quot;defaultServletHandlerMapping&quot;: {
                    &quot;aliases&quot;: [],
                    &quot;scope&quot;: &quot;singleton&quot;,
                    &quot;type&quot;: &quot;org.springframework.web.servlet.HandlerMapping&quot;,
                    &quot;resource&quot;: &quot;class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]&quot;,
                    &quot;dependencies&quot;: []
                },
            },
            &quot;parentId&quot;: null
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口展现了bean的别名、类型、是否单例、类的地址、依赖等信息。&lt;/p&gt;
&lt;p&gt;/configprops：该端点用来获取应用中配置的属性信息报告。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;spring.transaction-org.springframework.boot.autoconfigure.transaction.TransactionProperties&quot;: {
        &quot;prefix&quot;: &quot;spring.transaction&quot;,
        &quot;properties&quot;: {}
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面展示了TransactionProperties属性的配置信息。&lt;/p&gt;
&lt;p&gt;/mappings：该端点用来返回所有SpringMVC的控制器映射关系报告。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;handler&quot;: &quot;Actuator web endpoint 'beans'&quot;,
  &quot;predicate&quot;: &quot;{GET /actuator/beans, produces [application/vnd.spring-boot.actuator.v2+json || application/json]}&quot;,
  &quot;details&quot;: {
    &quot;handlerMethod&quot;: {
      &quot;className&quot;: &quot;org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping.OperationHandler&quot;,
      &quot;name&quot;: &quot;handle&quot;,
      &quot;descriptor&quot;: &quot;(Ljavax/servlet/http/HttpServletRequest;Ljava/util/Map;)Ljava/lang/Object;&quot;
    },
    &quot;requestMappingConditions&quot;: {
      &quot;consumes&quot;: [],
      &quot;headers&quot;: [],
      &quot;methods&quot;: [&quot;GET&quot;],
      &quot;params&quot;: [],
      &quot;patterns&quot;: [&quot;/actuator/beans&quot;],
      &quot;produces&quot;: [{
        &quot;mediaType&quot;: &quot;application/vnd.spring-boot.actuator.v2+json&quot;,
        &quot;negated&quot;: false
      }, {
        &quot;mediaType&quot;: &quot;application/json&quot;,
        &quot;negated&quot;: false
      }]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/env：该端点与/configprops不同，它用来获取应用所有可用的环境属性报告。包括：环境变量、JVM属性、应用的配置配置、命令行中的参数。&lt;/p&gt;
&lt;h2 id=&quot;度量指标类&quot;&gt;度量指标类&lt;/h2&gt;
&lt;p&gt;应用配置类提供的指标为静态报告，而度量指标类端点提供的报告内容则是动态变化的，提供了应用程序在运行过程中的一些快照信息，比如：内存使用情况、HTTP请求统计、外部资源指标等。这些端点对于构建微服务架构中的监控系统非常有帮助。&lt;/p&gt;
&lt;p&gt;/metrics：该端点用来返回当前应用的各类重要度量指标，比如：内存信息、线程信息、垃圾回收信息等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;names&quot;: [
        &quot;jvm.memory.max&quot;,
        &quot;jvm.threads.states&quot;,
        &quot;http.server.requests&quot;,
        &quot;process.files.max&quot;,
        &quot;jvm.gc.memory.promoted&quot;,
        &quot;system.load.average.1m&quot;,
        &quot;jvm.memory.used&quot;,
        &quot;jvm.gc.max.data.size&quot;,
        &quot;jvm.gc.pause&quot;,
        &quot;jvm.memory.committed&quot;,
        &quot;system.cpu.count&quot;,
        &quot;logback.events&quot;,
        &quot;tomcat.global.sent&quot;,
        &quot;jvm.buffer.memory.used&quot;,
        &quot;tomcat.sessions.created&quot;,
        &quot;jvm.threads.daemon&quot;,
        &quot;system.cpu.usage&quot;,
        &quot;jvm.gc.memory.allocated&quot;,
        &quot;tomcat.global.request.max&quot;,
        &quot;tomcat.global.request&quot;,
        &quot;tomcat.sessions.expired&quot;,
        &quot;jvm.threads.live&quot;,
        &quot;jvm.threads.peak&quot;,
        &quot;tomcat.global.received&quot;,
        &quot;process.uptime&quot;,
        &quot;tomcat.sessions.rejected&quot;,
        &quot;process.cpu.usage&quot;,
        &quot;tomcat.threads.config.max&quot;,
        &quot;jvm.classes.loaded&quot;,
        &quot;jvm.classes.unloaded&quot;,
        &quot;tomcat.global.error&quot;,
        &quot;tomcat.sessions.active.current&quot;,
        &quot;tomcat.sessions.alive.max&quot;,
        &quot;jvm.gc.live.data.size&quot;,
        &quot;tomcat.threads.current&quot;,
        &quot;process.files.open&quot;,
        &quot;jvm.buffer.count&quot;,
        &quot;jvm.buffer.total.capacity&quot;,
        &quot;tomcat.sessions.active.max&quot;,
        &quot;tomcat.threads.busy&quot;,
        &quot;process.start.time&quot;
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的示例中有这些重要的度量值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average。&lt;/li&gt;
&lt;li&gt;mem.*：内存概要信息，包括分配给应用的总内存数量以及当前空闲的内存数量。这些信息来自java.lang.Runtime。&lt;/li&gt;
&lt;li&gt;heap.*：堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。&lt;/li&gt;
&lt;li&gt;nonheap.*：非堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getNonHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。&lt;/li&gt;
&lt;li&gt;threads.*：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等，这些数据均来自java.lang.management.ThreadMXBean。&lt;/li&gt;
&lt;li&gt;classes.*：应用加载和卸载的类统计。这些数据均来自java.lang.management.ClassLoadingMXBean。&lt;/li&gt;
&lt;li&gt;gc.*：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清除算法的次数gc.ps_marksweep.count、标记-清除算法的消耗时间gc.ps_marksweep.time。这些数据均来自java.lang.management.GarbageCollectorMXBean。&lt;/li&gt;
&lt;li&gt;httpsessions.*：Tomcat容器的会话使用情况。包括最大会话数httpsessions.max和活跃会话数httpsessions.active。该度量指标信息仅在引入了嵌入式Tomcat作为应用容器的时候才会提供。&lt;/li&gt;
&lt;li&gt;gauge.*：HTTP请求的性能指标之一，它主要用来反映一个绝对数值。比如上面示例中的gauge.response.hello: 5，它表示上一次hello请求的延迟时间为5毫秒。&lt;/li&gt;
&lt;li&gt;counter.*：HTTP请求的性能指标之一，它主要作为计数器来使用，记录了增加量和减少量。如上示例中counter.status.200.hello: 11，它代表了hello请求返回200状态的次数为11。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;/threaddump：会生成当前线程活动的快照。方便我们在日常定位问题的时候查看线程的情况。主要展示了线程名、线程ID、线程的状态、是否等待锁资源等信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;threads&quot;: [{
        &quot;threadName&quot;: &quot;Reference Handler&quot;,
        &quot;threadId&quot;: 2,
        &quot;blockedTime&quot;: -1,
        &quot;blockedCount&quot;: 2,
        &quot;waitedTime&quot;: -1,
        &quot;waitedCount&quot;: 0,
        &quot;lockName&quot;: null,
        &quot;lockOwnerId&quot;: -1,
        &quot;lockOwnerName&quot;: null,
        &quot;daemon&quot;: true,
        &quot;inNative&quot;: false,
        &quot;suspended&quot;: false,
        &quot;threadState&quot;: &quot;RUNNABLE&quot;,
        &quot;priority&quot;: 10,
        &quot;stackTrace&quot;: [{
            &quot;classLoaderName&quot;: null,
            &quot;moduleName&quot;: &quot;java.base&quot;,
            &quot;moduleVersion&quot;: &quot;11.0.4&quot;,
            &quot;methodName&quot;: &quot;waitForReferencePendingList&quot;,
            &quot;fileName&quot;: &quot;Reference.java&quot;,
            &quot;lineNumber&quot;: -2,
            &quot;className&quot;: &quot;java.lang.ref.Reference&quot;,
            &quot;nativeMethod&quot;: true
        }
  ...
  &quot;lockedMonitors&quot;: [],
        &quot;lockedSynchronizers&quot;: [{
            &quot;className&quot;: &quot;java.util.concurrent.locks.ReentrantLock$NonfairSync&quot;,
            &quot;identityHashCode&quot;: 2060076420
        }],
        &quot;lockInfo&quot;: null
  ...
  {
        &quot;threadName&quot;: &quot;DestroyJavaVM&quot;,
        &quot;threadId&quot;: 42,
        &quot;blockedTime&quot;: -1,
        &quot;blockedCount&quot;: 0,
        &quot;waitedTime&quot;: -1,
        &quot;waitedCount&quot;: 0,
        &quot;lockName&quot;: null,
        &quot;lockOwnerId&quot;: -1,
        &quot;lockOwnerName&quot;: null,
        &quot;daemon&quot;: false,
        &quot;inNative&quot;: false,
        &quot;suspended&quot;: false,
        &quot;threadState&quot;: &quot;RUNNABLE&quot;,
        &quot;priority&quot;: 5,
        &quot;stackTrace&quot;: [],
        &quot;lockedMonitors&quot;: [],
        &quot;lockedSynchronizers&quot;: [],
        &quot;lockInfo&quot;: null
    }]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/trace：该端点用来返回基本的HTTP跟踪信息。默认情况下，跟踪信息的存储采用。&lt;/p&gt;
&lt;h2 id=&quot;操作控制类&quot;&gt;操作控制类&lt;/h2&gt;
&lt;p&gt;/shutdown：配置文件中配置开启此功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;management.endpoint.shutdown.enabled=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 curl 模拟 post 请求此接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST &quot;http://localhost:8080/actuator/shutdown&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;message&quot;: &quot;Shutting down, bye...&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本篇文章介绍了SpringBoot Actuator监控的基本功能和详解，下篇文章将会带大家了解一下该功能在Spring Boot中的实现原理。欢迎关注公众号“程序新视界”。&lt;/p&gt;
&lt;p&gt;原文链接：《&lt;a href=&quot;http://www.choupangxia.com/2019/11/19/spring-boot-actuator/&quot;&gt;Spring Boot Actuator监控使用详解&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;br/&gt;&lt;/h2&gt;
&lt;center&gt;&lt;strong&gt;程序新视界&lt;/strong&gt;：精彩和成长都不容错过&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742867/201910/1742867-20191013111755842-2090947098.png&quot; alt=&quot;程序新视界-微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Nov 2019 23:05:00 +0000</pubDate>
<dc:creator>程序新视界</dc:creator>
<og:description>在企业级应用中，学习了如何进行SpringBoot应用的功能开发，以及如何写单元测试、集成测试等还是不够的。在实际的软件开发中还需要：应用程序的监控和管理。SpringBoot的Actuator模块实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secbro/p/11895418.html</dc:identifier>
</item>
<item>
<title>CSS复合选择器是什么？复合选择器是如何工作 - 微笑是最初的信仰</title>
<link>http://www.cnblogs.com/lq0001/p/11894861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lq0001/p/11894861.html</guid>
<description>&lt;h2 id=&quot;复合选择器介绍&quot;&gt;复合选择器介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;复合选择器其实很好理解，说白了就跟我们生活中的有血缘关系家庭成员一样，通过标签或者&lt;code&gt;class&lt;/code&gt;属性或&lt;code&gt;id&lt;/code&gt;属性，去找对应的有血缘关系的某个选择器，具体的大家往下看哦。&lt;/li&gt;
&lt;li&gt;如果是初学者对基本的选择器不是很了解的可以看笔者之前写过的基本选择器文章，&lt;a href=&quot;https://www.cnblogs.com/lq0001/p/11846116.html&quot;&gt;CSS基本选择器是什么？基本选择器是如何工作&lt;/a&gt;，在这就不过多的介绍基本选择器的使用了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;复合选择器说明表&quot;&gt;复合选择器说明表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;选择器1 选择器2{属性：值;}&lt;/td&gt;
&lt;td&gt;多元素选择器。同时匹配选择器1和选择器2，多个选择器之间用逗号隔开即可。&lt;/td&gt;
&lt;td&gt;h1,h2,h3{color: red;}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;E F {属性：值;}&lt;/td&gt;
&lt;td&gt;后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格隔开即可。&lt;/td&gt;
&lt;td&gt;.box h1{color: red;}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E&amp;gt;F{属性：值;}&lt;/td&gt;
&lt;td&gt;子元素选择器，匹配所有E元素的子元素为F&lt;/td&gt;
&lt;td&gt;div &amp;gt;h1{color:red;}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E+F{属性：值;}&lt;/td&gt;
&lt;td&gt;相邻元素选择器，匹配所有紧跟随着E元素之后的同级元素F&lt;/td&gt;
&lt;td&gt;div+div{color:red;}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h3 id=&quot;多元素选择器&quot;&gt;多元素选择器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;多元素选择器在工作当中经常会用到，主要用于设置多个元素使用同一种&lt;code&gt;CSS&lt;/code&gt;样式。&lt;/li&gt;
&lt;li&gt;让我们进入多元素选择器实践，实践内容如：将&lt;code&gt;HTML&lt;/code&gt;页面中的&lt;code&gt;div&lt;/code&gt;标签、&lt;code&gt;h1&lt;/code&gt;标签、&lt;code&gt;p&lt;/code&gt;标签、中的文本颜色设置为红色。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;多元素选择器&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;style&amp;gt;
        div,h1,p{
           color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/div&amp;gt;
    &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191120005417170-2028274139.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：作用给列表中的所有的选择器设置样式，&lt;code&gt;class&lt;/code&gt;类选择器或&lt;code&gt;id&lt;/code&gt;选择器也是一样，在这里就拿&lt;code&gt;class&lt;/code&gt;类选择器属性值为&lt;code&gt;.box&lt;/code&gt;为例，其余的大家可以自己尝试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;多元素选择器&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;style&amp;gt;
        .box,h1,p{
           color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot; &amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/div&amp;gt;
    &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191120005417170-2028274139.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;后代元素选择器&quot;&gt;后代元素选择器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;让我们进入后代元素选择器实践，实践内容如：将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;的后代元素文本颜色设置为红色，给大家介绍下结构：&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;中一共有三个子元素，第一个&lt;code&gt;h1&lt;/code&gt;标签、第二个&lt;code&gt;h1&lt;/code&gt;标签、第三个&lt;code&gt;div&lt;/code&gt;标签、但是第三个子元素为&lt;code&gt;div&lt;/code&gt;标签里面还有一个子元素为&lt;code&gt;h1&lt;/code&gt;标签或者我们可以理解为&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;的孙子辈元素。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;后代元素选择器&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;style&amp;gt;
        .box h1{
           color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot; &amp;gt;
        &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;微笑是最初的信仰&amp;lt;/h1&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191120005458983-1675286146.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：后代选择器只能包含在&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;里面的所有属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;子元素选择器&quot;&gt;子元素选择器&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;让我们进入子元素选择器实践，实践内容如：将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;的子元素文本颜色设置为红色，给大家介绍下结构：&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;中一共有三个子元素，第一个&lt;code&gt;h1&lt;/code&gt;标签、第二个&lt;code&gt;h1&lt;/code&gt;标签、&lt;code&gt;div&lt;/code&gt;标签、但是第三个子元素为&lt;code&gt;div&lt;/code&gt;标签里面还有一个子元素为&lt;code&gt;h1&lt;/code&gt;标签或者我们可以理解为&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;的孙子辈元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;子元素选择器&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;style&amp;gt;
        .box &amp;gt; h1{
           color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot; &amp;gt;
        &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
        &amp;lt;h1&amp;gt;微笑是最初的信仰&amp;lt;/h1&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191120005529096-1718391314.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：子元素选择器和后代元素选择器是不样的，子元素选择器是将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;中的子元素设置&lt;code&gt;CSS&lt;/code&gt;样式，后代元素选择器是将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;中的所有元素设置&lt;code&gt;CSS&lt;/code&gt;样式，现在大家应该明白了，为什么&lt;code&gt;div&lt;/code&gt;标签中的&lt;code&gt;h1&lt;/code&gt;标签文本颜色没有被渲染的原因了吧，因为&lt;code&gt;div&lt;/code&gt;标签中的&lt;code&gt;h1&lt;/code&gt;标签是孙子辈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;相邻元素选择器&quot;&gt;相邻元素选择器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;相邻元素选择器必须满足以下条件才会匹配。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt;元素与&lt;code&gt;F&lt;/code&gt;元素必须是兄弟关系，意思就是平辈关系。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt;元素与&lt;code&gt;F&lt;/code&gt;元素必须要紧挨着，就是之间不能有任何元素阻挡。&lt;/li&gt;
&lt;li&gt;要求&lt;code&gt;F&lt;/code&gt;元素一定是在&lt;code&gt;E&lt;/code&gt;元素的下面。&lt;/li&gt;
&lt;li&gt;让我们进入相邻元素选择器实践，实践内容如：将&lt;code&gt;HTML&lt;/code&gt;页面中的&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;的相邻元素文本颜色设置为红色。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;相邻元素选择器&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
    &amp;lt;style&amp;gt;
        .box + h1{
           color: red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;我在上面学习&amp;lt;/h1&amp;gt;
    &amp;lt;div class=&quot;box&quot; &amp;gt;
        &amp;lt;h1&amp;gt;成功不是打败别人，而是改变自己。&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;h1&amp;gt;我在下面学习&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201911/1781381-20191120005552951-1310692853.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：大家一定要注意以上的&lt;code&gt;2&lt;/code&gt;个必须和&lt;code&gt;1&lt;/code&gt;个一定的规则，否则&lt;code&gt;CSS&lt;/code&gt;样式不会被渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 19 Nov 2019 16:58:00 +0000</pubDate>
<dc:creator>微笑是最初的信仰</dc:creator>
<og:description>复合选择器介绍 复合选择器其实很好理解，说白了就跟我们生活中的有血缘关系家庭成员一样，通过标签或者 属性或 属性，去找对应的有血缘关系的某个选择器，具体的大家往下看哦。 如果是初学者对基本的选择器不是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lq0001/p/11894861.html</dc:identifier>
</item>
</channel>
</rss>