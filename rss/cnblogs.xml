<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>asp.net core系列 34 EF保存数据(1) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10448663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10448663.html</guid>
<description>&lt;h3&gt;一. 基本数据&lt;/h3&gt;
&lt;p&gt;　　每个EF上下文实例都有一个 &lt;code&gt;ChangeTracker&lt;/code&gt;(更改跟踪器)，它负责跟踪需要写入数据库的更改。 当更改实体类的实例时(修改属性，删除实例，新建实例等)，这些更改会记录在 &lt;code&gt;ChangeTracker&lt;/code&gt; 中，然后在调用 &lt;code&gt;SaveChanges&lt;/code&gt; 时被写入数据库。 此数据库提供程序负责将更改，转换为特定的数据库操作（例如，关系数据库的 &lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 命令）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1.1 添加数据　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;使用 DbSet.Add 方法添加实体类的新实例。 调用 SaveChanges 时，数据将插入到数据库中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://sample.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
         context.Blogs.Add(blog);
         context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　1.2 更新数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;EF 将通过&lt;code&gt;ChangeTracker&lt;/code&gt;自动检测上下文对现有实体所做的更改。 检测包括从数据库查询的实体，以及之前添加并保存到数据库的实体。例如下面示例，从数据库查询的实体，只需通过赋值来修改属性，然后调用 SaveChanges 即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; context.Blogs.First();
         blog.Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://sample.com/blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
         context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;1.3 删除数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　使用 &lt;span lang=&quot;EN-US&quot;&gt;DbSet.Remove 方法删除实体类的实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(1)如果实体已存在于数据库中，则将在&lt;span lang=&quot;EN-US&quot;&gt;“SaveChanges”期间删除该实体，并且删除数据库中的数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　&lt;/span&gt;(2)如果实体尚未保存到数据库（即跟踪为“已添加”），则在调用SaveChanges时，该实体会从上下文中移除且不再插入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种情况&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; context.Blogs.First();
            context.Blogs.Remove(blog);
            context.SaveChanges();&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种情况&lt;/span&gt;
            Blog blog = &lt;span&gt;new&lt;/span&gt; Blog() { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加后该实体为已添加，尚未保存到数据库&lt;/span&gt;
&lt;span&gt;            BloggingContext.Blogs.Add(blog);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除实体类的实例&lt;/span&gt;
&lt;span&gt;            BloggingContext.Blogs.Remove(blog);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从上下文中移除blog实体&lt;/span&gt;
            BloggingContext.SaveChanges();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;1.4 单个 SaveChanges 中的多个操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以将多个添加&lt;span lang=&quot;EN-US&quot;&gt;/更新&lt;span lang=&quot;EN-US&quot;&gt;/删除操作合并到对&lt;span lang=&quot;EN-US&quot;&gt;“SaveChanges”的单个调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
    　　context.Blogs.Add(&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://sample.com/blog_one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
   　　 context.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://sample.com/blog_two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });

    　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; update&lt;/span&gt;
    　　&lt;span&gt;var&lt;/span&gt; firstBlog =&lt;span&gt; context.Blogs.First();
    　　firstBlog.Url &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

   　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove&lt;/span&gt;
    　　&lt;span&gt;var&lt;/span&gt; lastBlog =&lt;span&gt; context.Blogs.Last();
    　　context.Blogs.Remove(lastBlog);

    　　context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二.关联数据&lt;/h3&gt;
&lt;p&gt;　　除了上面对独立实体进行保存外，还可以保存模型中定义的关系(主体实体和依赖实体)&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　1.1 添加关系数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　　　如果创建多个新的依赖实体，在添加主体到上下文时，也会添加其他依赖实体。在下面的示例中，&lt;span lang=&quot;EN-US&quot;&gt;blog博客和三篇相关文章&lt;span lang=&quot;EN-US&quot;&gt;post将全部被插入数据库中。&lt;span lang=&quot;EN-US&quot;&gt; &lt;span data-ttu-id=&quot;ab412-108&quot;&gt;由于可通过&lt;span lang=&quot;EN-US&quot;&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;Blog.Posts&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; 导航属性访问这些文章，因此可发现并添加它们(Posts三条信息到数据库)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog
    {
        Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blogs.msdn.com/dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Posts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Post&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Post { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intro to C#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Post { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intro to VB.NET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Post { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intro to F#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
        }
    };
　　
    context.Blogs.Add(blog);
    context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　1.2 添加相关实体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　如果从上下文跟踪的实体的导航属性中，引用新实体。将发现该新实体并将其插入到数据库中。在下面的示例中，会保存 post 实体，因为该实体会添加到已从数据库中提取的 blog 实体的 Posts 属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;var&lt;/span&gt; blog = context.Blogs.Include(b =&amp;gt;&lt;span&gt; b.Posts).First();
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; post = &lt;span&gt;new&lt;/span&gt; Post { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intro to EF Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
      &lt;/span&gt;&lt;span&gt;//引用新实体， &lt;/span&gt;
&lt;span&gt;      blog.Posts.Add(post);&lt;br/&gt;context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　&lt;strong&gt;1.3 更改关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;如果更改实体的导航属性，则将对数据库中的外键列进行相应的更改。在下面的示例中，&lt;span&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;post&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; 依赖实体更新关系，关联新的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;blog&lt;/span&gt;&lt;/code&gt;&lt;code&gt;主体&lt;/code&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;实体&lt;/span&gt;，新 &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;blog&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; 会插入到数据库中， &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;post&lt;/span&gt;&lt;/code&gt;的导航属性引用的新实体&lt;span lang=&quot;EN-US&quot;&gt;blog。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增一个主体实体&lt;/span&gt;
   　　 &lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blogs.msdn.com/visualstudio&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
   　　 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; post =&lt;span&gt; context.Posts.First();
   　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;post更新关系&lt;/span&gt;
   　　 post.Blog =&lt;span&gt; blog;

   　　 context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　1.4 删除关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　在下面的示例中，对 &lt;code&gt;Blog&lt;/code&gt; 和 &lt;code&gt;Post&lt;/code&gt; 之间的关系配置了级联删除，因此将从数据库中删除 &lt;code&gt;post&lt;/code&gt; 实体。     &lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    　　&lt;span&gt;var&lt;/span&gt; blog = context.Blogs.Include(b =&amp;gt;&lt;span&gt; b.Posts).First();
   　　 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; post =&lt;span&gt; blog.Posts.First();
    　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除一条post依赖实体&lt;/span&gt;
&lt;span&gt;   　　 blog.Posts.Remove(post);

    　　context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;三.联级删除 &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　级联删除是指：允许在删除某行时，自动触发删除相关的行。 &lt;span&gt;即依赖实体与主实体的关系已断开时，自动删除该子实体&lt;/span&gt;，这通常称为“删除孤立项”。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.1 实体删除示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;var&lt;/span&gt; blog = context.Blogs.Include(b =&amp;gt;&lt;span&gt; b.Posts).First();
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts =&lt;span&gt; blog.Posts.ToList();
       context.Remove(blog);

       context.SaveChanges();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　--&lt;/span&gt;&lt;span&gt; 解发SaveChanges后，删除主体时，先自动删除子实体(具有必选或可选关系的 DeleteBehavior.Cascade级联)&lt;/span&gt;
    &lt;span&gt;DELETE&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Posts&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PostId&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;DELETE&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Posts&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PostId&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
    &lt;span&gt;DELETE&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Blogs&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;BlogId&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　关于联级删除，涉及到的外键约束包括：可选关系（可以为 null 的外键） 和 必须关系（不可为 null 的外键），&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/core/saving/cascade-delete&quot; target=&quot;_blank&quot;&gt;参考官网&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;四&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt; &lt;span&gt;事务&lt;/span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　事务是指：允许以原子方式处理多个数据库操作。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span data-ttu-id=&quot;8917b-104&quot;&gt;如果已提交事务，则所有操作都会成功应用到数据库。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span data-ttu-id=&quot;8917b-105&quot;&gt;如果已回滚事务，则所有操作都不会应用到数据库。关于数据事务的详细介绍可网上查看。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-ttu-id=&quot;8917b-105&quot;&gt;　　&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.1&lt;/span&gt; 默认事务行为(隐式事务)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　默认情况下，如果数据库提供程序支持事务，则会在事务中应用对&lt;span lang=&quot;EN-US&quot;&gt; SaveChanges() &lt;/span&gt;的单一调用中的所有更改。&lt;span lang=&quot;EN-US&quot;&gt;  &lt;/span&gt;这意味着&lt;span lang=&quot;EN-US&quot;&gt;SaveChanges() &lt;/span&gt;可保证提交到数据库完全成功或在出现错误时全部回滚。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;/span&gt;　下面来演示默认事务行为，建立&lt;span lang=&quot;EN-US&quot;&gt;blogs&lt;/span&gt;表的&lt;span lang=&quot;EN-US&quot;&gt;url&lt;/span&gt;字段唯一约束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　--&lt;/span&gt;&lt;span&gt;创建唯一索引&lt;/span&gt;
　　　　&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; IX_Url &lt;span&gt;ON&lt;/span&gt; Blogs(Url)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改数据&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; BloggingContext.Blogs.First();
        blog.Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入数据，再次插入违反约束&lt;/span&gt;
        BloggingContext.Blogs.Add(&lt;span&gt;new&lt;/span&gt; Blog() { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
           
        BloggingContext.SaveChanges();&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　检查数据库，该表数据没有做任何更改，通过&lt;span lang=&quot;EN-US&quot;&gt;sql&lt;/span&gt; 监听如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201902/151560-20190228145433901-877134081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4.2  控制事务（显示事务）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;对于大多数应用程序，上面4.1 默认事务已足够。 如果应用程序要求被视为有必要，则应该仅手动控制事务。&lt;/p&gt;
&lt;p&gt;　　　　可以使用&lt;span lang=&quot;EN-US&quot;&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;DbContext.Database&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; API 开始、提交和回滚事务。&lt;span lang=&quot;EN-US&quot;&gt; &lt;span data-ttu-id=&quot;8917b-115&quot;&gt;以下示例显示了两个&lt;span lang=&quot;EN-US&quot;&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;SaveChanges()&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; 操作以及正在单个事务中执行的 &lt;span lang=&quot;EN-US&quot;&gt;LINQ 查询。&lt;span&gt;并非所有数据库提供程序都支持事务。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span data-ttu-id=&quot;8917b-117&quot;&gt;&lt;span&gt;调用事务&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;API 时，某些提供程序可能会引发异常或不执行任何操作&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; transaction =&lt;span&gt; context.Database.BeginTransaction())
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            context.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blogs.msdn.com/dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            context.SaveChanges();

            context.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blogs.msdn.com/visualstudio&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            context.SaveChanges();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blogs =&lt;span&gt; context.Blogs
                .OrderBy(b &lt;/span&gt;=&amp;gt;&lt;span&gt; b.Url)
                .ToList();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Commit transaction if all commands succeed, transaction will auto-rollback&lt;/span&gt;&lt;span&gt; when disposed if either commands fails&lt;/span&gt;
&lt;span&gt;            transaction.Commit();
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Handle failure&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　4.3 跨上下文事务（仅限关系数据库）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;可以跨多个EF上下文实例，共享一个事务。 &lt;span&gt;此功能仅在使用关系数据库提供程序时才可用&lt;/span&gt;，因为该提供程序需要使用特定于关系数据库的 &lt;code&gt;DbTransaction&lt;/code&gt; 和 &lt;code&gt;DbConnection&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　　　(1) 允许在外部提供连接&lt;/p&gt;
&lt;p&gt;　　　　　　是指共享 &lt;code&gt;DbConnection&lt;/code&gt; 时，需要在DbContext构造上下文时向其中传入连接的功能。最简单方式是停止使用默认的 &lt;code&gt;DbContext.OnConfiguring&lt;/code&gt; 方法来配置上下文，在外部创建 &lt;code&gt;DbContextOptions&lt;/code&gt;，然后将其传递到上下文构造函数。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BloggingContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DbConnection _connection;
      
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BloggingContext(DbConnection connection)
    {
      _connection &lt;/span&gt;=&lt;span&gt; connection;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(_connection);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　(2)共享连接和跨上下文的事务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建共享连接&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt; DbContextOptionsBuilder&amp;lt;BloggingContext&amp;gt;&lt;span&gt;()
    .UseSqlServer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(connectionString))
    .Options;

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BloggingContext(options))
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; transaction =&lt;span&gt; context1.Database.BeginTransaction())
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            context1.Blogs.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Blog { Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://blogs.msdn.com/dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            context1.SaveChanges();

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BloggingContext(options))
            {
                &lt;span&gt;context2.Database.UseTransaction(transaction.GetDbTransaction());

                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blogs =&lt;span&gt; context2.Blogs
                    .OrderBy(b &lt;/span&gt;=&amp;gt;&lt;span&gt; b.Url)
                    .ToList();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Commit transaction if all commands succeed, transaction will auto-rollback&lt;/span&gt;&lt;span&gt; when disposed if either commands fails&lt;/span&gt;
&lt;span&gt;&lt;span&gt;            transaction.Commit();&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Handle failure&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　未完...&lt;/p&gt;

&lt;p&gt; 参考文献：&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/core/saving/&quot; target=&quot;_blank&quot;&gt;保存数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Feb 2019 08:00:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一. 基本数据 每个EF上下文实例都有一个 ChangeTracker(更改跟踪器)，它负责跟踪需要写入数据库的更改。 当更改实体类的实例时(修改属性，删除实例，新建实例等)，这些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10448663.html</dc:identifier>
</item>
<item>
<title>一步步学会用docker部署应用(nodejs版) - royalrover</title>
<link>http://www.cnblogs.com/accordion/p/10450952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accordion/p/10450952.html</guid>
<description>&lt;p&gt;docker是一种虚拟化技术，可以在内核层隔离资源。因此对于上层应用而言，采用docker技术可以达到类似于虚拟机的沙盒环境。这大大简化了应用部署，让运维人员无需陷入无止境繁琐的依赖环境及系统配置中；另一方面，容器技术也可以充分利用硬件资源，做到资源共享。&lt;/p&gt;
&lt;p&gt;本文将采用docker技术部署一个简单的nodejs应用，它包括一个简单的前置网关nginx、redis服务器以及业务服务器。同时使用dockerfile配置特定镜像，采用docker-compose进行容器编排，解决依赖、网络等问题。&lt;/p&gt;
&lt;h2 id=&quot;docker基础&quot;&gt;docker基础&lt;/h2&gt;
&lt;p&gt;本文默认机器已安装docker环境，即可以使用docker和docker-compose服务，如果本地没有安装，则参考：&lt;/p&gt;
&lt;ol readability=&quot;-0.712&quot;&gt;&lt;li readability=&quot;-0.65625&quot;&gt;
&lt;p&gt;安装docker及docker-compose，可参考 &lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;Install Docker Compose&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.76666666666667&quot;&gt;
&lt;p&gt;docker compose 技术可以查看官方文档 &lt;a href=&quot;https://github.com/nodejs/docker-node/blob/master/README.md#how-to-use-this-image&quot;&gt;Docker Compose&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;docker源&quot;&gt;docker源&lt;/h3&gt;
&lt;p&gt;默认docker采用官方镜像，国内用户下载镜像速度较慢，为了更好的体验，建议切换源。&lt;br/&gt;OSX系统通过添加 ~/.docker/daemon.json文件，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io/&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可，镜像源地址可替换，随后重启docker服务即可。&lt;/p&gt;
&lt;p&gt;linux系统通过修改 /etc/docker/daemon.josn文件，一样可以替换源。&lt;/p&gt;
&lt;h3 id=&quot;docker简单操作&quot;&gt;docker简单操作&lt;/h3&gt;
&lt;p&gt;源切换完毕之后，就可以尝试简单的容器操作。&lt;br/&gt;首先，运行一个简单的容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it node:8-slim node&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run命令，根据某个版本的node镜像运行容器，同时执行 “node”命令，进入node命令行交互模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d node:8-slim node&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 -d 选项，让容器以daemon进程运行，同时返回容器的hash值。根据该hash值，我们可以通过命令行进入运行的容器查看相关状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it hashcode bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hashcode可以通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到对应容器的hashcode&lt;/p&gt;
&lt;p&gt;关于镜像的选择以及版本的确定，可以通过访问官方 &lt;code&gt;https://hub.docker.com/&lt;/code&gt; 搜索，根据结果寻找 &lt;em&gt;official image&lt;/em&gt;使用，当然也可根据下载量和star数量进行选择。&lt;/p&gt;
&lt;p&gt;对于镜像的tag，则根据业务需求进行判断是否需要完整版的系统。如nodejs镜像，仅仅需要node基础环境而不需要其他的系统预装命令，因此选择了 node:-slim 版本。&lt;/p&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;从源下载的镜像大多数不满足实际的使用需求，因此需要定制镜像。镜像定制可以通过运行容器安装环境，最后提交为镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it node:8-slim bash
root@ff05391b4cf8:/# echo helloworld &amp;gt; /home/text
root@ff05391b4cf8:/# exit
docker commit ff05391b4cf8 node-hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行该镜像即可。&lt;/p&gt;
&lt;p&gt;另一种镜像定制可以通过Dockerfile的形式完成。Dockerfile是容器运行的配置文件，每次执行命令都会生成一个镜像，直到所有环境都已设置完毕。&lt;/p&gt;
&lt;p&gt;Dockerfile文件中可以执行命令定制化镜像，如 “FROM、COPY、ADD、ENV、EXPOSE、RUN、CMD”等，具体dockerfile的配置可参考相关文档。&lt;/p&gt;
&lt;p&gt;Dockerfile完成后，进行构建镜像:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t node:custom:v1 .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;镜像构建成功后即可运行容器。&lt;/p&gt;
&lt;h2 id=&quot;docker-compose&quot;&gt;docker-compose&lt;/h2&gt;
&lt;p&gt;关于docker-compose，将在下文示例中进行说明。&lt;/p&gt;
&lt;h2 id=&quot;示例搭建nodejs应用&quot;&gt;示例：搭建nodejs应用&lt;/h2&gt;
&lt;blockquote readability=&quot;4.1666666666667&quot;&gt;
&lt;p&gt;本文所有代码已开源至&lt;a href=&quot;https://github.com/royalrover/docker-web-examples&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;docker-compose.yml&quot;&gt;docker-compose.yml&lt;/h3&gt;
&lt;p&gt;在docker-compose.yml中配置相关服务节点，同时在每个服务节点中配置相关的镜像、网络、环境、磁盘映射等元信息，也可指定具体Dockerfile文件构建镜像使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3'
services:
  nginx:
    image: nginx:latest
    ports:
      - 80:80
    restart: always  
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - /tmp/logs:/var/log/nginx

  redis-server:
    image: redis:latest
    ports:
      - 6479:6379
    restart: always

  app:
    build: ./
    volumes:
      - ./:/usr/local/app
    restart: always  
    working_dir: /usr/local/app
    ports:
      - 8090:8090
    command: node server/server.js
    depends_on:
      - redis-server
    links:
      - redis-server:rd&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis服务器&quot;&gt;redis服务器&lt;/h3&gt;
&lt;p&gt;首先搭建一个单节点缓存服务，采用官方提供的redis最新版镜像，无需构建。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3'
services:
  redis-server:
    image: redis:latest
    ports:
      - 6479:6379
    restart: always&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于version具体信息，可参考&lt;a href=&quot;https://docs.docker.com/compose/compose-file/&quot;&gt;Compose and Docker compatibility matrix&lt;/a&gt;找到对应docker引擎匹配的版本格式。&lt;br/&gt;在services下，创建了一个名为 &lt;strong&gt;redis-server&lt;/strong&gt; 的服务，它采用最新的redis官方镜像，并通过宿主机的6479端口向外提供服务。并设置自动重启功能。&lt;/p&gt;
&lt;p&gt;此时，在宿主机上可以通过6479端口使用该缓存服务。&lt;/p&gt;
&lt;h3 id=&quot;web应用&quot;&gt;web应用&lt;/h3&gt;
&lt;p&gt;使用node.js的koa、koa-router可快速搭建web服务器。在本节中，创建一个8090端口的服务器，同时提供两个功能：1. 简单查询单个key的缓存 2. 流水线查询多个key的缓存&lt;/p&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services:
  app:
    build: ./
    volumes:
      - ./:/usr/local/app
    restart: always  
    working_dir: /usr/local/app
    ports:
      - 8090:8090
    command: node server/server.js
    depends_on:
      - redis-server
    links:
      - redis-server:rd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处创建一个app服务，它使用当前目录下的Dockerfile构建后的镜像，同时通过 volumes 配置磁盘映射，将当前目录下所有文件映射至容器的/usr/local/app，并制定为运行时目录；同时映射宿主机的8090端口，最后执行&lt;code&gt;node server/server.js&lt;/code&gt;命令运行服务器。&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;depends_on&lt;/strong&gt;设置app服务的依赖，等待 redis-server 服务启动后再启动app服务；通过&lt;strong&gt;links&lt;/strong&gt;设置容器间网络连接，在app服务中，可通过别名 &lt;strong&gt;rd&lt;/strong&gt; 访问redis-server。&lt;/p&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM node:8-slim
COPY ./ /usr/local/app
WORKDIR /usr/local/app
RUN npm i --registry=https://registry.npm.taobao.org
ENV NODE_ENV dev
EXPOSE 8090  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定的Dockerfile则做了初始化npm的操作。&lt;/p&gt;
&lt;p&gt;web-server sourcecode&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const Koa = require('koa');
const Router = require('koa-router');
const redis = require('redis');
const { promisify } = require('util');


let app = new Koa();
let router = new Router();
let redisClient = createRedisClient({
    // ip为docker-compose.yml配置的redis-server别名 rd，可在应用所在容器查看dns配置
    ip: 'rd',
    port: 6379,
    prefix: '',
    db: 1,
    password: null
});

function createRedisClient({port, ip, prefix, db}) {
    let client = redis.createClient(port, ip, {
        prefix,
        db,
        no_ready_check: true
    });
    
    client.on('reconnecting', (err)=&amp;gt;{
        console.warn(`redis client reconnecting, delay ${err.delay}ms and attempt ${err.attempt}`);
    });
    
    client.on('error', function (err) {
        console.error('Redis error!',err);
    });
    
    client.on('ready', function() {
        console.info(`redis初始化完成,就绪: ${ip}:${port}/${db}`);
    });
    return client;
}

function execReturnPromise(cmd, args) {
    return new Promise((res,rej)=&amp;gt;{
        redisClient.send_command(cmd, args, (e,reply)=&amp;gt;{
            if(e){
                rej(e);
            }else{
                res(reply);
            }
        });
    });
}

function batchReturnPromise() {
    return new Promise((res,rej)=&amp;gt;{
        let b = redisClient.batch();
        b.exec = promisify(b.exec);
        res(b);
    });
}


router.get('/', async (ctx, next) =&amp;gt; {
    await execReturnPromise('set',['testkey','helloworld']);
    let ret = await execReturnPromise('get',['testkey']);
    ctx.body = {
        status: 'ok',
        result: ret,
    };
});

router.get('/batch', async (ctx, next) =&amp;gt; {
    await execReturnPromise('set',['testkey','helloworld, batch!']);
    let batch = await batchReturnPromise();
    for(let i=0;i &amp;lt; 10;i++){
        batch.get('testkey');
    }
    let ret = await batch.exec();
    ctx.body = {
        status: 'ok',
        result: ret,
    };
});

app
  .use(router.routes())
  .use(router.allowedMethods())
  .listen(8090);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，在web服务所在的容器中，通过别名 &lt;strong&gt;rd&lt;/strong&gt; 访问缓存服务。&lt;/p&gt;
&lt;p&gt;此时，运行命令 &lt;code&gt;docker-compose up&lt;/code&gt;后，即可通过 http://127.0.0.1:8090/ http://127.0.0.1:8090/batch 访问这两个缓存服务。&lt;/p&gt;
&lt;h3 id=&quot;转发&quot;&gt;转发&lt;/h3&gt;
&lt;p&gt;目前可以通过宿主机的8090端口访问服务，为了此后web服务的可扩展性，需要在前端加入转发层。实例中使用nginx进行转发：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services:
  nginx:
    image: nginx:latest
    ports:
      - 80:80
    restart: always  
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - /tmp/logs:/var/log/nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采用最新版的nginx官方镜像，向宿主机暴露80端口，通过在本地配置nginx的抓发规则文件，映射至容器的nginx配置目录下实现快速高效的测试。&lt;/p&gt;
&lt;h2 id=&quot;运行与扩展&quot;&gt;运行与扩展&lt;/h2&gt;
&lt;p&gt;默认单节点下，直接运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可运行服务。&lt;/p&gt;
&lt;p&gt;如果服务节点需要扩展，可通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up -d --scale app=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展为3个web服务器，同时nginx转发规则需要修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream app_server { # 设置server集群,负载均衡关键指令
    server docker-web-examples_app_1:8090; # 设置具体server,
    server docker-web-examples_app_2:8090;
    server docker-web-examples_app_3:8090;
}

server {
    listen 80;
    charset utf-8;

    location / {
        proxy_pass http://app_server;
        proxy_set_header Host $host:$server_port;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app_server内部的各个服务器名称为&lt;strong&gt;docker-web-examples_app_1&lt;/strong&gt;，format为“&lt;span class=&quot;math inline&quot;&gt;\({path}_\)&lt;/span&gt;{service}_${number}”,&lt;/p&gt;
&lt;p&gt;即第一部分为 docker-compose.yml所在目录名称，如果在根目录则为应用名称；&lt;br/&gt;第二部分为扩展的服务名；&lt;br/&gt;第三部分为扩展序号&lt;/p&gt;
&lt;p&gt;通过设置nginx的配置的log_format中upstream_addr变量，可观察到负载均衡已生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http{
    log_format  main  '$remote_addr:$upstream_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/compose/compose-file/&quot;&gt;docker官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36148847/article/details/79427878&quot;&gt;docker-compose.yml 配置文件编写详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jsonhc/p/7767669.html&quot;&gt;Dockerfile实践&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 07:56:00 +0000</pubDate>
<dc:creator>royalrover</dc:creator>
<og:description>一步步学会用docker部署应用 docker是一种虚拟化技术，可以在内核层隔离资源。因此对于上层应用而言，采用docker技术可以达到类似于虚拟机的沙盒环境。这大大简化了应用部署，让运维人员无需陷入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accordion/p/10450952.html</dc:identifier>
</item>
<item>
<title>ALLOT流控设备操作手册指引 - CARLOS_CHIANG</title>
<link>http://www.cnblogs.com/yaoyaojcy/p/10450789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoyaojcy/p/10450789.html</guid>
<description>


&lt;h2&gt;&lt;span&gt;1.1 设备介绍&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.1.1 NetXploeer三层结构&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154044533-2107692378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Allot设备的管理如上图所示，采用三层结构。&lt;/p&gt;
&lt;p&gt;1）NetEnforcer层，包括所有型号的NetEnforcer设备连接到用户的网络中，在这一层主要起到收集网络数据和实施策略的作用。&lt;/p&gt;
&lt;p&gt;2）NetXplorer层，在服务器中安装特定版本的Java SDK 和NetXplorer 软件，在这一层中NetXplorer 服务器中存储了各种协议、策略等，并从NetEnforer 端收集网络数据存储在数据库中，并可以做NetEnforcer 的基础配置及策略配置，下发到远端的NetEnforcer。&lt;/p&gt;
&lt;p&gt;3）用户使用界面层(GUI)，可以是任何的具有浏览器的和安装了特定版本的JRE 的客户端。在这一层GUI 中起到管理的作用。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;当一台NetXplorer管理到5台以上AC1000或AC2500、10台以上的AC800、或15台以上的AC400则需要使用到Data Collector。&lt;/p&gt;
&lt;p&gt;通过以上结构，我们可知 Allot 流量管理设备主要有两种管理方式：&lt;/p&gt;
&lt;p&gt;①  命令行界面管理（直接在NetEnforcer上进行操作）&lt;/p&gt;
&lt;p&gt;② 图形界面管理（通过NetXplorer 对设备进行管理）&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.1.2 设备介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;S0&quot;&gt;采用设备型号ALLOT NetEnforcer AC-504。&lt;/p&gt;
&lt;p class=&quot;S0&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154109338-1511662640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.2 管理方式&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.2.1 命令行管理方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;命令行界面管理，即命令行的操作与管理，可以通过三种方式进入：&lt;/p&gt;
&lt;p&gt;1）超级终端： 进入字符管理界面。使用超级终端登录（波特率：19200，数据位：8，奇偶校验：N（无），停止位：（1）&lt;/p&gt;
&lt;p&gt;2）SSH（V2）：直接采用IP地址登录设备&lt;/p&gt;
&lt;p&gt;3）Telnet：直接采用IP地址登录设备&lt;/p&gt;
&lt;p&gt;进入命令行后，可以使用两个用户名登录：admin和root, 其密码分别为：allot 和bagabu，其两个用户有区别在于使用的权限不一样：&lt;/p&gt;
&lt;p&gt;1）admin 用户只能对设备作简单的配置&lt;/p&gt;
&lt;p&gt;2）root 具有超级用户的权限，二者的密码都可以根据用户的需求进修改&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.2.2 图形界面管理方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;图形界面操作方式，就是 NetXplorer（以下简称NX）的管理界面，用户可以通过访问NX 服务器的IP 地址来登录其管理界面，其默认登录的用户名及密码分别是：admin 和allot。（登录后可以修改密码，也可以创建不同权限的用户）&lt;br/&gt;目前主要allot的管理方式采用图形界面NX管理。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154013768-1864970695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.1 NX管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在 PC 机上的浏览器（如IE、Chrome 等）地址栏中直接输入NX 服务器的IP 地址，然后按“回车”键，在弹出的IE 界面中选择第二个选项“&lt;strong&gt;Launch NetXplorer&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;如下图：这前提需要操作的PC 机上装有JRE（Java 运行环境）版本，如果操作PC 机上未安装JRE，需要运行第一个选项，安装完成后，在弹出界面输入用户名和密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154215515-2009867046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2 语言切换&lt;/p&gt;
&lt;p&gt;登陆后默认语言为英文，通过下面方式可更改其他语种：&lt;/p&gt;
&lt;p&gt;“Tools”下拉菜单选择“Display Language Configuration”共有 3 种语言可以选择，分别为：英语/韩语/中文三种，选择“Chinese”点击“Save”保存选项，系统会要求重新打开中文的NX 管理界面。实施步骤如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154235236-280135228.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.2 界面各功能区域介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;NX 图型界面分为：菜单栏、工具栏、配置选项区（导航栏）、明细区（策略、数据、图表显示区）、警告栏 5 部分。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.1 菜单栏&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如下图，显示的是“菜单栏”和“工具栏”，最上面区域是菜单栏，分别为“文件”“编辑”“视图”“动作”“工具”“窗口”“帮助”，主要NX 界面的各项操作，如添加设备、编辑策略、定义主机、定义报表、更改语言、流量监视、窗口排列等功能都可以通过各菜单项实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154330048-1857719636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.2 工具栏&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如上图，在菜单下是“工具栏”，各工具按钮是功能菜单的快捷键，方便用户操作。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.3 导航栏&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在界面的最左侧为导航栏，导航栏是对 NX 平台功能的分类。如下图，“导航栏”分别有：&lt;br/&gt;①“网络”：“网络”栏中所列的是 NX 管理平台所管理的流量控制设备及实时数据收集和长期数&lt;/p&gt;
&lt;p&gt;据收集两个服务状态，并且在“网络”中，列出了每个流控设备下所做的策略，是一个树形结构。在每个策略或设备上都可以查看该设备或策略的属性或流量情况。&lt;/p&gt;
&lt;p&gt;②“类别”：NX 平台的对象都需要在“类别”中定义，如构成策略的条件有：主机、服务、时间等对象；对策略起到控制作用的动作有：QoS 和DoS 等对象。这些对象都存放于类别中，配置策略时，可以在策略编辑表中直接调用。而且Allot 提供了便利的操作方式，即点击左侧导航栏中相应的选项，在明细区中会连动显示对应的明细。&lt;/p&gt;
&lt;p&gt;③“时间/告警”：事件/告警是NX 平台为用户提供流量管理及监视设备运行状态的辅助工具。用户可以根据实际需要对某种流量进行告警阈值设定，当流量超过/等于或低于阈值时，会产生（取消）告警信息，并支持发邮件给管理者。&lt;/p&gt;
&lt;p&gt;④“报告”：NX 平台支持的网络流量监视视图超过100 种，而这100 多种视图都可以设定成报告形式展现给管理者，并且支持定时生成、特定格式如：JPG/PDF/CSV/HTML 等、报表生成后自动发邮件等功能。&lt;/p&gt;
&lt;p&gt;⑤“群组”：NX 平台为用户提供了策略流量对比功能，用户可以通过群组的方式将几个经常需要对比流量的策略放在一起进行监视，极大的方便用户对网络情况的掌握。&lt;br/&gt;⑥“NPP账户”：多用于运营商用户，即用户可以建立一个或多个NPP 帐户，将网络中符合某些条件（如IP 地址、服务等）的流量管理权限交给这些特定的NPP 帐户进行管理。NPP 管理界面是NX 操作&lt;br clear=&quot;all&quot;/&gt;
界面的简化版，与NX 界面类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154350227-1722150773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3.4 明细区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在导航栏的右侧，空间最大的区域为明细区。所有的流量监视、策略配置、类别定义等操作都是在这个区域进行的。而且在导航栏中各功能区进行相关操作，在明细区会连动显示。&lt;/p&gt;
&lt;p&gt;点击明细区的各标题项，可以相互切换明细区的当前显示界面。如下图：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154411567-2058231984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154436915-1736623791.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.5 告警区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在“导航栏”和“明细区”的下方是“告警区”，来自设备及策略的所有重要和严重告警信息都会及时的显示在告警区中，并且可以提供相应的问题描述&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.3 导航栏-配置类别catalogs&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在 NX 平台上，导航栏中的“类别”项可以定义主机、时间、DOS、QoS 等对象，流量控制策略是由这些对象构成的。&lt;/p&gt;
&lt;p&gt;单击导航栏中“类别”内的各对象项，在明细区会连动显示相应内容。如下图，单击“类别”中“主机”项，在明细区会显示NX平台内所有主机的配置情况。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154528100-1816349028.png&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;405&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3.1 主机hosts&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在一个主机列表中，可以包含主机名、单个IP 地址、IP range（IP 地址范围）、 IP subnet（IP 子网）、MAC 以及以上的集合。定义主机简单分如下几步：&lt;/p&gt;
&lt;p&gt;1、在导航栏中单击“类别”；&lt;/p&gt;
&lt;p&gt;2、在“类别”列表中选择“主机”项，这时在明细区会显示所有主机列表；&lt;/p&gt;
&lt;p&gt;3、在明细区的主机列表中点击右键，在右键菜单中选择“新建主机列表”；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154554048-1169374154.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;378&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br clear=&quot;all&quot;/&gt;
4、在弹出的主机定义对话框中设定主机名、主机项等，并保存。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3.2 定义时间times&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;时间条件：分为每天的几点到几点、每周中的每天几点到几点、每月的每天几点到几点、每年选项。&lt;/p&gt;
&lt;p&gt;设定时间时，注意如果使用时间条件，要把24 小时严格进行设置不要漏掉一些时段且不要跨跃午夜0 点。最常用的时间段设置有如下两种：&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3.2.1 普通“每天”设置（不分周六、周日）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、工作时间：（包含2 个时间段，即上午和下午）&lt;/p&gt;
&lt;p&gt;a) 上午：“频率”设置为‘每天’，“时间段”设置为：起始‘07：50’，结束‘11：30’&lt;/p&gt;
&lt;p&gt;b) 下午：“频率”设置为‘每天’，“时间段”设置为：起始‘13：00’，结束‘17：00’&lt;/p&gt;
&lt;p&gt;2、休息时间：（包含3 个时间段）&lt;/p&gt;
&lt;p&gt;a) 中午：“频率”设置为‘每天’，“时间段”设置为：起始‘11：30’，结束‘13：00’&lt;/p&gt;
&lt;p&gt;b) 晚上：“频率”设置为‘每天’，“时间段”设置为：起始‘17：00’，结束‘00：00’&lt;/p&gt;
&lt;p&gt;c) 晚上：“频率”设置为‘每天’，“时间段”设置为：起始‘00：00’，结束‘07：50’&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.3.2.2 包含周六、周日的时间段设定&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、工作时间：（包含每周一、二、三、四、五的上午和下午时间段，共10 个时间段）&lt;/p&gt;
&lt;p&gt;a)   上午：“频率”设置为‘每周’，“时间段”设置为：起始‘07：50’，结束‘11：30’&lt;/p&gt;
&lt;p&gt;“循环”设置为‘Monday/Tuesday/Wednesday/Thursday/Friday’，每个设置1 次，在列表中共5 个“上午”时间段&lt;/p&gt;
&lt;p&gt;b)   下午：“频率”设置为‘每周’，“时间段”设置为：起始‘13：00’，结束‘17：00’，&lt;/p&gt;
&lt;p&gt;“循环”设置为‘Monday/Tuesday/Wednesday/Thursday/Friday’，每个设置1 次，在列表中共5 个“下午”时间段&lt;/p&gt;
&lt;p&gt;2、休息时间：（包含每天中午、晚上及周六、周日，5 个时间段）&lt;/p&gt;
&lt;p&gt;a)  中午：“频率”设置为‘每天’，“时间段”设置为：起始‘11：30’，结束‘13：00’&lt;/p&gt;
&lt;p&gt;b)  晚上：“频率”设置为‘每天’，“时间段”设置为：起始‘17：00’，结束‘00：00’&lt;/p&gt;
&lt;p&gt;c)  晚上：“频率”设置为‘每天’，“时间段”设置为：起始‘00：00’，结束‘07：50’&lt;/p&gt;
&lt;p&gt;d)  周六：“频率”设置为‘每周’，“时间段”设置为：‘所有天’，“循环”设置为“Saturday”&lt;/p&gt;
&lt;p&gt;e)  周日：“频率”设置为‘每周’，“时间段”设置为：‘所有天’，“循环”设置为“Sunday”&lt;/p&gt;
&lt;p&gt;\&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154652278-553483589.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3.3 服务质量QoS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;QoS 动作：建立QoS 要注意 QoS 分为Line、Pipe、VC 三种级别。&lt;/p&gt;
&lt;p&gt;l  三种级别分别对应策略表中的Line、Pipe、VC 三个级别，相同级别的QoS 设置可以相互调用；&lt;/p&gt;
&lt;p&gt;l  不同级别使用不同级别的 QoS 动作，通过QoS 动作设置双向最小带宽保障、最大带宽限制。&lt;/p&gt;
&lt;p&gt;如下图：设置pipe 级别的最大1M 带宽限制。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154714342-1223776469.png&quot; alt=&quot;&quot; width=&quot;713&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3.4 DoS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;DOS 动作：DOS 动作定义了最大连接数、最大连接数建立/秒（不建议设置该属性）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154730501-1441176379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个属性，超过设置的数值可以选择丢弃或拒绝两个动作。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.4 导航栏-配置网络-策略policy&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;建策略主要分两步：&lt;/p&gt;
&lt;p&gt;第一步是建立“条件”和“动作”的对象，这些对象需要在“类别catalogs”中建立；&lt;/p&gt;
&lt;p&gt;第二步是在“策略表”中建相应的pipe 和VC，然后再把这些建好的“条件”和“动作”的对象加到策略表中来，加完后确保无误再保存，使其生效。如下图：定义一个名称为ERP的内部YK访问外部erp_server，保证带宽8~10M 。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154742891-1730854740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.4.1 Policy表的“列”的选择&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;下图显示列、pipe、vc的格局分配：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154752512-2020358650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在list表中右键菜单-“执行策略编辑器”，在明细区显示出所有的策略：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154801182-111702480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在策略表中包含不常用的列表内容，如“描述”、“&lt;strong&gt;DoS&lt;/strong&gt;”等。&lt;/p&gt;
&lt;p&gt;在“标题列”中右键-“策略表的列内容配置”会弹出如下右键菜单添加。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154821771-1078775212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.4.2 Pipe、VC 定义（以Piep 为例 VC 类似）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;建立 Pipe、VC 并对Pipe、VC 的条件和动作进行选择。在策略表中的某个pipe上点击右键，在弹出的右键菜单中可以看到“插入 &lt;strong&gt;Pipe…&lt;/strong&gt;”和“插入 &lt;strong&gt;Pipe Template…&lt;/strong&gt;”以及“移动向上”和“移动向下”等几个选项。&lt;/p&gt;
&lt;p&gt;当选择“插入 &lt;strong&gt;Pipe…&lt;/strong&gt;”后，系统会弹出如下图的Pipe 编辑对话框，要完成这个pipe的定义，可在这个对话框中可以填写Pipe 的“名称（只能写英文&lt;strong&gt;+&lt;/strong&gt;数字）”例如：“&lt;strong&gt;vlan68&lt;/strong&gt;”；在“描述”中可以写中文，如“办公厅”；双击“条件”框中的“内部”列选择之前定义的主机列表，如‘Vlan68’，然后选择“&lt;strong&gt;OK&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;注意：在这里执行“&lt;strong&gt;OK&lt;/strong&gt;”后，此对话框关闭，回到策略表。但此策略并未真正生效，需要再进一步确认，在确认保存之前还可以对这个Pipe 中的其他“条件”或“动作”进行修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154833895-1023206553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.4.2.1 对新建Pipe 中各“条件”的选择（包括：内部、外部、服务、时间）&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;1）选择主机（内部主机和外部主机）&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154850030-197428183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;2）选择时间：&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154916448-1623351259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;3）选择协议：&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154941310-424000062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.4.2.2 对新建Pipe 中各“动作”的选择（包括：QoS、DoS、动作访问）&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;）&lt;strong&gt;QoS&lt;/strong&gt;：（带宽限制或带宽保障）：&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228154953428-1942870731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;）&lt;strong&gt;DoS&lt;/strong&gt;（限制连接数）：&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155014434-1155597849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;） 访问动作：&lt;/p&gt;
&lt;p class=&quot;S&quot; align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155028798-486963956.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2.4.2.3 策略即时生效操作&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;完成对 Pipe、VC 的主机、协议、时间条件选择及访问动作选择、QoS 控制选择、DoS控制选择后，点击“工具按钮”中最左侧的“保存”按钮，即完成策略的即时生效。如下图：单击左上角保存策略按钮。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155038316-686979427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.5 实时监视流量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;由于图形界面的管理平台是基于 Jave 开发的，因此流量的显示都呈动态显示（每30秒刷新一次），同时它还支持不同方式的显示，有饼图、柱状图、线图、数据列表。&lt;/p&gt;
&lt;p&gt;监视分为实时（Real-Time Monitoring）和长期 (Long-Term Reporting)。&lt;/p&gt;
&lt;p&gt;监控的内容可以是网络的总流量、流量所占带宽的百分比、pipe 的流量、VC 的流量、协议的流量、主机流量、连接数、新增连接数、数据包、点到点的连接（即会话）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.1 统计视图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;实时监视中的统计视图是展现一段时间内，监视对象的流量走势情况，包括：总流量、入流量、出流量、入数据包、出数据包、并发连接、新建连接、Drop 连接等。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.1.1 全网流量统计&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;右键点击导航栏“网络”下的“YK_Allot_504”（YK_Allot_504为流量管理设备名称），在这个级别查看流量，称为设备级查看。在弹出的右键菜单中选择“实时监视”，然后在“实时监视”的下级菜单中选择“统计”，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155145079-223363166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击统计后，会弹出“统计”的属性对话框，在此对话框中包括“时间”选项和“显示”选项，设置完点击“&lt;strong&gt;OK&lt;/strong&gt;”按钮、在明细区会弹出如下监视视图：如下图：例：以&lt;strong&gt;30&lt;/strong&gt; 秒为解析粒度查看&lt;strong&gt;10&lt;/strong&gt;分钟内的流量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155227070-911447598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，点击“表格视图”按钮，可得到如下表格视图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155241646-404197443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.1.2 各pipe流量统计&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;监视某个 Pipe 的流量统计：可以选择“网络”——“设备”，点开“设备”前的“&lt;strong&gt;+&lt;/strong&gt;”，从树形结构上查看设备中的Pipe，然后在目标pipe 上直接点击右键，选择“实时监视”—“统计”，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155311338-95686595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.1.3 各VC 流量统计&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;查看 VC 的统计流量，方法同Pipe，如下图：&lt;/p&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155333370-1270698763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.2 监控视图&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.5.2.1 排名视图&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在设备级监控整个设备的Pipe排名。&lt;/p&gt;
&lt;p&gt;a)如下图设置：在网络栏的设备上点击右键，在弹出的右键菜单选择“实时监视”—“pipes”&lt;/p&gt;
&lt;p&gt;b)设置实时监视pipe 的属性&lt;/p&gt;
&lt;p&gt;c)显示出监控 Pipe 结果&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155346648-611005378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155406869-166395909.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.2.2 主要pipe走势监视&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;查看 Pipe 走势只需要更改Pipe 的排名监视的属性，如下图：选定“实时监视：pipe”属性页中的“指定pipes”选项，然后将左侧的目标pipe 加入到右侧，如下图：&lt;/p&gt;
&lt;p&gt;a)  编辑实时监视pipe 的属性&lt;/p&gt;
&lt;p&gt;b)  显示出监视 pipe 走势结果 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155422992-1143183435.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.3 协议监控&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.5.3.1 全网协议监控TOP10&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;a) 实时监视协议的属性设置     &lt;/p&gt;
&lt;p&gt;b) 显示协议监控结果 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155441926-400145709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.3.2 全网指定协议走势&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155502444-1399644289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.4 内部主机监控&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.5.4.1 全网内部主机实时监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot; align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155517961-582052101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.4.2 各Pipe内部主机实时监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155528108-834892884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.4.3 各VC内部主机实时监视监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155547584-2017572043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.5 会话监控&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.5.5.1 全网主机会话监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155603219-2026081490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.5.2 各Pipe会话监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot; align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155619242-1461651960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.5.5.3 各VC会话监控&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155638344-1801884446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5.6 关联下探监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在图形界面上对各流量视图进行关联下探监控功能是 Allot 一个进行数据深度挖掘的重要工具，通过不同层次的关联下探可以对网络流量进行层层剖解式的监控。比如通过对全网流量的统计视图进行关联，可以关联到最活跃的pipe、最活跃的VC、最活跃的主机、最活跃的协议以及会话等。通过关联下探功能，可以精确方便的查看网络中特定时间段内主机使用的协议、占用的带宽、连接的会话等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155655088-1198477034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.6 长期监控流量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;长期监控是对读取历史保存网络流量的日志，可随时将之前的数据调出，对网络质量分析、网络扩容分析有很大作用。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155717110-1545452802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下为长期监控全网协议统计、带宽统计，Pipe 内部主机；VC回话监控结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155727008-2008916674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.7 报表配置&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.7.1 收藏报表&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;S&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155750112-1514985353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.7.2 报告功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;报告功能可以设置每天某一时间自动发送报告数据，数据自动生成报表文件保存在服务器指定文件夹“&lt;strong&gt;$Allot\netxplorer\jboss-4.0.5\server\allot\reports&lt;/strong&gt;”中。NX 平台支持的网络流量监视视图超过100 种，而这100 多种视图都可以设定成报告形式展现给管理者，并且支持定时生成特定格式如：JPG/PDF/CSV/HTML 等,报表生成后可自动发邮件到指定邮箱等功能。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155806169-723509389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.8 NX协议包升级操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Allot 设备NetEnforcer 及集中管理平台NX平台支持本地协议包升级和在线协议包升级方式。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.8.1 本地协议包升级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在 NX 菜单栏的“工具”菜单中，选择“协议更新”，“协议更新”共有：“从&lt;strong&gt;Allot&lt;/strong&gt; 网站&lt;strong&gt;…&lt;/strong&gt;”、“从本地数据包&lt;strong&gt;…&lt;/strong&gt;”、“安装到设备&lt;strong&gt;…&lt;/strong&gt;”、“回退&lt;strong&gt;NetXplorer&lt;/strong&gt;（服务器）到以前的版本”、“回退设备到以前版本”5 个下级菜单，选择“从本地数据包&lt;strong&gt;…&lt;/strong&gt;”。如下图：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155826577-1280471907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地升级需要把协议包文件放到 NX 服务器中，然后在弹出的对话框的文本输入区域输入协议包所在的绝对路径（如下图）：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155837313-1371852533.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.8.2 Allot 网站升级（推荐升级方式）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在菜单栏的“工具”菜单中，选择“协议更新”的下级菜单：“从&lt;strong&gt;Allot&lt;/strong&gt; 网站&lt;strong&gt;…&lt;/strong&gt;”。如下图：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155852226-1054249489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果网络连接正常，会在弹出的对话框中显示可用的更新协议，根据需要单击“现在更新”，完成NX 协议包更新操作。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155903063-961178234.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.8.3 将协议安装到设备&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;NX 的协议包升级完成后，会自动检测设备的版本，然后提示更新。如需手动安装协议包到设备，在菜单栏的“工具”菜单中，选择“协议更新”的下级菜单：“安装到设备&lt;strong&gt;…&lt;/strong&gt;”。如下图： &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217531/201902/1217531-20190228155915500-775361540.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.9 用户配置操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;NX 平台有三种操作权限用户：&lt;/p&gt;
&lt;p&gt;l  Monitor（监视）用户：只能做监视（查看报表），不能新建、修改配置策略；&lt;/p&gt;
&lt;p&gt;l  Regular（普通）用户：可以监视，并可新建、修改配置策略；&lt;/p&gt;
&lt;p&gt;l  Admin（管理员）用户：除具备普通用户的所有权限外，还可以创建用户、修改用户权限。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.9.1帐户密码修改&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;以修改 admin 用户密码为例：在NX 菜单栏选择“工具” 菜单下的“用户配置”，系统会弹出“用户配置编辑器”对话框，选择&lt;strong&gt;admin&lt;/strong&gt; 帐户，单击对话框右侧的“编辑&lt;strong&gt;…&lt;/strong&gt;”按钮，在弹出的“用户编辑器”对话框中会显示更改密码的界面，更改后保存即可。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.9.2新建用户帐户&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;以新建 monitor 账户为例：单击“用户配置编辑器”对话框右侧的“增加&lt;strong&gt;…&lt;/strong&gt;”按钮，会弹出“用户编辑器”对话框，在这个对话框中填写要建立的monitor 帐户名称、密码，并将“角色”选择为“监视”，然后点击“保存”，即完成monitor 帐户的建立&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 07:39:00 +0000</pubDate>
<dc:creator>CARLOS_CHIANG</dc:creator>
<og:description>ALLOT流控设备操作手册指引 1 简介 1.1 设备介绍 1.1.1 NetXploeer三层结构 Allot设备的管理如上图所示，采用三层结构。 1）NetEnforcer层，包括所有型号的Net</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaoyaojcy/p/10450789.html</dc:identifier>
</item>
<item>
<title>HashMap源码解读(JDK1.7) - 愿做你的小叮当</title>
<link>http://www.cnblogs.com/sangskf/p/HashMap-yuan-ma-jie-du-JDK17.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sangskf/p/HashMap-yuan-ma-jie-du-JDK17.html</guid>
<description>&lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类&lt;/p&gt;&lt;p&gt;的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;什么是哈希表&lt;/h2&gt;
&lt;p&gt;在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;数据结构&lt;/h3&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;线性链表&lt;/strong&gt;：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们知道，数据结构的物理存储结构只有两种：&lt;strong&gt;顺序存储结构和链式存储结构&lt;/strong&gt;（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，&lt;strong&gt;哈希表的主干就是数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;存储位置 = f(关键字)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151304045-974436813.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;哈希冲突&lt;/h3&gt;
&lt;p&gt;　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的&lt;strong&gt;哈希冲突&lt;/strong&gt;，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 &lt;strong&gt;计算简单和散列地址分布均匀&lt;/strong&gt;,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是&lt;strong&gt;数组+链表&lt;/strong&gt;的方式，&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;HashMap实现原理&lt;/h2&gt;
&lt;p&gt;HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。
transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Entry是HashMap中的一个静态内部类。代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final K key;
        V value;
        Entry&amp;lt;K,V&amp;gt; next;//存储指向下一个Entry的引用，单链表结构
        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry&amp;lt;K,V&amp;gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，HashMap的整体结构如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151304100-1300081705.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;简单来说，&lt;strong&gt;HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，只需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他几个重要字段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//实际存储的key-value键值对的个数
transient int size;
//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;
//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;
//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
transient int modCount;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值。initialCapacity默认为16，loadFactory默认为0.75&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public HashMap(int initialCapacity, float loadFactor) {
　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&amp;lt;&amp;lt;30(2的30次方)
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
　　　　　
        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面这段代码我们可以看出，&lt;strong&gt;在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OK,接下来我们来看看put操作的实现吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public V put(K key, V value) {
        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&amp;lt;&amp;lt;4(2的4次方=16)
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
       //如果key为null，存储位置为table[0]或table[0]的冲突链上
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀
        int i = indexFor(hash, table.length);//获取在table中的实际位置
        for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value
            Object k;
            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败
        addEntry(hash, key, value, i);//新增一个entry
        return null;
    }  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看看inflateTable这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void inflateTable(int toSize) {
        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static int roundUpToPowerOf2(int number) {
        // assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;;
        return number &amp;gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1;    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;hash函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;amp;&amp;amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
        return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 返回数组下标
 */
static int indexFor(int h, int length) {
    return h &amp;amp; (length-1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;h&amp;amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    1  0  0  1  0
&amp;amp;   0  1  1  1  1
__________________
    0  0  0  1  0    = 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）&lt;/p&gt;
&lt;p&gt;所以最终存储位置的确定流程是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151302879-1760832267.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;再来看看addEntry的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;为何HashMap的数组长度一定是2的次幂？&lt;/h2&gt;
&lt;p&gt;我们来继续看上面提到的resize方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）
        for (Entry&amp;lt;K,V&amp;gt; e : table) {
            while(null != e) {
                Entry&amp;lt;K,V&amp;gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。&lt;/p&gt;
&lt;p&gt;　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151303214-1888859854.png&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt; 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151302942-2027345366.png&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;　　我们看到，上面的&amp;amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/960471/201902/960471-20190228151303419-744371877.png&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。&lt;br/&gt;　　&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;get方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public V get(Object key) {
　　　　 //如果key为null,则直接去table[0]处去检索即可。
        if (key == null)
            return getForNullKey();
        Entry&amp;lt;K,V&amp;gt; entry = getEntry(key);
        return null == entry ? null : entry.getValue();
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Entry&amp;lt;K,V&amp;gt; getEntry(Object key) {
            
        if (size == 0) {
            return null;
        }
        //通过key的hashcode值计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //indexFor (hash&amp;amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录
        for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;amp;&amp;amp; 
                ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return e;
        }
        return null;
    }  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，get方法的实现相对简单，key(hashcode)--&amp;gt;hash--&amp;gt;indexFor--&amp;gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;重写equals方法需同时重写hashCode方法&lt;/h2&gt;
&lt;p&gt;　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Created by chengxiao on 2016/11/15.
 */
public class MyTest {
    private static class Person{
        int idCard;
        String name;

        public Person(int idCard, String name) {
            this.idCard = idCard;
            this.name = name;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()){
                return false;
            }
            Person person = (Person) o;
            //两个对象是否等值，通过idCard来确定
            return this.idCard == person.idCard;
        }

    }
    public static void main(String []args){
        HashMap&amp;lt;Person,String&amp;gt; map = new HashMap&amp;lt;Person, String&amp;gt;();
        Person person = new Person(1234,&quot;乔峰&quot;);
        //put到hashmap中去
        map.put(person,&quot;天龙八部&quot;);
        //get取出，从逻辑上讲应该能输出“天龙八部”
        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;结果：null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)--&amp;gt;hash--&amp;gt;indexFor--&amp;gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)--&amp;gt;hash--&amp;gt;indexFor--&amp;gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）&lt;/p&gt;
&lt;p&gt;　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。&lt;/p&gt;
&lt;blockquote readability=&quot;0.93220338983051&quot;&gt;
&lt;p&gt;[转载]：&lt;a href=&quot;https://www.cnblogs.com/chengxiao/p/6059914.html&quot;&gt;https://www.cnblogs.com/chengxiao/p/6059914.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Feb 2019 07:13:00 +0000</pubDate>
<dc:creator>愿做你的小叮当</dc:creator>
<og:description>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sangskf/p/HashMap-yuan-ma-jie-du-JDK17.html</dc:identifier>
</item>
<item>
<title>PyTorch入门（一）向量 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10450483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10450483.html</guid>
<description>&lt;h3 id=&quot;什么是pytorch&quot;&gt;什么是PyTorch？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4cc0cf4365e73ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  PyTorch是Facebook人工智能团队开发的一个机器学习和深度学习工具，用于处理大规模图像分析，包括物体检测，分割与分类。但是它的功能不仅限于此。它与其它深度学习框架结合，能够完成复杂的算法。PyTorch用Python和C++编写。&lt;br/&gt;  PyTorch属于深度学习框架中的重要一员，与TensorFlow, Keras, Theano等其它深度学习框架不同，它是动态计算图模式，其应用模型支持在运行过程中根据运行参数动态改变，而其它框架都是静态计算图模式，其模型在运行之前就已经确定。以下是各个深度学习框架的热度对比:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-59452b9d8f3adf70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于各个深度学习框架的对比，可以参考网址：&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software&quot;&gt;Comparison of deep learning software&lt;/a&gt;&lt;br/&gt;。&lt;br/&gt;  PyTorch是使用GPU和CPU优化的深度学习张量库。&lt;br/&gt;  下面，我们将一起来学习PyTorch中向量（Tensor）的相关操作。&lt;/p&gt;
&lt;h3 id=&quot;安装与运行&quot;&gt;安装与运行&lt;/h3&gt;
&lt;p&gt;  PyTorch的安装十分简单，需要用pip安装即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install torch
pip3 install torchvision&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中torchvision包含了一些torch内置的图片与视频数据集。&lt;br/&gt;  用以下的Python代码可以输出安装的PyTorch版本信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch
print(torch.version.__version__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在笔者的电脑上，输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.0.1.post2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;向量的基本操作&quot;&gt;向量的基本操作&lt;/h3&gt;
&lt;h5 id=&quot;导入模块&quot;&gt;导入模块&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-38acdbcaa9ee3456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;导入模块&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;检测是否为pytorch中的向量&quot;&gt;检测是否为PyTorch中的向量&lt;/h5&gt;
&lt;p&gt;  is_tensor()函数可以检测某个序列是否为PyTorch中的向量，is_storage()可以检测某个序列是否被存储为PyTorch中的向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-562026510e912b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;向量检测&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  可以看到，Python中的列表并不是PyTorch中的向量，也不会被存储为PyTorch中的向量。那么，如何创建PyTorch中的向量呢？&lt;/p&gt;
&lt;h5 id=&quot;创建随机向量&quot;&gt;创建随机向量&lt;/h5&gt;
&lt;p&gt;  利用randn()函数可以创建随机向量，随机数为0~1的随机浮点数，可以指定创建的向量的维数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4f86806e36290f48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建随机向量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们创建了1*2*3维的向量，用size()函数可以查看向量的维数情况，用numel()函数可以查看向量中的所有元素个数。&lt;/p&gt;
&lt;h5 id=&quot;创建零向量&quot;&gt;创建零向量&lt;/h5&gt;
&lt;p&gt;  利用zeros()函数可以创建零向量，即所有元素均为零的向量，只需指定向量的维数即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-cdd99418a1379a06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建零向量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面，我们创建了4*4的零向量。&lt;/p&gt;
&lt;h5 id=&quot;创建单位向量&quot;&gt;创建单位向量&lt;/h5&gt;
&lt;p&gt;  利用eye()函数可以创建单位向量，即主对角元素为1，其余元素均为零的向量，只需指定向量的维数即可。当二维向量的行数与列数不一样时，主对角元素为1，其余为0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-6e7d5a423af748b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建单位向量&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;从numpy中创建向量&quot;&gt;从numpy中创建向量&lt;/h5&gt;
&lt;p&gt;  PyTorch支持直接从numpy中创建向量，这为PyTorch和numpy提供了无缝对接，这也是PyTorch的一个优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-19288052b45c5c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;从numpy直接创建向量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  当然，PyTorch也可以将向量转化为numpy中的ndarrays.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-ab8f910634d4deea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;向量转化为numpy.ndarrays&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;tensor函数创建向量&quot;&gt;Tensor函数创建向量&lt;/h5&gt;
&lt;p&gt;  可以利用Tensor()直接创建向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-08c1e1e9063c63ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Tensor函数&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;linspace与logspace创建向量&quot;&gt;linspace与logspace创建向量&lt;/h5&gt;
&lt;p&gt;  linspace(tart, end, steps=100, out=None)通过指定开始值、终值和元素个数创建表示等差数列的一维数组，可以通过endpoint参数指定是否包含终值，默认值为True，即包含终值。&lt;br/&gt;  logspace(tart, end, steps=100, out=None)返回一个1维张量，包含在区间10exp(start)和10exp(end)上以对数刻度均匀间隔的 steps个点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-31e9b53b86e2d1f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;linspace() &amp;amp; logspace()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建均匀分布向量&quot;&gt;创建均匀分布向量&lt;/h5&gt;
&lt;p&gt;  rand()函数可以创建指定维数的满足均匀分布的向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-6d905d5290ee6294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rand()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;随机整数排列向量&quot;&gt;随机整数排列向量&lt;/h5&gt;
&lt;p&gt;  randperm(n, out=None) ,给定参数n，返回一个从0 到n -1 的随机整数排列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-8326eda1bfcd7ffe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;randperm()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;等差数列向量&quot;&gt;等差数列向量&lt;/h5&gt;
&lt;p&gt;  arange(start, end, step=1, out=None) , 返回一个1维张量，包含从start到end，以step为步长的一组序列值(默认步长为1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-90ef95312e977036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;arange()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;寻找最大值最小组&quot;&gt;寻找最大值、最小组&lt;/h5&gt;
&lt;p&gt;  argmin()和argmax()函数可以寻找向量所在的最小值和最大值的下标，0表示沿着行查找，1表示沿着列查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-51ea584f5e1ad714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;argmin(), argmax()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;向量拼接&quot;&gt;向量拼接&lt;/h5&gt;
&lt;p&gt;  cat()函数在给定维度上对输入的张量序列seq 进行连接操作，默认的维度为0，即按行拼接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-b0b06a8a4120d4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;cat()&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;向量分块&quot;&gt;向量分块&lt;/h6&gt;
&lt;p&gt;  chunk(tensor, chunks, dim=0)函数在给定维度(轴)上将输入张量进行分块，默认为0，即按行进行分块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-cc0a811d0fbd34b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;chunk()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;gather函数&quot;&gt;gather()函数&lt;/h5&gt;
&lt;p&gt;  gather(input, dim, index, out=None), 沿给定轴dim，将输入索引张量index指定位置的值进行聚合。gather()函数理解起来比较困难，先看例子，再解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-7e0d6cfaa570318a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gather()&quot;/&gt;&lt;/p&gt;
&lt;p&gt;gather的作用是这样的，index是索引，具体是行还是列的索引要看前面dim ，比如对于我们的例子, [[11, 12], [23, 24]], 指定dim=1，也就是横向，那么索引就是列号。index的大小就是输出的大小，所以比如index是[[0,0], [1,0]]，那么看index第一行，0列指的是11，同理，第二行为1, 0 , 这样就是[24, 23]，参考这样的解释看上面的输出结果，即可理解gather的含义。&lt;/p&gt;
&lt;h5 id=&quot;索引&quot;&gt;索引&lt;/h5&gt;
&lt;p&gt;  index_select(input, dim, index, out=None) ，沿着指定维度对输入进行切片，取index中指定的相应项(index为一个LongTensor)，然后返回到一个新的张量，返回的张量与原始张量_Tensor_有相同的维度(在指定轴上)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-5df81a245fb9f7ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;index_select()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;split函数&quot;&gt;split()函数&lt;/h5&gt;
&lt;p&gt;  split(tensor, split_size, dim=0), 将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被split_size整分， 则最后一个分块会小于其它分块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-36a29ad3f51d7c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;split()&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;向量转置&quot;&gt;向量转置&lt;/h6&gt;
&lt;p&gt;   二维向量的转置可以用t()或transpos(1, 0)实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-c8a9b6ee76e706ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;向量转置&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;unbind&quot;&gt;unbind()&lt;/h5&gt;
&lt;p&gt;  unbind(tensor, dim=0), 移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片，默认维度为1，表示行，1表示列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-216738250d9aec96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;unbind()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;判断是否为零元素&quot;&gt;判断是否为零元素&lt;/h5&gt;
&lt;p&gt;  nonzero()函数可以判断向量中的元素是否为0.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-d86c5026d017070f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;nonzero()&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;向量运算&quot;&gt;向量运算&lt;/h5&gt;
&lt;p&gt;  以下将演示几种常见的矩阵运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-ea869b46218c7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;矩阵运算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;矩阵的点乘与矩阵乘法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-3619b21ad85ccb41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;矩阵点乘与矩阵乘法&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  本文的github地址为：&lt;a href=&quot;https://github.com/percent4/PyTorch_Learning/blob/master/pytorch_tensor_demo.ipynb&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/PyTorch_Learning/blob/master/pytorch_tensor_demo.ipynb&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;注意：不妨了解下笔者的微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注~&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 07:04:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>PyTorch入门（一）向量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10450483.html</dc:identifier>
</item>
<item>
<title>记一次升级Tomcat - Secondworld</title>
<link>http://www.cnblogs.com/Kidezyq/p/10450332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kidezyq/p/10450332.html</guid>
<description>&lt;h2 id=&quot;总述&quot;&gt;总述&lt;/h2&gt;
&lt;p&gt;    JDK都要出12了，而我们项目使用的jdk却仍然还停留在JDK1.6。为了追寻技术的发展的脚步，我这边准备将项目升级到JDK1.8。而作为一个web项目，我们的容器使用的是Tomcat。看了下Tomcat版本与JDK版本之间的兼容关系&lt;a href=&quot;http://tomcat.apache.org/whichversion.html&quot; class=&quot;uri&quot;&gt;http://tomcat.apache.org/whichversion.html&lt;/a&gt;以及网上所传的各种JDK1.8和Tomcat7不兼容的问题， 我决定将Tomcat升级到8。我这里本地验证采用的tomcat版本是8.5.38&lt;a href=&quot;https://tomcat.apache.org/download-80.cgi&quot; class=&quot;uri&quot;&gt;https://tomcat.apache.org/download-80.cgi&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;问题一请求js文件报404错误&quot;&gt;问题一：请求js文件报404错误&lt;/h2&gt;
&lt;p&gt;    其实这个问题严格来讲不是升级到Tomcat8出现的问题，而是升级到Tomcat9出现的问题。正好我开始尝试的是Tomcat9，无法解决这个问题才降到Tomcat8。所以这里一并记录下来。&lt;/p&gt;
&lt;p&gt;    这个问题在从Tomcat6升级到Tomcat7之后也会存在，原因如下，在项目代码中对js的请求路径中包含了&lt;code&gt;{、}&lt;/code&gt;等特殊符号：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;${ctx}/js/common/include_css.js?{'ctx':'${ctx}','easyui':'easyui'}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    前台会发现加载js的时候报了404的错误，后台报错信息如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Invalid character found in the request target.The valid characters are defined in RFC 7230 and RFC3986&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    出现这个问题的原因是因为Tomcat升级之后对安全进行了升级，其中就有对请求中的特殊字符进行校验，具体校验规则参照下面的代码：&lt;/p&gt;
&lt;p&gt;(InternalInputBuffer、InternalAprInputBuffer、InternalNioInputBuffer)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Read the request line. This function is meant to be used during the
 * HTTP request header parsing. Do NOT attempt to read the request body
 * using it.
 *
 * @throws IOException If an exception occurs during the underlying socket
 * read operations, or if the given buffer is not big enough to accommodate
 * the whole line.
 */
@Override
public boolean parseRequestLine(boolean useAvailableDataOnly)

    throws IOException {

    int start = 0;

    //
    // Skipping blank lines
    //

    byte chr = 0;
    do {

        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }
        // Set the start time once we start reading data (even if it is
        // just skipping blank lines)
        if (request.getStartTime() &amp;lt; 0) {
            request.setStartTime(System.currentTimeMillis());
        }
        chr = buf[pos++];
    } while ((chr == Constants.CR) || (chr == Constants.LF));

    pos--;

    // Mark the current buffer position
    start = pos;

    //
    // Reading the method name
    // Method name is a token
    //

    boolean space = false;

    while (!space) {

        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }

        // Spec says method name is a token followed by a single SP but
        // also be tolerant of multiple SP and/or HT.
        if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
            space = true;
            request.method().setBytes(buf, start, pos - start);
        } else if (!HttpParser.isToken(buf[pos])) {
            throw new IllegalArgumentException(sm.getString(&quot;iib.invalidmethod&quot;));
        }

        pos++;

    }

    // Spec says single SP but also be tolerant of multiple SP and/or HT
    while (space) {
        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }
        if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
            pos++;
        } else {
            space = false;
        }
    }

    // Mark the current buffer position
    start = pos;
    int end = 0;
    int questionPos = -1;

    //
    // Reading the URI
    //

    boolean eol = false;

    while (!space) {

        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }

        // Spec says single SP but it also says be tolerant of HT
        if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
            space = true;
            end = pos;
        } else if ((buf[pos] == Constants.CR)
                   || (buf[pos] == Constants.LF)) {
            // HTTP/0.9 style request
            eol = true;
            space = true;
            end = pos;
        } else if ((buf[pos] == Constants.QUESTION) &amp;amp;&amp;amp; (questionPos == -1)) {
            questionPos = pos;
        } else if (HttpParser.isNotRequestTarget(buf[pos])) {
            throw new IllegalArgumentException(sm.getString(&quot;iib.invalidRequestTarget&quot;));
        }

        pos++;

    }

    request.unparsedURI().setBytes(buf, start, end - start);
    if (questionPos &amp;gt;= 0) {
        request.queryString().setBytes(buf, questionPos + 1,
                                       end - questionPos - 1);
        request.requestURI().setBytes(buf, start, questionPos - start);
    } else {
        request.requestURI().setBytes(buf, start, end - start);
    }

    // Spec says single SP but also says be tolerant of multiple SP and/or HT
    while (space) {
        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }
        if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {
            pos++;
        } else {
            space = false;
        }
    }

    // Mark the current buffer position
    start = pos;
    end = 0;

    //
    // Reading the protocol
    // Protocol is always &quot;HTTP/&quot; DIGIT &quot;.&quot; DIGIT
    //
    while (!eol) {

        // Read new bytes if needed
        if (pos &amp;gt;= lastValid) {
            if (!fill())
                throw new EOFException(sm.getString(&quot;iib.eof.error&quot;));
        }

        if (buf[pos] == Constants.CR) {
            end = pos;
        } else if (buf[pos] == Constants.LF) {
            if (end == 0)
                end = pos;
            eol = true;
        } else if (!HttpParser.isHttpProtocol(buf[pos])) {
            // 关键点在这一句，如果校验不通过，则会报参数异常
            throw new IllegalArgumentException(sm.getString(&quot;iib.invalidHttpProtocol&quot;));
        }

        pos++;

    }

    if ((end - start) &amp;gt; 0) {
        request.protocol().setBytes(buf, start, end - start);
    } else {
        request.protocol().setString(&quot;&quot;);
    }

    return true;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们进一步跟进&lt;code&gt;HttpParser&lt;/code&gt;中的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static boolean isNotRequestTarget(int c) {
    // Fast for valid request target characters, slower for some incorrect
    // ones
    try {
        // 关键在于这个数组
        return IS_NOT_REQUEST_TARGET[c];
    } catch (ArrayIndexOutOfBoundsException ex) {
        return true;
    }
}


// Combination of multiple rules from RFC7230 and RFC 3986. Must be
// ASCII, no controls plus a few additional characters excluded
if (IS_CONTROL[i] || i &amp;gt; 127 ||
        i == ' ' || i == '\&quot;' || i == '#' || i == '&amp;lt;' || i == '&amp;gt;' || i == '\\' ||
        i == '^' || i == '`'  || i == '{' || i == '|' || i == '}') {
    // 可以看到只有在REQUEST_TARGET_ALLOW数组中的值才不会设置成true，所以我们需要追踪REQUEST_TARGET_ALLOW数组的赋值
    if (!REQUEST_TARGET_ALLOW[i]) {
        IS_NOT_REQUEST_TARGET[i] = true;
    }
}

String prop = System.getProperty(&quot;tomcat.util.http.parser.HttpParser.requestTargetAllow&quot;);
if (prop != null) {
    for (int i = 0; i &amp;lt; prop.length(); i++) {
        char c = prop.charAt(i);
        // 可以看到在配置文件中配置了tomcat.util.http.parser.HttpParser.requestTargetAllow并且包含{、}、|的时候，REQUEST_TARGET_ALLOW数组中的值才会为true
        if (c == '{' || c == '}' || c == '|') {
            REQUEST_TARGET_ALLOW[c] = true;
        } else {
            log.warn(sm.getString(&quot;httpparser.invalidRequestTargetCharacter&quot;,
                    Character.valueOf(c)));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;strong&gt;解决办法&lt;/strong&gt;: 其实通过源码分析不难得到解决办法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Tomcat的catalina.properties文件中添加以下语句：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tomcat.util.http.parser.HttpParser.requestTargetAllow={}|&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然需要注意的是，这个&lt;code&gt;后门&lt;/code&gt;在Tomcat8.5以后就无法使用的，Tomcat9之后的解决办法暂时未找到，可能只有对URL进行编码了。&lt;/p&gt;
&lt;h2 id=&quot;问题二cookie设置报错&quot;&gt;问题二：Cookie设置报错&lt;/h2&gt;
&lt;p&gt;     这个问题就是在升级到Tomcat8.5以上的时候会出现的，具体原因是Tomcat8.5采用的Cookie处理类是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rfc6265CookieProcessor&lt;/code&gt;,而在之前使用的处理类是&lt;code&gt;LegacyCookieProcessor&lt;/code&gt;。该处理类对domai进行了校验：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void validateDomain(String domain) {
    int i = 0;
    int prev = -1;
    int cur = -1;
    char[] chars = domain.toCharArray();
    while (i &amp;lt; chars.length) {
        prev = cur;
        cur = chars[i];
        if (!domainValid.get(cur)) {
            throw new IllegalArgumentException(sm.getString(
                    &quot;rfc6265CookieProcessor.invalidDomain&quot;, domain));
        }
        // labels must start with a letter or number
        if ((prev == '.' || prev == -1) &amp;amp;&amp;amp; (cur == '.' || cur == '-')) {
            throw new IllegalArgumentException(sm.getString(
                    &quot;rfc6265CookieProcessor.invalidDomain&quot;, domain));
        }
        // labels must end with a letter or number
        if (prev == '-' &amp;amp;&amp;amp; cur == '.') {
            throw new IllegalArgumentException(sm.getString(
                    &quot;rfc6265CookieProcessor.invalidDomain&quot;, domain));
        }
        i++;
    }
    // domain must end with a label
    if (cur == '.' || cur == '-') {
        throw new IllegalArgumentException(sm.getString(
                &quot;rfc6265CookieProcessor.invalidDomain&quot;, domain));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的Cookie规范对domain有以下要求&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、必须是1-9、a-z、A-Z、. 、- （注意是-不是_）这几个字符组成&lt;br/&gt;2、必须是数字或字母开头 （所以以前的cookie的设置为.XX.com 的机制要改为 XX.com 即可）&lt;br/&gt;3、必须是数字或字母结尾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来的代码设置domain时如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;cookie.setDomain(&quot;.aaa.com&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就导致设置domain的时候不符合新的规范，直接报错如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.IllegalArgumentException: An invalid domain [.aaa.com] was specified for this cookie
        at org.apache.tomcat.util.http.Rfc6265CookieProcessor.validateDomain(Rfc6265CookieProcessor.java:181)
        at org.apache.tomcat.util.http.Rfc6265CookieProcessor.generateHeader(Rfc6265CookieProcessor.java:123)
        at org.apache.catalina.connector.Response.generateCookieString(Response.java:989)
        at org.apache.catalina.connector.Response.addCookie(Response.java:937)
        at org.apache.catalina.connector.ResponseFacade.addCookie(ResponseFacade.java:386)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;strong&gt;解决办法(以下3中任意一种皆可)&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改原来代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;cookie.setDomain(&quot;aaa.com&quot;);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;如果是Spring-boot环境，直接替换默认的Cookie处理类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ConditionalOnExpression(&quot;${tomcat.useLegacyCookieProcessor:false}&quot;)
public class LegacyCookieProcessorConfiguration {
    @Bean
    EmbeddedServletContainerCustomizer embeddedServletContainerCustomizerLegacyCookieProcessor() {
        return new EmbeddedServletContainerCustomizer() {
            @Override
            public void customize(ConfigurableEmbeddedServletContainer factory) {
                if (factory instanceof TomcatEmbeddedServletContainerFactory) {
                    TomcatEmbeddedServletContainerFactory tomcatFactory =
                            (TomcatEmbeddedServletContainerFactory) factory;
                    tomcatFactory.addContextCustomizers(new TomcatContextCustomizer() {
                        @Override
                        public void customize(Context context) {
                            context.setCookieProcessor(new LegacyCookieProcessor());
                        }
                    });
                }
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在Tomcat的context.xml中增加如下配置，指定Cookie的处理类：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;CookieProcessor className=&quot;org.apache.tomcat.util.http.LegacyCookieProcessor&quot; /&amp;gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;blockquote readability=&quot;0.12413793103448&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fy_sun123/article/details/73115381&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/fy_sun123/article/details/73115381&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/367186&quot; class=&quot;uri&quot;&gt;http://ju.outofmemory.cn/entry/367186&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lr393993507/p/7755867.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lr393993507/p/7755867.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Feb 2019 06:47:00 +0000</pubDate>
<dc:creator>Secondworld</dc:creator>
<og:description>总述 &amp; 160;&amp; 160;&amp; 160;&amp; 160;JDK都要出12了，而我们项目使用的jdk却仍然还停留在JDK1.6。为了追寻技术的发展的脚步，我这边准备将项目升级到JDK1.8。而作为一个we</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kidezyq/p/10450332.html</dc:identifier>
</item>
<item>
<title>Spark2.1.0——内置Web框架详解 - 泰山不老生</title>
<link>http://www.cnblogs.com/jiaan-geng/p/10313068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiaan-geng/p/10313068.html</guid>
<description>&lt;p&gt;　　任何系统都需要提供监控功能，否则在运行期间发生一些异常时，我们将会束手无策。也许有人说，可以增加日志来解决这个问题。日志只能解决你的程序逻辑在运行期的监控，进而发现Bug，以及提供对业务有帮助的调试信息。当你的JVM进程奔溃或者程序响应速度很慢时，这些日志将毫无用处。好在JVM提供了jstat、jstack、jinfo、jmap、jhat等工具帮助我们分析，更有VisualVM的可视化界面以更加直观的方式对JVM运行期的状况进行监控。此外，像Tomcat、Hadoop等服务都提供了基于Web的监控页面，用浏览器能访问具有样式及布局，并提供丰富监控数据的页面无疑是一种简单、高效的方式。&lt;/p&gt;
&lt;p&gt;　　Spark自然也提供了Web页面来浏览监控数据，而且Master、Worker、Driver根据自身功能提供了不同内容的Web监控页面。无论是Master、Worker，还是Driver，它们都使用了统一的Web框架WebUI。Master、Worker及Driver分别使用MasterWebUI、WorkerWebUI及SparkUI提供的Web界面服务，后三者都继承自WebUI，并增加了个性化的功能。此外，在Yarn或Mesos模式下还有WebUI的另一个扩展实现HistoryServer。HistoryServer将会展现已经运行完成的应用程序信息。本章以SparkUI为例，并深入分析WebUI的框架体系。&lt;/p&gt;
&lt;h2&gt;SparkUI概述&lt;/h2&gt;
&lt;p&gt;　　在大型分布式系统中，采用事件监听机制是最常见的。为什么要使用事件监听机制？假如Spark UI采用Scala的函数调用方式，那么随着整个集群规模的增加，对函数的调用会越来越多，最终会受到Driver所在JVM的线程数量限制而影响监控数据的更新，甚至出现监控数据无法及时显示给用户的情况。由于函数调用多数情况下是同步调用，这就导致线程被阻塞，在分布式环境中，还可能因为网络问题，导致线程被长时间占用。将函数调用更换为发送事件，事件的处理是异步的，当前线程可以继续执行后续逻辑进而被快速释放。线程池中的线程还可以被重用，这样整个系统的并发度会大大增加。发送的事件会存入缓存，由定时调度器取出后，分配给监听此事件的监听器对监控数据进行更新。Spark UI就是这样的服务，它的构成如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/816981/201901/816981-20190124103235979-345421138.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1       SparkUI的组成&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;图1展示了SparkUI中的各个组件，这里对这些组件作简单介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SparkListenerEvent事件的来源：包括DAGScheduler、SparkContext、DriverEndpoint、BlockManagerMasterEndpoint以及LocalSchedulerBackend等，这些组件将会产生各种SparkListenerEvent，并发送到listenerBus的事件队列中。DriverEndpoint是Driver在Standalone或local-cluster模式下与其他组件进行通信的组件，在《Spark内核设计的艺术》一书的第9.9.2节有详细介绍。BlockManagerMasterEndpoint是Driver对分配给应用的所有Executor及其BlockManager进行统一管理的组件，在《Spark内核设计的艺术》一书的6.8节详细介绍。LocalSchedulerBackend是local模式下的调度后端接口，用于给任务分配资源或对任务的状态进行更新，在《Spark内核设计的艺术》一书的7.8.2节详细介绍。&lt;/li&gt;
&lt;li&gt;事件总线listenerBus。根据3.3节对事件总线的介绍，我们知道listenerBus通过定时器将SparkListenerEvent事件匹配到具体的SparkListener，进而改变各个SparkListener中的统计监控数据。&lt;/li&gt;
&lt;li&gt;Spark UI的界面。各个SparkListener内的统计监控数据将会被各种标签页和具体页面展示到Web界面。标签页有StagesTab、JobsTab、ExecutorsTab、EnvironmentTab以及StorageTab。每个标签页中包含若干个页面，例如StagesTab标签页中包含了AllStagesPage、StagePage及PoolPage三个页面。&lt;/li&gt;
&lt;li&gt;控制台的展示。细心的读者会发现图1中还有SparkStatusTracker（Spark状态跟踪器）和ConsoleProgressBar（控制台进度条）两个组件。SparkStatusTracker负责对Job和Stage的监控，其实际也是使用了JobProgressListener中的监控数据，并额外进行了一些加工。ConsoleProgressBar负责将SparkStatusTracker提供的数据打印到控制台上。从最终展现的角度来看，SparkStatusTracker和ConsoleProgressBar不应该属于SparkUI的组成部分，但是由于其实现与JobProgressListener密切相关，所以将它们也放在了SparkUI的内容中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;WebUI框架体系&lt;/h2&gt;
&lt;p&gt;　　Spark UI构建在WebUI的框架体系之上，因此应当首先了解WebUI。WebUI定义了一种Web界面展现的框架，并提供返回Json格式数据的Web服务。WebUI用于展示一组标签页，WebUITab定义了标签页的规范。每个标签页中包含着一组页面，WebUIPage定义了页面的规范。我们将首先了解WebUIPage和WebUITab，最后从整体来看WebUI。&lt;/p&gt;
&lt;h3&gt;WebUIPage的定义&lt;/h3&gt;
&lt;p&gt;　　任何的Web界面往往由多个页面组成，每个页面都将提供不同的内容展示。WebUIPage是WebUI框架体系的页节点，定义了所有页面应当遵循的规范。抽象类WebUIPage的定义见代码清单1。&lt;/p&gt;
&lt;p&gt;代码清单1  WebUIPage的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
private[spark] abstract class WebUIPage(var prefix: String) {
  def render(request: HttpServletRequest): Seq[Node]
  def renderJson(request: HttpServletRequest): JValue = JNothing
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WebUIPage定义了两个方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;render：渲染页面；&lt;/li&gt;
&lt;li&gt;renderJson：生成JSON。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;WebUIPage在WebUI框架体系中的上一级节点（也可以称为父亲）可以是WebUI或者WebUITab，其成员属性prefix将与上级节点的路径一起构成当前WebUIPage的访问路径。&lt;/p&gt;
&lt;h3&gt;WebUITab的定义&lt;/h3&gt;
&lt;p&gt;         有时候Web界面需要将多个页面作为一组内容放置在一起，这时候标签页是常见的展现形式。标签页WebUITab定义了所有标签页的规范，并用于展现一组WebUIPage。抽象类WebUITab的定义见代码清单2。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码清单2  WebUITab的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
private[spark] abstract class WebUITab(parent: WebUI, val prefix: String) {
  val pages = ArrayBuffer[WebUIPage]()
  val name = prefix.capitalize

  def attachPage(page: WebUIPage) {
    page.prefix = (prefix + &quot;/&quot; + page.prefix).stripSuffix(&quot;/&quot;)
    pages += page
  }

  def headerTabs: Seq[WebUITab] = parent.getTabs

  def basePath: String = parent.getBasePath
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;根据代码清单2，可以看到WebUITab有四个成员属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;parent：上一级节点，即父亲。WebUITab的父亲只能是WebUI。&lt;/li&gt;
&lt;li&gt;prefix：当前WebUITab的前缀。prefix将与上级节点的路径一起构成当前WebUITab的访问路径。&lt;/li&gt;
&lt;li&gt;pages：当前WebUITab所包含的WebUIPage的缓冲数组。&lt;/li&gt;
&lt;li&gt;name：当前WebUITab的名称。name实际是对prefix的首字母转换成大写字母后取得。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，WebUITab还有三个成员方法，下面介绍它们的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;attachPage：首先将当前WebUITab的前缀与WebUIPage的前缀拼接，作为WebUIPage的访问路径。然后向pages中添加WebUIPage。&lt;/li&gt;
&lt;li&gt;headerTabs：获取父亲WebUI中的所有WebUITab。此方法实际通过调用父亲WebUI的getTabs方法实现，getTabs方法请参阅下一小节——WebUI的定义。&lt;/li&gt;
&lt;li&gt;basePath：获取父亲WebUI的基本路径。此方法实际通过调用父亲WebUI的getBasePath方法实现，getBasePath方法请参阅下一小节——WebUI的定义。。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;WebUI的定义&lt;/h3&gt;
&lt;p&gt;　　WebUI是Spark实现的用于提供Web界面展现的框架，凡是需要页面展现的地方都可以继承它来完成。WebUI定义了WebUI框架体系的规范。为便于理解，首先明确WebUI中各个成员属性的含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;securityManager：SparkEnv中创建的安全管理器SecurityManager，5.2节对SecurityManager有详细介绍。&lt;/li&gt;
&lt;li&gt;sslOptions：使用SecurityManager获取spark.ssl.ui属性指定的WebUI的SSL（Secure Sockets Layer 安全套接层）选项。&lt;/li&gt;
&lt;li&gt;port：WebUI对外服务的端口。可以使用spark.ui.port属性进行配置。&lt;/li&gt;
&lt;li&gt;conf：即SparkConf。&lt;/li&gt;
&lt;li&gt;basePath：WebUI的基本路径。basePath默认为空字符串。&lt;/li&gt;
&lt;li&gt;name：WebUI的名称。Spark UI的name为SparkUI。&lt;/li&gt;
&lt;li&gt;tabs：WebUITab的缓冲数组。&lt;/li&gt;
&lt;li&gt;handlers：ServletContextHandler的缓冲数组。ServletContextHandler是Jetty提供的API，负责对ServletContext进行处理。ServletContextHandler的使用及Jetty的更多内容可以参阅附录C。&lt;/li&gt;
&lt;li&gt;pageToHandlers：WebUIPage与ServletContextHandler缓冲数组之间的映射关系。由于WebUIPage的两个方法render和renderJson分别需要由一个对应的ServletContextHandler处理。所以一个WebUIPage对应两个ServletContextHandler。&lt;/li&gt;
&lt;li&gt;serverInfo：用于缓存ServerInfo，即WebUI的Jetty服务器信息。&lt;/li&gt;
&lt;li&gt;publicHostName：当前WebUI的Jetty服务的主机名。优先采用系统环境变量SPARK_PUBLIC_DNS指定的主机名，否则采用spark.driver.host属性指定的host，在没有前两个配置的时候，将默认使用工具类Utils的localHostName方法（详见附录A）返回的主机名。&lt;/li&gt;
&lt;li&gt;className：过滤了$符号的当前类的简单名称。className 是通过Utils的getFormattedClassName方法得到的。getFormattedClassName方法的实现请看附录A。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解了WebUI的成员属性，现在就可以理解其提供的各个方法了。WebUI提供的方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getBasePath：获取basePath。&lt;/li&gt;
&lt;li&gt;getTabs：获取tabs中的所有WebUITab，并以Scala的序列返回。&lt;/li&gt;
&lt;li&gt;getHandlers：获取handlers中的所有ServletContextHandler，并以Scala的序列返回。&lt;/li&gt;
&lt;li&gt;getSecurityManager：获取securityManager。&lt;/li&gt;
&lt;li&gt;attachHandler：给handlers缓存数组中添加ServletContextHandler，并且将此ServletContextHandler通过ServerInfo的addHandler方法添加到Jetty服务器中。attachHandler的实现见代码清单3。ServerInfo的addHandler方法的请参阅附录C。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单3  attachHandler的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def attachHandler(handler: ServletContextHandler) {
    handlers += handler
    serverInfo.foreach(_.addHandler(handler))
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;detachHandler：从handlers缓存数组中移除ServletContextHandler，并且将此ServletContextHandler通过ServerInfo的removeHandler方法从Jetty服务器中移除。detachHandler的实现见代码清单4。ServerInfo的removeHandler方法的请参阅附录C。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码清单4  detachHandler的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def detachHandler(handler: ServletContextHandler) {
    handlers -= handler
    serverInfo.foreach(_.removeHandler(handler))
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;attachPage：首先调用工具类JettyUtils&lt;a title=&quot;&quot; href=&quot;file:///E:/个人资料/书/编辑疑问/第4章_SparkContext的初始化.docx#_ftn1&quot;&gt;[1]&lt;/a&gt;的createServletHandler方法给WebUIPage创建与render和renderJson两个方法分别关联的ServletContextHandler，然后通过attachHandler方法添加到handlers缓存数组与Jetty服务器中，最后把WebUIPage与这两个ServletContextHandler的映射关系更新到pageToHandlers中。attachPage的实现见代码清单5。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单5  attachPage的实现&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def attachPage(page: WebUIPage) {
    val pagePath = &quot;/&quot; + page.prefix
    val renderHandler = createServletHandler(pagePath,
      (request: HttpServletRequest) =&amp;gt; page.render(request), securityManager, conf, basePath)
    val renderJsonHandler = createServletHandler(pagePath.stripSuffix(&quot;/&quot;) + &quot;/json&quot;,
      (request: HttpServletRequest) =&amp;gt; page.renderJson(request), securityManager, conf, basePath)
    attachHandler(renderHandler)
    attachHandler(renderJsonHandler)
    val handlers = pageToHandlers.getOrElseUpdate(page, ArrayBuffer[ServletContextHandler]())
    handlers += renderHandler
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;detachPage：作用与attachPage相反。detachPage的实现见代码清单6。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单6  detachPage的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def detachPage(page: WebUIPage) {
    pageToHandlers.remove(page).foreach(_.foreach(detachHandler))
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;attachTab：首先向tabs中添加WebUITab，然后给WebUITab中的每个WebUIPage施加attachPage方法。attachTab的实现见代码清单7。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单7  attachTab的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def attachTab(tab: WebUITab) {
    tab.pages.foreach(attachPage)
    tabs += tab
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;detachTab：作用与attachTab相反。detachTab的实现见代码清单8。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单8  detachTab的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def detachTab(tab: WebUITab) {
    tab.pages.foreach(detachPage)
    tabs -= tab
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;addStaticHandler：首先调用工具类JettyUtils的createStaticHandler方法创建静态文件服务的ServletContextHandler，然后施加attachHandler方法。addStaticHandler的实现见代码清单9。JettyUtils的createStaticHandler方法的实现见附录C。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单9     addStaticHandler的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def addStaticHandler(resourceBase: String, path: String): Unit = {
    attachHandler(JettyUtils.createStaticHandler(resourceBase, path))
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;removeStaticHandler：作用与addStaticHandler相反。removeStaticHandler的实现见代码清单10。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单10         removeStaticHandler的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def removeStaticHandler(path: String): Unit = {
    handlers.find(_.getContextPath() == path).foreach(detachHandler)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;initialize：用于初始化WebUI服务中的所有组件。WebUI中此方法未实现，需要子类实现。&lt;/li&gt;
&lt;li&gt;bind：启动与WebUI绑定的Jetty服务。bind方法的实现见代码清单11。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单11         bind的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def bind() {
    assert(!serverInfo.isDefined, s&quot;Attempted to bind $className more than once!&quot;)
    try {
      val host = Option(conf.getenv(&quot;SPARK_LOCAL_IP&quot;)).getOrElse(&quot;0.0.0.0&quot;)
      serverInfo = Some(startJettyServer(host, port, sslOptions, handlers, conf, name))
      logInfo(s&quot;Bound $className to $host, and started at $webUrl&quot;)
    } catch {
      case e: Exception =&amp;gt;
        logError(s&quot;Failed to bind $className&quot;, e)
        System.exit(1)
    }
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;webUrl：获取WebUI的Web界面的URL。webUrl的实现如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def webUrl: String = shttp://$publicHostName:$boundPort
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;boundPort：获取WebUI的Jetty服务的端口。boundPort的实现如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def boundPort: Int = serverInfo.map(_.boundPort).getOrElse(-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;stop：停止WebUI。实际是停止WebUI底层的Jetty服务。stop方法的实现见代码清单12。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;代码清单12         stop方法的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def stop() {
    assert(serverInfo.isDefined,
      s&quot;Attempted to stop $className before binding to a server!&quot;)
    serverInfo.get.stop()
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 创建SparkUI&lt;/h2&gt;
&lt;p&gt;　　在SparkContext的初始化过程中，会创建SparkUI。有了对WebUI的总体认识，现在是时候了解SparkContext是如何构造SparkUI的了。SparkUI是WebUI框架的使用范例，了解了SparkUI的创建过程，读者对MasterWebUI、WorkerWebUI及HistoryServer的创建过程也必然了然于心。创建SparkUI的代码如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;61.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
    _statusTracker = new SparkStatusTracker(this)

    _progressBar =
      if (_conf.getBoolean(&quot;spark.ui.showConsoleProgress&quot;, true) &amp;amp;&amp;amp; !log.isInfoEnabled) {
        Some(new ConsoleProgressBar(this))
      } else {
        None
      }

    _ui =
      if (conf.getBoolean(&quot;spark.ui.enabled&quot;, true)) {
        Some(SparkUI.createLiveUI(this, _conf, listenerBus, _jobProgressListener,
          _env.securityManager, appName, startTime = startTime))
      } else {
        // For tests, do not enable the UI
        None
      }
    _ui.foreach(_.bind())
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;这段代码的执行步骤如下。&lt;/p&gt;
&lt;p&gt;1)  创建Spark状态跟踪器SparkStatusTracker。&lt;/p&gt;
&lt;p&gt;2)  创建ConsoleProgressBar。可以配置spark.ui.showConsoleProgress属性为false取消对ConsoleProgressBar的创建，此属性默认为true。&lt;/p&gt;
&lt;p&gt;3)  调用SparkUI的createLiveUI方法创建SparkUI。&lt;/p&gt;
&lt;p&gt;4)  给SparkUI绑定端口。SparkUI继承自WebUI，因此调用了代码清单4-12中WebUI的bind方法启动SparkUI底层的Jetty服务。&lt;/p&gt;
&lt;p&gt;         上述步骤中，第1)、2)、4)步都很简单，所以着重来分析第3)步。SparkUI的createLiveUI的实现如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def createLiveUI(
      sc: SparkContext,
      conf: SparkConf,
      listenerBus: SparkListenerBus,
      jobProgressListener: JobProgressListener,
      securityManager: SecurityManager,
      appName: String,
      startTime: Long): SparkUI = {
    create(Some(sc), conf, listenerBus, securityManager, appName,
      jobProgressListener = Some(jobProgressListener), startTime = startTime)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;可以看到SparkUI的createLiveUI方法中调用了create方法。create的实现如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  private def create(
      sc: Option[SparkContext],
      conf: SparkConf,
      listenerBus: SparkListenerBus,
      securityManager: SecurityManager,
      appName: String,
      basePath: String = &quot;&quot;,
      jobProgressListener: Option[JobProgressListener] = None,
      startTime: Long): SparkUI = {

    val _jobProgressListener: JobProgressListener = jobProgressListener.getOrElse {
      val listener = new JobProgressListener(conf)
      listenerBus.addListener(listener)
      listener
    }

    val environmentListener = new EnvironmentListener
    val storageStatusListener = new StorageStatusListener(conf)
    val executorsListener = new ExecutorsListener(storageStatusListener, conf)
    val storageListener = new StorageListener(storageStatusListener)
    val operationGraphListener = new RDDOperationGraphListener(conf)

    listenerBus.addListener(environmentListener)
    listenerBus.addListener(storageStatusListener)
    listenerBus.addListener(executorsListener)
    listenerBus.addListener(storageListener)
    listenerBus.addListener(operationGraphListener)

    new SparkUI(sc, conf, securityManager, environmentListener, storageStatusListener,
      executorsListener, _jobProgressListener, storageListener, operationGraphListener,
      appName, basePath, startTime)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;可以看到create方法里除了JobProgressListener是外部传入的之外，又增加了一些SparkListener，例如用于对JVM参数、Spark属性、Java系统属性、classpath等进行监控的EnvironmentListener；用于维护Executor的存储状态的StorageStatusListener；用于准备将Executor的信息展示在ExecutorsTab的ExecutorsListener；用于准备将Executor相关存储信息展示在BlockManagerUI的StorageListener；用于构建RDD的DAG（有向无关图）的RDDOperationGraphListener等。这5个SparkListener的实现添加到listenerBus的监听器列表中。最后使用SparkUI的构造器创建SparkUI。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;SparkUI的初始化&lt;/h3&gt;
&lt;p&gt;　　调用SparkUI的构造器创建SparkUI，实际也是对SparkUI的初始化过程。在介绍初始化之前，先来看看SparkUI中的两个成员属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;killEnabled：标记当前SparkUI能否提供杀死Stage或者Job的链接。&lt;/li&gt;
&lt;li&gt;appId：当前应用的ID。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;SparkUI的构造过程中会执行initialize方法，其实现见代码清单13。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码清单13         SparkUI的初始化&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;27&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def initialize() {
    val jobsTab = new JobsTab(this)
    attachTab(jobsTab)
    val stagesTab = new StagesTab(this)
    attachTab(stagesTab)
    attachTab(new StorageTab(this))
    attachTab(new EnvironmentTab(this))
    attachTab(new ExecutorsTab(this))
    attachHandler(createStaticHandler(SparkUI.STATIC_RESOURCE_DIR, &quot;/static&quot;))
    attachHandler(createRedirectHandler(&quot;/&quot;, &quot;/jobs/&quot;, basePath = basePath))
    attachHandler(ApiRootResource.getServletHandler(this))
    // These should be POST only, but, the YARN AM proxy won't proxy POSTs
    attachHandler(createRedirectHandler(
      &quot;/jobs/job/kill&quot;, &quot;/jobs/&quot;, jobsTab.handleKillRequest, httpMethods = Set(&quot;GET&quot;, &quot;POST&quot;)))
    attachHandler(createRedirectHandler(
      &quot;/stages/stage/kill&quot;, &quot;/stages/&quot;, stagesTab.handleKillRequest,
      httpMethods = Set(&quot;GET&quot;, &quot;POST&quot;)))
  }
  initialize()
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;根据代码清单13，SparkUI的初始化步骤如下。&lt;/p&gt;
&lt;p&gt;1)  构建页面布局并给每个WebUITab中的所有WebUIPage创建对应的ServletContextHandler。这一步使用了代码清单4-8中展示的attachTab方法。&lt;/p&gt;
&lt;p&gt;2)  调用JettyUtils的createStaticHandler方法创建对静态目录org/apache/spark/ui/static提供文件服务的ServletContextHandler，并使用attachHandler方法追加到SparkUI的服务中。&lt;/p&gt;
&lt;p&gt;3)  调用JettyUtils的createRedirectHandler方法创建几个将用户对源路径的请求重定向到目标路径的ServletContextHandler。例如，将用户对根路径&quot;/&quot;的请求重定向到目标路径&quot;/jobs/&quot;的ServletContextHandler。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;SparkUI的页面布局与展示&lt;/h3&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;　　SparkUI究竟是如何实现页面布局及展示的？ 由于所有标签页都继承了SparkUITab，所以我们先来看看SparkUITab的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
private[spark] abstract class SparkUITab(parent: SparkUI, prefix: String)
  extends WebUITab(parent, prefix) {
  def appName: String = parent.getAppName
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;根据上述代码，我们知道SparkUITab继承了WebUITab，并在实现中增加了一个用于获取当前应用名称的方法appName。EnvironmentTab是用于展示JVM、Spark属性、系统属性、类路径等相关信息的标签页，由于其实现简单且能说明问题，所以本节挑选EnvironmentTab作为示例解答本节一开始提出的问题。&lt;/p&gt;
&lt;p&gt;         EnvironmentTab的实现见代码清单14。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码清单14         EnvironmentTab的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
private[ui] class EnvironmentTab(parent: SparkUI) extends SparkUITab(parent, &quot;environment&quot;) {
  val listener = parent.environmentListener
  attachPage(new EnvironmentPage(this))
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据代码清单14，我们知道EnvironmentTab引用了SparkUI的environmentListener（类型为EnvironmentListener），并且包含EnvironmentPage这个页面。EnvironmentTab通过调用attachPage方法将EnvironmentPage与Jetty服务关联起来。根据代码清单5中attachPage的实现，创建的renderHandler将采用偏函数(request: HttpServletRequest) =&amp;gt; page.render(request) 处理请求，因而会调用EnvironmentPage的render方法。EnvironmentPage的render方法将会渲染页面元素。EnvironmentPage的实现见代码清单15。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码清单15         EnvironmentPage的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;34.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
private[ui] class EnvironmentPage(parent: EnvironmentTab) extends WebUIPage(&quot;&quot;) {
  private val listener = parent.listener

  private def removePass(kv: (String, String)): (String, String) = {
    if (kv._1.toLowerCase.contains(&quot;password&quot;) || kv._1.toLowerCase.contains(&quot;secret&quot;)) {
      (kv._1, &quot;******&quot;)
    } else kv
  }

  def render(request: HttpServletRequest): Seq[Node] = {
   // 调用UIUtils的listingTable方法生成JVM运行时信息、Spark属性信息、系统属性信息、类路径信息的表格 
   val runtimeInformationTable = UIUtils.listingTable(
      propertyHeader, jvmRow, listener.jvmInformation, fixedWidth = true)
    val sparkPropertiesTable = UIUtils.listingTable(
      propertyHeader, propertyRow, listener.sparkProperties.map(removePass), fixedWidth = true)
    val systemPropertiesTable = UIUtils.listingTable(
      propertyHeader, propertyRow, listener.systemProperties, fixedWidth = true)
    val classpathEntriesTable = UIUtils.listingTable(
      classPathHeaders, classPathRow, listener.classpathEntries, fixedWidth = true)
    val content =
      &amp;lt;span&amp;gt;
        &amp;lt;h4&amp;gt;Runtime Information&amp;lt;/h4&amp;gt; {runtimeInformationTable}
        &amp;lt;h4&amp;gt;Spark Properties&amp;lt;/h4&amp;gt; {sparkPropertiesTable}
        &amp;lt;h4&amp;gt;System Properties&amp;lt;/h4&amp;gt; {systemPropertiesTable}
        &amp;lt;h4&amp;gt;Classpath Entries&amp;lt;/h4&amp;gt; {classpathEntriesTable}
      &amp;lt;/span&amp;gt;
    // 调用UIUtils的headerSparkPage方法封装好css、js、header及页面布局等
    UIUtils.headerSparkPage(&quot;Environment&quot;, content, parent)
  }
  // 定义JVM运行时信息、Spark属性信息、系统属性信息的表格头部propertyHeader和类路径信息的表格头部   
  // classPathHeaders
  private def propertyHeader = Seq(&quot;Name&quot;, &quot;Value&quot;)
  private def classPathHeaders = Seq(&quot;Resource&quot;, &quot;Source&quot;)
  // 定义JVM运行时信息的表格中每行数据的生成方法jvmRow
  private def jvmRow(kv: (String, String)) = &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{kv._1}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{kv._2}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
  private def propertyRow(kv: (String, String)) = &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{kv._1}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{kv._2}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
  private def classPathRow(data: (String, String)) = &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{data._1}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{data._2}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;根据代码清单15，EnvironmentPage的render方法利用从父节点EnvironmentTab中得到的EnvironmentListener中的统计监控数据生成JVM运行时、Spark属性、系统属性以及类路径等状态的摘要信息。以JVM运行时为例，页面渲染的步骤如下：&lt;/p&gt;
&lt;p&gt;1)  定义JVM运行时信息、Spark属性信息、系统属性信息的表格头部propertyHeader和类路径信息的表格头部classPathHeaders。&lt;/p&gt;
&lt;p&gt;2)  定义JVM运行时信息的表格中每行数据的生成方法jvmRow。&lt;/p&gt;
&lt;p&gt;3)  调用UIUtils的listingTable方法生成JVM运行时信息、Spark属性信息、系统属性信息、类路径信息的表格。&lt;/p&gt;
&lt;p&gt;4)  调用UIUtils的headerSparkPage方法封装好css、js、header及页面布局等。&lt;/p&gt;
&lt;p&gt;UIUtils工具类的实现细节留给感兴趣的读者自行查阅，本文不多赘述。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.3227272727273&quot;&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;7.7818181818182&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;file:///E:/个人资料/书/编辑疑问/第4章_SparkContext的初始化.docx#_ftnref1&quot;&gt;[1]&lt;/a&gt;本节内容用到JettyUtils中的很多方法，读者可以在附录C中找到相应的实现与说明。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;关于《Spark内核设计的艺术 架构设计与实现》&lt;/h2&gt;
&lt;p&gt;经过近一年的准备，基于Spark2.1.0版本的《Spark内核设计的艺术 架构设计与实现》一书现已出版发行，图书如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/816981/201811/816981-20181123115505723-914011488.jpg&quot; alt=&quot;Spark内核设计的艺术&quot; width=&quot;400&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;纸质版售卖链接如下：&lt;/p&gt;
&lt;p&gt;京东：&lt;a href=&quot;https://item.jd.com/12302500.html&quot; data-cke-saved-href=&quot;https://item.jd.com/12302500.html&quot;&gt;https://item.jd.com/12302500.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 06:45:00 +0000</pubDate>
<dc:creator>泰山不老生</dc:creator>
<og:description>Spark2.1.0——内置Web框架详解 任何系统都需要提供监控功能，否则在运行期间发生一些异常时，我们将会束手无策。也许有人说，可以增加日志来解决这个问题。日志只能解决你的程序逻辑在运行期的监控，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiaan-geng/p/10313068.html</dc:identifier>
</item>
<item>
<title>Perl IO：IO重定向 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10450299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10450299.html</guid>
<description>&lt;h2 id=&quot;文件句柄和文件描述符的关系&quot;&gt;文件句柄和文件描述符的关系&lt;/h2&gt;
&lt;p&gt;文件描述符是操作系统的资源，对于实体文件来说，每打开一次文件，操作系统都会为该进程分配一个文件描述符来关联(指向)这个文件，以后操作文件数据都根据这个文件描述符来操作，而不是文件名。就像对文件句柄的操作一样。&lt;/p&gt;
&lt;p&gt;实际上，文件句柄、文件描述符和实体文件的关系存在层次上的关系。文件句柄指向文件描述符，文件描述符指向实体文件结构。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201902/733013-20190228002945171-1592835358.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如图中所示，&lt;strong&gt;文件句柄是文件描述符的更上层封装，文件句柄指向文件描述符，且多个文件句柄还可以指向同一个文件描述符。同样地，多个文件描述符可以指向同一个实体文件。实际上，从文件到文件描述符，是采用引用计数的方式的，表示有多少个文件描述符还关联在这个文件上。同理，文件描述符到文件句柄，也是使用引用计数方式的，表示有多少文件句柄指向这个文件描述符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用引用计数的特点之一就是&lt;strong&gt;只有引用数为0之后才表示关闭/删除/释放行为&lt;/strong&gt;。例如，关闭文件句柄只是在文件描述符上引用数减一，而不是真的关闭文件描述符，直到文件描述符上的文件句柄引用数为0之后，这个文件描述符才会被关闭。同理，关闭文件描述符只是对文件结构的引用计数减1，直到这个文件结构的所有文件描述符都关闭了，才表示释放这个文件结构。&lt;/p&gt;
&lt;p&gt;因为文件句柄是文件描述符的上层封装，所以文件句柄比文件描述符的功能多一些。实际上，从文件描述符到实体文件，中间的数据传输是纯裸数据流，不会有缓冲行为(当然，有非IO的缓冲)。而文件句柄到文件描述符，中间有好几个IO层次，例如编码层(utf8)、换行符层(raw/crlf)、标准IO库层(stdio/perlio)、最底层(unix)。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201902/733013-20190228002553547-1222693441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;标准IO库层用来提供IO buffer层&lt;/strong&gt;，stdio是操作系统提供的标准IO库，perlio是Perl提供的标准IO库，在Perl中可以选择使用哪种IO库提供buffer。&lt;strong&gt;unix是最底层(就算是在win下也是unix层)，它是最接近文件描述符的底层，几乎是纯裸数据，没有IO buffer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模块&lt;a href=&quot;https://metacpan.org/pod/PerlIO::Layers&quot;&gt;PerlIO::Layers&lt;/a&gt;提供了Perl在文件描述符到文件句柄的IO层次上的一些检测功能，例如检测文件句柄是否已打开，是否设置了autoflush，是否使用缓冲等等。&lt;/p&gt;
&lt;h2 id=&quot;文件句柄文件描述符的duplicate&quot;&gt;文件句柄、文件描述符的duplicate&lt;/h2&gt;
&lt;p&gt;在bash shell中经常见到的&lt;code&gt;&amp;gt;file 2&amp;gt;&amp;amp;1&lt;/code&gt;，它表示将标准错误、标准输出都重定向到file文件中。这里的过程是将标准输入重定向到file文件，然后duplicate文件描述符fd=1得到fd=2，使得fd=2也指向fd=1对应的文件(即file)，从而使得标准错误、标准输出都输出到file中。&lt;/p&gt;
&lt;p&gt;除了重定向、文件描述符的duplicate，bash shell还支持文件描述符的手动打开(分配文件描述符)、移动、关闭。&lt;/p&gt;
&lt;p&gt;Perl当然也支持类似的重定向和duplcate，而且&lt;strong&gt;不仅支持文件描述符级别的，还支持更上层别文件句柄级，无论是duplicate文件句柄还是duplicate文件描述符，都会生成新的文件描述符&lt;/strong&gt;。另外，&lt;strong&gt;duplicate的对象是文件句柄时，不会将IO Buffer中的内容也duplicate&lt;/strong&gt;，也就是说新的文件句柄中没有缓冲任何数据。&lt;/p&gt;
&lt;p&gt;在Perl中，可以在open时在&lt;code&gt;&amp;gt;、&amp;gt;&amp;gt;、&amp;lt;、+&amp;gt;、+&amp;gt;&amp;gt;、+&amp;lt;&lt;/code&gt;的后面加上符号&lt;code&gt;&amp;amp;&lt;/code&gt;，这就表示文件句柄或文件描述符的duplicate。给文件句柄就是文件句柄的duplicate，给数值就是文件描述符的duplicate。open可以是两参数的或三参数的，三参数时，可以是文件句柄、文件句柄的引用(即&lt;code&gt;\*FILEHANDLE&lt;/code&gt;格式)，可以是文件描述符数值。如果需要获取文件句柄指向的文件描述符，可以使用&lt;code&gt;fileno FILEHANDLE&lt;/code&gt;函数来获取。&lt;/p&gt;
&lt;p&gt;例如，下面将STDOUT文件句柄duplicate一份得到NEWOUT，使得NEWOUT也指向标准输出，即向NEWOUT写入数据时也会出现在屏幕上(默认)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 两参数或三参数的文件句柄duplicate
open NEWOUT, &quot;&amp;gt;&amp;amp;STDOUT&quot;;
open NEWOUT, &quot;&amp;gt;&amp;amp;&quot;, &quot;STDOUT&quot;;
open NEWOUT, &quot;&amp;gt;&amp;amp;&quot;, &quot;\*STDOUT&quot;;

# 三参数的文件描述符duplicate
open NEWOUT, &quot;&amp;gt;&amp;amp;&quot;, fileno STDOUT;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上面的duplicate过程，结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201902/733013-20190228101451234-1717303890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在duplicate时，所选的模式一定要匹配源文件句柄的模式&lt;/strong&gt;。例如STDOUT是可写不可读(write-only)的文件句柄，在duplicate STDOUT时，就必须只能选择可写不可读的&lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;模式。&lt;strong&gt;duplicate后，新的文件句柄或文件描述符和源文件句柄/文件描述符的读、写模式是完全一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是将STDOUT复制多份的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
#
use strict;
use warnings;
use 5.010;

open NEWOUT, &quot;&amp;gt;&amp;amp;STDOUT&quot; or die &quot;duplicate1 failed: $!&quot;;
say NEWOUT &quot;hello world1, fd=&quot;, fileno NEWOUT;

open NEWOUT1, &quot;&amp;gt;&amp;amp;&quot;, &quot;NEWOUT&quot; or die &quot;duplicate2 failed: $!&quot;;
say NEWOUT1 &quot;hello world2, fd=&quot;, fileno NEWOUT1;

open NEWOUT2, &quot;&amp;gt;&amp;amp;&quot;, &quot;\*NEWOUT&quot; or die &quot;duplicate3 failed: $!&quot;;
say NEWOUT2 &quot;hello world3, fd=&quot;, fileno NEWOUT2;

open NEWOUT3, &quot;&amp;gt;&amp;amp;&quot;, fileno NEWOUT or die &quot;duplicate4 failed: $!&quot;;
say NEWOUT3 &quot;hello world4, fd=&quot;, fileno NEWOUT3;

close NEWOUT;
close NEWOUT1;
close NEWOUT2;
close NEWOUT3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello world1, fd=3
hello world2, fd=4
hello world3, fd=5
hello world4, fd=6&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件描述符重用句柄别名&quot;&gt;文件描述符重用：句柄别名&lt;/h2&gt;
&lt;p&gt;duplicate文件句柄或文件描述符时，都会自动新建一个新的文件描述符，并自动新建指向这个文件描述符的文件句柄。也就是说，只要duplicate一次，就至少有2个描述符，两个句柄。&lt;/p&gt;
&lt;p&gt;如果想要重用文件描述符，只新建文件句柄，Perl中可以使用&lt;code&gt;&amp;amp;=&lt;/code&gt;符号（&lt;code&gt;&amp;lt;&amp;amp;=、&amp;gt;&amp;amp;=、&amp;gt;&amp;gt;&amp;amp;=、+&amp;lt;&amp;amp;=、+&amp;gt;&amp;amp;=、+&amp;gt;&amp;gt;&amp;amp;=&lt;/code&gt;），这表示创建一个文件句柄别名，使这个文件句柄也指向同一个文件描述符。也支持直接对文件描述符设置别名句柄，它会新建一个句柄指向这个文件描述符。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open(ALIAS, &quot;&amp;gt;&amp;amp;=HANDLE&quot;);
open ALIAS, &quot;&amp;gt;&amp;amp;=&quot;, fileno HANDLE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示创建HANDLE句柄的一个别名，使得它两指向同一个文件描述符。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201902/733013-20190228112645736-146586586.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为两个句柄指向同一个文件描述符，所以这两个文件句柄共享了这个文件描述符，包括这个描述符上的锁。另外，从任一句柄更改描述符状态，都会直接反映到另一个文件句柄上，比如从一个文件句柄上加一把flock锁，因为flock锁是直接文件描述符上的，所以另一个文件句柄别名也会持有这把锁。&lt;/p&gt;
&lt;h2 id=&quot;重定向&quot;&gt;重定向&lt;/h2&gt;
&lt;p&gt;在bash中重定向非常的简单，在Perl中重定向直接使用&lt;code&gt;&amp;gt; &amp;lt; &amp;gt;&amp;gt; +&amp;gt; +&amp;gt;&amp;gt; +&amp;lt;&lt;/code&gt;即可，只不过open的第一个参数是一个已存在的文件句柄，其无非是将输入自或输出到的某个文件句柄/文件描述符的数据转向另一个方向。&lt;/p&gt;
&lt;p&gt;例如，将输出到标准输出的数据重定向到某个文件中，就像使用&lt;code&gt;select FILEHANDLE&lt;/code&gt;一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open STDOUT, &quot;&amp;gt; abc.log&quot;;
say &quot;hello world&quot;;   # 将输出到abc.log文件中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如输入重定向，STDIN本该是从标准输入中读取数据的，但是现在改从一个文件中读取数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open STDIN, &quot;&amp;lt; abc.log&quot;;
while(&amp;lt;STDIN&amp;gt;){
    chomp;
    print &quot;$_\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样使用重定向功能会有一个问题，STDOUT或STDIN或其它重定向句柄没法还原回原始的目标了。例如STDOUT原本是输出到终端的，将其重定向到某个文件后就没法找回输出到终端的方法了。所以，在程序中使用重定向时，经常会将重定向配合duplicate使用，&lt;strong&gt;在重定向之前，先将重定向句柄dup保存一份，然后重定向，重定向结束后再使用保存的句柄恢复回来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 1.dup。OLDOUT和STDOUT都将指向同一个底层文件结构：终端设备文件
open OLDOUT, &quot;&amp;gt;&amp;amp;&quot;, STDOUT or die &quot;duplicate failed: $!&quot;;

# 2.redirect。OLDOUT仍然指向终端设备文件，但是STDOUT指向新文件结构
open STDOUT, &quot;&amp;gt; $newfile&quot; or die &quot;redirect failed: $!&quot;;

... do something to STDOUT ...

# 3.restore。通过dup的方式从OLDOUT恢复STDOUT
close STDOUT or die &quot;close failed: $!&quot;;
open STDOUT, &quot;&amp;gt;&amp;amp;&quot;, OLDOUT or die &quot;duplicate failed: $!&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面第三步中恢复之前，记得先关闭STDOUT，如果不关闭STDOUT，在第二步过程中STDOUT中的缓冲不会flush。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 06:42:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>文件句柄和文件描述符的关系 文件描述符是操作系统的资源，对于实体文件来说，每打开一次文件，操作系统都会为该进程分配一个文件描述符来关联(指向)这个文件，以后操作文件数据都根据这个文件描述符来操作，而不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10450299.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC5 + EF6 + LayUI实战教程，通用后台管理系统框架（3） - 小喆科技</title>
<link>http://www.cnblogs.com/xu3784/p/10450208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu3784/p/10450208.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本节将我们自己的CSS样式替换系统自带的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将脚本文件夹删掉，将内容文件夹里的内容删掉，将我们自己的CSS样式文件，全部复制到内容里边&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-314&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/1-1.jpg&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;583&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;新建家庭控制器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-316&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/1-2.jpg&quot; alt=&quot;&quot; width=&quot;955&quot; height=&quot;660&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-large wp-image-317&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/2-2.jpg&quot; alt=&quot;&quot; width=&quot;816&quot; height=&quot;241&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;给家庭控制器添加索引视图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-large wp-image-318&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/3-1.jpg&quot; alt=&quot;&quot; width=&quot;815&quot; height=&quot;637&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-large wp-image-319&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/4-1.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;350&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;指数代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; @ { Layout = &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ; }
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;   
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &amp;lt;！DOCTYPE html &amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt; meta charset = “utf-&lt;span&gt;8&lt;/span&gt;” &amp;gt; &amp;lt;title&amp;gt; BYCMS 后台管理系统&amp;lt;/ title &amp;gt; &amp;lt; meta name = “renderer” content = “webkit” &amp;gt; &amp;lt; meta http - equiv = “ X-UA兼容“ content = ”IE = edge，chrome = &lt;span&gt;1&lt;/span&gt;“ &amp;gt; &amp;lt; meta http - equiv = ”Access-Control-Allow-Origin“ content = ”*&lt;span&gt;“
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; “viewport” content = “width = device-width，initial-scale = &lt;span&gt;1&lt;/span&gt;，maximum-scale = &lt;span&gt;1&lt;/span&gt;” &amp;gt; &amp;lt; meta name = “apple-mobile-web-app-status-bar-style” content = “black” &amp;gt; &amp;lt; meta name = “apple-mobile-web-app-capable” content = “yes” &amp;gt; &amp;lt; meta name = “format-detection” content = “telephone = no” &amp;gt; &amp;lt; link rel = “icon” href = “〜/内容/ images / favicon.ico“ &amp;gt;&amp;lt; link rel =&lt;span&gt; “stylesheet”
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; href = “〜/ Content / css / index.css” media = “all” /&amp;gt; &amp;lt; link rel = “stylesheet” href = “〜/ Content / layui / css / layui.css” media = “all” /&amp;gt; &amp;lt; link rel = “stylesheet” href = “〜/ Content / css / index.css” media = “all” /&amp;gt; &amp;lt; / head&amp;gt; 
&lt;span&gt; 19&lt;/span&gt;  
&lt;span&gt; 20&lt;/span&gt;  
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &amp;lt;body &lt;span&gt;class&lt;/span&gt; =“main_body”&amp;gt;
&lt;span&gt; 23&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“layui-layout layui-layout-admin”&amp;gt;
&lt;span&gt; 24&lt;/span&gt; &amp;lt;！ - 顶部 - &amp;gt;
&lt;span&gt; 25&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“layui-header header”&amp;gt;
&lt;span&gt; 26&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“layui-main mag0”&amp;gt;
&lt;span&gt; 27&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; BYCMS &amp;lt;/ a &amp;gt; &amp;lt;！ - 显示/隐藏菜单- &amp;gt; &amp;lt; a href = “javascript：;” &lt;span&gt;class&lt;/span&gt; = “seraph hideMenu icon-caidan” &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt;！ - 顶级菜单- &amp;gt; &amp;lt; ul &lt;span&gt;class&lt;/span&gt; = “layui-nav mobileTopLevelMenus” mobile &amp;gt; &amp;lt; li &lt;span&gt;class&lt;/span&gt; = “layui-nav-item” data - menu = “contentManagement” &amp;gt; &amp;lt; a href =&lt;span&gt; “javascript：;”
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;   
&lt;span&gt; 29&lt;/span&gt;  
&lt;span&gt; 30&lt;/span&gt;   
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; “seraph icon-caidan” &amp;gt; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt; layuiCMS &amp;lt; / cite&amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; dl &lt;span&gt;class&lt;/span&gt; = “layui-nav-child” &amp;gt; &amp;lt; dd &lt;span&gt;class&lt;/span&gt; = “layui-&lt;span&gt;this&lt;/span&gt;” data - menu = “contentManagement “ &amp;gt; &amp;lt; a href = ”javascript：;“ &amp;gt; &amp;lt; i &lt;span&gt;class&lt;/span&gt; = “layui-icon” data - icon = “＆＃xe63c;” &amp;gt;＆＃xe63c; &amp;lt;/ i&amp;gt; &amp;lt;cite&amp;gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; = “memberCenter” &amp;gt; &amp;lt; a href = “javascript：;” &amp;gt; &amp;lt; i &lt;span&gt;class&lt;/span&gt; = “seraph icon-icon10” data - icon = “icon-icon10” &amp;gt; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;用户中心&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt;/ dd &amp;gt; &amp;lt; dd data - menu = “systemeSttings “ &amp;gt; &amp;lt; a href = ”javascript：;“ &amp;gt; &amp;lt; i &lt;span&gt;class&lt;/span&gt; = “layui-icon” data - icon = “＆＃xe620;” &amp;gt;&lt;span&gt;＆
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; ＃xe620; &amp;lt;/ i&amp;gt; &amp;lt;cite&amp;gt;系统设置&amp;lt;/ cite&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/ dd&amp;gt; &amp;lt; dd data - menu = “seraphApi” &amp;gt; &amp;lt; a href = “javascript：;” &amp;gt; &amp;lt; i &lt;span&gt;class&lt;/span&gt; = “layui-icon” data - icon = “＆＃xe705;” &amp;gt;＆＃xe705; &amp;lt;/ i&amp;gt; &amp;lt;cite&amp;gt;使用文档&amp;lt;/ cite&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/ dd&amp;gt; &amp;lt; / dl&amp;gt;
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt; &amp;lt;/ li &amp;gt; &amp;lt; / ul&amp;gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &amp;lt;ul &lt;span&gt;class&lt;/span&gt; =“layui-nav topLevelMenus”pc&amp;gt;
&lt;span&gt; 43&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item layui-&lt;span&gt;this&lt;/span&gt;”data-menu =“contentManagement”&amp;gt;
&lt;span&gt; 44&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“layui-icon”data-icon =“＆＃xe63c;”&amp;gt;＆＃xe63c; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;内容管理&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; / li&amp;gt;
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item”data-menu =“memberCenter”pc&amp;gt;
&lt;span&gt; 47&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“seraph icon-icon10”data-icon =“icon-icon10”&amp;gt; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;用户中心&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; / li &amp;gt;
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item”data-menu =“systemeSttings”pc&amp;gt;
&lt;span&gt; 50&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“layui-icon”data-icon =“＆＃xe620;”&amp;gt;＆＃xe620; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;系统设置&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; / li&amp;gt;
&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item”data-menu =“seraphApi”pc&amp;gt;
&lt;span&gt; 53&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“layui-icon”data-icon =“＆＃xe705;”&amp;gt;＆＃xe705; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;使用文档&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; / li&amp;gt;
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &amp;lt;/ ul &amp;gt; &amp;lt;！ - 顶部右侧菜单- &amp;gt; &amp;lt; ul &lt;span&gt;class&lt;/span&gt; = “layui-nav top_menu” &amp;gt; &amp;lt; li &lt;span&gt;class&lt;/span&gt; = “layui-nav-item” pc &amp;gt; &amp;lt; a href = “javascript：;” &lt;span&gt;class&lt;/span&gt; = “clearCache” &amp;gt; &amp;lt; i &lt;span&gt;class&lt;/span&gt; = “layui-icon” data - icon = “＆＃xe640;” &amp;gt;＆＃xe640; &amp;lt;/ i&amp;gt; &amp;lt;cite&amp;gt;清除缓存&amp;lt;/ cite&amp;gt; &amp;lt;span &lt;span&gt;class&lt;/span&gt; =“layui-badge-dot”&amp;gt; &amp;lt;/ span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;
&lt;span&gt; 56&lt;/span&gt;   
&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;  
&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item lockcms”pc&amp;gt;
&lt;span&gt; 62&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“seraph icon-&lt;span&gt;lock&lt;/span&gt;”&amp;gt; &amp;lt;/ i &amp;gt; &amp;lt; cite &amp;gt;锁屏&amp;lt;/ cite &amp;gt; &amp;lt;/ a &amp;gt; &amp;lt; / li&amp;gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“layui-nav-item”id =“userInfo”&amp;gt;
&lt;span&gt; 65&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;IMG SRC = “〜/ 内容/ 图像/ 面。JPG ”类= “ layui - NAV - IMG userAvatar ”宽度=“ &lt;span&gt;35&lt;/span&gt; ”HEIGHT =“ &lt;span&gt;35&lt;/span&gt; ”&amp;gt; &amp;lt;引用类= “ adminName ”&amp;gt;许伯一博客&amp;lt;/ cite&amp;gt; &amp;lt;/a&amp;gt;
&lt;span&gt; 66&lt;/span&gt; &amp;lt;dl &lt;span&gt;class&lt;/span&gt; =“ layui - nav - child ”&amp;gt;
&lt;span&gt; 67&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “data-url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 页/ 用户/ 用户信息的html &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;。 &amp;lt;I类=” 撒拉弗图标- ziliao “数据图标=” 图标- ziliao “&amp;gt; &amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;个人资料&amp;lt;/举&amp;gt; &amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “data-url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 页/ 用户/ changePwd HTML &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;。 &amp;lt;I类=” 撒拉弗图标- xiugai “数据图标=” 图标- xiugai “&amp;gt; &amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;修改密码&amp;lt;/举&amp;gt; &amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; showNotice &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” layui - 图标“&amp;gt;＆＃xe645; &amp;lt;/ i&amp;gt;的&amp;lt;引用&amp;gt;系统公告&amp;lt;/举&amp;gt; &amp;lt;跨度类=” layui - badge - dot “&amp;gt; &amp;lt;/ span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/ dd&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &amp;lt;DD PC&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; functionSetting &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” layui - 图标“&amp;gt;＆＃xe620; &amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;功能设定&amp;lt;/举&amp;gt; &amp;lt;跨度类=“ layui - badge - dot ”&amp;gt; &amp;lt;/ span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/ dd&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &amp;lt;DD PC&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; changeSkin &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” layui - 图标“&amp;gt;＆＃xe61b; &amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;更换皮肤&amp;lt;/举&amp;gt; &amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 页/ 登录/ 登录的html “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; signOut &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;。 &amp;lt;I类=” 撒拉弗图标- 一家推出“&amp;gt; &amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;退出&amp;lt;/举&amp;gt; &amp;lt;/A&amp;gt; &amp;lt; / DD&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &amp;lt;/ DL&amp;gt;
&lt;span&gt; 74&lt;/span&gt; &amp;lt;/ LI&amp;gt;
&lt;span&gt; 75&lt;/span&gt; &amp;lt;/ UL&amp;gt;
&lt;span&gt; 76&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt; 77&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt; 78&lt;/span&gt; &amp;lt;！ - 左侧导航 - &amp;gt;
&lt;span&gt; 79&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - side layui - bg - black ”&amp;gt;
&lt;span&gt; 80&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ user - photo ”&amp;gt;
&lt;span&gt; 81&lt;/span&gt; &amp;lt;a &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; IMG “title=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 我的头像&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;IMG SRC =” 〜/内容/ 图像/ 面。JPG “类=” userAvatar “&amp;gt; &amp;lt;/A&amp;gt;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &amp;lt;p&amp;gt;你好！&amp;lt;span &lt;span&gt;class&lt;/span&gt; =“ userName ”&amp;gt;许伯一博客&amp;lt;/ span&amp;gt;，欢迎登录&amp;lt;/ p&amp;gt;
&lt;span&gt; 83&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt; 84&lt;/span&gt; &amp;lt;！ - 搜索 - &amp;gt;
&lt;span&gt; 85&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - form component ”&amp;gt;
&lt;span&gt; 86&lt;/span&gt; &amp;lt;&lt;span&gt;select&lt;/span&gt; name =“ search ”id =“ search ”lay-search lay-filter =“ searchPage ”&amp;gt;
&lt;span&gt; 87&lt;/span&gt; &amp;lt;option value =“”&amp;gt;搜索页面或功能&amp;lt;/ option&amp;gt;
&lt;span&gt; 88&lt;/span&gt; &amp;lt;option value =“ &lt;span&gt;1&lt;/span&gt; ”&amp;gt;图层&amp;lt;/ option&amp;gt;
&lt;span&gt; 89&lt;/span&gt; &amp;lt;option value =“ &lt;span&gt;2&lt;/span&gt; ”&amp;gt;表格&amp;lt;/ option&amp;gt;
&lt;span&gt; 90&lt;/span&gt; &amp;lt;/选择&amp;gt;
&lt;span&gt; 91&lt;/span&gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“ layui - icon ”&amp;gt;＆＃xe615; &amp;lt;/ i&amp;gt;
&lt;span&gt; 92&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt; 93&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ navBar layui - side - scroll ”id =“ navBar ”&amp;gt;
&lt;span&gt; 94&lt;/span&gt; &amp;lt;ul &lt;span&gt;class&lt;/span&gt; =“ layui - nav layui - nav - tree ”&amp;gt;
&lt;span&gt; 95&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“ layui - nav - item layui - &lt;span&gt;this&lt;/span&gt; ”&amp;gt;
&lt;span&gt; 96&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “data-url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 页/ 主HTML &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;。 &amp;lt;I类=” layui - 图标“数据图标=”  “&amp;gt;&amp;lt;/ i&amp;gt;的&amp;lt;举&amp;gt;后台首页&amp;lt;/举&amp;gt; &amp;lt;/A&amp;gt;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &amp;lt;/ LI&amp;gt;
&lt;span&gt; 98&lt;/span&gt; &amp;lt;/ UL&amp;gt;
&lt;span&gt; 99&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;100&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;101&lt;/span&gt; &amp;lt;！ - 右侧内容 - &amp;gt;
&lt;span&gt;102&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - body layui - form ”&amp;gt;
&lt;span&gt;103&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - tab mag0 ”lay-filter =“ bodyTab ”id =“ top_tabs_box ”&amp;gt;
&lt;span&gt;104&lt;/span&gt; &amp;lt;ul &lt;span&gt;class&lt;/span&gt; =“ layui - tab - title top_tab ”id =“ top_tabs ”&amp;gt;
&lt;span&gt;105&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“ layui - &lt;span&gt;this&lt;/span&gt; ”lay-id =“”&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“ layui - icon ”&amp;gt;＆＃xe68e; &amp;lt;/ i&amp;gt; &amp;lt;cite&amp;gt;后台首页&amp;lt;/ cite&amp;gt; &amp;lt;/ li&amp;gt;
&lt;span&gt;106&lt;/span&gt; &amp;lt;/ UL&amp;gt;
&lt;span&gt;107&lt;/span&gt; &amp;lt;ul &lt;span&gt;class&lt;/span&gt; =“ layui - nav closeBox ”&amp;gt;
&lt;span&gt;108&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt; =“ layui - nav - item ”&amp;gt;
&lt;span&gt;109&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;I类= “ layui - 图标caozuo ”&amp;gt;＆＃xe643; &amp;lt;/ i&amp;gt;的页面操作&amp;lt;/A&amp;gt;
&lt;span&gt;110&lt;/span&gt; &amp;lt;dl &lt;span&gt;class&lt;/span&gt; =“ layui - nav - child ”&amp;gt;
&lt;span&gt;111&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 刷新refreshThis &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” layui - 图标“&amp;gt;＆＃x1002; &amp;lt;/ i&amp;gt;的刷新当前&amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; closePageOther &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” 撒拉弗图标- 禁止“&amp;gt; &amp;lt;/ i&amp;gt;的关闭其他&amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; &amp;lt;DD&amp;gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的javascript :; “class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; closePageAll &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;lt;I类=” 撒拉弗图标- guanbi “&amp;gt; &amp;lt;/ i&amp;gt;的关闭全部&amp;lt;/A&amp;gt; &amp;lt;/ DD&amp;gt;&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; &amp;lt;/ DL&amp;gt;
&lt;span&gt;115&lt;/span&gt; &amp;lt;/ LI&amp;gt;
&lt;span&gt;116&lt;/span&gt; &amp;lt;/ UL&amp;gt;
&lt;span&gt;117&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - tab - content clildFrame ”&amp;gt;
&lt;span&gt;118&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - tab - item layui - show ”&amp;gt;
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;你好，世界
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;121&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;122&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;123&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;124&lt;/span&gt; &amp;lt;！ - 底部 - &amp;gt;
&lt;span&gt;125&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ layui - footer footer ”&amp;gt;
&lt;span&gt;126&lt;/span&gt; &amp;lt;P&amp;gt; &amp;lt;跨度&amp;gt;版权@@ 2018许伯一博客&amp;lt;/跨度&amp;gt; &amp;lt;a onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 捐赠()“class=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; layui-BTN layui-BTN- 危险layui-BTN-SM &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;捐赠作者&amp;lt;/一&amp;gt; &amp;lt;/ p&amp;gt;&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;128&lt;/span&gt; &amp;lt;/ DIV&amp;gt;
&lt;span&gt;129&lt;/span&gt; &amp;lt;！ - 移动导航 - &amp;gt;
&lt;span&gt;130&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ site - tree - mobile ”&amp;gt; &amp;lt;i &lt;span&gt;class&lt;/span&gt; =“ layui - icon ”&amp;gt;＆＃xe602; &amp;lt;/ i&amp;gt; &amp;lt;/ div&amp;gt;
&lt;span&gt;131&lt;/span&gt; &amp;lt;div &lt;span&gt;class&lt;/span&gt; =“ site - mobile - shade ”&amp;gt; &amp;lt;/ div&amp;gt;
&lt;span&gt;132&lt;/span&gt; &amp;lt;脚本类型= “ 文本/ JavaScript的”SRC =“ 〜/内容/ layui / layui 。JS ”&amp;gt; &amp;lt;/ SCRIPT&amp;gt;
&lt;span&gt;133&lt;/span&gt; &amp;lt;脚本类型= “ 文本/ JavaScript的”SRC =“ 〜/内容/ JS / 索引。JS ”&amp;gt; &amp;lt;/ SCRIPT&amp;gt;
&lt;span&gt;134&lt;/span&gt; &amp;lt;脚本类型= “ 文本/ JavaScript的”SRC =“ 〜/内容/ JS / 高速缓存。JS ”&amp;gt; &amp;lt;/ SCRIPT&amp;gt;
&lt;span&gt;135&lt;/span&gt; &amp;lt;/ BODY&amp;gt;
&lt;span&gt;136&lt;/span&gt; &amp;lt;/ HTML&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;初步效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-large wp-image-325&quot; src=&quot;http://img.xuboyi.com/wp-content/uploads/2019/02/5-1-1024x618.jpg&quot; alt=&quot;&quot; width=&quot;1024&quot; height=&quot;618&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;终于见到点东西了，Hello World终于问世了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为了照顾零基础的朋友，每一步都有截图，算是详细的图文教程了，往后再有同样的步骤，就不再单步截图了，就要捡重点讲解了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Thu, 28 Feb 2019 06:32:00 +0000</pubDate>
<dc:creator>小喆科技</dc:creator>
<og:description>前言 本节将我们自己的CSS样式替换系统自带的 开始搭建 将脚本文件夹删掉，将内容文件夹里的内容删掉，将我们自己的CSS样式文件，全部复制到内容里边 新建家庭控制器 给家庭控制器添加索引视图 指数代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu3784/p/10450208.html</dc:identifier>
</item>
<item>
<title>IIS集中化管理与编程REST API - 滴答的雨</title>
<link>http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html</guid>
<description>&lt;p class=&quot;MsoTocHeading&quot;&gt;&lt;span&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html#one&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;一、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;简介&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html#two&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;安装&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html#three&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;三、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;IIS Administration&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;配置文件&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html#_Toc1846932&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;四、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;Web UI&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;管理界面&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoToc1&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html#_Toc1846933&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;五、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt; &lt;span&gt;IIS Administration API&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Microsoft IIS Administration&lt;/span&gt; &lt;span&gt;微软提供，管理&lt;span lang=&quot;EN-US&quot;&gt;IIS配置&lt;/span&gt;的&lt;span lang=&quot;EN-US&quot;&gt;REST API&lt;/span&gt; 和集中化IIS管理&lt;span lang=&quot;EN-US&quot;&gt;WEB UI&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;支持绝大部分&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;配置项管理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;支持管理远程&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;，实现集中化&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;配置管理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;支持&lt;span lang=&quot;EN-US&quot;&gt;REST API&lt;/span&gt;，方便集成到自研系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;支持&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;配置访问安全性设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Github&lt;/span&gt;：&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/Microsoft/IIS.Administration&quot; target=&quot;_blank&quot;&gt;https://github.com/Microsoft/IIS.Administration&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;微软官网使用文档：&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/IIS-Administration/&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/IIS-Administration/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;下载：&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/IIS-Administration/getting-started&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/IIS-Administration/getting-started&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;环境要求：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 操作系统&lt;span lang=&quot;EN-US&quot;&gt;Windows7&lt;/span&gt;版本及以上版本&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;IIS Administration API&lt;/span&gt; 依赖&lt;span lang=&quot;EN-US&quot;&gt;.NET Core&lt;/span&gt;，在安装&lt;span lang=&quot;EN-US&quot;&gt;IIS Administration&lt;/span&gt;安装包时，会按需自动安装&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;安装完后：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Windows&lt;/span&gt;服务名：&lt;span lang=&quot;EN-US&quot;&gt;Microsoft IIS Administration&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Microsoft IIS Administration API&lt;/span&gt;地址：&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;https://localhost:55539&lt;/span&gt;&lt;/span&gt; &lt;span&gt;（可以使用&lt;span lang=&quot;EN-US&quot;&gt;IP&lt;/span&gt;地址访问，当时会遇到权限问题，修改权限的方法在下面“修改配置文件”中介绍）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Web UI&lt;/span&gt;管理地址：&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://manage.iis.net/get&quot;&gt;https://manage.iis.net/get&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;获取&lt;span lang=&quot;EN-US&quot;&gt;AccessToken&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;进入&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;https://localhost:55539/connect&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，创建一个&lt;span lang=&quot;EN-US&quot;&gt;Access Key&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140427844-1528310468.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140428334-641015159.png&quot; alt=&quot;image&quot; width=&quot;714&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;拿到&lt;span lang=&quot;EN-US&quot;&gt;accesstoken&lt;/span&gt;后&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 通过地址：&lt;span lang=&quot;EN-US&quot;&gt;https://localhost:55539/connect&lt;span&gt; &lt;/span&gt;&lt;/span&gt;进入&lt;span lang=&quot;EN-US&quot;&gt;api&lt;/span&gt;展示界面（&lt;span lang=&quot;EN-US&quot;&gt;https://localhost:55539/#/api&lt;/span&gt;），查看可在自己的程序中通过&lt;span lang=&quot;EN-US&quot;&gt;rest api&lt;/span&gt; 访问&lt;span lang=&quot;EN-US&quot;&gt;iis&lt;/span&gt;信息&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;l&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 通过地址：&lt;span lang=&quot;EN-US&quot;&gt;https://manage.iis.net/connect&lt;/span&gt; 进入&lt;span lang=&quot;EN-US&quot;&gt;UI&lt;/span&gt;管理界面&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt;三、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Administration&lt;/span&gt;配置文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;1)&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 配置文件路径：&lt;span lang=&quot;EN-US&quot;&gt;%SystemDrive%\Program Files\IIS Administration\&amp;lt;version&amp;gt;\Microsoft.IIS.Administration\config\**&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;2)&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;修改配置文件后需要重启&lt;span lang=&quot;EN-US&quot;&gt;windows&lt;/span&gt;服务（&lt;span lang=&quot;EN-US&quot;&gt;Microsoft IIS Administration&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;3)&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;appsettings.json&lt;/span&gt; &lt;span&gt;配置：安全性、日志、&lt;span lang=&quot;EN-US&quot;&gt;audit&lt;/span&gt;（审计）、&lt;span lang=&quot;EN-US&quot;&gt;cors&lt;/span&gt;（跨域）等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;4)&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;modules.json&lt;/span&gt;&lt;span&gt;配置：启用或禁用&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;配置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;配置修改示例&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;示例一、访问&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;远程IP&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;地址:55539/connect&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;，出现&lt;span lang=&quot;EN-US&quot;&gt;windows&lt;/span&gt;登录验证框&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140428648-1692471065.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140429266-1231386464.png&quot; alt=&quot;image&quot; width=&quot;750&quot; height=&quot;337&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;修改点：修改&lt;span lang=&quot;EN-US&quot;&gt;appsettings.json&lt;/span&gt;&lt;span&gt;，将&lt;span lang=&quot;EN-US&quot;&gt;&quot;require_windows_authentication&quot;&lt;/span&gt;设置为 &lt;span lang=&quot;EN-US&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;示例二、编码访问&lt;span lang=&quot;EN-US&quot;&gt;IIS Administration REST API&lt;/span&gt; 报&lt;span lang=&quot;EN-US&quot;&gt;401&lt;/span&gt;没有权限访问&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;修改点：修改&lt;span lang=&quot;EN-US&quot;&gt;appsettings.json&lt;/span&gt;&lt;span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;&quot;access_policy&quot; -&amp;gt; &quot;api&quot; -&amp;gt;&quot;users&quot;: &quot;administrators&quot;&lt;/span&gt;修改为：&lt;span lang=&quot;EN-US&quot;&gt;&quot;users&quot;: &quot;Everyone&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;appsettings.json&lt;/span&gt;修改后类似如下：&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;默认会将执行安装包的角色加入到安全设置中&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&quot;security&quot;: {
    &quot;require_windows_authentication&quot;: false,    // 默认为true
    &quot;users&quot;: {
      &quot;administrators&quot;: [
                ……
      ],
      &quot;owners&quot;: [
                ……
      ]
    },
    &quot;access_policy&quot;: {
      &quot;api&quot;: {
        &quot;users&quot;: &quot;Everyone&quot;,    // 默认为执行安装包角色
        &quot;access_key&quot;: true
      },
      &quot;api_keys&quot;: {
        &quot;users&quot;: &quot;administrators&quot;,
        &quot;access_key&quot;: false
      },
      &quot;system&quot;: {
        &quot;users&quot;: &quot;owners&quot;,
        &quot;access_key&quot;: true
      }
    }
  }
&lt;/pre&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;四、&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Web UI&lt;/span&gt;管理界面&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;前面介绍中拿到&lt;span lang=&quot;EN-US&quot;&gt;Access Token&lt;/span&gt;后，进入 &lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://manage.iis.net&quot;&gt;https://manage.iis.net&lt;/a&gt;&lt;/span&gt; 管理界面&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;支持远程&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;管理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140429766-1791638719.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140430234-16476443.png&quot; alt=&quot;image&quot; width=&quot;846&quot; height=&quot;306&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;服务器的系统资源监控&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140430864-1845323188.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140431488-1236018375.png&quot; alt=&quot;image&quot; width=&quot;843&quot; height=&quot;546&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;根节点配置管理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140432083-59943257.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140432631-851045597.png&quot; alt=&quot;image&quot; width=&quot;839&quot; height=&quot;474&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140433102-944151118.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140433590-1572643214.png&quot; alt=&quot;image&quot; width=&quot;562&quot; height=&quot;797&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;&lt;span&gt;上的站点信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140434298-1076338133.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140434895-345825013.png&quot; alt=&quot;image&quot; width=&quot;792&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS&lt;/span&gt;&lt;span&gt;上的特定站点配置管理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;包括：绑定信息、应用程序池、虚拟目录下的应用程序、身份验证、默认文档、目录浏览、&lt;span lang=&quot;EN-US&quot;&gt;IP&lt;/span&gt;限制、日志、&lt;span lang=&quot;EN-US&quot;&gt;MIME&lt;/span&gt;类型、监控、模块、响应压缩、请求筛选、&lt;span lang=&quot;EN-US&quot;&gt;HTTP&lt;/span&gt;响应标头、请求跟踪、静态缓存、&lt;span lang=&quot;EN-US&quot;&gt;HTTP&lt;/span&gt;重定向等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140435442-437392088.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140436050-1582398524.png&quot; alt=&quot;image&quot; width=&quot;739&quot; height=&quot;734&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140436725-1770276072.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140437350-1573057119.png&quot; alt=&quot;image&quot; width=&quot;758&quot; height=&quot;435&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;五、&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IIS Administration API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;前面介绍中拿到&lt;span lang=&quot;EN-US&quot;&gt;Access Token&lt;/span&gt;后，进入 &lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;https://localhost:55539/#/api&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140437893-680381394.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140438378-179834003.png&quot; alt=&quot;image&quot; width=&quot;596&quot; height=&quot;659&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140438840-1077586676.png&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/106337/201902/106337-20190228140439411-1096504808.png&quot; alt=&quot;image&quot; width=&quot;655&quot; height=&quot;671&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;METHOD &lt;span&gt;    &lt;/span&gt; DESCRIPTION&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;GET &lt;span&gt;       &lt;/span&gt; Retrieves the specified resource&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;POST &lt;span&gt;      &lt;/span&gt; Creates a resource&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;PATCH &lt;span&gt;     &lt;/span&gt; Updates the specified resource&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;DELETE &lt;span&gt;    &lt;/span&gt; Deletes the specified resource&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;HEAD &lt;span&gt;      &lt;/span&gt; Similar to get except only returns HTTP headers&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/IIS-Administration/api/crud&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/IIS-Administration/api/crud&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;代码示例&lt;span lang=&quot;EN-US&quot;&gt;RestSharp&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: c-sharp;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
var client = new RestClient(iisAdminBaseUrl);
ServicePointManager.ServerCertificateValidationCallback +=
(sender, certificate, chain, sslPolicyErrors) =&amp;gt; true;
var request = new RestRequest(&quot;/api/webserver/websites&quot;, Method.GET);
request.AddHeader(&quot;Access-Token&quot;, $&quot;Bearer {token}&quot;);
request.AddHeader(&quot;Accept&quot;, &quot;application/hal+json&quot;);
IRestResponse response = client.Execute(request);
if (response.IsSuccessful)
{ …… }
&lt;/pre&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;代码示例&lt;span lang=&quot;EN-US&quot;&gt;HttpClient&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: c-sharp;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
var apiClient = new HttpClient(new HttpClientHandler()
{
UseDefaultCredentials = true,
ServerCertificateCustomValidationCallback = (message, cert, chain, error) =&amp;gt; true
}, true);
// Set access token for every request
apiClient.DefaultRequestHeaders.Add(&quot;Access-Token&quot;, &quot;Bearer {token}&quot;);
// Request HAL (_links)
apiClient.DefaultRequestHeaders.Add(&quot;Accept&quot;, &quot;application/hal+json&quot;);

var res = await apiClient.GetAsync(&quot;https://localhost:55539/api/webserver/websites&quot;);
if (res.StatusCode != HttpStatusCode.OK) {
  HandleError(res);
  return;
}
JArray sites = JObject.Parse(res.Content.ReadAsStringAsync().Result).Value&amp;lt;JArray&amp;gt;(&quot;websites&quot;);
&lt;/pre&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;===========================================&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;over&lt;/span&gt;，谢谢阅读，若对你有帮助，请帮推荐下。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 06:05:00 +0000</pubDate>
<dc:creator>滴答的雨</dc:creator>
<og:description>IIS Administration 管理IIS配置的REST API 和集中化IIS管理WEB UI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heyuquan/p/iis-admin-and-develop.html</dc:identifier>
</item>
</channel>
</rss>