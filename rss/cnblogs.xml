<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员必备能力——晋升之道 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/13894701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/13894701.html</guid>
<description>&lt;p&gt;从我认识的程序员中，包括我的团队中，有不少很久都没有晋升过。他们维护着已经再熟悉不过的模块，能迅速定位bug所在代码行数，在他们当中有部分人热爱coding，享受debug带来的成就感，但是绝大部分的程序员并不是他们热爱，而更多的是被迫。&lt;/p&gt;
&lt;p&gt;你们有认识这样的人吗？我想你肯定已经在点头了，这种情况竟然出乎意料的常见。如果你不想在这条死胡同里终老，你就应该主动点。&lt;/p&gt;
&lt;p&gt;本篇文章，我会从我多年工作经验的角度，结合自己的工作经历，给到大家一些快速晋升的建议，希望能够帮助到大家，少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/4ae3c78e2e39697b98d1cf3bdb8d261c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;在2017年发布的《中美毕业生就业对比研究》报告中，我们可以发现就业总量和就业结构，我们国家的就业的人口大概达到了7.4亿。并且这个数字还在每年700万的递增。随着最近十年互联网的繁荣，大量互联网公司如春笋一般涌出。但是每年毕业的大学生年年创新高。而我们也发现了每年毕业生的压力都在增加，IT市场已经进入到了“供大于求”的状态，而且是长期的存在。&lt;/p&gt;
&lt;p&gt;”知道的越多，就越感觉自己知道的少“，我想大家应该也有这种感觉吧。只有认识到自己的不足，才会有目标，有了目标，就有实现目标的动力，有了动力我们才能持续成长。&lt;/p&gt;
&lt;p&gt;很多同学在学校中，踌躇满志，充满着抱负，心怀梦想，渴望成功。但进入到企业中之后，发现适应不了企业的工作节奏，也没有及时调整好自己的心态，就会进入一种压力、没动力的恶性循环中。&lt;/p&gt;
&lt;p&gt;所以为了避免这样恶性循环，作为一个刚毕业的程序员，最重要的是：认识自己，提升自己，提高自身的核心竞争力。&lt;/p&gt;

&lt;h2&gt;认识自己&lt;/h2&gt;
&lt;p&gt;我们都是成年人，自我认知应该是清晰的。那事情就简单了。&lt;/p&gt;
&lt;p&gt;将自己的不足和长处牢记在心，打个比方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;技术能力很差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沟通能力很差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写作能力很差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协作能力很差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习能力很强&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抗压能力比较强&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果对自己没有很清晰的认知，也很简单，就是不断去试错，不要担心会被训斥，试错是最好的方式，而且成本极低。&lt;/p&gt;

&lt;h2&gt;提升自己&lt;/h2&gt;
&lt;p&gt;第一步就是要定目标！目标该如何制定，举个例子：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我要提升打字速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我要在半年内，将打字速度提升到150字每分钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大家能感受到区别吗？很明显第2种更加的具体，而且有时间限制。所以目标不简简单单只是一句口号，而且能够成为具体的方向。一般指定目标需要满足SMART原则。&lt;/p&gt;
&lt;p&gt;目标不一定需要定的非常大，但必须是可以达到的。可以根据自己晋升规则给自己定一年的目标即可。也许我们都不知道10年后的自己是怎样的？但是你一定要明确自己明年要晋升，而且必须要晋升成功。&lt;/p&gt;

&lt;p&gt;第二步就是去干！自己定的目标一定要完成，严格要求自己。你对公司最大的价值就是你是无可替代的，否则就没有任何意义。&lt;/p&gt;
&lt;p&gt;提升自己的最好的办法就是不断增加自己的技能和知识。自己的能力提升了，升职加薪才会有，因为现在的你比之前更有价值了。&lt;/p&gt;
&lt;p&gt;可以去参加一些培训课程，如果是公司能够为你付费的话，那就更好了。例如：pmp项目管理。&lt;/p&gt;
&lt;p&gt;我2018年的时候，感觉自己的项目管理的水平已经达到了瓶颈，于是我就决定了去考pmp，我努力学习，最终通过了考试，拿到了证书。考试的费用公司也报销了。&lt;/p&gt;
&lt;p&gt;除了专业知识外，我们的知识边界可以拓宽，为之后可能胜任的管理岗位置，甚至更高的岗位位置做好准备。&lt;/p&gt;
&lt;p&gt;你也可以以博客、公众号的方式将自己的学到的东西和经验，进行总结，分享出来。这样不是更有价值吗。&lt;/p&gt;

&lt;p&gt;作为程序员你要认识到，互联网行业日新月异，不进则退。要么做得更好，要么就要被淘汰，勇敢的说加油，干！&lt;/p&gt;
&lt;p&gt;送一句话给大家“你手中握着你的价值，也握着迈向成功的潜能。我们有权选择成功，也有权选择平庸，没有任何人或任何事能强迫你，就看你如何去选择了。如果是别人握着决定你是否应该留下的决定权，那么你永远无法实现自己的价值”&lt;/p&gt;



&lt;p&gt;在公司众多竞争者当中，有比你代码写得优美的，有ppt比你写得好看的。这些都不是最重要的，承担更多责任才是制胜法宝。&lt;/p&gt;

&lt;p&gt;当领导抛出一个技术攻关，这时的你应该怎么做？不是躲在角落，唯恐不及，而是积极承担。你要抓住任何需要承担责任的机会。&lt;/p&gt;

&lt;p&gt;当然这种技术攻关，并不是经常有。那如何去挖掘这样的机会呢？有时候可以扩展的视野，主动积极去寻找一些机会。&lt;/p&gt;

&lt;p&gt;举一个例子：这个模块的性能是否有优化的空间，这个流程是否可以再精简点，这个测试工作是否可以自动化，等等。&lt;/p&gt;

&lt;p&gt;只要用心总是能找到可以发挥的机会的。在这里给大家提供几个思路：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可以从涉足人少的领域入手，涉足人少说明很冷门，也说明这里存在没人愿意碰，或者是容易被人遗漏。比如：日志模块，这个是很稳定的模块，如果你能发挥自己聪明才智，将这个模块的使用更加便捷，完善。你就实现了自己的价值了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;往往流程规范上也是一个角度，在小公司中，往往存在流程规范缺失，无规范约束的情况。这就是漏洞，你可以主动承担起流程建设的责任。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;主动帮助新人，既可以学到更多的专业知识，同时帮助了新人，使其能够成长，随着时间的推移，你在团队中的形象也就高大了起来，说不定会有“技术大牛”的称号，这种声音迟早会传到你的领导的耳朵里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;一个猎人在高山之巅的鹰巢里，捡到了一颗鹰卵，于是猎人把它带回了家。他把鹰卵放在鸡窝里，让老母鸡把它孵化出来。于是过了不久，这只幼鹰啄破了蛋壳出生了。小鹰和小鸡一起啄食、嬉闹和休息。它始终以为自己是一只鸡。这只鹰渐渐长大，羽翼丰满了，主人知道自己找到是一只雄鹰，想把它训练成真正的猎鹰，可是由于终日和鸡混在一起，它已经变得和鸡完全一样，根本没有飞的愿望了。主人试了各种办法，都毫无效果。最后主人把它带到山顶上，一把将它扔了出去。这只鹰像块石头似的，直掉下去，慌乱之中它拼命地扑打翅膀，终于它发现他可以飞起来了，它可以飞翔在九天流云之上！&lt;/p&gt;

&lt;p&gt;这是一则小故事告诉我们，每个人都渴望成功，每个人都希望实现自己的梦想，不要总是认为自己就是栖息于屋檐下的麻雀，你应该勇敢而自信地告诉自己：我就是高飞的雄鹰。只有这样的激励，才可以使自己对于未来充满信心，也才能让自己做得更好。&lt;/p&gt;

&lt;p&gt;在平时工作中，总是会发现有人会说这个问题太难了，这个方法应该不对，这个设计方案太复杂了。我相信大家应该见过很多这样的人，说不定你自己就是这样的。他们就是上面故事描述的栖息于屋檐下的麻雀，对自己缺乏自信，千万不要和他们同流合污。&lt;/p&gt;

&lt;p&gt;我们要展现出自己的价值，就要成为那个永远能够为团队解决疑难问题，提供解决方案的人，要突破壁垒，努力的成为用勇于承担这些困难责任的人。&lt;/p&gt;

&lt;p&gt;如果你能解决别人无法解决或不愿解决的问题，无论在哪家公司，你都能轻而易举地成为最有价值的人。&lt;/p&gt;



&lt;p&gt;从提升自我价值、承担责任、最后到突破壁垒，循序渐进，不断的修炼自己。不能成为公司不可替代的人，那就成为公司中最有价值的人。&lt;/p&gt;

&lt;p&gt;如果上诉三点要求，你都完美的完成，却还是没有得到任何晋升的机会，那应该怎么办呢？离职吧。&lt;/p&gt;

&lt;p&gt;END&lt;/p&gt;

&lt;p&gt;觉得不错，记得关注、转发和在看！多年经验分享，实属不易，感谢支持！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;博主是一位物联网大厂技术总监，从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！有问题可以加我微信交流：pointersss&lt;/p&gt;

&lt;p&gt;长按关注我！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3986335aa0a5a37520c1d7033744f81f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Oct 2020 00:43:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>从我认识的程序员中，包括我的团队中，有不少很久都没有晋升过。他们维护着已经再熟悉不过的模块，能迅速定位bug所在代码行数，在他们当中有部分人热爱coding，享受debug带来的成就感，但是绝大部分的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/13894701.html</dc:identifier>
</item>
<item>
<title>MYSQL 那些事 - 从零开始的DBA生活</title>
<link>http://www.cnblogs.com/start-from-zero/p/13893657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start-from-zero/p/13893657.html</guid>
<description>&lt;div readability=&quot;70&quot;&gt;
&lt;p&gt;&lt;code&gt;1.先通过引擎找到对应的行数据，并加锁&lt;/code&gt;&lt;br/&gt;&lt;code&gt;2.对行数据进行修改并调用引擎接口修改这条数据，然后释放锁(此时并没有把数据在磁盘上做出修改)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;3.redo log在内存中生成这条update的日志，通过innodb_flush_log_trx_commit 参数判断是否flush（持久化到磁盘）,并告知mysql执行器完成操作&lt;/code&gt;&lt;br/&gt;&lt;code&gt;4.执行器生成binlog并持久化到磁盘&lt;/code&gt;&lt;br/&gt;&lt;code&gt;5.执行器调用引擎提交事务接口，redo log状态变为commit状态完成整个更新操作。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;6.InnoDB使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入， 使得数据写入更顺序，以提高效率。（数据真正落盘，）&lt;/p&gt;


&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;Mysql分配给redoLog固定大小区域记录日志，一般为4个文件，该日志采用循环写从头写到尾然后在从头，同时还有一个记录擦除日志位置的标记checkpoint。当写入点和checkpoint在同一个位置，则停止写日志。又Innodb引擎实现&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;首先确定redo log在写入的时经过redo log buffer、FSPage cache、hard disk&lt;br/&gt;&lt;code&gt;redo log buffer：物理上是Mysql进程内存&lt;/code&gt;&lt;br/&gt;&lt;code&gt;FSPage cache：写入磁盘但没有持久化，物理上是在文件系统page cache中&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hard disk 持久化到磁盘&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Mysql在记录redo log的时候会先将数据写入到内存中，然后通过flush将内存中的数据写入磁盘中。在此期间会产生脏数据页导致内存和磁盘的数据不一致。&lt;/p&gt;
&lt;p&gt;这时候mysql就需要刷脏数据页。即是第一点的第六小点的动作：使用一个后台线程智能地刷新这些变更到数据文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.当记录redo log的内存满了，会停止写入redo log操作，然后进行刷脏页工作&lt;/code&gt;&lt;br/&gt;&lt;code&gt;2.写入日志太多，发现分配的内存不够，这时候需要淘汰一部分数据页，坐刷脏页工作&lt;/code&gt;&lt;br/&gt;&lt;code&gt;3.mysql空闲时会进行刷脏页工作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;p&gt;在flush过程中如果存在读入的数据页没有内存的时候，需要到缓冲池中申请数据页。当数据页不足首先将最久不使用的数据从内存中淘汰，如果是脏数据页还得先进行刷盘才能复用。&lt;/p&gt;
&lt;div readability=&quot;75&quot;&gt;
&lt;p&gt;&lt;strong&gt;InnoDB刷盘影响因素：&lt;/strong&gt;脏页的比重（InnoDB_max_dirty_pages_pct控制）、redo log写盘速度 以及 INNODB_IO_CAPACITY参数控制mysql 的IOPS&lt;/p&gt;



&lt;p&gt;1.缩短数据库的恢复时间；&lt;/p&gt;
&lt;p&gt;2.缓冲池不够用时，将脏页刷新到磁盘；&lt;/p&gt;
&lt;p&gt;3.重做日志不可用时，刷新脏页。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。数据库只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;写入日志太多，发现分配的内存不够，这时候需要停止redo log写入然后淘汰一部分数据页，做刷脏页操作，然后移动checkpoint 位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;checkpoint 分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sharp Checkpoint&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Sharp Checkpoint 发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数innodb_fast_shutdown=1&lt;/p&gt;
&lt;p&gt;但是若数据库在运行时也使用Sharp Checkpoint，那么数据库的可用性就会受到很大的影响。故在InnoDB存储引擎内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Fuzzy Checkpoint&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、Master Thread Checkpoint&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘，这个过程是异步的，此时InnoDB存储引擎可以进行其他的操作，用户查询线程不会阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、FLUSH_LRU_LIST Checkpoint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为InnoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。在InnoDB1.1.x版本之前，需要检查LRU列表中是否有足够的可用空间操作发生在用户查询线程中，显然这会阻塞用户的查询操作。倘若没有100个可用空闲页，那么InnoDB存储引擎会将LRU列表尾端的页移除。如果这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU列表的，因此称为FLUSH_LRU_LIST Checkpoint。&lt;/p&gt;
&lt;p&gt;而从MySQL 5.6版本，也就是InnoDB1.2.x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行，并且用户可以通过参数innodb_lru_scan_depth控制LRU列表中可用页的数量，该值默认为1024，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot; readability=&quot;32.5&quot;&gt;
&lt;div id=&quot;highlighter_640518&quot; class=&quot;syntaxhighlighter bash&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;+-----------------------+-------+&lt;br/&gt;| Variable_name | Value |&lt;br/&gt;+-----------------------+-------+&lt;br/&gt;| innodb_lru_scan_depth | 1024 |&lt;/p&gt;
&lt;p&gt;+-----------------------+-------+&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Fuzzy Checkpoint&lt;/strong&gt;生命周期如下：Innodb每次取最老的modified page(last checkpoint)对应的LSN，再将此脏页的LSN作为Checkpoint点记录到日志文件，意思就是“此LSN之前的LSN对应的日志和数据都已经flush到redo log。&lt;/p&gt;
&lt;p&gt;当mysql crash的时候，Innodb扫描redo log，从last checkpoint开始apply redo log到磁盘，直到last checkpoint对应的LSN等于Log flushed up to对应的LSN，则恢复完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835746/202010/1835746-20201028085352981-322259147.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Log sequence number（LSN1）：当前系统LSN最大值，新的事务日志LSN将在此基础上生成（LSN1+新日志的大小）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Log flushed up to（LSN2）：当前已经写入日志文件的LSN；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Oldest modified data log（LSN3）：当前最旧的脏页数据对应的LSN，写Checkpoint的时候直接将此LSN写入到日志文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Last checkpoint at（LSN4）：当前已经写入Checkpoint的LSN；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上图所示，Innodb的一条事务日志共经历4个阶段：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建阶段：事务创建一条日志；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;日志刷盘：日志写入到磁盘上的日志文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据刷盘：日志对应的脏页数据写入到磁盘上的数据文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;写CKP：日志被当作Checkpoint写入日志文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、Async/Sync Flush Checkpoint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。若将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则可定义：&lt;/p&gt;
&lt;p&gt;checkpoint_age = redo_lsn - checkpoint_lsn&lt;/p&gt;

&lt;p&gt;再定义以下的变量：&lt;/p&gt;
&lt;p&gt;async_water_mark = 75% * total_redo_log_file_size&lt;/p&gt;
&lt;p&gt;sync_water_mark = 90% * total_redo_log_file_size&lt;/p&gt;
&lt;p&gt;若每个重做日志文件的大小为1GB，并且定义了两个重做日志文件，则重做日志文件的总大小为2GB。那么async_water_mark=1.5GB，sync_water_mark=1.8GB。则：&lt;/p&gt;
&lt;p&gt;当checkpoint_age&amp;lt;async_water_mark时，不需要刷新任何脏页到磁盘；&lt;/p&gt;
&lt;p&gt;当async_water_mark&amp;lt;checkpoint_age&amp;lt;sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age&amp;lt;async_water_mark；&lt;/p&gt;
&lt;p&gt;checkpoint_age&amp;gt;sync_water_mark这种情况一般很少发生，除非设置的重做日志文件太小，并且在进行类似LOAD DATA的BULK INSERT操作。此时触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age&amp;lt;async_water_mark&lt;/p&gt;
&lt;/div&gt;
可见，Async/Sync Flush Checkpoint是为了保证重做日志的循环使用的可用性。在InnoDB 1.2.x版本之前，Async Flush Checkpoint会阻塞发现问题的用户查询线程，而Sync Flush Checkpoint会阻塞所有的用户查询线程，并且等待脏页刷新完成。从InnoDB 1.2.x版本开始——也就是MySQL 5.6版本，这部分的刷新操作同样放入到了单独的Page Cleaner Thread中，故不会阻塞用户查询线程&lt;/div&gt;




&lt;p&gt;&lt;strong&gt;WAL机制(Write-Ahead-Logging),主要讲了数据在操作的时候先进行写日志，然后再将数据写入磁盘的过程&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;10.5&quot;&gt;

&lt;p&gt;称为归档日志，是追加写不会覆盖之前的日志。binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;执行事务过程，先将日志写入binlog cache，事务提交时再将cache写入到binlog中。对于cache系统会分配一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。超过这个参数则暂存在磁盘中。&lt;br/&gt;事务提交时，执行器将binlog cache完整事务写入binlog中，并清空binlog cache。&lt;br/&gt;整个写入过程分为两步 write和fsync&lt;br/&gt;&lt;code&gt;write：指把日志写入到文件系统page cache，并没有写入磁盘中，速度快&lt;/code&gt;&lt;br/&gt;&lt;code&gt;fsync：将数据持久化到磁盘，该过程占用磁盘IOPS。&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;1.Storage Engine（InnoDB） transaction prepare阶段：存储引擎的准备阶段,写redo-buffer然后根据参数罗盘redo log&lt;br/&gt;2.Binary log日志提交：写binlog并落盘.&lt;br/&gt;3.Storage Engine（InnoDB）内部提交把事务状态标记为已提交&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835746/202010/1835746-20201026202613083-2082157419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;如果数据库异常后宕机重启后会通过Crash recovery来恢复&lt;/p&gt;
&lt;p&gt;sync_binlog=1 和  innoDB_flush_log_at_trx_commit = 1 称之为双1&lt;/p&gt;
&lt;p&gt;双1模式可以保证提交后的事务不会丢失，即crash-safe。&lt;/p&gt;
&lt;p&gt;在做Crash recovery时：分为以下3种情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;binlog有记录，redolog状态commit：正常完成的事务，不需要恢复；&lt;/li&gt;
&lt;li&gt;binlog有记录，redolog状态prepare：在binlog写完提交事务之前的crash，恢复操作：提交事务。（因为之前没有提交）&lt;/li&gt;
&lt;li&gt;binlog无记录，redolog状态prepare：在binlog写完之前的crash，恢复操作：回滚事务（因为crash时并没有成功写入数据库）&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;mysql 5.7开始默认开启组提交。&lt;/p&gt;
&lt;p&gt;1. 要保证顺序必须是提交加入到队列的顺序（binlog_order_commits保证）。&lt;/p&gt;
&lt;p&gt;2. 如果有新的事务提交，此时队列为空，则可以加入到FLUSH队列中。不过，因为此时FLUSH临界区正在被占用，所以新事务组必须要等待。&lt;/p&gt;
&lt;p&gt;3. 给每个事务分配sequence_number，如果是第一个事务，则将这个组的last_committed设置为sequence_number-1.&lt;/p&gt;
&lt;p&gt;4. 将带着last_committed与sequence_number的GTID事件FLUSH到Binlog文件中。&lt;/p&gt;
&lt;p&gt;5. 将当前事务所产生的Binlog内容FLUSH到Binlog文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组提交之redo log&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个同时处于prepare阶段的事务生成各自的redo log 会一起刷盘。假设2WTPS，并不需要4W次刷盘。也会在binlog中生成相同的last_commited（表示事务提交的时候，上次事务提交的编号）.这些事务称之为1个事务组。&lt;/p&gt;
&lt;p&gt;其实每一个组的last_committed值，都是上一个组中事务的sequence_number最大值，也是本组中事务sequence_number最小值减1。同时这两个值的有效作用域都在文件内，只要换一个文件（flush binary logs），这两个值就都会从0开始计数。上述的last_committed和sequence_number代表的就是所谓的LOGICAL_CLOCK&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组提交之binlog&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了增加一组事务中的事务数量，提高刷盘收益，MySQL使用两个参数控制获取队列事务组的时机：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;   binlog_group_commit_sync_delay=N：在等待N μs后，开始事务刷盘(图中Sync binlog)&lt;/p&gt;
&lt;p&gt;   binlog_group_commit_sync_no_delay_count=N：如果队列中的事务数达到N个，就忽视binlog_group_commit_sync_delay的设置，直接开始刷盘(图中Sync binlog)&lt;/p&gt;
&lt;p&gt;组提交可以有效减低iops。 尽管上面两个参数都关闭，也会开启组提交。因为redo log组提交不由这两个参数控制。&lt;/p&gt;



&lt;p&gt;MySQL 5.7的并行复制基于一个前提，即所有已经处于prepare阶段的事务，都是可以并行提交的。这些当然也可以在从库中并行提交，因为处理这个阶段的事务，都是没有冲突的，该获取的资源都已经获取了。反过来说，如果有冲突，则后来的会等已经获取资源的事务完成之后才能继续，故而不会进入prepare阶段。&lt;/p&gt;
&lt;p&gt;一个组提交（group commit）的事务都是可以并行回放，因为这些事务都已进入到事务的prepare阶段，则说明事务之间没有任何冲突（否则就不可能提交）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binlog_order_commits会影响提交行为。如果设置为ON，那么此时提交就变为串行操作了，就以队列的顺序为提交顺序。而这也是LOGICAL_CLOCK并行复制的基础。因为order commit使得所有的事务分了组，并且有了序列号，从库拿到这些信息之后，就可以根据序号放心大胆地做分发了。&lt;/li&gt;
&lt;li&gt;slave_parallel_workers  从库并行复制得线程数&lt;/li&gt;
&lt;li&gt;slave_parallel_type： logical_clock 表示以事务组提交的方式并行复制。database 表示以不同database的方式并行复制&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 28 Oct 2020 23:38:00 +0000</pubDate>
<dc:creator>从零开始的DBA生活</dc:creator>
<og:description>1.一条update语句 1.先通过引擎找到对应的行数据，并加锁 2.对行数据进行修改并调用引擎接口修改这条数据，然后释放锁(此时并没有把数据在磁盘上做出修改) 3.redo log在内存中生成这条u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/start-from-zero/p/13893657.html</dc:identifier>
</item>
<item>
<title>【15】进大厂必须掌握的面试题-容器化和虚拟化面试 - Java架构师社区</title>
<link>http://www.cnblogs.com/mush/p/13894576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mush/p/13894576.html</guid>
<description>&lt;h3 id=&quot;q1。什么是容器？&quot;&gt;&lt;strong&gt;Q1。什么是容器？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我的建议是首先解释对容器化的需求，容器用于提供一致的计算环境，从开发人员的笔记本电脑到测试环境，从过渡环境到生产环境。&lt;br/&gt;现在给出容器的定义，一个容器包含一个完整的运行时环境：一个应用程序，及其所有依赖项，库和其他二进制文件，以及运行该文件所需的配置文件，这些文件捆绑在一个程序包中。容器化应用程序平台及其依赖项可消除OS分布和基础架构中的差异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2169955/202010/2169955-20201029072052372-349826661.png&quot; alt=&quot;容器-devops面试问题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;q2。与虚拟化相比，容器化提供了哪些优势？&quot;&gt;&lt;strong&gt;Q2。与虚拟化相比，容器化提供了哪些优势？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以下是容器化相对于虚拟化的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容器提供实时配置和可伸缩性，但虚拟机提供缓慢的配置&lt;/li&gt;
&lt;li&gt;与虚拟机相比，容器轻巧&lt;/li&gt;
&lt;li&gt;与容器相比，VM的性能有限&lt;/li&gt;
&lt;li&gt;与VM相比，容器具有更好的资源利用率&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;q3。容器（在我们的例子中为docker）与虚拟机管理程序虚拟化（vsphere）有何不同？有什么好处？&quot;&gt;&lt;strong&gt;Q3。容器（在我们的例子中为Docker）与虚拟机管理程序虚拟化（vSphere）有何不同？有什么好处？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;下面给出一些区别。确保在回答中包括以下差异：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2169955/202010/2169955-20201029072052715-494794916.png&quot; alt=&quot;docker vsphere-devops面试问题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;q4。什么是docker映像？&quot;&gt;&lt;strong&gt;Q4。什么是Docker映像？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Docker映像是Docker容器的来源。换句话说，Docker映像用于创建容器。图像是使用build命令创建的，开始运行时它们会产生一个容器。图像存储在Docker注册表中，例如registry.hub.docker.com，因为它们可能会变得很大，图像被设计为由其他图像层组成，从而在通过网络传输图像时仅发送少量数据。&lt;/p&gt;
&lt;h3 id=&quot;q5。什么是docker容器？&quot;&gt;&lt;strong&gt;Q5。什么是Docker容器？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这是一个非常重要的问题，因此请确保您不偏离本主题。我建议您遵循以下格式：&lt;br/&gt;Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核，并在主机操作系统上的用户空间中作为隔离的进程运行。Docker容器不依赖于任何特定的基础架构：它们可以在任何计算机，任何基础架构和任何云中运行。&lt;br/&gt;现在说明如何创建Docker容器。可以通过创建Docker映像然后运行它来创建Docker容器，也可以使用Dockerhub上存在的Docker映像。&lt;br/&gt;Docker容器基本上是Docker映像的运行时实例。&lt;/p&gt;
&lt;h3 id=&quot;q6。什么是docker-hub？&quot;&gt;&lt;strong&gt;Q6。&lt;/strong&gt;什么是Docker Hub？&lt;/h3&gt;
&lt;p&gt;这个问题的答案很直接。Docker Hub是一项基于云的注册表服务，可让您链接到代码存储库，构建映像并对其进行测试，存储手动推送的映像以及与Docker云的链接，以便您可以将映像部署到主机。它为整个开发流程中的容器映像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中式资源。&lt;/p&gt;
&lt;h3 id=&quot;q7。-docker与其他容器技术有何不同？&quot;&gt;&lt;strong&gt;Q7。&lt;/strong&gt; &lt;strong&gt;Docker与其他容器技术有何不同？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据我的说法，您的答案应该&lt;br/&gt;包含以下几点：Docker容器易于部署在云中。与其他技术相比，它可以使更多的应用程序在同一硬件上运行，这使开发人员可以轻松快速地创建可立即运行的容器化应用程序，并使管理和部署应用程序更加容易。您甚至可以与应用程序共享容器。&lt;br/&gt;如果您还有其他要点，可以这样做，但请确保您的答案中有上面的解释。&lt;/p&gt;
&lt;h3 id=&quot;q8。-什么是docker-swarm？&quot;&gt;&lt;strong&gt;Q8。&lt;/strong&gt; &lt;strong&gt;什么是Docker Swarm？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;您应该通过解释Docker Swarn开始这个答案。它是Docker的本机集群，可将Docker主机池转换为单个虚拟Docker主机。Docker Swarm提供了标准的Docker API，任何已经与Docker守护程序通信的工具都可以使用Swarm透明地扩展到多个主机。&lt;br/&gt;我还将建议您包括一些受支持的工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;独库&lt;/li&gt;
&lt;li&gt;Docker撰写&lt;/li&gt;
&lt;li&gt;Docker机器&lt;/li&gt;
&lt;li&gt;jenkins&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;q9。dockerfile的作用是什么？&quot;&gt;&lt;strong&gt;Q9。Dockerfile的作用是什么？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据我的回答，应该从解释Dockerfile的使用开始。Docker可以通过阅读Dockerfile中的指令来自动构建映像。&lt;br/&gt;现在，我建议您给Dockerfle一个小定义。Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以组装映像的所有命令。使用docker build的用户可以创建自动执行的构建，该构建可以连续执行多个命令行指令。&lt;/p&gt;
&lt;h3 id=&quot;q10。-我可以在docker中的撰写文件中使用json而不是yaml吗？&quot;&gt;&lt;strong&gt;Q10。&lt;/strong&gt; &lt;strong&gt;我可以在Docker中的撰写文件中使用json而不是yaml吗？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;您可以将json而不是yaml用于撰写文件，以将json文件与compose一起使用，指定要使用的文件名，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;docker-compose -f docker-compose.json up
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;&quot;/&gt;
&lt;h3 id=&quot;q11。-告诉我们您过去使用docker的方式吗？&quot;&gt;&lt;strong&gt;Q11。&lt;/strong&gt; &lt;strong&gt;告诉我们您过去使用Docker的方式吗？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;说明您如何使用Docker来帮助快速部署。说明您如何编写Docker脚本并将Docker与其他工具（如Puppet，Chef或Jenkins）一起使用。如果您以前没有使用过Docker的实践经验，也没有使用过类似领域其他工具的经验，请诚实并进行相同的解释。在这种情况下，就功能而言，是否可以将其他工具与Docker进行比较是有意义的。&lt;/p&gt;
&lt;h3 id=&quot;q12。如何创建docker容器？&quot;&gt;&lt;strong&gt;Q12。如何创建Docker容器？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我建议您直接回答。我们可以通过以下命令使用Docker映像创建Docker容器：&lt;br/&gt;**docker run -t -i &amp;lt;映像名称&amp;gt; &amp;lt;命令名称&amp;gt;&lt;/p&gt;
&lt;p&gt;**此命令将创建并启动容器。&lt;br/&gt;您还应该添加，如果要检查主机上所有运行容器的列表以及状态，请使用以下命令：&lt;br/&gt;&lt;strong&gt;docker ps -a&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;q13。如何停止并重新启动docker容器？&quot;&gt;&lt;strong&gt;Q13。如何停止并重新启动Docker容器？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了停止Docker容器，您可以使用以下命令：&lt;br/&gt;&lt;strong&gt;docker stop &amp;lt;容器ID&amp;gt;&lt;/strong&gt;&lt;br/&gt;现在要重新启动Docker容器，您可以使用：&lt;br/&gt;&lt;strong&gt;docker restart &amp;lt;容器ID&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;q14。docker容器可扩展到多远？&quot;&gt;Q14。Docker容器可扩展到多远？&lt;/h3&gt;
&lt;p&gt;诸如Google和Twitter之类的大型Web部署以及诸如Heroku和dotCloud之类的平台提供商都基于容器技术运行，并行运行的容器数以十万甚至数百万计。&lt;/p&gt;
&lt;h3 id=&quot;q15。docker在什么平台上运行？&quot;&gt;Q15。Docker在什么平台上运行？&lt;/h3&gt;
&lt;p&gt;首先，我将说Docker仅在Linux和Cloud平台上运行，然后再提及以下Linux供应商：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ubuntu 12.04、13.04等&lt;/li&gt;
&lt;li&gt;Fedora 19/20 +&lt;/li&gt;
&lt;li&gt;RHEL 6.5+&lt;/li&gt;
&lt;li&gt;CentOS 6以上&lt;/li&gt;
&lt;li&gt;Gentoo&lt;/li&gt;
&lt;li&gt;ArchLinux&lt;/li&gt;
&lt;li&gt;openSUSE 12.3+&lt;/li&gt;
&lt;li&gt;CRUX 3.0+&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;云：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Amazon EC2&lt;/li&gt;
&lt;li&gt;Google Compute Engine&lt;/li&gt;
&lt;li&gt;Microsoft Azure&lt;/li&gt;
&lt;li&gt;Rackspace&lt;/li&gt;
&lt;li&gt;Alibaba&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;q16。docker容器退出时是否会丢失数据？&quot;&gt;&lt;strong&gt;Q16。Docker容器退出时是否会丢失数据？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;您可以这样说：不，当Dcoker容器退出时，不会丢失数据。应用程序写入磁盘的所有数据都会保留在其容器中，直到您明确删除该容器为止。即使在容器停止后，该容器的文件系统仍然存在。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4905660377358&quot;&gt;
&lt;p&gt;欢迎关注 &lt;a href=&quot;http://javajgs.com/&quot;&gt;Java架构师社区&lt;/a&gt;公众号.&lt;br/&gt;本文转载自&lt;a href=&quot;http://javajgs.com/archives/6702&quot;&gt;Java架构师必看&lt;/a&gt; ,更多内容点击查看！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 28 Oct 2020 23:21:00 +0000</pubDate>
<dc:creator>Java架构师社区</dc:creator>
<og:description>Q1。什么是容器？ 我的建议是首先解释对容器化的需求，容器用于提供一致的计算环境，从开发人员的笔记本电脑到测试环境，从过渡环境到生产环境。 现在给出容器的定义，一个容器包含一个完整的运行时环境：一个应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mush/p/13894576.html</dc:identifier>
</item>
<item>
<title>晚间测试13 A. Dove 打扑克 vector +模拟 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13894552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13894552.html</guid>
<description>&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202010/1996139-20201029061625410-1939884434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202010/1996139-20201029061617270-1477335978.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题比较关键的一点就是要看出最终牌数的种类数不会超过 &lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt; 种&lt;br/&gt;知道了这个性质我们就可以用 &lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 维护一个有序的序列&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 中存放牌数的大小和有多少堆这样的牌&lt;br/&gt;每次二分插入和删除即可&lt;br/&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(m\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e6+5;
int n,m,tp,siz[maxn],sum[maxn],fa[maxn],sta[maxn];
int zhao(int xx){
        if(xx==fa[xx]) return xx;
        return fa[xx]=zhao(fa[xx]);
}
struct jie{
        int val,cnt;
        jie(){}
        jie(int aa,int bb){
                val=aa,cnt=bb;
        }
};
std::vector&amp;lt;jie&amp;gt; g;
int ef(int val){
        rg int l=1,r=g.size(),mids;
        while(l&amp;lt;=r){
                mids=(l+r)&amp;gt;&amp;gt;1;
                if(g[mids-1].val&amp;gt;=val) r=mids-1;
                else l=mids+1;
        }
        return l-1;
}
int main(){
        n=read(),m=read();
        for(rg int i=1;i&amp;lt;=n;i++){
                siz[i]=1;
                fa[i]=i;
        }
        g.insert(g.begin(),jie(1,n));
        rg int aa,bb,cc,dd,ee,ff;
        rg long long ans=0;
        for(rg int i=1;i&amp;lt;=m;i++){
                aa=read();
                if(aa==1){
                        bb=read(),cc=read();
                        dd=zhao(bb),ee=zhao(cc);
                        if(dd==ee) continue;
                        ff=ef(siz[dd]);
                        g[ff].cnt--;
                        if(g[ff].cnt==0) g.erase(g.begin()+ff);
                        ff=ef(siz[ee]);
                        g[ff].cnt--;
                        if(g[ff].cnt==0) g.erase(g.begin()+ff);
                        siz[dd]+=siz[ee];
                        siz[ee]=0;
                        if(g[g.size()-1].val&amp;lt;siz[dd]){
                                g.push_back(jie(siz[dd],1));
                        } else {
                                ff=ef(siz[dd]);
                                if(g[ff].val==siz[dd]) g[ff].cnt++;
                                else g.insert(g.begin()+ff,jie(siz[dd],1));
                        }
                        fa[ee]=dd;
                } else {
                        bb=read();
                        ans=0;
                        tp=g.size();
                        for(rg int j=1;j&amp;lt;=tp;j++){
                                sum[j]=sum[j-1]+g[j-1].cnt;
                                sta[j]=g[j-1].val;
                        }
                        if(bb==0){
                                ans+=1LL*(sum[tp]-1)*sum[tp]/2LL;
                        } else {
                                ee=1,ff=1;
                                while(ee&amp;lt;=tp){
                                        while(sta[ff]-sta[ee]&amp;lt;bb &amp;amp;&amp;amp; ff&amp;lt;=tp) ff++;
                                        if(sta[ff]-sta[ee]&amp;lt;bb || ff&amp;gt;tp) break;
                                        ans+=1LL*(sum[ee]-sum[ee-1])*(sum[tp]-sum[ff-1]);
                                        ee++;
                                }
                        }
                        printf(&quot;%lld\n&quot;,ans);
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 28 Oct 2020 22:21:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>题目描述 分析 这道题比较关键的一点就是要看出最终牌数的种类数不会超过 \(\sqrt{n}\) 种 知道了这个性质我们就可以用 \(vector\) 维护一个有序的序列 \(vector\) 中存放</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13894552.html</dc:identifier>
</item>
<item>
<title>C#基础访问修饰符概述 - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/13894517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/13894517.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在编写面向对象语言时我们时长离不开相关类型和成员的相关访问性，而访问性的关键则是取决于访问修饰符的声明，其作用是用于指定类型或成员的可访问性。&lt;/p&gt;
&lt;h2&gt;访问修饰符的六种可访问性级别：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;public：共有的，访问不受限制；&lt;/li&gt;
&lt;li&gt;private：私有的，只能在当前类中访问；&lt;/li&gt;
&lt;li&gt;internal：内部的，只能在当前程序集中访问；&lt;/li&gt;
&lt;li&gt;protected：受保护的，只能在当前类或其派生类中访问；&lt;/li&gt;
&lt;li&gt;protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；&lt;/li&gt;
&lt;li&gt;private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;其他类型的成员和嵌套类型的可访问性：&lt;/h2&gt;
&lt;table class=&quot;table&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span data-ttu-id=&quot;367b7-122&quot;&gt;成员&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span data-ttu-id=&quot;367b7-123&quot;&gt;默认成员可访问性&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span data-ttu-id=&quot;367b7-124&quot;&gt;允许的成员的声明的可访问性&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;enum（枚举）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span data-ttu-id=&quot;367b7-125&quot;&gt;无&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;class（类）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;p&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;internal&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;private&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;protected internal&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;private protected&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;interface（接口）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span data-ttu-id=&quot;367b7-126&quot;&gt;无&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;struct（结构）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;p&gt;&lt;code&gt;internal&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;private&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 28 Oct 2020 18:06:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 在编写面向对象语言时我们时长离不开相关类型和成员的相关访问性，而访问性的关键则是取决于访问修饰符的声明，其作用是用于指定类型或成员的可访问性。 访问修饰符的六种可访问性级别： public：共</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/13894517.html</dc:identifier>
</item>
<item>
<title>Java安全之安全加密算法 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/13894507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/13894507.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;本篇文来谈谈关于常见的一些加密算法，其实在此之前，对算法的了解并不是太多。了解的层次只是基于加密算法的一些应用上。也来浅谈一下加密算法在安全领域中的作用。写本篇文也是基于算法的应用和实现，也是我的基本原则，能用就行。&lt;/p&gt;
&lt;h2 id=&quot;0x01-算法体制&quot;&gt;0x01 算法体制&lt;/h2&gt;
&lt;p&gt;在加密算法里面大致分为四大类：对称加密算法、非对称加密算法、散列函数、组合加密。&lt;/p&gt;
&lt;p&gt;对称加密：指的是加密的密钥和解密的密钥相同。&lt;/p&gt;
&lt;p&gt;非对称加密：指的是加密的密钥和加密的密钥不同。分为公钥和私钥。&lt;/p&gt;
&lt;p&gt;散列函数：主要用于验证数据的完整性，长度不受限制，hash值容易计算，散列运算过程不可逆如：MD5、SHA&lt;/p&gt;
&lt;h2 id=&quot;0x02-散列算法&quot;&gt;0x02 散列算法&lt;/h2&gt;
&lt;p&gt;Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。&lt;/p&gt;
&lt;h3 id=&quot;md5&quot;&gt;MD5&lt;/h3&gt;
&lt;p&gt;md5的运用范围也比较广，比如在一些数据库存储密码的时候会去使用到该算法去进行加密存储。当然也可以看到网上的一些md5破解的。但是他们都是基于彩虹表去跑，使用字典进行md5加密，然后把加密的值进行对比，从而判断该md5值的明文。&lt;/p&gt;
&lt;h4 id=&quot;代码实例：&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5demo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);//设置要返回的摘要算法对象
        byte[] digest = md5.digest(name.getBytes()); //计算hash值
        System.out.println(HexBin.encode(digest));//输出hash结果
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012500602-1424182850.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sha&quot;&gt;SHA&lt;/h3&gt;
&lt;p&gt;安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。&lt;/p&gt;
&lt;p&gt;SHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512&lt;/p&gt;
&lt;p&gt;下面是一张对照图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012522671-455942907.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实例：-2&quot;&gt;代码实例：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class jdksha1 {
    private static String name = &quot;xiaoming&quot;;

    public static void main(String[] args) throws NoSuchAlgorithmException {
        MessageDigest sha = MessageDigest.getInstance(&quot;SHA&quot;);
        byte[] digest = sha.digest(name.getBytes());
        System.out.println(HexBin.encode(digest));

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012533036-2056041601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-对称加密算法&quot;&gt;0x03 对称加密算法&lt;/h2&gt;
&lt;p&gt;对称加密算法，他的加解密密钥都是一样的。而对称加密的算法又分两大类，一种是每次对明文中的字节使用密钥进行加密，而第二种是对一组明文使用密钥进行加密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012542726-1715098483.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来看看分组加密的工作模式。&lt;/p&gt;
&lt;h4 id=&quot;分组加密的工作模式&quot;&gt;分组加密的工作模式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1. ECB：电子密码本（最常用的，每次加密均产生独立的密文分组，并且对其他的密文分组不会产生影响，也就是相同的明文加密后产生相同的密文）
2. CBC：密文链接（常用的，明文加密前需要先和前面的密文进行异或运算，也就是相同的明文加密后产生不同的密文）
除了这两种常用的工作模式，还有：
3. CFB：密文反馈
4. OFB：输出反馈
5. CTR：计数器
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分组密码填充方式&quot;&gt;分组密码填充方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1. NoPadding：无填充
2. PKCS5Padding：
3. ISO10126Padding
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的加密方式DES、3DES、AES。可以来对比一下，这几个算法的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012555057-1627206124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;base64&quot;&gt;BASE64&lt;/h3&gt;
&lt;p&gt;因为BASE64的加密解密算法是公开的，所以加密数据是没有任何安全性可言。先来看看API文档中提供的BASE64加密的类。除了在JDK中内置的也有一些第三方类会提供BASE64加密的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012605636-821921847.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012634299-991428367.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实例：-3&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

import java.io.IOException;

public class base64demo {
    public static void main(String[] args) throws IOException {
        String name = &quot;xiaoming&quot;;
        BASE64Encoder encoder = new BASE64Encoder//实例化BASE64Encoder对象
        String encode = encoder.encode(name.getBytes());//调用encode进行加密
        System.out.println(encode);
        BASE64Decoder base64Decoder = new BASE64Decoder();//实例化BASE64Decoder对象
        byte[] bytes = base64Decoder.decodeBuffer(encode);//进行解密
        System.out.println(bytes);
        String s = new String(bytes);
        System.out.println(s);


    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012644999-2078759273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BASE64的加解密比较简单，在这里就不细说了。&lt;/p&gt;
&lt;h3 id=&quot;des&quot;&gt;DES&lt;/h3&gt;
&lt;p&gt;DES的算法其实已经被公开了，其实是不太安全的。&lt;/p&gt;
&lt;h4 id=&quot;代码实例：-4&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;

import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

public class desdemo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException, NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException {

        //1.生成密钥
        KeyGenerator des = KeyGenerator.getInstance(&quot;DES&quot;);//设置获取des的密钥
        des.init(56);//初始化密钥生成器，设置为56长度的密钥
        SecretKey secretKey = des.generateKey();//获取密钥
//        System.out.println(secretKey);
        byte[] deskey = secretKey.getEncoded(); //获取密钥的byte数组

        //2.密钥转换
        DESKeySpec desKeySpec = new DESKeySpec(deskey);
        SecretKeyFactory des1 = SecretKeyFactory.getInstance(&quot;DES&quot;);
        SecretKey secretKey1 = des1.generateSecret(desKeySpec);
//        System.out.println(secretKey1);

        //3.加密
        Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);//选择算法、工作模式和填充方式
        cipher.init(Cipher.ENCRYPT_MODE,secretKey1);//选择加密模式和密钥进行加密
        byte[] res = cipher.doFinal(name.getBytes());//加密数据
//        System.out.println(res);
//        String s = new String(res);
        System.out.println(HexBin.encode(res));//输出加密后结果

        //4.解密
        cipher.init(Cipher.DECRYPT_MODE,secretKey1);//选择密钥，并使用解密模式
        byte[] bytes = cipher.doFinal(res);//解密加密后的结果
        String s1 = new String(bytes);
        System.out.println(s1);

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012702065-128120240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3des&quot;&gt;3DES&lt;/h3&gt;
&lt;p&gt;3DES也被叫做DESede，也就是基于DES三次加密。其实也有四层和两层DES，但是平时中用的最多的还是3DES。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012711752-1336089810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图是他的一个算法的说明图。&lt;/p&gt;
&lt;p&gt;其实3DES和DES在代码中的实现方式很相似。但是要注意的一点是密钥长度要选择正确，否则会报错。或者是可以使用&lt;code&gt;SecureRandom()&lt;/code&gt;类，让他根据选择的加密算法使用默认的密钥长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012720765-1683694041.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实例：-5&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;

import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.DESedeKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;

public class jdk3des {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException, BadPaddingException, IllegalBlockSizeException {
//1.生成密钥
        KeyGenerator des = KeyGenerator.getInstance(&quot;DESede&quot;);//设置获取des的密钥
//        des.init(168);//初始化密钥生成器，设置为168长度的密钥
        des.init(new SecureRandom());//根据加密算法使用默认密钥长度
        SecretKey secretKey = des.generateKey();//获取密钥
//        System.out.println(secretKey);
        byte[] deskey = secretKey.getEncoded(); //获取密钥的byte数组

        //2.密钥转换
        DESedeKeySpec desKeySpec = new DESedeKeySpec(deskey);
        SecretKeyFactory des1 = SecretKeyFactory.getInstance(&quot;DESede&quot;);
        SecretKey secretKey1 = des1.generateSecret(desKeySpec);
//        System.out.println(secretKey1);

        //3.加密
        Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);//选择算法、工作模式和填充方式
        cipher.init(Cipher.ENCRYPT_MODE,secretKey1);//选择加密模式和密钥进行加密
        byte[] res = cipher.doFinal(name.getBytes());//加密数据
//        System.out.println(res);
//        String s = new String(res);
        System.out.println(HexBin.encode(res));//输出加密后结果

        //4.解密
        cipher.init(Cipher.DECRYPT_MODE,secretKey1);//选择密钥，并使用解密模式
        byte[] bytes = cipher.doFinal(res);//解密加密后的结果
        String s1 = new String(bytes);
        System.out.println(s1);

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;aes&quot;&gt;AES&lt;/h3&gt;
&lt;p&gt;AES是目前用的最多的对称加密算法，一般用于移动通讯系统加密或者是基于SSH协议的软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012749970-2078768787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实例：-6&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;
import com.sun.xml.internal.messaging.saaj.util.Base64;
import sun.misc.BASE64Encoder;

import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class aesdemo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        //1.获取密钥
        KeyGenerator aes = KeyGenerator.getInstance(&quot;AES&quot;);
        aes.init(128);
        SecretKey secretKey = aes.generateKey();
        byte[] encoded = secretKey.getEncoded();

        //2.密钥转换
        Key key = new SecretKeySpec(encoded, &quot;AES&quot;);

        //3.加密
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE,key);
        byte[] bytes = cipher.doFinal(name.getBytes());
        System.out.println(new BASE64Encoder().encode(bytes));//加密完成后，再使用base64进行加密


        //4.解密
        cipher.init(Cipher.DECRYPT_MODE,key);
        byte[] bytes1 = cipher.doFinal(bytes);
        System.out.println(new String(bytes1));
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来放一张基于AES加解密的流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012801518-2092407890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pbe&quot;&gt;PBE&lt;/h3&gt;
&lt;p&gt;PBE算法（Password Based Encryption，基于口令加密）是一种基于口令的加密算法，其特点是使用口令代替了密钥，而口令由用户自己掌管，采用随机数杂凑多重加密等方法保证数据的安全性。PBE算法在加密过程中并不是直接使用口令来加密，而是加密的密钥由口令生成，这个功能由PBE算法中的KDF函数完成。KDF函数的实现过程为：将用户输入的口令首先通过“盐”（salt）的扰乱产生准密钥，再将准密钥经过散列函数多次迭代后生成最终加密密钥，密钥生成后，PBE算法再选用对称加密算法对数据进行加密，可以选择DES、3DES、RC5等对称加密算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012811431-1257786791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上这张图是PBE算法的实现方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012819614-642462146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实例：-7&quot;&gt;代码实例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.xml.internal.messaging.saaj.util.Base64;
import sun.misc.BASE64Encoder;

import javax.crypto.*;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import java.security.*;
import java.security.spec.InvalidKeySpecException;

public class pbedemo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, BadPaddingException, IllegalBlockSizeException {

        //1.初始化盐
        SecureRandom secureRandom = new SecureRandom();
        byte[] salt = secureRandom.generateSeed(8);

        //2. 获取密钥

        String password = &quot;123456&quot;;
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBEWITHMD5andDES&quot;);
        Key key = factory.generateSecret(pbeKeySpec);
        //3.加密
        PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, 100);
        Cipher cipher = Cipher.getInstance(&quot;PBEWITHMD5andDES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE,key,pbeParameterSpec);
        byte[] bytes = cipher.doFinal(name.getBytes());
        System.out.println(new BASE64Encoder().encode(bytes));
        //4.解密

        cipher.init(Cipher.DECRYPT_MODE,key,pbeParameterSpec);
        byte[] res = cipher.doFinal(bytes);
        System.out.println(new String(res));

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012829877-1961932472.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-非对称加密算法&quot;&gt;0x04 非对称加密算法&lt;/h2&gt;
&lt;p&gt;非对称加密算法需要两个密钥：公钥和私钥。公钥]与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。&lt;/p&gt;
&lt;h3 id=&quot;dh&quot;&gt;DH&lt;/h3&gt;
&lt;p&gt;1976年非对称加密算法思想被提出，但是当时并没有给出具体算法和方案，因为当时没有研究出&lt;code&gt;单向函数&lt;/code&gt;（也就是信息摘要算法还没出现），但是IEEE的期刊中给出了通信时双方如何&lt;code&gt;通过信息交换协商密钥&lt;/code&gt;的算法，也就是DH算法，通过该算法双方可以协商对称加密的密钥。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;

import javax.crypto.*;
import javax.crypto.interfaces.DHPrivateKey;
import javax.crypto.interfaces.DHPublicKey;
import javax.crypto.spec.DHParameterSpec;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;

public class dhdemo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException, NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException {
//        1.初始化发送方密钥
        KeyPairGenerator sendKeyPairGenerator = KeyPairGenerator.getInstance(&quot;DH&quot;);
        sendKeyPairGenerator.initialize(512);
        KeyPair sendKeyPair = sendKeyPairGenerator.generateKeyPair();
        byte[] sendPublicKeyEnc = sendKeyPair.getPublic().getEncoded();//生成发送方公钥，发送给接收方（网络、文件...）

//        2.初始化接收方密钥：
        KeyFactory receiverKeyFactory = KeyFactory.getInstance(&quot;DH&quot;);
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(sendPublicKeyEnc);
        PublicKey receivePublicKey = receiverKeyFactory.generatePublic(x509EncodedKeySpec);
        DHParameterSpec dhParameterSpec = ((DHPublicKey)receivePublicKey).getParams();
        KeyPairGenerator receiverKeyPairGenerator = KeyPairGenerator.getInstance(&quot;DH&quot;);
        receiverKeyPairGenerator.initialize(dhParameterSpec);
        KeyPair receiverKeyPair = receiverKeyPairGenerator.generateKeyPair();
        PrivateKey receiverPrivateKey = receiverKeyPair.getPrivate();
        byte[] receiverPublicKeyEnc = receiverKeyPair.getPublic().getEncoded();

//        3.构建接收方密钥：
        KeyAgreement receiverKeyAgreement = KeyAgreement.getInstance(&quot;DH&quot;);
        receiverKeyAgreement.init(receiverPrivateKey);
        receiverKeyAgreement.doPhase(receivePublicKey, true);

        SecretKey receiverDESKey = receiverKeyAgreement.generateSecret(&quot;DES&quot;);//接收方Key
//        4.构建发送方密钥：
        KeyFactory sendKeyFactory = KeyFactory.getInstance(&quot;DH&quot;);
        x509EncodedKeySpec = new X509EncodedKeySpec(receiverPublicKeyEnc);
        PublicKey sendPublicKey = sendKeyFactory.generatePublic(x509EncodedKeySpec);

        KeyAgreement sendKeyAgreement = KeyAgreement.getInstance(&quot;DH&quot;);
        sendKeyAgreement.init(sendKeyPair.getPrivate());
        sendKeyAgreement.doPhase(sendPublicKey, true);

        SecretKey sendDESKey = sendKeyAgreement.generateSecret(&quot;DES&quot;);//发送方Key
//        5.发送方加密：
        Cipher sendCipher = Cipher.getInstance(&quot;DES&quot;);
        sendCipher.init(Cipher.ENCRYPT_MODE, sendDESKey);
        byte[] sendResult = sendCipher.doFinal(name.getBytes());
        System.out.println(&quot;sendResult ：&quot;+ HexBin.encode(sendResult));

//        6.接收方解密：
        Cipher receiverCipher = Cipher.getInstance(&quot;DES&quot;);
        receiverCipher.init(Cipher.DECRYPT_MODE, receiverDESKey);
        byte[] receiverResult = receiverCipher.doFinal(sendResult);
        System.out.println(&quot;receiverResult : &quot;+new String (receiverResult));



    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rsa&quot;&gt;RSA&lt;/h3&gt;
&lt;p&gt;RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。RSA算法实现了公钥加密、私钥解密 和私钥解密、公钥加密的一个机制。&lt;/p&gt;
&lt;p&gt;也就是说使用公钥来进行加密，想要解密获取明文内容，就必须使用对应的私钥来进行解密。而在其中私钥中的内容其实是比较长的，而公钥里面的内容会偏短一些。因为私钥一般会储存在本地，而公钥会放到各大互联网上，公钥比私钥内容短也是为了方便传输和存储。&lt;/p&gt;
&lt;h4 id=&quot;代码示例：&quot;&gt;代码示例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.demo;

import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
import sun.misc.BASE64Encoder;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class rsademo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
//        1.初始化密钥
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        keyPairGenerator.initialize(512);//设置密钥长度
        KeyPair keyPair = keyPairGenerator.generateKeyPair();//生成密钥对
        RSAPublicKey rsaPublic =(RSAPublicKey) keyPair.getPublic();//获取公钥
        RSAPrivateKey rsaPrivate = (RSAPrivateKey)keyPair.getPrivate();//获取私钥
//        System.out.println(new BASE64Encoder().encode(rsaPublic.getEncoded()));//输出公钥
        System.out.println(&quot;&quot;);
//        System.out.println(new BASE64Encoder().encode(rsaPrivate.getEncoded()));//输出私钥
//        2.私钥加密、公钥解密
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(rsaPrivate.getEncoded());//对密钥进行编码处理
        KeyFactory rsa = KeyFactory.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        PrivateKey privateKey = rsa.generatePrivate(pkcs8EncodedKeySpec);//从提供的密钥规范生成私钥对象。
//        2.1私钥加密
        Cipher encodecipher = Cipher.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        encodecipher.init(Cipher.ENCRYPT_MODE,privateKey);//设置为加密类型并传入私钥进行加密
        byte[] res = encodecipher.doFinal(name.getBytes());//对内容进行加密


        System.out.println(new BASE64Encoder().encode(res));

//        2.2公钥解密

        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(rsaPublic.getEncoded());//对公钥进行编码处理
        rsa = KeyFactory.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        PublicKey publicKey = rsa.generatePublic(x509EncodedKeySpec);//从提供的密钥规范生成公钥对象。 
        Cipher decodecipher = Cipher.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        decodecipher.init(Cipher.DECRYPT_MODE,publicKey);//设置解密类型并传入公钥进行解密
        byte[] decoderes = decodecipher.doFinal(res);//对内容进行解密
        System.out.println(new String(decoderes));



    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202010/1993669-20201029012851487-1971999637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面再来看个公钥加密私钥解密的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JAVA&quot;&gt;package com.demo;

import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
import sun.misc.BASE64Encoder;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class rsademo {
    private static String name = &quot;xiaoming&quot;;
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
//        1.初始化密钥
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;);//设置获取RSA的密钥
        keyPairGenerator.initialize(512);//设置密钥长度
        KeyPair keyPair = keyPairGenerator.generateKeyPair();//生成密钥对
        RSAPublicKey rsaPublic =(RSAPublicKey) keyPair.getPublic();//获取公钥
        RSAPrivateKey rsaPrivate = (RSAPrivateKey)keyPair.getPrivate();//获取私钥
//        System.out.println(new BASE64Encoder().encode(rsaPublic.getEncoded()));//输出公钥
        System.out.println(&quot;&quot;);


//        3.公钥加密、私钥解密
        //        3.1公钥加密
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(rsaPublic.getEncoded());
        KeyFactory encodersa = KeyFactory.getInstance(&quot;RSA&quot;);
        PublicKey publicKey = encodersa.generatePublic(x509EncodedKeySpec);
        Cipher encodecipher = Cipher.getInstance(&quot;RSA&quot;);
        encodecipher.init(Cipher.ENCRYPT_MODE,publicKey);
        byte[] encoderes = encodecipher.doFinal(name.getBytes());
        System.out.println(new BASE64Encoder().encode(encoderes));
//        3.2私钥解密
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(rsaPrivate.getEncoded());
        KeyFactory decodersa = KeyFactory.getInstance(&quot;RSA&quot;);
        PrivateKey privateKey = decodersa.generatePrivate(pkcs8EncodedKeySpec);
        Cipher decodecipher = Cipher.getInstance(&quot;RSA&quot;);
        decodecipher.init(Cipher.DECRYPT_MODE,privateKey);
        byte[] decoderes = decodecipher.doFinal(encoderes);
        System.out.println(new String(decoderes));


    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中其实可以看到用到了&lt;code&gt;x509EncodedKeySpec&lt;/code&gt;和&lt;code&gt;pkcs8EncodedKeySpec&lt;/code&gt;的类，其实这两个类一个用于对私钥进行编码的，一个是对私钥进行编码。&lt;/p&gt;
&lt;h2 id=&quot;0x05-结尾&quot;&gt;0x05 结尾&lt;/h2&gt;
&lt;p&gt;在安全中其实加密算法显得格外的重要，举个例子，比如说冰蝎，为什么就能过一些设备呢？其实分析过冰蝎的，或者是看过冰蝎作者大大的文章的应该会知道，冰蝎在流量传输中也是做了加密的。使用的是AES加密。首先是将客户端发送的命令转换成字节码，然后使用aes进行加密，然后在客户端也就是webshell获取密钥进行解密得到字节码，最后就是使用defineClass来动态加载字节码进行执行。&lt;/p&gt;
&lt;p&gt;但是在后面各大厂商的设备随着各大厂商设备的不断升级，冰蝎2还是被杀了。这是因为在冰蝎aes传输密钥的时候被识别出来了。那么我们如果再对该密钥进行更狠一点加密呢？虽然说也能实现，步骤繁琐一些。但是这还是会产生一些流量。在冰蝎3中的做法是去除了握手的过程，直接写死在Webshell中的字符串作为AES密钥解密流量包。&lt;/p&gt;
&lt;p&gt;后面打算基于冰蝎进行一个重写，并使用不同的算法来实现加密。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Oct 2020 17:29:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java安全之安全加密算法 0x00 前言 本篇文来谈谈关于常见的一些加密算法，其实在此之前，对算法的了解并不是太多。了解的层次只是基于加密算法的一些应用上。也来浅谈一下加密算法在安全领域中的作用。写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/13894507.html</dc:identifier>
</item>
<item>
<title>【问题记录】—.NetCore 编译问题 - chaney1992</title>
<link>http://www.cnblogs.com/cwsheng/p/13883581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwsheng/p/13883581.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;最近在协助验证Jenkins自动编译发布时，对一些.Net Core编译问题进行了解决；特记录一下&lt;/p&gt;
&lt;h3&gt;一、编译生成netcoreapp目录问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题现象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　.net core项目编译输出目录总是包含在【netcoreapp3.1】目录下，如图：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028215936240-1335103154.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　在项目文件中(*.csproj)中添加节点：&lt;span&gt;&lt;strong&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;AppendTargetFrameworkToOutputPath&amp;gt;false&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;AppendTargetFrameworkToOutputPath&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;hljs-name&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;span class=&quot;hljs-name&quot;&gt;　　　位置如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Library&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.&lt;span&gt;1&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;CopyLocalLockFileAssemblies&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/CopyLocalLockFileAssemblies&amp;gt;&amp;lt;!--所有依赖文件拷贝到输出目录--&amp;gt;
    &lt;span&gt;&lt;strong&gt;&amp;lt;AppendTargetFrameworkToOutputPath&amp;gt;false&amp;lt;/AppendTargetFrameworkToOutputPath&amp;gt;&lt;/strong&gt;&lt;/span&gt;
    &amp;lt;ApplicationIcon /&amp;gt;
    &amp;lt;StartupObject /&amp;gt;
    &amp;lt;AssemblyName&amp;gt;CustomReportResolver&amp;lt;/AssemblyName&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、编译语言包问题 &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题现象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　　在编译某些项目时，产生了多个文件包如下图：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028221813108-1033321278.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;产生原因&lt;/strong&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　　点开文件夹内，发现为：Microsoft.CodeAnalysis 包产生的文件(语言包)&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028221159228-2055208468.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;继续在项目文件中添加节点：&lt;span&gt;&lt;strong&gt;&amp;lt;SatelliteResourceLanguages&amp;gt;zh-Hans&amp;lt;/SatelliteResourceLanguages&amp;gt;&lt;/strong&gt;&lt;span&gt;指定语言包；&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果不想要语言包可指定一个非语言包名的内容&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　最终编译结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028221740621-1220177931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;三、Jenkins自动编译Nuget包还原问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题现象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;由于程序中，大量使用了&lt;a href=&quot;https://blog.nuget.org/20170316/NuGet-now-fully-integrated-into-MSBuild.html&quot;&gt;PackageReference&lt;/a&gt;方式引用nuget包，在使用Jenkins自动编译时，则使用 Nuget Restore 后，再使用 dotnet build 编译包。但是编译时总是失败提示以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028223611732-1659945340.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　根据问题提示，明确包版本不是最新的导致，然后根据vs中dll目录中，删除后，再编译依旧提示错误。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;产生原因&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　最终在网上找到原因：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;通过&lt;code&gt;PackageReference&lt;/code&gt;的方式引用在Nuget包还原的时候会在obj目录下自动生成Nuget包引用的配置文件&lt;strong&gt;&lt;span&gt;&lt;code&gt;project.assets.json&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;、&lt;code&gt;*.csproj.nuget.cache&lt;/code&gt;、&lt;code&gt;*.csproj.nuget.g.props&lt;/code&gt;、&lt;code&gt;*.csproj.nuget.g.targets&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终通过对比Jenkins和Vs自动编译时生成内容发现包换成位置不同导致的：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/374428/202010/374428-20201028222644127-2127463773.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　删除Jenkins编译时，所引用的包缓存中的包内容，重新编译；问题解决。&lt;/p&gt;

&lt;h4&gt;希望记录的问题，能解决一些问题&lt;/h4&gt;
</description>
<pubDate>Wed, 28 Oct 2020 14:48:00 +0000</pubDate>
<dc:creator>chaney1992</dc:creator>
<og:description>最近在协助验证Jenkins自动编译发布时，对一些.Net Core编译问题进行了解决；特记录一下 一、编译生成netcoreapp目录问题 问题现象 .net core项目编译输出目录总是包含在【n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cwsheng/p/13883581.html</dc:identifier>
</item>
<item>
<title>面试官：面对千万级、亿级流量怎么处理？ - 科技缪缪</title>
<link>http://www.cnblogs.com/ilovejaney/p/13893995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilovejaney/p/13893995.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个《我想进大厂》系列的最后一篇，终结篇。可能有点标题党了，但是我想要表达的意思和目的是一致的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一道很常见的面试题，但是大多数人并不知道怎么回答，这种问题其实可以有很多形式的提问方式，你一定见过而且感觉无从下手：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面对业务急剧增长你怎么处理？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务量增长10倍、100倍怎么处理？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你们系统怎么支撑高并发的？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么设计一个高并发系统？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高并发系统都有什么特点？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;... ...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诸如此类，问法很多，但是面试这种类型的问题，看着很难无处下手，但是我们可以有一个常规的思路去回答，就是围绕支撑高并发的业务场景怎么设计系统才合理？如果你能想到这一点，那接下来我们就可以围绕硬件和软件层面怎么支撑高并发这个话题去阐述了。本质上，这个问题就是综合考验你对各个细节是否知道怎么处理，是否有经验处理过而已。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面对超高的并发，首先硬件层面机器要能扛得住，其次架构设计做好微服务的拆分，代码层面各种缓存、削峰、解耦等等问题要处理好，数据库层面做好读写分离、分库分表，稳定性方面要保证有监控，熔断限流降级该有的必须要有，发生问题能及时发现处理。这样从整个系统设计方面就会有一个初步的概念。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;微服务架构演化&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网早期的时候，单体架构就足以支撑起日常的业务需求，大家的所有业务服务都在一个项目里，部署在一台物理机器上。所有的业务包括你的交易系统、会员信息、库存、商品等等都夹杂在一起，当流量一旦起来之后，单体架构的问题就暴露出来了，机器挂了所有的业务全部无法使用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk52ua81gnj30ne0hqaaq.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，集群架构的架构开始出现，单机无法抗住的压力，最简单的办法就是水平拓展横向扩容了，这样，通过负载均衡把压力流量分摊到不同的机器上，暂时是解决了单点导致服务不可用的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk52zyrmq1j31dm0kwjso.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着业务的发展，在一个项目里维护所有的业务场景使开发和代码维护变得越来越困难，一个简单的需求改动都需要发布整个服务，代码的合并冲突也会变得越来越频繁，同时线上故障出现的可能性越大。微服务的架构模式就诞生了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk536husyuj31ok0gamya.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把每个独立的业务拆分开独立部署，开发和维护的成本降低，集群能承受的压力也提高了，再也不会出现一个小小的改动点需要牵一发而动全身了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的点从高并发的角度而言，似乎都可以归类为通过服务拆分和集群物理机器的扩展提高了整体的系统抗压能力，那么，随之拆分而带来的问题也就是高并发系统需要解决的问题。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;RPC&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务化的拆分带来的好处和便利性是显而易见的，但是与此同时各个微服务之间的通信就需要考虑了。传统HTTP的通信方式对性能是极大的浪费，这时候就需要引入诸如Dubbo类的RPC框架，基于TCP长连接的方式提高整个集群通信的效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk53su6u45j31920oy75z.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设原来来自客户端的QPS是9000的话，那么通过负载均衡策略分散到每台机器就是3000，而HTTP改为RPC之后接口的耗时缩短了，单机和整体的QPS就提升了。而RPC框架本身一般都自带负载均衡、熔断降级的机制，可以更好的维护整个系统的高可用性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么说完RPC，作为基本上国内普遍的选择Dubbo的一些基本原理就是接下来的问题。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;Dubbo工作原理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务启动的时候，provider和consumer根据配置信息，连接到注册中心register，分别向注册中心注册和订阅服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;register根据服务订阅关系，返回provider信息到consumer，同时consumer会把provider信息缓存到本地。如果信息有变更，consumer会收到来自register的推送&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;consumer生成代理对象，同时根据负载均衡策略，选择一台provider，同时定时向monitor记录接口的调用次数和时间信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拿到代理对象之后，consumer通过代理对象发起接口调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;provider收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bpvltvpj31dp0u0whq.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;Dubbo负载均衡策略&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot; readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;加权随机：假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最小活跃数：每个服务提供者对应一个活跃数 active，初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一致性hash：通过hash算法，把provider的invoke和随机节点生成hash，并将这个 hash 投射到 [0, 2^32 - 1] 的圆环上，查询的时候根据key进行md5然后进行hash，得到第一个节点的值大于等于当前hash的invoker。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5boowccsj31920ki0tm.jpg&quot; alt=&quot;图片来自dubbo官方&quot;/&gt;图片来自dubbo官方&lt;/p&gt;
&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;加权轮询：比如服务器 A、B、C 权重比为 5:2:1，那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;集群容错&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Failover Cluster失败自动切换：dubbo的默认容错方案，当调用失败时自动切换到其他可用的节点，具体的重试次数和间隔时间可用通过引用服务的时候配置，默认重试次数为1也就是只调用一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Failback Cluster快速失败：在调用失败，记录日志和调用信息，然后返回空结果给consumer，并且通过定时任务每隔5秒对失败的调用进行重试&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Failfast Cluster失败自动恢复：只会调用一次，失败后立刻抛出异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Failsafe Cluster失败安全：调用出现异常，记录日志不抛出，返回空结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Forking Cluster并行调用多个服务提供者：通过线程池创建多个线程，并发调用多个provider，结果保存到阻塞队列，只要有一个provider成功返回了结果，就会立刻返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Broadcast Cluster广播模式：逐个调用每个provider，如果其中一台报错，在循环调用结束后，抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;消息队列&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于MQ的作用大家都应该很了解了，削峰填谷、解耦。依赖消息队列，同步转异步的方式，可以降低微服务之间的耦合。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一些不需要同步执行的接口，可以通过引入消息队列的方式异步执行以提高接口响应时间。在交易完成之后需要扣库存，然后可能需要给会员发放积分，本质上，发积分的动作应该属于履约服务，对实时性的要求也不高，我们只要保证最终一致性也就是能履约成功就行了。对于这种同类性质的请求就可以走MQ异步，也就提高了系统抗压能力了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk563uh5f2j31wc0r0dig.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于消息队列而言，怎么在使用的时候保证消息的可靠性、不丢失？&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;消息可靠性&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息丢失可能发生在生产者发送消息、MQ本身丢失消息、消费者丢失消息3个方面。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生产者丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者丢失消息的可能点在于程序发送失败抛异常了没有重试处理，或者发送的过程成功但是过程中网络闪断MQ没收到，消息就丢失了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于同步发送的一般不会出现这样使用方式，所以我们就不考虑同步发送的问题，我们基于异步发送的场景来说。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步发送分为两个方式：&lt;strong&gt;异步有回调和异步无回调&lt;/strong&gt;，无回调的方式，生产者发送完后不管结果可能就会造成消息丢失，而通过异步发送+回调通知+本地消息表的形式我们就可以做出一个解决方案。以下单的场景举例。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;下单后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么下单失败，事务回滚。&lt;/li&gt;
&lt;li&gt;下单成功，直接返回客户端成功，异步发送MQ消息&lt;/li&gt;
&lt;li&gt;MQ回调通知消息发送结果，对应更新数据库MQ发送状态&lt;/li&gt;
&lt;li&gt;JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试&lt;/li&gt;
&lt;li&gt;在监控平台配置或者JOB程序处理超过一定次数一直发送不成功的消息，告警，人工介入。&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bsdn94sj30re0z80up.jpg&quot; alt=&quot;&quot;/&gt; 一般而言，对于大部分场景来说异步回调的形式就可以了，只有那种需要完全保证不能丢失消息的场景我们做一套完整的解决方案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MQ丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果生产者保证消息发送到MQ，而MQ收到消息后还在内存中，这时候宕机了又没来得及同步给从节点，就有可能导致消息丢失。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如RocketMQ：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Kafka也可以通过配置做到：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;acks=all 只有参与复制的所有节点全部收到消息，才返回生产者成功。这样的话除非所有的节点都挂了，消息才会丢失。&lt;br/&gt;replication.factor=N,设置大于&lt;span class=&quot;hljs-number&quot;&gt;1的数，这会要求每个partion至少有&lt;span class=&quot;hljs-number&quot;&gt;2个副本&lt;br/&gt;min.insync.replicas=N，设置大于&lt;span class=&quot;hljs-number&quot;&gt;1的数，这会要求leader至少感知到一个follower还保持着连接&lt;br/&gt;retries=N，设置一个非常大的值，让生产者发送失败一直重试&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们可以通过配置的方式来达到MQ本身高可用的目的，但是都对性能有损耗，怎样配置需要根据业务做出权衡。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消费者丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者丢失消息的场景：消费者刚收到消息，此时服务器宕机，MQ认为消费者已经消费，不会重复发送消息，消息丢失。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ默认是需要消费者回复ack确认，而kafka需要手动开启配置关闭自动offset。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费方不返回ack确认，重发的机制根据MQ类型的不同发送时间间隔、次数都不尽相同，如果重试超过次数之后会进入死信队列，需要手工来处理了。（Kafka没有这些）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bsd0fwrj30s00d40tm.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;消息的最终一致性&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务消息可以达到分布式事务的最终一致性，事务消息就是MQ提供的类似XA的分布式事务能力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;半事务消息就是MQ收到了生产者的消息，但是没有收到二次确认，不能投递的消息。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现原理如下：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;生产者先发送一条半事务消息到MQ&lt;/li&gt;
&lt;li&gt;MQ收到消息后返回ack确认&lt;/li&gt;
&lt;li&gt;生产者开始执行本地事务&lt;/li&gt;
&lt;li&gt;如果事务执行成功发送commit到MQ，失败发送rollback&lt;/li&gt;
&lt;li&gt;如果MQ长时间未收到生产者的二次确认commit或者rollback，MQ对生产者发起消息回查&lt;/li&gt;
&lt;li&gt;生产者查询事务执行最终状态&lt;/li&gt;
&lt;li&gt;根据查询事务状态再次提交二次确认&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，如果MQ收到二次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在3天后被删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bv2qx9nj316u0gemyl.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据库&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于整个系统而言，最终所有的流量的查询和写入都落在数据库上，数据库是支撑系统高并发能力的核心。怎么降低数据库的压力，提升数据库的性能是支撑高并发的基石。主要的方式就是通过读写分离和分库分表来解决这个问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于整个系统而言，流量应该是一个漏斗的形式。比如我们的日活用户DAU有20万，实际可能每天来到提单页的用户只有3万QPS，最终转化到下单支付成功的QPS只有1万。那么对于系统来说读是大于写的，这时候可以通过读写分离的方式来降低数据库的压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk56wrs6ejj30mq0todha.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离也就相当于数据库集群的方式降低了单节点的压力。而面对数据的急剧增长，原来的单库单表的存储方式已经无法支撑整个业务的发展，这时候就需要对数据库进行分库分表了。针对微服务而言垂直的分库本身已经是做过的，剩下大部分都是分表的方案了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;水平分表&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如用户id为100，那我们都经过hash(100)，然后对1024取模，就可以落到对应的表上了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;分表后的ID唯一性&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。&lt;/li&gt;
&lt;li&gt;分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种&lt;/li&gt;
&lt;li&gt;分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;主从同步原理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;master提交完事务后，写入binlog&lt;/li&gt;
&lt;li&gt;slave连接到master，获取binlog&lt;/li&gt;
&lt;li&gt;master创建dump线程，推送binglog到slave&lt;/li&gt;
&lt;li&gt;slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中&lt;/li&gt;
&lt;li&gt;slave再开启一个sql线程读取relay log事件并在slave执行，完成同步&lt;/li&gt;
&lt;li&gt;slave记录自己的binglog&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bybdwy0j30ta0h23zj.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全同步复制&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;半同步复制&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;缓存&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存作为高性能的代表，在某些特殊业务可能承担90%以上的热点流量。对于一些活动比如秒杀这种并发QPS可能几十万的场景，引入缓存事先预热可以大幅降低对数据库的压力，10万的QPS对于单机的数据库来说可能就挂了，但是对于如redis这样的缓存来说就完全不是问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk578hq4j4j30mi0we75q.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以秒杀系统举例，活动预热商品信息可以提前缓存提供查询服务，活动库存数据可以提前缓存，下单流程可以完全走缓存扣减，秒杀结束后再异步写入数据库，数据库承担的压力就小的太多了。当然，引入缓存之后就还要考虑缓存击穿、雪崩、热点一系列的问题了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;热key问题&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bzdrohrj30t60c60tc.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对热key的解决方案：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;提前把热key打散到不同的服务器，降低压力&lt;/li&gt;
&lt;li&gt;加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;缓存击穿&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方案：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。&lt;/li&gt;
&lt;li&gt;将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bzfhc5lj30oe0cc74v.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;缓存穿透&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bze172kj30ny0c2gm4.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bzei06pj30yu0f475a.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;缓存雪崩&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5bzf0i2aj30ra0cagmh.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对雪崩几个解决方案：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;针对不同key设置不同的过期时间，避免同时过期&lt;/li&gt;
&lt;li&gt;限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB&lt;/li&gt;
&lt;li&gt;二级缓存，同热key的方案。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;稳定性&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5b5jw0msj31rf0u077u.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;熔断&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如营销服务挂了或者接口大量超时的异常情况，不能影响下单的主链路，涉及到积分的扣减一些操作可以在事后做补救。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;限流&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对突发如大促秒杀类的高并发，如果一些接口不做限流处理，可能直接就把服务打挂了，针对每个接口的压测性能的评估做出合适的限流尤为重要。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断之后实际上可以说就是降级的一种，以熔断的举例来说营销接口熔断之后降级方案就是短时间内不再调用营销的服务，等到营销恢复之后再调用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预案&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，就算是有统一配置中心，在业务的高峰期也是不允许做出任何的变更的，但是通过配置合理的预案可以在紧急的时候做一些修改。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;核对&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对各种分布式系统产生的分布式事务一致性或者受到攻击导致的数据异常，非常需要核对平台来做最后的兜底的数据验证。比如下游支付系统和订单系统的金额做核对是否正确，如果收到中间人攻击落库的数据是否保证正确性。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实可以看到，怎么设计高并发系统这个问题本身他是不难的，无非是基于你知道的知识点，从物理硬件层面到软件的架构、代码层面的优化，使用什么中间件来不断提高系统的抗压能力。但是这个问题本身会带来更多的问题，微服务本身的拆分带来了分布式事务的问题，http、RPC框架的使用带来了通信效率、路由、容错的问题，MQ的引入带来了消息丢失、积压、事务消息、顺序消息的问题，缓存的引入又会带来一致性、雪崩、击穿的问题，数据库的读写分离、分库分表又会带来主从同步延迟、分布式ID、事务一致性的问题，而为了解决这些问题我们又要不断的加入各种措施熔断、限流、降级、离线核对、预案处理等等来防止和追溯这些问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章结合了之前的文章的一些内容，实际上最开始的时候就是想写这一篇，发现篇幅实在太大了而且内容不好概括，所以就拆分了几篇开始写，这一篇算是对前面内容的一个归纳和总结吧，不是我为了水。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有就是我的读者朋友们的群开通了，你也希望加入的话那就加我的个人微信，备注”入群“吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gk5ceqdlnqj30e80e8ael.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有还有最后一件事情，帮朋友发一个阿里云的招聘信息，急招各路大牛，base北京。有兴趣的朋友也可以添加我的个人微信，备注”招聘“即可。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;职位要求：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;计算机相关专业本科及以上学历；&lt;/li&gt;
&lt;li&gt;精通两种以上主流数据库和缓存技术，有丰富的数据库设计、优化、维护经验。或熟悉ELK、hadoop、spark、flink等大数据技术中的一种或多种。&lt;/li&gt;
&lt;li&gt;精通JAVA、GO、Python等至少一门语言，5年以上的系统开发经验，熟悉微服务架构、基于容器和云原生技术，有丰富的实践和落地经验。&lt;/li&gt;
&lt;li&gt;大型分布式系统架构设计经验，如：容灾高可用、业务容灾多活、两地三中心架构等，有项目落地经验者优先。&lt;/li&gt;
&lt;li&gt;熟悉阿里云产品，通过阿里云ACP、PMP、TOGAF相关认证者优先考虑。&lt;/li&gt;
&lt;li&gt;能够准确的理解客户需求，有从事过大型企业云化架构规划、设计和咨询的交付经验。&lt;/li&gt;
&lt;li&gt;具备良好的客户沟通能力，工作积极主动，认真负责。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;- END -&lt;/p&gt;
</description>
<pubDate>Wed, 28 Oct 2020 14:36:00 +0000</pubDate>
<dc:creator>科技缪缪</dc:creator>
<og:description>这个《我想进大厂》系列的最后一篇，终结篇。可能有点标题党了，但是我想要表达的意思和目的是一致的。 这是一道很常见的面试题，但是大多数人并不知道怎么回答，这种问题其实可以有很多形式的提问方式，你一定见过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ilovejaney/p/13893995.html</dc:identifier>
</item>
<item>
<title> Shell脚本实现----Kubernetes单集群二进制部署 - 梦里花落知多少sl</title>
<link>http://www.cnblogs.com/user-sunli/p/13893991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/user-sunli/p/13893991.html</guid>
<description>&lt;pre&gt;
#/bin/&lt;span&gt;bash
#auther:sunli
#mail:&amp;lt;1916989848@qq.com&amp;gt;&lt;span&gt;
#description：利用cfssljson格式，自建CA中心，生成ca-&lt;span&gt;key.pem（私钥）和ca.pem（证书），还会生成ca.csr（证书签名请求）
 
CFSSL() {
#将下载好的三个cfssl文件赋予可执行权限,并设置为系统命令
wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
mv cfssl* /usr/local/bin/
chmod +x /usr/local/bin/cfssl*&lt;span&gt;
}
 
#判断cfssl命令是否存在
which cfssljson_linux-&lt;span&gt;amd64
[ `echo $?` -ne 0 ] &amp;amp;&amp;amp;&lt;span&gt; CFSSL
 
#确定service
service=$1&lt;span&gt;
[ ! -d /etc/$service/ssl ] &amp;amp;&amp;amp; mkdir -p /etc/$service/&lt;span&gt;ssl
CA_DIR=/etc/$service/&lt;span&gt;ssl
 
#CA中心配置文件
CA_CONFIG() {
cat &amp;gt;&amp;gt; $CA_DIR/ca-config.json &amp;lt;&amp;lt;-&lt;span&gt; EOF
{
  &quot;signing&quot;&lt;span&gt;: {
    &quot;default&quot;&lt;span&gt;: {
      &quot;expiry&quot;: &quot;87600h&quot;&lt;span&gt;
    },
    &quot;profiles&quot;&lt;span&gt;: {
      &quot;$service&quot;&lt;span&gt;: {
         &quot;expiry&quot;: &quot;87600h&quot;&lt;span&gt;,
         &quot;usages&quot;&lt;span&gt;: [
            &quot;signing&quot;&lt;span&gt;,
            &quot;key encipherment&quot;&lt;span&gt;,
            &quot;server auth&quot;&lt;span&gt;,
            &quot;client auth&quot;&lt;span&gt;
        ]
      }
    }
  }
}
EOF
}
 
#CA证书签名请求
CA_CSR() {
cat &amp;gt;&amp;gt; $CA_DIR/ca-csr.json &amp;lt;&amp;lt;-&lt;span&gt; EOF
{
    &quot;CN&quot;: &quot;$service&quot;&lt;span&gt;,
    &quot;key&quot;&lt;span&gt;: {
        &quot;algo&quot;: &quot;rsa&quot;&lt;span&gt;,
        &quot;size&quot;: 2048&lt;span&gt;
    },
    &quot;names&quot;&lt;span&gt;: [
        {
            &quot;C&quot;: &quot;CN&quot;&lt;span&gt;,
            &quot;L&quot;: &quot;GuangDong&quot;&lt;span&gt;,
            &quot;ST&quot;: &quot;GuangZhou&quot;&lt;span&gt;,
            &quot;O&quot;: &quot;$service&quot;&lt;span&gt;,
            &quot;OU&quot;: &quot;System&quot;&lt;span&gt;
        }
    ]
}
EOF
}
 
#服务器请求CA中心颁发证书签名请求
SERVER_CSR() {
host1=192.168.10.10&lt;span&gt;
host2=192.168.10.11&lt;span&gt;
host3=192.168.10.12&lt;span&gt;
host4=192.168.10.13&lt;span&gt;
host5=192.168.10.14&lt;span&gt;
host6=192.168.10.15
cat &amp;gt;&amp;gt; $CA_DIR/server-csr.json &amp;lt;&amp;lt;-&lt;span&gt; EOF
{
    &quot;CN&quot;: &quot;$service&quot;&lt;span&gt;,
    &quot;hosts&quot;&lt;span&gt;: [
    &quot;127.0.0.1&quot;&lt;span&gt;,
    &quot;$host1&quot;&lt;span&gt;,
    &quot;$host2&quot;&lt;span&gt;,
    &quot;$host3&quot;&lt;span&gt;,
    &quot;$host4&quot;&lt;span&gt;,
    &quot;$host5&quot;&lt;span&gt;
    ],
    &quot;key&quot;&lt;span&gt;: {
        &quot;algo&quot;: &quot;rsa&quot;&lt;span&gt;,
        &quot;size&quot;: 2048&lt;span&gt;
    },
    &quot;names&quot;&lt;span&gt;: [
        {
            &quot;C&quot;: &quot;CN&quot;&lt;span&gt;,
            &quot;L&quot;: &quot;GuangDong&quot;&lt;span&gt;,
            &quot;ST&quot;: &quot;GuangZhou&quot;&lt;span&gt;,
            &quot;O&quot;: &quot;$service&quot;&lt;span&gt;,
            &quot;OU&quot;: &quot;System&quot;&lt;span&gt;
        }
    ]
}
EOF
}
 
SERVER_CSR1() {
host1=192.168.10.10&lt;span&gt;
host2=192.168.10.20&lt;span&gt;
host3=192.168.10.30&lt;span&gt;
host4=192.168.10.40
cat &amp;gt;&amp;gt; $CA_DIR/server-csr.json &amp;lt;&amp;lt;-&lt;span&gt; EOF
{
    &quot;CN&quot;: &quot;$service&quot;&lt;span&gt;,
    &quot;hosts&quot;&lt;span&gt;: [
      &quot;10.0.0.1&quot;&lt;span&gt;,
      &quot;127.0.0.1&quot;&lt;span&gt;,
      &quot;$host1&quot;&lt;span&gt;,
      &quot;$host2&quot;&lt;span&gt;,
      &quot;$host3&quot;&lt;span&gt;,
      &quot;$host4&quot;&lt;span&gt;,
      &quot;kubernetes&quot;&lt;span&gt;,
      &quot;kubernetes.default&quot;&lt;span&gt;,
      &quot;kubernetes.default.svc&quot;&lt;span&gt;,
      &quot;kubernetes.default.svc.cluster&quot;&lt;span&gt;,
      &quot;kubernetes.default.svc.cluster.local&quot;&lt;span&gt;
    ],
    &quot;key&quot;&lt;span&gt;: {
        &quot;algo&quot;: &quot;rsa&quot;&lt;span&gt;,
        &quot;size&quot;: 2048&lt;span&gt;
    },
    &quot;names&quot;&lt;span&gt;: [
        {
            &quot;C&quot;: &quot;CN&quot;&lt;span&gt;,
            &quot;L&quot;: &quot;GuangDong&quot;&lt;span&gt;,
            &quot;ST&quot;: &quot;GuangZhou&quot;&lt;span&gt;,
            &quot;O&quot;: &quot;$service&quot;&lt;span&gt;,
            &quot;OU&quot;: &quot;System&quot;&lt;span&gt;
        }
    ]
}
EOF
}
 
CA_CONFIG &amp;amp;&amp;amp;&lt;span&gt; CA_CSR
[ &quot;$service&quot; == &quot;kubernetes&quot; ] &amp;amp;&amp;amp; SERVER_CSR1 ||&lt;span&gt; SERVER_CSR
 
#生成CA所必需的文件ca-&lt;span&gt;key.pem（私钥）和ca.pem（证书），还会生成ca.csr（证书签名请求），用于交叉签名或重新签名
cd $CA_DIR/&lt;span&gt;
cfssl_linux-amd64 gencert -initca ca-csr.json | cfssljson_linux-amd64 -&lt;span&gt;bare ca
 
#生成证书
cfssl_linux-amd64 gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=$service server-csr.json | cfssljson_linux-amd64 -bare server&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 28 Oct 2020 14:35:00 +0000</pubDate>
<dc:creator>梦里花落知多少sl</dc:creator>
<og:description>Shell脚本实现 Kubernetes单集群二进制部署 搭建Kubernetes集群环境有以下三种方式： 1.&amp;#160;Minikube安装方式Minikube是一个工具，可以在本地快速运行一个单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/user-sunli/p/13893991.html</dc:identifier>
</item>
<item>
<title>Linux配置和管理设备映射多路径multipath - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/13893346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/13893346.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028222713321-1157798541.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;(一)多路径管理软件的由来&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;在企业中，服务器与存储通常是分开放置的，服务器上的硬盘通常用来安装操作系统和应用软件，业务数据则是存储在单独的存储设备上，那么，服务器与存储是如何连接的呢？根据存储协议，经常有2种方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NAS存储(Network Attached Storage，网络附加存储)，NAS存储使用基于文件的协议（例如CIFS、NFS）,其它计算机通过以太网访问NAS存储，类似于一个共享目录，NAS存储好处多多，网络适配性好，只要网络互通，就能访问，NAS存储价格也较为便宜，缺点是相对SAN而言，网络带宽受限、网络延迟较大，性能较差。&lt;/li&gt;
&lt;li&gt;SAN存储(Storage Area Network，存储区域网络)，SAN存储基于Fabric协议，分配给其它机器的是LUN，SAN存储可以来理解为一个虚拟的磁盘。通常价格昂贵，性能较好。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于NAS存储，只要使用IP访问即可，但是对于SAN存储，需要专业的硬件支持，主要是SAN HBA卡和SAN交换机。&lt;br/&gt;在SAN网络中，大企业为了业务稳定，不因硬件损坏而导致业务停滞，在硬件采购时，往往采用“双份”的策略：2个网卡做绑定、2个CPU、2个风扇、2个HBA卡、2个SAN交换机等等。为了保障存储的高可用性，存储、SAN交换机、服务器架构通常如下：&lt;br/&gt;架构1：一台服务器拥有2个HBA卡，1台SAN交换机，2个存储控制器控制1台存储，这样就形成了2条链路。&lt;br/&gt;hba1 &amp;lt;--&amp;gt; SAN &amp;lt;--&amp;gt; cntrlr1 (Storage)&lt;br/&gt;hba2 &amp;lt;--&amp;gt; SAN &amp;lt;--&amp;gt; cntrlr2 (Storage)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205006885-244072123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;架构2：一台服务器拥有2个HBA卡，2台SAN交换机，2个存储控制器控制1台存储（这里把RAID A和RAID B看做是同一台存储上划出来的LUN，RAID A和RAID B使用相同的2个控制器），这样就形成了4台链路，但是对于每个LUN而言，还是2条链路：&lt;br/&gt;hba1 &amp;lt;--&amp;gt; SAN1 &amp;lt;--&amp;gt; cntrlr1 (RAID A)&lt;br/&gt;hba1 &amp;lt;--&amp;gt; SAN1 &amp;lt;--&amp;gt; cntrlr1 (RAID B)&lt;br/&gt;hba2 &amp;lt;--&amp;gt; SAN2 &amp;lt;--&amp;gt; cntrlr2 (RAID A)&lt;br/&gt;hba2 &amp;lt;--&amp;gt; SAN2 &amp;lt;--&amp;gt; cntrlr2 (RAID B)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205041642-471670036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种多条链路架构带来的&lt;strong&gt;好处&lt;/strong&gt;有：&lt;br/&gt;--冗余。每个存储都有2条链路，在active/standby模式下，如果HBA卡、SAN交换机、存储控制器出现了单点故障，还有另外一条链路提供服务。&lt;br/&gt;--改进的性能。2条链路设置为active/active模式，实现I/O负载平衡。&lt;br/&gt;当然，&lt;strong&gt;坏处&lt;/strong&gt;也非常明显：&lt;br/&gt;通过上面的2种架构可以发现，在SAN网络中，存储分配出来的LUN(可以理解为一个硬盘)，在多条存储链路连接后，主机会将每条链路识别到的LUN当做一个硬盘，如果一个LUN被主机上的2个HBA卡各自识别了一次，那么我们会在主机上看到2个一样大小的硬盘。明明只有一个硬盘，却因链路问题主机识别为了2个硬盘，给磁盘管理带来了麻烦。&lt;br/&gt;这时候，多路径设备管理软件就应运而生了。每个多路径设备都有一个全球识别符(WWID)，他是一个全球唯一的无法更改的号码，通过WWID，多路径软件就可以将因路径问题重复识别到了磁盘做一个整合映射，对外提供服务。例如，LUN A在通过存储多路径后，在主机上别识别为了/dev/sdc和/dev/sdd，然而sdc和sdd有相同的WWID，所以会将sdc和sdd整合为mpath1磁盘对外提供服务，解决了主机重复识别磁盘的问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;(二)设备映射多路径问题展现&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;在《&lt;a href=&quot;https://www.cnblogs.com/lijiaman/p/13854674.html&quot; target=&quot;_blank&quot;&gt;存储系列1-openfiler开源存储管理平台实践&lt;/a&gt;》文章第四节“（4.1）使用openfiler对外提供块存储(类似SAN存储)”分配存储之后，我们可以看到这样的情况：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在存储端分配了3个lv，大小分别为1GB、2GB、10GB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205110666-705608324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是在客户机上却增加了6个磁盘，多了1倍的数量，仔细查看，发现sdb和sdc、sdd和sde、sdf和sdg大小相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205126825-155517471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再确认磁盘路径确认磁盘分配，发现如下，客户机通过2条路径访问同一个磁盘，因为路径不同，最终同一个LUN分配了2个不同的盘符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205143878-2014120875.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里整理一下存储、链路、主机之间的对应关系，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205225379-13405180.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一块磁盘对应2个或以上盘符&lt;/strong&gt;，用户在使用时如果稍不注意，肯定会出问题，因此需要使用多路径软件将多个盘符映射到同一个盘符下面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(三)常见的多路径配置管理软件&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;通过上面的介绍，想必大家已经知道多路径存储带来的问题了。针对多路径问题，各个系统厂商和存储厂商均开发了多路径设备管理软件。常见的多路径设备管理软件有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EMC存储厂商的PowerPath&lt;/li&gt;
&lt;li&gt;Windows系统的MPIO&lt;/li&gt;
&lt;li&gt;HP-UNIX系统的Native_Multi-Path&lt;/li&gt;
&lt;li&gt;Linux系统的DM Multipath&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面以Linux的DM Multipath为例，学习多路径软件的配置和管理。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;(四)设备映射多路径软件安装&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;我使用的环境为：&lt;br/&gt;--存储服务器(iSCSI target)：使用openfiler提供iSCSI存储&lt;br/&gt;--客户机服务器(iSCSI initiator)：centos7(redhat7也一样)&lt;br/&gt;存储服务器openfiler的存储分配方法不再赘述，可以参考文章：《&lt;a href=&quot;https://www.cnblogs.com/lijiaman/p/13854674.html&quot; target=&quot;_blank&quot;&gt;存储系列1-openfiler开源存储管理平台实践&lt;/a&gt;》。接下来我们在客户机安装多路径软件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 安装多路径软件
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y device-mapper*&lt;span&gt;

# 将多路径软件添加至内核模块中
&lt;/span&gt;&lt;span&gt;modprobe&lt;/span&gt; dm-&lt;span&gt;multipath
&lt;/span&gt;&lt;span&gt;modprobe&lt;/span&gt; dm-round-&lt;span&gt;robin

&lt;span&gt;# 检查内核添加情况&lt;/span&gt;
[root@mysql8 &lt;/span&gt;~]# &lt;span&gt;lsmod&lt;/span&gt; |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; multipath
dm_multipath &lt;/span&gt;&lt;span&gt;27427&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt; dm_round_robin,dm_service_time
dm_mod &lt;/span&gt;&lt;span&gt;123303&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt; dm_round_robin,dm_multipath,dm_log,dm_mirror,dm_service_time

&lt;span&gt;# 设置开机自启动&lt;/span&gt;
systemctl enable multipathd.service

&lt;span&gt;# 检查开机自启动&lt;/span&gt;
[root@mysql8 &lt;/span&gt;~]# systemctl list-unit-files|&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; multipath
multipathd.service enabled

&lt;span&gt;# 创建多路径参数配置文件，该语句会创建multipath的参数配置文件:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/etc/multipath.conf
&lt;/span&gt;/sbin/mpathconf --&lt;span&gt;enable

&lt;span&gt;# 启动多路径软件multipathd&lt;/span&gt;
systemctl start multipathd.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装并启动multipath之后，我们并没有做任何的参数配置，但是可以发现，主机上多了3块磁盘：/dev/mapper/mpathe、/dev/mapper/mpathf、/dev/mapper/mpathg。我们知道，多路径软件就是用来管理磁盘映射的，把主机识别到的6块磁盘映射为了3块磁盘。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@testserver by-&lt;span&gt;id&lt;/span&gt;]# &lt;span&gt;fdisk -&lt;/span&gt;&lt;span&gt;&lt;span&gt;l&lt;/span&gt;
&lt;span&gt;... 略 ...&lt;/span&gt;
Disk &lt;/span&gt;/dev/mapper/mpathe: &lt;span&gt;1073&lt;/span&gt; MB, &lt;span&gt;1073741824&lt;/span&gt; bytes, &lt;span&gt;2097152&lt;/span&gt;&lt;span&gt; sectors
Units &lt;/span&gt;= sectors of &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes

Disk &lt;/span&gt;/dev/mapper/mpathf: &lt;span&gt;2147&lt;/span&gt; MB, &lt;span&gt;2147483648&lt;/span&gt; bytes, &lt;span&gt;4194304&lt;/span&gt;&lt;span&gt; sectors
Units &lt;/span&gt;= sectors of &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes

Disk &lt;/span&gt;/dev/mapper/mpathg: &lt;span&gt;10.7&lt;/span&gt; GB, &lt;span&gt;10737418240&lt;/span&gt; bytes, &lt;span&gt;20971520&lt;/span&gt;&lt;span&gt; sectors
Units &lt;/span&gt;= sectors of &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt; bytes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，这3块磁盘又和主机识别到的6块磁盘时上面关系呢？我们可以使用多路径查看命令来确认：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 可以看到mpathe与sdc和sdb对应同一块磁盘&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
[root@testserver by-&lt;span&gt;id&lt;/span&gt;]# multipath -&lt;span&gt;ll
&lt;span&gt;mpathe&lt;/span&gt; (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sdc&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sdb&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdf &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; active ready running
mpathf (14f504e46494c4552336b535576772d6f5a556b2d5844746e) dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
size&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sde &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sdd &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; active ready running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终，我们看到的磁盘关系就是这样的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202010/823295-20201028205505245-1156123035.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;：存储端划分了3个LUN(可以理解为逻辑卷lv，或者磁盘都行)，在通过2条存储链路映射之后，在主机端识别到了6个磁盘，2个盘符对应同一个LUN，在使用多路径软件multipath做了映射之后，6个磁盘映射为了3个磁盘，最终结果为：存储的lvdata1对应mpathe、lvdata2对应mpathf、lvdata3对应mpathg。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;(五)设备映射多路径软件配置&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;在上一步中，我们并没有对multipath的参数配置文件作任何修改，启动multipath之后，就自动将重复的磁盘做了聚合映射，在这一章节。我们通过修改参数文件，了解一下multipath软件有哪些参数可以配置。&lt;br/&gt;multipath软件的参数配置文件为 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/multipath.conf&lt;/span&gt; 。多路径配置文件主要分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;blacklist:多路径设备黑名单，该处的设备不会被多路径软件识别管理&lt;/li&gt;
&lt;li&gt;blacklist_exceptions:根据blacklist部分中的参数列出不在黑名单中的设备&lt;/li&gt;
&lt;li&gt;defaults:DM Multipath的常规配置&lt;/li&gt;
&lt;li&gt;multipaths:各个独立多路径设备的特性设置，该部分参数会覆盖defaults和devices的参数&lt;/li&gt;
&lt;li&gt;devices:各个存储控制器的设置，如果要使用非默认的存储设备，则可能需要创建devices子部份，该部分参数会覆盖defaults部分的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果同一个参数在defaults，devices，multipaths部分都进行了配置，则优先级从高到低为：multipaths，devices， defaults。&lt;/p&gt;
&lt;p&gt;multipath默认配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_5c48c168-9e43-40f9-b591-401094fed599&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_5c48c168-9e43-40f9-b591-401094fed599&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5c48c168-9e43-40f9-b591-401094fed599&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
[root@testserver ~]# &lt;span&gt;cat&lt;/span&gt; /etc/&lt;span&gt;multipath.conf 
# This is a basic configuration &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; with some examples, &lt;span&gt;for&lt;/span&gt;&lt;span&gt; device mapper
# multipath.
#
# For a complete list of the default configuration values, run either
# multipath &lt;/span&gt;-&lt;span&gt;t
# or
# multipathd show config
#
# For a list of configuration options with descriptions, see the multipath.conf
# &lt;/span&gt;&lt;span&gt;man&lt;/span&gt;&lt;span&gt; page

## By default, devices with vendor &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IBM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; and product = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S/390.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; are
## blacklisted. To enable mulitpathing on these devies, uncomment the
## following lines.
#blacklist_exceptions {
#    device {
#    vendor    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IBM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    product    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S/390.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    }
#}

## Use user friendly names, instead of using WWIDs as names.
defaults {
user_friendly_names yes
find_multipaths yes
}
##
## Here is an example of how to configure some standard options.
##
#
#defaults {
#    polling_interval &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
#    path_selector    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    path_grouping_policy    multibus
#    uid_attribute    ID_SERIAL
#    prio    alua
#    path_checker    readsector0
#    rr_min_io    &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
#    max_fds    &lt;/span&gt;&lt;span&gt;8192&lt;/span&gt;&lt;span&gt;
#    rr_weight    priorities
#    failback    immediate
#    no_path_retry    fail
#    user_friendly_names    yes
#}
##
## The wwid line &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the following blacklist section is shown as an example
## of how to blacklist devices by wwid. The &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; devnode lines are the
## compiled &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; default blacklist. If you want to blacklist entire types
## of devices, such as all scsi devices, you should use a devnode line.
## However, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; you want to blacklist specific devices, you should use
## a wwid line. Since there is no guarantee that a specific device will
## not change names on reboot (from &lt;/span&gt;/dev/sda to /dev/sdb &lt;span&gt;for&lt;/span&gt;&lt;span&gt; example)
## devnode lines are not recommended &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; blacklisting specific devices.
##
#blacklist {
# wwid 26353900f02796769
#    devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^hd[a-z]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#}
#multipaths {
#    multipath {
#    wwid    3600508b4000156d700012000000b0000
#    alias    yellow
#    path_grouping_policy    multibus
#    path_selector    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    failback    manual
#    rr_weight    priorities
#    no_path_retry    &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
#    }
#    multipath {
#    wwid    1DEC_____321816758474
#    alias    red
#    }
#}
#devices {
#    device {
#    vendor    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COMPAQ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    product    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HSV110 (C)COMPAQ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    path_grouping_policy    multibus
#    path_checker    readsector0
#    path_selector    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    hardware_handler    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    failback    &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
#    rr_weight    priorities
#    no_path_retry    queue
#    }
#    device {
#    vendor    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COMPAQ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    product    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSA1000 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#    path_grouping_policy    multibus
#    }
#}

blacklist {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; (5.1)配置文件黑名单(blacklist部分)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如将 find_multipaths 参数设定为 yes，则您只需要将那些您不想使其具有多路径功能的多路径设备列入黑名单，通常不需要将设备列入黑名单。可以使用三种方法将设备列入黑名单。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;(5.1.1)根据WWID将设备列入黑名单&lt;/strong&gt;&lt;br/&gt;要根据WWID配置黑名单，需要在blacklist中添加WWID条目&lt;br/&gt;例子:将WWID为14f504e46494c4552336b535576772d6f5a556b2d5844746e加入黑名单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist {
       wwid 14f504e46494c4552336b535576772d6f5a556b2d5844746e
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实战过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 1、添加黑名单之前&lt;/span&gt;&lt;br/&gt;[root@testserver ~]# multipath -&lt;span&gt;ll
mpathe (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdc &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdf &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; active ready running
&lt;span&gt;mpathf (14f504e46494c4552336b535576772d6f5a556b2d5844746e&lt;/span&gt;) dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sde &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sdd &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; active ready running&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 2.使用wwid添加黑名单&lt;/span&gt;&lt;br/&gt;[root@testserver &lt;/span&gt;~]# vim /etc/&lt;span&gt;multipath.conf 
blacklist {
       wwid 14f504e46494c4552336b535576772d6f5a556b2d5844746e
}
&lt;br/&gt;&lt;span&gt;# 3.使新添加的黑名单生效&lt;/span&gt;
[root@testserver &lt;/span&gt;~&lt;span&gt;]# service multipathd reload 
Reloading multipathd configuration (via systemctl):        [  OK  ]
&lt;/span&gt;&lt;span&gt;&lt;span&gt;
# 4.再次查看多路径信息，mpathf磁盘已经不在了&lt;/span&gt;&lt;br/&gt;[root@testserver &lt;/span&gt;~]# multipath -&lt;span&gt;ll
mpathe (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdc &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt; active ready running
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdf &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt; active ready running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;NOTE&lt;/span&gt;:如何查看WWID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@testserver ~]# &lt;span&gt;lsscsi -&lt;/span&gt;&lt;span&gt;&lt;span&gt;i&lt;/span&gt;
[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;] disk VMware, VMware Virtual S &lt;span&gt;1.0&lt;/span&gt; /dev/sda -&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;] cd/dvd NECVMWar VMware IDE CDR10 &lt;span&gt;1.00&lt;/span&gt; /dev/sr0 -&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/&lt;span&gt;sdb 14f504e46494c45523838576731322d526231352d73794852
[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/&lt;span&gt;sdd 14f504e46494c4552336b535576772d6f5a556b2d5844746e
[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/&lt;span&gt;sdf 14f504e46494c45526463737145732d426f516a2d6f4c416d
[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/&lt;span&gt;sdc 14f504e46494c45523838576731322d526231352d73794852
[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/&lt;span&gt;sde 14f504e46494c4552336b535576772d6f5a556b2d5844746e
[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;] disk OPNFILER VIRTUAL-DISK &lt;span&gt;0&lt;/span&gt; /dev/sdg 14f504e46494c45526463737145732d426f516a2d6f4c416d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.1.2)根据设备名称将设备列入黑名单&lt;/strong&gt;&lt;br/&gt;要根据设备名称配置黑名单，需要在blacklist中添加devnode条目&lt;br/&gt;例子:将磁盘sdb和sdc加入黑名单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist {
       devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sdb,sdc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实战过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 1.在上一步wwid的基础上添加设备名称黑名单，把sdb、sdc加入黑名单&lt;/span&gt;&lt;br/&gt;[root@testserver ~]# vim /etc/&lt;span&gt;multipath.conf 
blacklist {
       wwid 14f504e46494c4552336b535576772d6f5a556b2d5844746e
}

&lt;span&gt;# 在上面的基础上多添加一个blacklist模块&lt;/span&gt;
blacklist {
       devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sdb|sdc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

&lt;span&gt;# 2.使添加的黑名单生效&lt;/span&gt;&lt;br/&gt;[root@testserver &lt;/span&gt;~&lt;span&gt;]# service multipathd reload 
Reloading multipathd configuration (via systemctl):        [  OK  ]
&lt;/span&gt;&lt;span&gt;&lt;span&gt;
# 3.确认mpathe磁盘，已经识别不到了&lt;/span&gt;&lt;br/&gt;[root@testserver &lt;/span&gt;~]# multipath -&lt;span&gt;ll
Oct &lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; | /etc/multipath.conf line &lt;span&gt;97&lt;/span&gt;&lt;span&gt;, duplicate keyword: blacklist
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdf &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt; active ready running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;NOTE&lt;/span&gt;&lt;/strong&gt;:默认情况下，以下 devnode 条目将会被列入默认黑名单中；因为这些条目而被列入黑名单的设备通常不支持 DM Multipath。如需在这些设备中启用 multipath，则需要在配置文件的 blacklist_exceptions 部分指定这些设备。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist {
devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
devnode &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^(td|ha)d[a-z]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.1.3)根据设备类型将设备列入黑名单&lt;/strong&gt;&lt;br/&gt;要根据设备类型配置黑名单，需要在blacklist中添加device条目&lt;br/&gt;例子:将IBM 3S42存储和惠普的所有存储放入黑名单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist {
       device {
               vendor  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IBM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               product &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3S42&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;#DS4200 Product 10&lt;/span&gt;&lt;span&gt;
       }
       device {
               vendor  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               product &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.2)黑名单之外的设备(blacklist_exceptions部分)&lt;/strong&gt;&lt;br/&gt;如果有大量的设备，但只有一个设备想要设置为多路径，这是可以考虑将所有设备添加到黑名单blacklist中，然后在blacklist_exceptions中单独添加该设备。当在配置文件的 blacklist_exceptions 指定设备时，您必须以指定黑名单的相同方法来指定例外情况。&lt;br/&gt;例子：把所有设备加入黑名单，然后将wwid为14f504e46494c4552336b535576772d6f5a556b2d5844746e的设备添加到黑名单之外&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;blacklist{
       wwid &lt;/span&gt;*&lt;span&gt;
}

blacklist_exceptions {
       wwid 14f504e46494c4552336b535576772d6f5a556b2d5844746e
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实战过程：&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 1.将所有设备添加到黑名单blacklist中，然后在blacklist_exceptions中单独添加wwid为14f504e46494c4552336b535576772d6f5a556b2d5844746e的设备&lt;/span&gt;&lt;br/&gt;[root@testserver ~]# vim /etc/&lt;span&gt;multipath.conf 
blacklist{
       wwid &lt;/span&gt;*&lt;span&gt;
}

blacklist_exceptions {
       wwid 14f504e46494c4552336b535576772d6f5a556b2d5844746e
}

&lt;span&gt;# 2.使配置信息生效&lt;/span&gt;&lt;br/&gt;[root@testserver &lt;/span&gt;~&lt;span&gt;]# service multipathd reload
Reloading multipathd configuration (via systemctl):        [  OK  ]
&lt;br/&gt;&lt;span&gt;# 3.可以看到，只有该wwid的设备能够识别到&lt;/span&gt;
[root@testserver &lt;/span&gt;~]# multipath -&lt;span&gt;ll
mpathf (14f504e46494c4552336b535576772d6f5a556b2d5844746e) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sdd &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; sde &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;&lt;span&gt; active ready running&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.3)配置文件默认(defaults部分)&lt;/strong&gt;&lt;br/&gt;defaults部分时DM Multipath的常规属性配置，通常格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;defaults {
        user_friendly_names     yes
        path_grouping_policy    multibus
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; defaults部分有较多的参数，主要参数有(这里主要记录常用的)：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;polling_interval&lt;/td&gt;
&lt;td&gt;以秒(s)为单位指定两次路径检查的时间间隔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;find_multipaths&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;设定多路径设备的模式。如果这个参数为yes，多路径将不会尝试为不在黑名单中的每个路径都创建设备，而是满足一下3个条件之一才创建设备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于相同WWID设备，在黑名单指定的路径外还有2个或以上的路径&lt;/li&gt;
&lt;li&gt;用户通过使用multipath命令指定设备强制创建该设备&lt;/li&gt;
&lt;li&gt;路径拥有与之前创建的多路径设备相同的WWID。无论何时使用 find_multipaths 组件创建多路径设备后，多路径都会记住该设备的 WWID 以便在再次看到使用那个 WWID 的路径时自动创建设备。这可让您自动选择正确的所路径创建多路径设备而无需编辑多路径黑名单。&lt;/li&gt;
&lt;/ul&gt;
默认为no。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;path_selector&lt;/td&gt;
&lt;td&gt;指定I/O所使用路径算法，可能的值包括
&lt;ul&gt;&lt;li&gt;round-robin 0:在路径中循环使用每个路径，像每个路径发送同样的I/O，默认；&lt;/li&gt;
&lt;li&gt;queue-length 0:将下一组I/O请求发送到I/O队列最短的路径；&lt;/li&gt;
&lt;li&gt;service-time 0:将下一组 I/O 发送到具有最短预计服务时间的路径&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;path_grouping_policy&lt;/td&gt;
&lt;td&gt;用于指定分组策略，我的理解为指定多路径为active/active还是active/standby模式
&lt;ul&gt;&lt;li&gt;failover:每个优先组群有一个路径。默认&lt;/li&gt;
&lt;li&gt;multibus:所有有效路径在一个优先组中&lt;/li&gt;
&lt;li&gt;group_by_serial:每个检测到的系列号有一个优先组群&lt;/li&gt;
&lt;li&gt;group_by_prio:每个优先组群有一个路径优先值。优先权根据指定为 global、per-controller 或者 per-multipath 选项的调用程序决定&lt;/li&gt;
&lt;li&gt;group_by_node_name：每个目标节点名有一个优先组&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;failback&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;管理路径群组出错切换，值有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;immediate:立即恢复到包含活跃路径的最高级别路径组群&lt;/li&gt;
&lt;li&gt;manual:不需要立即恢复，只有在操作者干预的情况下发生恢复。默认&lt;/li&gt;
&lt;li&gt;followover:指定当路径组的第一个路径成为活跃路径时应执行自动恢复。这可让节点在另一个节点请求故障修复时不会自动恢复。&lt;/li&gt;
&lt;li&gt;大于0的数字值指定推迟出错切换时间，以秒(s)表示。&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;user_friendly_names&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;ul&gt;&lt;li&gt;如果设置为yes，则该操作系统会使用文件/etc/multipath/bindings为该多路径分配一个持久且唯一的别名，格式为mpath n&lt;/li&gt;
&lt;li&gt;如果为no，则该系统使用WWID作为多路径的别名。默认&lt;/li&gt;
&lt;li&gt;在这两种情况下，你在这里指定的数值将被你在配置文件multipaths部分指定的别名覆盖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NOTE&lt;/strong&gt;&lt;/span&gt;:如果为yes，多路径别名与wwid的关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@testserver ~]# &lt;span&gt;cat&lt;/span&gt; /etc/multipath/&lt;span&gt;bindings 
&lt;span&gt;... 略 ...&lt;/span&gt;
mpathe 14f504e46494c45523838576731322d526231352d73794852
mpathf 14f504e46494c4552336b535576772d6f5a556b2d5844746e
mpathg 14f504e46494c45526463737145732d426f516a2d6f4c416d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;checker_timeout&lt;/td&gt;
&lt;td&gt;路径检查器和排序器执行带显式超时SCSI命令的超时时间，以秒(s)为单位。默认是/sys/block/sdc/device/timeout的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;force_sync&lt;/td&gt;
&lt;td&gt;如果将其设置为yes,则会阻止路径检查程序在异步(async)模式下运行。默认值为no。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;NOTE&lt;/span&gt;&lt;/strong&gt;:path_grouping_policy这个参数我的理解是用来做多路径的路径访问方式的，简单来说就是多条路径是以active/active这种负载均衡的方式工作，还是以active/standby这种链路冗余的方式工作，我们不妨测试一下具体值的效果：&lt;/p&gt;
&lt;p&gt;(1)当 path_grouping_policy=failover时，路径为active/standby&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@testserver lib]# multipath -&lt;span&gt;ll
Oct &lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt; | /etc/multipath.conf line &lt;span&gt;96&lt;/span&gt;&lt;span&gt;, duplicate keyword: defaults
mpathe (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;&lt;span&gt;enabled&lt;/span&gt;
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdc &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt; active ready running
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; (2)当 path_grouping_policy=multibus时，路径为active/active&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@testserver lib]# multipath -&lt;span&gt;ll
Oct &lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt; | /etc/multipath.conf line &lt;span&gt;96&lt;/span&gt;&lt;span&gt;, duplicate keyword: defaults
mpathe (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;|- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdc &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt; active ready running
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.4)多路径设备配置属性(multipaths部分)&lt;/strong&gt;&lt;br/&gt;在multipath.conf配置文件multipaths部分可为每个多路径设备设置(可以理解为一个多路径磁盘)的属性，这些属性只适用于一个特定的multipath。这部分有较多的参数属性，其中大部分参数都与上面的defaults部分重合，这里只介绍2个参数。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;wwid&lt;/td&gt;
&lt;td&gt;指定使用multipath属性的多路径设备的符号名称，这个参数在multipath部分是必须的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;alias&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;指定使用multipath属性的多路径设备的符号名称，如果使用了user_friendly_names,这里不要将别名设置为mpath n,这样可能会与自动分配的友好用户名冲突，进而给出不正确的设备节点名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 实战过程：&lt;/p&gt;
&lt;p&gt;将wwid为14f504e46494c45523838576731322d526231352d73794852的存储名称从mpathe改为datadisk1,以便于用户识别，将路径选择方式改为failover&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 1.添加multipaths之前的多路径信息&lt;/span&gt;&lt;br/&gt;[root@testserver device]#&lt;span&gt; multipath -&lt;/span&gt;&lt;span&gt;&lt;span&gt;ll&lt;/span&gt;
Oct &lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; | /etc/multipath.conf line &lt;span&gt;96&lt;/span&gt;&lt;span&gt;, duplicate keyword: defaults
&lt;span&gt;mpathe&lt;/span&gt; (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;span&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
  &lt;/span&gt;|- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sde &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; active ready running&lt;/span&gt;
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
  &lt;/span&gt;|- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdd &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; active ready running
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt;&lt;span&gt; active ready running

&lt;span&gt;# 2.添加multipaths部分信息&lt;/span&gt;
[root@testserver &lt;/span&gt;~]# &lt;span&gt;vim /etc/&lt;/span&gt;&lt;span&gt;&lt;span&gt;multipath.conf&lt;/span&gt; 
multipaths {
       multipath {
              &lt;span&gt;wwid                  14f504e46494c45523838576731322d526231352d73794852&lt;/span&gt;
              &lt;span&gt;alias                 datadisk1&lt;/span&gt;
              &lt;span&gt;path_grouping_policy  failover&lt;/span&gt;
              path_selector         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
              failback              manual
              rr_weight             priorities
              no_path_retry         &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
       }
}

&lt;span&gt;# 3.使配置信息生效&lt;/span&gt;
[root@testserver &lt;/span&gt;~&lt;span&gt;]# &lt;span&gt;service multipathd reload&lt;/span&gt;
Reloading multipathd configuration (via systemctl):        [  OK  ]
[root@testserver &lt;/span&gt;~]# vim /etc/&lt;span&gt;multipath.conf 

&lt;span&gt;# 4.查看修改之后的多路径信息&lt;/span&gt;
[root@testserver device]# &lt;span&gt;multipath &lt;/span&gt;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&lt;span&gt;ll&lt;/span&gt;
Oct &lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;45&lt;/span&gt; | /etc/multipath.conf line &lt;span&gt;96&lt;/span&gt;&lt;span&gt;, duplicate keyword: defaults
&lt;span&gt;datadisk1&lt;/span&gt; (14f504e46494c45523838576731322d526231352d73794852) dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;.0G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 queue_if_no_path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
&lt;/span&gt;&lt;span&gt;|-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
&lt;/span&gt;| `- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sdb &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt; active ready running
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;round-robin 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;enabled
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt; sde &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; active ready running&lt;/span&gt;
mpathg (14f504e46494c45526463737145732d426f516a2d6f4c416d) dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK    
size&lt;/span&gt;=10G features=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hwhandler=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; wp=&lt;span&gt;rw
`&lt;/span&gt;-+- policy=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;service-time 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; prio=&lt;span&gt;1&lt;/span&gt; status=&lt;span&gt;active
  &lt;/span&gt;|- &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdd &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; active ready running
  `&lt;/span&gt;- &lt;span&gt;4&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt; sdg &lt;span&gt;8&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt;&lt;span&gt; active ready running


&lt;span&gt;# 5.通过fdisl -l也可以看到磁盘名称已经发生变化&lt;/span&gt;
[root@testserver device]# fdisk &lt;/span&gt;-&lt;span&gt;l
...
Disk &lt;/span&gt;&lt;span&gt;/dev/mapper/datadisk1&lt;/span&gt;: &lt;span&gt;1073&lt;/span&gt; MB, &lt;span&gt;1073741824&lt;/span&gt; bytes, &lt;span&gt;2097152&lt;/span&gt;&lt;span&gt; sectors
Units &lt;/span&gt;= sectors of &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;512&lt;/span&gt; = &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
Sector size (logical&lt;/span&gt;/physical): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt;&lt;span&gt; bytes
I&lt;/span&gt;/O size (minimum/optimal): &lt;span&gt;512&lt;/span&gt; bytes / &lt;span&gt;512&lt;/span&gt; bytes
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(5.5)多路径存储设备属性(devices部分)&lt;/strong&gt;&lt;br/&gt;在multipath.conf配置文件devices部分可为每个存储设备设置(可以理解为存储厂商的一款存储产品)的属性。多路径配置中默认包含许多的存储产品，要查看已经包含了哪些存储产品，可以使用以下查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;multipathd show config
&lt;span&gt;# 或者&lt;/span&gt;
multipath &lt;/span&gt;-t
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 正常情况下，无需修改这些存储设备的默认值，如果想要修改可以在配置文件的devices部分添加条目来覆盖修改。对于不在multipath默认里面的存储设备，也可以在devices部分手动添加一个设备。&lt;/p&gt;
&lt;p&gt;这部分有较多的参数属性，其中大部分参数都与上面的defaults、multipaths部分重合，这里只介绍几个参数。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ventor&lt;/td&gt;
&lt;td&gt;存储设备厂商名称，可查看/sys/block/sdc/device/vendor&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;product&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;存储设备产品名称，可查看/sys/block/sdc/device/model&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;alias_prefix&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;这个设备使用的user_friendly_name前缀，而不是默认的mpath。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;参考配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;device {
        vendor            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COMPAQ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        product            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSA1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        path_grouping_policy    multibus
        path_checker        tur
        rr_weight        priorities
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;(六)设备映射多路径软件管理及故障排除&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;(6.1)multipathd启动与关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;multipathd启动与关闭命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@testserver mapper]# service multipathd 
Usage: &lt;/span&gt;/etc/init.d/multipathd {start|stop|force-stop|status|restart|force-restart|condrestart|&lt;span&gt;reload}

&lt;span&gt;# 启动&lt;/span&gt;
service multipathd start

&lt;span&gt;# 关闭&lt;/span&gt;
service multipathd stop

&lt;span&gt;# 重新启动&lt;/span&gt;
service multipathd restart

&lt;span&gt;# 不重启multipathd使修改的参数生效&lt;/span&gt;
service multipathd reload &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(6.2)multipath命令&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt; 描述&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-l &lt;/td&gt;
&lt;td&gt;显示来自 sysfs 和设备映射器的当前多路径配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;-ll&lt;/td&gt;
&lt;td&gt;显示来自 sysfs 、设备映射器以及系统中其他所有可用组件的当前多路径配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;device 删除命名的多路径设备&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;删除所有不使用的多路经设备&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;device 从 wwids 文件中删除指定设备的 wwid。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-W&lt;/td&gt;
&lt;td&gt;重新设定 wwids 文件使其只包含当前 multipath 设备&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;(6.3)multipathd命令&lt;/strong&gt;&lt;br/&gt;可以使用multipathd命令管理multipathd守护进程。关于multipathd命令的使用，可以使用命令&quot;man multipathd&quot;查看手册，或者使用&quot;multipathd show&quot;命令也会有提示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@testserver mapper]# &lt;span&gt;multipathd show maps format &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%n %w %d %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
name uuid sysfs vend&lt;/span&gt;/prod/&lt;span&gt;rev 
datadisk1 14f504e46494c45523838576731322d526231352d73794852 dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
mpathf 14f504e46494c4552336b535576772d6f5a556b2d5844746e dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt; OPNFILER,VIRTUAL-&lt;span&gt;DISK 
mpathg 14f504e46494c45526463737145732d426f516a2d6f4c416d dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; OPNFILER,VIRTUAL-DISK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; multipath -k命令是multipathd守护进程的交互式界面，使用help命令帮助，使用Ctrl+D命令退出交互&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@testserver mapper]# &lt;span&gt;&lt;strong&gt;multipathd &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/span&gt;
multipathd&lt;/span&gt;&amp;gt;&lt;span&gt;&lt;span&gt; help&lt;/span&gt;
multipath&lt;/span&gt;-tools v0.&lt;span&gt;4.9&lt;/span&gt; (&lt;span&gt;05&lt;/span&gt;/&lt;span&gt;33&lt;/span&gt;, &lt;span&gt;2016&lt;/span&gt;&lt;span&gt;)
CLI commands reference:
list&lt;/span&gt;|&lt;span&gt;show paths
list&lt;/span&gt;|&lt;span&gt;show paths format $format
&lt;span&gt;... 略 ...&lt;/span&gt;
map&lt;/span&gt;|&lt;span&gt;multipath $map unsetprkey
forcequeueing daemon
restorequeueing daemon
multipathd&lt;/span&gt;&amp;gt;&lt;span&gt;&lt;span&gt; show maps&lt;/span&gt;   &lt;span&gt; #查看映射关系&lt;/span&gt;
name sysfs uuid 
datadisk1 dm&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 14f504e46494c45523838576731322d526231352d73794852
mpathf dm&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt; 14f504e46494c4552336b535576772d6f5a556b2d5844746e
mpathg dm&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt; 14f504e46494c45526463737145732d426f516a2d6f4c416d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(6.4)使用dmsetup命令查看设备映射条目&lt;/strong&gt;&lt;br/&gt;使用dmsetup找出操作系统内存设备映射条目与多路径设备的映射关系。以下命令显示所有映射设备及其主副号码，副号确定dm设备的名称，例如datadisk1的副号码为3，则datadisk1与/dev/dm-3对映。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@testserver ~]# &lt;span&gt;&lt;strong&gt;dmsetup ls&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
datadisk1    (253:3&lt;span&gt;)
centos-home    (253:2&lt;span&gt;)
mpathg    (253:5&lt;span&gt;)
mpathf    (253:4&lt;span&gt;)
centos-swap    (253:1&lt;span&gt;)
centos-root    (253:0)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设备映射关系也可以从这查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@testserver block]#&lt;span&gt; cd /dev/mapper/&lt;/span&gt;&lt;span&gt;
[root@testserver mapper]# ll
total 0&lt;span&gt;
lrwxrwxrwx. 1 root root 7 Oct 28 15:48 centos-home -&amp;gt; ../dm-2&lt;span&gt;
lrwxrwxrwx. 1 root root 7 Oct 28 15:48 centos-root -&amp;gt; ../dm-0&lt;span&gt;
lrwxrwxrwx. 1 root root 7 Oct 28 15:48 centos-swap -&amp;gt; ../dm-1&lt;span&gt;
crw-------. 1 root root 10, 236 Oct 28 15:48&lt;span&gt; control
lrwxrwxrwx. 1 root root 7 Oct 28 15:54 datadisk1 -&amp;gt; ../dm-3&lt;span&gt;
lrwxrwxrwx. 1 root root 7 Oct 28 15:54 mpathf -&amp;gt; ../dm-4&lt;span&gt;
lrwxrwxrwx. 1 root root 7 Oct 28 15:54 mpathg -&amp;gt; ../dm-5&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 【完】&lt;/p&gt;

</description>
<pubDate>Wed, 28 Oct 2020 14:22:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<og:description>(一)多路径管理软件的由来 在企业中，服务器与存储通常是分开放置的，服务器上的硬盘通常用来安装操作系统和应用软件，业务数据则是存储在单独的存储设备上，那么，服务器与存储是如何连接的呢？根据存储协议，经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lijiaman/p/13893346.html</dc:identifier>
</item>
</channel>
</rss>