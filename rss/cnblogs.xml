<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【设计模式】牛掰格拉斯的代理模式 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/a-post-about-designpattern-of-proxy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-post-about-designpattern-of-proxy.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
代理的本质&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论任何时候，只要谈到设计模式，大脑中一定要蹦出这四个字“活学活用”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想对某个事物做到活学活用，必须要对它足够了解，甚至要剖析到本质才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总是会有些人说，我干嘛要知道原理，干嘛要去看源码？&lt;/span&gt;&lt;span&gt;会用就行了。&lt;/span&gt;&lt;span&gt;对于这种情况，我只有五个字相送，“你开心就好”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可否认，认识一个陌生事物，大部分情况还是要从定义开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;为某对象提供一种代理以控制对该对象的访问，从而限制、增强或修改该对象的一些特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果对代理模式本身就很熟悉的人，一眼就明白什么意思，甚至连代码怎么写都会浮现在脑海中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键是对代理模式一点都不熟悉的人，看到定义后绝对一脸懵。&lt;/span&gt;&lt;span&gt;下面通过简单的图形来揭开迷惑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有使用代理模式，如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143049096-1771404983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;源&lt;/span&gt;&lt;span&gt;”直接访问“&lt;/span&gt;&lt;span&gt;目标&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用了代理模式，如下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143100943-1619212745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;源&lt;/span&gt;&lt;span&gt;”访问&lt;/span&gt;&lt;span&gt;代理&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;代理&lt;/span&gt;&lt;span&gt;访问“&lt;/span&gt;&lt;span&gt;目标&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人群中一定会有两种声音：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）设计模式是很高深莫测的东西，有这么简单吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）这怎么没有代码实现啊？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来听听作者的看法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;高深莫测和简单不一定都是对冲的。幸福绝对是高深莫测的，那什么是幸福呢，最多的答案恐怕就是，“一亩土地两头牛，老婆孩子热炕头”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多么简单朴实的答案，可惜，包括我在内的很多人都追求不到。主要原因是我们人为（主观）的把很多事情搞复杂了。下面这个事情可以说明这一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中秋节放假时到附近的一个小景区去看一看，我发现有一种果树的果子挂满枝头，又大又圆，让人看了之后特别有欲望，甚至垂涎欲滴，可惜没有一个人去摘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的第一反应就是果子肯定不能吃。过了一会儿，终于抑制不住好奇心，就找了一个比较矮的果树，摸了摸枝头上的果子。果然硬如磐石。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;对于一上来就说代码实现的人，只能认为是你拥有了一把锤子之后，看什么都像钉子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码实现永远都是最后一步，但在它之前，要找出问题，分析问题，给出方案，论证方案可行性。如果这些都OK了，代码就是水到渠成的事了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;记住&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这句话：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;认清原理，搞清本质，永远都是最重要的，不单单是在写代码上，在社会上依然如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那代理的本质是什么呢？就两个字，“&lt;/span&gt;&lt;span&gt;加层&lt;/span&gt;&lt;span&gt;”，即&lt;/span&gt;&lt;span&gt;增加一（多）层&lt;/span&gt;&lt;span&gt;。这就是本质。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像其它的什么“控制访问”啦，“增强或修改特性”啦，只不过是这个“层&quot;产生的一些（副）作用罢了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生活中充满着代理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然大部分人都没有参与过诉讼，但作为常识我们都知道，当事人可以通过协议把自己的一些权力授权给律师，律师就可以在法庭上行使这些权利，此时律师就是代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在网购已成为生活的一部分，但是收快递却比较麻烦，因为通常家中无人。此时菜鸟驿站（或妈妈驿站）出现了，它帮我们签收和暂存包裹，所以它就是代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在生活压力大，每个人都要上班，所以中午和下午都没有时间去接送自己上小学的孩子，此时只能选择午托，我们交了托费之后就等于给了它授权，它代替我们去接送孩子，可见午托也是代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有各种产品的代理商，有大区代理，省级代理，市级代理，等等。还有就是微商/代购，微商自己没有货品，只是发发朋友圈，最终是别人发货。代购就更直接了，代替你去购买，然后再邮寄给你。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明星艺人都有自己的经纪人，可以替自己接一些活动，讨价还价，安排日程等。此时经纪人就是代理。还有大BOSS也会请一到多个秘书，来代替自己做一些事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见，生活中充满着很多代理，他们以各种各样的形式存在着，发挥着各种各样的功能和作用，也确实解决了很多社会和生活的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但从本质来看，代理大都以“层”的形式呈现，站在老板的前面，替老板做事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;和计算机相关的代理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分人可能都听过这样一句话，&lt;/span&gt;&lt;span&gt;凡是遇到不好解决的问题，大都可以通过加一层得到有效的解决。&lt;/span&gt;&lt;span&gt;加的这个层很多时候和代理有关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了网络安全问题，可以加一层防火墙，防火墙虽然不完全是代理，但却用到许多代理的理论和技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了扩充本地局域网络，可以加一层交换机或路由器，它用来代理和转发网络请求。还会有一些附带的其它功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了平衡多个服务器的处理能力，我们在前面加一个请求路由层，也就是负载均衡器了，如Nginx，它可以代理请求，并按规则转发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说说CRUD，原来是我们写代码直接使用JDBC访问数据库，现在我们写代码使用的是ORM框架，ORM框架再使用JDBC去访问数据库。ORM框架可以看作是JDBC的代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到，从硬件到中间件，再到程序框架，都有代理的影子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;和编程相关的代理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面所说的代理，都是广义的代理，主要侧重于角色和功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦在编程中谈到代理，基本就是狭义代理了。除了广义代理的要求外，还要保持&lt;/span&gt;&lt;span&gt;类型的兼容和“接口”的一致&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说白了就是需要被代理对象的地方，给它一个代理也可以。可以在被代理对象上调用的方法，在代理上也可以调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个要求和代理模式中的要求是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果被代理的对象是一个类。我们用&lt;/span&gt;&lt;span&gt;Target&lt;/span&gt;&lt;span&gt;表示。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Target&lt;/span&gt; {&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getDateTime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;2019-10-09&quot;&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;为了保持类型兼容和接口一致，我们需要生成一个子类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外还要有被代理的对象，所以还需一个成员变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了添加一些功能，通常需要重写一些方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code readability=&quot;3&quot;&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Target&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;private&lt;/span&gt; Target target;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getDateTime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; target.getDateTime() + &lt;span&gt;&quot;, 星期三&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这样就生成了一个代理，在需要Target的地方换成Proxy也没有问题，而且还会在日期后面加上星期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果被代理的对象是一个接口。我们用&lt;/span&gt;&lt;span&gt;ITarget&lt;/span&gt;&lt;span&gt;表示。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ITarget&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;String&lt;/span&gt; sayHello(&lt;span&gt;String&lt;/span&gt; name);&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;pre readability=&quot;4&quot;&gt;
&lt;code readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Target&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ITarget&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello &quot;&lt;/span&gt; + name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;此时我们只需实现接口即可（当然也可以生成子类），其它的保持不变。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ITarget&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span&gt;private&lt;/span&gt; ITarget target;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; target.sayHello(name) + &lt;span&gt;&quot;, long time no see.&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这也是一个代理，同样可以使用Proxy代替Target，而且在原来问好的基础上增加了更多的话语。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于类型兼容且接口一致，所以用户代码有时也不知道到底是对象本身还是它的代理，不过这通常并不重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代理的好处我们已经看到了，但是也有不好的地方，就是要写代理的代码，造成代码量增加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个问题已经通过动态代理解决了。在Java里比较有名的动态代理，就是&lt;/span&gt;&lt;span&gt;JDK动态代理&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CGLIB代理&lt;/span&gt;&lt;span&gt;。这大家都知道了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;全文总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代理的本质就是通过加一层来解决问题。类型兼容和接口一致只是限制条件而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代理有着广泛的应用，想想Spring的成功，代理贡献了多少，绝对功不可没。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仔细体会下“&lt;/span&gt;&lt;span&gt;加层&lt;/span&gt;&lt;span&gt;”的含义，在代码中和生活中，你会发现它真的很牛掰格拉斯。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 玩转SpringBoot系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484558&amp;amp;idx=1&amp;amp;sn=6da1a74d280f4f2a41cbf5874ed620e0&amp;amp;chksm=fc333f7ecb44b668f8d18be8efa436d8052d98874f843a8edf314141c7a4bb4bcb2345ab5ae4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【玩转SpringBoot】配置文件yml的正确打开姿势&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484588&amp;amp;idx=1&amp;amp;sn=2b790b38aab1d1f6818c078a52b69553&amp;amp;chksm=fc333f5ccb44b64afcb7a9cabe51edefbb4f4123f6324ae3e1b2545f97ef8c9a2fb49e8a560e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【玩转SpringBoot】用好条件相关注解，开启自动配置之门&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484604&amp;amp;idx=1&amp;amp;sn=e999dadf378e3da42b05b99f8df00dc9&amp;amp;chksm=fc333f4ccb44b65a7a3cfd6f3261c9eef1d21b8f4e1a3d8358778fda7d3e98f806b271ce4886&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【玩转SpringBoot】给自动配置来个整体大揭秘&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484319&amp;amp;idx=1&amp;amp;sn=89d925e6128109444c2ec40111a9f217&amp;amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：负责bean定义注册的两个“排头兵”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=398a1f718cc8b5a711ba9f45a6d9074b&amp;amp;chksm=fc333841cb44b157da33d685daedda001cb59abb64aa6152c3d4096d43c8d92bff8ae5d084ed&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot轻松取胜bean定义注册的“第一阶段”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484358&amp;amp;idx=1&amp;amp;sn=21fc717c7815ae41103e3e2e4f5520df&amp;amp;chksm=fc333836cb44b120fd9073b6075580109d5665afbd0f50abe43e8a5aea42e066c759dcdb8157&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot发起bean定义注册的“二次攻坚战”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484369&amp;amp;idx=1&amp;amp;sn=ac9d591014074f49a96bc9f3ed7cca4a&amp;amp;chksm=fc333821cb44b137f3c0c7c24b88fc5b3edfa0dc530366b884a3813759ae6fb32c1974e506de&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解之王@Configuration和它的一众“小弟们”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484403&amp;amp;idx=1&amp;amp;sn=f10760d51119f91b5c18d3267ebbd1eb&amp;amp;chksm=fc333803cb44b115a6fcab3e264233514f90fd8874f038361aaa174e8c73bb7f2a31d96f9099&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean工厂后处理器的调用规则&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484414&amp;amp;idx=1&amp;amp;sn=16391934efdc318c65251d311a6cc61c&amp;amp;chksm=fc33380ecb44b1183af1d82647996fb5ec24a3cc977b028671cb62f91edcc421542e92ecbe92&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：详细解说bean后处理器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=29a6cc3aa9959c04512864ee59365f6b&amp;amp;chksm=fc333fffcb44b6e9cce30ca85ee1c8a32fd5e5597cd27d45a1c1a6bc3bd59b004df3cc66ea22&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@PostConstruct和@PreDestroy注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484448&amp;amp;idx=1&amp;amp;sn=dc0e6d9b0ddd8168d749b90069999c03&amp;amp;chksm=fc333fd0cb44b6c68127c6a1e8b9c91891ef4ee37df40e7c85d2b67bd058d3c59e5e51d06101&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Resource注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484462&amp;amp;idx=1&amp;amp;sn=d492ff48764329f37abd452b0b4e1287&amp;amp;chksm=fc333fdecb44b6c8b6634ac340a63c9271d22a08e53d3adaeef5e487658a425122b45f84fd20&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Autowired和@Value注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=98e154a00e7782ec8fb9ca2d6295dfcd&amp;amp;chksm=fc333fa9cb44b6bf0283da8353aba4cca8267315c91e18765dfebc4aa70da96394b9b374e078&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：真没想到，三十步才能完成一个bean实例的创建&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484532&amp;amp;idx=1&amp;amp;sn=09a007062e2d5835a253f14f9269d9b0&amp;amp;chksm=fc333f84cb44b692b4db0a7140776eefe746f52ca03bd522582d35752fc3ed3ff5eb6087feb8&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：关于@Scheduled定时任务的思考与探索，结果尴尬了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143150023-1391521187.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 25 May 2020 00:30:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>代理的本质无论任何时候，只要谈到设计模式，大脑中一定要蹦出这四个字“活学活用”。要想对某个事物做到活学活用，必须要对它足够了解，甚至要剖析到本质才行。总是会有些人说，我干嘛要知道原理，干嘛要去看源码？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/a-post-about-designpattern-of-proxy.html</dc:identifier>
</item>
<item>
<title>仿开源框架从零到一完整实现高性能、可扩展的RPC框架 | 6个月做成教程免费送 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/12952780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/12952780.html</guid>
<description>&lt;p&gt;去年年就在写一本付费小册，今年年初基本上就写完了，本来预计计划是春节上线结果由于平台的原因一直拖着没上。五一前跟平台联系给的反馈是五月份能上，结果平台又在重构，停止小册的申请和上线，最后我考虑了一下决定这本书免费放出来，书名是《跟着顶级项目学编程》，关注公众号 &lt;strong&gt;渡码&lt;/strong&gt; 回复关键字 &lt;strong&gt;manis&lt;/strong&gt;，可获取电子书+源码+读者交流群。下面给大家介绍下。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;19年上半年，我阅读了Hadoop RPC模块的源代码，读完后发现这个模块设计的非常好，与其他模块无耦合，完全可以独立出来当成一个独立的框架。为了总结学到的编程知识，同时也为了学习Apache顶级开源项目的代码是如何编写的，我便把它做成了电子书，共350页，从写代码到做成电子书共花了6个月的时间。本来想做成付费专栏赚点小钱，并且已经到了上架阶段了，但后来决定把它免费开放出来，让更多的人能够学习到优秀的实战项目。&lt;/p&gt;
&lt;p&gt;当然我们这本书并不是源码分析类教程，而是强调动手能力。在这里我会带着大家按照 Hadoop RPC 源码从 0 到 1 完整敲一遍，代码量在 4600 行左右。为了让不熟悉 Hadoop 或 RPC 的朋友也能够学习，我将 Hadoop RPC 稍微做了一点改造，赋予了新的业务含义，也有自己的名字，叫 Manis。Mnias 源码相比于 Hadoop RPC源码还原度为90%。为什么不是100%呢？一方面为了突出重点，我会把不太重要、不是很核心的技术舍弃掉。另一方面为了符合新的业务定义，我会做一些改进，而不是照搬完全 Hadoop RPC。&lt;/p&gt;
&lt;p&gt;虽然这个项目是实现 RPC 功能，但我觉得我们关注的重点不应该过多地放在 RPC 本身，而应该重点学习编写 RPC 过程中所涉及的系统设计、面向对象设计思想和原则、工程/代码规范、客户端开发、服务端开发、网络编程、多线程、并发编程、设计模式、异常处理等核心知识，可以说是麻雀虽小五脏俱全。尤其是对于刚学习 Java 还没有接触线上实战项目的朋友，这是一次很好的练兵机会。&lt;/p&gt;
&lt;p&gt;学习开源项目的一个优势在于它是经过线上检验的，Hadoop集群规模最大达到上万台服务端，足以证明它的 RPC 模块是优秀的。另外一个好处是可以积累顶级开源项目的开发经验，大到架构设计，小到设计模式、代码规范，说不定日后就能为开源社区贡献代码了。所以，学会了 Manis 后，不但有编写实战项目的经验，同时也有能力阅读 Hadoop RPC 的源码，这也算是面试的加分项。&lt;/p&gt;
&lt;h2 id=&quot;涉及到的核心技术&quot;&gt;涉及到的核心技术&lt;/h2&gt;
&lt;p&gt;下面我们来介绍一下 Manis 中涉及的核心技术点。作为一个 RPC 框架，最关键的几个模块是客户端、网络模块和服务端&lt;/p&gt;
&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;
&lt;p&gt;作为客户端来说，它的职责非常明确，以数据库客户端为例，它的职责就是向用户提供增删改查接口，并将相应的请求发送给服务端，接收结果并返回给用户。由于客户端职责边界是非常明确的，所以我们从设计上就要将其与网络模块、与服务端解耦，解耦的方式就要用到设计模式中的&lt;strong&gt;代理模式&lt;/strong&gt;。也就说客户端只需要定义好它需要提供的功能（接口）并提供给用户，具体如何实现就交给&lt;strong&gt;代理&lt;/strong&gt;，至于&lt;strong&gt;代理&lt;/strong&gt;是通过网络发送给服务端还是通过其他什么方式客户端就不需要关心了，客户端只关心调用&lt;strong&gt;代理&lt;/strong&gt;并拿结果。这样做的好处是客户端与其他模块解耦，提高了系统扩展性。当然，&lt;strong&gt;代理模式&lt;/strong&gt;还有个容易被忽略的好处是它天然地适合用在 RPC 场景。&lt;/p&gt;
&lt;p&gt;Manis 中支持多种序列化/反序列化方式，每种序列化方式对应一个类，它们都继承共同的基类。我们在设计时需要做到不同序列化方式之间的代码是解耦的，且序列化/反序列化模块与客户端模块、与网络模块是解耦的，这样才能做到任意地增加新的新的序列化方式以及删除老的序列化方式。为了实现客户端与序列化/反序列化模块的松耦合，我们需要用到一些&lt;strong&gt;设计模式&lt;/strong&gt;，比如，用&lt;strong&gt;适配器&lt;/strong&gt;模式将客户端定义的请求接口适配到不同序列化协议定义的请求接口。这样做几乎不需要修改现有的代码，符合面向对象的&lt;strong&gt;开闭原则&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;网络模块&quot;&gt;网络模块&lt;/h3&gt;
&lt;p&gt;下面再来说说网络模块。&lt;/p&gt;
&lt;p&gt;由于客户端的请求可能来自不同的序列化协议，但的目的是相同的，都是为了通过网络模块的服务端，可以说是&lt;strong&gt;殊途同归&lt;/strong&gt;。这样的话，我们就有必要在网络这一层定义一个统一的协议（接口），让不同序列化方式都遵循相同的协议（接口），那么网络模块就可以对它们“一视同仁”，编写一套代码就可以了。就好比，不管你用U盘还是硬盘，只要是 USB 接口，那都能插到电脑的同一个接口进行相同的读写逻辑。对于服务端的返回值也是采用同样的处理逻辑。&lt;/p&gt;
&lt;p&gt;网络模块必不可少的功能就是发送网络请求，当然除了这个还有一个更核心的功能是管理网络资源。听起来有点抽象，如果用面向对象的思想来理解，其实就是创建一个类代表网络连接，比如就叫&lt;code&gt;Connection&lt;/code&gt;类，每次创建一个网络连接其实就是创建一个&lt;code&gt;Connection&lt;/code&gt;对象。当然，我们知道网络资源比较宝贵且创建成本较高，当系统客户端请求量非常大的时候，我们不可能为每次请求都创建一个网络连接，所以，需要建立一个网络连接池，以达到复用网络资源的目的。我们可以再定义一个类&lt;code&gt;ConnectionId&lt;/code&gt;，每个&lt;code&gt;ConnectionId&lt;/code&gt;对象都唯一代表&lt;code&gt;Connection&lt;/code&gt;对象，&lt;code&gt;ConnectionId&lt;/code&gt;的属性包含&lt;strong&gt;服务端地址&lt;/strong&gt;和&lt;strong&gt;请求网络的一些参数&lt;/strong&gt;，所以我们可以认为客户端请求服务端的地址和参数相同的话，就可以复用同一个网络连接。当然，这里还有一个很关键的问题不容忽视，网络连接池是公共资源，为了保证线程安全，在对资源池读写时需要加锁，也是从这里开始本书加大了对&lt;strong&gt;并发编程&lt;/strong&gt;的相关讲解。刚刚介绍的这部分在 Manis 中是自主实现的。&lt;/p&gt;
&lt;p&gt;建立网络连接的过程中还会涉及发送请求头、请求上下文，装饰网络输入、输出流等功能，这些比较偏业务，这里就不再赘述了。&lt;/p&gt;
&lt;p&gt;发送网络请求时，为了将业务代码与发送请求代码剥离，在 Manis 创建了一个建线程池，将发送发送请求的代码封装成线程，丢到线程池中等待执行。所以，这里又涉及到三部分知识&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;strong&gt;工厂模式&lt;/strong&gt;创建线程池，并用&lt;strong&gt;单例模式&lt;/strong&gt;保证不被重复创建&lt;/li&gt;
&lt;li&gt;使用Java的&lt;strong&gt;Executor&lt;/strong&gt;和&lt;strong&gt;Future&lt;/strong&gt;，用来创建任务并等待返回&lt;/li&gt;
&lt;li&gt;对线程池的读写保证&lt;strong&gt;线程安全&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，网络模块要实现的是等待服务端返回的结果。由于网络模块同一时间会接收大量客户端网络请求，所以，我们可以创建一个单独的线程，每隔一定时间轮询是否有服务端的返回。&lt;/p&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;p&gt;对于服务端来说，我们最关心的是性能问题。因为大量的客户端请求最终都会汇总到服务端一个节点来处理。所以最原始的&lt;strong&gt;单线程+while循环&lt;/strong&gt;的方式肯定满足不了性能要求。所以比较最容易想到的改进点是&lt;strong&gt;多线程&lt;/strong&gt;，虽然在一定程度上能解决第一种方式带来的问题，但这种方式也有很大的缺点：频繁创建线程成本比较大，并且线程之间的切换也需要一定的开销，当线程数过多时显然会降低服务端的性能。目前比较常用的解决方案是&lt;strong&gt;Reactor模式&lt;/strong&gt;，&lt;strong&gt;Reactor模式&lt;/strong&gt;也分为单线程Reactor、多线程Reactor和多Reactor。这几种的区别在书里都有具体说明，这里我就不再介绍了。&lt;strong&gt;Reactor模式&lt;/strong&gt;的优势按照我自己的理解就四个字——&lt;strong&gt;各司其职&lt;/strong&gt;。Manis 中使用的是&lt;strong&gt;多Reactor模式&lt;/strong&gt;，设计图如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/1/16ebf870942c3a64?w=1108&amp;amp;h=642&amp;amp;f=png&amp;amp;s=98527&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;简单介绍一下图中几个线程的功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Listener： 接收客户端的连接请求，也可以叫做 Acceptor，封装连接请求&lt;/li&gt;
&lt;li&gt;Readr： 多线程并行地读取客户端请求，进行反序列化和解析操作&lt;/li&gt;
&lt;li&gt;Handler： 多线程并行地读取调用请求，解析调用方法并执行调用&lt;/li&gt;
&lt;li&gt;Responder： 读取响应结果，发送给客户端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;够各司其职吧。那它们之间怎么联系呢？从图上可以看到是&lt;strong&gt;消息队列&lt;/strong&gt;，消息队列可以很好地实现组件间的解耦。&lt;/p&gt;
&lt;p&gt;虽然服务端的职责也比较明确、清晰，但涉及的内容一点不少，包括注册不同的序列化方式，解析并调用相应的请求。最关键的是服务端线程是最多的，并且需要线程之间需要高度协调的，所以对&lt;strong&gt;并发编程&lt;/strong&gt;的要求也更高，这块书中也有重点讲解。&lt;/p&gt;
&lt;p&gt;最后我们看看&lt;strong&gt;Manis中核心组件的时序图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/24/16dfe4f20634297c?w=705&amp;amp;h=324&amp;amp;f=bmp&amp;amp;s=685638&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 Manis 在设计上是足够优秀的，所以开发的时候这三个模块可以并行进行。有点像近几年web开发比较火的前后端分离架构，只要各个模块把协议定义好了后，开发就可以并行进行而不需要依赖彼此。至此，Manis 的核心技术就介绍完了，当然这只是冰山一角，毕竟 4600 行代码。&lt;/p&gt;
&lt;p&gt;最后，讲解一下第一节的内容&lt;/p&gt;
&lt;h2 id=&quot;第一节：搭建客户端本地调用框架&quot;&gt;第一节：搭建客户端本地调用框架&lt;/h2&gt;
&lt;p&gt;本节开始我们就开启 Manis 项目的实战之旅，首先从客户端开发入手。主要包括以下4个小节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义接口&lt;/li&gt;
&lt;li&gt;创建代理工具类&lt;/li&gt;
&lt;li&gt;创建客户端类&lt;/li&gt;
&lt;li&gt;课外拓展：代理模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Manis 提供给用户调用的类有两个，一个是 &lt;code&gt;ManisClient&lt;/code&gt; 给数据库使用者提供的，另一个是 &lt;code&gt;Manager&lt;/code&gt; 给数据库管理员使用的。采用&lt;strong&gt;面向接口&lt;/strong&gt;的编程思想，我们可以将提供的功能定义在&lt;strong&gt;接口&lt;/strong&gt;中。&lt;/p&gt;
&lt;h3 id=&quot;定义接口&quot;&gt;定义接口&lt;/h3&gt;
&lt;p&gt;定义&lt;code&gt;ClientProtocol&lt;/code&gt;接口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.protocol;

import java.io.IOException;

public interface ClientProtocol {
    /**
     * 获取某个表的 meta 信息
     * @param dbName 数据库名称
     * @param tbName 表名称
     * @return 表中的记录数
     */
    public int getTableCount(String dbName, String tbName) throws IOException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ClientProtocol&lt;/code&gt;接口中定义了一个&lt;code&gt;getTableCount&lt;/code&gt;方法，提供了获取数据库中某张表的记录数的功能。该接口用在&lt;code&gt;ManisClient&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;接口的&lt;span&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/span&gt;需要解释一下，名称中包含了&lt;code&gt;protocol（协议）&lt;/code&gt;单词，因为它需要跟其他组件通信，所以称它们是协议也合理。后面代码中的变量、注释将其称为协议时大家不要觉得奇怪。&lt;/p&gt;
&lt;p&gt;定义&lt;code&gt;ManagerProtocol&lt;/code&gt;接口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.protocol;

public interface ManagerProtocol {
    /**
     * 设置支持的最大表的个数
     * @param tableNum 表数量
     * @return 设置成功返回 true，设置失败返回 false
     */
    public boolean setMaxTable(int tableNum);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ManagerProtocol&lt;/code&gt;接口中定义了一个&lt;code&gt;setMaxTable&lt;/code&gt;方法，可以让管理员设置数据库中能够支持最多的表数量，该接口用在&lt;code&gt;Manager&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;实现接口中的方法，最常见的方式就是在本地创建类并实现该接口，但这种方式显然不适用于 RPC 场景。RPC 场景中的方法需要在服务端调用，而不是本地。因此，就需要另一种方式创建实例化对象，即通过&lt;strong&gt;代理模式&lt;/strong&gt;。不理解的朋友可以阅读本节的&lt;strong&gt;课外拓展&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;创建代理工具类&quot;&gt;创建代理工具类&lt;/h3&gt;
&lt;p&gt;在 Manis 中，我们便是通过&lt;strong&gt;代理&lt;/strong&gt;的方式实例化接口。定义一个&lt;code&gt;ManisDbProxies&lt;/code&gt;工具类，来实现获取代理的相关逻辑，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma;

import com.cnblogs.duma.conf.Configuration;
import com.cnblogs.duma.protocol.ClientProtocol;
import com.cnblogs.duma.protocol.ManagerProtocol;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URI;

/**
 * @author duma
 */
public class ManisDbProxies {

    public static class ProxyInfo&amp;lt;PROXYTYPE&amp;gt; {
        private final PROXYTYPE proxy;
        private final InetSocketAddress address;

        public ProxyInfo(PROXYTYPE proxy, InetSocketAddress address) {
            this.proxy = proxy;
            this.address = address;
        }

        public PROXYTYPE getProxy() {
            return proxy;
        }

        public InetSocketAddress getAddress() {
            return address;
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &amp;lt;T&amp;gt; ProxyInfo&amp;lt;T&amp;gt; createProxy(Configuration conf, 
        URI uri, Class&amp;lt;T&amp;gt; xface)
            throws IOException {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ManisDbProxies&lt;/code&gt; 类中定义了一个静态类&lt;code&gt;ProxyInfo&lt;/code&gt;用来封装代理对象。由于需要代理的接口不止一个，所以&lt;code&gt;ProxyInfo&lt;/code&gt;类引入了泛型。另外，我们还定义&lt;code&gt;createProxy&lt;/code&gt;方法用来获取代理对象，里面的逻辑后续会完善。&lt;/p&gt;
&lt;p&gt;这里简单说一下&lt;code&gt;createProxy&lt;/code&gt;方法第一个参数——&lt;code&gt;Configuration&lt;/code&gt;对象，它保存了定义的配置信息，且定义了配置的&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;方法，功能与 Hadoop 中的同名类一致，但实现上比 Hadoop 简单。为了不影响我们对重点内容的介绍，这里就不贴该类的代码了，它的源码带可在上面的 GitHub 连接中找到。&lt;/p&gt;
&lt;h3 id=&quot;创建客户端类&quot;&gt;创建客户端类&lt;/h3&gt;
&lt;p&gt;准备工作已经就绪，下面分别看看两种客户端如何使用接口来实现我们需要的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ManisClient&lt;/code&gt;的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma;

import com.cnblogs.duma.conf.Configuration;
import com.cnblogs.duma.protocol.ClientProtocol;

import java.io.Closeable;
import java.io.IOException;
import java.net.URI;

/**
 *
 * @author duma
 */
public class ManisClient implements Closeable {
    volatile boolean clientRunning = true;
    final ClientProtocol manisDb;

    public ManisClient(URI manisDbUri, Configuration conf) throws IOException {
        ManisDbProxies.ProxyInfo&amp;lt;ClientProtocol&amp;gt; proxyInfo = null;

        proxyInfo = ManisDbProxies.createProxy(conf, manisDbUri, ClientProtocol.class);
        this.manisDb = proxyInfo.getProxy();
    }

    /**
     * 获取远程数据库表中的记录数
     * @param dbName 数据库名称
     * @param tbName 表名称
     * @return 表记录数
     * @see com.cnblogs.duma.protocol.ClientProtocol#getTableCount(String, String)
     */
    public int getTableCount(String dbName, String tbName)
            throws IOException {
        return this.manisDb.getTableCount(dbName, tbName);
    }

    @Override
    public void close() throws IOException {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Manager&lt;/code&gt;的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma;

import com.cnblogs.duma.conf.Configuration;
import com.cnblogs.duma.protocol.ManagerProtocol;

import java.io.Closeable;
import java.io.IOException;
import java.net.URI;

public class Manager implements Closeable {
    volatile boolean clientRunning = true;
    final ManagerProtocol manisDb;

    public Manager(URI manisDbUri, Configuration conf) throws IOException {
        ManisDbProxies.ProxyInfo&amp;lt;ManagerProtocol&amp;gt; proxyInfo = null;

        proxyInfo = ManisDbProxies.createProxy(conf, manisDbUri, ManagerProtocol.class);
        this.manisDb = proxyInfo.getProxy();
    }

    public boolean setMaxTable(int tableNum) {
        return this.manisDb.setMaxTable(tableNum);
    }

    @Override
    public synchronized void close() throws IOException {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种客户端的代码基本一致，以&lt;code&gt;ManisClient&lt;/code&gt;为例简单讲解下。&lt;code&gt;ManisClient&lt;/code&gt;中也定义了&lt;code&gt;getTableCount&lt;/code&gt;方法，它直接调用了&lt;code&gt;ClientProtocol&lt;/code&gt;的实例化对象（代理对象） &lt;code&gt;manisDb&lt;/code&gt;的 &lt;code&gt;getTableCount&lt;/code&gt;方法。从这里我们就可以看出&lt;strong&gt;面向接口&lt;/strong&gt;编程的一个优势——扩展性高。虽然现在&lt;code&gt;manisDb&lt;/code&gt;是通过代理对初始化的，但假设以后需求变了，变成直接调用本地的方法了呢？这时候我们就可以在本地创建一个实现了&lt;code&gt;ClientProtocol&lt;/code&gt;接口的类，将其对象赋值给&lt;code&gt;manisDb&lt;/code&gt;即可。这样改变只是&lt;code&gt;manisDb&lt;/code&gt;的初始化代码，而其他业务代码不需要做任何改变。这同时也提醒我们平时在做设计的时候要认清系统中不变的地方和可变的地方。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;ManisClient&lt;/code&gt;和&lt;code&gt;Manager&lt;/code&gt;都实现了&lt;code&gt;Closeable&lt;/code&gt;接口，目的是为了覆盖&lt;code&gt;close&lt;/code&gt;方法。在&lt;code&gt;close&lt;/code&gt;方法中可以关闭客户端，从而释放占用的资源。&lt;code&gt;close&lt;/code&gt;方法的实现代码会在后续的章节中会完善。&lt;/p&gt;
&lt;p&gt;至此，这一节的内容就讲解完毕了，下一节我们将定义不同的 RPC 引擎，并完善代理模式。&lt;/p&gt;
&lt;h3 id=&quot;课外拓展：代理模式&quot;&gt;课外拓展：代理模式&lt;/h3&gt;
&lt;p&gt;代理模式是设计模式中的一种，该模式应用比较广泛。如果不太理解该模式的朋友，可以阅读这一小节。代理模式有好多种，本小节我们只介绍 &lt;strong&gt;Java 语言的动态代理&lt;/strong&gt;机制。如果想详细了解其他代理模式可以阅读我之前写的&lt;a href=&quot;https://www.cnblogs.com/duma/p/10629302.html&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;假设我们有一个写文件的需求，我们首先定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.dp.proxy.dynamic;

public interface Writer {
    public void write(String fileName, String str);
    public void write(String fileName, byte[] bs);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再定义写文件的类并实现&lt;code&gt;Writer&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.dp.proxy.dynamic;

public class FileWriter implements Writer {
    @Override
    public void write(String fileName, String str) {
        System.out.println(&quot;call write str in FileWriter&quot;);
    }

    @Override
    public void write(String fileName, byte[] bs) {
        System.out.println(&quot;call write bytes in FileWriter&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们要写文件的话，通过&lt;code&gt;Writer writer = new FileWriter()&lt;/code&gt;就可以实现了。假设某天突然来了个需求，说我们写磁盘的时候要判断服务器存储空间是否达到某个临界值，如果达到了就不能再写了。对于这个需求来说我们可以直接修改&lt;code&gt;FileWriter&lt;/code&gt;类来实现，但这样做有两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;改现有代码风险高，可能改动过程中影响原有逻辑，不符合&lt;strong&gt;开闭原则——对扩展开放，对修改关闭&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这个需求跟写文件的业务无关，直接放在业务代码里面会导致耦合度比较大，不利于维护&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过代理模式就可以避免上述两个问题，接下来我们看看如何利用 Java 的动态代理来实现这个需求。&lt;/p&gt;
&lt;p&gt;首先，我们需要创建一个实现&lt;code&gt;java.lang.reflect.InvocationHandler&lt;/code&gt;接口的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.dp.proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class FileWriterInvocationHandler implements InvocationHandler {
    Writer writer = null;

    public FileWriterInvocationHandler(Writer writer) {
        this.writer = writer;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Exception {
        boolean localNoSpace = false;
        System.out.println(&quot;check local filesystem space.&quot;); //检测磁盘空间代码，返回值可以更新 localNoSpace 变量
        if (localNoSpace) {
            throw new Exception(&quot;no space.&quot;); //如果空间不足，抛出空间不足的异常
        }
        return method.invoke(writer, args); //调用真实对象（FileWriter）的方法
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;FileWriterInvocationHandler&lt;/code&gt;的构造方法中会保存实际用于写文件的对象，即&lt;code&gt;FileWriter&lt;/code&gt;对象。&lt;code&gt;invoke&lt;/code&gt;方法中先检查磁盘，如果没问题再调用文件的写方法&lt;code&gt;method.invoke(writer, args)&lt;/code&gt;，这个写法是&lt;strong&gt;Java反射机制&lt;/strong&gt;提供的。看起来&lt;code&gt;invoke&lt;/code&gt;方法就是我们想要的功能，但我们要怎么调用&lt;code&gt;invoke&lt;/code&gt;呢？这里就用到 Java 的动态代理技术了，在运行时将&lt;code&gt;Writer&lt;/code&gt;接口动态地跟代理对象（FileWriterInvocationHandler对象）绑定在一起。&lt;/p&gt;
&lt;p&gt;下面，我们看看如何创建代理对象并进行绑定：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;package com.cnblogs.duma.dp.proxy.dynamic;

import java.lang.reflect.Proxy;

public class DynamicProxyDriver {
    public static void main(String[] args) {
        /**
         * Proxy.newProxyInstance 包括三个参数
         * 第一个参数：定义代理类的 classloader，一般用被代理接口的 classloader
         * 第二个参数：需要被代理的接口列表
         * 第三个参数：实现了 InvocationHandler 接口的对象
         * 返回值：代理对象
         */
        Writer writer = (Writer) Proxy.newProxyInstance(
                Writer.class.getClassLoader(),
                new Class[]{Writer.class},
                new FileWriterInvocationHandler(new FileWriter())); //这就是动态的原因，运行时才创建代理类

        try {
            writer.write(&quot;file1.txt&quot;, &quot;text&quot;); //调用代理对象的write方法
        } catch (Exception e) {
            e.printStackTrace();
        }
        writer.write(&quot;file2.txt&quot;, new byte[]{}); //调用代理对象的write方法
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Java语言提供的&lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt;即可创建&lt;code&gt;Writer&lt;/code&gt;接口的动态代理对象，代码注释中有该方法的参数说明。对照本例，简单梳理一下&lt;strong&gt;Java动态代理机制&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当通过&lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt;创建代理对象后，在&lt;code&gt;Writer&lt;/code&gt;接口中调用&lt;code&gt;write&lt;/code&gt;方法便会跳转到&lt;code&gt;FileWriterInvocationHandler&lt;/code&gt;对象的&lt;code&gt;invoke&lt;/code&gt;方法中执行&lt;/li&gt;
&lt;li&gt;比如，执行&lt;code&gt;writer.write(&quot;file1.txt&quot;, &quot;text&quot;);&lt;/code&gt;时，程序跳转到&lt;code&gt;invoke&lt;/code&gt;方法，它的第二个参数&lt;code&gt;method&lt;/code&gt;对象是&lt;code&gt;write&lt;/code&gt;方法，第三个参数&lt;code&gt;args&lt;/code&gt;是调用&lt;code&gt;write&lt;/code&gt;方法的实参&lt;code&gt;file1.txt&lt;/code&gt;和&lt;code&gt;text&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;invoke&lt;/code&gt;方法中的最后一行&lt;code&gt;method.invoke(writer, args);&lt;/code&gt;代表&lt;code&gt;method&lt;/code&gt;方法（即&lt;code&gt;write&lt;/code&gt;方法）由&lt;code&gt;writer&lt;/code&gt;对象调用，参数是&lt;code&gt;args&lt;/code&gt;，跟&lt;code&gt;writer.write(&quot;file1.txt&quot;, &quot;text&quot;)&lt;/code&gt;是一样的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样我们就通过代理模式既实现新需求，有没有修改现有的代码。经过上述的讲解，希望你对代理模式的概念和优势有一定的了解。&lt;/p&gt;
&lt;p&gt;代理模式除了上述提到的用处外，还有一个用处是&lt;strong&gt;转发调用请求&lt;/strong&gt;，以 Manis 为例，假如我们为&lt;code&gt;ClientProtocol&lt;/code&gt;创建一个代理对象&lt;code&gt;manisDb&lt;/code&gt;，在&lt;code&gt;manisDb&lt;/code&gt;上调用&lt;code&gt;getTableCount&lt;/code&gt;方法时，便会跳转到代理对象的&lt;code&gt;invoke&lt;/code&gt;方法中执行，在&lt;code&gt;invoke&lt;/code&gt;方法中我们就可以将调用的方法和参数反序列化，并通过网络发送服务端，这就实现了调用请求的转发。&lt;/p&gt;
&lt;h2 id=&quot;获得本书&quot;&gt;获得本书&lt;/h2&gt;
&lt;p&gt;今天先介绍第一节， 想获取完整内容可以关注公众号 &lt;strong&gt;渡码&lt;/strong&gt; 回复关键字 &lt;strong&gt;manis&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1a34fe0c-72c9-49b3-85b5-538f9c454ea6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码结构&quot;&gt;代码结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/46b6d6a9-0e2c-43a2-bad5-4e9228f2c55c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本书特色&quot;&gt;本书特色&lt;/h2&gt;
&lt;p&gt;在讲解相册内容同时，大部分章节都加入了课外拓展，针对每一节涉及的基础知识，如：设计模式、序列化/反序列化基础、单例测试、源码分析、并发编程以及Hadoop源码分析等内容都有拓展讲解。力求让零基础的朋友也能跟上本书节奏，从0到1独立完成一个项目。&lt;/p&gt;
&lt;p&gt;希望你学完本书后不只学会了某项技术，而是提高了设计实现整个系统的能力。&lt;/p&gt;
&lt;p&gt;欢迎公众号「&lt;strong&gt;渡码&lt;/strong&gt;」，输出别地儿看不到的干货。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171de982f76fd7d0?w=804&amp;amp;h=800&amp;amp;f=png&amp;amp;s=169178&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;</description>
<pubDate>Mon, 25 May 2020 00:22:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>去年年就在写一本付费小册，今年年初基本上就写完了，本来预计计划是春节上线结果由于平台的原因一直拖着没上。五一前跟平台联系给的反馈是五月份能上，结果平台又在重构，停止小册的申请和上线，最后我考虑了一下决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/12952780.html</dc:identifier>
</item>
<item>
<title>法线贴图那些事儿 - bzyzhang</title>
<link>http://www.cnblogs.com/bzyzhang/p/12954603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bzyzhang/p/12954603.html</guid>
<description>&lt;p&gt;在学习&lt;a href=&quot;https://learnopengl.com/Advanced-Lighting/Normal-Mapping&quot;&gt;法线贴图&lt;/a&gt;的过程中，有几个比较难以理解的概念，这里记录一下。&lt;strong&gt;特别说一下，本文的法线贴图是切线空间下的法线贴图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bzyzhang/ImgHosting//img/2020-5-17/20200523103017.png&quot; alt=&quot;空间变换示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，简单表达了在使用法线贴图的过程中，涉及到的几个空间变换：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;切线空间：从法线贴图中采样得到的法线，在切线空间中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象空间：物体的本地坐标空间，顶点的相关信息，在对象空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;世界空间：光源位置、观察者位置等，在世界空间中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在空间变换的过程中，主要涉及到了两个变换矩阵：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;矩阵：从切线空间变换到对象空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Model\)&lt;/span&gt;矩阵：从对象空间变换到世界空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于上述概念，大部分都是比较熟悉的，只有法线贴图、切线空间和&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;矩阵比较陌生。下面，将分别介绍一下。&lt;/p&gt;

&lt;p&gt;在3D计算机图形学中，法线贴图是一种用于伪造凹凸光照的技术，是凹凸贴图的一种实现。它用于添加细节，而不使用更多的多边形。这种技术的一个常见用途是，通过从高精度多边形或高度图生成法线贴图，来极大地增强低精度多边形的外观和细节。下图来自Paolo Cignoni，图中对比了两种方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bzyzhang/ImgHosting//img/2020-5-17/20200523101852.png&quot; alt=&quot;法线可以使低精度模型实现高精度模型的效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;法线贴图通常存储为常规RGB图像，其中RGB分量分别对应于表面法线的X，Y和Z坐标。&lt;/p&gt;
&lt;p&gt;法线的每个分量的值的范围是&lt;span class=&quot;math inline&quot;&gt;\([-1,1]\)&lt;/span&gt;，而RGB分量的值的范围是&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;。所以，在将法线存储为RGB图像时，需要对每个分量做一个映射：&lt;/p&gt;
&lt;p&gt;\[vec3 \quad rgb\_normal = normal * 0.5 + 0.5 \]&lt;/p&gt;
&lt;p&gt;这里要注意，将法线存储到法线贴图的过程中，需要进行上述操作。当我们从法线贴图中读取到法线数据后，需要进行上述变换的逆变换，即从&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;映射到&lt;span class=&quot;math inline&quot;&gt;\([-1,1]\)&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;那么，法线向量应该相对于哪个坐标系呢？我们可以选择模型顶点的的坐标系，即对象空间；也可以选择模型纹理所在的坐标系，即切线空间，也称为纹理空间。&lt;/p&gt;
&lt;p&gt;对象空间中，法线信息是相对于对象空间的朝向的，各个方向的法线向量都有，所有贴图看起来色彩比较丰富；而在切线空间中，法线是相对于顶点的，大致指向顶点信息中的法线方向，即法线向量接近于&lt;span class=&quot;math inline&quot;&gt;\((0,0,1)\)&lt;/span&gt;，映射到RGB是&lt;span class=&quot;math inline&quot;&gt;\((0.5,0.5,1)\)&lt;/span&gt;，这是一种偏蓝的颜色。下图分别是对象空间和切线空间下的法线纹理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bzyzhang/ImgHosting//img/2020-5-17/20200523105701.jpg&quot; alt=&quot;对象空间和切线空间下的法线纹理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，怎么进行选择呢？考虑一下二者的优缺点：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重用性：对于对象空间的法线贴图，它是相对于特定对象的，假如应用到其他的对象上，可能效果就不正确了；而切线空间中的法线贴图，记录的是相对法线信息，所以可以把它应用到其他对象上，也能得到正确的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可压缩：考虑到法线向量是单位向量，而且Z分量总是正的，可以只存储XY方向，而推导出Z方向。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综上所述，我们一般选择切线空间下的法线贴图。&lt;/p&gt;

&lt;p&gt;在光照的计算过程中，需要用到光线方向、视线方向和法线方向等，为了得到正确的结果，这些变量必须在同一坐标系下计算。参考一下本文开头的“坐标变换示意图”。&lt;/p&gt;
&lt;p&gt;在纹理坐标系中，x和y分量与2D图片的水平方向和垂直方向对齐，而z分量指向图片外部的上方。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bzyzhang/ImgHosting//img/2020-5-17/20200523140057.png&quot; alt=&quot;纹理坐标系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了正确使用贴图中的纹理信息，我们必须找到一种方法——&lt;strong&gt;从切线坐标空间变换到对象空间&lt;/strong&gt;。这可以通过指定切线坐标系的坐标轴在对象空间中的方向来达到。&lt;/p&gt;
&lt;p&gt;对一个单独的三角形面片来说，我们可以认为纹理贴图覆盖在三角形的表面上，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/bzyzhang/ImgHosting//img/2020-5-17/20200523141704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上图，可以得出：三角面片和纹理贴图是&lt;strong&gt;共面&lt;/strong&gt;的。那么，根据平行四边形法则，可以得出：&lt;/p&gt;
&lt;p&gt;\[\begin{matrix} E_{1} = \Delta U_{1}U + \Delta V_{1}V \\ E_{2} = \Delta U_{2}U + \Delta V_{2}V \\ \end{matrix} \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(E_{1}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(E_{2}\)&lt;/span&gt;是两个顶点之间的向量差，可以根据顶点的坐标计算出来；&lt;span class=&quot;math inline&quot;&gt;\(\Delta U_{1}\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\Delta V_{1}\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\Delta U_{2}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\Delta V_{2}\)&lt;/span&gt;分别是纹理坐标的水平和垂直方向的差，可以根据纹理坐标计算得到。&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;分别是纹理的水平和垂直坐标轴，是要计算的未知量。&lt;/p&gt;
&lt;p&gt;写成坐标表示：&lt;/p&gt;
&lt;p&gt;\[\begin{matrix} \left( E_{1x},E_{1y},E_{1z} \right) = \Delta U_{1}\left(U_{x},U_{y},U_{z}\right) + \Delta V_{1}\left( V_{x},V_{y},V_{z} \right) \\ \left( E_{2x},E_{2y},E_{2z} \right) = \Delta U_{2}\left(U_{x},U_{y},U_{z}\right) + \Delta V_{2}\left( V_{x},V_{y},V_{z} \right) \\ \end{matrix} \]&lt;/p&gt;
&lt;p&gt;上面的方程，也可以写成矩阵乘法的形式：&lt;/p&gt;
&lt;p&gt;\[\begin{bmatrix} E_{1x} &amp;amp; E_{1y} &amp;amp; E_{1z} \\ E_{2x} &amp;amp; E_{2y} &amp;amp; E_{2z} \\ \end{bmatrix}= \begin{bmatrix} \Delta U_{1} &amp;amp; \Delta V_{1} \\ \Delta U_{2} &amp;amp; \Delta V_{2} \\ \end{bmatrix} \begin{bmatrix} U_{x} &amp;amp; U_{y} &amp;amp; U_{z} \\ V_{x} &amp;amp; V_{y} &amp;amp; V_{z} \\ \end{bmatrix} \]&lt;/p&gt;
&lt;p&gt;两边同时乘以&lt;span class=&quot;math inline&quot;&gt;\(\Delta U \Delta V\)&lt;/span&gt;的逆矩阵，可得：&lt;/p&gt;
&lt;p&gt;\[\begin{bmatrix} U_{x} &amp;amp; U_{y} &amp;amp; U_{z} \\ V_{x} &amp;amp; V_{y} &amp;amp; V_{z} \\ \end{bmatrix}= \begin{bmatrix} \Delta U_{1} &amp;amp; \Delta V_{1} \\ \Delta U_{2} &amp;amp; \Delta V_{2} \\ \end{bmatrix}^{-1} \begin{bmatrix} E_{1x} &amp;amp; E_{1y} &amp;amp; E_{1z} \\ E_{2x} &amp;amp; E_{2y} &amp;amp; E_{2z} \\ \end{bmatrix} \]&lt;/p&gt;
&lt;p&gt;求逆矩阵不太方便，可以使用&lt;strong&gt;伴随矩阵法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;\[\begin{bmatrix} U_x &amp;amp; U_y &amp;amp; U_z \\ V_x &amp;amp; V_y &amp;amp; V_z \end{bmatrix} = \frac{1}{\Delta U_1 \Delta V_2 - \Delta U_2 \Delta V_1} \begin{bmatrix} \Delta V_2 &amp;amp; -\Delta V_1 \\ -\Delta U_2 &amp;amp; \Delta U_1 \end{bmatrix} \begin{bmatrix} E_{1x} &amp;amp; E_{1y} &amp;amp; E_{1z} \\ E_{2x} &amp;amp; E_{2y} &amp;amp; E_{2z} \end{bmatrix} \]&lt;/p&gt;
&lt;p&gt;至此，我们求出了&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;向量。但是我们需要的构成&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;空间的坐标轴是正交的，这里求出的&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;并不一定能满足正交的条件。这里，顶点的法线&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;是已知的，我们可以根据&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;，根据&lt;strong&gt;格拉姆-施密特正交化&lt;/strong&gt;方法，求出与&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;正交的&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;（此处假设切线空间是右手坐标系）：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} T &amp;amp;= normalize \left( U - dot \left( U,N \right) * N \right) \\ B &amp;amp;= normalize \left( cross \left( N,T \right) \right) \\ TBN &amp;amp;= mat3 \left( T,B,N \right) \end{aligned} \]&lt;/p&gt;
&lt;p&gt;这样，我们获得了坐标轴相互正交的&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;矩阵。&lt;/p&gt;

&lt;p&gt;看完上面计算切线空间的&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;矩阵的部分，估计也是头大。不禁想到，每次使用法线贴图的过程，真的如此麻烦吗？&lt;/p&gt;
&lt;p&gt;幸运的是，答案是否定的。&lt;/p&gt;
&lt;p&gt;一般情况下，模型存储的顶点信息中，都包含了顶点的法线和切线的数据，这样，我们就不用进行上面的复杂计算了，直接使用法线和切线的叉乘，求出副切线，从而构成&lt;span class=&quot;math inline&quot;&gt;\(TBN\)&lt;/span&gt;矩阵。&lt;/p&gt;

</description>
<pubDate>Mon, 25 May 2020 00:07:00 +0000</pubDate>
<dc:creator>bzyzhang</dc:creator>
<og:description>概述 在学习 &amp;quot;法线贴图&amp;quot; 的过程中，有几个比较难以理解的概念，这里记录一下。 特别说一下，本文的法线贴图是切线空间下的法线贴图。 空间变换 如上图所示，简单表达了在使用法线贴图的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bzyzhang/p/12954603.html</dc:identifier>
</item>
<item>
<title>Node.js躬行记（1）——Buffer、流和EventEmitter - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12626335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12626335.html</guid>
<description>&lt;p&gt;　　Buffer是一种Node的内置类型，不需要通过require()函数额外引入。它能读取和写入二进制数据，常用于解析网络数据流、文件等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过new关键字初始化Buffer对象的方式已经被废弃，下面的代码都已经过时。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Buffer(array)
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Buffer(arrayBuffer[, byteOffset[, length]])
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Buffer(buffer)
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Buffer(size)
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Buffer(string[, encoding])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　目前有两种方式创建Buffer对象，第一种是通过alloc()或allocUnsafe()两个静态方法，语法如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Buffer.alloc(size[, fill[, encoding]])
Buffer.allocUnsafe(size)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　alloc()方法可接收三个参数，后两个是可选的。第一个参数是长度，第二个参数是预填充的值，第三个参数是字符编码，默认值是“utf8”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const buf1 = Buffer.alloc(10&lt;span&gt;);
const buf2 &lt;/span&gt;= Buffer.alloc(10, &quot;A&quot;&lt;span&gt;);
const buf3 &lt;/span&gt;= Buffer.alloc(10, &quot;A&quot;, &quot;ascii&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果打印buf3，那么得到的将是一组十六进制数据，而非难以阅读的二进制数据，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Buffer 41 41 41 41 41 41 41 41 41 41&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，Buffer的大小在创建时确定，后面也无法更改，其类型可由Buffer.isBuffer()辨别。当前Node支持的字符编码有6种：&lt;/p&gt;
&lt;p&gt;　　（1）ascii：仅适用于7位的ASCII数据。&lt;/p&gt;
&lt;p&gt;　　（2）utf8：多字节编码的Unicode字符。许多网页和其它文档格式都在使用UTF-8。&lt;/p&gt;
&lt;p&gt;　　（3）utf16le/ucs2：2或4个字节，小端序编码的Unicode字符。支持代理对（U+10000至U+10FFFF）。&lt;/p&gt;
&lt;p&gt;　　（4）base64：Base64编码，一种基于64个可打印字符来表示二进制数据的表示方法。&lt;/p&gt;
&lt;p&gt;　　（5）latin1/binary：一种可编码成单字节字符串的方法。&lt;/p&gt;
&lt;p&gt;　　（6）hex：将每个字节编码成两个十六进制的字符。&lt;/p&gt;
&lt;p&gt;　　allocUnsafe()是一个不安全的方法，因为它分配的内存片段是未初始化的，即没有被清零。虽然这种设计性能优越，但分配的内存中可能会包含旧数据。&lt;/p&gt;
&lt;p&gt;　　第二种是通过Buffer.from()方法创建Buffer对象，它的参数可以是数组、字符串、Buffer对象等，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const buf = Buffer.from(&quot;A&quot;&lt;span&gt;);
console.log(buf);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;Buffer 41&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）转换编码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在读取文件时，可通过toString()方法将Buffer对象转换成字符串，如下所示，默认是UTF-8格式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);
fs.readFile(&lt;/span&gt;'./demo.txt', (err, buf) =&amp;gt;&lt;span&gt; {
  buf.toString();            　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;你好，Node.js&quot;&lt;/span&gt;
  buf.toString(&quot;base64&quot;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;5L2g5aW977yMTm9kZS5qcw==&quot;&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Node中的stream模块用于处理流式数据，许多内置的核心模块都在其内部实现了流操作，流还适用于网络传输、JSON解析器、RFC（远程调用）等。流包括四个抽象类：&lt;/p&gt;
&lt;p&gt;　　（1）Readable：可读流，读取底层的I/O数据源。&lt;/p&gt;
&lt;p&gt;　　（2）Writeable：可写流，将数据写入到目标中。&lt;/p&gt;
&lt;p&gt;　　（3）Duplex：双工流，即可读也可写。&lt;/p&gt;
&lt;p&gt;　　（4）Transform：转换流，会修改数据的双工流。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）pipe()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在可读流中，包含一个管道方法：pipe()，它的作用是关联可读流与可写流，让数据通过管道从可读流进入到可写流中。pipe()方法能接收一个Writable对象，并返回对目标流的引用，从而可形成链式调用。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，会将origin.txt中的数据通过管道写入到target.txt文件中，调用文件模块的createReadStream()方法能得到一个Readable对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);
const readable &lt;/span&gt;= fs.createReadStream('./origin.txt'&lt;span&gt;);
const writable &lt;/span&gt;= fs.createWriteStream('./target.txt'&lt;span&gt;);
readable.pipe(writable);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）事件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　以可读流为例，它的data事件可在接收到数据块后触发，而end事件会在流没有数据时触发。在下面的示例中，origin.txt文件包含的内容是“hello Node.js”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;);
const readable &lt;/span&gt;= fs.createReadStream('./origin.txt', {highWaterMark: 2&lt;span&gt;});
readable.on(&lt;/span&gt;&quot;data&quot;, (chunk) =&amp;gt;&lt;span&gt; {
  console.log(`接收到 ${chunk.length} 个字节的数据`, chunk.toString());
});
readable.on(&lt;/span&gt;&quot;end&quot;, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;&quot;结束接收&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在调用createReadStream()方法时，包含一个highWaterMark属性，其默认值为64KB，它的作用是限制可缓冲的字节数。当定义为2后，每接收2个字节的数据，就会触发data事件，打印结果如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
接收到 2&lt;span&gt; 个字节的数据 he
接收到 &lt;/span&gt;2&lt;span&gt; 个字节的数据 ll
接收到 &lt;/span&gt;2&lt;span&gt; 个字节的数据 o
接收到 &lt;/span&gt;2&lt;span&gt; 个字节的数据 No
接收到 &lt;/span&gt;2&lt;span&gt; 个字节的数据 de
接收到 &lt;/span&gt;2&lt;span&gt; 个字节的数据 .j
接收到 &lt;/span&gt;1&lt;span&gt; 个字节的数据 s
结束接收&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可读流还包含一个error事件，用于监听异常，其事件处理程序会接收一个Error对象。在下面的示例中，会读取不存在的文件，从而触发error事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const readable = fs.createReadStream('./demo.txt'&lt;span&gt;);
readable.on(&lt;/span&gt;&quot;error&quot;, (err) =&amp;gt;&lt;span&gt; {
  console.log(err);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印错误信息&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）实现流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当实现自定义的流时，需要继承四个抽象类中的一个，表1列出了四个抽象类需要实现的方法。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;抽象类&lt;/td&gt;
&lt;td&gt;需要实现的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Readable&lt;/td&gt;
&lt;td&gt;_read()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Writeable&lt;/td&gt;
&lt;td&gt;_write()、_writev()、_final()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Duplex&lt;/td&gt;
&lt;td&gt;_read()、_write()、_writev()、_final()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Transform&lt;/td&gt;
&lt;td&gt;_transform()、_flush()、_final()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　下面是一个自定义可写流的例子，_write()方法中的encoding是一个字符串，表示字符编码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const { Writable } = require('stream'&lt;span&gt;);
class MyWritable extends Writable {
  constructor(options) {
    super(options);
  }
  _write(chunk, encoding, callback) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (encoding === &quot;buffer&quot;&lt;span&gt;) {
      callback();
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Node的事件模块目前只包含一个EventEmitter类（即事件触发器），所有能触发事件的对象都是EventEmitter类的实例。EventEmitter通常被用作基类，在Node内部，凡是提供事件机制的模块都会继承它。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，声明了一个EventEmitter实例，on()方法用于注册监听器，emit()方法用于触发事件。在调用emit()方法时，传递了自定义的type参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const EventEmitter = require('events'&lt;span&gt;);
class MyEmitter extends EventEmitter {}
const myEmitter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyEmitter();

myEmitter.on(&lt;/span&gt;'click', (type) =&amp;gt;&lt;span&gt; {
  console.log(`触发${type}事件`);
});
myEmitter.emit(&lt;/span&gt;'click', &quot;点击&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，可注册多个相同名称的事件，监听器会按照添加顺序依次调用。事件模块还提供了很多其它方法，例如off()用于解除事件绑定，once()可以只监听一次事件。&lt;/p&gt;

</description>
<pubDate>Sun, 24 May 2020 23:59:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、Buffer Buffer是一种Node的内置类型，不需要通过require()函数额外引入。它能读取和写入二进制数据，常用于解析网络数据流、文件等。 1）创建 通过new关键字初始化Buffer</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12626335.html</dc:identifier>
</item>
<item>
<title>.net core HttpClient 使用之消息管道解析（二） - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12897923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12897923.html</guid>
<description>&lt;p&gt;我们可以通过自定义的MessageHandler 来动态加载请求证书，通过数据库的一些信息，在自定义的Handler 中加载注入对应的证书，这样可以起到动态加载支付证书作用，同时可以SendAsync 之前或者之后做一些自己的验证等相关业务，大家只需要理解它们的用途，自然知道它的强大作用，今天就分享到这里&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;203.39613442452&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;前面分享了 &lt;a href=&quot;https://www.cnblogs.com/jlion/p/12813692.html&quot;&gt;.net core HttpClient 使用之掉坑解析（一）&lt;/a&gt;，今天来分享自定义消息处理&lt;code&gt;HttpMessageHandler&lt;/code&gt;和&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt; 的使用场景和区别&lt;/p&gt;
&lt;h2 id=&quot;二、源代码阅读&quot;&gt;二、源代码阅读&lt;/h2&gt;
&lt;h3 id=&quot;21-核心消息管道模型图&quot;&gt;2.1 核心消息管道模型图&lt;/h3&gt;
&lt;p&gt;先贴上一张核心MessageHandler 管道模型的流程图，图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202005/824291-20200523173914953-1939057591.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;HttpClient 中的&lt;code&gt;HttpMessageHandler&lt;/code&gt; 负责主要核心的业务，&lt;code&gt;HttpMessageHandler&lt;/code&gt; 是由MessageHandler 链表结构组成，形成一个消息管道模式；具体我们一起来看看源代码&lt;/p&gt;
&lt;h3 id=&quot;22-demo代码演示&quot;&gt;2.2 Demo代码演示&lt;/h3&gt;
&lt;p&gt;再阅读源代码的时候我们先来看下下面注入&lt;code&gt;HttpClient&lt;/code&gt; 的Demo 代码，代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddHttpClient(&quot;test&quot;)
        .ConfigurePrimaryHttpMessageHandler(provider =&amp;gt;
        {
            return new PrimaryHttpMessageHandler(provider);
        })
        .AddHttpMessageHandler(provider =&amp;gt;
        {
            return new LogHttpMessageHandler(provider);
        })
        .AddHttpMessageHandler(provider =&amp;gt;
        {
           return new Log2HttpMessageHandler(provider);
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中有两个核心扩展方法，分别是&lt;code&gt;ConfigurePrimaryHttpMessageHandler&lt;/code&gt;和&lt;code&gt;AddHttpMessageHandler&lt;/code&gt;,这两个方法大家可能会有疑问是做什么的呢？&lt;br/&gt;不错，这两个方法就是扩展注册自定义的&lt;code&gt;HttpMessageHandler&lt;/code&gt; 如果不注册，会有默认的&lt;code&gt;HttpMessageHandler&lt;/code&gt;,接下来我们分别来看下提供的扩展方法，如下图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202005/824291-20200523175819887-1350104124.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图中提供了一系列的&lt;code&gt;AddHttpMessageHandler&lt;/code&gt; 扩展方法和&lt;code&gt;ConfigurePrimaryHttpMessageHandler&lt;/code&gt;的扩展方法。&lt;/p&gt;
&lt;h3 id=&quot;23-addhttpmessagehandler&quot;&gt;2.3 &lt;code&gt;AddHttpMessageHandler&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们来看看&lt;code&gt;HttpClientBuilderExtensions&lt;/code&gt;中的其中一个&lt;code&gt;AddHttpMessageHandler&lt;/code&gt;扩展方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// Adds a delegate that will be used to create an additional message handler for a named &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;builder&quot;&amp;gt;The &amp;lt;see cref=&quot;IHttpClientBuilder&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;configureHandler&quot;&amp;gt;A delegate that is used to create a &amp;lt;see cref=&quot;DelegatingHandler&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;An &amp;lt;see cref=&quot;IHttpClientBuilder&quot;/&amp;gt; that can be used to configure the client.&amp;lt;/returns&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// The &amp;lt;see paramref=&quot;configureHandler&quot;/&amp;gt; delegate should return a new instance of the message handler each time it
        /// is invoked.
        /// &amp;lt;/remarks&amp;gt;
        public static IHttpClientBuilder AddHttpMessageHandler(this IHttpClientBuilder builder, Func&amp;lt;DelegatingHandler&amp;gt; configureHandler)
        {
            if (builder == null)
            {
                throw new ArgumentNullException(nameof(builder));
            }

            if (configureHandler == null)
            {
                throw new ArgumentNullException(nameof(configureHandler));
            }

            builder.Services.Configure&amp;lt;HttpClientFactoryOptions&amp;gt;(builder.Name, options =&amp;gt;
            {
                options.HttpMessageHandlerBuilderActions.Add(b =&amp;gt; b.AdditionalHandlers.Add(configureHandler()));
            });

            return builder;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中把自定义的&lt;code&gt;DelegatingHandler&lt;/code&gt; 方法添加到&lt;code&gt;HttpMessageHandlerBuilderActions&lt;/code&gt;中，我们再来看看&lt;code&gt;HttpClientFactoryOptions&lt;/code&gt;对象源代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
    /// An options class for configuring the default &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt;.
    /// &amp;lt;/summary&amp;gt;
    public class HttpClientFactoryOptions
    {
        // Establishing a minimum lifetime helps us avoid some possible destructive cases.
        //
        // IMPORTANT: This is used in a resource string. Update the resource if this changes.
        internal readonly static TimeSpan MinimumHandlerLifetime = TimeSpan.FromSeconds(1);

        private TimeSpan _handlerLifetime = TimeSpan.FromMinutes(2);

        /// &amp;lt;summary&amp;gt;
        /// Gets a list of operations used to configure an &amp;lt;see cref=&quot;HttpMessageHandlerBuilder&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        public IList&amp;lt;Action&amp;lt;HttpMessageHandlerBuilder&amp;gt;&amp;gt; HttpMessageHandlerBuilderActions { get; } = new List&amp;lt;Action&amp;lt;HttpMessageHandlerBuilder&amp;gt;&amp;gt;();

        /// &amp;lt;summary&amp;gt;
        /// Gets a list of operations used to configure an &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        public IList&amp;lt;Action&amp;lt;HttpClient&amp;gt;&amp;gt; HttpClientActions { get; } = new List&amp;lt;Action&amp;lt;HttpClient&amp;gt;&amp;gt;();

        /// &amp;lt;summary&amp;gt;
        /// Gets or sets the length of time that a &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt; instance can be reused. Each named 
        /// client can have its own configured handler lifetime value. The default value of this property is two minutes.
        /// Set the lifetime to &amp;lt;see cref=&quot;Timeout.InfiniteTimeSpan&quot;/&amp;gt; to disable handler expiry.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// The default implementation of &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt; will pool the &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt;
        /// instances created by the factory to reduce resource consumption. This setting configures the amount of time
        /// a handler can be pooled before it is scheduled for removal from the pool and disposal.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections; creating
        /// more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely
        /// which can prevent the handler from reacting to DNS changes. The value of &amp;lt;see cref=&quot;HandlerLifetime&quot;/&amp;gt; should be
        /// chosen with an understanding of the application's requirement to respond to changes in the network environment.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// Expiry of a handler will not immediately dispose the handler. An expired handler is placed in a separate pool 
        /// which is processed at intervals to dispose handlers only when they become unreachable. Using long-lived
        /// &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt; instances will prevent the underlying &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt; from being
        /// disposed until all references are garbage-collected.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;/remarks&amp;gt;
        public TimeSpan HandlerLifetime
        {
            get =&amp;gt; _handlerLifetime;
            set
            {
                if (value != Timeout.InfiniteTimeSpan &amp;amp;&amp;amp; value &amp;lt; MinimumHandlerLifetime)
                {
                    throw new ArgumentException(Resources.HandlerLifetime_InvalidValue, nameof(value));
                }

                _handlerLifetime = value;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// The &amp;lt;see cref=&quot;Func{T, R}&quot;/&amp;gt; which determines whether to redact the HTTP header value before logging.
        /// &amp;lt;/summary&amp;gt;
        public Func&amp;lt;string, bool&amp;gt; ShouldRedactHeaderValue { get; set; } = (header) =&amp;gt; false;

        /// &amp;lt;summary&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// Gets or sets a value that determines whether the &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt; will
        /// create a dependency injection scope when building an &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt;.
        /// If &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt; (default), a scope will be created, otherwise a scope will not be created.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// This option is provided for compatibility with existing applications. It is recommended
        /// to use the default setting for new applications.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// The &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt; will (by default) create a dependency injection scope
        /// each time it creates an &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt;. The created scope has the same
        /// lifetime as the message handler, and will be disposed when the message handler is disposed.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;para&amp;gt;
        /// When operations that are part of &amp;lt;see cref=&quot;HttpMessageHandlerBuilderActions&quot;/&amp;gt; are executed
        /// they will be provided with the scoped &amp;lt;see cref=&quot;IServiceProvider&quot;/&amp;gt; via 
        /// &amp;lt;see cref=&quot;HttpMessageHandlerBuilder.Services&quot;/&amp;gt;. This includes retrieving a message handler
        /// from dependency injection, such as one registered using 
        /// &amp;lt;see cref=&quot;HttpClientBuilderExtensions.AddHttpMessageHandler{THandler}(IHttpClientBuilder)&quot;/&amp;gt;.
        /// &amp;lt;/para&amp;gt;
        /// &amp;lt;/remarks&amp;gt;
        public bool SuppressHandlerScope { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源代码中有如下核心List:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public IList&amp;lt;Action&amp;lt;HttpMessageHandlerBuilder&amp;gt;&amp;gt; HttpMessageHandlerBuilderActions { get; } = new List&amp;lt;Action&amp;lt;HttpMessageHandlerBuilder&amp;gt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供了&lt;code&gt;HttpMessageHandlerBuilder&lt;/code&gt; HttpMessageHandler 的构造器列表对象，故，通过&lt;code&gt;AddHttpMessageHandler&lt;/code&gt;可以添加一系列的消息构造器方法对象&lt;br/&gt;我们再来看看这个消息构造器类，核心部分，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class HttpMessageHandlerBuilder
    {
        /// &amp;lt;summary&amp;gt;
        /// Gets or sets the name of the &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt; being created.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// The &amp;lt;see cref=&quot;Name&quot;/&amp;gt; is set by the &amp;lt;see cref=&quot;IHttpClientFactory&quot;/&amp;gt; infrastructure
        /// and is public for unit testing purposes only. Setting the &amp;lt;see cref=&quot;Name&quot;/&amp;gt; outside of
        /// testing scenarios may have unpredictable results.
        /// &amp;lt;/remarks&amp;gt;
        public abstract string Name { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// Gets or sets the primary &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        public abstract HttpMessageHandler PrimaryHandler { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// Gets a list of additional &amp;lt;see cref=&quot;DelegatingHandler&quot;/&amp;gt; instances used to configure an
        /// &amp;lt;see cref=&quot;HttpClient&quot;/&amp;gt; pipeline.
        /// &amp;lt;/summary&amp;gt;
        public abstract IList&amp;lt;DelegatingHandler&amp;gt; AdditionalHandlers { get; }

        /// &amp;lt;summary&amp;gt;
        /// Gets an &amp;lt;see cref=&quot;IServiceProvider&quot;/&amp;gt; which can be used to resolve services
        /// from the dependency injection container.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// This property is sensitive to the value of 
        /// &amp;lt;see cref=&quot;HttpClientFactoryOptions.SuppressHandlerScope&quot;/&amp;gt;. If &amp;lt;c&amp;gt;true&amp;lt;/c&amp;gt; this
        /// property will be a reference to the application's root service provider. If &amp;lt;c&amp;gt;false&amp;lt;/c&amp;gt;
        /// (default) this will be a reference to a scoped service provider that has the same
        /// lifetime as the handler being created.
        /// &amp;lt;/remarks&amp;gt;
        public virtual IServiceProvider Services { get; }

        /// &amp;lt;summary&amp;gt;
        /// Creates an &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;
        /// An &amp;lt;see cref=&quot;HttpMessageHandler&quot;/&amp;gt; built from the &amp;lt;see cref=&quot;PrimaryHandler&quot;/&amp;gt; and
        /// &amp;lt;see cref=&quot;AdditionalHandlers&quot;/&amp;gt;.
        /// &amp;lt;/returns&amp;gt;
        public abstract HttpMessageHandler Build();

        protected internal static HttpMessageHandler CreateHandlerPipeline(HttpMessageHandler primaryHandler, IEnumerable&amp;lt;DelegatingHandler&amp;gt; additionalHandlers)
        {
            // This is similar to https://github.com/aspnet/AspNetWebStack/blob/master/src/System.Net.Http.Formatting/HttpClientFactory.cs#L58
            // but we don't want to take that package as a dependency.

            if (primaryHandler == null)
            {
                throw new ArgumentNullException(nameof(primaryHandler));
            }

            if (additionalHandlers == null)
            {
                throw new ArgumentNullException(nameof(additionalHandlers));
            }

            var additionalHandlersList = additionalHandlers as IReadOnlyList&amp;lt;DelegatingHandler&amp;gt; ?? additionalHandlers.ToArray();

            var next = primaryHandler;
            for (var i = additionalHandlersList.Count - 1; i &amp;gt;= 0; i--)
            {
                var handler = additionalHandlersList[i];
                if (handler == null)
                {
                    var message = Resources.FormatHttpMessageHandlerBuilder_AdditionalHandlerIsNull(nameof(additionalHandlers));
                    throw new InvalidOperationException(message);
                }

                // Checking for this allows us to catch cases where someone has tried to re-use a handler. That really won't
                // work the way you want and it can be tricky for callers to figure out.
                if (handler.InnerHandler != null)
                {
                    var message = Resources.FormatHttpMessageHandlerBuilder_AdditionHandlerIsInvalid(
                        nameof(DelegatingHandler.InnerHandler),
                        nameof(DelegatingHandler),
                        nameof(HttpMessageHandlerBuilder),
                        Environment.NewLine,
                        handler);
                    throw new InvalidOperationException(message);
                }

                handler.InnerHandler = next;
                next = handler;
            }

            return next;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HttpMessageHandlerBuilder&lt;/code&gt;构造器中有两个核心属性&lt;code&gt;PrimaryHandler&lt;/code&gt; 和&lt;code&gt;AdditionalHandlers&lt;/code&gt; ，细心的同学可以发现&lt;code&gt;AdditionalHandlers&lt;/code&gt;是一个&lt;code&gt;IList&amp;lt;DelegatingHandler&amp;gt;&lt;/code&gt;列表，也就是说可以HttpClient 可以添加多个&lt;code&gt;DelegatingHandler&lt;/code&gt; 即多个&lt;code&gt;HttpMessageHandler&lt;/code&gt; 消息处理Handler 但是只能有一个&lt;code&gt;PrimaryHandler&lt;/code&gt; Handler&lt;/p&gt;
&lt;p&gt;同时&lt;code&gt;HttpMessageHandlerBuilder&lt;/code&gt;提供了一个抽象的&lt;code&gt;Build&lt;/code&gt;方法，还有一个&lt;code&gt;CreateHandlerPipeline&lt;/code&gt; 方法，这个方法主要是把&lt;code&gt;IList&amp;lt;DelegatingHandler&amp;gt;&lt;/code&gt; 和&lt;code&gt;PrimaryHandler&lt;/code&gt; 构造成一个MessageHandler 链表结构（通过&lt;code&gt;DelegatingHandler&lt;/code&gt; 的&lt;code&gt;InnerHandler&lt;/code&gt;属性进行连接起来）&lt;/p&gt;
&lt;h3 id=&quot;24-configureprimaryhttpmessagehandler&quot;&gt;2.4 ConfigurePrimaryHttpMessageHandler&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; public static IHttpClientBuilder ConfigurePrimaryHttpMessageHandler(this IHttpClientBuilder builder, Func&amp;lt;HttpMessageHandler&amp;gt; configureHandler)
        {
            if (builder == null)
            {
                throw new ArgumentNullException(nameof(builder));
            }

            if (configureHandler == null)
            {
                throw new ArgumentNullException(nameof(configureHandler));
            }

            builder.Services.Configure&amp;lt;HttpClientFactoryOptions&amp;gt;(builder.Name, options =&amp;gt;
            {
                options.HttpMessageHandlerBuilderActions.Add(b =&amp;gt; b.PrimaryHandler = configureHandler());
            });

            return builder;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的&lt;code&gt;HttpMessageHandlerBuilder&lt;/code&gt; 源代码分析&lt;code&gt;ConfigurePrimaryHttpMessageHandler&lt;/code&gt; 方法主要是给Builder 中添加&lt;code&gt;PrimaryHandler&lt;/code&gt;消息Handler&lt;/p&gt;
&lt;h3 id=&quot;25-defaulthttpmessagehandlerbuilder&quot;&gt;2.5 DefaultHttpMessageHandlerBuilder&lt;/h3&gt;
&lt;p&gt;我们知道在&lt;code&gt;services.AddHttpClient()&lt;/code&gt; 方法中会注册默认的&lt;code&gt;DefaultHttpMessageHandlerBuilder&lt;/code&gt; 消息构造器方法，它继承&lt;code&gt;DefaultHttpMessageHandlerBuilder&lt;/code&gt;,那我们来看看它的源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;internal class DefaultHttpMessageHandlerBuilder : HttpMessageHandlerBuilder
    {
        public DefaultHttpMessageHandlerBuilder(IServiceProvider services)
        {
            Services = services;
        }

        private string _name;

        public override string Name
        {
            get =&amp;gt; _name;
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException(nameof(value));
                }

                _name = value;
            }
        }

        public override HttpMessageHandler PrimaryHandler { get; set; } = new HttpClientHandler();

        public override IList&amp;lt;DelegatingHandler&amp;gt; AdditionalHandlers { get; } = new List&amp;lt;DelegatingHandler&amp;gt;();

        public override IServiceProvider Services { get; }

        public override HttpMessageHandler Build()
        {
            if (PrimaryHandler == null)
            {
                var message = Resources.FormatHttpMessageHandlerBuilder_PrimaryHandlerIsNull(nameof(PrimaryHandler));
                throw new InvalidOperationException(message);
            }
            
            return CreateHandlerPipeline(PrimaryHandler, AdditionalHandlers);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中&lt;code&gt;Build&lt;/code&gt; 会去调用HttpMessageHandlerBuilder 的&lt;code&gt;CreateHandlerPipeline&lt;/code&gt;方法把HttpMessageHandler 构建成一个类似于链表的结构。&lt;br/&gt;到这里源代码已经分析完了，接下来我们来演示一个Demo，来证明上面的核心HttpMessageHandler 流程走向图&lt;/p&gt;
&lt;h2 id=&quot;三、demo演示证明&quot;&gt;三、Demo演示证明&lt;/h2&gt;
&lt;p&gt;我们继续来看上面我的Demo代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddHttpClient(&quot;test&quot;)
        .ConfigurePrimaryHttpMessageHandler(provider =&amp;gt;
        {
            return new PrimaryHttpMessageHandler(provider);
        })
        .AddHttpMessageHandler(provider =&amp;gt;
        {
            return new LogHttpMessageHandler(provider);
        })
        .AddHttpMessageHandler(provider =&amp;gt;
        {
           return new Log2HttpMessageHandler(provider);
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中自定义了两个&lt;code&gt;HttpMessageHandler&lt;/code&gt;和一个&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt;&lt;br/&gt;我们再来分别看看&lt;code&gt;Log2HttpMessageHandler&lt;/code&gt;、&lt;code&gt;LogHttpMessageHandler&lt;/code&gt; 和&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt; 代码，代码很简单就是&lt;code&gt;SendAsync&lt;/code&gt;前后输出了Log信息，代码如下：&lt;br/&gt;自定义的&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrimaryHttpMessageHandler: DelegatingHandler
    {
        private IServiceProvider _provider;

        public PrimaryHttpMessageHandler(IServiceProvider provider)
        {
            _provider = provider;
            InnerHandler = new HttpClientHandler();
        }

        protected async override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            System.Console.WriteLine(&quot;PrimaryHttpMessageHandler Start Log&quot;);

            var response= await base.SendAsync(request, cancellationToken);
            System.Console.WriteLine(&quot;PrimaryHttpMessageHandler End Log&quot;);
            return response;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Log2HttpMessageHandler&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class Log2HttpMessageHandler : DelegatingHandler
    {
        private IServiceProvider _provider;

        public Log2HttpMessageHandler(IServiceProvider provider)
        {
            _provider = provider;
            //InnerHandler = new HttpClientHandler();
        }

        protected async override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            System.Console.WriteLine(&quot;LogHttpMessageHandler2 Start Log&quot;);
            var response=await base.SendAsync(request, cancellationToken);
            System.Console.WriteLine(&quot;LogHttpMessageHandler2 End Log&quot;);

            return response;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LogHttpMessageHandler&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class LogHttpMessageHandler : DelegatingHandler
  {
        private IServiceProvider _provider;

        public LogHttpMessageHandler(IServiceProvider provider)
        {
            _provider = provider;
            //InnerHandler = new HttpClientHandler();
        }

        protected async override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            System.Console.WriteLine(&quot;LogHttpMessageHandler Start Log&quot;);
            var response=await base.SendAsync(request, cancellationToken);
            System.Console.WriteLine(&quot;LogHttpMessageHandler End Log&quot;);
            return response;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个自定义Handler 代码已经完成，我们继续添加调用代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;url&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;string&amp;gt; GetBaiduAsync(string url)
        {
            var client = _clientFactory.CreateClient(&quot;test&quot;);
            var result = await client.GetStringAsync(url);
            return result;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们运行访问接口，运行后的控制台Log 如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202005/824291-20200523183405089-1274193421.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;看到输出结果，大家有没有发现跟Asp.net core 中的中间件管道的运行图一样。&lt;/p&gt;
&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HttpClient&lt;/code&gt;中&lt;code&gt;HttpMessageHandler&lt;/code&gt;可以自定义多个，但是只能有一个&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt;如果添加多个只会被最后面添加的给覆盖；添加的一系列Handler 构成一个链式管道模型，并且&lt;code&gt;PrimaryHttpMessageHandler&lt;/code&gt; 主的消息Handler 是在管道的最外层，也就是管道模型中的最后一道Handler。&lt;br/&gt;使用场景：我们可以通过自定义的MessageHandler 来动态加载请求证书，通过数据库的一些信息，在自定义的Handler 中加载注入对应的证书，这样可以起到动态加载支付证书作用，同时可以SendAsync 之前或者之后做一些自己的验证等相关业务，大家只需要理解它们的用途，自然知道它的强大作用，今天就分享到这里&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 24 May 2020 23:56:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>我们可以通过自定义的MessageHandler 来动态加载请求证书，通过数据库的一些信息，在自定义的Handler 中加载注入对应的证书，这样可以起到动态加载支付证书作用，同时可以SendAsync</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12897923.html</dc:identifier>
</item>
<item>
<title>List的扩容机制，你真的明白吗？ - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12954569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12954569.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;在前一篇大内存排查中，我们看到了Dictionary正在做扩容操作，当时这个字典的count=251w，你把字典玩的66飞起，其实都是底层为你负重前行，比如其中的扩容机制，当你遇到几百万甚至千万的大集合这个扩容机制还真的需要挖一下，免的入戏太深，难以自拔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200525075533693-1870681020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了方便讲述，我准备从List说起，因为它最简单哈😁😁😁&lt;/p&gt;
&lt;h2 id=&quot;二：list扩容机制&quot;&gt;二：List扩容机制&lt;/h2&gt;
&lt;h3 id=&quot;1-如何查看&quot;&gt;1. 如何查看&lt;/h3&gt;
&lt;p&gt;要想看它的扩容机制，可以用ILSpy去看看List的源码即可，非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200525075534016-112265824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从源码的 &lt;code&gt;int num = (_items.Length == 0) ? 4 : (_items.Length * 2)&lt;/code&gt; 可以非常清楚的看到，4个空间起步，后面都是 &lt;code&gt;*2&lt;/code&gt; 的扩容，也就说当你有 &lt;code&gt;2^(n-1) + 1&lt;/code&gt; 个元素，实际上你需要占用 &lt;code&gt;2^n&lt;/code&gt; 个空间。&lt;/p&gt;
&lt;p&gt;下面我用C#代码演示一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var list1 = Enumerable.Range(0, (int)Math.Pow(2, 22)).ToList();

            var list2 = new List&amp;lt;int&amp;gt;(list1);
            list2.Add(1);

            Console.WriteLine($&quot;list1.Capacity={list1.Capacity}&quot;);
            Console.WriteLine($&quot;list2.Capacity={list2.Capacity}&quot;);

            Console.ReadLine();
        }

 ------ output -------

list1.Capacity=4194304
list2.Capacity=8388608

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看到，当List中已有 &lt;code&gt;4194304&lt;/code&gt;个元素的时候，再往其中塞入一个元素，仅仅是多一个，在底层可是翻倍的空间占用哦，太可气了，要想往深处看可以用windbg看一下各自数组占用大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !DumpObj /d 000001ec037d2e20
Name:        System.Collections.Generic.List`1[[System.Int32, mscorlib]]
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ffde2ac8538  400189e        8       System.Int32[]  0 instance 000001ec147b9c10 _items
00007ffde2ac85a0  400189f       18         System.Int32  1 instance          4194304 _size
00007ffde2ac85a0  40018a0       1c         System.Int32  1 instance          4194304 _version
00007ffde2ac5dd8  40018a1       10        System.Object  0 instance 0000000000000000 _syncRoot
00007ffde2ac8538  40018a2        0       System.Int32[]  0   shared           static _emptyArray
                                 &amp;gt;&amp;gt; Domain:Value dynamic statics NYI 000001ec01bc0920:NotInit  &amp;lt;&amp;lt;

0:000&amp;gt; !do 000001ec147b9c10
Name:        System.Int32[]
MethodTable: 00007ffde2ac8538
EEClass:     00007ffde2c35918
Size:        16777240(0x1000018) bytes
Array:       Rank 1, Number of elements 4194304, Type Int32 (Print Array)
Fields:
None


0:000&amp;gt; !do 000001ec037d2e78
Name:        System.Collections.Generic.List`1[[System.Int32, mscorlib]]
MethodTable: 00007ffde2ada068
EEClass:     00007ffde2c3b008
Size:        40(0x28) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ffde2ac8538  400189e        8       System.Int32[]  0 instance 000001ec167b9c80 _items
00007ffde2ac85a0  400189f       18         System.Int32  1 instance          4194305 _size
00007ffde2ac85a0  40018a0       1c         System.Int32  1 instance                1 _version
00007ffde2ac5dd8  40018a1       10        System.Object  0 instance 0000000000000000 _syncRoot
00007ffde2ac8538  40018a2        0       System.Int32[]  0   shared           static _emptyArray
                                 &amp;gt;&amp;gt; Domain:Value dynamic statics NYI 000001ec01bc0920:NotInit  &amp;lt;&amp;lt;
0:000&amp;gt; !do 000001ec167b9c80
Name:        System.Int32[]
MethodTable: 00007ffde2ac8538
EEClass:     00007ffde2c35918
Size:        33554456(0x2000018) bytes
Array:       Rank 1, Number of elements 8388608, Type Int32 (Print Array)
Fields:
None


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以清楚的看到,一个int[] 占用 &lt;code&gt;16777240 byte /1024/1024 =16M&lt;/code&gt;，一个 int[] 占用 &lt;code&gt;33554456 byte/1024/1024 =32M&lt;/code&gt;,可这是翻倍的空间哈。&lt;/p&gt;
&lt;h3 id=&quot;2-真的以为是仅仅翻了一倍吗？&quot;&gt;2. 真的以为是仅仅翻了一倍吗？&lt;/h3&gt;
&lt;p&gt;为什么我要这么说呢？仔细看看&lt;code&gt;Capacity&lt;/code&gt;的Set实现，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public int Capacity
{
        get{ return _items.Length; }
        set
        {
                if (value &amp;gt; 0)
                {
                        T[] array = new T[value];
                        if (_size &amp;gt; 0)
                        {
                                Array.Copy(_items, 0, array, 0, _size);
                        }
                        _items = array;
                }
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家仔细研读，这个流程是先定义好新size的数组array，然后将老的数组(_items) copy到 新数组array中，然后将array的引用给了老的数组,不难看出真正的Size应该是 &lt;code&gt;array(32M) + _items（16M） =48M&lt;/code&gt; 才是真正的大小，只要GC没有回收老的&lt;code&gt;_items(16M)&lt;/code&gt;，那就一直保持&lt;code&gt;48M&lt;/code&gt;的大小，你说呢？&lt;/p&gt;
&lt;p&gt;要怎么验证呢? 大家可以用windbg去看看托管堆中 &lt;code&gt;int[]&lt;/code&gt; 不就可以啦。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
var list1 = Enumerable.Range(0, (int)Math.Pow(2, 22)).ToList();
list1.Add(1);

0:000&amp;gt; !DumpHeap -mt 00007ffde2ac8538  -min 102400
         Address               MT     Size
0000024c103e9ba0 00007ffde2ac8538  4194328     
0000024c107e9bd8 00007ffde2ac8538  8388632     
0000024c10fe9c10 00007ffde2ac8538 16777240     
0000024c11fe9c48 00007ffde2ac8538 33554456     

Statistics:
              MT    Count    TotalSize Class Name
00007ffde2ac8538        4     62914656 System.Int32[]
Total 4 objects


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从信息中看&lt;code&gt;(16777240 + 33554456)byte = 48M&lt;/code&gt;，按照刚才的理论这个&lt;code&gt;16777240&lt;/code&gt;的int[]应该是没有引用根的等待被GC回收，所以用&lt;code&gt;!gcroot&lt;/code&gt; 把两个 &lt;code&gt;int[]&lt;/code&gt; 都打印出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !gcroot 0000024c10fe9c10
Found 0 unique roots (run '!GCRoot -all' to see all roots).

0:000&amp;gt; !gcroot 0000024c11fe9c48
Thread 63dc:
    0000007b4abfee60 00007ffd85950938 ConsoleApp6.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp6\Program.cs @ 28]
        rbp-38: 0000007b4abfee88
            -&amp;gt;  0000024c00002da0 System.Collections.Generic.List`1[[System.Int32, mscorlib]]
            -&amp;gt;  0000024c11fe9c48 System.Int32[]

Found 1 unique roots (run '!GCRoot -all' to see all roots).

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;code&gt;0000024c10fe9c10&lt;/code&gt; 确实是没有引用根，也就验证了其实真正的是48M，而不是32M，翻了2倍哦。。。有点小恐怖。&lt;/p&gt;
&lt;h2 id=&quot;二：-如何压缩&quot;&gt;二： 如何压缩&lt;/h2&gt;
&lt;h2 id=&quot;1-系统提供的压缩机制&quot;&gt;1. 系统提供的压缩机制&lt;/h2&gt;
&lt;p&gt;回过头来看 &lt;code&gt;Capacity&lt;/code&gt; 属性中的扩容机制，你只需要将Capacity设置与Count平齐，_items数组多余的虚占空间就给清掉了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var list1 = Enumerable.Range(0, (int)Math.Pow(2, 22)).ToList();
            list1.Add(1);
            list1.Capacity = list1.Count;

            Console.ReadLine();
        }
       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200525075534307-1635751338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，数组中的 &lt;code&gt;8388608-4194305 =4194303&lt;/code&gt; 个int直接给灭掉了，优化了空间。&lt;/p&gt;
&lt;h2 id=&quot;2-自定义list&quot;&gt;2. 自定义List&lt;/h2&gt;
&lt;p&gt;其实问题的根源出在了&lt;span&gt;扩容机制&lt;/span&gt;，举个例子，如果当length大于400w的时候，默认情况下是翻倍成800w，有时候根据你的业务不需要翻到800w，其实500w就足够了，这样300w的虚占就可以免掉，所以必要的时候自己实现一个list，然后灵活控制它的扩容机制，妙哉妙哉~~~&lt;/p&gt;
&lt;h2 id=&quot;五：总结&quot;&gt;五：总结&lt;/h2&gt;
&lt;p&gt;明白扩容机制对你了解在大数据量下使用List还是非常有帮助的，大家根据自己的场景合理化使用，下一篇我们聊一聊HashSet。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Sun, 24 May 2020 23:56:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 在前一篇大内存排查中，我们看到了Dictionary正在做扩容操作，当时这个字典的count=251w，你把字典玩的66飞起，其实都是底层为你负重前行，比如其中的扩容机制，当你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12954569.html</dc:identifier>
</item>
<item>
<title>[开源] .Net orm FreeSql 1.5.0 最新版本（番号：好久不见） - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/12953836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/12953836.html</guid>
<description>&lt;p&gt;这篇文章是我有史以来编辑最长时间的，历时 4小时！！！原本我可以利用这 4小时编写一堆胶水代码，真心希望善良的您点个赞，谢谢了！！&lt;/p&gt;
&lt;p&gt;很久很久没有写文章了，上一次还是在元旦发布 1.0 版本的时候，今年版本规划是每月底发布小版本（年底发布 2.0），全年的开源工作主要是收集用户需求增加功能，完善测试，修复 bug。FreeSql 1.0 -&amp;gt; 1.5 相隔半年有哪些新功能？只能说每个功能都能让我兴奋，并且能感受到使用者也一样兴奋（妄想症）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525020352140-782072291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迫不及待的人会问，这更新速度也太快了吧，升级会不会有问题？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不了解版本的更新日志，直接升级不是好的习惯，建议关注我们的更新日志（github 上有专门的文档）；&lt;/li&gt;
&lt;li&gt;我们的版本开发原则：在尽量保证兼容的情况下，增加新功能，砍掉少量不合理的功能；&lt;/li&gt;
&lt;li&gt;我们的单元测试数量：4000+，这是我们引以自豪，发布版本的保障；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FreeSql 是 .Net ORM，能支持 .NetFramework4.0+、.NetCore、Xamarin、XAUI、Blazor、以及还有说不出来的运行平台，因为代码绿色无依赖，支持新平台非常简单。目前单元测试数量：4000+，Nuget下载数量：123K+，源码几乎每天都有提交。值得高兴的是 FreeSql 加入了 ncc 开源社区：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，加入组织之后社区责任感更大，需要更努力做好品质，为开源社区出一份力。QQ开发群：4336577&lt;/p&gt;
&lt;p&gt;为什么要重复造轮子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525013907903-1470982538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;FreeSql 主要优势在于易用性上，基本是开箱即用，在不同数据库之间切换兼容性比较好。作者花了大量的时间精力在这个项目，肯请您花半小时了解下项目，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FreeSql 整体的功能特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 CodeFirst 对比结构变化迁移；&lt;/li&gt;
&lt;li&gt;支持 DbFirst 从数据库导入实体类；&lt;/li&gt;
&lt;li&gt;支持 丰富的表达式函数，自定义解析；&lt;/li&gt;
&lt;li&gt;支持 批量添加、批量更新、BulkCopy；&lt;/li&gt;
&lt;li&gt;支持 导航属性，贪婪加载、延时加载、级联保存；&lt;/li&gt;
&lt;li&gt;支持 读写分离、分表分库，租户设计；&lt;/li&gt;
&lt;li&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/达梦/MsAccess；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.0 -&amp;gt; 1.5 更新的重要功能如下：&lt;/p&gt;
&lt;p&gt;一、UnitOfWorkManager 工作单元管理器，可实现 Spring 事务设计；&lt;/p&gt;
&lt;p&gt;二、IFreeSql.InsertOrUpdate 实现批量保存，执行时根据数据库自动适配执行 merge into 或者 on duplicate key update；&lt;/p&gt;
&lt;p&gt;三、ISelect.WhereDynamicFilter 方法实现动态过滤条件（与前端交互）；&lt;/p&gt;
&lt;p&gt;四、自动适配表达式解析 yyyyMMdd 常用 c# 日期格式化；&lt;/p&gt;
&lt;p&gt;五、IUpdate.SetSourceIgnore 方法实现忽略属性值为 null 的字段；&lt;/p&gt;
&lt;p&gt;六、FreeSql.Provider.Dameng 基于 DmProvider Ado.net 访问达梦数据库；&lt;/p&gt;
&lt;p&gt;七、自动识别 EFCore 常用的实体特性，FreeSql.DbContext 拥有和 EFCore 高相似度的语法，并且支持 90% 相似的 FluentApi；&lt;/p&gt;
&lt;p&gt;八、ISelect.ToTreeList 扩展方法查询数据，把配置父子导航属性的实体加工为树型 List；&lt;/p&gt;
&lt;p&gt;九、BulkCopy 相关方法提升大批量数据插入性能；&lt;/p&gt;
&lt;p&gt;十、Sqlite :memrory: 内存模式；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014307613-207448539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FreeSql 使用非常简单，只需要定义一个 IFreeSql 对象即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.MySql, connectionString)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SongService
{
    BaseRepository&amp;lt;Song&amp;gt; _repo;

    public SongService(BaseRepository&amp;lt;Song&amp;gt; repo)
    {
        _repo = repo;
    }

    [Transactional]
    public virtual void Test1()
    {
        _repo.Insert(new Song { Title = &quot;卡农1&quot; }); //事务1
        this.Test2();
    }

    [Transactional(Propagation = Propagation.Nested)] //嵌套事务，新的（不使用 Test1 的事务）
    public virtual void Test2()
    {
        _repo.Insert(new Song { Title = &quot;卡农2&quot; });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseRepository 是 FreeSql.BaseRepository 包实现的通用仓储类，实际项目中可以继承它再使用。&lt;/p&gt;
&lt;p&gt;Propagation 的模式参考了 Spring 事务，在以下几种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，默认的选择。&lt;/li&gt;
&lt;li&gt;Supports：支持当前事务，如果没有当前事务，就以非事务方法执行。&lt;/li&gt;
&lt;li&gt;Mandatory：使用当前事务，如果没有当前事务，就抛出异常。&lt;/li&gt;
&lt;li&gt;NotSupported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/li&gt;
&lt;li&gt;Never：以非事务方式执行操作，如果当前事务存在则抛出异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nested：以嵌套事务方式执行。&lt;/strong&gt;（上面的例子使用的这个）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;UnitOfWorkManager 正是干这件事的。避免了每次对数据操作都要现获得 Session 实例来启动事务/提交/回滚事务还有繁琐的Try/Catch操作。这些也是 AOP（面向切面编程）机制很好的应用。一方面使开发业务逻辑更清晰、专业分工更加容易进行。另一方面就是应用 AOP 隔离降低了程序的耦合性使我们可以在不同的应用中将各个切面结合起来使用大大提高了代码重用度。&lt;/p&gt;
&lt;p&gt;使用前准备第一步：配置 Startup.cs 注入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&amp;lt;IFreeSql&amp;gt;(fsql);
    services.AddScoped&amp;lt;UnitOfWorkManager&amp;gt;();
    services.AddFreeRepository(null, typeof(Startup).Assembly);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;UnitOfWorkManager 成员&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IUnitOfWork Current&lt;/td&gt;
&lt;td&gt;返回当前的工作单元&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void Binding(repository)&lt;/td&gt;
&lt;td&gt;将仓储的事务交给它管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;IUnitOfWork Begin(propagation, isolationLevel)&lt;/td&gt;
&lt;td&gt;创建工作单元&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用前准备第二步：定义事务特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[AttributeUsage(AttributeTargets.Method)]
public class TransactionalAttribute : Attribute
{
    /// &amp;lt;summary&amp;gt;
    /// 事务传播方式
    /// &amp;lt;/summary&amp;gt;
    public Propagation Propagation { get; set; } = Propagation.Requierd;
    /// &amp;lt;summary&amp;gt;
    /// 事务隔离级别
    /// &amp;lt;/summary&amp;gt;
    public IsolationLevel? IsolationLevel { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用前准备第三步：引入动态代理库&lt;/p&gt;
&lt;p&gt;在 Before 从容器中获取 UnitOfWorkManager，调用它的 var uow = uowManager.Begin(attr.Propagation, attr.IsolationLevel) 方法&lt;/p&gt;
&lt;p&gt;在 After 调用 Before 中的 uow.Commit 或者 Rollback 方法，最后调用 uow.Dispose&lt;/p&gt;
&lt;p&gt;自问自答：是不是进方法就开事务呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不一定是真实事务，有可能是虚的，就是一个假的 unitofwork（不带事务），也有可能是延用上一次的事务，也有可能是新开事务，具体要看传播模式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;IFreeSql 定义了 InsertOrUpdate 方法实现批量插入或更新的功能，利用的是数据库特性进行保存，执行时根据数据库自动适配：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;MySql&lt;/td&gt;
&lt;td&gt;on duplicate key update&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;on conflict do update&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlServer&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Oracle&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sqlite&lt;/td&gt;
&lt;td&gt;replace into&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dameng&lt;/td&gt;
&lt;td&gt;merge into&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.InsertOrUpdate&amp;lt;T&amp;gt;()
  .SetSource(items) //需要操作的数据
  .ExecuteAffrows();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们前面定义 fsql 变量的类型是 MySql，所以执行的语句大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO `T`(`id`, `name`) VALUES(1, '001'), (2, '002'), (3, '003'), (4, '004')
ON DUPLICATE KEY UPDATE
`name` = VALUES(`name`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当实体类有自增属性时，批量 InsertOrUpdate 最多可被拆成两次执行，内部计算出未设置自增值、和有设置自增值的数据，分别执行 insert into 和 上面讲到的 merge into 两种命令（采用事务执行）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200524235718959-1427957349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否见过这样的高级查询功能，WhereDynamicFilter 在后端可以轻松完成这件事情，前端根据 UI 组装好对应的 json 字符串传给后端就行，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DynamicFilterInfo dyfilter = JsonConvert.DeserializeObject&amp;lt;DynamicFilterInfo&amp;gt;(@&quot;
{
  &quot;&quot;Logic&quot;&quot; : &quot;&quot;Or&quot;&quot;,
  &quot;&quot;Filters&quot;&quot; :
  [
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Code&quot;&quot;,
      &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotContains&quot;&quot;,
      &quot;&quot;Value&quot;&quot; : &quot;&quot;val1&quot;&quot;,
      &quot;&quot;Filters&quot;&quot; :
      [
        {
          &quot;&quot;Field&quot;&quot; : &quot;&quot;Name&quot;&quot;,
          &quot;&quot;Operator&quot;&quot; : &quot;&quot;NotStartsWith&quot;&quot;,
          &quot;&quot;Value&quot;&quot; : &quot;&quot;val2&quot;&quot;,
        }
      ]
    },
    {
      &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Code&quot;&quot;,
      &quot;&quot;Operator&quot;&quot; : &quot;&quot;Eq&quot;&quot;,
      &quot;&quot;Value&quot;&quot; : &quot;&quot;val11&quot;&quot;,
      &quot;&quot;Filters&quot;&quot; :
      [
        {
          &quot;&quot;Field&quot;&quot; : &quot;&quot;Parent.Name&quot;&quot;,
          &quot;&quot;Operator&quot;&quot; : &quot;&quot;Contains&quot;&quot;,
          &quot;&quot;Value&quot;&quot; : &quot;&quot;val22&quot;&quot;,
        }
      ]
    }
  ]
}
&quot;);
fsql.Select&amp;lt;VM_District_Parent&amp;gt;().WhereDynamicFilter(dyfilter).ToList();
//SELECT a.&quot;&quot;Code&quot;&quot;, a.&quot;&quot;Name&quot;&quot;, a.&quot;&quot;ParentCode&quot;&quot;, a__Parent.&quot;&quot;Code&quot;&quot; as4, a__Parent.&quot;&quot;Name&quot;&quot; as5, a__Parent.&quot;&quot;ParentCode&quot;&quot; as6 
//FROM &quot;&quot;D_District&quot;&quot; a 
//LEFT JOIN &quot;&quot;D_District&quot;&quot; a__Parent ON a__Parent.&quot;&quot;Code&quot;&quot; = a.&quot;&quot;ParentCode&quot;&quot; 
//WHERE (not((a.&quot;&quot;Code&quot;&quot;) LIKE '%val1%') AND not((a.&quot;&quot;Name&quot;&quot;) LIKE 'val2%') OR a__Parent.&quot;&quot;Code&quot;&quot; = 'val11' AND (a__Parent.&quot;&quot;Name&quot;&quot;) LIKE '%val22%')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的操作符：Contains/StartsWith/EndsWith/NotContains/NotStartsWith/NotEndsWith、Equals/Eq/NotEqual、GreaterThan/GreaterThanOrEqual、LessThan/LessThanOrEqual&lt;/p&gt;

&lt;p&gt;不知道大家有没有这个困扰，在 ORM 表达式使用 DateTime.Now.ToString(&quot;yyyyMM&quot;) 是件很难转换的事，在我适配的这些数据库中，只有 MsAccess 可以直接翻译成对应的 SQL 执行。&lt;/p&gt;
&lt;p&gt;这个想法来自另一个 ORM issues，我时不时会去了解其他 ORM 优点和缺陷，以便给 FreeSql 做补充。&lt;/p&gt;
&lt;p&gt;想法出来之后当于，也就是昨天 2020/5/24 奋战一宿完成的，除了每个数据库进行编码适配外，更多的时间耗在了单元测试上，目前已全部通过（4000+单元测试不是吹的）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;仅以此功能让大家感受一下 FreeSql 的认真，他不是一些人口中所说的个人项目，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014552754-1095602309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var dtn = DateTime.Parse(&quot;2020-1-1 0:0:0&quot;);
var dts = Enumerable.Range(1, 12).Select(a =&amp;gt; dtn.AddMonths(a))
    .Concat(Enumerable.Range(1, 31).Select(a =&amp;gt; dtn.AddDays(a)))
    .Concat(Enumerable.Range(1, 24).Select(a =&amp;gt; dtn.AddHours(a)))
    .Concat(Enumerable.Range(1, 60).Select(a =&amp;gt; dtn.AddMinutes(a)))
    .Concat(Enumerable.Range(1, 60).Select(a =&amp;gt; dtn.AddSeconds(a)));
foreach (var dt in dts)
{
    Assert.Equal(dt.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString()));
    Assert.Equal(dt.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy-MM-dd HH:mm&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy-MM-dd HH:mm&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy-MM-dd HH&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy-MM-dd HH&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy-MM-dd&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy-MM-dd&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy-MM&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy-MM&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyyMMddHHmmss&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyyMMddHHmmss&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyyMMddHHmm&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyyMMddHHmm&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyyMMddHH&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyyMMddHH&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyyMMdd&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyyMMdd&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyyMM&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyyMM&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy&quot;)));
    Assert.Equal(dt.ToString(&quot;HH:mm:ss&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;HH:mm:ss&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy MM dd HH mm ss yy M d H hh h&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy MM dd HH mm ss yy M d H hh h&quot;)));
    Assert.Equal(dt.ToString(&quot;yyyy MM dd HH mm ss yy M d H hh h m s tt t&quot;).Replace(&quot;上午&quot;, &quot;AM&quot;).Replace(&quot;下午&quot;, &quot;PM&quot;).Replace(&quot;上&quot;, &quot;A&quot;).Replace(&quot;下&quot;, &quot;P&quot;), fsql.Select&amp;lt;T&amp;gt;().First(a =&amp;gt; dt.ToString(&quot;yyyy MM dd HH mm ss yy M d H hh h m s tt t&quot;)));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;支持常用 c# 日期格式化，yyyy MM dd HH mm ss yy M d H hh h m s tt t&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;tt t 为 AM PM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AM PM 这两个转换不完美，勉强能使用。&lt;/p&gt;

&lt;p&gt;这个功能被用户提了几次，每一次都认为 FreeSql.Repository 的状态对比可以完成这件事。&lt;/p&gt;
&lt;p&gt;这一次作者心疼他们了，为什么一定要用某个功能限制住使用者？大家是否经常听谁说 EF框架、MVC框架，框架的定义其实是约束+规范。&lt;/p&gt;
&lt;p&gt;作者不想做这样的约束，作者更希望尽量提供多一些实用功能让用户自己选择，把项目定义为：功能组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Update&amp;lt;Song&amp;gt;()
  .SetSourceIgnore(item, col =&amp;gt; col == null)
  .ExecuteAffrows();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数是 Func&amp;lt;object, bool&amp;gt; 类型，col 相当于属性的值，上面的代码更新实体 item 的时候会忽略 == null 的属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014719547-2026942960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;武汉达梦数据库有限公司成立于2000年，为中国电子信息产业集团(CEC)旗下基础软件企业，专业从事数据库管理系统的研发、销售与服务，同时可为用户提供大数据平台架构咨询、数据技术方案规划、产品部署与实施等服务。多年来，达梦公司始终坚持原始创新、独立研发，目前已掌握数据管理与数据分析领域的核心前沿技术，拥有全部源代码，具有完全自主知识产权。&lt;/p&gt;
&lt;p&gt;不知道大家没有听说过相关政策，政府推动国产化以后是趋势，虽然 .NET 不是国产，但是目前无法限制编程语言，当下正在对操作系统、数据库强制推进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014801483-1494727409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道 EFCore for oracle 问题多，并且现在还没更新到 3.x，在这样的背景下，一个国产数据库更不能指望谁实现好用的 EFCore。目前看来除了 EFCore for sqlserver 我们没把握完全占优势，起码在其他数据库肯定是我们更接地气。&lt;/p&gt;
&lt;p&gt;言归正传，达梦数据库其实蛮早就支持了，之前是以 Odbc 的方式实现的，后面根据使用者的反馈 Odbc 环境问题比较麻烦，经研究决定支持 ado.net 适配，让使用者更加方便。使用 ado.net 方式连接达梦只需要修改 IFreeSql 创建时候的类型即可，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.Dameng, connectionString)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;EFCore 目前用户量最多，为了方便一些项目过渡到 FreeSql，我们做了一些 “AI”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525014844442-829663116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动识别 EFCore 实体特性：Key/Required/NotMapped/Table/Column&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-scharp&quot;&gt;[Table(&quot;table01&quot;)] //这个其实是 EFCore 的特性
class MyTable
{
    [Key]
    public int Id { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;与 EFCore 90% 相似的 FluentApi&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.CodeFirst.Entity&amp;lt;Song&amp;gt;(eb =&amp;gt; {
    eb.ToTable(&quot;tb_song&quot;);
    eb.Ignore(a =&amp;gt; a.Field1);
    eb.Property(a =&amp;gt; a.Title).HasColumnType(&quot;varchar(50)&quot;).IsRequired();
    eb.Property(a =&amp;gt; a.Url).HasMaxLength(100);

    eb.Property(a =&amp;gt; a.RowVersion).IsRowVersion();
    eb.Property(a =&amp;gt; a.CreateTime).HasDefaultValueSql(&quot;current_timestamp&quot;);

    eb.HasKey(a =&amp;gt; a.Id);
    eb.HasIndex(a =&amp;gt; new { a.Id, a.Title }).IsUnique().HasName(&quot;idx_xxx11&quot;);

    //一对多、多对一
    eb.HasOne(a =&amp;gt; a.Type).HasForeignKey(a =&amp;gt; a.TypeId).WithMany(a =&amp;gt; a.Songs);

    //多对多
    eb.HasMany(a =&amp;gt; a.Tags).WithMany(a =&amp;gt; a.Songs, typeof(Song_tag));
});

fsql.CodeFirst.Entity&amp;lt;SongType&amp;gt;(eb =&amp;gt; {
    eb.HasMany(a =&amp;gt; a.Songs).WithOne(a =&amp;gt; a.Type).HasForeignKey(a =&amp;gt; a.TypeId);
    eb.HasData(new[]
    {
        new SongType
        {
            Id = 1,
            Name = &quot;流行&quot;,
            Songs = new List&amp;lt;Song&amp;gt;(new[]
            {
                new Song{ Title = &quot;真的爱你&quot; },
                new Song{ Title = &quot;爱你一万年&quot; },
            })
        },
        new SongType
        {
            Id = 2,
            Name = &quot;乡村&quot;,
            Songs = new List&amp;lt;Song&amp;gt;(new[]
            {
                new Song{ Title = &quot;乡里乡亲&quot; },
            })
        },
    });
});

public class SongType {
    public int Id { get; set; }
    public string Name { get; set; }

    public List&amp;lt;Song&amp;gt; Songs { get; set; }
}
public class Song {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public string Title { get; set; }
    public string Url { get; set; }
    public DateTime CreateTime { get; set; }

    public int TypeId { get; set; }
    public SongType Type { get; set; }

    public int Field1 { get; set; }
    public long RowVersion { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这是几个意思？有做过父子关系的表应该知道的，把数据查回来了是平面的，需要再用递归转化为树型。考虑到这个功能实用性比较高，所以就集成了进来。来自单元测试的一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var repo = fsql.GetRepository&amp;lt;VM_District_Child&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new VM_District_Child
{
    Code = &quot;100000&quot;,
    Name = &quot;中国&quot;,
    Childs = new List&amp;lt;VM_District_Child&amp;gt;(new[] {
        new VM_District_Child
        {
            Code = &quot;110000&quot;,
            Name = &quot;北京市&quot;,
            Childs = new List&amp;lt;VM_District_Child&amp;gt;(new[] {
                new VM_District_Child{ Code=&quot;110100&quot;, Name = &quot;北京市&quot; },
                new VM_District_Child{ Code=&quot;110101&quot;, Name = &quot;东城区&quot; },
            })
        }
    })
});
var t3 = fsql.Select&amp;lt;VM_District_Child&amp;gt;().ToTreeList();
Assert.Single(t3);
Assert.Equal(&quot;100000&quot;, t3[0].Code);
Assert.Single(t3[0].Childs);
Assert.Equal(&quot;110000&quot;, t3[0].Childs[0].Code);
Assert.Equal(2, t3[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t3[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t3[0].Childs[0].Childs[1].Code);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：实体需要配置父子导航属性&lt;/p&gt;

&lt;p&gt;原先 FreeSql 对批量数据操作就做得还可以，例如批量数据超过数据库某些限制的，会拆分执行，性能其实也还行。&lt;/p&gt;
&lt;p&gt;本需求也是来自用户，然后就实现了，实现完了我还专门做了性能测试对比，sqlserver bulkcopy 收益比较大，mysql 收益非常小。&lt;/p&gt;
&lt;p&gt;测试结果(52个字段，18W-50行数据，单位ms)：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;18W&lt;/th&gt;
&lt;th&gt;1W&lt;/th&gt;
&lt;th&gt;5K&lt;/th&gt;
&lt;th&gt;500&lt;/th&gt;
&lt;th&gt;50&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;MySql 5.5 ExecuteAffrows&lt;/td&gt;
&lt;td&gt;38,481&lt;/td&gt;
&lt;td&gt;2,234&lt;/td&gt;
&lt;td&gt;1,136&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MySql 5.5 ExecuteMySqlBulkCopy&lt;/td&gt;
&lt;td&gt;28,405&lt;/td&gt;
&lt;td&gt;1,142&lt;/td&gt;
&lt;td&gt;657&lt;/td&gt;
&lt;td&gt;592&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SqlServer Express ExecuteAffrows&lt;/td&gt;
&lt;td&gt;402,355&lt;/td&gt;
&lt;td&gt;24,847&lt;/td&gt;
&lt;td&gt;11,465&lt;/td&gt;
&lt;td&gt;915&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SqlServer Express ExecuteSqlBulkCopy&lt;/td&gt;
&lt;td&gt;21,065&lt;/td&gt;
&lt;td&gt;578&lt;/td&gt;
&lt;td&gt;326&lt;/td&gt;
&lt;td&gt;79&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PostgreSQL 10 ExecuteAffrows&lt;/td&gt;
&lt;td&gt;46,756&lt;/td&gt;
&lt;td&gt;3,294&lt;/td&gt;
&lt;td&gt;2,269&lt;/td&gt;
&lt;td&gt;209&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PostgreSQL 10 ExecutePgCopy&lt;/td&gt;
&lt;td&gt;10,090&lt;/td&gt;
&lt;td&gt;583&lt;/td&gt;
&lt;td&gt;337&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Oracle XE ExecuteAffrows&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;10,648&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sqlite ExecuteAffrows&lt;/td&gt;
&lt;td&gt;28,554&lt;/td&gt;
&lt;td&gt;1,149&lt;/td&gt;
&lt;td&gt;701&lt;/td&gt;
&lt;td&gt;91&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Oracle 插入性能不用怀疑，可能安装学生版限制较大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试结果(10个字段，18W-50行数据，单位ms)：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;18W&lt;/th&gt;
&lt;th&gt;1W&lt;/th&gt;
&lt;th&gt;5K&lt;/th&gt;
&lt;th&gt;500&lt;/th&gt;
&lt;th&gt;50&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;MySql 5.5 ExecuteAffrows&lt;/td&gt;
&lt;td&gt;11,171&lt;/td&gt;
&lt;td&gt;866&lt;/td&gt;
&lt;td&gt;366&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MySql 5.5 ExecuteMySqlBulkCopy&lt;/td&gt;
&lt;td&gt;6,504&lt;/td&gt;
&lt;td&gt;399&lt;/td&gt;
&lt;td&gt;257&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SqlServer Express ExecuteAffrows&lt;/td&gt;
&lt;td&gt;47,204&lt;/td&gt;
&lt;td&gt;2,275&lt;/td&gt;
&lt;td&gt;1,108&lt;/td&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SqlServer Express ExecuteSqlBulkCopy&lt;/td&gt;
&lt;td&gt;4,248&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PostgreSQL 10 ExecuteAffrows&lt;/td&gt;
&lt;td&gt;9,786&lt;/td&gt;
&lt;td&gt;568&lt;/td&gt;
&lt;td&gt;336&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PostgreSQL 10 ExecutePgCopy&lt;/td&gt;
&lt;td&gt;4,081&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;td&gt;93&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Oracle XE ExecuteAffrows&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;731&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sqlite ExecuteAffrows&lt;/td&gt;
&lt;td&gt;4,524&lt;/td&gt;
&lt;td&gt;246&lt;/td&gt;
&lt;td&gt;137&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试结果，是在相同操作系统下进行的，并且都有预热&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ExecuteMySqlBulkCopy 方法在 FreeSql.Provider.MySqlConnector 中实现的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;了解 EFCore 应该知道有一个 inMemory 实现，Sqlite 其实也有内存模式，所以在非常棒（忍不住）的 FreeSql.Provider.Sqlite 稍加适配就可以实现 inMemory 模式了。&lt;/p&gt;
&lt;p&gt;使用 inMemory 模式非常简单，只需要修改 IFreeSql 创建的类型，以及连接字符串即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.Sqlite, &quot;Data Source=:memory:&quot;)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存模式 + FreeSql CodeFirst 功能，用起来体验还是不错的。因为每次都要迁移结构，fsql 释放数据就没了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525015101348-1732336074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于写完了，这篇文章是我有史以来编辑最长时间的，历时 4小时！！！原本我可以利用这 4小时编写一堆胶水代码，却非要写推广的文章，真心希望正在使用的、善良的您能动一动小手指，把文章转发一下，让更多人知道 .NET 有这样一个好用的 ORM 存在。谢谢了！！&lt;/p&gt;
&lt;p&gt;FreeSql 开源协议 MIT &lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，可以商用，文档齐全。QQ开发群：4336577&lt;/p&gt;
&lt;p&gt;CSRedisCore 说：FreeSql 的待遇也好太多了。&lt;/p&gt;
&lt;p&gt;如果你有好的 ORM 实现想法，欢迎给作者留言讨论，谢谢观看！&lt;/p&gt;
</description>
<pubDate>Sun, 24 May 2020 19:21:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>废话开头 这篇文章是我有史以来编辑最长时间的，历时 4小时！！！原本我可以利用这 4小时编写一堆胶水代码，真心希望善良的您点个赞，谢谢了！！ 很久很久没有写文章了，上一次还是在元旦发布 1.0 版本的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/12953836.html</dc:identifier>
</item>
<item>
<title>【Python】利用python自动发送邮件 - 时光清浅，岁月嫣然</title>
<link>http://www.cnblogs.com/hatimwen/p/pythonmail.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hatimwen/p/pythonmail.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在训练网络的过程中，需要大量的时间，虽然可以预估网络训练完成时间，但蹲点看结果着实有点不太聪明的亚子。&lt;/p&gt;
&lt;p&gt;因此，参照师兄之前发的python利用smtp自动发邮件的代码，我作了些调整，并参照网上的开源代码，整理出了加强版（可以传文件），这样训练的log还有model，或者是远程电脑上的文件都可以通过邮件即时到达接收邮件的邮箱&lt;sub&gt;很方便吧&lt;/sub&gt;~~&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;废话不多说，直接上代码。&lt;/p&gt;
&lt;h3 id=&quot;一、普通文本邮件（作通知训练结束用--）&quot;&gt;一、普通文本邮件（作通知训练结束用 😃 ）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: UTF-8 -*-

import smtplib
from email.mime.text import MIMEText
  
# 第三方 SMTP 服务
mail_host = &quot;smtp.163.com&quot;  # SMTP服务器
mail_user = &quot;yourname&quot;  # 用户名
mail_pass = &quot;xxx&quot;  # 密码(这里的密码不是登录邮箱密码，而是授权码)
  
sender = 'yourname@163.com'  # 发件人邮箱
receivers = 'othername@163.com']  # 接收人邮箱
  
  
content = 'Python Send Mail ! 训练结束！'
title = 'Python SMTP Mail 训练结束'  # 邮件主题

message = MIMEText(content, 'plain', 'utf-8')  # 内容, 格式, 编码
message['From'] = &quot;{}&quot;.format(sender)
message['To'] = &quot;,&quot;.join(receivers)
message['Subject'] = title
  
try:
    smtpObj = smtplib.SMTP_SSL(mail_host, 465)  # 启用SSL发信, 端口一般是465
    smtpObj.login(mail_user, mail_pass)  # 登录验证
    smtpObj.sendmail(sender, receivers, message.as_string())  # 发送
    print(&quot;mail has been send to {0} successfully.&quot;.format(receivers))
except smtplib.SMTPException as e:
    print(e)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二、加强版附件传输邮件&quot;&gt;二、加强版附件传输邮件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: UTF-8 -*-

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

# Files' Paths:
file1 = 'mail.py'
file2 = 'maill.py'
# 收邮件的地址，可以多个。
Receivers = ['receiver1@163.com'，'receiver2@163.com'] 
# 邮件主题：
title = 'Python SMTP 邮件(文件传输)'


# 模拟服务器
# SMTP服务器
SMTPServer=&quot;smtp.163.com&quot;
# 发邮件的地址
Sender=&quot;yourname@163.com&quot;
# 发送者邮件的授权密码，去163邮箱设置里获取。并非是密码。
passwd=&quot;xxx&quot;  

# 创建一个带附件的实例
message = MIMEMultipart()
message['From'] = Sender
message['To'] = &quot;,&quot;.join(Receivers)
message['Subject'] = title
# 邮件正文内容
message.attach(MIMEText('附件中是要传输的文件。\n ', 'plain', 'utf-8'))
message.attach(MIMEText('The files you need are as followed. \n ', 'plain', 'utf-8'))

# 构造附件1
att1 = MIMEText(open(file1, 'rb').read(), 'base64', 'utf-8')
att1[&quot;Content-Type&quot;] = 'application/octet-stream'
att1[&quot;Content-Disposition&quot;] = 'attachment; filename={0}'.format(file1)
message.attach(att1)

# 构造附件2
att2 = MIMEText(open(file2, 'rb').read(), 'base64', 'utf-8')
att2[&quot;Content-Type&quot;] = 'application/octet-stream'
att2[&quot;Content-Disposition&quot;] = 'attachment; filename={0}'.format(file2)
message.attach(att2)

try:
    mailServer = smtplib.SMTP(SMTPServer, 25)  # 25为端口号(邮件），0-1024都被系统占用了
    # 登录邮箱
    mailServer.login(Sender, passwd)  # 需要的是，邮箱的地址和授权密码
    # 发送文件
    mailServer.sendmail(Sender, Receivers, message.as_string())
    print(&quot;邮件发送成功&quot;)
    print(&quot;Mail with {0} &amp;amp; {1} has been send to {2} successfully.&quot;.format(file1,file2,Receivers))
except smtplib.SMTPException as e:
    print(&quot;Error: 无法发送邮件&quot;)
    print(e)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后话&quot;&gt;后话&lt;/h2&gt;
&lt;p&gt;可以把代码加到网络train.py的最后，别忘了在train.py的开头加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -*- coding: UTF-8 -*-

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后你就可以专心忙自己的事情，网络训练结束就自动发邮件啦~&lt;/p&gt;
&lt;p&gt;果然——Codes change the world. 😃&lt;/p&gt;
</description>
<pubDate>Sun, 24 May 2020 18:58:00 +0000</pubDate>
<dc:creator>时光清浅，岁月嫣然</dc:creator>
<og:description>利用python自动发送邮件，用途多多~~~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hatimwen/p/pythonmail.html</dc:identifier>
</item>
<item>
<title>JavaScript的基础语法及DOM元素和事件 - YJ同心</title>
<link>http://www.cnblogs.com/yjtxin/p/12953824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjtxin/p/12953824.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一，JavaScript是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1，JavaScript简称：&lt;/span&gt;&lt;/strong&gt;js，是一种浏览器解释型语言，嵌套在HTML文件中交给浏览器解释执行。主要用来实现网页的动态效果，用户交互及前后端的数据传输等。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2，JavaScript 组成&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1，核心语法 - ECMAScript (ES5-ES6) 规范了JavaScript的基本语法
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.1 浏览器对象模型 ：-BOM &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Browser Object Model，提供了一系列操作浏览器的方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.2 文档对象模型： -DOM &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Document Object Model ，提供了一系列操作的文档的方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3. 使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.1元素绑定事件&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;事件 ：指用户的行为（单击，双击等）或元素的状态（输入框的焦点状态等）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li class=&quot;md-end-block md-p _mce_tagged_br&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;事件处理：元素监听某种事件并在事件发生后自动执行事件处理函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;md-end-block md-p _mce_tagged_br&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;常用事件：onclick (单击事件)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语法 ：将事件名称以标签属性的方式绑定到元素上，自定义事件处理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!--实现点击按钮在控制台输出--&amp;gt;
&amp;lt;button onclick=&quot;console.log('Hello World');&quot;&amp;gt;点击&amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.2文档内嵌：&lt;/strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;使用&lt;span class=&quot;md-html-inline md-raw-inline&quot;&gt;&lt;span class=&quot;md-raw-inline&quot;&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;标签书写。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
  alert(&lt;/span&gt;&quot;网页警告框&quot;&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;&lt;strong&gt;注意 ：&lt;/strong&gt;&lt;span class=&quot;md-html-inline md-raw-inline&quot;&gt;&lt;span class=&quot;md-raw-inline&quot;&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;标签可以书写在文档的任意位置，书写多次，一旦加载到script标签就会立即执行内部的JavaScript代码，因此不同的位置会影响代码最终的执行效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3外部链接：&lt;/strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;创建外部的JavaScript文件 XX.JavaScript，在HTML文档中使用&lt;span class=&quot;md-html-inline md-raw-inline&quot;&gt;&lt;span class=&quot;md-raw-inline&quot;&gt;&amp;lt;script src=&quot;&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;引入&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;index.JavaScript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;注意 ：&lt;span class=&quot;md-html-inline md-raw-inline&quot;&gt;&lt;span class=&quot;md-raw-inline&quot;&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;既可以实现内嵌 JavaScript 代码，也可以实现引入外部的 JavaScript 文件，但是只能二选一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.44 &lt;span class=&quot;md-plain md-expand&quot;&gt;JavaScript 输入和输出语句：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
alert(&quot;&quot;&lt;span&gt;)；普通的网页弹框

console.log()；控制台输出，多用于代码调试

document.write(&lt;/span&gt;&quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&quot;)；实现在动态在网页中写入内容，&lt;br/&gt;&lt;span class=&quot;md-plain&quot;&gt;可以识别HTML标签,脚本代码可以在文档任何地方书写，如果是普通写入（不涉及事件），&lt;br/&gt;区分代码的书写位置插入&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;二、基础语法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1.，语法规范：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JavaScript是由语句组成,语句由关键字，变量，常量，运算符，方法组成。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;分号可以作为语句结束的标志，也可以省略&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JavaScript严格区分大小写&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注释语法 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;单行注释使用 // &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;多行注释使用 /* */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2. JavaScript的变量与常量：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1，变量：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1638478/202005/1638478-20200525000305867-264004076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item md-focus-container&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-list-item md-focus-container&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;&lt;strong&gt;1.1作用 :&lt;/strong&gt; 用于存储程序运行过程中可动态修改的数据&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;1.2语法 :&lt;/strong&gt; 使用关键var声明,自定义变量名&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量声明&lt;/span&gt;
a = 100;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量赋值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; b = 200; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明并赋值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; m,n,k;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时声明多个变量&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; j = 10,c = 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时声明并赋值多个变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1.3 命名规范 :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量名，常量名，函数名，方法名自定义，可以由数字，字母，下划线，$组成，禁止以数字开头&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;禁止与关键字冲突(var const function if else for while do break case switch return class)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量名严格区分大小写&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量名尽量见名知意，多个单词组成采用小驼峰,例如：&quot;userName&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1.4使用注意 :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量如果省略var关键字，并且未赋值，直接访问会报错&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p _mce_tagged_br&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2，变量使用var关键字声明但未赋值，变量初始值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus _mce_tagged_br&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;3，变量省略var关键字声明，已被赋值，可正常使用，影响变量作用域&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2，常量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;2.1 作用 :&lt;/strong&gt; 存储一经定义就无法修改的数据&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;2.2 语法 :&lt;/strong&gt; 必须声明的同时赋值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
const PI = 3.14;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2.3 注意 :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;常量一经定义，不能修改，强制修改会报错&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;命名规范同变量，为了区分变量，常量名采用全大写字母&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2.4操作小数位：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;toFixed(n)； 保留小数点后 n 位，并且四舍五入。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; num = 3.1415926&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保留当前变量小数点后两位&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; res = num.toFixed(2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3. 数据类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1638478/202005/1638478-20200525001413757-1982502819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.1number 数值类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;整数&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;十进制表示&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; a = 100;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;八进制表示 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;以0为前缀&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; b = 021; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果为十进制的 17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;&lt;span&gt;使用 : 整数可以采用不同进制表示，在控制台输出时一律会按照十进制输出&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;小数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; m = 1.2345;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;科学计数法 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;例 : 1.5e3 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;e表示10为底，e后面的数值表示10的次方数 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.5e3 等价于 1.5 * 10(3)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.2string 字符串类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;字符串：由一个或多个字符组成，使用&quot;&quot;或''表示，每一位字符都有对应的Unicode编码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; s = &quot;100&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s1 = &quot;张三&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.3boolean 布尔类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;只有真和假两个值，布尔值与number值可以互相转换。true 为 1，false 为 0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; isSave = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isChecked = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.4undefined &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;特殊值&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;变量声明未赋值时显示undefined&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a;
console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3.5null 空类型&lt;span class=&quot;md-softbreak&quot;&gt; ：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;定义对象引用时使用null，表示对象为空&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;引用数据类型 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;主要指对象，函数等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;检测数据类型 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;​ typeof 变量或表达式 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;​ typeof (变量或表达式)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; n = &quot;asda&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; n);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
console.log(&lt;span&gt;typeof&lt;/span&gt;(n));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;4. 数据类型转换&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不同类型的数据参与运算时,需要转换类型&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;4.1强制类型转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1，转换字符串类型 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;方法：toString() &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;返回转换后的字符串&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; a = 100&lt;span&gt;;
 a &lt;/span&gt;= a.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;100&quot;&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
 b &lt;/span&gt;= b.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;true&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2，转换number类型&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Number(param) &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;参数为要进行数据类型转换的变量或值，返回转换后的结果: &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果转换成功，返回number值 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果转换失败，返回NaN，(Not a Number)，是非number字符，一律转换失败，返回 NaN&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;4.2隐式类型转换（自动转换）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当字符串与其他数据类型进行&quot;+&quot;运算时，表示字符串的拼接，不再是数学运算 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;转换规则 ：将非字符串类型的数据转换成字符串之后进行拼接，最终结果为字符串&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其他情况下，一律将操作数转number进行数学运算&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5. 运算符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.1赋值运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;&lt;span&gt;= 将右边的值赋给左边变量&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;5.2算数运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
+ - * / % 加 减 乘 除 取余
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.3符合运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
+= -= *= /= %=  
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.4 自增或自减运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;&lt;span&gt;++ -- 变量的自增和自减指的是在自身基础上进行 +1或-1 的操作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：&lt;/span&gt;&lt;span class=&quot;md-plain&quot;&gt;自增或自减运算符在单独与变量结合时，放前和放后没有区别，&lt;/span&gt;&lt;span class=&quot;md-plain&quot;&gt;如果自增或自减运算符与其他运算符结合使用，要区分前缀和后缀，做前缀，那就先++/--，再进行赋值或其他运算，如果做后缀，就先结合其他运算符，再进行++ / --&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.5关系运算符/比较运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; &amp;lt; 
&amp;gt;= &amp;lt;=
==(相等) !=&lt;span&gt;(相等)
&lt;/span&gt;===(全等) !==(不全等)
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1，关系运算符用来判断表达式之间的关系，结果永远是布尔值 true/false&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2，使用&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;字符串与字符串之间的比较 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;依次比较每位字符的Unicode码，只要某位字符比较出结果，就返回最终结果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;str.charCodeAt(index)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;index必需。表示字符串中某个位置的数字，即字符在字符串中的下标。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3，相等与全等&lt;/span&gt;&lt;/p&gt;

&lt;ol class=&quot;ol-list&quot; start=&quot;&quot;&gt;&lt;li&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.6逻辑运算符&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&amp;amp;&amp;amp; 逻辑与&lt;span class=&quot;md-softbreak&quot;&gt; ：&lt;span class=&quot;md-plain&quot;&gt;表达式同时成立，最终结果才为true；1则1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;|| 逻辑或&lt;span class=&quot;md-softbreak&quot;&gt; ：&lt;span class=&quot;md-plain&quot;&gt;表达式中只要有一个成立，最终结果即为true；有1则1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;! 逻辑非&lt;span class=&quot;md-softbreak&quot;&gt; ：&lt;span class=&quot;md-plain&quot;&gt;对已有表达式的结果取反 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：除零值以外，所有值都为真&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;5.7三目运算符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语法 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
表达式1 ? 表达式2 : 表达式3;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;过程 :&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;判断表达式1是否成立，返回布尔值；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果表达式1成立，执行表达式2；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果表达式1不成立，执行表达式3；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;三、DOM 元素和事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;&lt;strong&gt;什么是事件？：&lt;/strong&gt;事件是指用户的行为或元素的状态。由指定元素监听相关的事件，并且绑定事件处理函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;事件处理函数：元素监听事件，并在事件发生时自动执行的操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-heading&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1，事件函数分类&lt;span class=&quot;md-plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;1.1 鼠标事件&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
onclick &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单击&lt;/span&gt;
ondblclick &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击&lt;/span&gt;
onmouseover &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移入&lt;/span&gt;
onmouseout &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移出&lt;/span&gt;
onmousemove &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1.2文档或元素加载完毕&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
onload &lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素或文档加载完毕&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;1.3表单控件状态监听&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
onfocus &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本框获取焦点&lt;/span&gt;
onblur &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本框失去焦点&lt;/span&gt;
oninput &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实时监听输入&lt;/span&gt;
onchange &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两次输入内容发生变化时触发,或元素状态改变时触发&lt;/span&gt;
onsubmit &lt;span&gt;//&lt;/span&gt;&lt;span&gt;form元素监听,点击提交按钮后触发,通过返回值控制数据是否可以发送给服务器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2，获取元素节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2.1根据标签名获取元素节点列表&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; elems = document.getElementsByTagName(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
参数 : 标签名
返回值 : 节点列表,需要从节点列表中获取具体的元素节点对象,添加相应下标。
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2.2根据 class 属性值获取元素节点列表&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; elems = document.getElementsByClassName(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
参数 : 类名(class属性值)
返回值 : 节点列表
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;2.3根据 id 属性值取元素节点&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; elem = document.getElementById(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
参数 : id属性值
返回值 : 元素节点
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;2.4根据 name 属性值取元素列表&lt;span class=&quot;md-plain&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; elems = document.getElementsByName(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
参数 : name属性值
返回 : 节点列表
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;3，事件绑定方式&lt;span class=&quot;md-plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;3.1内联方式：&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将事件名称作为标签属性绑定到元素上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;例 :&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button onclick=&quot;alert()&quot;&amp;gt;点击&amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;3.2动态绑定&lt;/strong&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;strong&gt; ：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;获取元素节点，动态添加事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;例 :&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
btn.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
​
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 24 May 2020 16:54:00 +0000</pubDate>
<dc:creator>YJ同心</dc:creator>
<og:description>一，JavaScript是什么？ 1，JavaScript简称：js，是一种浏览器解释型语言，嵌套在HTML文件中交给浏览器解释执行。主要用来实现网页的动态效果，用户交互及前后端的数据传输等。 2，J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yjtxin/p/12953824.html</dc:identifier>
</item>
<item>
<title>实用算法系列之RT-Thread链表堆管理器 - 逸珺</title>
<link>http://www.cnblogs.com/embInn/p/12953799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/embInn/p/12953799.html</guid>
<description>&lt;p&gt;[导读] 前文描述了栈的基本概念，本文来聊聊堆是怎么会事儿。RT-Thread 在社区广受欢迎，阅读了其内核代码，实现了堆的管理，代码设计很清晰，可读性很好。故一方面了解RT-Thread内核实现，一方面可以弄清楚其堆的内部实现。将学习体会记录分享，希望对于堆的理解及实现有一个更深入的认知。&lt;/p&gt;
&lt;p&gt;注，文中代码分析基于rt-thread-v4.0.2 版本。&lt;/p&gt;
&lt;h2 id=&quot;什么是堆？&quot;&gt;什么是堆？&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;C语言堆是由malloc(),calloc(),realloc()等函数动态获取内存的一种机制。使用完成后，由程序员调用free()等函数进行释放。使用时，需要包含stdlib.h头文件。&lt;/p&gt;
&lt;p&gt;C++预言的堆管理则是使用new操作符向堆管理器申请动态内存分配，使用delete操作符将使用完毕内存的释放给堆管理器。&lt;/p&gt;
&lt;p&gt;注：本文只描述C的堆管理器实现相关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以C语言为例，将上面的描述，翻译成一个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003430239-1967762505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要动态管理一片内存，且需要动态分配释放，这样一个需求。很显然C语言需要将动态内存区抽象描述起来并实现动态管理。事实上，C语言中堆管理器其本质是利用数据结构将堆区抽象描述，所需要描述的方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可用于分配的内存&lt;/li&gt;
&lt;li&gt;正在使用的内存块&lt;/li&gt;
&lt;li&gt;释放掉的内存块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再利用相应算法对于这类数据结构对象进行动态管理而实现的堆管理器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经常看到各种算法书很多只讲算法原理，而不讲应用实例，往往体会不深。私以为可以做些改善。学而不能致用，何必费力去学。所以不是晦涩难懂的算法无用，而是没有去真正结合应用。可以再进一步想，如果算法没有应用场景，也一定会在技术发展的历程中逐渐被世人遗忘。所以建议学习阅读算法书籍时，找些实例来看看，一定会加深对算法的理解领悟。&lt;/strong&gt;这是比较重要的题外话，送给大家以共勉。&lt;/p&gt;
&lt;p&gt;所以从本质上讲，堆管理器就是数据结构+算法实现的动态内存管理器，管理内存的动态分配以及释放。&lt;/p&gt;
&lt;h2 id=&quot;为什么要堆？&quot;&gt;为什么要堆？&lt;/h2&gt;
&lt;p&gt;C编程语言对内存管理方式有静态，自动或动态三种方式。 静态内存分配的变量通常与程序的可执行代码一起分配在主存储器中，并在程序的整个生命周期内有效。 自动分配内存的变量在栈上分配，并随着函数的调用和返回而申请或释放。 对于静态分配内存和自动分配内存的生命周期，分配的大小必须是编译时常量（可变长度自动数组[5]除外）。 如果所需的内存大小直到运行时才知道（例如，如果要从用户或磁盘文件中读取任意大小的数据），则使用固定大小的数据对象则满足不了要求了。试想，即便假定都知道要多大内存，如在windows/Linux下有那么多应用程序，每个应用程序加载时都将运行中所需的内存采样静态分配策略，则如多个程序运行内存将很快耗尽。&lt;/p&gt;
&lt;p&gt;分配的内存的生命周期也可能引起关注。 静态或自动分配都不能满足所有情况。 自动分配内存不能在多个函数调用之间保留，而静态数据在程序的整个生命周期中必然保留，无论是否真正需要（所以都采用这样的策略必然造成浪费）。 在许多情况下，程序员在管理分配的内存的生命周期具有更多的灵活性。&lt;/p&gt;
&lt;p&gt;通过使用动态内存分配则避免了这些限制/缺点，在动态内存分配中，更明确（但更灵活）地管理内存，通常是通过从免费存储区（非正式地称为“堆”）中分配内存（为此目的而构造的内存区域）进行分配的。 在C语言中，库函数malloc用于在堆上分配一个内存块。 程序通过malloc返回的指针访问该内存块。 当不再需要内存时，会将指针传递给free，从而释放内存，以便可以将其用于其他目的。&lt;/p&gt;
&lt;h2 id=&quot;谁实现堆&quot;&gt;谁实现堆&lt;/h2&gt;
&lt;p&gt;如果一问道这个问题，马上会说C编译器。不错C编译器实现了堆管理器，而事实上并非编译器在编译的过程中实现动态内存管理器，而是C编译器所实现的C库实现了堆管理器，比如ANSI C，VC, IAR C编译器，GNU C等其实都需要一些C库的支持，那么这些库的内部就隐藏了这么一个堆管理器。眼见为实吧，还是以IAR ARM 8.40.1 为例，其堆管理器就实现在：&lt;/p&gt;
&lt;p&gt;.\IAR Systems\Embedded Workbench 8.3\arm\src\lib\dlib\heap&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003456529-820588243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一看有这么多的源码，那么对于应用开发而言，有哪些选项需要进行配置呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003505359-1393412146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持四个选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Automatic：
&lt;ul&gt;&lt;li&gt;如果您的应用程序中有对堆内存分配例程的调用，但没有对堆释放例程的调用，则链接程序将自动选择无空闲堆。&lt;/li&gt;
&lt;li&gt;如果您的应用程序中有对堆内存分配例程的调用，则链接程序会自动选择高级堆。&lt;/li&gt;
&lt;li&gt;例如，如果在库中调用了堆内存分配例程，则链接程序会自动选择基本堆。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Advanced heap:高级堆（--advanced_heap）为广泛使用该堆的应用程序提供有效的内存管理。 特别是，重复分配和释放内存的应用程序可能会在空间和时间上获得较少的开销。 高级堆的代码明显大于基本堆的代码。&lt;/li&gt;
&lt;li&gt;Basic heap: 基本堆（--basic_heap）是一个简单的堆分配器，适用于不经常使用堆的应用程序。 特别是，它可以用于仅分配堆内存而从不释放堆内存的应用程序中。 基本堆并不是特别快，并且在反复释放内存的应用程序中使用它很可能导致不必要的堆碎片化。 基本堆的代码远小于高级堆的大小。&lt;/li&gt;
&lt;li&gt;No-free heap:无可用堆（--no_free_heap）使用此选项可以使用最小的堆实现。 因为此堆不支持释放或重新分配，所以它仅适用于在启动阶段为各种缓冲区分配堆内存的应用程序，以及永不释放内存的应用程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是如果认为仅仅标准C库负责实现堆管理器，则这种理解并不全面。回到事物的本质，堆管理器是利用数据结构及算法动态管理一片内存的分配与释放。那么有这样需求的地方，都可能需要实现一个堆管理器。&lt;/p&gt;
&lt;p&gt;堆管理器的实现很大程度取决于操作系统以及硬件体系架构。大体上需要实现堆内存管理器的有两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序，应用程序需要堆内存管理器，是显而易见的。比如常见的windows/Linux下的应用程序，都需要堆内存管理器。而上述的cortex M或者其他单片机程序使用C/C++编程时都需要堆内存管理器。&lt;/li&gt;
&lt;li&gt;操作系统内核，操作系统内核需要像应用程序一样分配内存。 但是，内核中malloc的实现通常与C库使用的实现有很大不同。 例如，内存缓冲区可能需要符合DMA施加的特殊限制，或者可能从中断上下文中调用内存分配功能。这需要与操作系统内核的虚拟内存子系统紧密集成的malloc实现。比如Linux内核就需要实现内核版本的堆管理器，对外提供kmalloc/vmalloc申请内存，kfree/vfree用于释放内存。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;怎么实现堆&quot;&gt;怎么实现堆&lt;/h2&gt;
&lt;p&gt;对于RT-Thread的内核而言，也实现了一个内核堆管理器，这里就来梳理一下RT-Thread内核版本的小堆管理器的实现，同时来了解一下链表数据结构及算法操作的实例应用。&lt;/p&gt;
&lt;p&gt;其堆管理器实现位于.\rt-thread-v4.0.2\rt-thread\src下mem.c，memheap.c以及mempool.c。&lt;/p&gt;

&lt;p&gt;其堆管理器主要的数据结构为heap_mem。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003531650-1937027549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;堆管理器的初始化入口在mem.c，函数为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void rt_system_heap_init(void *begin_addr, void *end_addr)
{
    struct heap_mem *mem;
    /*按4字节对齐转换地址*/
    /*如0x2000 0001～0x2000 0003,转后为0x2000 0004*/
    rt_ubase_t begin_align = RT_ALIGN((rt_ubase_t)begin_addr, RT_ALIGN_SIZE);
    /*如0x3000 0001～0x3000 0003,转后为0x3000 0000*/
    rt_ubase_t end_align   = RT_ALIGN_DOWN((rt_ubase_t)end_addr, RT_ALIGN_SIZE);
    
    /*调试信息，函数不可用于中断内部*/
    RT_DEBUG_NOT_IN_INTERRUPT;

    /* 分配地址范围至少能存储两个heap_mem */
    if ((end_align &amp;gt; (2 * SIZEOF_STRUCT_MEM)) &amp;amp;&amp;amp;
        ((end_align - 2 * SIZEOF_STRUCT_MEM) &amp;gt;= begin_align))
    {
        /* 计算可用堆区，4字节对齐 */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf(&quot;mem init, error begin address 0x%x, and end address 0x%x\n&quot;,
                   (rt_ubase_t)begin_addr, (rt_ubase_t)end_addr);

        return;
    }

    /* heap_ptr指向堆区起始地址 */
    heap_ptr = (rt_uint8_t *)begin_align;

    RT_DEBUG_LOG(RT_DEBUG_MEM, (&quot;mem init, heap begin address 0x%x, size %d\n&quot;,
                                (rt_ubase_t)heap_ptr, mem_size_aligned));

    /* 初始化堆起始描述符 */
    mem        = (struct heap_mem *)heap_ptr;
    mem-&amp;gt;magic = HEAP_MAGIC;
    mem-&amp;gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
    mem-&amp;gt;prev  = 0;
    mem-&amp;gt;used  = 0;
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(mem, &quot;INIT&quot;);
#endif

    /* 初始化堆结束描述符 */
    heap_end        = (struct heap_mem *)&amp;amp;heap_ptr[mem-&amp;gt;next];
    heap_end-&amp;gt;magic = HEAP_MAGIC;
    heap_end-&amp;gt;used  = 1;
    heap_end-&amp;gt;next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
    heap_end-&amp;gt;prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(heap_end, &quot;INIT&quot;);
#endif

    rt_sem_init(&amp;amp;heap_sem, &quot;heap&quot;, 1, RT_IPC_FLAG_FIFO);

    /* 初始化释放指针指向堆的开始 */
    lfree = (struct heap_mem *)heap_ptr;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传入链接堆区的内存起始地址，以及结束地址。以STM32为例，传入0x20000000--0x20018000，96k字节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003550485-146261032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述rt_system_heap_init( 0x20000000,0x20018000)，主要做了下图这么一件事情。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003601510-1320585141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将堆管理头尾描述符进行了初始化，并指向对应的内存地址。用图翻译一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003610770-279999752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用类型强制转换将内存数据转换为struct heap_mem *。实现了静态双链表的创建&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;mem      = (struct heap_mem *)heap_ptr;
heap_end = (struct heap_mem *)&amp;amp;heap_ptr[mem-&amp;gt;next];
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义heap_mem没有定义使用多少字节为该块的用户数据字节数，节约了内存。是一个比较好的处理方式。&lt;/li&gt;
&lt;li&gt;对齐方式可配置，RT_ALIGN_SIZE默认为4字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户调用rt_malloc 用于申请分配动态内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void *rt_malloc(rt_size_t size)
{
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    if (size == 0)
        return RT_NULL;

    RT_DEBUG_NOT_IN_INTERRUPT;
    /*按四字节对齐申请，如申请5字节，则实际按8字节申请*/
    if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
        RT_DEBUG_LOG(RT_DEBUG_MEM, (&quot;malloc size %d, but align to %d\n&quot;,
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, (&quot;malloc size %d\n&quot;, size));

    /* 按四字节对齐申请，如申请5字节，则实际按8字节申请 */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);

    if (size &amp;gt; mem_size_aligned)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, (&quot;no memory\n&quot;));
        return RT_NULL;
    }

    /* 每块的长度必须至少为MIN_SIZE_ALIGNED=12 STM32*/
    if (size &amp;lt; MIN_SIZE_ALIGNED)
        size = MIN_SIZE_ALIGNED;

    /* 获取堆保护信号量 */
    rt_sem_take(&amp;amp;heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr &amp;lt; mem_size_aligned - size;
         ptr = ((struct heap_mem *)&amp;amp;heap_ptr[ptr])-&amp;gt;next)
    {
        mem = (struct heap_mem *)&amp;amp;heap_ptr[ptr];

        /*如果该块未使用，且满足大小要求*/
        if ((!mem-&amp;gt;used) &amp;amp;&amp;amp; (mem-&amp;gt;next - (ptr + SIZEOF_STRUCT_MEM)) &amp;gt;= size)
        {
            /* mem没有被使用，至少完美的配合是可能的:
             * mem-&amp;gt;next - (ptr + SIZEOF_STRUCT_MEM) 计算出mem的“用户数据大小” */
            if (mem-&amp;gt;next - (ptr + SIZEOF_STRUCT_MEM) &amp;gt;=
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
            {
                /* (除了上面的，我们测试另一个结构heap_mem (SIZEOF_STRUCT_MEM)
                 * 是否包含至少MIN_SIZE_ALIGNED的数据也适合'mem'的'用户数据空间')
                 * -&amp;gt; 分割大的块，创建空的余数,
                 * 余数必须足够大，以包含MIN_SIZE_ALIGNED大小数据:
                 * 如果mem-&amp;gt;next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
                 * struct heap_mem 会适合，在mem2及mem2-&amp;gt;next没有使用
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&amp;amp;heap_ptr[ptr2];
                mem2-&amp;gt;magic = HEAP_MAGIC;
                mem2-&amp;gt;used = 0;
                mem2-&amp;gt;next = mem-&amp;gt;next;
                mem2-&amp;gt;prev = ptr;
#ifdef RT_USING_MEMTRACE
                rt_mem_setname(mem2, &quot;    &quot;);
#endif
                /*将ptr2插入mem及mem-&amp;gt;next之间 */
                mem-&amp;gt;next = ptr2;
                mem-&amp;gt;used = 1;

                if (mem2-&amp;gt;next != mem_size_aligned + SIZEOF_STRUCT_MEM)
                {
                    ((struct heap_mem *)&amp;amp;heap_ptr[mem2-&amp;gt;next])-&amp;gt;prev = ptr2;
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
                if (max_mem &amp;lt; used_mem)
                    max_mem = used_mem;
#endif
            }
            else
            {
                mem-&amp;gt;used = 1;
#ifdef RT_MEM_STATS
                used_mem += mem-&amp;gt;next - ((rt_uint8_t *)mem - heap_ptr);
                if (max_mem &amp;lt; used_mem)
                    max_mem = used_mem;
#endif
            }
            /* 设置块幻数 */
            mem-&amp;gt;magic = HEAP_MAGIC;
#ifdef RT_USING_MEMTRACE
            if (rt_thread_self())
                rt_mem_setname(mem, rt_thread_self()-&amp;gt;name);
            else
                rt_mem_setname(mem, &quot;NONE&quot;);
#endif

            if (mem == lfree)
            {
                /* 寻找下一个空闲块并更新lfree指针*/
                while (lfree-&amp;gt;used &amp;amp;&amp;amp; lfree != heap_end)
                    lfree = (struct heap_mem *)&amp;amp;heap_ptr[lfree-&amp;gt;next];

                RT_ASSERT(((lfree == heap_end) || (!lfree-&amp;gt;used)));
            }

            rt_sem_release(&amp;amp;heap_sem);
            RT_ASSERT((rt_ubase_t)mem + SIZEOF_STRUCT_MEM + size &amp;lt;= (rt_ubase_t)heap_end);
            RT_ASSERT((rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
            RT_ASSERT((((rt_ubase_t)mem) &amp;amp; (RT_ALIGN_SIZE - 1)) == 0);

            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         (&quot;allocate memory at 0x%x, size: %d\n&quot;,
                          (rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_ubase_t)(mem-&amp;gt;next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* 返回除mem结构之外的内存地址 */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }
    /* 释放堆保护信号量 */
    rt_sem_release(&amp;amp;heap_sem);

    return RT_NULL;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其基本思路，从空闲块链表开始检索内存块，如检索到某块空闲且满足申请大小且其剩余空间至少能存储描述符，则满足了申请要求，则将后续内存头部生成描述，更新前后指针，标记幻数以及块已被使用标记，将该块插入链表。返回申请成功的内存地址。如果检索不到，则返回空指针，表示申请失败，堆目前没有满足要求的内存可供使用。实际上，上述代码在运行时将堆内存区按照下述示意图进行动态维护。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003628835-278035927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概括一下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;heap_ptr总是指向堆起始地址，heap_end总是指向最后一个块，两者配合可以实现边界保护，在释放内存时使用。&lt;/li&gt;
&lt;li&gt;lfree 总是指向最地址最小的空闲块，因此在动态申请内存时，总是从该块进行检索是否有满足申请要求的内存块可供使用。&lt;/li&gt;
&lt;li&gt;used=1表示该块被占用，非空闲。used=0表示该块空闲。&lt;/li&gt;
&lt;li&gt;magic 字段幻数，起始就是一个特殊标记字，与used=0配合，用于检测异常，试想一下如果仅仅用used=0判断块是空闲，则易出错，或者需要加其他的辅助代码，才能保证代码的健壮性。&lt;/li&gt;
&lt;li&gt;动态内存管理申请比较慢，需要检索链表，以及额外的内存开销。&lt;/li&gt;
&lt;li&gt;rt_realloc 及rt_calloc 不做分析了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;释放内存由rt_free实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void rt_free(void *rmem)
{
    struct heap_mem *mem;

    if (rmem == RT_NULL)
        return;

    RT_DEBUG_NOT_IN_INTERRUPT;

    RT_ASSERT((((rt_ubase_t)rmem) &amp;amp; (RT_ALIGN_SIZE - 1)) == 0);
    RT_ASSERT((rt_uint8_t *)rmem &amp;gt;= (rt_uint8_t *)heap_ptr &amp;amp;&amp;amp;
              (rt_uint8_t *)rmem &amp;lt; (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
    /* 申请释放地址不在堆区 */
    if ((rt_uint8_t *)rmem &amp;lt; (rt_uint8_t *)heap_ptr ||
        (rt_uint8_t *)rmem &amp;gt;= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, (&quot;illegal memory\n&quot;));

        return;
    }

    /* 获取块描述符 */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);

    RT_DEBUG_LOG(RT_DEBUG_MEM,
                 (&quot;release memory 0x%x, size: %d\n&quot;,
                  (rt_ubase_t)rmem,
                  (rt_ubase_t)(mem-&amp;gt;next - ((rt_uint8_t *)mem - heap_ptr))));


    /* 获取堆保护信号量 */
    rt_sem_take(&amp;amp;heap_sem, RT_WAITING_FOREVER);

    /* 待释放的内存，其块描述符需是使用状态 */
    if (!mem-&amp;gt;used || mem-&amp;gt;magic != HEAP_MAGIC)
    {
        rt_kprintf(&quot;to free a bad data block:\n&quot;);
        rt_kprintf(&quot;mem: 0x%08x, used flag: %d, magic code: 0x%04x\n&quot;, mem, mem-&amp;gt;used, mem-&amp;gt;magic);
    }
    RT_ASSERT(mem-&amp;gt;used);
    RT_ASSERT(mem-&amp;gt;magic == HEAP_MAGIC);
    /* 清除使用标志 */
    mem-&amp;gt;used  = 0;
    mem-&amp;gt;magic = HEAP_MAGIC;
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(mem, &quot;    &quot;);
#endif

    if (mem &amp;lt; lfree)
    {
        /* 更新空闲块lfree指针 */
        lfree = mem;
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem-&amp;gt;next - ((rt_uint8_t *)mem - heap_ptr));
#endif

    /* 如临近块也处于空闲态，则合并整理成一个更大的块 */
    plug_holes(mem);
    rt_sem_release(&amp;amp;heap_sem);
}
RTM_EXPORT(rt_free);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合并空闲块plug_holes&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;static void plug_holes(struct heap_mem *mem)
{
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem &amp;gt;= heap_ptr);
    RT_ASSERT((rt_uint8_t *)mem &amp;lt; (rt_uint8_t *)heap_end);
    RT_ASSERT(mem-&amp;gt;used == 0);

    /* 前向整理 */
    nmem = (struct heap_mem *)&amp;amp;heap_ptr[mem-&amp;gt;next];
    if (mem != nmem &amp;amp;&amp;amp;
        nmem-&amp;gt;used == 0 &amp;amp;&amp;amp;
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /*如果mem-&amp;gt;next是空闲，且非尾节点，则合并*/
        if (lfree == nmem)
        {
            lfree = mem;
        }
        mem-&amp;gt;next = nmem-&amp;gt;next;
        ((struct heap_mem *)&amp;amp;heap_ptr[nmem-&amp;gt;next])-&amp;gt;prev = (rt_uint8_t *)mem - heap_ptr;
    }

    /* 后向整理 */
    pmem = (struct heap_mem *)&amp;amp;heap_ptr[mem-&amp;gt;prev];
    if (pmem != mem &amp;amp;&amp;amp; pmem-&amp;gt;used == 0)
    {
        /* 如mem-&amp;gt;prev空闲,将mem与mem-&amp;gt;prev合并 */
        if (lfree == mem)
        {
            lfree = pmem;
        }
        pmem-&amp;gt;next = mem-&amp;gt;next;
        ((struct heap_mem *)&amp;amp;heap_ptr[mem-&amp;gt;next])-&amp;gt;prev = (rt_uint8_t *)pmem - heap_ptr;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态内存的释放相对比较简单，其思路主要是判断传入地址是否在堆区，如是堆内存，则判断其块信息是否合法。如果合法，则将使用标志清除。同时如果临近块如果是空闲态，则利用plug_holes将空闲块进行合并，合并成一个大的空闲块。&lt;/p&gt;

&lt;p&gt;使用free释放内存失败会导致不可重用内存的累积，程序不再使用这些内存。这将浪费内存资源，并可能在耗尽这些资源时导致分配失败。&lt;/p&gt;
&lt;h2 id=&quot;怎么使用堆&quot;&gt;怎么使用堆&lt;/h2&gt;

&lt;p&gt;对于STM32而言,位于board.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/ * 配置堆区大小，可根据实际使用进行修改 */
#define HEAP_BEGIN   STM32_SRAM1_START
#define HEAP_END     STM32_SRAM1_END

/* 用于板级初始化堆区 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;用于动态申请内存
void *rt_malloc(rt_size_t size)
/*追加申请内存，此函数将更改先前分配的内存块。*/
void *rt_realloc(void *rmem, rt_size_t newsize)
/* 申请的内存被初始化为0 */
void *rt_calloc(rt_size_t count, rt_size_t size)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存分配不能保证成功，而是可能返回一个空指针。使用返回的值，而不检查分配是否成功，将调用未定义的行为。这通常会导致崩溃，但不能保证会发生崩溃，因此依赖于它也会导致问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于申请的内存，使用前必须进行返回值判断，否则申请失败，且任继续使用。将会出现意想不到的错误！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结一下&quot;&gt;总结一下&lt;/h2&gt;
&lt;p&gt;通过对RT-Thread的小堆管理器实现的梳理，层层递进更深入理解以下一些要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么需要堆，为什么堆是C/C++运行时的基础之一。堆可实现动态内存管理的多样性，在牺牲一定开销情况下（申请/释放开销，以及内存开销),可以提供内存的利用率，在一定程度上解决内存不足的需求。&lt;/li&gt;
&lt;li&gt;可以更深入的理解链表实用价值，理解静态实现方法的一些技巧。&lt;/li&gt;
&lt;li&gt;通过更深入的理解堆的实现，可以更好的使用堆。&lt;/li&gt;
&lt;li&gt;理解堆管理器究竟在哪里实现的，C/C++标准库，以及操作系统内核都可能实现堆管理器。&lt;/li&gt;
&lt;li&gt;RT-Thread的小堆实现是一个比较简单和比较好的学习堆管理的例子，事实上堆的实现还有更复杂的场景，比如基于SLAB堆管理器实现，以及IAR中库的堆实现还需要使用树这个数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用前没有检查分配失败&lt;/strong&gt;：内存分配不能保证成功，不成功时返回一个空指针。使用返回的空指针，而直接操作这个空指针。可能会导致程序崩溃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存泄露&lt;/strong&gt;：使用free释放内存也可能会失败，失败会导致不可重用内存的累积，这些内存将在堆区不再能被使用。这将浪费内存资源，并可能会随着程序的运行耗尽所有堆内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑错误&lt;/strong&gt;：所有的分配须使用相同的模式:使用malloc申请分配内存，使用free释放内存。如果使用后而不释放。例如在调用free释放之后或在调用malloc之前使用内存、也或者两次调用free释放内存(“double free”)等，通常可能会导致段错误并导致程序崩溃。这些错误可能是偶发的，而且很难调试发现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;文章出自微信公众号：嵌入式客栈，更多内容，请关注本人公众号,严禁商业使用，违法必究&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2028254/202005/2028254-20200525003759750-511693355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 May 2020 16:39:00 +0000</pubDate>
<dc:creator>逸珺</dc:creator>
<og:description>[导读] 前文描述了栈的基本概念，本文来聊聊堆是怎么会事儿。RT Thread 在社区广受欢迎，阅读了其内核代码，实现了堆的管理，代码设计很清晰，可读性很好。故一方面了解RT Thread内核实现，一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/embInn/p/12953799.html</dc:identifier>
</item>
</channel>
</rss>