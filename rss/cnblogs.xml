<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【机器学习之数学】01 导数、偏导数、方向导数、梯度 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10513371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10513371.html</guid>
<description>&lt;p&gt;最近学习《最优化导论》，遇到了“方向导数”这一概念，故对其及相关概念进行一遍梳理。并给出方向导数的推导过程。&lt;/p&gt;
&lt;h2 id=&quot;导数偏导数和方向导数&quot;&gt;导数、偏导数和方向导数&lt;/h2&gt;
&lt;p&gt;  在一元可导函数 &lt;span class=&quot;math inline&quot;&gt;\(y = f(x)\)&lt;/span&gt; 中，导数 &lt;span class=&quot;math inline&quot;&gt;\(f'(x_0)\)&lt;/span&gt; 即是曲线上 &lt;span class=&quot;math inline&quot;&gt;\(x = x_0\)&lt;/span&gt; 处的斜率。按照定义求导数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f'(x) = \lim_{\Delta x \to 0}\frac{f(x+ \Delta x) - f(x)}{\Delta x} \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以通过各种求导法则来计算导数。&lt;/p&gt;
&lt;p&gt;  对一个 &lt;span class=&quot;math inline&quot;&gt;\(R^m \to R\)&lt;/span&gt; 的多元可导函数，&lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x),\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt;，我们能够求的导数就多，如偏导数、方向导数，但归根到底，这些导数都可以认为是曲面上一点在某个方向的斜率。对于 &lt;span class=&quot;math inline&quot;&gt;\(m\le 2\)&lt;/span&gt; 的情况，我们还能够通过坐标系很直观地了解；当 &lt;span class=&quot;math inline&quot;&gt;\(m &amp;gt; 2\)&lt;/span&gt; 时，我们可以从向量空间的角度理解。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;偏导数&lt;/strong&gt;是指 &lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x)\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 中的某一维进行求导，如下式（2）所示，对第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 维求偏导数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\bm x)}{\partial x_i} &amp;amp;= \frac{\partial f(x_1, x_2, ...,x_i,..., x_m)}{\partial x_i} \\ &amp;amp;= \lim_{\Delta x_i \to 0}\frac{f(x_1, x_2, ...,x_i + \Delta x_i,..., x_m) - f(x_1, x_2, ...,x_i,..., x_m)}{\Delta x_i} \end{split} \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;方向导数&lt;/strong&gt;就更好理解了，&lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x)\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 构成的向量空间 &lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt; 中某一方向 &lt;span class=&quot;math inline&quot;&gt;\(\bm d' = [\Delta x_1, \Delta x_2, ..., \Delta x_m]^\top\)&lt;/span&gt; 求导数，即得到该方向上的方向导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial f(\bm x)}{\partial \bm d'}\)&lt;/span&gt;，如式（3）所示：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\bm x)}{\partial \bm d'} &amp;amp;= \frac{\partial f(x_1, x_2,..., x_m)}{\partial x_i} \\ &amp;amp;= \lim_{\rho \to 0}\frac{f(x_1 + \Delta x_1, x_2 +\Delta x_2, ..., x_m +\Delta x_m) - f(x_1, x_2, ...,x_i,..., x_m)}{\rho} \\ &amp;amp;\rho = \sqrt{\Delta x_1^2 + \Delta x_2^2 + \cdots +\Delta x_m^2} \end{split} \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;方向导数和偏导数是什么关系？&lt;/strong&gt;对于多元可导函数 &lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x),\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt;，在其上任一点 &lt;span class=&quot;math inline&quot;&gt;\(\bm x_i\)&lt;/span&gt;，我们都可以在向量空间 &lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt; 中的每一个方向都可以计算一个方向导数，也就是超平面上点 &lt;span class=&quot;math inline&quot;&gt;\(\bm x_i\)&lt;/span&gt; 在每一个方向切线的“斜率”。这里“每一个方向”自然包括各个偏导数的方向。&lt;/p&gt;
&lt;h2 id=&quot;方向导数的推导过程&quot;&gt;方向导数的推导过程&lt;/h2&gt;
&lt;p&gt;  &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol x)\)&lt;/span&gt; 是一个 &lt;span class=&quot;math inline&quot;&gt;\(R^m \to R\)&lt;/span&gt; 的函数，如果我们要求 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol x)\)&lt;/span&gt; 在任一点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol x_0 = [x_1^{0}, x_2^{0}, ..., x_m^{0}]^\top\)&lt;/span&gt; 点方向为 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol d\)&lt;/span&gt; 的方向导数，那么按照定义，我们得到如下公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}\mid_{\boldsymbol x = \boldsymbol x_0} = \lim_{\alpha \to 0}\frac{f(\boldsymbol x_0 + \alpha \boldsymbol d) - f(\boldsymbol x_0)}{\alpha} \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;式（4）中，&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol d\)&lt;/span&gt; 为单位向量。公式（4）其实是公式（3）的向量形式。（plus：公式（3）中 &lt;span class=&quot;math inline&quot;&gt;\(d'\)&lt;/span&gt; 不是单位向量，故加上 &lt;span class=&quot;math inline&quot;&gt;\('\)&lt;/span&gt; 来区分）&lt;/p&gt;
&lt;p&gt;  设 &lt;span class=&quot;math inline&quot;&gt;\(g(\alpha) = f(x_0+\alpha \boldsymbol d)\)&lt;/span&gt;，我们注意到，&lt;span class=&quot;math inline&quot;&gt;\(g(0) = f(x_0)\)&lt;/span&gt;，所以，式（4）又可以写为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}\mid_{\boldsymbol x = \boldsymbol x_0} &amp;amp; = \lim_{\alpha \to 0}\frac{g(\alpha) - g(0)}{\alpha} \\ &amp;amp;= \frac{d g(\alpha)}{d \alpha}\mid_{\alpha = 0} \\ &amp;amp;= \frac{d f(\boldsymbol x_0+\alpha \boldsymbol d)}{d \alpha}|_{\alpha = 0} \\ &amp;amp;= \nabla f(\boldsymbol x_0)^\top\boldsymbol d \\ &amp;amp;= &amp;lt;\nabla f(\boldsymbol x_0), \boldsymbol d&amp;gt; \\ &amp;amp;= \boldsymbol d^\top\nabla f(\boldsymbol x_0) \end{split} \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}= \boldsymbol d^\top\nabla f(\boldsymbol x) \tag{6} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;方向导数和梯度&quot;&gt;方向导数和梯度&lt;/h2&gt;
&lt;p&gt;  首先明确，&lt;strong&gt;导数是一个值&lt;/strong&gt;，代表切线的斜率，而&lt;strong&gt;梯度是一个向量&lt;/strong&gt;。&lt;strong&gt;最大方向导数的方向就是梯度代表的方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;梯度&lt;/strong&gt;是 &lt;span class=&quot;math inline&quot;&gt;\(f(\bm x)\)&lt;/span&gt; 对各个自变量&lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 每一维分别求偏导数得到的向量。&lt;/p&gt;
&lt;p&gt;  从式（5）和（6）中我们也可以知道，&lt;strong&gt;最大方向导数的方向就是梯度，最大的方向导数就是梯度的欧几里德范数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/36301367&quot; target=&quot;_blank&quot;&gt;如何直观形象的理解方向导数与梯度以及它们之间的关系？-- 马同学&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40707407/article/details/80101501&quot; target=&quot;_blank&quot;&gt;方向导数与梯度——学习笔记 -- Reclusiveman&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/walilk/article/details/50978864&quot; target=&quot;_blank&quot;&gt;[机器学习] ML重要概念：梯度（Gradient）与梯度下降法（Gradient Descent）-- WangBo_NLPR&lt;/a&gt;&lt;br/&gt;Edwin K. P. Chong, Stanislaw H. Zak-An Introduction to Optimization-Wiley (2013)&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 15:46:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>本文从方向导数的角度理解偏导数和梯度，厘清这几者之间的关系，即“导数是一个值，代表切线的斜率，而梯度是一个向量。最大方向导数的方向就是梯度代表的方向，最大的方向导数就是梯度的欧几里德范数”。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10513371.html</dc:identifier>
</item>
<item>
<title>BATJ面试必会之 Spring 篇(一） - 程序员乔戈里</title>
<link>http://www.cnblogs.com/qiaogeli/p/10513981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaogeli/p/10513981.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;译者：深海 校对：方腾飞&lt;/p&gt;
&lt;p&gt;出自并发编程网 – ifeve.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;spring-概述&quot;&gt;Spring 概述&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么是spring?&lt;br/&gt;Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用Spring框架的好处是什么？&lt;br/&gt;轻量：Spring 是轻量的，基本的版本大约2MB。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。&lt;/p&gt;
&lt;p&gt;面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。&lt;/p&gt;
&lt;p&gt;容器：Spring 包含并管理应用中对象的生命周期和配置。&lt;/p&gt;
&lt;p&gt;MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。&lt;/p&gt;
&lt;p&gt;事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。&lt;/p&gt;
&lt;p&gt;异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring由哪些模块组成?&lt;br/&gt;以下是Spring 框架的基本模块：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Core module&lt;/p&gt;
&lt;p&gt;Bean module&lt;/p&gt;
&lt;p&gt;Context module&lt;/p&gt;
&lt;p&gt;Expression Language module&lt;/p&gt;
&lt;p&gt;JDBC module&lt;/p&gt;
&lt;p&gt;ORM module&lt;/p&gt;
&lt;p&gt;OXM module&lt;/p&gt;
&lt;p&gt;Java Messaging Service(JMS) module&lt;/p&gt;
&lt;p&gt;Transaction module&lt;/p&gt;
&lt;p&gt;Web module&lt;/p&gt;
&lt;p&gt;Web-Servlet module&lt;/p&gt;
&lt;p&gt;Web-Struts module&lt;/p&gt;
&lt;p&gt;Web-Portlet module&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;核心容器（应用上下文) 模块。&lt;br/&gt;这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BeanFactory – BeanFactory 实现举例。&lt;br/&gt;Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最常用的BeanFactory 实现是XmlBeanFactory 类。&lt;/p&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;XMLBeanFactory&lt;br/&gt;最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;解释AOP模块&lt;br/&gt;AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;解释JDBC抽象和DAO模块。&lt;br/&gt;通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;解释对象/关系映射集成模块。&lt;br/&gt;Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;解释WEB 模块。&lt;br/&gt;Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring配置文件&lt;br/&gt;Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;什么是Spring IOC 容器？&lt;br/&gt;Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;IOC的优点是什么？&lt;br/&gt;IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ApplicationContext通常的实现是什么?&lt;br/&gt;FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。&lt;/p&gt;
&lt;p&gt;WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Bean 工厂和 Application contexts 有什么区别？&lt;br/&gt;Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个Spring的应用看起来象什么？&lt;br/&gt;一个定义了一些功能的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这实现包括属性，它的Setter ， getter 方法和函数等。&lt;/p&gt;
&lt;p&gt;Spring AOP&lt;/p&gt;
&lt;p&gt;Spring 的XML 配置文件&lt;/p&gt;
&lt;p&gt;使用以上功能的客户端程序&lt;/p&gt;
&lt;p&gt;依赖注入&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;什么是Spring的依赖注入？&lt;br/&gt;依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;有哪些不同类型的IOC（依赖注入）方式？&lt;br/&gt;构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？&lt;br/&gt;你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring Beans&lt;br/&gt;21.什么是Spring beans?&lt;br/&gt;Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。&lt;/p&gt;
&lt;p&gt;Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个 Spring Bean 定义 包含什么？&lt;br/&gt;一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如何给Spring 容器提供配置元数据?&lt;br/&gt;这里有三种重要的方法给Spring 容器提供配置元数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;XML配置文件。&lt;/p&gt;
&lt;p&gt;基于注解的配置。&lt;/p&gt;
&lt;p&gt;基于java的配置。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;你怎样定义类的作用域?&lt;br/&gt;当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;解释Spring支持的几种bean的作用域。&lt;br/&gt;Spring框架支持以下五种bean的作用域：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;singleton : bean在每个Spring ioc 容器中只有一个实例。&lt;/p&gt;
&lt;p&gt;prototype：一个bean的定义可以有多个实例。&lt;/p&gt;
&lt;p&gt;request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。&lt;/p&gt;
&lt;p&gt;session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。&lt;/p&gt;
&lt;p&gt;global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。&lt;/p&gt;
&lt;p&gt;缺省的Spring bean 的作用域是Singleton.&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring框架中的单例bean是线程安全的吗?&lt;br/&gt;不，Spring框架中的单例bean不是线程安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释Spring框架中bean的生命周期。&lt;br/&gt;Spring容器 从XML 文件中读取bean的定义，并实例化bean。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring根据bean的定义填充所有的属性。&lt;/p&gt;
&lt;p&gt;如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。&lt;/p&gt;
&lt;p&gt;如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。&lt;/p&gt;
&lt;p&gt;如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。&lt;/p&gt;
&lt;p&gt;如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。&lt;/p&gt;
&lt;p&gt;如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。&lt;/p&gt;
&lt;p&gt;如果bean实现了 DisposableBean，它将调用destroy()方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哪些是重要的bean生命周期方法？ 你能重载它们吗？&lt;br/&gt;有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;什么是Spring的内部bean？&lt;br/&gt;当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在 或 元素内使用 元素，内部bean通常是匿名的，它们的Scope一般是prototype。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 Spring中如何注入一个java集合？&lt;br/&gt;Spring提供以下几种集合的配置元素：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类型用于注入一列值，允许有相同的值。&lt;/p&gt;
&lt;p&gt;类型用于注入一组值，不允许有相同的值。&lt;/p&gt;
&lt;map readability=&quot;87.5&quot;&gt;&lt;p&gt;类型用于注入一组键值对，键和值都可以为任意类型。&lt;/p&gt;
&lt;p&gt;类型用于注入一组键值对，键和值都只能为String类型。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;什么是bean装配?&lt;br/&gt;装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;什么是bean的自动装配？&lt;br/&gt;Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释不同方式的自动装配 。&lt;br/&gt;有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。&lt;/p&gt;
&lt;p&gt;byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。&lt;/p&gt;
&lt;p&gt;byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。&lt;/p&gt;
&lt;p&gt;constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。&lt;/p&gt;
&lt;p&gt;autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。&lt;/p&gt;
&lt;p&gt;34.自动装配有哪些局限性 ?&lt;br/&gt;自动装配的局限性是：&lt;/p&gt;
&lt;p&gt;重写： 你仍需用 和 配置来定义依赖，意味着总要重写自动装配。&lt;/p&gt;
&lt;p&gt;基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。&lt;/p&gt;
&lt;p&gt;模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你可以在Spring中注入一个null 和一个空字符串吗？&lt;br/&gt;可以。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring注解&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么是基于Java的Spring注解配置? 给一些注解的例子.&lt;br/&gt;基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么是基于注解的容器配置?&lt;br/&gt;相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;怎样开启注解装配？&lt;br/&gt;注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;@Required 注解&lt;br/&gt;这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;@Autowired 注解&lt;br/&gt;@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;@Qualifier 注解&lt;br/&gt;当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring数据访问&lt;br/&gt;42.在Spring框架中如何更有效地使用JDBC?&lt;br/&gt;使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate （例子见这里here）&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;JdbcTemplate&lt;br/&gt;JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Spring对DAO的支持&lt;br/&gt;Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用Spring通过什么方式访问Hibernate?&lt;br/&gt;在Spring中有两种方式访问Hibernate：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;控制反转 Hibernate Template和 Callback。&lt;/p&gt;
&lt;p&gt;继承 HibernateDAOSupport提供一个AOP 拦截器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring支持的ORM&lt;br/&gt;Spring支持以下ORM：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Hibernate&lt;/p&gt;
&lt;p&gt;iBatis&lt;/p&gt;
&lt;p&gt;JPA (Java Persistence API)&lt;/p&gt;
&lt;p&gt;TopLink&lt;/p&gt;
&lt;p&gt;JDO (Java Data Objects)&lt;/p&gt;
&lt;p&gt;OJB&lt;/p&gt;
&lt;p&gt;47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？&lt;br/&gt;用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：&lt;/p&gt;
&lt;p&gt;配置the Hibernate SessionFactory。&lt;/p&gt;
&lt;p&gt;继承HibernateDaoSupport实现一个DAO。&lt;/p&gt;
&lt;p&gt;在AOP支持的事务中装配。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring支持的事务管理类型&lt;br/&gt;Spring支持两种类型的事务管理：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。&lt;/p&gt;
&lt;p&gt;声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring框架的事务管理有哪些优点？&lt;br/&gt;它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如&lt;/p&gt;
&lt;p&gt;它支持声明式事务管理。&lt;/p&gt;
&lt;p&gt;它和Spring各种数据访问抽象层很好得集成。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你更倾向用那种事务管理类型？&lt;br/&gt;大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring面向切面编程（AOP）&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释AOP&lt;br/&gt;面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Aspect 切面&lt;br/&gt;AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Spring AOP 中，关注点和横切关注的区别是什么？&lt;br/&gt;关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。&lt;br/&gt;横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;连接点&lt;br/&gt;连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通知&lt;br/&gt;通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring切面可以应用五种类型的通知：&lt;/p&gt;
&lt;p&gt;before：前置通知，在一个方法执行前被调用。&lt;/p&gt;
&lt;p&gt;after: 在方法执行之后调用的通知，无论方法执行是否成功。&lt;/p&gt;
&lt;p&gt;after-returning: 仅当方法成功完成后执行的通知。&lt;/p&gt;
&lt;p&gt;after-throwing: 在方法抛出异常退出时执行的通知。&lt;/p&gt;
&lt;p&gt;around: 在方法执行之前和之后调用的通知。&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;切点&lt;br/&gt;切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么是引入?&lt;br/&gt;引入允许我们在已存在的类中增加新的方法和属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;什么是目标对象?&lt;br/&gt;被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;什么是代理?&lt;br/&gt;代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有几种不同类型的自动代理？&lt;br/&gt;BeanNameAutoProxyCreator&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;DefaultAdvisorAutoProxyCreator&lt;/p&gt;
&lt;p&gt;Metadata autoproxying&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么是织入。什么是织入应用的不同点？&lt;br/&gt;织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;织入可以在编译时，加载时，或运行时完成。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释基于XML Schema方式的切面实现。&lt;br/&gt;在这种情况下，切面由常规类以及基于XML的配置实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释基于注解的切面实现&lt;br/&gt;在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring 的MVC&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么是Spring的MVC框架？&lt;br/&gt;Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DispatcherServlet&lt;br/&gt;Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WebApplicationContext&lt;br/&gt;WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;什么是Spring MVC框架的控制器？&lt;br/&gt;控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@Controller 注解&lt;br/&gt;该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@RequestMapping 注解&lt;br/&gt;该注解是用来映射一个URL到一个类或一个特定的方处理法上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;觉得文章不错的欢迎关注我的WX公众号：&lt;strong&gt;程序员乔戈里&lt;/strong&gt;&lt;br/&gt;我是&lt;strong&gt;百度&lt;/strong&gt;后台开发工程师，哈工大计算机本硕，专注分享技术干货/编程资源/求职面试/成长感悟等,关注送3000G编程资源，免费下载CSDN资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007s8HJUly1g0fkgcpy8cj30760760t7.jpg&quot;/&gt;&lt;/p&gt;
&lt;/map&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:23:00 +0000</pubDate>
<dc:creator>程序员乔戈里</dc:creator>
<og:description>BATJ66SPring 面试题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaogeli/p/10513981.html</dc:identifier>
</item>
<item>
<title>第二章 模型评估 - wemo</title>
<link>http://www.cnblogs.com/wemo/p/10513972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wemo/p/10513972.html</guid>
<description>&lt;h3 id=&quot;评价指标的局限性&quot;&gt;1. 评价指标的局限性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;准确率（Accuracy）&lt;/li&gt;
&lt;li&gt;精确率（Precision）&lt;/li&gt;
&lt;li&gt;召回率（Recall）&lt;/li&gt;
&lt;li&gt;均方根误差（Root Mean Square Error, RMSE）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;准确率&quot;&gt;1.1 准确率&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;准确率：&lt;/strong&gt; 指分类正确的样本占总样本个数的比例&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;Accuracy = \frac{n_{correct}}{n_{total}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;准确度的问题：&lt;/strong&gt; 当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。&lt;br/&gt;例如：当负样本占99%，分类器把所有样本都预测为负样本也可以获得99%的准确率。&lt;/p&gt;
&lt;h4 id=&quot;精确率与召回率&quot;&gt;1.2 精确率与召回率&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;精确度：&lt;/strong&gt; 分类正确的正样本个数占分类器判定为正样本的样本个数的比例。&lt;br/&gt;&lt;strong&gt;召回率：&lt;/strong&gt; 分类正确的正样本个数占真正的正样本个数的比例。&lt;/p&gt;
&lt;p&gt;在排序问题中，通常没有一个确定的阀值把得到的结果直接判定为正样本或负样本，而是采用TopN返回结果的Precision值和Recall值来衡量排序模型的性能，即认为模型返回的Top N的结果就是模型判定的正样本，然后计算前N个位置上的准确率Precision@N和前N个位置上的召回率Recall@N。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Precision值和Recall值是既矛盾又统一的两个指标，为了提高Precision值，分类器需要尽量在“更有把握”时才把样本预测为正样本，但此时往往会因为过于保守而漏掉很多“没有把握”的正样本，导致Recall值降低。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了综合评价一个排序模型的好坏，不仅要看precision和recall，而且最好绘制模型&lt;strong&gt;P-R（precision-recall）曲线&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903111649_398.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图可见，当召回率接近于0时，模型A的精确率为0.9，模型B的精确率是1，这说明模型B得分前几位的样本全部是真正的正样本，而模型A即使得分最高的几个样本也存在预测错误的情况。并且，随着召回率的增加，精确率整体呈下降趋势。但是，当召回率为1时，模型A的精确率反而超过了模型B。这充分说明，只用某个点对应的精确率和召回率是不能全面地衡量模型的性能，只有通过P-R曲线的整体表现，才能够对模型进行更为全面的评估。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;F1 score&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;math F1 = \frac{2 \times precision \times recall} {precision + recall}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;均方根误差rmse&quot;&gt;1.3 均方根误差RMSE&lt;/h4&gt;
&lt;p&gt;RMSE的计算公式：&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;RMSE = \sqrt{ {\frac {{\sum_{i=1}^n} {(y_i - \overline{y}_{i} )}^2}  {n}}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;是第i个样本点的真实值，&lt;span class=&quot;math inline&quot;&gt;\(\overline{y}_{i}\)&lt;/span&gt; 是第i个样本预测值, n是样本点个数。&lt;/p&gt;
&lt;p&gt;RMSE能够很好地反映回归模型预测值与真实值的偏离程度。&lt;/p&gt;
&lt;p&gt;比RMSE的鲁棒性更好的指标，平均绝对百分比误差（Mean Absolute Percent Error， MAPE）,定义如下：&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112058_325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;物理含义：相比RMSE，MAPE相当于把每个点的误差进行了归一化，降低了个别离群点带来的绝对误差的影响。&lt;br/&gt;***&lt;/p&gt;
&lt;h3 id=&quot;roc曲线&quot;&gt;2. ROC曲线&lt;/h3&gt;
&lt;p&gt;ROC曲线是Receiver Operating Characteristic Curve的简称，中文名为“受试者工作特征曲线”。ROC曲线源于军事领域，而后在医学领域应用甚广，“受试者工作特征曲线”这一名称也正是来自于医学领域。&lt;/p&gt;
&lt;p&gt;ROC曲线的横坐标为&lt;strong&gt;假阳性率（False Positive Rate，FPR）&lt;/strong&gt;；纵坐标为&lt;strong&gt;真阳性率(True Positive Rate，TPR)&lt;/strong&gt; 。FPR和TPR的计算方法分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112102_291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上式中，P是真实的正样本的数量，N是真实的负样本的数量，&lt;strong&gt;TP是P个正样本中被分类器预测为正样本的个数&lt;/strong&gt;，&lt;strong&gt;FP是N个负样本中被分类器预测为正样本的个数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面例子有助于学习：&lt;br/&gt;只看定义确实有点绕，为了更直观地说明这个问题，我们举一个医院诊断病人的例子。假设有10位疑似癌症患者，其中有3位很不幸确实患了癌症（P=3），另外7位不是癌症患者（N=7）。医院对这10位疑似患者做了诊断，诊断出3位癌症患者，其中有2位确实是真正的患者（TP=2）。那么真阳性率TPR=TP/P=2/3。对于7位非癌症患者来说，有一位很不幸被误诊为癌症患者（FP=1），那么假阳性率FPR=FP/N=1/7。对于“该医院”这个分类器来说，这组分类结果就对应ROC曲线上的一个点（1/7，2/3）。&lt;/p&gt;
&lt;h4 id=&quot;如何画出roc曲线&quot;&gt;2.1 如何画出ROC曲线？&lt;/h4&gt;
&lt;p&gt;**ROC曲线是通过不选移动分类器的&lt;u&gt;截断点&lt;/u&gt;来生成曲线上的一组关键点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;截断点&lt;/strong&gt;:区分正负预测结果的阈值。&lt;/p&gt;
&lt;p&gt;通过动态地调整截断点，从最高的得分开始（实际上是从正无穷开始，对应着ROC曲线的零点），逐渐调整到最低得分，每一个截断点都会对应一个FPR和TPR，在ROC图上绘制出每个截断点对应的位置，再连接所有点就得到最终的ROC曲线。&lt;/p&gt;
&lt;p&gt;其实，还有一种更直观地绘制ROC曲线的方法。首先，根据样本标签统计出正负样本的数量，假设正样本数量为P，负样本数量为N；接下来，把横轴的刻度间隔设置为1/N，纵轴的刻度间隔设置为1/P；再根据模型输出的预测概率对样本进行排序（从高到低）；依次遍历样本，同时从零点开始绘制ROC曲线，每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线，每遇到一个负样本就沿横轴方向绘制一个刻度间隔的曲线，直到遍历完所有样本，曲线最终停在（1，1）这个点，整个ROC曲线绘制完成。&lt;/p&gt;
&lt;h4 id=&quot;如何计算auc&quot;&gt;2.2 如何计算AUC?&lt;/h4&gt;
&lt;p&gt;AUC，就是ROC曲线下的面积。&lt;strong&gt;能够量化地反映基于ROC曲线衡量出的模型性能。AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算AUC值只需要沿着ROC横轴做积分就可以了。&lt;/p&gt;
&lt;h4 id=&quot;比较roc曲线和p-r曲线有什么特点&quot;&gt;2.3 比较ROC曲线和P-R曲线有什么特点？&lt;/h4&gt;
&lt;p&gt;相比P-R曲线，ROC曲线有一个特点，当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。（从两者曲线的定义、物理含义就能很好地理解）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112130_536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，P-R曲线发生了明显的变化，而ROC曲线形状基本不变。这个特点让ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能。这有什么实际意义呢？在很多实际问题中，正负样本数量往往很不均衡。比如，计算广告领域经常涉及转化率模型，正样本的数量往往是负样本数量的1/1000甚至1/10000。若选择不同的测试集，P-R曲线的变化就会非常大，而ROC曲线则能够更加稳定地反映模型本身的好坏。所以，ROC曲线的适用场景更多，被广泛用于排序、推荐、广告等领域。但需要注意的是，选择P-R曲线还是ROC曲线是因实际问题而异的，如果研究者希望更多地看到模型在特定数据集上的表现，P-R曲线则能够更直观地反映其性能。&lt;br/&gt;***&lt;/p&gt;
&lt;h3 id=&quot;余弦距离的应用&quot;&gt;3. 余弦距离的应用&lt;/h3&gt;
&lt;p&gt;对于两个向量A和B，其余弦相似度定义为&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112141_811.png&quot;/&gt;&lt;br/&gt;即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，其取值范围是[-1，1]。当一对文本相似度的长度差距很大、但内容相近时，如果使用词频或词向量作为特征，它们在特征空间中的的欧氏距离通常很大；而如果使用余弦相似度的话，它们之间的夹角可能很小，因而相似度高。此外，在文本、图像、视频等领域，研究的对象的特征维度往往很高，余弦相似度在高维情况下依然保持“相同时为1，正交时为0，相反时为-1”的性质，而欧氏距离的数值则受维度的影响，范围不固定，并且含义也比较模糊。&lt;/p&gt;
&lt;p&gt;在一些场景，例如Word2Vec中，其向量的模长是经过归一化的，此时欧氏距离与余弦距离有着单调的关系，即&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112142_283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;：&lt;br/&gt;总体来说，&lt;strong&gt;欧氏距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异&lt;/strong&gt;。例如，统计两部剧的用户观看行为，用户A的观看向量为（0，1），用户B为（1，0）；此时二者的余弦距离很大，而欧氏距离很小；我们分析两个用户对于不同视频的偏好，更关注相对差异，显然应当使用余弦距离。而当我们分析用户活跃度，以登陆次数（单位：次）和平均观看时长（单位：分钟）作为特征时，余弦距离会认为（1，10）、（10，100）两个用户距离很近：但显然这两个用户活跃度是有着极大差异的，此时我们更关注数值绝对差异，应当使用欧氏距离。&lt;br/&gt;特定的度量方法适用于什么样的问题，需要在学习和研究中多总结和思考，这样不仅仅对面试有帮助，在遇到新的问题时也可以活学活用。&lt;/p&gt;
&lt;h4 id=&quot;余弦距离是不是一个严格定义的距离&quot;&gt;3.1 余弦距离是不是一个严格定义的距离？&lt;/h4&gt;
&lt;p&gt;距离定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得三条距离公理（&lt;strong&gt;正定性，对称性，三角不等式&lt;/strong&gt;）成立，则该实数可称为这对元素之间的距离。&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112149_295.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112149_853.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112150_718.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112151_336.png&quot;/&gt;&lt;br/&gt;***&lt;/p&gt;
&lt;h3 id=&quot;ab测试的陷阱&quot;&gt;4. A/B测试的陷阱&lt;/h3&gt;
&lt;h4 id=&quot;在对模型进行过充分的离线评估之后为什么还要进行在线ab测试&quot;&gt;4.1 在对模型进行过充分的离线评估之后，为什么还要进行在线A/B测试？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;离线评估无法完全消除模型过拟合的影响。&lt;/li&gt;
&lt;li&gt;离线评估无法完全还原线上工程环境。&lt;/li&gt;
&lt;li&gt;某些商业指标在离线评估中无法计算。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何进行线上ab测试&quot;&gt;4.2 如何进行线上A/B测试？&lt;/h4&gt;
&lt;p&gt;进行A/B测试的主要手段是进行用户分桶，即将用户分成实验组和对照组，对实验组的用户施以新模型，对对照组的用户施以旧模型。在分桶的过程中，要注意样本的独立性和采样方式的无偏性，确保同一个用户每次只能分到同一个桶中，在分桶过程中所选取的user_id需要是一个随机数，这样才能保证桶中的样本是无偏的。&lt;br/&gt;***&lt;/p&gt;
&lt;h3 id=&quot;模型评估的方法&quot;&gt;5. 模型评估的方法&lt;/h3&gt;
&lt;h4 id=&quot;模型评估过程中有哪些主要的验证方法优缺点是什么&quot;&gt;5.1 模型评估过程中，有哪些主要的验证方法，优缺点是什么？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. Holdout检验&lt;/strong&gt;&lt;br/&gt;Holdout 检验是最简单也是最直接的验证方法，&lt;strong&gt;它将原始的样本集合随机划分成训练集和验证集两部分&lt;/strong&gt;。比方说，对于一个点击率预测模型，我们把样本按照70%~30%的比例分成两部分，70%的样本用于模型训练；30%的样本用于模型验证，包括绘制ROC曲线、计算精确率和召回率等指标来评估模型性能。&lt;/p&gt;
&lt;p&gt;Holdout 检验的缺点很明显，即在验证集上计算出来的最后&lt;strong&gt;评估指标与原始分组有很大关系&lt;/strong&gt;。为了消除随机性，研究者们引入了“交叉检验”的思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 交叉检验&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;k-fold交叉验证&lt;/strong&gt;：首先将全部样本划分成k个大小相等的样本子集；依次遍历这k个子集，每次把当前子集作为验证集，其余所有子集作为训练集，进行模型的训练和评估；最后把k次评估指标的平均值作为最终的评估指标。在实际实验中，k经常取10。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;留一验证&lt;/strong&gt;：每次留下1个样本作为验证集，其余所有样本作为测试集。样本总58数为n，依次对n个样本进行遍历，进行n次验证，再将评估指标求平均值得到最终的评估指标。在样本总数较多的情况下，留一验证法的时间开销极大。事实上，留一验证是留p验证的特例。留p验证是每次留下p个样本作为验证集，而从n个元素中选择p个元素有C%种可能，因此它的时间开销更是远远高于留一验证，故而很少在实际工程中被应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自助法&lt;/strong&gt;：自助法是基于自助采样法的检验方法。对于总数为n的样本集合，进行n次有放回的随机抽样，得到大小为n的训练集。n次采样过程中，有的样本会被重复采样，有的样本没有被抽出过，将这些没有被抽出的样本作为验证集，进行模型验证，这就是自助法的验证过程。&lt;/p&gt;
&lt;h4 id=&quot;自助法对n个样本进行采样当n趋于无穷大时有多少样本从未被选择过&quot;&gt;5.2 自助法，对n个样本进行采样，当n趋于无穷大时，有多少样本从未被选择过？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112259_125.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://pno0u7rla.bkt.clouddn.com/201903112259_671.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;超参数调优&quot;&gt;6. 超参数调优&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;网格搜索：通过查找搜索范围内的所有的点来确定最优值&lt;/li&gt;
&lt;li&gt;随机搜索：在搜索范围内随机选取样本点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;贝叶斯优化算法&lt;/strong&gt;：贝叶斯优化算法在寻找最优最值参数时，采用了与网格搜索、随机搜索完全不同的方法。网格搜索和随机搜索在测试一个新点时，会忽略前一个点的信息；而贝叶斯优化算法则充分利用了之前的信息。贝叶斯优化算法通过对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。具体来说，它学习目标函数形状的方法是，首先根据先验分布，假设一个搜集函数；然后，每一次使用新的采样点来测试目标函数时，利用这个信息来更新目标函数的先验分布；最后，算法测试由后验分布给出的全局最值最可能出现的位置的点。对于贝叶斯优化算法，有一个需要注意的地方，一旦找到了一个局部最优值，它会在该区域不断采样，所以很容易陷入局部最优值。为了弥补这个缺陷，贝叶斯优化算法会在探索和利用之间找到一个平衡点，“探索”就是在还未取样的区域获取采样点；而“利用”则是根据后验分布在最可能出现全局最值的区域进行采样。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;过拟合与欠拟合&quot;&gt;7. 过拟合与欠拟合&lt;/h3&gt;
&lt;h4 id=&quot;过拟合和欠拟合具体指的是什么现象&quot;&gt;7.1 过拟合和欠拟合具体指的是什么现象？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;过拟合&lt;/strong&gt;：在训练集上表现很好，在测试集和新数据上表现很差。&lt;br/&gt;&lt;strong&gt;欠拟合&lt;/strong&gt;：训练和测试都表现不好。&lt;/p&gt;
&lt;h4 id=&quot;降低过拟合和欠拟合风险的方法&quot;&gt;7.2 降低过拟合和欠拟合风险的方法？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;降低过拟合的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获得更多的数据&lt;/li&gt;
&lt;li&gt;降低模型复杂度。&lt;/li&gt;
&lt;li&gt;正则化方法。（给模型参数加上一定的正则约束）&lt;/li&gt;
&lt;li&gt;集成学习。集成学习是把多个模型集成在一起，来降低单一模型的过拟合风险，如Bagging方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;降低欠拟合风险的方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加新特征&lt;/li&gt;
&lt;li&gt;增加模型复杂度&lt;/li&gt;
&lt;li&gt;减小正则化系数&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:22:00 +0000</pubDate>
<dc:creator>wemo</dc:creator>
<og:description>1. 评价指标的局限性 准确率（Accuracy） 精确率（Precision） 召回率（Recall） 均方根误差（Root Mean Square Error, RMSE） 1.1 准确率 准确率</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wemo/p/10513972.html</dc:identifier>
</item>
<item>
<title>爬虫与反爬虫的较量-图片反爬 - 一杯闪光喵</title>
<link>http://www.cnblogs.com/lyxdw/p/10513967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyxdw/p/10513967.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在去年6月吧，刚转行做爬虫的时候，经常拿图片网还有小说网练手，无意中发现一个壁纸网站叫做娟娟壁纸网，有好多高清壁纸（这不是广告，哈哈）&lt;/p&gt;
&lt;p&gt;当时是写了全站爬取的代码。以为自己大工告成的时候，结果刚运行，就发现爬出来的图片不对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311220901019-1153800688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每张图片都是这样，我以为遇到了IP限制，于是使用代理，结果仍然是失败。&lt;/p&gt;
&lt;p&gt;难道是请求头做了限制？好，那我全部带上。结果依旧失败。&lt;/p&gt;
&lt;p&gt;当时也是忙于找工作,也没静下心来仔细想，今天回过头来继续盘它。&lt;/p&gt;
&lt;p&gt;虽然最后巧妙的用了get请求爬取成功,但是还是没搞明白原图反爬的原因。&lt;/p&gt;
&lt;p&gt;下面来看一看究竟是怎么回事。&lt;/p&gt;
&lt;h2&gt;分析网站&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311221704833-1171540162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 附上链接：http://www.jj20.com/bz/zrfg/ssrh/5565.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222027616-146266129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 图片url在网站html代码中，我爬取的也是这张图片。&lt;/p&gt;
&lt;p&gt;复制图片链接到浏览器访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222223619-1633576832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 正常，浏览器能加载，爬虫为什么就不能下载。刷新图片，结果图片没了，出现了和爬虫一样的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222422762-618232221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到网站，刷新，结果，图片没了，加载不出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222540487-924273411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;假设是缓存导致的，清理一下浏览器的cookie和缓存。再次刷新，图片又出来了。&lt;/p&gt;
&lt;p&gt;爬虫直接请求链接会失败，具体的反爬策略，我们也不清楚。默认为图片只能在网站上加载，单独访问会失败。&lt;/p&gt;

&lt;p&gt;从网站分析图片，网站里可能有下载链接。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311225422821-760397861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成壁纸，根据分辨率来的，之前网站爬的应该都是原图，点进去看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311225632399-217067292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刷新，还是这张图，可以重复访问。&lt;/p&gt;
&lt;p&gt;http://cj.jj20.com/d/cj0.php?p=/up/allimg/611/031213123016/130312123016-0.jpg&amp;amp;w=1536&amp;amp;h=864&lt;/p&gt;
&lt;p&gt;这是一个get请求，提交了三个参数p(图片链接)，w(宽)，h(高),生成一张1536乘864的图片。&lt;/p&gt;
&lt;h2&gt;单张图片爬取&lt;/h2&gt;
&lt;p&gt;（写一个demo，测试了一下）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt;  requests
url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://cj.jj20.com/d/cj0.php?p=/up/allimg/611/031213123016/130312123016-0.jpg&amp;amp;w=1536&amp;amp;h=864&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
res &lt;/span&gt;= requests.get(url).content &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以二进制字节码保存&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    f.write(res)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311230649914-1658491221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（单张图片爬取成功）宽和高都是可以自己改的，看自己桌面分辨率自己改。&lt;/p&gt;

&lt;p&gt;本文主要介绍爬取思路，全站爬取代码后续再补充。&lt;/p&gt;

&lt;p&gt;对于上面的网站原图反爬，我至今不是特别明白是什么原因，希望了解这方面的大牛，可以留言告知，我会尽快回复。&lt;/p&gt;

&lt;h3&gt;温馨提示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果您对本文有疑问，请在评论部分留言，我会在最短时间回复。&lt;/li&gt;
&lt;li&gt;如果本文帮助了您，也请评论关注，作为对我的一份鼓励。&lt;/li&gt;
&lt;li&gt;如果您感觉我写的有问题，也请批评指正，我会尽量修改。&lt;/li&gt;
&lt;li&gt;本文为原创，转载请注明出处。&lt;/li&gt;
&lt;li&gt;本文所有代码仅供学习参考，在爬取的同时考虑对方的服务器承受能力，适可而止。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>一杯闪光喵</dc:creator>
<og:description>前言 在去年6月吧，刚转行做爬虫的时候，经常拿图片网还有小说网练手，无意中发现一个壁纸网站叫做娟娟壁纸网，有好多高清壁纸（这不是广告，哈哈） 当时是写了全站爬取的代码。以为自己大工告成的时候，结果刚运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyxdw/p/10513967.html</dc:identifier>
</item>
<item>
<title>React 精要面试题讲解(一) 单向数据流 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10513571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10513571.html</guid>
<description>&lt;h2 id=&quot;react-单向数据流概念&quot;&gt;react 单向数据流概念&lt;/h2&gt;
&lt;h3 id=&quot;react框架是怎样的数据流向react单向数据流是怎样的概念&quot;&gt;'react框架是怎样的数据流向？'||'react单向数据流是怎样的概念 ?'&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  解答这个问题之前，我们首先得知道，js框架是个怎样的概念。
  框架：具备一定**编程思想**的(mvc/mvvm)js库,叫做框架;
  那么这道题的答案重点就在于编程思想这四个字上。

  众所周知，多数MVVM框架，如react、vue都是单向数据流的框架。
  单向数据流：即规范了数据的流向——由外层组件向内层组件进行传递;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190311232907585-718986797.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ok，我们经由上述概念得知了单向数据流其实是一种框架本身对数据流向的限制。
  那么为什么会做出这样的限制呢？   为什么不让我们为所欲为的想怎么传就怎么传呢？&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;react的编程思想和单向数据流的关系&quot;&gt;react的编程思想和单向数据流的关系&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  针对上述问题，我们结合编程思想来思考这个问题的答案。
  多数React框架的使用者可能在接触react这门框架前，就听说了有关react的诸如此类的评价——
   ”react，从入门到放弃。“
   ”相对vue，react入门难的一批。“
   ”react语法限制太严格。“
   ……
   ok，首先在这里说些题外话——我要批判这类评价。理由很简单：
   在react基于es6改版之前，只要深层次掌握了原生js的构造函数，react入门难度其实也算不上啥。
    1而在react16版本后，恕我直言，如果es6的class玩明白了，react上手使用真的零难度入门。
    2jsx花五分钟,如果之前接触过ejs/xtemplate/jade这些模版引擎，jsx相对它们还要简单;
    3而props、state、refs、context，children可以看作几个特殊的实例属性(我们甚至可以直接做个推测：父类React.Component定义了它们的管理方式);
    4那么封装组件就是写个子类啊没毛病啊;
    5好吧你说哪个框架没有生命周期钩子这玩意;
    6高阶组件对比一下类的修饰器(generetor,es6的提案，es7实现),我滴乖乖，一样的东西啊;
    
    综上所述问题，react简单的一批啊，我们只要在js的基础上，学下jsx语法，弄明白几个特殊实例属性怎么玩，一张图明白react的基本生命周期钩子，结合单向数据流的思想，为所欲为啊。
   
    ……
    跑远了，我们回来讲react编程思想和单向数据流之间的关系。
    敲黑板了看重点：
     
      react的编程思想是严谨且周密的，它约束了我们的花式操作，这是为了确保我们在使用react构建复杂项目的时候不会出现太多问题。
      而好处也是显而易见的——我们写react项目，一旦出现了问题，那么我们会很轻松的发现，根源几乎集中在props和state这俩实例属性上。 
      单向数据流是react规范的数据流向,它的作用是极大的降低了我们组件间通信的代码耦合，让组件间的通信更为清晰，debug直接往props中找(后面会介绍context)。
      也就是说，基于react严谨且周密的编程思想，制订了单向数据流这样的通信约束，使得我们react项目中的数据传递结构稳定且不易耦合，有事没事找props解决一切通信问题(多好啊，你看vue不也乐呵呵的在使用嘛，话说这里好想吐个槽：很明显了你们这些英语负八级的渣渣啊~找啥接口啊放弃react到vue，vue对比react最大优势明明是中文文档好啊有木有！毕竟是中国人做的啊！ps: 致敬尤大佬)。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单向数据流除了单向之外还有怎样的限制&quot;&gt;单向数据流除了单向之外还有怎样的限制？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    其实react中的单向数据流，完整概念应该是： 数据的流向只能通过props由外层到内层 一层一层往里传递。
    只能通过props一层一层往里传递这样的限制啊……不可能的，考虑到项目复杂度，组件层级过高，这个我们真不能接受啊。
    react想了想，是啊不能太狠毒，限制过大万一没人用岂不是尴尬了？于是加上了context这个玩意，方便我们进行组件间的隔代通信。
  ![](https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190311233724579-784747102.png)
     但react也是要面子的，完事还告诉我们：这玩意轻易不要用啊，危险啊这家伙，慎重使用啊小伙子们！
   靠，君不见react-redux中的Provider组件，源码就是简单的用了context加上个插槽(children)就完事了啊…整个组件源码就八九行啊，我闭着眼都能封装给你看有木有啊喂！
   所以说只要是放在正式版本中的api，我们都可以大胆的去使用，当然，前提是最好得知道它的核心原理甚至源码的封装，避免太花哨的操作引起不必要的八阿哥。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  就单向数据流的概念这个问题，在清晰的给出概念给面试官后，一定要结合react的严谨性去做个解释，后面讲讲单向数据流的传递方式props和context，这道题基本已经不需要再讲了。(你满分了，别讲了，再讲你讲讲源码吧)
  然而，一般来讲，在你讲完单向数据流的概念后，心机的面试官立马会问你下一个问题： 
  react既然规定了单向数据流， 那么如何在react中实现逆向通信？（子组件向父组件方向通信）
  这个问题，我们留到下一篇做个讲解。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>react面试题之单向数据流</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10513571.html</dc:identifier>
</item>
<item>
<title>线性回归损失函数求解 - shayue111</title>
<link>http://www.cnblogs.com/shayue/p/10513898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shayue/p/10513898.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇笔记中已经记录了，&lt;span&gt;如何对一个无解的线性方程组&lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;求近似解。&lt;/span&gt;在这里，我们先来回顾两个知识点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何判断一个线性方程组无解：如果拿上面那个方程组&lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;举例，那就是向量&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;不在矩阵A对应的列空间中，至于列空间的概念，可以参考&lt;code&gt;四个基本子空间&lt;/code&gt;那篇笔记&lt;/li&gt;
&lt;li&gt;如何对无解的方程组求近似解：根据上一篇笔记&lt;code&gt;如何寻找一个投影矩阵&lt;/code&gt;可以有这么一个思路，将向量&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;往矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;所在的列空间投影得到向量&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;，得到新的方程组&lt;span class=&quot;math inline&quot;&gt;\(A\hat{x}=f\)&lt;/span&gt;，这个&lt;span class=&quot;math inline&quot;&gt;\(\hat{x}\)&lt;/span&gt;便为近似解了。如果仅仅为了求近似解可以直接在&lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;等式左右两侧同时左乘&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}\)&lt;/span&gt;，即&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}Ax=A^{\mathrm{T}}b\)&lt;/span&gt;。这个和上面先求投影向量再求解是一样的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这篇笔记将会探究在机器学习的线性回归如何求解损失函数。&lt;/p&gt;
&lt;h2 id=&quot;axb无解时求近似解&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;无解时求近似解&lt;/h2&gt;
&lt;p&gt;今天我们需要求一个线性方程组，长成这样&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left \{ \begin{array}{lr} 2 * w_1 + 2 * w_2 + b = 14 \\ 4 * w_1 - 1 * w_2 + b = 5 \\ 4 * w_1 + 0 * w_2 + b = 4 \\ 4 * w_1 - 2 * w_2 + b = 3 \\ 0 * w_1 - 3 * w_2 + b = -20 \end{array} \right. \end{equation} \]&lt;/span&gt;&lt;br/&gt;将(1)式写成矩阵形式，也就是&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left [ \begin{matrix} 2 &amp;amp; 2 &amp;amp; 1 \\ 4 &amp;amp; -1 &amp;amp; 1 \\ 4 &amp;amp; 0 &amp;amp; 1 \\ 4 &amp;amp; -2 &amp;amp; 1 \\ 0 &amp;amp; -3 &amp;amp; 1 \end{matrix} \right] \left [ \begin{matrix} w_1 \\ w_2 \\ b \end{matrix} \right]= \left [ \begin{matrix} 14 \\ 5 \\ 4 \\ 3 \\ -20 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;凭我多年的做题经验，这个方程是无解的。太好了，之前学的东西总算可以用上场了(参考笔记&lt;code&gt;如何寻找一个投影矩阵&lt;/code&gt;等式13）。我们将等式两边同时左乘矩阵的转置，我们会惊讶的发现这个新的等式(3)有解了:&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left [ \begin{matrix} 2 &amp;amp; 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; 0 \\ 2 &amp;amp; -1 &amp;amp; 0 &amp;amp; -2 &amp;amp; -3\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] \left [ \begin{matrix} 2 &amp;amp; 2 &amp;amp; 1 \\ 4 &amp;amp; -1 &amp;amp; 1 \\ 4 &amp;amp; 0 &amp;amp; 1 \\ 4 &amp;amp; -2 &amp;amp; 1 \\ 0 &amp;amp; -3 &amp;amp; 1 \end{matrix} \right] \left [ \begin{matrix} \hat{w_1} \\ \hat{w_2} \\ \hat{b} \end{matrix} \right]= \left [ \begin{matrix} 2 &amp;amp; 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; 0 \\ 2 &amp;amp; -1 &amp;amp; 0 &amp;amp; -2 &amp;amp; -3\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] \left [ \begin{matrix} 14 \\ 5 \\ 4 \\ 3 \\ -20 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;将(3)式化解得到:&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \left [ \begin{matrix} 52 &amp;amp; -8 &amp;amp; 14 \\ -8 &amp;amp; 18 &amp;amp; -4 \\ 14 &amp;amp; -4 &amp;amp; 5 \end{matrix} \right] \left [ \begin{matrix} \hat{w_1} \\ \hat{w_2} \\ \hat{b} \end{matrix} \right]= \left [ \begin{matrix} 72 \\ 73 \\ 6 \end{matrix} \right] \end{equation} \]&lt;/span&gt;&lt;br/&gt;由等式(4)解出的&lt;span class=&quot;math inline&quot;&gt;\(\hat{w_1},\hat{w_2},\hat{b}\)&lt;/span&gt;就是等式(1)的近似解，我们也认为它是最优解。&lt;/p&gt;
&lt;h2 id=&quot;线性回归&quot;&gt;线性回归&lt;/h2&gt;
&lt;p&gt;拿预测房价举例，谈谈什么是最小二乘法。比如我们假设房价(price)与2个特征即面积(x1)、楼层(x2)有关。那么我们的目标是找到一张三维空间中的平面去拟合一些数据(假设这些数据都经过归一化处理)。先来看看平面怎么定义的？&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} price = w_1 * x_1 + w_2 * x_2 + b \end{equation} \]&lt;/span&gt;&lt;br/&gt;我们希望所有的数据点都在这个平面上，那样可以通过解线性方程组来算出这个平面的参数&lt;span class=&quot;math inline&quot;&gt;\(w_1,w_2,b\)&lt;/span&gt;，这正是线性代数中学到过的。&lt;/p&gt;
&lt;p&gt;好的，我们现在有5笔数据(2, 2, 14)、(4, -1, 5)、(4, 0, 4)、(4 -2 3)、(0 -3 -20)，将它们代入(5)式得到我们的方程组吧，解出来&lt;span class=&quot;math inline&quot;&gt;\(w_1,w_2,b\)&lt;/span&gt;这样一个线性模型就ok了。&lt;br/&gt;可是这一步我们之前已经做过了，将这些数据代入方程组是无解的，即给出的这些数据根本不在一个平面上。那么，现在我们放松条件，既然找不到一个平面能令所有的点都在它上面，我们找一个最优的平面总可以吧。&lt;/p&gt;
&lt;h4 id=&quot;最优平面如何定义&quot;&gt;最优平面如何定义&lt;/h4&gt;
&lt;p&gt;假设我们已经有n组数据，每一组数据都是&lt;span class=&quot;math inline&quot;&gt;\((x_1,x_2,y)\)&lt;/span&gt;的集合。将一组数据&lt;span class=&quot;math inline&quot;&gt;\((x_1, x_2)\)&lt;/span&gt;代入(1)中求出price，我们认为每一组数据产生的误差为&lt;span class=&quot;math inline&quot;&gt;\((price-y)^2\)&lt;/span&gt;，将每一组数据产生的误差累加起来就是(6)式。即:&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w_1, w_2, b) = \sum_{i=1}^{n}(price_i-y_i)^2 \end{equation} \]&lt;/span&gt;&lt;br/&gt;使得&lt;span class=&quot;math inline&quot;&gt;\(J(w_1, w_2, b)\)&lt;/span&gt;最小的那组参数&lt;span class=&quot;math inline&quot;&gt;\((w_1,w_2,b)\)&lt;/span&gt;，可以认为是最优平面的参数。&lt;/p&gt;
&lt;p&gt;下面会给出一个动图来展示最优平面是怎么样的一个情况（画了好久才画出满意的效果，画图的代码也会在末尾给出）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201903/1531067-20190311230320382-140008535.gif&quot; height=&quot;80%&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到图中，红色的点是我们实际的数据，这个蓝色的透明平面是我画出来的认为能拟合这些数据的最好平面。&lt;/p&gt;
&lt;h4 id=&quot;如何能找到最优平面&quot;&gt;如何能找到最优平面？&lt;/h4&gt;
&lt;p&gt;这仍然是一个数学问题，我们认为使得&lt;span class=&quot;math inline&quot;&gt;\(J(w_1, w_2, b)\)&lt;/span&gt;最小的那组参数&lt;span class=&quot;math inline&quot;&gt;\((w_1,w_2,b)\)&lt;/span&gt;，就是最终要寻找的最优平面的参数。&lt;/p&gt;
&lt;p&gt;这样的话，我们记&lt;span class=&quot;math inline&quot;&gt;\(J(w_1, w_2, b)\)&lt;/span&gt;为一个函数，求一个多元函数的最值我们在微积分中学到过就是求&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial J}{\partial w_1}, \frac{\partial J}{\partial w_2}, \frac{\partial J}{\partial b}\)&lt;/span&gt;，并且令它们都等于0，就能求出最终的解了。&lt;/p&gt;
&lt;p&gt;这里已经涉及到矩阵微积分的内容，我试着写几步：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w_1, w_2, b) = (price-y)^{\mathrm{T}}(price-y) \end{equation} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(price\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;都是向量，再将&lt;span class=&quot;math inline&quot;&gt;\(price\)&lt;/span&gt;用参数&lt;span class=&quot;math inline&quot;&gt;\(w_1,w_2,b\)&lt;/span&gt;表示：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w) = (Xw-y)^{\mathrm{T}}(Xw-y) \end{equation} \]&lt;/span&gt;&lt;br/&gt;(8)式中，&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的每一行是1组数据，它是一个nx3的矩阵；&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是个向量&lt;span class=&quot;math display&quot;&gt;\[ X=\left[ \begin{matrix} 第一笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ 第二笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ . \\ . \\ . \\ 第n笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ \end{matrix} \right] \ \ \ \ \ \ \ \ w =\left[ \begin{matrix} w_1\\ w_2\\ b \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;继续将(8)式化简&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w) = (w^{\mathrm{T}}X^{\mathrm{T}}-y^{\mathrm{T}})(Xw-y) \end{equation} \]&lt;/span&gt;&lt;br/&gt;接着去括号&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w) = w^{\mathrm{T}}X^{\mathrm{T}}Xw-y^{\mathrm{T}}Xw-w^{\mathrm{T}}X^{\mathrm{T}}y+y^{\mathrm{T}}y \end{equation} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(y^{\mathrm{T}}Xw\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(w^{\mathrm{T}}X^{\mathrm{T}}y\)&lt;/span&gt;是相等的，都是一个数，所以最终可以写为&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(w) = w^{\mathrm{T}}X^{\mathrm{T}}Xw-2w^{\mathrm{T}}X^{\mathrm{T}}y+y^{\mathrm{T}}y \end{equation} \]&lt;/span&gt;&lt;br/&gt;下面就要进行矩阵微积分了，讲实话我不会。但是我学会两个trick能求出最终的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第一个trick来自台大的林轩田老师，我记得他很轻松地说可以把上面这个等式变换成我们会的一元二次等式，我当时带着满腹的怀疑按照他说的做了，不过真的得到了结果(惊吓！可能这就是数学的魅力)。我们将(11)式变为&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} J(x) = w^{\mathrm{T}}Aw - 2w^{\mathrm{T}}b + c \\ subject \ to \ A = X^{\mathrm{T}}X \\ \ \ \ \ \ \ \ \ \ \ \ \ b=X^{\mathrm{T}}y\\ \ \ \ \ \ \ \ \ \ \ \ \ c=y^{\mathrm{T}}y \end{equation} \]&lt;/span&gt;&lt;br/&gt;当然，这不是严格意义上的转换，但是真的能让我们像解熟悉的一元二次方程一样求出解。对(12)求导令其为0，再将原来的值代入回去能得到&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} 2X^{\mathrm{T}}Xw - 2X^{\mathrm{T}}y = 0 \end{equation} \]&lt;/span&gt;&lt;br/&gt;最终&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} w = (X^{\mathrm{T}}X)^{-1}X^{\mathrm{T}}y \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二种求解的办法就是记住矩阵微积分的公式：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(AX\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A^{\mathrm{T}}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(X^{\mathrm{T}}A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(X^{\mathrm{T}}X\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(2X\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(X^{\mathrm{T}}AX\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(AX+A^{\mathrm{T}}X\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;等等，(14)式好熟悉。这不就是求解线性方程组&lt;span class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;这个方程组无解时的最优近似解么。所以，机器学习的线性回归其实就是最小二乘中的拟合问题。一开始就将这个问题看为求解线性方程组问题的话：&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} 第一笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ 第二笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ . \\ . \\ . \\ 第n笔数据的 \ x1 &amp;amp; x2 &amp;amp; 1 \\ \end{matrix} \right] \left[ \begin{matrix} w_1\\ w_2\\ b \end{matrix} \right]=\left[ \begin{matrix} 第一笔数据的 \ price \\ 第二笔数据的 \ price \\ . \\ . \\ . \\ 第n笔数据的 \ price \\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;不就是求这个方程组有没有解么？如果没有解，我们就求近似解。这个近似解的求解方法就是上一篇笔记中一直强调的部分，在等式左右两边左乘矩阵的转置，我们马上能得到近似解。&lt;/p&gt;
&lt;h2 id=&quot;画图代码&quot;&gt;画图代码&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm

x1 = np.linspace(-5, 5, 5)
x2 = x1
x1, x2 = np.meshgrid(x1, x2)
price = x1 * 3 + x2 * 4 - 5
np.random.seed(325)
data_x = np.random.randint(-5, 5, 5)
data_y = np.random.randint(-5, 5, 5)
data_z = data_x * 3 + data_y * 4 - 5
bias = np.array([5, 2, -3, 4, -3])
data_z = data_z + bias
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_wireframe(x1, x2, price, rstride=10, cstride=10)
for i in range(len(data_x)):
    ax.scatter(data_x[i], data_y[i], data_z[i], color='r')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.set_zlabel('price')
ax.set_xticks([-5, 0, 5])
ax.set_yticks([-5, 0,10])
ax.set_zticks([ -40, 0, 40])
plt.show()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:05:00 +0000</pubDate>
<dc:creator>shayue111</dc:creator>
<og:description>引言 上一篇笔记中已经记录了，如何对一个无解的线性方程组$Ax=b$求近似解。在这里，我们先来回顾两个知识点： 1. 如何判断一个线性方程组无解：如果拿上面那个方程组$Ax=b$举例，那就是向量$b$</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shayue/p/10513898.html</dc:identifier>
</item>
<item>
<title>MySQL Binlog 解析工具 Maxwell 详解 - whirlys</title>
<link>http://www.cnblogs.com/whirly/p/10513868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whirly/p/10513868.html</guid>
<description>&lt;h3 id=&quot;maxwell-简介&quot;&gt;maxwell 简介&lt;/h3&gt;
&lt;p&gt;Maxwell是一个能实时读取MySQL二进制日志binlog，并生成 JSON 格式的消息，作为生产者发送给 Kafka，Kinesis、RabbitMQ、Redis、Google Cloud Pub/Sub、文件或其它平台的应用程序。它的常见应用场景有ETL、维护缓存、收集表级别的dml指标、增量到搜索引擎、数据分区迁移、切库binlog回滚方案等。官网(http://maxwells-daemon.io)、GitHub(https://github.com/zendesk/maxwell)&lt;/p&gt;
&lt;p&gt;Maxwell主要提供了下列功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 &lt;code&gt;SELECT * FROM table&lt;/code&gt; 的方式进行全量数据初始化&lt;/li&gt;
&lt;li&gt;支持在主库发生failover后，自动恢复binlog位置(GTID)&lt;/li&gt;
&lt;li&gt;可以对数据进行分区，解决数据倾斜问题，发送到kafka的数据支持database、table、column等级别的数据分区&lt;/li&gt;
&lt;li&gt;工作方式是伪装为Slave，接收binlog events，然后根据schemas信息拼装，可以接受ddl、xid、row等各种event&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了Maxwell外，目前常用的MySQL Binlog解析工具主要有阿里的canal、mysql_streamer，三个工具对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190310_163023.png&quot; alt=&quot;canal、maxwell、mysql_streamer对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;canal 由Java开发，分为服务端和客户端，拥有众多的衍生应用，性能稳定，功能强大；canal 需要自己编写客户端来消费canal解析到的数据。&lt;/p&gt;
&lt;p&gt;maxwell相对于canal的优势是使用简单，它直接将数据变更输出为json字符串，不需要再编写客户端。&lt;/p&gt;
&lt;h4 id=&quot;快速开始&quot;&gt;快速开始&lt;/h4&gt;
&lt;p&gt;首先MySQL需要先启用binlog，关于什么是MySQL binlog，可以参考文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483875&amp;amp;idx=1&amp;amp;sn=2cdc232fa3036da52a826964996506a8&amp;amp;chksm=e9c2edeedeb564f891b34ef1e47418bbe6b8cb6dcb7f48b5fa73b15cf1d63172df1a173c75d0&amp;amp;scene=0&amp;amp;xtrack=1&amp;amp;key=e3977f8a79490c6345befb88d0bbf74cbdc6b508a52e61ea076c830a5b64c552def6c6ad848d4bcc7a1d21e53e30eb5c1ead33acdb97df779d0e6fa8a0fbe4bda32c04077ea0d3511bc9f9490ad0b46c&amp;amp;ascene=1&amp;amp;uin=MjI4MTc0ODEwOQ%3D%3D&amp;amp;devicetype=Windows+7&amp;amp;version=62060719&amp;amp;lang=zh_CN&amp;amp;pass_ticket=h8jyrQ71hQc872LxydZS%2F3aU1JXFbp4raQ1KvY908BcKBeSBtXFgBY9IS9ZaLEDi&quot;&gt;MySQL Binlog 介绍&lt;/a&gt;》&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ vi my.cnf

[mysqld]
server_id=1
log-bin=master
binlog_format=row&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建Maxwell用户，并赋予 maxwell 库的一些权限&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE USER 'maxwell'@'%' IDENTIFIED BY '123456';
GRANT ALL ON maxwell.* TO 'maxwell'@'%';
GRANT SELECT, REPLICATION CLIENT, REPLICATION SLAVE on *.* to 'maxwell'@'%'; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 maxwell 之前需要先启动 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz
tar -xzf kafka_2.11-2.1.0.tgz
cd kafka_2.11-2.1.0
# 启动Zookeeper
bin/zookeeper-server-start.sh config/zookeeper.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单机启动 kafka 之前，需要修改一下配置文件，打开配置文件 &lt;code&gt;vi config/server.properties&lt;/code&gt;，在文件最后加入 &lt;code&gt;advertised.host.name&lt;/code&gt; 的配置，值为 kafka 所在机器的IP&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;advertised.host.name=10.100.97.246&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不然后面通过 docker 启动 maxwell 将会报异常（其中的 hadoop2 是我的主机名）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;17:45:21,446 DEBUG NetworkClient - [Producer clientId=producer-1] Error connecting to node hadoop2:9092 (id: 0 rack: null)
java.io.IOException: Can't resolve address: hadoop2:9092
        at org.apache.kafka.common.network.Selector.connect(Selector.java:217) ~[kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:793) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.NetworkClient.ready(NetworkClient.java:230) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.sendProducerData(Sender.java:263) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:238) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:176) [kafka-clients-1.0.0.jar:?]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
Caused by: java.nio.channels.UnresolvedAddressException
        at sun.nio.ch.Net.checkAddress(Net.java:101) ~[?:1.8.0_181]
        at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:622) ~[?:1.8.0_181]
        at org.apache.kafka.common.network.Selector.connect(Selector.java:214) ~[kafka-clients-1.0.0.jar:?]
        ... 6 more&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着可以启动 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-server-start.sh config/server.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建一个 topic
bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test

# 列出所有 topic
bin/kafka-topics.sh --list --zookeeper localhost:2181

# 启动一个生产者，然后随意发送一些消息
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test
This is a message
This is another message

# 在另一个终端启动一下消费者，观察所消费的消息
bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
This is a message
This is another message&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 docker 快速安装并使用 Maxwell （当然之前需要自行安装 docker）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 拉取镜像 
docker pull zendesk/maxwell

# 启动maxwell，并将解析出的binlog输出到控制台
docker run -ti --rm zendesk/maxwell bin/maxwell --user='maxwell' --password='123456' --host='10.100.97.246' --producer=stdout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试Maxwell，首先创建一张简单的表，然后增改删数据&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `test` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 
insert into test values(1,22,&quot;小旋锋&quot;);
update test set name='whirly' where id=1;
delete from test where id=1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察docker控制台的输出，从输出的日志中可以看出Maxwell解析出的binlog的JSON字符串的格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;insert&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:832,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;小旋锋&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;update&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:833,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;whirly&quot;},&quot;old&quot;:{&quot;name&quot;:&quot;小旋锋&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;delete&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:834,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;whirly&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出到 Kafka，关闭 docker，重新设置启动参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm zendesk/maxwell bin/maxwell --user='maxwell' \
    --password='123456' --host='10.100.97.246' --producer=kafka \
    --kafka.bootstrap.servers='10.100.97.246:9092' --kafka_topic=maxwell --log_level=debug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动一个消费者来消费 maxwell topic的消息，观察其输出；再一次执行增改删数据的SQL，仍然可以得到相同的输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出json字符串的格式&quot;&gt;输出JSON字符串的格式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;data 最新的数据，修改后的数据&lt;/li&gt;
&lt;li&gt;old 旧数据，修改前的数据&lt;/li&gt;
&lt;li&gt;type 操作类型，有insert, update, delete, database-create, database-alter, database-drop, table-create, table-alter, table-drop，bootstrap-insert，int(未知类型)&lt;/li&gt;
&lt;li&gt;xid 事务id&lt;/li&gt;
&lt;li&gt;commit 同一个xid代表同一个事务，事务的最后一条语句会有commit，可以利用这个重现事务&lt;/li&gt;
&lt;li&gt;server_id&lt;/li&gt;
&lt;li&gt;thread_id&lt;/li&gt;
&lt;li&gt;运行程序时添加参数--output_ddl，可以捕捉到ddl语句&lt;/li&gt;
&lt;li&gt;datetime列会输出为&quot;YYYY-MM-DD hh:mm:ss&quot;，如果遇到&quot;0000-00-00 00:00:00&quot;会原样输出&lt;/li&gt;
&lt;li&gt;maxwell支持多种编码，但仅输出utf8编码&lt;/li&gt;
&lt;li&gt;maxwell的TIMESTAMP总是作为UTC处理，如果要调整为自己的时区，需要在后端逻辑上进行处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与输出格式相关的配置如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_binlog_position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 binlog position&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_gtid_position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 gtid position&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_commit_info&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 commit and xid&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_xoffset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 virtual tx-row offset&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_nulls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含值为NULL的字段&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;output_server_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 server_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;output_thread_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 thread_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;output_schema_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 schema_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_row_query&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 INSERT/UPDATE/DELETE 语句. Mysql需要开启 &lt;code&gt;binlog_rows_query_log_events&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;output_ddl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 DDL (table-alter, table-create, etc) events&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_null_zerodates&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否将 '0000-00-00' 转换为 null?&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;进阶使用&quot;&gt;进阶使用&lt;/h3&gt;
&lt;h4 id=&quot;基本的配置&quot;&gt;基本的配置&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;config&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;配置文件 &lt;code&gt;config.properties&lt;/code&gt; 的路径&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;log_level&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[debug | info | warn | error]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日志级别&lt;/td&gt;
&lt;td&gt;info&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;指定Maxwell实例作为守护进程到后台运行&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;env_config_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;匹配该前缀的环境变量将被视为配置值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以把Maxwell的启动参数写到一个配置文件 &lt;code&gt;config.properties&lt;/code&gt; 中，然后通过 config 选项指定，&lt;code&gt;bin/maxwell --config config.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user=maxwell
password=123456
host=10.100.97.246
producer=kafka
kafka.bootstrap.servers=10.100.97.246:9092
kafka_topic=maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mysql-配置选项&quot;&gt;mysql 配置选项&lt;/h4&gt;
&lt;p&gt;Maxwell 根据用途将 MySQL 划分为3种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;host&lt;/code&gt;：主机，建maxwell库表，存储捕获到的schema等信息
&lt;ul&gt;&lt;li&gt;主要有六张表，bootstrap用于数据初始化，schemas记录所有的binlog文件信息，databases记录了所有的数据库信息，tables记录了所有的表信息，columns记录了所有的字段信息，positions记录了读取binlog的位移信息，heartbeats记录了心跳信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replication_host&lt;/code&gt;：复制主机，Event监听，读取该主机binlog
&lt;ul&gt;&lt;li&gt;将&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;replication_host&lt;/code&gt;分开，可以避免 &lt;code&gt;replication_user&lt;/code&gt; 往生产库里写数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema_host&lt;/code&gt;：schema主机，捕获表结构schema的主机
&lt;ul&gt;&lt;li&gt;binlog里面没有字段信息，所以maxwell需要从数据库查出schema，存起来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema_host&lt;/code&gt;一般用不到，但在&lt;code&gt;binlog-proxy&lt;/code&gt;场景下就很实用。比如要将已经离线的binlog通过maxwell生成json流，于是自建一个mysql server里面没有结构，只用于发送binlog，此时表机构就可以制动从 schema_host 获取。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常，这三个主机都是同一个，&lt;code&gt;schema_host&lt;/code&gt; 只在有 &lt;code&gt;replication_host&lt;/code&gt; 的时候使用。&lt;/p&gt;
&lt;p&gt;与MySQL相关的有下列配置&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 地址&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 用户名&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 密码&lt;/td&gt;
&lt;td&gt;(no password)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;mysql 端口 3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;jdbc_options&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql jdbc connection options&lt;/td&gt;
&lt;td&gt;DEFAULT_JDBC_OPTS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for mysql cx&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_database&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;Maxwell用于维护的schema和position将使用的数据库&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;client_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;用于标识Maxwell实例的唯一字符串&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replica_server_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;LONG&lt;/td&gt;
&lt;td&gt;用于标识Maxwell实例的唯一数字&lt;/td&gt;
&lt;td&gt;6379 (see notes)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;master_recovery&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;enable experimental master recovery code&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;gtid_mode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否开启基于GTID的复制&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;recapture_schema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;重新捕获最新的表结构(schema)，不可在 config.properties中配置&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;server to replicate from. See split server roles&lt;/td&gt;
&lt;td&gt;schema-store host&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;password on replication server&lt;/td&gt;
&lt;td&gt;(none)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;port on replication server&lt;/td&gt;
&lt;td&gt;3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;user on replication server&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for replication cx cx&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;server to capture schema from. See split server roles&lt;/td&gt;
&lt;td&gt;schema-store host&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;password on schema-capture server&lt;/td&gt;
&lt;td&gt;(none)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;port on schema-capture server&lt;/td&gt;
&lt;td&gt;3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;user on schema-capture server&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for schema-capture server&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;生产者的配置&quot;&gt;生产者的配置&lt;/h4&gt;
&lt;p&gt;仅介绍kafka，其他的生产者的配置详见官方文档。&lt;/p&gt;
&lt;p&gt;kafka是maxwell支持最完善的一个生产者，并且内置了多个版本的kafka客户端(0.8.2.2, 0.9.0.1, 0.10.0.1, 0.10.2.1 or 0.11.0.1, 1.0.0.)，默认 kafka_version=1.0.0（当前Maxwell版本1.20.0）&lt;/p&gt;
&lt;p&gt;Maxwell 会将消息投递到Kafka的Topic中，该Topic由 &lt;code&gt;kafka_topic&lt;/code&gt; 选项指定，默认值为 &lt;code&gt;maxwell&lt;/code&gt;，除了指定为静态的Topic，还可以指定为动态的，譬如 &lt;code&gt;namespace_%{database}_%{table}&lt;/code&gt;，&lt;code&gt;%{database}&lt;/code&gt; 和 &lt;code&gt;%{table}&lt;/code&gt; 将被具体的消息的 database 和 table 替换。&lt;/p&gt;
&lt;p&gt;Maxwell 读取配置时，如果配置项是以 &lt;code&gt;kafka.&lt;/code&gt; 开头，那么该配置将设置到 Kafka Producer 客户端的连接参数中去，譬如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka.acks = 1
kafka.compression.type = snappy
kafka.retries=5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是Maxwell通用生产者和Kafka生产者的配置参数&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;producer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PRODUCER_TYPE&lt;/td&gt;
&lt;td&gt;生产者类型&lt;/td&gt;
&lt;td&gt;stdout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;custom_producer.factory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CLASS_NAME&lt;/td&gt;
&lt;td&gt;自定义消费者的工厂类&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;producer_ack_timeout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PRODUCER_ACK_TIMEOUT&lt;/td&gt;
&lt;td&gt;异步消费认为消息丢失的超时时间（毫秒ms）&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_by&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PARTITION_BY&lt;/td&gt;
&lt;td&gt;输入到kafka/kinesis的分区函数&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_columns&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;若按列分区，以逗号分隔的列名称&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_by_fallback&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PARTITION_BY_FALLBACK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;producer_partition_by=column&lt;/code&gt;时需要，当列不存在是使用&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;ignore_producer_error&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;为false时，在kafka/kinesis发生错误时退出程序；为true时，仅记录日志 See also &lt;code&gt;dead_letter_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;kafka.bootstrap.servers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;kafka 集群列表，&lt;code&gt;HOST:PORT[,HOST:PORT]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;kafka topic&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;dead_letter_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;详见官方文档&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;KAFKA_VERSION&lt;/td&gt;
&lt;td&gt;指定maxwell的 kafka 生产者客户端版本，不可在config.properties中配置&lt;/td&gt;
&lt;td&gt;0.11.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_partition_hash&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[default | murmur3]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;选择kafka分区时使用的hash方法&lt;/td&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_key_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[array | hash]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;how maxwell outputs kafka keys, either a hash or an array of hashes&lt;/td&gt;
&lt;td&gt;hash&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;ddl_kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;output_ddl&lt;/code&gt;为true时, 所有DDL的消息都将投递到该topic&lt;/td&gt;
&lt;td&gt;&lt;code&gt;kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;过滤器配置&quot;&gt;过滤器配置&lt;/h4&gt;
&lt;p&gt;Maxwell 可以通过 &lt;code&gt;--filter&lt;/code&gt; 配置项来指定过滤规则，通过 &lt;code&gt;exclude&lt;/code&gt; 排除，通过 &lt;code&gt;include&lt;/code&gt; 包含，值可以为具体的数据库、数据表、数据列，甚至用 Javascript 来定义复杂的过滤规则；可以用正则表达式描述，有几个来自官网的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 仅匹配foodb数据库的tbl表和所有table_数字的表
--filter='exclude: foodb.*, include: foodb.tbl, include: foodb./table_\d+/'
# 排除所有库所有表，仅匹配db1数据库
--filter = 'exclude: *.*, include: db1.*'
# 排除含db.tbl.col列值为reject的所有更新
--filter = 'exclude: db.tbl.col = reject'
# 排除任何包含col_a列的更新
--filter = 'exclude: *.*.col_a = *'
# blacklist 黑名单，完全排除bad_db数据库，若要恢复，必须删除maxwell库
--filter = 'blacklist: bad_db.*' &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据初始化&quot;&gt;数据初始化&lt;/h4&gt;
&lt;p&gt;Maxwell 启动后将从maxwell库中获取上一次停止时position，从该断点处开始读取binlog。如果binlog已经清除了，那么怎样可以通过maxwell把整张表都复制出来呢？也就是数据初始化该怎么做？&lt;/p&gt;
&lt;p&gt;对整张表进行操作，人为地产生binlog？譬如找一个不影响业务的字段譬如update_time，然后加一秒，再减一秒？&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;update test set update_time = DATE_ADD(update_time,intever 1 second);
update test set update_time = DATE_ADD(update_time,intever -1 second);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样明显存在几个大问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不存在一个不重要的字段怎么办？每个字段都很重要，不能随便地修改！&lt;/li&gt;
&lt;li&gt;如果整张表很大，修改的过程耗时很长，影响了业务！&lt;/li&gt;
&lt;li&gt;将产生大量非业务的binlog！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对数据初始化的问题，Maxwell 提供了一个命令工具 &lt;code&gt;maxwell-bootstrap&lt;/code&gt; 帮助我们完成数据初始化，&lt;code&gt;maxwell-bootstrap&lt;/code&gt; 是基于 &lt;code&gt;SELECT * FROM table&lt;/code&gt; 的方式进行全量数据初始化，不会产生多余的binlog！&lt;/p&gt;
&lt;p&gt;这个工具有下面这些参数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;--log_level LOG_LEVEL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日志级别（DEBUG, INFO, WARN or ERROR）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--user USER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 用户名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--password PASSWORD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 密码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--host HOST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--port PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;--database DATABASE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要bootstrap的表所在的数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--table TABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要引导的表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--where WHERE_CLAUSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置过滤条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;--client_id CLIENT_ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定执行引导操作的Maxwell实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实验一番，下面将引导 &lt;code&gt;test&lt;/code&gt; 数据库中 &lt;code&gt;test&lt;/code&gt; 表，首先是准备几条测试用的数据&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO `test` VALUES (1, 1, '1');
INSERT INTO `test` VALUES (2, 2, '2');
INSERT INTO `test` VALUES (3, 3, '3');
INSERT INTO `test` VALUES (4, 4, '4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 &lt;code&gt;reset master;&lt;/code&gt; 清空binlog，删除 maxwell 库中的表。接着使用快速开始中的命令，启动Kafka、Maxwell和Kafka消费者，然后启动 &lt;code&gt;maxwell-bootstrap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm zendesk/maxwell bin/maxwell-bootstrap --user maxwell  \
    --password 123456 --host 10.100.97.246  --database test --table test --client_id maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;--bootstrapper=sync&lt;/code&gt; 时，在处理bootstrap时，会阻塞正常的binlog解析；&lt;code&gt;--bootstrapper=async&lt;/code&gt; 时，不会阻塞。&lt;/p&gt;
&lt;p&gt;也可以执行下面的SQL，在 &lt;code&gt;maxwell.bootstrap&lt;/code&gt; 表中插入记录，手动触发&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;insert into maxwell.bootstrap (database_name, table_name) values ('test', 'test');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以在 kafka 消费者端看见引导过来的数据了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;database&quot;:&quot;maxwell&quot;,&quot;table&quot;:&quot;bootstrap&quot;,&quot;type&quot;:&quot;insert&quot;,&quot;ts&quot;:1552199115,&quot;xid&quot;:36738,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:3,&quot;database_name&quot;:&quot;test&quot;,&quot;table_name&quot;:&quot;test&quot;,&quot;where_clause&quot;:null,&quot;is_complete&quot;:0,&quot;inserted_rows&quot;:0,&quot;total_rows&quot;:0,&quot;created_at&quot;:null,&quot;started_at&quot;:null,&quot;completed_at&quot;:null,&quot;binlog_file&quot;:null,&quot;binlog_position&quot;:0,&quot;client_id&quot;:&quot;maxwell&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-start&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:1,&quot;name&quot;:&quot;1&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:2,&quot;age&quot;:2,&quot;name&quot;:&quot;2&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:3,&quot;age&quot;:3,&quot;name&quot;:&quot;3&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:4,&quot;age&quot;:4,&quot;name&quot;:&quot;4&quot;}}
{&quot;database&quot;:&quot;maxwell&quot;,&quot;table&quot;:&quot;bootstrap&quot;,&quot;type&quot;:&quot;update&quot;,&quot;ts&quot;:1552199115,&quot;xid&quot;:36756,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:3,&quot;database_name&quot;:&quot;test&quot;,&quot;table_name&quot;:&quot;test&quot;,&quot;where_clause&quot;:null,&quot;is_complete&quot;:1,&quot;inserted_rows&quot;:4,&quot;total_rows&quot;:0,&quot;created_at&quot;:null,&quot;started_at&quot;:&quot;2019-03-10 14:25:15&quot;,&quot;completed_at&quot;:&quot;2019-03-10 14:25:15&quot;,&quot;binlog_file&quot;:&quot;mysql-bin.000001&quot;,&quot;binlog_position&quot;:64446,&quot;client_id&quot;:&quot;maxwell&quot;},&quot;old&quot;:{&quot;is_complete&quot;:0,&quot;inserted_rows&quot;:1,&quot;completed_at&quot;:null}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-complete&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间的4条便是 &lt;code&gt;test.test&lt;/code&gt; 的binlog数据了，注意这里的 type 是 &lt;code&gt;bootstrap-insert&lt;/code&gt;，而不是 &lt;code&gt;insert&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后再一次查看binlog，&lt;code&gt;show binlog events;&lt;/code&gt;，会发现只有与 &lt;code&gt;maxwell&lt;/code&gt; 相关的binlog，并没有 &lt;code&gt;test.test&lt;/code&gt; 相关的binlog，所以 &lt;code&gt;maxwell-bootstrap&lt;/code&gt; 命令并不会产生多余的 binlog，当数据表的数量很大时，这个好处会更加明显&lt;/p&gt;
&lt;p&gt;Bootstrap 的过程是 &lt;code&gt;bootstrap-start -&amp;gt; bootstrap-insert -&amp;gt; bootstrap-complete&lt;/code&gt;，其中，start和complete的data字段为空，不携带数据。&lt;/p&gt;
&lt;p&gt;在进行bootstrap过程中，如果maxwell崩溃，重启时，bootstrap会完全重新开始，不管之前进行到多少，若不希望这样，可以到数据库中设置 &lt;code&gt;is_complete&lt;/code&gt; 字段值为1(表示完成)，或者删除该行&lt;/p&gt;
&lt;h4 id=&quot;maxwell监控&quot;&gt;Maxwell监控&lt;/h4&gt;
&lt;p&gt;Maxwell 提供了 &lt;code&gt;base logging mechanism, JMX, HTTP or by push to Datadog&lt;/code&gt; 这四种监控方式，与监控相关的配置项有下列这些：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;指标的前缀&lt;/td&gt;
&lt;td&gt;MaxwellMetrics&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[slf4j | jmx | http | datadog]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;发布指标的方式&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_jvm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否收集JVM信息&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_slf4j_interval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SECONDS&lt;/td&gt;
&lt;td&gt;将指标记录到日志的频率，&lt;code&gt;metrics_type&lt;/code&gt;须配置为slf4j&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;为http时，发布指标绑定的端口&lt;/td&gt;
&lt;td&gt;8080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;http_path_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;http的路径前缀&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_bind_address&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;http发布指标绑定的地址&lt;/td&gt;
&lt;td&gt;all addresses&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_diagnostic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;http是否开启diagnostic后缀&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_diagnostic_timeout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;MILLISECONDS&lt;/td&gt;
&lt;td&gt;http diagnostic 响应超时时间&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[udp | http]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;为datadog时发布指标的方式&lt;/td&gt;
&lt;td&gt;udp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;提供给 datadog 的标签，如 tag1:value1,tag2:value2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_interval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;推指标到datadog的频率，单位秒&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_apikey&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当 &lt;code&gt;metrics_datadog_type=http&lt;/code&gt; 时datadog用的api key&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;metrics_datadog_type=udp&lt;/code&gt;时推指标的目标地址&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;metrics_datadog_type=udp&lt;/code&gt; 时推指标的端口&lt;/td&gt;
&lt;td&gt;8125&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体可以得到哪些监控指标呢？有如下，注意所有指标都预先配置了指标前缀 &lt;code&gt;metrics_prefix&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.succeeded&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;成功发送到kafka的消息数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.failed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;发送失败的消息数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;row.count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;已处理的binlog行数，注意并非所有binlog都发往kafka&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.succeeded.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;消息成功发送到Kafka的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.failed.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;消息发送失败到kafka的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;row.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;行(row)从binlog连接器到达maxwell的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication.lag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gauges&lt;/td&gt;
&lt;td&gt;从数据库事务提交到Maxwell处理该事务之间所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;inflightmessages.count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gauges&lt;/td&gt;
&lt;td&gt;当前正在处理的消息数（等待来自目的地的确认，或在消息之前）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;message.publish.time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;向kafka发送record所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;message.publish.age&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;从数据库产生事件到发送到Kafka之间的时间（毫秒），精确度为+/-500ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication.queue.time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;将一个binlog事件送到处理队列所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上述有些指标为kafka特有的，并不支持所有的生产者。&lt;/p&gt;
&lt;p&gt;实验一番，通过 http 方式获取监控指标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -p 8080:8080 -it --rm zendesk/maxwell bin/maxwell --user='maxwell' \
    --password='123456' --host='10.100.97.246' --producer=kafka \
    --kafka.bootstrap.servers='10.100.97.246:9092' --kafka_topic=maxwell --log_level=debug \
    --metrics_type=http  --metrics_jvm=true --http_port=8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置大部分与前面的相同，不同的有 &lt;code&gt;-p 8080:8080&lt;/code&gt; docker端口映射，以及 &lt;code&gt;--metrics_type=http --metrics_jvm=true --http_port=8080&lt;/code&gt;，配置了通过http方式发布指标，启用收集JVM信息，端口为8080，之后可以通过 &lt;code&gt;http://10.100.97.246:8080/metrics&lt;/code&gt; 便可获取所有的指标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190310_234508.png&quot; alt=&quot;Maxwell监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http 方式有四种后缀，分别对应四种不同的格式&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/metrics&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有指标以JSON格式返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;/prometheus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有指标以Prometheus格式返回（Prometheus是一套开源的监控&amp;amp;报警&amp;amp;时间序列数据库的组合）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/healthcheck&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回Maxwell过去15分钟是否健康&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/ping&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单的测试，返回 &lt;code&gt;pong&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果是通过 JMX 的方式收集Maxwell监控指标，可以 &lt;code&gt;JAVA_OPTS&lt;/code&gt; 环境变量配置JMX访问权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_OPTS=&quot;-Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.port=9010 \
-Dcom.sun.management.jmxremote.local.only=false \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-Djava.rmi.server.hostname=10.100.97.246&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多个maxwell实例&quot;&gt;多个Maxwell实例&lt;/h4&gt;
&lt;p&gt;在不同的配置下，Maxwell可以在同一个主服务器上运行多个实例。如果希望让生产者以不同的配置运行，例如将来自不同组的表(table)的事件投递到不同的Topic中，这将非常有用。Maxwell的每个实例都必须配置一个唯一的client_id，以便区分的binlog位置。&lt;/p&gt;
&lt;h4 id=&quot;gtid-支持&quot;&gt;GTID 支持&lt;/h4&gt;
&lt;p&gt;Maxwell 从1.8.0版本开始支持基于GTID的复制(&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/replication-gtids.html&quot;&gt;GTID-based replication&lt;/a&gt;)，在GTID模式下，Maxwell将在主机更改后透明地选择新的复制位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是GTID Replication？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GTID (Global Transaction ID) 是对于一个已提交事务的编号，并且是一个全局唯一的编号。&lt;/p&gt;
&lt;p&gt;从 MySQL 5.6.5 开始新增了一种基于 GTID 的复制方式。通过 GTID 保证了每个在主库上提交的事务在集群中有一个唯一的ID。这种方式强化了数据库的主备一致性，故障恢复以及容错能力。&lt;/p&gt;
&lt;p&gt;在原来基于二进制日志的复制中，从库需要告知主库要从哪个偏移量进行增量同步，如果指定错误会造成数据的遗漏，从而造成数据的不一致。借助GTID，在发生主备切换的情况下，MySQL的其它从库可以自动在新主库上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制位置发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;h4 id=&quot;timestamp-column&quot;&gt;timestamp column&lt;/h4&gt;
&lt;p&gt;maxwell对时间类型（datetime, timestamp, date）都是&lt;strong&gt;当做字符串处理&lt;/strong&gt;的，这也是为了保证数据一致(比如&lt;code&gt;0000-00-00 00:00:00&lt;/code&gt;这样的时间在timestamp里是非法的，但mysql却认，解析成java或者python类型就是null/None)。&lt;/p&gt;
&lt;p&gt;如果MySQL表上的字段是 timestamp 类型，是有时区的概念，&lt;strong&gt;binlog解析出来的是标准UTC时间&lt;/strong&gt;，但用户看到的是本地时间。比如 &lt;code&gt;f_create_time timestamp&lt;/code&gt; 创建时间是北京时间 &lt;code&gt;2018-01-05 21:01:01&lt;/code&gt;，那么mysql实际存储的是 &lt;code&gt;2018-01-05 13:01:01&lt;/code&gt;，binlog里面也是这个时间字符串。如果不做消费者不做时区转换，会少8个小时。&lt;/p&gt;
&lt;p&gt;与其每个客户端都要考虑这个问题，我觉得更合理的做法是提供时区参数，然后maxwell自动处理时区问题，否则要么客户端先需要知道哪些列是timestamp类型，或者连接上原库缓存上这些类型。&lt;/p&gt;
&lt;h4 id=&quot;binary-column&quot;&gt;binary column&lt;/h4&gt;
&lt;p&gt;maxwell可以处理binary类型的列，如blob、varbinary，它的做法就是对二进制列使用 &lt;code&gt;base64_encode&lt;/code&gt;，当做字符串输出到json。消费者拿到这个列数据后，不能直接拼装，需要 &lt;code&gt;base64_decode&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;表结构不同步&quot;&gt;表结构不同步&lt;/h4&gt;
&lt;p&gt;如果是拿比较老的binlog，放到新的mysql server上去用maxwell拉去，有可能表结构已经发生了变化，比如binlog里面字段比 &lt;code&gt;schema_host&lt;/code&gt; 里面的字段多一个。目前这种情况没有发现异常，比如阿里RDS默认会为 无主键无唯一索引的表，增加一个&lt;code&gt;__##alibaba_rds_rowid##__&lt;/code&gt;，在 &lt;code&gt;show create table&lt;/code&gt; 和 &lt;code&gt;schema&lt;/code&gt; 里面都看不到这个隐藏主键，但binlog里面会有，同步到从库。&lt;/p&gt;
&lt;p&gt;另外我们有通过git去管理结构版本，如果真有这种场景，也可以应对。&lt;/p&gt;
&lt;h4 id=&quot;大事务binlog&quot;&gt;大事务binlog&lt;/h4&gt;
&lt;p&gt;当一个事物产生的binlog量非常大的时候，比如迁移日表数据，maxwell为了控制内存使用，会自动将处理不过来的binlog放到文件系统&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using kafka version: 0.11.0.1
21:16:07,109 WARN  MaxwellMetrics - Metrics will not be exposed: metricsReportingType not configured.
21:16:07,380 INFO  SchemaStoreSchema - Creating maxwell database
21:16:07,540 INFO  Maxwell - Maxwell v?? is booting (RabbitmqProducer), starting at Position[BinlogPosition[mysql-bin.006235:24980714],
lastHeartbeat=0]
21:16:07,649 INFO  AbstractSchemaStore - Maxwell is capturing initial schema
21:16:08,267 INFO  BinlogConnectorReplicator - Setting initial binlog pos to: mysql-bin.006235:24980714
21:16:08,324 INFO  BinaryLogClient - Connected to rm-xxxxxxxxxxx.mysql.rds.aliyuncs.com:3306 at mysql-bin.006235/24980714 (sid:637
9, cid:9182598)
21:16:08,325 INFO  BinlogConnectorLifecycleListener - Binlog connected.
03:15:36,104 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell7935334910787514257events
03:17:14,880 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell3143086481692829045events&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是遇到另外一个问题，overflow随后就出现异常 &lt;code&gt;EventDataDeserializationException: Failed to deserialize data of EventHeaderV4&lt;/code&gt;，当我另起一个maxwell指点之前的binlog postion开始解析，却有没有抛异常。事后的数据也表明并没有数据丢失。&lt;/p&gt;
&lt;p&gt;问题产生的原因还不明，&lt;code&gt;Caused by: java.net.SocketException: Connection reset&lt;/code&gt;，感觉像读取 binlog 流的时候还没读取到完整的event，异常关闭了连接。这个问题比较顽固，github上面类似问题都没有达到明确的解决。（这也从侧面告诉我们，大表数据迁移，也要批量进行，不要一个&lt;code&gt;insert into .. select&lt;/code&gt; 搞定）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;03:18:20,586 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell5229190074667071141events
03:19:31,289 WARN  BinlogConnectorLifecycleListener - Communication failure.
com.github.shyiko.mysql.binlog.event.deserialization.EventDataDeserializationException: Failed to deserialize data of EventHeaderV4{time
stamp=1514920657000, eventType=WRITE_ROWS, serverId=2115082720, headerLength=19, dataLength=8155, nextPosition=520539918, flags=0}
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.deserializeEventData(EventDeserializer.java:216) ~[mys
ql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.nextEvent(EventDeserializer.java:184) ~[mysql-binlog-c
onnector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:890) [mysql-binlog-connector-java-0
.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:559) [mysql-binlog-connector-java-0.13.0.jar:0.13
.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:793) [mysql-binlog-connector-java-0.13.0.jar:0.13.0
]
        at java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]
Caused by: java.net.SocketException: Connection reset
        at java.net.SocketInputStream.read(SocketInputStream.java:210) ~[?:1.8.0_121]
        at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[?:1.8.0_121]
        at com.github.shyiko.mysql.binlog.io.BufferedSocketInputStream.read(BufferedSocketInputStream.java:51) ~[mysql-binlog-connector-
java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.readWithinBlockBoundaries(ByteArrayInputStream.java:202) ~[mysql-binlo
g-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.read(ByteArrayInputStream.java:184) ~[mysql-binlog-connector-java-0.13
.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.readInteger(ByteArrayInputStream.java:46) ~[mysql-binlog-connector-jav
a-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeLong(AbstractRowsEventDataD
eserializer.java:212) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeCell(AbstractRowsEventDataD
eserializer.java:150) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeRow(AbstractRowsEventDataDeserializer.java:132) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserializeRows(WriteRowsEventDataDeserializer.java:64) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserialize(WriteRowsEventDataDeserializer.java:56) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserialize(WriteRowsEventDataDeserializer.java:32) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.deserializeEventData(EventDeserializer.java:210) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        ... 5 more
03:19:31,514 INFO  BinlogConnectorLifecycleListener - Binlog disconnected.
03:19:31,590 WARN  BinlogConnectorReplicator - replicator stopped at position: mysql-bin.006236:520531744 -- restarting
03:19:31,595 INFO  BinaryLogClient - Connected to rm-xxxxxx.mysql.rds.aliyuncs.com:3306 at mysql-bin.006236/520531744 (sid:6379, cid:9220521)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tablemapcache&quot;&gt;tableMapCache&lt;/h4&gt;
&lt;p&gt;前面讲过，如果我只想获取某几个表的binlog变更，需要用 include_tables 来过滤，但如果mysql server上现在删了一个表t1，但我的binlog是从昨天开始读取，被删的那个表t1在maxwell启动的时候是拉取不到表结构的。然后昨天的binlog里面有 t1 的变更，因为找不到表结构给来组装成json，会抛异常。&lt;/p&gt;
&lt;p&gt;手动在 &lt;code&gt;maxwell.tables/columns&lt;/code&gt; 里面插入记录是可行的。但这个问题的根本是，maxwell在binlog过滤的时候，只在处理row_event的时候，而对 tableMapCache 要求binlog里面的所有表都要有。&lt;/p&gt;
&lt;p&gt;自己（seanlook）提交了一个commit，可以在做 tableMapCache 的时候也仅要求缓存 include_dbs/tables 这些表： https://github.com/seanlook/maxwell/commit/2618b70303078bf910a1981b69943cca75ee04fb&lt;/p&gt;
&lt;h4 id=&quot;提高消费性能&quot;&gt;提高消费性能&lt;/h4&gt;
&lt;p&gt;在用rabbitmq时，&lt;code&gt;routing_key&lt;/code&gt; 是 &lt;code&gt;%db%.%table%&lt;/code&gt;，但某些表产生的binlog增量非常大，就会导致各队列消息量很不平均，目前因为还没做到事务xid或者thread_id级别的并发回放，所以最小队列粒度也是表，尽量单独放一个队列，其它数据量小的合在一起。&lt;/p&gt;
&lt;h4 id=&quot;binlog&quot;&gt;binlog&lt;/h4&gt;
&lt;p&gt;Maxwell 在 maxwell 库中维护了 binlog 的位移等信息，由于一些原因譬如 &lt;code&gt;reset master;&lt;/code&gt;，导致 maxwell 库中的记录与实际的binlog对不上，这时将报异常，这是可以手动修正binlog位移或者直接清空/删除 maxwell 库重建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.github.shyiko.mysql.binlog.network.ServerException: Could not find first log file name in binary log index file
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:885)
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:564)
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:796)
        at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.github.shyiko.mysql.binlog.network.ServerException: A slave with the same server_uuid/server_id as this slave has connected to the master; the first event 'mysql-bin.000001' at 760357, the last event read from './mysql-bin.000001' at 1888540, the last byte read from './mysql-bin.000001' at 1888540.
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:885)
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:564)
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:796)
        at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参考文档&quot;&gt;参考文档&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190116_014816.png&quot; alt=&quot;关注_小旋锋_微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 15:00:00 +0000</pubDate>
<dc:creator>whirlys</dc:creator>
<og:description>maxwell 简介 Maxwell是一个能实时读取MySQL二进制日志binlog，并生成 JSON 格式的消息，作为生产者发送给 Kafka，Kinesis、RabbitMQ、Redis、Goog</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whirly/p/10513868.html</dc:identifier>
</item>
<item>
<title>软件工程真的是一门什么用都没有的学科么？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10513847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10513847.html</guid>
<description>&lt;p&gt;软件工程真的是一门什么用都没有的学科么？&lt;/p&gt;
&lt;p&gt;-----读《构建之法》有感&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我很惭愧，构建之法这本书已经出版四五年了，我之前却未曾涉猎，还是在通过组织长沙.net技术社区之后，才因为因缘际遇有幸认识邹欣邹老师之后，才了解和阅读了这本书。这是一本非常不错的软件工程学著作，事实上应该值得IT企业中不同岗位的从业者都来读，而不仅仅只是软件工程师或软件设计师来读。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;回到10多年前，当时我有幸就读于位于湖南湘中小城娄底的人文科技学院，那是湖南众多二本院校中排名较后的普通学府，并且我就读的专业是数学系下的学科，信息与计算科学专业，这是一个数学和计算机的边缘学科。事实上呢，其实当时班上绝大多数人都是调剂生，我是为数不多的一志愿录取吧，因为对计算机感兴趣，高中数学成绩太差，想在进一步学习数学才选了这个专业，当然，实际上入学后我的数学成绩依然很差，这就是后话了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;由于这个专业的教授队伍本身就是数学教授为主，因此开设了许多数学加计算机的课程，那些数学课程令我头大，屡屡挂科，但是那些计算机学科的课程却令我痴迷，并最终让我选择了IT行业，并在这条道路上已经迈过来十个年头，甚至已经决定把他当做终生职业来奋斗。这些课程中，包括了软件工程，当时使用的教材来自于清华大学，那本在我这种阅读爱好者看来浅显易懂的软件工程基础书，在我的同学眼中却仿佛看天书。在书中，作者以比较容易理解的角度简单介绍了软件工程的前因后果和本质，让我觉得如获至宝，经常手不释卷，一直到大学毕业后三年，我都保留了这本书，并时常翻阅。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不知不觉从业十年，再回过头来看这门学科，我觉得我有了不同的体会。软件工程究竟是什么？应该说时至今日，许多资深从业者都不能理解，这也证明为什么有的院校的软件工程课，最终应学生的要求改成了学习JAVA视频教学的原因吧。作为一名十年经验的开发者，我不打算引用原文中的话来说明究竟什么是软件工程，而是说一下自己的理解，我认为软件工程实际上定义了IT公司的管理流程，设计理念，企业架构的方方面面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这个知识大爆炸的时代，计算机领域的书籍非常多，大部分都是偏重于介绍开发者技能提高的书籍，大概可以称为技能书，通过阅读这些技能书，开发者只需花较短的时间就能快速的掌握作者多年学习的收获，并快速的成长，进而实现自己收入的大幅度提高。软件工程所介绍的内容，在某些读者眼里，看起来就像天书昏昏欲睡，尤其是那些UML图和设计理念，在某些开发者眼里认为，就是浪费公司的人力财力和时间，于是有人说软件工程其实什么用都没有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;我觉得软件工程更像是心法，技术不好的时候，心法通则技术通，技术好了，更需要读心法，这样可以让你的念头通达，格局透彻。软件工程，或许并不像一门工程学，更像两种东西的融合，一个是软件管理学，一个是软件设计学，更像是从更高的维度来看待软件和软件公司的全生命周期，又从更微观的角度来介绍如何优雅的设计一个软件。这也大概是邹老师的杰作，《构建之法》的标题，取的是构建，而不是架构的原因吧。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;构建是什么？在最开始听到这个名词时，我以为是build，我甚至觉得构建一个软件，不就是开发集成环境中的一个按钮么？难道这本书谈的是编译原理？然而我错了，这本书实际上是build一套企业管理制度和文化，build一套切实可行的软件技术体系，正是讲述如何优雅的build一家能够持久生存的IT公司，用现在的主流说法，就是打造优秀IT企业的最佳实践方法吧。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;&lt;em&gt;当然，来到9102年的今天IT公司似乎已经成为一个令人不适的名词，在大家的眼中，仿佛言不离互联网公司，似乎一家公司自称是IT公司就自降身价一般。然而，互联网公司难道不是IT公司么？留给读者们评说吧。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;说到最佳实践，目前我也在一家互联网公司，也有幸接触了一些比较大的圈子，那就是中国的MVP们，他们是微软最有价值的技术专家，这些专家们都对技术充满了无限的追求、并积累了丰富的知识体系，从他们的交流沟通过程以及我自己平时的积累，我遇到了以下几种常&lt;span&gt;见，却不一定正确的最佳实践。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;1、设计优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;互联网公司常用的模式之一，就是设计和用户体验优先，在这种理念中，认为用户体验是第一生产力，技术是第二生产力。先把面子做好，再把产品做好。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;2，架构优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;这种理念认为，软件架构体系是决定软件生死命脉的关键因素。往往容易变成架构师优先，往往会招一位优秀的架构师，然后来组建他的核心班底，再变成一家技术优先的企业。真的是最佳实践么？谁吃过苦谁自己明白。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;3，中台优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;阿里巴巴的实践告诉我们，要重中台，轻前台，一切以业务流转为目标。但是真的是每家企业的最佳实践么？&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;4，数据优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;这种理念认为，数据是第一生产力，一切业务都是数据。在前几年的DT时代，就是这么鼓吹数据优先，然后各种大数据平台层出不穷，但是，往往做成了多数据，数据大，却很少有必要做成大数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我认为，核心理念应该依然是，构建优先，即作为一家软件公司的核心任务，应该是构建符合企业实际的管理体系。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;必须承认，在中国有许多业务优先的公司，其实并不能理解IT公司与传统公司的区别，总是用自己片面的理解认为，公司什么都缺，缺的只是一个程序员或几个程序员，但是，真的是这样么？没有，哪怕有幸被你招到了一位能独挑大梁的优秀程序员，往往也会由于与企业文化和管理理念极度的不适应而离去。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;在互联网概念已经深入人心的今天，从某种意义上讲，或许对于企业，只要掌握了合适的时机加上一些机遇，也许总是能获得成功。但是，真的能存活超过十年的时间，并保持持续的增长么？在偌大的中国，近些年以来有许多优秀的企业凭借优秀的产品获得了短期的成功，却深刻反映出中国经济发展全靠吃人口红利的客观事实。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;尤其是那些看起来短期依靠员工的创新能力获得快速发展的中小型或者独角兽企业，越是容易因为创新能力枯竭而最终内卷化。每家公司都有机会火五分钟，但是有的公司大概只能火那么几分钟。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;任何IT公司，撇开软件管理之道谈纯粹的技术实现或产品输出，或许都不过是一瞬间的爆发，越是看起来成功的优秀的互联网公司越是必须基于软件工程学的理论出发，建立一套切实可行，持续迭代的管理体系才能获得长久的生命力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;但是，哪怕有了构建之法，又该如何打破中国IT企业平均寿命不过2.8年的客观事实呢？我想我还是好好搬砖吧。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201903/191302-20190311230208110-900599403.jpg&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;304&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　插播广告，长沙.NET 技术社区已经成立，各种技术活动正火热的开展中，欢迎各地高手前来指教，公众号：DotNET技术圈（MoreDotNetCore），也可以添加微信（xuehua0602），加入社区与大家共同探讨技术。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:55:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>软件工程真的是一门什么用都没有的学科么？ 读《构建之法》有感 楔子 我很惭愧，构建之法这本书已经出版四五年了，我之前却未曾涉猎，还是在通过组织长沙.net技术社区之后，才因为因缘际遇有幸认识邹欣邹老师</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10513847.html</dc:identifier>
</item>
<item>
<title>大湾区联动:广州深圳助力东莞.NET俱乐部首次线下活动 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</guid>
<description>&lt;p&gt;新年伊始，经过一个寒冬考验后的.NET社区热情不减，长沙、南京、合肥、东莞先后建立以微信为主要平台的线上.NET社区。并相继开始筹划和组织各地区的首次线下活动。&lt;br/&gt;东莞作为粤港澳大湾区的腹地，制造业基地，沉淀了大量的.NET传统领域的开发人员。这些默默无闻，致力于为制造业提供各种信息化解决方案的.NETer 需要去被挖掘，需要和广深两城的同行一起交流，需要和大湾区所有的同行一起努力才能打造出一个实力强大且受众广泛的“大湾区.NET俱乐部”。&lt;br/&gt;120报名额度三天内报满，活动当天即使下雨依旧有高达65%的到场率，天气不良下免费活动的到场率到达这个数字真的说明东莞.NET的小伙伴儿们非常关注此次活动。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225002333-265279109.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225012798-1924290768.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;Excel催化剂作者-李伟坚，公元前（网名）作为非专业人士，非常热情和积极的去组织和筹备这次东莞的线下活动。“广州.NET微软技术俱乐部”作为大湾区.NET线下活动先行者，在本次活动中积极的协助东莞方面筹备本次活动，并且在活动当天广州俱乐部的两位主席（叶伟民，陈作）以及秘书处的两位成员（戚亚柱，郑子铭）都赶到了现场，全程参与此次活动。深圳俱乐部的主席张队（张善友）也自驾从深圳赶赴东莞现场助威，并为活动带来了礼品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225040195-233892769.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，本次活动的三个话题均来自三城社区的领袖。&lt;/p&gt;&lt;p&gt;话题一：国外.NET俱乐部经验分享 · 叶伟民 · 广州.NET俱乐部主席&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225047029-1441661723.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;话题二：.NET Core,Docker &amp;amp; Kubernetes · 张善友 · 深圳.NET俱乐部主席&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225053568-677255965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;话题三：使用.NET技术对Office软件二次开发 · 东莞.NET社区发起者 · 李伟坚&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225103457-2088585476.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;除了各位讲师精心准备的课程之外，广州俱乐部也会同东莞俱乐部在本次活动中做了活动形式上的创新。为了区别线上社区和课程，提高线下活动中参会人员的参与感，本次活动最后特意设置了分小组讨论环节。&lt;br/&gt;每小组在小组主持人带领对一个或多个话题展开讨论，以此让所有参会者都有区别于线上活动的体验。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225120286-1739007624.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;.NET 社区在2018年末的燃气的星星之火，在互联网寒冬的大背景下依然在2019年春出现了燎原之势，相信不久的将来一定会横扫神州大地，让处在每一个地方的.NETer都能够找到“组织”，都能都社区组织各种活动中学到技术，了解信息，交到朋友。&lt;/p&gt;&lt;p&gt;欢迎广州的.NETer 加入“广州.NET微软技术俱乐部”QQ群：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225128435-323427547.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;广州.NET微软技术俱乐部秘书处撰稿&lt;br/&gt;2019-03-11&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:42:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>大湾区联动:广州深圳助力东莞.NET俱乐部首次线下活动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</dc:identifier>
</item>
<item>
<title>Typescript 3.x 中常见的几种函数重载方法与应用示例 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/10513731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/10513731.html</guid>
<description>&lt;p&gt;所谓的重载，其实就是使用相同的函数名，传入不同数量的参数或不同类型的参数，以此创建出多个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 最常见的，也就是根据定义傻瓜式地判断参数类型与数量&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name, ...others) {
    console.log(name, others)
}

showPerson('tate', {age: 25, test: 'test str'})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 其次就是使用常规的重载签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用重载签名进行重载，好处在于可以对传入的参数进行限制，只有当签名存在对应类型或数量的参数时，才不会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此处定义完重载签名之后，一定要有具体实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name: string): void;
function showPerson (age: number): void;
function showPerson (play: () =&amp;gt; void): void;

function showPerson (...args) {
    console.log(args)
    // 根据函数类型和数量作出不同的行为
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重载签名配合可选参数可以使重载变得更加灵活&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name:string, age?: number, play?: () =&amp;gt; void): void;

// 利用重载签名 对不同的缺省做相应的处理
function showPerson (name, age, play) {
    // dosomething
}

showPerson('tate', 25)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.利用特定重载签名做更加细致的重载处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;鄙人比较喜欢NBA，就拿NBA举例。比如说现在需要写一个函数，只有当名字是姚明的时候，他才可以打中锋， 是科比的时候才能打后卫，是詹姆斯的时候才能打前锋，并且因为国内球员比较瘦弱，所以只有当姚明是25岁以上的时候，才能被归为合格的中锋（只是举个例子，不要太当真），那这个时候就用到特定重载签名了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43.5&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot; readability=&quot;10&quot;&gt;
function playBasketball (name: 'YaoMing', age: number): void;
function playBasketball (name: 'Kobe', age?: number): void;
function playBasketball (name: 'James', age?: number): void;&lt;p&gt;function playBasketball (name: string, age: number) {
    if (name === 'YaoMing' &amp;amp;&amp;amp; age &amp;amp;&amp;amp; age &amp;gt;= 25) {
        console.log('good Center')
    } else if (name === 'Kobe') {
        console.log('good guard')
    } else if (name === 'Jams') {
        console.log('good forward')
    } else {
        console.log('ordinary baskerball player')
    }
}
&lt;br/&gt;playBasketball('YaoMing', 25);
playBasketball('Kobe');　
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.  使用接口搭配重载签名或非重载签名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
interface BasketballPlayer {
    (name: 'YaoMing', age: number): void;
    (name: 'Kobe', age: number): void;
    (name: 'James', age: number): void;
}

let playBasketball: BasketballPlayer = function (name) {
    if (name === 'YaoMing') {
        // dosomething
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用接口配合函数的默认参数，可实现特定重载签名的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
interface BasketballPlayer {
    (name: 'YaoMing', age: number): void;
    (name: 'Kobe', age: number): void;
    (name: 'James', age: number): void;
}


let playBasketball: BasketballPlayer = function (name = 'Yaoming', age: number) {
    if (age &amp;gt;= 25) {
        console.log('good center')
    }
}

let playBasketball2: BasketballPlayer = function (name = 'Kobe') {
    console.log('good guard')
}

let playBasketball3: BasketballPlayer = function (name = 'James') {
    console.log('good forward');
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处其并非严格意义上的重载，但是却利用了重载的思想，并且灵活搭配了函数的默认参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TS在大型项目中带来的优势超乎我们的想象，其他各方面的分享将会持续进行，有兴趣的小伙伴可持续关注。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 11 Mar 2019 14:35:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<og:description>所谓的重载，其实就是使用相同的函数名，传入不同数量的参数或不同类型的参数，以此创建出多个方法。 1. 最常见的，也就是根据定义傻瓜式地判断参数类型与数量 2. 其次就是使用常规的重载签名 使用重载签名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pomelott/p/10513731.html</dc:identifier>
</item>
</channel>
</rss>