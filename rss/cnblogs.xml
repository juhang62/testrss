<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>中文数字阿拉伯数字相互转换 - 烟花散尽13141</title>
<link>http://www.cnblogs.com/zhangxinhua/p/13358571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinhua/p/13358571.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;阿拉伯数字肯定是使用最广泛的符合之一了。我们日常生活都离不开数字。中文下的数字是中国特色的数字。开发中也会遇到需要两者相互转换的需求。今天就来实现下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200722001.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;想上面的数字一样。假设我们的中文数字是【一亿七千七十九万七千一百九十七】。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解题思路&quot;&gt;解题思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先我们需要将上面中文数字按阿拉伯数字进行分离。这里我们先提出一个思想前提： 亿、万 这种是高级单位；千、百、十这种是低级单位。所以我们先按高级单位将上面的进行拆分。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200722002.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们得到上面的三个数字。分别是【一亿】、【七千零七十九万】、【七千一百九十七】。下面我们针对这三个数字进行翻译。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;各个击破&quot;&gt;各个击破&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;仔细分析下上面三个中文数字，不难得出结论-上面三个数字去掉高级单位剩下的都只有低级单位了。这也是我们实现的重点【低级单位内的数字转换】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们将三个数字分别转换完成之后，剩下的就是将他们组合。组合的问题也就是中间补零和去零的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;【七千零七十九万】去掉高级单位【七千零七十九】我们翻译也很简单就是将低级单位去掉变成【七零七九】及【7079】。那么上面的三位数字分别是&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文数字&lt;/th&gt;
&lt;th&gt;去掉单位后&lt;/th&gt;
&lt;th&gt;数字映射&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;一亿&lt;/td&gt;
&lt;td&gt;一&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;七千零七十九万&lt;/td&gt;
&lt;td&gt;七零七九&lt;/td&gt;
&lt;td&gt;7079&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;七千一百九十七&lt;/td&gt;
&lt;td&gt;七一九七&lt;/td&gt;
&lt;td&gt;7197&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;三位数字翻译好之后我们进行阿拉伯数字的拼接就完成了。 170797197&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;友情提醒&quot;&gt;友情提醒&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上面的数字翻译的很是顺利。但是又这么一类数字总是事与愿违。&lt;/li&gt;
&lt;li&gt;【一亿零七十九万零一百九十七】==【100790197】&lt;/li&gt;
&lt;li&gt;按照上面的思路我们会有如有推理&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文数字&lt;/th&gt;
&lt;th&gt;去掉单位后&lt;/th&gt;
&lt;th&gt;数字映射&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;一亿&lt;/td&gt;
&lt;td&gt;一&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;零七十九万&lt;/td&gt;
&lt;td&gt;零七九&lt;/td&gt;
&lt;td&gt;079&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;零一百九十七&lt;/td&gt;
&lt;td&gt;零一九七&lt;/td&gt;
&lt;td&gt;0197&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据表格我们拼接得到的数字是【10790197】。这个时候问题就大了去了。我们丢失了一位0。原因也很简单在中文数字中在同一高级单位维度里连续多个零的出现会同一读零。但是阿拉伯数字中确实实实在在的占位的。所以这里就会缺失一位零。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里的情况是一开始笔者没哟注意到的。但是后来改正了。所以上面提到的合并方法是没有问题的。上面是进行数字化乘以10000的。所以这里的0也不会丢失的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;正确的拼接方案是 ((1&lt;em&gt;10000)+079)&lt;/em&gt;10000+0197=100790197&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这种问题反向过来同样值得注意，在阿拉伯转中文数字的时候我们需要注意0到底代表几个0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【100790197】 ==【一亿零七十九万零一百九十七】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【100000197】 ==【一亿零一百九十七】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下面我们将对上面的两个阿拉伯数字进行解析转换。同样我们对他们进行高位分离。这里需要注意的是我们需要从低位到高位方向进行分离&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200722003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分离是从低位到高位。但是我们转换却要从高位到低位。顺序不能错。在我们阿拉伯数字转中文数字的时候非零数字注解映射转换就行了。但是遇到0的时候我们需要有一下三个条件才能转换，否则就要忽略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次遇到0&lt;/li&gt;
&lt;li&gt;数字为0&lt;/li&gt;
&lt;li&gt;统一高位单元内后面并不是全是0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;简单解释下上面三个。第一个通过一个状态为就能搞定。第二个其实就是保险点。可有可无。最重要第三点遇零后后面不能全是0.这个时候我们才可以将当前位置0翻译成零。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个非零数字翻译后需要加上低级单位的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所以上面的0079我们翻译的是【零七十九】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但是零七九并不是真正的汉字数字。所以我们在每一次高位翻译完成之后需要加上高位单位。所以【0079】==【零七十九万】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以我们得出如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阿拉伯数字&lt;/th&gt;
&lt;th&gt;数字映射&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;一亿&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0079&lt;/td&gt;
&lt;td&gt;零七十九万&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0197&lt;/td&gt;
&lt;td&gt;零一百九十七&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;所以【100790197】 ==【一亿零七十九万零一百九十七】&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阿拉伯数字&lt;/th&gt;
&lt;th&gt;数字映射&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;一亿&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0000&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0197&lt;/td&gt;
&lt;td&gt;零一百九十七&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;在加入高级单位时我们需要判断高级单位内数字是否有效。因为我们上面三个原因。所以0000对应的中文数字就是空字符串。这里我们认为是无效中文数字。所以万单位也就没有了。所以【100000197】==【一亿零一百九十七】&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;光谈理论不讲实践都是扯淡。下面我们需要对我们的设计进行验证。如何验证嗯。好在我们实现的【中文数字转阿拉伯数字】、【阿拉伯数字转中文数字】 。 那么我们直接通过两个方法相互转换。看看最终是不是原来的数据就能验证出来了。话不多说、上代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
Integer right = 0;
Integer total = 10000000;
List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
for (int i = 0; i &amp;lt; total; i++) {
    Integer number = MathUtil.getInstance().getRandom(1, 1000000000);
    //System.out.println(i);
    //Integer number = 400001989;
    String chinese = DigitUtil.getInstance().getNumberFromAlabo(number.toString());
    String alabo = DigitUtil.getInstance().getNumberFromChinese(chinese);
    boolean equals = alabo.equals(number.toString());
    if (equals) {
        right++;
    } else {
        Map&amp;lt;String, Object&amp;gt; map  = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;number&quot;, number);
        map.put(&quot;alabo&quot;, alabo);
        map.put(&quot;chinese&quot;, chinese);
        list.add(map);
    }
}
for (Map&amp;lt;String, Object&amp;gt; map : list) {
    System.out.println(map);
}
System.out.println(&quot;成功率：&quot;+Double.valueOf(right/(double)total));

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试后的正确率是1 。 也就是0差错。&lt;/li&gt;
&lt;li&gt;欢迎指出错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
package org.zxhtom.utils;

import org.zxhtom.constant.ChineseNumber;

import java.util.*;

/**
 * @package org.zxhtom.utils
 * @Class DigitUtil
 * @Description 数字工具类
 * @Author zhangxinhua
 * @Date 19-7-2 下午3:47
 */
public class DigitUtil {
    private static DigitUtil util;

    public static DigitUtil getInstance() {
        if (null == util) {
            util = new DigitUtil();
        }
        return util;
    }

    /**
     * 中文数字转阿拉伯数字
     *  一万两千三百五十四 --&amp;gt; 12354
     * @param chinese 阿拉伯数字
     * @return 中文数字
     */
    public String getNumberFromChinese(String chinese) {
        String result = &quot;0&quot;;
        //将中文数字按四位进行截取。这样每一位里只有单一
        List&amp;lt;String&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;();
        //暂时未使用到
        int lastLevelIndex = 0;
        //循环遍历，目的是将亿万进行分离
        for (int i =  ChineseNumber.highLevel.size()-1; i&amp;gt;=0; i--) {
            //判断亿万单位出现索引
            int levelIndex = chinese.indexOf(ChineseNumber.highLevel.get(i));
            if (levelIndex&amp;gt;0) {
                //表示有单位索引 ， 将单位前数据进行截取装入lists中。后面的继续循环截取
                lists.add(chinese.substring(0, levelIndex));
                chinese = chinese.substring(levelIndex+1);
            } else if (levelIndex == -1) {
                //表示已经是最低单位了，不超过万。直接加入lists中 ， 这里情况对应的是高位分离后，次高位开头是0的情况
                lists.add(ChineseNumber.number.get(0));
            } else if (levelIndex == 0) {
                while (levelIndex &amp;gt; 1) {
                    levelIndex--;
                    lists.add(ChineseNumber.number.get(0));
                }
                //直接加入
                lists.add(chinese);
            }
        }
        //针对分离的四位数据，进行单独翻译
        for (int i = 0; i &amp;lt; lists.size(); i++) {
            //未使用
            Integer highLevelIndex = lists.size() - i - 1;
            //获取单元数据
            String single = lists.get(i);
            //对单元数据进行翻译 。
            String nextResult = getNumberFromFChinese(single);
            //lists中每位都是4位数截取 ，所以这里需要乘以10000进行叠加
            Long next = Long.valueOf(Integer.valueOf(result) * (int)(Math.pow(10, 4)) + Integer.valueOf(nextResult));
            result = next.toString();
        }
        //将开头0抹掉
        result = result.replaceFirst(&quot;^(0+)&quot;, &quot;&quot;);
        return result;
    }

    /**
     * 通过中文数字获取4位数阿拉伯数字
     * 万以内的数据转换
     * @param single
     * @return
     */
    private String getNumberFromFChinese(String single) {
        String result = &quot;0&quot;;
        Integer highIndex = 1;
        for (int i = 0; i &amp;lt; single.length(); i++) {
            String str = String.valueOf(single.charAt(i));
            int unit = ChineseNumber.level.indexOf(str);
            int number = ChineseNumber.number.indexOf(str);
            if (unit == -1) {
                //当前数字是万以内的单位即  千百十其中之一
                int next = 0;
                if (i &amp;lt; single.length() - 1) {
                    //如果不是最后一位，则需要考虑当前位的权重
                    next = ChineseNumber.level.indexOf(String.valueOf(single.charAt(i + 1)));
                }
                result=String.valueOf(Integer.valueOf(result)+number * (int) (Math.pow(10, next)));
            }
        }
        //权重叠加
        result = &quot;&quot;+Integer.valueOf(result) * (int) (Math.pow(10, highIndex - 1));
        return result;
    }

    /**
     * 阿拉伯数字转中文数字
     * 12354 --&amp;gt; 一万两千三百五十四
     * @param alabo 阿拉伯数字
     * @return 中文数字
     */
    public String getNumberFromAlabo(String alabo) {
        String result = &quot;&quot;;
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int length = alabo.length()-1; length &amp;gt;= 0; length--) {
            list.add(String.valueOf(alabo.charAt(length)));
        }
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; lists = CollectionUtil.averageSize(list, 4);
        Collections.reverse(lists);
        if (CollectionUtil.isNotEmpty(lists)) {
            for (int index=0;index&amp;lt;lists.size();index++) {
                List&amp;lt;String&amp;gt; singleNumList = lists.get(index);
                //反转集合
                Collections.reverse(singleNumList);
                //默认0 false
                Boolean zeroflag =false;
                String chinese = &quot;&quot;;
                for (int j=0 ; j&amp;lt;singleNumList.size();j++) {
                    Integer number = Integer.valueOf(singleNumList.get(j));
                    if (number == 0 &amp;amp;&amp;amp; !zeroflag &amp;amp;&amp;amp; afterNotAllZero(singleNumList, j)) {
                        //第一次遇到0 且后面有小单位内并不是全为0
                        chinese += ChineseNumber.number.get(number);
                        //修改遇零状态true
                        zeroflag = true;
                    } else if(number!=0) {
                        //映射出对应的中文数字
                        chinese += ChineseNumber.number.get(number) + ChineseNumber.level.get(singleNumList.size()-j-1);
                    }
                }
                if (index==lists.size()&amp;amp;&amp;amp;chinese.substring(0, 1).equals(ChineseNumber.number.get(0))) {
                    //条件永远不成立。
                    chinese = chinese.substring(1);
                }
                //并不是全部为0，该高级单位才会生效
                if (chinese.length()&amp;gt;0&amp;amp;&amp;amp;!ChineseNumber.highLevel.contains(chinese.substring(chinese.length() - 1))) {
                    result += chinese + ChineseNumber.highLevel.get(lists.size() - 1 - index);
                }
            }
        }
        return result;
    }

    /**
     * 判断singleNumList在j位置之后是否全是0
     * @param singleNumList
     * @param j
     * @return
     */
    private boolean afterNotAllZero(List&amp;lt;String&amp;gt; singleNumList, int j) {
        for (int i = j+1; i &amp;lt; singleNumList.size(); i++) {
            if (!&quot;0&quot;.equals(singleNumList.get(i))) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Integer right = 0;
        Integer total = 10000000;
        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; total; i++) {
            Integer number = MathUtil.getInstance().getRandom(1, 1000000000);
            //System.out.println(i);
            //Integer number = 400001989;
            String chinese = DigitUtil.getInstance().getNumberFromAlabo(number.toString());
            String alabo = DigitUtil.getInstance().getNumberFromChinese(chinese);
            boolean equals = alabo.equals(number.toString());
            if (equals) {
                right++;
            } else {
                Map&amp;lt;String, Object&amp;gt; map  = new HashMap&amp;lt;&amp;gt;();
                map.put(&quot;number&quot;, number);
                map.put(&quot;alabo&quot;, alabo);
                map.put(&quot;chinese&quot;, chinese);
                list.add(map);
            }
        }
        for (Map&amp;lt;String, Object&amp;gt; map : list) {
            System.out.println(map);
        }
        System.out.println(&quot;成功率：&quot;+Double.valueOf(right/(double)total));
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxinhua/p/13358571.html#addMe&quot;&gt;加入战队&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/weixin.jpeg&quot; alt=&quot;微信公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Jul 2020 00:39:00 +0000</pubDate>
<dc:creator>烟花散尽13141</dc:creator>
<og:description>阿拉伯数字肯定是使用最广泛的符合之一了。我们日常生活都离不开数字。中文下的数字是中国特色的数字。开发中也会遇到需要两者相互转换的需求。今天就来实现下。 中文数字转阿拉伯数字 想上面的数字一样。假设我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangxinhua/p/13358571.html</dc:identifier>
</item>
<item>
<title>感知机算法（PLA）代码实现 - jianli-Alex</title>
<link>http://www.cnblogs.com/liangjianli/p/13358384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangjianli/p/13358384.html</guid>
<description>&lt;h3 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h3&gt;
&lt;p&gt;在这里主要实现感知机算法（PLA）的以下几种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PLA算法的原始形式（二分类）&lt;/li&gt;
&lt;li&gt;PLA算法的对偶形式（二分类）&lt;/li&gt;
&lt;li&gt;PLA算法的作图（二维）&lt;/li&gt;
&lt;li&gt;PLA算法的多分类情况（包括one vs. rest 和one vs. one 两种情况）&lt;/li&gt;
&lt;li&gt;PLA算法的sklearn实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了方便起见，使用鸢尾花数据集进行PLA算法的验证。&lt;/p&gt;
&lt;h3 id=&quot;2-载入库和数据处理&quot;&gt;2. 载入库和数据处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 载入库
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Perceptron
import warnings
warnings.filterwarnings(&quot;ignore&quot;)

# 设置图形尺寸
plt.rcParams[&quot;figure.figsize&quot;] = [14, 7]
plt.rcParams[&quot;font.size&quot;] = 14

# 载入鸢尾花数据集
iris_data = load_iris()
xdata = iris_data[&quot;data&quot;]
ydata = iris_data[&quot;target&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-感知机的原始形式&quot;&gt;3. 感知机的原始形式&lt;/h3&gt;
&lt;p&gt;感知机的详细原理见我的&lt;a href=&quot;https://www.cnblogs.com/liangjianli/p/13357057.html&quot;&gt;前一篇博客&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class model_perceptron(object):
    &quot;&quot;&quot;
    功能：实现感知机算法
    参数 w：权重，默认都为None
    参数 b：偏置项，默认为0
    参数 alpha：学习率，默认为0.001
    参数 iter_epoch：迭代轮数，默认最大为1000
    &quot;&quot;&quot;
    def __init__(self, w = None, b = 0, alpha = 0.001, max_iter_epoch = 1000):
        self.w = w
        self.b = b
        self.alpha = alpha
        self.max_iter_epoch = max_iter_epoch
        
    def linear_model(self, X):
        &quot;&quot;&quot;功能：实现线性模型&quot;&quot;&quot;
        return np.dot(X, self.w) + self.b
         
    def fit(self, X, y):
        &quot;&quot;&quot;
        功能：拟合感知机模型
        参数 X：训练集的输入数据
        参数 y：训练集的输出数据
        &quot;&quot;&quot;
        # 按训练集的输入维度初始化w
        self.w = np.zeros(X.shape[1])
        # 误分类的样本就为True
        state = np.sign(self.linear_model(X)) != y
        # 迭代轮数
        total_iter_epoch = 1
        
        while state.any() and (total_iter_epoch &amp;lt;= self.max_iter_epoch):
            # 使用误分类点进行权重更新
            self.w += self.alpha * y[state][0] * X[state][0]
            self.b += self.alpha * y[state][0]
            
            # 状态更新
            total_iter_epoch += 1
            state = np.sign(self.linear_model(X)) != y
            
        print(f&quot;fit model_perceptron(alpha = {self.alpha}, max_iter_epoch = {self.max_iter_epoch}, total_iter_epoch = {min(self.max_iter_epoch, total_iter_epoch)})&quot;)
        
    def predict(self, X):
        &quot;&quot;&quot;
        功能：模型预测
        参数 X：测试集的输入数据
        &quot;&quot;&quot;
        return np.sign(self.linear_model(X)) 
    
    def score(self, X, y):
        &quot;&quot;&quot;
        功能：模型评价（准确率）
        参数 X：测试集的输入数据
        参数 y：测试集的输出数据
        &quot;&quot;&quot;
        y_predict = self.predict(X)
        y_score = (y_predict == y).sum() / len(y)
        
        return y_score
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 二分类的情况（原始形式）/ 数据集的处理与划分
X = xdata[ydata &amp;lt; 2]
y = ydata[ydata &amp;lt; 2]
y = np.where(y == 0, -1, 1)
xtrain, xtest, ytrain, ytest = train_test_split(X, y)

# 原始形式的验证
ppn = model_perceptron()
ppn.fit(xtrain, ytrain)
ppn.predict(xtest)
ppn.score(xtest, ytest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示（由于随机划分数据集，运行结果不一定和图示相同）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722005316056-1526099280.png&quot; alt=&quot;感知机的原始形式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-感知机的对偶形式&quot;&gt;4. 感知机的对偶形式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class perceptron_dual(object):
    &quot;&quot;&quot;
    功能：实现感知机的对偶形式
    参数 beta：每个实例点更新的次数组成的向量
    参数 w：权重，默认都为None
    参数 b：偏置项，默认为0
    参数 alpha：学习率，默认0.001
    参数 max_iter_epoch：最大迭代次数，默认为1000
    &quot;&quot;&quot;
    def __init__(self, alpha = 0.001, max_iter_epoch = 1000):
        self.beta = None
        self.w = None
        self.b = 0
        self.alpha = alpha
        self.max_iter_epoch = max_iter_epoch
        
    def fit(self, X, y):
        # 实例点的数量
        xnum = X.shape[0]
        # 初始化
        self.beta = np.zeros(xnum)
        
        # gram矩阵
        gram = np.dot(X, X.T)
        
        # 迭代条件
        state = y*((self.beta * y * gram).sum(axis = 1) + self.b) &amp;lt;= 0
        iter_epoch = 1
        
        while state.any() and (iter_epoch &amp;lt;= self.max_iter_epoch):
            nx = X[state][0]
            ny = y[state][0]
            index = (X == nx).argmax()
            self.beta[index] += self.alpha
            self.b += ny
            
            # 更新条件
            iter_epoch += 1
            state = y*((self.beta * y * gram).sum(axis = 1) + self.b) &amp;lt;= 0
        
        # 通过beta计算出w
        self.w = ((self.beta * y).reshape(-1, 1) * X).sum(axis = 0) 
        print(f&quot;fit perceptron_dual(alpha = {self.alpha}, total_iter_epoch = {min(self.max_iter_epoch, iter_epoch)})&quot;)
            
        
    def predict(self, X):
        &quot;&quot;&quot;
        功能：模型预测
        参数 X：测试集的输入数据
        &quot;&quot;&quot;
        y_predict = np.sign(X @ self.w  + self.b)
        return y_predict
    
    def score(self, X, y):
        &quot;&quot;&quot;
        功能：模型评价（准确率）
        参数 X：测试集的输入数据
        参数 y：测试集的输出数据
        &quot;&quot;&quot;
        y_score = (self.predict(X) == y).sum() / len(y)
        
        return y_score
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 二分类的情况（对偶形式）/ 数据集的处理与划分
X = xdata[ydata &amp;lt; 2]
y = ydata[ydata &amp;lt; 2]
y = np.where(y == 0, -1, 1)
xtrain, xtest, ytrain, ytest = train_test_split(X, y)

# 对偶形式验证
ppn = perceptron_dual()
ppn.fit(xtrain, ytrain)
ppn.predict(xtest)
ppn.score(xtest, ytest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示（由于随机划分数据集，运行结果不一定和图示相同）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722012858846-862728564.png&quot; alt=&quot;感知机的对偶形式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-多分类情况one-vs-rest&quot;&gt;5. 多分类情况—one vs. rest&lt;/h3&gt;
&lt;p&gt;假设有k个类别，ovr策略是生成k个分类器，最后选取概率最大的预测结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class perceptron_ovr(object):
    &quot;&quot;&quot;
    功能：实现感知机的多分类情形（采用one vs. rest策略）
    参数 w：权重，默认都为None
    参数 b：偏置项，默认为0
    参数 alpha：学习率，默认0.001
    参数 max_iter_epoch：最大迭代次数，默认为1000
    &quot;&quot;&quot;
    def __init__(self, alpha = 0.001, max_iter_epoch = 1000):
        self.w = None
        self.b = None
        self.alpha = alpha
        self.max_iter_epoch = max_iter_epoch
        
    def linear_model(self, X):
        &quot;&quot;&quot;功能：实现线性模型&quot;&quot;&quot;
        return np.dot(self.w, X.T) + self.b
        
    def fit(self, X, y):
        &quot;&quot;&quot;
        功能：拟合感知机模型
        参数 X：训练集的输入数据
        参数 y：训练集的输出数据
        &quot;&quot;&quot;
        # 生成各分类器对应的标记
        self.y_class = np.unique(y)
        y_ovr = np.vstack([np.where(y == i, 1, -1) for i in self.y_class])
        
        # 初始化w, b
        self.w = np.zeros([self.y_class.shape[0], X.shape[1]])
        self.b = np.zeros([self.y_class.shape[0], 1])
        
        # 拟合各分类器，并更新相应维度的w和b
        for index in range(self.y_class.shape[0]):
            ppn = model_perceptron(alpha = self.alpha, max_iter_epoch = self.max_iter_epoch)
            ppn.fit(X, y_ovr[index])
            self.w[index] = ppn.w
            self.b[index] = ppn.b
            
    def predict(self, X):
        &quot;&quot;&quot;
        功能：模型预测
        参数 X：测试集的输入数据
        &quot;&quot;&quot;
        # 值越大，说明第i维的分类器将该点分得越开，即属于该分类器的概率值越大
        y_predict = self.linear_model(X).argmax(axis = 0)
        
        # 还原原数据集的标签
        for index in range(self.y_class.shape[0]):
            y_predict = np.where(y_predict == index, self.y_class[index], y_predict)
            
        return y_predict
    
    def score(self, X, y):
        &quot;&quot;&quot;
        功能：模型评价（准确率）
        参数 X：测试集的输入数据
        参数 y：测试集的输出数据
        &quot;&quot;&quot;
        y_score = (self.predict(X) == y).sum()/len(y)
        return y_score
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 多分类数据集处理
xtrain, xtest, ytrain, ytest = train_test_split(xdata, ydata)

# one vs. rest的验证
ppn = perceptron_ovr()
ppn.fit(xtrain, ytrain)
ppn.predict(xtest)
ppn.score(xtest, ytest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示（由于随机划分数据集，运行结果不一定和图示相同）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722012654195-472433040.png&quot; alt=&quot;one vs. rest&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-多分类情况one-vs-one&quot;&gt;6. 多分类情况—one vs. one&lt;/h3&gt;
&lt;p&gt;假设有k个类别，生成k(k-1)/2个二分类器，最后通过多数投票来选取预测结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from itertools import combinations

class perceptron_ovo(object):
    &quot;&quot;&quot;
    功能：实现感知机的多分类情形（采用one vs. one策略）
    参数 w：权重，默认都为None
    参数 b：偏置项，默认为0
    参数 alpha：学习率，默认0.001
    参数 max_iter_epoch：最大迭代次数，默认为1000
    &quot;&quot;&quot;
    def __init__(self, alpha = 0.001, max_iter_epoch = 1000):
        self.w = None
        self.b = None
        self.alpha = alpha
        self.max_iter_epoch = max_iter_epoch
        
    def linear_model(self, X):
        &quot;&quot;&quot;功能：实现线性模型&quot;&quot;&quot;
        return np.dot(self.w, X.T) + self.b
        
    def fit(self, X, y):
        &quot;&quot;&quot;
        功能：拟合感知机模型
        参数 X：训练集的输入数据
        参数 y：训练集的输出数据
        &quot;&quot;&quot;
        # 生成各分类器对应的标记（使用排列组合）
        self.y_class = np.unique(y)
        self.y_combine = [i for i in combinations(self.y_class, 2)]
        
        # 初始化w和b
        clf_num = len(self.y_combine)
        self.w = np.zeros([clf_num, X.shape[1]])
        self.b = np.zeros([clf_num, 1])
        
        for index, label in enumerate(self.y_combine):
            # 根据各分类器的标签选取数据集
            cond = pd.Series(y).isin(pd.Series(label))
            xdata, ydata = X[cond], y[cond]
            ydata = np.where(ydata == label[0], 1, -1)
            
            # 拟合各分类器，并更新相应维度的w和b
            ppn = model_perceptron(alpha = self.alpha, max_iter_epoch = self.max_iter_epoch)
            ppn.fit(xdata, ydata)
            self.w[index] = ppn.w
            self.b[index] = ppn.b
    
    def voting(self, y):
        &quot;&quot;&quot;
        功能：投票
        参数 y：各分类器的预测结果，接受的是元组如(1, 1, 2)
        &quot;&quot;&quot;
        # 统计分类器预测结果的出现次数
        y_count = np.unique(np.array(y), return_counts = True)
        # 返回出现次数最大的结果位置索引
        max_index = y_count[1].argmax()
        # 返回某个实例投票后的结果
        y_predict = y_count[0][max_index]
        
        return y_predict
        
                      
    def predict(self, X):
        &quot;&quot;&quot;
        功能：模型预测
        参数 X：测试集的输入数据
        &quot;&quot;&quot;
        # 预测结果
        y_predict = np.sign(self.linear_model(X))
        # 还原标签（根据排列组合的标签）
        for index, label in enumerate(self.y_combine):
            y_predict[index] = np.where(y_predict[index] == 1, label[0], label[1])
        
        # 列为某一个实例的预测结果，打包用于之后的投票
        predict_zip = zip(*(i.reshape(-1) for i in np.vsplit(y_predict, self.y_class.shape[0])))
        # 投票得到预测结果
        y_predict = list(map(lambda x: self.voting(x), list(predict_zip)))
        
        return np.array(y_predict)
    
    def score(self, X, y):
        &quot;&quot;&quot;
        功能：模型评价（准确率）
        参数 X：测试集的输入数据
        参数 y：测试集的输出数据
        &quot;&quot;&quot;
        y_predict = self.predict(X)
        y_score = (y_predict == y).sum() / len(y)
        
        return y_score
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 多分类数据集处理
xtrain, xtest, ytrain, ytest = train_test_split(xdata, ydata)

# one vs. one的验证
ppn = perceptron_ovo()
ppn.fit(xtrain, ytrain)
ppn.predict(xtest)
ppn.score(xtest, ytest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示（由于随机划分数据集，运行结果不一定和图示相同）：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722012747655-1642787601.png&quot; alt=&quot;one vs. one&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;准确率一般比one vs. rest要高，但是生成的分类器多&lt;/p&gt;
&lt;h3 id=&quot;7-sklearn实现&quot;&gt;7. sklearn实现&lt;/h3&gt;
&lt;p&gt;主要使用sklearn中的Perceptron模块，其中可以实现多分类的情况（默认采用one vs. rest）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.linear_model import Perceptron

xtrain, xtest, ytrain, ytest = train_test_split(xdata, ydata)
ppn = Perceptron(max_iter = 1000)
ppn.fit(xtrain, ytrain)
ppn.predict(xtest)
ppn.score(xtest, ytest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722013140127-439368261.png&quot; alt=&quot;sklearn实现&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;8-感知机算法的作图&quot;&gt;8. 感知机算法的作图&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;from matplotlib.colors import ListedColormap

def decision_plot(X, Y, clf, test_idx = None, resolution = 0.02):
    &quot;&quot;&quot;
    功能：画分类器的决策图
    参数 X：输入实例
    参数 Y：实例标记
    参数 clf：分类器
    参数 test_idx：测试集的index
    参数 resolution：np.arange的间隔大小
    &quot;&quot;&quot;
    # 标记和颜色设置
    markers = ['o', 's', 'x', '^', '&amp;gt;']
    colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan')
    cmap = ListedColormap(colors[:len(np.unique(Y))])
    
    # 图形范围
    xmin, xmax = X[:, 0].min() - 1, X[:, 0].max() + 1
    ymin, ymax = X[:, 1].min() - 1, X[:, 1].max() + 1
    x = np.arange(xmin, xmax, resolution)
    y = np.arange(ymin, ymax, resolution)
    
    # 网格
    nx, ny = np.meshgrid(x, y)
    
    # 数据合并
    xdata = np.c_[nx.reshape(-1), ny.reshape(-1)]
    
    # 分类器预测
    z = clf.predict(xdata)
    z = z.reshape(nx.shape)
    
    # 作区域图
    plt.contourf(nx, ny, z, alpha = 0.4, cmap = cmap)
    plt.xlim(nx.min(), nx.max())
    plt.ylim(ny.min(), ny.max())
    
    # 画点
    for index, cl in enumerate(np.unique(Y)):
        plt.scatter(x=X[Y == cl, 0], y=X[Y == cl, 1],
                    alpha=0.8, c = cmap(index), 
                    marker=markers[index], label=cl)
    
    # 突出测试集的点
    if test_idx:
        X_test, y_test = X[test_idx, :], y[test_idx]

        plt.scatter(X_test[:, 0],
                    X_test[:, 1],
                    alpha=0.15,
                    linewidths=2,
                    marker='^',
                    edgecolors='black',
                    facecolors='none',
                    s=55, label='test set')
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 作图时的数据处理
X = xdata[ydata &amp;lt; 2, :2]
y = ydata[ydata &amp;lt; 2]
y = np.where(y == 0, -1, 1)

xtrain, xtest, ytrain, ytest = train_test_split(X, y)
ppn = model_perceptron()
ppn.fit(xtrain, ytrain)
decision_plot(X, y, ppn)
plt.legend()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1684731/202007/1684731-20200722011004055-323785418.png&quot; alt=&quot;感知机作图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Jul 2020 00:20:00 +0000</pubDate>
<dc:creator>jianli-Alex</dc:creator>
<og:description>1. 引言 在这里主要实现感知机算法（PLA）的以下几种情况： PLA算法的原始形式（二分类） PLA算法的对偶形式（二分类） PLA算法的作图（二维） PLA算法的多分类情况（包括one vs. r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liangjianli/p/13358384.html</dc:identifier>
</item>
<item>
<title>[翻译]ASP.NET Core在 .NET 5 Preview 7的更新 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/13358470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/13358470.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview7/&quot;&gt;.NET 5 Preview 7现在可以用了&lt;/a&gt;，可以进行评估了。这是此版本中的新增功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor WebAssembly应用程序现在针对.NET 5&lt;/li&gt;
&lt;li&gt;更新了Blazor WebAssembly的调试要求&lt;/li&gt;
&lt;li&gt;Blazor的可访问性改进&lt;/li&gt;
&lt;li&gt;Blazor的性能改进&lt;/li&gt;
&lt;li&gt;证书认证性能改进&lt;/li&gt;
&lt;li&gt;发送HTTP/2 PING帧&lt;/li&gt;
&lt;li&gt;支持Kestrel套接字传输中的其他终结点类型&lt;/li&gt;
&lt;li&gt;Kestrel中的自定义标头解码&lt;/li&gt;
&lt;li&gt;其他小改进&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;get-started&quot;&gt;Get started&lt;/h2&gt;
&lt;p&gt;要开始使用.NET 5 Preview 7中的ASP.NET Core，&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core/5.0&quot;&gt;请安装.NET 5 SDK&lt;/a&gt;。&lt;br/&gt;您需要使用&lt;a href=&quot;https://visualstudio.microsoft.com/vs/preview/&quot;&gt;的Visual Studio 2019 16.7 PreView 5&lt;/a&gt;或更新的版本来使用.NET 5 Preview 7. .NET 5也支持了最新的&lt;a href=&quot;https://docs.microsoft.com/visualstudio/mac/install-preview&quot;&gt;预览&lt;/a&gt;的&lt;a href=&quot;https://visualstudio.microsoft.com/&quot;&gt;Visual Studio中的Mac&lt;/a&gt;。要将.NET 5与&lt;a href=&quot;https://visualstudio.microsoft.com/&quot;&gt;Visual Studio Code一起使用&lt;/a&gt;，请安装最新版本的&lt;a href=&quot;https://code.visualstudio.com/Docs/languages/csharp&quot;&gt;C# extension&lt;/a&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;升级现有项目&quot;&gt;升级现有项目&lt;/h2&gt;
&lt;p&gt;要将现有的ASP.NET Core应用程序从.NET 5 Preview 6升级到.NET 5 Preview 7，请执行以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将所有Microsoft.AspNetCore.* 软件包引用更新为。&lt;code&gt;5.0.0-preview.7.*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将所有Microsoft.Extensions.* 程序包引用更新为。&lt;code&gt;5.0.0-preview.7.*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新System.Net.Http.Json包引用。&lt;code&gt;5.0.0-preview.7.*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请参阅.NET 5的ASP.NET Core 中&lt;a href=&quot;https://github.com/aspnet/announcements/issues?q=is%3Aopen+is%3Aissue+milestone%3A5.0+label%3A%22Breaking+change%22&quot;&gt;重大更改&lt;/a&gt;的完整列表。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;升级现有的blazor-webassembly项目&quot;&gt;升级现有的Blazor WebAssembly项目&lt;/h3&gt;
&lt;p&gt;要升级现有的Blazor WebAssembly项目，请更新以下属性：&lt;br/&gt;&lt;strong&gt;从&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;TargetFramework&amp;gt;netstandard2.1&amp;lt;/TargetFramework&amp;gt;
&amp;lt;RazorLangVersoin&amp;gt;3.0&amp;lt;/RazorLangVersion&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;至&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
&amp;lt;RuntimeIdentifier&amp;gt;browser-wasm&amp;lt;/RuntimeIdentifier&amp;gt;
&amp;lt;UseBlazorWebAssembly&amp;gt;true&amp;lt;/UseBlazorWebAssembly&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，请删除对的所有包引用，因为不再需要它。&lt;code&gt;Microsoft.AspNetCore.Components.WebAssembly.Build&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是新的？&quot;&gt;什么是新的？&lt;/h2&gt;

&lt;h3 id=&quot;blazor-webassembly应用程序现在针对net-5&quot;&gt;Blazor WebAssembly应用程序现在针对.NET 5&lt;/h3&gt;
&lt;p&gt;Blazor WebAssembly 3.2应用程序只能访问.NET Standard 2.1 API集。在此版本中，Blazor WebAssembly项目现在以.NET 5为目标，并且可以访问更广泛的API集。在.NET 5中实现对API的Blazor WebAssembly支持正在进行中，因此某些API可能会在运行时抛出。如果您因缺乏对特定API的支持而受阻，我们很乐意收到您的来信。&lt;code&gt;net5.0``PlatformNotSupportedException&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新了blazor-webassembly的调试要求&quot;&gt;更新了Blazor WebAssembly的调试要求&lt;/h3&gt;
&lt;p&gt;要在Visual Studio Code中启用Blazor WebAssembly应用程序的调试，您以前需要安装&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.js-debug-nightly&quot;&gt;JavaScript Debugger（Nightly）扩展程序&lt;/a&gt;。不再需要这样做，因为&lt;a href=&quot;https://github.com/microsoft/vscode-js-debug#nightly-extension&quot;&gt;JavaScript调试器扩展现已作为VS Code的一部分提供&lt;/a&gt;。如果您先前已安装（Nightly）JavaScript调试器扩展，则可以将其卸载。仍然需要通过Visual Studio Code设置启用JavaScript调试器的预览版。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;blazor的可访问性改进&quot;&gt;Blazor的可访问性改进&lt;/h3&gt;
&lt;p&gt;从&lt;code&gt;InputBase&lt;/code&gt;现在开始派生的内置Blazor输入组件会在验证失败时自动呈现&lt;code&gt;aria-invalid&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;blazor的性能改进&quot;&gt;Blazor的性能改进&lt;/h3&gt;
&lt;p&gt;.NET 5中Blazor WebAssembly的主要投资领域之一是提高运行时性能。这是一个多方面的努力。以下是一些需要优化的高级区域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;.NET运行时执行&lt;/li&gt;
&lt;li&gt;JSON序列化&lt;/li&gt;
&lt;li&gt;JavaScript互操作&lt;/li&gt;
&lt;li&gt;Blazor组件渲染&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不断改进.NET 5的Blazor WebAssembly运行时性能。此版本包含一些初步的性能改进，我们希望在以后的.NET 5更新中共享有关此性能工作结果的更多详细信息。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;证书认证性能改进&quot;&gt;证书认证性能改进&lt;/h3&gt;
&lt;p&gt;我们在ASP.NET Core中为证书身份验证添加了缓存。缓存证书验证可以大大提高证书验证的性能。我们的基准测试显示，启用缓存后，每秒请求的速度提高了400％。&lt;br/&gt;您无需对应用程序进行任何更改即可利用性能改进。默认情况下，缓存处于打开状态。如果您愿意，有一些选项可以调整或禁用缓存。&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/aspnet/core/security/authentication/certauth&quot;&gt;在文档中&lt;/a&gt;找到有关ASP.NET Core &lt;a href=&quot;https://docs.microsoft.com/aspnet/core/security/authentication/certauth&quot;&gt;中的&lt;/a&gt;证书身份验证的更多信息。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;发送http2-ping帧&quot;&gt;发送HTTP/2 PING帧&lt;/h3&gt;
&lt;p&gt;HTTP / 2具有用于发送PING帧的机制，以确保空闲连接是否仍然有效。当使用长期闲置但只能间歇性地查看活动的长寿命流（例如gRPC流）时，此功能特别有用。通过在上设置限制，我们增加了在Kestrel中发送定期PING帧的功能&lt;code&gt;KestrelServerOptions&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            webBuilder.ConfigureKestrel(options =&amp;gt;
            {
                options.Limits.Http2.KeepAlivePingInterval = TimeSpan.FromSeconds(10);
                options.Limits.Http2.KeepAlivePingTimeout = TimeSpan.FromSeconds(1);
            });
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;支持kestrel套接字传输中的其他终结点类型&quot;&gt;支持Kestrel套接字传输中的其他终结点类型&lt;/h3&gt;
&lt;p&gt;在Kestrel中引入的新API的基础上，Kestrel中的套接字传输（默认）现在允许您绑定到现有文件句柄和Unix域套接字。支持绑定到现有文件句柄，从而可以使用现有的Systemd集成，而无需使用libuv传输。&lt;code&gt;System.Net.Sockets&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;kestrel中的自定义标头解码&quot;&gt;Kestrel中的自定义标头解码&lt;/h3&gt;
&lt;p&gt;我们添加了根据标题名称指定用于解释传入标题的功能，而不是默认使用UTF-8。您可以将属性设置为on，以指定要使用的编码。&lt;code&gt;System.Text.Encoding``RequestHeaderEncodingSelector``KestrelServerOptions&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&amp;gt;
        {
            webBuilder.ConfigureKestrel(options =&amp;gt;
            {
                options.RequestHeaderEncodingSelector = encoding =&amp;gt;
                {
                    switch (encoding)
                    {
                        case &quot;Host&quot;:
                            return System.Text.Encoding.Latin1;
                        default:
                            return System.Text.Encoding.UTF8;
                    }
                };
            });
            webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
        });
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;其他改进&quot;&gt;其他改进&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对于预览版7，我们已开始将可为空的注释应用于ASP.NET Core程序集。我们打算在5.0版本期间对框架的大多数常见公共API表面进行注释。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CompareAttribute&lt;/code&gt; 现在可以应用于“Razor Page”模型上的属性。&lt;/li&gt;
&lt;li&gt;默认情况下，从主体绑定的参数和属性被认为是必需的。&lt;/li&gt;
&lt;li&gt;我们已经开始将可为空的注释应用于ASP.NET Core程序集。我们打算在.NET 5发布期间对框架的大多数常见公共API表面进行注释。&lt;/li&gt;
&lt;li&gt;现在，使用端点路由时的授权将接收&lt;code&gt;HttpContext&lt;/code&gt;而不是端点实例。这允许授权中间件访问通过类无法访问的&lt;code&gt;RouteData&lt;/code&gt;和属性。可以使用从上下文中获取端点。&lt;code&gt;HttpContext``Endpoint``context.GetEndpoint()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;现在的默认格式默认为W3C格式。默认情况下，这使得ASP.NET Core中的分布式跟踪支持可与更多框架互操作。&lt;code&gt;System.Diagnostics.Activity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CompareAttribute&lt;/code&gt; 现在可以应用于“Razor Page”模型上的属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FromBodyAttribute&lt;/code&gt; 现在支持配置允许将这些参数或属性视为可选的选项：&lt;br/&gt;&lt;code&gt;C# public IActionResult Post([FromBody(EmptyBodyBehavior = EmptyBodyBehavior.Allow)] MyModel model) { ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;给予反馈&quot;&gt;给予反馈&lt;/h2&gt;
&lt;p&gt;我们希望您喜欢.NET 5中此版本的ASP.NET Core！我们很想听听您有关此最新.NET 5版本的经验。通过在&lt;a href=&quot;https://github.com/dotnet/aspnetcore/issues&quot;&gt;GitHub上&lt;/a&gt;提交问题，让我们知道您的想法。&lt;br/&gt;感谢您试用ASP.NET Core！&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-7/&quot;&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-7/&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jul 2020 23:19:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>.NET 5 Preview 7现在可以用了，可以进行评估了。这是此版本中的新增功能： Blazor WebAssembly应用程序现在针对.NET 5 更新了Blazor WebAssembly的调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/13358470.html</dc:identifier>
</item>
<item>
<title>如何从最坏、平均、最好的情况分析复杂度？ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13358458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13358458.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202007/1648938-20200722063552433-98326217.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.125&quot;&gt;
&lt;p&gt;本篇文章收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。&lt;/p&gt;
&lt;p&gt;上一节，我们从事后统计法过渡到渐近分析法，详细讲解了如何进行算法的复杂度分析。&lt;/p&gt;
&lt;p&gt;但是，如果遵循严格的渐近分析法，需要掌握大量数学知识，这无疑给我们评估算法的优劣带来了很大的挑战。&lt;/p&gt;
&lt;p&gt;那么，有没有更好地评估算法的方法呢？&lt;/p&gt;
&lt;p&gt;答案是必然的，本节，我们就从最坏、平均、最好三种情况来分析分析复杂度。&lt;/p&gt;

&lt;p&gt;为了便于讲解，我写了一个小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinearSearch {
    public static void main(String[] args) {
        int[] array = new int[]{1, 8, 9, 3, 5, 6, 10, 13};
        int index = search(array, 10);
        System.out.println(&quot;index=&quot; + index);
    }

    private static int search(int[] array, int value) {
        for (int i = 0; i &amp;lt; array.length; i++) {
            if (array[i] == value) {
                return i;
            }
        }
        return -1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子使用线性搜索从一个数组中查找一个元素，这个元素有可能存在，也有可能不存在于数组中。&lt;/p&gt;

&lt;p&gt;在最坏情况下，要查找的元素不存在于数组中，此时，它的时间复杂度是多少呢？&lt;/p&gt;
&lt;p&gt;很简单，必然需要遍历完所有元素才会发现要查找的元素不存在于数组中。&lt;/p&gt;
&lt;p&gt;所以，最坏情况下，使用线性查找的时间复杂度为O(n)。&lt;/p&gt;

&lt;p&gt;在平均情况下，我们要照顾到每一个元素，此时，它的时间复杂度如何计算呢？&lt;/p&gt;
&lt;p&gt;在上一节，我们已经讲过计算方式了，不过，这里考虑到有元素不存在于数组中，所以，是(n+1)种可能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;1*1/(n+1) + 2*/(n+1) + ... + n*1/(n+1) + (n+1)/(n+1) = 1/(n+1) * (n+1)(n+2)/2 = (n+2)/2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，在平均情况下，忽略掉常数项，使用线性查找的时间复杂度也是O(n)。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;为什么要忽略掉常数项？&lt;/p&gt;
&lt;p&gt;当n趋向于无穷大的时候，常数项的意义不是很大，所以，可以忽略，比如(n+2)/2=n/2 + 1，n本身已经趋向于无穷大，加不加1有什么意义呢，n的倍数是2还是1/2并不会有明显的差别。&lt;/p&gt;
&lt;p&gt;同样地，低阶项一般也会抹掉，比如2n^2 + 3n + 1，当n趋向于无穷大的时候，n^2的值是远远大于3n的，所以，不需要保留3n。&lt;/p&gt;
&lt;p&gt;所以，计算复杂度时通常都会把常数项和低阶项抹掉，只保留高阶项。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最好情况是什么呢？&lt;/p&gt;
&lt;p&gt;如果我们要查找的元素正好是数组的第一个元素，查找一次就找到了，这无疑是最好的情况。&lt;/p&gt;
&lt;p&gt;所以，在最好情况下，使用线性查找的时间复杂度是O(1)。&lt;/p&gt;

&lt;p&gt;通过上面的分析，可以看到，最坏情况和最好情况是比较好评估的，而平均情况则比较难以计算。&lt;/p&gt;
&lt;p&gt;但是，最好情况又不能代表大多数样本，且平均情况与最坏情况在省略常数项的情况下往往是比较接近的。&lt;/p&gt;
&lt;p&gt;所以，通常，我们使用最坏情况来评估算法的时间复杂度，这也是比较简单的一种评估方法，且往往也是比较准确的。&lt;/p&gt;

&lt;p&gt;本节，我们从最坏、平均、最好三种情况分析了线性查找的时间复杂度，经过详细地分析，我们得出结论，通常使用最坏情况来评估算法的时间复杂度。&lt;/p&gt;
&lt;p&gt;请注意，我们这里使用了“通常”，说明有些情况是不能使用最坏情况来评估算法的时间复杂度的。&lt;/p&gt;
&lt;p&gt;那么，你知道什么情况下不能使用最坏情况来评估算法的时间复杂度吗？&lt;/p&gt;
&lt;p&gt;下一节，我们接着聊。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公众号“彤哥读源码”，解锁更多源码、基础、架构知识！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Jul 2020 22:36:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>本篇文章收录于专辑：http://dwz.win/HjK 前言 你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。 上一节，我们从事后统计法过渡到渐近分析法，详细讲解了如何进行算法的复杂度分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13358458.html</dc:identifier>
</item>
<item>
<title>程序员肺被切掉一块还得去加班... 再谈“工作996，生病ICU” - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/13358102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/13358102.html</guid>
<description>&lt;p&gt;如题，为什么要说再谈“工作996，生病ICU”，因为996问题早已不是一个新问题。近日，北京一程序员在知乎问题“如何看待 996 工作制度”下分享了自己因长期加班而致病，最终因病切除部分肺部的经历。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;119.47642357642&quot;&gt;
&lt;p&gt;如题，为什么要说再谈“工作996，生病ICU”，因为996问题早已不是一个新问题，在我最近刚出版的新书&lt;a href=&quot;http://www.pwmis.com/sod/index.htm&quot; target=&quot;_blank&quot;&gt;《SOD框架“企业级”应用数据架构实战》&lt;/a&gt;写作期间，爆发了一次程序员“起义”，出现了一个流行词“工作996，生病ICU”，于是我将这个词作为了新书里面第一章第三节的标题。由于这个话题比较敏感，在与出版社编辑反复沟通之后，保留本节内容，但是删除“起义”这个字眼，毕竟白纸黑字，出版社也怕承担压力。&lt;/p&gt;
&lt;p&gt;就在我的这本书这个月正式上市之际，程序员996问题再次成为程序员圈子的热点话题，让我觉得有必要将书里面的这部分内容拿出来再谈谈。 这件事情就是近日北京一程序员在知乎问题“如何看待 996 工作制度”下分享了自己因长期加班而致病，最终因病切除部分肺部的经历。这位叫“卷眉毛山治君”的北京程序员讲述自己肺被切掉一块还得去加班，后来终于醒悟，感慨到只有家人才会最在乎你。截止到现在，该回答已获得 10000 余赞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7.itc.cn/q_70/images03/20200714/a016723fce6c4381b19c28e820f0f81f.jpeg&quot; width=&quot;440&quot; height=&quot;5470&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有关这个事情，可以参考园子里面一个朋友的文章：《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/12345ai/p/13301023.html&quot;&gt;一个996程序员的自述：在公司眼里你就是一个工具&lt;/a&gt;》，也可以看看51CTO的博客：《&lt;a href=&quot;https://www.sohu.com/a/407451350_463994&quot; target=&quot;_blank&quot;&gt;一个北京996程序员的自述：肺被切掉一块还得去加班...&lt;/a&gt; 》，在百度搜索一下这个事情，能找到很多转载报道此事的文章。于此相关，也有些文章对此做了思考讨论：《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/daimalady/p/13280144.html&quot;&gt;程序员未来会成为非常内卷的职业吗？&lt;/a&gt;》，《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/dhcn/p/13220405.html&quot;&gt;经济学家林采宜：996是种洗脑文化 马云的解释存在三大谬论&lt;/a&gt;》。当然，我在书里面不能直接这样写，毕竟我写的是一本技术书，只谈事实，不评论是非。下面，是我书中第一章第三节《工作996，生病ICU》的内容，让我们来回顾下这个话题的由来。可以点击下面的标题链接来查看原文。&lt;/p&gt;


&lt;p&gt;2017中国加班最狠公司排行榜，第一名华为，腾讯阿里排第二三，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pwmis.com/sod/images/bookpic_1_3.jpg&quot; width=&quot;551&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些打鸡血的互联网公司有很多员工都是程序员，加班是常态，随即衍生出来“996”工作制。所谓996工作制是指，早9点上班，晚9点下班，每周工作6天。渐渐地，由于互联网行业的特殊性，这种工作制成了很多公司心照不宣的潜规则。&lt;br/&gt;     那么到底是什么原因导致了程序员们这么疯狂的加班现象呢？这个问题主流媒体前几年就关注报道了，下面来看看它们的报道和分析调查。&lt;br/&gt;     2016年，人民日报3问过度加班，并且指出，IT已成为最疯狂的加班行业，没有之一。在《过度加班，咋就停不下来？》文中报道一名深圳的程序员，“夜夜做项目，敲码到凌晨；左右不是人，都是‘程序猿’。”程序员自称“程序猿”，有几分自嘲和无奈。之后，光明日报呼吁，《杜绝过度加班，应正确理解“敬业”》，文章指出，敬业精神的本质是忠于职守，尽最大可能完成好工作，而不是讨好领导。&lt;br/&gt;     到底是什么原因导致国家的“喉舌”都要出来说加班的问题了呢？下面先看看网友热议人民日报“过度加班”报道后的一则调查数据：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;39%的网友认为，“加班已成为一种单位（企业）文化，不加班说明你不积极，为保饭碗只能加班”；&lt;/li&gt;
&lt;li&gt;39%的网友认为，“加班完全是被迫，老板、上司、客户没完没了地布置各种任务”；&lt;/li&gt;
&lt;li&gt;6%的网友认为，“经常加班主要是因为自己工作效率低，没法按时交差，只能靠加班来补”；&lt;/li&gt;
&lt;li&gt;4%的网友认为，“加班一方面是因为工作没有做完，另外一方面也因为加班费收入很可观”；&lt;/li&gt;
&lt;li&gt;只有6%的网友说，“很幸福地说，我很少加班，大家不要太羡慕我”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     看来，加班的主要原因是“加班文化”和“任务太多”，两项相加占比接近80%，只有很少网友说不加班或者是其它原因的加班。下面一些来自人民日报的新闻报道也可以印证这个调查投票。&lt;/p&gt;
&lt;p&gt;     《58同城“996”引发员工声讨 认为公司在变相裁员》人民网2016.9.3，&lt;br/&gt;     《&quot;996工作制&quot;已成互联网公司潜规则 折射行业不景气》人民网2016.9.11，&lt;br/&gt;     《为了十一陪爸妈，26岁IT男连续熬夜加班突然口吐鲜血，经历生死劫！》 都市快报2017.9.26&lt;/p&gt;
&lt;p&gt;     在2018年8月，《又一程序员倒下，内心感到悲凉…》的网络文章在程序员社交圈炸锅，一个互联网公司年仅24岁的程序员在长时间加班后从工位站起来随后晕倒，再也没有起来… 看来不是传说中的“老年人”程序员经不起加班，现在年轻人也经不起加班了！ &lt;strong&gt;任何时候身体健康是第一位的&lt;/strong&gt;，不能为了工作这么拼，你的倒下等于抛弃了世间最爱你的人，你对工作的“敬业”此时是对爱你的人的一种“自私”！程序员，且行且珍重！&lt;br/&gt;     看来IT业加班的新闻或者事件早就不是个案，这已经成为行业的通病，广大程序员梦寐以求的进入BAT工作的机会，看了起来也不是只有美好的一面，前提你得适应这些企业的加班文化和高强度的工作节奏。不过在很多一般的IT公司程序员加班也是很常见的现象，就像前面的新闻报道一样。所以，加不加班是摆在广大程序员面前一个难以逾越的“坎”，每个程序员都要面对这个问题。&lt;br/&gt;     既然大家改变不了加班这个大环境，那么能做的就是去适应环境，提高工作效率，改善工作质量，“多。快。好。省”的完成自己的工作任务，从而减轻加班节奏，能够有更多的时间和精力去寻找另一半，去陪伴家人和孩子，让自己生活丰富一点，美好一点，幸福一点！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
注意：
    本节下面有些内容有可能让读者感到不适，出版社的编辑说下面的叙述负能量有点多，
    让人觉得“前途无亮”，建议删改。
编者按：
    经过笔者和编辑的多次沟通，同意保留下面的内容。
    如果您不喜欢这样的内容，请跳过下面的内容。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;     “ &lt;strong&gt;&lt;span&gt;工作996，生病ICU&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;     “996”工作制，指的是一种越来越流行的非官方工作制（早上 9 点 ~ 晚上 9 点，每周 6 天）。在一个实行“996”工作制的公司工作就意味着每周至少要工作 60 个小时。&lt;/p&gt;
&lt;p&gt;写本书的时候，恰好在2019年3月程序员世界爆发了一次“QY ”，抵制996运动，有人注册了一个域名996.icu的域名，打开这个地址： &lt;a href=&quot;https://996.icu/#/zh_CN&quot; target=&quot;_blank&quot;&gt;https://996.icu/#/zh_CN&lt;/a&gt;，可以看到中国劳动法和相关法律法规的介绍，然后页面上大举控诉部分互联网公司实行996工作制的行为。截止笔者写稿，已经超过了20万个点赞。见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pwmis.com/sod/images/bookpic_1_4.jpg&quot; width=&quot;774&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个数字来源于有人在GitHub上建立的996.icu项目的点赞数，地址是：&lt;a href=&quot;https://github.com/996icu/996.ICU&quot; target=&quot;_blank&quot;&gt;https://github.com/996icu/996.ICU&lt;/a&gt; ，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pwmis.com/sod/images/bookpic_1_5.jpg&quot; width=&quot;1198&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
编者按：
    1,应出版社编辑要求，作为纸质出版物，原词[QY]“不和谐”，故用字母表示，具体含义请自行搜索网络。
    2,网站被屏蔽的时间发生在抵制996运动开始的的2019年3月，什么时候取消了屏蔽不清楚，
      但截至到2020年6月在这些特定浏览器上该网站已经可以访问。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于参与这个项目互动的人数实在是太多，项目作者不得不关闭了 issues，并声明这跟“ GitHub 或其他方面无关”，可见程序员世界却是是群情激愤，作者也是饱受压力。有趣的是，这个项目网站在一段时间内被国内各大浏览器厂商集体屏蔽 ，无法访问。&lt;br/&gt;     现在这个项目已经被翻译成了超过 10 种的外国语言，分别为：德语，英语，西班牙语，法语，希腊语，意大利语，日语，俄语，泰语，越南语，当然还有汉语，以及繁体字。这让全世界都听到了中国程序员的呐喊与彷徨。与至于，连“Python之父”都看不过去了，在推特上说这是不人道的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pwmis.com/sod/images/bookpic_1_6.jpg&quot; width=&quot;950&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，微软员工和 GitHub 员工也宣布支持 996.ICU 运动，并且呼吁：“对于其他技术从业者和行业内外的支持者，我们恳请您加入我们对 996.ICU 运动的支持。” 该活动页面地址是：&lt;a href=&quot;https://github.com/MSWorkers/support.996.ICU&quot; target=&quot;_blank&quot;&gt;https://github.com/MSWorkers/support.996.ICU&lt;/a&gt; ，页面截图如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.pwmis.com/sod/images/bookpic_1_7.jpg&quot; width=&quot;1460&quot; height=&quot;950&quot;/&gt;&lt;/p&gt;

&lt;p&gt; “996问题”的原因，在博客园caozsay的一篇文章&lt;a href=&quot;https://news.cnblogs.com/n/623096/&quot; target=&quot;_blank&quot;&gt;《关于程序员的996，我们谈谈历史和逻辑》&lt;/a&gt;认为程序员供过于求，平庸的程序员太多，优秀的程序员很稀缺，这是市场的选择。一石激起千层浪， 这篇文章引发了一场大讨论，反对者众，有些观点值得思考。笔者认同作者文章中的一句话：“这很不正确，但这是事实，事实经常不正确。”由于喷的人太多， 原文作者不得不再发文&lt;a href=&quot;https://mp.weixin.qq.com/s/j0YsxTOxepr1B5KPHfy8SQ&quot; target=&quot;_blank&quot;&gt;《谈谈事实和逻辑》&lt;/a&gt;澄清，“从头到尾，其实我根本没有表达我个人的观点和立场。 但很多人把事实和逻辑当作是我的立场和观点”，强调要分清事实与观点，看懂事实的逻辑，不能“拿逻辑当观点喷，用观点混淆事实”。&lt;br/&gt;     很快，博客园“沉默王二”的另一篇文章&lt;a href=&quot;https://www.cnblogs.com/qing-gee/p/10642292.html&quot; target=&quot;_blank&quot;&gt;《996：只要能活着就好，不管活得多么糟糕》&lt;/a&gt;再度引发996问题的大讨论， 文章说，996问题，实属无耐，生存现状所迫，并不是只有程序员行业有这个问题。但作者是反对“只要能活着就好，不管活得多么糟糕”， 并且说，“我们来到这个世界上，难道是为了比谁过得更惨吗？”这种为程序员奔走呐喊的声音，文章赢得了很多点赞。&lt;br/&gt;     为此，笔者决定将本节内容的标题，从原来的“大部分开发人员都经常加班”，修改为“工作996，生病ICU”，这样更加符合程序员世界的生存事实。&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Tue, 21 Jul 2020 15:38:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<og:description>如题，为什么要说再谈“工作996，生病ICU”，因为996问题早已不是一个新问题。近日，北京一程序员在知乎问题“如何看待 996 工作制度”下分享了自己因长期加班而致病，最终因病切除部分肺部的经历。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bluedoctor/p/13358102.html</dc:identifier>
</item>
<item>
<title>移动端适配必须掌握的基本概念和适配方案 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/13358140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/13358140.html</guid>
<description>&lt;p&gt;随着技术的发展，移动设备越来越流行，并且不同设备间屏幕尺寸和屏幕像素的差异，移动端开发面临着多分辨率适配的问题。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;136.24937065008&quot;&gt;
&lt;p&gt;随着技术的发展，移动设备越来越流行，并且不同设备间屏幕尺寸和屏幕像素的差异，移动端开发面临着多分辨率适配的问题。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;响应式开发本质时针对多种屏幕做适配，在实际开发中，通常情况下时针对主流的设备进行适配。在开发前，必须掌握几个基本概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;物理像素：即屏幕的实际像素点。像素是屏幕设备的最小显示单元，如 iPhone4 的屏幕分辨率是640x960像素，即 iPhone4 的屏幕由横向640个像素和纵向960个像素排列组成。&lt;/li&gt;
&lt;li&gt;设备独立像素：即逻辑像素，用于定义应用的 UI（UI即用户界面，这里指的是定义应用界面的各个元素的大小）。苹果 iPhone4 首次提出了 Retina Display（视网膜屏幕）的概念，在 iPhone4 使用的视网膜屏幕中，把 2x2 个像素当 1 个物理像素使用，即使用 2x2 个像素显示原来 1 个物理像素显示的内容，从而让 UI 显示更精致清晰，这 2x2 个像素即使逻辑像素。&lt;/li&gt;
&lt;li&gt;屏幕像素比（device pixel ratio 简称 dpr）：即物理像素与逻辑像素的比值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;常见设备宽高：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备名称&lt;/th&gt;
&lt;th&gt;物理像素&lt;/th&gt;
&lt;th&gt;设备独立像素&lt;/th&gt;
&lt;th&gt;屏幕像素比&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;iPhone4&lt;/td&gt;
&lt;td&gt;640x960&lt;/td&gt;
&lt;td&gt;320x480&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone6，6S，7&lt;/td&gt;
&lt;td&gt;750x1334&lt;/td&gt;
&lt;td&gt;375x667&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;iPhone6 Plus，6S Plus，7 Plus&lt;/td&gt;
&lt;td&gt;1080x1920&lt;/td&gt;
&lt;td&gt;414x736&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Galaxy S4, S5&lt;/td&gt;
&lt;td&gt;1080x1920&lt;/td&gt;
&lt;td&gt;360x640&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Galaxy Note4&lt;/td&gt;
&lt;td&gt;1440x2560&lt;/td&gt;
&lt;td&gt;360x640&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPad mini 2, 3&lt;/td&gt;
&lt;td&gt;1536x2048&lt;/td&gt;
&lt;td&gt;768x1024&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;视口（viewport）&quot;&gt;视口（Viewport）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;视口（Viewport）&lt;/strong&gt;是指当前可见的计算机图形区域，在浏览器中，是指能用来显示网页的区域。视口当前可见的部分叫做&lt;strong&gt;可视视口（visual viewport）&lt;/strong&gt;。整个网页所占据的区域（包括可视也包括不可视的区域）叫做&lt;strong&gt;布局视口（layout viewport）&lt;/strong&gt;。当可视视口比布局视口小时，浏览器网页就会出现横向滚动条，以支持用户浏览整个网页的内容。&lt;/p&gt;
&lt;p&gt;通常情况下，大多数移动设备的 Viewport（一般指布局视口）的宽度都是 980 像素，而可视视口（即设备独立像素）通常都小于 980 像素。为了禁止出现横向滚动条，不得不设置设备的 Viewport。通过在 Head 元素中使用 Meta 标签来设置 Viewport 属性。常用的 Viewport 设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Viewport 属性：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;取值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;定义视口的宽度，单位为像素&lt;/td&gt;
&lt;td&gt;正整数或 device-width（设备的宽度）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;定义视口的高度，单位为像素&lt;/td&gt;
&lt;td&gt;正整数或 device-height（设备的高度）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;initial-scale&lt;/td&gt;
&lt;td&gt;定义初始缩放比例&lt;/td&gt;
&lt;td&gt;整数或小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;maximum-scale&lt;/td&gt;
&lt;td&gt;定义允许用户缩放到的最大比例&lt;/td&gt;
&lt;td&gt;整数或小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;minimum-scale&lt;/td&gt;
&lt;td&gt;定义允许用户缩放到的最小比例&lt;/td&gt;
&lt;td&gt;整数或小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;user-scalable&lt;/td&gt;
&lt;td&gt;定义是否允许用户缩放&lt;/td&gt;
&lt;td&gt;yes或no&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;适配方案&quot;&gt;适配方案&lt;/h2&gt;
&lt;p&gt;对于移动端适配的方案，市面上有很多种。细心观察会发现，实际上这些适配方案是基于两种不同的设计思想而产生的。一种是通过缩放处理屏蔽屏幕尺寸和分辨率的影响，保证内容元素数量的一致性。这种做法产生的结果是屏幕尺寸越大的设备显示的内容元素越大，反之亦然。另一种是不进行缩放处理，保证内容元素大小的一致性。这种做法产生的结果是屏幕尺寸越大的设备在横向上显示的内容元素越多，反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;rem-适配&quot;&gt;rem 适配&lt;/h3&gt;
&lt;p&gt;rem 适配是缩放处理设计思想的典型代表。rem 是一个相对单位，它永远相对于根元素（html）的字体大小，这个特性方便了统一管理元素的大小，非常适合用来处理布局。rem 适配通常采用如下的 viewport 设置:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何合理设置 rem 的大小呢？通常将页面宽度进行 10 等分，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const rem = document.documentElement.clientWidth / 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，rem 的大小完全是随屏幕正比变化，就能根据设计稿尺寸换算页面元素和字体的大小。以常用的 750px 设计稿尺寸为例，假设设计稿的某个字体大小是 40px，换算成 rem 应该为 40 / 75 = 0.53333rem。当然这样计算很麻烦，可以选择使用构建工具&lt;a href=&quot;https://github.com/cuth/postcss-pxtorem&quot;&gt;postcss-pxtorem&lt;/a&gt;简化这些工作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：并非所有单位都需要转换成 rem，通常只对需要等比缩放的元素进行 rem 换算，对于不需要缩放的元素，比如边框阴影，使用 px 等其他单位。实际开发中，应该以 rem 单位为基础，同时结合其他单位协同工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;vw-适配&quot;&gt;vw 适配&lt;/h3&gt;
&lt;p&gt;vw 是一个相对于 viewport 的单位，100vw 就等于 viewport 的宽度。vw 适配同样是一个缩放处理设计思想的适配方案，得益于现代浏览器对 vw 单位的良好支持性而流行，它是比 rem 适配更优秀的适配方案。vw 适配通常采用如下的 viewport 设置:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vw 适配如何换算元素大小呢？使用公式：（元素大小 / 设计稿大小）* 100vw 将元素大小转换为 vw 单位的大小。以常用的 750px 设计稿尺寸为例，假设设计稿的某个字体大小是 40px，换算成 vw 单位大小应该为 （40 / 750）* 100vw = 5.33333vw。同样可以选择使用构建工具&lt;a href=&quot;https://github.com/evrone/postcss-px-to-viewport&quot;&gt;postcss-px-to-viewport&lt;/a&gt;简化工作流程。&lt;/p&gt;
&lt;p&gt;vw 适配和 rem 适配出自同一种设计思想，它们极其相似，vw 适配同样需要结合其他单位协同工作。&lt;/p&gt;
&lt;h3 id=&quot;弹性盒（flexbox）适配&quot;&gt;弹性盒（Flexbox）适配&lt;/h3&gt;
&lt;p&gt;弹性盒（CSS Flexible Box Layout Module 简称 Flexbox）是一种用于在单个维度（行或列）中显示项目的布局模型。当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式，提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。Flexbox 布局的两个基本概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容器：弹性布局的父元素（display=flex的元素）。&lt;/li&gt;
&lt;li&gt;项目：弹性布局容器中的每一个子元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;弹性盒适配就是采用了 Flexbox 布局模型的适配方案，这种适配方案通常使用如下的 viewport 设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用弹性盒适配的优点是不需要进行单位转换，因为其不需进行缩放处理，因此通常情况下都使用 px 单位。弹性盒适配的基本原则是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容流式：即弹性项目（弹性布局容器中的每一个子元素）的填充内容使用流式布局。&lt;/li&gt;
&lt;li&gt;布局弹性：即涉及元素排列、对齐和空间分配时，使用弹性盒进行布局。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前，没有完美的适配方式。实际开发中，应根据项目的需求和团队的素质选用合适的方案。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 21 Jul 2020 15:31:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<og:description>随着技术的发展，移动设备越来越流行，并且不同设备间屏幕尺寸和屏幕像素的差异，移动端开发面临着多分辨率适配的问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jofun/p/13358140.html</dc:identifier>
</item>
<item>
<title>函数节流与函数防抖 - 重科前端小鑫</title>
<link>http://www.cnblogs.com/cqkjxxxx/p/13358083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqkjxxxx/p/13358083.html</guid>
<description>&lt;h2 id=&quot;函数节流（throttle）&quot;&gt;函数节流（throttle）&lt;/h2&gt;
&lt;p&gt;函数节流：在指定的间隔时间内只执行一次&lt;br/&gt;有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。&lt;br/&gt;比如下面的例子，在不加函数节流的时候，每当滚动条滚动的时候都会触发一次，造成大量的性能浪费&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 未添加节流函数
document.onscroll = function () {
  console.log('scroll事件被触发了')
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002005/202007/2002005-20200721224828879-1896982078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加了节流函数后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 添加了节流函数
document.onscroll = throttle(function () {
  console.log('scroll事件被触发了')
}, 300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002005/202007/2002005-20200721224953767-857251965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;具体代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @description 函数节流
 * @param {Function} fn 需要执行函数节流的函数
 * @param {Number} interval 指定间隔时间
 */
function throttle(fn, interval = 300) {
  let canRun = true // 通过闭包保存一个标记
  return function () {
    if (!canRun) return // 第一次调用执行
    canRun = false // setTimeout未执行时，后续fn函数调用都不会再执行
    // setTimeout 定时器延时执行
    setTimeout(() =&amp;gt; {
      fn.apply(this, arguments)
      canRun = true // 标记为true，节流完成
    }, interval)
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码解释&lt;/strong&gt;&lt;br/&gt;简单来说，函数的节流就是通过闭包保存一个标记(&lt;code&gt;canRun = true&lt;/code&gt;), 在函数的开头判断这个标记是否为&lt;code&gt;true&lt;/code&gt;，如果这个标记为&lt;code&gt;true&lt;/code&gt;的话就继续执行，否则就&lt;code&gt;return&lt;/code&gt;掉，判断完标记后立即把这个标记设置为&lt;code&gt;false&lt;/code&gt;，然后把外部传入的函数的执行包在一个&lt;code&gt;setTimout&lt;/code&gt;中，最后在定时器执行完毕之后再把标记设置为&lt;code&gt;true&lt;/code&gt;，表示本次延迟执行完毕，可以执行下一次循环了。当定时器还未执行完毕的时候，&lt;code&gt;canRun&lt;/code&gt;这个标记始终未&lt;code&gt;false&lt;/code&gt;，故在开头的判断中总是被&lt;code&gt;return&lt;/code&gt;掉，函数并未执行。、&lt;br/&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;br/&gt;监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次等&lt;/p&gt;
&lt;h2 id=&quot;函数防抖（debounce）&quot;&gt;函数防抖（debounce）&lt;/h2&gt;
&lt;p&gt;函数防抖: 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。&lt;br/&gt;比如点击一个按钮，每点击一次就会触发一次事件，在没有加防抖函数的情况下，快速点击会导致多次触发&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 未加防抖函数
document.getElementById('btn').onclick = function(){
  console.log('我被点击了');
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002005/202007/2002005-20200721231017227-545504262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在加了防抖函数后，只会在规定时间后触发一次&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 加了防抖函数
document.getElementById('btn').onclick = debounce(function(){
  console.log('我被点击了');
},300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002005/202007/2002005-20200721231225898-1843840430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @description 函数防抖
 * @param {Function} fn 需要执行函数防抖的函数
 * @param {Number} interval 指定间隔时间
 */
function debounce(fn, interval = 300) {
  let timeout = null // 通过闭包保存一个标记
  return function () {
    clearInterval() // 把前一个定时器去掉
    // 又创建一个新的定时器
    timeout = setTimeout(() =&amp;gt; {
      fn.apply(this, arguments) // 指定的时间间隔之后运行fn
    }, interval)
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码解释&lt;/strong&gt;&lt;br/&gt;其原理就第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器，然后延迟一定时间再执行。&lt;br/&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;br/&gt;文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jul 2020 15:21:00 +0000</pubDate>
<dc:creator>重科前端小鑫</dc:creator>
<og:description>##函数节流（throttle） 函数节流：在指定的间隔时间内只执行一次 有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。 比如下面的例子，在不加函数节流的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cqkjxxxx/p/13358083.html</dc:identifier>
</item>
<item>
<title>IO、NIO实现简单聊天室，附带问题解析 - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/13358026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/13358026.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  本篇文章主要使用IO和NIO的形式来实现一个简单的聊天室，并且说明IO方法存在的问题，而NIO又是如何解决的。&lt;/p&gt;
&lt;p&gt;  大概的框架为，先提供思路和大概框架图——代码——问题及解决方式，这样会容易看一点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;11-思路框架&quot;&gt;1.1 思路框架&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;  下面编写一个简单的聊天室，大概需要的功能就是服务端维护一个聊天室，里边的客户端发送消息之后服务将其消息转发给其他客户端，达到一个聊天室的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  大致的思路：&lt;strong&gt;服务端区分职责，分成两部分，主线程负责接收连接并把连接放入到线程池中处理，维护一个线程池，所有对于socket的处理都交给线程池中的线程来处理。如下图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200721144427IO%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg&quot; alt=&quot;socket架构图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  下面贴上&lt;strong&gt;demo&lt;/strong&gt;代码（代码中有几处为了方便并没有采用最规范的定义方式，如线程池的创建和&lt;strong&gt;Map&lt;/strong&gt;初始化的时候未设置初始容量等）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;代码分五个类，服务端（ChatServer，监听作用，为服务端主线程）、客户端（ChatClient）、服务端处理器（ServerHandler，可以理解为线程池中要执行的事情）、客户端处理器（ClientHandler，客户端读写服务器消息的处理），工具类（SocketUtils，只有一个发送消息方法）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;12-demo代码&quot;&gt;1.2 demo代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 服务端启动类
 * 主要负责监听客户端连接
 */
public class ChatServer {

    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        /*----------为了方便使用Executors创建线程-------------*/
        ExecutorService handlerThreadPool = Executors.newFixedThreadPool(100);
        try {
            serverSocket = new ServerSocket(8888);
            while (true) {
                System.out.println(&quot;-----------阻塞等待连接------------&quot;);
                Socket socket = serverSocket.accept();
                String key = socket.getInetAddress().getHostAddress() + &quot;:&quot; + socket.getPort();
                System.err.println(key + &quot;已连接&quot;);
                // 主线程只接收，处理直接交给处理线程池
                handlerThreadPool.execute(new ServerHandler(socket));
            }
        } catch (IOException e) {
            e.printStackTrace();
            if (Objects.nonNull(serverSocket)) {
                try {
                    serverSocket.close();
                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务端处理类：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
/**
 * 服务端socket事件处理类
 * 负责处理对应socket中的读写操作
 */
public class ServerHandler implements Runnable {

    /**
     * 连接到服务端的所有连接 socket的地址端口-&amp;gt;socket
     */
    private static final Map&amp;lt;String, Socket&amp;gt; socketMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * 维护名称和地址的map
     */
    private static final Map&amp;lt;String, String&amp;gt; nameMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private Socket socket;

    /**
     * 每个socket的标识，使用地址+端口构成
     */
    private String key;

    public ServerHandler() {
    }

    public ServerHandler(Socket socket) {
        this.socket = socket;
        this.key = socket.getInetAddress().getHostAddress() + &quot;:&quot; + socket.getPort();
    }

    @Override
    public void run() {
        Socket s = socket;
        // 根据消息执行不同操作
        InputStream inputStream;
        // debug查看数据用
        // Map&amp;lt;String, Socket&amp;gt; tmpMap = socketMap;
        try {
            inputStream = s.getInputStream();
            Scanner scanner = new Scanner(inputStream);
            while (true) {
                String line = scanner.nextLine();
                if (line.startsWith(&quot;register&quot;)) {
                    // 登记
                    String[] split = line.split(&quot;:&quot;);
                    String name = split[1];
                    String msg;
                    // 校验是否存在
                    if (socketMap.containsKey(key)) {
                        msg = &quot;请勿重复登记&quot;;
                        sendMsg(s, msg);
                        return;
                    }

                    if (nameMap.containsValue(name)) {
                        msg = &quot;名称已被登记，请换一个名称&quot;;
                        sendMsg(s, msg);
                        return;
                    }

                    // 通知自己已连接
                    sendMsg(s, &quot;已连接到服务器&quot;);

                    msg = name + &quot;进入聊天室&quot;;
                    // 将消息转发给其他客户端
                    sendMsgToClients(msg);

                    // 放入socket池
                    socketMap.put(key, s);
                    nameMap.put(key, name);
                    System.err.println(name + &quot;已登记&quot;);
                } else if (line.trim().equalsIgnoreCase(&quot;end&quot;)) {
                    if (notPassRegisterValidate()) {
                        continue;
                    }

                    // 断开连接
                    socketMap.remove(key);
                    String name = nameMap.get(key);
                    String msg = name + &quot;离开聊天室&quot;;
                    System.err.println(msg);
                    // 将消息转发给其他客户端
                    sendMsgToClients(msg);

                    msg = &quot;已断开连接&quot;;
                    // 发送给对应的连接断开信息
                    sendMsg(s, msg);
                    inputStream.close();
                    break;
                } else {
                    if (notPassRegisterValidate()) {
                        continue;
                    }

                    // 正常通信
                    String name = nameMap.get(key);
                    String msg = name + &quot;:&quot; + line;
                    // 将消息转发给其他客户端
                    sendMsgToClients(msg);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 是否已登录校验
     *
     * @return 是否已登录
     */
    private boolean notPassRegisterValidate() {
        boolean hasRegister = nameMap.containsKey(key);
        if (hasRegister) {
            return false;
        }

        String msg = &quot;您还未登录，请先登录&quot;;
        sendMsg(socket, msg);
        return true;
    }

    /**
     * 往连接发送消息
     *
     * @param socket 客户端连接
     * @param msg    消息
     */
    private void sendMsg(Socket socket, String msg) {
        SocketUtils.sendMsg(socket, msg);
        if (socket.isClosed()) {
            socketMap.remove(key);
        }
    }

    /**
     * 发送给其他客户端信息
     *
     * @param msg 信息
     */
    private void sendMsgToClients(String msg) {
        for (Map.Entry&amp;lt;String, Socket&amp;gt; entry : socketMap.entrySet()) {
            if (this.key.equals(entry.getKey())) {
                continue;
            }

            sendMsg(entry.getValue(), msg);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;工具类（一个发送消息的方法）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SocketUtils {

    private SocketUtils() {
    }

    public static void sendMsg(Socket socket, String msg) {
        Socket s = socket;
        OutputStream outputStream = null;
        msg += &quot;\r\n&quot;;
        try {
            outputStream = s.getOutputStream();
            outputStream.write(msg.getBytes(StandardCharsets.UTF_8));
            outputStream.flush();
        } catch (IOException e) {
            System.err.println(&quot;发送消息失败, 连接已断开&quot;);
            try {
                if (Objects.nonNull(outputStream)) {
                    outputStream.close();
                }
                socket.close();
            } catch (IOException ioException) {
                ioException.printStackTrace();
            }

        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 客户端读和写各自使用一个线程
 */
public class ChatClient {

    public static void main(String[] args) {
        Socket socket;
        ExecutorService clientHandlerPool = Executors.newFixedThreadPool(2);
        try {
            socket = new Socket(&quot;localhost&quot;, 8888);

            // 写线程
            clientHandlerPool.execute(new ClientHandler(socket, 1));
            // 读线程
            clientHandlerPool.execute(new ClientHandler(socket, 0));

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端处理器：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 客户端处理器
 * 根据type来区分是做读工作还是写工作
 */
public class ClientHandler implements Runnable {

    private Socket socket;

    /**
     * 处理类型，0-读、1-写
     */
    private int type;

    public ClientHandler() {
        throw new IllegalArgumentException(&quot;不能使用没有参数的构造函数&quot;);
    }

    public ClientHandler(Socket socket, int type) {
        this.socket = socket;
        this.type = type;
    }

    @Override
    public void run() {
        if (type == 1) {
            // 进行写操作
            doWriteJob();
            return;
        }

        // 默认读操作
        doReadJob();
    }

    /**
     * 读操作
     */
    private void doReadJob() {
        Socket s = socket;
        InputStream inputStream;
        try {
            inputStream = s.getInputStream();
            Scanner scanner = new Scanner(inputStream);
            while (true) {
                String line = scanner.nextLine();
                if (null != line &amp;amp;&amp;amp; !&quot;&quot;.equals(line)) {
                    System.err.println(line);
                }
                // 如果已退出了，那么关闭连接
                if (&quot;已断开连接&quot;.equals(line)) {
                    socket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
            try {
                socket.close();
            } catch (IOException ioException) {
                ioException.printStackTrace();
            }
        }
    }

    /**
     * 写线程
     */
    private void doWriteJob() {
        Socket s = socket;
        try {
            Scanner scanner = new Scanner(System.in);
            while (true) {
                String output = scanner.nextLine();
                if (Objects.nonNull(output) &amp;amp;&amp;amp; !&quot;&quot;.equals(output)) {
                    SocketUtils.sendMsg(s, output);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println(&quot;错误发生了:&quot; + e.getMessage());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200721145521IO%E7%BB%93%E6%9E%9C%E5%9B%BE.jpg&quot; alt=&quot;IO结果图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;思考：&lt;strong&gt;当前这样实现有什么瓶颈，可能会出现什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;存在问题：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;服务端使用&lt;strong&gt;accept&lt;/strong&gt;阻塞接收线程，连接一个一个处理，在&lt;strong&gt;高并发下处理性能缓慢&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;没有连接的时候线程一直处于&lt;strong&gt;阻塞状态&lt;/strong&gt;造成&lt;strong&gt;资源的浪费&lt;/strong&gt;（如果使用多线程接收处理并发，那么没连接的时候造成多个线程的资源浪费）。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;21-整体思路&quot;&gt;2.1 整体思路&lt;/h2&gt;
&lt;p&gt;  那我们来看下&lt;strong&gt;NIO&lt;/strong&gt;是怎么解决上方的问题的，首先上这个&lt;strong&gt;demo&lt;/strong&gt;整体的架构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200721145529NIO%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg&quot; alt=&quot;NIO架构图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;大概的逻辑为&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;服务端将&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;注册到&lt;strong&gt;Selector&lt;/strong&gt;中，客户端连接进来的时候事件触发，将客户端的连接注册到selector中。&lt;/li&gt;
&lt;li&gt;主线程负责&lt;strong&gt;selector&lt;/strong&gt;的轮询工作，发现有事件可以处理就将其交给&lt;strong&gt;线程池&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;客户端同理分成两个部分，写操作和读操作，每个操作由一个线程单独完成；但是如果读操作处理使用while循环不断轮询等待接收的话，&lt;strong&gt;CPU会飙升&lt;/strong&gt;，所以需要客户端&lt;strong&gt;新建一个selector来解决这个问题&lt;/strong&gt;，注意这个&lt;strong&gt;selector&lt;/strong&gt;跟服务端不是同一个，没有啥关系。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;  代码分类大致跟IO写法一样，&lt;strong&gt;分成服务端、服务端处理器、客户端、客户端处理器&lt;/strong&gt;，下面为demo。&lt;/p&gt;
&lt;h2 id=&quot;22-代码&quot;&gt;2.2 代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ChatServer {

    private Selector selector;

    private ServerSocketChannel serverSocketChannel;

    private static final ExecutorService handlerPool = Executors.newFixedThreadPool(100);

    public ChatServer() throws IOException {
        this.selector = Selector.open();
        serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.configureBlocking(false);
        ServerSocket serverSocket = serverSocketChannel.socket();
        serverSocket.bind(new InetSocketAddress(9999));
        // 将服务端的socket注册到selector中，接收客户端，并将其注册到selector中，其本身也是selector中的一个I/O事件
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        System.err.println(&quot;聊天室服务端初始化结束&quot;);
    }

    /**
     * 启动方法
     * 1.监听，拿到之后进行处理
     */
    public void start() throws IOException {
        int count;
        while (true) {
            // 可能出现select方法没阻塞，空轮询导致死循环的情况
            count = selector.select();

            if (count &amp;gt; 0) {
                Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
                Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();
                    // 交给线程池处理
                    handlerPool.execute(new ServerHandler(key, selector));
                    // 处理完成后移除
                    iterator.remove();
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        new ChatServer().start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务端处理器：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class ServerHandler implements Runnable {

    private SelectionKey key;

    private Selector selector;

    public ServerHandler() {

    }

    /**
     * 本来可以通过key拿到selector，这里为了图方便就这样写了
     */
    public ServerHandler(SelectionKey key, Selector selector) {
        this.key = key;
        this.selector = selector;
    }

    @Override
    public void run() {
        try {
            if (key.isAcceptable()) {
                // 说明是服务端的事件，注意这里强转换为的是ServerSocketChannel
                ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                // 接收连接
                SocketChannel socket = channel.accept();
                if (Objects.isNull(socket)) {
                    return;
                }

                socket.configureBlocking(false);
                // 接收客户端的socket并且将其注册到服务端这边的selector中，注意客户端在此时跟服务端selector产生关联
                socket.register(selector, SelectionKey.OP_READ);
                System.err.println(&quot;服务端已接收连接&quot;);
            } else if (key.isReadable()) {
                // 客户端发送信息过来了
                doReadJob();
            }
        } catch (IOException e) {
            e.printStackTrace();
            // 错误处理
        }
    }

    /**
     * 读取操作
     */
    private void doReadJob() throws IOException {
        SocketChannel socketChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        int readCount = socketChannel.read(buffer);
        if (readCount &amp;gt; 0) {
            String msg = new String(buffer.array(), StandardCharsets.UTF_8);
            System.err.println(socketChannel.getRemoteAddress().toString() + &quot;的信息为:&quot; + msg);

            // 转发给其他客户端
            sendMsgToOtherClients(msg);
        }
    }

    /**
     * 转发消息给其他客户端
     *
     * @param msg 消息
     */
    private void sendMsgToOtherClients(String msg) throws IOException {

        SocketChannel self = (SocketChannel) key.channel();

        Set&amp;lt;SelectionKey&amp;gt; keys = selector.keys();
        Iterator&amp;lt;SelectionKey&amp;gt; iterator = keys.iterator();
        while (iterator.hasNext()) {
            SelectionKey selectionKey = iterator.next();
            SelectableChannel channel = selectionKey.channel();
            // 如果是本身或者不是socketChannel类型则跳过
            if (self.equals(channel) || channel instanceof ServerSocketChannel) {
                continue;
            }

            SocketChannel socketChannel = (SocketChannel) channel;
            ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8));
            socketChannel.write(byteBuffer);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class ChatClient {

    private Selector selector;

    private SocketChannel socketChannel;

    private static ExecutorService dealPool = Executors.newFixedThreadPool(2);

    public ChatClient() throws IOException {

        /*
         * 说明一下：
         * 客户端这边的selector跟刚才在服务端定义的selector是不同的两个selector
         * 客户端这边不需要selector也能实现功能，但是读取的时候必须不断的循环，会导致CPU飙升，
         * 所以使用selector是为了解决这个问题的，别跟服务端的selector搞混就好
         */
        selector = Selector.open();
        socketChannel = SocketChannel.open(new InetSocketAddress(&quot;localhost&quot;, 9999));
        socketChannel.configureBlocking(false);
        socketChannel.register(selector, SelectionKey.OP_READ);
    }


    public void start() throws IOException, InterruptedException {
        // 连接
//        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9999));
        while (!socketChannel.finishConnect()) {
            System.err.println(&quot;正在连接...&quot;);
            TimeUnit.MILLISECONDS.sleep(200);
        }

        System.err.println(&quot;连接成功&quot;);

        // 使用两个线程来分别处理读取和写操作
        // 写数据
        dealPool.execute(new ClientHandler(selector, socketChannel, 1));

        // 读取数据
        dealPool.execute(new ClientHandler(selector, socketChannel, 0));
    }


    public static void main(String[] args) throws IOException, InterruptedException {
        new ChatClient().start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端处理器：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class ClientHandler implements Runnable {

    private Selector selector;

    private SocketChannel socketChannel;

    /**
     * 0-读，1-写
     */
    private int type;

    public ClientHandler() {
    }

    public ClientHandler(Selector selector, SocketChannel socketChannel, int type) {
        // selector是为了解决读时候CPU飙升的问题，具体见客户端的启动类代码注释
        this.selector = selector;
        this.socketChannel = socketChannel;
        this.type = type;
    }

    @Override
    public void run() {
        try {
            if (type == 0) {
                doClientReadJob();
                return;
            }

            doClientWriteJob();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 写操作
     */
    private void doClientWriteJob() throws IOException {
        SocketChannel sc = socketChannel;
        Scanner scanner = new Scanner(System.in);
        while (true) {
            if (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (null != line &amp;amp;&amp;amp; !&quot;&quot;.equals(line)) {
                    ByteBuffer buffer = ByteBuffer.wrap(line.getBytes(StandardCharsets.UTF_8));
                    sc.write(buffer);
                }
            }
        }
    }

    /**
     * 读操作
     */
    private void doClientReadJob() throws IOException {
        SocketChannel sc = socketChannel;
        ByteBuffer buf = ByteBuffer.allocate(1024);
        while (true) {
            int select = selector.select();
            if (select &amp;gt; 0) {
                Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
                Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    // 这是必须的，不然下方的remove会出错
                    SelectionKey next = iterator.next();
                    // 这里因为只有本身这个客户端注册到客户端的selector中，所以有事件一定是它的，也就不用从key拿了，直接操作就行
                    buf.clear();
                    int read = sc.read(buf);
                    if (read &amp;gt; 0) {
                        String msg = new String(buf.array(), StandardCharsets.UTF_8);
                        System.err.println(msg);
                    }
                    // 事件处理完之后要移除这个key，否则的话selector.select()方法不会再读到这个key，即便有新的时间到这个channel来
                    iterator.remove();
                }
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;strong&gt;结果图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangweicheng/1583123/o_200721145536NIO%E7%BB%93%E6%9E%9C%E5%9B%BE.jpg&quot; alt=&quot;NIO结果图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在编写的过程中发现了以下两点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;select&lt;/strong&gt;方法之后如果存在&lt;strong&gt;key&lt;/strong&gt;，并且接下来的操作未对这个&lt;strong&gt;selectionKey&lt;/strong&gt;做&lt;strong&gt;remove&lt;/strong&gt;操作，那么&lt;strong&gt;下次的select不会再将其选入&lt;/strong&gt;，即便有事件发生，也就是说，&lt;strong&gt;select方法不会选择之前已经选过的key。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;selector.select()方法中偶尔会出现不阻塞的情况&lt;/strong&gt;。这就是&lt;strong&gt;NIO&lt;/strong&gt;中的空轮询&lt;strong&gt;bug&lt;/strong&gt;，也就是说，&lt;strong&gt;没有连接又不阻塞的话，while(true) ... 的写法就是一个死循环，会导致CPU飙升。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;  第二点问题在&lt;strong&gt;NIO&lt;/strong&gt;框架（如&lt;strong&gt;netty&lt;/strong&gt;）中都采用了比较好的解决方法，可以去查下如何解决的。接下来看下&lt;strong&gt;NIO&lt;/strong&gt;的写法是否解决了&lt;strong&gt;IO&lt;/strong&gt;写法中存在的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;服务端使用accept阻塞接收线程，连接一个一个处理，在高并发下处理性能缓慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;上述写法中还是使用&lt;strong&gt;一个ServerSocketChannel&lt;/strong&gt;来接收客户端，没有解决这个问题；但是可以通过&lt;strong&gt;使用线程池的方式来解决&lt;/strong&gt;。也就是说&lt;strong&gt;将服务端的事件分成两个部分，第一个部分为接收客户端，使用一个线程池来维护；第二个部分为客户端的事件处理操作，也维护一个线程池来执行这些事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这样性能上去了，&lt;strong&gt;由于selector的存在也不会出现资源浪费的事情&lt;/strong&gt;，&lt;strong&gt;netty&lt;/strong&gt;就是这么做的哦。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;没有连接的时候线程一直处于阻塞状态造成资源的浪费（如果使用多线程接收处理并发，那么没连接的时候造成多个线程的资源浪费）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;解决。NIO写法主要有&lt;strong&gt;selector&lt;/strong&gt;不断轮询，不会出现没连接不作为的情况，而且多个连接的话也没有问题（参考1的回答）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;  两种写法都有Reactor模式的影子，但是IO写法有明显的缺点就是如果没有连接会造成资源浪费的问题（采用多个接收连接的话更甚），而NIO中selector轮询机制就很好的解决了无连接时无作为的情况，并且在性能方面可以通过职责分类和线程池来得到改善，所以，NIO，永远滴神。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要压力，需要努力。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Jul 2020 15:12:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>本篇文章主要使用IO和NIO的形式来实现一个简单的聊天室，并且说明IO方法存在的问题，而NIO又是如何解决的。 大概的框架为，先提供思路和大概框架图——代码——问题及解决方式，这样会容易看一点。 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/13358026.html</dc:identifier>
</item>
<item>
<title>大型Java进阶专题(八) 设计模式之适配器模式、装饰者模式、观察者模式 - 有梦想的老王</title>
<link>http://www.cnblogs.com/whgk/p/13357954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whgk/p/13357954.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​ 今天开始我们专题的第八课了。本章节将介绍：三个设计模式，适配器模式、装饰者模式和观察者模式。通过学习适配器模式，可以优雅的解决代码功能的兼容问题。另外有重构需求的人群一定需要掌握装饰者模式。本章节参考资料书籍《Spring 5核心原理》中的第一篇 Spring 内功心法（Spring中常用的设计模式）（没有电子档，都是我取其精华并结合自己的理解，一个字一个字手敲出来的，如果觉得本文对你有用，请点个推荐）。&lt;/p&gt;
&lt;h2 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h2&gt;
&lt;h3 id=&quot;适配器模式的应用场景&quot;&gt;适配器模式的应用场景&lt;/h3&gt;
&lt;p&gt;​ 适配器模式（Adapter Pattern）是指将一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作，属于结构型设计模式。&lt;br/&gt;适配器适用于以下几种业务场景：&lt;br/&gt;​ 1、已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。&lt;br/&gt;​ 2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。生活中也非常的应用场景，例如电源插转换头、手机充电转换头、显示器转接头。&lt;/p&gt;
&lt;p&gt;在中国民用电都是 220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我 们给手机充电时就需要使用电源适配器来进行转换。下面我们有代码来还原这个生活场 景，创建 AC220 类，表示 220V 交流电：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wangzhongyuan
 */
public class AC220 {
    public int outputAC220V(){
        int output = 220;
        System.out.println(&quot;提供220V交流电&quot;);
        return output;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建5V电源的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wangzhongyuan
 */
public interface DC5 {
    int output5V();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建提供5V电源的适配器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wangzhongyuan
 */
public class PowerAdapter implements DC5{
    AC220 ac220;

    public PowerAdapter(AC220 ac220) {
        this.ac220 = ac220;
    }

    @Override
    public int output5V() {
        int outputAC220V = ac220.outputAC220V();
        System.out.println(&quot;将220v转换成5v&quot;);
        return outputAC220V/44;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/20 11:17 下午
 */
public class DemoTest {

    public static void main(String[] args) {
        DC5 powerAdapter = new PowerAdapter(new AC220());
        powerAdapter.output5V();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200721224931243-1280730049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的代码样式可以看出，适配器就是通过增加一个适配器类持有原有提供者的对象，实现了二者的兼容。&lt;/p&gt;
&lt;h3 id=&quot;适配模式的优缺点&quot;&gt;适配模式的优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点：&quot;&gt;优点：&lt;/h4&gt;
&lt;p&gt;1、能提高类的透明性和复用，现有的类复用但不需要改变。&lt;/p&gt;
&lt;p&gt;2、目标类和适配器类解耦，提高程序的扩展性。&lt;/p&gt;
&lt;p&gt;3、在很多业务场景中符合开闭原则。&lt;/p&gt;
&lt;h4 id=&quot;缺点：&quot;&gt;缺点：&lt;/h4&gt;
&lt;p&gt;1、适配器编写过程需要全面考虑，可能会增加系统的复杂性。&lt;/p&gt;
&lt;p&gt;2、增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。&lt;/p&gt;
&lt;h2 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h2&gt;
&lt;h3 id=&quot;装饰者模式的应用场景&quot;&gt;装饰者模式的应用场景&lt;/h3&gt;
&lt;p&gt;​ 装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对 象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能），属于结构型模式。 装饰者模式在我们生活中应用也比较多如给煎饼加鸡蛋；给蛋糕加上一些水果；给房子 装修等，为对象扩展一些额外的职责。装饰者在代码程序中适用于以下场景：&lt;/p&gt;
&lt;p&gt;1、用于扩展一个类的功能或给一个类添加附加职责。&lt;/p&gt;
&lt;p&gt;2、动态的给一个对象添加功能，这些功能可以再动态的撤销。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;来看一个这样的场景，上班族白领其实大多有睡懒觉的习惯，每天早上上班都是踩点，于是很多小伙伴为了多赖一会儿床都不吃早餐。那么，也有些小伙伴可能在上班路上碰 到卖煎饼的路边摊，都会顺带一个到公司茶水间吃早餐。卖煎饼的大姐可以给你的煎饼 加鸡蛋，也可以加香肠。&lt;/p&gt;
&lt;p&gt;创建煎饼类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/20 11:57 下午
 */
public class Battercake {

    public String getMsg(){
        return &quot;煎饼&quot;;
    }

    public int getPrice(){
        return 5;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给煎饼加个蛋：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/20 11:59 下午
 */
public class BattercakeWithEgg extends Battercake{
    @Override
    public String getMsg() {
        return super.getMsg() + &quot;加鸡蛋&quot;;
    }

    @Override
    public int getPrice() {
        return super.getPrice() + 1;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再加个烤肠：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:00 上午
 */
public class BatterCakeWithEggAndSausage extends BattercakeWithEgg{
    @Override
    public String getMsg() {
        return super.getMsg() +&quot;加烤肠&quot;;
    }

    @Override
    public int getPrice() {
        return super.getPrice() + 3;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:01 上午
 */
public class DemoTest {

    public static void main(String[] args) {
        BatterCakeWithEggAndSausage batterCakeWithEggAndSausage = new BatterCakeWithEggAndSausage();
        String msg = batterCakeWithEggAndSausage.getMsg();
        int price = batterCakeWithEggAndSausage.getPrice();
        System.out.println(&quot;买了：&quot;+msg+&quot;，价格为：&quot;+price);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;​&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200721224952971-1595591694.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果没有问题，但是如果用户需要一个加 2 个鸡蛋加 1 根香肠的煎饼，那么用我们现在的类结构是创建不出来的，也无法自动计算出价格，除非再创建一个类做定制。 如果需求再变，一直加定制显然是不科学的。那么下面我们就用装饰者模式来解决上面 的问题。&lt;/p&gt;
&lt;p&gt;创建煎饼抽象类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:18 上午
 */
public abstract class AbstractBatterCake {
    protected abstract String getMsg();
    protected abstract int getPrice();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建基础套餐煎饼：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:19 上午
 */
public class BatterCakeWithBase extends AbstractBatterCake{
    @Override
    protected String getMsg() {
        return &quot;煎饼&quot;;
    }

    @Override
    protected int getPrice() {
        return 5;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建额外套餐的抽象装饰类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:21 上午
 */
public abstract class BatterCakeDecorator extends AbstractBatterCake{
    AbstractBatterCake batterCake;

    public BatterCakeDecorator(AbstractBatterCake batterCake) {
        this.batterCake = batterCake;
    }

    protected abstract void doSomething();

    @Override
    protected String getMsg() {
        return this.batterCake.getMsg();
    }

    @Override
    protected int getPrice() {
        return this.batterCake.getPrice();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建加鸡蛋套餐：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/20 11:59 下午
 */
public class BattercakeWithEgg extends BatterCakeDecorator{


    public BattercakeWithEgg(AbstractBatterCake batterCake) {
        super(batterCake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    public String getMsg() {
        return super.getMsg() + &quot;加鸡蛋&quot;;
    }

    @Override
    public int getPrice() {
        return super.getPrice() + 1;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建加烤肠套餐：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:00 上午
 */
public class BatterCakeWithSausage extends BatterCakeDecorator{

    public BatterCakeWithSausage(AbstractBatterCake batterCake) {
        super(batterCake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    public String getMsg() {
        return super.getMsg() +&quot;加烤肠&quot;;
    }

    @Override
    public int getPrice() {
        return super.getPrice() + 3;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study;

/**
 * @author wang.zhongyuan
 * @version 1.0
 * @date 2020/7/21 12:01 上午
 */
public class DemoTest {

    public static void main(String[] args) {
        AbstractBatterCake batterCake;
        batterCake = new BatterCakeWithBase();
        batterCake = new BattercakeWithEgg(batterCake);
        batterCake = new BatterCakeWithSausage(batterCake);
        //再加个鸡蛋
        batterCake = new BattercakeWithEgg(batterCake);
        System.out.println(batterCake.getMsg()+&quot;，价格：&quot;+batterCake.getPrice());
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200721225013648-1938096649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;装饰者模式最本质的特征是讲原有类的附加功能抽离出来，简化原有类的逻辑。通过这样两个案例，我们可以总结出来，其实抽象的装饰者是可有可无的，具体可以根据业务模型来选择。&lt;/p&gt;
&lt;h3 id=&quot;装饰者模式与适配器模式对比&quot;&gt;装饰者模式与适配器模式对比&lt;/h3&gt;
&lt;p&gt;装饰者和适配器模式都是包装模式（Wrapper Pattern），装饰者也是一种特殊的代理模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;               装饰者模式                                                                                                                   适配器模式 
形式 是一种非常特别的适配器模式 没有层级关系，                装饰器模式有层级关系 
定义 装饰者和被装饰者都实现同一个接口，                                    适配器和被适配者没有必然的联系，通 常是采用继承或代理的形式进行包装 
                主要目的是为了扩展之后依旧保 留 OOP 关系 
关系 满足 is-a 的关系                                                                                           满足 has-a 的关系 
功能 注重覆盖、扩展                                                                                                              注重兼容、转换 
设计 前置考虑                                                                                                                                 后置考虑
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;装饰者模式的优缺点&quot;&gt;装饰者模式的优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点：-2&quot;&gt;优点：&lt;/h4&gt;
&lt;p&gt;1、装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。&lt;/p&gt;
&lt;p&gt;2、通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。&lt;/p&gt;
&lt;p&gt;3、装饰者完全遵守开闭原则。&lt;/p&gt;
&lt;h4 id=&quot;缺点：-2&quot;&gt;缺点：&lt;/h4&gt;
&lt;p&gt;1、会出现更多的代码，更多的类，增加程序复杂性。&lt;/p&gt;
&lt;p&gt;2、动态装饰时，多层装饰时会更复杂。&lt;/p&gt;
&lt;h2 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h2&gt;
&lt;h3 id=&quot;观察者模式的应用场景&quot;&gt;观察者模式的应用场景&lt;/h3&gt;
&lt;p&gt;​ 观察者模式（Observer Pattern）定义了对象之间的一对多依赖，让多个观察者对象同 时监听一个主体对象，当主体对象发生变化时，它的所有依赖者（观察者）都会收到通 知并更新，属于行为型模式。观察者模式有时也叫做发布订阅模式。观察者模式主要用 于在关联行为之间建立一套触发机制的场景。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;​ 小伙伴们肯定都刷过抖音，遇到喜欢的作品都会点个❥喜欢，我们通过模拟喜欢这个事件来实践下观察者模式。当你点击喜欢时，会触发两个事件，一个喜欢数量会增加+1，二是作者会受到消息。你可能会想到MQ，异步队列等，其实JDK本身就提供这样的API。&lt;/p&gt;
&lt;p&gt;创建事件模型类，用于区分什么样的事件，观察者可以根据不同事件类型做不同处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo4;

/**
 * 事件模型
 * @Author wangzhongyuan
 * @Date 2020/7/21 11:28
 * @Version 1.0
 **/
public enum EventModel {
    LIKE_EVENT(&quot;喜欢事件&quot;,1,null),
    MCOMENT_ENVET(&quot;评论事件&quot;,2,null)
    ;

    private String message;
    private int type;
    private Object date;

    EventModel(String message, int type, Object date) {
        this.message = message;
        this.type = type;
        this.date = date;
    }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建事件类，被观察者对象，调用方可以向该对象中传送事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo4;

import java.util.Observable;

/**
 * 事件总线(被观察者)
 * @Author wangzhongyuan
 * @Date 2020/7/21 11:24
 * @Version 1.0
 **/
public class EventBus extends Observable{
    /**
     * 被观察者方法
     * @param eventModel
     */
    public void postEvent(EventModel eventModel){
        System.out.println(&quot;推送事件&quot;);
        setChanged();
        //通知观察者
        notifyObservers(eventModel);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建不同业务的观察者:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo4;

import java.util.Observable;
import java.util.Observer;

/**
 * 观察者1
 *
 * @Author 19054253
 * @Date 2020/7/21 11:32
 * @Version 1.0
 **/
public class OneObserver implements Observer {

    public void update(Observable o, Object arg) {
        System.out.println(&quot;观察1,监听到了事件,触发:给作者推送消息!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo4;

import java.util.Observable;
import java.util.Observer;

/**
 * 观察者2
 *
 * @Author 19054253
 * @Date 2020/7/21 11:48
 * @Version 1.0
 **/
public class TwoObserver implements Observer {

    public void update(Observable o, Object arg) {
        System.out.println(&quot;观察2,监听到了事件,触发:喜欢总数+1&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用测试:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.study.demo4;

/**
 * @Author wangzhongyuan
 * @Date 2020/7/21 11:35
 * @Version 1.0
 **/
public class DemoTest {
    public static void main(String[] args) {
        //被观察者
        EventBus eventBus = new EventBus();
        //观察者
        OneObserver oneObserver = new OneObserver();
        TwoObserver twoObserver = new TwoObserver();
        //监听观察者
        eventBus.addObserver(oneObserver);
        eventBus.addObserver(twoObserver);
        //被观察者触发事件
        eventBus.postEvent(EventModel.LIKE_EVENT);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874710/202007/874710-20200721225104495-432438366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面代码可以看出来，观察者模式的本质就是，被观察者对象持有观察者对象的引用，由被观察者去通知了观察者去做了某件事。JDK源码中，观察者模式也应用非常多。例如java.awt.Event就是观察者模式的一种，只不过Java很少被用来写桌面程序。以上就是我模拟的事件机制。&lt;/p&gt;
&lt;h3 id=&quot;观察模式的优缺点&quot;&gt;观察模式的优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点：-3&quot;&gt;优点：&lt;/h4&gt;
&lt;p&gt;1、观察者和被观察者之间建立了一个抽象的耦合。&lt;br/&gt;2、观察者模式支持广播通信。&lt;/p&gt;
&lt;h4 id=&quot;缺点：-3&quot;&gt;缺点：&lt;/h4&gt;
&lt;p&gt;1、观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。&lt;br/&gt;2、使用要得当，要避免循环调用。&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jul 2020 14:53:00 +0000</pubDate>
<dc:creator>有梦想的老王</dc:creator>
<og:description>前言 ​	今天开始我们专题的第八课了。本章节将介绍：三个设计模式，适配器模式、装饰者模式和观察者模式。通过学习适配器模式，可以优雅的解决代码功能的兼容问题。另外有重构需求的人群一定需要掌握装饰者模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whgk/p/13357954.html</dc:identifier>
</item>
<item>
<title>程序员修神之路--简约而不简单的分布式通信基石 - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/13357643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/13357643.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/157718/202007/157718-20200721214806192-550792969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分布式系统可以总结为是处于不同物理位置的多个进程组成的整体，为了确保这个整体有效并且高效的对外提供服务，每个节点之间都有可能需要进行通信来交换信息，而这个交换信息的过程多数使用的是tcp协议。tcp协议是位于ip层之上的传输层协议，在这个传输层里有两个比较重要的协议：tcp和udp。对于应用层的开发人员来说，用的最多的就是这两个协议，这也是一些面试官必问的知识点之一&lt;/p&gt;
&lt;p&gt;无论是tcp还是udp，都是建立在ip+端口的规则之上，什么意思呢？也就是说采用tcp和udp的进程都需要一个端口来读取和写入数据。&lt;/p&gt;
&lt;h3 id=&quot;tcp协议&quot;&gt;TCP协议&lt;/h3&gt;
&lt;p&gt;tcp协议是可靠的协议，而且是面向连接的，建立连接的过程会经过三次握手。为什么会是三次握手而不是二次或者四次呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3488071278,382537329&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说到这个问题，可以抽象出一个场景，怎么样才能确定一端是和另外一端互通的呢？其实很简单，一端发送给另一端的消息能顺利给我答复，这就说明两端是联通的。tcp协议的三次握手恰好说明了这一点，A和B通信，只要三次握手，A能得到B的答复，B也能得到A的答复。&lt;/p&gt;
&lt;p&gt;基于ip层发送的报文，在网络中是无法确定是否正确到达对方的。tcp协议在ip协议之上添加了一系列数据结构和算法来保证tcp的数据正确到达。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;tcp的数据包是有编号的，这么做主要是为了解决顺序问题，如果没有编号，对方怎么确定顺序呢？另外一点，编号是为了发送方来确认哪些包已经正确到达对方&lt;/li&gt;
&lt;li&gt;当tcp的数据包被接收方接收，接收方需要发送确认包给发送方，发送方在接收到确认包之后会把对应的数据包做状态修改，由于每个数据包其实有超时机制，在超时之后，发送方会进行重试&lt;/li&gt;
&lt;li&gt;tcp是面向字节流的，发送的时候发的是一个字节流，这是tcp自己的状态维护的事情。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说了这么多，其实可以把tcp看做是一个有状态的协议，它可以根据网络状况，对方接收情况等诸多因素来调整自己的发送状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;upp协议&quot;&gt;UPP协议&lt;/h3&gt;
&lt;p&gt;相对于tcp协议来说，udp要简单很多&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;udp协议不需要建立连接，这就意味着发送方只要知道对方的ip和端口，就可以发送，基于这一点可以做广播。&lt;br/&gt;2.udp协议不负责可靠交付，因为它不像tcp协议那样有一堆的算法和数据结构来做保证。&lt;/li&gt;
&lt;li&gt;udp是基于数据报形式的，一个一个的发，一个一个的接收。而且udp数据的发送不会根据因为网络环境的阻塞而改变&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;udp基于以上特性可以在网络环境比较好或者对于丢包不敏感的应用中使用。udp在舍弃了重传，顺序等一些列特性之后，处理速度特别快，在一些不敏感但是实时性要求比较高的场景中应用非常广泛。&lt;/p&gt;
&lt;h3 id=&quot;socket&quot;&gt;Socket&lt;/h3&gt;
&lt;p&gt;在有了tcp和udp协议之后，进程间通信的基石就有了。但是总不能每次通信自己都需要写tcp的三次握手等这些复杂过程吧。为了屏蔽这些复杂的过程，使通信程序简单，在tcp和udp协议之上，便抽象出来了socket这个概念。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;socket是区分服务端和客户端的，本地的socket与远程的一个socket建立连接的过程，其实就是tcp协议三次握手的过程。一旦socket连接建立，就可以利用socket抽象出来的read或者write方法来进行通信了。&lt;/p&gt;
&lt;p&gt;socket需要指定使用的IP协议，还需要指定使用的是tcp还是udp协议。基于tcp协议的服务端的socket需要bind一个端口来listen并且accept客户端的socket连接。这也是服务端socket和客户端socket的一个区别。&lt;br/&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202007/0crhYDf38_WT4E.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于udp来说，过程有点不一样。udp是没有连接的，一是不需要三次握手，二是不需要listen和connect，但是仍然需要ip和端口bind，要不然远端的数据到来的时候，系统会找不到接收程序的。UDP是没有连接状态的，因而不需要每次连接都建立一组Socket，而是只用一个Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，调用sendto和recvfrom，都需要传入 IP 地址和端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/553/5534532/202007/0SaysKcdz_7jnL.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于tcp的socket在内核中都有一个发送缓冲区和接收缓冲区，tcp的双工工作模式以及tcp的滑动窗口就是依赖于这两个独立的buffer以及buffer的数据填充状态。接收缓冲区把数据缓存入内核之中，如果对应的应用一直没有调用socket的read方法进行数据读取，则此数据会一直被缓存在接收缓冲区中，如果接收缓冲区满了，便会通知对方socket，以调整对方socket的发送窗口大小，这就是滑动窗口的实现。如果对方仍然持续发送数据，接收方在接收缓冲区没有被读取的情况下将丢弃后到的数据，这就是tcp的流量控制。对于udp来说，它没有真正的发送缓冲区，只要有数据就会发送，无论对方能否正常正确接收，这也是udp丢包的原因之一，但是udp的socket 和tcp的socket一样都会有接收缓冲区，而且行为也一样。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;有的面试官吹水，号称http长连接，这个说法其实是不准确的，长连接和短连接是针对tcp协议而言，http只是建立在tcp/ip协议之上的应用层的一个协议。总体而言，tcp和udp设计的数据结构和算法有很多，这里只是粗略的说了一下，有兴趣的同学可以去研究tcp协议那本书。&lt;/p&gt;
</description>
<pubDate>Tue, 21 Jul 2020 13:49:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>分布式系统可以总结为是处于不同物理位置的多个进程组成的整体，为了确保这个整体有效并且高效的对外提供服务，每个节点之间都有可能需要进行通信来交换信息，而这个交换信息的过程多数使用的是tcp协议。tcp协</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/13357643.html</dc:identifier>
</item>
</channel>
</rss>