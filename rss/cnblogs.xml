<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud系列文，Feign整合Ribbon和Hysrix - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/10928778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/10928778.html</guid>
<description>&lt;p&gt;    在本博客之前的Spring Cloud系列里，我们讲述了Feign的基本用法，这里我们将讲述下Feign整合Ribbon实现负载均衡以及整合Hystrix实现断路保护效果的方式。    &lt;/p&gt;
&lt;h4&gt;1 准备Eureka服务器以及多个服务提供者&lt;/h4&gt;
&lt;p&gt;    这里，我们将重用之前博文里讲过的案例，提供的两个（即主从）Eureka服务项目以及三个服务提供者的项目。随后在此基础上，在服务调用者的项目中，通过Feign以负载均衡的方式调用三个服务提供者所提供的sayHello方法。    &lt;/p&gt;
&lt;h4&gt;2 在客户端引入Ribbon&lt;/h4&gt;
&lt;p&gt;在FeignDemo-ServiceCaller项目里开发Fegin整合Ribbon，具体的步骤如下。&lt;/p&gt;
&lt;p class=&quot;a4&quot;&gt; 在pom.xml中，引入Ribbon依赖包，关键代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1       &amp;lt;dependency&amp;gt;
2          &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
3          &amp;lt;artifactId&amp;gt;spring-cloud-ribbon&amp;lt;/artifactId&amp;gt;
4       &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     在ControllerForFeignRibbon.java中，编写Feign以Ribbon负载均衡的方式调用服务的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import的代码
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这和Ribbon Provider中的applicationname一致&lt;/span&gt;
@FeignClient(value = &quot;sayHelloAvoidCopy&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FeignClientRibbonTool{
      @RequestMapping(method &lt;/span&gt;= RequestMethod.GET, value = &quot;/sayHello/{username}/avoidCopy&quot;&lt;span&gt;)
       String sayHelloAsRibbon(@PathVariable(&lt;/span&gt;&quot;username&quot;&lt;span&gt;) String username);
}

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerForFeignRibbon {    
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; FeignClientRibbonTool tool;
     @RequestMapping(value &lt;/span&gt;= &quot;/callHelloAsRibbon/{username}&quot;, method =&lt;span&gt; RequestMethod.GET)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String callHelloAsRibbon(@PathVariable(&quot;username&quot;&lt;span&gt;) String username) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tool.sayHelloAsRibbon(username);
    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在上述代码里，，我们定义了一个名为FeignClientRibbonTool的接口；在第3行中，我们通过@FeignClient注解指定了该Feign接口将会调用名为sayHello的服务。请注意，这里的sayHello命名需要和EurekaRibbonDemo-ServiceProviderOne等项目中application.yml中的相应配置一致。&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;    在第10行中，我们通过@RestController注解定义了一个名为ControllerForFeignRibbon的控制器类，在其中的第14行的callHelloAsRibbon中，我们是通过Feign接口中的sayHelloAsRibbon方法调用服务的。&lt;/p&gt;
&lt;p class=&quot;a4&quot;&gt;     在application.yml中，编写Ribbon的相关配置信息，关键代码如下。&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;1   sayHello:&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;2     ribbon:&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;3       listOfServer: http://localhost:1111/,http://localhost:2222/,http://localhost:3333&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;4       ConnectionsTimeout: 1000&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;5   ribbon:&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;6       ConnectionsTimeout: 2000  &lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;    在第1~4行，我们通过配置指定了基于ribbon的多台服务器，它们将以负载均衡的方式承担请求url，而且还指定了连接超时的时间。从第1行我们能看到，这个配置是针对sayHello这个服务实例的。而在第5行和第6行，我们配置了全局性的ribbon属性，这里也配置了连接超时时间。&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;    完成开发后，启动定义在表6.2中的两台Eureka服务器、三台服务提供者和一台服务调用者程序后，在浏览器中多次输入http://localhost:8080/callHelloAsRibbon/Peter以调用服务，这时我们能看到有如下输出。从输出结果来看，我们以Feign的形式调用的请求确实被均衡地转发到3台服务提供者的机器上。&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;    1   Hello Ribbon, there are Server1, my name is:Peter&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;    2   Hello Ribbon, there are Server2, my name is:Peter&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;    3   Hello Ribbon, there are Server3, my name is:Peter&lt;/p&gt;
&lt;p class=&quot;a1&quot;&gt;    这里我们来总结一下Feign整合Ribbon的要点。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;    第一，多个服务器提供者的实例名应当一致，比如这里都是sayHello。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;    第二，在Feign的接口中，是通过@FeignClient的注解调用服务提供者的方法的。&lt;/p&gt;
&lt;p&gt;    第三，这里我们是在application.yml配置文件中指定Ribbon的各种参数，也可以通过@Configuration注解在Java文件中配置Ribbon的参数。&lt;/p&gt;
&lt;h4&gt;3 在客户端引入Hystrix(Feigh整合Hystrix)&lt;/h4&gt;
&lt;p class=&quot;a&quot;&gt;    在通过Feign调用服务时，同样不能保证服务一定可用，为了提升客户体验，这里可以通过引入Hystrix对访问请求进行“容错保护”。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;     在FeignDemo-ServiceCaller的pom.xml中，增加Hystrix的依赖包，关键代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1       &amp;lt;dependency&amp;gt;
2          &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; 
3          &amp;lt;artifactId&amp;gt;spring-cloud-hystrix&amp;lt;/artifactId&amp;gt;
4       &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 还是在FeignDemo-ServiceCaller项目的application.yml配置文件中，通过如下配置项启动Hystrix模式，关键代码如下。&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;1   feign:&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;2       hystrix:&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;3           enabled: true   &lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;    此外，还可以通过如下代码配置针对sayHelloServiceProvider服务的hystrix参数。其中，第3行指定了hystrix所作用的服务名，第7行指定了请求时间一旦超过1000毫秒（也就是1秒），就会启动熔断模式，调用定义在回退方法中的业务动作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;   hystrix:
&lt;/span&gt;2&lt;span&gt;       command:
&lt;/span&gt;3&lt;span&gt;           sayHelloServiceProvider:
&lt;/span&gt;4&lt;span&gt;               execution:
&lt;/span&gt;5&lt;span&gt;                  isolations:
&lt;/span&gt;6&lt;span&gt;                      threads:
&lt;/span&gt;7                         timeoutInMilliseconds: 1000   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     在启动类ServiceCallerApp.java中，增加启动hystrix断路器的注解，如第5行所示，这个类的关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import方法&lt;/span&gt;
2&lt;span&gt;   EnableFeignClients
&lt;/span&gt;3&lt;span&gt;   @EnableDiscoveryClient
&lt;/span&gt;4&lt;span&gt;   @SpringBootApplication
&lt;/span&gt;5&lt;span&gt;   @EnableCircuitBreakers
&lt;/span&gt;6   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCallerApp
&lt;/span&gt;7&lt;span&gt;   {
&lt;/span&gt;8       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略其他代码&lt;/span&gt;
9   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 新建一个名为ControllerForFeignHystrix.java的控制器类，代码如下。&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;1   //省略必要的package和import代码&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;2   @FeignClient(value = &quot;sayHelloServiceProvider&quot;,fallback=FeignClientHystrixToolFallback.class)&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;3   interface FeignClientHystrixTool{&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;4       @RequestMapping(method = RequestMethod.GET, value = &quot;/hello/{name}&quot;)&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;5       String sayHelloInClient(@RequestParam(&quot;name&quot;) String name);&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;6   }&lt;/p&gt;
&lt;p class=&quot;a2&quot;&gt;在第3行中，我们定义了一个名为FeignClientHystrixTool的接口；在第2行的注解中，我们定义了它将以Feign的形式调用sayHelloServiceProvider中的服务，并且通过fallback配置指定一旦出现调用异常，将调用FeignClientHystrixToolFallback类中的回退方法。&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;7   @Component&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;8   class FeignClientHystrixToolFallback implements FeignClientHystrixTool{&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;9       public String sayHelloInClient(String name)&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;10      { return &quot;In Fallback Function.&quot;;    }  &lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;11  }&lt;/p&gt;
&lt;p class=&quot;a1&quot;&gt;在第8行的FeignClientHystrixToolFallback类中，我们将定义针对FeignClientHystrixTool接口的回退方法。&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p class=&quot;a5&quot;&gt;该类必须和第2行中fallback指定的类同名，而且，该类需要实现（implements）FeignClientHystrixTool接口，在其中的sayHelloInClient方法中定义了回退动作，这里的动作是打印一段话。&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;a3&quot;&gt;12  @RestController&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;13  public class ControllerForFeignHystrix {       &lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;14      @Autowired&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;15      private FeignClientHystrixTool tool;   &lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;16      @RequestMapping(value = &quot;/callHelloAsHystrix/{username}&quot;, method = RequestMethod.GET)&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;17      public String callHelloAsHystrix(@PathVariable(&quot;username&quot;) String username)&lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;18      { return tool.sayHelloInClient(username);}  &lt;/p&gt;
&lt;p class=&quot;a3&quot;&gt;19  }&lt;/p&gt;
&lt;p class=&quot;a1&quot;&gt;    在第13行中，我们定义了一个包含@RestController注解的控制器类ControllerForFeignHystrix，在其中第17行的callHelloAsHystrix方法中，我们是以Feign的形式调用sayHelloInClient方法的。&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;    至此，完成代码的编写工作。我们依次启动FeignDemo-Server、FeignDemo-ServiceProvider和FeignDemo-ServiceCaller项目，随后在浏览器中输入http://localhost:8080/callHelloAsHystrix/Peter，此时能看到“hello Peter”的输出，这个是正常的调用流程。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;    如果我们关闭FeignDemo-ServiceProvider项目，也就是说sayHelloServiceProvider服务不可用了，如果再次在浏览器中输入&lt;a href=&quot;http://localhost:8080/callHelloAsHystrix/Peter&quot;&gt;http://localhost:8080/callHelloAsHystrix/Peter&lt;/a&gt;，此时就会走熔断保护的流程，触发FeignClientHystrixToolFallback 类中的sayHelloInClient方法，在浏览器中输出“In Fallback Function“的字样。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;本文谢绝转载，如果要代码，请和作者联系。Spring Cloud相关博文如下：&lt;/p&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/10448098.html&quot;&gt;Spring Cloud微服务系列文，服务调用框架Feign&lt;/a&gt;  &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_1&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/10129378.html&quot;&gt;Spring Cloud微服务系列文，Hystrix与Eureka的整合&lt;/a&gt;  &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_2&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9972861.html&quot;&gt;架构师系列文：通过Spring Cloud组件Hystrix合并请求&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_3&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9874631.html&quot;&gt;架构师入门：Spring Cloud系列，Hystrix与Eureka的整合&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_4&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9557991.html&quot;&gt;Hystrix针对不可用服务的保护机制以及引入缓存&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_5&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9399209.html&quot;&gt;通过案例了解Hystrix的各种基本使用方式&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_6&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8999772.html&quot;&gt;Ribbon整合Eureka组件，以实现负载均衡&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_7&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8648420.html&quot;&gt;Spring Clould负载均衡重要组件：Ribbon中重要类的用法&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_8&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8481756.html&quot;&gt;架构师入门：搭建双注册中心的高可用Eureka架构（基于项目实战）&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_9&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8471364.html&quot;&gt;架构师入门：搭建基本的Eureka架构（从项目里抽取）&lt;/a&gt; &lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_10&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8468934.html&quot;&gt;借助Maven入手Spring Boot第一个程序&lt;/a&gt; &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 23:29:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>在本博客之前的Spring Cloud系列里，我们讲述了Feign的基本用法，这里我们将讲述下Feign整合Ribbon实现负载均衡以及整合Hystrix实现断路保护效果的方式。 1 准备E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaArchitect/p/10928778.html</dc:identifier>
</item>
<item>
<title>推荐一款基于 AI 开发的 IED 插件，帮助提升编码效率 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/10928481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/10928481.html</guid>
<description>&lt;p&gt;最近在浏览技术社区的时候，发现了一款神奇 IED 插件，官网称可以利用 AI 帮助程序员写代码，一下子吸引了我的好奇心。赶紧下载下来使用一番，感谢确实蛮神奇，可以火速提升编程效率。&lt;/p&gt;
&lt;p&gt;这款插件叫做 aixcoder，我们可以从插件名字就可以看出他的特殊性，是一个利用 AI 技术帮助大家提升编程效率的插件。&lt;/p&gt;
&lt;p&gt;根据官网的信息得知，智能编程助手插件有三大特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;智能代码提示，她用强大的深度学习引擎，能给出更加精确的代码提示；&lt;/li&gt;
&lt;li&gt;代码风格检查，她有代码风格智能检查能力，帮助开发者改善代码质量；&lt;/li&gt;
&lt;li&gt;编程模式学习，她能自主学习开发者的编程模式，边用边学，越用越强；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;功能很强大，但使用起来很简单，aixcoder 已经集成到了 IDE，以一个IDE自动代码补全工具的方式出现，一次能写一整行，还有多行的代码补全，用起来和常规的IDE代码提示一样，比那个提示的长很多，速度也跟得上，感觉在开发过程中非常有用。&lt;/p&gt;
&lt;p&gt;写起 Java 代码来，走路带风。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/it/ai1.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我们现在都在使用 Spring Boot，因此官方亲切的对 Spring Boot 进行了待遇处理。在写后端框架如【Spring Boot】的时候，也发现补全的非常好，应该是做了对特定框架的优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/it/ai2.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随手试了一下，发现这款插件同时支持 Python：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/it/ai3.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C++ 也是支持的，感觉也不错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/it/ai4.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还能在IDE中搜索相关代码&amp;amp;功能，这个小功能也是我比较喜欢的，身为程序员，少不了重复造轮子的工作，我很多时候都需要在搜索引擎中去搜索具体的功能实现方式，他们直接把相关功能做到IDE里面了，省去了切换浏览器来回筛选的时间成本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/it/ai5.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要是能够自动按照我们的思考编写代码，辅助我们的程序开发工作，这样可以把繁琐的「搬砖」、重复性质的劳动交给人工智能，让人去做真正有创造力的工作。&lt;/p&gt;
&lt;p&gt;试用完之后感慨万千，现在人工智能在不断在各个行业渗透，终于也来到了编程这个领域，那么 AI 究竟能给程序员们带来一些什么，我感觉有以下几点可以帮助我们：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高效率&lt;/strong&gt; 减少软件开发人员的简单重复劳动，具体什么是重复劳动呢？我觉得主要就是&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重复造轮子：这个需要解决的就是程序员自己代码的复用性的问题，或者通过一些配置工具自动生成一部分代码片段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;优质代码的参考和使用：github等开放平台上面有很多优质的代码，但真正想获取到合适自己使用的代码是有时间成本的，来回筛选会浪费很多宝贵的开发时间，如果人工智能能够知道代码的具体实现功能，方面我们在需要的时候自动把对应的代码片段或者是文件送到我们眼前，这个也能大幅度提高编程的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;代码规范性：在一个项目中，命名规范的统一会帮助我们减少很多沟通上的成本，如果人工智能的工具能够根据我们完成的功能需求，自动为我们完成明明的规范化和自动化，形成统一的标准，这样的话，对于人数比较多的开发团队而言，会非常方便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，这类型的产品毕竟是需要我们程序员使用，我觉得也必须做到两点才能让我们使用的更好：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符合程序员习惯的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即安即用，直接安装在IDE环境中，和使用IDE编译器自带的短提示使用方式一致需要一致，就像这个小工具一样，这样我们在使用过程中才没有什么学习成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性的重要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保您的代码安全隐私（企业端支持私有部署），这个产品的用户手册中写了不会保存用户的代码，并且加密传输的，这个还是很考虑到开发者对于代码的隐私要求，尤其是一些公司的软件开发项目，这一点上还是很不错的。&lt;/p&gt;
&lt;p&gt;很有意思的产品，现在实际开发中，我用上了其中的部分功能，大家也可以试试。这是他们的官网&lt;a href=&quot;https://www.aixcoder.com/&quot; class=&quot;uri&quot;&gt;https://www.aixcoder.com/&lt;/a&gt;，大家可以下载这款插件去试用。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 16:18:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<og:description>最近在浏览技术社区的时候，发现了一款神奇 IED 插件，官网称可以利用 AI 帮助程序员写代码，一下子吸引了我的好奇心。赶紧下载下来使用一番，感谢确实蛮神奇，可以火速提升编程效率。 这款插件叫做 ai</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ityouknow/p/10928481.html</dc:identifier>
</item>
<item>
<title>Eventbus 使用方法和原理分析 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/10926138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/10926138.html</guid>
<description>&lt;p&gt;即可将当前类注册，成为订阅者，即对应观察者模式的“观察者”，一旦有事件发送过来，该观察者就会接收到匹配的事件。通常，在类的初始化时便进行注册，如果是 Activity 则在的 onCreate（）方法内进行注册。&lt;/p&gt;&lt;p&gt;&lt;span&gt;当订阅者不再需要接受事件的时候，我们需要解除注册，释放内存：&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;197.526818906&quot;&gt;
&lt;h3&gt;5、threadMode&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;POSTING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认的模式,开销最小的模式,因为声明为 POSTING 的订阅者会在发布的同一个线程调用，发布者在主线程那么订阅者也就在主线程，反之亦，避免了线程切换，如果不确定是否有耗时操作，谨慎使用，因为可能是在主线程发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAIN&lt;/strong&gt;&lt;br/&gt;主线程调用，视发布线程不同处理不同，如果发布者在主线程那么直接调用(非阻塞式)，如果发布者不在主线程那么阻塞式调用,这句话怎么理解呢，看下面的 Log 比较清晰的理解&lt;br/&gt;主线程(阻塞式):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   Log.d(TAG, &quot;run : 1&quot;&lt;span&gt;);
    EventBus.getDefault().post(text);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送一个事件&lt;/span&gt;
    Log.d(TAG, &quot;run : 2&quot;&lt;span&gt;);
    EventBus.getDefault().post(text);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送一个事件&lt;/span&gt;
&lt;span&gt;                
                
    @Subscribe(threadMode &lt;/span&gt;=&lt;span&gt; ThreadMode.MAIN)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessageEvent1(String text) {
        Log.d(TAG, &lt;/span&gt;&quot;onMessageEvent1 : &quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
: run : 1&lt;span&gt;
: onMessageEvent1 :
: run : &lt;/span&gt;2&lt;span&gt;
: onMessageEvent1 :&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非主线程(非阻塞式):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;final&lt;/span&gt; String text = &quot;长江长江我是黄河&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                Log.d(TAG, &lt;/span&gt;&quot;run : 1&quot;&lt;span&gt;);
                EventBus.getDefault().post(text);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送一个事件&lt;/span&gt;
                Log.d(TAG, &quot;run : 2&quot;&lt;span&gt;);
                EventBus.getDefault().post(text);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送一个事件&lt;/span&gt;
&lt;span&gt;            }
        }).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志输出:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
run : 1&lt;span&gt;
run : &lt;/span&gt;2&lt;span&gt;
onMessageEvent1 :
onMessageEvent1 :&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;MAIN_ORDERED&lt;/strong&gt;&lt;br/&gt;和MAIN差不多,主线程调用，和 MAIN 不同的是他保证了 post 是非阻塞式的(默认走 MAIN 的非主线程的逻辑，所以可以做到非阻塞)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BACKGROUND&lt;/strong&gt;&lt;br/&gt;在子线程调用,如果发布在子线程那么直接在发布线程调用，如果发布在主线程那么将开启一个子线程来调用，这个子线程是阻塞式的,按顺序交付所有事件，所以也不适合做耗时任务，因为多个事件共用这一个后台线程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASYNC&lt;/strong&gt;&lt;br/&gt;在子线程调用，总是开启一个新的线程来调用，适用于做耗时任务，比如数据库操作，网络请求等，不适合做计算任务,会导致开启大量线程&lt;/p&gt;
&lt;h3&gt;6、原理分析：&lt;/h3&gt;
&lt;p&gt;这里并不打算分析具体的源码逻辑，而是个人在看了源码之后的笔记。帮助自己更好的理解 eventbus 的实现原理，梳理清楚每一条逻辑。&lt;/p&gt;
&lt;p&gt;想看源码分析可以参考这篇文章：&lt;/p&gt;
&lt;div class=&quot;article-title-box&quot;&gt;
&lt;h4 class=&quot;title-article&quot;&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/duo_shine/article/details/80354117&quot; target=&quot;_blank&quot;&gt;Android EventBus3.1.1从使用到源码解析&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;h4 class=&quot;article-info-box&quot;&gt;&lt;strong&gt;6.1 单例&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Convenience singleton for apps using a process-wide EventBus instance. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EventBus getDefault() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultInstance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (EventBus.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultInstance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    defaultInstance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventBus();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; defaultInstance;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在生成单例的时候使用了双重检验，避免多线程过程中重复创建。其次这里使用到了，类缩而非对象锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类锁只是一个概念上的东西，并不是真实存在的，他只是用来帮助我们理解锁定实例方法和静态方法的区别的。&lt;br/&gt;java 类可能会有很多对象，但是只有一个 Class (字节码)对象，也就是说类的不同实例之间共享该类的 Class 对象。Class 对象其实也仅仅是 1 个 java 对象，只不过有点特殊而已。&lt;br/&gt;由于每个 java 对象都有1个互斥锁，而类的静态方法是需要 Class 对象。所以所谓的类锁，只不过是 Class 对象的锁而已。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;6.2 以 class 为 key 来存储方法信息&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;例如一个 activity 里面注册了一个 eventbus。我们每次进入activity 的时候，都会把 this 传进去，然后走一遍注册逻辑，所以你觉得内部是如何存储注册对象的呢？是按照 this 来的？&lt;/p&gt;
&lt;p&gt;其实内部是通过 class 来存储的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; register(Object subscriber) {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; subscriberClass =&lt;span&gt; subscriber.getClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subscriberMethods返回的是subscriber这个类中所有的订阅方法&lt;/span&gt;
        List&amp;lt;SubscriberMethod&amp;gt; subscriberMethods =&lt;span&gt; subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分类保存后面有分析&lt;/span&gt;
&lt;span&gt;            }
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面代码，我们可以看到会去获取当前对象的类名，然后在通过反射的形式获取该类的所有方法，从中找到订阅方法，方便以后发布消息。&lt;/p&gt;
&lt;p&gt;如果采用对象保存，每次进入，都是一个不同的对象，然后通过对象再去获取方法信息，这样做太费力，也太耗内存了。通过类名的方式，只是第一次比较耗时，后面就方便了。&lt;/p&gt;
&lt;p&gt;添加新方法，或者新的事件的时候，会重新编译，重新获取一遍新的数据的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS : 注册本身还是挂在对象上的，当对象销毁的时候，也会进行注销。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;6.3 如何保存订阅同一事件的不同类&lt;/h4&gt;
&lt;p&gt;根据事件类型，将注册同一个事件类型的 class 放在一起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must be called in synchronized block&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; eventType = subscriberMethod.eventType;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅函数参数类型 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一步很简单就是在构造函数中记录下订阅者和订阅方法&lt;/span&gt;
        Subscription newSubscription = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subscription(subscriber, subscriberMethod);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CopyOnWriteArrayList是java.util包下的,他使用了写时复制的方法来实现,其效率并不高,但可以保证在多线程环境下最终(强调是最终)数据的一致性&lt;/span&gt;
        CopyOnWriteArrayList&amp;lt;Subscription&amp;gt; subscriptions = subscriptionsByEventType.get(eventType);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subscriptionsByEventType可以根据参数类型来获取到订阅事件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在操作第一个订阅事件时肯定是==null的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (subscriptions == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            subscriptions &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList&amp;lt;&amp;gt;&lt;span&gt;();
            subscriptionsByEventType.put(eventType, subscriptions);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (subscriptions.contains(newSubscription)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                        + eventType);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经注册的事件不允许再次注册&lt;/span&gt;
&lt;span&gt;            }
        }
 
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; subscriptions.size();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= size; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据优先级来添加&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i == size || subscriberMethod.priority &amp;gt;&lt;span&gt; subscriptions.get(i).subscriberMethod.priority) {
                subscriptions.add(i, newSubscription);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;typesBySubscriber可以根据订阅者来获取到所有的订阅方法参数类型&lt;/span&gt;
        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; subscribedEvents =&lt;span&gt; typesBySubscriber.get(subscriber);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subscribedEvents == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            subscribedEvents &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
            typesBySubscriber.put(subscriber, subscribedEvents);
        }
        subscribedEvents.add(eventType);
 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subscriberMethod.sticky) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;粘性事件的处理逻辑在最后再分析,因为其内容包含了post流程&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventInheritance) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Existing sticky events of all subclasses of eventType have to be considered.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: Iterating over all events may be inefficient with lots of sticky events,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thus data structure should be changed to allow a more efficient lookup
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (e.g. an additional map storing sub classes of super classes: Class -&amp;gt; List&amp;lt;Class&amp;gt;).&lt;/span&gt;
                Set&amp;lt;Map.Entry&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;&amp;gt; entries =&lt;span&gt; stickyEvents.entrySet();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;&lt;span&gt; entry : entries) {
                    Class&lt;/span&gt;&amp;lt;?&amp;gt; candidateEventType =&lt;span&gt; entry.getKey();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventType.isAssignableFrom(candidateEventType)) {
                        Object stickyEvent &lt;/span&gt;=&lt;span&gt; entry.getValue();
                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                    }
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                Object stickyEvent &lt;/span&gt;=&lt;span&gt; stickyEvents.get(eventType);
                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对 subscriptionsByEventType  typesBySubscriber 完成数据初始化，subscriptionsByEventType 根据参数类型存储订阅者和订阅方法，typesBySubscriber 根据订阅者存储了所有的参数类型，subscriptionsByEventType 主要是 post 时使用，因为其存储了订阅者和订阅事件这两个参数在反射时要用到，typesBySubscriber 在反注册时可以根据订阅者获取到存储的事件类型就可以从 subscriptionsByEventType 中获取到对应的订阅者和订阅方法释放资源,还可以用来判断是否注册。&lt;/p&gt;
&lt;h4&gt; 6.4 如何找到订阅方法&lt;/h4&gt;
&lt;p&gt;从缓存中获取订阅方法列表，如果缓存中不存在则通过反射获取到订阅者所有的函数，遍历再通过权限修饰符，参数长度(只允许一个参数)，注解(@Subscribe) 来判断是否是具备成为订阅函数的前提，具备则构建一个 SubscriberMethod (订阅方法，其相当于一个数据实体类，包含方法，threadmode，参数类型，优先级，是否粘性事件这些参数)，循环结束订阅函数列表构建完成添加进入缓存&lt;/p&gt;

&lt;h4&gt;6.5 如何在子线程发布消息后在主线程处理&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HandlerPoster(EventBus eventBus, Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxMillisInsideHandleMessage) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(looper);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eventBus =&lt;span&gt; eventBus;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maxMillisInsideHandleMessage =&lt;span&gt; maxMillisInsideHandleMessage;
        queue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PendingPostQueue();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用独立队列，与backgroundPoster一致&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，HandlerPoster 自身携带一个 looper，主要传入 mainLooper，就可以处理主线程的事物了。&lt;/p&gt;

&lt;h4&gt;6.6 是如何调用订阅方法的&lt;/h4&gt;
&lt;p&gt;通过反射的形式调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeSubscriber(Subscription subscription, Object event) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里最后说明一下subscription中包含了订阅者和订阅方法 event是Post的参数 这里通过反射直接调用订阅者的订阅方法 完成本次通信&lt;/span&gt;
&lt;span&gt;            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            handleSubscriberException(subscription, event, e.getCause());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unexpected exception&quot;&lt;span&gt;, e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.7 如何确定优先级&lt;/h4&gt;
&lt;p&gt;每次添加的时候，就会根据优先级来添加，优先级越高的，添加在最前面。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        Subscription newSubscription = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subscription(subscriber, subscriberMethod);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CopyOnWriteArrayList是java.util包下的,他使用了写时复制的方法来实现,其效率并不高,但可以保证在多线程环境下最终(强调是最终)数据的一致性&lt;/span&gt;
        CopyOnWriteArrayList&amp;lt;Subscription&amp;gt; subscriptions = subscriptionsByEventType.get(eventType);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subscriptionsByEventType可以根据参数类型来获取到订阅事件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在操作第一个订阅事件时肯定是==null的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (subscriptions == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            subscriptions &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList&amp;lt;&amp;gt;&lt;span&gt;();
            subscriptionsByEventType.put(eventType, subscriptions);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (subscriptions.contains(newSubscription)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                        + eventType);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经注册的事件不允许再次注册&lt;/span&gt;
&lt;span&gt;            }
        }
 
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; subscriptions.size();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= size; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据优先级来添加&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i == size || subscriberMethod.priority &amp;gt;&lt;span&gt; subscriptions.get(i).subscriberMethod.priority) {
                subscriptions.add(i, newSubscription);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.8 既然存在多线程，是如何保存数据的？&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; post(Object event) {
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;currentPostingThreadState是ThreadLocal,ThreadLocal可以解决多线程的并发访问问题,他会为每一个线程提供一个独立的变量副本,可以隔离多个线程对数据的访问冲突&lt;/span&gt;
        PostingThreadState postingState =&lt;span&gt; currentPostingThreadState.get();&lt;br/&gt;&lt;span&gt; ......
&lt;/span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ThreadLocal 的是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PostingThreadState {
    &lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;通过post方法参数传入的事件集合&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; eventQueue = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;&lt;span&gt;(); 
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isPosting; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;是否正在执行postSingleEvent()方法&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isMainThread;
    Subscription subscription;
    Object event;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canceled;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; Subscription(Object subscriber, SubscriberMethod subscriberMethod) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscriber =&lt;span&gt; subscriber;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscriberMethod =&lt;span&gt; subscriberMethod;
        active &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 订阅方法的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; SubscriberMethod(String methodName, Class&amp;lt;?&amp;gt;&lt;span&gt; eventType, ThreadMode threadMode,
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; priority, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sticky) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methodName =&lt;span&gt; methodName;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadMode =&lt;span&gt; threadMode;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eventType =&lt;span&gt; eventType;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.priority =&lt;span&gt; priority;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sticky =&lt;span&gt; sticky;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现，基本上所有的信息都被包含在 PostingThreadState 中了，这样在 post 的方法中就不要额外依赖其他数据了。&lt;/p&gt;
&lt;h4&gt;6.9  发送消息逻辑过程是怎样的&lt;/h4&gt;
&lt;p&gt;post () 发送消息，首先得获取当前线程的一个发送队列。从队列里面依次取出 event ，根据 event.getClass（）来获取保存的订阅者。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据我们注册的时候总结 这个容器中装的是订阅者和订阅方法,现在根据发送事件的类型来获取到对应的订阅者和订阅方法这些参数是反射必须要用到的&lt;/span&gt;
            subscriptions =&lt;span&gt; subscriptionsByEventType.get(eventClass);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到订阅者以后，依次循环，对每个订阅者进行处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据是否在主线程和threadmode来判断&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; postToSubscription(Subscription subscription, Object event, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isMainThread) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (subscription.subscriberMethod.threadMode) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; POSTING:
                invokeSubscriber(subscription, event);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;post在什么线程就直接调用 不需要切换线程&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MAIN:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMainThread) {
                    invokeSubscriber(subscription, event);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    mainThreadPoster.enqueue(subscription, event);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Post在主线程直接调用,反之通过handler来切换到主线程再调用反射&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MAIN_ORDERED:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainThreadPoster != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认走这里的逻辑和MAIN一致 事件排队等待调用,非阻塞式&lt;/span&gt;
&lt;span&gt;                    mainThreadPoster.enqueue(subscription, event);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; temporary: technically not correct as poster not decoupled from subscriber&lt;/span&gt;
&lt;span&gt;                    invokeSubscriber(subscription, event);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; BACKGROUND:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在主线程则开启一条线程 事件将排队在同一条线程执行&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果post在子线程直接在Post线程调用&lt;/span&gt;
&lt;span&gt;                    invokeSubscriber(subscription, event);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ASYNC:
                asyncPoster.enqueue(subscription, event);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总是开启线程来调用&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unknown thread mode: &quot; +&lt;span&gt; subscription.subscriberMethod.threadMode);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用 enqueue 后，用于切换线程来处理事件，最后还是会通过反射的形式进行调用。&lt;/p&gt;

&lt;h4&gt;6.10 黏性事件如何保存和发送&lt;/h4&gt;
&lt;p&gt;主要使用场景是：当订阅者尚未创建，先调用 EventBus.getDefault().postSticky() 方法发送一个 sticky 事件，该事件会被 stickyEvents 缓存起来，当订阅该事件的类调用 register() 方法时，最终会将保存的事件全部发给新注册的订阅者一份，因此，新的订阅者同样可以收到该事。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取subsrciberMethod传递的自定义EventType参数的运行时的类&lt;/span&gt;
    Class eventType =&lt;span&gt; subscriberMethod.eventType;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Subscription用于绑定subscriber和sucriberMethod,一个订阅者可以有多个subscriberMethod&lt;/span&gt;
    Subscription newSubscription = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subscription(subscriber, subscriberMethod);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据EventType的运行时类取到该类所有的subscriptioins，subscriptionsByEventType是HashMap中的key&lt;/span&gt;
    CopyOnWriteArrayList subscriptions =&lt;span&gt; subscriptionsByEventType.get(eventType);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subscriptions == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
         subscriptions &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList&amp;lt;&amp;gt;&lt;span&gt;();
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若根据EventType找不到subscriptions,则eventType作key,subscriptions作value添加到subscriptionByEventType中。&lt;/span&gt;
&lt;span&gt;         subscriptionsByEventType.put(eventType, subscriptions);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (subscriptions.contains(newSubscription)) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经存在newSubscription，抛出异常该订阅者已经注册，不可重复注册同一个subscriber&lt;/span&gt;
             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                     +&lt;span&gt; eventType);
         }
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; subscriptions.size();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= size; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环subscriptions，根据标记优先级的priority从高到低，将新的subscription插入到subscriptions中&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (i == size || subscriberMethod.priority &amp;gt;&lt;span&gt; subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;typesBySubscriber是一个HashMap，根据subscriber做key,获取该subscriber对应的所有的订阅事件的类型&lt;/span&gt;
    List&amp;gt; subscribedEvents =&lt;span&gt; typesBySubscriber.get(subscriber);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subscribedEvents == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          subscribedEvents &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该订阅者之前的订阅事件类型列表为空，则将当前订阅类型添加到typesBySubscriber中&lt;/span&gt;
&lt;span&gt;          typesBySubscriber.put(subscriber, subscribedEvents);
      }
    subscribedEvents.add(eventType);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该方法被标识为sticky事件&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;    if (subscriberMethod.sticky) {
         &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventInheritance) { eventInheritance标识是否考虑EventType的类层次结构
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环所有的sticky黏性事件&lt;/span&gt;
              Set, Object&amp;gt;&amp;gt; entries =&lt;span&gt; stickyEvents.entrySet();
              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry, Object&amp;gt;&lt;span&gt; entry : entries) {
                  Class candidateEventType &lt;/span&gt;=&lt;span&gt; entry.getKey();
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前事件是其他事件的同类型的或者是他们的父类&lt;/span&gt;
                  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventType.isAssignableFrom(candidateEventType)) {
                     Object stickyEvent &lt;/span&gt;=&lt;span&gt; entry.getValue();
                     heckPostStickyEventToSubscription(newSubscription, stickyEvent);
                  }
              }
         } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
             Object stickyEvent &lt;/span&gt;=&lt;span&gt; stickyEvents.get(eventType);
             checkPostStickyEventToSubscription(newSubscription, stickyEvent);
         }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面我们可以知道，最后都会调用一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stickyEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; --&amp;gt; Strange corner case, which we don't take care of here.&lt;/span&gt;
            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() ==&lt;span&gt; Looper.myLooper());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，也会调用到所有事件不管是不是黏性都会走的一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; postToSubscription(Subscription subscription, Object event, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isMainThread) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据@subscriber中threadMode进行区分，POSTING为当前线程执行，
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MAIN为主线程，BACKGROUND为子进程，ASYNC为异步执行。&lt;/span&gt;
       &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (subscription.subscriberMethod.threadMode) {
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; POSTING:
               invokeSubscriber(subscription, event);
               &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MAIN:
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMainThread) {
                   invokeSubscriber(subscription, event);
               } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                   mainThreadPoster.enqueue(subscription, event);
               }
               &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; BACKGROUND:
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMainThread) {
                   backgroundPoster.enqueue(subscription, event);
               } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                   invokeSubscriber(subscription, event);
               }
               &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ASYNC:
               asyncPoster.enqueue(subscription, event);
               &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
               &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unknown thread mode: &quot; +&lt;span&gt; subscription.subscriberMethod.threadMode);
       }
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后调用的逻辑还是一样的。&lt;/p&gt;

&lt;p&gt;最后，附上一张 eventbus 的思维导图，帮助你们更好的去理解 eventbus。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201905/916005-20190526162848407-2137550619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 26 May 2019 16:15:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>对于 Eventbus ，相信很多 Android 小伙伴都用到过。 1、创建事件实体类 所谓的事件实体类，就是传递的事件，一个组件向另一个组件发送的信息可以储存在一个类中，该类就是一个事件，会被 E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/10926138.html</dc:identifier>
</item>
<item>
<title>Kafka应用实践与生态集成 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/10928396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/10928396.html</guid>
<description>&lt;p&gt;Apache Kafka发展至今，已经是一个很成熟的消息队列组件了，也是大数据生态圈中不可或缺的一员。Apache Kafka社区非常的活跃，通过社区成员不断的贡献代码和迭代项目，使得Apache Kafka功能越发丰富、性能越发稳定，截止本篇博客Apache Kafka发布了V2.2.0版本。&lt;/p&gt;
&lt;p&gt;那么，今天就来聊一聊Kafka应用实践与生态集成的相关内容。&lt;/p&gt;

&lt;p&gt;项目立项时，会做技术调研，那么如何知道你选择的Kafka技术是否能够满足你？据Confluent公司调研报告可知，Apache Kafka在过去几年中在功能和覆盖范围方面取得了很大成就。它被财富500强中的三分之一用于生产，包括全球十大银行中的七家，十大保险公司中的八家，以及美国十大电信公司中的九家。接下来，为大家介绍Kafka示例来帮助大家了解常见的使用模式。并且希望大家能找到与自己的工作流程有交集的地方，这样大家就可以开始利用Kafka的强大功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526191354212-1787770858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面让先来看看Kafka提供的两个核心功能：&lt;/p&gt;
&lt;h2&gt;2.1 消息系统&lt;/h2&gt;
&lt;p&gt;消息系统常见的两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;队列：队列消费者充当了工作组的角色，每条消息记录只传递给一个工作进程，从而有效的划分工作流程；&lt;/li&gt;
&lt;li&gt;发布与订阅：订阅者通常是彼此独立的，每个订阅者都可以获得每条消息的副本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种模式都是有效和实用的，通过队列将工作内容分开，用于容错和扩展；发布与订阅能够允许多租户，来使系统解耦。而Apache Kafka的有点之一在于它将队列、发布与订阅结合到了一个强大的消息系统中。&lt;/p&gt;
&lt;h2&gt;2.2 流处理&lt;/h2&gt;
&lt;p&gt;Apache Kafka拥有强大，可扩展的消息系统，只需要一种简单的方法来处理消息流。而在Kafka中，Stream API提供这一功能，它是一个Java客户端类库，提供比Producer和Consumer更高级别的抽象API。&lt;/p&gt;
&lt;p&gt;这使得它使用起来非常的方便：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无状态操作，例如过滤和转换流消息；&lt;/li&gt;
&lt;li&gt;有状态操作，例如时间窗口上的连接和聚合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Stream API处理消息的序列化与反序列化，同时维护有状态操作所需要的状态。&lt;/p&gt;
&lt;h2&gt;2.3 典型的Kafka案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;旅游行业&lt;/strong&gt;：例如，在一个旅游网站，酒店和航班的价格是一直在变化的，系统的一些组件（价格告警、分析等）需要了解这些变化。你在Kafka的Topic上发布更改，并且需要通知的每个组件都充当一个消费者。每个消费者应用所组成的节点形成一个消费者组。给消费者组所消费的Topic的发送消息动态记录，这样每个消费者均可获取消息记录，同时每个消费者内能够有效的划分工作内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户分析&lt;/strong&gt;：页面查看、搜索、用户行为分析等，这些实际上是Kafka在LinkedIn设计的原始初衷。用户点击网站活动内容，每个活动类型均有一个Topic，可以实时的反馈，以便深入了解用户参与度、下载量、页面流量等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPS&lt;/strong&gt;：例如，能够实时获取智能手机设备的位置数据，并且希望能够实时处理这些数据来显示车辆路径、行驶距离等。传入数据到Kafka的Topic中，并使用Stream API来进行处理。当需要在特定时间段内提取和处理给定用户的所有位置数据时，使用窗口进行状态处理会有不错的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何你确定了Kafka技术适合你当前的项目，满足你的业务需求。你可能会很好奇，Kafka的内部存储工作原理是什么呢？接下来，将给大家分析Kafka是如何存储其数据的。&lt;/p&gt;
&lt;h2&gt;3.1 Kafka存储单元是分区&lt;/h2&gt;
&lt;p&gt;Topic中的分区是有序写入的，且不可变的消息序列。分区不能跨多个Broker或者多个磁盘来进行分割。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526194921913-96297082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 保留策略来管理Topic中消息&lt;/h2&gt;
&lt;p&gt;在你创建的Topic中，你可以指定保留多少数据或者保留多长时间的数据，然后Kafka会按照顺序来清除这些消息（不管消息是否有被使用）。&lt;/p&gt;
&lt;h2&gt;3.3 分区片段&lt;/h2&gt;
&lt;p&gt;Kafka需要定期查找磁盘上待清除的数据，对于分区消息单个非常长的文件，该操作会很慢并且容易出错。为了解决这个问题，Kafka实行了分区分片策略。当Kafka将消息写入分区时，它会写入到一个片段，如果该片段到达阀值，则会新开一个新的片段来写入。片段以偏移量来命名，片段的偏移量是大于前一个片段的偏移量且小于或者等于当前片段中的偏移量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526200547087-179262332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.4 片段日志是存储消息的位置&lt;/h2&gt;
&lt;p&gt;每条消息都包含值、偏移量、时间戳、主键（KEY）、消息大小、压缩编解码器、校验、以及消息格式的版本。磁盘上的数据格式与Broker通过网络从Producer端接收的格式完全相同，然后由Consumer去获取数据，这使得Kafka能够通过零拷贝技术有效的传输数据。&lt;/p&gt;
&lt;h2&gt;3.5 片段索引将消息偏移量映射到它们在日志中的位置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190527004706971-987395267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引文件是内存映射的，偏移量查找时使用二进制搜索来查找小于或等于最近的目标偏移量。索引文件由8个字节组成，4个字节用于存储基本偏移量，另外4个字节来存储位置。&lt;/p&gt;
&lt;h2&gt;3.6 Kafka将压缩的消息包装在一起&lt;/h2&gt;
&lt;p&gt;发送压缩消息的Producer端会将压缩批处理，并将其作为包装消息的有效负载发送。和之前一样，磁盘上的数据与Broker通过网络从Producer端接收并发送给其Consumer的数据完全相同。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526203114880-714179955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.7 Kafka内部存储工作原理小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Kafka的存储单元是分区；&lt;/li&gt;
&lt;li&gt;分区通过片段来进行分割；&lt;/li&gt;
&lt;li&gt;片段包含两个文件：索引和日志文件；&lt;/li&gt;
&lt;li&gt;索引将每个偏移量映射到它们所在日志中的消息位置，用于查找消息；&lt;/li&gt;
&lt;li&gt;压缩消息批处理作为包装消息的有效负载；&lt;/li&gt;
&lt;li&gt;存储在磁盘上的数据与Broker通过网络从Producer端接收并发给Consumer的数据相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kafka的核心尽管在一段时间内保持相对的稳定，但是Kafka生态圈然后在快速的发展。最初的Kafka，包含Producer和Consumer，很容易理解。现在Kafka处理Producer和Consumer，还有Kafka Connect、Kafka Streams、以及KSQL。 &lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526214743170-546503773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.1 如何正确的选择Kafka API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Kafka Producer API&lt;/strong&gt;：应用直接生成数据，例如移动设备、PC、其他硬件等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Connect Source API&lt;/strong&gt;：应用程序桥接在我们无法控制的数据存储介质，例如MongoDB、ElasticSearch、RESTAPI等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Streams API/KSQL&lt;/strong&gt;：如果希望像SQL一样操作实时流数据，可以通过KSQL来完成；如果需要编写复杂的业务逻辑，可以使用Kafka Streams API来完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Consumer API&lt;/strong&gt;：直接读取流数据，并对其执行实时操作，例如推送商品促销活动、发送邮件、获取游戏行为等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Connect Sink API&lt;/strong&gt;：读取实时流并将其存储到目标介质中，例如Kafka到S3、Kafka到HDFS、Kafka到HBase等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择不同的API来实现不同的业务需求，例如，如果希望为实现的需求编写大量的自定义代码，Kafka Consumer API和Kafka Connect Sink API完全是可以互换的。总而言之，上述API可以帮助你在实际的业务中以最少的代码量来实现最有效的工作流程。&lt;/p&gt;
&lt;h2&gt;4.2 各个API的优势和局限&lt;/h2&gt;
&lt;h3&gt;4.2.1 Kafka Producer API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;： Kafka Producer API使用起来非常的简单，异步发送数据，获取回调结果。非常适合直接发送数据流的应用程序，例如日志、点击流、物联网等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：可以扩展和构建Kafka Producer API以便执行更多的操作，但是这需要开发人员编写更多的附加逻辑。例如，试图使用Kafka Producer API在数据库和Kafka之间执行ETL操作时，如何跟踪偏移量（即当Producer端停止后，如何正确恢复你的Producer应用程序）？、如何在若干个Producer之间分配ETL的负载？这种情况，我们使用Kafka Connect Source API会更好一些。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.2 Kafka Connect Source API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：Kafka Connect Source API是一个构建在Kafka Producer API之上的完整框架。它的构建是为了让开发人员能够获得更好的API，以便为并行处理生成并分配任务。另外，可以使用各种各样的连接器，利用这些连接器来处理大多数数据介质，且无需编写任何代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：适配的数据源连接器均是专属的，如果你当前的数据源在已有的连接器中不包含，需要自行编写连接器来进行适配。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.3 Kafka Consumer API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：Kafka Consumer API非常简单，可以使用Consumer Groups，因此可以并行使用Topic。新版本的Kafka（V2.2.0）对于偏移量的管理和提交、Balance、幂等性等无需开发者关心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：在ETL场景中，Kafka Connect Sink更加合适，因为它们会避免针对外部数据源编写复杂的逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.4 Kafka Connect Sink API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：与Kafka Connect Source API类似，Kafka Connect Sink API允许利用现有的Kafka连接器的生态系统来执行流式ETL，且无需编写任何代码。Kafka Connect Sink API建立在Kafka Consumer API的基础之上，但是与它有所不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：如果写入的数据源没有可用的适配器，那么需要自行编写Kafka Connect连接器，并且调试过程会有些复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.5 Kafka Streams API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：对于流处理场景，Kafka中附带Kafka Streams API，并且能够编写高级DSL（类似于函数式编程或者Spark类型的程序）或偏底层的API（类似于Storm）。Kafka Streams API完全隐藏了Producer和Consumer的复杂性，让开发者更加专注于流处理的逻辑实现上。同时，它还具有连接、聚合、一次性处理等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：使用Kafka Streams API会让编码门槛提高，同时也可能让你业务逻辑变得复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.6 KSQL&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：KSQL不是Kafka API的直接组成部分，而是Kafka Streams之上的包装器。这里还是值得一说的，虽然Kafka Streams允许编写一些复杂的Topology，但它还是需要一些实质性的编程知识，尤其是新手来说。KSQL希望通过提供与现有的SQL语义类似来抽象出这种复杂性。对于开发者来说，KSQL是非常具有诱惑力的，它使得流处理器变得轻而易举。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：对于复杂的业务场景，对数据进行复杂的转换操作，或一些特定的需求，可能还是需要使用Kafka Streams来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526225021149-1460884720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.1 介绍&lt;/h2&gt;
&lt;p&gt;Kubernetes是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。Kubernetes旨在运行无状态工作负载，这些工作负载通常采用微服务架构形式，轻量级、水平扩展。而Kafka的本质上是一个分布式的存储介质，这意味着你在使用时必需处理状态，它比微服务更重要。尽管Kubernetes支持有状态的工作负载，但还是需要谨慎使用。&lt;/p&gt;
&lt;p&gt;那么，应该在Kubernetes上运行Kafka吗？如何让Kafka和Kubernetes互相补充，以及如何避免可能遇到的“坑”？&lt;/p&gt;
&lt;h2&gt;5.2 基础指标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：Kafka Broker对CPU很友好，TLS的引入可能会产生一些开销。Kafka Client如果使用加密会需要更多的CPU，但是这并不会影响Broker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;：Kafka Broker的JVM通常可以设置为4GB-8GB之间，但是由于Kafka大量使用了页面缓存，因此还是需要有足够的系统内存。在Kubernetes中，相应的设置容器资源限制和请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储&lt;/strong&gt;：容器中的存储是暂时的，重启后数据将会丢失，但是可以对Kafka数据使用空目录卷。因此，需要使用持久化存储，存储必须是非本地的，以便Kubernetes在重启后或重新定位后更加灵活的选择另一个节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt;：与大多数分布式系统一样，Kafka性能在很大程度上取决于低网络延迟和高带宽。建议不要把所有的Broker放在同一个节点，因为这样会降低可用性。如果Kubernetes节点出现故障，那么整个Kafka集群都会出现故障。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.3 性能&lt;/h2&gt;
&lt;p&gt;安装Kafka之前，做POC测试是非常重要的。这样做的好处是，在遇到有关性能瓶颈问题时，可以提供帮助。而Kafka附带了两个POC测试工具，它们分别是：kafka-producer-perf-test.sh和kafka-consumer-perf-test.sh。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：监控Kafka指标是非常有必要的，能够让我们及时的掌握Kafka、Zookeeper集群的健康状态，例如使用Kafka Eagle来监控和管理Kafka Topic（http://www.kafka-eagle.org/）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt;：日志是一个比较关键的部分，确保Kafka安装中所有的容器都记录到stdout和stderr中，并确保Kubernetes集群日志能集中管理，例如输送到ElasticSearch。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态更新&lt;/strong&gt;：StatefulSets支持自动更新，RollingUpdate策略将一次更新一个Kafka Pod，来实现零停机维护，这也是Kubernetes的优势之一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩容&lt;/strong&gt;：Kubernetes可以很容易的将Pod缩放到一定数量的副本，这意味着可以声明性的定义所需数量的Kafka Broker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;备份&amp;amp;还原&lt;/strong&gt;：Kafka部署在Kubernetes中，这样Kafka的可用性就取决于Kubernetes的可用性，如果Kubernetes集群出现故障，那么Kafka的可用性就会下降，同时，也会出现数据丢失的风险，因此需要做好数据备份策略，例如MirrorMaker，或是S3进行连接备份。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.4 对于Kubernetes的选择&lt;/h2&gt;
&lt;p&gt;对于中小型的Kafka集群，将Kafka部署到Kubernetes是一个不错的选择，因为它提供了更大的灵活性、且简化了操作。如果在延迟或吞吐量方面有较高的功能性要求，独立部署的方式可能会更好。&lt;/p&gt;

&lt;p&gt;本篇博客，介绍了Kafka应用实践与生态集成，通过阅读本篇博客的内容，大家可以参考本篇博客的内容，来做出合理、有效的选择。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《&lt;a href=&quot;https://item.jd.com/12455361.html&quot; target=&quot;_blank&quot;&gt;Kafka并不难学&lt;/a&gt;》和《&lt;a href=&quot;https://item.jd.com/12371763.html&quot; target=&quot;_blank&quot;&gt;Hadoop大数据挖掘从入门到进阶实战&lt;/a&gt;》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 15:48:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.前言 Apache Kafka发展至今，已经是一个很成熟的消息队列组件了，也是大数据生态圈中不可或缺的一员。Apache Kafka社区非常的活跃，通过社区成员不断的贡献代码和迭代项目，使得Apa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smartloli/p/10928396.html</dc:identifier>
</item>
<item>
<title>Linux之旅第一篇-目录结构及操作目录 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10928374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10928374.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Linux对java开发来说也是一项必备的技能，因为项目基本都是部署在Linux操作系统的服务器中，虽然项目不一定需要我们去部署，但不管是自己测试环境部署，还是一些生产环境中日志的查看，Linux操作系统都是免不了要去接触的。对于我们开发来说懂得基础的命令及简单shell脚本编写是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;跳过Linux介绍和安装，我们直接从基础命令开始。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;Linux目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;在Linux世界中，一切皆是文件，Linux文件采用级层式的树状目录结构，在此结构中根目录是“/”,我们可以看看根目录下面有哪些目录，使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd &lt;span&gt;/&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;进入根目录&lt;/span&gt;
ll   &lt;span&gt;--&lt;/span&gt;&lt;span&gt;查看目录接口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些命令我们后面再学习，结果如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232645064-2114521446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构整理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232721354-1334256224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;目录结构作用&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;bin&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放二进制可执行文件(ls,cat,mkdir等)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boot&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放用于系统引导时使用的各种文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;dev&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放设备文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;etc&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放系统配置文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;home&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放所有用户文件的根目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;lib&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放跟文件系统中的程序运行所需要的共享库及内核模块&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;mnt&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;系统管理员安装临时文件系统的安装点&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;opt&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;额外安装的可选应用程序包所放置的位置&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;proc&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;虚拟文件系统，存放当前内存的映射&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;root&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;超级用户目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;sbin&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放二进制可执行文件，只有root才能访问&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放各种临时文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;usr&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;var&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span md-focus&quot;&gt;&lt;span&gt;用于存放运行时需要改变数据的文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们需要关注的几个目录&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;home: 存放我们用户文件的目录。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;etc ：存放配置文件的目录，当我们需要修改配置文件的时候就需要进入该目录。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;usr/local :安装自己的程序，必须放在该目录中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;var:存在数据的目录&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;操作文件目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;了解完了大体的目录结构，下面就开始一些操作文件目录的操作，其实就要记住和熟悉命令的过程，每个命令都去敲敲，无非是一个熟能生巧的过程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;ls&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ls 显示文件和目录列表，另外还有两个可选参数：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;ls命令&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232930057-1910735378.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们切换至home 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232951420-503019287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ls -a&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233014039-447944227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在linux中以.开头的是隐藏文件&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.2 mkdir&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; mkdir 创建目录命令，一个可选参数-p:父目录不存在情况下先生成父目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233151815-1471670806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我们直接增加父目录时，不存在父目录就会出错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233217470-1679501845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233236192-2094264085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.3 cd&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; cd 是切换目录，这个命令很简单，后面加上切换的目录地址即可&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.4 touch&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;touch 生成一个空文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233346342-1329425540.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.5 echo&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; echo 生成一个带内容文件&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;格式： echo hello world &amp;gt;1.txt 创建文件并写入（一个尖括号）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;echo linux &amp;gt;&amp;gt;1.txt 追加文本内容 （两个尖括号）&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.6 cat&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;echo 显示文本文件内，我们来显示刚刚创建的文件内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233455103-1511793022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.7 cp&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;cp 复制文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;格式：cp 原始文件 复制到的目录位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233530776-1993880228.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.8 rm&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;rm 是删除文件，有两个可选参数，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当我们删除的文件是一个目录是，就必须强制的删除文件，并且删除目录下的所有文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233615538-269770462.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;所以从删库到跑路的命令就是：rm -fr /*&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.9 mv&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;mv 移动文件或目录,相当于剪切命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233705138-1495857985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.10 find&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; find 在文件系统中查找指定的文件，有一个可选参数- name 即为文件的名称，如果不加在这个参数，直接查询文件是查询不到的，只会查找目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233740033-172933237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.11 grep&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;grep 在指定的文本文件中查找指定的字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233819517-1962391108.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;3.12 tree&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;tree 用于以树状图列出目录的内容，默认的版本应该是没有这个命令，需要后面自主下载&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.13 pwd&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;pwd 显示当前工作目录，这个无需讲了&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.14 more&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;more 分页显示文本文件内容,当文件内容过长时，我们可以使用此命令，然后按住enter键往下浏览&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.15 head&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;head 显示文件开头内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233918446-1816763010.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;3.16 tail&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;tail 显示文件结尾内容，有一个可选参数，-f 跟踪输出，什么意思呢？当我们执行这个命令是，执行过后并不会立即结束，而是卡住状态，当文件被修改时，会自动的输出修改的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 15:45:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 Linux对java开发来说也是一项必备的技能，因为项目基本都是部署在Linux操作系统的服务器中，虽然项目不一定需要我们去部署，但不管是自己测试环境部署，还是一些生产环境中日志的查看，Li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/10928374.html</dc:identifier>
</item>
<item>
<title>netframework中等待多个子线程执行完毕并计算执行时间 - 紫云秀</title>
<link>http://www.cnblogs.com/ziyunxiu/p/10928331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ziyunxiu/p/10928331.html</guid>
<description>&lt;p&gt;本文主要描述在.netframework中(实验环境.netframework版本为4.6.1)提供两种方式等待多个子线程执行完毕。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ManualResetEvent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;             在多线程中，将ManualResetEvent实例作为方法传入，线程执行完毕后可以设置标志位来标识当前线程已经执行完毕。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e782fd5b-6fd5-4037-ad13-b6f2b788e5ba')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e782fd5b-6fd5-4037-ad13-b6f2b788e5ba',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  List&amp;lt;ManualResetEvent&amp;gt; manualResetEvents = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ManualResetEvent&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; ManualResetEvent标志多线程是否执行完毕
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btn_ManualResetEvent_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SetBtnEnabled(false);&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             Stopwatch watch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadCount; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 ManualResetEvent manualReset = &lt;span&gt;new&lt;/span&gt; ManualResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                manualResetEvents.Add(manualReset);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                ThreadPool.QueueUserWorkItem(ManualResetEventMethod, manualReset);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待所有线程执行完毕&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            WaitHandle.WaitAll(manualResetEvents.ToArray());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暂停watch，获取多线程执行时间&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; watch.ElapsedMilliseconds;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             lab_time.Text =&lt;span&gt; time.ToString();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SetBtnEnabled(true);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放句柄&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            manualResetEvents.Clear();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ManualResetEventMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             ManualResetEvent mre =&lt;span&gt; (ManualResetEvent)obj;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            mre.Set();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      注意：&lt;/p&gt;
&lt;p&gt;     在WaitHandle.WaitAll方法中，等待的句柄不能超过64，所以每次用完后，需要手动调用Clear方法进行释放。&lt;/p&gt;
&lt;p&gt;     如果等待的线程超过64个，可以参考博客：https://www.cnblogs.com/xiaofengfeng/archive/2012/12/27/2836183.html，在该博客中，通过对ManualResetEvent的封装，能够使等待的句柄超过64（测试环境下一次起1000个线程，没有问题）&lt;/p&gt;
&lt;p&gt;         在主线程中通过Monitor.Wait(locker)达到阻塞的目的，子线程执行完毕通过 Monitor.Pulse(locker)通知主线程，直到所有子线程执行完成，主线程再继续执行，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a2fbd9dc-ed66-4622-ab89-b2d386410874')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a2fbd9dc-ed66-4622-ab89-b2d386410874',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;object&lt;/span&gt; locker = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; threadCount = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; finshCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Monitor线程之间同步标记多线程执行完毕
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btn_Monitor_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             finshCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             SetBtnEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Stopwatch watch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadCount; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Thread trd = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterizedThreadStart(MonitorMethod));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                trd.Start(i);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (locker)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (finshCount !=&lt;span&gt; threadCount)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     Monitor.Wait(locker);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有线程执行完毕，获取执行时间&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; watch.ElapsedMilliseconds;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             lab_time.Text =&lt;span&gt; time.ToString();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             SetBtnEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MonitorMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (locker)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 finshCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 Monitor.Pulse(locker); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成，通知等待队列,告知已完，执行下一个。&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       在一次开启10、1000个线程两种环境下，分别测试以上两种方式，ManualResetEvent在多次执行时，前几次耗时会比较大，后续耗时会减少并且稳定下来，接近 Monitor的速度。相对而言，Monitor的效率更高。&lt;/p&gt;

&lt;p&gt;   如果了解过go语言，会发现通过sync包下的WaitGroup也可以达到同样的目的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;collapse:true;;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
        &quot;sync&quot;
        &quot;time&quot;
)

var wg sync.WaitGroup
var count = 1000

func main() {

        startTime := time.Now().Unix()
        wg.Add(count)
        for i := 0; i &amp;lt; count; i++ {
                go func() {
                        defer wg.Done()
                        time.Sleep(time.Second)
                }()
        }
        fmt.Println(&quot;waiting for all goroutine&quot;)
        wg.Wait()

        endTime := time.Now().Unix()

        fmt.Printf(&quot;all goroutine is done! time:%v s&quot;, (endTime-startTime))

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相较而言，go语言的协程效率最高&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 15:28:00 +0000</pubDate>
<dc:creator>紫云秀</dc:creator>
<og:description>本文主要描述在.netframework中(实验环境.netframework版本为4.6.1)提供两种方式等待多个子线程执行完毕。 ManualResetEvent 在多线程中，将ManualRes</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ziyunxiu/p/10928331.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第21期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10928295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10928295.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;F 在GitHub上的开发仓库现在变为dotnet/fsharp&quot; &quot;Ionide 4.0路线图&quot; &quot;Fable的五月公告&quot; &quot;Visual Studio 2019版本16.1&quot; &quot;WinUI 3.0路线图&quot; &quot;欢迎来到Shell时代：Xamarin.Forms 4.0发布&quot; 视频及幻灯片 </description>
<pubDate>Sun, 26 May 2019 15:21:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'F 在GitHub上的开发仓库现在变为dotnet/fsharp' 'Ionide 4.0路线图' 'Fable的五月公告' 'Visual Studio 2019版本16.1' 'WinUI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/10928295.html</dc:identifier>
</item>
<item>
<title>SpringBoot+Mybatis增删改查实战 - 林静生寒</title>
<link>http://www.cnblogs.com/ljsh/p/10928106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljsh/p/10928106.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;SpringBoot和Mybatis是啥请自行百度，作者这里也是花了几天时间入门了这个框架用来完成任务，并且也算符合要求的完成了任务，期间也各种百度但是没找到自己想要的那种简单易懂的教程，所以踩了很多坑，写这个博客的目的就是为了让大家少踩一点坑，开始。&lt;/p&gt;
&lt;h2 id=&quot;创建一个springboot项目&quot;&gt;创建一个SpringBoot项目&lt;/h2&gt;
&lt;h3 id=&quot;httpsstart.spring.io&quot;&gt;&lt;a href=&quot;https://start.spring.io/&quot; class=&quot;uri&quot;&gt;https://start.spring.io/&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;点开这个网站，创建一个Springboot项目，如下图，这里用的是2.1.5，学技术嘛，就是要学新的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223350588-806991173.png&quot;/&gt;&lt;br/&gt;选择依赖，点击左下角的Dependencies&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Web&lt;/code&gt; 我们这次开发的是web应用所以选择web&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thymeleaf&lt;/code&gt; 一款模板引擎，能够比较方便的展现后台传来的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt; 我们这次使用Mysql数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JDBC&lt;/code&gt; Java 数据库连接 Java Database Connectivity,简称JDBC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyBatis&lt;/code&gt; 请看第一段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223404310-107768824.png&quot;/&gt;&lt;br/&gt;最后点击左下角的Generate Project，将会开始下载一个以你项目名称开头的zip文件，下载完成后解压到你的工作目录。&lt;/p&gt;
&lt;h3 id=&quot;打开这个项目&quot;&gt;打开这个项目&lt;/h3&gt;
&lt;p&gt;这里使用的是IDEA，别的啥也行比如eclipse，这里只讲解IDEA的操作，安装破解IDEA百度一大堆，安装好之后打开IDEA（发现IDEA有个问题，有的时候自动import包好用，有的时候不好用，坑！），然后选择左上角的File-&amp;gt;Open，找到你刚刚解压的项目文件里的pom.xml点击ok如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223451702-1206712524.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;p&gt;增加修改目录结构为下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223501448-1867389567.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始编写&quot;&gt;开始编写&lt;/h2&gt;
&lt;p&gt;这里我们就编写一个人员信息的增删改查&lt;/p&gt;
&lt;h3 id=&quot;配置数据库&quot;&gt;配置数据库&lt;/h3&gt;
&lt;h4 id=&quot;数据库创建&quot;&gt;数据库创建&lt;/h4&gt;
&lt;p&gt;打开mysql数据库创建一个叫test的数据库之后创建person表，这里使用的是Navicat百度有破解版，会命令用命令行也行，如下图，记得设置主键自增，然后随便加几个数据以便之后查询。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223513803-1820680642.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;application.yml&lt;/h4&gt;
&lt;p&gt;路径：/resources/application.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;server:
  port: 8080

spring:
  datasource:
    name:
    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;allowMultiQueries=true&amp;amp;serverTimezone=UTC
    username: root
    password: root

mybatis:
  mapper-locations: classpath:mapper/*.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;person类&quot;&gt;Person类&lt;/h3&gt;
&lt;p&gt;路径/model/Person.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.model;

public class Person {
    /*
    {id} 自增主键
    {name} 人员姓名
    {mobile} 人员电话
     */
    private int id;
    private String name;
    private String mobile;
    
    // 右键 Generate -&amp;gt; Setter and Getter -&amp;gt; Shift全选 -&amp;gt; ok 生成如下代码

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }
    
    // 右键 Generate -&amp;gt; toString() -&amp;gt; 全选 -&amp;gt; ok 生成如下代码

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, mobile='&quot; + mobile + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;persondao&quot;&gt;PersonDao&lt;/h3&gt;
&lt;p&gt;路径：/dao/PersonDao.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.dao;

import com.ljsh.test.model.Person;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface PersonDao {
    /*
    查所有
    return List&amp;lt;Person&amp;gt;
     */
    List&amp;lt;Person&amp;gt; getAll();

    /*
    根据ID查询
    {id} 要查询人员的 id
     */
    Person getPersonByID(int id);
    
    /*
    删除
    {id} 要删除人员的 id
     */
    void delete(int id);

    /*
    更新
    {p} 要更新的Person实例
     */
    void update(Person p);

    /*
    增加
    {p} 要新增的Person实例
     */
    void newp(Person p);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;persondao.xml&quot;&gt;PersonDao.xml&lt;/h3&gt;
&lt;p&gt;路径：/mapper/PersonDao.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;!-- 这里填写对应的Dao文件所在的路径 --&amp;gt;
&amp;lt;mapper namespace=&quot;com.ljsh.test.dao.PersonDao&quot;    &amp;gt;
    &amp;lt;!-- 填写数据库里实例Person对应的表的表名 --&amp;gt;
    &amp;lt;!-- 这里是作为一个变量使用 --&amp;gt;
    &amp;lt;sql id=&quot;table&quot;&amp;gt;person&amp;lt;/sql&amp;gt;

    &amp;lt;!-- id属性填写Dao文件里的函数名称 xxType是参数或是结果的类型根据情况填写 --&amp;gt;
    &amp;lt;!-- 查询所有   --&amp;gt;
    &amp;lt;select id=&quot;getAll&quot; resultType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        SELECT
        *
        FROM
        &amp;lt;include refid=&quot;table&quot; /&amp;gt;
    &amp;lt;/select&amp;gt;


    &amp;lt;!-- 根据id查询 --&amp;gt;
    &amp;lt;select id=&quot;getPersonById&quot; resultType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        SELECT
        *
        FROM
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        WHERE
        id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 增 --&amp;gt;
    &amp;lt;insert id=&quot;newp&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        INSERT INTO
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        (name,phone)
        VALUES
        (#{name},#{phone})
    &amp;lt;/insert&amp;gt;

    &amp;lt;!-- 改 --&amp;gt;
    &amp;lt;update id=&quot;update&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        UPDATE
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        SET
        &amp;lt;!--&amp;lt;if test=&quot;name != null&quot;&amp;gt;name = #{name}&amp;lt;/if&amp;gt;--&amp;gt;
        name  = #{name},phone = #{phone},status = #{status}
        WHERE
        id = #{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;!-- 删 --&amp;gt;
    &amp;lt;delete id=&quot;delete&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        DELETE FROM
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        WHERE
        id = #{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;personservice&quot;&gt;PersonService&lt;/h3&gt;
&lt;p&gt;路径：/service/PersonService.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.service;
import com.ljsh.test.dao.PersonDao;
import com.ljsh.test.model.Person;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class PersonService {
    @Autowired
    PersonDao personDao;

    /*
        Service层介于controller和dao之间作为服务层进行一些逻辑处理，
        这里逻辑太简单所以知识单纯调用dao所以不做注释
     */
    public List&amp;lt;Person&amp;gt; getAll(){
        return personDao.getAll();
    }

    public Person getPersonByID(int id){
        return personDao.getPersonByID(id);
    }

    public void  delete(int id){
        personDao.delete(id);
    }

    public void update(Person p){
        personDao.update(p);
    }

    public void newp(Person p){
        personDao.newp(p);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;personcontroller&quot;&gt;PersonController&lt;/h3&gt;
&lt;p&gt;路径：/controller/PersonController.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.controller;

import com.ljsh.test.model.Person;
import com.ljsh.test.service.PersonService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import java.util.List;

@Controller
public class PersonController {

    @Autowired
    PersonService personService;

    // 设置访问路由值为路径
    @RequestMapping(&quot;/&quot;)
    public ModelAndView index(){
        // 顾名思义 实体和数据 同时返回页面模板和数据
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&amp;lt;Person&amp;gt; list = personService.getAll();
        mav.addObject(&quot;list&quot;,list);
        return mav;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;前端页面&quot;&gt;前端页面&lt;/h3&gt;
&lt;p&gt;路径：/templates/index.html&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;!-- --&amp;gt;
&amp;lt;!-- 使用thymeleaf需引入 --&amp;gt;
&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div  id=&quot;tableP&quot;&amp;gt;
        &amp;lt;table&amp;gt;
            &amp;lt;caption&amp;gt;人员信息&amp;lt;/caption&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Phone&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;!-- 通过th命令使用一些操作 --&amp;gt;
            &amp;lt;!-- 通过${} 使用变量 --&amp;gt;
            &amp;lt;tr  th:each=&quot;item: ${list}&quot;&amp;gt;
                &amp;lt;td th:text=&quot;${{item.name}}&quot;&amp;gt;还没有任何人员信息哦&amp;lt;/td&amp;gt;
                &amp;lt;td th:text=&quot;${{item.mobile}}&quot;&amp;gt;你是不是想独吞奖品&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;右上角运行&quot;&gt;右上角运行&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223536192-1917348177.png&quot;/&gt;&lt;br/&gt;要是没有这个可以右侧选择TestApplication右键Run，结果图如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526224319152-188703909.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;未完待续&quot;&gt;未完待续&lt;/h2&gt;
&lt;p&gt;熄灯睡觉了，写的有点慢，删改查还没来及写，如果需求留言，我会继续更新。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:36:00 +0000</pubDate>
<dc:creator>林静生寒</dc:creator>
<og:description>简介 SpringBoot和Mybatis是啥请自行百度，作者这里也是花了几天时间入门了这个框架用来完成任务，并且也算符合要求的完成了任务，期间也各种百度但是没找到自己想要的那种简单易懂的教程，所以踩</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljsh/p/10928106.html</dc:identifier>
</item>
<item>
<title>设计模式之代理模式（一） - justBobo</title>
<link>http://www.cnblogs.com/justBobo/p/10927408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justBobo/p/10927408.html</guid>
<description>&lt;p&gt;定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。&lt;/p&gt;
&lt;p&gt;组成：&lt;/p&gt;
&lt;p&gt;抽象角色:（主题）通过接口或抽象类声明真实角色实现的业务方法。&lt;/p&gt;
&lt;p&gt;代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/p&gt;
&lt;p&gt;真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;意图&lt;/strong&gt;：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例：&lt;/strong&gt;1、Windows 里面的快捷方式。2、买火车票不一定在火车站买，也可以去代售点。 3、spring aop。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 1、职责清晰。&lt;/p&gt;
&lt;p&gt;　　　　被代理对象只负责自己实际的业务逻辑，不关心其他非本身的职责。并将其他事务可以通过代理类处理。&lt;/p&gt;
&lt;p&gt;　　     2、高扩展性。&lt;/p&gt;
&lt;p&gt;　　　　无论被代理对象如何改变，只要代理类和被代理类都实现了统一接口，都不同修改代理类，而且即使扩展了新的被代理类，代理类也可以使用，只要创建代理类的时候传入对应的被代理类对象。&lt;/p&gt;

&lt;p&gt;　　　 3、智能化。&lt;/p&gt;
&lt;p&gt;　　　　这主要体现在动态代理中，下面会讲解动态代理。如果有兴趣了解Spring的AOP，其实就是使用了动态代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。&lt;/p&gt;
&lt;p&gt;　　     2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt; 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。&lt;/p&gt;
&lt;p&gt;　　　　     2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;

&lt;p&gt;　　我们举个示例，比如在娱乐圈，客户与艺人进行商业合作，一般都不是与艺人直接联系，签订时间、地点、薪酬等合同，而是&lt;/p&gt;
&lt;p&gt;找艺人的经纪人商讨，那么这里商艺活动就是抽象对象（主题），艺人就被代理对象，经纪人就是代理对象。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('208f986e-d21d-4cd1-9c7c-bb45c68addc0')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('208f986e-d21d-4cd1-9c7c-bb45c68addc0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  抽象接口 演艺
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Performance {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sing(String name , String address, String date);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点唱歌&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dance(String name , String address, String date); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点跳舞&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; perform(String name , String address, String date);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点表演&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;抽象对象（主题）&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f17c3dad-defe-47d8-8fb1-77e4db7eda63')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f17c3dad-defe-47d8-8fb1-77e4db7eda63',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  被代理对象 艺人
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Artist &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Performance{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Agent agent;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定代理人对象

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定的代理人对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Performance getAgent(){
        agent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Agent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; agent;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sing(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        System.out.println(date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;rap了一首xX&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            System.out.println( date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;跳了一个芭蕾&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            System.out.println(date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;表演了打篮球&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;被代理对象&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d63f3aa0-93ff-4032-975a-2a4166f66654')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d63f3aa0-93ff-4032-975a-2a4166f66654',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 代理对象 经纪人
 * Created by wanbf on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Agent  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Performance{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存被代理人的实例&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Performance performance;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Agent(Performance performance){

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.performance =&lt;span&gt; performance;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sing(String name, String address, String date) {
        performance.Sing(name,address,date);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里经纪人是不会唱歌的，执行艺人的唱歌 下同&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(String name, String address, String date) {
        performance.dance(name,address,date);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String name, String address, String date) {
        performance.perform(name,address,date);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代理对象&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2518668b-a0ec-4477-a5d5-7f853ae36d93')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2518668b-a0ec-4477-a5d5-7f853ae36d93',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){

        Performance performance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist().getAgent();

        performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));

    }
输出：
&lt;/span&gt;2019-5-26&lt;span&gt;    CXK在韩国rap了一首xX
&lt;/span&gt;2019-5-26&lt;span&gt;    CXK在韩国跳了一个芭蕾
&lt;/span&gt;2019-5-26    CXK在韩国表演了打篮球
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面我们是走指定的代理对象 执行方法；&lt;/p&gt;
&lt;p&gt;那么我们不通过代理方法来执行呢，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b3c67f75-0583-4a7c-ab8f-843bf18f66c8')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b3c67f75-0583-4a7c-ab8f-843bf18f66c8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不通过代理还执行&lt;/span&gt;
Performance performance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist();

performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));

输出：
请使用指定的代理类
请使用指定的代理类
请使用指定的代理类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;不走代理方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;很显然，不用代理方法是不能执行成功的&lt;/p&gt;
&lt;p&gt;不是指定代理方法呢，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是指定的代理方法&lt;/span&gt;
Performance performance = &lt;span&gt;new&lt;/span&gt; Agent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist());

performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
输出：
请使用指定的代理类
请使用指定的代理类
请使用指定的代理类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;不是指定的代理方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;显然不是指定的代理方法也是执行不了的&lt;/p&gt;
&lt;p&gt; 这个示例是强制代理模式，概念就是要从真是角色那里查找到代理角色，不允许直接访问真实角色。&lt;/p&gt;
&lt;p&gt;上层模块只需要调用Agent()获取代理来访问真实角色的所有方法，它根本就不需要产生一个代理角色，代理的管理已经由真实角色自己来完成。&lt;/p&gt;
&lt;p&gt;后续讲解一个 基本代理 、普通代理、虚拟代理模式 和动态代理模式。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:14:00 +0000</pubDate>
<dc:creator>justBobo</dc:creator>
<og:description>一、什么是代理模式 定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。一个类代表另一个类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justBobo/p/10927408.html</dc:identifier>
</item>
<item>
<title>Java设计模式——单例模式 - 程序猿开心</title>
<link>http://www.cnblogs.com/programmerkaixin/p/10927837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/programmerkaixin/p/10927837.html</guid>
<description>&lt;h3 id=&quot;java设计模式单例模式&quot;&gt;Java设计模式——单例模式&lt;/h3&gt;
&lt;p&gt;我一直觉得，设计模式的思想都是源于生活的。单例在生活之中也是经常用到的，比如国家领导人、某某公司创始人......类似这种独一无二的。单例模式也属于创建型设计模式，确保在任何情况下单例类最多只能有一个实例对象，并且提供全局访问点。单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用。反正就是在内存世界里，单例模式的类的实例是独一无二的。当然也有线程单例，就是同一个线程只有一个单例类实例。&lt;/p&gt;
&lt;h3 id=&quot;饿汉式单例&quot;&gt;饿汉式单例&lt;/h3&gt;
&lt;p&gt;类加载的时候就立马初始化生成类的实例对象。不管来没来，先吃饱再说。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供一个单例类的私有的最终的静态全局单例类属性变量。&lt;/li&gt;
&lt;li&gt;私有化单例类的构造方法。&lt;/li&gt;
&lt;li&gt;初始化对象（可以在第一步或者第二步完成）。&lt;/li&gt;
&lt;li&gt;提供全局访问点，用于返回对象实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 饿汉式单例
 * @author: lmc
 * @create: 2019-04-02 20:39
 **/

public class HungrySingletonOne implements Serializable {

    /**
     * 饿汉式单例，在类初始化的时候就进行对象的创建，不存在不同步问题
     */

    //第一步提供一个私有的最终的静态全局属性变量，用于返回对象。
    private static final HungrySingletonOne hungrySingletonOne=new HungrySingletonOne();

    //第二步 私有化构造方法
    private HungrySingletonOne(){
        if(null != hungrySingletonOne){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }

    //提供全局访问点
    public static HungrySingletonOne getInstance(){
        return hungrySingletonOne;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return hungrySingletonOne;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 饿汉式单例
 * @author: lmc
 * @create: 2019-04-02 20:39
 **/

public class HungrySingletonTwo {

    /**
     * 饿汉式单例，在类初始化的时候就进行对象的创建
     */

    //第一步提供一个私有的最终的静态全局属性变量，用于返回对象。
    private static final HungrySingletonTwo hungrySingletonTwo;

    static {
        hungrySingletonTwo=new HungrySingletonTwo();
    }

    //第二步 私有化构造方法
    private HungrySingletonTwo(){
        if(null != hungrySingletonTwo){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }

    //提供全局访问点
    public static HungrySingletonTwo getInstance(){
        return hungrySingletonTwo;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return hungrySingletonTwo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;饿汉式单例利弊&lt;/p&gt;
&lt;p&gt;利：没有加锁，执行效率高，比懒汉式体验好。饿汉式，在单例类加载的时候就已经初始化好了实例对象，不存在线程安全问题，因此没有共享的说法。&lt;/p&gt;
&lt;p&gt;弊：如果单例类不经常使用，占用了内存。&lt;/p&gt;
&lt;p&gt;Spring中 &lt;code&gt;IOC&lt;/code&gt;容器&lt;code&gt;ApplicationContext&lt;/code&gt;本身就是典型的饿汉式单例&lt;/p&gt;
&lt;p&gt;饿汉式单例不存在线程安全问题，这里就不做测试结果展示了，上面的代码都是可以直接运行测试的。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式单例之双重检查锁单例&quot;&gt;懒汉式单例之双重检查锁单例&lt;/h3&gt;
&lt;p&gt;懒汉式单例类在类加载的时候不会初始化类生成单例类的实例，而是在调用单例类获取实例的方法的时候才会去初始化实例对象，并返回一个单例对象。&lt;/p&gt;
&lt;p&gt;因为懒汉式单例，是在单例类的获取实例方法被调用的时候才会去初始化对象，所以存在高并发，线程安全问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronized&lt;/strong&gt;用来保证线程安全问题（原理在这里不细说了）&lt;/p&gt;
&lt;p&gt;根据业务需求，synchronized关键字能不写在方法上就不要写在方法上，写在方法里面。这样可以避免整个类都被锁住，写在方法里面，其他线程还是能够运行这个方法被锁之前的代码的。性能稍微提供提高一点点。所以我们有了双重检查锁单例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 简单的懒汉式单例
 * @author: lmc
 * @create: 2019-04-03 08:59
 **/
public class LazySimpleSingleton implements Serializable {

    //第一步 构造方法私有化,并且设置异常防止反射破坏单例
    private LazySimpleSingleton(){
        if(null != lazySimpleSingleton){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }
    //第二步 定义对象属性
    private static volatile LazySimpleSingleton lazySimpleSingleton=null;

    //第三步 声明全局访问点
    /**
     * @description: 双重检查锁单例
     * @return com.lmc.gp12380.pattern.singleton.lazy.LazySimpleSingleton
     * @date 2019/5/25 21:21
     * @author lmc
     */
    public static LazySimpleSingleton getInstance(){

        if(null == lazySimpleSingleton){//第一次检查
            synchronized (LazySimpleSingleton.class){//加锁 保证线程安全性
                if(null == lazySimpleSingleton){//第二次检查
                    lazySimpleSingleton=new LazySimpleSingleton();
                }
            }
        }
        return lazySimpleSingleton;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return lazySimpleSingleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双重检查锁单例，可以用 &lt;strong&gt;idea&lt;/strong&gt; 的&lt;strong&gt;debug&lt;/strong&gt;线程模式调试测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;关键字的作用在这里不细说，就是用来保证绝对的线程安全。&lt;/p&gt;
&lt;p&gt;定义一个线程执行器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 执行线程
 * @author: lmc
 * @create: 2019-04-03 08:56
 **/
public class ExectorThread implements Runnable {

    public void run() {
        LazySimpleSingleton lazySimpleSingleton=LazySimpleSingleton.getInstance();
        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;lazySimpleSingleton&quot;+lazySimpleSingleton);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 简单懒汉式单例测试
 * @author: lmc
 * @create: 2019-04-03 09:10
 **/
public class LazySimpleSingletonTest {

    public static void main(String[] args){
        
        for (int i = 0; i &amp;lt;10; i++) {
            Thread thread= new Thread(new ExectorThread());
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214547616-705906728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，10个线程获取的对象都是同一个实例。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式单例之静态内部类单例&quot;&gt;懒汉式单例之静态内部类单例&lt;/h3&gt;
&lt;p&gt;静态内部类单例在外部类调用获取实例方法的时候才会初始化实例对象，静态内部类在类加载的时候并不会初始化，只有在创建内部类对象或者，内部类对象静态成员被第一次引用的时候才会初始化对象。然而，对于静态内部类单例来说，我们永远不会主动的去创建内部类对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 懒汉式静态内部类单例
 * @author: lmc
 * @create: 2019-04-03 11:28
 **/
public class LazyInnerClassSingleton implements Serializable {

    //私有化构造方法
    private LazyInnerClassSingleton(){
        if(Holder.lazy != null){//只能调用一次构造创建实例
            throw new RuntimeException(&quot;静态内部类单例，不允许创建多个实例&quot;);
        }
    }

    public static final LazyInnerClassSingleton getInstance(){
        return Holder.lazy;
    }

    /**
     * @description:静态内部类初始化外部类成员变量
     * @date 2019/5/25 22:11
     * @author lmc
     */
    private static class Holder {
        private final static LazyInnerClassSingleton lazy=new LazyInnerClassSingleton();
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return Holder.lazy;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，内部类Holder的静态成员变量 lazy是 final static修饰，无论是创建内部类对象，初始化lazy还是调用静态属性lazy引用初始化都之后初始化一次。并且&lt;code&gt;LazyInnerClassSingleton&lt;/code&gt;单例类只能被内部类实例化一次。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 内部类懒汉式单例测试
 * @author: lmc
 * @create: 2019-04-03 09:10
 **/

public class LazyInnerClassSingletonTest {


    public static void main(String[] args){

        for (int i = 0; i &amp;lt;10 ; i++) {
            Thread thread= new Thread(new Runnable() {
                @Override
                public void run() {
                    LazyInnerClassSingleton lazyInnerClassSingleton =   LazyInnerClassSingleton.getInstance();
                    System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;lazyInnerClassSingleton&quot;+lazyInnerClassSingleton);
                }
            });
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214612945-848053188.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册式单例之容器单例&quot;&gt;注册式单例之容器单例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 容器式单例
 * @author: lmc
 * @create: 2019-04-08 21:43
 **/
public class ContainerSingleton {

    private ContainerSingleton(){};

    private static Map&amp;lt;String,Object&amp;gt; ioc=new ConcurrentHashMap&amp;lt;String, Object&amp;gt;();

    public static Object getBean(String className){
        if(null != className &amp;amp;&amp;amp; className!=&quot;&quot;){
            synchronized (className){
                if(ioc.containsKey(className)){
                    return ioc.get(className);
                }
                Object obj=null;
                try {
                    obj=Class.forName(className).newInstance();
                    ioc.put(className,obj);
                }catch (Exception e){
                    e.printStackTrace();
                }
                return obj;
            }
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要创建很多单例对象，一般用容器式单例管理对象。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;是线程安全的，但是调用&lt;code&gt;getBean&lt;/code&gt;方法不是线程安全的，所有要加&lt;code&gt;synchronized&lt;/code&gt;锁。&lt;/p&gt;
&lt;p&gt;容器式单例就不写测试结果了。&lt;/p&gt;
&lt;h3 id=&quot;注册式单例之枚举单例&quot;&gt;注册式单例之枚举单例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 枚举单例
 * @author: lmc
 * @create: 2019-04-03 15:31
 **/

public enum EnumSingleton {

    INSTENCE;

    private EnumSingleton(){

    }

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance(){
        return INSTENCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举类型重&lt;code&gt;JVM&lt;/code&gt;虚拟机底层就帮我们做了防止序列化和反射破坏单例。&lt;/p&gt;
&lt;p&gt;反编译&lt;code&gt;EnumSingleton.class&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.lmc.gp12380.pattern.singleton.register;


public final class EnumSingleton extends Enum
{

    public static EnumSingleton[] values()
    {
        return (EnumSingleton[])$VALUES.clone();
    }

    public static EnumSingleton valueOf(String name)
    {
        return (EnumSingleton)Enum.valueOf(com/lmc/gp12380/pattern/singleton/register/EnumSingleton, name);
    }

    private EnumSingleton(String s, int i)
    {
        super(s, i);
    }

    public Object getData()
    {
        return data;
    }

    public void setData(Object data)
    {
        this.data = data;
    }

    public static EnumSingleton getInstance()
    {
        return INSTENCE;
    }

    public static final EnumSingleton INSTENCE;
    private Object data;
    private static final EnumSingleton $VALUES[];

    static 
    {
        INSTENCE = new EnumSingleton(&quot;INSTENCE&quot;, 0);
        $VALUES = (new EnumSingleton[] {
            INSTENCE
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译之后枚举 &lt;code&gt;INSTENCE&lt;/code&gt;变成了静态最终变量，由静态代码块饿汉式初始化，&lt;code&gt;EnumSingleton&lt;/code&gt;构造函数也是私有的，不允许外部创建对象。所有枚举符合单例需求。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 枚举单例测试
 * @author: lmc
 * @create: 2019-04-03 15:33
 **/

public class EnumSingletonTest {

    public static void main(String[] args) {

        for (int i = 0; i &amp;lt;10 ; i++) {
            Thread thread=new Thread(new Runnable() {
                @Override
                public void run() {
                    EnumSingleton enumSingleton=EnumSingleton.getInstance();
                    System.out.println(Thread.currentThread().getName()+&quot;enumSingleton&amp;gt;&amp;gt;&quot;+enumSingleton);
                }
            });
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214644649-1296220715.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;反射和序列化破坏单例测试&quot;&gt;反射和序列化破坏单例测试&lt;/h3&gt;
&lt;p&gt;上述代码中，饿汉式和懒汉式，在私有化构造方法中都是有条件抛出异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(condition){
    throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是为了保证单例类只能实例化一次，防止反射破坏单例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private Object readResolve(){
    return hungrySingletonOne;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是重写了&lt;code&gt;Serializable&lt;/code&gt;接口的&lt;code&gt;readResolve&lt;/code&gt;方法，是为了防止序列化破坏单例对象。&lt;/p&gt;
&lt;p&gt;防止反射破坏单例测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 反射破坏单例测试
 * @author: lmc
 * @create: 2019-05-25 23:19
 **/

public class TestReflectDestructionSingleton {

    public static void main(String[] args) {

        try {
            LazyInnerClassSingleton lazyInnerClassSingleton1= LazyInnerClassSingleton.getInstance();
            System.out.println(lazyInnerClassSingleton1);
            Class&amp;lt;?&amp;gt; clazz=LazyInnerClassSingleton.class;
            Constructor c=clazz.getDeclaredConstructor(null);
            c.setAccessible(true);
            LazyInnerClassSingleton lazyInnerClassSingleton2= (LazyInnerClassSingleton) c.newInstance();
            System.out.println(lazyInnerClassSingleton2);
            System.out.println(lazyInnerClassSingleton1==lazyInnerClassSingleton2);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214704863-489046067.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用反射生成实例，直接抛出异常，中断程序运行。客户端调用就不会去利用反射了。&lt;/p&gt;
&lt;p&gt;去掉上面的抛出异常的条件执行测试程序，会出现两个不一样的实例，单例被破坏。&lt;/p&gt;
&lt;p&gt;防止序列化破坏&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 序列化破坏单例测试
 * @author: lmc
 * @create: 2019-05-25 23:13
 **/

public class TestSerializDestructionSingleton {

    public static void main(String[] args) {

        LazyInnerClassSingleton s1 = null;
        LazyInnerClassSingleton s2 = LazyInnerClassSingleton.getInstance();
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;LazyInnerClassSingleton.txt&quot;);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s2);
            oos.flush();
            oos.close();
            FileInputStream fis = new FileInputStream(&quot;LazyInnerClassSingleton.txt&quot;);
            ObjectInputStream ois = new ObjectInputStream(fis);
            s1 = (LazyInnerClassSingleton)ois.readObject();
            ois.close();
            System.out.println(s1);
            System.out.println(s2);
            System.out.println(s1 == s2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214724239-1085933845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;序列化和反序列化生成的对象和之前的对象是一样的，这就说明单例模式有效。&lt;/p&gt;
&lt;p&gt;验证序列化破坏单例只需要去掉重写的&lt;code&gt;readResolve&lt;/code&gt;方法就可以得到两个不一样的实例，单例被破坏。&lt;/p&gt;
&lt;p&gt;反射破坏单例测试和序列化破坏单例只需要更换类就能测试其他单例了，在这就不做测试了。&lt;/p&gt;
&lt;p&gt;注册式容器式单例是从Map集合获取对象，不需要做单例破坏测试。&lt;/p&gt;
&lt;p&gt;注册式枚举式单例是重&lt;code&gt;JVM&lt;/code&gt;层面防止单例破坏。虽然没有加上面的防止破坏代码，也可以用上面的测试代码测试。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:04:00 +0000</pubDate>
<dc:creator>程序猿开心</dc:creator>
<og:description>Java设计模式——单例模式 我一直觉得，设计模式的思想都是源于生活的。单例在生活之中也是经常用到的，比如国家领导人、某某公司创始人......类似这种独一无二的。单例模式也属于创建型设计模式，确保在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/programmerkaixin/p/10927837.html</dc:identifier>
</item>
</channel>
</rss>