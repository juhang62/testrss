<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>多线程编程学习六(Java 中的阻塞队列). - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/11442616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/11442616.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;阻塞队列（BlockingQueue）是指当队列满时，队列会阻塞插入元素的线程，直到队列不满；当队列空时，队列会阻塞获得元素的线程，直到队列变非空。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。&lt;/p&gt;
&lt;p&gt;当线程 插入/获取 动作由于队列 满/空 阻塞后，队列也提供了一些机制去处理，或抛出异常，或返回特殊值，或者线程一直等待...&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;插入方法&lt;/td&gt;
&lt;td&gt;add(e)&lt;/td&gt;
&lt;td&gt;offer(e)&lt;/td&gt;
&lt;td&gt;put(e)&lt;/td&gt;
&lt;td&gt;offer(e, timeout, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;移除方法&lt;/td&gt;
&lt;td&gt;remove(o)&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;poll(timeout, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;检查方法&lt;/td&gt;
&lt;td&gt;element()&lt;/td&gt;
&lt;td&gt;peek() — 不移除元素&lt;/td&gt;
&lt;td&gt;不可用&lt;/td&gt;
&lt;td&gt;不可用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt; 如果是无界阻塞队列，则 put 方法永远不会被阻塞；offer 方法始终返回 true。&lt;/p&gt;
&lt;p&gt;Java 中的阻塞队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1153954/201909/1153954-20190901221615105-2066123573.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;arrayblockingqueue&quot;&gt;ArrayBlockingQueue&lt;/h2&gt;
&lt;p&gt;ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序，默认情况下不保证线程公平的访问。&lt;/p&gt;
&lt;p&gt;通过可重入的独占锁 ReentrantLock 来控制并发，Condition 来实现阻塞。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ArrayBlockingQueueTest {

    /**
     * 1. 由于是有界阻塞队列，需要设置初始大小
     * 2. 默认不保证阻塞线程的公平访问，可设置公平性
     */
    private static ArrayBlockingQueue&amp;lt;String&amp;gt; QUEUE = new ArrayBlockingQueue&amp;lt;&amp;gt;(2, true);

    public static void main(String[] args) throws InterruptedException {

        Thread put = new Thread(() -&amp;gt; {
            // 3. 尝试插入元素
            try {
                QUEUE.put(&quot;java&quot;);
                QUEUE.put(&quot;javaScript&quot;);
                // 4. 元素已满，会阻塞线程
                QUEUE.put(&quot;c++&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        put.start();
        Thread take = new Thread(() -&amp;gt; {
            try {
                // 5. 获取一个元素
                System.out.println(QUEUE.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        take.start();
        // 6 javaScript、c++
        System.out.println(QUEUE.take());
        System.out.println(QUEUE.take());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linkedblockingqueue&quot;&gt;LinkedBlockingQueue&lt;/h2&gt;
&lt;p&gt;LinkedBlockingQueue 是一个用单向链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。&lt;/p&gt;
&lt;p&gt;和 ArrayBlockingQueue 一样，采用 ReentrantLock 来控制并发，不同的是它使用了两个独占锁来控制消费和生产，通过 takeLock 和 putLock 两个锁来控制生产和消费，互不干扰，只要队列未满，生产线程可以一直生产；只要队列不空，消费线程可以一直消费，不会相互因为独占锁而阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt;因为使用了双锁，避免并发计算不准确，使用了一个 AtomicInteger 变量统计元素总量。&lt;/p&gt;
&lt;h2 id=&quot;linkedblockingdeque&quot;&gt;LinkedBlockingDeque&lt;/h2&gt;
&lt;p&gt;LinkedBlockingDeque 是一个由双向链表结构组成的有界阻塞队列，可以从队列的两端插入和移出元素。它实现了BlockingDeque接口，多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以 First 单词结尾的方法，表示插入、获取或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。&lt;/p&gt;
&lt;p&gt;LinkedBlockingDeque 的 Node 实现多了指向前一个节点的变量 prev，以此实现双向队列。并发控制上和 ArrayBlockingQueue 类似，采用单个 ReentrantLock 来控制并发。因为双端队列头尾都可以消费和生产，所以使用了一个共享锁。&lt;/p&gt;
&lt;p&gt;双向阻塞队列可以运用在“工作窃取”模式中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LinkedBlockingDequeTest {

    private static LinkedBlockingDeque&amp;lt;String&amp;gt; DEQUE = new LinkedBlockingDeque&amp;lt;&amp;gt;(2);

    public static void main(String[] args) {
        DEQUE.addFirst(&quot;java&quot;);
        DEQUE.addFirst(&quot;c++&quot;);
        // java
        System.out.println(DEQUE.peekLast());
        // java
        System.out.println(DEQUE.pollLast());
        DEQUE.addLast(&quot;php&quot;);
        // c++
        System.out.println(DEQUE.pollFirst());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt; take() 方法调用的是 takeFirst()，使用时候需注意。&lt;/p&gt;
&lt;h2 id=&quot;priorityblockingqueue&quot;&gt;PriorityBlockingQueue&lt;/h2&gt;
&lt;p&gt;PriorityBlockingQueue 是一个底层由数组实现的无界阻塞队列，并带有排序功能。由于是无界队列，所以插入永远不会被阻塞。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。&lt;/p&gt;
&lt;p&gt;底层同样采用 ReentrantLock 来控制并发，由于只有获取会阻塞，所以只采用一个Condition（只通知消费）来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PriorityBlockingQueueTest {

    private static PriorityBlockingQueue&amp;lt;String&amp;gt; QUEUE = new PriorityBlockingQueue&amp;lt;&amp;gt;();

    public static void main(String[] args) {
        QUEUE.add(&quot;java&quot;);
        QUEUE.add(&quot;javaScript&quot;);
        QUEUE.add(&quot;c++&quot;);
        QUEUE.add(&quot;python&quot;);
        QUEUE.add(&quot;php&quot;);
        Iterator&amp;lt;String&amp;gt; it = QUEUE.iterator();
        while (it.hasNext()) {
            // c++  javaScript  java  python  php
            // 同优先级不保证排序顺序
            System.out.print(it.next() + &quot;  &quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;delayqueue&quot;&gt;DelayQueue&lt;/h2&gt;
&lt;p&gt;DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，元素按延迟优先级排序，延迟时间短的排在前面，只有在延迟期满时才能从队列中提取元素。&lt;/p&gt;
&lt;p&gt;和 PriorityBlockingQueue 相似，底层也是数组，采用一个 ReentrantLock 来控制并发。&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。&lt;/li&gt;
&lt;li&gt;定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，比如 TimerQueue 就是使用 DelayQueue 实现的。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DelayElement implements Delayed, Runnable {

    private static final AtomicLong SEQUENCER = new AtomicLong();
    /**
     * 标识元素先后顺序
     */
    private final long sequenceNumber;
    /**
     * 延迟时间，单位纳秒
     */
    private long time;

    public DelayElement(long time) {
        this.time = System.nanoTime() + time;
        this.sequenceNumber = SEQUENCER.getAndIncrement();
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(time - System.nanoTime(), NANOSECONDS);
    }

    @Override
    public int compareTo(Delayed other) {
        // compare zero if same object
        if (other == this) {
            return 0;
        }
        if (other instanceof DelayElement) {
            DelayElement x = (DelayElement) other;
            long diff = time - x.time;
            if (diff &amp;lt; 0) {
                return -1;
            } else if (diff &amp;gt; 0) {
                return 1;
            } else if (sequenceNumber &amp;lt; x.sequenceNumber) {
                return -1;
            } else {
                return 1;
            }
        }
        long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);
        return (diff &amp;lt; 0) ? -1 : (diff &amp;gt; 0) ? 1 : 0;
    }

    @Override
    public void run() {
        System.out.println(&quot;sequenceNumber&quot; + sequenceNumber);
    }

    @Override
    public String toString() {
        return &quot;DelayElement{&quot; + &quot;sequenceNumber=&quot; + sequenceNumber + &quot;, time=&quot; + time + '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DelayQueueTest {

    private static DelayQueue&amp;lt;DelayElement&amp;gt; QUEUE = new DelayQueue&amp;lt;&amp;gt;();

    public static void main(String[] args) {
        // 1. 添加 10 个参数
        for (int i = 1; i &amp;lt; 10; i++) {
            // 2. 5 秒内随机延迟
            int nextInt = new Random().nextInt(5);
            long convert = TimeUnit.NANOSECONDS.convert(nextInt, TimeUnit.SECONDS);
            QUEUE.offer(new DelayElement(convert));
        }
        // 3. 查询元素排序 —— 延迟短的排在前面
        Iterator&amp;lt;DelayElement&amp;gt; iterator = QUEUE.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        // 4. 可观察到元素延迟输出
        while (!QUEUE.isEmpty()) {
            Thread thread = new Thread(QUEUE.poll());
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linkedtransferqueue&quot;&gt;LinkedTransferQueue&lt;/h2&gt;
&lt;p&gt;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。&lt;/p&gt;
&lt;p&gt;并发控制上采用了大量的 CAS 操作，没有使用锁。&lt;/p&gt;
&lt;p&gt;相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;transfer ： Transfers the element to a consumer, waiting if necessary to do so. 存入的元素必须等到有消费者消费才返回。&lt;/li&gt;
&lt;li&gt;tryTransfer：Transfers the element to a waiting consumer immediately, if possible. 如果有消费者正在等待消费元素，则把传入的元素传给消费者。否则立即返回 false，不用等到消费。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;synchronousqueue&quot;&gt;SynchronousQueue&lt;/h2&gt;
&lt;p&gt;SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则继续 put 操作会被阻塞。&lt;/p&gt;
&lt;p&gt;SynchronousQueue 默认情况下线程采用非公平性策略访问队列，未使用锁，全部通过 CAS 操作来实现并发，吞吐量非常高，高于 LinkedBlockingQueue 和 ArrayBlockingQueue，非常适合用来处理一些高效的传递性场景。Executors.newCachedThreadPool() 就使用了 SynchronousQueue 进行任务传递。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SynchronousQueueTest {

    private static class SynchronousQueueProducer implements Runnable {

        private BlockingQueue&amp;lt;String&amp;gt; blockingQueue;

        private SynchronousQueueProducer(BlockingQueue&amp;lt;String&amp;gt; queue) {
            this.blockingQueue = queue;
        }

        @Override
        public void run() {
            while (true) {
                try {
                    String data = UUID.randomUUID().toString();
                    System.out.println(Thread.currentThread().getName() + &quot; Put: &quot; + data);
                    blockingQueue.put(data);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    private static class SynchronousQueueConsumer implements Runnable {

        private BlockingQueue&amp;lt;String&amp;gt; blockingQueue;

        private SynchronousQueueConsumer(BlockingQueue&amp;lt;String&amp;gt; queue) {
            this.blockingQueue = queue;
        }

        @Override
        public void run() {
            while (true) {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot; take(): &quot; + blockingQueue.take());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static void main(String[] args) {

        final BlockingQueue&amp;lt;String&amp;gt; synchronousQueue = new SynchronousQueue&amp;lt;&amp;gt;();
        SynchronousQueueProducer queueProducer = new SynchronousQueueProducer(synchronousQueue);
        new Thread(queueProducer, &quot;producer - 1&quot;).start();
        SynchronousQueueConsumer queueConsumer1 = new SynchronousQueueConsumer(synchronousQueue);
        new Thread(queueConsumer1, &quot;consumer — 1&quot;).start();
        SynchronousQueueConsumer queueConsumer2 = new SynchronousQueueConsumer(synchronousQueue);
        new Thread(queueConsumer2, &quot;consumer — 2&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;参考书籍：《Java 并发编程的艺术》&lt;/li&gt;
&lt;li&gt;参考博文：&lt;a href=&quot;https://www.cnblogs.com/konck/p/9473677.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/konck/p/9473677.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 04 Sep 2019 00:32:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>介绍 阻塞队列（BlockingQueue）是指当队列满时，队列会阻塞插入元素的线程，直到队列不满；当队列空时，队列会阻塞获得元素的线程，直到队列变非空。阻塞队列就是生产者用来存放元素、消费者用来获取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jmcui/p/11442616.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之基于win32-openssh搭建jenkins混合集群(一) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11456796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11456796.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的demo我们使用的都是只有一个windows主节点的的jenkins,实际生产环境中,一个节点往往是不能满足需求的.比如,.net项目要使用windows节点构建,java项目如果部署在linux服务器上往往也需要目标类型的linux节点做为构建节点,开发中使用的jdk版本不同也可能需要不同的构建主机.构建docker镜像往往也需要linux主机(强烈不建议使用docker for windows 进行linux环境的docker构建).本节我们讲解如何搭建一个主节点为windows server主机,从节点同时包含windows server和centos的jenkins集群&lt;/p&gt;
&lt;p&gt;需要注意的是,由于windows不支持ssh(至少目前绝大多数线上的windows server主机是这样的),因此windows从节点往往是通过&lt;code&gt;JNLP&lt;/code&gt;的方式搭建的.而linux则相对较为简单,只需要配置ssh即可.&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;JNLP&lt;/code&gt;配置从节点虽然也不十分复杂,但是缺点也比较明显.那就是需要在目标主机上启动一个控制台程序,一方面这个程序容易被误关,另一方面如果windows server重启则需要手动把它启动起来,这样极大增加了工作量.如果运维的工作负荷非常高,很可能在一次大规模主机重启后忘记重启一些软件,这样很多错误可能在已经影响使用的情况下才会发现.因此,这里我们探索一种新的方式,即使用微软公司开发的&lt;code&gt;win32-openssh&lt;/code&gt;(现已集成到windows 10和windows server 2019),配置也非常方式.有了win32-openssh,我们就可以像linux主机一样使用ssh方式配置windows从节点.虽然我们提倡使用win32-openssh,但是仍然会介绍如何使用JNLP来配置windows从节点&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;经过笔者测试,win32-openssh支持windows server 2008及以上版本,目前恐怕没有更老的服务器版本了吧,大家不用担心生产环境无法使用的问题.当然,win32-openssh的用途绝不仅限于搭建jenkins混合集群,还可以用它完成更多的基于windows的自动化管理工作.笔者基于win32-openssh做了一套windows服务的自动化管理工具(支持windows服务的关闭,更新,启动,重启,停止,扩容等功能),目前部署在大约30台线上服务器上.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面我们说到要基于win32-openssh来基于ssh配置Jenkins的windows从节点,这节我们就先介绍如何安装win32-openssh,然后紧接着开始使用ssh配置jenkins windows从节点.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;linux从节点ssh配置也是一样,因此不再单独介绍linux从节点的ssh配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们进入&lt;a href=&quot;https://github.com/PowerShell/Win32-OpenSSH/releases&quot;&gt;openssh-win32&lt;/a&gt;github页面进行下载,根据自己系统位数选择32位或者64位的.&lt;/p&gt;
&lt;p&gt;下载完成以后进行解压,把解压后的文件夹放到C盘(也可以是其它盘),然后进入文件夹里面,内容类似如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904082004561-1784548689.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在当前目录下打开powershell(或者从其它位置打开,cd到当前目录),在powershell命令窗口输入&lt;code&gt;.\install-sshd.ps1&lt;/code&gt;,执行安装命令.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;如果在执行过程中powershell报错,提示权限不足,则进行以下设置&lt;code&gt;Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process&lt;/code&gt;,很多网上的教程没有指定scope,则很容易造成安全问题,在个人电脑上无所谓,在服务器上一定要重视过高的权限.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完了以后再执行&lt;code&gt;FixHostFilePermissions.ps1&lt;/code&gt;和&lt;code&gt;FixUserFilePermissions.ps1&lt;/code&gt;这两个文件.(在powershell命令窗口输入&lt;code&gt;.\文件名&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&quot;启动ssh服务.&quot;&gt;启动ssh服务.&lt;/h2&gt;
&lt;p&gt;安装完成以后,ssh相关服务默认是不启动的,我们打开服务管理界面,手动启动它们并把启动类型设置为自动,这样服务器重启开机时ssh相关的服务就会自动启动.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904081956937-269763319.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows10开启ssh&quot;&gt;windows10开启ssh&lt;/h2&gt;
&lt;p&gt;windows较新的版本已集成了openssh,但是需要手动开启它.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入&lt;code&gt;我的电脑&lt;/code&gt;,然后点击上面的&lt;code&gt;计算机&lt;/code&gt;标签,然后选择&lt;code&gt;卸载或更新应用&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904081950096-842604219.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在出现的界面里选择&lt;code&gt;管理额外功能&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904081941886-1277213689.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;添加功能&lt;/code&gt;,然后在出现的列表里找到ssh相关的功能,都添加上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904081933538-1107572206.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;把openssh所在文件夹添加到path&quot;&gt;把openssh所在文件夹添加到path&lt;/h2&gt;
&lt;p&gt;我们把win32-openssh所在文件夹路径添加到环境变量path里,这样我们就可以在控制台输入&lt;code&gt;ssh&lt;/code&gt;命令来连接远程主机,而不需要类似xshell,putty这样的终端工具.&lt;/p&gt;
&lt;h2 id=&quot;生成ssh-key&quot;&gt;生成ssh key&lt;/h2&gt;
&lt;p&gt;添加完环境变量后,我们打开cmd或者powershell命令窗口,输入&lt;code&gt;ssh-keygen&lt;/code&gt;命令,生成ssh key,输入命令后一路回车.最终生成的key存放在&lt;code&gt;C:/Users/当前用户名/.ssh/&lt;/code&gt;目录下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190904081925975-958695326.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;id_rsa&lt;/code&gt;为私钥,&lt;code&gt;id_rsa.pub&lt;/code&gt;为公钥,&lt;code&gt;authorized_keys&lt;/code&gt;为授权访问本机的远程电脑的公钥,&lt;code&gt;known_hosts&lt;/code&gt;为,初次访问远程主机时存储的信息.晚些时候我们会用到这些文件.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;安装完ssh以后如果忘记了它的安装位置,打开命令窗口,输入&lt;code&gt;where ssh&lt;/code&gt;就可以看到ssh.exe所在的目录.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 04 Sep 2019 00:28:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 前面的demo我们使用的都是只有一个windows主节点的的jenkins,实际生产环境中,一个节点往往是不能满足需求的.比如,.net项目要使用windows节点构建,java项目如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11456796.html</dc:identifier>
</item>
<item>
<title>机器学习项目实战----新闻分类任务(二) - |旧市拾荒|</title>
<link>http://www.cnblogs.com/xiaoyh/p/11453364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyh/p/11453364.html</guid>
<description>&lt;p&gt;&lt;span&gt;TF-IDF关键词提取&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import jieba.analyse
index = 2400
print(df_news['content'][index])
content_S_str = ''.join(content_S[index])

# 提取关键词
print(&quot;  &quot;.join(jieba.analyse.extract_tags(content_S_str,topK=5,withWeight = False)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以得到第2400条数据以及关键词&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;法国ＶＳ西班牙、里贝里ＶＳ哈维，北京时间６月２４日凌晨一场的大战举世瞩目，而这场胜利不仅仅关乎两支顶级强队的命运，同时也是他们背后&lt;br/&gt;的球衣赞助商耐克和阿迪达斯之间的一次角逐。Ｔ谌胙”窘炫分薇的１６支球队之中，阿迪达斯和耐克的势力范围也是几乎旗鼓相当：其中有５家球&lt;br/&gt;衣由耐克提供，而阿迪达斯则赞助了６家，此外茵宝有３家，而剩下的两家则由彪马赞助。而当比赛进行到现在，率先挺进四强的两支球队分别被耐&lt;br/&gt;克支持的葡萄牙和阿迪达斯支持的德国占据，而由于最后一场１／４决赛是茵宝（英格兰）和彪马（意大利）的对决，这也意味着明天凌晨西班牙同&lt;br/&gt;法国这场阿迪达斯和耐克在１／４决赛的唯一一次直接交手将直接决定两家体育巨头在此次欧洲杯上的胜负。８据评估，在２０１２年足球商品的销&lt;br/&gt;售额能总共超过４０亿欧元，而单单是不足一个月的欧洲杯就有高达５亿的销售额，也就是说在欧洲杯期间将有７００万件球衣被抢购一空。根据市&lt;br/&gt;场评估，两大巨头阿迪达斯和耐克的市场占有率也是并驾齐驱，其中前者占据３８％，而后者占据３６％。体育权利顾问奥利弗－米歇尔在接受《队&lt;br/&gt;报》采访时说：“欧洲杯是耐克通过法国翻身的一个绝佳机会！”Ｃ仔尔接着谈到两大赞助商的经营策略：“竞技体育的成功会燃起球衣购买的热情，&lt;br/&gt;不过即便是水平相当，不同国家之间的欧洲杯效应却存在不同。在德国就很出色，大约１／４的德国人通过电视观看了比赛，而在西班牙效果则差很&lt;br/&gt;多，由于民族主义高涨的加泰罗尼亚地区只关注巴萨和巴萨的球衣，他们对西班牙国家队根本没什么兴趣。”因此尽管西班牙接连拿下欧洲杯和世界&lt;br/&gt;杯，但是阿迪达斯只为西班牙足协支付每年２６００万的赞助费＃相比之下尽管最近两届大赛表现糟糕法国足协将从耐克手中每年可以得到４０００&lt;br/&gt;万欧元。米歇尔解释道：“法国创纪录的４０００万欧元赞助费得益于阿迪达斯和耐克竞逐未来１５年欧洲市场的竞争。耐克需要笼络一个大国来打&lt;br/&gt;赢这场欧洲大陆的战争，而尽管德国拿到的赞助费并不太高，但是他们却显然牢牢掌握在民族品牌阿迪达斯手中。从长期投资来看，耐克给法国的&lt;br/&gt;赞助并不算过高。”
耐克  阿迪达斯  欧洲杯  球衣  西班牙&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从最后一句话就可以大致得到这段文章的大致意思，那这些词就是这段文章的关键词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;LDA（Latent Dirichlet Allocation）是一种文档主题生成模型&lt;/span&gt;，它是一种主题模型，它包含文章，主题和词三个部分，它可以将文档集中每篇文档的主题以概率分布的形式给出，从而通过分析一些文档抽取出它们的主题（分布）出来后，便可以根据主题（分布）进行主题聚类或文本分类。同时，它是一种典型的词袋模型，即一篇文档是由一组词构成，词与词之间没有先后顺序的关系。此外，一篇文档可以包含多个主题，文档中每一个词都由其中的一个主题生成。&lt;span&gt;LDA就是要干的事就是根据给定的一篇文档，推测其主题分布&lt;/span&gt;。&lt;span&gt;它是一个无监督学习&lt;/span&gt;，类似于聚类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导入gensim库，需要自己手动安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pip install gensim
from gensim import corpora,models,similarities
import gensim # 自然语言处理库
#http://radimrehurek.com/gensim/  # 需要用时可以自行查阅官方文档
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进行词映射，相当于一个大的字典，每一个词汇进行一个映射。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 做映射，相当于词袋 格式要求：list of list
dictionary = corpora.Dictionary(contents_clean) # 字典
corpus = [dictionary.doc2bow(sentence) for sentence in contents_clean] # 语料
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进行LDA建模，&lt;span&gt;将整个语料库划分为20个主题&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# num_topics=20 类似Kmeans自己指定K值
lda = gensim.models.ldamodel.LdaModel(corpus=corpus,id2word=dictionary,num_topics=20)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看第1号主题的结果，然后选出这个主题中&lt;span&gt;权重值&lt;/span&gt;最高的5个关键词。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 一号分类结果
print(lda.print_topic(1, topn=5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分类后结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
0.008*&quot;说&quot; + 0.007*&quot;男人&quot; + 0.005*&quot;爱情&quot; + 0.005*&quot;中&quot; + 0.004*&quot;离婚&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看这20个主题的关键词&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
for topic in lda.print_topics(num_topics=20,num_words=5):
    print(topic[1])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0.007*&quot;孩子&quot; + 0.004*&quot;Ｐ&quot; + 0.003*&quot;高校&quot; + 0.003*&quot;ａ&quot; + 0.003*&quot;说&quot;
0.008*&quot;说&quot; + 0.007*&quot;男人&quot; + 0.005*&quot;爱情&quot; + 0.005*&quot;中&quot; + 0.004*&quot;离婚&quot;
0.008*&quot;中&quot; + 0.007*&quot;说&quot; + 0.005*&quot;观众&quot; + 0.005*&quot;ａ&quot; + 0.004*&quot;男人&quot;
0.020*&quot;男人&quot; + 0.014*&quot;女人&quot; + 0.008*&quot;说&quot; + 0.005*&quot;中&quot; + 0.005*&quot;孩子&quot;
0.018*&quot;ｅ&quot; + 0.015*&quot;ａ&quot; + 0.012*&quot;ｉ&quot; + 0.010*&quot;ｏ&quot; + 0.008*&quot;ｌ&quot;
0.021*&quot;电影&quot; + 0.018*&quot;导演&quot; + 0.010*&quot;影片&quot; + 0.008*&quot;中&quot; + 0.006*&quot;主演&quot;
0.009*&quot;节目&quot; + 0.007*&quot;中&quot; + 0.006*&quot;说&quot; + 0.004*&quot;主持人&quot; + 0.004*&quot;吃&quot;
0.006*&quot;学校&quot; + 0.004*&quot;工作&quot; + 0.004*&quot;学生&quot; + 0.004*&quot;高考&quot; + 0.004*&quot;中&quot;
0.012*&quot;ａ&quot; + 0.012*&quot;ｎ&quot; + 0.010*&quot;中&quot; + 0.010*&quot;ｅ&quot; + 0.010*&quot;ｏ&quot;
0.008*&quot;中国&quot; + 0.005*&quot;中&quot; + 0.004*&quot;创作&quot; + 0.004*&quot;西班牙&quot; + 0.004*&quot;说&quot;
0.013*&quot;官兵&quot; + 0.007*&quot;部队&quot; + 0.006*&quot;武警&quot; + 0.004*&quot;万&quot; + 0.003*&quot;中&quot;
0.005*&quot;中&quot; + 0.005*&quot;Ｓ&quot; + 0.004*&quot;Ｖ&quot; + 0.004*&quot;Ｌ&quot; + 0.004*&quot;Ｎ&quot;
0.010*&quot;Ｍ&quot; + 0.005*&quot;Ｐ&quot; + 0.005*&quot;张绍&quot; + 0.005*&quot;Ｉ&quot; + 0.004*&quot;Ｓ&quot;
0.008*&quot;中&quot; + 0.006*&quot;中国&quot; + 0.006*&quot;观众&quot; + 0.005*&quot;说&quot; + 0.004*&quot;比赛&quot;
0.005*&quot;万&quot; + 0.003*&quot;号&quot; + 0.003*&quot;公司&quot; + 0.002*&quot;Ｔ&quot; + 0.002*&quot;壮阳&quot;
0.007*&quot;Ｓ&quot; + 0.006*&quot;号&quot; + 0.004*&quot;万&quot; + 0.004*&quot;ａ&quot; + 0.004*&quot;中&quot;
0.004*&quot;中国&quot; + 0.004*&quot;产品&quot; + 0.003*&quot;欧洲杯&quot; + 0.003*&quot;中&quot; + 0.003*&quot;化妆水&quot;
0.005*&quot;中&quot; + 0.005*&quot;万&quot; + 0.004*&quot;排毒&quot; + 0.003*&quot;纹身&quot; + 0.003*&quot;号&quot;
0.005*&quot;中&quot; + 0.005*&quot;比赛&quot; + 0.004*&quot;食物&quot; + 0.003*&quot;香港&quot; + 0.003*&quot;营养&quot;
0.010*&quot;考生&quot; + 0.008*&quot;中&quot; + 0.004*&quot;发展&quot; + 0.004*&quot;文化&quot; + 0.003*&quot;中国&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;先将清洗好的数据转换为pandas支持的DataFrame格式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
df_train=pd.DataFrame({'contents_clean':contents_clean,'label':df_news['category']})
df_train.tail()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190902230838457-1424529594.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看数据集所有类别&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
df_train.label.unique()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;array(['汽车', '财经', '科技', '健康', '体育', '教育', '文化', '军事', '娱乐', '时尚'],
      dtype=object)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用pandas对类别进行映射&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
label_mapping = {&quot;汽车&quot;: 1, &quot;财经&quot;: 2, &quot;科技&quot;: 3, &quot;健康&quot;: 4, &quot;体育&quot;:5, &quot;教育&quot;: 6,&quot;文化&quot;: 7,&quot;军事&quot;: 8,&quot;娱乐&quot;: 9,&quot;时尚&quot;: 0}
df_train['label'] = df_train['label'].map(label_mapping)
df_train.head()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的结果是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190903140946832-359833168.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面开始常规的机器学习套路进行分类，首先划分训练集与测试集&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(df_train['contents_clean'].values, df_train['label'].values, random_state=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看训练集&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#x_train = x_train.flatten()
x_train[0][1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;训练集数据转为字符串数据，为了符合下面输入数据的格式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
words = []
for line_index in range(len(x_train)):
    try:
        #x_train[line_index][word_index] = str(x_train[line_index][word_index])
        words.append(' '.join(x_train[line_index]))
    except:
        print(line_index,word_index)
words[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的第0条数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
'中新网 上海 日电 于俊 父亲节 网络 吃 一顿 电影 快餐 微 电影 爸 对不起 我爱你 定于 本月 父亲节 当天 各大 视频 网站 &lt;br/&gt;首映 葜 谱 鞣 剑 保慈 障蚣 钦 呓 樯 埽 ⒌ 缬 埃 ǎ 停 椋 悖 颍 铩 妫 椋 恚 称 微型 电影 新 媒体 平台 播放 状态 &lt;br/&gt;短时 休闲 状态 观看 完整 策划 系统 制作 体系 支持 显示 较完整 故事情节 电影 微 超短 放映 微 周期 制作 天 数周 微 &lt;br/&gt;规模 投资 人民币 几千 数万元 每部 内容 融合 幽默 搞怪 时尚 潮流 人文 言情 公益 教育 商业 定制 主题 单独 成篇 系列&lt;br/&gt;成剧 唇 开播 微 电影 爸 对不起 我爱你 讲述 一对 父子 观念 缺少 沟通 导致 关系 父亲 传统 固执 钟情 传统 生活 方式&lt;br/&gt;儿子 新派 音乐 达 习惯 晚出 早 生活 性格 张扬 叛逆 两种 截然不同 生活 方式 理念 差异 一场 父子 间 拉开序幕 子 失&lt;br/&gt;手 打破 父亲 心爱 物品 父亲 赶出 家门 剧情 演绎 父亲节 妹妹 哥哥 化解 父亲 这场 矛盾 映逋坏 嚼 斫 狻 ⒍ 粤 ⒌ 桨&lt;br/&gt;容 争执 退让 传统 尴尬 父子 尴尬 情 男人 表达 心中 那份 感恩 一杯 滤挂 咖啡 父亲节 变得 温馨 镁 缬 缮 虾 Ｎ 逄 煳&lt;br/&gt;幕 传播 迪欧 咖啡 联合 出品 出品人 希望 观摩 扪心自问 父亲节 父亲 记得 父亲 生日 哪一天 父亲 爱喝 跨出 家门 那一&lt;br/&gt;刻 感觉 一颗 颤动 心 操劳 天下 儿女 父亲节 大声 喊出 父亲 家人 爱 完'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打印word的长度&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
print(len(words))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;word长度为&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用一个小例子用sklearn将词转换为&lt;span&gt;词频向量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.feature_extraction.text import CountVectorizer
texts=['dog cat fish','dog cat cat','fish bird','bird'] # 注意text格式
cv = CountVectorizer()
cv_fit = cv.fit_transform(texts)

print(cv.get_feature_names())
print(cv_fit.toarray())

print(cv_fit.toarray().sum(axis=0))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果是&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;['bird', 'cat', 'dog', 'fish']
[[0 1 1 1]
 [0 2 1 0]
 [1 0 0 1]
 [1 0 0 0]]
[2 3 2 2]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;改变参数试一下，&lt;span&gt;ngram_range&lt;/span&gt;表示1到4个词进行组合，让向量更加复杂&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.feature_extraction.text import CountVectorizer
texts=[&quot;dog cat fish&quot;,&quot;dog cat cat&quot;,&quot;fish bird&quot;, 'bird']
cv = CountVectorizer(ngram_range=(1,4))
cv_fit=cv.fit_transform(texts)

print(cv.get_feature_names())
print(cv_fit.toarray())


print(cv_fit.toarray().sum(axis=0))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的向量为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1126989/201909/1126989-20190902231640657-475356894.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在使用sklearn对上面构造的数据(也就是特定格式的数据)转换为词频向量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.feature_extraction.text import CountVectorizer

vec = CountVectorizer(analyzer='word', max_features=4000,  lowercase = False)
vec.fit(words)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;构造的模型为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CountVectorizer(analyzer='word', binary=False, decode_error='strict',
                dtype=&amp;lt;class 'numpy.int64'&amp;gt;&lt;span&gt;, encoding='utf-8', input='content',
                lowercase=False, max_df=1.0, max_features=4000, min_df=1,
                ngram_range=(1, 1), preprocessor=None, stop_words=None,
                strip_accents=None, token_pattern='(?u)\\b\\w\\w+\\b',
                tokenizer=None, vocabulary=None)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后使用贝叶斯算法完成结果分类，传入的参数是刚才的词频向量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.naive_bayes import MultinomialNB
classifier = MultinomialNB()
classifier.fit(vec.transform(words), y_train)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;构造的模型为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是将数据转换为字符串，使用测试集来进行测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
test_words = []
for line_index in range(len(x_test)):
    try:
        #x_train[line_index][word_index] = str(x_train[line_index][word_index])
        test_words.append(' '.join(x_test[line_index]))
    except:
         print (line_index,word_index)
test_words[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看得到的测试集(也要符合输入的格式)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
'国家 公务员 考试 申论 应用文 类 试题 实质 一道 集 概括 分析 提出 解决问题 一体 综合性 试题 说 一道 客观 &lt;br/&gt;凝练 申发 论述 文章 题目 分析 历年 国考 申论 真题 公文 类 试题 类型 多样 包括 公文 类 事务性 文书 类 题&lt;br/&gt;材 从题 干 作答 材料 内容 整合 分析 无需 太 创造性 发挥 纵观 历年 申论 真题 作答 应用文 类 试题 文种 格&lt;br/&gt;式 作出 特别 重在 内容 考查 行文 格式 考生 平常心 面对 应用文 类 试题 准确 把握 作答 领会 内在 含义 把&lt;br/&gt;握 题材 主旨 材料 结构 轻松 应对 应用文 类 试题 Ｒ 弧 ⒆ 钒 盐 展文 写作 原则 Ｔ 材料 中来 应用文 类 试&lt;br/&gt;题 材料 总体 把握 客观 考生 材料 中来 材料 中 把握 材料 准确 理解 题材 主旨 Ｔ 政府 角度 作答 应用文 类&lt;br/&gt;试题 更应 注重 政府 角度 观点 政府 角度 出发 原则 表述 观点 提出 解决 之策 考生 作答 站 政府 人员 角度&lt;br/&gt;看待 提出 解决问题 Ｔ 文体 结构 形式 考查 重点 文体 结构 大部分 评分 关键点 解答 方法 薄 ⒆ ス 丶 词 &lt;br/&gt;明 方向 作答 题目 题干 作答 作答 方向 作答 角度 关键 向导 考生 仔细阅读 题干 作答 抓住 关键词 作答 方向&lt;br/&gt;相关 要点 整理 作答 思路 年国考 地市级 真 题为 例 潦惺姓 府 宣传 推进 近海 水域 污染 整治 工作 请 给定&lt;br/&gt;资料 市政府 工作人员 身份 草拟 一份 宣传 纲要 Ｒ 求 保对 宣传 内容 要点 提纲挈领 陈述 玻 体现 政府 精&lt;br/&gt;神 全市 各界 关心 支持 污染 整治 工作 通俗易懂 超过 字 肮 丶 词 近海 水域 污染 整治 工作 市政府 工作人&lt;br/&gt;员 身份 宣传 纲要 提纲挈领 陈述 体现 政府 精神 全市 各界 关心 支持 污染 整治 工作 通俗易懂 提示 归结 &lt;br/&gt;作答 要点 包括 污染 情况 原因 解决 对策 作答 思路 情况 原因 对策 意义 逻辑 顺序 安排 文章 结构 病 ⒋ &lt;br/&gt;缶殖 龇 ⅲ 明 结构 解答 应用文 类 试题 考生 材料 整体 出发 大局 出发 高屋建瓴 把握 材料 主题 思想 事件&lt;br/&gt;起因 解决 对策 阅读文章 构建 文章 结构 直至 快速 解答 场 ⒗ 硭 乘悸 罚明 逻辑 应用文 类 试题 严密 逻&lt;br/&gt;辑思维 情况 原因 对策 意义 考生 作答 先 弄清楚 解答 思路 统筹安排 脉络 清晰 逻辑 表达 内容 表述 础 &lt;br/&gt;把握 明 详略 考生 仔细阅读 分析 揣摩 应用文 类 试题 内容 答题 时要 详略 得当 主次 分明 安排 内容 增加 &lt;br/&gt;文章 层次感 阅卷 老师 阅卷 时能 明白 清晰 一目了然 玻埃 保蹦旯 考 考试 申论 试卷 分为 省级 地市级 两套&lt;br/&gt;试卷 能力 大有 省级 申论 试题 考生 宏观 角度看 注重 深度 广度 考生 深谋远虑 地市级 试题 考生 微观 视角&lt;br/&gt;观察 侧重 考查 解决 能力 考生 贯彻执行 作答 区别对待'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看预测准确率为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
classifier.score(vec.transform(test_words), y_test)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;准确率为：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在可以使用另外一种方式来&lt;span&gt;构造TF-IDF向量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.feature_extraction.text import TfidfVectorizer

vectorizer = TfidfVectorizer(analyzer='word', max_features=4000,  lowercase = False)
vectorizer.fit(words)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;构造的模型&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TfidfVectorizer(analyzer='word', binary=False, decode_error='strict',
                dtype=&amp;lt;class 'numpy.float64'&amp;gt;&lt;span&gt;, encoding='utf-8',
                input='content', lowercase=False, max_df=1.0, max_features=4000,
                min_df=1, ngram_range=(1, 1), norm='l2', preprocessor=None,
                smooth_idf=True, stop_words=None, strip_accents=None,
                sublinear_tf=False, token_pattern='(?u)\\b\\w\\w+\\b',
                tokenizer=None, use_idf=True, vocabulary=None)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;继续贝叶斯算法来建模&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.naive_bayes import MultinomialNB
classifier = MultinomialNB()
classifier.fit(vectorizer.transform(words), y_train)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的模型为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看预测准确率&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
classifier.score(vectorizer.transform(test_words), y_test)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的结果为：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看出通过TF-IDF向量得到的结果更好一些，我们也可以更改上面的ngram_range的值来使结果更好，一般来说值为2就足够了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在这个新闻分类的案例中，我们了解了文本分析一般的处理步骤&lt;span&gt;分词、词频统计、词频向量或者TF-IDF向量、最后相似度的计算&lt;/span&gt;。还学习了&lt;span&gt;jieba&lt;/span&gt;分词库的使用，还有&lt;span&gt;停用词表&lt;/span&gt;的使用，还有&lt;span&gt;TF-IDF&lt;/span&gt;关键词提取以及&lt;span&gt;LDA&lt;/span&gt;主题模型，后面还使用到了&lt;span&gt;词云&lt;/span&gt;来进行词频的可视化展示，最后还使用到了自然语言处理库&lt;span&gt;gensim&lt;/span&gt;，然后使用机器学习中的&lt;span&gt;贝叶斯算法&lt;/span&gt;进行最终的分类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还有就是最重要的一点就是学习使用陌生的python库最好是找官方教程进行模仿学习，先把结果进行跑通然后再进行深入的学习。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 04 Sep 2019 00:22:00 +0000</pubDate>
<dc:creator>|旧市拾荒|</dc:creator>
<og:description>五、TF-IDF以及LDA主题模型 TF-IDF关键词提取 可以得到第2400条数据以及关键词 从最后一句话就可以大致得到这段文章的大致意思，那这些词就是这段文章的关键词。 LDA（Latent Di</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyh/p/11453364.html</dc:identifier>
</item>
<item>
<title>Linux之Shell编程(16) - 酷学大叔</title>
<link>http://www.cnblogs.com/az4215/p/11456767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/az4215/p/11456767.html</guid>
<description>&lt;p&gt;&lt;span&gt;读取从控制台输入的值（read）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190904075346813-75265975.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　basename：返回完整路径最后/部分，常用于获取文件名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　basename [pathname] [suffix]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190904075957368-2087087246.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　dirname：返回完整路径最后/的前面部分，常用于返回路径部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190904080158146-655458685.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190904081041816-1468580596.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;综合案例：定时维护数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、每天凌晨2:10备份数据库myTestDB到/data/backup/db&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、备份开始和结束给予相应提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190904084316550-1057293686.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在crond中添加定时任务 &lt;/span&gt;&lt;span&gt;crontab -e &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　10 2 * * * sh文件&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Sep 2019 00:13:00 +0000</pubDate>
<dc:creator>酷学大叔</dc:creator>
<og:description>读取从控制台输入的值（read）： 系统函数： basename：返回完整路径最后/部分，常用于获取文件名 basename [pathname] [suffix] dirname：返回完整路径最后/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/az4215/p/11456767.html</dc:identifier>
</item>
<item>
<title>Java NIO之理解I/O模型 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/11450667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/11450667.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;自己以前在Java NIO这块儿，一直都是比较薄弱的，以前还因为这点知识而错失了一个机会。所以最近打算好好学习一下这部分内容，我想应该也会有朋友像我一样，一直想闹明白这块儿内容。但是一直无从下手，每次被问到什么NIO，BIO，AIO就慌，下面我们先从一些基本概念来慢慢了解NIO这部分内容。&lt;/p&gt;
&lt;h2&gt;同步与异步&lt;/h2&gt;
&lt;p&gt;同步和异步是比较好理解的，网上也有好多解释。下面我通过个人的理解来解释这两个概念可能会通俗一些，希望能更好理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;span&gt;就是多个任务或事件在执行时需要按顺序逐个执行，如果排在顺序前面的任务或事件在执行的时候，排在后面的任务或事件就需要等待前面的执行完后才可以执行，这些任务或事件是不能并行执行的&lt;/span&gt;&lt;/strong&gt;。同步执行任务可以被设计为可靠的任务序列，前后两个任务可以保持一致才算整个任务结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;span&gt;是多个任务或事件可以同时并行执行，前面的任务不会导致后面的任务的等待&lt;/span&gt;&lt;/strong&gt;。因为是多个任务同时进行的，所以每个任务之间不产生相互的依赖，所以无法保证可靠性。&lt;/p&gt;
&lt;p&gt;同步流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190902235132996-660324540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异步流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190903000032601-1472302618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
    System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;test1&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
    System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;test2&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
    System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;test3&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        test1();
        test2();
        test3();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按顺序逐个执行的方法，test3会等待test1和test2都执行完后再执行。&lt;/p&gt;
&lt;p&gt;异步示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testA(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;testA&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
            }
        }.start();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testB(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;testB&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
            }
        }.start();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testC(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;testC&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;span&gt;);
            }
        }.start();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        testA();
        testB();
        testC();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段异步代码可以看出，testA、testB、testC三个方法各自有自己的线程来执行任务，五项不依赖所以不会造成有任务等待的情况。典型的异步处理机制。&lt;/p&gt;
&lt;p&gt;虽然上面的异步用了三个线程来实现了，但是并不代表多线程就是异步，这是两个概念，多线程只是实现异步的一种方式。而异步是一种处理模式，除了多线程还可以有其他的方式来实现。&lt;/p&gt;
&lt;p&gt;在生活中的例子我们在打电话的时候就相当于同步，只有对方接通了才算任务执行成功。而发短信则是异步，短信发送后并不依赖接收者是否接收成功。&lt;/p&gt;
&lt;h2&gt;阻塞与非阻塞&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;阻塞&lt;span&gt;是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，那么就会一直等待，直到条件满足后，才继续执行后面的其他工作&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非阻塞&lt;span&gt;是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，会立即返回一个标志信息告知条件不满足，而不会一直在等待下去&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;阻塞流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190903010837823-947403378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;非阻塞流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190903011515281-2072868827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有的人总是把同步、异步，与阻塞、非阻塞， 这两组概念给理解混了，但是其实这是两组完全不同的概念。&lt;/p&gt;
&lt;p&gt;同步与异步这组概念的重点在于，前面的任务是否会导致整个流程的等待。&lt;/p&gt;
&lt;p&gt;阻塞与非阻塞这组概念的重点在于，如果操作请求不满足条件是否会返回一个标志信息告知不满足条件。&lt;/p&gt;
&lt;p&gt;其实理解阻塞与非阻塞可以从我们通常所接触的线程阻塞来理解，当出现慢任务的时候，线程会发生阻塞，cpu会等待慢任务执行完成后再执行后续的任务。而非阻塞线程在执行这个慢任务的时候，会去做其他事情，当慢任务执行完成后，再去执行后面的任务。非阻塞虽然看似可以明显提高效率，但是系统的线程切换也是会造成时间损耗，所以需要合理利用。&lt;/p&gt;
&lt;h2&gt;同步IO与异步IO&lt;/h2&gt;
&lt;p&gt;同步IO是指，当一个线程在执行IO操作时，该线程在IO操作完成前，是会被阻塞的。&lt;/p&gt;
&lt;p&gt;异步IO是指，当一个线程在执行IO操作时，该线程并不会被阻塞。 &lt;/p&gt;
&lt;p&gt;IO操作其实是有一个过程的，我们拿网络IO为例，一个网络IO主要会涉及到两个对象，一个是调用这个IO得线程，另一个是系统内核。当一个read操作发生时，会经历两个阶段。&lt;/p&gt;
&lt;p&gt;1、等待数据准备就绪。&lt;/p&gt;
&lt;p&gt;2、将数据从内核拷贝到调用调用这个IO得线程中。&lt;/p&gt;
&lt;p&gt;IO模型的区别主要都在这两个阶段上面所以很重要，我们所说的同步与异步的区别，在于第二个阶段中，将数据从内核拷贝到线程（或进程）中，如果被阻塞了就同步，没有被阻塞就是异步。被阻塞了说明该阶段的操作是依赖用户线程的，而没有被阻塞说明不依赖用户线程，而依赖内核，所以异步是需要操作系统内核支持的。&lt;/p&gt;
&lt;h2&gt;阻塞IO与非阻塞IO&lt;/h2&gt;
&lt;p&gt;上面我们在介绍同步IO与非同步IO的时候说到，同步与不同步的区别在IO操作的第二个阶段，这节我们说的阻塞IO与非阻塞IO则是发生在IO操作第一个阶段的。&lt;/p&gt;
&lt;p&gt;阻塞IO是指当一个线程发起IO操作请求时，系统内核会去查看要操作的数据是否就绪，当是阻塞IO时，发现要操作是数据没有就绪，就会一直等待下去，直到数据准备就绪；当是非阻塞IO时如果数据没有准备好，就会返回一个标识信息告诉调用线程，当前操作数据没有准备就绪。当数据准备就绪后才会执行第一阶段。&lt;/p&gt;
&lt;p&gt;其实阻塞IO与非阻塞IO的关键区别在于，是等待执行，还是说立即返回一个通知标识。当数据没有准备好时就等待执行，而当立即返回一个通知标识时，线程会根据标识知道现在数据是个什么情况，如果没有准备好，那么线程会再次发起请求，知道数据准备好后立即执行。&lt;/p&gt;
&lt;h2&gt;两种方式的组合&lt;/h2&gt;
&lt;p&gt;虽然异步和非阻塞能够提升I/O的性能，但是也会带来一些额外的性能成本，例如：会增加线程数量，从而增加CPU的消耗，同时也会导致程序设计复杂度的上升。如果设计的不合理反而会导致性能下降，在实际设计时要分解应用场景总和评估。&lt;/p&gt;
&lt;p&gt;下面这个表格就列出了同步异步与阻塞非阻塞组合起来的性能分析。&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;组合方式&lt;/td&gt;
&lt;td&gt;性能分析&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot;&gt;同步阻塞&lt;/td&gt;
&lt;td&gt;最常用的一种用法，使用也是最简单的，但是I/O性能一般很差，CPU大部分处于空闲状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td align=&quot;center&quot;&gt;同步非阻塞&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;　　提升I/O性能的常用手段，就是将I/O的阻塞改为非阻塞方式，尤其在网络I/O是长连接同事传输&lt;/p&gt;
&lt;p&gt;数据也不很多的情况下，提升性能非常有效。&lt;/p&gt;
&lt;p&gt;　　这种方式通常能提升I/O性能，但是会增加CPU消耗，要考虑增加的I/O性能能不能补偿CPU的&lt;/p&gt;
&lt;p&gt;消耗，也就是系统的瓶颈是在I/O上还是在CPU上。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td align=&quot;center&quot;&gt;异步阻塞&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;　　这种方式在分布式数据库中经常用到，例如，在一个分布式数据库中写一条记录，通常会有一份是&lt;/p&gt;
&lt;p&gt;同步阻塞的记录，还有2~3份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写I/O。&lt;/p&gt;
&lt;p&gt;　　异步阻塞对网络I/O能够提升效率，尤其像上面这种同时写多份相同数据的情况。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td align=&quot;center&quot;&gt;异步非阻塞&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;　　这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下用，集群之间的消息同步机制&lt;/p&gt;
&lt;p&gt;一般用这种I/O组合方式。&lt;/p&gt;
&lt;p&gt;　　它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大却非常频繁的情况。&lt;/p&gt;
&lt;p&gt;这种网络I/O用此方式性能达到最高。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


















&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201909/772743-20190904004009398-659676330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 文章会同步到我的公众号上面，欢迎关注。&lt;/p&gt;

</description>
<pubDate>Tue, 03 Sep 2019 16:51:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 自己以前在Java NIO这块儿，一直都是比较薄弱的，以前还因为这点知识而错失了一个机会。所以最近打算好好学习一下这部分内容，我想应该也会有朋友像我一样，一直想闹明白这块儿内容。但是一直无从下手</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/11450667.html</dc:identifier>
</item>
<item>
<title>Spring中老生常谈的FactoryBean - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11456587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11456587.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文完整代码地址：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/factorybean&quot; class=&quot;uri&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/factorybean&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FactoryBean&lt;/code&gt;和&lt;code&gt;BeanFactory&lt;/code&gt;由于在命名上极其相似，一直以来困扰了不少的开发者。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;，耳熟能详的Spring核心接口，提供IoC容器的最基本功能。但要解释&lt;code&gt;FactoryBean&lt;/code&gt;一句话可能就说不清楚了。我们将从下面的例子逐步说明，FactoryBean是什么，它提供了什么样的能力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 布料
 * 包含颜色属性
 * Created by OKevin On 2019/9/3
 **/
public class Cloth {
    private Red red;
    //省略setter/getter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当初始化一个Cloth对象时，我希望Red对象也被赋值，此时我将在Cloth的构造方法中new一个Red对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Cloth() {
    red = new Red();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是随着业务的发展，我希望Cloth的颜色属性将是Blue蓝色，这时我将修改代码将Red和Blue类抽象出一个Color接口，Cloth代码将重构：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 布料
 * 包含颜色属性
 * Created by OKevin On 2019/9/3
 **/
public class Cloth {
    private Color color;
    public Cloth() {
        color = new Blue();
    }
    //省略setter/getter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;业务又进一步发展，Cloth类中的颜色属性将会根据一定的条件赋值为Red红色，此时我们将代码继续重构：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 布料
 * 包含颜色属性
 * Created by OKevin On 2019/9/3
 **/
public class Cloth {
    private Color color;
    public Cloth() {
        if (condition()) {
            color = new Blue();    
        } else {
            color = new Red();
        }
    }
    //省略setter/getter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的代码的确能运行，但如果有新的条件继续加入到业务中，此时我们又将改动Cloth类的构造方法，而我们认为Cloth方法是一个比较核心的业务对象，&lt;strong&gt;不应该&lt;/strong&gt;经常对它进行修改，并且在构造方法中对于Color对象创建过于冗余，不符合&lt;strong&gt;单一职责&lt;/strong&gt;的原则，所以我们将Color对象的创建过程通过&lt;strong&gt;工厂方法模式&lt;/strong&gt;来完成。&lt;/p&gt;
&lt;h3 id=&quot;静态工厂方法&quot;&gt;静态工厂方法&lt;/h3&gt;
&lt;p&gt;我们再次将Cloth类进行如下重构（为了使示例代码更加简洁，下面的示例将只创建Red对象）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 布料
 * 包含颜色属性
 * Created by OKevin On 2019/9/3
 **/
public class Cloth {
    private Color color;
    public Cloth() {
        color = StaticColorFactory.newInstance();
    }
    //省略setter/getter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 静态工厂方法
 * Created by OKevin On 2019/9/3
 **/
public class StaticColorFactory {
    public static Color getInstance() {
        return new Red();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们在Spring容器中要通过静态工厂方法，创建具体的对象实例应该怎么做呢？&lt;/p&gt;
&lt;p&gt;众所周知，要将一个对象实例交由Spring容器管理，我们通常是通过以下XML配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cloth&quot; class=&quot;com.coderbuff.bean.Cloth&quot;&amp;gt;
    &amp;lt;property name=&quot;color&quot; ref=&quot;red&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;red&quot; class=&quot;com.coderbuff.bean.Red&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但此时，Red对象实例并不是由Spring容器管理，而是由静态工厂方法创建的，此时我们应该讲XML配置修改为以下方式：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cloth&quot; class=&quot;com.coderbuff.bean.Cloth&quot;&amp;gt;
    &amp;lt;property name=&quot;color&quot; ref=&quot;red&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;red&quot; class=&quot;com.coderbuff.factory.StaticColorFactory&quot; factory-method=&quot;getInstance&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是Spring支持静态工厂方法创建对象实例的特定方式。这样我们就能在Spring中通过&lt;strong&gt;静态工厂方法&lt;/strong&gt;创建对象实例。&lt;/p&gt;
&lt;h3 id=&quot;实例工厂方法&quot;&gt;实例工厂方法&lt;/h3&gt;
&lt;p&gt;有静态工厂方法，就有非静态工厂方法，区别就是方法不是静态的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 实例工厂方法
 * Created by OKevin On 2019/9/3
 **/
public class ColorFactory {
    public Color getInstance() {
        return new Red();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例工厂方法在Spring中XML配置略有不同：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cloth&quot; class=&quot;com.coderbuff.bean.Cloth&quot;&amp;gt;
    &amp;lt;property name=&quot;color&quot; ref=&quot;red&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;colorFactory&quot; class=&quot;com.coderbuff.factory.ColorFactory&quot;/&amp;gt;
&amp;lt;bean id=&quot;red&quot; factory-bean=&quot;colorFactory&quot; factory-method=&quot;getInstance&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过配置可以看到，我们需要首先在Spring中实例化工厂，再通过工厂对象实例化Red对象。&lt;/p&gt;
&lt;p&gt;在有了对工厂方法在Spring中创建对象实例的认识后，FactoryBean实际上就是为我们简化这个操作。下面我们将通过FactoryBean来创建Red对象。&lt;/p&gt;
&lt;h3 id=&quot;factorybean&quot;&gt;FactoryBean&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Created by OKevin On 2019/9/3
 **/
public class ColorFactoryBean implements FactoryBean&amp;lt;Color&amp;gt; {
    public Color getObject() throws Exception {
        return new Red();
    }
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return Red.class;
    }
    public boolean isSingleton() {
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实现FactoryBean的方式，XML配置如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;cloth&quot; class=&quot;com.coderbuff.bean.Cloth&quot;&amp;gt;
    &amp;lt;property name=&quot;color&quot; ref=&quot;red&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;red&quot; class=&quot;com.coderbuff.factory.ColorFactoryBean&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就不用像工厂方法那样配置相应的属性，直接按照普通的Bean注入即可，由于Spring内部做了特殊处理，此时名称为“red”的Bean并不是ColorFactoryBean，而是它方法中getObject中返回的对象。如果实在想要获取ColorFactoryBean的对象实例，则在Bean的名称前加入“&amp;amp;”即可（“&amp;amp;red”）。&lt;/p&gt;
&lt;p&gt;看到这里，是否对FactoryBean有了一点认识呢？FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。&lt;/p&gt;
&lt;p&gt;我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。&lt;/p&gt;
&lt;h3 id=&quot;proxyfactorybean&quot;&gt;ProxyFactoryBean&lt;/h3&gt;
&lt;p&gt;我们将通过比较“古老”的方式创建一个Red对象的切面，在它的print方法执行前和执行后分别执行一条语句。之所以古老是因为我们往往通过注解的方式，而不会这么折磨自己去写一个切面对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 环绕通知
 * Created by OKevin On 2019/9/4
 **/
public class LogAround implements MethodInterceptor {
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&quot;调用目标方法【前】打印日志&quot;);
        Object result = invocation.proceed();
        System.out.println(&quot;调用目标方法【后】打印日志&quot;);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们需要ProxyFactoryBean的介入为我们创建一个代理对象并由Spring容器管理，根据上面ColorFactoryBean的经验，ProxyFacoryBean也应该如下配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;xxx&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答案是肯定的，只是ProxyFactoryBean多了几个参数，既然是生成代理对象，那么目标对象、目标方法就必不可少，实际的XLM配置如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;logAround&quot; class=&quot;com.coderbuff.aop.LogAround&quot;/&amp;gt;
&amp;lt;bean id=&quot;red&quot; class=&quot;com.coderbuff.bean.Red&quot;/&amp;gt;
&amp;lt;bean id=&quot;proxyRed&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.coderbuff.bean.Color&quot;/&amp;gt;
    &amp;lt;property name=&quot;interceptorNames&quot; value=&quot;logAround&quot;/&amp;gt;
    &amp;lt;property name=&quot;target&quot; ref=&quot;red&quot;/&amp;gt;
    &amp;lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过测试程序，ProxyFactoryBean的确生成了一个代理对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProxyFactoryBeanTest {
    private ClassPathXmlApplicationContext ctx;
    @Before
    public void init() {
        ctx = new ClassPathXmlApplicationContext(&quot;spring-proxyfactorybean.xml&quot;);
    }
    @Test
    public void testProxyFactory() {
        Red proxyRed = (Red) ctx.getBean(&quot;proxyRed&quot;);
        proxyRed.print();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文完整代码地址：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/factorybean&quot; class=&quot;uri&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/factorybean&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 03 Sep 2019 16:32:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>本文完整代码地址： 'https://github.com/yu linfeng/BlogRepositories/tree/master/repositories/factorybean' 和 由于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11456587.html</dc:identifier>
</item>
<item>
<title>从0到1体验Jenkins+Docker+Git+Registry实现CI自动化发布 - 拿着保温瓶的年轻人</title>
<link>http://www.cnblogs.com/l-hh/p/11455870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l-hh/p/11455870.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Jenkins是一款开源 CI&amp;amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Jenkins是一个广泛用于持续构建的可视化Web工具，持续构建就是将项目自动化编译、打包、部署。通过规范化来完成，简单，繁琐，浪费时间的重复工作。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; Jenkins名言：&lt;strong&gt;构建伟大，无所不能！ &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Jenkins用户手册传送门：&lt;a href=&quot;https://jenkins.io/zh/doc/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/zh/doc/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903214211420-449544842.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 工作详细流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903214325146-1279988975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;服务器角色&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;IP地址&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;主机名&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;运行服务&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;系统版本&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; Jenkins/Docker&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 192.168.115.21&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; jenkins&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;安装Docker、Tomcat运行Jenkins、Git客户端、JDK、Maven&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;CentOS 7.4 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; Git/Registry&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 192.168.115.22&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; git&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 安装Docker、Git服务、Registry私有仓库容器&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; CentOS 7.4&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; Docker&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 192.168.115.23&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; docker&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 安装Docker、拉取Tomcat镜像运行Java项目&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; CentOS 7.4&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903215345094-302391309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;i. 配置好yum源安装必要的一些系统工具&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; ii. 添加软件源信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# yum-config-manager --add-repo http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 更新并安装 Docker-CE&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~&lt;span&gt;]# yum makecache fast
[root@jenkins &lt;/span&gt;~]# yum -y install docker-ce&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iv. 开启Docker服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~&lt;span&gt;]# systemctl start docker
[root@jenkins &lt;/span&gt;~]# systemctl enable docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;v. 检查docker版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903215631341-618059919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：以上步骤三台服务器都需要同样的操作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;61-部署git仓库git机器上操作&quot; data-source-line=&quot;59&quot;&gt;6.1、部署Git仓库，Git机器上操作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 安装Git&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~]# yum install git -y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ii. 创建Git用户和设置密码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~&lt;span&gt;]# useradd git
[root@git &lt;/span&gt;~&lt;span&gt;]# passwd git
Changing password &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; user git.
New password: &lt;/span&gt;*******&lt;span&gt;
BAD PASSWORD: The password &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; shorter than &lt;span&gt;8&lt;/span&gt;&lt;span&gt; characters
Retype &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; password: *******&lt;span&gt;
passwd: all authentication tokens updated successfully.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 创建仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~]# su -&lt;span&gt; git
[git@git &lt;/span&gt;~]$ mkdir test-&lt;span&gt;jenkins.git
[git@git &lt;/span&gt;~]$ cd test-jenkins.git/&lt;span&gt;
[git@git test&lt;/span&gt;-jenkins.git]$ git --&lt;span&gt;bare init
Initialized empty Git repository &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /home/git/test-jenkins.git/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;62-访问git仓库测试jenkins机器上操作&quot; data-source-line=&quot;82&quot;&gt;6.2、访问Git仓库测试，Jenkins机器上操作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 安装Git客户端&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# yum install git -y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ii. 生成公钥，拷贝到Git服务器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# ssh-keygen -t rsa   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三个回车&lt;/span&gt;
[root@jenkins ~]# ssh-copy-id git@&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意是git用户&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 拉取Git项目测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# git clone git@&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:/home/git/test-&lt;span&gt;jenkins.git
Cloning into &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test-jenkins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;...
warning: You appear to have cloned an empty repository.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;63-部署docker私有仓库git机器上操作&quot; data-source-line=&quot;99&quot;&gt;6.3、部署Docker私有仓库，Git机器上操作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 创建Registry容器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~]# docker run -d -v /opt/registry:/&lt;span&gt;var&lt;/span&gt;/lib/registry -p &lt;span&gt;5000&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt; --restart=always --name rregistry registry&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ii. 检查Registry容器状态，已经成功启动了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903220153979-1161483853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;i. 配置私有仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# cat  /etc/docker/&lt;span&gt;daemon.json 
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://abcd1234.m.daocloud.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insecure-registries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.115.22:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;注：第2行是192.168.115.22 Docker私有仓库地址。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;ii. 重启Docker服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# systemctl restart docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 配置JDK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JDK1.8下载：&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# tar zxvf jdk-8u221-linux-&lt;span&gt;x64.tar.gz
[root@docker &lt;/span&gt;~]# mv jdk1.&lt;span&gt;8&lt;/span&gt;.0_221/ /usr/local/jdk&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iv. 构建Tomcat基础镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~&lt;span&gt;]# cat Dockerfile
# 基础镜像
FROM centos:&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
# 维护者信息
MAINTAINER test&lt;/span&gt;-&lt;span&gt;Jenkins        
# Tomcat版本
ENV VERSION&lt;/span&gt;=&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;45&lt;/span&gt;&lt;span&gt;    
# jdk目录    
ENV JAVA_HOME &lt;/span&gt;/usr/local/&lt;span&gt;jdk    
# 安装wget命令
RUN yum install wget &lt;/span&gt;-&lt;span&gt;y        

# 下载Tomcat
RUN wget http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v${VERSION}/bin/apache-tomcat-${VERSION}.tar.gz &amp;amp;&amp;amp; \     &lt;/span&gt;
&lt;span&gt;# 解压tomcat
tar zxf apache&lt;/span&gt;-tomcat-${VERSION}.tar.gz &amp;amp;&amp;amp;&lt;span&gt; \                    
# 移动解压出来的tomcat文件
mv apache&lt;/span&gt;-tomcat-${VERSION} /usr/local/tomcat-jenkins &amp;amp;&amp;amp;&lt;span&gt; \        
# 删除不需要的文件，减轻容器体积
rm &lt;/span&gt;-rf apache-tomcat-${VERSION}.tar.gz /usr/local/tomcat-jenkins/webapps&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &amp;amp;&amp;amp; \        
# 创建ROOT，tomcat默认目录
mkdir /usr/local/tomcat-jenkins/webapps/ROOT            

# 映射端口
EXPOSE 8080        
# 启动tomcat    
CMD [&quot;/usr/local/tomcat-jenkins/bin/catalina.sh&quot;, &quot;run&quot;]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;v. 构建镜像上传Registry仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# docker build -t &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/tomcat-jenkins -f Dockerfile .&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;vi. 推送到镜像仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# docker push &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/tomcat-jenkins&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;vii. 验证是否上传Registry镜像仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# curl -XGET http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.115.22:5000/v2/_catalog&lt;/span&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tomcat-jenkins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;81-配置私有仓库-git-jdk-maven&quot; data-source-line=&quot;174&quot;&gt;8.1、配置私有仓库、Git、JDK、Maven&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 配置私有仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@docker ~]# cat  /etc/docker/&lt;span&gt;daemon.json 
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://abcd1234.m.daocloud.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insecure-registries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.115.22:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}
 
重启Docker服务：
[root@docker &lt;/span&gt;~]# systemctl restart docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;注：第2行是192.168.115.22 Docker私有仓库地址。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;ii. 安装JDK &lt;br/&gt;JDK1.8下载：&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# tar zxvf jdk-8u221-linux-&lt;span&gt;x64.tar.gz
[root@jenkins &lt;/span&gt;~]# mv jdk1.&lt;span&gt;8&lt;/span&gt;.0_221/ /usr/local/jdk&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 配置JDK&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# vim /etc/&lt;span&gt;profile
&lt;/span&gt;--------------------添加环境变量---------------------&lt;span&gt;
JAVA_HOME&lt;/span&gt;=/usr/local/&lt;span&gt;jdk
PATH&lt;/span&gt;=$PATH:$JAVA_HOME/&lt;span&gt;bin
CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/&lt;span&gt;tools.jar
export JAVA_HOME PATH CLASSPATH&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iv. 更新系统环境变量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# source /etc/profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;v. 验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# java -version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;vi. 安装Maven &lt;/span&gt;&lt;br/&gt;&lt;span&gt;Maven下载连接：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;http://maven.apache.org/download.cgi&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# tar zxvf apache-maven-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;bin.tar.gz
[root@jenkins &lt;/span&gt;~]# mv apache-maven-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; /usr/local/maven&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;82-安装jenkins和tomcat&quot; data-source-line=&quot;218&quot;&gt;8.2、安装Jenkins和Tomcat&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Jenkins下载链接：&lt;a href=&quot;https://jenkins.io/zh/download/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/zh/download/&lt;/a&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;Tomcat下载链接：&lt;a href=&quot;http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.45/bin/apache-tomcat-8.5.45.tar.gz&quot; target=&quot;_blank&quot;&gt;http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.45/bin/apache-tomcat-8.5.45.tar.gz&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i. 解压和拷贝Jenkins.war到Tomcat目录下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# tar zxvf apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;45&lt;/span&gt;&lt;span&gt;.tar.gz
[root@jenkins &lt;/span&gt;~]# mv apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;45&lt;/span&gt;  /usr/local/tomcat-&lt;span&gt;jenkins
[root@jenkins &lt;/span&gt;~]# rm -rf /usr/local/tomcat-jenkins/webapps&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
[root@jenkins ~]# unzip jenkins.war -d /usr/local/tomcat-jenkins/ROOT&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ii. 启动Tomcat&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# /usr/local/tomcat-jenkins/bin/startup.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;83-配置jenkins&quot; data-source-line=&quot;236&quot;&gt;8.3、配置Jenkins&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 访问Jenkins（&lt;a href=&quot;http://ip:8080/&quot; target=&quot;_blank&quot;&gt;http://IP:8080&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903225959920-1974157808.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ii. 获取密码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# cat /&lt;span&gt;var&lt;/span&gt;/jenkins_home/secrets/&lt;span&gt;initialAdminPassword
e3218946860a4e62b5b4808db0a7f2b6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;iii. 选择插件的安装（不熟悉的情况下推荐安装即可，省得麻烦）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230035302-836122007.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iv. 创建用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230051295-251735517.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;255&quot;&gt;&lt;span&gt;v. 配置Maven、jdk、git环境&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-source-line=&quot;257&quot;&gt;&lt;span&gt;注：系统管理 —&amp;gt;  全局工具配置，指定JDK、Maven路径，Git保持默认&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230143361-1399684055.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;261&quot;&gt;&lt;span&gt;vi. Jenkins安装必要插件&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-source-line=&quot;263&quot;&gt;&lt;span&gt;注：系统管理 —&amp;gt; 管理插件（安装SSH与Git Parameter插件）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230214856-1905451260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230231368-1966394797.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插件说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SSH：用于SSH远程Docker主机执行Shell命令；
Git Parameter：动态获取Git仓库Branch、Tag；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;vii. 配置SSH插件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230313884-80545873.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;viii. 输入Docker主机的用户名/密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230332405-1352312709.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ix. 添加SSH远程主机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230355745-303291850.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230418411-2110614329.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;注：记得点击左下角“保存”按钮。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;先下载并安装git：&lt;a href=&quot;https://git-scm.com/download/&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/download/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230526451-141395694.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;91-使用idea创建测试项目&quot; data-source-line=&quot;296&quot;&gt;9.1、使用IDEA创建测试项目&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建新项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230555942-1305390880.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择Spring Initializr：&lt;span&gt;本地提前配置好JDK环境和Maven环境&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230626266-744977773.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择war：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230655828-1673372006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择Web —&amp;gt; Sping Web Starter：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230713062-630157203.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随便起个项目名称：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230738728-511303879.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来个简单的“Hello World”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230755863-1060820523.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
    @RequestMapping
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello Jenkins v1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;本地运行测试项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230839262-42626342.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地浏览器访问测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230855842-1133329048.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;92-连接git仓库上传代码&quot; data-source-line=&quot;353&quot;&gt;9.2、连接Git仓库上传代码&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;i. 在IDEA中设置Git，在File--&amp;gt;Setting-&amp;gt;Version Control--&amp;gt;Git--&amp;gt;Path to Git executable选择你的git安装后的git.exe文件，然后点击Test，测试是否设置成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230925161-2111416090.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ii. 选择要上传的项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903230957896-2066552853.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;362&quot;&gt;&lt;span&gt;iii. 将本项目添加到本地仓库&lt;/span&gt;&lt;/p&gt;
&lt;blockquote data-source-line=&quot;363&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;注：我们在项目文件名上右键选择 git，通过 add 添加到本地库的跟踪区,再comment 正式提交到本地仓库。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231044283-1583759973.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iv. 添加Git仓库地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231121086-1416420746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;v. 上传代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231139464-1741028625.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231209423-251979474.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231235475-362207342.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vi. 在Jenkins机器上下载项目验证是否上传成功&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@jenkins ~]# git clone git@&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:/home/git/test-&lt;span&gt;jenkins.git
[root@jenkins &lt;/span&gt;~]# cd test-jenkins/&lt;span&gt;
[root@jenkins test&lt;/span&gt;-&lt;span&gt;jenkins]# ls
mvnw  mvnw.cmd  pom.xml  src&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;93-给项目添加tag&quot; data-source-line=&quot;386&quot;&gt;9.3、给项目添加Tag&lt;/h2&gt;
&lt;h3 id=&quot;931-idea测试项目连接git添加tag&quot; data-source-line=&quot;387&quot;&gt;9.3.1、IDEA测试项目连接Git添加Tag&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;i. 进入Version Control--&amp;gt;log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231326098-222090290.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ii. 在之前版本中，右键，新建标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231346558-867417455.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iii. Push标签&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;注：由于不是在当前最新版本打入的标签，push 时需要选择 push tags （all）,不然不能push。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231423817-1312964212.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iv. 在Git仓库上查看Tag验证一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~]# su -&lt;span&gt; git
[git@git &lt;/span&gt;~]$ cd test-jenkins.git/&lt;span&gt;
[git@git test&lt;/span&gt;-&lt;span&gt;jenkins.git]$ git tag
v1.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;932-如果是直接上传项目到git仓库加tag方法&quot; data-source-line=&quot;408&quot;&gt;9.3.2、如果是直接上传项目到Git仓库，加Tag方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@git ~]# su -&lt;span&gt; git
[git@git &lt;/span&gt;~]$ cd test-jenkins.git/&lt;span&gt;
[git@git test&lt;/span&gt;-&lt;span&gt;jenkins.git]$ git branch
[git@git test&lt;/span&gt;-jenkins.git]$ git tag v1.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[git@git test&lt;/span&gt;-&lt;span&gt;jenkins.git]$ git tag
v1.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;额外补充删除Tag：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[git@git test-jenkins.git]$ git tag -d v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;101-配置jenkins项目&quot; data-source-line=&quot;422&quot;&gt;10.1、配置Jenkins项目&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;安装Maven插件，构建一个Maven项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231542871-2026031950.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置项目（新建任务 -&amp;gt; 输入任务名称，构建一个Maven项目）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231559672-978846548.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置Git参数化构建：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231619381-129267992.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态获取Git仓库Tag，与用户交互选择Tag发布：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231639677-1552562539.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;439&quot;&gt;&lt;span&gt;指定项目Git仓库地址：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote data-source-line=&quot;440&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;注：修改*/master为$Tag，Tag是上面动态获取的变量名，表示根据用户选择打代码版本。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231725142-1646671289.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置maven构建命令选项（clean package -Dmaven.test.skip=true）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231750776-181252722.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jenkins本机镜像构建和推送到私有镜像仓库：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231804419-1513171359.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 定义变量
REPOSITORY&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/tomcat-&lt;span&gt;jenkins:${Tag}

# 开始构建镜像
cat &lt;/span&gt;&amp;gt; Dockerfile &amp;lt;&amp;lt;&lt;span&gt; EOF
# 拉取私有仓库的镜像
FROM &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/tomcat-&lt;span&gt;jenkins:latest
# 删除Tomcat下不需要的ROOT项目
RUN rm &lt;/span&gt;-rf /usr/local/tomcat-jenkins/webapps/&lt;span&gt;ROOT
# 将jenkins编译好的war包拷贝到Tomcat目录下
COPY target&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.war /usr/local/tomcat-jenkins/webapps/ROOT.war
# 运行Tomcat
CMD [&quot;/usr/local/tomcat-jenkins/bin/catalina.sh&quot;, &quot;run&quot;]
EOF

# 清除Jenkins主机旧的构建镜像
docker image rm 192.168.115.22:5000/tomcat-jenkins:${Tag}
# 构建自定义镜像
docker build -t $REPOSITORY .
# 开始上传镜像
docker push $REPOSITORY&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SSH远程在Docker主机上执行创建容器命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231857518-1172385372.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 定义变量
REPOSITORY&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;115.22&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/tomcat-&lt;span&gt;jenkins:${Tag}

# 删除之前容器和镜像
docker rm &lt;/span&gt;-f tomcat-jenkins |&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
docker image rm $REPOSITORY &lt;/span&gt;|&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

# 开始部署容器
docker container run &lt;/span&gt;-d --name tomcat-jenkins -v /usr/local/jdk:/usr/local/jdk -p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; $REPOSITORY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;102-开始构建&quot; data-source-line=&quot;494&quot;&gt;10.2、开始构建&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;点击项目名称 —&amp;gt; 选择版本 —&amp;gt; 开始构建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231939416-2024248550.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看构建过程以及信息输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903231954839-676227870.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看是否构建成功：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903232015854-1688578999.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证项目是否可以访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418489/201909/1418489-20190903232034830-1090107325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;到此就简单体验了Jenkins+Docker+Git+&lt;span&gt;Registry实现一套CI自动化发布流程，本来打算Jenkins放在容器上运行的，发现Jenkins容器里面需要Docker命令，但是比较繁琐，也感觉没必要好像，就直接采用方法一了。
感兴趣的可以通过以下方式实现：
&lt;/span&gt;-&lt;span&gt; 不使用任何Jenkins镜像，宿主机安装Jenkins [宿主机有Docker服务]
&lt;/span&gt;-&lt;span&gt; 不使用官方Jenkins镜像，自己构造带有Docker服务的Jenkins镜像
&lt;/span&gt;- Docker-&lt;span&gt;in&lt;/span&gt;-&lt;span&gt;Docker [DinD]
&lt;/span&gt;- Docker-outside-of-&lt;span&gt;Docker [DooD]
&lt;/span&gt;- 使用Jenkins的Docker插件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;4.3087248322148&quot;&gt;
&lt;p&gt;&lt;span&gt;注：如有问题请指点出来，非常感谢。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;注：本文参考这篇博客，非常感谢博主：&lt;a href=&quot;https://blog.51cto.com/lizhenliang/2159817&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://blog.51cto.com/lizhenliang/2159817&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Tue, 03 Sep 2019 15:35:00 +0000</pubDate>
<dc:creator>拿着保温瓶的年轻人</dc:creator>
<og:description>一、前言 Jenkins是一款开源 CI&amp;amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/l-hh/p/11455870.html</dc:identifier>
</item>
<item>
<title>重识 ArrayList - 闻人的技术博客</title>
<link>http://www.cnblogs.com/one12138/p/11456147.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/one12138/p/11456147.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;ArrayList 作为 Java 集合框架中最常用的类，在一般情况下，用它存储集合数据最适合不过。知其然知其所以然，为了能更好地认识和使用 ArrayList，本文将从下面几方面深入理解 ArrayList：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么不用数组，用 ArrayList&lt;/li&gt;
&lt;li&gt;ArrayList 特性的源码分析&lt;/li&gt;
&lt;li&gt;Java 8 后 的 ArrayList&lt;/li&gt;
&lt;li&gt;正确的 ArrayList 使用姿势&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么不用数组用-arraylist&quot;&gt;为什么不用数组，用 ArrayList。&lt;/h2&gt;
&lt;p&gt;在 Java 语言中，由于普通数组受到长度限制，初始化时就需要限定数组长度，无法根据元素个数动态扩容，并且 Java 数组供开发者调用方法有限，只有取元素，获取数组长度和添加元素一些简单操作。后台在 Java 1.2 引入了强大丰富的 Collection 框架，其中用 ArrayList 来作为可动态扩容数组的列表实现来代替 Array 在日常开发的使用，ArrayList 实现所有列表的操作方法，方便开发者操作列表集合。这里我们先列举下 ArrayList 的主要特点，在后文进行一一阐述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;有序存储元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;允许元素重复，允许存储 &lt;code&gt;null&lt;/code&gt; 值&lt;/li&gt;
&lt;li&gt;支持动态扩容&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非线程安全&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了更好地认识 ArrayList，我们首先来看下从 ArrayList 的UML类图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222811499-1320084641.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出 ArrayList 继承了 AbstractList, 直接实现了 Cloneable, Serializable，RandomAccess 类型标志接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbstractList 作为列表的抽象实现，将元素的增删改查都交给了具体的子类去实现，在元素的迭代遍历的操作上提供了默认实现。&lt;/li&gt;
&lt;li&gt;Cloneable 接口的实现，表示了 ArrayList 支持调用 Object 的 &lt;code&gt;clone&lt;/code&gt; 方法，实现 ArrayList 的拷贝。&lt;/li&gt;
&lt;li&gt;Serializable 接口实现，说明了 ArrayList 还支持序列化和反序列操作，具有固定的 &lt;code&gt;serialVersionUID&lt;/code&gt; 属性值。&lt;/li&gt;
&lt;li&gt;RandomAccess 接口实现，表示 ArrayList 里的元素可以被高效效率的随机访问，以下标数字的方式获取元素。实现 RandomAccess 接口的列表上在遍历时可直接使用普通的&lt;code&gt;for&lt;/code&gt;循环方式，并且执行效率上给迭代器方式更高。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;arraylist-源码分析&quot;&gt;ArrayList 源码分析&lt;/h2&gt;
&lt;p&gt;进入 ArrayList 源代码，从类的结构里很快就能看到 ArrayList 的两个重要成员变量：&lt;code&gt;elementData&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222811785-814669521.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;elementData&lt;/code&gt; 是一个 Object 数组，存放的元素，正是外部需要存放到 ArrayList 的元素，即 ArrayList 对象维护着这个对象数组 Object[]，对外提供的增删改查以及遍历都是与这个数组有关，也因此添加到 ArrayList 的元素都是有序地存储在数组对象 &lt;code&gt;elementData&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt; 字段表示着当前添加到 ArrayList 的元素个数，需要注意的是它必定小于等于数组对象 &lt;code&gt;elementData&lt;/code&gt; 的长度。一旦当 &lt;code&gt;size&lt;/code&gt; 与 &lt;code&gt;elementData&lt;/code&gt; 长度相同，并且还在往列表里添加元素时，ArrayList 就会执行扩容操作，用一个更长的数组对象存储先前的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于底层维护的是一个对象数组，所以向 ArrayList 集合添加的元素自然是可以重复的，允许为 &lt;code&gt;null&lt;/code&gt; 的，并且它们的索引位置各不一样。&lt;/p&gt;
&lt;h3 id=&quot;如何扩容&quot;&gt;如何扩容&lt;/h3&gt;
&lt;p&gt;了解完 ArrayList 为何有序存储元素和元素可以重复，我们再来看下作为动态数组列表，底层扩容是如何实现的。&lt;/p&gt;
&lt;p&gt;首先，要确定下扩容的时机会是在哪里，就如上面描述 &lt;code&gt;size&lt;/code&gt; 字段时提到的，当 &lt;code&gt;size&lt;/code&gt; 与 &lt;code&gt;elementData&lt;/code&gt; 长度相同，此刻再添加一个元素到集合就会出现容量不够的情况，需要进行扩容，也就是说 ArrayList 的扩容操作发生在添加方法中，并且满足一定条件时才会发生。&lt;/p&gt;
&lt;p&gt;现在我们再来看下 ArrayList 类的代码结构，可以看到有四个添加元素的方法，分为两类：添加单个元素和添加另一个集合内的所有元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222812820-1666773811.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先从简单的方法下手分析，查看 &lt;code&gt;add(E):boolean&lt;/code&gt; 方法实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e; 
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出第三行代码是简单地添加单个元素，并让 &lt;code&gt;size&lt;/code&gt; 递增加 1；那么扩容实现就在 &lt;code&gt;ensureCapacityInternal&lt;/code&gt; 方法中，这里传入参数为 &lt;code&gt;size&lt;/code&gt;+1，就是要在真正添加元素前判断添加后的元素个数，也就是集合所需要的最小容量是否会超过原数组的长度。再看下这个 &lt;code&gt;ensureCapacityInternal&lt;/code&gt; 方法实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其内部仍有两个方法调用，首先看下比较简单的 &lt;code&gt;calculateCapacity&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;elementData&lt;/code&gt; 与 &lt;code&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt; 相等，也就是空数组时，返回一个可添加元素的默认最小容量值 &lt;code&gt;DEFAULT_CAPACITY&lt;/code&gt; 对应的10 ，否则按照传入的 &lt;code&gt;size&lt;/code&gt; +1 为最小容量值；执行完之后接着看 &lt;code&gt;ensureExplicitCapacity&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看到扩容实现在 &lt;code&gt;grow&lt;/code&gt; 方法之中，并且只有当数组长度小于所需要的最小容量时执行：当数组存储元素已满，无法再存储将新加入的元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进一步跳转到 &lt;code&gt;grow&lt;/code&gt; 方法的实现，可以看到第8行利用工具类方法 &lt;code&gt;java.util.Arrays#copyOf(T[], int)&lt;/code&gt; ,对原有数组进行拷贝，将内部所有的元素存放到长度为 &lt;code&gt;newCapacity&lt;/code&gt; 的新数组中，并将对应新数组的引用赋值给 &lt;code&gt;elementData&lt;/code&gt;。此刻 ArrayList 内部引用的对象就是更新长度了的新数组，实现效果就如下图一样：&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222813148-2136966561.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们再来关注下代表数组新容量的 &lt;code&gt;newCapacity&lt;/code&gt; 被调整为多少。首先 &lt;code&gt;newCapacity&lt;/code&gt; 通过 &lt;code&gt;oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)&lt;/code&gt; 计算获得，使用位运算将原容量值 &lt;code&gt;oldCapacity&lt;/code&gt; 通过右移一位，获得其一半的值（向下取整）, 然后加上原来的容量值，那么就是原容量值 &lt;code&gt;oldCapacity&lt;/code&gt; 的1.5倍。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 右位运算符，会将左操作数进行右移，相当于除以2，并且向下取整，比如表达式 &lt;code&gt;(7 &amp;gt;&amp;gt; 1) == 3&lt;/code&gt; 结果为真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当计算得到的 &lt;code&gt;newCapacity&lt;/code&gt; 仍然小于传入最小容量值时，说明当前数组个数为空，采用默认的 &lt;code&gt;DEFAULT_CAPACITY&lt;/code&gt;作为容量值分配数组。&lt;/p&gt;
&lt;p&gt;额外需要注意的是还有最大数组个数的判断，&lt;code&gt;MAX_ARRAY_SIZE&lt;/code&gt; 在文件对应的代码定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ArrayList 存储元素个数有最大限制，如果超过限制就会导致 JVM 抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;到这里 &lt;code&gt;java.util.ArrayList#add(E)&lt;/code&gt; 方法的扩容逻辑就分析结束了。类似的，在其他添加元素的方法里实现内我们都可以看到 &lt;code&gt;ensureCapacityInternal&lt;/code&gt; 方法的调用，在真正操作底层数组前都会进行容量的确认，容量不够则进行动态扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222814334-987873932.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;序列化与反序列化&quot;&gt;序列化与反序列化&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;transient Object[] elementData;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ArrayList 源码看到的 &lt;code&gt;elementData&lt;/code&gt; 带有关键字 &lt;code&gt;transient&lt;/code&gt;，而通常 &lt;code&gt;transient&lt;/code&gt; 关键字修饰了字段则表示该字段不会被序列化，但是 ArrayList 实现了序列化接口，并且提供的序列化方法 &lt;code&gt;writeObject&lt;/code&gt; 与反序列化方法 &lt;code&gt;readObject&lt;/code&gt; 的实现, 这是如何做到的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222815261-1006797194.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们首先来看下 ArrayList 进行序列化的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
    int expectedModCount = modCount;
    s.defaultWriteObject();

    s.writeInt(size);

    for (int i = 0; i &amp;lt; size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第4行代码首先将当前对象的非 &lt;code&gt;static&lt;/code&gt; 修饰，非 &lt;code&gt;transient&lt;/code&gt; 修饰的字段写出到流中；第6行将写出元素的个数作为容量。&lt;/p&gt;
&lt;p&gt;接下来就是通过循环将包含的所有元素写出到流，在这一步可以看出 ArrayList 在自己实现的序列化方法中没有将无存储数据的内存空间进行序列化，节省了空间和时间。&lt;/p&gt;
&lt;p&gt;同样地，在反序列化中根据读进来的流数据中获取 &lt;code&gt;size&lt;/code&gt; 属性，然后进行数组的扩容，最后将流数据中读到的所有元素数据存放到持有的对象数组中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    s.defaultReadObject();

    s.readInt(); // ignored

    if (size &amp;gt; 0) {
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        for (int i = 0; i &amp;lt; size; i++) {
            a[i] = s.readObject();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于拷贝&quot;&gt;关于拷贝&lt;/h3&gt;
&lt;p&gt;针对列表元素的拷贝，ArrayList 提供自定义的 clone 实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Object clone() {
  try {
    ArrayList&amp;lt;?&amp;gt; v = (ArrayList&amp;lt;?&amp;gt;) super.clone();
    v.elementData = Arrays.copyOf(elementData, size);
    v.modCount = 0;
    return v;
  } catch (CloneNotSupportedException e) {
    // this shouldn't happen, since we are Cloneable
    throw new InternalError(e);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码可以清楚看出执行的 &lt;code&gt;copyOf&lt;/code&gt; 操作是一次浅拷贝操作，原 ArrayList 对象的元素不会被拷贝一份存到新的 ArrayList 对象然后返回，它们各自的字段 &lt;code&gt;elementData&lt;/code&gt; 里各位置存放的都是一样元素的引用，一旦哪个列表修改了数组中的某个元素，另一个列表也将受到影响。&lt;/p&gt;
&lt;h2 id=&quot;jdk-1.8-后的-arraylist&quot;&gt;JDK 1.8 后的 ArrayList&lt;/h2&gt;
&lt;p&gt;从源码角度分析完 ArrayList 的特性之后，我们再来看下 JDK 1.8 之后在 ArrayList 类上有什么新的变化。&lt;/p&gt;
&lt;h3 id=&quot;新增-removeif-方法&quot;&gt;新增 removeIf 方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeIf&lt;/code&gt; 是 Collection 接口新增的接口方法，ArrayList 由于父类实现该接口，所以也有这个方法。&lt;code&gt;removeIf&lt;/code&gt; 方法用于进行指定条件的从数组中删除元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter){...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传入一个代表条件的函数式接口参数 &lt;code&gt;Predicate&lt;/code&gt;，也就是Lambda 表达式进行条件匹配，如果条件为 &lt;code&gt;true&lt;/code&gt;， 则将该元素从数组中删除，例如下方代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; numbers = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
numbers.removeIf(i -&amp;gt; i % 2 == 0);
System.out.println(numbers); // [1, 3, 5, 7, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新增-spliterator-方法&quot;&gt;新增 spliterator 方法&lt;/h3&gt;
&lt;p&gt;这个方法也是来自于 Collection 接口，ArrayList 对此方法进行了重写。该方法会返回 ListSpliterator 实例，该实例用于遍历和分离容器所存储的元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Spliterator&amp;lt;E&amp;gt; spliterator() {
    return new ArrayListSpliterator&amp;lt;&amp;gt;(this, 0, -1, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ArrayList 的实现中，该方法返回一个内部静态类对象 ArrayListSpliterator，通过它可以就可以集合元素进行操作。&lt;/p&gt;
&lt;p&gt;它的主要操作方法有下面三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tryAdvance&lt;/code&gt; 迭代单个元素，类似于 &lt;code&gt;iterator.next()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forEachRemaining&lt;/code&gt; 迭代剩余元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trySplit&lt;/code&gt; 将元素切分成两部分并行处理,但需要注意的 Spliterator 并不是线程安全的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然这个三个方法不常用，还是有必要了解，可以简单看下方法的使用方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt; numbers = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(1,2,3,4,5,6));
Spliterator&amp;lt;Integer&amp;gt; numbers = numbers.spliterator();

numbers.tryAdvance( e -&amp;gt; System.out.println( e ) ); // 1

numbers.forEachRemaining( e -&amp;gt; System.out.println( e ) ); // 2 3 4 5 6

Spliterator&amp;lt;Integer&amp;gt; numbers2 = numbers.trySplit();

numbers.forEachRemaining( e -&amp;gt; System.out.println( 3 ) );      //4 5 6
numbers2.forEachRemaining( e -&amp;gt; System.out.println( 3 ) );      //1 2 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;必会的使用姿势&quot;&gt;必会的使用姿势&lt;/h2&gt;
&lt;p&gt;接触了 ArrayList 源码和新API 之后，我们最后学习如何在平常开发中高效地使用 ArrayList。&lt;/p&gt;
&lt;h3 id=&quot;高效的初始化&quot;&gt;高效的初始化&lt;/h3&gt;
&lt;p&gt;ArrayList 实现了三个构造函数, 默认创建时会分配到空数组对象 &lt;code&gt;EMPTY_ELEMENTDATA&lt;/code&gt;；第二个是传入一个集合类型数据进行初始化；第三个允许传入集合长度的初始化值，也就是数组长度。由于每次数组长度不够会导致扩容，重新申请更长的内存空间，并进行复制。而让我们初始化 ArrayList 指定数组初始大小，可以减少数组的扩容次数，提供性能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ArrayList(int initialCapacity) {
    if (initialCapacity &amp;gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                            initialCapacity);
    }
}

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        this.elementData = EMPTY_ELEMENTDATA;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;元素遍历&quot;&gt;元素遍历&lt;/h3&gt;
&lt;p&gt;JDK 1.8前，ArrayList 只支持3种遍历方式：迭代器遍历，普通 &lt;code&gt;for&lt;/code&gt; 循环，&lt;code&gt;for-each&lt;/code&gt; 增强，在 JDK1.8 引入了 Stream API 之后，同属于 Collection 集合的 ArrayList，可以使用 &lt;code&gt;stream.foreach()&lt;/code&gt; 方法一个个地获取元素：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ArrayList&amp;lt;String&amp;gt; names = new ArrayList&amp;lt;String&amp;gt;(Arrays.asList( &quot;alex&quot;, &quot;brian&quot;, &quot;charles&quot;));
names.forEach(name -&amp;gt; System.out.println(name)); // alex brian charles&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;转换-array&quot;&gt;转换 Array&lt;/h3&gt;
&lt;p&gt;ArrayList 提供两个方法用于列表向数组的转换&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Object[] toArray();
public &amp;lt;T&amp;gt; T[] toArray(T[] a);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;第一个方法直接返回 Object 类型数组&lt;/li&gt;
&lt;li&gt;在第二个方法中，返回数组的类型为所传入的指定数组的类型。 并且如果列表的长度符合传入的数组，将元素拷贝后数组后，则在其中返回数组。 否则，将根据传入数组的类型和列表的大小重新分配一个新数组，拷贝完成后再返回。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上述描述可以看出使用第二个方法更加合适，能保留原先类型：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(4);
list.add(&quot;A&quot;);
list.add(&quot;B&quot;);
list.add(&quot;C&quot;);
list.add(&quot;D&quot;);

String[] array = list.toArray(new String[list.size()]);
System.out.println(Arrays.toString(array)); // [A, B, C, D]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;应对多线程&quot;&gt;应对多线程&lt;/h3&gt;
&lt;p&gt;在这里需要说明的是 ArrayList 本身是非线程安全的，如果需要使用线程安全的列表通常采用的方式是 &lt;code&gt;java.util.Collections#synchronizedList(java.util.List&amp;lt;T&amp;gt;)&lt;/code&gt; 或者 使用 Vector 类代替。还有一种方式是使用并发容器类 CopyOnWriteArrayList 在多线程中使用，它底层通过创建原数组的副本来实现更新，添加等原本需同步的操作，不仅线程安全，减少了对线程的同步操作。&lt;/p&gt;
&lt;h3 id=&quot;应对头部结点的增删&quot;&gt;应对头部结点的增删&lt;/h3&gt;
&lt;p&gt;ArrayList是数组实现的，使用的是连续的内存空间，当有在数组头部将元素添加或者删除的时候，需要对头部以后的数据进行复制并重新排序，效率很低。针对有大量类似操作的场景，出于性能考虑，我们应该使用 LinkedList 代替。由于LinkedList 是基于链表实现，当需要操作的元素位置位于List 前半段时，就从头开始遍历，马上找到后将把元素在相应的位置进行插入或者删除操作。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;到这里我们学习总结 ArrayList 的实现和常见使用，作为基础容器集合，越是多些了解，对我们日常使用越顺手。由于上文提到了另一个列表集合 LinkedList，它与 ArrayList 实现方式不同，使用场景也不同，将作为下一篇文章分析的集合登场，感兴趣的小伙伴欢迎关注我的微信公众号，期待更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201909/664672-20190903222816064-787094909.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;https://www.cnblogs.com/skywang12345/p/3308556.html&lt;/li&gt;
&lt;li&gt;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&lt;/li&gt;
&lt;li&gt;https://yuqirong.me/2018/01/21/ArrayList%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&lt;/li&gt;
&lt;li&gt;https://juejin.im/post/5a58aa62f265da3e4d72a51b&lt;/li&gt;
&lt;li&gt;https://howtodoinjava.com/java-arraylist/&lt;/li&gt;
&lt;li&gt;http://cmsblogs.com/?p=4727&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 03 Sep 2019 14:28:00 +0000</pubDate>
<dc:creator>闻人的技术博客</dc:creator>
<og:description>前言 ArrayList 作为 Java 集合框架中最常用的类，在一般情况下，用它存储集合数据最适合不过。知其然知其所以然，为了能更好地认识和使用 ArrayList，本文将从下面几方面深入理解 Ar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/one12138/p/11456147.html</dc:identifier>
</item>
<item>
<title>Springboot源码分析之事务问题 - TheGir1</title>
<link>http://www.cnblogs.com/qinzj/p/11456067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinzj/p/11456067.html</guid>
<description>&lt;h4 id=&quot;摘要&quot;&gt;摘要：&lt;/h4&gt;
&lt;p&gt;事务在后端开发中无处不在，是数据一致性的最基本保证。要明白进事务的本质就是进到事务切面的代理方法中，最常见的是同一个类的非事务方法调用一个加了事务注解的方法没进入事务。我们以&lt;code&gt;cglib&lt;/code&gt;代理为例，由于Spring的对于&lt;code&gt;cglib AOP&lt;/code&gt;代理的实现，进入被代理方法的时候实际上已经离开了“代理这一层壳子”，可以认为代码走到的是一个朴素的bean，调用同一个bean中方法自然与代理没有半毛钱关系了。&lt;br/&gt;一般对于声明式事务都是以调用另一个类的加了&lt;code&gt;@Transactional&lt;/code&gt;注解的&lt;code&gt;public&lt;/code&gt;方法作为入口的。&lt;/p&gt;
&lt;h4 id=&quot;spring事务关键处理流程&quot;&gt;spring事务关键处理流程&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;EnableTransactionManagement&lt;/code&gt;注解导入&lt;code&gt;TransactionManagementConfigurationSelector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TransactionManagementConfigurationSelector&lt;/code&gt;加载&lt;code&gt;InfrastructureAdvisorAutoProxyCreator&lt;/code&gt;(但不一定是它，一般都是&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;)，&lt;code&gt;BeanFactoryTransactionAttributeSourceAdvisor&lt;/code&gt;，&lt;code&gt;TransactionInterceptor&lt;/code&gt;&lt;br/&gt;-&lt;code&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/code&gt;在&lt;code&gt;ioc&lt;/code&gt;流程一个关键步骤是查找&lt;code&gt;Advisor&lt;/code&gt;，有两个方面，第一是实现了&lt;code&gt;Advisor&lt;/code&gt;接口的类，第二是基于注解&lt;code&gt;Aspectj&lt;/code&gt;。关键是&lt;code&gt;BeanFactoryTransactionAttributeSourceAdvisor&lt;/code&gt;被加载进了代理缓存&lt;/li&gt;
&lt;li&gt;代理调用方法的时候会执行&lt;code&gt;DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice&lt;/code&gt;，这个时候就会将我们的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;BeanFactoryTransactionAttributeSourceAdvisor&lt;/code&gt;派上用处，最主要的还是它里面的&lt;code&gt;TransactionAttributeSourcePointcut&lt;/code&gt;进行匹配，执行&lt;code&gt;TransactionInterceptor&lt;/code&gt;的方法&lt;/p&gt;
&lt;h4 id=&quot;transactioninterceptor&quot;&gt;TransactionInterceptor&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    @Nullable
    public Object invoke(MethodInvocation invocation) throws Throwable {
       // Work out the target class: may be {@code null}.
       // The TransactionAttributeSource should be passed the target class
       // as well as the method, which may be from an interface.
       Class&amp;lt;?&amp;gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
    
       // Adapt to TransactionAspectSupport's invokeWithinTransaction...
       return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;transactionaspectsupport&quot;&gt;TransactionAspectSupport&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Nullable
    protected Object invokeWithinTransaction(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass,
          final InvocationCallback invocation) throws Throwable {
    
       // If the transaction attribute is null, the method is non-transactional.
       TransactionAttributeSource tas = getTransactionAttributeSource();
       final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
       final PlatformTransactionManager tm = determineTransactionManager(txAttr);
       final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
    
       if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
          // Standard transaction demarcation with getTransaction and commit/rollback calls.
          TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
    
          Object retVal;
          try {
             // This is an around advice: Invoke the next interceptor in the chain.
             // This will normally result in a target object being invoked.
             retVal = invocation.proceedWithInvocation();
          }
          catch (Throwable ex) {
             // target invocation exception
             completeTransactionAfterThrowing(txInfo, ex);
             throw ex;
          }
          finally {
             cleanupTransactionInfo(txInfo);
          }
          commitTransactionAfterReturning(txInfo);
          return retVal;
       }
    
       else {
          final ThrowableHolder throwableHolder = new ThrowableHolder();
    
          // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
          try {
             Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&amp;gt; {
                TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
                try {
                   return invocation.proceedWithInvocation();
                }
                catch (Throwable ex) {
                   if (txAttr.rollbackOn(ex)) {
                      // A RuntimeException: will lead to a rollback.
                      if (ex instanceof RuntimeException) {
                         throw (RuntimeException) ex;
                      }
                      else {
                         throw new ThrowableHolderException(ex);
                      }
                   }
                   else {
                      // A normal return value: will lead to a commit.
                      throwableHolder.throwable = ex;
                      return null;
                   }
                }
                finally {
                   cleanupTransactionInfo(txInfo);
                }
             });
    
             // Check result state: It might indicate a Throwable to rethrow.
             if (throwableHolder.throwable != null) {
                throw throwableHolder.throwable;
             }
             return result;
          }
          catch (ThrowableHolderException ex) {
             throw ex.getCause();
          }
          catch (TransactionSystemException ex2) {
             if (throwableHolder.throwable != null) {
                logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);
                ex2.initApplicationException(throwableHolder.throwable);
             }
             throw ex2;
          }
          catch (Throwable ex2) {
             if (throwableHolder.throwable != null) {
                logger.error(&quot;Application exception overridden by commit exception&quot;, throwableHolder.throwable);
             }
             throw ex2;
          }
       }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次在分析这个方法，但是从事务的异常，不生效等角度来分析问题。注解事务和编程式都一样的核心思想，下面我们来分析注解事务逻辑&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
                // Standard transaction demarcation with getTransaction and commit/rollback calls.
                TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
    
                Object retVal;
                try {
                    // This is an around advice: Invoke the next interceptor in the chain.
                    // This will normally result in a target object being invoked.
                    retVal = invocation.proceedWithInvocation();
                }
                catch (Throwable ex) {
                    // target invocation exception
                    completeTransactionAfterThrowing(txInfo, ex);
                    throw ex;
                }
                finally {
            // 把上一层事务的TxInfo重新绑到ThreadLocal中
                    cleanupTransactionInfo(txInfo);
                }
                commitTransactionAfterReturning(txInfo);
                return retVal;
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请记住这几个核心的方法逻辑顺序和异常捕获哦！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
            if (txInfo != null &amp;amp;&amp;amp; txInfo.getTransactionStatus() != null) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +
                            &quot;] after exception: &quot; + ex);
                }
          //事务回滚的异常支持
                if (txInfo.transactionAttribute != null &amp;amp;&amp;amp; txInfo.transactionAttribute.rollbackOn(ex)) {
                    try {
                        txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
                    }
                    catch (TransactionSystemException ex2) {
                        logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);
                        ex2.initApplicationException(ex);
                        throw ex2;
                    }
                    catch (RuntimeException | Error ex2) {
                        logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);
                        throw ex2;
                    }
                }
                else {
                    // We don't roll back on this exception.
                    // Will still roll back if TransactionStatus.isRollbackOnly() is true.
                    try {
                        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
                    }
                    catch (TransactionSystemException ex2) {
                        logger.error(&quot;Application exception overridden by commit exception&quot;, ex);
                        ex2.initApplicationException(ex);
                        throw ex2;
                    }
                    catch (RuntimeException | Error ex2) {
                        logger.error(&quot;Application exception overridden by commit exception&quot;, ex);
                        throw ex2;
                    }
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;事务回滚的异常支持&quot;&gt;事务回滚的异常支持&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public boolean rollbackOn(Throwable ex) {
       return (ex instanceof RuntimeException || ex instanceof Error);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意点来了，仅支持运行时异常和错误机制，否则不予回滚。并进行直接条件。&lt;/p&gt;
&lt;h4 id=&quot;abstractplatformtransactionmanager&quot;&gt;AbstractPlatformTransactionManager&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void processRollback(DefaultTransactionStatus status, boolean unexpected) {
       try {
         //默认false
          boolean unexpectedRollback = unexpected;
          try {
            //回调TransactionSynchronization对象的beforeCompletion方法。
             triggerBeforeCompletion(status);
             if (status.hasSavepoint()) {
                if (status.isDebug()) {
                   logger.debug(&quot;Rolling back transaction to savepoint&quot;);
                }
                status.rollbackToHeldSavepoint();
             }
            // 在最外层事务边界进行回滚
             else if (status.isNewTransaction()) {
                if (status.isDebug()) {
                   logger.debug(&quot;Initiating transaction rollback&quot;);
                }
               // 由具体TxMgr子类实现回滚。
                doRollback(status);
             }
             else {
                // Participating in larger transaction
                if (status.hasTransaction()) {
                  /*
                     * 内层事务被标记为rollBackOnly或者globalRollbackOnParticipationFailure开关开启时,给当前事务标记需要回滚。
                     * 
                     * 如果内层事务显式打上了rollBackOnly的标记,最终全事务一定是回滚掉的。
                     * 
                     * 但如果没有被打上rollBackOnly标记,则globalRollbackOnParticipationFailure开关就很重要了。
                     * globalRollbackOnParticipationFailure开关默认是开启的，也就是说内层事务挂了,最终的结果只能是全事务回滚。
                     * 但如果globalRollbackOnParticipationFailure开关被关闭的话,内层事务挂了,外层事务业务方法中可以根据情况控制是否回滚。
                     */
     
                   if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
                      if (status.isDebug()) {
                         logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);
                      }
                     // 由具体TxMgr子类实现回滚。
                      doSetRollbackOnly(status);
                   }
                   else {
                      if (status.isDebug()) {
                         logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);
                      }
                   }
                }
                else {
                   logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);
                }
                // Unexpected rollback only matters here if we're asked to fail early
                if (!isFailEarlyOnGlobalRollbackOnly()) {
                   unexpectedRollback = false;
                }
             }
          }
          catch (RuntimeException | Error ex) {
             triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
             throw ex;
          }
    // 回调TransactionSynchronization对象的afterCompletion方法。
          triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
    
          // Raise UnexpectedRollbackException if we had a global rollback-only marker
          if (unexpectedRollback) {
             throw new UnexpectedRollbackException(
                   &quot;Transaction rolled back because it has been marked as rollback-only&quot;);
          }
       }
       finally {
          cleanupAfterCompletion(status);
       }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例分析&quot;&gt;案例分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281920/201909/1281920-20190903221301652-929850102.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281920/201909/1281920-20190903221301919-1330849940.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有经验的同学肯定知道整个事务最终被回滚掉了, &lt;code&gt;TransactionB#test&lt;/code&gt;并没有执行&lt;code&gt;System.out.println(&quot;TransactionB#test after&quot;);&lt;/code&gt;&lt;br/&gt;其实对于Spring事务来说，这样的结果是正确的，但对于开发者来说，这个结果确实看似有些“不能理解”。&lt;/p&gt;
&lt;h4 id=&quot;我们不妨来分析一下原因&quot;&gt;我们不妨来分析一下原因：&lt;/h4&gt;
&lt;p&gt;首先&lt;code&gt;TransactionB#test&lt;/code&gt;本身是直接抛出&lt;code&gt;RuntimeException&lt;/code&gt;的，那么退栈到事务切面后，事务切面会发现需要回滚但因为&lt;code&gt;TransactionB#test&lt;/code&gt;还不是事务的最外层边界，所以在&lt;code&gt;AbstractPlatformTransactionManager#processRollback&lt;/code&gt;方法仅仅会调用&lt;code&gt;doSetRollbackOnly(status)&lt;/code&gt;;，子类&lt;code&gt;DataSourceTransactionManager&lt;/code&gt;会拿出&lt;code&gt;DefaultTransactionStatus&lt;/code&gt;中的&lt;code&gt;transaction&lt;/code&gt;对象打上回滚标记，具体来说就是&lt;code&gt;transaction&lt;/code&gt;对象(对于&lt;code&gt;DataSourceTransactionManager&lt;/code&gt;来说类型是&lt;code&gt;DataSourceTransactionObject&lt;/code&gt;)会取出&lt;code&gt;ConnectionHolder&lt;/code&gt;，调用&lt;code&gt;setRollbackOnly&lt;/code&gt;。我们知道这样就相当于标记是一个全局的标记了，因为只要是隶属于同一个物理事务的Spring事务都能够读到同一个&lt;code&gt;ConnectionHolder&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    protected void doSetRollbackOnly(DefaultTransactionStatus status) {
            DataSourceTransactionManager.DataSourceTransactionObject txObject = (DataSourceTransactionManager.DataSourceTransactionObject)status.getTransaction();
            if (status.isDebug()) {
                this.logger.debug(&quot;Setting JDBC transaction [&quot; + txObject.getConnectionHolder().getConnection() + &quot;] rollback-only&quot;);
            }
      //关键点
            txObject.setRollbackOnly();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到上层事务切面，在&lt;code&gt;AbstractPlatformTransactionManager#commit&lt;/code&gt;方法读到&lt;code&gt;if(!shouldCommitOnGlobalRollbackOnly() &amp;amp;&amp;amp; defStatus.isGlobalRollbackOnly())&lt;/code&gt;条件成立，接下来调用&lt;code&gt;processRollback&lt;/code&gt;，由于在事务最外层边界会物理回滚掉，并且也正是到了事务最外层边界,Spring抛出&lt;code&gt;UnexpectedRollbackException&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;如何解决&quot;&gt;如何解决？&lt;/h4&gt;
&lt;p&gt;那么问题怎么解决呢，这个问题有好几种解决办法，但是得根据具体情况决定。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;根据实际代码与业务情况处理，如果内嵌事务注解取消，Spring也不会抛出&lt;code&gt;UnexpectedRollbackException&lt;/code&gt;。但是方法实际上并没有完整执行，所以这样的解决思路很容易导致出现不完整的脏数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;手动控制是否回滚。如果不能接受内嵌事务挂掉的话，可以在catch块里加上&lt;code&gt;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();&lt;/code&gt;用于显式控制回滚。这样Spring就明白你自己要求回滚事务，而不是unexpected了。Spring也不会抛出&lt;code&gt;UnexpectedRollbackException&lt;/code&gt;了。那么如果在上层事务中捕获到异常，真的就是不想回滚，即便上层事务发生了异常，也想要最终提交整个事务呢？如果有这样的需求的话，可以给事务管理器配置一个参数&lt;code&gt;setGlobalRollbackOnParticipationFailure(false);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;如果isGlobalRollbackOnParticipationFailure为false,则会让主事务决定回滚，如果当遇到exception加入事务失败时，调用者能继续在事务内决定是回滚还是继续。然而，要注意是那样做仅仅适用于在数据访问失败的情况下且只要所有操作事务能提交，这个方法也能解决，但显然影响到全局的事务属性，所以极力不推荐使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public final void commit(TransactionStatus status) throws TransactionException {
       if (status.isCompleted()) {
          throw new IllegalTransactionStateException(
                &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
       }
    
       DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
       if (defStatus.isLocalRollbackOnly()) {
          if (defStatus.isDebug()) {
             logger.debug(&quot;Transactional code has requested rollback&quot;);
          }
          processRollback(defStatus, false);
          return;
       }
    
       if (!shouldCommitOnGlobalRollbackOnly() &amp;amp;&amp;amp; defStatus.isGlobalRollbackOnly()) {
          if (defStatus.isDebug()) {
             logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);
          }
          processRollback(defStatus, true);
          return;
       }
    
       processCommit(defStatus);
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 03 Sep 2019 14:13:00 +0000</pubDate>
<dc:creator>TheGir1</dc:creator>
<og:description>Springboot源码分析之项目结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinzj/p/11456067.html</dc:identifier>
</item>
<item>
<title>vue中使用web worker - Gerryli</title>
<link>http://www.cnblogs.com/gerry2019/p/11456035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gerry2019/p/11456035.html</guid>
<description>&lt;p&gt;　　众所周知，JavaScript是单线程的，一些复杂比较耗时的操作，会阻塞页面的渲染交互，引起页面卡顿，影响用户体验。web worker是html5的新特性之一，主要就是用来解决此类问题，为页面&lt;strong&gt;额外开启一个线程&lt;/strong&gt;，用来处理一些比较耗时操作，不影响主线程的进行。&lt;/p&gt;
&lt;p&gt;　　在实际vue项目的开发使用过程中，还是遇到不少坑，特别记录一下。&lt;/p&gt;
&lt;p&gt;　　首先，基本的w&lt;strong&gt;eb worker使用直接调用Worker构造函数&lt;/strong&gt;，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; url: js文件路径&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; options: 配置信息&lt;/span&gt;
const worker = &lt;span&gt;new&lt;/span&gt; Worker(url, options)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其次，不同模块间的通信主要通过&lt;strong&gt;postMessage&lt;/strong&gt;进行消息推送，通过&lt;strong&gt;onmessage&lt;/strong&gt;进行消息接收，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.js&lt;/span&gt;
let worker = &lt;span&gt;new&lt;/span&gt; Worker('a.js'&lt;span&gt;)
worker.postMessage({
      method: &lt;/span&gt;'transferLang'&lt;span&gt;
})
&lt;/span&gt;worker.onmessage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
      init(e.data.params)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.js&lt;/span&gt;
self.onmessage = ev =&amp;gt;&lt;span&gt; {
  let funName &lt;/span&gt;=&lt;span&gt; ev.data.method
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (self[funName]) {
    self[funName](ev.data.params)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    console.warn(`方法${funName}未定义`)
  }
}

self.transferLang &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  let arr &lt;/span&gt;=&lt;span&gt; []
  self.postMessage({
    params: arr
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在vue项目中，如果直接使用，首先遇到的问题是&lt;strong&gt;worker文件路径与打包解析问题&lt;/strong&gt;，这种首先需要安装worker-loader,解析web worker，执行以下命令即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install worker-loader -D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　vue.config.js要添加以下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
configureWebpack: config =&amp;gt;&lt;span&gt; {
    config.module.rules.push({
      test: &lt;/span&gt;/\.worker.js$/&lt;span&gt;,
      use: {
        loader: &lt;/span&gt;'worker-loader'&lt;span&gt;,
        options: { inline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, name: 'workerName.[hash].js'&lt;span&gt; }
      }
    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在使用的时候，就不能调用原生的Worker构造函数了，需要手动import worker文件，然后直接实例化这个文件即可，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.js&lt;/span&gt;
import Worker from './b.js'&lt;span&gt;

let worker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，&lt;strong&gt;会发现控制台会报错，“window is undefined”&lt;/strong&gt;，这个是因为worker线程中不存在window对象，因此不能直接使用，要用this代替，要在vue.config.js中添加以下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chainWebpack: config =&amp;gt;&lt;span&gt; {
    config.output.globalObject(&lt;/span&gt;'this'&lt;span&gt;)
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着在&lt;strong&gt;打包的时候，也会报错&lt;/strong&gt;，需要加入以下配置，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
parallel: &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完整的webpack配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  configureWebpack: config &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    config.module.rules.push({
      test: &lt;/span&gt;/\.worker.js$/&lt;span&gt;,
      use: {
        loader: &lt;/span&gt;'worker-loader'&lt;span&gt;,
        options: { inline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, name: 'workerName.[hash].js'&lt;span&gt; }
      }
    })
  },
  parallel: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  chainWebpack: config &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    config.output.globalObject(&lt;/span&gt;'this'&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　还存在另外一个问题，就是每次修改worker文件时，&lt;strong&gt;debugger调试总是保留之前的记录，感觉编译的时候存在缓存&lt;/strong&gt;，目前解决办法是修改worker.js文件名称，比较繁琐，如果哪位大神有好的建议，不吝赐教，谢谢！&lt;/p&gt;
&lt;p&gt;　　参考链接:&lt;/p&gt;
&lt;p&gt;　　　　Worker: &lt;a href=&quot;https://www.cnblogs.com/gerry2019/p/worker&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/Worker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　Function support: &lt;a href=&quot;https://www.cnblogs.com/gerry2019/p/function%20support&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers#Comparison_of_the_properties_and_methods_of_the_different_type_of_workers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　Worker loader: &lt;a href=&quot;https://www.cnblogs.com/gerry2019/p/worker%20loader&quot; target=&quot;_blank&quot;&gt;https://www.webpackjs.com/loaders/worker-loader/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Sep 2019 14:07:00 +0000</pubDate>
<dc:creator>Gerryli</dc:creator>
<og:description>众所周知，JavaScript是单线程的，一些复杂比较耗时的操作，会阻塞页面的渲染交互，引起页面卡顿，影响用户体验。web worker是html5的新特性之一，主要就是用来解决此类问题，为页面额外开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gerry2019/p/11456035.html</dc:identifier>
</item>
</channel>
</rss>